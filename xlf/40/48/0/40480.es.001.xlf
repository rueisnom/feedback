<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/40480">
    <body>
      <group id="40480">
        <trans-unit id="679ac82a1b80b565bd19565ec122a565572f35a9" translate="yes" xml:space="preserve">
          <source>&quot;String&quot; Objects appear to be a good &lt;strong&gt;counter-example&lt;/strong&gt; to the urban legend saying that &quot;Objects are passed by reference&quot;:</source>
          <target state="translated">Los objetos de &quot;cadena&quot; parecen ser un buen &lt;strong&gt;contraejemplo de&lt;/strong&gt; la leyenda urbana que dice que &quot;los objetos se pasan por referencia&quot;:</target>
        </trans-unit>
        <trans-unit id="d88ecdddf8b9e6ef14e68530529dc23d4ff6b148" translate="yes" xml:space="preserve">
          <source>&quot;by value&quot; is the only way in java to pass a parameter to a method</source>
          <target state="translated">&quot;por valor&quot; es la única manera en Java de pasar un parámetro a un método</target>
        </trans-unit>
        <trans-unit id="ac7bea48c9f3e3c013ee3b9ca43c1cd4255ba9c6" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Account account1&amp;rdquo; is the type and name of the reference variable, &amp;ldquo;=&amp;rdquo; is the assignment operator, &amp;ldquo;new&amp;rdquo; asks for the required amount of space from the system. The constructor to the right of keyword new which creates the object is called implicitly by the keyword new. Address of the created object(result of right variable, which is an expression) is assigned to the left variable (which is a reference variable with a name and a type specified) using the assign operator. &amp;ldquo;new Account()&amp;rdquo; is called &amp;ldquo;class instance creation expression&amp;rdquo;.</source>
          <target state="translated">&quot;Cuenta cuenta1&quot; es el tipo y el nombre de la variable de referencia, &quot;=&quot; es el operador de asignaci&amp;oacute;n, &quot;nuevo&quot; solicita la cantidad de espacio requerida del sistema. El constructor a la derecha de la palabra clave new que crea el objeto se llama impl&amp;iacute;citamente por la palabra clave new. La direcci&amp;oacute;n del objeto creado (resultado de la variable derecha, que es una expresi&amp;oacute;n) se asigna a la variable izquierda (que es una variable de referencia con un nombre y un tipo especificado) utilizando el operador de asignaci&amp;oacute;n. &quot;Nueva cuenta ()&quot; se llama &quot;expresi&amp;oacute;n de creaci&amp;oacute;n de instancia de clase&quot;.</target>
        </trans-unit>
        <trans-unit id="94aa2ba0bb8a675b61aef491a803f4a9834f2892" translate="yes" xml:space="preserve">
          <source>(I say essentially because Java pointers aren't direct addresses, but it's easiest to think of them that way)</source>
          <target state="translated">(Digo esencialmente porque los punteros de Java no son direcciones directas,pero es más fácil pensar en ellos de esa manera)</target>
        </trans-unit>
        <trans-unit id="4deb5f3c7a0f51652194597de3c850eb67417a51" translate="yes" xml:space="preserve">
          <source>/**
  This 'Pass By Value has a feeling of 'Pass By Reference'</source>
          <target state="translated">/**Este &quot;valor de paso&quot; tiene un sentimiento de &quot;referencia de paso</target>
        </trans-unit>
        <trans-unit id="9aadafd84fb3481ea6953e7000de351b550c282f" translate="yes" xml:space="preserve">
          <source>/**
 * 
 * Pass By Value
 *
 */</source>
          <target state="translated">/****Pasar por el valor**</target>
        </trans-unit>
        <trans-unit id="2d699180ecfe5b34c3e0bc840eb47751e4372814" translate="yes" xml:space="preserve">
          <source>223 gets PUSHd to the stack.</source>
          <target state="translated">223 se empuja a la pila.</target>
        </trans-unit>
        <trans-unit id="6446e71ace78a7a3a0a5710cd60edb392c5f7798" translate="yes" xml:space="preserve">
          <source>223 gets copied to one of the CPU registers.</source>
          <target state="translated">223 se copia a uno de los registros de la CPU.</target>
        </trans-unit>
        <trans-unit id="b89be71dff7edaa9c74d2426c943f820435958da" translate="yes" xml:space="preserve">
          <source>47 PUSHd to the stack.</source>
          <target state="translated">47 PUSHd a la pila.</target>
        </trans-unit>
        <trans-unit id="29eebea6f72ba92d2ef802d866c3af082d2c6911" translate="yes" xml:space="preserve">
          <source>47 gets copied to one of the CPU registers</source>
          <target state="translated">47 se copia a uno de los registros de la CPU</target>
        </trans-unit>
        <trans-unit id="35f6cb5f76dc39cccdd22e4f4ed75145651bad22" translate="yes" xml:space="preserve">
          <source>5 gets PUSHd to the stack.</source>
          <target state="translated">5 se empuja a la pila.</target>
        </trans-unit>
        <trans-unit id="bd53eeaa13917b9c1cd0ffee5c08d5548f0f975f" translate="yes" xml:space="preserve">
          <source>5 gets copied to one of the CPU registers (ie. EAX).</source>
          <target state="translated">5 se copia a uno de los registros de la CPU (es decir,EAX).</target>
        </trans-unit>
        <trans-unit id="669fc2a12114e17f53bf6a6eea0a996b3e52e4db" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028&quot;&gt;Java is also mentioned&lt;/a&gt;. Here is the short summary:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028&quot;&gt;Tambi&amp;eacute;n se menciona Java&lt;/a&gt; . Aqu&amp;iacute; est&amp;aacute; el breve resumen:</target>
        </trans-unit>
        <trans-unit id="44522a95088af6ee8afeac1924a88cbdb726d3ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a = b&lt;/code&gt; makes a new assignment to the reference &lt;code&gt;a&lt;/code&gt;, &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;f&lt;/code&gt;, of the object whose its attribute is &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a = b&lt;/code&gt; realiza una nueva asignaci&amp;oacute;n a la referencia &lt;code&gt;a&lt;/code&gt; , &lt;strong&gt;no&lt;/strong&gt; &lt;code&gt;f&lt;/code&gt; , del objeto cuyo atributo es &lt;code&gt;&quot;b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc8f4e638edf822f721d61b825c182734c0569b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c.setAttribute(&quot;c&quot;);&lt;/code&gt; will change the attribute of the object that reference &lt;code&gt;c&lt;/code&gt; points to it, and it's same object that reference &lt;code&gt;f&lt;/code&gt; points to it.</source>
          <target state="translated">&lt;code&gt;c.setAttribute(&quot;c&quot;);&lt;/code&gt; cambiar&amp;aacute; el atributo del objeto al que hace referencia &lt;code&gt;c&lt;/code&gt; , y es el mismo objeto al que hace referencia &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14cac2530311a23fb072c9ef26feba713000c665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;someDog&lt;/code&gt; is followed to the &lt;code&gt;Dog&lt;/code&gt; it points to (the &lt;code&gt;Dog&lt;/code&gt; object at address 42)</source>
          <target state="translated">&lt;code&gt;someDog&lt;/code&gt; se sigue hasta el &lt;code&gt;Dog&lt;/code&gt; que apunta (el objeto &lt;code&gt;Dog&lt;/code&gt; en la direcci&amp;oacute;n 42)</target>
        </trans-unit>
        <trans-unit id="1e1295aabf56bdb60aa6cdd4c585a17ef60d34fd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Did &lt;code&gt;myDog&lt;/code&gt; change?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iquest; &lt;code&gt;myDog&lt;/code&gt; ?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f5e57136a5902e29d33131a3a28391b65ae5a66" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Master&lt;/em&gt;: Grasshopper, No.</source>
          <target state="translated">&lt;em&gt;Maestro&lt;/em&gt; : Saltamontes, No.</target>
        </trans-unit>
        <trans-unit id="b89440cba42f99210f8524ad856b1d7e2968203e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Student&lt;/em&gt;: Master, does this mean that Java is pass-by-reference?</source>
          <target state="translated">&lt;em&gt;Estudiante&lt;/em&gt; : Maestro, &amp;iquest;significa esto que Java es paso por referencia?</target>
        </trans-unit>
        <trans-unit id="e9026cb4dbf68f5a89f59e77b991a00db2fad347" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;This value is actually COPIED and given to the method&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Este valor es COPIADO y dado al m&amp;eacute;todo&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="eac8606431b898a08bfa815724043bf24baea91c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A variable holds the bits that tell the JVM how to get to the referenced Object in memory (Heap).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Una variable contiene los bits que le dicen a la JVM c&amp;oacute;mo llegar al Objeto referenciado en la memoria (Heap).&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee963e4f98e2321319006e78120a5c33385ffa8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All parameters to methods are passed &quot;by value&quot;&lt;/strong&gt;. In other words,
  values of parameter variables in a method are copies of the invoker
  specified as arguments.</source>
          <target state="translated">&lt;strong&gt;Todos los par&amp;aacute;metros a los m&amp;eacute;todos se pasan &quot;por valor&quot;&lt;/strong&gt; . En otras palabras, los valores de las variables de par&amp;aacute;metro en un m&amp;eacute;todo son copias del invocador especificado como argumentos.</target>
        </trans-unit>
        <trans-unit id="d0c0ba2ae2424364bf0a5b15f58afb340e72d7df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ allows Pass-by-reference&lt;/strong&gt; by declaring a reference parameter using the &quot;&amp;amp;&quot; character (which happens to be the same character used to indicate &quot;the address of a variable&quot; in both C and C++). For example, if we pass in a pointer by reference, the parameter and the argument are not just pointing to the same object. Rather, they are the same variable. If one gets set to a different address or to null, so does the other.</source>
          <target state="translated">&lt;strong&gt;C ++ permite el paso por referencia&lt;/strong&gt; declarando un par&amp;aacute;metro de referencia utilizando el car&amp;aacute;cter &quot;&amp;amp;&quot; (que resulta ser el mismo car&amp;aacute;cter utilizado para indicar &quot;la direcci&amp;oacute;n de una variable&quot; en C y C ++). Por ejemplo, si pasamos un puntero por referencia, el par&amp;aacute;metro y el argumento no solo apuntan al mismo objeto. M&amp;aacute;s bien, son la misma variable. Si uno se establece en una direcci&amp;oacute;n diferente o nula, tambi&amp;eacute;n lo hace el otro.</target>
        </trans-unit>
        <trans-unit id="250414fd453c52d7a94d41cac5720b0bf6770e9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDITAR 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e432c6162816f0458b741aeccb3b66bf810d917a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDITAR 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3b32f3bc0cf8e132bab93bdb849247ffeab0402" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDITAR 4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eee5a199ee48a34a0cc9134ad8533202fc7fcb52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ejemplo 1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba5182d053766559c8a796587cc6e079b0edece9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ejemplo 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87994c9ddef100c712273600d84d2680b1176fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ejemplo 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f029fd8a8bc2187006a97a36768f3a9a0f4c6825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ejemplo 4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46619b51e67a75935bc9ceedee2a6019b4258008" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Java creates and stores objects:&lt;/strong&gt; When we create an object we store the object&amp;rsquo;s address in a reference variable. Let's analyze the following statement.</source>
          <target state="translated">&lt;strong&gt;C&amp;oacute;mo Java crea y almacena objetos:&lt;/strong&gt; cuando creamos un objeto, almacenamos la direcci&amp;oacute;n del objeto en una variable de referencia. Analicemos la siguiente declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8522a877bd114b6f39cde66fbd073f0156a79129" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Java only references are passed and are passed by value:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;En Java solo se pasan referencias y se pasan por valor:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fb07fd2faf3d430de82df4b1196a7157526121c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java doesn't pass method arguments by reference; it passes them by value.&lt;/strong&gt; I will use example from &lt;a href=&quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html&quot;&gt;this site&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;Java no pasa argumentos de m&amp;eacute;todo por referencia;&lt;/strong&gt; &lt;strong&gt;los pasa por valor.&lt;/strong&gt; Usar&amp;eacute; ejemplos de &lt;a href=&quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html&quot;&gt;este sitio&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f8710d2de84f7d70df19d71411b10789671cf77e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java is Pass-by-value&lt;/strong&gt;, but allows us to emulate pass be reference by passing a Java reference (i.e. a pointer) by value. Meaning it passes a copy of the Java reference. &lt;strong&gt;&lt;em&gt;EDIT&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;: since someone made a comment about this, let me explain. Before C, several (but not all) earlier languages like FORTRAN and COBOL supported PBR, but C did not. In order to change the values of variables inside functions, C programmers emulated PBR by passing pointers to variables into functions. Languages inspired by C, such as Java, borrowed this idea and continue to emulate PBR as C did.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Java es Pass-by-value&lt;/strong&gt; , pero nos permite emular pass be reference haciendo pasar una referencia Java (es decir, un puntero) por valor. Lo que significa que pasa una copia de la referencia de Java. &lt;strong&gt;&lt;em&gt;EDITAR&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;: dado que alguien hizo un comentario sobre esto, d&amp;eacute;jame explicarte.&lt;/em&gt; &lt;em&gt;Antes de C, varios (pero no todos) lenguajes anteriores como FORTRAN y COBOL soportaban PBR, pero C no.&lt;/em&gt; &lt;em&gt;Para cambiar los valores de las variables dentro de las funciones, los programadores de C emularon PBR pasando punteros a las variables en funciones.&lt;/em&gt; &lt;em&gt;Los lenguajes inspirados en C, como Java, tomaron prestada esta idea y contin&amp;uacute;an emulando PBR como lo hizo C.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="539967da6afd5b4c7cf196939fd0d2173148d5e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java is always pass by value, not pass by reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java siempre pasa por valor, no pasa por referencia&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daf65d846a847f4224f37e5964ce49e033a6516e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that the anotherReferenceToTheSamePersonObject arrows is directed towards the Object and not towards the variable person!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tenga en cuenta que las flechas anotherReferenceToTheSamePersonObject se dirigen hacia el objeto y no hacia la persona variable.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82bf5f83e99ffaf8561e8e28fe3ef14c8cc29ecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;On this line 'pass-by-value' goes into the play...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;En esta l&amp;iacute;nea, el 'paso por valor' entra en juego ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f82acf071fee6ab2a7abd0313bbf60fe384f861" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference (also called pass by address) means that a copy of the address of the actual parameter is stored&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Pasar por referencia (tambi&amp;eacute;n llamado pasar por direcci&amp;oacute;n) significa que se almacena una copia de la direcci&amp;oacute;n del par&amp;aacute;metro real&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="24f93d53f1599b4ac1080cabfb887cfff18610ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference&lt;/strong&gt;--There is no copy of the reference. Single reference is shared by both the caller and the function being called. Any changes to the reference or the Object's data are reflected in the caller's scope.</source>
          <target state="translated">&lt;strong&gt;Pasar por referencia&lt;/strong&gt; : no hay copia de la referencia. La persona que llama y la funci&amp;oacute;n que se est&amp;aacute; llamando comparten la referencia &amp;uacute;nica. Cualquier cambio en la referencia o los datos del Objeto se reflejan en el alcance de la persona que llama.</target>
        </trans-unit>
        <trans-unit id="a7a81b026c4fc8d49d09f4de01c114901f7c0d8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by value means that you are making a copy in memory of the actual parameter's value that is passed in. This is a copy of the contents of the actual parameter&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Pasar por valor significa que est&amp;aacute; haciendo una copia en memoria del valor del par&amp;aacute;metro real que se pasa. Esta es una copia del contenido del par&amp;aacute;metro real&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5501243b5acfe1576d19283bdb0a2ab76d3504bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing a reference by value&lt;/strong&gt;--Changes to the reference are not reflected in the caller's scope, but the changes to the object are. This is because the reference is copied, but the both the original and the copy refer to the same object.</source>
          <target state="translated">&lt;strong&gt;Pasar una referencia por valor: los&lt;/strong&gt; cambios a la referencia no se reflejan en el alcance de la persona que llama, pero los cambios en el objeto s&amp;iacute;. Esto se debe a que la referencia se copia, pero tanto el original como la copia se refieren al mismo objeto.</target>
        </trans-unit>
        <trans-unit id="d128a624743e2f0a142ea51104871088ef3baab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Result&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f28b5e99d681d23b2424be728e4d14ac53de034" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The fact that you can follow the reference to invoke a method or access a field of the referenced object is completely irrelevant to the conversation.&lt;/strong&gt; The definition of pass-by-reference was</source>
          <target state="translated">&lt;strong&gt;El hecho de que pueda seguir la referencia para invocar un m&amp;eacute;todo o acceder a un campo del objeto referenciado es completamente irrelevante para la conversaci&amp;oacute;n.&lt;/strong&gt; La definici&amp;oacute;n de paso por referencia fue</target>
        </trans-unit>
        <trans-unit id="155adcfa1e1a2d90f9b1663c701b8baa445db69b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The reference values (often just references) are pointers to these objects&lt;/strong&gt;, and a special null reference, which refers to no object.</source>
          <target state="translated">&lt;strong&gt;Los valores de referencia (a menudo solo referencias) son punteros a estos objetos&lt;/strong&gt; , y una referencia nula especial, que no se refiere a ning&amp;uacute;n objeto.</target>
        </trans-unit>
        <trans-unit id="c6c7f19df18b6b50e6865d7508209d9363946c4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This will give you some insights of how Java really works to the point that in your next discussion about Java passing by reference or passing by value you'll just smile :-)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Esto le dar&amp;aacute; una idea de c&amp;oacute;mo funciona realmente Java hasta el punto de que en su pr&amp;oacute;xima discusi&amp;oacute;n sobre Java pasando por referencia o pasando por valor, simplemente sonreir&amp;aacute; :-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a57a48f1825e5c9fb8aafac2b685e4eb2761f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is the value of the argument?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Cu&amp;aacute;l es el valor del argumento?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f32da0f05cfb43b8594e1350dffac69d7279c2e" translate="yes" xml:space="preserve">
          <source>A String Object, holds characters by an array declared &lt;strong&gt;final&lt;/strong&gt; that can't be modified.
Only the address of the Object might be replaced by another using &quot;new&quot;. 
Using &quot;new&quot; to update the variable, will not let the Object be accessed from outside, since the variable was initially passed by value and copied.</source>
          <target state="translated">Un objeto de cadena contiene caracteres mediante una matriz declarada &lt;strong&gt;final&lt;/strong&gt; que no puede modificarse. Solo la direcci&amp;oacute;n del Objeto puede ser reemplazada por otra usando &quot;nuevo&quot;. El uso de &quot;nuevo&quot; para actualizar la variable no permitir&amp;aacute; que se acceda al Objeto desde afuera, ya que la variable se pas&amp;oacute; inicialmente por valor y se copi&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="5cadb13ab1a3063435130babe3e0bd30a1122a5f" translate="yes" xml:space="preserve">
          <source>A few points:</source>
          <target state="translated">Unos pocos puntos:</target>
        </trans-unit>
        <trans-unit id="a6487d11fc0e1086219982c44902ad61a1998227" translate="yes" xml:space="preserve">
          <source>A method local variable -&lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt;- is created and then comes the magic in line #6:</source>
          <target state="translated">Se &lt;em&gt;crea&lt;/em&gt; una variable local del m&amp;eacute;todo - &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; - y luego viene la magia en la l&amp;iacute;nea # 6:</target>
        </trans-unit>
        <trans-unit id="939671d12f121c636331468aedcb607655b0467d" translate="yes" xml:space="preserve">
          <source>A new Person Object is created in line #2, stored in memory, and the variable &lt;em&gt;person&lt;/em&gt; is given the reference to the Person object. That is, its address. Let's say 3bad086a.</source>
          <target state="translated">Se crea un nuevo Objeto Persona en la l&amp;iacute;nea # 2, almacenado en la memoria, y la &lt;em&gt;persona&lt;/em&gt; variable recibe la referencia al objeto Persona. Es decir, su direcci&amp;oacute;n. Digamos 3bad086a.</target>
        </trans-unit>
        <trans-unit id="6cb5cc922e3e7afc89e697c3a55b40eccd85c7e8" translate="yes" xml:space="preserve">
          <source>A picture is worth a thousand words:</source>
          <target state="translated">Una imagen vale más que mil palabras:</target>
        </trans-unit>
        <trans-unit id="7890ee11943cdb236a4c3b5ce7b9f732f716679f" translate="yes" xml:space="preserve">
          <source>A reference is always a value when represented, no matter what language you use.</source>
          <target state="translated">Una referencia es siempre un valor cuando se representa,sin importar el idioma que se use.</target>
        </trans-unit>
        <trans-unit id="9f8832ae6457f58e3904c76f8d5c2aa49f842301" translate="yes" xml:space="preserve">
          <source>After: a = 2, b = 3</source>
          <target state="translated">Después:a=2,b=3</target>
        </trans-unit>
        <trans-unit id="ec423d5a41945c4f52f7be0ea48ac07e83fd86ae" translate="yes" xml:space="preserve">
          <source>Although an object&amp;rsquo;s reference is passed by value, a method can still interact with the referenced object by calling its public methods using the copy of the object&amp;rsquo;s reference. Since the reference stored in the parameter is a copy of the reference that was passed as an argument, the parameter in the called method and the argument in the calling method refer to the same object in memory.</source>
          <target state="translated">Aunque la referencia de un objeto se pasa por valor, un m&amp;eacute;todo a&amp;uacute;n puede interactuar con el objeto referenciado llamando a sus m&amp;eacute;todos p&amp;uacute;blicos utilizando la copia de la referencia del objeto. Dado que la referencia almacenada en el par&amp;aacute;metro es una copia de la referencia que se pas&amp;oacute; como argumento, el par&amp;aacute;metro en el m&amp;eacute;todo llamado y el argumento en el m&amp;eacute;todo de llamada se refieren al mismo objeto en la memoria.</target>
        </trans-unit>
        <trans-unit id="b65974e5bb87a60e0a3ebacd86b70b176a71aea4" translate="yes" xml:space="preserve">
          <source>An array is an object, so it goes on the heap as well. And what about the objects in the array? They get their own heap space, and the address of each object goes inside the array.</source>
          <target state="translated">Una matriz es un objeto,así que también va en el montón.¿Y qué pasa con los objetos de la matriz? Tienen su propio espacio en el montón,y la dirección de cada objeto va dentro de la matriz.</target>
        </trans-unit>
        <trans-unit id="9bf2ce1dceef2dc96a821885bc168afbf5d4d9a1" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value&quot;&gt;on the subject of pass-by-value&lt;/a&gt;</source>
          <target state="translated">Y &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value&quot;&gt;sobre el tema del paso por valor&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="753dfa9513c7de7c01e5a4ee8e20f57993151233" translate="yes" xml:space="preserve">
          <source>And now that reverseArray method is over, its reference variables(array1 and array2) are gone. Which means we now only have the two reference variables in main method array1 and array2 which point to c and b arrays respectively. No reference variable is pointing to object (array) a. So it is eligible for garbage collection.</source>
          <target state="translated">Y ahora que el método reverseArray ha terminado,sus variables de referencia (array1 y array2)han desaparecido.Lo que significa que ahora sólo tenemos las dos variables de referencia del método principal array1 y array2 que apuntan a los arrays c y b respectivamente.Ninguna variable de referencia está apuntando al objeto (array)a.Por lo tanto,es elegible para la recogida de basura.</target>
        </trans-unit>
        <trans-unit id="1427090bc2dee2db920c7dcba2e93785a6f9fced" translate="yes" xml:space="preserve">
          <source>And towards the end of the same section he makes a broader statement about java being only pass by value and never pass by reference.</source>
          <target state="translated">Y hacia el final de la misma sección hace una declaración más amplia sobre el hecho de que Java sólo pasa por valor y nunca pasa por referencia.</target>
        </trans-unit>
        <trans-unit id="7ccd274eb97af58443d0d98f31f8165d44df954a" translate="yes" xml:space="preserve">
          <source>Anyway, I noticed a comment by &lt;a href=&quot;https://stackoverflow.com/users/208457/dhackner&quot;&gt;dhackner&lt;/a&gt; in an older post, who made a balloon analogy which I really liked. So much so that I decided to glue together some clip-art to make a set of cartoons to illustrate the point.</source>
          <target state="translated">De todos modos, not&amp;eacute; un comentario de &lt;a href=&quot;https://stackoverflow.com/users/208457/dhackner&quot;&gt;dhackner&lt;/a&gt; en una publicaci&amp;oacute;n anterior, que hizo una analog&amp;iacute;a de globos que realmente me gust&amp;oacute;. Tanto es as&amp;iacute; que decid&amp;iacute; unir algunas im&amp;aacute;genes predise&amp;ntilde;adas para hacer un conjunto de dibujos animados para ilustrar el punto.</target>
        </trans-unit>
        <trans-unit id="7a6f63a9fa8ba00d31fa864a81af348461e2059d" translate="yes" xml:space="preserve">
          <source>As expected output will be:</source>
          <target state="translated">Como se espera que sea el resultado:</target>
        </trans-unit>
        <trans-unit id="9e95da2bd7af315b2113d39a70608c332bc48d91" translate="yes" xml:space="preserve">
          <source>As far as I know, Java only knows call by value. This means for primitive datatypes you will work with an copy and for objects you will work with an copy of the reference to the objects. However I think there are some pitfalls; for example, this will not work:</source>
          <target state="translated">Por lo que sé,Java sólo conoce la llamada por valor.Esto significa que para los tipos de datos primitivos trabajará con una copia y para los objetos trabajará con una copia de la referencia a los objetos.Sin embargo,creo que hay algunas trampas;por ejemplo,esto no funcionará:</target>
        </trans-unit>
        <trans-unit id="d05f320102345bc58ddfdf1478a148fed340e361" translate="yes" xml:space="preserve">
          <source>As many people mentioned it before, &lt;a href=&quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm&quot;&gt;Java is always pass-by-value&lt;/a&gt;</source>
          <target state="translated">Como muchas personas lo mencionaron antes, &lt;a href=&quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm&quot;&gt;Java siempre es un valor de paso&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd4f600b4ca0e57b260d865e338eb632ae21d0de" translate="yes" xml:space="preserve">
          <source>As was explained in previous answers, in Java you're passing a pointer to the array as a value into &lt;code&gt;getValues&lt;/code&gt;. That is enough, because the method then modifies the array element, and by convention you're expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn't necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.</source>
          <target state="translated">Como se explic&amp;oacute; en respuestas anteriores, en Java est&amp;aacute; pasando un puntero a la matriz como un valor en &lt;code&gt;getValues&lt;/code&gt; . Eso es suficiente, porque el m&amp;eacute;todo modifica el elemento de matriz y, por convenci&amp;oacute;n, espera que el elemento 0 contenga el valor de retorno. Obviamente, puede hacer esto de otras maneras, como estructurar su c&amp;oacute;digo para que esto no sea necesario o construir una clase que pueda contener el valor de retorno o permitir que se establezca. Pero el patr&amp;oacute;n simple disponible en C ++ anterior no est&amp;aacute; disponible en Java.</target>
        </trans-unit>
        <trans-unit id="8d7366694d78adcdb573e21740168952ff60eb6a" translate="yes" xml:space="preserve">
          <source>As we all know it will create an object in the heap and return the reference value back to t. For example, suppose the value of t is &lt;code&gt;0x100234&lt;/code&gt; (we don't know the actual JVM internal value, this is just an example) .</source>
          <target state="translated">Como todos sabemos, crear&amp;aacute; un objeto en el mont&amp;oacute;n y devolver&amp;aacute; el valor de referencia a t. Por ejemplo, suponga que el valor de t es &lt;code&gt;0x100234&lt;/code&gt; (no conocemos el valor interno real de JVM, esto es solo un ejemplo).</target>
        </trans-unit>
        <trans-unit id="430da7a13966f26ff5a4c5e2f81b52ff90b0253b" translate="yes" xml:space="preserve">
          <source>As you call &lt;code&gt;modifyReference(Foo c)&lt;/code&gt; method, a reference &lt;code&gt;c&lt;/code&gt; is created and assigned the object with attribute &lt;code&gt;&quot;f&quot;&lt;/code&gt;.</source>
          <target state="translated">Cuando llama al &lt;code&gt;modifyReference(Foo c)&lt;/code&gt; , se crea una referencia &lt;code&gt;c&lt;/code&gt; y se le asigna el objeto con el atributo &lt;code&gt;&quot;f&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa285e6edfa6d99016592271e8d0555fae43569f" translate="yes" xml:space="preserve">
          <source>As you call the method &lt;code&gt;changeReference&lt;/code&gt;, the reference &lt;code&gt;a&lt;/code&gt; will be assigned the object which is passed as an argument.</source>
          <target state="translated">Cuando llame al m&amp;eacute;todo &lt;code&gt;changeReference&lt;/code&gt; , a la referencia &lt;code&gt;a&lt;/code&gt; se le asignar&amp;aacute; el objeto que se pasa como argumento.</target>
        </trans-unit>
        <trans-unit id="108085f3bb0f4209a639200317b9f008aaf21dab" translate="yes" xml:space="preserve">
          <source>Back when I studied compilers-in the 90's, I used the first edition of the book from 1986 which pre-dated Java by about 9 or 10 years. However, I just ran across a copy of the &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W&quot;&gt;2nd Eddition&lt;/a&gt; from 2007 &lt;strong&gt;which actually mentions Java!&lt;/strong&gt; Section 1.6.6 labeled &quot;Parameter Passing Mechanisms&quot; describes parameter passing pretty nicely. Here is an excerpt under the heading &quot;Call-by-value&quot; which mentions Java:</source>
          <target state="translated">Cuando estudi&amp;eacute; compiladores, en los a&amp;ntilde;os 90, utilic&amp;eacute; la primera edici&amp;oacute;n del libro de 1986 que preced&amp;iacute;a a Java por unos 9 o 10 a&amp;ntilde;os. Sin embargo, &amp;iexcl;acabo de encontrar una copia de la &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W&quot;&gt;2da Edici&amp;oacute;n&lt;/a&gt; del 2007 &lt;strong&gt;que en realidad menciona Java!&lt;/strong&gt; La Secci&amp;oacute;n 1.6.6 denominada &quot;Mecanismos de paso de par&amp;aacute;metros&quot; describe el paso de par&amp;aacute;metros bastante bien. Aqu&amp;iacute; hay un extracto bajo el t&amp;iacute;tulo &quot;Llamada por valor&quot; que menciona Java:</target>
        </trans-unit>
        <trans-unit id="2a5566bd96317aa68aedfcd4ec8973cfbf92a199" translate="yes" xml:space="preserve">
          <source>Basically, reassigning Object parameters doesn't affect the argument, e.g.,</source>
          <target state="translated">Básicamente,reasignar los parámetros del objeto no afecta al argumento,por ejemplo,</target>
        </trans-unit>
        <trans-unit id="1b0434b117ced506f4e292880cee2d016b9caf22" translate="yes" xml:space="preserve">
          <source>Before: a = 2, b = 3</source>
          <target state="translated">Antes:a=2,b=3</target>
        </trans-unit>
        <trans-unit id="687e81922c00310f84049051118a03dc31fabaae" translate="yes" xml:space="preserve">
          <source>Both &quot;&lt;em&gt;person&lt;/em&gt;&quot; and &quot;&lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt;&quot; hold the same value of 3bad086a.</source>
          <target state="translated">Tanto &quot; &lt;em&gt;person&lt;/em&gt; &quot; como &quot; &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; &quot; tienen el mismo valor de 3bad086a.</target>
        </trans-unit>
        <trans-unit id="2689caac6d3ec6ddc37d1cac015f4e8ae4e22c88" translate="yes" xml:space="preserve">
          <source>Both variables have IDENTICAL COPIES of the reference and they both refer to the same Person Object, the SAME Object on the Heap and NOT A COPY.</source>
          <target state="translated">Ambas variables tienen COPIAS IDENTICAS de la referencia y ambas se refieren al mismo Objeto Persona,el MISMO Objeto en el Montón y NO UNA COPIA.</target>
        </trans-unit>
        <trans-unit id="e9170e035719274989ed5cf55b194f253b0ee3eb" translate="yes" xml:space="preserve">
          <source>But from this example, we can understand that it is infact pass by value only,
  keeping in mind that here we are passing the reference as the value.
  ie: reference is passed by value.
  That's why are able to change and still it holds true after the local scope.
  But we cannot change the actual reference outside the original scope.
  what that means is demonstrated by next example of PassByValueObjectCase2.</source>
          <target state="translated">Pero a partir de este ejemplo,podemos entender que de hecho es sólo pasar por valor,teniendo en cuenta que aquí estamos pasando la referencia como el valor.Es decir:la referencia se pasa por valor.Es por eso que son capaces de cambiar y aún así se mantiene después del ámbito local.Pero no podemos cambiar la referencia real fuera del ámbito original.Lo que eso significa se demuestra en el siguiente ejemplo de PassByValueObjectCase2.</target>
        </trans-unit>
        <trans-unit id="006ecf4b1a9cc9edb60404b2fb553d2bccdff314" translate="yes" xml:space="preserve">
          <source>C++ pass by reference example:</source>
          <target state="translated">C++pasa por el ejemplo de referencia:</target>
        </trans-unit>
        <trans-unit id="83514ce69e30402f75b91daf4e42e15d62db4d49" translate="yes" xml:space="preserve">
          <source>Check the comment on line #5</source>
          <target state="translated">Revisa el comentario de la línea 5</target>
        </trans-unit>
        <trans-unit id="ce636731102296dcc967f8d443bba701fa39128c" translate="yes" xml:space="preserve">
          <source>Crash course on stack/heap before we get to the Java implementation:
Values go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria.
Memory in the heap (also known as dynamic memory) is haphazard and disorganized. The JVM just finds space wherever it can, and frees it up as the variables that use it are no longer needed.</source>
          <target state="translated">Curso de choque en stackheap antes de llegar a la implementación de Java:Los valores entran y salen de la pila de forma ordenada,como una pila de platos en una cafetería.La memoria en el montón (también conocida como memoria dinámica)es azarosa y desorganizada.La MVC sólo encuentra espacio donde puede,y lo libera ya que las variables que lo usan ya no son necesarias.</target>
        </trans-unit>
        <trans-unit id="9a4330ec3ed061c85b3e0b082e1656ec35e5d3df" translate="yes" xml:space="preserve">
          <source>Creates new Point object</source>
          <target state="translated">Crea un nuevo objeto puntual</target>
        </trans-unit>
        <trans-unit id="1926dd5e7c03bbf781269e3b1f10a918298da01a" translate="yes" xml:space="preserve">
          <source>Creates new Point reference and initialize that reference to &lt;em&gt;point (refer to)&lt;/em&gt; on previously created Point object.</source>
          <target state="translated">Crea una nueva referencia de Punto e inicializa esa referencia a un &lt;em&gt;punto (consulte)&lt;/em&gt; en un objeto de Punto creado previamente.</target>
        </trans-unit>
        <trans-unit id="91a5cb67c9d537c081e9f8cf1bbc2d3e758ce171" translate="yes" xml:space="preserve">
          <source>Creating two different Point object with two different reference associated.</source>
          <target state="translated">Creando dos objetos puntuales diferentes con dos referencias diferentes asociadas.</target>
        </trans-unit>
        <trans-unit id="b0dda1bfba52f041403c7023d96d1d341ad3c077" translate="yes" xml:space="preserve">
          <source>Data in memory has a &lt;strong&gt;Location&lt;/strong&gt; and at that location there is a value (byte,word, whatever). In Assembly we have a convenient solution to give a &lt;strong&gt;Name&lt;/strong&gt; to certain &lt;strong&gt;Location&lt;/strong&gt; (aka variable), but when compiling the code, the assembler simply replaces &lt;strong&gt;Name&lt;/strong&gt; with the designated location just like your browser replaces domain names with IP addresses.</source>
          <target state="translated">Los datos en la memoria tienen una &lt;strong&gt;ubicaci&amp;oacute;n&lt;/strong&gt; y en esa ubicaci&amp;oacute;n hay un valor (byte, palabra, lo que sea). En Assembly tenemos una soluci&amp;oacute;n conveniente para asignar un &lt;strong&gt;nombre&lt;/strong&gt; a una determinada &lt;strong&gt;ubicaci&amp;oacute;n&lt;/strong&gt; (tambi&amp;eacute;n conocida como variable), pero al compilar el c&amp;oacute;digo, el ensamblador simplemente reemplaza &lt;strong&gt;Name&lt;/strong&gt; con la ubicaci&amp;oacute;n designada, al igual que su navegador reemplaza los nombres de dominio con direcciones IP.</target>
        </trans-unit>
        <trans-unit id="bfb16cd1cd030c8e69601029c768549e17aa7047" translate="yes" xml:space="preserve">
          <source>Declaring a reference named &lt;code&gt;b&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; and assign it a new object of type &lt;code&gt;Foo&lt;/code&gt; with an attribute &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">Declarar una referencia llamada &lt;code&gt;b&lt;/code&gt; de tipo &lt;code&gt;Foo&lt;/code&gt; y asignarle un nuevo objeto de tipo &lt;code&gt;Foo&lt;/code&gt; con un atributo &lt;code&gt;&quot;b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bb0f2661240daa3e654c2b942a4228aef7a6a44" translate="yes" xml:space="preserve">
          <source>Declaring a reference named &lt;code&gt;f&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; and assign it a new object of type &lt;code&gt;Foo&lt;/code&gt; with an attribute &lt;code&gt;&quot;f&quot;&lt;/code&gt;.</source>
          <target state="translated">Declarar una referencia llamada &lt;code&gt;f&lt;/code&gt; de tipo &lt;code&gt;Foo&lt;/code&gt; y asignarle un nuevo objeto de tipo &lt;code&gt;Foo&lt;/code&gt; con un atributo &lt;code&gt;&quot;f&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd9950fdb8d7858353a3702108602c9648dd0e68" translate="yes" xml:space="preserve">
          <source>Does this sound strange and confusing? Let's consider how C implements pass by reference and pass by value. In C, the default convention is pass by value. &lt;code&gt;void foo(int x)&lt;/code&gt; passes an int by value. &lt;code&gt;void foo(int *x)&lt;/code&gt; is a function that does not want an &lt;code&gt;int a&lt;/code&gt;, but a pointer to an int: &lt;code&gt;foo(&amp;amp;a)&lt;/code&gt;. One would use this with the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to pass a variable address.</source>
          <target state="translated">&amp;iquest;Suena extra&amp;ntilde;o y confuso? Consideremos c&amp;oacute;mo C implementa pasa por referencia y pasa por valor. En C, la convenci&amp;oacute;n predeterminada es pasar por valor. &lt;code&gt;void foo(int x)&lt;/code&gt; pasa un int por valor. &lt;code&gt;void foo(int *x)&lt;/code&gt; es una funci&amp;oacute;n que no quiere un &lt;code&gt;int a&lt;/code&gt; , sino un puntero a un int: &lt;code&gt;foo(&amp;amp;a)&lt;/code&gt; . Uno usar&amp;iacute;a esto con el operador &lt;code&gt;&amp;amp;&lt;/code&gt; para pasar una direcci&amp;oacute;n variable.</target>
        </trans-unit>
        <trans-unit id="b5854bdd57360320e24b9397418a212d3b8b3fc1" translate="yes" xml:space="preserve">
          <source>Don't try this but person==anotherReferenceToTheSamePersonObject would be true.</source>
          <target state="translated">No intentes esto,pero otra referencia al objeto de la misma persona sería verdadera.</target>
        </trans-unit>
        <trans-unit id="207ba28fc5d0fc3ff8e2b02914c001bb5bb368b5" translate="yes" xml:space="preserve">
          <source>Down to the core it is technically impossible to pass a reference to anything in any language without representing it (when it immediately becomes a value).</source>
          <target state="translated">Hasta el fondo es técnicamente imposible pasar una referencia a algo en cualquier idioma sin representarlo (cuando se convierte inmediatamente en un valor).</target>
        </trans-unit>
        <trans-unit id="438f74e42d1fb68f2c51553f32173992bba966c9" translate="yes" xml:space="preserve">
          <source>First of all, we need to understand what pass by value and pass by reference are.</source>
          <target state="translated">En primer lugar,tenemos que entender lo que es pasar por valor y pasar por referencia.</target>
        </trans-unit>
        <trans-unit id="9e5aff39fe5953d4740386d14bbfaa42a906a8b9" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&quot;&gt;What's the difference between passing by reference vs. passing by value?&lt;/a&gt;</source>
          <target state="translated">Primero, &lt;a href=&quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&quot;&gt;&amp;iquest;cu&amp;aacute;l es la diferencia entre pasar por referencia versus pasar por valor?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e0065a83f42a57a3911225215a70e9b907a2bbc" translate="yes" xml:space="preserve">
          <source>Flow of the program:</source>
          <target state="translated">Flujo del programa:</target>
        </trans-unit>
        <trans-unit id="0dfdb0b2fd7037984e97ec60ea513d8d5b9e3dd0" translate="yes" xml:space="preserve">
          <source>For objects, the pass by value is the value of &lt;em&gt;the reference to the object&lt;/em&gt;.</source>
          <target state="translated">Para los objetos, el paso por valor es el valor de &lt;em&gt;la referencia al objeto&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5c00717c1eeb06ca14fc62309936f50e756db581" translate="yes" xml:space="preserve">
          <source>For primitive arguments (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, etc.), the pass by value is &lt;em&gt;the actual value&lt;/em&gt; of the primitive (for example, 3).</source>
          <target state="translated">Para argumentos primitivos ( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , etc.), el valor de paso es &lt;em&gt;el valor real&lt;/em&gt; de la primitiva (por ejemplo, 3).</target>
        </trans-unit>
        <trans-unit id="d717d5e3b868b30355b36493393d4dedba688590" translate="yes" xml:space="preserve">
          <source>From here scope of &lt;code&gt;tricky&lt;/code&gt; method is gone and you don't have access any more to the references: &lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, &lt;code&gt;temp&lt;/code&gt;. &lt;strong&gt;But important note is that everything you do with these references when they are 'in life' will permanently affect object on which they are &lt;em&gt;point&lt;/em&gt; to.&lt;/strong&gt;</source>
          <target state="translated">Desde aqu&amp;iacute;, el alcance del m&amp;eacute;todo &lt;code&gt;tricky&lt;/code&gt; ha desaparecido y ya no tiene acceso a las referencias: &lt;code&gt;arg1&lt;/code&gt; , &lt;code&gt;arg2&lt;/code&gt; , &lt;code&gt;temp&lt;/code&gt; . &lt;strong&gt;Pero una nota importante es que todo lo que haga con estas referencias cuando est&amp;eacute;n 'en la vida' afectar&amp;aacute; permanentemente el objeto al que &lt;em&gt;apuntan&lt;/em&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ee364d2560bc79a19a4c72624692c7755f4443f" translate="yes" xml:space="preserve">
          <source>From here, through Point object life, you will access to that object through pnt1
 reference. So we can say that in Java you manipulate object through its reference.</source>
          <target state="translated">Desde aquí,a través de la vida de los objetos puntuales,accederás a ese objeto a través de la referencia pnt1.Así que podemos decir que en Java se manipula el objeto a través de su referencia.</target>
        </trans-unit>
        <trans-unit id="2c8076e66b55ab8aeac61f85404367064fccd996" translate="yes" xml:space="preserve">
          <source>From the method side, a reference of type &lt;code&gt;Foo&lt;/code&gt; with a name &lt;code&gt;a&lt;/code&gt; is declared and it's initially assigned &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Desde el lado del m&amp;eacute;todo, se declara una referencia de tipo &lt;code&gt;Foo&lt;/code&gt; con un nombre &lt;code&gt;a&lt;/code&gt; y se le asigna inicialmente un &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb62bec2c3a15680c7c08a655906f2b1d75ef3f" translate="yes" xml:space="preserve">
          <source>Getting an outside of the box view, let's look at Assembly or some low level memory management. At the CPU level a &lt;em&gt;reference&lt;/em&gt; to anything immediately becomes a &lt;em&gt;value&lt;/em&gt; if it gets written to memory or to one of the CPU registers. (That is why &lt;em&gt;pointer&lt;/em&gt; is a good definition. It is a value, which has a purpose at the same time).</source>
          <target state="translated">Para obtener una vista fuera del cuadro, veamos el ensamblaje o alguna administraci&amp;oacute;n de memoria de bajo nivel. A nivel de CPU, una &lt;em&gt;referencia&lt;/em&gt; a cualquier cosa se convierte inmediatamente en un &lt;em&gt;valor&lt;/em&gt; si se escribe en la memoria o en uno de los registros de la CPU. (Es por eso que &lt;em&gt;puntero&lt;/em&gt; es una buena definici&amp;oacute;n. Es un valor, que tiene un prop&amp;oacute;sito al mismo tiempo).</target>
        </trans-unit>
        <trans-unit id="a09f4f73a25672b2d71176498d77cdaf4f9d5f33" translate="yes" xml:space="preserve">
          <source>He goes on to make the same point regarding objects . . .</source>
          <target state="translated">Continúa haciendo lo mismo con respecto a los objetos...</target>
        </trans-unit>
        <trans-unit id="dcab7f73c798d9959b167db93301f1b793cb10fc" translate="yes" xml:space="preserve">
          <source>Here is another example that will help you understand the difference (&lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;the classic swap example&lt;/a&gt;):</source>
          <target state="translated">Aqu&amp;iacute; hay otro ejemplo que lo ayudar&amp;aacute; a comprender la diferencia ( &lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;el ejemplo de intercambio cl&amp;aacute;sico&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="095229be47d5e504de9b8c6e3f105270472a7db4" translate="yes" xml:space="preserve">
          <source>Here, you first create new &lt;code&gt;temp&lt;/code&gt; Point reference which will &lt;em&gt;point&lt;/em&gt; on same place like &lt;code&gt;arg1&lt;/code&gt; reference. Then you move reference &lt;code&gt;arg1&lt;/code&gt; to &lt;em&gt;point&lt;/em&gt; to the same place like &lt;code&gt;arg2&lt;/code&gt; reference.
Finally &lt;code&gt;arg2&lt;/code&gt; will &lt;em&gt;point&lt;/em&gt; to the same place like &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, primero crea una nueva referencia de punto &lt;code&gt;temp&lt;/code&gt; oral que apuntar&amp;aacute; al mismo lugar como referencia &lt;code&gt;arg1&lt;/code&gt; . Luego mueve la referencia &lt;code&gt;arg1&lt;/code&gt; para &lt;em&gt;apuntar&lt;/em&gt; al mismo lugar como la referencia &lt;code&gt;arg2&lt;/code&gt; . Finalmente &lt;code&gt;arg2&lt;/code&gt; apuntar&amp;aacute; al mismo lugar como &lt;code&gt;temp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64169e4a61bae86f469a92b3cfc4bae9c3a53858" translate="yes" xml:space="preserve">
          <source>Hopefully this will help.</source>
          <target state="translated">Esperemos que esto ayude.</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">Cómo funciona</target>
        </trans-unit>
        <trans-unit id="e5beaeff3bbae8257639b2987a7f67bd9d85c384" translate="yes" xml:space="preserve">
          <source>However you could make a wrapper for String like this which would make it able to use it with Strings:</source>
          <target state="translated">Sin embargo,se podría hacer un envoltorio para Cuerda como este que lo haría capaz de utilizarlo con Cuerdas:</target>
        </trans-unit>
        <trans-unit id="26dd9ac7a210ba6a96d874cf5c6e8374ed5dbcf2" translate="yes" xml:space="preserve">
          <source>However, I've seen a couple of blog posts (for example, &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this blog&lt;/a&gt;) that claim that it isn't.</source>
          <target state="translated">Sin embargo, he visto un par de publicaciones en el blog (por ejemplo, &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;este blog&lt;/a&gt; ) que afirman que no lo es.</target>
        </trans-unit>
        <trans-unit id="ec1be69fa319cc52b285a8bee8c6a7f04ee9e1f8" translate="yes" xml:space="preserve">
          <source>I always think of it as &quot;pass by copy&quot;. It is a copy of the value be it primitive or reference. If it is a primitive it is a copy of the bits that are the value and if it is an Object it is a copy of the reference.</source>
          <target state="translated">Siempre pienso en ello como &quot;copia de paso&quot;.Es una copia del valor,ya sea primitivo o de referencia.Si es primitivo es una copia de los bits que son el valor y si es un objeto es una copia de la referencia.</target>
        </trans-unit>
        <trans-unit id="69f13178ffc91e81d12909e0fab0a089bbad804f" translate="yes" xml:space="preserve">
          <source>I always thought Java was &lt;strong&gt;pass-by-reference&lt;/strong&gt;.</source>
          <target state="translated">Siempre pens&amp;eacute; que Java era &lt;strong&gt;paso por referencia&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="efd75827ae1611bf4e22af1ec1d50ca7541b3557" translate="yes" xml:space="preserve">
          <source>I can't believe that nobody mentioned Barbara Liskov yet. When she designed CLU in 1974, she ran into this same terminology problem, and she invented the term &lt;em&gt;call by sharing&lt;/em&gt; (also known as &lt;em&gt;call by object-sharing&lt;/em&gt; and &lt;em&gt;call by object&lt;/em&gt;) for this specific case of &quot;call by value where the value is a reference&quot;.</source>
          <target state="translated">No puedo creer que nadie haya mencionado a Barbara Liskov todav&amp;iacute;a. Cuando dise&amp;ntilde;&amp;oacute; CLU en 1974, se encontr&amp;oacute; con este mismo problema de terminolog&amp;iacute;a e invent&amp;oacute; el t&amp;eacute;rmino &lt;em&gt;llamada por compartir&lt;/em&gt; (tambi&amp;eacute;n conocido como &lt;em&gt;llamada por compartir objetos&lt;/em&gt; y &lt;em&gt;llamada por objeto&lt;/em&gt; ) para este caso espec&amp;iacute;fico de &quot;llamada por valor donde el valor es una referencia&quot;.</target>
        </trans-unit>
        <trans-unit id="aeaec84d031aa5cb38d5557cf7de3f76bf7cafb0" translate="yes" xml:space="preserve">
          <source>I don't think I understand the distinction they're making.</source>
          <target state="translated">Creo que no entiendo la distinción que están haciendo.</target>
        </trans-unit>
        <trans-unit id="d5405762999d453eb212ccf6bcc5f6125f900230" translate="yes" xml:space="preserve">
          <source>I feel like arguing about &quot;pass-by-reference vs pass-by-value&quot; is not super-helpful.</source>
          <target state="translated">Siento que discutir sobre &quot;paso-por-referencia vs paso-por-valor&quot; no es súper útil.</target>
        </trans-unit>
        <trans-unit id="da328c30116bfb1c498c3407693d22ba90f3115c" translate="yes" xml:space="preserve">
          <source>I have created a thread devoted to these kind of questions for &lt;em&gt;any&lt;/em&gt; programming languages &lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">He creado un hilo dedicado a este tipo de preguntas para &lt;em&gt;cualquier&lt;/em&gt; lenguaje de programaci&amp;oacute;n &lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be8f8168e2402a238a9976383c81f993f3a3e74e" translate="yes" xml:space="preserve">
          <source>I have seen posts on this topic which describe the low level implementation of parameter passing in Java, which I think is great and very helpful because it makes an abstract idea concrete. However, to me the question is more about &lt;strong&gt;the behavior described in the language specification&lt;/strong&gt; than about the technical implementation of the behavior. This is an exerpt from the &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java Language Specification, section 8.4.1&lt;/a&gt; :</source>
          <target state="translated">He visto publicaciones sobre este tema que describen la implementaci&amp;oacute;n de bajo nivel de paso de par&amp;aacute;metros en Java, lo que creo que es excelente y muy &amp;uacute;til porque hace concreta una idea abstracta. Sin embargo, para m&amp;iacute; la pregunta es m&amp;aacute;s sobre &lt;strong&gt;el comportamiento descrito en la especificaci&amp;oacute;n del lenguaje&lt;/strong&gt; que sobre la implementaci&amp;oacute;n t&amp;eacute;cnica del comportamiento. Este es un ejercicio de la &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Especificaci&amp;oacute;n del lenguaje Java, secci&amp;oacute;n 8.4.1&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cb7305997ab86247b2a49056cbf4e89230b9f222" translate="yes" xml:space="preserve">
          <source>I hope this settles the debate, but probably won't.</source>
          <target state="translated">Espero que esto resuelva el debate,pero probablemente no lo hará.</target>
        </trans-unit>
        <trans-unit id="d415e610e2056093f16e0b12b5086931ca855762" translate="yes" xml:space="preserve">
          <source>I hope you understand now how passing objects as arguments works in Java :)</source>
          <target state="translated">Espero que entiendas ahora cómo funcionan los objetos de paso como argumentos en Java :)</target>
        </trans-unit>
        <trans-unit id="53b25f35c0f07624c3ab774845793894e9df085c" translate="yes" xml:space="preserve">
          <source>I just noticed you referenced &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;my article&lt;/a&gt;.</source>
          <target state="translated">Acabo de notar que hiciste referencia a &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;mi art&amp;iacute;culo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2935658c6ca5dd052a7a1348a0e9a0f71fe8584b" translate="yes" xml:space="preserve">
          <source>I might be a little obsessed with this post. Probably because I feel that the makers of Java inadvertently spread misinformation. If instead of using the word &quot;reference&quot; for pointers they had used something else, say 
dingleberry, there would've been no problem. You could say, &quot;Java passes dingleberries by value and not by reference&quot;, and nobody would be confused. (Hence forth, when referencing pass by reference vs value, I shall refer to references as dinglebarries.)</source>
          <target state="translated">Puede que esté un poco obsesionado con este puesto.Probablemente porque siento que los fabricantes de Java inadvertidamente difunden información errónea.Si en lugar de usar la palabra &quot;referencia&quot; para los punteros hubieran usado otra cosa,digamos &quot;dingleberry&quot;,no habría habido ningún problema.Podrías decir,&quot;Java pasa las bayas por valor y no por referencia&quot;,y nadie se confundiría.(De aquí en adelante,cuando se haga referencia a pasar por referencia vs valor,me referiré a las referencias como dinglebarries.)</target>
        </trans-unit>
        <trans-unit id="dbf80c5168a8cdece318ecb980f6dc4582312bc0" translate="yes" xml:space="preserve">
          <source>I think the difference between the two models is very subtle and unless you've done programming where you actually used pass-by-reference, it's easy to miss where two models differ.</source>
          <target state="translated">Creo que la diferencia entre los dos modelos es muy sutil y a menos que hayas hecho la programación donde realmente usaste la referencia de paso,es fácil perderse donde dos modelos difieren.</target>
        </trans-unit>
        <trans-unit id="051719f18cca69c8321cf2db575cbe7c3c8fc918" translate="yes" xml:space="preserve">
          <source>I thought I'd contribute this answer to add more details from the Specifications.</source>
          <target state="translated">Pensé en contribuir con esta respuesta para añadir más detalles de las especificaciones.</target>
        </trans-unit>
        <trans-unit id="02668452fdc578abe59e37b1d267b95f2c167d43" translate="yes" xml:space="preserve">
          <source>I will explain this in steps:</source>
          <target state="translated">Te lo explicaré por etapas:</target>
        </trans-unit>
        <trans-unit id="7e24c4c25b98f1916d4e52df7af6eeb891b2b203" translate="yes" xml:space="preserve">
          <source>If Java had pass-by-reference semantics, the &lt;code&gt;foo&lt;/code&gt; method we defined above would have changed where &lt;code&gt;myDog&lt;/code&gt; was pointing when it assigned &lt;code&gt;someDog&lt;/code&gt; on line BBB.</source>
          <target state="translated">Si Java tuviera una sem&amp;aacute;ntica de paso por referencia, el m&amp;eacute;todo &lt;code&gt;foo&lt;/code&gt; que definimos anteriormente habr&amp;iacute;a cambiado hacia d&amp;oacute;nde &lt;code&gt;myDog&lt;/code&gt; cuando asign&amp;oacute; &lt;code&gt;someDog&lt;/code&gt; en la l&amp;iacute;nea BBB.</target>
        </trans-unit>
        <trans-unit id="6697d56d6fde5f640c216d07a963f93b03bd1f54" translate="yes" xml:space="preserve">
          <source>If it's a primitive data type these bits contain the value of the primitive data type itself, That's why if we change the value of header inside the method then it does not reflect the changes outside.</source>
          <target state="translated">Si se trata de un tipo de datos primitivos,estos bits contienen el valor del propio tipo de datos primitivos,por lo que si cambiamos el valor de la cabecera dentro del método,entonces no refleja los cambios fuera.</target>
        </trans-unit>
        <trans-unit id="79742ec00dad7a7b993ddfde20c405582b74811d" translate="yes" xml:space="preserve">
          <source>If it's a primitive data type these bits will contain the value of the primitive data type itself.</source>
          <target state="translated">Si se trata de un tipo de datos primitivos,estos bits contendrán el valor del propio tipo de datos primitivos.</target>
        </trans-unit>
        <trans-unit id="f0283f6b09b05e1b1e2ef39baf027825432d4169" translate="yes" xml:space="preserve">
          <source>If it's an Object the bits will contain the value of the address that tells the JVM how to get to the Object.</source>
          <target state="translated">Si es un Objeto,los bits contendrán el valor de la dirección que le dice a la JVM cómo llegar al Objeto.</target>
        </trans-unit>
        <trans-unit id="8a2c1b22c98b47861f2f787055fd5f2fa95e5b32" translate="yes" xml:space="preserve">
          <source>If it's an object data type like &lt;strong&gt;Foo foo=new Foo()&lt;/strong&gt; then in this case copy of the address of the object passes like file shortcut  , suppose we have a text file &lt;strong&gt;abc.txt&lt;/strong&gt; at &lt;strong&gt;C:\desktop&lt;/strong&gt; and suppose we make shortcut of the same file and put this inside &lt;strong&gt;C:\desktop\abc-shortcut&lt;/strong&gt; so when you access the file from &lt;strong&gt;C:\desktop\abc.txt&lt;/strong&gt; and write &lt;strong&gt;'Stack Overflow'&lt;/strong&gt; and close the file and again you open the file from shortcut then you write &lt;strong&gt;' is the largest online community for programmers to learn'&lt;/strong&gt; then total file change will be &lt;strong&gt;'Stack Overflow is the largest online community for programmers to learn'&lt;/strong&gt; which means it doesn't matter from where you open the file , each time we were accessing the same file , here we can assume &lt;strong&gt;Foo&lt;/strong&gt; as a file and suppose foo stored at &lt;strong&gt;123hd7h&lt;/strong&gt;(original address like &lt;strong&gt;C:\desktop\abc.txt&lt;/strong&gt; ) address and &lt;strong&gt;234jdid&lt;/strong&gt;(copied address like &lt;strong&gt;C:\desktop\abc-shortcut&lt;/strong&gt; which actually contains the original address of the file inside) ..
So for better understanding make shortcut file and feel..</source>
          <target state="translated">Si se trata de un tipo de datos de objeto como &lt;strong&gt;Foo foo = new Foo ()&lt;/strong&gt; , en este caso la copia de la direcci&amp;oacute;n del objeto pasa como acceso directo de archivo, supongamos que tenemos un archivo de texto &lt;strong&gt;abc.txt&lt;/strong&gt; en &lt;strong&gt;C: \ escritorio&lt;/strong&gt; y supongamos que hacemos un acceso directo de el mismo archivo y col&amp;oacute;quelo dentro de &lt;strong&gt;C: \ desktop \ abc-shortcut&lt;/strong&gt; para que cuando acceda al archivo desde &lt;strong&gt;C: \ desktop \ abc.txt&lt;/strong&gt; y escriba &lt;strong&gt;'Stack Overflow'&lt;/strong&gt; y cierre el archivo y nuevamente abra el archivo desde el acceso directo y luego escribir &lt;strong&gt;'es la comunidad en l&amp;iacute;nea m&amp;aacute;s grande para que los programadores aprendan',&lt;/strong&gt; luego el cambio total de archivos ser&amp;aacute; &lt;strong&gt;'Stack Overflow es la comunidad en l&amp;iacute;nea m&amp;aacute;s grande para que los programadores aprendan', lo&lt;/strong&gt; que significa que no importa desde d&amp;oacute;nde abras el archivo, cada vez que accedimos el mismo archivo, aqu&amp;iacute; podemos asumir &lt;strong&gt;Foo&lt;/strong&gt; como un archivo y suponer foo almacenado en &lt;strong&gt;123hd7h&lt;/strong&gt; (direcci&amp;oacute;n original como &lt;strong&gt;C: \ desktop \ abc.txt&lt;/strong&gt; ) y &lt;strong&gt;234jdid&lt;/strong&gt; (direcci&amp;oacute;n copiada como &lt;strong&gt;C: \ desktop \ abc-shortcut&lt;/strong&gt; que realmente contiene el direcci&amp;oacute;n original del archivo dentro). Entonces, para una mejor comprensi&amp;oacute;n, crea un archivo de acceso directo y siente ...</target>
        </trans-unit>
        <trans-unit id="d09449cf7c49c0bb34af69bedb5138b6a6cf6571" translate="yes" xml:space="preserve">
          <source>If we pass the value of array1 reference variable as an argument to the reverseArray method, a reference variable is created in the method and that reference variable starts pointing to the same array (a).</source>
          <target state="translated">Si pasamos el valor de la variable de referencia de la matriz1 como argumento al método reverseArray,se crea una variable de referencia en el método y esa variable de referencia empieza a apuntar a la misma matriz (a).</target>
        </trans-unit>
        <trans-unit id="111cce0df4d6a3eea4ae694172e96a48fec02a36" translate="yes" xml:space="preserve">
          <source>If we return value of reference variable array2 as the return value of method reverseArray and assign this value to reference variable array1 in main method, array1 in main will start pointing to array c.</source>
          <target state="translated">Si devolvemos el valor de la variable de referencia array2 como el valor de retorno del método reverseArray y asignamos este valor a la variable de referencia array1 en el método principal,el array1 en el principal empezará a apuntar al array c.</target>
        </trans-unit>
        <trans-unit id="cdd0e1a5c0a10b05b85a4f05bf0c8857fb0dc54a" translate="yes" xml:space="preserve">
          <source>If we want to call a method/function/procedure with Foo's value, there are a few possible way to pass the variable to the method, depending on the &lt;strong&gt;language&lt;/strong&gt; and its several method invocation modes:</source>
          <target state="translated">Si queremos llamar a un m&amp;eacute;todo / funci&amp;oacute;n / procedimiento con el valor de Foo, hay algunas formas posibles de pasar la variable al m&amp;eacute;todo, dependiendo del &lt;strong&gt;idioma&lt;/strong&gt; y sus diversos modos de invocaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="ae7787cfc8ddd2039110866a573a0e2714e49edb" translate="yes" xml:space="preserve">
          <source>If you change anything in the function using reference f it will modify the existing contents of the object. That is why we got the output &lt;code&gt;changevalue&lt;/code&gt;,   which is updated in the function.</source>
          <target state="translated">Si cambia algo en la funci&amp;oacute;n utilizando la referencia f, modificar&amp;aacute; el contenido existente del objeto. Es por eso que obtuvimos el valor de cambio de salida, que se actualiza en la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fe4914949893eeb60b019dffcc6cea87be8dcc83" translate="yes" xml:space="preserve">
          <source>If you didn't get it then just trust me and remember that it's better to say that &lt;strong&gt;Java is pass by value&lt;/strong&gt;. Well, &lt;strong&gt;pass by reference value&lt;/strong&gt;. Oh well, even better is &lt;strong&gt;&lt;em&gt;pass-by-copy-of-the-variable-value! ;)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">Si no lo obtuvo, simplemente conf&amp;iacute;e en m&amp;iacute; y recuerde que es mejor decir que &lt;strong&gt;Java es pasar por valor&lt;/strong&gt; . Bueno, &lt;strong&gt;pase por valor de referencia&lt;/strong&gt; . &amp;iexcl;Oh, bueno, a&amp;uacute;n mejor es &lt;strong&gt;&lt;em&gt;pasar por copia del valor de la variable!&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;;)&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d76bdbeace9817e06089a031711671ab9b1f87b3" translate="yes" xml:space="preserve">
          <source>If you say, &quot;Java is pass-by-whatever (reference/value)&quot;, in either case, you're not provide a complete answer. Here's some additional information that will hopefully aid in understanding what's happening in memory.</source>
          <target state="translated">Si dices,&quot;Java es pasa-lo que sea (valor de referencia)&quot;,en cualquier caso,no estás dando una respuesta completa.Aquí hay alguna información adicional que esperamos ayude a entender lo que está pasando en la memoria.</target>
        </trans-unit>
        <trans-unit id="2864474958a88d28e0e852e593201018ce309c3a" translate="yes" xml:space="preserve">
          <source>In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.</source>
          <target state="translated">En C++,Ada,Pascal y otros lenguajes que soportan pass-by-reference,puedes cambiar la variable que fue pasada.</target>
        </trans-unit>
        <trans-unit id="cd1ab35d296b25bfeeda42a17c0845735976d063" translate="yes" xml:space="preserve">
          <source>In C++: &lt;strong&gt;Note: Bad code - memory leaks!&lt;/strong&gt;  But it demonstrates the point.</source>
          <target state="translated">En C ++: &lt;strong&gt;Nota: C&amp;oacute;digo incorrecto: &amp;iexcl;p&amp;eacute;rdidas de memoria!&lt;/strong&gt; Pero demuestra el punto.</target>
        </trans-unit>
        <trans-unit id="70a7832950563eb1e68d730cfc8633aecba50e12" translate="yes" xml:space="preserve">
          <source>In Java,</source>
          <target state="translated">En Java,</target>
        </trans-unit>
        <trans-unit id="ee32c40f3e465ae5371086558cba52983a8a32d8" translate="yes" xml:space="preserve">
          <source>In Java, all parameters are passed by value, i.e. assigning a method argument is not visible to the caller.</source>
          <target state="translated">En Java,todos los parámetros se pasan por valor,es decir,la asignación de un argumento de método no es visible para el llamador.</target>
        </trans-unit>
        <trans-unit id="ea4a661eaa255681fb44e9a0ceb260d8c9521fd5" translate="yes" xml:space="preserve">
          <source>In Java, modifying the variable means reassigning it. In Java, if you reassigned the variable within the method, it would go unnoticed to the caller. &lt;strong&gt;Modifying the object referenced by the variable is a different concept entirely.&lt;/strong&gt;</source>
          <target state="translated">En Java, modificar la variable significa reasignarla. En Java, si reasigna la variable dentro del m&amp;eacute;todo, pasar&amp;aacute; desapercibido para la persona que llama. &lt;strong&gt;Modificar el objeto al que hace referencia la variable es un concepto completamente diferente.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ec57628bd6a19cc372e0d82956fbc9926fe31cc" translate="yes" xml:space="preserve">
          <source>In addition to what was mentioned in Example3 (PassByValueObjectCase1.java),  we cannot change the actual reference outside the original scope.&quot;</source>
          <target state="translated">Además de lo que se mencionó en el ejemplo 3 (PassByValueObjectCase1.java),no podemos cambiar la referencia real fuera del ámbito original&quot;.</target>
        </trans-unit>
        <trans-unit id="bf42410ba453a42ec3533408e27e6dbcc281e995" translate="yes" xml:space="preserve">
          <source>In call-by-reference evaluation (also referred to as
  pass-by-reference), a function receives an implicit reference to a
  variable used as argument, rather than a copy of its value. This
  typically means that the function can modify (i.e. assign to) the
  variable used as argument&amp;mdash;something that will be seen by its caller.</source>
          <target state="translated">En la evaluaci&amp;oacute;n de llamada por referencia (tambi&amp;eacute;n conocida como paso por referencia), una funci&amp;oacute;n recibe una referencia impl&amp;iacute;cita a una variable utilizada como argumento, en lugar de una copia de su valor. Esto generalmente significa que la funci&amp;oacute;n puede modificar (es decir, asignar a) la variable utilizada como argumento, algo que ver&amp;aacute; la persona que llama.</target>
        </trans-unit>
        <trans-unit id="8b7b4cb1ed7c07a761b7c04a976a8f1ba04382e4" translate="yes" xml:space="preserve">
          <source>In call-by-value, the actual parameter is evaluated (if it is an
  expression) or copied (if it is a variable). The value is placed in
  the location belonging to the corresponding formal parameter of the
  called procedure. &lt;strong&gt;This method is used in C and Java, and is a common
  option in C++ , as well as in most other languages.&lt;/strong&gt;</source>
          <target state="translated">En la llamada por valor, el par&amp;aacute;metro real se eval&amp;uacute;a (si es una expresi&amp;oacute;n) o se copia (si es una variable). El valor se coloca en la ubicaci&amp;oacute;n que pertenece al par&amp;aacute;metro formal correspondiente del procedimiento llamado. &lt;strong&gt;Este m&amp;eacute;todo se usa en C y Java, y es una opci&amp;oacute;n com&amp;uacute;n en C ++, as&amp;iacute; como en la mayor&amp;iacute;a de los otros lenguajes.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80cff4aaaefaebbc2f88f5d26ae6ac275dc4f40b" translate="yes" xml:space="preserve">
          <source>In call-by-value, the argument expression is evaluated, and the
  resulting value is bound to the corresponding variable in the function [...]. 
  If the function or procedure is able to assign values to its
  parameters, only its local copy is assigned [...].</source>
          <target state="translated">En la llamada por valor,se evalúa la expresión del argumento,y el valor resultante se vincula a la variable correspondiente en la función [...].Si la función o el procedimiento es capaz de asignar valores a sus parámetros,sólo se le asigna su copia local [...].</target>
        </trans-unit>
        <trans-unit id="bd4f5299b140615753485c299e8a2e77b0c5997f" translate="yes" xml:space="preserve">
          <source>In case of Objects, this is the same: 
Object variables are pointers (buckets) holding only Object&amp;rsquo;s &lt;strong&gt;address&lt;/strong&gt; that was created using the &quot;new&quot; keyword, and are copied like primitive types.</source>
          <target state="translated">En el caso de los objetos, esto es lo mismo: las variables de objeto son punteros (dep&amp;oacute;sitos) que contienen solo la &lt;strong&gt;direcci&amp;oacute;n&lt;/strong&gt; del objeto que se cre&amp;oacute; con la palabra clave &quot;nueva&quot; y se copian como tipos primitivos.</target>
        </trans-unit>
        <trans-unit id="fc3d33069def51ed42a9766ed121449803b82259" translate="yes" xml:space="preserve">
          <source>In effect, using a method, you will never be able, to update the value of a String passed as argument:</source>
          <target state="translated">En efecto,usando un método,nunca serás capaz,de actualizar el valor de un String pasado como argumento:</target>
        </trans-unit>
        <trans-unit id="80da013ae7fbb0cb942c6b9e18118975ac88e298" translate="yes" xml:space="preserve">
          <source>In every cases above a value - a &lt;strong&gt;copy&lt;/strong&gt; of an existing value - has been created, it is now upto the receiving method to handle it. When you write &quot;Foo&quot; inside the method, it is either read out from EAX, or automatically  &lt;strong&gt;dereferenced&lt;/strong&gt;, or double dereferenced, the process depends on how the language works and/or what the type of Foo dictates. This is hidden from the developer until she circumvents the dereferencing process. So a &lt;em&gt;reference&lt;/em&gt; is a &lt;em&gt;value&lt;/em&gt; when represented, because a reference is a value that has to be processed (at language level).</source>
          <target state="translated">En todos los casos por encima de un valor, una &lt;strong&gt;copia&lt;/strong&gt; de un valor existente, se ha creado, ahora depende del m&amp;eacute;todo de recepci&amp;oacute;n manejarlo. Cuando escribe &quot;Foo&quot; dentro del m&amp;eacute;todo, se lee desde EAX, o se &lt;strong&gt;desreferencia&lt;/strong&gt; autom&amp;aacute;ticamente o se &lt;strong&gt;desreferencia&lt;/strong&gt; doble, el proceso depende de c&amp;oacute;mo funciona el lenguaje y / o qu&amp;eacute; dicta el tipo de Foo. Esto queda oculto para el desarrollador hasta que elude el proceso de desreferenciaci&amp;oacute;n. Por lo tanto, una &lt;em&gt;referencia&lt;/em&gt; es un &lt;em&gt;valor&lt;/em&gt; cuando se representa, porque una referencia es un valor que debe procesarse (a nivel de lenguaje).</target>
        </trans-unit>
        <trans-unit id="58d4de45900cd3a103d99c18d12234d5bb3d377d" translate="yes" xml:space="preserve">
          <source>In general, Java has primitive types (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, etc) that are passed directly by value. Then Java has objects (everything that derives from &lt;code&gt;java.lang.Object&lt;/code&gt;). Objects are actually always handled through a reference (a reference being a pointer that you can't touch). That means that in effect, objects are passed by reference, as the references are normally not interesting. It does however mean that you cannot change which object is pointed to as the reference itself is passed by value.</source>
          <target state="translated">En general, Java tiene tipos primitivos ( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , etc.) que se pasan directamente por valor. Entonces Java tiene objetos (todo lo que deriva de &lt;code&gt;java.lang.Object&lt;/code&gt; ). Los objetos siempre se manejan a trav&amp;eacute;s de una referencia (una referencia es un puntero que no puede tocar). Eso significa que, en efecto, los objetos se pasan por referencia, ya que las referencias normalmente no son interesantes. Sin embargo, significa que no puede cambiar a qu&amp;eacute; objeto se apunta cuando la referencia en s&amp;iacute; misma se pasa por valor.</target>
        </trans-unit>
        <trans-unit id="45cfc45c3c6f01b610517a50ecd3388655190ac5" translate="yes" xml:space="preserve">
          <source>In java everything is reference, so when you have something like:
    &lt;code&gt;Point pnt1 = new Point(0,0);&lt;/code&gt; Java does following:</source>
          <target state="translated">En java todo es referencia, entonces cuando tienes algo como: &lt;code&gt;Point pnt1 = new Point(0,0);&lt;/code&gt; Java hace lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b73ac48cac4cc50104187760bd5de00365a5e1fd" translate="yes" xml:space="preserve">
          <source>In line #4 you can listen to the sound of silence</source>
          <target state="translated">En la línea 4 se puede escuchar el sonido del silencio</target>
        </trans-unit>
        <trans-unit id="f876ee91061153b58472e3caad886db2830e5e6c" translate="yes" xml:space="preserve">
          <source>In pascal, parameters passed-by-reference are called &quot;var parameters&quot;. In the procedure setToNil below, please note the keyword 'var' which precedes the parameter 'ptr'. When a pointer is passed to this procedure, it will be passed &lt;strong&gt;by reference&lt;/strong&gt;. Note the behavior: when this procedure sets ptr to nil (that's pascal speak for NULL), it will set the argument to nil--you can't do that in Java.</source>
          <target state="translated">En pascal, los par&amp;aacute;metros pasados ​​por referencia se denominan &quot;par&amp;aacute;metros var&quot;. En el siguiente procedimiento setToNil, tenga en cuenta la palabra clave 'var' que precede al par&amp;aacute;metro 'ptr'. Cuando se pasa un puntero a este procedimiento, se pasar&amp;aacute; &lt;strong&gt;por referencia&lt;/strong&gt; . Tenga en cuenta el comportamiento: cuando este procedimiento establece ptr en nil (eso es hablar pascal para NULL), establecer&amp;aacute; el argumento en nil; no puede hacerlo en Java.</target>
        </trans-unit>
        <trans-unit id="0e25ccb4e75ab4aec689df71744743c33feb9136" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;tricky&lt;/code&gt; method:</source>
          <target state="translated">En el m&amp;eacute;todo &lt;code&gt;tricky&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="556c40767e22c9d0e16c7d2e8fd66f4fc3765ab3" translate="yes" xml:space="preserve">
          <source>In the C++ example below I'm passing a &lt;strong&gt;pointer&lt;/strong&gt; to a null terminated string &lt;strong&gt;by reference&lt;/strong&gt;. And in the Java example below I'm passing a Java reference to a String (again, the same as a pointer to a String) by value. Notice the output in the comments.</source>
          <target state="translated">En el siguiente ejemplo de C ++, paso un &lt;strong&gt;puntero&lt;/strong&gt; a una cadena terminada en nulo &lt;strong&gt;por referencia&lt;/strong&gt; . Y en el siguiente ejemplo de Java, estoy pasando una referencia de Java a una Cadena (de nuevo, lo mismo que un puntero a una Cadena) por valor. Observe el resultado en los comentarios.</target>
        </trans-unit>
        <trans-unit id="eaf8d1084a66af0ad2274ebc5bf33bd05b487e6a" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;Fifi&lt;/code&gt; is the dog's name after call to &lt;code&gt;foo(aDog)&lt;/code&gt; because the object's name was set inside of &lt;code&gt;foo(...)&lt;/code&gt;. Any operations that &lt;code&gt;foo&lt;/code&gt; performs on &lt;code&gt;d&lt;/code&gt; are such that, for all practical purposes, they are performed on &lt;code&gt;aDog&lt;/code&gt;, but it is &lt;strong&gt;not&lt;/strong&gt; possible to change the value of the variable &lt;code&gt;aDog&lt;/code&gt; itself.</source>
          <target state="translated">En el ejemplo anterior, &lt;code&gt;Fifi&lt;/code&gt; es el nombre del perro despu&amp;eacute;s de llamar a &lt;code&gt;foo(aDog)&lt;/code&gt; porque el nombre del objeto se estableci&amp;oacute; dentro de &lt;code&gt;foo(...)&lt;/code&gt; . Cualquier operaci&amp;oacute;n que &lt;code&gt;foo&lt;/code&gt; realice en &lt;code&gt;d&lt;/code&gt; es tal que, a todos los efectos pr&amp;aacute;cticos, se realiza en &lt;code&gt;aDog&lt;/code&gt; , pero no es posible cambiar el valor de la variable &lt;code&gt;aDog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5f1d7ec3ad0697448f7bd1694b6d4a13eec5e90" translate="yes" xml:space="preserve">
          <source>In the case of primitive types, Java behaviour is simple: 
The value is copied in another instance of the primitive type.</source>
          <target state="translated">En el caso de los tipos primitivos,el comportamiento de Java es simple:El valor se copia en otra instancia del tipo primitivo.</target>
        </trans-unit>
        <trans-unit id="a522d3c2682539ae850f96edab1cea9361d6e16b" translate="yes" xml:space="preserve">
          <source>In the example above &lt;code&gt;aDog.getName()&lt;/code&gt; will still return &lt;code&gt;&quot;Max&quot;&lt;/code&gt;. The value &lt;code&gt;aDog&lt;/code&gt; within &lt;code&gt;main&lt;/code&gt; is not changed in the function &lt;code&gt;foo&lt;/code&gt; with the &lt;code&gt;Dog&lt;/code&gt;&lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; as the object reference is passed by value. If it were passed by reference, then the &lt;code&gt;aDog.getName()&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt; would return &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; after the call to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">En el ejemplo anterior, &lt;code&gt;aDog.getName()&lt;/code&gt; a&amp;uacute;n devolver&amp;aacute; &lt;code&gt;&quot;Max&quot;&lt;/code&gt; . El valor &lt;code&gt;aDog&lt;/code&gt; dentro de &lt;code&gt;main&lt;/code&gt; no cambia en la funci&amp;oacute;n &lt;code&gt;foo&lt;/code&gt; con el &lt;code&gt;Dog&lt;/code&gt; &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; ya que la referencia del objeto se pasa por valor. Si se pasara por referencia, &lt;code&gt;aDog.getName()&lt;/code&gt; en &lt;code&gt;main&lt;/code&gt; devolver&amp;iacute;a &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; despu&amp;eacute;s de la llamada a &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2767cb995f4a551872be17db0731dc32b9631113" translate="yes" xml:space="preserve">
          <source>In the following (please don't try to compile/execute this...):</source>
          <target state="translated">En lo siguiente (por favor no intente compilar-ejecutar esto...):</target>
        </trans-unit>
        <trans-unit id="3cc72807c6aa2f7787bc1d2e01e7b1a38a8163b3" translate="yes" xml:space="preserve">
          <source>In the image below you can see we have two reference variables(These are called pointers in C/C++, and I think that term makes it easier to understand this feature.) in the main method. Primitive and reference variables are kept in stack memory(left side in images below). array1 and array2 reference variables &quot;point&quot; (as C/C++ programmers call it) or reference to a and b arrays respectively, which are objects (values these reference variables hold are addresses of objects) in heap memory (right side in images below).</source>
          <target state="translated">En la imagen de abajo se puede ver que tenemos dos variables de referencia(Se llaman punteros en CC++,y creo que ese término facilita la comprensión de esta característica.)en el método principal.Las variables primitivas y de referencia se mantienen en la memoria de pila (lado izquierdo en las imágenes de abajo).Las variables de referencia de la matriz1 y la matriz2 &quot;punto&quot; (como lo llaman los programadores de CC++)o referencia a las matrices a y b respectivamente,que son objetos (los valores que estas variables de referencia mantienen son direcciones de objetos)en la memoria de pila (lado derecho en las imágenes de abajo).</target>
        </trans-unit>
        <trans-unit id="1db423d4e50678143cbe574c1553ab77c64d2ec7" translate="yes" xml:space="preserve">
          <source>Is Java “pass-by-reference” or “pass-by-value”</source>
          <target state="translated">¿Es Java &quot;paso-por-referencia&quot; o &quot;paso-por-valor&quot;</target>
        </trans-unit>
        <trans-unit id="da12241a17ef14fa43fa2b4e3155933518c0d4e0" translate="yes" xml:space="preserve">
          <source>It goes like this:</source>
          <target state="translated">Va así:</target>
        </trans-unit>
        <trans-unit id="98f312d82b1864aed2fd685327b3e2e9e1d88ca2" translate="yes" xml:space="preserve">
          <source>It's perfectly valid to &lt;em&gt;follow&lt;/em&gt; an address and change what's at the end of it; that does not change the variable, however.</source>
          <target state="translated">Es perfectamente v&amp;aacute;lido &lt;em&gt;seguir&lt;/em&gt; una direcci&amp;oacute;n y cambiar lo que est&amp;aacute; al final; eso no cambia la variable, sin embargo.</target>
        </trans-unit>
        <trans-unit id="f5635fa4e11fcd1915675b96d22971357494e751" translate="yes" xml:space="preserve">
          <source>Java always passes arguments &lt;em&gt;by value&lt;/em&gt;, NOT by reference.</source>
          <target state="translated">Java siempre pasa argumentos &lt;em&gt;por valor&lt;/em&gt; , NO por referencia.</target>
        </trans-unit>
        <trans-unit id="1e1d0bd5765a75bcdfc28bab135f3be439234c61" translate="yes" xml:space="preserve">
          <source>Java arguments are &lt;strong&gt;all passed by value&lt;/strong&gt; (the reference is copied when used by the method) :</source>
          <target state="translated">&lt;strong&gt;Todos los&lt;/strong&gt; argumentos de Java se &lt;strong&gt;pasan por valor&lt;/strong&gt; (la referencia se copia cuando la usa el m&amp;eacute;todo):</target>
        </trans-unit>
        <trans-unit id="d45e3643eb2a0c3cfaa96ee1ba516a58b305181b" translate="yes" xml:space="preserve">
          <source>Java has only pass by value. A very simple example to validate this.</source>
          <target state="translated">Java sólo tiene un valor de paso.Un ejemplo muy simple para validar esto.</target>
        </trans-unit>
        <trans-unit id="703fb214de1457e7f2c05c6d4fec19e41f4cb320" translate="yes" xml:space="preserve">
          <source>Java is a call by value</source>
          <target state="translated">Java es una llamada por valor</target>
        </trans-unit>
        <trans-unit id="3acd670af680bc110c036092f510ce1f098fa3fb" translate="yes" xml:space="preserve">
          <source>Java is always &lt;strong&gt;pass-by-value&lt;/strong&gt;. Unfortunately, when we pass the value of an object, we are passing the &lt;em&gt;reference&lt;/em&gt; to it.  This is confusing to beginners.</source>
          <target state="translated">Java siempre es &lt;strong&gt;paso por valor&lt;/strong&gt; . Desafortunadamente, cuando pasamos el valor de un objeto, le pasamos la &lt;em&gt;referencia&lt;/em&gt; . Esto es confuso para los principiantes.</target>
        </trans-unit>
        <trans-unit id="d999ec799d7d7e3e79463bd37bb62eacf6e25b10" translate="yes" xml:space="preserve">
          <source>Java is always pass by value, with no exceptions, &lt;strong&gt;ever&lt;/strong&gt;.</source>
          <target state="translated">Java siempre se pasa por valor, sin excepciones, &lt;strong&gt;nunca&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bffa033db8f0f65b32ac37222c7fbfe326862449" translate="yes" xml:space="preserve">
          <source>Java is pass by value according to the Java Language Specification:</source>
          <target state="translated">Java se pasa por valor según la Especificación del Lenguaje Java:</target>
        </trans-unit>
        <trans-unit id="5d5b05490570ab7df7923106ad5234571b0ba144" translate="yes" xml:space="preserve">
          <source>Java is pass-by-value because inside a method you can modify the referenced Object as much as you want but no matter how hard you try you'll never be able to modify the passed variable that will keep referencing (not p _ _ _ _ _ _ _) the same Object no matter what!</source>
          <target state="translated">Java es pass-by-value porque dentro de un método puedes modificar el Objeto referenciado tanto como quieras pero no importa cuánto lo intentes nunca podrás modificar la variable pasada que seguirá referenciando (no p______)el mismo Objeto sin importar qué!</target>
        </trans-unit>
        <trans-unit id="45192a707a26fe3bb2f92c6fbcb126e95a6e9b0e" translate="yes" xml:space="preserve">
          <source>Java only has the two types of passing: by value for built-in types, and by value of the pointer for object types.</source>
          <target state="translated">Java sólo tiene dos tipos de paso:por el valor de los tipos incorporados y por el valor del puntero para los tipos de objetos.</target>
        </trans-unit>
        <trans-unit id="529efc0a206bb877a5914af86dac2e005794eacf" translate="yes" xml:space="preserve">
          <source>Java pass &quot;a Java reference&quot; by value example</source>
          <target state="translated">Java pasa &quot;una referencia de Java&quot; por ejemplo de valor</target>
        </trans-unit>
        <trans-unit id="3a23cc46246cbf17c3306653ed35fc739dd92303" translate="yes" xml:space="preserve">
          <source>Java passes it parameters by value</source>
          <target state="translated">Java le pasa los parámetros por valor</target>
        </trans-unit>
        <trans-unit id="93f3aa9ad265f6adfea081d81b4ce0f2dd3364f2" translate="yes" xml:space="preserve">
          <source>Java passes references by value.</source>
          <target state="translated">Java pasa las referencias por valor.</target>
        </trans-unit>
        <trans-unit id="866018b39b9f976d7a4fda32831571acb3fe531a" translate="yes" xml:space="preserve">
          <source>Java passes references to objects by value.</source>
          <target state="translated">Java pasa referencias a los objetos por valor.</target>
        </trans-unit>
        <trans-unit id="cb688bcbe4d4a31366fbbe80d020a8f8c54e722d" translate="yes" xml:space="preserve">
          <source>Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, you cannot change where that pointer points.</source>
          <target state="translated">Java funciona exactamente como C.Puedes asignar un puntero,pasar el puntero a un método,seguir el puntero en el método y cambiar los datos a los que se apuntó.Sin embargo,no puedes cambiar a dónde apunta ese puntero.</target>
        </trans-unit>
        <trans-unit id="c3ceb58d38297bd42517df14fa453efa53f2e920" translate="yes" xml:space="preserve">
          <source>Just to show the contrast, compare the following &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C++&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; snippets:</source>
          <target state="translated">Solo para mostrar el contraste, compare los siguientes fragmentos de &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C ++&lt;/a&gt; y &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="76eed6720175d9c487a151ea0ec369ca6ff2bea0" translate="yes" xml:space="preserve">
          <source>Keeping in mind that &lt;code&gt;myDog&lt;/code&gt; is a &lt;em&gt;pointer&lt;/em&gt;, and not an actual &lt;code&gt;Dog&lt;/code&gt;, the answer is NO. &lt;code&gt;myDog&lt;/code&gt; still has the value 42; it's still pointing to the original &lt;code&gt;Dog&lt;/code&gt; (but note that because of line &quot;AAA&quot;, its name is now &quot;Max&quot; - still the same Dog; &lt;code&gt;myDog&lt;/code&gt;'s value has not changed.)</source>
          <target state="translated">Teniendo en cuenta que &lt;code&gt;myDog&lt;/code&gt; es un &lt;em&gt;puntero&lt;/em&gt; , y no un &lt;code&gt;Dog&lt;/code&gt; real, la respuesta es NO. &lt;code&gt;myDog&lt;/code&gt; todav&amp;iacute;a tiene el valor 42; sigue apuntando al &lt;code&gt;Dog&lt;/code&gt; original (pero tenga en cuenta que debido a la l&amp;iacute;nea &quot;AAA&quot;, su nombre ahora es &quot;Max&quot;, sigue siendo el mismo perro; el valor de &lt;code&gt;myDog&lt;/code&gt; no ha cambiado).</target>
        </trans-unit>
        <trans-unit id="2671b77ed672eeae8e1bb043ed9cddaa3c26b00f" translate="yes" xml:space="preserve">
          <source>Let me explain this through an &lt;a href=&quot;https://stackoverflow.com/a/9404727/597657&quot;&gt;example&lt;/a&gt;:</source>
          <target state="translated">D&amp;eacute;jame explicarte esto a trav&amp;eacute;s de un &lt;a href=&quot;https://stackoverflow.com/a/9404727/597657&quot;&gt;ejemplo&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1769d859356c9306da11a136d37d7bc840e8173d" translate="yes" xml:space="preserve">
          <source>Let me try to explain my understanding with the help of four examples. Java is pass-by-value, and not pass-by-reference</source>
          <target state="translated">Déjeme intentar explicarle mi comprensión con la ayuda de cuatro ejemplos.Java es paso-por-valor,y no paso-por-referencia</target>
        </trans-unit>
        <trans-unit id="667ee93519391efd5ef048789e42e4cd7eb32ed7" translate="yes" xml:space="preserve">
          <source>Let's consider reference types, the &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4&quot;&gt;Java Virtual Machine Specification&lt;/a&gt; states</source>
          <target state="translated">Consideremos los tipos de referencia, los estados de la &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4&quot;&gt;especificaci&amp;oacute;n de m&amp;aacute;quina virtual Java&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="017c2442a73e3b150be4f8d7101d3d565a83f364" translate="yes" xml:space="preserve">
          <source>Let's understand step by step:</source>
          <target state="translated">Entendamos paso a paso:</target>
        </trans-unit>
        <trans-unit id="5685f4b4e04daf5f5c1aa0517659cc4fb4246e59" translate="yes" xml:space="preserve">
          <source>Lets say we have a variable Foo, its &lt;strong&gt;Location&lt;/strong&gt; is at the 47th byte in memory and its &lt;strong&gt;Value&lt;/strong&gt; is 5. We have another variable &lt;strong&gt;Ref2Foo&lt;/strong&gt; which is at 223rd byte in memory, and its value will be 47. This Ref2Foo might be a technical variable, not explicitly created by the program. If you just look at 5 and 47 without any other information, you will see just two &lt;strong&gt;Values&lt;/strong&gt;.
If you use them as references then to reach to &lt;code&gt;5&lt;/code&gt; we have to travel:</source>
          <target state="translated">Digamos que tenemos una variable Foo, su &lt;strong&gt;ubicaci&amp;oacute;n&lt;/strong&gt; est&amp;aacute; en el byte 47 en la memoria y su &lt;strong&gt;valor&lt;/strong&gt; es 5. Tenemos otra variable &lt;strong&gt;Ref2Foo&lt;/strong&gt; que est&amp;aacute; en el 223 byte en la memoria, y su valor ser&amp;aacute; 47. Este Ref2Foo podr&amp;iacute;a ser una variable t&amp;eacute;cnica , no creado expl&amp;iacute;citamente por el programa. Si solo mira 5 y 47 sin ninguna otra informaci&amp;oacute;n, ver&amp;aacute; solo dos &lt;strong&gt;valores&lt;/strong&gt; . Si los usa como referencia, para llegar al &lt;code&gt;5&lt;/code&gt; tenemos que viajar:</target>
        </trans-unit>
        <trans-unit id="d50fff30ab03bcac896614280d7ce79d010333b1" translate="yes" xml:space="preserve">
          <source>Like so:</source>
          <target state="translated">Así:</target>
        </trans-unit>
        <trans-unit id="1cfac11915904016eed201cd17895ef142e7298c" translate="yes" xml:space="preserve">
          <source>Likewise:</source>
          <target state="translated">Likewise:</target>
        </trans-unit>
        <trans-unit id="5cd871265dfcea1f716cd6d1540a0775e084af34" translate="yes" xml:space="preserve">
          <source>Naturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.</source>
          <target state="translated">Naturalmente,pasar por valor una referencia a un objeto se parece mucho (y es indistinguible en la práctica)a pasar un objeto por referencia.</target>
        </trans-unit>
        <trans-unit id="74a399506f2951a7b197ec01ea8e798ce4122914" translate="yes" xml:space="preserve">
          <source>Next in the &lt;code&gt;tricky&lt;/code&gt; method</source>
          <target state="translated">Siguiente en el m&amp;eacute;todo &lt;code&gt;tricky&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c7f2f0ce70a51c735ee73784fc914a2704fd44b" translate="yes" xml:space="preserve">
          <source>Nitpicking on insignificant details, even languages that do pass-by-reference will pass values to functions, but those functions know that they have to use it for dereferencing purposes. This pass-the-reference-as-value is just hidden from the programmer because it is practically useless and the terminology is only &lt;em&gt;pass-by-reference&lt;/em&gt;.</source>
          <target state="translated">Analizando detalles insignificantes, incluso los lenguajes que hacen referencia pasar&amp;aacute;n valores a las funciones, pero esas funciones saben que tienen que usarlo para fines de referencia. Este paso de referencia como valor simplemente est&amp;aacute; oculto para el programador porque es pr&amp;aacute;cticamente in&amp;uacute;til y la terminolog&amp;iacute;a es solo &lt;em&gt;paso por referencia&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f39a1496ed9448598fdec7fa441d4eb247a6d515" translate="yes" xml:space="preserve">
          <source>No new instances of Person are created.</source>
          <target state="translated">No se crean nuevas instancias de Persona.</target>
        </trans-unit>
        <trans-unit id="5a3c28a6866958ddbd72e8e5bfcca8b47c170a56" translate="yes" xml:space="preserve">
          <source>No, it's not pass by reference.</source>
          <target state="translated">No,no es pasar por referencia.</target>
        </trans-unit>
        <trans-unit id="a2c2fa354963a9acfa4e9abfc392a844ec4c593d" translate="yes" xml:space="preserve">
          <source>Note: I am not pasting the code for &lt;code&gt;private class Student&lt;/code&gt;. The class definition for &lt;code&gt;Student&lt;/code&gt; is same as Example3.</source>
          <target state="translated">Nota: No estoy pegando el c&amp;oacute;digo para &lt;code&gt;private class Student&lt;/code&gt; . La definici&amp;oacute;n de clase para &lt;code&gt;Student&lt;/code&gt; es la misma que en Ejemplo3.</target>
        </trans-unit>
        <trans-unit id="922f6a86dea64e63a3edc02c1877ce2a3c46981e" translate="yes" xml:space="preserve">
          <source>Now feel free to hate me but note that given this &lt;strong&gt;there is no difference between passing primitive data types and Objects&lt;/strong&gt; when talking about method arguments.</source>
          <target state="translated">Ahora si&amp;eacute;ntase libre de odiarme, pero tenga en cuenta que, dado esto, &lt;strong&gt;no hay diferencia entre pasar tipos de datos primitivos y objetos&lt;/strong&gt; cuando se habla de argumentos de m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="69d2ccd64b25d43c28b50000e4e7f2b5a02a3236" translate="yes" xml:space="preserve">
          <source>Now let's think about what happens outside the method:</source>
          <target state="translated">Ahora pensemos en lo que sucede fuera del método:</target>
        </trans-unit>
        <trans-unit id="ff38daeae639f963939233f6e3fdce27295e1cf5" translate="yes" xml:space="preserve">
          <source>Now think of what an Object's reference/variable does/is:</source>
          <target state="translated">Ahora piensa en lo que hace la variable de referencia de un objeto:</target>
        </trans-unit>
        <trans-unit id="0e2ffb2ff2a00fd086483aeae2222dbc11a4d2c8" translate="yes" xml:space="preserve">
          <source>Now we have passed Foo to the method:</source>
          <target state="translated">Ahora hemos pasado a Foo al método:</target>
        </trans-unit>
        <trans-unit id="a68e19abd4296329735454d01ddb1f100edde052" translate="yes" xml:space="preserve">
          <source>Of course you can cut it short and just say that  &lt;strong&gt;Java is pass-by-value!&lt;/strong&gt;</source>
          <target state="translated">&amp;iexcl;Por supuesto, puede acortarlo y solo decir que &lt;strong&gt;Java es paso por valor!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e25bdd3d54506e9fcb400bfa35ebbf005d8293eb" translate="yes" xml:space="preserve">
          <source>Okay. First off, local primitives go on the stack. So this code:</source>
          <target state="translated">Está bien.En primer lugar,los primitivos locales van en la pila.Así que este código:</target>
        </trans-unit>
        <trans-unit id="8e109f9696197d944923c2e8918140789af777d2" translate="yes" xml:space="preserve">
          <source>One String gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier &lt;code&gt;hisName&lt;/code&gt;, since the address of the second String is the same as the first, no new String is created and no new heap space is allocated, but a new identifier is created on the stack. Then we call &lt;code&gt;shout()&lt;/code&gt;: a new stack frame is created and a new identifier, &lt;code&gt;name&lt;/code&gt; is created and assigned the address of the already-existing String.</source>
          <target state="translated">Se crea una cadena y se asigna espacio para ella en el mont&amp;oacute;n, y la direcci&amp;oacute;n de la cadena se almacena en la pila y se le da el identificador &lt;code&gt;hisName&lt;/code&gt; , ya que la direcci&amp;oacute;n de la segunda cadena es la misma que la primera, no se crea una nueva cadena y no se asigna nuevo espacio de almacenamiento din&amp;aacute;mico, pero se crea un nuevo identificador en la pila. Luego llamamos a &lt;code&gt;shout()&lt;/code&gt; : se crea un nuevo marco de pila y se crea un nuevo identificador, &lt;code&gt;name&lt;/code&gt; y se le asigna la direcci&amp;oacute;n de la Cadena ya existente.</target>
        </trans-unit>
        <trans-unit id="e9fbef27678eb892ee44cd57611d9c038d5ddbb8" translate="yes" xml:space="preserve">
          <source>Or from wikipedia, &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference&quot;&gt;on the subject of pass-by-reference&lt;/a&gt;</source>
          <target state="translated">O de wikipedia, &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference&quot;&gt;sobre el tema de la referencia de paso&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89050305305bcda692140fffe8f7276e92d157fe" translate="yes" xml:space="preserve">
          <source>Pass By Value</source>
          <target state="translated">Pasar por el valor</target>
        </trans-unit>
        <trans-unit id="7a52d2d617a0327ba951584e0dd74a3b60d0e2ee" translate="yes" xml:space="preserve">
          <source>Pass by value means the called functions' parameter will be a copy of
  the callers' passed argument.</source>
          <target state="translated">Pasar por valor significa que el parámetro de las funciones llamadas será una copia del argumento pasado de los llamantes.</target>
        </trans-unit>
        <trans-unit id="b05d82b9afa13c63a41c110afc8f23afc15f5eb7" translate="yes" xml:space="preserve">
          <source>Passing by reference means the called functions' parameter will be the
  same as the callers' passed argument (not the value, but the identity
  - the variable itself).</source>
          <target state="translated">Pasar por referencia significa que el parámetro de las funciones llamadas será el mismo que el argumento pasado por los llamantes (no el valor,sino la identidad-la propia variable).</target>
        </trans-unit>
        <trans-unit id="cc7d7eee18bf03fb193a57aacc259b0ecd56568e" translate="yes" xml:space="preserve">
          <source>Passing references to arrays, instead of the array objects themselves, makes sense for performance reasons. Because everything in Java is passed by value, if array objects were passed,
a copy of each element would be passed. For large arrays, this would waste time and consume
considerable storage for the copies of the elements.</source>
          <target state="translated">Pasar referencias a las matrices,en vez de a los objetos de las matrices en sí,tiene sentido por razones de rendimiento.Como todo en Java se pasa por valor,si se pasaran los objetos de la matriz,se pasaría una copia de cada elemento.En el caso de las matrices de gran tamaño,esto haría perder tiempo y consumiría un almacenamiento considerable para las copias de los elementos.</target>
        </trans-unit>
        <trans-unit id="8cfedebc2d3a9442c6efa9728f78e57e537d2cba" translate="yes" xml:space="preserve">
          <source>Primitive values are also defined in the Java Virtual Machine Specification, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3&quot;&gt;here&lt;/a&gt;. The value of the type is the corresponding integral or floating point value, encoded appropriately (8, 16, 32, 64, etc. bits).</source>
          <target state="translated">Los valores primitivos tambi&amp;eacute;n se definen en la Especificaci&amp;oacute;n de m&amp;aacute;quina virtual Java, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3&quot;&gt;aqu&amp;iacute;&lt;/a&gt; . El valor del tipo es el valor de punto flotante o integral correspondiente, codificado apropiadamente (8, 16, 32, 64, etc. bits).</target>
        </trans-unit>
        <trans-unit id="20eebab5a449d25f5d3973bfc691fbe91ed1dda9" translate="yes" xml:space="preserve">
          <source>Primitive wrapper classes and Strings are immutable so any example using those types will not work the same as other types/objects.</source>
          <target state="translated">Las clases de envoltorios primitivos y las cadenas son inmutables,por lo que cualquier ejemplo que utilice esos tipos no funcionará igual que otros tipos de objetos.</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="45c34d3cd3e583ca8c9f01b7fd4364b4be14d83e" translate="yes" xml:space="preserve">
          <source>References &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;pnt2&lt;/code&gt; are &lt;strong&gt;passed by value&lt;/strong&gt; to the tricky method, which means that now yours references &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;pnt2&lt;/code&gt; have their &lt;code&gt;copies&lt;/code&gt; named &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;.So &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;arg1&lt;/code&gt;&lt;em&gt;points&lt;/em&gt; to the same object. (Same for the &lt;code&gt;pnt2&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;)</source>
          <target state="translated">Las referencias &lt;code&gt;pnt1&lt;/code&gt; y &lt;code&gt;pnt2&lt;/code&gt; se &lt;strong&gt;pasan por valor&lt;/strong&gt; al m&amp;eacute;todo complicado, lo que significa que ahora sus referencias &lt;code&gt;pnt1&lt;/code&gt; y &lt;code&gt;pnt2&lt;/code&gt; tienen sus &lt;code&gt;copies&lt;/code&gt; llamadas &lt;code&gt;arg1&lt;/code&gt; y &lt;code&gt;arg2&lt;/code&gt; . As&amp;iacute; que &lt;code&gt;pnt1&lt;/code&gt; y &lt;code&gt;arg1&lt;/code&gt; &lt;em&gt;apuntan&lt;/em&gt; al mismo objeto. (Lo mismo para el &lt;code&gt;pnt2&lt;/code&gt; y &lt;code&gt;arg2&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bf00fec3f22ea28e6b86a2ef752102c2e7ecb750" translate="yes" xml:space="preserve">
          <source>Second, we need to know what Java uses in its method invocations. The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java Language Specification&lt;/a&gt; states</source>
          <target state="translated">En segundo lugar, necesitamos saber qu&amp;eacute; utiliza Java en sus invocaciones de m&amp;eacute;todos. Los estados de la &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;especificaci&amp;oacute;n del lenguaje Java&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6c9ce881b6078a8902ba5543f51a3b0d775b3fa" translate="yes" xml:space="preserve">
          <source>Several people have written comments which seem to indicate that either they are not looking at my examples or they don't get the c++ example. Not sure where the disconnect is, but guessing the c++ example is not clear. I'm posting the same example in pascal because I think pass-by-reference looks cleaner in pascal, but I could be wrong. I might just be confusing people more; I hope not.</source>
          <target state="translated">Varias personas han escrito comentarios que parecen indicar que o bien no están mirando mis ejemplos o bien no reciben el ejemplo de c++.No estoy seguro de dónde está la desconexión,pero adivinar el ejemplo de c++no está claro.Estoy posteando el mismo ejemplo en pascal porque creo que la referencia de paso se ve más limpia en pascal,pero podría estar equivocado.Podría estar confundiendo más a la gente;espero que no.</target>
        </trans-unit>
        <trans-unit id="26c0ca793e8f7074d3f8c82877440040dbf9523b" translate="yes" xml:space="preserve">
          <source>So</source>
          <target state="translated">So</target>
        </trans-unit>
        <trans-unit id="ff40a96c97ebf788e8cecb055d7af4f991b2166d" translate="yes" xml:space="preserve">
          <source>So after executing method &lt;code&gt;tricky&lt;/code&gt;, when you return to &lt;code&gt;main&lt;/code&gt;, you have this situation:</source>
          <target state="translated">Entonces, despu&amp;eacute;s de ejecutar un m&amp;eacute;todo &lt;code&gt;tricky&lt;/code&gt; , cuando regresas a &lt;code&gt;main&lt;/code&gt; , tienes esta situaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="7ef4027a6bbd3300b48fbef4e07ab82867158511" translate="yes" xml:space="preserve">
          <source>So how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java &lt;strong&gt;never&lt;/strong&gt; provides direct access to the values of &lt;em&gt;objects themselves&lt;/em&gt;, in &lt;em&gt;any&lt;/em&gt; circumstances. The only access to objects is through a &lt;em&gt;reference&lt;/em&gt; to that object. Because Java objects are &lt;em&gt;always&lt;/em&gt; accessed through a reference, rather than directly, it is common to talk about fields and variables &lt;em&gt;and method arguments&lt;/em&gt; as being &lt;em&gt;objects&lt;/em&gt;, when pedantically they are only &lt;em&gt;references to objects&lt;/em&gt;. &lt;strong&gt;The confusion stems from this (strictly speaking, incorrect) change in nomenclature.&lt;/strong&gt;</source>
          <target state="translated">Entonces, &amp;iquest;c&amp;oacute;mo es que cualquiera puede estar confundido por esto y creer que Java se pasa por referencia, o cree que tiene un ejemplo de Java que act&amp;uacute;a como pase por referencia? El punto clave es que Java &lt;strong&gt;nunca&lt;/strong&gt; proporciona acceso directo a los valores de los &lt;em&gt;objetos&lt;/em&gt; , en &lt;em&gt;ninguna&lt;/em&gt; circunstancia. El &amp;uacute;nico acceso a los objetos es a trav&amp;eacute;s de una &lt;em&gt;referencia&lt;/em&gt; a ese objeto. Debido a que &lt;em&gt;siempre se&lt;/em&gt; accede a los objetos Java a trav&amp;eacute;s de una referencia, en lugar de hacerlo directamente, es com&amp;uacute;n hablar de campos y variables &lt;em&gt;y argumentos de m&amp;eacute;todos&lt;/em&gt; como &lt;em&gt;objetos&lt;/em&gt; , cuando pedag&amp;oacute;gicamente solo son &lt;em&gt;referencias a objetos&lt;/em&gt; . &lt;strong&gt;La confusi&amp;oacute;n surge de este cambio (estrictamente hablando, incorrecto) en la nomenclatura.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49f6e297927d971ba38fa95bec79322b3f55ffe8" translate="yes" xml:space="preserve">
          <source>So if you have &lt;code&gt;doSomething(foo)&lt;/code&gt; and &lt;code&gt;public void doSomething(Foo foo) { .. }&lt;/code&gt; the two Foos have copied &lt;em&gt;references&lt;/em&gt; that point to the same objects.</source>
          <target state="translated">Entonces, si tiene &lt;code&gt;doSomething(foo)&lt;/code&gt; y &lt;code&gt;public void doSomething(Foo foo) { .. }&lt;/code&gt; los dos Foos han copiado &lt;em&gt;referencias&lt;/em&gt; que apuntan a los mismos objetos.</target>
        </trans-unit>
        <trans-unit id="7b4e3120f9e0ef1963e36854a84df92466e8bd5c" translate="yes" xml:space="preserve">
          <source>So in short and in Java's own terminology, Java is &lt;em&gt;pass-by-value&lt;/em&gt; where &lt;em&gt;value&lt;/em&gt; can be: either a &lt;strong&gt;real value&lt;/strong&gt; or a &lt;strong&gt;value&lt;/strong&gt; that is a representation of a &lt;strong&gt;reference&lt;/strong&gt;.</source>
          <target state="translated">En resumen, y en la propia terminolog&amp;iacute;a de Java, Java es &lt;em&gt;paso por valor&lt;/em&gt; donde el &lt;em&gt;valor&lt;/em&gt; puede ser: un &lt;strong&gt;valor real&lt;/strong&gt; o un &lt;strong&gt;valor&lt;/strong&gt; que es una representaci&amp;oacute;n de una &lt;strong&gt;referencia&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="634936d81c1689fe91adca4c5ee1e8fd9d96a1ad" translate="yes" xml:space="preserve">
          <source>So it assigns (or binds) the value of the argument to the corresponding parameter variable.</source>
          <target state="translated">Así que asigna (o vincula)el valor del argumento a la variable de parámetro correspondiente.</target>
        </trans-unit>
        <trans-unit id="f4945724933ec9be2092b5806b370216861c5eeb" translate="yes" xml:space="preserve">
          <source>So let's write all the things we have done at once now.</source>
          <target state="translated">Así que escribamos todas las cosas que hemos hecho de una vez.</target>
        </trans-unit>
        <trans-unit id="9a181e916502cbb03b3332b929a47423efcc6e84" translate="yes" xml:space="preserve">
          <source>So now, completely execution of program will be:</source>
          <target state="translated">Así que ahora,la ejecución completa del programa será:</target>
        </trans-unit>
        <trans-unit id="2a27627ea047cda38b06899780beb9ed096f3a7d" translate="yes" xml:space="preserve">
          <source>So you can't change the reference that gets passed in.</source>
          <target state="translated">Así que no puedes cambiar la referencia que se pasa.</target>
        </trans-unit>
        <trans-unit id="866237ea6abd1c73ce2cd72c6c84fc4749c1fab7" translate="yes" xml:space="preserve">
          <source>So you're just passing 3bad086a that it's the value of the reference.</source>
          <target state="translated">Así que estás pasando 3bad086a que es el valor de la referencia.</target>
        </trans-unit>
        <trans-unit id="20fd78625a8ef72411c2e7f9cc21dcf94a034a8f" translate="yes" xml:space="preserve">
          <source>So, if we say</source>
          <target state="translated">Así que,si decimos</target>
        </trans-unit>
        <trans-unit id="90e7e6de17ceea609c89967f7448b462eff52e91" translate="yes" xml:space="preserve">
          <source>So, value, reference? You say &quot;potato&quot;.</source>
          <target state="translated">Entonces,¿valor,referencia? Dices &quot;patata&quot;.</target>
        </trans-unit>
        <trans-unit id="daa39b66ef2d8fde4dcb582dccfc4335693ba86f" translate="yes" xml:space="preserve">
          <source>So, what gets passed in when you call a method? If you pass in an object, what you're actually passing in is the address of the object. Some might say the &quot;value&quot; of the address, and some say it's just a reference to the object. This is the genesis of the holy war between &quot;reference&quot; and &quot;value&quot; proponents. What you call it isn't as important as that you understand that what's getting passed in is the address to the object.</source>
          <target state="translated">Entonces,¿qué se pasa cuando llamas a un método? Si pasas un objeto,lo que realmente pasas es la dirección del objeto.Algunos podrían decir que el &quot;valor&quot; de la dirección,y otros dicen que es sólo una referencia al objeto.Esta es la génesis de la guerra santa entre los partidarios de la &quot;referencia&quot; y el &quot;valor&quot;.Lo que se llama no es tan importante como que se entienda que lo que se pasa es la dirección del objeto.</target>
        </trans-unit>
        <trans-unit id="f804721f9a225c83f9f775159b5195bbbe96d25c" translate="yes" xml:space="preserve">
          <source>So, when calling a method</source>
          <target state="translated">Así que,cuando se llama a un método</target>
        </trans-unit>
        <trans-unit id="ee33b63e4d6f38a1051e9487d652448deba03bf9" translate="yes" xml:space="preserve">
          <source>Some excerpts from &lt;strong&gt;&quot;THE Java Programming Language&quot;&lt;/strong&gt; by Ken Arnold, &lt;strong&gt;James Gosling (the guy who invented Java)&lt;/strong&gt;, and David Holmes, chapter 2, section 2.6.5</source>
          <target state="translated">Algunos extractos de &lt;strong&gt;&quot;THE Java Programming Language&quot;&lt;/strong&gt; de Ken Arnold, &lt;strong&gt;James Gosling (el tipo que invent&amp;oacute; Java)&lt;/strong&gt; y David Holmes, cap&amp;iacute;tulo 2, secci&amp;oacute;n 2.6.5</target>
        </trans-unit>
        <trans-unit id="94b891247159e943febc8cc22cd31a1491a1cb74" translate="yes" xml:space="preserve">
          <source>Some people say primitive types and 'String' are 'pass by value'
  and objects are 'pass by reference'.</source>
          <target state="translated">Algunas personas dicen que los tipos primitivos y &quot;Cuerda&quot; son &quot;pasar por valor&quot; y los objetos son &quot;pasar por referencia&quot;.</target>
        </trans-unit>
        <trans-unit id="ae7f019ce2b7e1139c2214fe199d7dfbfd4ace30" translate="yes" xml:space="preserve">
          <source>Sometimes Java can give the illusion of pass by reference. Let's see how it works by using the example below:</source>
          <target state="translated">A veces Java puede dar la ilusión de pasar por referencia.Veamos cómo funciona utilizando el ejemplo siguiente:</target>
        </trans-unit>
        <trans-unit id="523c67e3005e1319a95db986a92e473eccf87a79" translate="yes" xml:space="preserve">
          <source>Sometimes you want to use the same pattern in Java, but you can't; at least not directly. Instead you could do something like this:</source>
          <target state="translated">A veces quieres usar el mismo patrón en Java,pero no puedes;al menos no directamente.En su lugar podrías hacer algo como esto:</target>
        </trans-unit>
        <trans-unit id="aa1ec5d7dc80c372add31e690fc9b6adfcbed953" translate="yes" xml:space="preserve">
          <source>Step one please erase from your mind that word that starts with 'p' &quot;_ _ _ _ _ _ _&quot;, especially if you come from other programming languages. Java and 'p' cannot be written in the same book, forum, or even txt.</source>
          <target state="translated">Paso uno,por favor,borra de tu mente esa palabra que empieza por 'p' &quot;_______&quot;,especialmente si vienes de otros lenguajes de programación.Java y 'p' no pueden ser escritas en el mismo libro,foro,o incluso txt.</target>
        </trans-unit>
        <trans-unit id="e060e28388e7368925caf9e91796e5aa4d2b1720" translate="yes" xml:space="preserve">
          <source>Step two remember that when you pass an Object into a method you're passing the Object reference and not the Object itself.</source>
          <target state="translated">Paso dos,recuerda que cuando pasas un objeto a un método estás pasando la referencia del objeto y no el objeto en sí mismo.</target>
        </trans-unit>
        <trans-unit id="6207dc3dd0572f9c051d767720eb5104f3fb4f3c" translate="yes" xml:space="preserve">
          <source>Strict &lt;em&gt;pass-by-value&lt;/em&gt; is also useless, it would mean that a 100 Mbyte array should have to be copied every time we call a method with the array as argument, therefore Java cannot be stricly pass-by-value. Every language would pass a reference to this huge array (as a value) and either employs copy-on-write mechanism if that array can be changed locally inside the method or allows the method (as Java does) to modify the array globally (from the caller's view) and a few languages allows to modify the Value of the reference itself.</source>
          <target state="translated">El &lt;em&gt;paso por valor&lt;/em&gt; estricto tambi&amp;eacute;n es in&amp;uacute;til, significar&amp;iacute;a que una matriz de 100 Mbytes deber&amp;iacute;a copiarse cada vez que llamamos a un m&amp;eacute;todo con la matriz como argumento, por lo tanto, Java no puede pasar estrictamente por valor. Cada idioma pasar&amp;iacute;a una referencia a esta gran matriz (como valor) y emplea un mecanismo de copia en escritura si esa matriz se puede cambiar localmente dentro del m&amp;eacute;todo o permite que el m&amp;eacute;todo (como lo hace Java) modifique la matriz globalmente (desde la vista del llamante) y algunos idiomas permiten modificar el valor de la referencia en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="f14bbbb986af6b74a6c4b3c0e5664a7de3e563b7" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;code&gt;Dog&lt;/code&gt; object resides at memory address 42. This means we pass 42 to the method.</source>
          <target state="translated">Supongamos que el objeto &lt;code&gt;Dog&lt;/code&gt; reside en la direcci&amp;oacute;n de memoria 42. Esto significa que pasamos 42 al m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="8d27872f4e15932b79d2264d4a0cddb9e2521238" translate="yes" xml:space="preserve">
          <source>Take this to C++, and we have references. References are basically (in this context) syntactic sugar that hide the pointer part of the equation: &lt;code&gt;void foo(int &amp;amp;x)&lt;/code&gt; is called by &lt;code&gt;foo(a)&lt;/code&gt;, where the compiler itself knows that it is a reference and the address of the non-reference &lt;code&gt;a&lt;/code&gt; should be passed. In Java, all variables referring to objects are actually of reference type, in effect forcing call by reference for most intends and purposes without the fine grained control (and complexity) afforded by, for example, C++.</source>
          <target state="translated">Lleva esto a C ++, y tenemos referencias. Las referencias son b&amp;aacute;sicamente (en este contexto) az&amp;uacute;car sint&amp;aacute;ctico que oculta la parte del puntero de la ecuaci&amp;oacute;n: &lt;code&gt;void foo(int &amp;amp;x)&lt;/code&gt; es llamado por &lt;code&gt;foo(a)&lt;/code&gt; , donde el compilador mismo sabe que es una referencia y la direcci&amp;oacute;n de se debe pasar la referencia &lt;code&gt;a&lt;/code&gt; . En Java, todas las variables que se refieren a objetos son en realidad de tipo de referencia, en efecto forzando la llamada por referencia para la mayor&amp;iacute;a de los prop&amp;oacute;sitos y prop&amp;oacute;sitos sin el control (y la complejidad) de grano fino que ofrece, por ejemplo, C ++.</target>
        </trans-unit>
        <trans-unit id="1f5466dbc044f44594c32f9e6b1b8a7351767c72" translate="yes" xml:space="preserve">
          <source>That's the reason only Java developers have issue with this. They look at the word &quot;reference&quot; and think they know exactly what that means, so they don't even bother to consider the opposing argument.</source>
          <target state="translated">Esa es la razón por la que sólo los desarrolladores de Java tienen problemas con esto.Miran la palabra &quot;referencia&quot; y piensan que saben exactamente lo que significa,así que ni siquiera se molestan en considerar el argumento contrario.</target>
        </trans-unit>
        <trans-unit id="c94098a38907257d1a6a763b38d1468647d923f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1&quot;&gt;Java Language Specification&lt;/a&gt; also states</source>
          <target state="translated">La &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1&quot;&gt;especificaci&amp;oacute;n del lenguaje Java&lt;/a&gt; tambi&amp;eacute;n establece</target>
        </trans-unit>
        <trans-unit id="079b195af1fa053069e0e9a1be334e5b752f52b4" translate="yes" xml:space="preserve">
          <source>The Java Spec says that everything in Java is pass-by-value. There is no such thing as &quot;pass-by-reference&quot; in Java.</source>
          <target state="translated">El Java Spec dice que todo en Java es un valor de paso.No existe tal cosa como &quot;paso-por-referencia&quot; en Java.</target>
        </trans-unit>
        <trans-unit id="fd7bc25c7313046e736eb3d62b656f193458641b" translate="yes" xml:space="preserve">
          <source>The Java programming language &lt;strong&gt;does not pass objects by reference; it&lt;/strong&gt;&lt;strong&gt;passes object references by value&lt;/strong&gt;. Because two copies of the same
  reference refer to the same actual object, changes made through one
  reference variable are visible through the other. There is exactly one
  parameter passing mode-&lt;strong&gt;pass by value&lt;/strong&gt;-and that helps keep things
  simple.</source>
          <target state="translated">El lenguaje de programaci&amp;oacute;n Java &lt;strong&gt;no pasa objetos por referencia;&lt;/strong&gt; &lt;strong&gt;pasa referencias de objeto por valor&lt;/strong&gt; . Debido a que dos copias de la misma referencia se refieren al mismo objeto real, los cambios realizados a trav&amp;eacute;s de una variable de referencia son visibles a trav&amp;eacute;s de la otra. Hay exactamente un modo de paso de par&amp;aacute;metros, pasar &lt;strong&gt;por valor,&lt;/strong&gt; y eso ayuda a simplificar las cosas.</target>
        </trans-unit>
        <trans-unit id="ea546a9da3076dcf69d6a878525afaefa3c2665d" translate="yes" xml:space="preserve">
          <source>The behaviour can appear different from primitive types: Because the copied object-variable contains the same address (to the same Object).
Object's &lt;strong&gt;content/members&lt;/strong&gt; might still be modified within a method and later access outside, giving the illusion that the (containing) Object itself was passed by reference.</source>
          <target state="translated">El comportamiento puede parecer diferente de los tipos primitivos: porque la variable objeto copiada contiene la misma direcci&amp;oacute;n (al mismo Objeto). El &lt;strong&gt;contenido / los miembros&lt;/strong&gt; del Objeto a&amp;uacute;n podr&amp;iacute;an modificarse dentro de un m&amp;eacute;todo y luego acceder al exterior, dando la ilusi&amp;oacute;n de que el Objeto (que contiene) se pas&amp;oacute; por referencia.</target>
        </trans-unit>
        <trans-unit id="f6f95a7e89d7fa53f741a6006a73b3f53dbfe98a" translate="yes" xml:space="preserve">
          <source>The changeName function above will never be able to modify the actual content (the bit values) of the passed reference. In other word changeName cannot make Person person refer to another Object.</source>
          <target state="translated">La función changeName anterior nunca podrá modificar el contenido real (los valores de los bits)de la referencia pasada.En otras palabras,changeName no puede hacer que una persona se refiera a otro objeto.</target>
        </trans-unit>
        <trans-unit id="d43a36b01a5a36e6a4fed6f955af9bd89a90e8e2" translate="yes" xml:space="preserve">
          <source>The crux of the matter is that the word &lt;em&gt;reference&lt;/em&gt; in the expression &quot;pass by reference&quot; means something completely different from the usual meaning of the word &lt;em&gt;reference&lt;/em&gt; in Java.</source>
          <target state="translated">El quid de la cuesti&amp;oacute;n es que la palabra &lt;em&gt;referencia&lt;/em&gt; en la expresi&amp;oacute;n &quot;pasar por referencia&quot; significa algo completamente diferente del significado habitual de la palabra &lt;em&gt;referencia&lt;/em&gt; en Java.</target>
        </trans-unit>
        <trans-unit id="d6413d6c252fab8253fe8c316fa9f97b12f5c04a" translate="yes" xml:space="preserve">
          <source>The distinction, or perhaps just the way I remember as I used to be under the same impression as the original poster is this: Java is always pass by value. All objects( in Java, anything except for primitives) in Java are references. These references are passed by value.</source>
          <target state="translated">La distinción,o tal vez sólo la forma en que recuerdo que solía estar bajo la misma impresión que el cartel original es esta:Java es siempre un valor de paso.Todos los objetos (en Java,cualquier cosa excepto los primitivos)en Java son referencias.Estas referencias se pasan por valor.</target>
        </trans-unit>
        <trans-unit id="e90dc2a7bcee6387a6415dbc06ec56f2e174cf42" translate="yes" xml:space="preserve">
          <source>The key to understanding this is that something like</source>
          <target state="translated">La clave para entender esto es que algo como</target>
        </trans-unit>
        <trans-unit id="c870634849690af62ce95dbaaffd653c3bdc1132" translate="yes" xml:space="preserve">
          <source>The output of this program is:</source>
          <target state="translated">El resultado de este programa es:</target>
        </trans-unit>
        <trans-unit id="914b3110e6efe55bce5c55f82df6a7638d0fa6d6" translate="yes" xml:space="preserve">
          <source>The term &quot;reference&quot; is a overloaded with two separate meanings. In Java it simply means a pointer, but in the context of &quot;Pass-by-reference&quot; it means a handle to the original variable which was passed in.</source>
          <target state="translated">El término &quot;referencia&quot; es una sobrecarga con dos significados separados.En Java significa simplemente un puntero,pero en el contexto de &quot;Pasar por referencia&quot; significa un mango a la variable original que se pasó.</target>
        </trans-unit>
        <trans-unit id="d685aec290065c3d070420033a198dff8941ecc8" translate="yes" xml:space="preserve">
          <source>The value of an argument (of some reference type) is a pointer to an object. Note that a variable, an invocation of a method with a reference type return type, and an instance creation expression (&lt;code&gt;new ...&lt;/code&gt;) all resolve to a reference type value.</source>
          <target state="translated">El valor de un argumento (de alg&amp;uacute;n tipo de referencia) es un puntero a un objeto. Tenga en cuenta que una variable, una invocaci&amp;oacute;n de un m&amp;eacute;todo con un tipo de referencia tipo de retorno y una expresi&amp;oacute;n de creaci&amp;oacute;n de instancia ( &lt;code&gt;new ...&lt;/code&gt; ) se resuelven en un valor de tipo de referencia.</target>
        </trans-unit>
        <trans-unit id="b9723eb7fef6befdaac82e1c6cd7ab277e54545d" translate="yes" xml:space="preserve">
          <source>The variable &lt;em&gt;person&lt;/em&gt; holding the address of the Object is passed to the function in line #3.</source>
          <target state="translated">La &lt;em&gt;persona&lt;/em&gt; variable &lt;em&gt;que&lt;/em&gt; posee la direcci&amp;oacute;n del Objeto se pasa a la funci&amp;oacute;n en la l&amp;iacute;nea # 3.</target>
        </trans-unit>
        <trans-unit id="9a827a692a5c5bbbe054c83be9d12f395ddfae3c" translate="yes" xml:space="preserve">
          <source>The variable &lt;em&gt;person&lt;/em&gt; is created in line #1 and it's null at the beginning.</source>
          <target state="translated">La &lt;em&gt;persona&lt;/em&gt; variable se crea en la l&amp;iacute;nea n. &amp;deg; 1 y es nula al principio.</target>
        </trans-unit>
        <trans-unit id="d211d018025495720be4d35b0fb0e965174108f6" translate="yes" xml:space="preserve">
          <source>The variable/reference &lt;em&gt;person&lt;/em&gt; is copied bit-by-bit and passed to &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; inside the function.</source>
          <target state="translated">La &lt;em&gt;persona&lt;/em&gt; variable / de referencia se copia bit por bit y se pasa a otra &lt;em&gt;referencia&lt;/em&gt; al &lt;em&gt;objeto&lt;/em&gt; dentro de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a6a7f9ad555d80ee9f46a19d1dc4de44b454dbba" translate="yes" xml:space="preserve">
          <source>There are already great answers that cover this. I wanted to make a small contribution by sharing a &lt;strong&gt;very simple example&lt;/strong&gt; (which will compile) contrasting the behaviors between Pass-by-reference in c++ and Pass-by-value in Java.</source>
          <target state="translated">Ya hay excelentes respuestas que cubren esto. Quer&amp;iacute;a hacer una peque&amp;ntilde;a contribuci&amp;oacute;n compartiendo un &lt;strong&gt;ejemplo muy simple&lt;/strong&gt; (que compilar&amp;aacute;) contrastando los comportamientos entre Pass-by-reference en c ++ y Pass-by-value en Java.</target>
        </trans-unit>
        <trans-unit id="dfab606767515e58a1e6d064ffb7613d99a953bf" translate="yes" xml:space="preserve">
          <source>There are three kinds of &lt;strong&gt;reference types&lt;/strong&gt;: class types, array types,
  and interface types. &lt;strong&gt;Their values are references to dynamically
  created class instances, arrays, or class instances or arrays that
  implement interfaces, respectively.&lt;/strong&gt;</source>
          <target state="translated">Hay tres tipos de tipos de &lt;strong&gt;referencia&lt;/strong&gt; : tipos de clase, tipos de matriz y tipos de interfaz. &lt;strong&gt;Sus valores son referencias a instancias de clase, matrices o instancias de clase o matrices creadas din&amp;aacute;micamente que implementan interfaces, respectivamente.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa2284d9a49a58f0919e69504baa39d271367e04" translate="yes" xml:space="preserve">
          <source>There's the key.</source>
          <target state="translated">Ahí está la llave.</target>
        </trans-unit>
        <trans-unit id="e1f460dd17e5cf9708ba41d056ae77c8a33b5f05" translate="yes" xml:space="preserve">
          <source>Think of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.</source>
          <target state="translated">Piense en los parámetros de referencia como si fueran alias de la variable pasada.Cuando se asigna ese alias,también lo es la variable que se pasó.</target>
        </trans-unit>
        <trans-unit id="d3a442ecb80bc2357c8302e2cfa37890d9a8f934" translate="yes" xml:space="preserve">
          <source>This happens because iA and iB are new local reference variables that have the same value of the passed references (they point to a and b respectively). So, trying to change the references of iA or iB will only change in the local scope and not outside of this method.</source>
          <target state="translated">Esto sucede porque iA y iB son nuevas variables de referencia locales que tienen el mismo valor de las referencias pasadas (apuntan a a y b respectivamente).Por lo tanto,tratar de cambiar las referencias de iA o iB sólo cambiará en el ámbito local y no fuera de este método.</target>
        </trans-unit>
        <trans-unit id="5eefcb95db3d521d55f45ddd3a85d502cf4cdc4f" translate="yes" xml:space="preserve">
          <source>This is how jump-tables work.</source>
          <target state="translated">Así es como funcionan las mesas de salto.</target>
        </trans-unit>
        <trans-unit id="6bf397e1d5e88f4359962543f1564d72392aa1a0" translate="yes" xml:space="preserve">
          <source>This section of the book has a great explanation of parameter passing in Java and of the distinction between pass-by-reference and pass-by-value and it's by the creator of Java. I would encourage anyone to read it, especially if you're still not convinced.</source>
          <target state="translated">Esta sección del libro tiene una gran explicación del paso de parámetros en Java y de la distinción entre paso por referencia y paso por valor y es del creador de Java.Animaría a cualquiera a leerlo,especialmente si aún no está convencido.</target>
        </trans-unit>
        <trans-unit id="f6f7ba733b2534ecc1ea818cdddfaf4dcf24537c" translate="yes" xml:space="preserve">
          <source>This typically means that the function can modify (i.e. assign to) the
  variable used as argument&amp;mdash;something that will be seen by its caller.</source>
          <target state="translated">Esto generalmente significa que la funci&amp;oacute;n puede modificar (es decir, asignar a) la variable utilizada como argumento, algo que ver&amp;aacute; la persona que llama.</target>
        </trans-unit>
        <trans-unit id="a24fd574548676d8a5fdf4e5d5e866b85294afa6" translate="yes" xml:space="preserve">
          <source>This will populate Hello World and not World Hello because in the swap function you use copys which have no impact on the references in the main. But if your objects are not immutable you can change it for example:</source>
          <target state="translated">Esto poblará el Mundo Hola y no el Mundo Hola porque en la función de intercambio se utilizan copias que no tienen impacto en las referencias de la principal.Pero si tus objetos no son inmutables puedes cambiarlos,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e505e393bf5f01ebb5d9bfa9244eb4fa82d49415" translate="yes" xml:space="preserve">
          <source>This will populate Hello World on the command line. If you change StringBuffer into String it will produce just Hello because String is immutable. For example:</source>
          <target state="translated">Esto poblará a Hello World en la línea de comando.Si cambias StringBuffer por String,producirá sólo Hello porque String es inmutable.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ecc09e1b426d0f3bbdde2b52d1275b4a9684b1cb" translate="yes" xml:space="preserve">
          <source>To make a long story short, &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; objects have some very peculiar properties.</source>
          <target state="translated">Para resumir, los objetos &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; tienen algunas propiedades muy peculiares.</target>
        </trans-unit>
        <trans-unit id="d8f2d10c7283892fc482b2460252534f2c951f8f" translate="yes" xml:space="preserve">
          <source>To understand this more clearly, consider the following example:</source>
          <target state="translated">Para entender esto más claramente,considere el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="4a3568015b17ba4456e0d1ce2a6b83da248a6190" translate="yes" xml:space="preserve">
          <source>Unlike some other languages, Java does not allow you to choose between pass-by-value and pass-by-reference&amp;mdash;all arguments are passed by value. A method call can pass two types of values to a method&amp;mdash;copies of primitive values (e.g., values of int and double) and copies of references to objects.</source>
          <target state="translated">A diferencia de otros lenguajes, Java no le permite elegir entre pasar por valor y pasar por referencia: todos los argumentos se pasan por valor. Una llamada a m&amp;eacute;todo puede pasar dos tipos de valores a un m&amp;eacute;todo: copias de valores primitivos (por ejemplo, valores de int y double) y copias de referencias a objetos.</target>
        </trans-unit>
        <trans-unit id="8379236c60a3ff28075f90353d681fa71cd1a5aa" translate="yes" xml:space="preserve">
          <source>Usually in Java &lt;em&gt;reference&lt;/em&gt; means a a &lt;em&gt;reference to an object&lt;/em&gt;. But the technical terms &lt;em&gt;pass by reference/value&lt;/em&gt; from programming language theory is talking about a &lt;em&gt;reference to the memory cell holding the variable&lt;/em&gt;, which is something completely different.</source>
          <target state="translated">Por lo general, en Java, &lt;em&gt;referencia&lt;/em&gt; significa una &lt;em&gt;referencia a un objeto&lt;/em&gt; . Pero los t&amp;eacute;rminos t&amp;eacute;cnicos &lt;em&gt;pasan por referencia / valor&lt;/em&gt; de la teor&amp;iacute;a del lenguaje de programaci&amp;oacute;n hablando de una &lt;em&gt;referencia a la celda de memoria que contiene la variable&lt;/em&gt; , que es algo completamente diferente.</target>
        </trans-unit>
        <trans-unit id="189b909d14e035d9439146930c7bf76ee3ba35f1" translate="yes" xml:space="preserve">
          <source>We have another reference variable in reverseArray method (array2) that points to an array c. If we were to say</source>
          <target state="translated">Tenemos otra variable de referencia en el método reverseArray (array2)que apunta a un array c.Si dijéramos</target>
        </trans-unit>
        <trans-unit id="df89229a206448022bc5ed3d58cbdd5121102868" translate="yes" xml:space="preserve">
          <source>What happens?</source>
          <target state="translated">¿Qué es lo que pasa?</target>
        </trans-unit>
        <trans-unit id="2721876ca410fad542be9395684b871758604935" translate="yes" xml:space="preserve">
          <source>What is the explanation?</source>
          <target state="translated">¿Cuál es la explicación?</target>
        </trans-unit>
        <trans-unit id="c6c48753b57b8c36067f08152d304ac38b370fa1" translate="yes" xml:space="preserve">
          <source>What that means, is when you have</source>
          <target state="translated">Lo que significa,es que cuando tienes</target>
        </trans-unit>
        <trans-unit id="b82d13a18500a976024ec3aaa69437e0d2e0bcb9" translate="yes" xml:space="preserve">
          <source>When a method modifies a primitive-type parameter, changes to the parameter have no effect on the original argument value in the calling method.</source>
          <target state="translated">Cuando un método modifica un parámetro de tipo primitivo,los cambios en el parámetro no tienen efecto sobre el valor del argumento original en el método de llamada.</target>
        </trans-unit>
        <trans-unit id="47a4b97547a431dafab08418cf4ef38d6006e62e" translate="yes" xml:space="preserve">
          <source>When it comes to objects, objects themselves cannot be passed to methods. So we pass the address of the object which is held in the reference variable.</source>
          <target state="translated">Cuando se trata de objetos,los objetos en sí no pueden pasar a los métodos.Así que pasamos la dirección del objeto que se mantiene en la variable de referencia.</target>
        </trans-unit>
        <trans-unit id="42a98879de2bf7e9712995f5e8ec5b041e9c310b" translate="yes" xml:space="preserve">
          <source>When passing arguments to a method &lt;strong&gt;you ARE NOT passing the reference variable, but a copy of the bits in the reference variable&lt;/strong&gt;. Something like this: 3bad086a. 3bad086a represents a way to get to the passed object.</source>
          <target state="translated">Al pasar argumentos a un m&amp;eacute;todo &lt;strong&gt;, NO EST&amp;Aacute; pasando la variable de referencia, sino una copia de los bits en la variable de referencia&lt;/strong&gt; . Algo como esto: 3bad086a. 3bad086a representa una forma de llegar al objeto pasado.</target>
        </trans-unit>
        <trans-unit id="26b0a49f4378f6ec3b7ac0d3ca02eabd027e1846" translate="yes" xml:space="preserve">
          <source>When passing reference t to the function it will not directly pass the actual reference value of object test,  but it will create a copy of t and then pass it to the function. Since it is &lt;strong&gt;passing by value&lt;/strong&gt;, it passes a copy of the variable rather than the actual reference of it. Since we said the value of t was &lt;code&gt;0x100234&lt;/code&gt;, both t and f will have the same value and hence they will point to the same object.</source>
          <target state="translated">Al pasar la referencia t a la funci&amp;oacute;n, no pasar&amp;aacute; directamente el valor de referencia real de la prueba de objeto, pero crear&amp;aacute; una copia de t y luego la pasar&amp;aacute; a la funci&amp;oacute;n. Como est&amp;aacute; &lt;strong&gt;pasando por valor&lt;/strong&gt; , pasa una copia de la variable en lugar de la referencia real de la misma. Como dijimos que el valor de t era &lt;code&gt;0x100234&lt;/code&gt; , tanto t como f tendr&amp;aacute;n el mismo valor y, por lo tanto, apuntar&amp;aacute;n al mismo objeto.</target>
        </trans-unit>
        <trans-unit id="db86d10509b05e8bc49df8c7cd3d9cada5dd82ab" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the
  actual argument expressions initialize newly created parameter
  variables, each of the declared type, before execution of the body of
  the method or constructor.&lt;/strong&gt; The Identifier that appears in the
  DeclaratorId may be used as a simple name in the body of the method or
  constructor to refer to the formal parameter.</source>
          <target state="translated">Cuando se invoca el m&amp;eacute;todo o el constructor (&amp;sect;15.12), &lt;strong&gt;los valores de las expresiones de argumento reales inicializan las variables de par&amp;aacute;metro reci&amp;eacute;n creadas, cada una del tipo declarado, antes de la ejecuci&amp;oacute;n del cuerpo del m&amp;eacute;todo o constructor.&lt;/strong&gt; El Identificador que aparece en el DeclaratorId puede usarse como un nombre simple en el cuerpo del m&amp;eacute;todo o constructor para referirse al par&amp;aacute;metro formal.</target>
        </trans-unit>
        <trans-unit id="8b67851b479dc283a6f950e2733c899590974221" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the
  actual argument expressions initialize newly created parameter
  variables&lt;/strong&gt;, each of the declared type, before execution of the body of
  the method or constructor.</source>
          <target state="translated">Cuando se invoca el m&amp;eacute;todo o el constructor (&amp;sect;15.12), &lt;strong&gt;los valores de las expresiones de argumento reales inicializan las variables de par&amp;aacute;metro reci&amp;eacute;n creadas&lt;/strong&gt; , cada una del tipo declarado, antes de la ejecuci&amp;oacute;n del cuerpo del m&amp;eacute;todo o constructor.</target>
        </trans-unit>
        <trans-unit id="2d221d1e03c75efd20f3411a07f7d84f428d8be4" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the actual argument expressions initialize newly created parameter variables&lt;/strong&gt;, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1&quot;&gt;formal parameter&lt;/a&gt;.</source>
          <target state="translated">Cuando se invoca el m&amp;eacute;todo o el constructor (&amp;sect;15.12), &lt;strong&gt;los valores de las expresiones de argumento reales inicializan las variables de par&amp;aacute;metro reci&amp;eacute;n creadas&lt;/strong&gt; , cada una del tipo declarado, antes de la ejecuci&amp;oacute;n del cuerpo del m&amp;eacute;todo o constructor. El Identificador que aparece en el DeclaratorId puede usarse como un nombre simple en el cuerpo del m&amp;eacute;todo o constructor para referirse al &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1&quot;&gt;par&amp;aacute;metro formal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9aee34f3d95b06bea3cb4049aac2fc385dba277b" translate="yes" xml:space="preserve">
          <source>When you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are against the word &quot;pointer&quot;. Whatever. Just know that the address of the object goes on the stack.</source>
          <target state="translated">Cuando declaras e instanciar un objeto.El objeto real va en el montón.¿Qué va en el montón? La dirección del objeto en el montón.Los programadores de C++llamarían a esto un puntero,pero algunos desarrolladores de Java están en contra de la palabra &quot;puntero&quot;.Lo que sea.Sólo debes saber que la dirección del objeto va en la pila.</target>
        </trans-unit>
        <trans-unit id="28b1f1b3dfbb6a4aedcea3dba4b14239a6b023ba" translate="yes" xml:space="preserve">
          <source>Which means, java creates a copy of the passed parameters before executing a method. Like most people who studied compilers in college, I used &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201100886&quot;&gt;&quot;The Dragon Book&quot;&lt;/a&gt; which is &lt;strong&gt;THE&lt;/strong&gt; compilers book. It has a good description of &quot;Call-by-value&quot; and &quot;Call-by-Reference&quot; in Chapter 1. The Call-by-value description matches up with Java Specs exactly.</source>
          <target state="translated">Lo que significa que Java crea una copia de los par&amp;aacute;metros pasados ​​antes de ejecutar un m&amp;eacute;todo. Como la mayor&amp;iacute;a de las personas que estudiaron compiladores en la universidad, us&amp;eacute; &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201100886&quot;&gt;&quot;The Dragon Book&quot;,&lt;/a&gt; que es &lt;strong&gt;EL&lt;/strong&gt; libro de compiladores. Tiene una buena descripci&amp;oacute;n de &quot;Llamada por valor&quot; y &quot;Llamada por referencia&quot; en el Cap&amp;iacute;tulo 1. La descripci&amp;oacute;n de Llamada por valor coincide exactamente con las especificaciones Java.</target>
        </trans-unit>
        <trans-unit id="0dcbcbf7f981b706be204f899221bd4d6394bba1" translate="yes" xml:space="preserve">
          <source>Will this throw a &lt;code&gt;NullPointerException&lt;/code&gt;? No, because it only passes a copy of the reference. 
In the case of passing by reference, it could have thrown a &lt;code&gt;NullPointerException&lt;/code&gt;, as seen below:</source>
          <target state="translated">&amp;iquest;Esto arrojar&amp;aacute; una &lt;code&gt;NullPointerException&lt;/code&gt; ? No, porque solo pasa una copia de la referencia. En el caso de pasar por referencia, podr&amp;iacute;a haber arrojado una &lt;code&gt;NullPointerException&lt;/code&gt; , como se ve a continuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a28f32f5173460812904146e506dc73421a481d8" translate="yes" xml:space="preserve">
          <source>You always pass a copy of the bits of the value of the reference!</source>
          <target state="translated">¡Siempre se pasa una copia de los bits del valor de la referencia!</target>
        </trans-unit>
        <trans-unit id="a3dc507f44237c76ec4ef1ec8e4c68370d0b3167" translate="yes" xml:space="preserve">
          <source>You can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:</source>
          <target state="translated">Nunca se puede pasar por referencia en Java,y una de las maneras que es obvia es cuando se quiere devolver más de un valor de una llamada de método.Considera el siguiente fragmento de código en C++:</target>
        </trans-unit>
        <trans-unit id="02c7b73324c917e7dbe1ca63e76c51d7ead60641" translate="yes" xml:space="preserve">
          <source>You could also assign value of array2 in main to array1. array1 would start pointing to b.</source>
          <target state="translated">También podrías asignar el valor de la matriz 2 en principal a la matriz 1.La matriz 1 empezaría a apuntar a b.</target>
        </trans-unit>
        <trans-unit id="6b4f593c12270cbc6715abff6481a0a796758bb7" translate="yes" xml:space="preserve">
          <source>You should note that when the parameter is an object reference, it is
  the object reference-not the object itself-that is &lt;strong&gt;passed &quot;by value&quot;&lt;/strong&gt;.</source>
          <target state="translated">Debe tener en cuenta que cuando el par&amp;aacute;metro es una referencia de objeto, es la referencia del objeto, no el objeto en s&amp;iacute;, lo que se &lt;strong&gt;pasa &quot;por valor&quot;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fc75d6d2c095fd5d227713114c34ed1913a0b634" translate="yes" xml:space="preserve">
          <source>You're passing the value of the reference and not the reference itself (and not the object).</source>
          <target state="translated">Estás pasando el valor de la referencia y no la referencia en sí misma (y no el objeto).</target>
        </trans-unit>
        <trans-unit id="e412d3eb76b9c511737b2f188cf28aa0a3b15e42" translate="yes" xml:space="preserve">
          <source>a new &lt;code&gt;Dog&lt;/code&gt; is created. Let's say he's at address 74</source>
          <target state="translated">Se crea un nuevo &lt;code&gt;Dog&lt;/code&gt; . Digamos que est&amp;aacute; en la direcci&amp;oacute;n 74</target>
        </trans-unit>
        <trans-unit id="fb3668ea3a8369fdbba52413c9d814f6e3ed4702" translate="yes" xml:space="preserve">
          <source>all bind the value of a reference to a &lt;code&gt;String&lt;/code&gt; instance to the method's newly created parameter, &lt;code&gt;param&lt;/code&gt;. This is exactly what the definition of pass-by-value describes. As such, &lt;strong&gt;Java is pass-by-value&lt;/strong&gt;.</source>
          <target state="translated">todos vinculan el valor de una referencia a una instancia de &lt;code&gt;String&lt;/code&gt; con el par&amp;aacute;metro reci&amp;eacute;n creado del m&amp;eacute;todo, &lt;code&gt;param&lt;/code&gt; . Esto es exactamente lo que describe la definici&amp;oacute;n de paso por valor. Como tal, &lt;strong&gt;Java es paso por valor&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8c38907cfcadbaccdbfd358b9d0106488c0111a7" translate="yes" xml:space="preserve">
          <source>at line &quot;AAA&quot;</source>
          <target state="translated">en la línea &quot;AAA&quot;</target>
        </trans-unit>
        <trans-unit id="f93c76dfe98a248d087f8423725428bab806588d" translate="yes" xml:space="preserve">
          <source>at line &quot;BBB&quot;</source>
          <target state="translated">en la línea &quot;BBB&quot;</target>
        </trans-unit>
        <trans-unit id="48a51572765a96c5528d9b97e645d1cb1d8ca215" translate="yes" xml:space="preserve">
          <source>at line &quot;CCC&quot;</source>
          <target state="translated">en la línea &quot;CCC&quot;</target>
        </trans-unit>
        <trans-unit id="5b6a04bdcab2545757147311bdd9dcec1526a1b4" translate="yes" xml:space="preserve">
          <source>edit: i believe this is also the reason to use StringBuffer when it comes to &quot;adding&quot; two Strings because you can modifie the original object which u can't with immutable objects like String is.</source>
          <target state="translated">Creo que esta es también la razón para usar StringBuffer cuando se trata de &quot;añadir&quot; dos cadenas,porque puedes modificar el objeto original,lo que no puedes hacer con objetos inmutables como String.</target>
        </trans-unit>
        <trans-unit id="de6d9b079fecccb2b44d0540cd59d6982bd1a708" translate="yes" xml:space="preserve">
          <source>if the Method were defined as</source>
          <target state="translated">si el Método se definiera como</target>
        </trans-unit>
        <trans-unit id="c0b841e19d194bfe513d4d90839ad8c2b89afe31" translate="yes" xml:space="preserve">
          <source>in case 1. and 2. if you change Foo (&lt;code&gt;Foo = 9&lt;/code&gt;) it only affects local scope as you have a copy of the Value. From inside the method we cannot even determine where in memory the original Foo was located.</source>
          <target state="translated">en el caso 1. y 2. si cambia Foo ( &lt;code&gt;Foo = 9&lt;/code&gt; ) solo afecta el alcance local ya que tiene una copia del Valor. Desde el interior del m&amp;eacute;todo, ni siquiera podemos determinar en qu&amp;eacute; lugar de la memoria se encontraba el Foo original.</target>
        </trans-unit>
        <trans-unit id="1865b6df13986dcf11d66c36aeef32061892ca5b" translate="yes" xml:space="preserve">
          <source>in case 3. and 4. if you use default language constructs and change Foo (&lt;code&gt;Foo = 11&lt;/code&gt;), it could change Foo globally (depends on the language, ie. Java or like Pascal's &lt;code&gt;procedure findMin(x, y, z: integer;&lt;/code&gt;&lt;strong&gt;var m&lt;/strong&gt;&lt;code&gt;: integer);&lt;/code&gt;). However if the language allows you to circumvent the dereference process, you can change &lt;code&gt;47&lt;/code&gt;, say to &lt;code&gt;49&lt;/code&gt;. At that point Foo seems to have been changed if you read it, because you have changed the &lt;strong&gt;local pointer&lt;/strong&gt; to it. And if you were to modify this Foo inside the method (&lt;code&gt;Foo = 12&lt;/code&gt;) you will probably FUBAR the execution of the program (aka. segfault) because you will write to a different memory than expected, you can even modify an area that is destined to hold executable program and writing to it will modify running code (Foo is now not at &lt;code&gt;47&lt;/code&gt;). BUT Foo's value of &lt;code&gt;47&lt;/code&gt; did not change globally, only the one inside the method, because &lt;code&gt;47&lt;/code&gt; was also a copy to the method.</source>
          <target state="translated">en el caso 3. y 4. si usa construcciones de lenguaje predeterminadas y cambia Foo ( &lt;code&gt;Foo = 11&lt;/code&gt; ), podr&amp;iacute;a cambiar Foo globalmente (depende del lenguaje, es decir, Java o como el &lt;code&gt;procedure findMin(x, y, z: integer;&lt;/code&gt; de Pascal findMin (x, y, z: entero; &lt;strong&gt;var m&lt;/strong&gt; &lt;code&gt;: integer);&lt;/code&gt; ). Sin embargo, si el idioma le permite eludir el proceso de desreferenciaci&amp;oacute;n, puede cambiar &lt;code&gt;47&lt;/code&gt; , digamos a &lt;code&gt;49&lt;/code&gt; . En ese punto, Foo parece haber cambiado si lo lees, porque le has cambiado el &lt;strong&gt;puntero local&lt;/strong&gt; . Y si tuviera que modificar este Foo dentro del m&amp;eacute;todo ( &lt;code&gt;Foo = 12&lt;/code&gt; ) probablemente FUBAR&amp;Aacute; la ejecuci&amp;oacute;n del programa (tambi&amp;eacute;n conocido como segfault) porque escribir&amp;aacute; en una memoria diferente a la esperada, incluso puede modificar un &amp;aacute;rea que est&amp;aacute; destinada retener el programa ejecutable y escribir en &amp;eacute;l modificar&amp;aacute; el c&amp;oacute;digo de ejecuci&amp;oacute;n (Foo ahora no est&amp;aacute; en &lt;code&gt;47&lt;/code&gt; ). PERO el valor de &lt;code&gt;47&lt;/code&gt; de Foo no cambi&amp;oacute; globalmente, solo el que est&amp;aacute; dentro del m&amp;eacute;todo, porque &lt;code&gt;47&lt;/code&gt; tambi&amp;eacute;n era una copia del m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="dd97dfe75334fc4ae374b64905b80db5da6f0246" translate="yes" xml:space="preserve">
          <source>in case 5. and 6. if you modify &lt;code&gt;223&lt;/code&gt; inside the method it creates the same mayhem as in 3. or 4. (a pointer, pointing to a now bad value, that is again used as a pointer) but this is still a local problem, as 223 was &lt;strong&gt;copied&lt;/strong&gt;. However if you are able to dereference &lt;code&gt;Ref2Foo&lt;/code&gt; (that is &lt;code&gt;223&lt;/code&gt;), reach to and modify the pointed value &lt;code&gt;47&lt;/code&gt;, say, to &lt;code&gt;49&lt;/code&gt;, it will affect Foo &lt;strong&gt;globally&lt;/strong&gt;, because in this case the methods got a copy of &lt;code&gt;223&lt;/code&gt;  but the referenced &lt;code&gt;47&lt;/code&gt; exists only once, and changing that to &lt;code&gt;49&lt;/code&gt; will lead every &lt;code&gt;Ref2Foo&lt;/code&gt; double-dereferencing to a wrong value.</source>
          <target state="translated">en el caso 5. y 6. si modifica &lt;code&gt;223&lt;/code&gt; dentro del m&amp;eacute;todo, crea el mismo caos que en 3. o 4. (un puntero, apuntando a un valor ahora incorrecto, que nuevamente se usa como puntero) pero esto sigue siendo un problema local, ya que se &lt;strong&gt;copi&amp;oacute;&lt;/strong&gt; 223. Sin embargo, si puede desreferenciar &lt;code&gt;Ref2Foo&lt;/code&gt; (es decir, &lt;code&gt;223&lt;/code&gt; ), alcanzar y modificar el valor se&amp;ntilde;alado &lt;code&gt;47&lt;/code&gt; , digamos, a &lt;code&gt;49&lt;/code&gt; , afectar&amp;aacute; a Foo &lt;strong&gt;globalmente&lt;/strong&gt; , porque en este caso los m&amp;eacute;todos obtuvieron una copia de &lt;code&gt;223&lt;/code&gt; pero existe el &lt;code&gt;47&lt;/code&gt; referenciado solo una vez, y cambiar eso a &lt;code&gt;49&lt;/code&gt; llevar&amp;aacute; a cada &lt;code&gt;Ref2Foo&lt;/code&gt; doble Ref2Foo a un valor incorrecto.</target>
        </trans-unit>
        <trans-unit id="ea582fe2290fa53002694c7ca06cb1d90981b239" translate="yes" xml:space="preserve">
          <source>in reverseArray method, it will make a change in array a.</source>
          <target state="translated">en el método reverseArray,hará un cambio en el array a.</target>
        </trans-unit>
        <trans-unit id="84dd6095c9c7186e7a49f24a310118598e04da82" translate="yes" xml:space="preserve">
          <source>in reverseArray method, then the reference variable array1 in method reverseArray would stop pointing to array a and start pointing to array c (Dotted line in second image).</source>
          <target state="translated">en el método reverseArray,entonces la matriz de variables de referencia1 en el método reverseArray dejaría de apuntar a la matriz a y empezaría a apuntar a la matriz c (Línea punteada en la segunda imagen).</target>
        </trans-unit>
        <trans-unit id="d97fae11a419e6a12bc3edb13062dc19c09875c0" translate="yes" xml:space="preserve">
          <source>is &lt;em&gt;not&lt;/em&gt; a Dog; it's actually a &lt;em&gt;pointer&lt;/em&gt; to a Dog.</source>
          <target state="translated">&lt;em&gt;no&lt;/em&gt; es un perro en realidad es un &lt;em&gt;puntero&lt;/em&gt; a un perro.</target>
        </trans-unit>
        <trans-unit id="b39623476b2f81bd70a4ff62eb5267bce22738e1" translate="yes" xml:space="preserve">
          <source>let's look at what's happening.</source>
          <target state="translated">veamos lo que está pasando.</target>
        </trans-unit>
        <trans-unit id="cf3a9617ac647d82c56f77cf9e8ae2169d187941" translate="yes" xml:space="preserve">
          <source>name= Fido</source>
          <target state="translated">nombre=Fido</target>
        </trans-unit>
        <trans-unit id="dcf9d3f64bd4525093b6cb2a29ebf7e8b0769c96" translate="yes" xml:space="preserve">
          <source>name= Maxx</source>
          <target state="translated">nombre=Maxx</target>
        </trans-unit>
        <trans-unit id="ea4bd0e3bb9e113c03dc6f25c82ed0880ff1e2b7" translate="yes" xml:space="preserve">
          <source>output of java PassByCopy:</source>
          <target state="translated">salida de java PassByCopy:</target>
        </trans-unit>
        <trans-unit id="38b2369b273631468a9a5a2e59b5d466d9ec4e32" translate="yes" xml:space="preserve">
          <source>results in this:</source>
          <target state="translated">resulta en esto:</target>
        </trans-unit>
        <trans-unit id="015c3de73f8f17655e3dba14c211482d8731c15c" translate="yes" xml:space="preserve">
          <source>someDog is followed to the &lt;code&gt;Dog&lt;/code&gt; it points to (the &lt;code&gt;Dog&lt;/code&gt; object at address 74)</source>
          <target state="translated">someDog se sigue hasta el &lt;code&gt;Dog&lt;/code&gt; que apunta (el objeto &lt;code&gt;Dog&lt;/code&gt; en la direcci&amp;oacute;n 74)</target>
        </trans-unit>
        <trans-unit id="e52ae0c10562272d36f12c255484e6e511e5858a" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;Dog&lt;/code&gt; (the one at address 42) is asked to change his name to Max</source>
          <target state="translated">se le pide a ese &lt;code&gt;Dog&lt;/code&gt; (el de la direcci&amp;oacute;n 42) que cambie su nombre a Max</target>
        </trans-unit>
        <trans-unit id="7444c7540aa94d77adc3ade05581aa22935938f0" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;Dog&lt;/code&gt; (the one at address 74) is asked to change his name to Rowlf</source>
          <target state="translated">se le pide a ese &lt;code&gt;Dog&lt;/code&gt; (el de la direcci&amp;oacute;n 74) que cambie su nombre a Rowlf</target>
        </trans-unit>
        <trans-unit id="a28fea2db09c1001f61be42d428ec193c0c8fe83" translate="yes" xml:space="preserve">
          <source>the parameter &lt;code&gt;someDog&lt;/code&gt; is set to the value 42</source>
          <target state="translated">el par&amp;aacute;metro &lt;code&gt;someDog&lt;/code&gt; se establece en el valor 42</target>
        </trans-unit>
        <trans-unit id="05ed7faac6636fc4d3a902712b65ab43bb7a5b80" translate="yes" xml:space="preserve">
          <source>then, we return</source>
          <target state="translated">entonces,regresamos</target>
        </trans-unit>
        <trans-unit id="49280f2d918fc694c452825a7629c4f082161d51" translate="yes" xml:space="preserve">
          <source>using methods from the object given as parameter will alter the
object as the references point to
the original objects. (if that
method itself alters some values)</source>
          <target state="translated">El uso de métodos del objeto dado como parámetro alterará el objeto ya que las referencias apuntan a los objetos originales.(si ese método en sí mismo altera algunos valores)</target>
        </trans-unit>
        <trans-unit id="d8b3d65782447afeffa2d99acee97cbf42b98ecf" translate="yes" xml:space="preserve">
          <source>we assign the parameter &lt;code&gt;someDog&lt;/code&gt; to 74</source>
          <target state="translated">asignamos el par&amp;aacute;metro &lt;code&gt;someDog&lt;/code&gt; a 74</target>
        </trans-unit>
        <trans-unit id="b5086d2ae6b0cb0d15f1111f65e03a674960103f" translate="yes" xml:space="preserve">
          <source>will print out &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; instead of &lt;code&gt;null&lt;/code&gt;. The reason this works is because &lt;code&gt;bar&lt;/code&gt; is a copy of the value of &lt;code&gt;baz&lt;/code&gt;, which is just a reference to &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt;. If it were the actual reference itself, then &lt;code&gt;foo&lt;/code&gt; would have redefined &lt;code&gt;baz&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">imprimir&amp;aacute; &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; en lugar de &lt;code&gt;null&lt;/code&gt; La raz&amp;oacute;n por la que esto funciona es porque la &lt;code&gt;bar&lt;/code&gt; ra es una copia del valor de &lt;code&gt;baz&lt;/code&gt; , que es solo una referencia a &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; . Si fuera la referencia en s&amp;iacute; misma, entonces &lt;code&gt;foo&lt;/code&gt; habr&amp;iacute;a redefinido &lt;code&gt;baz&lt;/code&gt; a &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f07948ada1b914ebc3731995719969a1b588a36" translate="yes" xml:space="preserve">
          <source>you're essentially passing the &lt;em&gt;address&lt;/em&gt; of the created &lt;code&gt;Dog&lt;/code&gt; object to the &lt;code&gt;foo&lt;/code&gt; method.</source>
          <target state="translated">b&amp;aacute;sicamente est&amp;aacute; pasando la &lt;em&gt;direcci&amp;oacute;n&lt;/em&gt; del objeto &lt;code&gt;Dog&lt;/code&gt; creado al m&amp;eacute;todo &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
