<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/40480">
    <body>
      <group id="40480">
        <trans-unit id="679ac82a1b80b565bd19565ec122a565572f35a9" translate="yes" xml:space="preserve">
          <source>&quot;String&quot; Objects appear to be a good &lt;strong&gt;counter-example&lt;/strong&gt; to the urban legend saying that &quot;Objects are passed by reference&quot;:</source>
          <target state="translated">&quot;문자열&quot;개체는 &quot;범례가 참조로 전달된다&quot;는 도시의 전설에 &lt;strong&gt;반하는&lt;/strong&gt; 좋은 &lt;strong&gt;예입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d88ecdddf8b9e6ef14e68530529dc23d4ff6b148" translate="yes" xml:space="preserve">
          <source>&quot;by value&quot; is the only way in java to pass a parameter to a method</source>
          <target state="translated">&quot;값별&quot;은 Java에서 매개 변수를 메소드에 전달하는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ac7bea48c9f3e3c013ee3b9ca43c1cd4255ba9c6" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Account account1&amp;rdquo; is the type and name of the reference variable, &amp;ldquo;=&amp;rdquo; is the assignment operator, &amp;ldquo;new&amp;rdquo; asks for the required amount of space from the system. The constructor to the right of keyword new which creates the object is called implicitly by the keyword new. Address of the created object(result of right variable, which is an expression) is assigned to the left variable (which is a reference variable with a name and a type specified) using the assign operator. &amp;ldquo;new Account()&amp;rdquo; is called &amp;ldquo;class instance creation expression&amp;rdquo;.</source>
          <target state="translated">&amp;ldquo;Account account1&amp;rdquo;은 참조 변수의 유형 및 이름이고&amp;ldquo;=&amp;rdquo;는 할당 연산자이며&amp;ldquo;new&amp;rdquo;는 시스템에서 필요한 공간을 요구합니다. 객체를 생성하는 new 키워드 오른쪽의 생성자는 new 키워드에 의해 암시 적으로 호출됩니다. 할당 된 연산자 (표현식 인 오른쪽 변수의 결과)의 주소는 assign 연산자를 사용하여 왼쪽 변수 (이름과 유형이 지정된 참조 변수)에 할당됩니다. &amp;ldquo;새 계정 ()&amp;rdquo;을&amp;ldquo;클래스 인스턴스 생성 식&amp;rdquo;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="94aa2ba0bb8a675b61aef491a803f4a9834f2892" translate="yes" xml:space="preserve">
          <source>(I say essentially because Java pointers aren't direct addresses, but it's easiest to think of them that way)</source>
          <target state="translated">(기본적으로 Java 포인터는 직접적인 주소가 아니기 때문에 그렇게 생각하는 것이 가장 쉽습니다)</target>
        </trans-unit>
        <trans-unit id="4deb5f3c7a0f51652194597de3c850eb67417a51" translate="yes" xml:space="preserve">
          <source>/**
  This 'Pass By Value has a feeling of 'Pass By Reference'</source>
          <target state="translated">/ **이 'Pass By Value'에는 'Pass By Reference'라는 느낌이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aadafd84fb3481ea6953e7000de351b550c282f" translate="yes" xml:space="preserve">
          <source>/**
 * 
 * Pass By Value
 *
 */</source>
          <target state="translated">/ ** * * 값으로 전달 * * /</target>
        </trans-unit>
        <trans-unit id="2d699180ecfe5b34c3e0bc840eb47751e4372814" translate="yes" xml:space="preserve">
          <source>223 gets PUSHd to the stack.</source>
          <target state="translated">223은 스택에 PUSHd를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6446e71ace78a7a3a0a5710cd60edb392c5f7798" translate="yes" xml:space="preserve">
          <source>223 gets copied to one of the CPU registers.</source>
          <target state="translated">223은 CPU 레지스터 중 하나로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="b89be71dff7edaa9c74d2426c943f820435958da" translate="yes" xml:space="preserve">
          <source>47 PUSHd to the stack.</source>
          <target state="translated">47 스택에 밀어 넣습니다.</target>
        </trans-unit>
        <trans-unit id="29eebea6f72ba92d2ef802d866c3af082d2c6911" translate="yes" xml:space="preserve">
          <source>47 gets copied to one of the CPU registers</source>
          <target state="translated">47은 CPU 레지스터 중 하나에 복사됩니다</target>
        </trans-unit>
        <trans-unit id="35f6cb5f76dc39cccdd22e4f4ed75145651bad22" translate="yes" xml:space="preserve">
          <source>5 gets PUSHd to the stack.</source>
          <target state="translated">5는 스택에 PUSHd를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bd53eeaa13917b9c1cd0ffee5c08d5548f0f975f" translate="yes" xml:space="preserve">
          <source>5 gets copied to one of the CPU registers (ie. EAX).</source>
          <target state="translated">5는 CPU 레지스터 중 하나 (예 : EAX)에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="669fc2a12114e17f53bf6a6eea0a996b3e52e4db" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028&quot;&gt;Java is also mentioned&lt;/a&gt;. Here is the short summary:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028&quot;&gt;자바도 언급되어있다&lt;/a&gt; . 다음은 간단한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="44522a95088af6ee8afeac1924a88cbdb726d3ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a = b&lt;/code&gt; makes a new assignment to the reference &lt;code&gt;a&lt;/code&gt;, &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;f&lt;/code&gt;, of the object whose its attribute is &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a = b&lt;/code&gt; 는 속성이 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 인 객체의 &lt;code&gt;f&lt;/code&gt; 가 &lt;strong&gt;아닌&lt;/strong&gt; 참조 a에 새 할당을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="dc8f4e638edf822f721d61b825c182734c0569b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c.setAttribute(&quot;c&quot;);&lt;/code&gt; will change the attribute of the object that reference &lt;code&gt;c&lt;/code&gt; points to it, and it's same object that reference &lt;code&gt;f&lt;/code&gt; points to it.</source>
          <target state="translated">&lt;code&gt;c.setAttribute(&quot;c&quot;);&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 를 참조하는 객체의 속성을 변경하고 &lt;code&gt;f&lt;/code&gt; 를 참조하는 객체와 동일한 객체를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="14cac2530311a23fb072c9ef26feba713000c665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;someDog&lt;/code&gt; is followed to the &lt;code&gt;Dog&lt;/code&gt; it points to (the &lt;code&gt;Dog&lt;/code&gt; object at address 42)</source>
          <target state="translated">&lt;code&gt;someDog&lt;/code&gt; 가 가리키는 &lt;code&gt;Dog&lt;/code&gt; (주소 42의 Dog 개체)를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1e1295aabf56bdb60aa6cdd4c585a17ef60d34fd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Did &lt;code&gt;myDog&lt;/code&gt; change?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;myDog&lt;/code&gt; 가 변경 되었습니까?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f5e57136a5902e29d33131a3a28391b65ae5a66" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Master&lt;/em&gt;: Grasshopper, No.</source>
          <target state="translated">&lt;em&gt;마스터&lt;/em&gt; : 메뚜기</target>
        </trans-unit>
        <trans-unit id="b89440cba42f99210f8524ad856b1d7e2968203e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Student&lt;/em&gt;: Master, does this mean that Java is pass-by-reference?</source>
          <target state="translated">&lt;em&gt;학생&lt;/em&gt; : 스승님, Java가 참조로 전달한다는 의미입니까?</target>
        </trans-unit>
        <trans-unit id="e9026cb4dbf68f5a89f59e77b991a00db2fad347" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;This value is actually COPIED and given to the method&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;이 값은 실제로 복사되어 메소드에 제공&lt;/em&gt;&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="eac8606431b898a08bfa815724043bf24baea91c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A variable holds the bits that tell the JVM how to get to the referenced Object in memory (Heap).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;변수는 JVM에서 메모리의 참조 된 오브젝트 (힙)에 도달하는 방법을 알려주는 비트를 보유합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee963e4f98e2321319006e78120a5c33385ffa8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All parameters to methods are passed &quot;by value&quot;&lt;/strong&gt;. In other words,
  values of parameter variables in a method are copies of the invoker
  specified as arguments.</source>
          <target state="translated">&lt;strong&gt;메소드에 대한 모든 매개 변수는 &quot;값으로&quot;전달됩니다&lt;/strong&gt; . 즉, 메소드의 매개 변수 변수 값은 인수로 지정된 호출자의 사본입니다.</target>
        </trans-unit>
        <trans-unit id="d0c0ba2ae2424364bf0a5b15f58afb340e72d7df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ allows Pass-by-reference&lt;/strong&gt; by declaring a reference parameter using the &quot;&amp;amp;&quot; character (which happens to be the same character used to indicate &quot;the address of a variable&quot; in both C and C++). For example, if we pass in a pointer by reference, the parameter and the argument are not just pointing to the same object. Rather, they are the same variable. If one gets set to a different address or to null, so does the other.</source>
          <target state="translated">&lt;strong&gt;C ++에서는&lt;/strong&gt; &quot;&amp;amp;&quot;문자 (C 및 C ++에서 &quot;변수의 주소&quot;를 나타내는 데 사용되는 것과 동일한 문자 임)를 사용하여 참조 매개 변수를 선언하여 참조로 &lt;strong&gt;전달할&lt;/strong&gt; 수 있습니다. 예를 들어, 참조로 포인터를 전달하면 매개 변수와 인수가 동일한 객체를 가리키는 것이 아닙니다. 오히려 그들은 같은 변수입니다. 하나가 다른 주소로 설정되거나 null로 설정되면 다른 주소도 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="250414fd453c52d7a94d41cac5720b0bf6770e9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;편집 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e432c6162816f0458b741aeccb3b66bf810d917a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;편집 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3b32f3bc0cf8e132bab93bdb849247ffeab0402" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;편집 4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eee5a199ee48a34a0cc9134ad8533202fc7fcb52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 1 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba5182d053766559c8a796587cc6e079b0edece9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 2 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87994c9ddef100c712273600d84d2680b1176fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 3 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f029fd8a8bc2187006a97a36768f3a9a0f4c6825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 4 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46619b51e67a75935bc9ceedee2a6019b4258008" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Java creates and stores objects:&lt;/strong&gt; When we create an object we store the object&amp;rsquo;s address in a reference variable. Let's analyze the following statement.</source>
          <target state="translated">&lt;strong&gt;Java가 객체를 생성하고 저장하는 방법 : 객체&lt;/strong&gt; 를 생성 할 때 객체의 주소를 참조 변수에 저장합니다. 다음 진술을 분석해 봅시다.</target>
        </trans-unit>
        <trans-unit id="8522a877bd114b6f39cde66fbd073f0156a79129" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Java only references are passed and are passed by value:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java에서는 참조 만 전달되고 값으로 전달됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fb07fd2faf3d430de82df4b1196a7157526121c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java doesn't pass method arguments by reference; it passes them by value.&lt;/strong&gt; I will use example from &lt;a href=&quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html&quot;&gt;this site&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;Java는 메소드 인수를 참조로 전달하지 않습니다.&lt;/strong&gt; &lt;strong&gt;그것들은 가치에 의해 전달됩니다.&lt;/strong&gt; &lt;a href=&quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html&quot;&gt;이 사이트&lt;/a&gt; 에서 예제를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="f8710d2de84f7d70df19d71411b10789671cf77e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java is Pass-by-value&lt;/strong&gt;, but allows us to emulate pass be reference by passing a Java reference (i.e. a pointer) by value. Meaning it passes a copy of the Java reference. &lt;strong&gt;&lt;em&gt;EDIT&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;: since someone made a comment about this, let me explain. Before C, several (but not all) earlier languages like FORTRAN and COBOL supported PBR, but C did not. In order to change the values of variables inside functions, C programmers emulated PBR by passing pointers to variables into functions. Languages inspired by C, such as Java, borrowed this idea and continue to emulate PBR as C did.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Java는 Pass-by-value&lt;/strong&gt; 이지만 Java 참조 (예 : 포인터)를 값으로 전달하여 pass be reference를 에뮬레이션 할 수 있습니다. 의미는 Java 참조의 사본을 전달한다는 의미입니다. &lt;strong&gt;&lt;em&gt;편집&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;: 누군가 이것에 대해 의견을&lt;/em&gt; &lt;strong&gt;&lt;em&gt;말했기&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;때문에 설명해 드리겠습니다.&lt;/em&gt; &lt;em&gt;C 이전에는 FORTRAN 및 COBOL과 같은 일부 (전부는 아님) 언어가 PBR을 지원했지만 C는 지원하지 않았습니다.&lt;/em&gt; &lt;em&gt;함수 내부의 변수 값을 변경하기 위해 C 프로그래머는 변수에 대한 포인터를 함수에 전달하여 PBR을 에뮬레이트했습니다.&lt;/em&gt; &lt;em&gt;Java와 같은 C에서 영감을 얻은 언어는이 아이디어를 빌려 왔으며 C와 마찬가지로 PBR을 계속 모방합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="539967da6afd5b4c7cf196939fd0d2173148d5e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java is always pass by value, not pass by reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java는 항상 참조로 전달되지 않고 값으로 전달됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daf65d846a847f4224f37e5964ce49e033a6516e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that the anotherReferenceToTheSamePersonObject arrows is directed towards the Object and not towards the variable person!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;anotherReferenceToTheSamePersonObject 화살표는 변수 사람이 아닌 오브젝트를 향합니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82bf5f83e99ffaf8561e8e28fe3ef14c8cc29ecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;On this line 'pass-by-value' goes into the play...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 줄에서 '가치 통과'는 연극으로 들어갑니다 ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f82acf071fee6ab2a7abd0313bbf60fe384f861" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference (also called pass by address) means that a copy of the address of the actual parameter is stored&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;참조로 전달 (주소로 전달이라고도 함)은 실제 매개 변수의 주소 사본이 저장됨을 의미합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="24f93d53f1599b4ac1080cabfb887cfff18610ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference&lt;/strong&gt;--There is no copy of the reference. Single reference is shared by both the caller and the function being called. Any changes to the reference or the Object's data are reflected in the caller's scope.</source>
          <target state="translated">&lt;strong&gt;참조로 전달&lt;/strong&gt; - &lt;strong&gt;참조&lt;/strong&gt; 사본이 없습니다. 단일 참조는 호출자와 호출되는 함수 모두에 의해 공유됩니다. 참조 또는 객체의 데이터에 대한 변경 사항은 호출자의 범위에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="a7a81b026c4fc8d49d09f4de01c114901f7c0d8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by value means that you are making a copy in memory of the actual parameter's value that is passed in. This is a copy of the contents of the actual parameter&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;값으로 전달은 전달 된 실제 매개 변수 값의 메모리에 사본을 작성 함을 의미합니다. 이것은 실제 매개 변수 컨텐츠의 사본입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5501243b5acfe1576d19283bdb0a2ab76d3504bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing a reference by value&lt;/strong&gt;--Changes to the reference are not reflected in the caller's scope, but the changes to the object are. This is because the reference is copied, but the both the original and the copy refer to the same object.</source>
          <target state="translated">&lt;strong&gt;값으로 참조 전달-참조에&lt;/strong&gt; 대한 변경 사항은 호출자의 범위에 반영되지 않지만 객체의 변경 사항은 반영됩니다. 참조가 복사 되었으나 원본과 사본이 모두 동일한 객체를 참조하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d128a624743e2f0a142ea51104871088ef3baab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Result&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f28b5e99d681d23b2424be728e4d14ac53de034" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The fact that you can follow the reference to invoke a method or access a field of the referenced object is completely irrelevant to the conversation.&lt;/strong&gt; The definition of pass-by-reference was</source>
          <target state="translated">&lt;strong&gt;참조를 따라 메소드를 호출하거나 참조 된 오브젝트의 필드에 액세스 할 수 있다는 사실은 대화와 전혀 관련이 없습니다.&lt;/strong&gt; 통과 기준의 정의는</target>
        </trans-unit>
        <trans-unit id="155adcfa1e1a2d90f9b1663c701b8baa445db69b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The reference values (often just references) are pointers to these objects&lt;/strong&gt;, and a special null reference, which refers to no object.</source>
          <target state="translated">&lt;strong&gt;참조 값 (종종 단지 참조)은 이러한 객체에 대한 포인터&lt;/strong&gt; 이며 객체가없는 특수 null 참조입니다.</target>
        </trans-unit>
        <trans-unit id="c6c7f19df18b6b50e6865d7508209d9363946c4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This will give you some insights of how Java really works to the point that in your next discussion about Java passing by reference or passing by value you'll just smile :-)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이것은 자바가 실제로 어떻게 작동하는지에 대한 통찰력을 줄 것입니다. 다음에 토론 할 때 참조로 전달하거나 값으로 전달하는 것에 대해 다음과 같이 웃을 것입니다 :-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a57a48f1825e5c9fb8aafac2b685e4eb2761f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is the value of the argument?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;논증의 가치는 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f32da0f05cfb43b8594e1350dffac69d7279c2e" translate="yes" xml:space="preserve">
          <source>A String Object, holds characters by an array declared &lt;strong&gt;final&lt;/strong&gt; that can't be modified.
Only the address of the Object might be replaced by another using &quot;new&quot;. 
Using &quot;new&quot; to update the variable, will not let the Object be accessed from outside, since the variable was initially passed by value and copied.</source>
          <target state="translated">String 개체는 &lt;strong&gt;final로&lt;/strong&gt; 선언 된 배열에서 수정할 수없는 문자를 보유합니다. &quot;새&quot;를 사용하여 오브젝트의 주소 만 다른 주소로 대체 ​​될 수 있습니다. 변수를 업데이트하기 위해 &quot;new&quot;를 사용하면 변수가 처음에 값으로 전달되어 복사되었으므로 외부에서 오브젝트에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5cadb13ab1a3063435130babe3e0bd30a1122a5f" translate="yes" xml:space="preserve">
          <source>A few points:</source>
          <target state="translated">몇 가지 사항 :</target>
        </trans-unit>
        <trans-unit id="a6487d11fc0e1086219982c44902ad61a1998227" translate="yes" xml:space="preserve">
          <source>A method local variable -&lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt;- is created and then comes the magic in line #6:</source>
          <target state="translated">메소드 local 변수 인 &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; 가 작성되어 6 번째 줄에 마법이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="939671d12f121c636331468aedcb607655b0467d" translate="yes" xml:space="preserve">
          <source>A new Person Object is created in line #2, stored in memory, and the variable &lt;em&gt;person&lt;/em&gt; is given the reference to the Person object. That is, its address. Let's say 3bad086a.</source>
          <target state="translated">새로운 Person Object가 2 번 줄에 생성되어 메모리에 저장되고 변수 &lt;em&gt;person&lt;/em&gt; 에 Person 객체에 대한 참조가 제공됩니다. 즉, 주소입니다. 3bad086a를 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="6cb5cc922e3e7afc89e697c3a55b40eccd85c7e8" translate="yes" xml:space="preserve">
          <source>A picture is worth a thousand words:</source>
          <target state="translated">그림은 천 단어의 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7890ee11943cdb236a4c3b5ce7b9f732f716679f" translate="yes" xml:space="preserve">
          <source>A reference is always a value when represented, no matter what language you use.</source>
          <target state="translated">사용하는 언어에 관계없이 참조는 항상 표현할 때 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f8832ae6457f58e3904c76f8d5c2aa49f842301" translate="yes" xml:space="preserve">
          <source>After: a = 2, b = 3</source>
          <target state="translated">이후 : a = 2, b = 3</target>
        </trans-unit>
        <trans-unit id="ec423d5a41945c4f52f7be0ea48ac07e83fd86ae" translate="yes" xml:space="preserve">
          <source>Although an object&amp;rsquo;s reference is passed by value, a method can still interact with the referenced object by calling its public methods using the copy of the object&amp;rsquo;s reference. Since the reference stored in the parameter is a copy of the reference that was passed as an argument, the parameter in the called method and the argument in the calling method refer to the same object in memory.</source>
          <target state="translated">객체의 참조는 값으로 전달되지만 메소드는 객체의 참조 사본을 사용하여 공용 메소드를 호출하여 참조 된 객체와 상호 작용할 수 있습니다. 매개 변수에 저장된 참조는 인수로 전달 된 참조의 사본이므로 호출 된 메소드의 매개 변수 및 호출 메소드의 인수는 메모리의 동일한 오브젝트를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="b65974e5bb87a60e0a3ebacd86b70b176a71aea4" translate="yes" xml:space="preserve">
          <source>An array is an object, so it goes on the heap as well. And what about the objects in the array? They get their own heap space, and the address of each object goes inside the array.</source>
          <target state="translated">배열은 객체이므로 힙에도 적용됩니다. 그리고 배열의 객체는 어떻습니까? 그들은 자신의 힙 공간을 얻고 각 객체의 주소는 배열 내부로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="9bf2ce1dceef2dc96a821885bc168afbf5d4d9a1" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value&quot;&gt;on the subject of pass-by-value&lt;/a&gt;</source>
          <target state="translated">그리고 &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value&quot;&gt;가치에 의한 주제&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="753dfa9513c7de7c01e5a4ee8e20f57993151233" translate="yes" xml:space="preserve">
          <source>And now that reverseArray method is over, its reference variables(array1 and array2) are gone. Which means we now only have the two reference variables in main method array1 and array2 which point to c and b arrays respectively. No reference variable is pointing to object (array) a. So it is eligible for garbage collection.</source>
          <target state="translated">이제 reverseArray 메서드가 끝났으므로 참조 변수 (array1 및 array2)가 사라졌습니다. 즉, 주 메소드 array1 및 array2에는 각각 c 및 b 배열을 가리키는 두 개의 참조 변수 만 있습니다. 참조 변수가 객체 (배열)를 가리 키지 않습니다. 따라서 가비지 수집에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="1427090bc2dee2db920c7dcba2e93785a6f9fced" translate="yes" xml:space="preserve">
          <source>And towards the end of the same section he makes a broader statement about java being only pass by value and never pass by reference.</source>
          <target state="translated">그리고 같은 섹션의 끝을 향하여 그는 자바가 가치에 의해서만 전달되고 결코 참조에 의해 전달되지 않는다는 것에 대해 더 넓은 진술을합니다.</target>
        </trans-unit>
        <trans-unit id="7ccd274eb97af58443d0d98f31f8165d44df954a" translate="yes" xml:space="preserve">
          <source>Anyway, I noticed a comment by &lt;a href=&quot;https://stackoverflow.com/users/208457/dhackner&quot;&gt;dhackner&lt;/a&gt; in an older post, who made a balloon analogy which I really liked. So much so that I decided to glue together some clip-art to make a set of cartoons to illustrate the point.</source>
          <target state="translated">어쨌든, 나는 오래된 게시물에서 &lt;a href=&quot;https://stackoverflow.com/users/208457/dhackner&quot;&gt;dhackner&lt;/a&gt; 의 의견을 발견했습니다. 그래서 클립 아트를 붙여서 요점을 설명하기 위해 만화 세트를 만들기로 결심했습니다.</target>
        </trans-unit>
        <trans-unit id="7a6f63a9fa8ba00d31fa864a81af348461e2059d" translate="yes" xml:space="preserve">
          <source>As expected output will be:</source>
          <target state="translated">예상되는 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e95da2bd7af315b2113d39a70608c332bc48d91" translate="yes" xml:space="preserve">
          <source>As far as I know, Java only knows call by value. This means for primitive datatypes you will work with an copy and for objects you will work with an copy of the reference to the objects. However I think there are some pitfalls; for example, this will not work:</source>
          <target state="translated">내가 아는 한 Java는 가치에 의한 호출 만 알고 있습니다. 이는 사본으로 작업 할 기본 데이터 유형과 객체에 대한 참조 사본으로 작업 할 객체를 의미합니다. 그러나 나는 함정이 있다고 생각한다. 예를 들어, 이것은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d05f320102345bc58ddfdf1478a148fed340e361" translate="yes" xml:space="preserve">
          <source>As many people mentioned it before, &lt;a href=&quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm&quot;&gt;Java is always pass-by-value&lt;/a&gt;</source>
          <target state="translated">많은 사람들이 이전에 언급했듯이 &lt;a href=&quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm&quot;&gt;Java는 항상 가치를 전달합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd4f600b4ca0e57b260d865e338eb632ae21d0de" translate="yes" xml:space="preserve">
          <source>As was explained in previous answers, in Java you're passing a pointer to the array as a value into &lt;code&gt;getValues&lt;/code&gt;. That is enough, because the method then modifies the array element, and by convention you're expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn't necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.</source>
          <target state="translated">이전 답변에서 설명한 것처럼 Java에서는 &lt;code&gt;getValues&lt;/code&gt; 에 값으로 배열에 포인터를 전달합니다. 메소드가 배열 요소를 수정하기 때문에 충분하지만, 일반적으로 요소 0에 반환 값이 포함될 것으로 예상됩니다. 분명히 코드를 구성하지 않아도되거나 반환 값을 포함하거나 설정할 수있는 클래스 구성과 같은 다른 방법으로이 작업을 수행 할 수 있습니다. 그러나 위의 C ++에서 사용 가능한 간단한 패턴은 Java에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8d7366694d78adcdb573e21740168952ff60eb6a" translate="yes" xml:space="preserve">
          <source>As we all know it will create an object in the heap and return the reference value back to t. For example, suppose the value of t is &lt;code&gt;0x100234&lt;/code&gt; (we don't know the actual JVM internal value, this is just an example) .</source>
          <target state="translated">우리 모두 알고 있듯이 힙에 객체를 만들고 참조 값을 다시 t로 반환합니다. 예를 들어, t 값이 &lt;code&gt;0x100234&lt;/code&gt; 라고 가정합니다 (실제 JVM 내부 값을 모르는 경우, 이것은 단지 예일뿐입니다).</target>
        </trans-unit>
        <trans-unit id="430da7a13966f26ff5a4c5e2f81b52ff90b0253b" translate="yes" xml:space="preserve">
          <source>As you call &lt;code&gt;modifyReference(Foo c)&lt;/code&gt; method, a reference &lt;code&gt;c&lt;/code&gt; is created and assigned the object with attribute &lt;code&gt;&quot;f&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modifyReference(Foo c)&lt;/code&gt; 메소드를 호출하면 참조 &lt;code&gt;c&lt;/code&gt; 가 작성되고 속성 &lt;code&gt;&quot;f&quot;&lt;/code&gt; 를 가진 오브젝트가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa285e6edfa6d99016592271e8d0555fae43569f" translate="yes" xml:space="preserve">
          <source>As you call the method &lt;code&gt;changeReference&lt;/code&gt;, the reference &lt;code&gt;a&lt;/code&gt; will be assigned the object which is passed as an argument.</source>
          <target state="translated">&lt;code&gt;changeReference&lt;/code&gt; 메소드를 호출하면 참조 &lt;code&gt;a&lt;/code&gt; 에 인수로 전달 된 오브젝트가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="108085f3bb0f4209a639200317b9f008aaf21dab" translate="yes" xml:space="preserve">
          <source>Back when I studied compilers-in the 90's, I used the first edition of the book from 1986 which pre-dated Java by about 9 or 10 years. However, I just ran across a copy of the &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W&quot;&gt;2nd Eddition&lt;/a&gt; from 2007 &lt;strong&gt;which actually mentions Java!&lt;/strong&gt; Section 1.6.6 labeled &quot;Parameter Passing Mechanisms&quot; describes parameter passing pretty nicely. Here is an excerpt under the heading &quot;Call-by-value&quot; which mentions Java:</source>
          <target state="translated">90 년대에 컴파일러를 연구했을 때, 나는 1986 년부터 책의 첫 번째 판을 사용했는데,이 책은 약 9 년에서 10 년 전에 Java를 미리 작성했습니다. 그러나 저는 2007 년부터 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W&quot;&gt;제 2 판&lt;/a&gt; 의 사본을 보았습니다 &lt;strong&gt;.&lt;/strong&gt; &quot;매개 변수 전달 메커니즘&quot;이라고 라벨이 붙은 1.6.6 절은 매개 변수 전달을 아주 잘 설명합니다. 다음은 Java를 언급 한 &quot;값별 호출&quot;이라는 제목 아래의 발췌문입니다.</target>
        </trans-unit>
        <trans-unit id="2a5566bd96317aa68aedfcd4ec8973cfbf92a199" translate="yes" xml:space="preserve">
          <source>Basically, reassigning Object parameters doesn't affect the argument, e.g.,</source>
          <target state="translated">기본적으로 Object 매개 변수를 다시 할당해도 인수에 영향을 미치지 않습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="1b0434b117ced506f4e292880cee2d016b9caf22" translate="yes" xml:space="preserve">
          <source>Before: a = 2, b = 3</source>
          <target state="translated">전 : a = 2, b = 3</target>
        </trans-unit>
        <trans-unit id="687e81922c00310f84049051118a03dc31fabaae" translate="yes" xml:space="preserve">
          <source>Both &quot;&lt;em&gt;person&lt;/em&gt;&quot; and &quot;&lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt;&quot; hold the same value of 3bad086a.</source>
          <target state="translated">&quot; &lt;em&gt;person&lt;/em&gt; &quot;과 &quot; &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; &quot;는 모두 같은 값 3bad086a를가집니다.</target>
        </trans-unit>
        <trans-unit id="2689caac6d3ec6ddc37d1cac015f4e8ae4e22c88" translate="yes" xml:space="preserve">
          <source>Both variables have IDENTICAL COPIES of the reference and they both refer to the same Person Object, the SAME Object on the Heap and NOT A COPY.</source>
          <target state="translated">두 변수 모두 참조의 동일 사본을 가지며 동일한 개인 오브젝트, 힙의 동일한 오브젝트 및 사본이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e9170e035719274989ed5cf55b194f253b0ee3eb" translate="yes" xml:space="preserve">
          <source>But from this example, we can understand that it is infact pass by value only,
  keeping in mind that here we are passing the reference as the value.
  ie: reference is passed by value.
  That's why are able to change and still it holds true after the local scope.
  But we cannot change the actual reference outside the original scope.
  what that means is demonstrated by next example of PassByValueObjectCase2.</source>
          <target state="translated">그러나이 예에서 우리는 실제로 가치에 의한 전달이라는 것을 이해할 수 있습니다. 여기서는 참조로서 가치를 전달한다는 점을 명심하십시오. 즉, 참조는 값으로 전달됩니다. 그렇기 때문에 로컬 범위 이후에도 변경이 가능합니다. 그러나 실제 범위를 벗어난 실제 참조는 변경할 수 없습니다. 그 의미는 PassByValueObjectCase2의 다음 예제에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="006ecf4b1a9cc9edb60404b2fb553d2bccdff314" translate="yes" xml:space="preserve">
          <source>C++ pass by reference example:</source>
          <target state="translated">참조 예제로 C ++ 전달 :</target>
        </trans-unit>
        <trans-unit id="83514ce69e30402f75b91daf4e42e15d62db4d49" translate="yes" xml:space="preserve">
          <source>Check the comment on line #5</source>
          <target state="translated">5 번 라인의 코멘트 확인</target>
        </trans-unit>
        <trans-unit id="ce636731102296dcc967f8d443bba701fa39128c" translate="yes" xml:space="preserve">
          <source>Crash course on stack/heap before we get to the Java implementation:
Values go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria.
Memory in the heap (also known as dynamic memory) is haphazard and disorganized. The JVM just finds space wherever it can, and frees it up as the variables that use it are no longer needed.</source>
          <target state="translated">Java 구현을하기 전에 스택 / 힙에 대한 충돌 코스 : 식당의 플레이트 스택과 같이 값은 스택 순서대로 멋지게 정렬됩니다. 힙의 메모리 (동적 메모리라고도 함)가 우연히 발생하고 구성이 해제되었습니다. JVM은 가능한 한 공간을 찾고 더 이상 사용하지 않는 변수를 확보합니다.</target>
        </trans-unit>
        <trans-unit id="9a4330ec3ed061c85b3e0b082e1656ec35e5d3df" translate="yes" xml:space="preserve">
          <source>Creates new Point object</source>
          <target state="translated">새 Point 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1926dd5e7c03bbf781269e3b1f10a918298da01a" translate="yes" xml:space="preserve">
          <source>Creates new Point reference and initialize that reference to &lt;em&gt;point (refer to)&lt;/em&gt; on previously created Point object.</source>
          <target state="translated">새로운 Point 참조를 작성하고 이전에 작성된 Point 객체의 &lt;em&gt;point (참조)&lt;/em&gt; 에 대한 해당 참조를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="91a5cb67c9d537c081e9f8cf1bbc2d3e758ce171" translate="yes" xml:space="preserve">
          <source>Creating two different Point object with two different reference associated.</source>
          <target state="translated">두 개의 서로 다른 참조가 연결된 두 개의 다른 Point 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b0dda1bfba52f041403c7023d96d1d341ad3c077" translate="yes" xml:space="preserve">
          <source>Data in memory has a &lt;strong&gt;Location&lt;/strong&gt; and at that location there is a value (byte,word, whatever). In Assembly we have a convenient solution to give a &lt;strong&gt;Name&lt;/strong&gt; to certain &lt;strong&gt;Location&lt;/strong&gt; (aka variable), but when compiling the code, the assembler simply replaces &lt;strong&gt;Name&lt;/strong&gt; with the designated location just like your browser replaces domain names with IP addresses.</source>
          <target state="translated">메모리의 데이터에는 &lt;strong&gt;위치가&lt;/strong&gt; 있으며 해당 위치에는 값 (바이트, 단어 등)이 있습니다. 어셈블리에는 특정 &lt;strong&gt;위치&lt;/strong&gt; (일명 변수)에 &lt;strong&gt;이름&lt;/strong&gt; 을 &lt;strong&gt;지정&lt;/strong&gt; 하는 편리한 솔루션이 있지만 코드를 컴파일 할 때 브라우저가 도메인 이름을 IP 주소로 바꾸는 것처럼 어셈블러는 단순히 &lt;strong&gt;이름&lt;/strong&gt; 을 지정된 위치로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="bfb16cd1cd030c8e69601029c768549e17aa7047" translate="yes" xml:space="preserve">
          <source>Declaring a reference named &lt;code&gt;b&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; and assign it a new object of type &lt;code&gt;Foo&lt;/code&gt; with an attribute &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 유형의 &lt;code&gt;b&lt;/code&gt; 라는 참조를 선언하고 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 속성을 가진 &lt;code&gt;Foo&lt;/code&gt; 유형의 새 객체를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0bb0f2661240daa3e654c2b942a4228aef7a6a44" translate="yes" xml:space="preserve">
          <source>Declaring a reference named &lt;code&gt;f&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; and assign it a new object of type &lt;code&gt;Foo&lt;/code&gt; with an attribute &lt;code&gt;&quot;f&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 유형의 &lt;code&gt;f&lt;/code&gt; 라는 참조를 선언하고 &lt;code&gt;&quot;f&quot;&lt;/code&gt; 속성을 가진 &lt;code&gt;Foo&lt;/code&gt; 유형의 새 오브젝트를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="cd9950fdb8d7858353a3702108602c9648dd0e68" translate="yes" xml:space="preserve">
          <source>Does this sound strange and confusing? Let's consider how C implements pass by reference and pass by value. In C, the default convention is pass by value. &lt;code&gt;void foo(int x)&lt;/code&gt; passes an int by value. &lt;code&gt;void foo(int *x)&lt;/code&gt; is a function that does not want an &lt;code&gt;int a&lt;/code&gt;, but a pointer to an int: &lt;code&gt;foo(&amp;amp;a)&lt;/code&gt;. One would use this with the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to pass a variable address.</source>
          <target state="translated">이게 이상하고 혼란스럽게 들립니까? C 구현이 참조로 전달하고 값으로 전달하는 방법을 고려해 봅시다. C에서 기본 규칙은 값으로 전달됩니다. &lt;code&gt;void foo(int x)&lt;/code&gt; 는 int를 값으로 전달합니다. &lt;code&gt;void foo(int *x)&lt;/code&gt; 는 &lt;code&gt;int a&lt;/code&gt; 는 원하지 않지만 int에 대한 포인터는 &lt;code&gt;foo(&amp;amp;a)&lt;/code&gt; 입니다. 변수 주소를 전달하기 위해 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자와 함께 이것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b5854bdd57360320e24b9397418a212d3b8b3fc1" translate="yes" xml:space="preserve">
          <source>Don't try this but person==anotherReferenceToTheSamePersonObject would be true.</source>
          <target state="translated">이것을 시도하지 말고 person == anotherReferenceToTheSamePersonObject는 true입니다.</target>
        </trans-unit>
        <trans-unit id="207ba28fc5d0fc3ff8e2b02914c001bb5bb368b5" translate="yes" xml:space="preserve">
          <source>Down to the core it is technically impossible to pass a reference to anything in any language without representing it (when it immediately becomes a value).</source>
          <target state="translated">핵심은 기술적으로 표현하지 않고 어떤 언어로든 참조를 전달하는 것은 기술적으로 불가능합니다 (즉시 가치가 될 때).</target>
        </trans-unit>
        <trans-unit id="438f74e42d1fb68f2c51553f32173992bba966c9" translate="yes" xml:space="preserve">
          <source>First of all, we need to understand what pass by value and pass by reference are.</source>
          <target state="translated">우선, 우리는 가치에 의한 통과와 참조에 의한 통과가 무엇인지 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e5aff39fe5953d4740386d14bbfaa42a906a8b9" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&quot;&gt;What's the difference between passing by reference vs. passing by value?&lt;/a&gt;</source>
          <target state="translated">첫째, &lt;a href=&quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&quot;&gt;참조로 전달하는 것과 값으로 전달하는 것의 차이점은 무엇입니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e0065a83f42a57a3911225215a70e9b907a2bbc" translate="yes" xml:space="preserve">
          <source>Flow of the program:</source>
          <target state="translated">프로그램의 흐름 :</target>
        </trans-unit>
        <trans-unit id="0dfdb0b2fd7037984e97ec60ea513d8d5b9e3dd0" translate="yes" xml:space="preserve">
          <source>For objects, the pass by value is the value of &lt;em&gt;the reference to the object&lt;/em&gt;.</source>
          <target state="translated">객체의 경우 전달 값은 &lt;em&gt;객체&lt;/em&gt; 에 &lt;em&gt;대한 참조&lt;/em&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="5c00717c1eeb06ca14fc62309936f50e756db581" translate="yes" xml:space="preserve">
          <source>For primitive arguments (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, etc.), the pass by value is &lt;em&gt;the actual value&lt;/em&gt; of the primitive (for example, 3).</source>
          <target state="translated">기본 인수 ( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; 등)의 경우 전달 기준 값은 기본 &lt;em&gt;의 실제 값&lt;/em&gt; (예 : 3)입니다.</target>
        </trans-unit>
        <trans-unit id="d717d5e3b868b30355b36493393d4dedba688590" translate="yes" xml:space="preserve">
          <source>From here scope of &lt;code&gt;tricky&lt;/code&gt; method is gone and you don't have access any more to the references: &lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, &lt;code&gt;temp&lt;/code&gt;. &lt;strong&gt;But important note is that everything you do with these references when they are 'in life' will permanently affect object on which they are &lt;em&gt;point&lt;/em&gt; to.&lt;/strong&gt;</source>
          <target state="translated">여기에서 &lt;code&gt;tricky&lt;/code&gt; 방법의 범위가 사라지고 참조에 더 이상 액세스 할 수 없습니다 : &lt;code&gt;arg1&lt;/code&gt; , &lt;code&gt;arg2&lt;/code&gt; , &lt;code&gt;temp&lt;/code&gt; . &lt;strong&gt;그러나 중요한 점은 이러한 참조가 '생명'일 때 수행하는 모든 작업은 대상이 가리키는 대상에 영구적으로 영향을 미칩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ee364d2560bc79a19a4c72624692c7755f4443f" translate="yes" xml:space="preserve">
          <source>From here, through Point object life, you will access to that object through pnt1
 reference. So we can say that in Java you manipulate object through its reference.</source>
          <target state="translated">여기에서 Point 객체 수명을 통해 pnt1 참조를 통해 해당 객체에 액세스합니다. 따라서 Java에서는 참조를 통해 객체를 조작한다고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c8076e66b55ab8aeac61f85404367064fccd996" translate="yes" xml:space="preserve">
          <source>From the method side, a reference of type &lt;code&gt;Foo&lt;/code&gt; with a name &lt;code&gt;a&lt;/code&gt; is declared and it's initially assigned &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">메소드 측에서 이름이 &lt;code&gt;a&lt;/code&gt; 인 &lt;code&gt;Foo&lt;/code&gt; 유형의 참조가 선언되고 처음에는 &lt;code&gt;null&lt;/code&gt; 이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="7fb62bec2c3a15680c7c08a655906f2b1d75ef3f" translate="yes" xml:space="preserve">
          <source>Getting an outside of the box view, let's look at Assembly or some low level memory management. At the CPU level a &lt;em&gt;reference&lt;/em&gt; to anything immediately becomes a &lt;em&gt;value&lt;/em&gt; if it gets written to memory or to one of the CPU registers. (That is why &lt;em&gt;pointer&lt;/em&gt; is a good definition. It is a value, which has a purpose at the same time).</source>
          <target state="translated">상자 밖에서 어셈블리 또는 일부 저수준 메모리 관리를 살펴 보겠습니다. CPU 레벨에서 메모리 또는 CPU 레지스터 중 하나에 쓰면 어떤 것에 대한 &lt;em&gt;참조&lt;/em&gt; 도 즉시 &lt;em&gt;값이&lt;/em&gt; 됩니다. (그래서 &lt;em&gt;포인터&lt;/em&gt; 가 좋은 정의입니다. 동시에 목적이있는 값입니다).</target>
        </trans-unit>
        <trans-unit id="a09f4f73a25672b2d71176498d77cdaf4f9d5f33" translate="yes" xml:space="preserve">
          <source>He goes on to make the same point regarding objects . . .</source>
          <target state="translated">그는 객체에 관해 같은 점을 지적합니다. . .</target>
        </trans-unit>
        <trans-unit id="dcab7f73c798d9959b167db93301f1b793cb10fc" translate="yes" xml:space="preserve">
          <source>Here is another example that will help you understand the difference (&lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;the classic swap example&lt;/a&gt;):</source>
          <target state="translated">다음은 차이점을 이해하는 데 도움이되는 또 다른 예입니다 ( &lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;클래식 스왑 예&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="095229be47d5e504de9b8c6e3f105270472a7db4" translate="yes" xml:space="preserve">
          <source>Here, you first create new &lt;code&gt;temp&lt;/code&gt; Point reference which will &lt;em&gt;point&lt;/em&gt; on same place like &lt;code&gt;arg1&lt;/code&gt; reference. Then you move reference &lt;code&gt;arg1&lt;/code&gt; to &lt;em&gt;point&lt;/em&gt; to the same place like &lt;code&gt;arg2&lt;/code&gt; reference.
Finally &lt;code&gt;arg2&lt;/code&gt; will &lt;em&gt;point&lt;/em&gt; to the same place like &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">여기에서는 먼저 &lt;code&gt;arg1&lt;/code&gt; 참조와 같은 곳을 &lt;em&gt;가리키는&lt;/em&gt; 새로운 &lt;code&gt;temp&lt;/code&gt; 포인트 참조를 만듭니다. 그런 다음 &lt;code&gt;arg1&lt;/code&gt; 참조를 이동하여 &lt;code&gt;arg2&lt;/code&gt; 참조와 같은 위치를 &lt;em&gt;가리 킵니다&lt;/em&gt; . 마지막으로 &lt;code&gt;arg2&lt;/code&gt; 는 &lt;code&gt;temp&lt;/code&gt; 와 같은 장소를 &lt;em&gt;가리 킵니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="64169e4a61bae86f469a92b3cfc4bae9c3a53858" translate="yes" xml:space="preserve">
          <source>Hopefully this will help.</source>
          <target state="translated">잘하면 이것이 도움이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="e5beaeff3bbae8257639b2987a7f67bd9d85c384" translate="yes" xml:space="preserve">
          <source>However you could make a wrapper for String like this which would make it able to use it with Strings:</source>
          <target state="translated">그러나 String과 함께 사용할 수 있도록 String 래퍼를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26dd9ac7a210ba6a96d874cf5c6e8374ed5dbcf2" translate="yes" xml:space="preserve">
          <source>However, I've seen a couple of blog posts (for example, &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this blog&lt;/a&gt;) that claim that it isn't.</source>
          <target state="translated">그러나 나는 그것이 아니라고 주장하는 두 개의 블로그 게시물 (예 : &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;이 블로그&lt;/a&gt; )을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="ec1be69fa319cc52b285a8bee8c6a7f04ee9e1f8" translate="yes" xml:space="preserve">
          <source>I always think of it as &quot;pass by copy&quot;. It is a copy of the value be it primitive or reference. If it is a primitive it is a copy of the bits that are the value and if it is an Object it is a copy of the reference.</source>
          <target state="translated">나는 항상 그것을 &quot;통과로 통과&quot;로 생각합니다. 프리미티브 또는 참조 값의 사본입니다. 프리미티브 인 경우 값인 비트의 복사본이며, 객체 인 경우 참조의 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="69f13178ffc91e81d12909e0fab0a089bbad804f" translate="yes" xml:space="preserve">
          <source>I always thought Java was &lt;strong&gt;pass-by-reference&lt;/strong&gt;.</source>
          <target state="translated">나는 항상 Java가 &lt;strong&gt;pass-by-reference&lt;/strong&gt; 라고 생각했다.</target>
        </trans-unit>
        <trans-unit id="efd75827ae1611bf4e22af1ec1d50ca7541b3557" translate="yes" xml:space="preserve">
          <source>I can't believe that nobody mentioned Barbara Liskov yet. When she designed CLU in 1974, she ran into this same terminology problem, and she invented the term &lt;em&gt;call by sharing&lt;/em&gt; (also known as &lt;em&gt;call by object-sharing&lt;/em&gt; and &lt;em&gt;call by object&lt;/em&gt;) for this specific case of &quot;call by value where the value is a reference&quot;.</source>
          <target state="translated">나는 아무도 바바라 Liskov를 아직 언급하지 않았다는 것을 믿을 수 없다. 그녀는 1974 년에 CLU를 설계 할 때 동일한 용어 문제에 부딪 쳤고 &quot;값이있는 값에 의한 호출&quot;이라는 특정 경우에 대해 &lt;em&gt;공유 (객체 공유에&lt;/em&gt; &lt;em&gt;의한 호출&lt;/em&gt; 및 &lt;em&gt;객체에 의한 호출&lt;/em&gt; 이라고도 함)라는 &lt;em&gt;호출&lt;/em&gt; 이라는 용어를 발명했습니다. 참조 &quot;.</target>
        </trans-unit>
        <trans-unit id="aeaec84d031aa5cb38d5557cf7de3f76bf7cafb0" translate="yes" xml:space="preserve">
          <source>I don't think I understand the distinction they're making.</source>
          <target state="translated">나는 그들이 만들고있는 차이점을 이해하지 못한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="d5405762999d453eb212ccf6bcc5f6125f900230" translate="yes" xml:space="preserve">
          <source>I feel like arguing about &quot;pass-by-reference vs pass-by-value&quot; is not super-helpful.</source>
          <target state="translated">나는 &quot;기준 별 통과 대 가치 별&quot;에 대해 논쟁하는 것이 도움이되지 않는다고 생각한다.</target>
        </trans-unit>
        <trans-unit id="da328c30116bfb1c498c3407693d22ba90f3115c" translate="yes" xml:space="preserve">
          <source>I have created a thread devoted to these kind of questions for &lt;em&gt;any&lt;/em&gt; programming languages &lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">나는 &lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value&quot;&gt;여기&lt;/a&gt; 프로그래밍 언어에 대한 이런 종류의 질문에 전념하는 스레드를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="be8f8168e2402a238a9976383c81f993f3a3e74e" translate="yes" xml:space="preserve">
          <source>I have seen posts on this topic which describe the low level implementation of parameter passing in Java, which I think is great and very helpful because it makes an abstract idea concrete. However, to me the question is more about &lt;strong&gt;the behavior described in the language specification&lt;/strong&gt; than about the technical implementation of the behavior. This is an exerpt from the &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java Language Specification, section 8.4.1&lt;/a&gt; :</source>
          <target state="translated">Java에서 매개 변수 전달의 저수준 구현을 설명하는이 주제에 대한 게시물을 보았습니다. 추상적 인 아이디어를 구체화하기 때문에 위대하고 매우 유용하다고 생각합니다. 그러나 나에게는 문제의 기술적 구현에 대한 것보다 &lt;strong&gt;언어 사양에 설명 된 동작&lt;/strong&gt; 에 대한 질문이 더 있습니다. 다음은 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java 언어 사양 섹션 8.4.1&lt;/a&gt; 에서 발췌 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb7305997ab86247b2a49056cbf4e89230b9f222" translate="yes" xml:space="preserve">
          <source>I hope this settles the debate, but probably won't.</source>
          <target state="translated">나는 이것이 논쟁을 해결하기를 희망하지만 아마 그렇지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d415e610e2056093f16e0b12b5086931ca855762" translate="yes" xml:space="preserve">
          <source>I hope you understand now how passing objects as arguments works in Java :)</source>
          <target state="translated">Java에서 인수로 객체를 전달하는 방법을 이해하기를 바랍니다. :)</target>
        </trans-unit>
        <trans-unit id="53b25f35c0f07624c3ab774845793894e9df085c" translate="yes" xml:space="preserve">
          <source>I just noticed you referenced &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;my article&lt;/a&gt;.</source>
          <target state="translated">난 당신이 &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;내 기사&lt;/a&gt; 를 참조한 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="2935658c6ca5dd052a7a1348a0e9a0f71fe8584b" translate="yes" xml:space="preserve">
          <source>I might be a little obsessed with this post. Probably because I feel that the makers of Java inadvertently spread misinformation. If instead of using the word &quot;reference&quot; for pointers they had used something else, say 
dingleberry, there would've been no problem. You could say, &quot;Java passes dingleberries by value and not by reference&quot;, and nobody would be confused. (Hence forth, when referencing pass by reference vs value, I shall refer to references as dinglebarries.)</source>
          <target state="translated">이 게시물에 약간 집착했을 수도 있습니다. 아마도 Java 제작자가 실수로 잘못된 정보를 퍼뜨렸다 고 생각하기 때문일 것입니다. 포인터에 &quot;reference&quot;라는 단어를 사용하는 대신 dingleberry와 같은 다른 것을 사용했다면 아무런 문제가 없었을 것입니다. &quot;자바는 딩글 베리를 참조가 아닌 가치에 따라 전달한다&quot;고 말할 수 있으며, 아무도 혼동하지 않을 것입니다. (따라서 참조 대 값으로 패스를 참조하는 경우 참조를 dinglebarries라고합니다.)</target>
        </trans-unit>
        <trans-unit id="dbf80c5168a8cdece318ecb980f6dc4582312bc0" translate="yes" xml:space="preserve">
          <source>I think the difference between the two models is very subtle and unless you've done programming where you actually used pass-by-reference, it's easy to miss where two models differ.</source>
          <target state="translated">두 모델의 차이점은 매우 미묘하다고 생각합니다. 실제로 참조로 전달하는 곳에서 프로그래밍을 수행하지 않으면 두 모델이 다른 곳을 놓치기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="051719f18cca69c8321cf2db575cbe7c3c8fc918" translate="yes" xml:space="preserve">
          <source>I thought I'd contribute this answer to add more details from the Specifications.</source>
          <target state="translated">나는이 답변을 스펙의 세부 사항을 추가하기 위해 기여할 것이라고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="02668452fdc578abe59e37b1d267b95f2c167d43" translate="yes" xml:space="preserve">
          <source>I will explain this in steps:</source>
          <target state="translated">나는 이것을 단계적으로 설명 할 것이다 :</target>
        </trans-unit>
        <trans-unit id="7e24c4c25b98f1916d4e52df7af6eeb891b2b203" translate="yes" xml:space="preserve">
          <source>If Java had pass-by-reference semantics, the &lt;code&gt;foo&lt;/code&gt; method we defined above would have changed where &lt;code&gt;myDog&lt;/code&gt; was pointing when it assigned &lt;code&gt;someDog&lt;/code&gt; on line BBB.</source>
          <target state="translated">Java가 참조 별 통과 의미론을 가지고 있다면, 위에서 정의한 &lt;code&gt;foo&lt;/code&gt; 메소드는 &lt;code&gt;someDog&lt;/code&gt; 가 BBB 라인에서 someDog 를 지정할 때 가리키는 위치를 변경했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="6697d56d6fde5f640c216d07a963f93b03bd1f54" translate="yes" xml:space="preserve">
          <source>If it's a primitive data type these bits contain the value of the primitive data type itself, That's why if we change the value of header inside the method then it does not reflect the changes outside.</source>
          <target state="translated">그것이 원시 데이터 유형이라면,이 비트들은 원시 데이터 유형 자체의 값을 포함합니다. 따라서 우리가 메소드 내부의 헤더 값을 변경하면 외부의 변경 사항을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79742ec00dad7a7b993ddfde20c405582b74811d" translate="yes" xml:space="preserve">
          <source>If it's a primitive data type these bits will contain the value of the primitive data type itself.</source>
          <target state="translated">기본 데이터 유형 인 경우이 비트에는 기본 데이터 유형 자체의 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f0283f6b09b05e1b1e2ef39baf027825432d4169" translate="yes" xml:space="preserve">
          <source>If it's an Object the bits will contain the value of the address that tells the JVM how to get to the Object.</source>
          <target state="translated">그것이 Object 인 경우 비트는 JVM에게 Object에 도달하는 방법을 알려주는 주소 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8a2c1b22c98b47861f2f787055fd5f2fa95e5b32" translate="yes" xml:space="preserve">
          <source>If it's an object data type like &lt;strong&gt;Foo foo=new Foo()&lt;/strong&gt; then in this case copy of the address of the object passes like file shortcut  , suppose we have a text file &lt;strong&gt;abc.txt&lt;/strong&gt; at &lt;strong&gt;C:\desktop&lt;/strong&gt; and suppose we make shortcut of the same file and put this inside &lt;strong&gt;C:\desktop\abc-shortcut&lt;/strong&gt; so when you access the file from &lt;strong&gt;C:\desktop\abc.txt&lt;/strong&gt; and write &lt;strong&gt;'Stack Overflow'&lt;/strong&gt; and close the file and again you open the file from shortcut then you write &lt;strong&gt;' is the largest online community for programmers to learn'&lt;/strong&gt; then total file change will be &lt;strong&gt;'Stack Overflow is the largest online community for programmers to learn'&lt;/strong&gt; which means it doesn't matter from where you open the file , each time we were accessing the same file , here we can assume &lt;strong&gt;Foo&lt;/strong&gt; as a file and suppose foo stored at &lt;strong&gt;123hd7h&lt;/strong&gt;(original address like &lt;strong&gt;C:\desktop\abc.txt&lt;/strong&gt; ) address and &lt;strong&gt;234jdid&lt;/strong&gt;(copied address like &lt;strong&gt;C:\desktop\abc-shortcut&lt;/strong&gt; which actually contains the original address of the file inside) ..
So for better understanding make shortcut file and feel..</source>
          <target state="translated">&lt;strong&gt;Foo foo = new Foo ()&lt;/strong&gt; 와 같은 객체 데이터 유형 인 경우이 경우 객체의 주소 사본이 파일 바로 가기처럼 전달됩니다 &lt;strong&gt;.C : \ desktop에&lt;/strong&gt; 텍스트 파일 &lt;strong&gt;abc.txt&lt;/strong&gt; 가 있고 바로 가기를 만든다고 가정합니다. 같은 파일을 &lt;strong&gt;C : \ desktop \ abc-shortcut에&lt;/strong&gt; 넣으십시오 &lt;strong&gt;.C : \ desktop \ abc.txt&lt;/strong&gt; 에서 파일에 액세스하고 &lt;strong&gt;'Stack Overflow'를&lt;/strong&gt; 작성하고 파일을 닫은 다음 바로 가기에서 파일을 다시 열면 write &lt;strong&gt;'는 프로그래머가 배울 수있는 가장 큰 온라인 커뮤니티'입니다.&lt;/strong&gt; 그러면 총 파일 변경은 &lt;strong&gt;'Stack Overflow는 프로그래머가 배울 수있는 가장 큰 온라인 커뮤니티'&lt;/strong&gt; 입니다. 즉, 액세스 할 때마다 파일을 여는 위치에서 중요하지 않습니다. 동일한 파일, 여기에서 &lt;strong&gt;Foo&lt;/strong&gt; 를 파일로 가정하고 foo가 &lt;strong&gt;123hd7h&lt;/strong&gt; ( &lt;strong&gt;C : \ desktop \ abc.txt&lt;/strong&gt; 와 같은 원래 주소) 주소와 &lt;strong&gt;234jdid&lt;/strong&gt; ( &lt;strong&gt;C : \ desktop \ abc-shortcut&lt;/strong&gt; 과 같이 실제로 복사 된 주소)에 저장된 것으로 가정 할 수 있습니다 내부 파일의 원래 주소) .. 더 나은 이해를 위해 바로 가기 파일과 느낌을 만드십시오 ..</target>
        </trans-unit>
        <trans-unit id="d09449cf7c49c0bb34af69bedb5138b6a6cf6571" translate="yes" xml:space="preserve">
          <source>If we pass the value of array1 reference variable as an argument to the reverseArray method, a reference variable is created in the method and that reference variable starts pointing to the same array (a).</source>
          <target state="translated">array1 참조 변수의 값을 reverseArray 메소드의 인수로 전달하면 참조 변수가 메소드에 작성되고 해당 참조 변수가 동일한 배열 (a)을 가리 키기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="111cce0df4d6a3eea4ae694172e96a48fec02a36" translate="yes" xml:space="preserve">
          <source>If we return value of reference variable array2 as the return value of method reverseArray and assign this value to reference variable array1 in main method, array1 in main will start pointing to array c.</source>
          <target state="translated">참조 변수 array2의 값을 reverseArray 메소드의 리턴 값으로 리턴하고이 값을 main 메소드의 참조 변수 array1에 지정하면 main의 array1이 배열 c를 가리 키기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="cdd0e1a5c0a10b05b85a4f05bf0c8857fb0dc54a" translate="yes" xml:space="preserve">
          <source>If we want to call a method/function/procedure with Foo's value, there are a few possible way to pass the variable to the method, depending on the &lt;strong&gt;language&lt;/strong&gt; and its several method invocation modes:</source>
          <target state="translated">Foo 값으로 메소드 / 함수 / 프로 시저를 호출하려면 &lt;strong&gt;언어&lt;/strong&gt; 와 여러 메소드 호출 모드에 따라 메소드에 변수를 전달할 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae7787cfc8ddd2039110866a573a0e2714e49edb" translate="yes" xml:space="preserve">
          <source>If you change anything in the function using reference f it will modify the existing contents of the object. That is why we got the output &lt;code&gt;changevalue&lt;/code&gt;,   which is updated in the function.</source>
          <target state="translated">참조 f를 사용하여 함수에서 내용을 변경하면 객체의 기존 내용이 수정됩니다. 그렇기 때문에 출력값이 &lt;code&gt;changevalue&lt;/code&gt; 되어 함수에서 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="fe4914949893eeb60b019dffcc6cea87be8dcc83" translate="yes" xml:space="preserve">
          <source>If you didn't get it then just trust me and remember that it's better to say that &lt;strong&gt;Java is pass by value&lt;/strong&gt;. Well, &lt;strong&gt;pass by reference value&lt;/strong&gt;. Oh well, even better is &lt;strong&gt;&lt;em&gt;pass-by-copy-of-the-variable-value! ;)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">당신이 그것을 얻지 못하면 저를 믿어 &lt;strong&gt;Java가 가치에 의해 전달&lt;/strong&gt; 된다고 말하는 것이 좋습니다. 음, &lt;strong&gt;참조 값으로 전달하십시오&lt;/strong&gt; . 글쎄, 훨씬 더 나은 &lt;strong&gt;&lt;em&gt;값의 복사 값&lt;/em&gt;&lt;/strong&gt; 이 더 좋습니다 &lt;strong&gt;&lt;em&gt;!&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;;)&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d76bdbeace9817e06089a031711671ab9b1f87b3" translate="yes" xml:space="preserve">
          <source>If you say, &quot;Java is pass-by-whatever (reference/value)&quot;, in either case, you're not provide a complete answer. Here's some additional information that will hopefully aid in understanding what's happening in memory.</source>
          <target state="translated">두 경우 모두 &quot;자바는 전달 (참조 / 값)입니다&quot;라고 말하면 완전한 답을 제공 할 수 없습니다. 다음은 메모리에서 발생하는 상황을 이해하는 데 도움이되는 추가 정보입니다.</target>
        </trans-unit>
        <trans-unit id="2864474958a88d28e0e852e593201018ce309c3a" translate="yes" xml:space="preserve">
          <source>In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.</source>
          <target state="translated">C ++, Ada, Pascal 및 참조 별 전달을 지원하는 기타 언어에서는 전달 된 변수를 실제로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd1ab35d296b25bfeeda42a17c0845735976d063" translate="yes" xml:space="preserve">
          <source>In C++: &lt;strong&gt;Note: Bad code - memory leaks!&lt;/strong&gt;  But it demonstrates the point.</source>
          <target state="translated">C ++ : &lt;strong&gt;참고 : 잘못된 코드-메모리 누수!&lt;/strong&gt; 그러나 그것은 요점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="70a7832950563eb1e68d730cfc8633aecba50e12" translate="yes" xml:space="preserve">
          <source>In Java,</source>
          <target state="translated">자바에서는</target>
        </trans-unit>
        <trans-unit id="ee32c40f3e465ae5371086558cba52983a8a32d8" translate="yes" xml:space="preserve">
          <source>In Java, all parameters are passed by value, i.e. assigning a method argument is not visible to the caller.</source>
          <target state="translated">Java에서 모든 매개 변수는 값으로 전달됩니다. 즉 메소드 인수 지정은 호출자에게 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea4a661eaa255681fb44e9a0ceb260d8c9521fd5" translate="yes" xml:space="preserve">
          <source>In Java, modifying the variable means reassigning it. In Java, if you reassigned the variable within the method, it would go unnoticed to the caller. &lt;strong&gt;Modifying the object referenced by the variable is a different concept entirely.&lt;/strong&gt;</source>
          <target state="translated">Java에서 변수를 수정하면 변수를 다시 할당해야합니다. Java에서는 메소드 내에서 변수를 다시 지정하면 호출자에게 알리지 않습니다. &lt;strong&gt;변수가 참조하는 객체를 수정하는 것은 완전히 다른 개념입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ec57628bd6a19cc372e0d82956fbc9926fe31cc" translate="yes" xml:space="preserve">
          <source>In addition to what was mentioned in Example3 (PassByValueObjectCase1.java),  we cannot change the actual reference outside the original scope.&quot;</source>
          <target state="translated">Example3 (PassByValueObjectCase1.java)에 언급 된 것 외에도 실제 범위를 벗어난 실제 참조를 변경할 수 없습니다. &quot;</target>
        </trans-unit>
        <trans-unit id="bf42410ba453a42ec3533408e27e6dbcc281e995" translate="yes" xml:space="preserve">
          <source>In call-by-reference evaluation (also referred to as
  pass-by-reference), a function receives an implicit reference to a
  variable used as argument, rather than a copy of its value. This
  typically means that the function can modify (i.e. assign to) the
  variable used as argument&amp;mdash;something that will be seen by its caller.</source>
          <target state="translated">참조 별 호출 평가 (참조 별 전달이라고도 함)에서 함수는 값의 사본이 아니라 인수로 사용되는 변수에 대한 암시 적 참조를받습니다. 이는 일반적으로 함수가 인수로 사용 된 변수 (호출자가 볼 수있는 변수)를 수정할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b7b4cb1ed7c07a761b7c04a976a8f1ba04382e4" translate="yes" xml:space="preserve">
          <source>In call-by-value, the actual parameter is evaluated (if it is an
  expression) or copied (if it is a variable). The value is placed in
  the location belonging to the corresponding formal parameter of the
  called procedure. &lt;strong&gt;This method is used in C and Java, and is a common
  option in C++ , as well as in most other languages.&lt;/strong&gt;</source>
          <target state="translated">값별 호출에서는 실제 매개 변수가 평가되거나 (표현식 인 경우) 복사됩니다 (변수 인 경우). 값은 호출 된 프로 시저의 해당 형식 매개 변수에 속하는 위치에 배치됩니다. &lt;strong&gt;이 메소드는 C 및 Java에서 사용되며 대부분의 다른 언어뿐만 아니라 C ++에서도 일반적인 옵션입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80cff4aaaefaebbc2f88f5d26ae6ac275dc4f40b" translate="yes" xml:space="preserve">
          <source>In call-by-value, the argument expression is evaluated, and the
  resulting value is bound to the corresponding variable in the function [...]. 
  If the function or procedure is able to assign values to its
  parameters, only its local copy is assigned [...].</source>
          <target state="translated">값별 호출에서 인수 표현식이 평가되고 결과 값이 함수 [...]의 해당 변수에 바인딩됩니다. 함수 또는 프로 시저가 매개 변수에 값을 지정할 수있는 경우 로컬 사본 만 [...]으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="bd4f5299b140615753485c299e8a2e77b0c5997f" translate="yes" xml:space="preserve">
          <source>In case of Objects, this is the same: 
Object variables are pointers (buckets) holding only Object&amp;rsquo;s &lt;strong&gt;address&lt;/strong&gt; that was created using the &quot;new&quot; keyword, and are copied like primitive types.</source>
          <target state="translated">객체의 경우 동일합니다. 객체 변수는 &quot;new&quot;키워드를 사용하여 생성 된 객체의 &lt;strong&gt;주소&lt;/strong&gt; 만 보유하는 포인터 (버킷)이며 기본 유형처럼 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="fc3d33069def51ed42a9766ed121449803b82259" translate="yes" xml:space="preserve">
          <source>In effect, using a method, you will never be able, to update the value of a String passed as argument:</source>
          <target state="translated">실제로 메소드를 사용하면 인수로 전달 된 문자열의 값을 업데이트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="80da013ae7fbb0cb942c6b9e18118975ac88e298" translate="yes" xml:space="preserve">
          <source>In every cases above a value - a &lt;strong&gt;copy&lt;/strong&gt; of an existing value - has been created, it is now upto the receiving method to handle it. When you write &quot;Foo&quot; inside the method, it is either read out from EAX, or automatically  &lt;strong&gt;dereferenced&lt;/strong&gt;, or double dereferenced, the process depends on how the language works and/or what the type of Foo dictates. This is hidden from the developer until she circumvents the dereferencing process. So a &lt;em&gt;reference&lt;/em&gt; is a &lt;em&gt;value&lt;/em&gt; when represented, because a reference is a value that has to be processed (at language level).</source>
          <target state="translated">기존 값의 &lt;strong&gt;사본&lt;/strong&gt; 인 값 위의 모든 경우에 이제 값을 처리하는 수신 방법이 결정됩니다. 메소드 내에 &quot;Foo&quot;를 쓸 때, EAX에서 읽거나 자동으로 &lt;strong&gt;역 참조&lt;/strong&gt; 되거나 이중 역 참조되면 프로세스는 언어 작동 방식 및 / 또는 Foo 유형에 따라 다릅니다. 이는 역 참조 프로세스를 우회 할 때까지 개발자에게 숨겨져 있습니다. 따라서 &lt;em&gt;참조&lt;/em&gt; 는 처리되어야하는 값 (언어 레벨에서)이므로 참조는 표현 될 때의 값입니다.</target>
        </trans-unit>
        <trans-unit id="58d4de45900cd3a103d99c18d12234d5bb3d377d" translate="yes" xml:space="preserve">
          <source>In general, Java has primitive types (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, etc) that are passed directly by value. Then Java has objects (everything that derives from &lt;code&gt;java.lang.Object&lt;/code&gt;). Objects are actually always handled through a reference (a reference being a pointer that you can't touch). That means that in effect, objects are passed by reference, as the references are normally not interesting. It does however mean that you cannot change which object is pointed to as the reference itself is passed by value.</source>
          <target state="translated">일반적으로 Java에는 값에 의해 직접 전달되는 기본 유형 ( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 등)이 있습니다. 그런 다음 Java에는 객체 ( &lt;code&gt;java.lang.Object&lt;/code&gt; 에서 파생되는 모든 것)가 있습니다. 실제로 객체는 항상 참조 (터치 할 수없는 포인터 인 참조)를 통해 처리됩니다. 이는 사실상 참조가 흥미롭지 않기 때문에 객체가 참조로 전달됨을 의미합니다. 그러나 참조 자체가 값으로 전달 될 때 가리키는 오브젝트를 변경할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="45cfc45c3c6f01b610517a50ecd3388655190ac5" translate="yes" xml:space="preserve">
          <source>In java everything is reference, so when you have something like:
    &lt;code&gt;Point pnt1 = new Point(0,0);&lt;/code&gt; Java does following:</source>
          <target state="translated">자바에서는 모든 것이 참조이므로 다음과 같은 것이있을 때 : &lt;code&gt;Point pnt1 = new Point(0,0);&lt;/code&gt; 자바는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b73ac48cac4cc50104187760bd5de00365a5e1fd" translate="yes" xml:space="preserve">
          <source>In line #4 you can listen to the sound of silence</source>
          <target state="translated">4 번 라인에서 침묵의 소리를들을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f876ee91061153b58472e3caad886db2830e5e6c" translate="yes" xml:space="preserve">
          <source>In pascal, parameters passed-by-reference are called &quot;var parameters&quot;. In the procedure setToNil below, please note the keyword 'var' which precedes the parameter 'ptr'. When a pointer is passed to this procedure, it will be passed &lt;strong&gt;by reference&lt;/strong&gt;. Note the behavior: when this procedure sets ptr to nil (that's pascal speak for NULL), it will set the argument to nil--you can't do that in Java.</source>
          <target state="translated">파스칼에서 참조에 의해 전달 된 매개 변수를 &quot;var 매개 변수&quot;라고합니다. 아래 setToNil 프로 시저에서 'ptr'매개 변수 앞에 오는 키워드 'var'에 유의하십시오. 이 프로 시저에 포인터가 전달되면 &lt;strong&gt;reference&lt;/strong&gt; 로 전달 &lt;strong&gt;됩니다&lt;/strong&gt; . 이 절차는 ptr을 nil로 설정하면 (파스칼은 NULL), 인수를 nil로 설정합니다. Java에서는이를 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e25ccb4e75ab4aec689df71744743c33feb9136" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;tricky&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;tricky&lt;/code&gt; 방법에서 :</target>
        </trans-unit>
        <trans-unit id="556c40767e22c9d0e16c7d2e8fd66f4fc3765ab3" translate="yes" xml:space="preserve">
          <source>In the C++ example below I'm passing a &lt;strong&gt;pointer&lt;/strong&gt; to a null terminated string &lt;strong&gt;by reference&lt;/strong&gt;. And in the Java example below I'm passing a Java reference to a String (again, the same as a pointer to a String) by value. Notice the output in the comments.</source>
          <target state="translated">아래의 C ++ 예제 &lt;strong&gt;에서 reference&lt;/strong&gt; 로 null 종료 문자열 &lt;strong&gt;에 대한&lt;/strong&gt; &lt;strong&gt;포인터&lt;/strong&gt; 를 전달합니다. 그리고 아래의 Java 예제에서 나는 Java 참조를 String (또한 String에 대한 포인터와 동일)에 값으로 전달합니다. 주석의 출력을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="eaf8d1084a66af0ad2274ebc5bf33bd05b487e6a" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;Fifi&lt;/code&gt; is the dog's name after call to &lt;code&gt;foo(aDog)&lt;/code&gt; because the object's name was set inside of &lt;code&gt;foo(...)&lt;/code&gt;. Any operations that &lt;code&gt;foo&lt;/code&gt; performs on &lt;code&gt;d&lt;/code&gt; are such that, for all practical purposes, they are performed on &lt;code&gt;aDog&lt;/code&gt;, but it is &lt;strong&gt;not&lt;/strong&gt; possible to change the value of the variable &lt;code&gt;aDog&lt;/code&gt; itself.</source>
          <target state="translated">위의 예에서 &lt;code&gt;Fifi&lt;/code&gt; 는 객체의 이름이 &lt;code&gt;foo(...)&lt;/code&gt; 안에 설정 되었기 때문에 &lt;code&gt;foo(aDog)&lt;/code&gt; 호출 한 후 개의 이름입니다. &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;d&lt;/code&gt; 에서 수행하는 모든 작업은 모든 실제적인 목적으로 &lt;code&gt;aDog&lt;/code&gt; 에서 수행되지만 변수 &lt;code&gt;aDog&lt;/code&gt; 자체의 값을 변경할 수는 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e5f1d7ec3ad0697448f7bd1694b6d4a13eec5e90" translate="yes" xml:space="preserve">
          <source>In the case of primitive types, Java behaviour is simple: 
The value is copied in another instance of the primitive type.</source>
          <target state="translated">기본 유형의 경우 Java 동작은 간단합니다. 기본 유형의 다른 인스턴스에 값이 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="a522d3c2682539ae850f96edab1cea9361d6e16b" translate="yes" xml:space="preserve">
          <source>In the example above &lt;code&gt;aDog.getName()&lt;/code&gt; will still return &lt;code&gt;&quot;Max&quot;&lt;/code&gt;. The value &lt;code&gt;aDog&lt;/code&gt; within &lt;code&gt;main&lt;/code&gt; is not changed in the function &lt;code&gt;foo&lt;/code&gt; with the &lt;code&gt;Dog&lt;/code&gt;&lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; as the object reference is passed by value. If it were passed by reference, then the &lt;code&gt;aDog.getName()&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt; would return &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; after the call to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;aDog.getName()&lt;/code&gt; 은 여전히 &lt;code&gt;&quot;Max&quot;&lt;/code&gt; 를 반환합니다. 개체 참조가 값으로 전달되므로 &lt;code&gt;Dog&lt;/code&gt; 내의 &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; 를 사용하여 &lt;code&gt;foo&lt;/code&gt; 함수에서 &lt;code&gt;main&lt;/code&gt; 내의 값 &lt;code&gt;aDog&lt;/code&gt; 는 변경되지 않습니다. 참조로 전달 된 경우 &lt;code&gt;main&lt;/code&gt; 의 &lt;code&gt;aDog.getName()&lt;/code&gt; 은 &lt;code&gt;foo&lt;/code&gt; 호출 후 &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2767cb995f4a551872be17db0731dc32b9631113" translate="yes" xml:space="preserve">
          <source>In the following (please don't try to compile/execute this...):</source>
          <target state="translated">다음에서 (컴파일 / 실행하려고하지 마십시오 ...) :</target>
        </trans-unit>
        <trans-unit id="3cc72807c6aa2f7787bc1d2e01e7b1a38a8163b3" translate="yes" xml:space="preserve">
          <source>In the image below you can see we have two reference variables(These are called pointers in C/C++, and I think that term makes it easier to understand this feature.) in the main method. Primitive and reference variables are kept in stack memory(left side in images below). array1 and array2 reference variables &quot;point&quot; (as C/C++ programmers call it) or reference to a and b arrays respectively, which are objects (values these reference variables hold are addresses of objects) in heap memory (right side in images below).</source>
          <target state="translated">아래 이미지에서 우리는 두 가지 참조 변수가 있음을 알 수 있습니다 (C / C ++에서는 포인터라고하며,이 용어는이 기능을 이해하기가 더 쉽다고 생각합니다). 기본 변수와 참조 변수는 스택 메모리에 저장됩니다 (아래 이미지의 왼쪽). array1 및 array2 참조 변수 &quot;point&quot;(C / C ++ 프로그래머가 호출 할 때) 또는 a 및 b 배열 각각에 대한 힙 메모리의 객체 (이러한 참조 변수가 보유한 값은 객체의 주소 임) (아래 이미지의 오른쪽) .</target>
        </trans-unit>
        <trans-unit id="1db423d4e50678143cbe574c1553ab77c64d2ec7" translate="yes" xml:space="preserve">
          <source>Is Java “pass-by-reference” or “pass-by-value”</source>
          <target state="translated">Java가 &quot;Pass-by-Reference&quot;또는 &quot;Pass-by-Value&quot;입니까?</target>
        </trans-unit>
        <trans-unit id="da12241a17ef14fa43fa2b4e3155933518c0d4e0" translate="yes" xml:space="preserve">
          <source>It goes like this:</source>
          <target state="translated">다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="98f312d82b1864aed2fd685327b3e2e9e1d88ca2" translate="yes" xml:space="preserve">
          <source>It's perfectly valid to &lt;em&gt;follow&lt;/em&gt; an address and change what's at the end of it; that does not change the variable, however.</source>
          <target state="translated">주소를 &lt;em&gt;따르고&lt;/em&gt; 끝에있는 것을 변경하는 것은 완벽하게 유효합니다. 그러나 변수를 변경하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5635fa4e11fcd1915675b96d22971357494e751" translate="yes" xml:space="preserve">
          <source>Java always passes arguments &lt;em&gt;by value&lt;/em&gt;, NOT by reference.</source>
          <target state="translated">Java는 항상 참조가 아닌 &lt;em&gt;값으로&lt;/em&gt; 인수 &lt;em&gt;를&lt;/em&gt; 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1e1d0bd5765a75bcdfc28bab135f3be439234c61" translate="yes" xml:space="preserve">
          <source>Java arguments are &lt;strong&gt;all passed by value&lt;/strong&gt; (the reference is copied when used by the method) :</source>
          <target state="translated">Java 인수는 &lt;strong&gt;모두 값으로 전달됩니다&lt;/strong&gt; (메서드가 메소드를 사용할 때 참조가 복사 됨).</target>
        </trans-unit>
        <trans-unit id="d45e3643eb2a0c3cfaa96ee1ba516a58b305181b" translate="yes" xml:space="preserve">
          <source>Java has only pass by value. A very simple example to validate this.</source>
          <target state="translated">자바는 가치를 지니고있다. 이를 검증하는 매우 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="703fb214de1457e7f2c05c6d4fec19e41f4cb320" translate="yes" xml:space="preserve">
          <source>Java is a call by value</source>
          <target state="translated">자바는 가치에 의한 호출</target>
        </trans-unit>
        <trans-unit id="3acd670af680bc110c036092f510ce1f098fa3fb" translate="yes" xml:space="preserve">
          <source>Java is always &lt;strong&gt;pass-by-value&lt;/strong&gt;. Unfortunately, when we pass the value of an object, we are passing the &lt;em&gt;reference&lt;/em&gt; to it.  This is confusing to beginners.</source>
          <target state="translated">자바는 항상 &lt;strong&gt;가치가있다&lt;/strong&gt; . 불행히도, 우리는 객체의 값을 전달할 때 그 &lt;em&gt;참조&lt;/em&gt; 를 전달합니다. 초보자에게는 혼동 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="d999ec799d7d7e3e79463bd37bb62eacf6e25b10" translate="yes" xml:space="preserve">
          <source>Java is always pass by value, with no exceptions, &lt;strong&gt;ever&lt;/strong&gt;.</source>
          <target state="translated">Java는 예외없이 항상 가치를 지니고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bffa033db8f0f65b32ac37222c7fbfe326862449" translate="yes" xml:space="preserve">
          <source>Java is pass by value according to the Java Language Specification:</source>
          <target state="translated">Java는 Java 언어 사양에 따라 값으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5d5b05490570ab7df7923106ad5234571b0ba144" translate="yes" xml:space="preserve">
          <source>Java is pass-by-value because inside a method you can modify the referenced Object as much as you want but no matter how hard you try you'll never be able to modify the passed variable that will keep referencing (not p _ _ _ _ _ _ _) the same Object no matter what!</source>
          <target state="translated">메소드 내에서 참조 된 객체를 원하는만큼 수정할 수는 있지만 아무리 노력해도 참조를 계속 전달하는 전달 된 변수를 수정할 수는 없기 때문에 Java는 값을 전달합니다 (p _ _ _ 아님) _ _ _ _) 무엇이든 상관없이 동일한 객체!</target>
        </trans-unit>
        <trans-unit id="45192a707a26fe3bb2f92c6fbcb126e95a6e9b0e" translate="yes" xml:space="preserve">
          <source>Java only has the two types of passing: by value for built-in types, and by value of the pointer for object types.</source>
          <target state="translated">Java에는 두 가지 유형의 전달 만 있습니다. 내장 유형의 값 및 오브젝트 유형의 포인터 값.</target>
        </trans-unit>
        <trans-unit id="529efc0a206bb877a5914af86dac2e005794eacf" translate="yes" xml:space="preserve">
          <source>Java pass &quot;a Java reference&quot; by value example</source>
          <target state="translated">값 예제로 Java 전달 &quot;Java 참조&quot;</target>
        </trans-unit>
        <trans-unit id="3a23cc46246cbf17c3306653ed35fc739dd92303" translate="yes" xml:space="preserve">
          <source>Java passes it parameters by value</source>
          <target state="translated">Java는 값으로 매개 변수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="93f3aa9ad265f6adfea081d81b4ce0f2dd3364f2" translate="yes" xml:space="preserve">
          <source>Java passes references by value.</source>
          <target state="translated">Java는 값으로 참조를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="866018b39b9f976d7a4fda32831571acb3fe531a" translate="yes" xml:space="preserve">
          <source>Java passes references to objects by value.</source>
          <target state="translated">Java는 값으로 객체에 대한 참조를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="cb688bcbe4d4a31366fbbe80d020a8f8c54e722d" translate="yes" xml:space="preserve">
          <source>Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, you cannot change where that pointer points.</source>
          <target state="translated">Java는 C와 똑같이 작동합니다. 포인터를 지정하고 포인터를 메소드에 전달하고 메소드의 포인터를 따라 지시 된 데이터를 변경할 수 있습니다. 그러나 해당 포인터가 가리키는 위치는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c3ceb58d38297bd42517df14fa453efa53f2e920" translate="yes" xml:space="preserve">
          <source>Just to show the contrast, compare the following &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C++&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; snippets:</source>
          <target state="translated">대비를 보여주기 위해 다음 &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C ++&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; 스 니펫을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="76eed6720175d9c487a151ea0ec369ca6ff2bea0" translate="yes" xml:space="preserve">
          <source>Keeping in mind that &lt;code&gt;myDog&lt;/code&gt; is a &lt;em&gt;pointer&lt;/em&gt;, and not an actual &lt;code&gt;Dog&lt;/code&gt;, the answer is NO. &lt;code&gt;myDog&lt;/code&gt; still has the value 42; it's still pointing to the original &lt;code&gt;Dog&lt;/code&gt; (but note that because of line &quot;AAA&quot;, its name is now &quot;Max&quot; - still the same Dog; &lt;code&gt;myDog&lt;/code&gt;'s value has not changed.)</source>
          <target state="translated">&lt;code&gt;myDog&lt;/code&gt; 은 실제 &lt;code&gt;Dog&lt;/code&gt; 가 아니라 &lt;em&gt;포인터&lt;/em&gt; 라는 것을 명심하십시오. 대답은 NO입니다. &lt;code&gt;myDog&lt;/code&gt; 의 값은 여전히 ​​42입니다. 여전히 원래 &lt;code&gt;Dog&lt;/code&gt; 를 가리키고 있습니다. 그러나 &quot;AAA&quot;라인으로 인해 이름은 &quot;Max&quot;입니다. 여전히 같은 Dog이며 &lt;code&gt;myDog&lt;/code&gt; 의 값은 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2671b77ed672eeae8e1bb043ed9cddaa3c26b00f" translate="yes" xml:space="preserve">
          <source>Let me explain this through an &lt;a href=&quot;https://stackoverflow.com/a/9404727/597657&quot;&gt;example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/9404727/597657&quot;&gt;예를&lt;/a&gt; 통해 이것을 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="1769d859356c9306da11a136d37d7bc840e8173d" translate="yes" xml:space="preserve">
          <source>Let me try to explain my understanding with the help of four examples. Java is pass-by-value, and not pass-by-reference</source>
          <target state="translated">네 가지 예를 통해 이해를 설명하려고 노력하겠습니다. Java는 값으로 전달되며 참조로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="667ee93519391efd5ef048789e42e4cd7eb32ed7" translate="yes" xml:space="preserve">
          <source>Let's consider reference types, the &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4&quot;&gt;Java Virtual Machine Specification&lt;/a&gt; states</source>
          <target state="translated">참조 유형을 고려해 봅시다. &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4&quot;&gt;Java Virtual Machine Specification&lt;/a&gt; 상태</target>
        </trans-unit>
        <trans-unit id="017c2442a73e3b150be4f8d7101d3d565a83f364" translate="yes" xml:space="preserve">
          <source>Let's understand step by step:</source>
          <target state="translated">단계별로 이해하자 :</target>
        </trans-unit>
        <trans-unit id="5685f4b4e04daf5f5c1aa0517659cc4fb4246e59" translate="yes" xml:space="preserve">
          <source>Lets say we have a variable Foo, its &lt;strong&gt;Location&lt;/strong&gt; is at the 47th byte in memory and its &lt;strong&gt;Value&lt;/strong&gt; is 5. We have another variable &lt;strong&gt;Ref2Foo&lt;/strong&gt; which is at 223rd byte in memory, and its value will be 47. This Ref2Foo might be a technical variable, not explicitly created by the program. If you just look at 5 and 47 without any other information, you will see just two &lt;strong&gt;Values&lt;/strong&gt;.
If you use them as references then to reach to &lt;code&gt;5&lt;/code&gt; we have to travel:</source>
          <target state="translated">변수 Foo가 있고 &lt;strong&gt;위치&lt;/strong&gt; 가 메모리에서 47 번째 바이트이고 &lt;strong&gt;값&lt;/strong&gt; 이 5라고 가정 해 &lt;strong&gt;봅시다&lt;/strong&gt; . 메모리에서 223 번째 바이트에있는 또 다른 변수 &lt;strong&gt;Ref2Foo&lt;/strong&gt; 가 있으며 그 값은 47입니다.이 Ref2Foo는 기술 변수 일 수 있습니다 프로그램에서 명시 적으로 생성하지 않았습니다. 다른 정보없이 5와 47 만 보면 두 개의 &lt;strong&gt;값만 표시&lt;/strong&gt; 됩니다. 참조로 사용하고 &lt;code&gt;5&lt;/code&gt; 에 도달하려면 여행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d50fff30ab03bcac896614280d7ce79d010333b1" translate="yes" xml:space="preserve">
          <source>Like so:</source>
          <target state="translated">이렇게 :</target>
        </trans-unit>
        <trans-unit id="1cfac11915904016eed201cd17895ef142e7298c" translate="yes" xml:space="preserve">
          <source>Likewise:</source>
          <target state="translated">Likewise:</target>
        </trans-unit>
        <trans-unit id="5cd871265dfcea1f716cd6d1540a0775e084af34" translate="yes" xml:space="preserve">
          <source>Naturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.</source>
          <target state="translated">당연히, 값에 의해 객체에 대한 참조를 전달하는 것은 참조에 의해 객체를 전달하는 것과 매우 유사합니다 (실제로 구분할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="74a399506f2951a7b197ec01ea8e798ce4122914" translate="yes" xml:space="preserve">
          <source>Next in the &lt;code&gt;tricky&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;tricky&lt;/code&gt; 방법의 다음</target>
        </trans-unit>
        <trans-unit id="4c7f2f0ce70a51c735ee73784fc914a2704fd44b" translate="yes" xml:space="preserve">
          <source>Nitpicking on insignificant details, even languages that do pass-by-reference will pass values to functions, but those functions know that they have to use it for dereferencing purposes. This pass-the-reference-as-value is just hidden from the programmer because it is practically useless and the terminology is only &lt;em&gt;pass-by-reference&lt;/em&gt;.</source>
          <target state="translated">중요하지 않은 세부 사항을 참고하면 참조로 전달하는 언어조차도 값을 함수에 전달하지만 해당 함수는 역 참조 목적으로 사용해야한다는 것을 알고 있습니다. 이 값으로 전달은 실제로 쓸모없고 용어는 &lt;em&gt;참조&lt;/em&gt; 로만 &lt;em&gt;전달&lt;/em&gt; 되므로 프로그래머에게 숨겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="f39a1496ed9448598fdec7fa441d4eb247a6d515" translate="yes" xml:space="preserve">
          <source>No new instances of Person are created.</source>
          <target state="translated">Person의 새 인스턴스가 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a3c28a6866958ddbd72e8e5bfcca8b47c170a56" translate="yes" xml:space="preserve">
          <source>No, it's not pass by reference.</source>
          <target state="translated">아니요, 참조로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2c2fa354963a9acfa4e9abfc392a844ec4c593d" translate="yes" xml:space="preserve">
          <source>Note: I am not pasting the code for &lt;code&gt;private class Student&lt;/code&gt;. The class definition for &lt;code&gt;Student&lt;/code&gt; is same as Example3.</source>
          <target state="translated">참고 : &lt;code&gt;private class Student&lt;/code&gt; 코드를 붙여 넣지 않았습니다. &lt;code&gt;Student&lt;/code&gt; 의 클래스 정의는 Example3과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="922f6a86dea64e63a3edc02c1877ce2a3c46981e" translate="yes" xml:space="preserve">
          <source>Now feel free to hate me but note that given this &lt;strong&gt;there is no difference between passing primitive data types and Objects&lt;/strong&gt; when talking about method arguments.</source>
          <target state="translated">이제 나를 미워하지만이 방법을 사용하면 메소드 인수에 대해 이야기 할 때 &lt;strong&gt;기본 데이터 유형과 객체를 전달하는 것에는 차이가 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="69d2ccd64b25d43c28b50000e4e7f2b5a02a3236" translate="yes" xml:space="preserve">
          <source>Now let's think about what happens outside the method:</source>
          <target state="translated">이제 메소드 외부에서 발생하는 일에 대해 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="ff38daeae639f963939233f6e3fdce27295e1cf5" translate="yes" xml:space="preserve">
          <source>Now think of what an Object's reference/variable does/is:</source>
          <target state="translated">이제 객체의 참조 / 변수가 무엇을 / 그 것인지 생각하십시오 :</target>
        </trans-unit>
        <trans-unit id="0e2ffb2ff2a00fd086483aeae2222dbc11a4d2c8" translate="yes" xml:space="preserve">
          <source>Now we have passed Foo to the method:</source>
          <target state="translated">이제 Foo를 메소드에 전달했습니다.</target>
        </trans-unit>
        <trans-unit id="a68e19abd4296329735454d01ddb1f100edde052" translate="yes" xml:space="preserve">
          <source>Of course you can cut it short and just say that  &lt;strong&gt;Java is pass-by-value!&lt;/strong&gt;</source>
          <target state="translated">물론 짧게 자르고 &lt;strong&gt;Java가 가치에 의한&lt;/strong&gt; 것이라고 말할 수 있습니다 &lt;strong&gt;!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e25bdd3d54506e9fcb400bfa35ebbf005d8293eb" translate="yes" xml:space="preserve">
          <source>Okay. First off, local primitives go on the stack. So this code:</source>
          <target state="translated">괜찮아. 먼저, 로컬 프리미티브가 스택으로 이동합니다. 따라서이 코드 :</target>
        </trans-unit>
        <trans-unit id="8e109f9696197d944923c2e8918140789af777d2" translate="yes" xml:space="preserve">
          <source>One String gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier &lt;code&gt;hisName&lt;/code&gt;, since the address of the second String is the same as the first, no new String is created and no new heap space is allocated, but a new identifier is created on the stack. Then we call &lt;code&gt;shout()&lt;/code&gt;: a new stack frame is created and a new identifier, &lt;code&gt;name&lt;/code&gt; is created and assigned the address of the already-existing String.</source>
          <target state="translated">하나의 문자열이 작성되고이를위한 공간이 힙에 할당되고 문자열에 대한 주소가 스택에 저장되고 식별자 &lt;code&gt;hisName&lt;/code&gt; 이 지정됩니다. 두 번째 문자열의 주소가 첫 번째와 동일하므로 새 문자열이 작성되지 않습니다. 새 힙 공간이 할당되지 않지만 스택에 새 식별자가 작성됩니다. 그런 다음 &lt;code&gt;shout()&lt;/code&gt; 을 호출합니다. 새로운 스택 프레임이 생성되고 새로운 식별자, &lt;code&gt;name&lt;/code&gt; 이 생성되고 이미 존재하는 문자열의 주소가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="e9fbef27678eb892ee44cd57611d9c038d5ddbb8" translate="yes" xml:space="preserve">
          <source>Or from wikipedia, &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference&quot;&gt;on the subject of pass-by-reference&lt;/a&gt;</source>
          <target state="translated">또는 wikipedia에서 &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference&quot;&gt;참조로 전달 주제&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89050305305bcda692140fffe8f7276e92d157fe" translate="yes" xml:space="preserve">
          <source>Pass By Value</source>
          <target state="translated">값으로 전달</target>
        </trans-unit>
        <trans-unit id="7a52d2d617a0327ba951584e0dd74a3b60d0e2ee" translate="yes" xml:space="preserve">
          <source>Pass by value means the called functions' parameter will be a copy of
  the callers' passed argument.</source>
          <target state="translated">값으로 전달은 호출 된 함수의 매개 변수가 호출자의 전달 된 인수의 사본이됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b05d82b9afa13c63a41c110afc8f23afc15f5eb7" translate="yes" xml:space="preserve">
          <source>Passing by reference means the called functions' parameter will be the
  same as the callers' passed argument (not the value, but the identity
  - the variable itself).</source>
          <target state="translated">참조에 의한 전달은 호출 된 함수의 매개 변수가 호출자의 전달 된 인수 (값이 아니라 ID-변수 자체)와 동일 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cc7d7eee18bf03fb193a57aacc259b0ecd56568e" translate="yes" xml:space="preserve">
          <source>Passing references to arrays, instead of the array objects themselves, makes sense for performance reasons. Because everything in Java is passed by value, if array objects were passed,
a copy of each element would be passed. For large arrays, this would waste time and consume
considerable storage for the copies of the elements.</source>
          <target state="translated">배열 객체 자체 대신 배열에 대한 참조를 전달하면 성능상의 이유로 의미가 있습니다. Java의 모든 것이 값으로 전달되므로 배열 객체가 전달되면 각 요소의 사본이 전달됩니다. 대형 어레이의 경우 시간이 낭비되고 요소 사본을 저장하는 데 상당한 스토리지가 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="8cfedebc2d3a9442c6efa9728f78e57e537d2cba" translate="yes" xml:space="preserve">
          <source>Primitive values are also defined in the Java Virtual Machine Specification, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3&quot;&gt;here&lt;/a&gt;. The value of the type is the corresponding integral or floating point value, encoded appropriately (8, 16, 32, 64, etc. bits).</source>
          <target state="translated">기본 값은 Java 가상 머신 사양 ( &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3&quot;&gt;여기)&lt;/a&gt; 에도 정의되어 있습니다 . 유형의 값은 해당 정수 또는 부동 소수점 값이며 적절하게 인코딩됩니다 (8, 16, 32, 64 등 비트).</target>
        </trans-unit>
        <trans-unit id="20eebab5a449d25f5d3973bfc691fbe91ed1dda9" translate="yes" xml:space="preserve">
          <source>Primitive wrapper classes and Strings are immutable so any example using those types will not work the same as other types/objects.</source>
          <target state="translated">기본 랩퍼 클래스 및 문자열은 변경할 수 없으므로 해당 유형을 사용하는 모든 예제는 다른 유형 / 객체와 동일하게 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="45c34d3cd3e583ca8c9f01b7fd4364b4be14d83e" translate="yes" xml:space="preserve">
          <source>References &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;pnt2&lt;/code&gt; are &lt;strong&gt;passed by value&lt;/strong&gt; to the tricky method, which means that now yours references &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;pnt2&lt;/code&gt; have their &lt;code&gt;copies&lt;/code&gt; named &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;.So &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;arg1&lt;/code&gt;&lt;em&gt;points&lt;/em&gt; to the same object. (Same for the &lt;code&gt;pnt2&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;)</source>
          <target state="translated">참조 &lt;code&gt;pnt1&lt;/code&gt; 과 &lt;code&gt;pnt2&lt;/code&gt; 는 까다로운 방법 &lt;strong&gt;으로 값&lt;/strong&gt; 으로 &lt;strong&gt;전달됩니다.&lt;/strong&gt; 이제 &lt;code&gt;pnt1&lt;/code&gt; 과 &lt;code&gt;pnt2&lt;/code&gt; 의 참조가 &lt;code&gt;arg1&lt;/code&gt; 과 &lt;code&gt;arg2&lt;/code&gt; 라는 &lt;code&gt;copies&lt;/code&gt; 을 가지므로 &lt;code&gt;pnt1&lt;/code&gt; 과 &lt;code&gt;arg1&lt;/code&gt; 은 동일한 객체를 &lt;em&gt;가리 킵니다&lt;/em&gt; . ( &lt;code&gt;pnt2&lt;/code&gt; 및 &lt;code&gt;arg2&lt;/code&gt; 와 동일)</target>
        </trans-unit>
        <trans-unit id="bf00fec3f22ea28e6b86a2ef752102c2e7ecb750" translate="yes" xml:space="preserve">
          <source>Second, we need to know what Java uses in its method invocations. The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java Language Specification&lt;/a&gt; states</source>
          <target state="translated">둘째, 메소드 호출에서 Java가 무엇을 사용하는지 알아야합니다. &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java 언어 사양&lt;/a&gt; 상태</target>
        </trans-unit>
        <trans-unit id="d6c9ce881b6078a8902ba5543f51a3b0d775b3fa" translate="yes" xml:space="preserve">
          <source>Several people have written comments which seem to indicate that either they are not looking at my examples or they don't get the c++ example. Not sure where the disconnect is, but guessing the c++ example is not clear. I'm posting the same example in pascal because I think pass-by-reference looks cleaner in pascal, but I could be wrong. I might just be confusing people more; I hope not.</source>
          <target state="translated">여러 사람들이 내 예제를 보지 않거나 c ++ 예제를 얻지 못했음을 나타내는 의견을 작성했습니다. 연결이 어디에 있는지 확실하지 않지만 c ++ 예제를 추측하는 것은 분명하지 않습니다. 패스 바이 레퍼런스가 파스칼에서 더 깨끗해 보인다고 생각하기 때문에 파스칼에 동일한 예제를 게시하고 있지만 잘못 될 수 있습니다. 나는 사람들을 더 혼란스럽게 할 수 있습니다. 내가하지 희망.</target>
        </trans-unit>
        <trans-unit id="26c0ca793e8f7074d3f8c82877440040dbf9523b" translate="yes" xml:space="preserve">
          <source>So</source>
          <target state="translated">So</target>
        </trans-unit>
        <trans-unit id="ff40a96c97ebf788e8cecb055d7af4f991b2166d" translate="yes" xml:space="preserve">
          <source>So after executing method &lt;code&gt;tricky&lt;/code&gt;, when you return to &lt;code&gt;main&lt;/code&gt;, you have this situation:</source>
          <target state="translated">따라서 &lt;code&gt;tricky&lt;/code&gt; 메소드를 실행 한 후 &lt;code&gt;main&lt;/code&gt; 으로 돌아 오면 다음과 같은 상황이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7ef4027a6bbd3300b48fbef4e07ab82867158511" translate="yes" xml:space="preserve">
          <source>So how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java &lt;strong&gt;never&lt;/strong&gt; provides direct access to the values of &lt;em&gt;objects themselves&lt;/em&gt;, in &lt;em&gt;any&lt;/em&gt; circumstances. The only access to objects is through a &lt;em&gt;reference&lt;/em&gt; to that object. Because Java objects are &lt;em&gt;always&lt;/em&gt; accessed through a reference, rather than directly, it is common to talk about fields and variables &lt;em&gt;and method arguments&lt;/em&gt; as being &lt;em&gt;objects&lt;/em&gt;, when pedantically they are only &lt;em&gt;references to objects&lt;/em&gt;. &lt;strong&gt;The confusion stems from this (strictly speaking, incorrect) change in nomenclature.&lt;/strong&gt;</source>
          <target state="translated">그렇다면 누구나 이것으로 혼란 스러울 수 있고 Java가 참조로 전달된다고 생각하거나 참조로 전달하는 Java의 예가 있다고 생각합니까? 요점은 Java가 &lt;em&gt;어떤&lt;/em&gt; 상황에서도 &lt;em&gt;객체 자체&lt;/em&gt; 의 값에 직접 액세스 할 수 &lt;strong&gt;없다는 것&lt;/strong&gt; 입니다. 객체에 대한 유일한 액세스는 해당 객체에 대한 &lt;em&gt;참조&lt;/em&gt; 를 통해서입니다. Java 객체는 직접적이 아닌 참조를 통해 &lt;em&gt;항상&lt;/em&gt; 액세스되므로 필드와 변수 &lt;em&gt;및 메소드 인수&lt;/em&gt; 에 대해 일반적으로 &lt;em&gt;객체&lt;/em&gt; 에 &lt;em&gt;대한 참조&lt;/em&gt; 일 때만 &lt;em&gt;객체&lt;/em&gt; 인 것으로 이야기하는 것이 일반적입니다. &lt;strong&gt;혼동은 명명법의 (엄격하게 말해서, 부정확 한) 변화에서 비롯됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49f6e297927d971ba38fa95bec79322b3f55ffe8" translate="yes" xml:space="preserve">
          <source>So if you have &lt;code&gt;doSomething(foo)&lt;/code&gt; and &lt;code&gt;public void doSomething(Foo foo) { .. }&lt;/code&gt; the two Foos have copied &lt;em&gt;references&lt;/em&gt; that point to the same objects.</source>
          <target state="translated">따라서 &lt;code&gt;doSomething(foo)&lt;/code&gt; 및 &lt;code&gt;public void doSomething(Foo foo) { .. }&lt;/code&gt; 있는 경우 두 Foos는 동일한 객체를 가리키는 &lt;em&gt;참조&lt;/em&gt; 를 복사했습니다.</target>
        </trans-unit>
        <trans-unit id="7b4e3120f9e0ef1963e36854a84df92466e8bd5c" translate="yes" xml:space="preserve">
          <source>So in short and in Java's own terminology, Java is &lt;em&gt;pass-by-value&lt;/em&gt; where &lt;em&gt;value&lt;/em&gt; can be: either a &lt;strong&gt;real value&lt;/strong&gt; or a &lt;strong&gt;value&lt;/strong&gt; that is a representation of a &lt;strong&gt;reference&lt;/strong&gt;.</source>
          <target state="translated">간단히 말해서 Java 자체 용어로 Java는 &lt;em&gt;값&lt;/em&gt; 이 &lt;strong&gt;실제 값&lt;/strong&gt; 또는 &lt;strong&gt;참조를&lt;/strong&gt; 나타내는 &lt;strong&gt;값일&lt;/strong&gt; 수있는 &lt;strong&gt;값별 전달&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="634936d81c1689fe91adca4c5ee1e8fd9d96a1ad" translate="yes" xml:space="preserve">
          <source>So it assigns (or binds) the value of the argument to the corresponding parameter variable.</source>
          <target state="translated">따라서 인수의 값을 해당 매개 변수에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="f4945724933ec9be2092b5806b370216861c5eeb" translate="yes" xml:space="preserve">
          <source>So let's write all the things we have done at once now.</source>
          <target state="translated">이제 한 번에 수행 한 모든 작업을 작성하겠습니다.</target>
        </trans-unit>
        <trans-unit id="9a181e916502cbb03b3332b929a47423efcc6e84" translate="yes" xml:space="preserve">
          <source>So now, completely execution of program will be:</source>
          <target state="translated">이제 프로그램을 완전히 실행하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a27627ea047cda38b06899780beb9ed096f3a7d" translate="yes" xml:space="preserve">
          <source>So you can't change the reference that gets passed in.</source>
          <target state="translated">따라서 전달 된 참조를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="866237ea6abd1c73ce2cd72c6c84fc4749c1fab7" translate="yes" xml:space="preserve">
          <source>So you're just passing 3bad086a that it's the value of the reference.</source>
          <target state="translated">따라서 3bad086a를 전달하여 참조 값입니다.</target>
        </trans-unit>
        <trans-unit id="20fd78625a8ef72411c2e7f9cc21dcf94a034a8f" translate="yes" xml:space="preserve">
          <source>So, if we say</source>
          <target state="translated">우리가 말하면</target>
        </trans-unit>
        <trans-unit id="90e7e6de17ceea609c89967f7448b462eff52e91" translate="yes" xml:space="preserve">
          <source>So, value, reference? You say &quot;potato&quot;.</source>
          <target state="translated">그래서 가치, 참조? 당신은 &quot;감자&quot;라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="daa39b66ef2d8fde4dcb582dccfc4335693ba86f" translate="yes" xml:space="preserve">
          <source>So, what gets passed in when you call a method? If you pass in an object, what you're actually passing in is the address of the object. Some might say the &quot;value&quot; of the address, and some say it's just a reference to the object. This is the genesis of the holy war between &quot;reference&quot; and &quot;value&quot; proponents. What you call it isn't as important as that you understand that what's getting passed in is the address to the object.</source>
          <target state="translated">그렇다면 메소드를 호출 할 때 무엇이 ​​전달됩니까? 객체를 전달하는 경우 실제로 전달하는 것은 객체의 주소입니다. 일부는 주소의 &quot;값&quot;이라고 말하고 일부는 객체에 대한 참조 일뿐입니다. 이것이 &quot;참조&quot;와 &quot;가치&quot;지지자들 사이의 거룩한 전쟁의 기원입니다. 당신이 부르는 것은 전달되는 것이 객체의 주소라는 것을 이해하는 것만 큼 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f804721f9a225c83f9f775159b5195bbbe96d25c" translate="yes" xml:space="preserve">
          <source>So, when calling a method</source>
          <target state="translated">따라서 메소드를 호출 할 때</target>
        </trans-unit>
        <trans-unit id="ee33b63e4d6f38a1051e9487d652448deba03bf9" translate="yes" xml:space="preserve">
          <source>Some excerpts from &lt;strong&gt;&quot;THE Java Programming Language&quot;&lt;/strong&gt; by Ken Arnold, &lt;strong&gt;James Gosling (the guy who invented Java)&lt;/strong&gt;, and David Holmes, chapter 2, section 2.6.5</source>
          <target state="translated">Ken Arnold의 &lt;strong&gt;&quot;THE Java Programming Language&quot;&lt;/strong&gt; , &lt;strong&gt;James Gosling (Java를 발명 한 사람)&lt;/strong&gt; 및 David Holmes의 2 장, 섹션 2.6.5에서 발췌 한 내용</target>
        </trans-unit>
        <trans-unit id="94b891247159e943febc8cc22cd31a1491a1cb74" translate="yes" xml:space="preserve">
          <source>Some people say primitive types and 'String' are 'pass by value'
  and objects are 'pass by reference'.</source>
          <target state="translated">어떤 사람들은 기본 유형과 '문자열'이 '값으로 전달'이고 객체가 '참조로 전달'이라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="ae7f019ce2b7e1139c2214fe199d7dfbfd4ace30" translate="yes" xml:space="preserve">
          <source>Sometimes Java can give the illusion of pass by reference. Let's see how it works by using the example below:</source>
          <target state="translated">때로는 Java가 참조로 통과의 환상을 줄 수 있습니다. 아래 예제를 사용하여 작동 방식을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="523c67e3005e1319a95db986a92e473eccf87a79" translate="yes" xml:space="preserve">
          <source>Sometimes you want to use the same pattern in Java, but you can't; at least not directly. Instead you could do something like this:</source>
          <target state="translated">때로는 Java에서 동일한 패턴을 사용하려고하지만 할 수는 없습니다. 적어도 직접적으로는 아닙니다. 대신 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa1ec5d7dc80c372add31e690fc9b6adfcbed953" translate="yes" xml:space="preserve">
          <source>Step one please erase from your mind that word that starts with 'p' &quot;_ _ _ _ _ _ _&quot;, especially if you come from other programming languages. Java and 'p' cannot be written in the same book, forum, or even txt.</source>
          <target state="translated">1 단계 : 특히 다른 프로그래밍 언어에서 온 경우 'p' &quot;_ _ _ _ _ _ _&quot;로 시작하는 단어를 기억하십시오. Java와 'p'는 같은 책, 포럼 또는 txt로 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e060e28388e7368925caf9e91796e5aa4d2b1720" translate="yes" xml:space="preserve">
          <source>Step two remember that when you pass an Object into a method you're passing the Object reference and not the Object itself.</source>
          <target state="translated">2 단계는 객체를 메소드에 전달할 때 객체 자체가 아니라 객체 참조를 전달한다는 것을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="6207dc3dd0572f9c051d767720eb5104f3fb4f3c" translate="yes" xml:space="preserve">
          <source>Strict &lt;em&gt;pass-by-value&lt;/em&gt; is also useless, it would mean that a 100 Mbyte array should have to be copied every time we call a method with the array as argument, therefore Java cannot be stricly pass-by-value. Every language would pass a reference to this huge array (as a value) and either employs copy-on-write mechanism if that array can be changed locally inside the method or allows the method (as Java does) to modify the array globally (from the caller's view) and a few languages allows to modify the Value of the reference itself.</source>
          <target state="translated">엄격한 &lt;em&gt;값으로 전달하는&lt;/em&gt; 것도 쓸모가 없습니다. 즉, 배열을 인수로 사용하여 메소드를 호출 할 때마다 100MB 배열을 복사해야하므로 Java를 &lt;em&gt;값으로&lt;/em&gt; 엄격하게 &lt;em&gt;전달할&lt;/em&gt; 수 없습니다. 모든 언어는이 거대한 배열에 대한 참조를 값으로 전달하고 해당 배열을 메소드 내부에서 로컬로 변경하거나 메소드가 (Java 가하는 것처럼) 메소드를 전역 적으로 수정하도록 허용하면 쓰기시 복사 메커니즘을 사용합니다. 발신자의 관점과 일부 언어를 사용하면 참조 자체의 값을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14bbbb986af6b74a6c4b3c0e5664a7de3e563b7" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;code&gt;Dog&lt;/code&gt; object resides at memory address 42. This means we pass 42 to the method.</source>
          <target state="translated">&lt;code&gt;Dog&lt;/code&gt; 객체가 메모리 주소 42에 있다고 가정합니다. 이는 메서드에 42를 전달한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="8d27872f4e15932b79d2264d4a0cddb9e2521238" translate="yes" xml:space="preserve">
          <source>Take this to C++, and we have references. References are basically (in this context) syntactic sugar that hide the pointer part of the equation: &lt;code&gt;void foo(int &amp;amp;x)&lt;/code&gt; is called by &lt;code&gt;foo(a)&lt;/code&gt;, where the compiler itself knows that it is a reference and the address of the non-reference &lt;code&gt;a&lt;/code&gt; should be passed. In Java, all variables referring to objects are actually of reference type, in effect forcing call by reference for most intends and purposes without the fine grained control (and complexity) afforded by, for example, C++.</source>
          <target state="translated">이것을 C ++로 가져 가면 참조가 있습니다. 참조는 기본적으로 (이 문맥에서) 방정식의 포인터 부분을 숨기는 구문 설탕입니다. &lt;code&gt;void foo(int &amp;amp;x)&lt;/code&gt; 는 &lt;code&gt;foo(a)&lt;/code&gt; 의해 호출됩니다. 여기서 컴파일러는 그것이 참조임을 알 수 있습니다. 참조 &lt;code&gt;a&lt;/code&gt; 를 전달해야합니다. Java에서 객체를 참조하는 모든 변수는 실제로 참조 유형이므로 C ++와 같이 세밀한 제어 (및 복잡성)없이 대부분의 의도와 목적을 위해 참조로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="1f5466dbc044f44594c32f9e6b1b8a7351767c72" translate="yes" xml:space="preserve">
          <source>That's the reason only Java developers have issue with this. They look at the word &quot;reference&quot; and think they know exactly what that means, so they don't even bother to consider the opposing argument.</source>
          <target state="translated">이것이 바로 Java 개발자 만이이 문제를 해결하는 이유입니다. 그들은 &quot;참조&quot;라는 단어를보고 그것이 의미하는 바를 정확히 알고 있다고 생각하기 때문에 반대 주장을 고려할 필요조차 없습니다.</target>
        </trans-unit>
        <trans-unit id="c94098a38907257d1a6a763b38d1468647d923f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1&quot;&gt;Java Language Specification&lt;/a&gt; also states</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1&quot;&gt;Java 언어 사양&lt;/a&gt; 에는 또한</target>
        </trans-unit>
        <trans-unit id="079b195af1fa053069e0e9a1be334e5b752f52b4" translate="yes" xml:space="preserve">
          <source>The Java Spec says that everything in Java is pass-by-value. There is no such thing as &quot;pass-by-reference&quot; in Java.</source>
          <target state="translated">자바 스펙은 자바의 모든 것이 가치에 의한 것이라고 말한다. Java에는 &quot;pass-by-reference&quot;와 같은 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd7bc25c7313046e736eb3d62b656f193458641b" translate="yes" xml:space="preserve">
          <source>The Java programming language &lt;strong&gt;does not pass objects by reference; it&lt;/strong&gt;&lt;strong&gt;passes object references by value&lt;/strong&gt;. Because two copies of the same
  reference refer to the same actual object, changes made through one
  reference variable are visible through the other. There is exactly one
  parameter passing mode-&lt;strong&gt;pass by value&lt;/strong&gt;-and that helps keep things
  simple.</source>
          <target state="translated">Java 프로그래밍 언어 &lt;strong&gt;는 객체를 참조로 전달하지 않습니다.&lt;/strong&gt; &lt;strong&gt;값으로 객체 참조를 전달합니다&lt;/strong&gt; . 동일한 참조의 두 사본이 동일한 실제 객체를 참조하므로 하나의 참조 변수를 통해 작성된 변경 사항은 다른 참조 변수를 통해 볼 수 있습니다. &lt;strong&gt;값&lt;/strong&gt; 을 기준으로 mode- &lt;strong&gt;pass를 전달하는&lt;/strong&gt; 매개 변수는 정확히 하나 뿐이며 일을 단순하게 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ea546a9da3076dcf69d6a878525afaefa3c2665d" translate="yes" xml:space="preserve">
          <source>The behaviour can appear different from primitive types: Because the copied object-variable contains the same address (to the same Object).
Object's &lt;strong&gt;content/members&lt;/strong&gt; might still be modified within a method and later access outside, giving the illusion that the (containing) Object itself was passed by reference.</source>
          <target state="translated">동작은 기본 유형과 다르게 나타날 수 있습니다. 복사 된 객체 변수에는 동일한 주소에 동일한 주소가 포함되어 있기 때문입니다. 객체의 &lt;strong&gt;내용 / 멤버&lt;/strong&gt; 는 여전히 메소드 내에서 수정되고 나중에 외부에 액세스하여 (포함) 객체 자체가 참조로 전달되었다는 환상을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f95a7e89d7fa53f741a6006a73b3f53dbfe98a" translate="yes" xml:space="preserve">
          <source>The changeName function above will never be able to modify the actual content (the bit values) of the passed reference. In other word changeName cannot make Person person refer to another Object.</source>
          <target state="translated">위의 changeName 함수는 전달 된 참조의 실제 내용 (비트 값)을 수정할 수 없습니다. 즉, changeName은 Person 개인이 다른 오브젝트를 참조하도록 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d43a36b01a5a36e6a4fed6f955af9bd89a90e8e2" translate="yes" xml:space="preserve">
          <source>The crux of the matter is that the word &lt;em&gt;reference&lt;/em&gt; in the expression &quot;pass by reference&quot; means something completely different from the usual meaning of the word &lt;em&gt;reference&lt;/em&gt; in Java.</source>
          <target state="translated">문제의 요점은 &quot;pass by reference&quot;라는 &lt;em&gt;표현&lt;/em&gt; 에서 단어 &lt;em&gt;참조&lt;/em&gt; 가 Java에서 단어 &lt;em&gt;참조&lt;/em&gt; 의 일반적인 의미와 완전히 다른 것을 의미한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d6413d6c252fab8253fe8c316fa9f97b12f5c04a" translate="yes" xml:space="preserve">
          <source>The distinction, or perhaps just the way I remember as I used to be under the same impression as the original poster is this: Java is always pass by value. All objects( in Java, anything except for primitives) in Java are references. These references are passed by value.</source>
          <target state="translated">독창적 인 포스터와 같은 인상을 받았던 기억이나 방식은 다음과 같습니다. Java는 항상 가치에 의해 전달됩니다. Java의 모든 객체 (Java의 경우 기본 요소를 제외한 모든 것)는 참조입니다. 이러한 참조는 값으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e90dc2a7bcee6387a6415dbc06ec56f2e174cf42" translate="yes" xml:space="preserve">
          <source>The key to understanding this is that something like</source>
          <target state="translated">이것을 이해하는 열쇠는</target>
        </trans-unit>
        <trans-unit id="c870634849690af62ce95dbaaffd653c3bdc1132" translate="yes" xml:space="preserve">
          <source>The output of this program is:</source>
          <target state="translated">이 프로그램의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="914b3110e6efe55bce5c55f82df6a7638d0fa6d6" translate="yes" xml:space="preserve">
          <source>The term &quot;reference&quot; is a overloaded with two separate meanings. In Java it simply means a pointer, but in the context of &quot;Pass-by-reference&quot; it means a handle to the original variable which was passed in.</source>
          <target state="translated">&quot;참조&quot;라는 용어는 두 가지 의미로 오버로드됩니다. Java에서는 단순히 포인터를 의미하지만 &quot;참조 별 패스&quot;의 맥락에서 전달 된 원래 변수에 대한 핸들을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d685aec290065c3d070420033a198dff8941ecc8" translate="yes" xml:space="preserve">
          <source>The value of an argument (of some reference type) is a pointer to an object. Note that a variable, an invocation of a method with a reference type return type, and an instance creation expression (&lt;code&gt;new ...&lt;/code&gt;) all resolve to a reference type value.</source>
          <target state="translated">인수 (일부 참조 유형)의 값은 객체에 대한 포인터입니다. 변수, 참조 유형 리턴 유형의 메소드 호출 및 인스턴스 작성 표현식 ( &lt;code&gt;new ...&lt;/code&gt; )은 모두 참조 유형 값으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="b9723eb7fef6befdaac82e1c6cd7ab277e54545d" translate="yes" xml:space="preserve">
          <source>The variable &lt;em&gt;person&lt;/em&gt; holding the address of the Object is passed to the function in line #3.</source>
          <target state="translated">객체의 주소를 보유한 변수 &lt;em&gt;사람&lt;/em&gt; 은 3 번 라인의 함수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9a827a692a5c5bbbe054c83be9d12f395ddfae3c" translate="yes" xml:space="preserve">
          <source>The variable &lt;em&gt;person&lt;/em&gt; is created in line #1 and it's null at the beginning.</source>
          <target state="translated">변수 &lt;em&gt;person&lt;/em&gt; 은 1 번 줄에 만들어지며 처음에는 null입니다.</target>
        </trans-unit>
        <trans-unit id="d211d018025495720be4d35b0fb0e965174108f6" translate="yes" xml:space="preserve">
          <source>The variable/reference &lt;em&gt;person&lt;/em&gt; is copied bit-by-bit and passed to &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; inside the function.</source>
          <target state="translated">변수 / 레퍼런스 &lt;em&gt;개인&lt;/em&gt; 은 비트 단위로 복사되어 함수 내에서 &lt;em&gt;anotherReferenceToTheSamePersonObject에&lt;/em&gt; 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a6a7f9ad555d80ee9f46a19d1dc4de44b454dbba" translate="yes" xml:space="preserve">
          <source>There are already great answers that cover this. I wanted to make a small contribution by sharing a &lt;strong&gt;very simple example&lt;/strong&gt; (which will compile) contrasting the behaviors between Pass-by-reference in c++ and Pass-by-value in Java.</source>
          <target state="translated">이것을 다루는 훌륭한 답변이 이미 있습니다. c ++의 Pass-by-reference와 Java의 Pass-by-value 사이의 동작을 대조하는 &lt;strong&gt;매우 간단한 예제&lt;/strong&gt; (컴파일 할)를 공유하여 작은 기여를하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="dfab606767515e58a1e6d064ffb7613d99a953bf" translate="yes" xml:space="preserve">
          <source>There are three kinds of &lt;strong&gt;reference types&lt;/strong&gt;: class types, array types,
  and interface types. &lt;strong&gt;Their values are references to dynamically
  created class instances, arrays, or class instances or arrays that
  implement interfaces, respectively.&lt;/strong&gt;</source>
          <target state="translated">클래스 유형, 배열 유형 및 인터페이스 유형의 세 가지 &lt;strong&gt;참조 유형이&lt;/strong&gt; 있습니다. &lt;strong&gt;해당 값은 동적으로 생성 된 클래스 인스턴스, 배열 또는 인터페이스를 구현하는 클래스 인스턴스 또는 배열에 대한 참조입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa2284d9a49a58f0919e69504baa39d271367e04" translate="yes" xml:space="preserve">
          <source>There's the key.</source>
          <target state="translated">열쇠가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1f460dd17e5cf9708ba41d056ae77c8a33b5f05" translate="yes" xml:space="preserve">
          <source>Think of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.</source>
          <target state="translated">참조 매개 변수는 전달 된 변수의 별명으로 생각하십시오. 해당 별명이 지정되면 전달 된 변수도 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d3a442ecb80bc2357c8302e2cfa37890d9a8f934" translate="yes" xml:space="preserve">
          <source>This happens because iA and iB are new local reference variables that have the same value of the passed references (they point to a and b respectively). So, trying to change the references of iA or iB will only change in the local scope and not outside of this method.</source>
          <target state="translated">이는 iA와 iB가 전달 된 참조의 값이 동일한 새로운 로컬 참조 변수이기 때문에 발생합니다 (각각 a와 b를 가리킴). 따라서 iA 또는 iB의 참조를 변경하려고하면이 방법을 제외하고 로컬 범위에서만 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5eefcb95db3d521d55f45ddd3a85d502cf4cdc4f" translate="yes" xml:space="preserve">
          <source>This is how jump-tables work.</source>
          <target state="translated">이것이 점프 테이블의 작동 방식입니다.</target>
        </trans-unit>
        <trans-unit id="6bf397e1d5e88f4359962543f1564d72392aa1a0" translate="yes" xml:space="preserve">
          <source>This section of the book has a great explanation of parameter passing in Java and of the distinction between pass-by-reference and pass-by-value and it's by the creator of Java. I would encourage anyone to read it, especially if you're still not convinced.</source>
          <target state="translated">이 책의 섹션은 Java에서 매개 변수 전달과 참조 별 값과 값별의 차이점에 대한 훌륭한 설명을 제공하며 Java 작성자가 작성합니다. 나는 아직도 당신이 확신하지 않는 경우, 누군가가 그것을 읽을 것을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="f6f7ba733b2534ecc1ea818cdddfaf4dcf24537c" translate="yes" xml:space="preserve">
          <source>This typically means that the function can modify (i.e. assign to) the
  variable used as argument&amp;mdash;something that will be seen by its caller.</source>
          <target state="translated">이는 일반적으로 함수가 인수로 사용 된 변수 (호출자가 볼 수있는 변수)를 수정할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a24fd574548676d8a5fdf4e5d5e866b85294afa6" translate="yes" xml:space="preserve">
          <source>This will populate Hello World and not World Hello because in the swap function you use copys which have no impact on the references in the main. But if your objects are not immutable you can change it for example:</source>
          <target state="translated">스왑 기능에서는 기본 참조에 영향을 미치지 않는 사본을 사용하기 때문에 World Hello가 아닌 Hello World에 채워집니다. 그러나 객체가 변경 불가능한 경우 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e505e393bf5f01ebb5d9bfa9244eb4fa82d49415" translate="yes" xml:space="preserve">
          <source>This will populate Hello World on the command line. If you change StringBuffer into String it will produce just Hello because String is immutable. For example:</source>
          <target state="translated">명령 행에 Hello World가 채워집니다. StringBuffer를 String으로 변경하면 String이 변경되지 않기 때문에 Hello 만 생성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecc09e1b426d0f3bbdde2b52d1275b4a9684b1cb" translate="yes" xml:space="preserve">
          <source>To make a long story short, &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; objects have some very peculiar properties.</source>
          <target state="translated">간단히 말해 &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; 객체에는 매우 독특한 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8f2d10c7283892fc482b2460252534f2c951f8f" translate="yes" xml:space="preserve">
          <source>To understand this more clearly, consider the following example:</source>
          <target state="translated">이를보다 명확하게 이해하려면 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4a3568015b17ba4456e0d1ce2a6b83da248a6190" translate="yes" xml:space="preserve">
          <source>Unlike some other languages, Java does not allow you to choose between pass-by-value and pass-by-reference&amp;mdash;all arguments are passed by value. A method call can pass two types of values to a method&amp;mdash;copies of primitive values (e.g., values of int and double) and copies of references to objects.</source>
          <target state="translated">다른 언어와는 달리 Java에서는 값으로 전달 및 참조로 전달을 선택할 수 없으며 모든 인수는 값으로 전달됩니다. 메소드 호출은 두 가지 유형의 값, 즉 기본 값의 사본 (예 : int 및 double 값)과 오브젝트에 대한 참조 사본의 사본을 메소드에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8379236c60a3ff28075f90353d681fa71cd1a5aa" translate="yes" xml:space="preserve">
          <source>Usually in Java &lt;em&gt;reference&lt;/em&gt; means a a &lt;em&gt;reference to an object&lt;/em&gt;. But the technical terms &lt;em&gt;pass by reference/value&lt;/em&gt; from programming language theory is talking about a &lt;em&gt;reference to the memory cell holding the variable&lt;/em&gt;, which is something completely different.</source>
          <target state="translated">일반적으로 Java &lt;em&gt;참조&lt;/em&gt; &lt;em&gt;는 객체에 대한 참조를&lt;/em&gt; 의미 &lt;em&gt;합니다&lt;/em&gt; . 그러나 기술 용어는 프로그래밍 언어 이론에서 &lt;em&gt;참조 / 값으로 전달됩니다&lt;/em&gt; &lt;em&gt;. 변수를 보유한 메모리 셀&lt;/em&gt; 에 대한 &lt;em&gt;참조&lt;/em&gt; 는 완전히 다릅니다.</target>
        </trans-unit>
        <trans-unit id="189b909d14e035d9439146930c7bf76ee3ba35f1" translate="yes" xml:space="preserve">
          <source>We have another reference variable in reverseArray method (array2) that points to an array c. If we were to say</source>
          <target state="translated">우리는 array를 가리키는 reverseArray 메소드 (array2)에 또 다른 참조 변수를 가지고 있습니다. c. 우리가 말하면</target>
        </trans-unit>
        <trans-unit id="df89229a206448022bc5ed3d58cbdd5121102868" translate="yes" xml:space="preserve">
          <source>What happens?</source>
          <target state="translated">무슨 일이야?</target>
        </trans-unit>
        <trans-unit id="2721876ca410fad542be9395684b871758604935" translate="yes" xml:space="preserve">
          <source>What is the explanation?</source>
          <target state="translated">설명은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c6c48753b57b8c36067f08152d304ac38b370fa1" translate="yes" xml:space="preserve">
          <source>What that means, is when you have</source>
          <target state="translated">그것이 의미하는 것은</target>
        </trans-unit>
        <trans-unit id="b82d13a18500a976024ec3aaa69437e0d2e0bcb9" translate="yes" xml:space="preserve">
          <source>When a method modifies a primitive-type parameter, changes to the parameter have no effect on the original argument value in the calling method.</source>
          <target state="translated">메소드가 기본 유형 매개 변수를 수정하는 경우, 매개 변수 변경은 호출 메소드의 원래 인수 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47a4b97547a431dafab08418cf4ef38d6006e62e" translate="yes" xml:space="preserve">
          <source>When it comes to objects, objects themselves cannot be passed to methods. So we pass the address of the object which is held in the reference variable.</source>
          <target state="translated">객체에 관해서는 객체 자체가 메소드에 전달 될 수 없습니다. 따라서 참조 변수에 포함 된 객체의 주소를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="42a98879de2bf7e9712995f5e8ec5b041e9c310b" translate="yes" xml:space="preserve">
          <source>When passing arguments to a method &lt;strong&gt;you ARE NOT passing the reference variable, but a copy of the bits in the reference variable&lt;/strong&gt;. Something like this: 3bad086a. 3bad086a represents a way to get to the passed object.</source>
          <target state="translated">메소드에 인수를 &lt;strong&gt;전달할 때는 참조 변수를 전달하지 않고 참조 변수의 비트 사본을 전달하십시오&lt;/strong&gt; . 이 같은 것 : 3bad086a. 3bad086a는 전달 된 객체에 도달하는 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="26b0a49f4378f6ec3b7ac0d3ca02eabd027e1846" translate="yes" xml:space="preserve">
          <source>When passing reference t to the function it will not directly pass the actual reference value of object test,  but it will create a copy of t and then pass it to the function. Since it is &lt;strong&gt;passing by value&lt;/strong&gt;, it passes a copy of the variable rather than the actual reference of it. Since we said the value of t was &lt;code&gt;0x100234&lt;/code&gt;, both t and f will have the same value and hence they will point to the same object.</source>
          <target state="translated">참조 t를 함수에 전달하면 객체 테스트의 실제 참조 값을 직접 전달하지 않지만 t의 사본을 작성한 다음 함수에 전달합니다. &lt;strong&gt;value&lt;/strong&gt; 로 &lt;strong&gt;전달&lt;/strong&gt; 되므로 변수의 실제 참조가 아닌 변수의 사본을 전달합니다. t의 값이 &lt;code&gt;0x100234&lt;/code&gt; 라고 말 했으므로 t와 f는 모두 같은 값을 가지므로 동일한 객체를 가리킬 것입니다.</target>
        </trans-unit>
        <trans-unit id="db86d10509b05e8bc49df8c7cd3d9cada5dd82ab" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the
  actual argument expressions initialize newly created parameter
  variables, each of the declared type, before execution of the body of
  the method or constructor.&lt;/strong&gt; The Identifier that appears in the
  DeclaratorId may be used as a simple name in the body of the method or
  constructor to refer to the formal parameter.</source>
          <target state="translated">메소드 또는 생성자가 호출되면 (&amp;sect;15.12) &lt;strong&gt;실제 인수 표현식의 값은 메소드 또는 생성자의 본문을 실행하기 전에 선언 된 각 유형으로 새로 작성된 매개 변수를 초기화합니다.&lt;/strong&gt; DeclaratorId에 나타나는 식별자는 공식 매개 변수를 참조하기 위해 메소드 또는 생성자의 본문에서 간단한 이름으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b67851b479dc283a6f950e2733c899590974221" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the
  actual argument expressions initialize newly created parameter
  variables&lt;/strong&gt;, each of the declared type, before execution of the body of
  the method or constructor.</source>
          <target state="translated">메소드 또는 생성자가 호출되면 (&amp;sect;15.12) &lt;strong&gt;실제 인수 표현식의 값은&lt;/strong&gt; 메소드 또는 생성자의 본문을 실행하기 전에 선언 된 각 유형으로 &lt;strong&gt;새로 작성된 매개 변수를 초기화&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2d221d1e03c75efd20f3411a07f7d84f428d8be4" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the actual argument expressions initialize newly created parameter variables&lt;/strong&gt;, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1&quot;&gt;formal parameter&lt;/a&gt;.</source>
          <target state="translated">메소드 또는 생성자가 호출되면 (&amp;sect;15.12) &lt;strong&gt;실제 인수 표현식의 값은&lt;/strong&gt; 메소드 또는 생성자의 본문을 실행하기 전에 선언 된 각 유형으로 &lt;strong&gt;새로 작성된 매개 변수를 초기화&lt;/strong&gt; 합니다. DeclaratorId에 나타나는 식별자는 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1&quot;&gt;형식 매개 변수&lt;/a&gt; 를 참조하기 위해 메서드 또는 생성자의 본문에서 간단한 이름으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aee34f3d95b06bea3cb4049aac2fc385dba277b" translate="yes" xml:space="preserve">
          <source>When you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are against the word &quot;pointer&quot;. Whatever. Just know that the address of the object goes on the stack.</source>
          <target state="translated">객체를 선언하고 인스턴스화 할 때 실제 객체는 힙에서 진행됩니다. 스택에 무슨 일이? 힙에서 오브젝트의 주소입니다. C ++ 프로그래머는 이것을 포인터라고 부르지 만 일부 Java 개발자는 &quot;포인터&quot;라는 단어에 반대합니다. 도대체 무엇이. 객체의 주소가 스택에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="28b1f1b3dfbb6a4aedcea3dba4b14239a6b023ba" translate="yes" xml:space="preserve">
          <source>Which means, java creates a copy of the passed parameters before executing a method. Like most people who studied compilers in college, I used &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201100886&quot;&gt;&quot;The Dragon Book&quot;&lt;/a&gt; which is &lt;strong&gt;THE&lt;/strong&gt; compilers book. It has a good description of &quot;Call-by-value&quot; and &quot;Call-by-Reference&quot; in Chapter 1. The Call-by-value description matches up with Java Specs exactly.</source>
          <target state="translated">즉, java는 메소드를 실행하기 전에 전달 된 매개 변수의 사본을 작성합니다. 대학에서 컴파일러를 연구 한 대부분의 사람들과 마찬가지로 필자는 컴파일러 책인 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201100886&quot;&gt;&quot;The Dragon Book&quot;&lt;/a&gt; 을 사용했습니다. 1 장의 &quot;값별 호출&quot;및 &quot;참조 별 호출&quot;에 대한 자세한 설명이 있습니다. 값별 설명은 Java 스펙과 정확히 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0dcbcbf7f981b706be204f899221bd4d6394bba1" translate="yes" xml:space="preserve">
          <source>Will this throw a &lt;code&gt;NullPointerException&lt;/code&gt;? No, because it only passes a copy of the reference. 
In the case of passing by reference, it could have thrown a &lt;code&gt;NullPointerException&lt;/code&gt;, as seen below:</source>
          <target state="translated">이것으로 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니까? 아니요, 참조 사본 만 전달하기 때문입니다. 참조로 전달하는 경우 아래와 같이 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a28f32f5173460812904146e506dc73421a481d8" translate="yes" xml:space="preserve">
          <source>You always pass a copy of the bits of the value of the reference!</source>
          <target state="translated">항상 참조 값의 비트 사본을 전달합니다!</target>
        </trans-unit>
        <trans-unit id="a3dc507f44237c76ec4ef1ec8e4c68370d0b3167" translate="yes" xml:space="preserve">
          <source>You can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:</source>
          <target state="translated">Java에서는 참조를 통해 전달할 수 없으며, 분명한 방법 중 하나는 메소드 호출에서 둘 이상의 값을 리턴하려는 경우입니다. C ++에서 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="02c7b73324c917e7dbe1ca63e76c51d7ead60641" translate="yes" xml:space="preserve">
          <source>You could also assign value of array2 in main to array1. array1 would start pointing to b.</source>
          <target state="translated">main의 array2 값을 array1에 할당 할 수도 있습니다. array1은 b를 가리 키기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6b4f593c12270cbc6715abff6481a0a796758bb7" translate="yes" xml:space="preserve">
          <source>You should note that when the parameter is an object reference, it is
  the object reference-not the object itself-that is &lt;strong&gt;passed &quot;by value&quot;&lt;/strong&gt;.</source>
          <target state="translated">매개 변수가 객체 참조 인 경우 객체 자체가 아니라 &lt;strong&gt;&quot;값별&quot;로 전달&lt;/strong&gt; 되는 것은 객체 참조입니다.</target>
        </trans-unit>
        <trans-unit id="fc75d6d2c095fd5d227713114c34ed1913a0b634" translate="yes" xml:space="preserve">
          <source>You're passing the value of the reference and not the reference itself (and not the object).</source>
          <target state="translated">참조 자체가 아니라 참조 자체의 값이 아닌 참조의 값을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e412d3eb76b9c511737b2f188cf28aa0a3b15e42" translate="yes" xml:space="preserve">
          <source>a new &lt;code&gt;Dog&lt;/code&gt; is created. Let's say he's at address 74</source>
          <target state="translated">새로운 &lt;code&gt;Dog&lt;/code&gt; 만들어집니다. 그가 주소 74에 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="fb3668ea3a8369fdbba52413c9d814f6e3ed4702" translate="yes" xml:space="preserve">
          <source>all bind the value of a reference to a &lt;code&gt;String&lt;/code&gt; instance to the method's newly created parameter, &lt;code&gt;param&lt;/code&gt;. This is exactly what the definition of pass-by-value describes. As such, &lt;strong&gt;Java is pass-by-value&lt;/strong&gt;.</source>
          <target state="translated">모두 &lt;code&gt;String&lt;/code&gt; 인스턴스에 대한 참조 값을 메소드의 새로 작성된 매개 변수 &lt;code&gt;param&lt;/code&gt; 에 바인드합니다. 이것이 바로 값별 정의가 설명하는 것입니다. 따라서 &lt;strong&gt;Java는 값을 전달합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8c38907cfcadbaccdbfd358b9d0106488c0111a7" translate="yes" xml:space="preserve">
          <source>at line &quot;AAA&quot;</source>
          <target state="translated">&quot;AAA&quot;라인에서</target>
        </trans-unit>
        <trans-unit id="f93c76dfe98a248d087f8423725428bab806588d" translate="yes" xml:space="preserve">
          <source>at line &quot;BBB&quot;</source>
          <target state="translated">&quot;BBB&quot;라인에서</target>
        </trans-unit>
        <trans-unit id="48a51572765a96c5528d9b97e645d1cb1d8ca215" translate="yes" xml:space="preserve">
          <source>at line &quot;CCC&quot;</source>
          <target state="translated">&quot;CCC&quot;라인에서</target>
        </trans-unit>
        <trans-unit id="5b6a04bdcab2545757147311bdd9dcec1526a1b4" translate="yes" xml:space="preserve">
          <source>edit: i believe this is also the reason to use StringBuffer when it comes to &quot;adding&quot; two Strings because you can modifie the original object which u can't with immutable objects like String is.</source>
          <target state="translated">편집 : 나는 또한 StringBuffer와 같이 불변의 객체로 할 수없는 원래 객체를 수정할 수 있기 때문에 두 개의 문자열을 &quot;추가&quot;할 때 StringBuffer를 사용해야하는 이유라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="de6d9b079fecccb2b44d0540cd59d6982bd1a708" translate="yes" xml:space="preserve">
          <source>if the Method were defined as</source>
          <target state="translated">방법이 다음과 같이 정의 된 경우</target>
        </trans-unit>
        <trans-unit id="c0b841e19d194bfe513d4d90839ad8c2b89afe31" translate="yes" xml:space="preserve">
          <source>in case 1. and 2. if you change Foo (&lt;code&gt;Foo = 9&lt;/code&gt;) it only affects local scope as you have a copy of the Value. From inside the method we cannot even determine where in memory the original Foo was located.</source>
          <target state="translated">1과 2의 경우 Foo ( &lt;code&gt;Foo = 9&lt;/code&gt; )를 변경하면 값의 사본이 있으므로 로컬 범위에만 영향을줍니다. 방법 내부에서 우리는 메모리에서 원래 Foo가 어디에 있는지 확인할 수조차 없습니다.</target>
        </trans-unit>
        <trans-unit id="1865b6df13986dcf11d66c36aeef32061892ca5b" translate="yes" xml:space="preserve">
          <source>in case 3. and 4. if you use default language constructs and change Foo (&lt;code&gt;Foo = 11&lt;/code&gt;), it could change Foo globally (depends on the language, ie. Java or like Pascal's &lt;code&gt;procedure findMin(x, y, z: integer;&lt;/code&gt;&lt;strong&gt;var m&lt;/strong&gt;&lt;code&gt;: integer);&lt;/code&gt;). However if the language allows you to circumvent the dereference process, you can change &lt;code&gt;47&lt;/code&gt;, say to &lt;code&gt;49&lt;/code&gt;. At that point Foo seems to have been changed if you read it, because you have changed the &lt;strong&gt;local pointer&lt;/strong&gt; to it. And if you were to modify this Foo inside the method (&lt;code&gt;Foo = 12&lt;/code&gt;) you will probably FUBAR the execution of the program (aka. segfault) because you will write to a different memory than expected, you can even modify an area that is destined to hold executable program and writing to it will modify running code (Foo is now not at &lt;code&gt;47&lt;/code&gt;). BUT Foo's value of &lt;code&gt;47&lt;/code&gt; did not change globally, only the one inside the method, because &lt;code&gt;47&lt;/code&gt; was also a copy to the method.</source>
          <target state="translated">기본 언어 구문을 사용하고 Foo를 변경하면 ( &lt;code&gt;Foo = 11&lt;/code&gt; ), 언어에 따라 Foo가 전역 적으로 변경 될 수 있습니다 (예 : Java 또는 Pascal의 &lt;code&gt;procedure findMin(x, y, z: integer;&lt;/code&gt; 와 같은 findMin (x, y, z : integer; &lt;strong&gt;var m&lt;/strong&gt; &lt;code&gt;: integer);&lt;/code&gt; ). 그러나 언어가 역 참조 프로세스를 우회하도록 허용하는 경우 &lt;code&gt;47&lt;/code&gt; 을 &lt;code&gt;49&lt;/code&gt; 로 변경할 수 있습니다. 그 시점에서 Foo는 &lt;strong&gt;로컬 포인터&lt;/strong&gt; 를 변경했기 때문에 읽은 경우 변경된 것으로 보입니다. 그리고 메소드 ( &lt;code&gt;Foo = 12&lt;/code&gt; ) 내 에서이 Foo를 수정한다면 예상과 다른 메모리에 쓸 수 있기 때문에 프로그램 실행 (일명 segfault)을 FUBAR 할 것입니다. 실행 가능한 프로그램을 유지하고 프로그램을 작성하면 실행중인 코드가 수정됩니다 (Foo는 &lt;code&gt;47&lt;/code&gt; 이 아닙니다). 그러나 &lt;code&gt;47&lt;/code&gt; 의 47 도 메소드의 사본이기 때문에 Foo의 값 47 은 전체적으로 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="dd97dfe75334fc4ae374b64905b80db5da6f0246" translate="yes" xml:space="preserve">
          <source>in case 5. and 6. if you modify &lt;code&gt;223&lt;/code&gt; inside the method it creates the same mayhem as in 3. or 4. (a pointer, pointing to a now bad value, that is again used as a pointer) but this is still a local problem, as 223 was &lt;strong&gt;copied&lt;/strong&gt;. However if you are able to dereference &lt;code&gt;Ref2Foo&lt;/code&gt; (that is &lt;code&gt;223&lt;/code&gt;), reach to and modify the pointed value &lt;code&gt;47&lt;/code&gt;, say, to &lt;code&gt;49&lt;/code&gt;, it will affect Foo &lt;strong&gt;globally&lt;/strong&gt;, because in this case the methods got a copy of &lt;code&gt;223&lt;/code&gt;  but the referenced &lt;code&gt;47&lt;/code&gt; exists only once, and changing that to &lt;code&gt;49&lt;/code&gt; will lead every &lt;code&gt;Ref2Foo&lt;/code&gt; double-dereferencing to a wrong value.</source>
          <target state="translated">경우 5와 6의 경우 메소드 내에서 &lt;code&gt;223&lt;/code&gt; 을 수정하면 3이나 4에서와 동일한 신체 상해를 만듭니다 (현재 포인터가 나쁜 값을 가리키고 다시 포인터로 사용됨). 223이 &lt;strong&gt;복사 된&lt;/strong&gt; 로컬 문제 그러나 &lt;code&gt;Ref2Foo&lt;/code&gt; ( &lt;code&gt;223&lt;/code&gt; )를 역 참조 할 수 있고, 지정된 값 &lt;code&gt;47&lt;/code&gt; 에 도달하여 &lt;code&gt;49&lt;/code&gt; 로 수정하면 (예 : 49) , Foo &lt;strong&gt;전역에&lt;/strong&gt; 영향을 미칩니다.이 경우 메소드는 &lt;code&gt;223&lt;/code&gt; 의 사본을 얻었지만 참조 된 &lt;code&gt;47&lt;/code&gt; 은 존재하기 때문입니다. 한 번만, &lt;code&gt;49&lt;/code&gt; 로 변경하면 모든 &lt;code&gt;Ref2Foo&lt;/code&gt; 이중 역 참조가 잘못된 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="ea582fe2290fa53002694c7ca06cb1d90981b239" translate="yes" xml:space="preserve">
          <source>in reverseArray method, it will make a change in array a.</source>
          <target state="translated">reverseArray 메서드에서는 배열 a를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="84dd6095c9c7186e7a49f24a310118598e04da82" translate="yes" xml:space="preserve">
          <source>in reverseArray method, then the reference variable array1 in method reverseArray would stop pointing to array a and start pointing to array c (Dotted line in second image).</source>
          <target state="translated">reverseArray 메서드에서 reverseArray 메서드의 참조 변수 array1은 배열 a를 가리 키지 않고 배열 c (두 번째 이미지의 점선)를 가리 키기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d97fae11a419e6a12bc3edb13062dc19c09875c0" translate="yes" xml:space="preserve">
          <source>is &lt;em&gt;not&lt;/em&gt; a Dog; it's actually a &lt;em&gt;pointer&lt;/em&gt; to a Dog.</source>
          <target state="translated">개가 &lt;em&gt;아닙니다&lt;/em&gt; . 실제로는 개를 &lt;em&gt;가리키는 포인터&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b39623476b2f81bd70a4ff62eb5267bce22738e1" translate="yes" xml:space="preserve">
          <source>let's look at what's happening.</source>
          <target state="translated">무슨 일이 일어나고 있는지 보자.</target>
        </trans-unit>
        <trans-unit id="cf3a9617ac647d82c56f77cf9e8ae2169d187941" translate="yes" xml:space="preserve">
          <source>name= Fido</source>
          <target state="translated">이름 = 피도</target>
        </trans-unit>
        <trans-unit id="dcf9d3f64bd4525093b6cb2a29ebf7e8b0769c96" translate="yes" xml:space="preserve">
          <source>name= Maxx</source>
          <target state="translated">이름 = Maxx</target>
        </trans-unit>
        <trans-unit id="ea4bd0e3bb9e113c03dc6f25c82ed0880ff1e2b7" translate="yes" xml:space="preserve">
          <source>output of java PassByCopy:</source>
          <target state="translated">Java PassByCopy의 출력 :</target>
        </trans-unit>
        <trans-unit id="38b2369b273631468a9a5a2e59b5d466d9ec4e32" translate="yes" xml:space="preserve">
          <source>results in this:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="015c3de73f8f17655e3dba14c211482d8731c15c" translate="yes" xml:space="preserve">
          <source>someDog is followed to the &lt;code&gt;Dog&lt;/code&gt; it points to (the &lt;code&gt;Dog&lt;/code&gt; object at address 74)</source>
          <target state="translated">someDog가 가리키는 &lt;code&gt;Dog&lt;/code&gt; (주소 74의 Dog 개체)를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e52ae0c10562272d36f12c255484e6e511e5858a" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;Dog&lt;/code&gt; (the one at address 42) is asked to change his name to Max</source>
          <target state="translated">그 &lt;code&gt;Dog&lt;/code&gt; (주소 42에있는 개)는 자신의 이름을 Max로 변경하라는 요청을받습니다</target>
        </trans-unit>
        <trans-unit id="7444c7540aa94d77adc3ade05581aa22935938f0" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;Dog&lt;/code&gt; (the one at address 74) is asked to change his name to Rowlf</source>
          <target state="translated">그 &lt;code&gt;Dog&lt;/code&gt; (주소 74에있는 개 )는 그의 이름을 Rowlf로 바꾸라는 요청을받습니다</target>
        </trans-unit>
        <trans-unit id="a28fea2db09c1001f61be42d428ec193c0c8fe83" translate="yes" xml:space="preserve">
          <source>the parameter &lt;code&gt;someDog&lt;/code&gt; is set to the value 42</source>
          <target state="translated">&lt;code&gt;someDog&lt;/code&gt; 매개 변수는 42 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="05ed7faac6636fc4d3a902712b65ab43bb7a5b80" translate="yes" xml:space="preserve">
          <source>then, we return</source>
          <target state="translated">우리는 돌아온다</target>
        </trans-unit>
        <trans-unit id="49280f2d918fc694c452825a7629c4f082161d51" translate="yes" xml:space="preserve">
          <source>using methods from the object given as parameter will alter the
object as the references point to
the original objects. (if that
method itself alters some values)</source>
          <target state="translated">매개 변수로 제공된 오브젝트의 메소드를 사용하면 참조가 원래 오브젝트를 가리키는대로 오브젝트가 변경됩니다. (그 방법 자체가 일부 값을 변경하는 경우)</target>
        </trans-unit>
        <trans-unit id="d8b3d65782447afeffa2d99acee97cbf42b98ecf" translate="yes" xml:space="preserve">
          <source>we assign the parameter &lt;code&gt;someDog&lt;/code&gt; to 74</source>
          <target state="translated">매개 변수 &lt;code&gt;someDog&lt;/code&gt; 를 74에 할당합니다</target>
        </trans-unit>
        <trans-unit id="b5086d2ae6b0cb0d15f1111f65e03a674960103f" translate="yes" xml:space="preserve">
          <source>will print out &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; instead of &lt;code&gt;null&lt;/code&gt;. The reason this works is because &lt;code&gt;bar&lt;/code&gt; is a copy of the value of &lt;code&gt;baz&lt;/code&gt;, which is just a reference to &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt;. If it were the actual reference itself, then &lt;code&gt;foo&lt;/code&gt; would have redefined &lt;code&gt;baz&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; 를 출력합니다 &lt;code&gt;null&lt;/code&gt; 대신에. 이것이 작동하는 이유는 &lt;code&gt;bar&lt;/code&gt; 가 &lt;code&gt;baz&lt;/code&gt; 값의 사본이기 때문에 &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; 에 대한 참조 일뿐 입니다. . 실제 참조 자체라면 &lt;code&gt;foo&lt;/code&gt; 는 &lt;code&gt;baz&lt;/code&gt; 를 &lt;code&gt;null&lt;/code&gt; 로 재정의했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="4f07948ada1b914ebc3731995719969a1b588a36" translate="yes" xml:space="preserve">
          <source>you're essentially passing the &lt;em&gt;address&lt;/em&gt; of the created &lt;code&gt;Dog&lt;/code&gt; object to the &lt;code&gt;foo&lt;/code&gt; method.</source>
          <target state="translated">본질적으로 작성된 &lt;code&gt;Dog&lt;/code&gt; 객체의 &lt;em&gt;주소&lt;/em&gt; 를 &lt;code&gt;foo&lt;/code&gt; 메소드로 전달합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
