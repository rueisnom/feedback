<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/406230">
    <body>
      <group id="406230">
        <trans-unit id="9eb4a6c92e209092a0d12923bf9cc9ff4cb48470" translate="yes" xml:space="preserve">
          <source>(found with &lt;a href=&quot;http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/&quot;&gt;Grail&lt;/a&gt; and some further optimizations made by hand).</source>
          <target state="translated">( &lt;a href=&quot;http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/&quot;&gt;Grail&lt;/a&gt; 과 수작업으로 만든 추가 최적화 기능으로 발견).</target>
        </trans-unit>
        <trans-unit id="2e52af52a8546054dfc6413acff069ef2bc147ca" translate="yes" xml:space="preserve">
          <source>1. Search/replace the entire file to add a unique &quot;Tag&quot; to the beginning of each line containing any text.</source>
          <target state="translated">1. 전체 파일을 검색 / 바꾸어 텍스트가 포함 된 각 줄의 시작 부분에 고유 한 &quot;태그&quot;를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e705aab59352280c966865af9240b1976c79fb0c" translate="yes" xml:space="preserve">
          <source>2. Delete all lines that contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt; (replacement string is empty):</source>
          <target state="translated">2. 문자열 &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; 를 포함하는 모든 행을 삭제하십시오 (교체 문자열이 비어 있음).</target>
        </trans-unit>
        <trans-unit id="4d5359854c4a837f09da9271b5d18c0d86e98cb7" translate="yes" xml:space="preserve">
          <source>2. For all lines that contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, remove the unique &quot;Tag&quot;:</source>
          <target state="translated">2. 문자열 &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; 를 포함하는 모든 행에 대해 고유 한 &quot;Tag&quot;를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="3a77e275bfbe2978b006ae190f18f26a3701a1f9" translate="yes" xml:space="preserve">
          <source>3. At this point, all lines that begin with the unique &quot;Tag&quot;, &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;. I can now do my &lt;b&gt;&lt;i&gt;Something Else&lt;/i&gt;&lt;/b&gt; to only those lines.</source>
          <target state="translated">3.이 시점에서 고유 한 &quot;태그&quot;로 시작하는 모든 행은 문자열 &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; 를&lt;/strong&gt; 포함 &lt;b&gt;&lt;i&gt;하지 않습니다&lt;/i&gt;&lt;/b&gt; . 나는 이제 그 라인에만 &lt;b&gt;&lt;i&gt;다른&lt;/i&gt;&lt;/b&gt; 것을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da9c9c3fd6b8b9646ab8565f22f270096999311b" translate="yes" xml:space="preserve">
          <source>3. At this point, all remaining lines &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;. Remove the unique &quot;Tag&quot; from all lines (replacement string is empty):</source>
          <target state="translated">3.이 시점에서 나머지 모든 행에는 문자열 &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; 가&lt;/strong&gt; 포함 &lt;b&gt;&lt;i&gt;되지 않습니다&lt;/i&gt;&lt;/b&gt; . 모든 줄에서 고유 한 &quot;태그&quot;를 제거하십시오 (대체 문자열이 비어 있음).</target>
        </trans-unit>
        <trans-unit id="c5af5bfa811f56236562a7f528f03723506bbc92" translate="yes" xml:space="preserve">
          <source>4. When I am done, I remove the unique &quot;Tag&quot; from all lines (replacement string is empty):</source>
          <target state="translated">4. 완료되면 모든 줄에서 고유 한 &quot;태그&quot;를 제거합니다 (교체 문자열이 비어 있음).</target>
        </trans-unit>
        <trans-unit id="78feb677fcb5b7b33212618320b97f32f0c56503" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://vcsn.lrde.epita.fr&quot;&gt;Vcsn&lt;/a&gt; supports this operator (which it denotes &lt;code&gt;{c}&lt;/code&gt;, postfix).</source>
          <target state="translated">&lt;a href=&quot;http://vcsn.lrde.epita.fr&quot;&gt;Vcsn&lt;/a&gt; 은이 연산자 ( &lt;code&gt;{c}&lt;/code&gt; , 접미사를 나타냄)를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="27524e01dd8c223e92fc167f869ddb9c6ea20286" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24&quot;&gt;jex.im&lt;/a&gt; visualizes regular expressions:</source>
          <target state="translated">&lt;a href=&quot;https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24&quot;&gt;jex.im은&lt;/a&gt; 정규 표현식을 시각화합니다.</target>
        </trans-unit>
        <trans-unit id="b57eb38c594f4159c8cde8abea030ead596d976b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; Asserts that we are at the line end.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 우리는 줄 끝에 있다고 주장한다.</target>
        </trans-unit>
        <trans-unit id="52b36ac718178a71145d1ba891ac99338438678c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; End of the line anchor is not necessary here.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 라인 앵커의 끝은 여기에 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bc93b176a15f9710c8851f5f6d588bd9d60ed13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; before an optional \n, and the end of the string</source>
          <target state="translated">선택적인 \ n 앞의 &lt;code&gt;$&lt;/code&gt; 와 문자열의 끝</target>
        </trans-unit>
        <trans-unit id="b7c0e80a3bbc4ac75bc1f047ce7b29f9cae01e22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?!&lt;/code&gt; look ahead to see if there is not,</source>
          <target state="translated">&lt;code&gt;(?!&lt;/code&gt; 없는지 미리 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="13e685cc0a2609aafd47726b3d9c59af6288a725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)*&lt;/code&gt; end of \1   (Note: because you are using a quantifier on this capture, only the LAST repetition of the captured pattern will be stored in \1)</source>
          <target state="translated">&lt;code&gt;)*&lt;/code&gt; \ 1의 끝 (참고 :이 캡처에서 수량자를 사용하고 있으므로 캡처 된 패턴의 마지막 반복 만 \ 1에 저장됩니다)</target>
        </trans-unit>
        <trans-unit id="684f435ac9c437471ef88a255e4938ea502d9f17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; end of look-ahead, 
&lt;code&gt;.&lt;/code&gt; any character except \n,</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; 미리보기 끝, &lt;code&gt;.&lt;/code&gt; \ n을 제외한 모든 문자</target>
        </trans-unit>
        <trans-unit id="75716139a3b0f1db692009b0858a2ebdd5cb3451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.*&lt;/code&gt; In the Multiline mode, &lt;code&gt;.&lt;/code&gt; would match any character except newline or carriage return characters. And &lt;code&gt;*&lt;/code&gt; would repeat the previous character zero or more times. So &lt;code&gt;.*&lt;/code&gt; would match the whole line. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/4&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 멀티 라인 모드에서 &lt;code&gt;.&lt;/code&gt; 개행 또는 캐리지 리턴 문자를 제외한 모든 문자와 일치합니다. 그리고 &lt;code&gt;*&lt;/code&gt; 는 이전 문자를 0 번 이상 반복합니다. 따라서 &lt;code&gt;.*&lt;/code&gt; 는 전체 줄과 일치합니다. &lt;a href=&quot;http://regex101.com/r/kR0tO2/4&quot;&gt;여기&lt;/a&gt; 데모를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd00c1d9cc56e5d787782a13e4d330c5944bf7e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/&amp;lt;span(?:(?!bad).)*?&amp;gt;&lt;/code&gt; will match &lt;code&gt;&amp;lt;span class=\&quot;good\&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;span class=\&quot;ugly\&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/&amp;lt;span(?:(?!bad).)*?&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&amp;lt;span class=\&quot;good\&quot;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;span class=\&quot;ugly\&quot;&amp;gt;&lt;/code&gt; 와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="de91b3ecf3e66e23675457dbbafca8287427b031" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;  Asserts that we are at the start. ie, it matches all the line starts except the one in the &lt;code&gt;hede&lt;/code&gt; line. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/3&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 우리가 시작에 있다고 주장합니다. 즉, &lt;code&gt;hede&lt;/code&gt; 라인을 제외한 모든 라인 시작과 일치합니다. &lt;a href=&quot;http://regex101.com/r/kR0tO2/3&quot;&gt;여기&lt;/a&gt; 데모를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="19f3528c6d690ada198857c36184fef7782bef63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; Asserts that we are at the start.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 우리가 시작에 있다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="ca6ec5ae2a05e42e32bda5e3ea41a1c74bef7b3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;the beginning of the string,
&lt;code&gt;(&lt;/code&gt; group and capture to \1 (0 or more times (matching the most amount possible)),</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 문자열의 시작 &lt;code&gt;(&lt;/code&gt; 그룹화 및 \ 1까지 캡처 (0 회 이상 (가장 많은 양과 일치)),</target>
        </trans-unit>
        <trans-unit id="88ef62a0b91eaca8ee49fdab3c971717fd8464d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hede&lt;/code&gt; Matches the string &lt;code&gt;hede&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hede&lt;/code&gt; 문자열 hede와 일치</target>
        </trans-unit>
        <trans-unit id="d1a65ea189e42cc8455fe0afc293a1e00cd3f479" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hede&lt;/code&gt; your string,</source>
          <target state="translated">당신의 끈을 &lt;code&gt;hede&lt;/code&gt; 하십시오</target>
        </trans-unit>
        <trans-unit id="d003b960bdb077c1dfe6beb8ce4ca5d1176468dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(where the &lt;code&gt;/.../&lt;/code&gt; are the regex delimiters, i.e., not part of the pattern)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(여기서 &lt;code&gt;/.../&lt;/code&gt; 는 정규식 구분 기호입니다. 즉 패턴의 일부가 아닙니다)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f717ceaec1723443831abf050e1226ab1d95364" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If&lt;/em&gt; you're just using it for grep, you can use &lt;code&gt;grep -v hede&lt;/code&gt; to get all lines which do not contain hede.</source>
          <target state="translated">grep에 사용하는 경우 &lt;code&gt;grep -v hede&lt;/code&gt; 를 사용하여 hede 가 포함되지 않은 모든 행을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201b5844b8586d0c78336f51ab67e7879a440e2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Textpad&lt;/code&gt;&lt;/strong&gt; supports some Regex, but does not support lookahead or lookbehind, so it takes a few steps.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Textpad&lt;/code&gt; &lt;/strong&gt; 는 일부 정규식을 지원하지만 미리보기 또는 뒤보기를 지원하지 않으므로 몇 가지 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c332061cf4bd899460b0a4c0a7eaa14bdb27b163" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Answer:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4780b347f8b966f53592b8d6b23f2c7b9836e63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Details:&lt;/strong&gt; The ^ anchor ensures the regex engine doesn't retry the match at every location in the string, which would match every string.</source>
          <target state="translated">&lt;strong&gt;세부 정보 :&lt;/strong&gt; ^ 앵커는 정규식 엔진이 모든 문자열과 일치하는 문자열의 모든 위치에서 일치를 재 시도하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="33a872627b08a5f899edf01305ae93d8a50b8d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Execution of the parts:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;부품의 실행 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9108ede24ec6135336892fdeecab45ae62e7a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Explanation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7844df429e40743092ec192901b82594402fa14d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hey why you added .* instead of .+ ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;왜 + 대신에. *를 추가했는지?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3f0d81e6aa9f7ffd4a855a16e0040cc0551378b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PART 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1 부&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e8addc8bc7252fbc0e0c5e9141350f92b5f32c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PART 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2 부&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73254be12eadf36210870b716538368a2fedd571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Through PCRE verb &lt;code&gt;(*SKIP)(*F)&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PCRE 동사를 통해 &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6b4aedb6aa5c2789c02d933c0a26fd6986b225b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; I have recently found Kendall Hopkins' excellent &lt;a href=&quot;https://github.com/KendallHopkins/FormalTheory&quot;&gt;FormalTheory&lt;/a&gt; library, written in PHP, which provides a functionality similar to Grail. Using it, and a simplifier written by myself, I've been able to write an online generator of negative regular expressions given an input phrase (only alphanumeric and space characters currently supported): &lt;a href=&quot;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&quot;&gt;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;업데이트 :&lt;/strong&gt; 최근 PHP로 작성된 Kendall Hopkins의 우수한 &lt;a href=&quot;https://github.com/KendallHopkins/FormalTheory&quot;&gt;FormalTheory&lt;/a&gt; 라이브러리가 Grail과 유사한 기능을 제공합니다. 그것을 사용하고 직접 작성 한 단순화를 사용하여 입력 문구 (현재 영숫자 및 공백 문자 만 지원됨)가 주어진 음수 정규 표현식의 온라인 생성기를 작성할 수있었습니다 : &lt;a href=&quot;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&quot;&gt;http://www.formauri.es/personal/ pgimeno / misc / 비 일치 정규식 /&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adb30139018c264605cc9fc4ba28906a625cb041" translate="yes" xml:space="preserve">
          <source>A more complicated example: match all lines that start with &lt;code&gt;a&lt;/code&gt; and end with &lt;code&gt;z&lt;/code&gt;, but do not contain the substring &lt;code&gt;hede&lt;/code&gt;:</source>
          <target state="translated">더 복잡한 예 : &lt;code&gt;a&lt;/code&gt; 로 시작하고 &lt;code&gt;z&lt;/code&gt; 로 끝나는 모든 행을 일치 시키지만 하위 문자열 &lt;code&gt;hede&lt;/code&gt; 는 포함하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5a6ebacdd544ad2aebe976aa12b05b25bcb11e5b" translate="yes" xml:space="preserve">
          <source>A simpler solution is to use the not operator &lt;strong&gt;!&lt;/strong&gt;</source>
          <target state="translated">더 간단한 해결책은 not 연산자를 사용하는 것입니다 &lt;strong&gt;!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd0a50c6415821fc8508d785e47d96d51a7df1f3" translate="yes" xml:space="preserve">
          <source>A string is just a list of &lt;code&gt;n&lt;/code&gt; characters. Before, and after each character, there's an empty string. So a list of &lt;code&gt;n&lt;/code&gt; characters will have &lt;code&gt;n+1&lt;/code&gt; empty strings. Consider the string &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt;:</source>
          <target state="translated">문자열은 단지 &lt;code&gt;n&lt;/code&gt; 문자의 목록입니다. 각 문자 전후에 빈 문자열이 있습니다. 따라서 &lt;code&gt;n&lt;/code&gt; 개의 문자 목록에는 &lt;code&gt;n+1&lt;/code&gt; 개의 빈 문자열이 있습니다. &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; 문자열을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="99646ae275e2441f59e1131f109b01e70dc81648" translate="yes" xml:space="preserve">
          <source>Accurate and more efficient than the other answers. It implements Friedl's &lt;em&gt;&quot;unrolling-the-loop&quot;&lt;/em&gt; efficiency technique and requires much less backtracking.</source>
          <target state="translated">다른 답변보다 정확하고 효율적입니다. Friedl의 &lt;em&gt;&quot;언 롤링 루프 (unrolling-the-loop)&quot;&lt;/em&gt; 효율 기술을 구현하며 역 추적이 훨씬 적습니다.</target>
        </trans-unit>
        <trans-unit id="3cac49dcc87a01e093615798c54dde978759b6c5" translate="yes" xml:space="preserve">
          <source>Aforementioned &lt;code&gt;(?:(?!hede).)*&lt;/code&gt; is great because it can be anchored.</source>
          <target state="translated">&lt;code&gt;(?:(?!hede).)*&lt;/code&gt; 는 고정 할 수 있기 때문에 훌륭합니다.</target>
        </trans-unit>
        <trans-unit id="5b055b615dfbba6017949fb1b34a623d48637083" translate="yes" xml:space="preserve">
          <source>Also, please check out &lt;a href=&quot;https://github.com/amobiz/regexgen.js&quot;&gt;RegexGen.js&lt;/a&gt;, a JavaScript Regular Expression Generator that helps to construct complex regular expressions. With RegexGen.js, you can construct the regex in a more readable way:</source>
          <target state="translated">또한 복잡한 정규식을 생성하는 데 도움이되는 JavaScript 정규식 생성기 인 &lt;a href=&quot;https://github.com/amobiz/regexgen.js&quot;&gt;RegexGen.js&lt;/a&gt; 를 확인하십시오. RegexGen.js를 사용하면보다 읽기 쉬운 방식으로 정규식을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="583b84d757cb6a3e09c59142f1d4214fcaef0cf4" translate="yes" xml:space="preserve">
          <source>An, in my opinon, more readable variant of the top answer:</source>
          <target state="translated">내 의견으로는 더 많은 최고의 답변을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a4878a06e9361751e0c8c9f154eb93373a2d656" translate="yes" xml:space="preserve">
          <source>And if you need to match line break chars as well, use the &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;DOT-ALL modifier&lt;/a&gt; (the trailing &lt;code&gt;s&lt;/code&gt; in the following pattern):</source>
          <target state="translated">또한 줄 바꿈 문자도 일치시켜야하는 경우 &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;DOT-ALL 수정 자&lt;/a&gt; (다음 패턴의 후행 &lt;code&gt;s&lt;/code&gt; )를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="815196bdcfbffb0484620f8f7ff2d786b9c04d25" translate="yes" xml:space="preserve">
          <source>Another option is that to add a positive look-ahead and check if &lt;code&gt;hehe&lt;/code&gt; is anywhere in the input line, then we would negate that, with an expression similar to:</source>
          <target state="translated">또 다른 옵션은 긍정적 인 &lt;code&gt;hehe&lt;/code&gt; 을 추가하고 입력 행의 어느 곳에 있는지 확인하는 것입니다. 그러면 다음과 유사한 표현식으로이를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="90315245d641776926e97cda6abf2b5d2a47c6aa" translate="yes" xml:space="preserve">
          <source>As you can see, the input &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; will fail because on &lt;code&gt;e3&lt;/code&gt;, the regex &lt;code&gt;(?!hede)&lt;/code&gt; fails (there &lt;em&gt;is&lt;/em&gt;&lt;code&gt;&quot;hede&quot;&lt;/code&gt; up ahead!).</source>
          <target state="translated">보다시피 &lt;code&gt;e3&lt;/code&gt; 에서 정규식 &lt;code&gt;(?!hede)&lt;/code&gt; 이 실패하기 때문에 &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; 입력이 실패합니다 (앞에 &lt;code&gt;&quot;hede&quot;&lt;/code&gt; 가 있습니다!).</target>
        </trans-unit>
        <trans-unit id="14f0d43928a101b17017ac03b48125ba0258064c" translate="yes" xml:space="preserve">
          <source>Basically, &quot;match at the beginning of the line if and only if it does not have 'hede' in it&quot; - so the requirement translated almost directly into regex.</source>
          <target state="translated">기본적으로 &quot; 'hede'가없는 경우에만 줄의 시작과 일치하므로 요구 사항은 거의 직접 정규식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b76db96cf2a32f41f46b8568c9c2f6995d10c7a9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.*&lt;/code&gt; would match a blank line but &lt;code&gt;.+&lt;/code&gt; won't match a blank. We want to match all the lines except &lt;code&gt;hede&lt;/code&gt; , there may be a possibility of blank lines also in the input . so you must use &lt;code&gt;.*&lt;/code&gt; instead of &lt;code&gt;.+&lt;/code&gt; . &lt;code&gt;.+&lt;/code&gt; would repeat the previous character one or more times. See &lt;code&gt;.*&lt;/code&gt; matches a blank line &lt;a href=&quot;http://regex101.com/r/kR0tO2/5&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 는 빈 줄과 일치하지만 &lt;code&gt;.+&lt;/code&gt; 는 빈 줄과 일치하지 않기 때문입니다. 우리는 &lt;code&gt;hede&lt;/code&gt; 를 제외한 모든 줄을 일치시키고 싶습니다. 입력에 빈 줄이있을 수도 있습니다. 따라서 &lt;code&gt;.+&lt;/code&gt; 대신 &lt;code&gt;.*&lt;/code&gt; 를 사용해야합니다. &lt;code&gt;.+&lt;/code&gt; 는 이전 문자를 여러 번 반복합니다. &lt;a href=&quot;http://regex101.com/r/kR0tO2/5&quot;&gt;여기에서&lt;/a&gt; . &lt;code&gt;.*&lt;/code&gt; 는 빈 줄과 일치합니다를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6f977a9521045923d16f98954c616fecb8c843e" translate="yes" xml:space="preserve">
          <source>Benchmark Text:</source>
          <target state="translated">벤치 마크 텍스트 :</target>
        </trans-unit>
        <trans-unit id="4f46ac72b3634f96c6860b1ed26d9d4cd71d21aa" translate="yes" xml:space="preserve">
          <source>Benchmarks</source>
          <target state="translated">Benchmarks</target>
        </trans-unit>
        <trans-unit id="b3d97f68b4c000dbfe8c7d755739582257de96d6" translate="yes" xml:space="preserve">
          <source>But the following would suffice in this case:</source>
          <target state="translated">그러나이 경우에는 다음과 같이 충분합니다.</target>
        </trans-unit>
        <trans-unit id="9c556257951e2f974fa9f074f2d437367d7b7de5" translate="yes" xml:space="preserve">
          <source>But the overall most readable and performance-wise fastest solution seems to be 05 using a conditional statement
or 04 with the possesive quantifier. I think the Perl solutions should be even faster and more easily readable.</source>
          <target state="translated">그러나 전반적으로 가장 읽기 쉽고 성능 측면에서 가장 빠른 솔루션은 조건문을 사용하여 05 또는 소유 수량자를 사용하여 04로 보입니다. Perl 솔루션은 훨씬 빠르고 쉽게 읽을 수 있어야한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="038bc41a7c6c6423fba68ab38e1243e0673eb5b1" translate="yes" xml:space="preserve">
          <source>DEMO</source>
          <target state="translated">DEMO</target>
        </trans-unit>
        <trans-unit id="0b308b0064ee9df9865833a93aaf9d02316a25a9" translate="yes" xml:space="preserve">
          <source>Demo in Ruby:</source>
          <target state="translated">루비 데모 :</target>
        </trans-unit>
        <trans-unit id="2668fed25786577ef5330fbb43aa5160b5fce977" translate="yes" xml:space="preserve">
          <source>Desired output:</source>
          <target state="translated">원하는 출력 :</target>
        </trans-unit>
        <trans-unit id="22ed035c38e99c0a0525f1aa14558f382586a7e4" translate="yes" xml:space="preserve">
          <source>Do not use:</source>
          <target state="translated">사용하지 마세요:</target>
        </trans-unit>
        <trans-unit id="8248c9f017b2a661d23671bd60ce72132eb021cd" translate="yes" xml:space="preserve">
          <source>ETA Oh, rereading the question, &lt;code&gt;grep -v&lt;/code&gt; is probably what you meant by &quot;tools options&quot;.</source>
          <target state="translated">ETA 아, &lt;code&gt;grep -v&lt;/code&gt; 라는 질문을 다시 읽으면 &quot;도구 옵션&quot;이라는 의미 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="38d08890b5b368e55863bf943b6b9078a77b395b" translate="yes" xml:space="preserve">
          <source>FWIW, since regular languages (aka rational languages) are closed under complementation, it's always possible to find a regular expression (aka rational expression) that negates another expression. But not many tools implement this.</source>
          <target state="translated">FWIW, 정규 언어 (일명 합리적 언어)는 보완 아래 닫혀 있기 때문에 다른 표현을 무효화하는 정규 표현식 (일명 합리적인 표현)을 항상 찾을 수 있습니다. 그러나이를 구현하는 도구는 많지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94a4158640ead0903e4198248cdd279ee4bf592b" translate="yes" xml:space="preserve">
          <source>Finally, as everyone has noted, if your regular expression engine supports negative lookahead, that simplifies the task a lot. For example, with GNU grep:</source>
          <target state="translated">마지막으로, 모든 사람들이 지적했듯이 정규 표현식 엔진이 부정적인 예측을 지원하면 작업이 크게 단순화됩니다. 예를 들어 GNU grep을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e7840fc67eb63c0fc62b3bb9275d4ae78f58cc36" translate="yes" xml:space="preserve">
          <source>First, it tries to find &quot;hede&quot; somewhere in the line. If successful, at this point, &lt;code&gt;(*COMMIT)&lt;/code&gt; tells the engine to, not only not backtrack in the event of a failure, but also not to attempt any further matching in that case. Then, we try to match something that cannot possibly match (in this case, &lt;code&gt;^&lt;/code&gt;).</source>
          <target state="translated">먼저, 어딘가에서 &quot;hede&quot;를 찾으려고 노력합니다. 성공하면이 시점에서 &lt;code&gt;(*COMMIT)&lt;/code&gt; 은 엔진에 장애 발생시 역 추적뿐만 아니라 해당 경우 추가 일치를 시도하지 않도록 지시합니다. 그런 다음 일치하지 않는 항목 (이 경우 &lt;code&gt;^&lt;/code&gt; )을 일치 시키려고합니다.</target>
        </trans-unit>
        <trans-unit id="66fd11bbda1e7cb077ac7a5170f9d22cd9e79e06" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;hede&lt;/code&gt; it outputs:</source>
          <target state="translated">&lt;code&gt;hede&lt;/code&gt; 의 경우 다음을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="c7cb8f31d0f67cada2b023061ce292ebd71188db" translate="yes" xml:space="preserve">
          <source>For example, a string:</source>
          <target state="translated">예를 들어, 문자열 :</target>
        </trans-unit>
        <trans-unit id="44957a991234be8e9df9fa75f2eb494f5b1a8eed" translate="yes" xml:space="preserve">
          <source>For me, I sometimes need to do this while editing a file using &lt;strong&gt;&lt;code&gt;Textpad&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">나에게 &lt;strong&gt; &lt;code&gt;Textpad&lt;/code&gt; 을&lt;/strong&gt; 사용하여 파일을 편집하는 동안 때로는이 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce940869d506a887a010eb773ba2c6af358bf25a" translate="yes" xml:space="preserve">
          <source>For more information about lookahead, please check out the great article: &lt;a href=&quot;http://www.rexegg.com/regex-lookarounds.html&quot;&gt;Mastering Lookahead and Lookbehind&lt;/a&gt;.</source>
          <target state="translated">lookahead에 대한 자세한 내용은 위대한 기사 인 &lt;a href=&quot;http://www.rexegg.com/regex-lookarounds.html&quot;&gt;Lookahead 및 Lookbehind 마스터 링을&lt;/a&gt; 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c25f2278c3b324ffc728c690b8635beda0a6a6d1" translate="yes" xml:space="preserve">
          <source>For those interested in the details, the technique employed is to convert the regular expression that matches the word into a finite automaton, then invert the automaton by changing every acceptance state to non-acceptance and vice versa, and then converting the resulting FA back to a regular expression.</source>
          <target state="translated">세부 사항에 관심이있는 사람들을 위해 사용 된 기술은 단어와 일치하는 정규식을 유한 오토 마톤으로 변환 한 다음 모든 수락 상태를 비수용으로 변경하거나 그 반대로 오토 마톤을 반전시킨 다음 결과 FA를 정규식.</target>
        </trans-unit>
        <trans-unit id="e3b647855c42983ecd846d1757dfd4687da23b1b" translate="yes" xml:space="preserve">
          <source>Given a string: 
&lt;code&gt;
&amp;lt;span class=&quot;good&quot;&amp;gt;bar&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;bad&quot;&amp;gt;foo&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ugly&quot;&amp;gt;baz&amp;lt;/span&amp;gt;
&lt;/code&gt;</source>
          <target state="translated">주어진 문자열 : &lt;code&gt; &amp;lt;span class=&quot;good&quot;&amp;gt;bar&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;bad&quot;&amp;gt;foo&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ugly&quot;&amp;gt;baz&amp;lt;/span&amp;gt; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a41b37dc9eb2f2ea1a88a659b705994f14fc76f" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;http://jsfiddle.net/pvJL5/3/&quot;&gt;demo code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/pvJL5/3/&quot;&gt;데모 코드&lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="440b25c25e75becc55b449c73a3491fe97d861e4" translate="yes" xml:space="preserve">
          <source>Here is the improved regex:</source>
          <target state="translated">향상된 정규식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a9a8952516d81a0b39d9122ade38c17c2ed9060" translate="yes" xml:space="preserve">
          <source>Here's &lt;a href=&quot;http://www.perlmonks.org/?node_id=588315#588368&quot;&gt;a good explanation&lt;/a&gt; of why it's not easy to negate an arbitrary regex. I have to agree with the other answers, though: if this is anything other than a hypothetical question, then a regex is not the right choice here.</source>
          <target state="translated">여기에 임의의 정규식을 부정하는 것이 쉽지 않은 이유에 &lt;a href=&quot;http://www.perlmonks.org/?node_id=588315#588368&quot;&gt;대한 좋은 설명&lt;/a&gt; 이 있습니다. 그러나 다른 대답에 동의해야합니다. 이것이 가상의 질문 이외의 것이면 정규 표현식이 올바른 선택이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ddaef8476b8e3acafac4825d7b8f1ac998e71f92" translate="yes" xml:space="preserve">
          <source>Here's a method that I haven't seen used before:</source>
          <target state="translated">이전에 사용하지 않은 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dff1040ef948d2545fd38f5ddc5048a75c98520" translate="yes" xml:space="preserve">
          <source>Here's a script to test it (note it generates a file &lt;code&gt;testinput.txt&lt;/code&gt; in the current directory):</source>
          <target state="translated">테스트 할 스크립트는 다음과 같습니다 (현재 디렉토리에 &lt;code&gt;testinput.txt&lt;/code&gt; 파일이 생성됨).</target>
        </trans-unit>
        <trans-unit id="5f28c2737b2f0e2188d8328f330fac2b15157b53" translate="yes" xml:space="preserve">
          <source>Here's how I'd do it:</source>
          <target state="translated">내가하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="af4b2da81f792f5da8904c48f25a28f04b5d9a3c" translate="yes" xml:space="preserve">
          <source>How to use PCRE's backtracking control verbs to match a line not containing a word</source>
          <target state="translated">PCRE의 역 추적 제어 동사를 사용하여 단어를 포함하지 않는 행과 일치시키는 방법</target>
        </trans-unit>
        <trans-unit id="358f19a96883463715eb0b8d693998ffb417eb35" translate="yes" xml:space="preserve">
          <source>However, GNU &lt;code&gt;grep&lt;/code&gt; implements extensions that allow it. In particular, &lt;code&gt;\|&lt;/code&gt; is the alternation operator in GNU's implementation of BREs, and &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; are the parentheses. If your regular expression engine supports alternation, negative bracket expressions, parentheses and the Kleene star, and is able to anchor to the beginning and end of the string, that's all you need for this approach. Note however that negative sets &lt;code&gt;[^ ... ]&lt;/code&gt; are very convenient in addition to those, because otherwise, you need to replace them with an expression of the form &lt;code&gt;(a|b|c| ... )&lt;/code&gt; that lists every character that is not in the set, which is extremely tedious and overly long, even more so if the whole character set is Unicode.</source>
          <target state="translated">그러나 GNU &lt;code&gt;grep&lt;/code&gt; 은이 를 허용하는 확장을 구현합니다. 특히 &lt;code&gt;\|&lt;/code&gt; GNU의 BRE 구현에서 대체 연산자이며 &lt;code&gt;\(&lt;/code&gt; 및 &lt;code&gt;\)&lt;/code&gt; 는 괄호입니다. 정규식 엔진이 교대, 음수 대괄호 식, 괄호 및 Kleene 별을 지원하고 문자열의 시작과 끝에 고정 할 수 있으면이 방법이 필요합니다. 그러나 음수 집합 &lt;code&gt;[^ ... ]&lt;/code&gt; 은 그 외에 추가로 매우 편리합니다. 그렇지 않은 경우 음수 집합 [a ... &lt;code&gt;(a|b|c| ... )&lt;/code&gt; 을 모든 문자를 나열하는 형식 (a | b | c | ...) 으로 바꿔야합니다. 전체 문자 세트가 유니 코드 인 경우에는 매우 지루하고 지나치게 긴 세트에 없습니다.</target>
        </trans-unit>
        <trans-unit id="87fce9ed530df5073b27f7dc4a7cb8a5bddaceaa" translate="yes" xml:space="preserve">
          <source>However, with Bart Kiers' answer, the lookahead part will test 1 to 4 characters ahead while matching any single character. We can avoid this and let the lookahead part check out the whole text, ensure there is no 'hede', and then the normal part (.*) can eat the whole text all at one time.</source>
          <target state="translated">그러나 Bart Kiers의 답변으로 lookahead 부분은 단일 문자와 일치하면서 1 ~ 4자를 미리 테스트합니다. 이를 피하고 lookahead 부분이 전체 텍스트를 확인하고 'hede'가 없는지 확인한 다음 일반 부분 (. *)이 전체 텍스트를 한 번에 모두 먹을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="358d0378b2ab94ec8627f21e6e089dabbbed421a" translate="yes" xml:space="preserve">
          <source>I believe the designers of RegEx anticipated the use of not operators.</source>
          <target state="translated">RegEx의 설계자는 연산자가 아닌 사람의 사용을 예상했습니다.</target>
        </trans-unit>
        <trans-unit id="e798d46c6cfecdfa243d565a95292a06448c5bd4" translate="yes" xml:space="preserve">
          <source>I decided to evaluate some of the presented Options and compare their performance, as well as use some new Features.
Benchmarking on .NET Regex Engine: &lt;a href=&quot;http://regexhero.net/tester/&quot;&gt;http://regexhero.net/tester/&lt;/a&gt;</source>
          <target state="translated">제시된 옵션 중 일부를 평가하고 성능을 비교하고 새로운 기능을 사용하기로 결정했습니다. .NET Regex Engine 벤치마킹 : &lt;a href=&quot;http://regexhero.net/tester/&quot;&gt;http://regexhero.net/tester/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa66090b531a3943e8315caeac17d53e7fa5772a" translate="yes" xml:space="preserve">
          <source>I know it's possible to match a word and then reverse the matches using other tools (e.g. &lt;code&gt;grep -v&lt;/code&gt;). However, is it possible to match lines that do not contain a specific word, e.g. &lt;code&gt;hede&lt;/code&gt;, using a regular expression?</source>
          <target state="translated">단어를 일치시키고 다른 도구 (예 : &lt;code&gt;grep -v&lt;/code&gt; )를 사용하여 일치를 뒤집을 수 있다는 것을 알고 있습니다. 그러나 정규식을 사용하여 특정 단어를 포함하지 않는 행 (예 : &lt;code&gt;hede&lt;/code&gt; ) 을 일치시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4065441f68e9c6020ab5a572b3efff079b3598f2" translate="yes" xml:space="preserve">
          <source>I tried to test most proposed solutions, some Optimizations are possible for certain words.
For Example if the First two letters of the search string are not the Same, answer 03 can be expanded to
&lt;code&gt;^(?&amp;gt;[^R]+|R+(?!egex Hero))*$&lt;/code&gt; resulting in a small performance gain.</source>
          <target state="translated">가장 제안 된 솔루션을 테스트하려고했지만 특정 단어에 대해 일부 최적화가 가능합니다. 예를 들어, 검색 문자열의 처음 두 글자가 같지 않으면 답변 03을 &lt;code&gt;^(?&amp;gt;[^R]+|R+(?!egex Hero))*$&lt;/code&gt; 로 확장하여 성능이 약간 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55152e4cb8b05e2398aff1b805ef864a7498c807" translate="yes" xml:space="preserve">
          <source>I want to match &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; tags which do not contain the substring &quot;bad&quot;.</source>
          <target state="translated">하위 문자열 &quot;bad&quot;를 포함하지 않는 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 태그와 일치 시키려고합니다.</target>
        </trans-unit>
        <trans-unit id="348fdb226d122d58a879e94920244cb659c2ff80" translate="yes" xml:space="preserve">
          <source>If I am looking to &lt;b&gt;&lt;i&gt;Do Something Else&lt;/i&gt;&lt;/b&gt; to only lines that &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, I would do it like this:</source>
          <target state="translated">문자열 &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; 를&lt;/strong&gt; 포함 &lt;b&gt;&lt;i&gt;하지 않는&lt;/i&gt;&lt;/b&gt; 행에만 &lt;b&gt;&lt;i&gt;다른&lt;/i&gt;&lt;/b&gt; 것을 수행하려는 경우 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="38622a9faba8a5ee89d14dd8753c178ec7f57e80" translate="yes" xml:space="preserve">
          <source>If I am looking to retain all lines that &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, I would do it like this:</source>
          <target state="translated">문자열 &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; 를&lt;/strong&gt; 포함 &lt;b&gt;&lt;i&gt;하지 않는&lt;/i&gt;&lt;/b&gt; 모든 줄을 유지하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="38763d6f5618ba3862a9ce1d1f4a6b9b7ba82b1e" translate="yes" xml:space="preserve">
          <source>If a line does not contain &quot;hede&quot; then the second alternative, an empty subpattern, successfully matches the subject string.</source>
          <target state="translated">행에 &quot;hede&quot;가 포함되어 있지 않으면 두 번째 대안 인 빈 하위 패턴이 제목 문자열과 성공적으로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d412617b77836527f5a7b6be35bc1f03d6769b94" translate="yes" xml:space="preserve">
          <source>If the DOT-ALL modifier is not available, you can mimic the same behavior with the character class &lt;code&gt;[\s\S]&lt;/code&gt;:</source>
          <target state="translated">DOT-ALL 수정자를 사용할 수없는 경우 문자 클래스 &lt;code&gt;[\s\S]&lt;/code&gt; 하여 동일한 동작을 모방 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92f26649c4516946fcb1add8c4a8263d3b34b2bf" translate="yes" xml:space="preserve">
          <source>If you want the regex test to &lt;strong&gt;only&lt;/strong&gt; fail if the &lt;em&gt;entire string&lt;/em&gt; matches, the following will work:</source>
          <target state="translated">&lt;em&gt;전체 문자열이&lt;/em&gt; 일치하는 경우 &lt;strong&gt;에만&lt;/strong&gt; 정규식 테스트가 실패하도록하려면 다음이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="729b36879bb4e3767c9a57246277a86e711573a2" translate="yes" xml:space="preserve">
          <source>If you want to match a character to negate a word similar to negate character class:</source>
          <target state="translated">문자 클래스를 부정하는 것과 비슷한 단어를 부정하기 위해 문자를 일치 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="translated">파이썬에서 :</target>
        </trans-unit>
        <trans-unit id="f1be7176418bc2ec420699af8dfcaafdad7421f0" translate="yes" xml:space="preserve">
          <source>In my system it prints:</source>
          <target state="translated">내 시스템에서 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">Input:</target>
        </trans-unit>
        <trans-unit id="70b4e36c7616180b6c9127dc59657f047a94fe8b" translate="yes" xml:space="preserve">
          <source>It may be more maintainable to two regexes in your code, one to do the first match, and then if it matches run the second regex to check for outlier cases you wish to block for example &lt;code&gt;^.*(hede).*&lt;/code&gt; then have appropriate logic in your code.</source>
          <target state="translated">코드에서 두 개의 정규 표현식을 유지 관리하는 것이 더 좋을 수 있습니다. 하나는 첫 번째 일치를 수행 한 다음 일치하는 경우 두 번째 정규 표현식을 실행하여 이상 사례를 확인하여 &lt;code&gt;^.*(hede).*&lt;/code&gt; 와 같이 차단하려는 경우를 확인하십시오 . * 코드의 논리.</target>
        </trans-unit>
        <trans-unit id="619838c3b0a02408fab5aaa30829a7d4c40bef84" translate="yes" xml:space="preserve">
          <source>Let us consider the above regex by splitting it into two parts.</source>
          <target state="translated">위 정규식을 두 부분으로 나누어 고려해 봅시다.</target>
        </trans-unit>
        <trans-unit id="5395b8e8626e7f4b1fd55874dc85b6775aa31200" translate="yes" xml:space="preserve">
          <source>Maybe you'll find this on Google while trying to write a regex that is able to match segments of a line (as opposed to entire lines) which do &lt;strong&gt;not&lt;/strong&gt; contain a substring. Tooke me a while to figure out, so I'll share:</source>
          <target state="translated">하위 문자열을 포함하지 &lt;strong&gt;않는&lt;/strong&gt; 한 줄의 세그먼트 (전체 줄이 &lt;strong&gt;아닌&lt;/strong&gt; )와 일치 할 수있는 정규 표현식을 작성하려고 시도하는 동안 Google에서 찾을 수 있습니다. 알아내는 데 시간이 걸렸으므로 공유하겠습니다.</target>
        </trans-unit>
        <trans-unit id="f65015b6743116c0d591a6ecf9d76f8aaa121c4e" translate="yes" xml:space="preserve">
          <source>Not regex, but I've found it logical and useful to use serial greps with pipe to eliminate noise.</source>
          <target state="translated">정규식은 아니지만 소음을 제거하기 위해 파이프와 함께 직렬 그렙을 사용하는 것이 논리적이고 유용하다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="081045e6b01eadb48d20a103dbb36df17d72fe50" translate="yes" xml:space="preserve">
          <source>Note that the solution to &lt;strong&gt;does not &lt;em&gt;start with&lt;/em&gt; &amp;ldquo;hede&amp;rdquo;&lt;/strong&gt;:</source>
          <target state="translated">해결책 &lt;strong&gt;&lt;em&gt;은&lt;/em&gt; &quot;hede&quot;로 &lt;em&gt;시작&lt;/em&gt; 하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="26b82927c1805e4c7847c9a3577899e346640e6a" translate="yes" xml:space="preserve">
          <source>Note the (*?) lazy quantifier in the negative lookahead part is optional, you can use (*) greedy quantifier instead, depending on your data: if 'hede' does present and in the beginning half of the text, the lazy quantifier can be faster; otherwise, the greedy quantifier be faster. However if 'hede' does not present, both would be equal slow.</source>
          <target state="translated">네거티브 lookahead 부분의 (*?) 게으른 수량자는 선택 사항입니다. 데이터에 따라 대신 (*) 욕심 많은 수량자를 사용할 수 있습니다. 'hede'가 있고 텍스트의 절반에 게으른 수량자는 더 빠르다. 그렇지 않으면 탐욕스러운 수량자가 더 빠릅니다. 그러나 'hede'가 없으면 둘 다 느려집니다.</target>
        </trans-unit>
        <trans-unit id="0e9a29d02e68bcb3679deea8d109eb179570c686" translate="yes" xml:space="preserve">
          <source>Notice &lt;code&gt;&quot;(?!bbb).&quot;&lt;/code&gt; is neither lookbehind nor lookahead, it's lookcurrent, for example:</source>
          <target state="translated">&lt;code&gt;&quot;(?!bbb).&quot;&lt;/code&gt; 주목하십시오 . 뒤돌아 보지도 않고 예견하지도 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30d37c9788dcecf1fad3016f170ca9201ffa1d65" translate="yes" xml:space="preserve">
          <source>Notice that there are two sets (layers) of parentheses:</source>
          <target state="translated">괄호에는 두 세트 (계층)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a86f480c07344c42ab876520a48514924063ed70" translate="yes" xml:space="preserve">
          <source>Now you have the original text with all lines containing the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt; removed.</source>
          <target state="translated">이제 문자열 &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; 를&lt;/strong&gt; 포함하는 모든 줄이 제거 된 원본 텍스트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcc9367c99afe75c60c7432ea228375c0eed703b" translate="yes" xml:space="preserve">
          <source>OK, I admit this is not really an answer to the posted question posted and it may also use slightly more processing than a single regex. But for developers who came here looking for a fast emergency fix for an outlier case then this solution should not be overlooked.</source>
          <target state="translated">좋아, 이것은 실제로 게시 된 질문에 대한 답변이 아니며 단일 정규 표현식보다 약간 더 많은 처리를 사용할 수도 있음을 인정합니다. 그러나 이상 사례에 대한 빠른 긴급 수정을 찾고자하는 개발자에게는이 솔루션을 간과해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b217bc7b14d3698eeeed95b262a2782958f75640" translate="yes" xml:space="preserve">
          <source>Of course, if you're checking for &lt;em&gt;exact&lt;/em&gt; equality, a better general solution in this case is to check for string equality, i.e.</source>
          <target state="translated">물론, 당신이 &lt;em&gt;정확한&lt;/em&gt; 동등성을 검사한다면,이 경우에 더 나은 일반적인 해결책은 문자열 동등성을 검사하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="92e4e642b4116921153d765748bceeb2a5d28218" translate="yes" xml:space="preserve">
          <source>Of course, it's possible to have multiple failure requirements:</source>
          <target state="translated">물론 여러 가지 실패 요구 사항이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1676b6642119a6e78e273b06ef382dc642a9b8c8" translate="yes" xml:space="preserve">
          <source>Old answer:</source>
          <target state="translated">오래된 답변 :</target>
        </trans-unit>
        <trans-unit id="c25c62a5bc188579d5d23849efc8f31cf2a447d1" translate="yes" xml:space="preserve">
          <source>Part after the &lt;code&gt;|&lt;/code&gt; symbol. Part &lt;strong&gt;should be matched&lt;/strong&gt;.</source>
          <target state="translated">후 부분 &lt;code&gt;|&lt;/code&gt; 상징. 부분 &lt;strong&gt;이 일치해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="73b61b7b35a3691f94481b52b729efe8e43baadb" translate="yes" xml:space="preserve">
          <source>Part before the &lt;code&gt;|&lt;/code&gt; symbol. Part &lt;strong&gt;shouldn't be matched&lt;/strong&gt;.</source>
          <target state="translated">전 부분 &lt;code&gt;|&lt;/code&gt; 상징. 부품 &lt;strong&gt;이 일치하지 않아야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d7ae9fea9116fab8d5be9f40e43c9fe24123c8e9" translate="yes" xml:space="preserve">
          <source>RegEx Circuit</source>
          <target state="translated">정규식 회로</target>
        </trans-unit>
        <trans-unit id="41676a1dc090860fb04559a11f57d002c96d15af" translate="yes" xml:space="preserve">
          <source>Regex engine will start its execution from the first part.</source>
          <target state="translated">정규식 엔진은 첫 번째 부분부터 실행을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="71546fc265910c3ba4c3a0c33a7cfa6a7c857490" translate="yes" xml:space="preserve">
          <source>Regex negation is not particularly useful on its own but when you also have intersection, things get interesting, since you have a full set of boolean set operations: you can express &quot;the set which matches this, except for things which match that&quot;.</source>
          <target state="translated">정규 표현식 부정은 그 자체로는 특별히 유용하지는 않지만 교차가있을 때 부울 세트 연산 세트가 있기 때문에 상황이 흥미로워집니다. &quot;일치하는 것을 제외하고는 이것과 일치하는 세트&quot;를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19997c21128f333f226b26bb698b36f34117927e" translate="yes" xml:space="preserve">
          <source>Regular Expressions in the meaning of theoretical computer sciences &lt;em&gt;ARE NOT ABLE&lt;/em&gt; do it like this. For them it had to look something like this:</source>
          <target state="translated">이론적 인 컴퓨터 과학의 의미에서 정규 표현식은 불가능합니다. 그들에게는 다음과 같이 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="af38a3c1a9ef260f4705cde91de11408ba9cc3b3" translate="yes" xml:space="preserve">
          <source>Regular expression to match a line that doesn't contain a word</source>
          <target state="translated">단어를 포함하지 않는 행과 일치하는 정규식</target>
        </trans-unit>
        <trans-unit id="e9a6ae937eb3ddd638ffc636c1c42607a3fc5a93" translate="yes" xml:space="preserve">
          <source>Results are Iterations per second as the median of 3 runs - &lt;strong&gt;Bigger Number = Better&lt;/strong&gt;</source>
          <target state="translated">결과는 3 번의 중앙값 실행으로 초당 반복 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="2a8fa741fc245177c287037e3934f7b7d34f2900" translate="yes" xml:space="preserve">
          <source>Since .NET doesn't support action Verbs (*FAIL, etc.) I couldn't test the solutions P1 and P2.</source>
          <target state="translated">.NET은 동작 동사 (* FAIL 등)를 지원하지 않으므로 솔루션 P1 및 P2를 테스트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e8ae50092c4781a2d7e2ceca8e2bcb82f39e2eb" translate="yes" xml:space="preserve">
          <source>Since no one else has given a direct answer to the question &lt;em&gt;that was asked&lt;/em&gt;, I'll do it.</source>
          <target state="translated">다른 사람은 &lt;em&gt;요청 된&lt;/em&gt; 질문에 대한 직접적인 대답을하지 않았으므로 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a53ab784ceaf12bbfbc9f16efc79e5e24d16d2c3" translate="yes" xml:space="preserve">
          <source>Since the introduction of ruby-2.4.1, we can use the new &lt;a href=&quot;https://github.com/k-takata/Onigmo/issues/82&quot;&gt;Absent Operator&lt;/a&gt; in Ruby&amp;rsquo;s Regular Expressions</source>
          <target state="translated">루비 -2.4.1이 도입 된 이후, 루비 정규 표현식에서 새로운 &lt;a href=&quot;https://github.com/k-takata/Onigmo/issues/82&quot;&gt;부재 연산자&lt;/a&gt; 를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1692e723845d6b6032f0c8d3b96f35a2c9ce70d7" translate="yes" xml:space="preserve">
          <source>So the line which contains the string &lt;code&gt;hede&lt;/code&gt; would be matched. Once the regex engine sees the following &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; (&lt;em&gt;Note: You could write &lt;code&gt;(*F)&lt;/code&gt; as &lt;code&gt;(*FAIL)&lt;/code&gt;&lt;/em&gt;) verb, it skips and make the match to fail. &lt;code&gt;|&lt;/code&gt; called alteration or logical OR operator added next to the PCRE verb which inturn matches all the boundaries exists between each and every character on all the lines except the line contains the exact string &lt;code&gt;hede&lt;/code&gt;. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/2&quot;&gt;here&lt;/a&gt;. That is, it tries to match the characters from the remaining string. Now the regex in the second part would be executed.</source>
          <target state="translated">따라서 문자열 &lt;code&gt;hede&lt;/code&gt; 를 포함하는 줄이 일치합니다. 정규식 엔진에 다음 &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; ( &lt;em&gt;참고 : &lt;code&gt;(*F)&lt;/code&gt; 를 &lt;code&gt;(*FAIL)&lt;/code&gt; &lt;/em&gt; ) 동사 &lt;em&gt;로 쓸 수&lt;/em&gt; 있으면 건너 뛰고 일치하지 않습니다. &lt;code&gt;|&lt;/code&gt; PCRE 동사 옆에 추가 된 변경 또는 논리 OR 연산자는 행이 정확한 문자열 &lt;code&gt;hede&lt;/code&gt; 를 포함하는 것을 제외하고 모든 행의 각 문자 사이에 존재하는 모든 경계와 일치합니다. &lt;a href=&quot;http://regex101.com/r/kR0tO2/2&quot;&gt;여기&lt;/a&gt; 데모를 참조 하십시오 . 즉, 나머지 문자열의 문자를 일치 시키려고합니다. 이제 두 번째 부분의 정규식이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b7a42192468575a7e5a39750585ef8b488514333" translate="yes" xml:space="preserve">
          <source>So, in my example, every empty string is first validated to see if there's no &lt;code&gt;&quot;hede&quot;&lt;/code&gt; up ahead, before a character is consumed by the &lt;code&gt;.&lt;/code&gt; (dot). The regex &lt;code&gt;(?!hede).&lt;/code&gt; will do that only once, so it is wrapped in a group, and repeated zero or more times: &lt;code&gt;((?!hede).)*&lt;/code&gt;. Finally, the start- and end-of-input are anchored to make sure the entire input is consumed: &lt;code&gt;^((?!hede).)*$&lt;/code&gt;</source>
          <target state="translated">따라서, 나의 예에서, 모든 빈 문자열은 먼저 문자가 소비되기 전에 &lt;code&gt;&quot;hede&quot;&lt;/code&gt; 가 없는지 확인하기 위해 먼저 검증됩니다 &lt;code&gt;.&lt;/code&gt; (점). 정규식 &lt;code&gt;(?!hede).&lt;/code&gt; 한 번만 수행하므로 그룹으로 &lt;code&gt;((?!hede).)*&lt;/code&gt; 0 번 이상 반복됩니다 : ((?! hede).) * . 마지막으로 입력 시작과 끝은 전체 입력이 소비되도록 고정됩니다 : &lt;code&gt;^((?!hede).)*$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="f117cb601daa3d4275b6f738d374bfc07fdd9f7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.nongnu.org/txr/&quot;&gt;TXR Language&lt;/a&gt; supports regex negation.</source>
          <target state="translated">&lt;a href=&quot;http://www.nongnu.org/txr/&quot;&gt;TXR 언어&lt;/a&gt; 는 정규식 부정을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ebcf6058f2929ecc3e3b08aed979b745665af5ef" translate="yes" xml:space="preserve">
          <source>The OP did not specify or &lt;b&gt;&lt;kbd&gt;Tag&lt;/kbd&gt;&lt;/b&gt; the post to indicate the context (programming language, editor, tool) the Regex will be used within.</source>
          <target state="translated">OP는 정규식 내에서 사용될 컨텍스트 (프로그래밍 언어, 편집기, 도구)를 나타 내기 위해 게시물을 지정하거나 &lt;b&gt;&lt;kbd&gt;태그를&lt;/kbd&gt;&lt;/b&gt; 지정하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="11aa9db6100b5bf50fd1febfe3c053a2d5441f2d" translate="yes" xml:space="preserve">
          <source>The ^ anchor in the beginning is meant to represent the beginning of the line. The grep tool matches each line one at a time, in contexts where you're working with a multiline string, you can use the &quot;m&quot; flag:</source>
          <target state="translated">시작에서 ^ 앵커는 줄의 시작을 나타냅니다. grep 도구는 여러 줄 문자열로 작업하는 상황에서 &quot;m&quot;플래그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098ea33d53cc62129cfb7875bd9edba4f4bec259" translate="yes" xml:space="preserve">
          <source>The answer is that with POSIX &lt;code&gt;grep&lt;/code&gt;, it's impossible to literally satisfy this request:</source>
          <target state="translated">대답은 POSIX &lt;code&gt;grep&lt;/code&gt; 을 사용하면 문자 그대로이 요청을 만족시킬 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc27072c8e8fa68ee8a4aecd5fdce94bfeb957de" translate="yes" xml:space="preserve">
          <source>The below function will help you get your desired output</source>
          <target state="translated">아래 기능은 원하는 출력을 얻는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="452667fef7f202d7937567d77ec3043088267fe1" translate="yes" xml:space="preserve">
          <source>The expression is explained on the top right panel of &lt;a href=&quot;https://regex101.com/r/S127jy/1/&quot;&gt;regex101.com&lt;/a&gt;, if you wish to explore/simplify/modify it, and in &lt;a href=&quot;https://regex101.com/r/S127jy/1/debugger&quot;&gt;this link&lt;/a&gt;, you can watch how it would match against some sample inputs, if you like.</source>
          <target state="translated">표현식은 &lt;a href=&quot;https://regex101.com/r/S127jy/1/&quot;&gt;regex101.com의&lt;/a&gt; 오른쪽 상단 패널에 설명되어 있습니다. 탐색 / 단순화 / 수정하려는 &lt;a href=&quot;https://regex101.com/r/S127jy/1/debugger&quot;&gt;경우이 링크&lt;/a&gt; 에서 원하는 경우 일부 샘플 입력과 일치하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81d959c36f65aa571d1474a3105362386f4bce31" translate="yes" xml:space="preserve">
          <source>The first 7 lines should not match, since they contain the searched Expression, while the lower 7 lines should match!</source>
          <target state="translated">처음 7 줄은 검색된 Expression을 포함하므로 일치하지 않아야합니다. 반면 7 줄은 일치해야합니다!</target>
        </trans-unit>
        <trans-unit id="30eca3e3a5dee91a29274eb92d118bf760f5f68b" translate="yes" xml:space="preserve">
          <source>The former checks for &amp;ldquo;hede&amp;rdquo; only at the input string&amp;rsquo;s first position, rather than at every position.</source>
          <target state="translated">전자는 모든 위치가 아닌 입력 문자열의 첫 번째 위치에서만 &quot;hede&quot;를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ec7560158d4afaeca7ad767df676f2c3f8316d2b" translate="yes" xml:space="preserve">
          <source>The given answers are perfectly fine, just an academic point:</source>
          <target state="translated">주어진 대답은 학문적 요점으로 완벽하게 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2d09bbc95c0bd1eee8d3c6bb5adc11e14f4f00c5" translate="yes" xml:space="preserve">
          <source>The innermost one is for the negative lookahead (it is not a capture group)</source>
          <target state="translated">가장 안쪽은 부정적 예측을위한 것입니다 (캡처 그룹이 아님).</target>
        </trans-unit>
        <trans-unit id="29b7a8c9eb45daf61b377e68a90e0dacca34eb0c" translate="yes" xml:space="preserve">
          <source>The logic of serial grep's is (not a comment) and (matches dir)</source>
          <target state="translated">직렬 grep의 논리는 (댓글이 아님) 및 (dir과 일치)</target>
        </trans-unit>
        <trans-unit id="1a96bded5f6ba78d21a0246672404cc4fdf84614" translate="yes" xml:space="preserve">
          <source>The notion that regex doesn't support inverse matching is not entirely true. You can mimic this behavior by using negative look-arounds:</source>
          <target state="translated">정규 표현식이 역 매칭을 지원하지 않는다는 개념은 전적으로 사실이 아닙니다. 부정적인 둘러보기를 사용하여이 동작을 모방 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3854f1c652980feef2e8f16cab154d60899f8027" translate="yes" xml:space="preserve">
          <source>The outermost was interpreted by Ruby as capture group but we don't want it to be a capture group, so I added ?: at it's beginning and it is no longer interpreted as a capture group.</source>
          <target state="translated">가장 바깥 쪽은 Ruby에서 캡처 그룹으로 해석되었지만 캡처 그룹이되기를 원하지 않으므로 시작시에? :를 추가하고 더 이상 캡처 그룹으로 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53549eab46883cf85fd1a09e3b5aed26dca85805" translate="yes" xml:space="preserve">
          <source>The reason is that POSIX &lt;code&gt;grep&lt;/code&gt; is only required to work with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003&quot;&gt;Basic Regular Expressions&lt;/a&gt;, which are simply not powerful enough for accomplishing that task (they are not capable of parsing regular languages, because of lack of alternation and parentheses).</source>
          <target state="translated">POSIX &lt;code&gt;grep&lt;/code&gt; 은 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003&quot;&gt;기본 정규 표현식으로&lt;/a&gt; 만 작동해야하기 때문에 해당 작업을 수행하기에 충분히 강력하지 않습니다 (대체 및 괄호가 없기 때문에 정규 언어를 구문 분석 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="7ecb97c8fab3f5fb0b327ca5ef4661a1a4cf0f1f" translate="yes" xml:space="preserve">
          <source>The regex above will match any string, or line without a line break, &lt;strong&gt;not&lt;/strong&gt; containing the (sub)string 'hede'. As mentioned, this is not something regex is &quot;good&quot; at (or should do), but still, it &lt;em&gt;is&lt;/em&gt; possible.</source>
          <target state="translated">위의 정규 표현식은 (하위) 문자열 'hede'를 포함 &lt;strong&gt;하지 않는&lt;/strong&gt; 모든 문자열 또는 줄 바꿈이없는 행과 일치합니다. 언급했듯이 이것은 정규 표현식이 &quot;좋은&quot;것은 아니지만 여전히 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8bc1736cb0d5560815fe759f45e070ec21870289" translate="yes" xml:space="preserve">
          <source>The regex solution at the top of this answer may be helpful, however, in situations where a positive regex test is required (perhaps by an API).</source>
          <target state="translated">그러나이 답변의 맨 위에있는 정규식 솔루션은 긍정적 정규식 테스트가 필요한 경우 (아마도 API에 의해) 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18d6c0cc722c7bbc3e65fb8a5074dc1d497a9c6b" translate="yes" xml:space="preserve">
          <source>This method is no more efficient than a negative lookahead, but I figured I'd just throw it on here in case someone finds it nifty and finds a use for it for other, more interesting applications.</source>
          <target state="translated">이 방법은 부정적 예측보다 효율적이지 않지만 누군가가 멋진 것을 발견하고 더 흥미로운 다른 응용 프로그램에 사용하는 경우를 대비하여 여기에 던질 것이라고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="3886ebe4339f9490f06300de01ba2a2e949b872b" translate="yes" xml:space="preserve">
          <source>This only does a FULL match. Doing it for sub-matches would even be more awkward.</source>
          <target state="translated">이것은 전체 일치 만 수행합니다. 하위 경기를 위해 그것을하는 것은 더 어색 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="e922e950305ed79d2617ae1c8940572582dfcd3e" translate="yes" xml:space="preserve">
          <source>This simplification is ready to have &quot;AND&quot; clauses added:</source>
          <target state="translated">이 단순화는 &quot;AND&quot;절을 추가 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="31ba508b83d08df1a58027dfb2ff5193636dcc21" translate="yes" xml:space="preserve">
          <source>This would completely skips the line which contains the exact string &lt;code&gt;hede&lt;/code&gt; and matches all the remaining lines.</source>
          <target state="translated">이것은 정확한 문자열 &lt;code&gt;hede&lt;/code&gt; 를 포함하고 나머지 모든 줄과 일치하는 줄을 완전히 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="bda56a9be7875939dbf47726436cb5a754e198c2" translate="yes" xml:space="preserve">
          <source>Thus, in your case &lt;code&gt;^(?~hede)$&lt;/code&gt; does the job for you</source>
          <target state="translated">따라서 귀하의 경우 &lt;code&gt;^(?~hede)$&lt;/code&gt; 는 당신을 위해 일을 합니까</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="e70838bc7b5ac1d8247c350d535a21945717c6a7" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.conyedit.com&quot;&gt;ConyEdit&lt;/a&gt;, you can use the command line &lt;code&gt;cc.gl !/hede/&lt;/code&gt; to get lines that do not contain the regex matching, or use the command line &lt;code&gt;cc.dl /hede/&lt;/code&gt; to delete lines that contain the regex matching. They have the same result.</source>
          <target state="translated">&lt;a href=&quot;https://www.conyedit.com&quot;&gt;ConyEdit&lt;/a&gt; 을 사용하면 명령 행 &lt;code&gt;cc.gl !/hede/&lt;/code&gt; 를 사용하여 정규식 일치를 포함하지 않는 행을 가져 오거나 명령 행 &lt;code&gt;cc.dl /hede/&lt;/code&gt; 를 사용하여 정규식 일치를 포함하는 행을 삭제할 수 있습니다. 그들은 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="45f7d6f93e756fe076c6f4d4cc20e5bb4a0af7f1" translate="yes" xml:space="preserve">
          <source>With GNU &lt;code&gt;grep&lt;/code&gt;, the answer would be something like:</source>
          <target state="translated">GNU &lt;code&gt;grep&lt;/code&gt; 을 사용하면 대답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af3a7829ae5f96bbccfbc07b95bfc1b6818d038b" translate="yes" xml:space="preserve">
          <source>With negative lookahead, regular expression can match something not contains specific pattern. This is answered and explained by Bart Kiers. Great explanation!</source>
          <target state="translated">부정적 예측을 사용하면 정규식은 특정 패턴을 포함하지 않는 것과 일치 할 수 있습니다. 이것은 Bart Kiers가 대답하고 설명합니다. 좋은 설명!</target>
        </trans-unit>
        <trans-unit id="af97db013e5d443d690246871b2054ab1d1ebdfc" translate="yes" xml:space="preserve">
          <source>You can also use a tool that implements &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004&quot;&gt;Extended Regular Expressions&lt;/a&gt;, like &lt;code&gt;egrep&lt;/code&gt;, to get rid of the backslashes:</source>
          <target state="translated">&lt;code&gt;egrep&lt;/code&gt; 와 같은 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004&quot;&gt;확장 정규 표현식&lt;/a&gt; 을 구현하는 도구를 사용하여 백 슬래시를 제거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c3ead2f2a71a7f8de04237ee09b7ad0902ae6d3" translate="yes" xml:space="preserve">
          <source>You can see this example &lt;a href=&quot;https://stackoverflow.com/questions/406230&quot;&gt;here&lt;/a&gt;, and try Vcsn online &lt;a href=&quot;http://vcsn-sandbox.lrde.epita.fr/tree&quot;&gt;there&lt;/a&gt;.</source>
          <target state="translated">이 예제를 볼 수 있으며 Vcsn을 온라인으로 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="9117813c61704c7f607c297794b874af93ed534d" translate="yes" xml:space="preserve">
          <source>You could even put the negation &lt;em&gt;outside&lt;/em&gt; the test if you need any regex features (here, case insensitivity and range matching):</source>
          <target state="translated">정규식 기능 (여기서는 대소 문자를 구분하지 않고 범위 일치)이 필요한 경우 테스트 &lt;em&gt;외부&lt;/em&gt; 에서 부정을 넣을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e3bfb39813e0d54c6b52dba372f9b67a2de3789" translate="yes" xml:space="preserve">
          <source>You first define the type of your expressions: labels are letter (&lt;code&gt;lal_char&lt;/code&gt;) to pick from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; for instance (defining the alphabet when working with complementation is, of course, very important), and the &quot;value&quot; computed for each word is just a Boolean: &lt;code&gt;true&lt;/code&gt; the word is accepted, &lt;code&gt;false&lt;/code&gt;, rejected.</source>
          <target state="translated">먼저 표현식의 유형을 정의하십시오. 레이블은 예를 들어 &lt;code&gt;a&lt;/code&gt; 를 &lt;code&gt;z&lt;/code&gt; 에서 선택하기위한 문자 ( &lt;code&gt;lal_char&lt;/code&gt; )입니다 (보완 작업시 알파벳 정의는 물론 매우 중요합니다). 각 단어에 대해 계산 된 &quot;값&quot; 부울 만 : &lt;code&gt;true&lt;/code&gt; 단어가 수락되고 &lt;code&gt;false&lt;/code&gt; 가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8b92e959c52f5c967563185e1dc02103fcdeb744" translate="yes" xml:space="preserve">
          <source>Your &lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt; statement will need to match &quot;contains&quot; and not match &quot;excludes&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt; 문은 &quot;contains&quot;와 일치해야하며 &quot;excludes&quot;와 일치하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="dc5f45feccd145875695bcee7ec9e44130e5b96f" translate="yes" xml:space="preserve">
          <source>^((?!hede).)*$ is an elegant solution, except since it consumes characters you won't be able to combine it with other criteria. For instance, say you wanted to check for the non-presence of &quot;hede&quot; and the presence of &quot;haha.&quot; This solution would work because it won't consume characters:</source>
          <target state="translated">^ ((?! hede).) * $는 문자를 소비하기 때문에 다른 기준과 결합 할 수 없다는 점을 제외하고는 훌륭한 솔루션입니다. 예를 들어, &quot;hede&quot;가 없는지 &quot;haha&quot;가 있는지 확인하고 싶다고 가정하십시오. 이 솔루션은 문자를 소비하지 않기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3c24d7c6f693449c71187e2b53fec214d5e24eb3" translate="yes" xml:space="preserve">
          <source>^(?!.&lt;em&gt;\bhede\b)(?=.&lt;/em&gt;\bhaha\b)</source>
          <target state="translated">^(?!.&lt;em&gt;\bhede\b)(?=.&lt;/em&gt;\bhaha\b)</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="89c0d93ef605454f65fa159648fcc4f79d2c32ad" translate="yes" xml:space="preserve">
          <source>as expected.</source>
          <target state="translated">예상대로.</target>
        </trans-unit>
        <trans-unit id="78b9b44deba42148afa14f26da3512a067ed3f05" translate="yes" xml:space="preserve">
          <source>convert this expression to an automaton:</source>
          <target state="translated">이 표현식을 자동으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="0c97c3b2e427dd08a2a22afc585bfb112e48c297" translate="yes" xml:space="preserve">
          <source>e.g. -- If you want to allow all values except &quot;foo&quot; (i.e. &quot;foofoo&quot;, &quot;barfoo&quot;, and &quot;foobar&quot; will pass, but &quot;foo&quot; will fail), use: &lt;code&gt;^(?!foo$).*&lt;/code&gt;</source>
          <target state="translated">예 :- &quot;foo&quot;를 제외한 모든 값을 허용하려면 (예 : &quot;foofoo&quot;, &quot;barfoo&quot;및 &quot;foobar&quot;는 통과하지만 &quot;foo&quot;는 실패 함) &lt;code&gt;^(?!foo$).*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e16583e5292c76975f4ece4ba1b17808d175dd82" translate="yes" xml:space="preserve">
          <source>eg.  search an apache config file without all the comments-</source>
          <target state="translated">예. 모든 주석없이 아파치 구성 파일을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="81165d7e6d83159d5242d2e3447560267f5f0a15" translate="yes" xml:space="preserve">
          <source>equivalent to (for .net):</source>
          <target state="translated">(.net의 경우)에 해당 :</target>
        </trans-unit>
        <trans-unit id="b9c5a9fb1e9449b3cc8c15f7f902b1d5321d355e" translate="yes" xml:space="preserve">
          <source>finally, convert this automaton back to a simple expression.</source>
          <target state="translated">마지막으로,이 오토 마톤을 간단한 표현으로 다시 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="37e4a0d8a8bb537de21f7a46cd439c6814401bfd" translate="yes" xml:space="preserve">
          <source>from the official &lt;a href=&quot;https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f&quot;&gt;doc&lt;/a&gt;</source>
          <target state="translated">공식 &lt;a href=&quot;https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f&quot;&gt;문서에서&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52ac93fe88a76f92fd6cbc405e59f5efceaa621f" translate="yes" xml:space="preserve">
          <source>is generally much more efficient than the solution to &lt;strong&gt;does not &lt;em&gt;contain&lt;/em&gt; &amp;ldquo;hede&amp;rdquo;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&quot;hede&quot;를 &lt;em&gt;포함&lt;/em&gt; 하지 않는&lt;/strong&gt; 솔루션보다 일반적으로 훨씬 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="86416a3c88475bb3fd86ea86b3fb79d0fa1fd2ab" translate="yes" xml:space="preserve">
          <source>or use it inline:</source>
          <target state="translated">또는 인라인으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ca91e5f012d312c0136c2de3497b8aa8ce4a805a" translate="yes" xml:space="preserve">
          <source>then you enter your expression:</source>
          <target state="translated">그런 다음 식을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="14ff5d9b2a6dee566d29abfb4bfc694ba905fd5b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;+&lt;/code&gt; is usually denoted &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt; denotes the empty word, and &lt;code&gt;[^]&lt;/code&gt; is usually written &lt;code&gt;.&lt;/code&gt; (any character).  So, with a bit of rewriting &lt;code&gt;()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;+&lt;/code&gt; 는 일반적으로 &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; 는 빈 단어를 나타내며 &lt;code&gt;[^]&lt;/code&gt; 는 보통 씁니다 &lt;code&gt;.&lt;/code&gt; (모든 문자). 따라서 약간의 다시 쓰기 &lt;code&gt;()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13a0d941cdbf53982cbc548e039164854ba5a26f" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;e&lt;/code&gt;'s are the empty strings. The regex &lt;code&gt;(?!hede).&lt;/code&gt; looks ahead to see if there's no substring &lt;code&gt;&quot;hede&quot;&lt;/code&gt; to be seen, and if that is the case (so something else is seen), then the &lt;code&gt;.&lt;/code&gt; (dot) will match any character except a line break. Look-arounds are also called &lt;em&gt;zero-width-assertions&lt;/em&gt; because they don't &lt;em&gt;consume&lt;/em&gt; any characters. They only assert/validate something.</source>
          <target state="translated">여기서 &lt;code&gt;e&lt;/code&gt; 는 빈 문자열입니다. 정규식 &lt;code&gt;(?!hede).&lt;/code&gt; 하위 문자열 &lt;code&gt;&quot;hede&quot;&lt;/code&gt; 가 표시되지 않는지 계속 확인하고이 경우 (따라서 다른 것이 있으면) &lt;code&gt;.&lt;/code&gt; (점)은 줄 바꿈을 제외한 모든 문자와 일치합니다. 둘러보기는 문자를 &lt;em&gt;소비&lt;/em&gt; 하지 않기 때문에 &lt;em&gt;폭이 0 인 어설 션&lt;/em&gt; 이라고도 &lt;em&gt;합니다&lt;/em&gt; . 그들은 단지 무언가를 주장하고 / 확인한다.</target>
        </trans-unit>
        <trans-unit id="88141f0aa6d0a5c8b71d83d50fe9878477ba508a" translate="yes" xml:space="preserve">
          <source>which is equivalent to the above.</source>
          <target state="translated">위와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3f4587567dd91d6188f1c48f4e79ecf19e09aae" translate="yes" xml:space="preserve">
          <source>with this, you avoid to test a lookahead on each positions:</source>
          <target state="translated">이를 통해 각 위치에서 미리보기를 테스트하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="a9f7501a4bb77ecb148f3a5340b3c2a4dc0e6caf" translate="yes" xml:space="preserve">
          <source>with word boundaries.</source>
          <target state="translated">단어 경계와 함께.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
