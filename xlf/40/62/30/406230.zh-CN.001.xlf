<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/406230">
    <body>
      <group id="406230">
        <trans-unit id="9eb4a6c92e209092a0d12923bf9cc9ff4cb48470" translate="yes" xml:space="preserve">
          <source>(found with &lt;a href=&quot;http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/&quot;&gt;Grail&lt;/a&gt; and some further optimizations made by hand).</source>
          <target state="translated">（在&lt;a href=&quot;http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/&quot;&gt;Grail中&lt;/a&gt;找到，并进行了一些手动优化）。</target>
        </trans-unit>
        <trans-unit id="2e52af52a8546054dfc6413acff069ef2bc147ca" translate="yes" xml:space="preserve">
          <source>1. Search/replace the entire file to add a unique &quot;Tag&quot; to the beginning of each line containing any text.</source>
          <target state="translated">1.搜索替换整个文件,在包含任何文本的每一行的开头添加一个唯一的 &quot;标签&quot;。</target>
        </trans-unit>
        <trans-unit id="e705aab59352280c966865af9240b1976c79fb0c" translate="yes" xml:space="preserve">
          <source>2. Delete all lines that contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt; (replacement string is empty):</source>
          <target state="translated">2.删除所有包含字符串&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; 的行&lt;/strong&gt; （替换字符串为空）：</target>
        </trans-unit>
        <trans-unit id="4d5359854c4a837f09da9271b5d18c0d86e98cb7" translate="yes" xml:space="preserve">
          <source>2. For all lines that contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, remove the unique &quot;Tag&quot;:</source>
          <target state="translated">2.对于所有包含字符串&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; 的行&lt;/strong&gt; ，删除唯一的&amp;ldquo; Tag&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="3a77e275bfbe2978b006ae190f18f26a3701a1f9" translate="yes" xml:space="preserve">
          <source>3. At this point, all lines that begin with the unique &quot;Tag&quot;, &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;. I can now do my &lt;b&gt;&lt;i&gt;Something Else&lt;/i&gt;&lt;/b&gt; to only those lines.</source>
          <target state="translated">3.至此，所有以唯一的&amp;ldquo; Tag&amp;rdquo;开头的行都&lt;b&gt;&lt;i&gt;不要&lt;/i&gt;&lt;/b&gt;包含字符串&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; 。 现在，我只能对这些行进行其他操作。</target>
        </trans-unit>
        <trans-unit id="da9c9c3fd6b8b9646ab8565f22f270096999311b" translate="yes" xml:space="preserve">
          <source>3. At this point, all remaining lines &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;. Remove the unique &quot;Tag&quot; from all lines (replacement string is empty):</source>
          <target state="translated">3.此时，所有剩余的行&lt;b&gt;&lt;i&gt;都不&lt;/i&gt;&lt;/b&gt;包含字符串&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; 。 从所有行中删除唯一的&amp;ldquo; Tag&amp;rdquo;（替换字符串为空）：</target>
        </trans-unit>
        <trans-unit id="c5af5bfa811f56236562a7f528f03723506bbc92" translate="yes" xml:space="preserve">
          <source>4. When I am done, I remove the unique &quot;Tag&quot; from all lines (replacement string is empty):</source>
          <target state="translated">4.完成后,我把所有行中唯一的 &quot;Tag &quot;去掉(替换字符串为空)。</target>
        </trans-unit>
        <trans-unit id="78feb677fcb5b7b33212618320b97f32f0c56503" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://vcsn.lrde.epita.fr&quot;&gt;Vcsn&lt;/a&gt; supports this operator (which it denotes &lt;code&gt;{c}&lt;/code&gt;, postfix).</source>
          <target state="translated">&lt;a href=&quot;http://vcsn.lrde.epita.fr&quot;&gt;Vcsn&lt;/a&gt;支持此运算符（它表示后缀 &lt;code&gt;{c}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="27524e01dd8c223e92fc167f869ddb9c6ea20286" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24&quot;&gt;jex.im&lt;/a&gt; visualizes regular expressions:</source>
          <target state="translated">&lt;a href=&quot;https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24&quot;&gt;jex.im&lt;/a&gt;可视化正则表达式：</target>
        </trans-unit>
        <trans-unit id="b57eb38c594f4159c8cde8abea030ead596d976b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; Asserts that we are at the line end.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 断言我们处于行尾。</target>
        </trans-unit>
        <trans-unit id="52b36ac718178a71145d1ba891ac99338438678c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; End of the line anchor is not necessary here.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 此处不需要行锚。</target>
        </trans-unit>
        <trans-unit id="5bc93b176a15f9710c8851f5f6d588bd9d60ed13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; before an optional \n, and the end of the string</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 在可选的\ n之前和字符串的结尾</target>
        </trans-unit>
        <trans-unit id="b7c0e80a3bbc4ac75bc1f047ce7b29f9cae01e22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?!&lt;/code&gt; look ahead to see if there is not,</source>
          <target state="translated">&lt;code&gt;(?!&lt;/code&gt; 向前看是否没有，</target>
        </trans-unit>
        <trans-unit id="13e685cc0a2609aafd47726b3d9c59af6288a725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)*&lt;/code&gt; end of \1   (Note: because you are using a quantifier on this capture, only the LAST repetition of the captured pattern will be stored in \1)</source>
          <target state="translated">&lt;code&gt;)*&lt;/code&gt; \ 1的结尾（注意：由于您在此捕获中使用了量词，因此仅将LAST重复的捕获模式存储在\ 1中）</target>
        </trans-unit>
        <trans-unit id="684f435ac9c437471ef88a255e4938ea502d9f17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; end of look-ahead, 
&lt;code&gt;.&lt;/code&gt; any character except \n,</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; 提前结束， &lt;code&gt;.&lt;/code&gt; \ n以外的任何字符，</target>
        </trans-unit>
        <trans-unit id="75716139a3b0f1db692009b0858a2ebdd5cb3451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.*&lt;/code&gt; In the Multiline mode, &lt;code&gt;.&lt;/code&gt; would match any character except newline or carriage return characters. And &lt;code&gt;*&lt;/code&gt; would repeat the previous character zero or more times. So &lt;code&gt;.*&lt;/code&gt; would match the whole line. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/4&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 在多行模式下， &lt;code&gt;.&lt;/code&gt; 将匹配除换行符或回车符以外的任何字符。 &lt;code&gt;*&lt;/code&gt; 将重复前一个字符零次或多次。 所以 &lt;code&gt;.*&lt;/code&gt; 会匹配整行。 在&lt;a href=&quot;http://regex101.com/r/kR0tO2/4&quot;&gt;这里&lt;/a&gt;查看演示。</target>
        </trans-unit>
        <trans-unit id="bd00c1d9cc56e5d787782a13e4d330c5944bf7e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/&amp;lt;span(?:(?!bad).)*?&amp;gt;&lt;/code&gt; will match &lt;code&gt;&amp;lt;span class=\&quot;good\&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;span class=\&quot;ugly\&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/&amp;lt;span(?:(?!bad).)*?&amp;gt;&lt;/code&gt; 将与 &lt;code&gt;&amp;lt;span class=\&quot;good\&quot;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;span class=\&quot;ugly\&quot;&amp;gt;&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="de91b3ecf3e66e23675457dbbafca8287427b031" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;  Asserts that we are at the start. ie, it matches all the line starts except the one in the &lt;code&gt;hede&lt;/code&gt; line. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/3&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 断言我们是开始。 即，它与 &lt;code&gt;hede&lt;/code&gt; 行中的所有行开头匹配。 在&lt;a href=&quot;http://regex101.com/r/kR0tO2/3&quot;&gt;这里&lt;/a&gt;查看演示。</target>
        </trans-unit>
        <trans-unit id="19f3528c6d690ada198857c36184fef7782bef63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; Asserts that we are at the start.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 断言我们是开始。</target>
        </trans-unit>
        <trans-unit id="ca6ec5ae2a05e42e32bda5e3ea41a1c74bef7b3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;the beginning of the string,
&lt;code&gt;(&lt;/code&gt; group and capture to \1 (0 or more times (matching the most amount possible)),</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 字符串的开头， &lt;code&gt;(&lt;/code&gt; 将和分组并捕获到\ 1（0次或多次（匹配尽可能多的次数））），</target>
        </trans-unit>
        <trans-unit id="88ef62a0b91eaca8ee49fdab3c971717fd8464d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hede&lt;/code&gt; Matches the string &lt;code&gt;hede&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hede&lt;/code&gt; 匹配字符串 &lt;code&gt;hede&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1a65ea189e42cc8455fe0afc293a1e00cd3f479" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hede&lt;/code&gt; your string,</source>
          <target state="translated">&lt;code&gt;hede&lt;/code&gt; 你的弦，</target>
        </trans-unit>
        <trans-unit id="d003b960bdb077c1dfe6beb8ce4ca5d1176468dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(where the &lt;code&gt;/.../&lt;/code&gt; are the regex delimiters, i.e., not part of the pattern)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（其中 &lt;code&gt;/.../&lt;/code&gt; 是正则表达式分隔符，即，不是模式的一部分）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f717ceaec1723443831abf050e1226ab1d95364" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If&lt;/em&gt; you're just using it for grep, you can use &lt;code&gt;grep -v hede&lt;/code&gt; to get all lines which do not contain hede.</source>
          <target state="translated">&lt;em&gt;如果&lt;/em&gt;仅将其用于grep，则可以使用 &lt;code&gt;grep -v hede&lt;/code&gt; 获取不包含hede的所有行。</target>
        </trans-unit>
        <trans-unit id="201b5844b8586d0c78336f51ab67e7879a440e2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Textpad&lt;/code&gt;&lt;/strong&gt; supports some Regex, but does not support lookahead or lookbehind, so it takes a few steps.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Textpad&lt;/code&gt; &lt;/strong&gt;支持某些Regex，但不支持向前或向后查找，因此需要执行一些步骤。</target>
        </trans-unit>
        <trans-unit id="c332061cf4bd899460b0a4c0a7eaa14bdb27b163" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Answer:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4780b347f8b966f53592b8d6b23f2c7b9836e63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Details:&lt;/strong&gt; The ^ anchor ensures the regex engine doesn't retry the match at every location in the string, which would match every string.</source>
          <target state="translated">&lt;strong&gt;详细信息：&lt;/strong&gt; ^锚确保正则表达式引擎不会在字符串的每个位置（将匹配每个字符串）重试匹配项。</target>
        </trans-unit>
        <trans-unit id="33a872627b08a5f899edf01305ae93d8a50b8d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Execution of the parts:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;零件执行：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9108ede24ec6135336892fdeecab45ae62e7a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Explanation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7844df429e40743092ec192901b82594402fa14d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hey why you added .* instead of .+ ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;嘿，为什么要添加。*而不是。+？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3f0d81e6aa9f7ffd4a855a16e0040cc0551378b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PART 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;第1部分&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e8addc8bc7252fbc0e0c5e9141350f92b5f32c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PART 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;第2部分&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73254be12eadf36210870b716538368a2fedd571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Through PCRE verb &lt;code&gt;(*SKIP)(*F)&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通过PCRE动词 &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6b4aedb6aa5c2789c02d933c0a26fd6986b225b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; I have recently found Kendall Hopkins' excellent &lt;a href=&quot;https://github.com/KendallHopkins/FormalTheory&quot;&gt;FormalTheory&lt;/a&gt; library, written in PHP, which provides a functionality similar to Grail. Using it, and a simplifier written by myself, I've been able to write an online generator of negative regular expressions given an input phrase (only alphanumeric and space characters currently supported): &lt;a href=&quot;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&quot;&gt;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;我最近发现Kendall Hopkins的出色的&lt;a href=&quot;https://github.com/KendallHopkins/FormalTheory&quot;&gt;FormalTheory&lt;/a&gt;库是用PHP编写的，它提供了与Grail类似的功能。 使用它以及我自己编写的一个简化程序，我已经能够编写一个带有给定输入短语（当前仅支持字母数字和空格字符）的否定正则表达式的在线生成器： &lt;a href=&quot;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&quot;&gt;http&lt;/a&gt; : //www.formauri.es/personal/ pgimeno / misc / non-match-regex /</target>
        </trans-unit>
        <trans-unit id="adb30139018c264605cc9fc4ba28906a625cb041" translate="yes" xml:space="preserve">
          <source>A more complicated example: match all lines that start with &lt;code&gt;a&lt;/code&gt; and end with &lt;code&gt;z&lt;/code&gt;, but do not contain the substring &lt;code&gt;hede&lt;/code&gt;:</source>
          <target state="translated">一个更复杂的示例：匹配以 &lt;code&gt;a&lt;/code&gt; 开头和以 &lt;code&gt;z&lt;/code&gt; 结尾但不包含子字符串 &lt;code&gt;hede&lt;/code&gt; 的所有行：</target>
        </trans-unit>
        <trans-unit id="5a6ebacdd544ad2aebe976aa12b05b25bcb11e5b" translate="yes" xml:space="preserve">
          <source>A simpler solution is to use the not operator &lt;strong&gt;!&lt;/strong&gt;</source>
          <target state="translated">一个更简单的解决方案是使用not运算符&lt;strong&gt;！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd0a50c6415821fc8508d785e47d96d51a7df1f3" translate="yes" xml:space="preserve">
          <source>A string is just a list of &lt;code&gt;n&lt;/code&gt; characters. Before, and after each character, there's an empty string. So a list of &lt;code&gt;n&lt;/code&gt; characters will have &lt;code&gt;n+1&lt;/code&gt; empty strings. Consider the string &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt;:</source>
          <target state="translated">字符串只是 &lt;code&gt;n&lt;/code&gt; 个字符的列表。 每个字符之前和之后都有一个空字符串。 因此， &lt;code&gt;n&lt;/code&gt; 个字符的列表将具有 &lt;code&gt;n+1&lt;/code&gt; 个空字符串。 考虑字符串 &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="99646ae275e2441f59e1131f109b01e70dc81648" translate="yes" xml:space="preserve">
          <source>Accurate and more efficient than the other answers. It implements Friedl's &lt;em&gt;&quot;unrolling-the-loop&quot;&lt;/em&gt; efficiency technique and requires much less backtracking.</source>
          <target state="translated">比其他答案更准确，更高效。 它实现了Friedl的&lt;em&gt;&amp;ldquo;展开循环&amp;rdquo;&lt;/em&gt;效率技术，并且所需的回溯更少。</target>
        </trans-unit>
        <trans-unit id="3cac49dcc87a01e093615798c54dde978759b6c5" translate="yes" xml:space="preserve">
          <source>Aforementioned &lt;code&gt;(?:(?!hede).)*&lt;/code&gt; is great because it can be anchored.</source>
          <target state="translated">前面提到的 &lt;code&gt;(?:(?!hede).)*&lt;/code&gt; 很棒，因为它可以锚定。</target>
        </trans-unit>
        <trans-unit id="5b055b615dfbba6017949fb1b34a623d48637083" translate="yes" xml:space="preserve">
          <source>Also, please check out &lt;a href=&quot;https://github.com/amobiz/regexgen.js&quot;&gt;RegexGen.js&lt;/a&gt;, a JavaScript Regular Expression Generator that helps to construct complex regular expressions. With RegexGen.js, you can construct the regex in a more readable way:</source>
          <target state="translated">另外，请查看&lt;a href=&quot;https://github.com/amobiz/regexgen.js&quot;&gt;RegexGen.js&lt;/a&gt; ，这是一个JavaScript正则表达式生成器，可帮助构造复杂的正则表达式。 使用RegexGen.js，可以以更易读的方式构造正则表达式：</target>
        </trans-unit>
        <trans-unit id="583b84d757cb6a3e09c59142f1d4214fcaef0cf4" translate="yes" xml:space="preserve">
          <source>An, in my opinon, more readable variant of the top answer:</source>
          <target state="translated">一个,在我看来,上面的答案更易读的变体。</target>
        </trans-unit>
        <trans-unit id="4a4878a06e9361751e0c8c9f154eb93373a2d656" translate="yes" xml:space="preserve">
          <source>And if you need to match line break chars as well, use the &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;DOT-ALL modifier&lt;/a&gt; (the trailing &lt;code&gt;s&lt;/code&gt; in the following pattern):</source>
          <target state="translated">如果还需要匹配换行符，请使用&lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;DOT-ALL修饰符&lt;/a&gt; （以下模式中的尾随）：</target>
        </trans-unit>
        <trans-unit id="815196bdcfbffb0484620f8f7ff2d786b9c04d25" translate="yes" xml:space="preserve">
          <source>Another option is that to add a positive look-ahead and check if &lt;code&gt;hehe&lt;/code&gt; is anywhere in the input line, then we would negate that, with an expression similar to:</source>
          <target state="translated">另一个选择是添加一个正向的前瞻并检查 &lt;code&gt;hehe&lt;/code&gt; 是否在输入行中的任何地方，然后我们将其取反，其表达式类似于：</target>
        </trans-unit>
        <trans-unit id="90315245d641776926e97cda6abf2b5d2a47c6aa" translate="yes" xml:space="preserve">
          <source>As you can see, the input &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; will fail because on &lt;code&gt;e3&lt;/code&gt;, the regex &lt;code&gt;(?!hede)&lt;/code&gt; fails (there &lt;em&gt;is&lt;/em&gt;&lt;code&gt;&quot;hede&quot;&lt;/code&gt; up ahead!).</source>
          <target state="translated">如您所见，输入 &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; 将失败，因为在 &lt;code&gt;e3&lt;/code&gt; 上 ，正则表达式 &lt;code&gt;(?!hede)&lt;/code&gt; 失败（前面有 &lt;code&gt;&quot;hede&quot;&lt;/code&gt; ！）。</target>
        </trans-unit>
        <trans-unit id="14f0d43928a101b17017ac03b48125ba0258064c" translate="yes" xml:space="preserve">
          <source>Basically, &quot;match at the beginning of the line if and only if it does not have 'hede' in it&quot; - so the requirement translated almost directly into regex.</source>
          <target state="translated">基本上,&quot;如果并且只有当它没有'hede'的时候,才会在行首匹配&quot;--所以这个要求几乎直接翻译成了regex。</target>
        </trans-unit>
        <trans-unit id="b76db96cf2a32f41f46b8568c9c2f6995d10c7a9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.*&lt;/code&gt; would match a blank line but &lt;code&gt;.+&lt;/code&gt; won't match a blank. We want to match all the lines except &lt;code&gt;hede&lt;/code&gt; , there may be a possibility of blank lines also in the input . so you must use &lt;code&gt;.*&lt;/code&gt; instead of &lt;code&gt;.+&lt;/code&gt; . &lt;code&gt;.+&lt;/code&gt; would repeat the previous character one or more times. See &lt;code&gt;.*&lt;/code&gt; matches a blank line &lt;a href=&quot;http://regex101.com/r/kR0tO2/5&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">因为 &lt;code&gt;.*&lt;/code&gt; 将匹配空白行，而 &lt;code&gt;.+&lt;/code&gt; 将不匹配空白。 我们希望匹配除 &lt;code&gt;hede&lt;/code&gt; 以外的所有行，输入中可能还会有空白行。 因此您必须使用 &lt;code&gt;.*&lt;/code&gt; 而不是 &lt;code&gt;.+&lt;/code&gt; 。 &lt;code&gt;.+&lt;/code&gt; 将重复前一个字符一次或多次。 请参阅 &lt;code&gt;.*&lt;/code&gt; &lt;a href=&quot;http://regex101.com/r/kR0tO2/5&quot;&gt;在此处&lt;/a&gt;匹配空白行。</target>
        </trans-unit>
        <trans-unit id="e6f977a9521045923d16f98954c616fecb8c843e" translate="yes" xml:space="preserve">
          <source>Benchmark Text:</source>
          <target state="translated">基准文本:</target>
        </trans-unit>
        <trans-unit id="4f46ac72b3634f96c6860b1ed26d9d4cd71d21aa" translate="yes" xml:space="preserve">
          <source>Benchmarks</source>
          <target state="translated">Benchmarks</target>
        </trans-unit>
        <trans-unit id="b3d97f68b4c000dbfe8c7d755739582257de96d6" translate="yes" xml:space="preserve">
          <source>But the following would suffice in this case:</source>
          <target state="translated">但在这种情况下,以下几点就足够了:</target>
        </trans-unit>
        <trans-unit id="9c556257951e2f974fa9f074f2d437367d7b7de5" translate="yes" xml:space="preserve">
          <source>But the overall most readable and performance-wise fastest solution seems to be 05 using a conditional statement
or 04 with the possesive quantifier. I think the Perl solutions should be even faster and more easily readable.</source>
          <target state="translated">但总体来说,最易读、性能最快的解决方案似乎是使用条件语句的05或使用占有式量化器的04。我觉得Perl的解决方案应该会更快,更容易读懂。</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="038bc41a7c6c6423fba68ab38e1243e0673eb5b1" translate="yes" xml:space="preserve">
          <source>DEMO</source>
          <target state="translated">DEMO</target>
        </trans-unit>
        <trans-unit id="0b308b0064ee9df9865833a93aaf9d02316a25a9" translate="yes" xml:space="preserve">
          <source>Demo in Ruby:</source>
          <target state="translated">在Ruby中进行演示。</target>
        </trans-unit>
        <trans-unit id="2668fed25786577ef5330fbb43aa5160b5fce977" translate="yes" xml:space="preserve">
          <source>Desired output:</source>
          <target state="translated">希望的产出:</target>
        </trans-unit>
        <trans-unit id="22ed035c38e99c0a0525f1aa14558f382586a7e4" translate="yes" xml:space="preserve">
          <source>Do not use:</source>
          <target state="translated">不要使用。</target>
        </trans-unit>
        <trans-unit id="8248c9f017b2a661d23671bd60ce72132eb021cd" translate="yes" xml:space="preserve">
          <source>ETA Oh, rereading the question, &lt;code&gt;grep -v&lt;/code&gt; is probably what you meant by &quot;tools options&quot;.</source>
          <target state="translated">ETA哦，重新阅读一下问题， &lt;code&gt;grep -v&lt;/code&gt; 可能就是您所说的&amp;ldquo;工具选项&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="38d08890b5b368e55863bf943b6b9078a77b395b" translate="yes" xml:space="preserve">
          <source>FWIW, since regular languages (aka rational languages) are closed under complementation, it's always possible to find a regular expression (aka rational expression) that negates another expression. But not many tools implement this.</source>
          <target state="translated">FWIW,因为正则语言(又名有理语言)在互补下是封闭的,所以总是可以找到一个否定另一个表达式的正则表达式(又名有理表达式)。但没有多少工具能实现这一点。</target>
        </trans-unit>
        <trans-unit id="94a4158640ead0903e4198248cdd279ee4bf592b" translate="yes" xml:space="preserve">
          <source>Finally, as everyone has noted, if your regular expression engine supports negative lookahead, that simplifies the task a lot. For example, with GNU grep:</source>
          <target state="translated">最后,正如大家所注意到的,如果你的正则表达式引擎支持负的 lookahead,那将会简化很多任务。例如,用GNU grep.GREP:</target>
        </trans-unit>
        <trans-unit id="e7840fc67eb63c0fc62b3bb9275d4ae78f58cc36" translate="yes" xml:space="preserve">
          <source>First, it tries to find &quot;hede&quot; somewhere in the line. If successful, at this point, &lt;code&gt;(*COMMIT)&lt;/code&gt; tells the engine to, not only not backtrack in the event of a failure, but also not to attempt any further matching in that case. Then, we try to match something that cannot possibly match (in this case, &lt;code&gt;^&lt;/code&gt;).</source>
          <target state="translated">首先，它试图在行中的某个地方找到&amp;ldquo; hede&amp;rdquo;。 如果成功，这时 &lt;code&gt;(*COMMIT)&lt;/code&gt; 告诉引擎，不仅在发生故障时不回溯，而且在这种情况下也不尝试任何进一步的匹配。 然后，我们尝试匹配可能不匹配的内容（在这种情况下为 &lt;code&gt;^&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="66fd11bbda1e7cb077ac7a5170f9d22cd9e79e06" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;hede&lt;/code&gt; it outputs:</source>
          <target state="translated">对于 &lt;code&gt;hede&lt;/code&gt; ,它输出：</target>
        </trans-unit>
        <trans-unit id="c7cb8f31d0f67cada2b023061ce292ebd71188db" translate="yes" xml:space="preserve">
          <source>For example, a string:</source>
          <target state="translated">例如,一个字符串。</target>
        </trans-unit>
        <trans-unit id="44957a991234be8e9df9fa75f2eb494f5b1a8eed" translate="yes" xml:space="preserve">
          <source>For me, I sometimes need to do this while editing a file using &lt;strong&gt;&lt;code&gt;Textpad&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">对我来说，有时我需要在使用&lt;strong&gt; &lt;code&gt;Textpad&lt;/code&gt; &lt;/strong&gt;编辑文件时执行此操作。</target>
        </trans-unit>
        <trans-unit id="ce940869d506a887a010eb773ba2c6af358bf25a" translate="yes" xml:space="preserve">
          <source>For more information about lookahead, please check out the great article: &lt;a href=&quot;http://www.rexegg.com/regex-lookarounds.html&quot;&gt;Mastering Lookahead and Lookbehind&lt;/a&gt;.</source>
          <target state="translated">有关lookahead的更多信息，请查看出色的文章： &lt;a href=&quot;http://www.rexegg.com/regex-lookarounds.html&quot;&gt;Mastering Lookahead和Lookbehind&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c25f2278c3b324ffc728c690b8635beda0a6a6d1" translate="yes" xml:space="preserve">
          <source>For those interested in the details, the technique employed is to convert the regular expression that matches the word into a finite automaton, then invert the automaton by changing every acceptance state to non-acceptance and vice versa, and then converting the resulting FA back to a regular expression.</source>
          <target state="translated">对于那些对细节感兴趣的人来说,所采用的技术是将与该词相匹配的正则表达式转换为有限自动机,然后通过将每一个接受状态转换为非接受状态,反之亦然,再将得到的FA转换回正则表达式。</target>
        </trans-unit>
        <trans-unit id="e3b647855c42983ecd846d1757dfd4687da23b1b" translate="yes" xml:space="preserve">
          <source>Given a string: 
&lt;code&gt;
&amp;lt;span class=&quot;good&quot;&amp;gt;bar&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;bad&quot;&amp;gt;foo&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ugly&quot;&amp;gt;baz&amp;lt;/span&amp;gt;
&lt;/code&gt;</source>
          <target state="translated">给定一个字符串： &lt;code&gt; &amp;lt;span class=&quot;good&quot;&amp;gt;bar&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;bad&quot;&amp;gt;foo&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ugly&quot;&amp;gt;baz&amp;lt;/span&amp;gt; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a41b37dc9eb2f2ea1a88a659b705994f14fc76f" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;http://jsfiddle.net/pvJL5/3/&quot;&gt;demo code&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;http://jsfiddle.net/pvJL5/3/&quot;&gt;演示代码&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="440b25c25e75becc55b449c73a3491fe97d861e4" translate="yes" xml:space="preserve">
          <source>Here is the improved regex:</source>
          <target state="translated">下面是改进后的regex。</target>
        </trans-unit>
        <trans-unit id="9a9a8952516d81a0b39d9122ade38c17c2ed9060" translate="yes" xml:space="preserve">
          <source>Here's &lt;a href=&quot;http://www.perlmonks.org/?node_id=588315#588368&quot;&gt;a good explanation&lt;/a&gt; of why it's not easy to negate an arbitrary regex. I have to agree with the other answers, though: if this is anything other than a hypothetical question, then a regex is not the right choice here.</source>
          <target state="translated">这&lt;a href=&quot;http://www.perlmonks.org/?node_id=588315#588368&quot;&gt;很好地解释&lt;/a&gt;了为什么对任意正则表达式求反并不容易。 不过，我必须同意其他答案：如果这不是一个假设的问题，那么正则表达式不是这里的正确选择。</target>
        </trans-unit>
        <trans-unit id="ddaef8476b8e3acafac4825d7b8f1ac998e71f92" translate="yes" xml:space="preserve">
          <source>Here's a method that I haven't seen used before:</source>
          <target state="translated">这里有一个方法,是我以前没有见过用过的。</target>
        </trans-unit>
        <trans-unit id="1dff1040ef948d2545fd38f5ddc5048a75c98520" translate="yes" xml:space="preserve">
          <source>Here's a script to test it (note it generates a file &lt;code&gt;testinput.txt&lt;/code&gt; in the current directory):</source>
          <target state="translated">这是一个测试它的脚本（注意它 &lt;code&gt;testinput.txt&lt;/code&gt; 在当前目录中生成一个文件testinput.txt ）：</target>
        </trans-unit>
        <trans-unit id="5f28c2737b2f0e2188d8328f330fac2b15157b53" translate="yes" xml:space="preserve">
          <source>Here's how I'd do it:</source>
          <target state="translated">我是这样做的。</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">它是如何工作的</target>
        </trans-unit>
        <trans-unit id="af4b2da81f792f5da8904c48f25a28f04b5d9a3c" translate="yes" xml:space="preserve">
          <source>How to use PCRE's backtracking control verbs to match a line not containing a word</source>
          <target state="translated">如何使用PCRE的回溯控制动词来匹配不含单词的行文中的句子</target>
        </trans-unit>
        <trans-unit id="358f19a96883463715eb0b8d693998ffb417eb35" translate="yes" xml:space="preserve">
          <source>However, GNU &lt;code&gt;grep&lt;/code&gt; implements extensions that allow it. In particular, &lt;code&gt;\|&lt;/code&gt; is the alternation operator in GNU's implementation of BREs, and &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; are the parentheses. If your regular expression engine supports alternation, negative bracket expressions, parentheses and the Kleene star, and is able to anchor to the beginning and end of the string, that's all you need for this approach. Note however that negative sets &lt;code&gt;[^ ... ]&lt;/code&gt; are very convenient in addition to those, because otherwise, you need to replace them with an expression of the form &lt;code&gt;(a|b|c| ... )&lt;/code&gt; that lists every character that is not in the set, which is extremely tedious and overly long, even more so if the whole character set is Unicode.</source>
          <target state="translated">但是，GNU &lt;code&gt;grep&lt;/code&gt; 实现了允许它的扩展。 特别是 &lt;code&gt;\|&lt;/code&gt; 是GNU BRE实现中的交替运算符， &lt;code&gt;\(&lt;/code&gt; 和 &lt;code&gt;\)&lt;/code&gt; 是括号。 如果您的正则表达式引擎支持交替，负括号表达式，括号和Kleene星号，并且能够锚定到字符串的开头和结尾，那么这就是您所需要的。 但是请注意，除负数集 &lt;code&gt;[^ ... ]&lt;/code&gt; 之外，它们还非常方便，因为否则，您需要用 &lt;code&gt;(a|b|c| ... )&lt;/code&gt; 形式的表达式替换它们，该表达式列出每个不在集合中，这非常繁琐且过长，如果整个字符集都是Unicode，则更是如此。</target>
        </trans-unit>
        <trans-unit id="87fce9ed530df5073b27f7dc4a7cb8a5bddaceaa" translate="yes" xml:space="preserve">
          <source>However, with Bart Kiers' answer, the lookahead part will test 1 to 4 characters ahead while matching any single character. We can avoid this and let the lookahead part check out the whole text, ensure there is no 'hede', and then the normal part (.*) can eat the whole text all at one time.</source>
          <target state="translated">但是,用Bart Kiers的答案,lookahead部分会在匹配任何一个字符的同时,对前面的1到4个字符进行测试。我们可以避免这种情况,让 lookahead 部分检查出整个文本,确保没有 &quot;hede&quot;,然后正常部分(.*)可以一次性吃掉整个文本。</target>
        </trans-unit>
        <trans-unit id="358d0378b2ab94ec8627f21e6e089dabbbed421a" translate="yes" xml:space="preserve">
          <source>I believe the designers of RegEx anticipated the use of not operators.</source>
          <target state="translated">我相信RegEx的设计者们已经预料到了非运营商的使用。</target>
        </trans-unit>
        <trans-unit id="e798d46c6cfecdfa243d565a95292a06448c5bd4" translate="yes" xml:space="preserve">
          <source>I decided to evaluate some of the presented Options and compare their performance, as well as use some new Features.
Benchmarking on .NET Regex Engine: &lt;a href=&quot;http://regexhero.net/tester/&quot;&gt;http://regexhero.net/tester/&lt;/a&gt;</source>
          <target state="translated">我决定评估一些介绍的选件并比较它们的性能，并使用一些新功能。 .NET Regex Engine上的基准测试： &lt;a href=&quot;http://regexhero.net/tester/&quot;&gt;http&lt;/a&gt; : //regexhero.net/tester/</target>
        </trans-unit>
        <trans-unit id="fa66090b531a3943e8315caeac17d53e7fa5772a" translate="yes" xml:space="preserve">
          <source>I know it's possible to match a word and then reverse the matches using other tools (e.g. &lt;code&gt;grep -v&lt;/code&gt;). However, is it possible to match lines that do not contain a specific word, e.g. &lt;code&gt;hede&lt;/code&gt;, using a regular expression?</source>
          <target state="translated">我知道可以匹配一个单词，然后使用其他工具（例如 &lt;code&gt;grep -v&lt;/code&gt; ）反转匹配。 但是，是否可以使用正则表达式匹配不包含特定单词（例如 &lt;code&gt;hede&lt;/code&gt; ）的行？</target>
        </trans-unit>
        <trans-unit id="4065441f68e9c6020ab5a572b3efff079b3598f2" translate="yes" xml:space="preserve">
          <source>I tried to test most proposed solutions, some Optimizations are possible for certain words.
For Example if the First two letters of the search string are not the Same, answer 03 can be expanded to
&lt;code&gt;^(?&amp;gt;[^R]+|R+(?!egex Hero))*$&lt;/code&gt; resulting in a small performance gain.</source>
          <target state="translated">我尝试测试大多数建议的解决方案，某些单词可能有一些优化。 例如，如果搜索字符串的前两个字母不相同，则答案03可以扩展为 &lt;code&gt;^(?&amp;gt;[^R]+|R+(?!egex Hero))*$&lt;/code&gt; 从而获得较小的性能提升。</target>
        </trans-unit>
        <trans-unit id="55152e4cb8b05e2398aff1b805ef864a7498c807" translate="yes" xml:space="preserve">
          <source>I want to match &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; tags which do not contain the substring &quot;bad&quot;.</source>
          <target state="translated">我想匹配不包含子字符串&amp;ldquo;坏&amp;rdquo;的 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 标签。</target>
        </trans-unit>
        <trans-unit id="348fdb226d122d58a879e94920244cb659c2ff80" translate="yes" xml:space="preserve">
          <source>If I am looking to &lt;b&gt;&lt;i&gt;Do Something Else&lt;/i&gt;&lt;/b&gt; to only lines that &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, I would do it like this:</source>
          <target state="translated">如果我只想对&lt;b&gt;&lt;i&gt;不&lt;/i&gt;&lt;/b&gt;包含字符串&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; 的&lt;/strong&gt;行&lt;b&gt;&lt;i&gt;执行其他&lt;/i&gt;&lt;/b&gt;操作，则可以这样做：</target>
        </trans-unit>
        <trans-unit id="38622a9faba8a5ee89d14dd8753c178ec7f57e80" translate="yes" xml:space="preserve">
          <source>If I am looking to retain all lines that &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, I would do it like this:</source>
          <target state="translated">如果我要保留所有&lt;b&gt;&lt;i&gt;不&lt;/i&gt;&lt;/b&gt;包含字符串&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; 的行&lt;/strong&gt; ，则应这样做：</target>
        </trans-unit>
        <trans-unit id="38763d6f5618ba3862a9ce1d1f4a6b9b7ba82b1e" translate="yes" xml:space="preserve">
          <source>If a line does not contain &quot;hede&quot; then the second alternative, an empty subpattern, successfully matches the subject string.</source>
          <target state="translated">如果一行中不包含 &quot;hede&quot;,那么第二种选择,即空子模式,成功匹配了主题字符串。</target>
        </trans-unit>
        <trans-unit id="d412617b77836527f5a7b6be35bc1f03d6769b94" translate="yes" xml:space="preserve">
          <source>If the DOT-ALL modifier is not available, you can mimic the same behavior with the character class &lt;code&gt;[\s\S]&lt;/code&gt;:</source>
          <target state="translated">如果DOT-ALL修饰符不可用，则可以使用字符类 &lt;code&gt;[\s\S]&lt;/code&gt; 模仿相同的行为：</target>
        </trans-unit>
        <trans-unit id="92f26649c4516946fcb1add8c4a8263d3b34b2bf" translate="yes" xml:space="preserve">
          <source>If you want the regex test to &lt;strong&gt;only&lt;/strong&gt; fail if the &lt;em&gt;entire string&lt;/em&gt; matches, the following will work:</source>
          <target state="translated">如果您只想让正则表达式测试&lt;strong&gt;仅&lt;/strong&gt;在&lt;em&gt;整个字符串&lt;/em&gt;匹配&lt;strong&gt;时才&lt;/strong&gt;失败，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="729b36879bb4e3767c9a57246277a86e711573a2" translate="yes" xml:space="preserve">
          <source>If you want to match a character to negate a word similar to negate character class:</source>
          <target state="translated">如果你想匹配一个否定的字,可以匹配一个类似于否定字类的字。</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="translated">在Python中。</target>
        </trans-unit>
        <trans-unit id="f1be7176418bc2ec420699af8dfcaafdad7421f0" translate="yes" xml:space="preserve">
          <source>In my system it prints:</source>
          <target state="translated">在我的系统里,它可以打印。</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">Input:</target>
        </trans-unit>
        <trans-unit id="70b4e36c7616180b6c9127dc59657f047a94fe8b" translate="yes" xml:space="preserve">
          <source>It may be more maintainable to two regexes in your code, one to do the first match, and then if it matches run the second regex to check for outlier cases you wish to block for example &lt;code&gt;^.*(hede).*&lt;/code&gt; then have appropriate logic in your code.</source>
          <target state="translated">对于您的代码中的两个正则表达式而言，它可能更易于维护，一个可以进行第一个匹配，然后如果匹配则运行第二个正则表达式来检查您希望阻止的异常情况，例如 &lt;code&gt;^.*(hede).*&lt;/code&gt; 然后进行适当处理代码中的逻辑。</target>
        </trans-unit>
        <trans-unit id="619838c3b0a02408fab5aaa30829a7d4c40bef84" translate="yes" xml:space="preserve">
          <source>Let us consider the above regex by splitting it into two parts.</source>
          <target state="translated">让我们通过将上述的regex分成两部分来考虑。</target>
        </trans-unit>
        <trans-unit id="5395b8e8626e7f4b1fd55874dc85b6775aa31200" translate="yes" xml:space="preserve">
          <source>Maybe you'll find this on Google while trying to write a regex that is able to match segments of a line (as opposed to entire lines) which do &lt;strong&gt;not&lt;/strong&gt; contain a substring. Tooke me a while to figure out, so I'll share:</source>
          <target state="translated">也许您会在尝试编写一个正则表达式时在Google上找到此正则表达式，该正则表达式能够匹配&lt;strong&gt;不&lt;/strong&gt;包含子字符串的行段（而不是整行）。 花了一段时间让我弄清楚，所以我将分享：</target>
        </trans-unit>
        <trans-unit id="f65015b6743116c0d591a6ecf9d76f8aaa121c4e" translate="yes" xml:space="preserve">
          <source>Not regex, but I've found it logical and useful to use serial greps with pipe to eliminate noise.</source>
          <target state="translated">虽然不是regex,但我发现用serial greps搭配管道来消除噪音是很合理也很有用的。</target>
        </trans-unit>
        <trans-unit id="081045e6b01eadb48d20a103dbb36df17d72fe50" translate="yes" xml:space="preserve">
          <source>Note that the solution to &lt;strong&gt;does not &lt;em&gt;start with&lt;/em&gt; &amp;ldquo;hede&amp;rdquo;&lt;/strong&gt;:</source>
          <target state="translated">请注意，解决方案&lt;strong&gt;并非&lt;em&gt;以&lt;/em&gt; &amp;ldquo; hede&amp;rdquo; &lt;em&gt;开头&lt;/em&gt;&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="26b82927c1805e4c7847c9a3577899e346640e6a" translate="yes" xml:space="preserve">
          <source>Note the (*?) lazy quantifier in the negative lookahead part is optional, you can use (*) greedy quantifier instead, depending on your data: if 'hede' does present and in the beginning half of the text, the lazy quantifier can be faster; otherwise, the greedy quantifier be faster. However if 'hede' does not present, both would be equal slow.</source>
          <target state="translated">请注意,在负的 lookahead 部分中的 (*?)lazy quantifier 是可选的,你可以使用 (*)greedy quantifier 来代替,这取决于你的数据:如果 'hede' 确实存在,并且是在文本的开头半部分,lazy quantifier 可以更快;否则,greedy quantifier 会更快。但是,如果'hede'没有出现,那么两者都是慢的。</target>
        </trans-unit>
        <trans-unit id="0e9a29d02e68bcb3679deea8d109eb179570c686" translate="yes" xml:space="preserve">
          <source>Notice &lt;code&gt;&quot;(?!bbb).&quot;&lt;/code&gt; is neither lookbehind nor lookahead, it's lookcurrent, for example:</source>
          <target state="translated">注意 &lt;code&gt;&quot;(?!bbb).&quot;&lt;/code&gt; 既不落后也不超前，它是当前的，例如：</target>
        </trans-unit>
        <trans-unit id="30d37c9788dcecf1fad3016f170ca9201ffa1d65" translate="yes" xml:space="preserve">
          <source>Notice that there are two sets (layers) of parentheses:</source>
          <target state="translated">注意,有两组(层)的括号。</target>
        </trans-unit>
        <trans-unit id="a86f480c07344c42ab876520a48514924063ed70" translate="yes" xml:space="preserve">
          <source>Now you have the original text with all lines containing the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt; removed.</source>
          <target state="translated">现在，您已删除了包含字符串&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; 的&lt;/strong&gt;所有行的原始文本。</target>
        </trans-unit>
        <trans-unit id="dcc9367c99afe75c60c7432ea228375c0eed703b" translate="yes" xml:space="preserve">
          <source>OK, I admit this is not really an answer to the posted question posted and it may also use slightly more processing than a single regex. But for developers who came here looking for a fast emergency fix for an outlier case then this solution should not be overlooked.</source>
          <target state="translated">好吧,我承认这并不是真正的答案,而且它可能也比单一的regex的处理量要多一点。但是对于那些来这里寻找快速紧急解决离群情况的开发者来说,这个解决方案是不应该被忽视的。</target>
        </trans-unit>
        <trans-unit id="b217bc7b14d3698eeeed95b262a2782958f75640" translate="yes" xml:space="preserve">
          <source>Of course, if you're checking for &lt;em&gt;exact&lt;/em&gt; equality, a better general solution in this case is to check for string equality, i.e.</source>
          <target state="translated">当然，如果要检查&lt;em&gt;完全&lt;/em&gt;相等，则在这种情况下更好的常规解决方案是检查字符串是否相等，即</target>
        </trans-unit>
        <trans-unit id="92e4e642b4116921153d765748bceeb2a5d28218" translate="yes" xml:space="preserve">
          <source>Of course, it's possible to have multiple failure requirements:</source>
          <target state="translated">当然,也有可能出现多个故障要求。</target>
        </trans-unit>
        <trans-unit id="1676b6642119a6e78e273b06ef382dc642a9b8c8" translate="yes" xml:space="preserve">
          <source>Old answer:</source>
          <target state="translated">旧的答案。</target>
        </trans-unit>
        <trans-unit id="c25c62a5bc188579d5d23849efc8f31cf2a447d1" translate="yes" xml:space="preserve">
          <source>Part after the &lt;code&gt;|&lt;/code&gt; symbol. Part &lt;strong&gt;should be matched&lt;/strong&gt;.</source>
          <target state="translated">部分 &lt;code&gt;|&lt;/code&gt; 符号。 零件&lt;strong&gt;应匹配&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="73b61b7b35a3691f94481b52b729efe8e43baadb" translate="yes" xml:space="preserve">
          <source>Part before the &lt;code&gt;|&lt;/code&gt; symbol. Part &lt;strong&gt;shouldn't be matched&lt;/strong&gt;.</source>
          <target state="translated">前部分 &lt;code&gt;|&lt;/code&gt; 符号。 部分&lt;strong&gt;不应该匹配&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7ae9fea9116fab8d5be9f40e43c9fe24123c8e9" translate="yes" xml:space="preserve">
          <source>RegEx Circuit</source>
          <target state="translated">RegEx电路</target>
        </trans-unit>
        <trans-unit id="41676a1dc090860fb04559a11f57d002c96d15af" translate="yes" xml:space="preserve">
          <source>Regex engine will start its execution from the first part.</source>
          <target state="translated">Regex引擎将从第一部分开始执行。</target>
        </trans-unit>
        <trans-unit id="71546fc265910c3ba4c3a0c33a7cfa6a7c857490" translate="yes" xml:space="preserve">
          <source>Regex negation is not particularly useful on its own but when you also have intersection, things get interesting, since you have a full set of boolean set operations: you can express &quot;the set which matches this, except for things which match that&quot;.</source>
          <target state="translated">Regex否定本身并不是特别有用,但是当你也有交集的时候,事情就变得有趣了,因为你有了一个完整的布尔集操作:你可以表达 &quot;除了匹配这个的东西之外,匹配那个的东西的集&quot;。</target>
        </trans-unit>
        <trans-unit id="19997c21128f333f226b26bb698b36f34117927e" translate="yes" xml:space="preserve">
          <source>Regular Expressions in the meaning of theoretical computer sciences &lt;em&gt;ARE NOT ABLE&lt;/em&gt; do it like this. For them it had to look something like this:</source>
          <target state="translated">理论计算机科学意义上的正则表达式无法做到这一点。 对于他们来说，它看起来必须像这样：</target>
        </trans-unit>
        <trans-unit id="af38a3c1a9ef260f4705cde91de11408ba9cc3b3" translate="yes" xml:space="preserve">
          <source>Regular expression to match a line that doesn't contain a word</source>
          <target state="translated">正则表达式,用于匹配不包含一个词的行。</target>
        </trans-unit>
        <trans-unit id="e9a6ae937eb3ddd638ffc636c1c42607a3fc5a93" translate="yes" xml:space="preserve">
          <source>Results are Iterations per second as the median of 3 runs - &lt;strong&gt;Bigger Number = Better&lt;/strong&gt;</source>
          <target state="translated">结果是每秒迭代数，为3次运行的中位数- &lt;strong&gt;更大的数字=更好&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="2a8fa741fc245177c287037e3934f7b7d34f2900" translate="yes" xml:space="preserve">
          <source>Since .NET doesn't support action Verbs (*FAIL, etc.) I couldn't test the solutions P1 and P2.</source>
          <target state="translated">由于.NET不支持动作动词(*FAIL等),我无法测试P1和P2的解决方案。</target>
        </trans-unit>
        <trans-unit id="6e8ae50092c4781a2d7e2ceca8e2bcb82f39e2eb" translate="yes" xml:space="preserve">
          <source>Since no one else has given a direct answer to the question &lt;em&gt;that was asked&lt;/em&gt;, I'll do it.</source>
          <target state="translated">由于没有其他人可以直接回答所提出的问题，所以我会做的。</target>
        </trans-unit>
        <trans-unit id="a53ab784ceaf12bbfbc9f16efc79e5e24d16d2c3" translate="yes" xml:space="preserve">
          <source>Since the introduction of ruby-2.4.1, we can use the new &lt;a href=&quot;https://github.com/k-takata/Onigmo/issues/82&quot;&gt;Absent Operator&lt;/a&gt; in Ruby&amp;rsquo;s Regular Expressions</source>
          <target state="translated">自从引入ruby-2.4.1以来，我们可以在Ruby的正则表达式中使用新的&lt;a href=&quot;https://github.com/k-takata/Onigmo/issues/82&quot;&gt;Absent运算符&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1692e723845d6b6032f0c8d3b96f35a2c9ce70d7" translate="yes" xml:space="preserve">
          <source>So the line which contains the string &lt;code&gt;hede&lt;/code&gt; would be matched. Once the regex engine sees the following &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; (&lt;em&gt;Note: You could write &lt;code&gt;(*F)&lt;/code&gt; as &lt;code&gt;(*FAIL)&lt;/code&gt;&lt;/em&gt;) verb, it skips and make the match to fail. &lt;code&gt;|&lt;/code&gt; called alteration or logical OR operator added next to the PCRE verb which inturn matches all the boundaries exists between each and every character on all the lines except the line contains the exact string &lt;code&gt;hede&lt;/code&gt;. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/2&quot;&gt;here&lt;/a&gt;. That is, it tries to match the characters from the remaining string. Now the regex in the second part would be executed.</source>
          <target state="translated">因此包含字符串 &lt;code&gt;hede&lt;/code&gt; 的行将被匹配。 一旦正则表达式引擎看到以下 &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; （ &lt;em&gt;注：您可以将 &lt;code&gt;(*F)&lt;/code&gt; 编写为 &lt;code&gt;(*FAIL)&lt;/code&gt; &lt;/em&gt; ）动词，它将跳过并使匹配失败。 &lt;code&gt;|&lt;/code&gt; 在PCRE动词旁边添加的所谓的改变或逻辑OR运算符，它反过来匹配所有行的每个字符之间的所有边界，除了该行包含确切的字符串 &lt;code&gt;hede&lt;/code&gt; 。 在&lt;a href=&quot;http://regex101.com/r/kR0tO2/2&quot;&gt;这里&lt;/a&gt;查看演示。 也就是说，它尝试匹配其余字符串中的字符。 现在，第二部分中的正则表达式将被执行。</target>
        </trans-unit>
        <trans-unit id="b7a42192468575a7e5a39750585ef8b488514333" translate="yes" xml:space="preserve">
          <source>So, in my example, every empty string is first validated to see if there's no &lt;code&gt;&quot;hede&quot;&lt;/code&gt; up ahead, before a character is consumed by the &lt;code&gt;.&lt;/code&gt; (dot). The regex &lt;code&gt;(?!hede).&lt;/code&gt; will do that only once, so it is wrapped in a group, and repeated zero or more times: &lt;code&gt;((?!hede).)*&lt;/code&gt;. Finally, the start- and end-of-input are anchored to make sure the entire input is consumed: &lt;code&gt;^((?!hede).)*$&lt;/code&gt;</source>
          <target state="translated">因此，在我的示例中，首先验证每个空字符串，以查看在字符消耗之前，前面是否没有 &lt;code&gt;&quot;hede&quot;&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; （点）。 正则表达式 &lt;code&gt;(?!hede).&lt;/code&gt; 只会执行一次，因此将它包装在一个组中，并重复零次或多次： &lt;code&gt;((?!hede).)*&lt;/code&gt; 。 最后，锚定输入的开始和结束以确保消耗了整个输入： &lt;code&gt;^((?!hede).)*$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="f117cb601daa3d4275b6f738d374bfc07fdd9f7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.nongnu.org/txr/&quot;&gt;TXR Language&lt;/a&gt; supports regex negation.</source>
          <target state="translated">&lt;a href=&quot;http://www.nongnu.org/txr/&quot;&gt;TXR语言&lt;/a&gt;支持正则表达式否定。</target>
        </trans-unit>
        <trans-unit id="ebcf6058f2929ecc3e3b08aed979b745665af5ef" translate="yes" xml:space="preserve">
          <source>The OP did not specify or &lt;b&gt;&lt;kbd&gt;Tag&lt;/kbd&gt;&lt;/b&gt; the post to indicate the context (programming language, editor, tool) the Regex will be used within.</source>
          <target state="translated">OP未指定或&lt;b&gt;&lt;kbd&gt;标记&lt;/kbd&gt;&lt;/b&gt;帖子以指示正则表达式将在其中使用的上下文（编程语言，编辑器，工具）。</target>
        </trans-unit>
        <trans-unit id="11aa9db6100b5bf50fd1febfe3c053a2d5441f2d" translate="yes" xml:space="preserve">
          <source>The ^ anchor in the beginning is meant to represent the beginning of the line. The grep tool matches each line one at a time, in contexts where you're working with a multiline string, you can use the &quot;m&quot; flag:</source>
          <target state="translated">开头的^锚是为了表示该行的开始。grep工具会逐行匹配,在处理多行字符串的上下文中,可以使用 &quot;m &quot;标志。</target>
        </trans-unit>
        <trans-unit id="098ea33d53cc62129cfb7875bd9edba4f4bec259" translate="yes" xml:space="preserve">
          <source>The answer is that with POSIX &lt;code&gt;grep&lt;/code&gt;, it's impossible to literally satisfy this request:</source>
          <target state="translated">答案是，使用POSIX &lt;code&gt;grep&lt;/code&gt; ，不可能从字面上满足此请求：</target>
        </trans-unit>
        <trans-unit id="cc27072c8e8fa68ee8a4aecd5fdce94bfeb957de" translate="yes" xml:space="preserve">
          <source>The below function will help you get your desired output</source>
          <target state="translated">下面的功能将帮助你获得你所需要的输出。</target>
        </trans-unit>
        <trans-unit id="452667fef7f202d7937567d77ec3043088267fe1" translate="yes" xml:space="preserve">
          <source>The expression is explained on the top right panel of &lt;a href=&quot;https://regex101.com/r/S127jy/1/&quot;&gt;regex101.com&lt;/a&gt;, if you wish to explore/simplify/modify it, and in &lt;a href=&quot;https://regex101.com/r/S127jy/1/debugger&quot;&gt;this link&lt;/a&gt;, you can watch how it would match against some sample inputs, if you like.</source>
          <target state="translated">在&lt;a href=&quot;https://regex101.com/r/S127jy/1/&quot;&gt;regex101.com&lt;/a&gt;右上角的面板上解释了该表达式，如果您希望对其进行探索/简化/修改，并且在&lt;a href=&quot;https://regex101.com/r/S127jy/1/debugger&quot;&gt;此链接中&lt;/a&gt; ，您可以根据需要观看它与某些示例输入的匹配方式。</target>
        </trans-unit>
        <trans-unit id="81d959c36f65aa571d1474a3105362386f4bce31" translate="yes" xml:space="preserve">
          <source>The first 7 lines should not match, since they contain the searched Expression, while the lower 7 lines should match!</source>
          <target state="translated">前7行应该是不匹配的,因为它们包含了被搜索的表达式,而下面的7行应该是匹配的!</target>
        </trans-unit>
        <trans-unit id="30eca3e3a5dee91a29274eb92d118bf760f5f68b" translate="yes" xml:space="preserve">
          <source>The former checks for &amp;ldquo;hede&amp;rdquo; only at the input string&amp;rsquo;s first position, rather than at every position.</source>
          <target state="translated">前者仅在输入字符串的第一个位置而不是每个位置检查&amp;ldquo; hede&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ec7560158d4afaeca7ad767df676f2c3f8316d2b" translate="yes" xml:space="preserve">
          <source>The given answers are perfectly fine, just an academic point:</source>
          <target state="translated">给出的答案是完全没有问题的,只是学术上的一个观点。</target>
        </trans-unit>
        <trans-unit id="2d09bbc95c0bd1eee8d3c6bb5adc11e14f4f00c5" translate="yes" xml:space="preserve">
          <source>The innermost one is for the negative lookahead (it is not a capture group)</source>
          <target state="translated">最内侧的是为负数看头(它不是捕捉组</target>
        </trans-unit>
        <trans-unit id="29b7a8c9eb45daf61b377e68a90e0dacca34eb0c" translate="yes" xml:space="preserve">
          <source>The logic of serial grep's is (not a comment) and (matches dir)</source>
          <target state="translated">串行grep的逻辑是(不是注释)和(匹配dir)。</target>
        </trans-unit>
        <trans-unit id="1a96bded5f6ba78d21a0246672404cc4fdf84614" translate="yes" xml:space="preserve">
          <source>The notion that regex doesn't support inverse matching is not entirely true. You can mimic this behavior by using negative look-arounds:</source>
          <target state="translated">关于regex不支持逆匹配的概念并不完全正确。你可以通过使用逆向匹配来模仿这种行为。</target>
        </trans-unit>
        <trans-unit id="3854f1c652980feef2e8f16cab154d60899f8027" translate="yes" xml:space="preserve">
          <source>The outermost was interpreted by Ruby as capture group but we don't want it to be a capture group, so I added ?: at it's beginning and it is no longer interpreted as a capture group.</source>
          <target state="translated">最外层被Ruby解释为捕获组,但我们不希望它是一个捕获组,所以我在它的开头加上了?</target>
        </trans-unit>
        <trans-unit id="53549eab46883cf85fd1a09e3b5aed26dca85805" translate="yes" xml:space="preserve">
          <source>The reason is that POSIX &lt;code&gt;grep&lt;/code&gt; is only required to work with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003&quot;&gt;Basic Regular Expressions&lt;/a&gt;, which are simply not powerful enough for accomplishing that task (they are not capable of parsing regular languages, because of lack of alternation and parentheses).</source>
          <target state="translated">原因是POSIX &lt;code&gt;grep&lt;/code&gt; 只需要与&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003&quot;&gt;Basic Regular Expressions&lt;/a&gt;一起使用， Basic Regular Expressions根本不足以完成该任务（由于缺少交替和括号，它们无法解析常规语言）。</target>
        </trans-unit>
        <trans-unit id="7ecb97c8fab3f5fb0b327ca5ef4661a1a4cf0f1f" translate="yes" xml:space="preserve">
          <source>The regex above will match any string, or line without a line break, &lt;strong&gt;not&lt;/strong&gt; containing the (sub)string 'hede'. As mentioned, this is not something regex is &quot;good&quot; at (or should do), but still, it &lt;em&gt;is&lt;/em&gt; possible.</source>
          <target state="translated">上面的正则表达式将匹配&lt;strong&gt;不&lt;/strong&gt;包含（子）字符串'hede'的任何字符串或没有换行符的行。 如前所述，这不是正则表达式&amp;ldquo;擅长&amp;rdquo;（或应该做）的事情，但仍有可能。</target>
        </trans-unit>
        <trans-unit id="8bc1736cb0d5560815fe759f45e070ec21870289" translate="yes" xml:space="preserve">
          <source>The regex solution at the top of this answer may be helpful, however, in situations where a positive regex test is required (perhaps by an API).</source>
          <target state="translated">然而,在需要进行阳性的regex测试的情况下(也许是通过API),本答案顶部的regex解决方案可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="18d6c0cc722c7bbc3e65fb8a5074dc1d497a9c6b" translate="yes" xml:space="preserve">
          <source>This method is no more efficient than a negative lookahead, but I figured I'd just throw it on here in case someone finds it nifty and finds a use for it for other, more interesting applications.</source>
          <target state="translated">这个方法不比负值查询更有效,但我想我只是把它放在这里,以防有人发现它很好用,并在其他更有趣的应用中使用。</target>
        </trans-unit>
        <trans-unit id="3886ebe4339f9490f06300de01ba2a2e949b872b" translate="yes" xml:space="preserve">
          <source>This only does a FULL match. Doing it for sub-matches would even be more awkward.</source>
          <target state="translated">这只做了一场完整的比赛。如果是分赛制,那就更尴尬了。</target>
        </trans-unit>
        <trans-unit id="e922e950305ed79d2617ae1c8940572582dfcd3e" translate="yes" xml:space="preserve">
          <source>This simplification is ready to have &quot;AND&quot; clauses added:</source>
          <target state="translated">这种简化是准备增加 &quot;和 &quot;的条款。</target>
        </trans-unit>
        <trans-unit id="31ba508b83d08df1a58027dfb2ff5193636dcc21" translate="yes" xml:space="preserve">
          <source>This would completely skips the line which contains the exact string &lt;code&gt;hede&lt;/code&gt; and matches all the remaining lines.</source>
          <target state="translated">这将完全跳过包含确切字符串 &lt;code&gt;hede&lt;/code&gt; 的行并匹配所有其余行。</target>
        </trans-unit>
        <trans-unit id="bda56a9be7875939dbf47726436cb5a754e198c2" translate="yes" xml:space="preserve">
          <source>Thus, in your case &lt;code&gt;^(?~hede)$&lt;/code&gt; does the job for you</source>
          <target state="translated">因此，在您的情况下 &lt;code&gt;^(?~hede)$&lt;/code&gt; 会为您完成工作</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="e70838bc7b5ac1d8247c350d535a21945717c6a7" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.conyedit.com&quot;&gt;ConyEdit&lt;/a&gt;, you can use the command line &lt;code&gt;cc.gl !/hede/&lt;/code&gt; to get lines that do not contain the regex matching, or use the command line &lt;code&gt;cc.dl /hede/&lt;/code&gt; to delete lines that contain the regex matching. They have the same result.</source>
          <target state="translated">使用&lt;a href=&quot;https://www.conyedit.com&quot;&gt;ConyEdit&lt;/a&gt; ，可以使用命令行 &lt;code&gt;cc.gl !/hede/&lt;/code&gt; 来获取不包含正则表达式匹配项的行，也可以使用命令行 &lt;code&gt;cc.dl /hede/&lt;/code&gt; 来删除包含正则表达式匹配项的行。 他们有相同的结果。</target>
        </trans-unit>
        <trans-unit id="45f7d6f93e756fe076c6f4d4cc20e5bb4a0af7f1" translate="yes" xml:space="preserve">
          <source>With GNU &lt;code&gt;grep&lt;/code&gt;, the answer would be something like:</source>
          <target state="translated">使用GNU &lt;code&gt;grep&lt;/code&gt; ，答案将类似于：</target>
        </trans-unit>
        <trans-unit id="af3a7829ae5f96bbccfbc07b95bfc1b6818d038b" translate="yes" xml:space="preserve">
          <source>With negative lookahead, regular expression can match something not contains specific pattern. This is answered and explained by Bart Kiers. Great explanation!</source>
          <target state="translated">用负向看头,正则表达式可以匹配不包含特定模式的东西。这个问题由Bart Kiers回答和解释。很好的解释!</target>
        </trans-unit>
        <trans-unit id="af97db013e5d443d690246871b2054ab1d1ebdfc" translate="yes" xml:space="preserve">
          <source>You can also use a tool that implements &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004&quot;&gt;Extended Regular Expressions&lt;/a&gt;, like &lt;code&gt;egrep&lt;/code&gt;, to get rid of the backslashes:</source>
          <target state="translated">您还可以使用实现&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004&quot;&gt;扩展正则表达式&lt;/a&gt;的工具（例如 &lt;code&gt;egrep&lt;/code&gt; ）来消除反斜杠：</target>
        </trans-unit>
        <trans-unit id="3c3ead2f2a71a7f8de04237ee09b7ad0902ae6d3" translate="yes" xml:space="preserve">
          <source>You can see this example &lt;a href=&quot;https://stackoverflow.com/questions/406230&quot;&gt;here&lt;/a&gt;, and try Vcsn online &lt;a href=&quot;http://vcsn-sandbox.lrde.epita.fr/tree&quot;&gt;there&lt;/a&gt;.</source>
          <target state="translated">您可以&lt;a href=&quot;https://stackoverflow.com/questions/406230&quot;&gt;在此处&lt;/a&gt;看到此示例，并在那里在线尝试Vcsn。</target>
        </trans-unit>
        <trans-unit id="9117813c61704c7f607c297794b874af93ed534d" translate="yes" xml:space="preserve">
          <source>You could even put the negation &lt;em&gt;outside&lt;/em&gt; the test if you need any regex features (here, case insensitivity and range matching):</source>
          <target state="translated">如果需要任何正则表达式功能（此处不区分大小写和范围匹配），甚至可以将否定项&lt;em&gt;放在&lt;/em&gt;测试&lt;em&gt;之外&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="4e3bfb39813e0d54c6b52dba372f9b67a2de3789" translate="yes" xml:space="preserve">
          <source>You first define the type of your expressions: labels are letter (&lt;code&gt;lal_char&lt;/code&gt;) to pick from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; for instance (defining the alphabet when working with complementation is, of course, very important), and the &quot;value&quot; computed for each word is just a Boolean: &lt;code&gt;true&lt;/code&gt; the word is accepted, &lt;code&gt;false&lt;/code&gt;, rejected.</source>
          <target state="translated">首先定义表达式的类型：例如，标签是从 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;z&lt;/code&gt; 的字母（ &lt;code&gt;lal_char&lt;/code&gt; ）（当然，在使用补码时定义字母非常重要），每个单词的&amp;ldquo;值&amp;rdquo;为只是一个布尔值： &lt;code&gt;true&lt;/code&gt; 这个词被接受， &lt;code&gt;false&lt;/code&gt; ，被拒绝。</target>
        </trans-unit>
        <trans-unit id="8b92e959c52f5c967563185e1dc02103fcdeb744" translate="yes" xml:space="preserve">
          <source>Your &lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt; statement will need to match &quot;contains&quot; and not match &quot;excludes&quot;.</source>
          <target state="translated">您的&lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt;语句将需要匹配&amp;ldquo;包含&amp;rdquo;而不是&amp;ldquo;排除&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="dc5f45feccd145875695bcee7ec9e44130e5b96f" translate="yes" xml:space="preserve">
          <source>^((?!hede).)*$ is an elegant solution, except since it consumes characters you won't be able to combine it with other criteria. For instance, say you wanted to check for the non-presence of &quot;hede&quot; and the presence of &quot;haha.&quot; This solution would work because it won't consume characters:</source>
          <target state="translated">^((((?!hede).)*$是一个优雅的解决方案,只是因为它消耗了字符,所以你无法将其与其他条件结合起来。例如,假设你想检查是否有 &quot;hede &quot;和 &quot;hahaha &quot;的存在。这个解决方案会很有效,因为它不会消耗字符。</target>
        </trans-unit>
        <trans-unit id="3c24d7c6f693449c71187e2b53fec214d5e24eb3" translate="yes" xml:space="preserve">
          <source>^(?!.&lt;em&gt;\bhede\b)(?=.&lt;/em&gt;\bhaha\b)</source>
          <target state="translated">^(?!.&lt;em&gt;\bhede\b)(?=.&lt;/em&gt;\bhaha\b)</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="89c0d93ef605454f65fa159648fcc4f79d2c32ad" translate="yes" xml:space="preserve">
          <source>as expected.</source>
          <target state="translated">果然,</target>
        </trans-unit>
        <trans-unit id="78b9b44deba42148afa14f26da3512a067ed3f05" translate="yes" xml:space="preserve">
          <source>convert this expression to an automaton:</source>
          <target state="translated">将这一表达式转换为自动化。</target>
        </trans-unit>
        <trans-unit id="0c97c3b2e427dd08a2a22afc585bfb112e48c297" translate="yes" xml:space="preserve">
          <source>e.g. -- If you want to allow all values except &quot;foo&quot; (i.e. &quot;foofoo&quot;, &quot;barfoo&quot;, and &quot;foobar&quot; will pass, but &quot;foo&quot; will fail), use: &lt;code&gt;^(?!foo$).*&lt;/code&gt;</source>
          <target state="translated">例如-如果要允许除&amp;ldquo; foo&amp;rdquo;以外的所有值（即&amp;ldquo; foofoo&amp;rdquo;，&amp;ldquo; barfoo&amp;rdquo;和&amp;ldquo; foobar&amp;rdquo;将通过，但&amp;ldquo; foo&amp;rdquo;将失败），请使用： &lt;code&gt;^(?!foo$).*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e16583e5292c76975f4ece4ba1b17808d175dd82" translate="yes" xml:space="preserve">
          <source>eg.  search an apache config file without all the comments-</source>
          <target state="translated">例如,搜索一个不包含所有注释的apache配置文件-。</target>
        </trans-unit>
        <trans-unit id="81165d7e6d83159d5242d2e3447560267f5f0a15" translate="yes" xml:space="preserve">
          <source>equivalent to (for .net):</source>
          <target state="translated">相当于(对于.net)。</target>
        </trans-unit>
        <trans-unit id="b9c5a9fb1e9449b3cc8c15f7f902b1d5321d355e" translate="yes" xml:space="preserve">
          <source>finally, convert this automaton back to a simple expression.</source>
          <target state="translated">最后,将这个自动机转换回简单的表达式。</target>
        </trans-unit>
        <trans-unit id="37e4a0d8a8bb537de21f7a46cd439c6814401bfd" translate="yes" xml:space="preserve">
          <source>from the official &lt;a href=&quot;https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f&quot;&gt;doc&lt;/a&gt;</source>
          <target state="translated">来自官方&lt;a href=&quot;https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f&quot;&gt;文档&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52ac93fe88a76f92fd6cbc405e59f5efceaa621f" translate="yes" xml:space="preserve">
          <source>is generally much more efficient than the solution to &lt;strong&gt;does not &lt;em&gt;contain&lt;/em&gt; &amp;ldquo;hede&amp;rdquo;&lt;/strong&gt;:</source>
          <target state="translated">通常比&lt;strong&gt;不&lt;em&gt;包含&lt;/em&gt; &amp;ldquo; hede&amp;rdquo;&lt;/strong&gt;的解决方案效率更高：</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="86416a3c88475bb3fd86ea86b3fb79d0fa1fd2ab" translate="yes" xml:space="preserve">
          <source>or use it inline:</source>
          <target state="translated">或者用它来做内联。</target>
        </trans-unit>
        <trans-unit id="ca91e5f012d312c0136c2de3497b8aa8ce4a805a" translate="yes" xml:space="preserve">
          <source>then you enter your expression:</source>
          <target state="translated">然后输入你的表情。</target>
        </trans-unit>
        <trans-unit id="14ff5d9b2a6dee566d29abfb4bfc694ba905fd5b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;+&lt;/code&gt; is usually denoted &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt; denotes the empty word, and &lt;code&gt;[^]&lt;/code&gt; is usually written &lt;code&gt;.&lt;/code&gt; (any character).  So, with a bit of rewriting &lt;code&gt;()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;+&lt;/code&gt; 通常表示 &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;\e&lt;/code&gt; 表示空词，通常写 &lt;code&gt;[^]&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; （任何字符）。 因此，稍微重写一下 &lt;code&gt;()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13a0d941cdbf53982cbc548e039164854ba5a26f" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;e&lt;/code&gt;'s are the empty strings. The regex &lt;code&gt;(?!hede).&lt;/code&gt; looks ahead to see if there's no substring &lt;code&gt;&quot;hede&quot;&lt;/code&gt; to be seen, and if that is the case (so something else is seen), then the &lt;code&gt;.&lt;/code&gt; (dot) will match any character except a line break. Look-arounds are also called &lt;em&gt;zero-width-assertions&lt;/em&gt; because they don't &lt;em&gt;consume&lt;/em&gt; any characters. They only assert/validate something.</source>
          <target state="translated">其中 &lt;code&gt;e&lt;/code&gt; 是空字符串。 正则表达式 &lt;code&gt;(?!hede).&lt;/code&gt; 向前看，看是否没有子串 &lt;code&gt;&quot;hede&quot;&lt;/code&gt; 可以看到，如果是这种情况（那么可以看到其他情况），则该 &lt;code&gt;.&lt;/code&gt; （点）将匹配除换行符以外的任何字符。 环顾四周也称为&lt;em&gt;零宽度断言，&lt;/em&gt;因为它们不&lt;em&gt;占用&lt;/em&gt;任何字符。 他们只断言/验证某些东西。</target>
        </trans-unit>
        <trans-unit id="88141f0aa6d0a5c8b71d83d50fe9878477ba508a" translate="yes" xml:space="preserve">
          <source>which is equivalent to the above.</source>
          <target state="translated">相当于上述内容。</target>
        </trans-unit>
        <trans-unit id="b3f4587567dd91d6188f1c48f4e79ecf19e09aae" translate="yes" xml:space="preserve">
          <source>with this, you avoid to test a lookahead on each positions:</source>
          <target state="translated">有了这个,你可以避免在每个位置上测试一个看头。</target>
        </trans-unit>
        <trans-unit id="a9f7501a4bb77ecb148f3a5340b3c2a4dc0e6caf" translate="yes" xml:space="preserve">
          <source>with word boundaries.</source>
          <target state="translated">以字为界。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
