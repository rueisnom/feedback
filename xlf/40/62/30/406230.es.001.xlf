<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/406230">
    <body>
      <group id="406230">
        <trans-unit id="9eb4a6c92e209092a0d12923bf9cc9ff4cb48470" translate="yes" xml:space="preserve">
          <source>(found with &lt;a href=&quot;http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/&quot;&gt;Grail&lt;/a&gt; and some further optimizations made by hand).</source>
          <target state="translated">(encontrado con &lt;a href=&quot;http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/&quot;&gt;Grail&lt;/a&gt; y algunas optimizaciones adicionales hechas a mano).</target>
        </trans-unit>
        <trans-unit id="2e52af52a8546054dfc6413acff069ef2bc147ca" translate="yes" xml:space="preserve">
          <source>1. Search/replace the entire file to add a unique &quot;Tag&quot; to the beginning of each line containing any text.</source>
          <target state="translated">1.Buscarreemplazar todo el archivo para añadir una &quot;Etiqueta&quot; única al principio de cada línea que contenga cualquier texto.</target>
        </trans-unit>
        <trans-unit id="e705aab59352280c966865af9240b1976c79fb0c" translate="yes" xml:space="preserve">
          <source>2. Delete all lines that contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt; (replacement string is empty):</source>
          <target state="translated">2. Elimine todas las l&amp;iacute;neas que contienen el &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; cadena (la cadena de reemplazo est&amp;aacute; vac&amp;iacute;a):</target>
        </trans-unit>
        <trans-unit id="4d5359854c4a837f09da9271b5d18c0d86e98cb7" translate="yes" xml:space="preserve">
          <source>2. For all lines that contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, remove the unique &quot;Tag&quot;:</source>
          <target state="translated">2. Para todas las l&amp;iacute;neas que contienen el &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; cadena, elimine la &quot;Etiqueta&quot; &amp;uacute;nica:</target>
        </trans-unit>
        <trans-unit id="3a77e275bfbe2978b006ae190f18f26a3701a1f9" translate="yes" xml:space="preserve">
          <source>3. At this point, all lines that begin with the unique &quot;Tag&quot;, &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;. I can now do my &lt;b&gt;&lt;i&gt;Something Else&lt;/i&gt;&lt;/b&gt; to only those lines.</source>
          <target state="translated">3. En este punto, todas las l&amp;iacute;neas que comienzan con la &quot;Etiqueta&quot; &amp;uacute;nica, &lt;b&gt;&lt;i&gt;NO&lt;/i&gt;&lt;/b&gt; contienen el &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; cadena. Ahora puedo hacer mi &lt;b&gt;&lt;i&gt;Algo m&amp;aacute;s&lt;/i&gt;&lt;/b&gt; solo con esas l&amp;iacute;neas.</target>
        </trans-unit>
        <trans-unit id="da9c9c3fd6b8b9646ab8565f22f270096999311b" translate="yes" xml:space="preserve">
          <source>3. At this point, all remaining lines &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;. Remove the unique &quot;Tag&quot; from all lines (replacement string is empty):</source>
          <target state="translated">3. En este punto, todas las l&amp;iacute;neas restantes &lt;b&gt;&lt;i&gt;NO&lt;/i&gt;&lt;/b&gt; contienen la cadena &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; . Elimine la &quot;Etiqueta&quot; &amp;uacute;nica de todas las l&amp;iacute;neas (la cadena de reemplazo est&amp;aacute; vac&amp;iacute;a):</target>
        </trans-unit>
        <trans-unit id="c5af5bfa811f56236562a7f528f03723506bbc92" translate="yes" xml:space="preserve">
          <source>4. When I am done, I remove the unique &quot;Tag&quot; from all lines (replacement string is empty):</source>
          <target state="translated">4.Cuando termino,quito la &quot;Etiqueta&quot; única de todas las líneas (la cadena de reemplazo está vacía):</target>
        </trans-unit>
        <trans-unit id="78feb677fcb5b7b33212618320b97f32f0c56503" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://vcsn.lrde.epita.fr&quot;&gt;Vcsn&lt;/a&gt; supports this operator (which it denotes &lt;code&gt;{c}&lt;/code&gt;, postfix).</source>
          <target state="translated">&lt;a href=&quot;http://vcsn.lrde.epita.fr&quot;&gt;Vcsn&lt;/a&gt; admite este operador (que denota &lt;code&gt;{c}&lt;/code&gt; , postfix).</target>
        </trans-unit>
        <trans-unit id="27524e01dd8c223e92fc167f869ddb9c6ea20286" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24&quot;&gt;jex.im&lt;/a&gt; visualizes regular expressions:</source>
          <target state="translated">&lt;a href=&quot;https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24&quot;&gt;jex.im&lt;/a&gt; visualiza expresiones regulares:</target>
        </trans-unit>
        <trans-unit id="b57eb38c594f4159c8cde8abea030ead596d976b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; Asserts that we are at the line end.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; Afirma que estamos al final de la l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="52b36ac718178a71145d1ba891ac99338438678c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; End of the line anchor is not necessary here.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; El ancla de fin de l&amp;iacute;nea no es necesaria aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="5bc93b176a15f9710c8851f5f6d588bd9d60ed13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; before an optional \n, and the end of the string</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; antes de un \ n opcional, y el final de la cadena</target>
        </trans-unit>
        <trans-unit id="b7c0e80a3bbc4ac75bc1f047ce7b29f9cae01e22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?!&lt;/code&gt; look ahead to see if there is not,</source>
          <target state="translated">&lt;code&gt;(?!&lt;/code&gt; mira hacia adelante para ver si no hay,</target>
        </trans-unit>
        <trans-unit id="13e685cc0a2609aafd47726b3d9c59af6288a725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)*&lt;/code&gt; end of \1   (Note: because you are using a quantifier on this capture, only the LAST repetition of the captured pattern will be stored in \1)</source>
          <target state="translated">&lt;code&gt;)*&lt;/code&gt; final de \ 1 (Nota: debido a que est&amp;aacute; utilizando un cuantificador en esta captura, solo la &amp;Uacute;LTIMA repetici&amp;oacute;n del patr&amp;oacute;n capturado se almacenar&amp;aacute; en \ 1)</target>
        </trans-unit>
        <trans-unit id="684f435ac9c437471ef88a255e4938ea502d9f17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; end of look-ahead, 
&lt;code&gt;.&lt;/code&gt; any character except \n,</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; fin de la anticipaci&amp;oacute;n,. cualquier caracter excepto \ n,</target>
        </trans-unit>
        <trans-unit id="75716139a3b0f1db692009b0858a2ebdd5cb3451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.*&lt;/code&gt; In the Multiline mode, &lt;code&gt;.&lt;/code&gt; would match any character except newline or carriage return characters. And &lt;code&gt;*&lt;/code&gt; would repeat the previous character zero or more times. So &lt;code&gt;.*&lt;/code&gt; would match the whole line. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/4&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; En el modo Multil&amp;iacute;nea,. coincidir&amp;iacute;a con cualquier car&amp;aacute;cter, excepto los caracteres de nueva l&amp;iacute;nea o retorno de carro. Y &lt;code&gt;*&lt;/code&gt; repetir&amp;iacute;a el car&amp;aacute;cter anterior cero o m&amp;aacute;s veces. Entonces &lt;code&gt;.*&lt;/code&gt; Coincidir&amp;iacute;a con toda la l&amp;iacute;nea. Vea la demostraci&amp;oacute;n &lt;a href=&quot;http://regex101.com/r/kR0tO2/4&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd00c1d9cc56e5d787782a13e4d330c5944bf7e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/&amp;lt;span(?:(?!bad).)*?&amp;gt;&lt;/code&gt; will match &lt;code&gt;&amp;lt;span class=\&quot;good\&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;span class=\&quot;ugly\&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/&amp;lt;span(?:(?!bad).)*?&amp;gt;&lt;/code&gt; coincidir&amp;aacute; con &lt;code&gt;&amp;lt;span class=\&quot;good\&quot;&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;lt;span class=\&quot;ugly\&quot;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de91b3ecf3e66e23675457dbbafca8287427b031" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;  Asserts that we are at the start. ie, it matches all the line starts except the one in the &lt;code&gt;hede&lt;/code&gt; line. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/3&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; Afirma que estamos al principio. es decir, coincide con todos los inicios de l&amp;iacute;nea excepto el de la l&amp;iacute;nea &lt;code&gt;hede&lt;/code&gt; . Vea la demostraci&amp;oacute;n &lt;a href=&quot;http://regex101.com/r/kR0tO2/3&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19f3528c6d690ada198857c36184fef7782bef63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; Asserts that we are at the start.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; Afirma que estamos al principio.</target>
        </trans-unit>
        <trans-unit id="ca6ec5ae2a05e42e32bda5e3ea41a1c74bef7b3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;the beginning of the string,
&lt;code&gt;(&lt;/code&gt; group and capture to \1 (0 or more times (matching the most amount possible)),</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; el comienzo de la cadena, &lt;code&gt;(&lt;/code&gt; agrupe y capture a \ 1 (0 o m&amp;aacute;s veces (igualando la mayor cantidad posible)),</target>
        </trans-unit>
        <trans-unit id="88ef62a0b91eaca8ee49fdab3c971717fd8464d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hede&lt;/code&gt; Matches the string &lt;code&gt;hede&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hede&lt;/code&gt; Coincide con la cuerda &lt;code&gt;hede&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1a65ea189e42cc8455fe0afc293a1e00cd3f479" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hede&lt;/code&gt; your string,</source>
          <target state="translated">&lt;code&gt;hede&lt;/code&gt; tu cuerda,</target>
        </trans-unit>
        <trans-unit id="d003b960bdb077c1dfe6beb8ce4ca5d1176468dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(where the &lt;code&gt;/.../&lt;/code&gt; are the regex delimiters, i.e., not part of the pattern)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(donde &lt;code&gt;/.../&lt;/code&gt; son los delimitadores de expresiones regulares, es decir, no forman parte del patr&amp;oacute;n)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f717ceaec1723443831abf050e1226ab1d95364" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If&lt;/em&gt; you're just using it for grep, you can use &lt;code&gt;grep -v hede&lt;/code&gt; to get all lines which do not contain hede.</source>
          <target state="translated">&lt;em&gt;Si solo&lt;/em&gt; lo est&amp;aacute; utilizando para grep, puede usar &lt;code&gt;grep -v hede&lt;/code&gt; para obtener todas las l&amp;iacute;neas que no contienen hede.</target>
        </trans-unit>
        <trans-unit id="201b5844b8586d0c78336f51ab67e7879a440e2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Textpad&lt;/code&gt;&lt;/strong&gt; supports some Regex, but does not support lookahead or lookbehind, so it takes a few steps.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Textpad&lt;/code&gt; es&lt;/strong&gt; compatible con algunos Regex, pero no es compatible con mirar hacia atr&amp;aacute;s o hacia atr&amp;aacute;s, por lo que debe seguir algunos pasos.</target>
        </trans-unit>
        <trans-unit id="c332061cf4bd899460b0a4c0a7eaa14bdb27b163" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Answer:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4780b347f8b966f53592b8d6b23f2c7b9836e63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Details:&lt;/strong&gt; The ^ anchor ensures the regex engine doesn't retry the match at every location in the string, which would match every string.</source>
          <target state="translated">&lt;strong&gt;Detalles:&lt;/strong&gt; el ancla ^ asegura que el motor de expresiones regulares no vuelva a intentar la coincidencia en cada ubicaci&amp;oacute;n de la cadena, lo que coincidir&amp;iacute;a con cada cadena.</target>
        </trans-unit>
        <trans-unit id="33a872627b08a5f899edf01305ae93d8a50b8d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Execution of the parts:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ejecuci&amp;oacute;n de las partes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9108ede24ec6135336892fdeecab45ae62e7a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Explanation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7844df429e40743092ec192901b82594402fa14d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hey why you added .* instead of .+ ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Oye, &amp;iquest;por qu&amp;eacute; agregaste. * En lugar de. +?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3f0d81e6aa9f7ffd4a855a16e0040cc0551378b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PART 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PARTE 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e8addc8bc7252fbc0e0c5e9141350f92b5f32c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PART 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PARTE 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73254be12eadf36210870b716538368a2fedd571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Through PCRE verb &lt;code&gt;(*SKIP)(*F)&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;A trav&amp;eacute;s del verbo PCRE &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6b4aedb6aa5c2789c02d933c0a26fd6986b225b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; I have recently found Kendall Hopkins' excellent &lt;a href=&quot;https://github.com/KendallHopkins/FormalTheory&quot;&gt;FormalTheory&lt;/a&gt; library, written in PHP, which provides a functionality similar to Grail. Using it, and a simplifier written by myself, I've been able to write an online generator of negative regular expressions given an input phrase (only alphanumeric and space characters currently supported): &lt;a href=&quot;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&quot;&gt;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n:&lt;/strong&gt; Recientemente encontr&amp;eacute; la excelente biblioteca &lt;a href=&quot;https://github.com/KendallHopkins/FormalTheory&quot;&gt;FormalTheory de&lt;/a&gt; Kendall Hopkins, escrita en PHP, que proporciona una funcionalidad similar a Grail. Utiliz&amp;aacute;ndolo, y un simplificador escrito por m&amp;iacute; mismo, he podido escribir un generador en l&amp;iacute;nea de expresiones regulares negativas con una frase de entrada (solo se admiten caracteres alfanum&amp;eacute;ricos y de espacio actualmente): &lt;a href=&quot;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&quot;&gt;http://www.formauri.es/personal/ pgimeno / misc / no-match-regex /&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adb30139018c264605cc9fc4ba28906a625cb041" translate="yes" xml:space="preserve">
          <source>A more complicated example: match all lines that start with &lt;code&gt;a&lt;/code&gt; and end with &lt;code&gt;z&lt;/code&gt;, but do not contain the substring &lt;code&gt;hede&lt;/code&gt;:</source>
          <target state="translated">Un ejemplo m&amp;aacute;s complicado: haga coincidir todas las l&amp;iacute;neas que comienzan con &lt;code&gt;a&lt;/code&gt; y terminan con &lt;code&gt;z&lt;/code&gt; , pero no contienen el subcadena &lt;code&gt;hede&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5a6ebacdd544ad2aebe976aa12b05b25bcb11e5b" translate="yes" xml:space="preserve">
          <source>A simpler solution is to use the not operator &lt;strong&gt;!&lt;/strong&gt;</source>
          <target state="translated">&amp;iexcl;Una soluci&amp;oacute;n m&amp;aacute;s simple es usar el operador no &lt;strong&gt;!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd0a50c6415821fc8508d785e47d96d51a7df1f3" translate="yes" xml:space="preserve">
          <source>A string is just a list of &lt;code&gt;n&lt;/code&gt; characters. Before, and after each character, there's an empty string. So a list of &lt;code&gt;n&lt;/code&gt; characters will have &lt;code&gt;n+1&lt;/code&gt; empty strings. Consider the string &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt;:</source>
          <target state="translated">Una cadena es solo una lista de &lt;code&gt;n&lt;/code&gt; caracteres. Antes y despu&amp;eacute;s de cada personaje, hay una cadena vac&amp;iacute;a. Entonces, una lista de &lt;code&gt;n&lt;/code&gt; caracteres tendr&amp;aacute; &lt;code&gt;n+1&lt;/code&gt; cadenas vac&amp;iacute;as. Considere la cadena &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99646ae275e2441f59e1131f109b01e70dc81648" translate="yes" xml:space="preserve">
          <source>Accurate and more efficient than the other answers. It implements Friedl's &lt;em&gt;&quot;unrolling-the-loop&quot;&lt;/em&gt; efficiency technique and requires much less backtracking.</source>
          <target state="translated">Preciso y m&amp;aacute;s eficiente que las otras respuestas. Implementa la t&amp;eacute;cnica de eficiencia de &lt;em&gt;&quot;desenrollar el ciclo&quot; de&lt;/em&gt; Friedl y requiere mucho menos retroceso.</target>
        </trans-unit>
        <trans-unit id="3cac49dcc87a01e093615798c54dde978759b6c5" translate="yes" xml:space="preserve">
          <source>Aforementioned &lt;code&gt;(?:(?!hede).)*&lt;/code&gt; is great because it can be anchored.</source>
          <target state="translated">Lo mencionado anteriormente &lt;code&gt;(?:(?!hede).)*&lt;/code&gt; Es excelente porque se puede anclar.</target>
        </trans-unit>
        <trans-unit id="5b055b615dfbba6017949fb1b34a623d48637083" translate="yes" xml:space="preserve">
          <source>Also, please check out &lt;a href=&quot;https://github.com/amobiz/regexgen.js&quot;&gt;RegexGen.js&lt;/a&gt;, a JavaScript Regular Expression Generator that helps to construct complex regular expressions. With RegexGen.js, you can construct the regex in a more readable way:</source>
          <target state="translated">Adem&amp;aacute;s, consulte &lt;a href=&quot;https://github.com/amobiz/regexgen.js&quot;&gt;RegexGen.js&lt;/a&gt; , un generador de expresiones regulares de JavaScript que ayuda a construir expresiones regulares complejas. Con RegexGen.js, puede construir la expresi&amp;oacute;n regular de una manera m&amp;aacute;s legible:</target>
        </trans-unit>
        <trans-unit id="583b84d757cb6a3e09c59142f1d4214fcaef0cf4" translate="yes" xml:space="preserve">
          <source>An, in my opinon, more readable variant of the top answer:</source>
          <target state="translated">Una,en mi opinión,variante más legible de la respuesta superior:</target>
        </trans-unit>
        <trans-unit id="4a4878a06e9361751e0c8c9f154eb93373a2d656" translate="yes" xml:space="preserve">
          <source>And if you need to match line break chars as well, use the &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;DOT-ALL modifier&lt;/a&gt; (the trailing &lt;code&gt;s&lt;/code&gt; in the following pattern):</source>
          <target state="translated">Y si necesita hacer coincidir tambi&amp;eacute;n los caracteres de salto de l&amp;iacute;nea, use el &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;modificador DOT-ALL&lt;/a&gt; (el final &lt;code&gt;s&lt;/code&gt; el siguiente patr&amp;oacute;n):</target>
        </trans-unit>
        <trans-unit id="815196bdcfbffb0484620f8f7ff2d786b9c04d25" translate="yes" xml:space="preserve">
          <source>Another option is that to add a positive look-ahead and check if &lt;code&gt;hehe&lt;/code&gt; is anywhere in the input line, then we would negate that, with an expression similar to:</source>
          <target state="translated">Otra opci&amp;oacute;n es agregar un look-ahead positivo y verificar si &lt;code&gt;hehe&lt;/code&gt; est&amp;aacute; en alg&amp;uacute;n lugar de la l&amp;iacute;nea de entrada, entonces lo negar&amp;iacute;amos, con una expresi&amp;oacute;n similar a:</target>
        </trans-unit>
        <trans-unit id="90315245d641776926e97cda6abf2b5d2a47c6aa" translate="yes" xml:space="preserve">
          <source>As you can see, the input &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; will fail because on &lt;code&gt;e3&lt;/code&gt;, the regex &lt;code&gt;(?!hede)&lt;/code&gt; fails (there &lt;em&gt;is&lt;/em&gt;&lt;code&gt;&quot;hede&quot;&lt;/code&gt; up ahead!).</source>
          <target state="translated">Como puede ver, la entrada &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; fallar&amp;aacute; porque en &lt;code&gt;e3&lt;/code&gt; , la expresi&amp;oacute;n regular &lt;code&gt;(?!hede)&lt;/code&gt; falla (&amp;iexcl;hay &lt;code&gt;&quot;hede&quot;&lt;/code&gt; adelante!).</target>
        </trans-unit>
        <trans-unit id="14f0d43928a101b17017ac03b48125ba0258064c" translate="yes" xml:space="preserve">
          <source>Basically, &quot;match at the beginning of the line if and only if it does not have 'hede' in it&quot; - so the requirement translated almost directly into regex.</source>
          <target state="translated">Básicamente,&quot;coinciden al principio de la línea si y sólo si no tiene 'hede' en ella&quot;-así que el requisito se tradujo casi directamente en regex.</target>
        </trans-unit>
        <trans-unit id="b76db96cf2a32f41f46b8568c9c2f6995d10c7a9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.*&lt;/code&gt; would match a blank line but &lt;code&gt;.+&lt;/code&gt; won't match a blank. We want to match all the lines except &lt;code&gt;hede&lt;/code&gt; , there may be a possibility of blank lines also in the input . so you must use &lt;code&gt;.*&lt;/code&gt; instead of &lt;code&gt;.+&lt;/code&gt; . &lt;code&gt;.+&lt;/code&gt; would repeat the previous character one or more times. See &lt;code&gt;.*&lt;/code&gt; matches a blank line &lt;a href=&quot;http://regex101.com/r/kR0tO2/5&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Porque &lt;code&gt;.*&lt;/code&gt; Coincidir&amp;iacute;a con una l&amp;iacute;nea en blanco pero &lt;code&gt;.+&lt;/code&gt; No coincidir&amp;aacute; con un espacio en blanco. Queremos hacer coincidir todas las l&amp;iacute;neas excepto &lt;code&gt;hede&lt;/code&gt; , puede haber una posibilidad de l&amp;iacute;neas en blanco tambi&amp;eacute;n en la entrada. as&amp;iacute; que debes usar &lt;code&gt;.*&lt;/code&gt; en lugar de &lt;code&gt;.+&lt;/code&gt; . &lt;code&gt;.+&lt;/code&gt; repetir&amp;iacute;a el car&amp;aacute;cter anterior una o m&amp;aacute;s veces. Ver &lt;code&gt;.*&lt;/code&gt; Coincide con una l&amp;iacute;nea en blanco &lt;a href=&quot;http://regex101.com/r/kR0tO2/5&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6f977a9521045923d16f98954c616fecb8c843e" translate="yes" xml:space="preserve">
          <source>Benchmark Text:</source>
          <target state="translated">Texto de referencia:</target>
        </trans-unit>
        <trans-unit id="4f46ac72b3634f96c6860b1ed26d9d4cd71d21aa" translate="yes" xml:space="preserve">
          <source>Benchmarks</source>
          <target state="translated">Benchmarks</target>
        </trans-unit>
        <trans-unit id="b3d97f68b4c000dbfe8c7d755739582257de96d6" translate="yes" xml:space="preserve">
          <source>But the following would suffice in this case:</source>
          <target state="translated">Pero lo siguiente sería suficiente en este caso:</target>
        </trans-unit>
        <trans-unit id="9c556257951e2f974fa9f074f2d437367d7b7de5" translate="yes" xml:space="preserve">
          <source>But the overall most readable and performance-wise fastest solution seems to be 05 using a conditional statement
or 04 with the possesive quantifier. I think the Perl solutions should be even faster and more easily readable.</source>
          <target state="translated">Pero la solución más legible y más rápida en cuanto a rendimiento parece ser 05 usando una declaración condicional o 04 con el cuantificador posesivo.Creo que las soluciones de Perl deberían ser aún más rápidas y más fáciles de leer.</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="038bc41a7c6c6423fba68ab38e1243e0673eb5b1" translate="yes" xml:space="preserve">
          <source>DEMO</source>
          <target state="translated">DEMO</target>
        </trans-unit>
        <trans-unit id="0b308b0064ee9df9865833a93aaf9d02316a25a9" translate="yes" xml:space="preserve">
          <source>Demo in Ruby:</source>
          <target state="translated">Demo en Ruby:</target>
        </trans-unit>
        <trans-unit id="2668fed25786577ef5330fbb43aa5160b5fce977" translate="yes" xml:space="preserve">
          <source>Desired output:</source>
          <target state="translated">Salida deseada:</target>
        </trans-unit>
        <trans-unit id="22ed035c38e99c0a0525f1aa14558f382586a7e4" translate="yes" xml:space="preserve">
          <source>Do not use:</source>
          <target state="translated">No lo use:</target>
        </trans-unit>
        <trans-unit id="8248c9f017b2a661d23671bd60ce72132eb021cd" translate="yes" xml:space="preserve">
          <source>ETA Oh, rereading the question, &lt;code&gt;grep -v&lt;/code&gt; is probably what you meant by &quot;tools options&quot;.</source>
          <target state="translated">ETA Oh, releyendo la pregunta, &lt;code&gt;grep -v&lt;/code&gt; es probablemente lo que quisiste decir con &quot;opciones de herramientas&quot;.</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="38d08890b5b368e55863bf943b6b9078a77b395b" translate="yes" xml:space="preserve">
          <source>FWIW, since regular languages (aka rational languages) are closed under complementation, it's always possible to find a regular expression (aka rational expression) that negates another expression. But not many tools implement this.</source>
          <target state="translated">FWIW,dado que los idiomas regulares (también conocidos como idiomas racionales)se cierran bajo la complementación,siempre es posible encontrar una expresión regular (también conocida como expresión racional)que niega otra expresión.Pero no hay muchas herramientas que implementen esto.</target>
        </trans-unit>
        <trans-unit id="94a4158640ead0903e4198248cdd279ee4bf592b" translate="yes" xml:space="preserve">
          <source>Finally, as everyone has noted, if your regular expression engine supports negative lookahead, that simplifies the task a lot. For example, with GNU grep:</source>
          <target state="translated">Finalmente,como todos han notado,si su motor de expresión regular apoya la mirada negativa,eso simplifica mucho la tarea.Por ejemplo,con GNU grep:</target>
        </trans-unit>
        <trans-unit id="e7840fc67eb63c0fc62b3bb9275d4ae78f58cc36" translate="yes" xml:space="preserve">
          <source>First, it tries to find &quot;hede&quot; somewhere in the line. If successful, at this point, &lt;code&gt;(*COMMIT)&lt;/code&gt; tells the engine to, not only not backtrack in the event of a failure, but also not to attempt any further matching in that case. Then, we try to match something that cannot possibly match (in this case, &lt;code&gt;^&lt;/code&gt;).</source>
          <target state="translated">Primero, trata de encontrar &quot;hede&quot; en alg&amp;uacute;n lugar de la l&amp;iacute;nea. Si tiene &amp;eacute;xito, en este punto, &lt;code&gt;(*COMMIT)&lt;/code&gt; le dice al motor que no solo retroceda en caso de falla, sino que no intente ninguna otra coincidencia en ese caso. Luego, intentamos hacer coincidir algo que no puede coincidir (en este caso, &lt;code&gt;^&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="66fd11bbda1e7cb077ac7a5170f9d22cd9e79e06" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;hede&lt;/code&gt; it outputs:</source>
          <target state="translated">Para &lt;code&gt;hede&lt;/code&gt; sale :</target>
        </trans-unit>
        <trans-unit id="c7cb8f31d0f67cada2b023061ce292ebd71188db" translate="yes" xml:space="preserve">
          <source>For example, a string:</source>
          <target state="translated">Por ejemplo,una cuerda:</target>
        </trans-unit>
        <trans-unit id="44957a991234be8e9df9fa75f2eb494f5b1a8eed" translate="yes" xml:space="preserve">
          <source>For me, I sometimes need to do this while editing a file using &lt;strong&gt;&lt;code&gt;Textpad&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Para m&amp;iacute;, a veces necesito hacer esto mientras &lt;strong&gt; &lt;code&gt;Textpad&lt;/code&gt; &lt;/strong&gt; un archivo usando &lt;strong&gt;Textpad&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ce940869d506a887a010eb773ba2c6af358bf25a" translate="yes" xml:space="preserve">
          <source>For more information about lookahead, please check out the great article: &lt;a href=&quot;http://www.rexegg.com/regex-lookarounds.html&quot;&gt;Mastering Lookahead and Lookbehind&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre lookahead, consulte el excelente art&amp;iacute;culo: &lt;a href=&quot;http://www.rexegg.com/regex-lookarounds.html&quot;&gt;Dominar Lookahead y Lookbehind&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c25f2278c3b324ffc728c690b8635beda0a6a6d1" translate="yes" xml:space="preserve">
          <source>For those interested in the details, the technique employed is to convert the regular expression that matches the word into a finite automaton, then invert the automaton by changing every acceptance state to non-acceptance and vice versa, and then converting the resulting FA back to a regular expression.</source>
          <target state="translated">Para los interesados en los detalles,la técnica empleada es convertir la expresión regular que coincide con la palabra en un autómata finito,luego invertir el autómata cambiando cada estado de aceptación a no-aceptación y viceversa,y luego convertir el FA resultante de nuevo a una expresión regular.</target>
        </trans-unit>
        <trans-unit id="e3b647855c42983ecd846d1757dfd4687da23b1b" translate="yes" xml:space="preserve">
          <source>Given a string: 
&lt;code&gt;
&amp;lt;span class=&quot;good&quot;&amp;gt;bar&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;bad&quot;&amp;gt;foo&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ugly&quot;&amp;gt;baz&amp;lt;/span&amp;gt;
&lt;/code&gt;</source>
          <target state="translated">Dada una cadena: &lt;code&gt; &amp;lt;span class=&quot;good&quot;&amp;gt;bar&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;bad&quot;&amp;gt;foo&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ugly&quot;&amp;gt;baz&amp;lt;/span&amp;gt; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a41b37dc9eb2f2ea1a88a659b705994f14fc76f" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;http://jsfiddle.net/pvJL5/3/&quot;&gt;demo code&lt;/a&gt;.</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el &lt;a href=&quot;http://jsfiddle.net/pvJL5/3/&quot;&gt;c&amp;oacute;digo de demostraci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="440b25c25e75becc55b449c73a3491fe97d861e4" translate="yes" xml:space="preserve">
          <source>Here is the improved regex:</source>
          <target state="translated">Aquí está el regex mejorado:</target>
        </trans-unit>
        <trans-unit id="9a9a8952516d81a0b39d9122ade38c17c2ed9060" translate="yes" xml:space="preserve">
          <source>Here's &lt;a href=&quot;http://www.perlmonks.org/?node_id=588315#588368&quot;&gt;a good explanation&lt;/a&gt; of why it's not easy to negate an arbitrary regex. I have to agree with the other answers, though: if this is anything other than a hypothetical question, then a regex is not the right choice here.</source>
          <target state="translated">Aqu&amp;iacute; hay &lt;a href=&quot;http://www.perlmonks.org/?node_id=588315#588368&quot;&gt;una buena explicaci&amp;oacute;n&lt;/a&gt; de por qu&amp;eacute; no es f&amp;aacute;cil negar una expresi&amp;oacute;n regular arbitraria. Sin embargo, tengo que estar de acuerdo con las otras respuestas: si esto no es una pregunta hipot&amp;eacute;tica, entonces una expresi&amp;oacute;n regular no es la opci&amp;oacute;n correcta aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="ddaef8476b8e3acafac4825d7b8f1ac998e71f92" translate="yes" xml:space="preserve">
          <source>Here's a method that I haven't seen used before:</source>
          <target state="translated">Aquí hay un método que no he visto usar antes:</target>
        </trans-unit>
        <trans-unit id="1dff1040ef948d2545fd38f5ddc5048a75c98520" translate="yes" xml:space="preserve">
          <source>Here's a script to test it (note it generates a file &lt;code&gt;testinput.txt&lt;/code&gt; in the current directory):</source>
          <target state="translated">Aqu&amp;iacute; hay un script para probarlo (tenga en cuenta que genera un archivo &lt;code&gt;testinput.txt&lt;/code&gt; en el directorio actual):</target>
        </trans-unit>
        <trans-unit id="5f28c2737b2f0e2188d8328f330fac2b15157b53" translate="yes" xml:space="preserve">
          <source>Here's how I'd do it:</source>
          <target state="translated">Así es como lo haría yo:</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">Cómo funciona</target>
        </trans-unit>
        <trans-unit id="af4b2da81f792f5da8904c48f25a28f04b5d9a3c" translate="yes" xml:space="preserve">
          <source>How to use PCRE's backtracking control verbs to match a line not containing a word</source>
          <target state="translated">Cómo usar los verbos de control de retroceso de PCRE para hacer coincidir una línea que no contiene una palabra</target>
        </trans-unit>
        <trans-unit id="358f19a96883463715eb0b8d693998ffb417eb35" translate="yes" xml:space="preserve">
          <source>However, GNU &lt;code&gt;grep&lt;/code&gt; implements extensions that allow it. In particular, &lt;code&gt;\|&lt;/code&gt; is the alternation operator in GNU's implementation of BREs, and &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; are the parentheses. If your regular expression engine supports alternation, negative bracket expressions, parentheses and the Kleene star, and is able to anchor to the beginning and end of the string, that's all you need for this approach. Note however that negative sets &lt;code&gt;[^ ... ]&lt;/code&gt; are very convenient in addition to those, because otherwise, you need to replace them with an expression of the form &lt;code&gt;(a|b|c| ... )&lt;/code&gt; that lists every character that is not in the set, which is extremely tedious and overly long, even more so if the whole character set is Unicode.</source>
          <target state="translated">Sin embargo, GNU &lt;code&gt;grep&lt;/code&gt; implementa extensiones que lo permiten. En particular, &lt;code&gt;\|&lt;/code&gt; es el operador de alternancia en la implementaci&amp;oacute;n de BRE de GNU, y &lt;code&gt;\(&lt;/code&gt; y &lt;code&gt;\)&lt;/code&gt; son par&amp;eacute;ntesis. Si su motor de expresiones regulares admite alternancia, expresiones de par&amp;eacute;ntesis negativas, par&amp;eacute;ntesis y la estrella de Kleene, y puede anclarse al principio y al final de la cadena, eso es todo lo que necesita para este enfoque. Sin embargo, tenga en cuenta que los conjuntos negativos &lt;code&gt;[^ ... ]&lt;/code&gt; son muy convenientes adem&amp;aacute;s de esos, porque de lo contrario, debe reemplazarlos con una expresi&amp;oacute;n de la forma &lt;code&gt;(a|b|c| ... )&lt;/code&gt; que enumera todos los caracteres que son no en el conjunto, que es extremadamente tedioso y demasiado largo, incluso m&amp;aacute;s si todo el conjunto de caracteres es Unicode.</target>
        </trans-unit>
        <trans-unit id="87fce9ed530df5073b27f7dc4a7cb8a5bddaceaa" translate="yes" xml:space="preserve">
          <source>However, with Bart Kiers' answer, the lookahead part will test 1 to 4 characters ahead while matching any single character. We can avoid this and let the lookahead part check out the whole text, ensure there is no 'hede', and then the normal part (.*) can eat the whole text all at one time.</source>
          <target state="translated">Sin embargo,con la respuesta de Bart Kiers,la parte del lookahead pondrá a prueba de 1 a 4 caracteres por delante,mientras que se iguala a cualquier personaje individual.Podemos evitar esto y dejar que la parte &quot;lookahead&quot; revise todo el texto,se asegure de que no hay &quot;hede&quot;,y entonces la parte normal (.*)puede comerse todo el texto de una sola vez.</target>
        </trans-unit>
        <trans-unit id="358d0378b2ab94ec8627f21e6e089dabbbed421a" translate="yes" xml:space="preserve">
          <source>I believe the designers of RegEx anticipated the use of not operators.</source>
          <target state="translated">Creo que los diseñadores de RegEx anticiparon el uso de no operadores.</target>
        </trans-unit>
        <trans-unit id="e798d46c6cfecdfa243d565a95292a06448c5bd4" translate="yes" xml:space="preserve">
          <source>I decided to evaluate some of the presented Options and compare their performance, as well as use some new Features.
Benchmarking on .NET Regex Engine: &lt;a href=&quot;http://regexhero.net/tester/&quot;&gt;http://regexhero.net/tester/&lt;/a&gt;</source>
          <target state="translated">Decid&amp;iacute; evaluar algunas de las opciones presentadas y comparar su rendimiento, as&amp;iacute; como utilizar algunas caracter&amp;iacute;sticas nuevas. Evaluaci&amp;oacute;n comparativa en .NET Regex Engine: &lt;a href=&quot;http://regexhero.net/tester/&quot;&gt;http://regexhero.net/tester/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa66090b531a3943e8315caeac17d53e7fa5772a" translate="yes" xml:space="preserve">
          <source>I know it's possible to match a word and then reverse the matches using other tools (e.g. &lt;code&gt;grep -v&lt;/code&gt;). However, is it possible to match lines that do not contain a specific word, e.g. &lt;code&gt;hede&lt;/code&gt;, using a regular expression?</source>
          <target state="translated">S&amp;eacute; que es posible hacer coincidir una palabra y luego revertir las coincidencias utilizando otras herramientas (por ejemplo, &lt;code&gt;grep -v&lt;/code&gt; ). Sin embargo, &amp;iquest;es posible hacer coincidir l&amp;iacute;neas que no contengan una palabra espec&amp;iacute;fica, por ejemplo, &lt;code&gt;hede&lt;/code&gt; , usando una expresi&amp;oacute;n regular?</target>
        </trans-unit>
        <trans-unit id="4065441f68e9c6020ab5a572b3efff079b3598f2" translate="yes" xml:space="preserve">
          <source>I tried to test most proposed solutions, some Optimizations are possible for certain words.
For Example if the First two letters of the search string are not the Same, answer 03 can be expanded to
&lt;code&gt;^(?&amp;gt;[^R]+|R+(?!egex Hero))*$&lt;/code&gt; resulting in a small performance gain.</source>
          <target state="translated">Trat&amp;eacute; de probar la mayor&amp;iacute;a de las soluciones propuestas, algunas optimizaciones son posibles para ciertas palabras. Por ejemplo, si las dos primeras letras de la cadena de b&amp;uacute;squeda no son iguales, la respuesta 03 se puede expandir a &lt;code&gt;^(?&amp;gt;[^R]+|R+(?!egex Hero))*$&lt;/code&gt; resulta en una peque&amp;ntilde;a ganancia de rendimiento.</target>
        </trans-unit>
        <trans-unit id="55152e4cb8b05e2398aff1b805ef864a7498c807" translate="yes" xml:space="preserve">
          <source>I want to match &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; tags which do not contain the substring &quot;bad&quot;.</source>
          <target state="translated">Quiero hacer coincidir las etiquetas &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; que no contienen la subcadena &quot;mala&quot;.</target>
        </trans-unit>
        <trans-unit id="348fdb226d122d58a879e94920244cb659c2ff80" translate="yes" xml:space="preserve">
          <source>If I am looking to &lt;b&gt;&lt;i&gt;Do Something Else&lt;/i&gt;&lt;/b&gt; to only lines that &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, I would do it like this:</source>
          <target state="translated">Si estoy buscando &lt;b&gt;&lt;i&gt;hacer algo m&amp;aacute;s&lt;/i&gt;&lt;/b&gt; para solo l&amp;iacute;neas que &lt;b&gt;&lt;i&gt;NO&lt;/i&gt;&lt;/b&gt; contienen el &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; cadena, lo har&amp;iacute;a as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="38622a9faba8a5ee89d14dd8753c178ec7f57e80" translate="yes" xml:space="preserve">
          <source>If I am looking to retain all lines that &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, I would do it like this:</source>
          <target state="translated">Si estoy buscando retener todas las l&amp;iacute;neas que &lt;b&gt;&lt;i&gt;NO&lt;/i&gt;&lt;/b&gt; contienen el &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; cadena, lo har&amp;iacute;a as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="38763d6f5618ba3862a9ce1d1f4a6b9b7ba82b1e" translate="yes" xml:space="preserve">
          <source>If a line does not contain &quot;hede&quot; then the second alternative, an empty subpattern, successfully matches the subject string.</source>
          <target state="translated">Si una línea no contiene &quot;hede&quot;,entonces la segunda alternativa,un subpatrón vacío,coincide con éxito con la cadena del sujeto.</target>
        </trans-unit>
        <trans-unit id="d412617b77836527f5a7b6be35bc1f03d6769b94" translate="yes" xml:space="preserve">
          <source>If the DOT-ALL modifier is not available, you can mimic the same behavior with the character class &lt;code&gt;[\s\S]&lt;/code&gt;:</source>
          <target state="translated">Si el modificador DOT-ALL no est&amp;aacute; disponible, puede imitar el mismo comportamiento con la clase de caracteres &lt;code&gt;[\s\S]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="92f26649c4516946fcb1add8c4a8263d3b34b2bf" translate="yes" xml:space="preserve">
          <source>If you want the regex test to &lt;strong&gt;only&lt;/strong&gt; fail if the &lt;em&gt;entire string&lt;/em&gt; matches, the following will work:</source>
          <target state="translated">Si desea que la prueba de expresi&amp;oacute;n regular &lt;strong&gt;solo&lt;/strong&gt; falle si la &lt;em&gt;cadena completa&lt;/em&gt; coincide, lo siguiente funcionar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="729b36879bb4e3767c9a57246277a86e711573a2" translate="yes" xml:space="preserve">
          <source>If you want to match a character to negate a word similar to negate character class:</source>
          <target state="translated">Si quieres emparejar un personaje para negar una palabra similar a negar la clase de personaje:</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="translated">En Python:</target>
        </trans-unit>
        <trans-unit id="f1be7176418bc2ec420699af8dfcaafdad7421f0" translate="yes" xml:space="preserve">
          <source>In my system it prints:</source>
          <target state="translated">En mi sistema se imprime:</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">Input:</target>
        </trans-unit>
        <trans-unit id="70b4e36c7616180b6c9127dc59657f047a94fe8b" translate="yes" xml:space="preserve">
          <source>It may be more maintainable to two regexes in your code, one to do the first match, and then if it matches run the second regex to check for outlier cases you wish to block for example &lt;code&gt;^.*(hede).*&lt;/code&gt; then have appropriate logic in your code.</source>
          <target state="translated">Puede ser m&amp;aacute;s f&amp;aacute;cil de mantener dos expresiones regulares en su c&amp;oacute;digo, una para hacer la primera coincidencia, y luego, si coincide, ejecute la segunda expresi&amp;oacute;n regular para verificar los casos at&amp;iacute;picos que desea bloquear, por ejemplo &lt;code&gt;^.*(hede).*&lt;/code&gt; Luego tener el apropiado l&amp;oacute;gica en tu c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="619838c3b0a02408fab5aaa30829a7d4c40bef84" translate="yes" xml:space="preserve">
          <source>Let us consider the above regex by splitting it into two parts.</source>
          <target state="translated">Consideremos el anterior regex dividiéndolo en dos partes.</target>
        </trans-unit>
        <trans-unit id="5395b8e8626e7f4b1fd55874dc85b6775aa31200" translate="yes" xml:space="preserve">
          <source>Maybe you'll find this on Google while trying to write a regex that is able to match segments of a line (as opposed to entire lines) which do &lt;strong&gt;not&lt;/strong&gt; contain a substring. Tooke me a while to figure out, so I'll share:</source>
          <target state="translated">Tal vez encuentre esto en Google mientras intenta escribir una expresi&amp;oacute;n regular que pueda coincidir con segmentos de una l&amp;iacute;nea (en oposici&amp;oacute;n a l&amp;iacute;neas completas) que &lt;strong&gt;no&lt;/strong&gt; contienen una subcadena. T&amp;oacute;came un tiempo para averiguar, as&amp;iacute; que compartir&amp;eacute;:</target>
        </trans-unit>
        <trans-unit id="f65015b6743116c0d591a6ecf9d76f8aaa121c4e" translate="yes" xml:space="preserve">
          <source>Not regex, but I've found it logical and useful to use serial greps with pipe to eliminate noise.</source>
          <target state="translated">No es regex,pero me ha parecido lógico y útil usar greps en serie con tubería para eliminar el ruido.</target>
        </trans-unit>
        <trans-unit id="081045e6b01eadb48d20a103dbb36df17d72fe50" translate="yes" xml:space="preserve">
          <source>Note that the solution to &lt;strong&gt;does not &lt;em&gt;start with&lt;/em&gt; &amp;ldquo;hede&amp;rdquo;&lt;/strong&gt;:</source>
          <target state="translated">Tenga en cuenta que la soluci&amp;oacute;n a &lt;strong&gt;no &lt;em&gt;comienza con&lt;/em&gt; &quot;hede&quot;&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="26b82927c1805e4c7847c9a3577899e346640e6a" translate="yes" xml:space="preserve">
          <source>Note the (*?) lazy quantifier in the negative lookahead part is optional, you can use (*) greedy quantifier instead, depending on your data: if 'hede' does present and in the beginning half of the text, the lazy quantifier can be faster; otherwise, the greedy quantifier be faster. However if 'hede' does not present, both would be equal slow.</source>
          <target state="translated">Nota el (*?)cuantificador perezoso en la parte negativa del lookahead es opcional,puedes usar el (*)cuantificador codicioso en su lugar,dependiendo de tus datos:si &quot;hede&quot; se presenta y en la mitad inicial del texto,el cuantificador perezoso puede ser más rápido;de lo contrario,el cuantificador codicioso será más rápido.Sin embargo,si &quot;hede&quot; no se presenta,ambos serían igual de lentos.</target>
        </trans-unit>
        <trans-unit id="0e9a29d02e68bcb3679deea8d109eb179570c686" translate="yes" xml:space="preserve">
          <source>Notice &lt;code&gt;&quot;(?!bbb).&quot;&lt;/code&gt; is neither lookbehind nor lookahead, it's lookcurrent, for example:</source>
          <target state="translated">Observe &lt;code&gt;&quot;(?!bbb).&quot;&lt;/code&gt; no es mirar hacia atr&amp;aacute;s ni mirar hacia adelante, es actual, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="30d37c9788dcecf1fad3016f170ca9201ffa1d65" translate="yes" xml:space="preserve">
          <source>Notice that there are two sets (layers) of parentheses:</source>
          <target state="translated">Obsérvese que hay dos conjuntos (capas)de paréntesis:</target>
        </trans-unit>
        <trans-unit id="a86f480c07344c42ab876520a48514924063ed70" translate="yes" xml:space="preserve">
          <source>Now you have the original text with all lines containing the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt; removed.</source>
          <target state="translated">Ahora tiene el texto original con todas las l&amp;iacute;neas que contienen la cadena &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; eliminada.</target>
        </trans-unit>
        <trans-unit id="dcc9367c99afe75c60c7432ea228375c0eed703b" translate="yes" xml:space="preserve">
          <source>OK, I admit this is not really an answer to the posted question posted and it may also use slightly more processing than a single regex. But for developers who came here looking for a fast emergency fix for an outlier case then this solution should not be overlooked.</source>
          <target state="translated">OK,admito que esto no es realmente una respuesta a la pregunta publicada y también puede usar un poco más de procesamiento que un simple regex.Pero para los desarrolladores que vinieron aquí buscando una solución rápida de emergencia para un caso atípico,entonces esta solución no debe ser pasada por alto.</target>
        </trans-unit>
        <trans-unit id="b217bc7b14d3698eeeed95b262a2782958f75640" translate="yes" xml:space="preserve">
          <source>Of course, if you're checking for &lt;em&gt;exact&lt;/em&gt; equality, a better general solution in this case is to check for string equality, i.e.</source>
          <target state="translated">Por supuesto, si est&amp;aacute; verificando la igualdad &lt;em&gt;exacta&lt;/em&gt; , una mejor soluci&amp;oacute;n general en este caso es verificar la igualdad de la cadena, es decir</target>
        </trans-unit>
        <trans-unit id="92e4e642b4116921153d765748bceeb2a5d28218" translate="yes" xml:space="preserve">
          <source>Of course, it's possible to have multiple failure requirements:</source>
          <target state="translated">Por supuesto,es posible tener múltiples requisitos de fallo:</target>
        </trans-unit>
        <trans-unit id="1676b6642119a6e78e273b06ef382dc642a9b8c8" translate="yes" xml:space="preserve">
          <source>Old answer:</source>
          <target state="translated">Respuesta antigua:</target>
        </trans-unit>
        <trans-unit id="c25c62a5bc188579d5d23849efc8f31cf2a447d1" translate="yes" xml:space="preserve">
          <source>Part after the &lt;code&gt;|&lt;/code&gt; symbol. Part &lt;strong&gt;should be matched&lt;/strong&gt;.</source>
          <target state="translated">Parte despu&amp;eacute;s de la &lt;code&gt;|&lt;/code&gt; s&amp;iacute;mbolo. Parte &lt;strong&gt;debe coincidir&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="73b61b7b35a3691f94481b52b729efe8e43baadb" translate="yes" xml:space="preserve">
          <source>Part before the &lt;code&gt;|&lt;/code&gt; symbol. Part &lt;strong&gt;shouldn't be matched&lt;/strong&gt;.</source>
          <target state="translated">Parte antes de la &lt;code&gt;|&lt;/code&gt; s&amp;iacute;mbolo. La parte &lt;strong&gt;no debe coincidir&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d7ae9fea9116fab8d5be9f40e43c9fe24123c8e9" translate="yes" xml:space="preserve">
          <source>RegEx Circuit</source>
          <target state="translated">Circuito RegEx</target>
        </trans-unit>
        <trans-unit id="41676a1dc090860fb04559a11f57d002c96d15af" translate="yes" xml:space="preserve">
          <source>Regex engine will start its execution from the first part.</source>
          <target state="translated">El motor Regex comenzará su ejecución desde la primera parte.</target>
        </trans-unit>
        <trans-unit id="71546fc265910c3ba4c3a0c33a7cfa6a7c857490" translate="yes" xml:space="preserve">
          <source>Regex negation is not particularly useful on its own but when you also have intersection, things get interesting, since you have a full set of boolean set operations: you can express &quot;the set which matches this, except for things which match that&quot;.</source>
          <target state="translated">La negación de Regex no es particularmente útil por sí sola,pero cuando también tienes una intersección,las cosas se ponen interesantes,ya que tienes un conjunto completo de operaciones de conjunto booleano:puedes expresar &quot;el conjunto que coincide con esto,excepto las cosas que coinciden con eso&quot;.</target>
        </trans-unit>
        <trans-unit id="19997c21128f333f226b26bb698b36f34117927e" translate="yes" xml:space="preserve">
          <source>Regular Expressions in the meaning of theoretical computer sciences &lt;em&gt;ARE NOT ABLE&lt;/em&gt; do it like this. For them it had to look something like this:</source>
          <target state="translated">Expresiones regulares en el significado de las ciencias de la computaci&amp;oacute;n te&amp;oacute;rica &lt;em&gt;NO SON CAPAZ de&lt;/em&gt; hacerlo as&amp;iacute;. Para ellos ten&amp;iacute;a que verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="af38a3c1a9ef260f4705cde91de11408ba9cc3b3" translate="yes" xml:space="preserve">
          <source>Regular expression to match a line that doesn't contain a word</source>
          <target state="translated">Expresión regular para coincidir con una línea que no contiene una palabra</target>
        </trans-unit>
        <trans-unit id="e9a6ae937eb3ddd638ffc636c1c42607a3fc5a93" translate="yes" xml:space="preserve">
          <source>Results are Iterations per second as the median of 3 runs - &lt;strong&gt;Bigger Number = Better&lt;/strong&gt;</source>
          <target state="translated">Los resultados son iteraciones por segundo como la mediana de 3 carreras - &lt;strong&gt;N&amp;uacute;mero mayor = Mejor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="2a8fa741fc245177c287037e3934f7b7d34f2900" translate="yes" xml:space="preserve">
          <source>Since .NET doesn't support action Verbs (*FAIL, etc.) I couldn't test the solutions P1 and P2.</source>
          <target state="translated">Como el .NET no soporta verbos de acción (*FAIL,etc.)no pude probar las soluciones P1 y P2.</target>
        </trans-unit>
        <trans-unit id="6e8ae50092c4781a2d7e2ceca8e2bcb82f39e2eb" translate="yes" xml:space="preserve">
          <source>Since no one else has given a direct answer to the question &lt;em&gt;that was asked&lt;/em&gt;, I'll do it.</source>
          <target state="translated">Como nadie m&amp;aacute;s ha dado una respuesta directa a la pregunta &lt;em&gt;que se hizo&lt;/em&gt; , lo har&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="a53ab784ceaf12bbfbc9f16efc79e5e24d16d2c3" translate="yes" xml:space="preserve">
          <source>Since the introduction of ruby-2.4.1, we can use the new &lt;a href=&quot;https://github.com/k-takata/Onigmo/issues/82&quot;&gt;Absent Operator&lt;/a&gt; in Ruby&amp;rsquo;s Regular Expressions</source>
          <target state="translated">Desde la introducci&amp;oacute;n de ruby-2.4.1, podemos usar el nuevo &lt;a href=&quot;https://github.com/k-takata/Onigmo/issues/82&quot;&gt;operador ausente&lt;/a&gt; en las expresiones regulares de Ruby</target>
        </trans-unit>
        <trans-unit id="1692e723845d6b6032f0c8d3b96f35a2c9ce70d7" translate="yes" xml:space="preserve">
          <source>So the line which contains the string &lt;code&gt;hede&lt;/code&gt; would be matched. Once the regex engine sees the following &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; (&lt;em&gt;Note: You could write &lt;code&gt;(*F)&lt;/code&gt; as &lt;code&gt;(*FAIL)&lt;/code&gt;&lt;/em&gt;) verb, it skips and make the match to fail. &lt;code&gt;|&lt;/code&gt; called alteration or logical OR operator added next to the PCRE verb which inturn matches all the boundaries exists between each and every character on all the lines except the line contains the exact string &lt;code&gt;hede&lt;/code&gt;. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/2&quot;&gt;here&lt;/a&gt;. That is, it tries to match the characters from the remaining string. Now the regex in the second part would be executed.</source>
          <target state="translated">Por lo tanto, la l&amp;iacute;nea que contiene la cadena &lt;code&gt;hede&lt;/code&gt; coincidir&amp;iacute;a. Una vez que el motor regex ve el siguiente verbo &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; ( &lt;em&gt;Nota: Puede escribir &lt;code&gt;(*F)&lt;/code&gt; como &lt;code&gt;(*FAIL)&lt;/code&gt; &lt;/em&gt; ), se salta y falla la coincidencia. &lt;code&gt;|&lt;/code&gt; llamado alteraci&amp;oacute;n u operador l&amp;oacute;gico OR agregado al verbo PCRE que coincide con todos los l&amp;iacute;mites existentes entre todos y cada uno de los caracteres en todas las l&amp;iacute;neas, excepto que la l&amp;iacute;nea contiene el &lt;code&gt;hede&lt;/code&gt; de cadena exacto . Vea la demostraci&amp;oacute;n &lt;a href=&quot;http://regex101.com/r/kR0tO2/2&quot;&gt;aqu&amp;iacute;&lt;/a&gt; . Es decir, intenta hacer coincidir los caracteres de la cadena restante. Ahora se ejecutar&amp;iacute;a la expresi&amp;oacute;n regular en la segunda parte.</target>
        </trans-unit>
        <trans-unit id="b7a42192468575a7e5a39750585ef8b488514333" translate="yes" xml:space="preserve">
          <source>So, in my example, every empty string is first validated to see if there's no &lt;code&gt;&quot;hede&quot;&lt;/code&gt; up ahead, before a character is consumed by the &lt;code&gt;.&lt;/code&gt; (dot). The regex &lt;code&gt;(?!hede).&lt;/code&gt; will do that only once, so it is wrapped in a group, and repeated zero or more times: &lt;code&gt;((?!hede).)*&lt;/code&gt;. Finally, the start- and end-of-input are anchored to make sure the entire input is consumed: &lt;code&gt;^((?!hede).)*$&lt;/code&gt;</source>
          <target state="translated">Entonces, en mi ejemplo, cada cadena vac&amp;iacute;a se valida primero para ver si no hay &lt;code&gt;&quot;hede&quot;&lt;/code&gt; m&amp;aacute;s adelante, antes de que el personaje consuma un car&amp;aacute;cter &lt;code&gt;.&lt;/code&gt; (punto). La expresi&amp;oacute;n regular &lt;code&gt;(?!hede).&lt;/code&gt; lo har&amp;aacute; solo una vez, por lo que se envuelve en un grupo y se repite cero o m&amp;aacute;s veces: &lt;code&gt;((?!hede).)*&lt;/code&gt; . Finalmente, el inicio y el final de la entrada est&amp;aacute;n anclados para garantizar que se consuma toda la entrada: &lt;code&gt;^((?!hede).)*$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="f117cb601daa3d4275b6f738d374bfc07fdd9f7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.nongnu.org/txr/&quot;&gt;TXR Language&lt;/a&gt; supports regex negation.</source>
          <target state="translated">El &lt;a href=&quot;http://www.nongnu.org/txr/&quot;&gt;lenguaje TXR&lt;/a&gt; admite la negaci&amp;oacute;n regex.</target>
        </trans-unit>
        <trans-unit id="ebcf6058f2929ecc3e3b08aed979b745665af5ef" translate="yes" xml:space="preserve">
          <source>The OP did not specify or &lt;b&gt;&lt;kbd&gt;Tag&lt;/kbd&gt;&lt;/b&gt; the post to indicate the context (programming language, editor, tool) the Regex will be used within.</source>
          <target state="translated">El OP no especific&amp;oacute; ni &lt;b&gt;&lt;kbd&gt;etiquet&amp;oacute;&lt;/kbd&gt;&lt;/b&gt; la publicaci&amp;oacute;n para indicar el contexto (lenguaje de programaci&amp;oacute;n, editor, herramienta) en el que se utilizar&amp;aacute; Regex.</target>
        </trans-unit>
        <trans-unit id="11aa9db6100b5bf50fd1febfe3c053a2d5441f2d" translate="yes" xml:space="preserve">
          <source>The ^ anchor in the beginning is meant to represent the beginning of the line. The grep tool matches each line one at a time, in contexts where you're working with a multiline string, you can use the &quot;m&quot; flag:</source>
          <target state="translated">El ^ ancla en el principio está destinada a representar el comienzo de la línea.La herramienta grep coincide con cada línea una a una,en los contextos en los que se trabaja con una cadena de varias líneas,se puede usar la bandera &quot;m&quot;:</target>
        </trans-unit>
        <trans-unit id="098ea33d53cc62129cfb7875bd9edba4f4bec259" translate="yes" xml:space="preserve">
          <source>The answer is that with POSIX &lt;code&gt;grep&lt;/code&gt;, it's impossible to literally satisfy this request:</source>
          <target state="translated">La respuesta es que con POSIX &lt;code&gt;grep&lt;/code&gt; , es imposible satisfacer literalmente esta solicitud:</target>
        </trans-unit>
        <trans-unit id="cc27072c8e8fa68ee8a4aecd5fdce94bfeb957de" translate="yes" xml:space="preserve">
          <source>The below function will help you get your desired output</source>
          <target state="translated">La siguiente función le ayudará a obtener el resultado deseado</target>
        </trans-unit>
        <trans-unit id="452667fef7f202d7937567d77ec3043088267fe1" translate="yes" xml:space="preserve">
          <source>The expression is explained on the top right panel of &lt;a href=&quot;https://regex101.com/r/S127jy/1/&quot;&gt;regex101.com&lt;/a&gt;, if you wish to explore/simplify/modify it, and in &lt;a href=&quot;https://regex101.com/r/S127jy/1/debugger&quot;&gt;this link&lt;/a&gt;, you can watch how it would match against some sample inputs, if you like.</source>
          <target state="translated">La expresi&amp;oacute;n se explica en el panel superior derecho de &lt;a href=&quot;https://regex101.com/r/S127jy/1/&quot;&gt;regex101.com&lt;/a&gt; , si desea explorarla / simplificarla / modificarla, y en &lt;a href=&quot;https://regex101.com/r/S127jy/1/debugger&quot;&gt;este enlace&lt;/a&gt; , puede ver c&amp;oacute;mo coincidir&amp;iacute;a con algunas entradas de muestra, si lo desea.</target>
        </trans-unit>
        <trans-unit id="81d959c36f65aa571d1474a3105362386f4bce31" translate="yes" xml:space="preserve">
          <source>The first 7 lines should not match, since they contain the searched Expression, while the lower 7 lines should match!</source>
          <target state="translated">Las primeras 7 líneas no deberían coincidir,ya que contienen la Expresión buscada,mientras que las 7 líneas inferiores deberían coincidir!</target>
        </trans-unit>
        <trans-unit id="30eca3e3a5dee91a29274eb92d118bf760f5f68b" translate="yes" xml:space="preserve">
          <source>The former checks for &amp;ldquo;hede&amp;rdquo; only at the input string&amp;rsquo;s first position, rather than at every position.</source>
          <target state="translated">El primero verifica &quot;hede&quot; solo en la primera posici&amp;oacute;n de la cadena de entrada, en lugar de en cada posici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ec7560158d4afaeca7ad767df676f2c3f8316d2b" translate="yes" xml:space="preserve">
          <source>The given answers are perfectly fine, just an academic point:</source>
          <target state="translated">Las respuestas dadas están perfectamente bien,sólo un punto académico:</target>
        </trans-unit>
        <trans-unit id="2d09bbc95c0bd1eee8d3c6bb5adc11e14f4f00c5" translate="yes" xml:space="preserve">
          <source>The innermost one is for the negative lookahead (it is not a capture group)</source>
          <target state="translated">El más interno es para el lookahead negativo (no es un grupo de captura)</target>
        </trans-unit>
        <trans-unit id="29b7a8c9eb45daf61b377e68a90e0dacca34eb0c" translate="yes" xml:space="preserve">
          <source>The logic of serial grep's is (not a comment) and (matches dir)</source>
          <target state="translated">La lógica del grep de la serie es (no un comentario)y (coincide con dir)</target>
        </trans-unit>
        <trans-unit id="1a96bded5f6ba78d21a0246672404cc4fdf84614" translate="yes" xml:space="preserve">
          <source>The notion that regex doesn't support inverse matching is not entirely true. You can mimic this behavior by using negative look-arounds:</source>
          <target state="translated">La noción de que regex no soporta la comparación inversa no es del todo cierta.Puedes imitar este comportamiento usando miradas negativas:</target>
        </trans-unit>
        <trans-unit id="3854f1c652980feef2e8f16cab154d60899f8027" translate="yes" xml:space="preserve">
          <source>The outermost was interpreted by Ruby as capture group but we don't want it to be a capture group, so I added ?: at it's beginning and it is no longer interpreted as a capture group.</source>
          <target state="translated">El más exterior fue interpretado por Ruby como un grupo de captura,pero no queremos que sea un grupo de captura,así que añadí...al principio y ya no se interpreta como un grupo de captura.</target>
        </trans-unit>
        <trans-unit id="53549eab46883cf85fd1a09e3b5aed26dca85805" translate="yes" xml:space="preserve">
          <source>The reason is that POSIX &lt;code&gt;grep&lt;/code&gt; is only required to work with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003&quot;&gt;Basic Regular Expressions&lt;/a&gt;, which are simply not powerful enough for accomplishing that task (they are not capable of parsing regular languages, because of lack of alternation and parentheses).</source>
          <target state="translated">La raz&amp;oacute;n es que POSIX &lt;code&gt;grep&lt;/code&gt; solo se requiere para trabajar con &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003&quot;&gt;expresiones regulares b&amp;aacute;sicas&lt;/a&gt; , que simplemente no son lo suficientemente potentes para realizar esa tarea (no son capaces de analizar lenguajes regulares, debido a la falta de alternancia y par&amp;eacute;ntesis).</target>
        </trans-unit>
        <trans-unit id="7ecb97c8fab3f5fb0b327ca5ef4661a1a4cf0f1f" translate="yes" xml:space="preserve">
          <source>The regex above will match any string, or line without a line break, &lt;strong&gt;not&lt;/strong&gt; containing the (sub)string 'hede'. As mentioned, this is not something regex is &quot;good&quot; at (or should do), but still, it &lt;em&gt;is&lt;/em&gt; possible.</source>
          <target state="translated">La expresi&amp;oacute;n regular anterior coincidir&amp;aacute; con cualquier cadena o l&amp;iacute;nea sin un salto de l&amp;iacute;nea, que &lt;strong&gt;no&lt;/strong&gt; contenga la (sub) cadena 'hede'. Como se mencion&amp;oacute;, esto no es algo en lo que regex sea &quot;bueno&quot; (o deber&amp;iacute;a hacerlo), pero a&amp;uacute;n as&amp;iacute;, &lt;em&gt;es&lt;/em&gt; posible.</target>
        </trans-unit>
        <trans-unit id="8bc1736cb0d5560815fe759f45e070ec21870289" translate="yes" xml:space="preserve">
          <source>The regex solution at the top of this answer may be helpful, however, in situations where a positive regex test is required (perhaps by an API).</source>
          <target state="translated">La solución de regex que aparece en la parte superior de esta respuesta puede ser útil,sin embargo,en situaciones en las que se requiere una prueba de regex positiva (tal vez por un API).</target>
        </trans-unit>
        <trans-unit id="18d6c0cc722c7bbc3e65fb8a5074dc1d497a9c6b" translate="yes" xml:space="preserve">
          <source>This method is no more efficient than a negative lookahead, but I figured I'd just throw it on here in case someone finds it nifty and finds a use for it for other, more interesting applications.</source>
          <target state="translated">Este método no es más eficiente que una cabeza de chorlito negativo,pero pensé en ponerlo aquí en caso de que alguien lo encuentre ingenioso y le encuentre un uso para otras aplicaciones más interesantes.</target>
        </trans-unit>
        <trans-unit id="3886ebe4339f9490f06300de01ba2a2e949b872b" translate="yes" xml:space="preserve">
          <source>This only does a FULL match. Doing it for sub-matches would even be more awkward.</source>
          <target state="translated">Esto sólo hace una coincidencia completa.Hacerlo por sub-partidos sería aún más incómodo.</target>
        </trans-unit>
        <trans-unit id="e922e950305ed79d2617ae1c8940572582dfcd3e" translate="yes" xml:space="preserve">
          <source>This simplification is ready to have &quot;AND&quot; clauses added:</source>
          <target state="translated">Esta simplificación está lista para que se añadan cláusulas &quot;Y&quot;:</target>
        </trans-unit>
        <trans-unit id="31ba508b83d08df1a58027dfb2ff5193636dcc21" translate="yes" xml:space="preserve">
          <source>This would completely skips the line which contains the exact string &lt;code&gt;hede&lt;/code&gt; and matches all the remaining lines.</source>
          <target state="translated">Esto &lt;code&gt;hede&lt;/code&gt; completo la l&amp;iacute;nea que contiene el hede de cadena exacto y coincide con todas las l&amp;iacute;neas restantes.</target>
        </trans-unit>
        <trans-unit id="bda56a9be7875939dbf47726436cb5a754e198c2" translate="yes" xml:space="preserve">
          <source>Thus, in your case &lt;code&gt;^(?~hede)$&lt;/code&gt; does the job for you</source>
          <target state="translated">Por lo tanto, en su caso &lt;code&gt;^(?~hede)$&lt;/code&gt; hace el trabajo por usted</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="e70838bc7b5ac1d8247c350d535a21945717c6a7" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.conyedit.com&quot;&gt;ConyEdit&lt;/a&gt;, you can use the command line &lt;code&gt;cc.gl !/hede/&lt;/code&gt; to get lines that do not contain the regex matching, or use the command line &lt;code&gt;cc.dl /hede/&lt;/code&gt; to delete lines that contain the regex matching. They have the same result.</source>
          <target state="translated">Con &lt;a href=&quot;https://www.conyedit.com&quot;&gt;ConyEdit&lt;/a&gt; , puede usar la l&amp;iacute;nea de comando &lt;code&gt;cc.gl !/hede/&lt;/code&gt; para obtener l&amp;iacute;neas que no contienen la coincidencia de &lt;code&gt;cc.dl /hede/&lt;/code&gt; regulares, o usar la l&amp;iacute;nea de comando cc.dl / hede / para eliminar las l&amp;iacute;neas que contienen la coincidencia de expresiones regulares. Tienen el mismo resultado.</target>
        </trans-unit>
        <trans-unit id="45f7d6f93e756fe076c6f4d4cc20e5bb4a0af7f1" translate="yes" xml:space="preserve">
          <source>With GNU &lt;code&gt;grep&lt;/code&gt;, the answer would be something like:</source>
          <target state="translated">Con GNU &lt;code&gt;grep&lt;/code&gt; , la respuesta ser&amp;iacute;a algo como:</target>
        </trans-unit>
        <trans-unit id="af3a7829ae5f96bbccfbc07b95bfc1b6818d038b" translate="yes" xml:space="preserve">
          <source>With negative lookahead, regular expression can match something not contains specific pattern. This is answered and explained by Bart Kiers. Great explanation!</source>
          <target state="translated">Con un lookahead negativo,la expresión regular puede coincidir con algo que no contiene un patrón específico.Esto es contestado y explicado por Bart Kiers.¡Gran explicación!</target>
        </trans-unit>
        <trans-unit id="af97db013e5d443d690246871b2054ab1d1ebdfc" translate="yes" xml:space="preserve">
          <source>You can also use a tool that implements &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004&quot;&gt;Extended Regular Expressions&lt;/a&gt;, like &lt;code&gt;egrep&lt;/code&gt;, to get rid of the backslashes:</source>
          <target state="translated">Tambi&amp;eacute;n puede usar una herramienta que implemente &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004&quot;&gt;Expresiones regulares extendidas&lt;/a&gt; , como &lt;code&gt;egrep&lt;/code&gt; , para eliminar las barras invertidas:</target>
        </trans-unit>
        <trans-unit id="3c3ead2f2a71a7f8de04237ee09b7ad0902ae6d3" translate="yes" xml:space="preserve">
          <source>You can see this example &lt;a href=&quot;https://stackoverflow.com/questions/406230&quot;&gt;here&lt;/a&gt;, and try Vcsn online &lt;a href=&quot;http://vcsn-sandbox.lrde.epita.fr/tree&quot;&gt;there&lt;/a&gt;.</source>
          <target state="translated">Puede ver este ejemplo &lt;a href=&quot;https://stackoverflow.com/questions/406230&quot;&gt;aqu&amp;iacute;&lt;/a&gt; y probar Vcsn en l&amp;iacute;nea &lt;a href=&quot;http://vcsn-sandbox.lrde.epita.fr/tree&quot;&gt;all&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9117813c61704c7f607c297794b874af93ed534d" translate="yes" xml:space="preserve">
          <source>You could even put the negation &lt;em&gt;outside&lt;/em&gt; the test if you need any regex features (here, case insensitivity and range matching):</source>
          <target state="translated">Incluso podr&amp;iacute;a poner la negaci&amp;oacute;n &lt;em&gt;fuera de&lt;/em&gt; la prueba si necesita caracter&amp;iacute;sticas de expresiones regulares (aqu&amp;iacute;, insensibilidad a may&amp;uacute;sculas y min&amp;uacute;sculas):</target>
        </trans-unit>
        <trans-unit id="4e3bfb39813e0d54c6b52dba372f9b67a2de3789" translate="yes" xml:space="preserve">
          <source>You first define the type of your expressions: labels are letter (&lt;code&gt;lal_char&lt;/code&gt;) to pick from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; for instance (defining the alphabet when working with complementation is, of course, very important), and the &quot;value&quot; computed for each word is just a Boolean: &lt;code&gt;true&lt;/code&gt; the word is accepted, &lt;code&gt;false&lt;/code&gt;, rejected.</source>
          <target state="translated">Primero define el tipo de sus expresiones: por ejemplo, las etiquetas son letras ( &lt;code&gt;lal_char&lt;/code&gt; ) para elegir de la &lt;code&gt;a&lt;/code&gt; a la &lt;code&gt;z&lt;/code&gt; (definir el alfabeto cuando se trabaja con complementaci&amp;oacute;n es, por supuesto, muy importante), y el &quot;valor&quot; calculado para cada palabra es solo un booleano: &lt;code&gt;true&lt;/code&gt; la palabra es aceptada, &lt;code&gt;false&lt;/code&gt; , rechazado.</target>
        </trans-unit>
        <trans-unit id="8b92e959c52f5c967563185e1dc02103fcdeb744" translate="yes" xml:space="preserve">
          <source>Your &lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt; statement will need to match &quot;contains&quot; and not match &quot;excludes&quot;.</source>
          <target state="translated">Su declaraci&amp;oacute;n &lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt; deber&amp;aacute; coincidir con &quot;contiene&quot; y no con &quot;excluir&quot;.</target>
        </trans-unit>
        <trans-unit id="dc5f45feccd145875695bcee7ec9e44130e5b96f" translate="yes" xml:space="preserve">
          <source>^((?!hede).)*$ is an elegant solution, except since it consumes characters you won't be able to combine it with other criteria. For instance, say you wanted to check for the non-presence of &quot;hede&quot; and the presence of &quot;haha.&quot; This solution would work because it won't consume characters:</source>
          <target state="translated">^((?!hede).)*$ es una solución elegante,excepto porque consume personajes que no podrás combinar con otros criterios.Por ejemplo,digamos que quieres comprobar la no presencia de &quot;hede&quot; y la presencia de &quot;jaja&quot;.Esta solución funcionaría porque no consumirá personajes:</target>
        </trans-unit>
        <trans-unit id="3c24d7c6f693449c71187e2b53fec214d5e24eb3" translate="yes" xml:space="preserve">
          <source>^(?!.&lt;em&gt;\bhede\b)(?=.&lt;/em&gt;\bhaha\b)</source>
          <target state="translated">^(?!.&lt;em&gt;\bhede\b)(?=.&lt;/em&gt;\bhaha\b)</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="89c0d93ef605454f65fa159648fcc4f79d2c32ad" translate="yes" xml:space="preserve">
          <source>as expected.</source>
          <target state="translated">como se esperaba.</target>
        </trans-unit>
        <trans-unit id="78b9b44deba42148afa14f26da3512a067ed3f05" translate="yes" xml:space="preserve">
          <source>convert this expression to an automaton:</source>
          <target state="translated">convertir esta expresión en un autómata:</target>
        </trans-unit>
        <trans-unit id="0c97c3b2e427dd08a2a22afc585bfb112e48c297" translate="yes" xml:space="preserve">
          <source>e.g. -- If you want to allow all values except &quot;foo&quot; (i.e. &quot;foofoo&quot;, &quot;barfoo&quot;, and &quot;foobar&quot; will pass, but &quot;foo&quot; will fail), use: &lt;code&gt;^(?!foo$).*&lt;/code&gt;</source>
          <target state="translated">por ejemplo: si desea permitir todos los valores excepto &quot;foo&quot; (es decir, &quot;foofoo&quot;, &quot;barfoo&quot; y &quot;foobar&quot; pasar&amp;aacute;n, pero &quot;foo&quot; fallar&amp;aacute;), use: &lt;code&gt;^(?!foo$).*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e16583e5292c76975f4ece4ba1b17808d175dd82" translate="yes" xml:space="preserve">
          <source>eg.  search an apache config file without all the comments-</source>
          <target state="translated">por ejemplo,buscar en un archivo de configuración de Apache sin todos los comentarios...</target>
        </trans-unit>
        <trans-unit id="81165d7e6d83159d5242d2e3447560267f5f0a15" translate="yes" xml:space="preserve">
          <source>equivalent to (for .net):</source>
          <target state="translated">equivalente a (para .net):</target>
        </trans-unit>
        <trans-unit id="b9c5a9fb1e9449b3cc8c15f7f902b1d5321d355e" translate="yes" xml:space="preserve">
          <source>finally, convert this automaton back to a simple expression.</source>
          <target state="translated">finalmente,convertir este autómata de nuevo en una simple expresión.</target>
        </trans-unit>
        <trans-unit id="37e4a0d8a8bb537de21f7a46cd439c6814401bfd" translate="yes" xml:space="preserve">
          <source>from the official &lt;a href=&quot;https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f&quot;&gt;doc&lt;/a&gt;</source>
          <target state="translated">del &lt;a href=&quot;https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f&quot;&gt;documento&lt;/a&gt; oficial</target>
        </trans-unit>
        <trans-unit id="52ac93fe88a76f92fd6cbc405e59f5efceaa621f" translate="yes" xml:space="preserve">
          <source>is generally much more efficient than the solution to &lt;strong&gt;does not &lt;em&gt;contain&lt;/em&gt; &amp;ldquo;hede&amp;rdquo;&lt;/strong&gt;:</source>
          <target state="translated">es generalmente mucho m&amp;aacute;s eficiente que la soluci&amp;oacute;n para &lt;strong&gt;que no &lt;em&gt;contenga&lt;/em&gt; &quot;hede&quot;&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="86416a3c88475bb3fd86ea86b3fb79d0fa1fd2ab" translate="yes" xml:space="preserve">
          <source>or use it inline:</source>
          <target state="translated">o utilizarlo en línea:</target>
        </trans-unit>
        <trans-unit id="ca91e5f012d312c0136c2de3497b8aa8ce4a805a" translate="yes" xml:space="preserve">
          <source>then you enter your expression:</source>
          <target state="translated">...y luego se introduce la expresión:</target>
        </trans-unit>
        <trans-unit id="14ff5d9b2a6dee566d29abfb4bfc694ba905fd5b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;+&lt;/code&gt; is usually denoted &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt; denotes the empty word, and &lt;code&gt;[^]&lt;/code&gt; is usually written &lt;code&gt;.&lt;/code&gt; (any character).  So, with a bit of rewriting &lt;code&gt;()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*&lt;/code&gt;.</source>
          <target state="translated">donde &lt;code&gt;+&lt;/code&gt; generalmente se denota &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; denota la palabra vac&amp;iacute;a, y &lt;code&gt;[^]&lt;/code&gt; generalmente se escribe &lt;code&gt;.&lt;/code&gt; (cualquier personaje). Entonces, con un poco de reescritura &lt;code&gt;()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13a0d941cdbf53982cbc548e039164854ba5a26f" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;e&lt;/code&gt;'s are the empty strings. The regex &lt;code&gt;(?!hede).&lt;/code&gt; looks ahead to see if there's no substring &lt;code&gt;&quot;hede&quot;&lt;/code&gt; to be seen, and if that is the case (so something else is seen), then the &lt;code&gt;.&lt;/code&gt; (dot) will match any character except a line break. Look-arounds are also called &lt;em&gt;zero-width-assertions&lt;/em&gt; because they don't &lt;em&gt;consume&lt;/em&gt; any characters. They only assert/validate something.</source>
          <target state="translated">donde las &lt;code&gt;e&lt;/code&gt; son las cadenas vac&amp;iacute;as. La expresi&amp;oacute;n regular &lt;code&gt;(?!hede).&lt;/code&gt; mira hacia adelante para ver si no hay subcadena &lt;code&gt;&quot;hede&quot;&lt;/code&gt; para ver, y si ese es el caso (entonces se ve algo m&amp;aacute;s), entonces el &lt;code&gt;.&lt;/code&gt; (punto) coincidir&amp;aacute; con cualquier car&amp;aacute;cter, excepto un salto de l&amp;iacute;nea. Las miradas tambi&amp;eacute;n se llaman &lt;em&gt;aserciones de ancho cero&lt;/em&gt; porque no &lt;em&gt;consumen&lt;/em&gt; ning&amp;uacute;n car&amp;aacute;cter. Solo afirman / validan algo.</target>
        </trans-unit>
        <trans-unit id="88141f0aa6d0a5c8b71d83d50fe9878477ba508a" translate="yes" xml:space="preserve">
          <source>which is equivalent to the above.</source>
          <target state="translated">que es equivalente a lo anterior.</target>
        </trans-unit>
        <trans-unit id="b3f4587567dd91d6188f1c48f4e79ecf19e09aae" translate="yes" xml:space="preserve">
          <source>with this, you avoid to test a lookahead on each positions:</source>
          <target state="translated">con esto,evitas probar una cabeza de mira en cada posición:</target>
        </trans-unit>
        <trans-unit id="a9f7501a4bb77ecb148f3a5340b3c2a4dc0e6caf" translate="yes" xml:space="preserve">
          <source>with word boundaries.</source>
          <target state="translated">con límites de palabras.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
