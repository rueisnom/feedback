<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/406230">
    <body>
      <group id="406230">
        <trans-unit id="9eb4a6c92e209092a0d12923bf9cc9ff4cb48470" translate="yes" xml:space="preserve">
          <source>(found with &lt;a href=&quot;http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/&quot;&gt;Grail&lt;/a&gt; and some further optimizations made by hand).</source>
          <target state="translated">(найдено с &lt;a href=&quot;http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/&quot;&gt;Grail&lt;/a&gt; и некоторыми дополнительными оптимизациями, сделанными вручную).</target>
        </trans-unit>
        <trans-unit id="2e52af52a8546054dfc6413acff069ef2bc147ca" translate="yes" xml:space="preserve">
          <source>1. Search/replace the entire file to add a unique &quot;Tag&quot; to the beginning of each line containing any text.</source>
          <target state="translated">1.Поиск по всему файлу для добавления уникального &quot;Тега&quot; в начало каждой строки,содержащей любой текст.</target>
        </trans-unit>
        <trans-unit id="e705aab59352280c966865af9240b1976c79fb0c" translate="yes" xml:space="preserve">
          <source>2. Delete all lines that contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt; (replacement string is empty):</source>
          <target state="translated">2. Удалите все строки, содержащие строку &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; (строка замены пуста):</target>
        </trans-unit>
        <trans-unit id="4d5359854c4a837f09da9271b5d18c0d86e98cb7" translate="yes" xml:space="preserve">
          <source>2. For all lines that contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, remove the unique &quot;Tag&quot;:</source>
          <target state="translated">2. Для всех строк, содержащих строку &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; , удалите уникальный &amp;laquo;Tag&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="3a77e275bfbe2978b006ae190f18f26a3701a1f9" translate="yes" xml:space="preserve">
          <source>3. At this point, all lines that begin with the unique &quot;Tag&quot;, &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;. I can now do my &lt;b&gt;&lt;i&gt;Something Else&lt;/i&gt;&lt;/b&gt; to only those lines.</source>
          <target state="translated">3. На этом этапе все строки, начинающиеся с уникального тега, &lt;b&gt;&lt;i&gt;НЕ&lt;/i&gt;&lt;/b&gt; содержат строку &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; . Теперь я могу сделать что- &lt;b&gt;&lt;i&gt;то еще&lt;/i&gt;&lt;/b&gt; только для этих строк.</target>
        </trans-unit>
        <trans-unit id="da9c9c3fd6b8b9646ab8565f22f270096999311b" translate="yes" xml:space="preserve">
          <source>3. At this point, all remaining lines &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;. Remove the unique &quot;Tag&quot; from all lines (replacement string is empty):</source>
          <target state="translated">3. На этом этапе все остальные строки &lt;b&gt;&lt;i&gt;НЕ&lt;/i&gt;&lt;/b&gt; содержат строку &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; . Удалите уникальный &amp;laquo;тег&amp;raquo; из всех строк (строка замены пуста):</target>
        </trans-unit>
        <trans-unit id="c5af5bfa811f56236562a7f528f03723506bbc92" translate="yes" xml:space="preserve">
          <source>4. When I am done, I remove the unique &quot;Tag&quot; from all lines (replacement string is empty):</source>
          <target state="translated">4.Когда я закончил,я удаляю уникальный &quot;Tag&quot; из всех строк (строка замены пуста):</target>
        </trans-unit>
        <trans-unit id="78feb677fcb5b7b33212618320b97f32f0c56503" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://vcsn.lrde.epita.fr&quot;&gt;Vcsn&lt;/a&gt; supports this operator (which it denotes &lt;code&gt;{c}&lt;/code&gt;, postfix).</source>
          <target state="translated">&lt;a href=&quot;http://vcsn.lrde.epita.fr&quot;&gt;Vcsn&lt;/a&gt; поддерживает этот оператор (который он обозначает &lt;code&gt;{c}&lt;/code&gt; , постфикс).</target>
        </trans-unit>
        <trans-unit id="27524e01dd8c223e92fc167f869ddb9c6ea20286" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24&quot;&gt;jex.im&lt;/a&gt; visualizes regular expressions:</source>
          <target state="translated">&lt;a href=&quot;https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24&quot;&gt;jex.im&lt;/a&gt; визуализирует регулярные выражения:</target>
        </trans-unit>
        <trans-unit id="b57eb38c594f4159c8cde8abea030ead596d976b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; Asserts that we are at the line end.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; Утверждает, что мы находимся в конце строки.</target>
        </trans-unit>
        <trans-unit id="52b36ac718178a71145d1ba891ac99338438678c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; End of the line anchor is not necessary here.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; Привязка конца строки здесь не нужна.</target>
        </trans-unit>
        <trans-unit id="5bc93b176a15f9710c8851f5f6d588bd9d60ed13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; before an optional \n, and the end of the string</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; перед необязательным \ n и концом строки</target>
        </trans-unit>
        <trans-unit id="b7c0e80a3bbc4ac75bc1f047ce7b29f9cae01e22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?!&lt;/code&gt; look ahead to see if there is not,</source>
          <target state="translated">&lt;code&gt;(?!&lt;/code&gt; посмотрите вперед, чтобы увидеть, если нет,</target>
        </trans-unit>
        <trans-unit id="13e685cc0a2609aafd47726b3d9c59af6288a725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)*&lt;/code&gt; end of \1   (Note: because you are using a quantifier on this capture, only the LAST repetition of the captured pattern will be stored in \1)</source>
          <target state="translated">&lt;code&gt;)*&lt;/code&gt; конец \ 1 (Примечание: поскольку вы используете квантификатор для этого захвата, в \ 1 будет сохранено только последнее повторение захваченного шаблона)</target>
        </trans-unit>
        <trans-unit id="684f435ac9c437471ef88a255e4938ea502d9f17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; end of look-ahead, 
&lt;code&gt;.&lt;/code&gt; any character except \n,</source>
          <target state="translated">конец просмотра &lt;code&gt;.&lt;/code&gt; любой символ кроме \ n,</target>
        </trans-unit>
        <trans-unit id="75716139a3b0f1db692009b0858a2ebdd5cb3451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.*&lt;/code&gt; In the Multiline mode, &lt;code&gt;.&lt;/code&gt; would match any character except newline or carriage return characters. And &lt;code&gt;*&lt;/code&gt; would repeat the previous character zero or more times. So &lt;code&gt;.*&lt;/code&gt; would match the whole line. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/4&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; В многострочном режиме &lt;code&gt;.&lt;/code&gt; будет соответствовать любому символу, кроме символов новой строки или возврата каретки. И &lt;code&gt;*&lt;/code&gt; будет повторять предыдущий символ ноль или более раз. Итак &lt;code&gt;.*&lt;/code&gt; Будет соответствовать всей строке. Смотрите демо &lt;a href=&quot;http://regex101.com/r/kR0tO2/4&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd00c1d9cc56e5d787782a13e4d330c5944bf7e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/&amp;lt;span(?:(?!bad).)*?&amp;gt;&lt;/code&gt; will match &lt;code&gt;&amp;lt;span class=\&quot;good\&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;span class=\&quot;ugly\&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/&amp;lt;span(?:(?!bad).)*?&amp;gt;&lt;/code&gt; будет соответствовать &lt;code&gt;&amp;lt;span class=\&quot;good\&quot;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;span class=\&quot;ugly\&quot;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de91b3ecf3e66e23675457dbbafca8287427b031" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;  Asserts that we are at the start. ie, it matches all the line starts except the one in the &lt;code&gt;hede&lt;/code&gt; line. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/3&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; Утверждает, что мы в начале. то есть он соответствует всем &lt;code&gt;hede&lt;/code&gt; строки, кроме той, что в строке хеде . Смотрите демо &lt;a href=&quot;http://regex101.com/r/kR0tO2/3&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19f3528c6d690ada198857c36184fef7782bef63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; Asserts that we are at the start.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; Утверждает, что мы в начале.</target>
        </trans-unit>
        <trans-unit id="ca6ec5ae2a05e42e32bda5e3ea41a1c74bef7b3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;the beginning of the string,
&lt;code&gt;(&lt;/code&gt; group and capture to \1 (0 or more times (matching the most amount possible)),</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; начало строки, &lt;code&gt;(&lt;/code&gt; сгруппировать и записать в \ 1 (0 или более раз (соответствует максимально возможному количеству)),</target>
        </trans-unit>
        <trans-unit id="88ef62a0b91eaca8ee49fdab3c971717fd8464d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hede&lt;/code&gt; Matches the string &lt;code&gt;hede&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hede&lt;/code&gt; соответствует струне &lt;code&gt;hede&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1a65ea189e42cc8455fe0afc293a1e00cd3f479" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hede&lt;/code&gt; your string,</source>
          <target state="translated">&lt;code&gt;hede&lt;/code&gt; твоя нить,</target>
        </trans-unit>
        <trans-unit id="d003b960bdb077c1dfe6beb8ce4ca5d1176468dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(where the &lt;code&gt;/.../&lt;/code&gt; are the regex delimiters, i.e., not part of the pattern)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(где &lt;code&gt;/.../&lt;/code&gt; - разделители регулярных выражений, т. е. не являются частью шаблона)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f717ceaec1723443831abf050e1226ab1d95364" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If&lt;/em&gt; you're just using it for grep, you can use &lt;code&gt;grep -v hede&lt;/code&gt; to get all lines which do not contain hede.</source>
          <target state="translated">&lt;em&gt;Если&lt;/em&gt; вы просто используете его для grep, вы можете использовать &lt;code&gt;grep -v hede&lt;/code&gt; , чтобы получить все строки, которые не содержат hede.</target>
        </trans-unit>
        <trans-unit id="201b5844b8586d0c78336f51ab67e7879a440e2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Textpad&lt;/code&gt;&lt;/strong&gt; supports some Regex, but does not support lookahead or lookbehind, so it takes a few steps.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Textpad&lt;/code&gt; &lt;/strong&gt; поддерживает некоторые Regex, но не поддерживает lookahead или lookbehind, поэтому требуется несколько шагов.</target>
        </trans-unit>
        <trans-unit id="c332061cf4bd899460b0a4c0a7eaa14bdb27b163" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Answer:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4780b347f8b966f53592b8d6b23f2c7b9836e63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Details:&lt;/strong&gt; The ^ anchor ensures the regex engine doesn't retry the match at every location in the string, which would match every string.</source>
          <target state="translated">&lt;strong&gt;Детали:&lt;/strong&gt; Якорь ^ гарантирует, что механизм регулярных выражений не повторяет совпадение в каждом месте строки, что соответствует каждой строке.</target>
        </trans-unit>
        <trans-unit id="33a872627b08a5f899edf01305ae93d8a50b8d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Execution of the parts:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Исполнение частей:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9108ede24ec6135336892fdeecab45ae62e7a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Explanation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7844df429e40743092ec192901b82594402fa14d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hey why you added .* instead of .+ ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Эй, почему ты добавил. * Вместо. +?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3f0d81e6aa9f7ffd4a855a16e0040cc0551378b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PART 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ЧАСТЬ 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e8addc8bc7252fbc0e0c5e9141350f92b5f32c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PART 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ЧАСТЬ 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73254be12eadf36210870b716538368a2fedd571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Through PCRE verb &lt;code&gt;(*SKIP)(*F)&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Через глагол PCRE &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6b4aedb6aa5c2789c02d933c0a26fd6986b225b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; I have recently found Kendall Hopkins' excellent &lt;a href=&quot;https://github.com/KendallHopkins/FormalTheory&quot;&gt;FormalTheory&lt;/a&gt; library, written in PHP, which provides a functionality similar to Grail. Using it, and a simplifier written by myself, I've been able to write an online generator of negative regular expressions given an input phrase (only alphanumeric and space characters currently supported): &lt;a href=&quot;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&quot;&gt;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Обновление:&lt;/strong&gt; я недавно нашел превосходную библиотеку &lt;a href=&quot;https://github.com/KendallHopkins/FormalTheory&quot;&gt;FormalTheory&lt;/a&gt; Кендалла Хопкинса, написанную на PHP, которая обеспечивает функциональность, аналогичную Grail. Используя его и написанный мной упрощатель, я смог написать онлайн-генератор отрицательных регулярных выражений с учетом входной фразы (в настоящее время поддерживаются только буквенно-цифровые и пробельные символы): &lt;a href=&quot;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&quot;&gt;http://www.formauri.es/personal/ pgimeno / разное / неигровые-регулярное выражение /&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adb30139018c264605cc9fc4ba28906a625cb041" translate="yes" xml:space="preserve">
          <source>A more complicated example: match all lines that start with &lt;code&gt;a&lt;/code&gt; and end with &lt;code&gt;z&lt;/code&gt;, but do not contain the substring &lt;code&gt;hede&lt;/code&gt;:</source>
          <target state="translated">Более сложный пример: сопоставьте все строки, которые начинаются с &lt;code&gt;a&lt;/code&gt; и заканчиваются на &lt;code&gt;z&lt;/code&gt; , но не содержат подстроку &lt;code&gt;hede&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5a6ebacdd544ad2aebe976aa12b05b25bcb11e5b" translate="yes" xml:space="preserve">
          <source>A simpler solution is to use the not operator &lt;strong&gt;!&lt;/strong&gt;</source>
          <target state="translated">Более простое решение - использовать оператор not &lt;strong&gt;!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd0a50c6415821fc8508d785e47d96d51a7df1f3" translate="yes" xml:space="preserve">
          <source>A string is just a list of &lt;code&gt;n&lt;/code&gt; characters. Before, and after each character, there's an empty string. So a list of &lt;code&gt;n&lt;/code&gt; characters will have &lt;code&gt;n+1&lt;/code&gt; empty strings. Consider the string &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt;:</source>
          <target state="translated">Строка - это просто список из &lt;code&gt;n&lt;/code&gt; символов. До и после каждого символа есть пустая строка. Таким образом, список из &lt;code&gt;n&lt;/code&gt; символов будет иметь &lt;code&gt;n+1&lt;/code&gt; пустых строк. Рассмотрим строку &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99646ae275e2441f59e1131f109b01e70dc81648" translate="yes" xml:space="preserve">
          <source>Accurate and more efficient than the other answers. It implements Friedl's &lt;em&gt;&quot;unrolling-the-loop&quot;&lt;/em&gt; efficiency technique and requires much less backtracking.</source>
          <target state="translated">Точнее и эффективнее других ответов. Он реализует метод эффективности &lt;em&gt;&amp;laquo;развернутой петли&amp;raquo;&lt;/em&gt; Фридла и требует гораздо меньшего возврата.</target>
        </trans-unit>
        <trans-unit id="3cac49dcc87a01e093615798c54dde978759b6c5" translate="yes" xml:space="preserve">
          <source>Aforementioned &lt;code&gt;(?:(?!hede).)*&lt;/code&gt; is great because it can be anchored.</source>
          <target state="translated">Вышеупомянутое &lt;code&gt;(?:(?!hede).)*&lt;/code&gt; потому что это может быть закреплено.</target>
        </trans-unit>
        <trans-unit id="5b055b615dfbba6017949fb1b34a623d48637083" translate="yes" xml:space="preserve">
          <source>Also, please check out &lt;a href=&quot;https://github.com/amobiz/regexgen.js&quot;&gt;RegexGen.js&lt;/a&gt;, a JavaScript Regular Expression Generator that helps to construct complex regular expressions. With RegexGen.js, you can construct the regex in a more readable way:</source>
          <target state="translated">Также ознакомьтесь с &lt;a href=&quot;https://github.com/amobiz/regexgen.js&quot;&gt;RegexGen.js&lt;/a&gt; , генератором регулярных выражений JavaScript, который помогает создавать сложные регулярные выражения. С помощью RegexGen.js вы можете создать регулярное выражение более читабельным способом:</target>
        </trans-unit>
        <trans-unit id="583b84d757cb6a3e09c59142f1d4214fcaef0cf4" translate="yes" xml:space="preserve">
          <source>An, in my opinon, more readable variant of the top answer:</source>
          <target state="translated">В моем opinon,более читабельный вариант верхнего ответа:</target>
        </trans-unit>
        <trans-unit id="4a4878a06e9361751e0c8c9f154eb93373a2d656" translate="yes" xml:space="preserve">
          <source>And if you need to match line break chars as well, use the &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;DOT-ALL modifier&lt;/a&gt; (the trailing &lt;code&gt;s&lt;/code&gt; in the following pattern):</source>
          <target state="translated">И если вам нужно сопоставить и символы разрыва строки, используйте &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;модификатор DOT-ALL&lt;/a&gt; (конечные &lt;code&gt;s&lt;/code&gt; в следующем шаблоне):</target>
        </trans-unit>
        <trans-unit id="815196bdcfbffb0484620f8f7ff2d786b9c04d25" translate="yes" xml:space="preserve">
          <source>Another option is that to add a positive look-ahead and check if &lt;code&gt;hehe&lt;/code&gt; is anywhere in the input line, then we would negate that, with an expression similar to:</source>
          <target state="translated">Другой вариант заключается в том, чтобы добавить положительный прогноз и проверить, находится ли &lt;code&gt;hehe&lt;/code&gt; где-либо во входной строке, тогда мы бы отрицаем это, используя выражение, подобное:</target>
        </trans-unit>
        <trans-unit id="90315245d641776926e97cda6abf2b5d2a47c6aa" translate="yes" xml:space="preserve">
          <source>As you can see, the input &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; will fail because on &lt;code&gt;e3&lt;/code&gt;, the regex &lt;code&gt;(?!hede)&lt;/code&gt; fails (there &lt;em&gt;is&lt;/em&gt;&lt;code&gt;&quot;hede&quot;&lt;/code&gt; up ahead!).</source>
          <target state="translated">Как вы можете видеть, ввод &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; не удастся, потому что на &lt;code&gt;e3&lt;/code&gt; не выполнено регулярное выражение &lt;code&gt;(?!hede)&lt;/code&gt; (впереди &lt;em&gt;есть&lt;/em&gt; &lt;code&gt;&quot;hede&quot;&lt;/code&gt; !).</target>
        </trans-unit>
        <trans-unit id="14f0d43928a101b17017ac03b48125ba0258064c" translate="yes" xml:space="preserve">
          <source>Basically, &quot;match at the beginning of the line if and only if it does not have 'hede' in it&quot; - so the requirement translated almost directly into regex.</source>
          <target state="translated">В принципе,&quot;соответствовать в начале строки,если и только если в ней нет &quot;хеде&quot;&quot;-так требование переводилось почти непосредственно в регекс.</target>
        </trans-unit>
        <trans-unit id="b76db96cf2a32f41f46b8568c9c2f6995d10c7a9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.*&lt;/code&gt; would match a blank line but &lt;code&gt;.+&lt;/code&gt; won't match a blank. We want to match all the lines except &lt;code&gt;hede&lt;/code&gt; , there may be a possibility of blank lines also in the input . so you must use &lt;code&gt;.*&lt;/code&gt; instead of &lt;code&gt;.+&lt;/code&gt; . &lt;code&gt;.+&lt;/code&gt; would repeat the previous character one or more times. See &lt;code&gt;.*&lt;/code&gt; matches a blank line &lt;a href=&quot;http://regex101.com/r/kR0tO2/5&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Потому что &lt;code&gt;.*&lt;/code&gt; Будет соответствовать пустой строке, но &lt;code&gt;.+&lt;/code&gt; Не будет соответствовать пустой. Мы хотим сопоставить все строки, кроме &lt;code&gt;hede&lt;/code&gt; , может быть также возможность появления пустых строк на входе. поэтому вы должны использовать &lt;code&gt;.*&lt;/code&gt; вместо &lt;code&gt;.+&lt;/code&gt; . &lt;code&gt;.+&lt;/code&gt; будет повторять предыдущий символ один или несколько раз. См &lt;code&gt;.*&lt;/code&gt; Соответствует пустой строке &lt;a href=&quot;http://regex101.com/r/kR0tO2/5&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6f977a9521045923d16f98954c616fecb8c843e" translate="yes" xml:space="preserve">
          <source>Benchmark Text:</source>
          <target state="translated">Текст закладки:</target>
        </trans-unit>
        <trans-unit id="4f46ac72b3634f96c6860b1ed26d9d4cd71d21aa" translate="yes" xml:space="preserve">
          <source>Benchmarks</source>
          <target state="translated">Benchmarks</target>
        </trans-unit>
        <trans-unit id="b3d97f68b4c000dbfe8c7d755739582257de96d6" translate="yes" xml:space="preserve">
          <source>But the following would suffice in this case:</source>
          <target state="translated">Но в этом случае достаточно следующего:</target>
        </trans-unit>
        <trans-unit id="9c556257951e2f974fa9f074f2d437367d7b7de5" translate="yes" xml:space="preserve">
          <source>But the overall most readable and performance-wise fastest solution seems to be 05 using a conditional statement
or 04 with the possesive quantifier. I think the Perl solutions should be even faster and more easily readable.</source>
          <target state="translated">Но в целом самым быстрым решением с точки зрения читаемости и производительности кажется 05 с использованием условного оператора или 04 с обладающим квантификатором.Я думаю,что решения на Perl должны быть еще более быстрыми и легко читаемыми.</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="038bc41a7c6c6423fba68ab38e1243e0673eb5b1" translate="yes" xml:space="preserve">
          <source>DEMO</source>
          <target state="translated">DEMO</target>
        </trans-unit>
        <trans-unit id="0b308b0064ee9df9865833a93aaf9d02316a25a9" translate="yes" xml:space="preserve">
          <source>Demo in Ruby:</source>
          <target state="translated">Демонстрация в Руби:</target>
        </trans-unit>
        <trans-unit id="2668fed25786577ef5330fbb43aa5160b5fce977" translate="yes" xml:space="preserve">
          <source>Desired output:</source>
          <target state="translated">Желаемый выход:</target>
        </trans-unit>
        <trans-unit id="22ed035c38e99c0a0525f1aa14558f382586a7e4" translate="yes" xml:space="preserve">
          <source>Do not use:</source>
          <target state="translated">Не используйте:</target>
        </trans-unit>
        <trans-unit id="8248c9f017b2a661d23671bd60ce72132eb021cd" translate="yes" xml:space="preserve">
          <source>ETA Oh, rereading the question, &lt;code&gt;grep -v&lt;/code&gt; is probably what you meant by &quot;tools options&quot;.</source>
          <target state="translated">ETA О, перечитывая вопрос, &lt;code&gt;grep -v&lt;/code&gt; - это, вероятно, то, что вы имели в виду под &quot;настройками инструментов&quot;.</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="38d08890b5b368e55863bf943b6b9078a77b395b" translate="yes" xml:space="preserve">
          <source>FWIW, since regular languages (aka rational languages) are closed under complementation, it's always possible to find a regular expression (aka rational expression) that negates another expression. But not many tools implement this.</source>
          <target state="translated">FWIW,так как регулярные языки (так называемые рациональные языки)закрываются при дополнении,всегда можно найти регулярное выражение (так называемое рациональное выражение),которое отрицает другое выражение.Но не многие инструменты реализуют это.</target>
        </trans-unit>
        <trans-unit id="94a4158640ead0903e4198248cdd279ee4bf592b" translate="yes" xml:space="preserve">
          <source>Finally, as everyone has noted, if your regular expression engine supports negative lookahead, that simplifies the task a lot. For example, with GNU grep:</source>
          <target state="translated">Наконец,как все отмечали,если ваш движок регулярных выражений поддерживает негативный взгляд,то это значительно упрощает задачу.Например,с помощью GNU grep:</target>
        </trans-unit>
        <trans-unit id="e7840fc67eb63c0fc62b3bb9275d4ae78f58cc36" translate="yes" xml:space="preserve">
          <source>First, it tries to find &quot;hede&quot; somewhere in the line. If successful, at this point, &lt;code&gt;(*COMMIT)&lt;/code&gt; tells the engine to, not only not backtrack in the event of a failure, but also not to attempt any further matching in that case. Then, we try to match something that cannot possibly match (in this case, &lt;code&gt;^&lt;/code&gt;).</source>
          <target state="translated">Сначала он пытается найти &amp;laquo;хеде&amp;raquo; где-то в очереди. В случае успеха на этом этапе &lt;code&gt;(*COMMIT)&lt;/code&gt; сообщает движку не только не возвращаться в случае сбоя, но и не пытаться выполнить дальнейшее сопоставление в этом случае. Затем мы пытаемся сопоставить что-то, что не может совпадать (в данном случае &lt;code&gt;^&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="66fd11bbda1e7cb077ac7a5170f9d22cd9e79e06" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;hede&lt;/code&gt; it outputs:</source>
          <target state="translated">Для &lt;code&gt;hede&lt;/code&gt; это выводит:</target>
        </trans-unit>
        <trans-unit id="c7cb8f31d0f67cada2b023061ce292ebd71188db" translate="yes" xml:space="preserve">
          <source>For example, a string:</source>
          <target state="translated">Например,строка:</target>
        </trans-unit>
        <trans-unit id="44957a991234be8e9df9fa75f2eb494f5b1a8eed" translate="yes" xml:space="preserve">
          <source>For me, I sometimes need to do this while editing a file using &lt;strong&gt;&lt;code&gt;Textpad&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Для меня иногда нужно сделать это при редактировании файла с помощью &lt;strong&gt; &lt;code&gt;Textpad&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ce940869d506a887a010eb773ba2c6af358bf25a" translate="yes" xml:space="preserve">
          <source>For more information about lookahead, please check out the great article: &lt;a href=&quot;http://www.rexegg.com/regex-lookarounds.html&quot;&gt;Mastering Lookahead and Lookbehind&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации о Lookahead, пожалуйста, прочитайте большую статью: &lt;a href=&quot;http://www.rexegg.com/regex-lookarounds.html&quot;&gt;Освоение Lookahead и Lookbehind&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c25f2278c3b324ffc728c690b8635beda0a6a6d1" translate="yes" xml:space="preserve">
          <source>For those interested in the details, the technique employed is to convert the regular expression that matches the word into a finite automaton, then invert the automaton by changing every acceptance state to non-acceptance and vice versa, and then converting the resulting FA back to a regular expression.</source>
          <target state="translated">Для тех,кто интересуется деталями,используется техника преобразования регулярного выражения,совпадающего со словом,в конечный автомат,затем инвертирование автомата путем изменения каждого состояния принятия на непринятие и наоборот,а затем преобразование полученного ФА обратно в регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="e3b647855c42983ecd846d1757dfd4687da23b1b" translate="yes" xml:space="preserve">
          <source>Given a string: 
&lt;code&gt;
&amp;lt;span class=&quot;good&quot;&amp;gt;bar&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;bad&quot;&amp;gt;foo&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ugly&quot;&amp;gt;baz&amp;lt;/span&amp;gt;
&lt;/code&gt;</source>
          <target state="translated">Имеется строка: &lt;code&gt; &amp;lt;span class=&quot;good&quot;&amp;gt;bar&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;bad&quot;&amp;gt;foo&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ugly&quot;&amp;gt;baz&amp;lt;/span&amp;gt; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a41b37dc9eb2f2ea1a88a659b705994f14fc76f" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;http://jsfiddle.net/pvJL5/3/&quot;&gt;demo code&lt;/a&gt;.</source>
          <target state="translated">Вот &lt;a href=&quot;http://jsfiddle.net/pvJL5/3/&quot;&gt;демонстрационный код&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="440b25c25e75becc55b449c73a3491fe97d861e4" translate="yes" xml:space="preserve">
          <source>Here is the improved regex:</source>
          <target state="translated">Вот улучшенный регекс:</target>
        </trans-unit>
        <trans-unit id="9a9a8952516d81a0b39d9122ade38c17c2ed9060" translate="yes" xml:space="preserve">
          <source>Here's &lt;a href=&quot;http://www.perlmonks.org/?node_id=588315#588368&quot;&gt;a good explanation&lt;/a&gt; of why it's not easy to negate an arbitrary regex. I have to agree with the other answers, though: if this is anything other than a hypothetical question, then a regex is not the right choice here.</source>
          <target state="translated">Вот &lt;a href=&quot;http://www.perlmonks.org/?node_id=588315#588368&quot;&gt;хорошее объяснение&lt;/a&gt; того, почему нелегко отрицать произвольное регулярное выражение. Однако я должен согласиться с другими ответами: если это не гипотетический вопрос, тогда регулярное выражение не является правильным выбором.</target>
        </trans-unit>
        <trans-unit id="ddaef8476b8e3acafac4825d7b8f1ac998e71f92" translate="yes" xml:space="preserve">
          <source>Here's a method that I haven't seen used before:</source>
          <target state="translated">Вот метод,который я раньше не видел:</target>
        </trans-unit>
        <trans-unit id="1dff1040ef948d2545fd38f5ddc5048a75c98520" translate="yes" xml:space="preserve">
          <source>Here's a script to test it (note it generates a file &lt;code&gt;testinput.txt&lt;/code&gt; in the current directory):</source>
          <target state="translated">Вот скрипт для его проверки (обратите внимание, что он генерирует файл &lt;code&gt;testinput.txt&lt;/code&gt; в текущем каталоге):</target>
        </trans-unit>
        <trans-unit id="5f28c2737b2f0e2188d8328f330fac2b15157b53" translate="yes" xml:space="preserve">
          <source>Here's how I'd do it:</source>
          <target state="translated">Вот как бы я это сделал:</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">Как это работает</target>
        </trans-unit>
        <trans-unit id="af4b2da81f792f5da8904c48f25a28f04b5d9a3c" translate="yes" xml:space="preserve">
          <source>How to use PCRE's backtracking control verbs to match a line not containing a word</source>
          <target state="translated">Как использовать контрольные глаголы PCRE для сопоставления со строкой,не содержащей слова</target>
        </trans-unit>
        <trans-unit id="358f19a96883463715eb0b8d693998ffb417eb35" translate="yes" xml:space="preserve">
          <source>However, GNU &lt;code&gt;grep&lt;/code&gt; implements extensions that allow it. In particular, &lt;code&gt;\|&lt;/code&gt; is the alternation operator in GNU's implementation of BREs, and &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; are the parentheses. If your regular expression engine supports alternation, negative bracket expressions, parentheses and the Kleene star, and is able to anchor to the beginning and end of the string, that's all you need for this approach. Note however that negative sets &lt;code&gt;[^ ... ]&lt;/code&gt; are very convenient in addition to those, because otherwise, you need to replace them with an expression of the form &lt;code&gt;(a|b|c| ... )&lt;/code&gt; that lists every character that is not in the set, which is extremely tedious and overly long, even more so if the whole character set is Unicode.</source>
          <target state="translated">Однако GNU &lt;code&gt;grep&lt;/code&gt; реализует расширения, которые позволяют это. В частности, &lt;code&gt;\|&lt;/code&gt; является оператором чередования в реализации BRE в GNU, а &lt;code&gt;\(&lt;/code&gt; и &lt;code&gt;\)&lt;/code&gt; - круглые скобки. Если ваш механизм регулярных выражений поддерживает чередование, выражения с отрицательными скобками, круглые скобки и звездочку Клини и может привязывать начало и конец строки, это все, что вам нужно для этого подхода. Обратите внимание, что отрицательные множества &lt;code&gt;[^ ... ]&lt;/code&gt; очень удобны в дополнение к тем, потому что в противном случае вам нужно заменить их выражением формы &lt;code&gt;(a|b|c| ... )&lt;/code&gt; котором перечислены все символы, которые не в наборе, который является чрезвычайно утомительным и чрезмерно длинным, тем более, если весь набор символов - Unicode.</target>
        </trans-unit>
        <trans-unit id="87fce9ed530df5073b27f7dc4a7cb8a5bddaceaa" translate="yes" xml:space="preserve">
          <source>However, with Bart Kiers' answer, the lookahead part will test 1 to 4 characters ahead while matching any single character. We can avoid this and let the lookahead part check out the whole text, ensure there is no 'hede', and then the normal part (.*) can eat the whole text all at one time.</source>
          <target state="translated">Однако,с ответом Барта Киерса,часть обзора будет тестировать от 1 до 4 символов впереди при совпадении любого одного символа.Мы можем избежать этого и позволить обзорной части проверить весь текст,убедиться,что нет 'hede',а затем обычная часть (.*)может съесть весь текст за один раз.</target>
        </trans-unit>
        <trans-unit id="358d0378b2ab94ec8627f21e6e089dabbbed421a" translate="yes" xml:space="preserve">
          <source>I believe the designers of RegEx anticipated the use of not operators.</source>
          <target state="translated">Я считаю,что разработчики компании RegEx ожидали использования не операторов.</target>
        </trans-unit>
        <trans-unit id="e798d46c6cfecdfa243d565a95292a06448c5bd4" translate="yes" xml:space="preserve">
          <source>I decided to evaluate some of the presented Options and compare their performance, as well as use some new Features.
Benchmarking on .NET Regex Engine: &lt;a href=&quot;http://regexhero.net/tester/&quot;&gt;http://regexhero.net/tester/&lt;/a&gt;</source>
          <target state="translated">Я решил оценить некоторые из представленных опций и сравнить их производительность, а также использовать некоторые новые функции. Сравнительный анализ на .NET Regex Engine: &lt;a href=&quot;http://regexhero.net/tester/&quot;&gt;http://regexhero.net/tester/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa66090b531a3943e8315caeac17d53e7fa5772a" translate="yes" xml:space="preserve">
          <source>I know it's possible to match a word and then reverse the matches using other tools (e.g. &lt;code&gt;grep -v&lt;/code&gt;). However, is it possible to match lines that do not contain a specific word, e.g. &lt;code&gt;hede&lt;/code&gt;, using a regular expression?</source>
          <target state="translated">Я знаю, что можно сопоставить слово, а затем отменить совпадения, используя другие инструменты (например, &lt;code&gt;grep -v&lt;/code&gt; ). Однако можно ли сопоставить строки, которые не содержат определенного слова, например &lt;code&gt;hede&lt;/code&gt; , с помощью регулярного выражения?</target>
        </trans-unit>
        <trans-unit id="4065441f68e9c6020ab5a572b3efff079b3598f2" translate="yes" xml:space="preserve">
          <source>I tried to test most proposed solutions, some Optimizations are possible for certain words.
For Example if the First two letters of the search string are not the Same, answer 03 can be expanded to
&lt;code&gt;^(?&amp;gt;[^R]+|R+(?!egex Hero))*$&lt;/code&gt; resulting in a small performance gain.</source>
          <target state="translated">Я пытался протестировать большинство предложенных решений, возможна некоторая оптимизация для определенных слов. Например, если первые две буквы строки поиска не совпадают, ответ 03 можно расширить до &lt;code&gt;^(?&amp;gt;[^R]+|R+(?!egex Hero))*$&lt;/code&gt; приведет к небольшому приросту производительности.</target>
        </trans-unit>
        <trans-unit id="55152e4cb8b05e2398aff1b805ef864a7498c807" translate="yes" xml:space="preserve">
          <source>I want to match &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; tags which do not contain the substring &quot;bad&quot;.</source>
          <target state="translated">Я хочу сопоставить теги &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; , которые не содержат подстроку &amp;laquo;плохо&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="348fdb226d122d58a879e94920244cb659c2ff80" translate="yes" xml:space="preserve">
          <source>If I am looking to &lt;b&gt;&lt;i&gt;Do Something Else&lt;/i&gt;&lt;/b&gt; to only lines that &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, I would do it like this:</source>
          <target state="translated">Если я хочу &lt;b&gt;&lt;i&gt;сделать что-то еще&lt;/i&gt;&lt;/b&gt; только для строк, которые &lt;b&gt;&lt;i&gt;НЕ&lt;/i&gt;&lt;/b&gt; содержат строку &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; , я бы сделал это так:</target>
        </trans-unit>
        <trans-unit id="38622a9faba8a5ee89d14dd8753c178ec7f57e80" translate="yes" xml:space="preserve">
          <source>If I am looking to retain all lines that &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, I would do it like this:</source>
          <target state="translated">Если я хочу сохранить все строки, которые &lt;b&gt;&lt;i&gt;НЕ&lt;/i&gt;&lt;/b&gt; содержат строку &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; , я бы сделал это следующим образом:</target>
        </trans-unit>
        <trans-unit id="38763d6f5618ba3862a9ce1d1f4a6b9b7ba82b1e" translate="yes" xml:space="preserve">
          <source>If a line does not contain &quot;hede&quot; then the second alternative, an empty subpattern, successfully matches the subject string.</source>
          <target state="translated">Если строка не содержит &quot;hede&quot;,то вторая альтернатива,пустая подмаска,успешно совпадает с тематической строкой.</target>
        </trans-unit>
        <trans-unit id="d412617b77836527f5a7b6be35bc1f03d6769b94" translate="yes" xml:space="preserve">
          <source>If the DOT-ALL modifier is not available, you can mimic the same behavior with the character class &lt;code&gt;[\s\S]&lt;/code&gt;:</source>
          <target state="translated">Если модификатор DOT-ALL недоступен, вы можете имитировать то же поведение с классом символов &lt;code&gt;[\s\S]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="92f26649c4516946fcb1add8c4a8263d3b34b2bf" translate="yes" xml:space="preserve">
          <source>If you want the regex test to &lt;strong&gt;only&lt;/strong&gt; fail if the &lt;em&gt;entire string&lt;/em&gt; matches, the following will work:</source>
          <target state="translated">Если вы хотите, чтобы тест регулярного выражения завершился неудачей, &lt;strong&gt;только&lt;/strong&gt; если &lt;em&gt;вся строка&lt;/em&gt; совпадает, будет работать следующее:</target>
        </trans-unit>
        <trans-unit id="729b36879bb4e3767c9a57246277a86e711573a2" translate="yes" xml:space="preserve">
          <source>If you want to match a character to negate a word similar to negate character class:</source>
          <target state="translated">Если вы хотите сопоставить символ,чтобы опровергнуть слово,аналогичное опровержению класса символов:</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="translated">В Питоне:</target>
        </trans-unit>
        <trans-unit id="f1be7176418bc2ec420699af8dfcaafdad7421f0" translate="yes" xml:space="preserve">
          <source>In my system it prints:</source>
          <target state="translated">В моей системе он печатает:</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">Input:</target>
        </trans-unit>
        <trans-unit id="70b4e36c7616180b6c9127dc59657f047a94fe8b" translate="yes" xml:space="preserve">
          <source>It may be more maintainable to two regexes in your code, one to do the first match, and then if it matches run the second regex to check for outlier cases you wish to block for example &lt;code&gt;^.*(hede).*&lt;/code&gt; then have appropriate logic in your code.</source>
          <target state="translated">Это может быть более удобным для двух регулярных выражений в вашем коде, один для первого сопоставления, а затем, если он совпадает, запустите второе регулярное выражение, чтобы проверить наличие выбросов, которые вы хотите заблокировать, например, &lt;code&gt;^.*(hede).*&lt;/code&gt; Затем имеют соответствующие логика в вашем коде.</target>
        </trans-unit>
        <trans-unit id="619838c3b0a02408fab5aaa30829a7d4c40bef84" translate="yes" xml:space="preserve">
          <source>Let us consider the above regex by splitting it into two parts.</source>
          <target state="translated">Рассмотрим вышеприведенный регекс,разделив его на две части.</target>
        </trans-unit>
        <trans-unit id="5395b8e8626e7f4b1fd55874dc85b6775aa31200" translate="yes" xml:space="preserve">
          <source>Maybe you'll find this on Google while trying to write a regex that is able to match segments of a line (as opposed to entire lines) which do &lt;strong&gt;not&lt;/strong&gt; contain a substring. Tooke me a while to figure out, so I'll share:</source>
          <target state="translated">Возможно, вы найдете это в Google, пытаясь написать регулярное выражение, способное сопоставлять сегменты строки (в отличие от целых строк), которые &lt;strong&gt;не&lt;/strong&gt; содержат подстроки. Уделите мне немного времени, чтобы понять, поэтому я поделюсь</target>
        </trans-unit>
        <trans-unit id="f65015b6743116c0d591a6ecf9d76f8aaa121c4e" translate="yes" xml:space="preserve">
          <source>Not regex, but I've found it logical and useful to use serial greps with pipe to eliminate noise.</source>
          <target state="translated">Не регекс,но я нашел логичным и полезным использование серийных смазок с трубой для устранения шума.</target>
        </trans-unit>
        <trans-unit id="081045e6b01eadb48d20a103dbb36df17d72fe50" translate="yes" xml:space="preserve">
          <source>Note that the solution to &lt;strong&gt;does not &lt;em&gt;start with&lt;/em&gt; &amp;ldquo;hede&amp;rdquo;&lt;/strong&gt;:</source>
          <target state="translated">Обратите внимание, что решение &lt;strong&gt;не &lt;em&gt;начинается с&lt;/em&gt; &amp;laquo;хеде&amp;raquo;&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="26b82927c1805e4c7847c9a3577899e346640e6a" translate="yes" xml:space="preserve">
          <source>Note the (*?) lazy quantifier in the negative lookahead part is optional, you can use (*) greedy quantifier instead, depending on your data: if 'hede' does present and in the beginning half of the text, the lazy quantifier can be faster; otherwise, the greedy quantifier be faster. However if 'hede' does not present, both would be equal slow.</source>
          <target state="translated">Обратите внимание,что (*?)ленивый квантификатор в отрицательной части выглядит необязательно,вы можете использовать (*)жадный квантификатор вместо него,в зависимости от ваших данных:если 'hede' присутствует и в начальной части текста,ленивый квантификатор может быть быстрее;в противном случае,жадный квантификатор может быть быстрее.Однако,если &quot;hede&quot; не присутствует,оба квантификатора будут одинаково медленными.</target>
        </trans-unit>
        <trans-unit id="0e9a29d02e68bcb3679deea8d109eb179570c686" translate="yes" xml:space="preserve">
          <source>Notice &lt;code&gt;&quot;(?!bbb).&quot;&lt;/code&gt; is neither lookbehind nor lookahead, it's lookcurrent, for example:</source>
          <target state="translated">Обратите внимание &lt;code&gt;&quot;(?!bbb).&quot;&lt;/code&gt; это не взгляд назад и не взгляд вперед, это взгляд тока, например:</target>
        </trans-unit>
        <trans-unit id="30d37c9788dcecf1fad3016f170ca9201ffa1d65" translate="yes" xml:space="preserve">
          <source>Notice that there are two sets (layers) of parentheses:</source>
          <target state="translated">Обратите внимание,что существует два набора (слоя)скобок:</target>
        </trans-unit>
        <trans-unit id="a86f480c07344c42ab876520a48514924063ed70" translate="yes" xml:space="preserve">
          <source>Now you have the original text with all lines containing the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt; removed.</source>
          <target state="translated">Теперь у вас есть оригинальный текст со всеми строками, содержащими &lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dcc9367c99afe75c60c7432ea228375c0eed703b" translate="yes" xml:space="preserve">
          <source>OK, I admit this is not really an answer to the posted question posted and it may also use slightly more processing than a single regex. But for developers who came here looking for a fast emergency fix for an outlier case then this solution should not be overlooked.</source>
          <target state="translated">Хорошо,я признаю,что это не совсем ответ на заданный вопрос,и он также может использовать чуть больше обработки,чем один регекс.Но для разработчиков,которые пришли сюда в поисках быстрого экстренного исправления для случая выброса,то это решение не должно быть упущено из виду.</target>
        </trans-unit>
        <trans-unit id="b217bc7b14d3698eeeed95b262a2782958f75640" translate="yes" xml:space="preserve">
          <source>Of course, if you're checking for &lt;em&gt;exact&lt;/em&gt; equality, a better general solution in this case is to check for string equality, i.e.</source>
          <target state="translated">Конечно, если вы проверяете &lt;em&gt;точное&lt;/em&gt; равенство, лучшим общим решением в этом случае является проверка на равенство строк, т.е.</target>
        </trans-unit>
        <trans-unit id="92e4e642b4116921153d765748bceeb2a5d28218" translate="yes" xml:space="preserve">
          <source>Of course, it's possible to have multiple failure requirements:</source>
          <target state="translated">Конечно,можно иметь несколько требований к отказам:</target>
        </trans-unit>
        <trans-unit id="1676b6642119a6e78e273b06ef382dc642a9b8c8" translate="yes" xml:space="preserve">
          <source>Old answer:</source>
          <target state="translated">Старый ответ:</target>
        </trans-unit>
        <trans-unit id="c25c62a5bc188579d5d23849efc8f31cf2a447d1" translate="yes" xml:space="preserve">
          <source>Part after the &lt;code&gt;|&lt;/code&gt; symbol. Part &lt;strong&gt;should be matched&lt;/strong&gt;.</source>
          <target state="translated">Часть после &lt;code&gt;|&lt;/code&gt; условное обозначение. Часть &lt;strong&gt;должна соответствовать&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="73b61b7b35a3691f94481b52b729efe8e43baadb" translate="yes" xml:space="preserve">
          <source>Part before the &lt;code&gt;|&lt;/code&gt; symbol. Part &lt;strong&gt;shouldn't be matched&lt;/strong&gt;.</source>
          <target state="translated">Часть до &lt;code&gt;|&lt;/code&gt; условное обозначение. Часть &lt;strong&gt;не должна совпадать&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d7ae9fea9116fab8d5be9f40e43c9fe24123c8e9" translate="yes" xml:space="preserve">
          <source>RegEx Circuit</source>
          <target state="translated">RegEx Цепь</target>
        </trans-unit>
        <trans-unit id="41676a1dc090860fb04559a11f57d002c96d15af" translate="yes" xml:space="preserve">
          <source>Regex engine will start its execution from the first part.</source>
          <target state="translated">Регекс-движок начнет свое исполнение с первой части.</target>
        </trans-unit>
        <trans-unit id="71546fc265910c3ba4c3a0c33a7cfa6a7c857490" translate="yes" xml:space="preserve">
          <source>Regex negation is not particularly useful on its own but when you also have intersection, things get interesting, since you have a full set of boolean set operations: you can express &quot;the set which matches this, except for things which match that&quot;.</source>
          <target state="translated">Отрицание регекса само по себе не особенно полезно,но когда вы также имеете пересечение,вещи становятся интересными,так как у вас есть полный набор операций с булевыми множествами:вы можете выразить &quot;множество,которое соответствует этому,за исключением вещей,которые соответствуют этому&quot;.</target>
        </trans-unit>
        <trans-unit id="19997c21128f333f226b26bb698b36f34117927e" translate="yes" xml:space="preserve">
          <source>Regular Expressions in the meaning of theoretical computer sciences &lt;em&gt;ARE NOT ABLE&lt;/em&gt; do it like this. For them it had to look something like this:</source>
          <target state="translated">Регулярные выражения в значении теоретических компьютерных наук &lt;em&gt;НЕ МОГУТ&lt;/em&gt; делать это так. Для них это должно было выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="af38a3c1a9ef260f4705cde91de11408ba9cc3b3" translate="yes" xml:space="preserve">
          <source>Regular expression to match a line that doesn't contain a word</source>
          <target state="translated">Регулярное выражение,которое соответствует строке,не содержащей слова.</target>
        </trans-unit>
        <trans-unit id="e9a6ae937eb3ddd638ffc636c1c42607a3fc5a93" translate="yes" xml:space="preserve">
          <source>Results are Iterations per second as the median of 3 runs - &lt;strong&gt;Bigger Number = Better&lt;/strong&gt;</source>
          <target state="translated">Результатами являются итерации в секунду в качестве медианы 3 прогонов - &lt;strong&gt;большее число = лучшее&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="2a8fa741fc245177c287037e3934f7b7d34f2900" translate="yes" xml:space="preserve">
          <source>Since .NET doesn't support action Verbs (*FAIL, etc.) I couldn't test the solutions P1 and P2.</source>
          <target state="translated">Поскольку .NET не поддерживает действие Verbs (*FAIL и т.д.),я не смог протестировать решения P1 и P2.</target>
        </trans-unit>
        <trans-unit id="6e8ae50092c4781a2d7e2ceca8e2bcb82f39e2eb" translate="yes" xml:space="preserve">
          <source>Since no one else has given a direct answer to the question &lt;em&gt;that was asked&lt;/em&gt;, I'll do it.</source>
          <target state="translated">Поскольку никто другой не дал прямого ответа на заданный &lt;em&gt;вопрос&lt;/em&gt; , я сделаю это.</target>
        </trans-unit>
        <trans-unit id="a53ab784ceaf12bbfbc9f16efc79e5e24d16d2c3" translate="yes" xml:space="preserve">
          <source>Since the introduction of ruby-2.4.1, we can use the new &lt;a href=&quot;https://github.com/k-takata/Onigmo/issues/82&quot;&gt;Absent Operator&lt;/a&gt; in Ruby&amp;rsquo;s Regular Expressions</source>
          <target state="translated">С момента появления ruby-2.4.1 мы можем использовать новый &lt;a href=&quot;https://github.com/k-takata/Onigmo/issues/82&quot;&gt;оператор Absent&lt;/a&gt; в регулярных выражениях Ruby.</target>
        </trans-unit>
        <trans-unit id="1692e723845d6b6032f0c8d3b96f35a2c9ce70d7" translate="yes" xml:space="preserve">
          <source>So the line which contains the string &lt;code&gt;hede&lt;/code&gt; would be matched. Once the regex engine sees the following &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; (&lt;em&gt;Note: You could write &lt;code&gt;(*F)&lt;/code&gt; as &lt;code&gt;(*FAIL)&lt;/code&gt;&lt;/em&gt;) verb, it skips and make the match to fail. &lt;code&gt;|&lt;/code&gt; called alteration or logical OR operator added next to the PCRE verb which inturn matches all the boundaries exists between each and every character on all the lines except the line contains the exact string &lt;code&gt;hede&lt;/code&gt;. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/2&quot;&gt;here&lt;/a&gt;. That is, it tries to match the characters from the remaining string. Now the regex in the second part would be executed.</source>
          <target state="translated">Таким образом, строка, содержащая строку &lt;code&gt;hede&lt;/code&gt; , будет сопоставлена. Как только механизм регулярных выражений видит следующий &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; ( &lt;em&gt;Примечание: вы можете написать &lt;code&gt;(*F)&lt;/code&gt; как &lt;code&gt;(*FAIL)&lt;/code&gt; &lt;/em&gt; ) глагол, он пропускает и делает совпадение неудачным. &lt;code&gt;|&lt;/code&gt; Вызывается изменение или логическое ИЛИ оператор добавляется рядом с глаголом PCRE, который соответствует всем границам, существующим между каждым и каждым символом во всех строках, за исключением того, что строка содержит точную строку &lt;code&gt;hede&lt;/code&gt; . Смотрите демо &lt;a href=&quot;http://regex101.com/r/kR0tO2/2&quot;&gt;здесь&lt;/a&gt; . То есть он пытается сопоставить символы из оставшейся строки. Теперь регулярное выражение во второй части будет выполнено.</target>
        </trans-unit>
        <trans-unit id="b7a42192468575a7e5a39750585ef8b488514333" translate="yes" xml:space="preserve">
          <source>So, in my example, every empty string is first validated to see if there's no &lt;code&gt;&quot;hede&quot;&lt;/code&gt; up ahead, before a character is consumed by the &lt;code&gt;.&lt;/code&gt; (dot). The regex &lt;code&gt;(?!hede).&lt;/code&gt; will do that only once, so it is wrapped in a group, and repeated zero or more times: &lt;code&gt;((?!hede).)*&lt;/code&gt;. Finally, the start- and end-of-input are anchored to make sure the entire input is consumed: &lt;code&gt;^((?!hede).)*$&lt;/code&gt;</source>
          <target state="translated">Итак, в моем примере каждая пустая строка сначала проверяется, чтобы увидеть, нет &lt;code&gt;&quot;hede&quot;&lt;/code&gt; впереди &amp;laquo;хеде&amp;raquo; , прежде чем символ будет использован символом &lt;code&gt;.&lt;/code&gt; (Точка). &lt;code&gt;(?!hede).&lt;/code&gt; выражение (?! Hede). будет делать это только один раз, поэтому он будет заключен в группу и повторен ноль или более раз: &lt;code&gt;((?!hede).)*&lt;/code&gt; . Наконец, начало и конец ввода привязываются, чтобы убедиться, что весь ввод используется: &lt;code&gt;^((?!hede).)*$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="f117cb601daa3d4275b6f738d374bfc07fdd9f7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.nongnu.org/txr/&quot;&gt;TXR Language&lt;/a&gt; supports regex negation.</source>
          <target state="translated">Язык &lt;a href=&quot;http://www.nongnu.org/txr/&quot;&gt;TXR&lt;/a&gt; поддерживает отрицание регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="ebcf6058f2929ecc3e3b08aed979b745665af5ef" translate="yes" xml:space="preserve">
          <source>The OP did not specify or &lt;b&gt;&lt;kbd&gt;Tag&lt;/kbd&gt;&lt;/b&gt; the post to indicate the context (programming language, editor, tool) the Regex will be used within.</source>
          <target state="translated">ОП не указал или не &lt;b&gt;&lt;kbd&gt;пометил&lt;/kbd&gt;&lt;/b&gt; пост, чтобы указать контекст (язык программирования, редактор, инструмент), в котором будет использоваться регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="11aa9db6100b5bf50fd1febfe3c053a2d5441f2d" translate="yes" xml:space="preserve">
          <source>The ^ anchor in the beginning is meant to represent the beginning of the line. The grep tool matches each line one at a time, in contexts where you're working with a multiline string, you can use the &quot;m&quot; flag:</source>
          <target state="translated">Ведущий ^ в начале предназначен для обозначения начала линии.Инструмент grep соответствует каждой строке по одной,в контекстах,где вы работаете с многострочной строкой,можно использовать флаг &quot;m&quot;:</target>
        </trans-unit>
        <trans-unit id="098ea33d53cc62129cfb7875bd9edba4f4bec259" translate="yes" xml:space="preserve">
          <source>The answer is that with POSIX &lt;code&gt;grep&lt;/code&gt;, it's impossible to literally satisfy this request:</source>
          <target state="translated">Ответ в том, что с POSIX &lt;code&gt;grep&lt;/code&gt; невозможно выполнить этот запрос буквально:</target>
        </trans-unit>
        <trans-unit id="cc27072c8e8fa68ee8a4aecd5fdce94bfeb957de" translate="yes" xml:space="preserve">
          <source>The below function will help you get your desired output</source>
          <target state="translated">Функция ниже поможет вам получить желаемый результат</target>
        </trans-unit>
        <trans-unit id="452667fef7f202d7937567d77ec3043088267fe1" translate="yes" xml:space="preserve">
          <source>The expression is explained on the top right panel of &lt;a href=&quot;https://regex101.com/r/S127jy/1/&quot;&gt;regex101.com&lt;/a&gt;, if you wish to explore/simplify/modify it, and in &lt;a href=&quot;https://regex101.com/r/S127jy/1/debugger&quot;&gt;this link&lt;/a&gt;, you can watch how it would match against some sample inputs, if you like.</source>
          <target state="translated">Выражение объяснено на верхней правой панели &lt;a href=&quot;https://regex101.com/r/S127jy/1/&quot;&gt;regex101.com&lt;/a&gt; , если вы хотите изучить / упростить / изменить его, и в &lt;a href=&quot;https://regex101.com/r/S127jy/1/debugger&quot;&gt;этой ссылке&lt;/a&gt; вы можете посмотреть, как оно будет соответствовать некоторым образцам входных данных, если хотите.</target>
        </trans-unit>
        <trans-unit id="81d959c36f65aa571d1474a3105362386f4bce31" translate="yes" xml:space="preserve">
          <source>The first 7 lines should not match, since they contain the searched Expression, while the lower 7 lines should match!</source>
          <target state="translated">Первые 7 строк не должны совпадать,так как они содержат искомое выражение,в то время как нижние 7 строк должны совпадать!</target>
        </trans-unit>
        <trans-unit id="30eca3e3a5dee91a29274eb92d118bf760f5f68b" translate="yes" xml:space="preserve">
          <source>The former checks for &amp;ldquo;hede&amp;rdquo; only at the input string&amp;rsquo;s first position, rather than at every position.</source>
          <target state="translated">Первый проверяет &amp;laquo;hede&amp;raquo; только в первой позиции входной строки, а не в каждой позиции.</target>
        </trans-unit>
        <trans-unit id="ec7560158d4afaeca7ad767df676f2c3f8316d2b" translate="yes" xml:space="preserve">
          <source>The given answers are perfectly fine, just an academic point:</source>
          <target state="translated">Полученные ответы совершенно нормальные,просто академический балл:</target>
        </trans-unit>
        <trans-unit id="2d09bbc95c0bd1eee8d3c6bb5adc11e14f4f00c5" translate="yes" xml:space="preserve">
          <source>The innermost one is for the negative lookahead (it is not a capture group)</source>
          <target state="translated">Самое сокровенное-для негативного взгляда (это не группа захвата).</target>
        </trans-unit>
        <trans-unit id="29b7a8c9eb45daf61b377e68a90e0dacca34eb0c" translate="yes" xml:space="preserve">
          <source>The logic of serial grep's is (not a comment) and (matches dir)</source>
          <target state="translated">Логика последовательной смазки (не комментарий)и (соответствует dir).</target>
        </trans-unit>
        <trans-unit id="1a96bded5f6ba78d21a0246672404cc4fdf84614" translate="yes" xml:space="preserve">
          <source>The notion that regex doesn't support inverse matching is not entirely true. You can mimic this behavior by using negative look-arounds:</source>
          <target state="translated">Представление о том,что регекс не поддерживает обратное соответствие,не совсем верно.Вы можете подражать этому поведению,используя отрицательные обратные совпадения:</target>
        </trans-unit>
        <trans-unit id="3854f1c652980feef2e8f16cab154d60899f8027" translate="yes" xml:space="preserve">
          <source>The outermost was interpreted by Ruby as capture group but we don't want it to be a capture group, so I added ?: at it's beginning and it is no longer interpreted as a capture group.</source>
          <target state="translated">Самое внешнее было интерпретировано Ruby как группа захвата,но мы не хотим,чтобы это была группа захвата,поэтому я добавил ?:в начале,и оно больше не интерпретируется как группа захвата.</target>
        </trans-unit>
        <trans-unit id="53549eab46883cf85fd1a09e3b5aed26dca85805" translate="yes" xml:space="preserve">
          <source>The reason is that POSIX &lt;code&gt;grep&lt;/code&gt; is only required to work with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003&quot;&gt;Basic Regular Expressions&lt;/a&gt;, which are simply not powerful enough for accomplishing that task (they are not capable of parsing regular languages, because of lack of alternation and parentheses).</source>
          <target state="translated">Причина в том, что POSIX &lt;code&gt;grep&lt;/code&gt; требуется только для работы с &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003&quot;&gt;базовыми регулярными выражениями&lt;/a&gt; , которые просто недостаточно мощны для выполнения этой задачи (они не способны анализировать обычные языки из-за отсутствия чередования и скобок).</target>
        </trans-unit>
        <trans-unit id="7ecb97c8fab3f5fb0b327ca5ef4661a1a4cf0f1f" translate="yes" xml:space="preserve">
          <source>The regex above will match any string, or line without a line break, &lt;strong&gt;not&lt;/strong&gt; containing the (sub)string 'hede'. As mentioned, this is not something regex is &quot;good&quot; at (or should do), but still, it &lt;em&gt;is&lt;/em&gt; possible.</source>
          <target state="translated">Приведенное выше регулярное выражение будет соответствовать любой строке или строке без разрыва строки, &lt;strong&gt;не&lt;/strong&gt; содержащей (под) строку 'hede'. Как уже упоминалось, это не то, что регулярное выражение &amp;laquo;хорошо&amp;raquo; (или должно делать), но все же, это возможно.</target>
        </trans-unit>
        <trans-unit id="8bc1736cb0d5560815fe759f45e070ec21870289" translate="yes" xml:space="preserve">
          <source>The regex solution at the top of this answer may be helpful, however, in situations where a positive regex test is required (perhaps by an API).</source>
          <target state="translated">Решение по регексу в верхней части этого ответа может быть полезным,однако,в ситуациях,когда требуется положительный регекс-тест (возможно,с помощью API).</target>
        </trans-unit>
        <trans-unit id="18d6c0cc722c7bbc3e65fb8a5074dc1d497a9c6b" translate="yes" xml:space="preserve">
          <source>This method is no more efficient than a negative lookahead, but I figured I'd just throw it on here in case someone finds it nifty and finds a use for it for other, more interesting applications.</source>
          <target state="translated">Этот метод не более эффективен,чем негативный взгляд,но я решил просто бросить его здесь на тот случай,если кто-нибудь сочтет его отличным и найдет для него применение в других,более интересных приложениях.</target>
        </trans-unit>
        <trans-unit id="3886ebe4339f9490f06300de01ba2a2e949b872b" translate="yes" xml:space="preserve">
          <source>This only does a FULL match. Doing it for sub-matches would even be more awkward.</source>
          <target state="translated">Это только полное совпадение.Делать это для субматчей было бы еще более неудобно.</target>
        </trans-unit>
        <trans-unit id="e922e950305ed79d2617ae1c8940572582dfcd3e" translate="yes" xml:space="preserve">
          <source>This simplification is ready to have &quot;AND&quot; clauses added:</source>
          <target state="translated">Это упрощение готово к тому,что в него будут добавлены пункты &quot;И&quot;:</target>
        </trans-unit>
        <trans-unit id="31ba508b83d08df1a58027dfb2ff5193636dcc21" translate="yes" xml:space="preserve">
          <source>This would completely skips the line which contains the exact string &lt;code&gt;hede&lt;/code&gt; and matches all the remaining lines.</source>
          <target state="translated">Это полностью пропустит строку, которая содержит точную строку &lt;code&gt;hede&lt;/code&gt; и соответствует всем оставшимся строкам.</target>
        </trans-unit>
        <trans-unit id="bda56a9be7875939dbf47726436cb5a754e198c2" translate="yes" xml:space="preserve">
          <source>Thus, in your case &lt;code&gt;^(?~hede)$&lt;/code&gt; does the job for you</source>
          <target state="translated">Таким образом, в вашем случае &lt;code&gt;^(?~hede)$&lt;/code&gt; делает работу за вас</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="e70838bc7b5ac1d8247c350d535a21945717c6a7" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.conyedit.com&quot;&gt;ConyEdit&lt;/a&gt;, you can use the command line &lt;code&gt;cc.gl !/hede/&lt;/code&gt; to get lines that do not contain the regex matching, or use the command line &lt;code&gt;cc.dl /hede/&lt;/code&gt; to delete lines that contain the regex matching. They have the same result.</source>
          <target state="translated">С помощью &lt;a href=&quot;https://www.conyedit.com&quot;&gt;ConyEdit&lt;/a&gt; вы можете использовать командную строку &lt;code&gt;cc.gl !/hede/&lt;/code&gt; чтобы получить строки, не содержащие сопоставление с регулярным выражением, или использовать командную строку &lt;code&gt;cc.dl /hede/&lt;/code&gt; чтобы удалить строки, содержащие сопоставление с регулярным выражением. У них одинаковый результат.</target>
        </trans-unit>
        <trans-unit id="45f7d6f93e756fe076c6f4d4cc20e5bb4a0af7f1" translate="yes" xml:space="preserve">
          <source>With GNU &lt;code&gt;grep&lt;/code&gt;, the answer would be something like:</source>
          <target state="translated">С GNU &lt;code&gt;grep&lt;/code&gt; ответ будет примерно таким:</target>
        </trans-unit>
        <trans-unit id="af3a7829ae5f96bbccfbc07b95bfc1b6818d038b" translate="yes" xml:space="preserve">
          <source>With negative lookahead, regular expression can match something not contains specific pattern. This is answered and explained by Bart Kiers. Great explanation!</source>
          <target state="translated">При отрицательном внешнем виде регулярное выражение может соответствовать чему-то,не содержащему конкретного шаблона.На это отвечает и объясняет Барт Кирс.Отличное объяснение!</target>
        </trans-unit>
        <trans-unit id="af97db013e5d443d690246871b2054ab1d1ebdfc" translate="yes" xml:space="preserve">
          <source>You can also use a tool that implements &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004&quot;&gt;Extended Regular Expressions&lt;/a&gt;, like &lt;code&gt;egrep&lt;/code&gt;, to get rid of the backslashes:</source>
          <target state="translated">Вы также можете использовать инструмент, который реализует &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004&quot;&gt;расширенные регулярные выражения&lt;/a&gt; , например &lt;code&gt;egrep&lt;/code&gt; , чтобы избавиться от обратной косой черты:</target>
        </trans-unit>
        <trans-unit id="3c3ead2f2a71a7f8de04237ee09b7ad0902ae6d3" translate="yes" xml:space="preserve">
          <source>You can see this example &lt;a href=&quot;https://stackoverflow.com/questions/406230&quot;&gt;here&lt;/a&gt;, and try Vcsn online &lt;a href=&quot;http://vcsn-sandbox.lrde.epita.fr/tree&quot;&gt;there&lt;/a&gt;.</source>
          <target state="translated">Вы можете увидеть этот пример &lt;a href=&quot;https://stackoverflow.com/questions/406230&quot;&gt;здесь&lt;/a&gt; и попробовать Vcsn онлайн &lt;a href=&quot;http://vcsn-sandbox.lrde.epita.fr/tree&quot;&gt;там&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9117813c61704c7f607c297794b874af93ed534d" translate="yes" xml:space="preserve">
          <source>You could even put the negation &lt;em&gt;outside&lt;/em&gt; the test if you need any regex features (here, case insensitivity and range matching):</source>
          <target state="translated">Вы даже можете поместить отрицание &lt;em&gt;вне&lt;/em&gt; теста, если вам нужны какие-либо функции регулярных выражений (здесь, нечувствительность к регистру и согласование диапазона):</target>
        </trans-unit>
        <trans-unit id="4e3bfb39813e0d54c6b52dba372f9b67a2de3789" translate="yes" xml:space="preserve">
          <source>You first define the type of your expressions: labels are letter (&lt;code&gt;lal_char&lt;/code&gt;) to pick from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; for instance (defining the alphabet when working with complementation is, of course, very important), and the &quot;value&quot; computed for each word is just a Boolean: &lt;code&gt;true&lt;/code&gt; the word is accepted, &lt;code&gt;false&lt;/code&gt;, rejected.</source>
          <target state="translated">Сначала вы определяете тип своих выражений: метки - это буква ( &lt;code&gt;lal_char&lt;/code&gt; ), например, для выбора от &lt;code&gt;a&lt;/code&gt; до &lt;code&gt;z&lt;/code&gt; (определение алфавита при работе с дополнением, конечно, очень важно), а &amp;laquo;значение&amp;raquo;, вычисляемое для каждого слова: просто логическое значение: &lt;code&gt;true&lt;/code&gt; слово принято, &lt;code&gt;false&lt;/code&gt; , отклонено.</target>
        </trans-unit>
        <trans-unit id="8b92e959c52f5c967563185e1dc02103fcdeb744" translate="yes" xml:space="preserve">
          <source>Your &lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt; statement will need to match &quot;contains&quot; and not match &quot;excludes&quot;.</source>
          <target state="translated">Ваше заявление &lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt; должно соответствовать &amp;laquo;содержит&amp;raquo;, а не соответствовать &amp;laquo;исключает&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="dc5f45feccd145875695bcee7ec9e44130e5b96f" translate="yes" xml:space="preserve">
          <source>^((?!hede).)*$ is an elegant solution, except since it consumes characters you won't be able to combine it with other criteria. For instance, say you wanted to check for the non-presence of &quot;hede&quot; and the presence of &quot;haha.&quot; This solution would work because it won't consume characters:</source>
          <target state="translated">^((?!hede).)*$-элегантное решение,за исключением того,что он потребляет символы,которые вы не сможете комбинировать с другими критериями.Например,скажем,вы хотели проверить на отсутствие &quot;хеда&quot; и наличие &quot;хаха&quot;.Это решение сработает,потому что оно не будет потреблять символы:</target>
        </trans-unit>
        <trans-unit id="3c24d7c6f693449c71187e2b53fec214d5e24eb3" translate="yes" xml:space="preserve">
          <source>^(?!.&lt;em&gt;\bhede\b)(?=.&lt;/em&gt;\bhaha\b)</source>
          <target state="translated">^(?!.&lt;em&gt;\bhede\b)(?=.&lt;/em&gt;\bhaha\b)</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="89c0d93ef605454f65fa159648fcc4f79d2c32ad" translate="yes" xml:space="preserve">
          <source>as expected.</source>
          <target state="translated">как и ожидалось.</target>
        </trans-unit>
        <trans-unit id="78b9b44deba42148afa14f26da3512a067ed3f05" translate="yes" xml:space="preserve">
          <source>convert this expression to an automaton:</source>
          <target state="translated">преобразовать это выражение в автомат:</target>
        </trans-unit>
        <trans-unit id="0c97c3b2e427dd08a2a22afc585bfb112e48c297" translate="yes" xml:space="preserve">
          <source>e.g. -- If you want to allow all values except &quot;foo&quot; (i.e. &quot;foofoo&quot;, &quot;barfoo&quot;, and &quot;foobar&quot; will pass, but &quot;foo&quot; will fail), use: &lt;code&gt;^(?!foo$).*&lt;/code&gt;</source>
          <target state="translated">Например, если вы хотите разрешить все значения, кроме &amp;laquo;foo&amp;raquo; (то есть &amp;laquo;foofoo&amp;raquo;, &amp;laquo;barfoo&amp;raquo; и &amp;laquo;foobar&amp;raquo; пройдут, но &amp;laquo;foo&amp;raquo; завершится ошибкой), используйте: &lt;code&gt;^(?!foo$).*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e16583e5292c76975f4ece4ba1b17808d175dd82" translate="yes" xml:space="preserve">
          <source>eg.  search an apache config file without all the comments-</source>
          <target state="translated">например,искать в конфигурационном файле apache без всех комментариев...</target>
        </trans-unit>
        <trans-unit id="81165d7e6d83159d5242d2e3447560267f5f0a15" translate="yes" xml:space="preserve">
          <source>equivalent to (for .net):</source>
          <target state="translated">эквивалентно (для .net):</target>
        </trans-unit>
        <trans-unit id="b9c5a9fb1e9449b3cc8c15f7f902b1d5321d355e" translate="yes" xml:space="preserve">
          <source>finally, convert this automaton back to a simple expression.</source>
          <target state="translated">наконец,преобразовать этот автомат обратно в простое выражение.</target>
        </trans-unit>
        <trans-unit id="37e4a0d8a8bb537de21f7a46cd439c6814401bfd" translate="yes" xml:space="preserve">
          <source>from the official &lt;a href=&quot;https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f&quot;&gt;doc&lt;/a&gt;</source>
          <target state="translated">из официального &lt;a href=&quot;https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f&quot;&gt;документа&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52ac93fe88a76f92fd6cbc405e59f5efceaa621f" translate="yes" xml:space="preserve">
          <source>is generally much more efficient than the solution to &lt;strong&gt;does not &lt;em&gt;contain&lt;/em&gt; &amp;ldquo;hede&amp;rdquo;&lt;/strong&gt;:</source>
          <target state="translated">обычно гораздо эффективнее, чем решение &lt;strong&gt;, не &lt;em&gt;содержащее&lt;/em&gt; &amp;laquo;хеде&amp;raquo;&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="86416a3c88475bb3fd86ea86b3fb79d0fa1fd2ab" translate="yes" xml:space="preserve">
          <source>or use it inline:</source>
          <target state="translated">или используйте его в строке:</target>
        </trans-unit>
        <trans-unit id="ca91e5f012d312c0136c2de3497b8aa8ce4a805a" translate="yes" xml:space="preserve">
          <source>then you enter your expression:</source>
          <target state="translated">а потом вводишь свое выражение:</target>
        </trans-unit>
        <trans-unit id="14ff5d9b2a6dee566d29abfb4bfc694ba905fd5b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;+&lt;/code&gt; is usually denoted &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt; denotes the empty word, and &lt;code&gt;[^]&lt;/code&gt; is usually written &lt;code&gt;.&lt;/code&gt; (any character).  So, with a bit of rewriting &lt;code&gt;()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*&lt;/code&gt;.</source>
          <target state="translated">где &lt;code&gt;+&lt;/code&gt; обычно обозначается &lt;code&gt;|&lt;/code&gt; &lt;code&gt;\e&lt;/code&gt; обозначает пустое слово, а &lt;code&gt;[^]&lt;/code&gt; обычно пишется &lt;code&gt;.&lt;/code&gt; (любой персонаж). Итак, с небольшой переписью &lt;code&gt;()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13a0d941cdbf53982cbc548e039164854ba5a26f" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;e&lt;/code&gt;'s are the empty strings. The regex &lt;code&gt;(?!hede).&lt;/code&gt; looks ahead to see if there's no substring &lt;code&gt;&quot;hede&quot;&lt;/code&gt; to be seen, and if that is the case (so something else is seen), then the &lt;code&gt;.&lt;/code&gt; (dot) will match any character except a line break. Look-arounds are also called &lt;em&gt;zero-width-assertions&lt;/em&gt; because they don't &lt;em&gt;consume&lt;/em&gt; any characters. They only assert/validate something.</source>
          <target state="translated">где &lt;code&gt;e&lt;/code&gt; - пустые строки. &lt;code&gt;(?!hede).&lt;/code&gt; выражение (?! Hede). смотрит вперед, чтобы увидеть, нет ли подстроки &lt;code&gt;&quot;hede&quot;&lt;/code&gt; , чтобы увидеть, и если это так (то есть что-то еще видно), то &lt;code&gt;.&lt;/code&gt; (точка) будет соответствовать любому символу, кроме разрыва строки. Осмотры также называются &lt;em&gt;утверждениями нулевой ширины,&lt;/em&gt; потому что они не &lt;em&gt;потребляют&lt;/em&gt; никаких символов. Они только утверждают / подтверждают что-то.</target>
        </trans-unit>
        <trans-unit id="88141f0aa6d0a5c8b71d83d50fe9878477ba508a" translate="yes" xml:space="preserve">
          <source>which is equivalent to the above.</source>
          <target state="translated">что эквивалентно вышесказанному.</target>
        </trans-unit>
        <trans-unit id="b3f4587567dd91d6188f1c48f4e79ecf19e09aae" translate="yes" xml:space="preserve">
          <source>with this, you avoid to test a lookahead on each positions:</source>
          <target state="translated">с помощью этого,ты избегаешь проверять на прочность каждую позицию:</target>
        </trans-unit>
        <trans-unit id="a9f7501a4bb77ecb148f3a5340b3c2a4dc0e6caf" translate="yes" xml:space="preserve">
          <source>with word boundaries.</source>
          <target state="translated">с границами слов.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
