<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/406230">
    <body>
      <group id="406230">
        <trans-unit id="9eb4a6c92e209092a0d12923bf9cc9ff4cb48470" translate="yes" xml:space="preserve">
          <source>(found with &lt;a href=&quot;http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/&quot;&gt;Grail&lt;/a&gt; and some further optimizations made by hand).</source>
          <target state="translated">（ &lt;a href=&quot;http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/&quot;&gt;Grail&lt;/a&gt;と、手動で行われたいくつかのさらなる最適化で見つかりました）。</target>
        </trans-unit>
        <trans-unit id="2e52af52a8546054dfc6413acff069ef2bc147ca" translate="yes" xml:space="preserve">
          <source>1. Search/replace the entire file to add a unique &quot;Tag&quot; to the beginning of each line containing any text.</source>
          <target state="translated">1.ファイル全体を検索して、任意のテキストを含む各行の先頭に一意の「タグ」を追加します。</target>
        </trans-unit>
        <trans-unit id="e705aab59352280c966865af9240b1976c79fb0c" translate="yes" xml:space="preserve">
          <source>2. Delete all lines that contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt; (replacement string is empty):</source>
          <target state="translated">2.文字列&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt;を含むすべての行を削除します（置換文字列は空です）。</target>
        </trans-unit>
        <trans-unit id="4d5359854c4a837f09da9271b5d18c0d86e98cb7" translate="yes" xml:space="preserve">
          <source>2. For all lines that contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, remove the unique &quot;Tag&quot;:</source>
          <target state="translated">2.文字列&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt;を含むすべての行について、一意の「タグ」を削除します。</target>
        </trans-unit>
        <trans-unit id="3a77e275bfbe2978b006ae190f18f26a3701a1f9" translate="yes" xml:space="preserve">
          <source>3. At this point, all lines that begin with the unique &quot;Tag&quot;, &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;. I can now do my &lt;b&gt;&lt;i&gt;Something Else&lt;/i&gt;&lt;/b&gt; to only those lines.</source>
          <target state="translated">3.この時点で、一意の「タグ」で始まるすべての行には、文字列&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; を含め&lt;/strong&gt; &lt;b&gt;&lt;i&gt;ない&lt;/i&gt;&lt;/b&gt;で&lt;b&gt;&lt;i&gt;ください&lt;/i&gt;&lt;/b&gt; 。 これで、 &lt;b&gt;&lt;i&gt;Something Else&lt;/i&gt;&lt;/b&gt;をこれらの行にのみ実行できます。</target>
        </trans-unit>
        <trans-unit id="da9c9c3fd6b8b9646ab8565f22f270096999311b" translate="yes" xml:space="preserve">
          <source>3. At this point, all remaining lines &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;. Remove the unique &quot;Tag&quot; from all lines (replacement string is empty):</source>
          <target state="translated">3.この時点で、残りのすべての行には文字列&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt;が含まれてい&lt;b&gt;&lt;i&gt;ません&lt;/i&gt;&lt;/b&gt; 。 すべての行から一意の「タグ」を削除します（置換文字列は空です）：</target>
        </trans-unit>
        <trans-unit id="c5af5bfa811f56236562a7f528f03723506bbc92" translate="yes" xml:space="preserve">
          <source>4. When I am done, I remove the unique &quot;Tag&quot; from all lines (replacement string is empty):</source>
          <target state="translated">4.終わったら、すべての行からユニークな「タグ」を削除します(置換文字列は空です)。</target>
        </trans-unit>
        <trans-unit id="78feb677fcb5b7b33212618320b97f32f0c56503" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://vcsn.lrde.epita.fr&quot;&gt;Vcsn&lt;/a&gt; supports this operator (which it denotes &lt;code&gt;{c}&lt;/code&gt;, postfix).</source>
          <target state="translated">&lt;a href=&quot;http://vcsn.lrde.epita.fr&quot;&gt;Vcsn&lt;/a&gt;はこの演算子をサポートします（これは &lt;code&gt;{c}&lt;/code&gt; 、postfixを示します）。</target>
        </trans-unit>
        <trans-unit id="27524e01dd8c223e92fc167f869ddb9c6ea20286" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24&quot;&gt;jex.im&lt;/a&gt; visualizes regular expressions:</source>
          <target state="translated">&lt;a href=&quot;https://jex.im/regulex/#!flags=&amp;amp;re=%5E(a%7Cb)*%3F%24&quot;&gt;jex.imは&lt;/a&gt;正規表現を視覚化します。</target>
        </trans-unit>
        <trans-unit id="b57eb38c594f4159c8cde8abea030ead596d976b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; Asserts that we are at the line end.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 行末にいることを表明します。</target>
        </trans-unit>
        <trans-unit id="52b36ac718178a71145d1ba891ac99338438678c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; End of the line anchor is not necessary here.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 行末のアンカーはここでは必要ありません。</target>
        </trans-unit>
        <trans-unit id="5bc93b176a15f9710c8851f5f6d588bd9d60ed13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; before an optional \n, and the end of the string</source>
          <target state="translated">オプションの\ nの前の &lt;code&gt;$&lt;/code&gt; と文字列の終わり</target>
        </trans-unit>
        <trans-unit id="b7c0e80a3bbc4ac75bc1f047ce7b29f9cae01e22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?!&lt;/code&gt; look ahead to see if there is not,</source>
          <target state="translated">&lt;code&gt;(?!&lt;/code&gt; ないかどうかを確認してください、</target>
        </trans-unit>
        <trans-unit id="13e685cc0a2609aafd47726b3d9c59af6288a725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)*&lt;/code&gt; end of \1   (Note: because you are using a quantifier on this capture, only the LAST repetition of the captured pattern will be stored in \1)</source>
          <target state="translated">&lt;code&gt;)*&lt;/code&gt; \ 1の終わり（注：このキャプチャで数量詞を使用しているため、キャプチャされたパターンの最後の繰り返しのみが\ 1に格納されます）</target>
        </trans-unit>
        <trans-unit id="684f435ac9c437471ef88a255e4938ea502d9f17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; end of look-ahead, 
&lt;code&gt;.&lt;/code&gt; any character except \n,</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; 先読みの終わり、 \ n以外の任意の文字</target>
        </trans-unit>
        <trans-unit id="75716139a3b0f1db692009b0858a2ebdd5cb3451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.*&lt;/code&gt; In the Multiline mode, &lt;code&gt;.&lt;/code&gt; would match any character except newline or carriage return characters. And &lt;code&gt;*&lt;/code&gt; would repeat the previous character zero or more times. So &lt;code&gt;.*&lt;/code&gt; would match the whole line. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/4&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; マルチラインモードでは、 改行または復帰文字を除くすべての文字に一致します。 また、 &lt;code&gt;*&lt;/code&gt; は前の文字を0回以上繰り返します。 したがって、 &lt;code&gt;.*&lt;/code&gt; は行全体と一致します。 こちらのデモを&lt;a href=&quot;http://regex101.com/r/kR0tO2/4&quot;&gt;ご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd00c1d9cc56e5d787782a13e4d330c5944bf7e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/&amp;lt;span(?:(?!bad).)*?&amp;gt;&lt;/code&gt; will match &lt;code&gt;&amp;lt;span class=\&quot;good\&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;span class=\&quot;ugly\&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/&amp;lt;span(?:(?!bad).)*?&amp;gt;&lt;/code&gt; は &lt;code&gt;&amp;lt;span class=\&quot;good\&quot;&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;span class=\&quot;ugly\&quot;&amp;gt;&lt;/code&gt; と一致します。</target>
        </trans-unit>
        <trans-unit id="de91b3ecf3e66e23675457dbbafca8287427b031" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;  Asserts that we are at the start. ie, it matches all the line starts except the one in the &lt;code&gt;hede&lt;/code&gt; line. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/3&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 最初にいることを表明します。 つまり、 &lt;code&gt;hede&lt;/code&gt; 行の行を除くすべての行の先頭に一致します。 こちらのデモを&lt;a href=&quot;http://regex101.com/r/kR0tO2/3&quot;&gt;ご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="19f3528c6d690ada198857c36184fef7782bef63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; Asserts that we are at the start.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 最初にいることを表明します。</target>
        </trans-unit>
        <trans-unit id="ca6ec5ae2a05e42e32bda5e3ea41a1c74bef7b3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;the beginning of the string,
&lt;code&gt;(&lt;/code&gt; group and capture to \1 (0 or more times (matching the most amount possible)),</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 文字列の先頭、 &lt;code&gt;(&lt;/code&gt; \ 1にグループ化してキャプチャ（0回以上（可能な限り多くの量に一致）））、</target>
        </trans-unit>
        <trans-unit id="88ef62a0b91eaca8ee49fdab3c971717fd8464d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hede&lt;/code&gt; Matches the string &lt;code&gt;hede&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hede&lt;/code&gt; 文字列hedeに一致します</target>
        </trans-unit>
        <trans-unit id="d1a65ea189e42cc8455fe0afc293a1e00cd3f479" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hede&lt;/code&gt; your string,</source>
          <target state="translated">あなたのひもを &lt;code&gt;hede&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="d003b960bdb077c1dfe6beb8ce4ca5d1176468dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(where the &lt;code&gt;/.../&lt;/code&gt; are the regex delimiters, i.e., not part of the pattern)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（ここで、/ &lt;code&gt;/.../&lt;/code&gt; は正規表現の区切り文字です。つまり、パターンの一部ではありません）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f717ceaec1723443831abf050e1226ab1d95364" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If&lt;/em&gt; you're just using it for grep, you can use &lt;code&gt;grep -v hede&lt;/code&gt; to get all lines which do not contain hede.</source>
          <target state="translated">単にgrepに使用している場合は、 &lt;code&gt;grep -v hede&lt;/code&gt; を使用して、hedeを含まないすべての行を取得できます。</target>
        </trans-unit>
        <trans-unit id="201b5844b8586d0c78336f51ab67e7879a440e2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Textpad&lt;/code&gt;&lt;/strong&gt; supports some Regex, but does not support lookahead or lookbehind, so it takes a few steps.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Textpad&lt;/code&gt; &lt;/strong&gt;は一部の&lt;strong&gt;正規表現を&lt;/strong&gt;サポートしていますが、先読みや後読みはサポートしていないため、いくつかの手順を実行します。</target>
        </trans-unit>
        <trans-unit id="c332061cf4bd899460b0a4c0a7eaa14bdb27b163" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Answer:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4780b347f8b966f53592b8d6b23f2c7b9836e63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Details:&lt;/strong&gt; The ^ anchor ensures the regex engine doesn't retry the match at every location in the string, which would match every string.</source>
          <target state="translated">&lt;strong&gt;詳細：&lt;/strong&gt; ^アンカーは、正規表現エンジンが文字列のすべての場所で一致を再試行しないことを保証します。</target>
        </trans-unit>
        <trans-unit id="33a872627b08a5f899edf01305ae93d8a50b8d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Execution of the parts:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;パーツの実行：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9108ede24ec6135336892fdeecab45ae62e7a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Explanation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7844df429e40743092ec192901b82594402fa14d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hey why you added .* instead of .+ ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;。+ではなく。*を追加した理由&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3f0d81e6aa9f7ffd4a855a16e0040cc0551378b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PART 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;パート1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e8addc8bc7252fbc0e0c5e9141350f92b5f32c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PART 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;パート2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73254be12eadf36210870b716538368a2fedd571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Through PCRE verb &lt;code&gt;(*SKIP)(*F)&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PCRE動詞 &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6b4aedb6aa5c2789c02d933c0a26fd6986b225b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; I have recently found Kendall Hopkins' excellent &lt;a href=&quot;https://github.com/KendallHopkins/FormalTheory&quot;&gt;FormalTheory&lt;/a&gt; library, written in PHP, which provides a functionality similar to Grail. Using it, and a simplifier written by myself, I've been able to write an online generator of negative regular expressions given an input phrase (only alphanumeric and space characters currently supported): &lt;a href=&quot;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&quot;&gt;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;最近、PHPで記述されたKendall Hopkinsの優れた&lt;a href=&quot;https://github.com/KendallHopkins/FormalTheory&quot;&gt;FormalTheory&lt;/a&gt;ライブラリを見つけました。これは、Grailと同様の機能を提供します。 それを使用して、自分で作成した単純化プログラムを使用して、入力句（現在サポートされている英数字とスペース文字のみ）を指定して、負の正規表現のオンラインジェネレーターを作成できました&lt;a href=&quot;http://www.formauri.es/personal/pgimeno/misc/non-match-regex/&quot;&gt;。http&lt;/a&gt; ： //www.formauri.es/personal/ pgimeno / misc / non-match-regex /</target>
        </trans-unit>
        <trans-unit id="adb30139018c264605cc9fc4ba28906a625cb041" translate="yes" xml:space="preserve">
          <source>A more complicated example: match all lines that start with &lt;code&gt;a&lt;/code&gt; and end with &lt;code&gt;z&lt;/code&gt;, but do not contain the substring &lt;code&gt;hede&lt;/code&gt;:</source>
          <target state="translated">より複雑な例： &lt;code&gt;a&lt;/code&gt; で始まり &lt;code&gt;z&lt;/code&gt; で終わるすべての行に一致しますが、部分文字列 &lt;code&gt;hede&lt;/code&gt; は含まれません。</target>
        </trans-unit>
        <trans-unit id="5a6ebacdd544ad2aebe976aa12b05b25bcb11e5b" translate="yes" xml:space="preserve">
          <source>A simpler solution is to use the not operator &lt;strong&gt;!&lt;/strong&gt;</source>
          <target state="translated">より簡単な解決策は、not演算子を使用すること&lt;strong&gt;です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd0a50c6415821fc8508d785e47d96d51a7df1f3" translate="yes" xml:space="preserve">
          <source>A string is just a list of &lt;code&gt;n&lt;/code&gt; characters. Before, and after each character, there's an empty string. So a list of &lt;code&gt;n&lt;/code&gt; characters will have &lt;code&gt;n+1&lt;/code&gt; empty strings. Consider the string &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt;:</source>
          <target state="translated">文字列は、 &lt;code&gt;n&lt;/code&gt; 文字のリストです。 各文字の前後に空の文字列があります。 したがって、 &lt;code&gt;n&lt;/code&gt; 文字のリストには &lt;code&gt;n+1&lt;/code&gt; 個の空の文字列が含まれます。 文字列 &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; について考えてみます。</target>
        </trans-unit>
        <trans-unit id="99646ae275e2441f59e1131f109b01e70dc81648" translate="yes" xml:space="preserve">
          <source>Accurate and more efficient than the other answers. It implements Friedl's &lt;em&gt;&quot;unrolling-the-loop&quot;&lt;/em&gt; efficiency technique and requires much less backtracking.</source>
          <target state="translated">他の回答よりも正確で効率的です。 Friedlの&lt;em&gt;「unrolling-the-loop」&lt;/em&gt;効率化手法を実装しており、必要なバックトラックがはるかに少なくなります。</target>
        </trans-unit>
        <trans-unit id="3cac49dcc87a01e093615798c54dde978759b6c5" translate="yes" xml:space="preserve">
          <source>Aforementioned &lt;code&gt;(?:(?!hede).)*&lt;/code&gt; is great because it can be anchored.</source>
          <target state="translated">&lt;code&gt;(?:(?!hede).)*&lt;/code&gt; は、アンカーできるので素晴らしいです。</target>
        </trans-unit>
        <trans-unit id="5b055b615dfbba6017949fb1b34a623d48637083" translate="yes" xml:space="preserve">
          <source>Also, please check out &lt;a href=&quot;https://github.com/amobiz/regexgen.js&quot;&gt;RegexGen.js&lt;/a&gt;, a JavaScript Regular Expression Generator that helps to construct complex regular expressions. With RegexGen.js, you can construct the regex in a more readable way:</source>
          <target state="translated">また、複雑な正規表現の作成に役立つJavaScript正規表現ジェネレーターである&lt;a href=&quot;https://github.com/amobiz/regexgen.js&quot;&gt;RegexGen.jsも&lt;/a&gt;確認してください。 RegexGen.jsを使用すると、より読みやすい方法で正規表現を作成できます。</target>
        </trans-unit>
        <trans-unit id="583b84d757cb6a3e09c59142f1d4214fcaef0cf4" translate="yes" xml:space="preserve">
          <source>An, in my opinon, more readable variant of the top answer:</source>
          <target state="translated">私の意見では、トップアンサーのより読みやすいバリエーション。</target>
        </trans-unit>
        <trans-unit id="4a4878a06e9361751e0c8c9f154eb93373a2d656" translate="yes" xml:space="preserve">
          <source>And if you need to match line break chars as well, use the &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;DOT-ALL modifier&lt;/a&gt; (the trailing &lt;code&gt;s&lt;/code&gt; in the following pattern):</source>
          <target state="translated">また、改行文字も一致させる必要がある場合は、 &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;DOT-ALL修飾子&lt;/a&gt; （次のパターンの末尾 &lt;code&gt;s&lt;/code&gt; ）を使用します。</target>
        </trans-unit>
        <trans-unit id="815196bdcfbffb0484620f8f7ff2d786b9c04d25" translate="yes" xml:space="preserve">
          <source>Another option is that to add a positive look-ahead and check if &lt;code&gt;hehe&lt;/code&gt; is anywhere in the input line, then we would negate that, with an expression similar to:</source>
          <target state="translated">別のオプションは、肯定的な先読みを追加して、入力行のどこかにあるかどうかを確認することです。その場合は、次のような式でそれを否定します。</target>
        </trans-unit>
        <trans-unit id="90315245d641776926e97cda6abf2b5d2a47c6aa" translate="yes" xml:space="preserve">
          <source>As you can see, the input &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; will fail because on &lt;code&gt;e3&lt;/code&gt;, the regex &lt;code&gt;(?!hede)&lt;/code&gt; fails (there &lt;em&gt;is&lt;/em&gt;&lt;code&gt;&quot;hede&quot;&lt;/code&gt; up ahead!).</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;e3&lt;/code&gt; では正規表現 &lt;code&gt;(?!hede)&lt;/code&gt; が失敗するため、入力 &lt;code&gt;&quot;ABhedeCD&quot;&lt;/code&gt; は失敗します（前に &lt;code&gt;&quot;hede&quot;&lt;/code&gt; がある ！）。</target>
        </trans-unit>
        <trans-unit id="14f0d43928a101b17017ac03b48125ba0258064c" translate="yes" xml:space="preserve">
          <source>Basically, &quot;match at the beginning of the line if and only if it does not have 'hede' in it&quot; - so the requirement translated almost directly into regex.</source>
          <target state="translated">基本的には「'hede'が含まれていない場合にのみ、行頭にマッチする」ということですが、この要件はほぼそのまま正規表現に変換されます。</target>
        </trans-unit>
        <trans-unit id="b76db96cf2a32f41f46b8568c9c2f6995d10c7a9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.*&lt;/code&gt; would match a blank line but &lt;code&gt;.+&lt;/code&gt; won't match a blank. We want to match all the lines except &lt;code&gt;hede&lt;/code&gt; , there may be a possibility of blank lines also in the input . so you must use &lt;code&gt;.*&lt;/code&gt; instead of &lt;code&gt;.+&lt;/code&gt; . &lt;code&gt;.+&lt;/code&gt; would repeat the previous character one or more times. See &lt;code&gt;.*&lt;/code&gt; matches a blank line &lt;a href=&quot;http://regex101.com/r/kR0tO2/5&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; は空白行と一致しますが、 &lt;code&gt;.+&lt;/code&gt; は空白行と一致しないためです 。 &lt;code&gt;hede&lt;/code&gt; を除くすべての行を一致させたいので、入力にも空白行が含まれる可能性があります。 したがって、 &lt;code&gt;.+&lt;/code&gt; 代わりに。 &lt;code&gt;.*&lt;/code&gt; を使用する必要があります。 &lt;code&gt;.+&lt;/code&gt; は、前の文字を1回以上繰り返します。 &lt;code&gt;.*&lt;/code&gt; 、 &lt;a href=&quot;http://regex101.com/r/kR0tO2/5&quot;&gt;ここの&lt;/a&gt;空白行と一致します 。</target>
        </trans-unit>
        <trans-unit id="e6f977a9521045923d16f98954c616fecb8c843e" translate="yes" xml:space="preserve">
          <source>Benchmark Text:</source>
          <target state="translated">ベンチマークテキスト。</target>
        </trans-unit>
        <trans-unit id="4f46ac72b3634f96c6860b1ed26d9d4cd71d21aa" translate="yes" xml:space="preserve">
          <source>Benchmarks</source>
          <target state="translated">Benchmarks</target>
        </trans-unit>
        <trans-unit id="b3d97f68b4c000dbfe8c7d755739582257de96d6" translate="yes" xml:space="preserve">
          <source>But the following would suffice in this case:</source>
          <target state="translated">しかし、この場合は次のようにすれば十分です。</target>
        </trans-unit>
        <trans-unit id="9c556257951e2f974fa9f074f2d437367d7b7de5" translate="yes" xml:space="preserve">
          <source>But the overall most readable and performance-wise fastest solution seems to be 05 using a conditional statement
or 04 with the possesive quantifier. I think the Perl solutions should be even faster and more easily readable.</source>
          <target state="translated">しかし、全体的に最も読みやすく、パフォーマンス的に最も速い解決策は、条件文を使った05か、所有量詞を使った04のようです。Perlのソリューションはもっと速くて読みやすいはずだと思います。</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="038bc41a7c6c6423fba68ab38e1243e0673eb5b1" translate="yes" xml:space="preserve">
          <source>DEMO</source>
          <target state="translated">DEMO</target>
        </trans-unit>
        <trans-unit id="0b308b0064ee9df9865833a93aaf9d02316a25a9" translate="yes" xml:space="preserve">
          <source>Demo in Ruby:</source>
          <target state="translated">Rubyでのデモ。</target>
        </trans-unit>
        <trans-unit id="2668fed25786577ef5330fbb43aa5160b5fce977" translate="yes" xml:space="preserve">
          <source>Desired output:</source>
          <target state="translated">望まれる出力。</target>
        </trans-unit>
        <trans-unit id="22ed035c38e99c0a0525f1aa14558f382586a7e4" translate="yes" xml:space="preserve">
          <source>Do not use:</source>
          <target state="translated">使用しないでください。</target>
        </trans-unit>
        <trans-unit id="8248c9f017b2a661d23671bd60ce72132eb021cd" translate="yes" xml:space="preserve">
          <source>ETA Oh, rereading the question, &lt;code&gt;grep -v&lt;/code&gt; is probably what you meant by &quot;tools options&quot;.</source>
          <target state="translated">ETAああ、質問をもう一度読んでください。grep-vは、おそらく「ツールオプション」が意味するものです。</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="38d08890b5b368e55863bf943b6b9078a77b395b" translate="yes" xml:space="preserve">
          <source>FWIW, since regular languages (aka rational languages) are closed under complementation, it's always possible to find a regular expression (aka rational expression) that negates another expression. But not many tools implement this.</source>
          <target state="translated">FWIW、正規言語(別名有理言語)は相補性の下で閉じているので、別の式を否定する正規表現(別名有理表現)を見つけることは常に可能です。しかし、これを実装しているツールは多くありません。</target>
        </trans-unit>
        <trans-unit id="94a4158640ead0903e4198248cdd279ee4bf592b" translate="yes" xml:space="preserve">
          <source>Finally, as everyone has noted, if your regular expression engine supports negative lookahead, that simplifies the task a lot. For example, with GNU grep:</source>
          <target state="translated">最後に、誰もが指摘しているように、もし正規表現エンジンが負のルックヘッドをサポートしているならば、タスクを非常に単純化します。例えば、GNU grep.</target>
        </trans-unit>
        <trans-unit id="e7840fc67eb63c0fc62b3bb9275d4ae78f58cc36" translate="yes" xml:space="preserve">
          <source>First, it tries to find &quot;hede&quot; somewhere in the line. If successful, at this point, &lt;code&gt;(*COMMIT)&lt;/code&gt; tells the engine to, not only not backtrack in the event of a failure, but also not to attempt any further matching in that case. Then, we try to match something that cannot possibly match (in this case, &lt;code&gt;^&lt;/code&gt;).</source>
          <target state="translated">まず、行のどこかで「へで」を見つけようとします。 成功した場合、この時点で &lt;code&gt;(*COMMIT)&lt;/code&gt; はエンジンに、障害が発生した場合にバックトラックするだけでなく、その場合はさらにマッチングを試行しないように指示します。 次に、一致する可能性がないもの（この場合は &lt;code&gt;^&lt;/code&gt; ）を一致させようとします。</target>
        </trans-unit>
        <trans-unit id="66fd11bbda1e7cb077ac7a5170f9d22cd9e79e06" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;hede&lt;/code&gt; it outputs:</source>
          <target state="translated">&lt;code&gt;hede&lt;/code&gt; の出力：</target>
        </trans-unit>
        <trans-unit id="c7cb8f31d0f67cada2b023061ce292ebd71188db" translate="yes" xml:space="preserve">
          <source>For example, a string:</source>
          <target state="translated">例えば、文字列。</target>
        </trans-unit>
        <trans-unit id="44957a991234be8e9df9fa75f2eb494f5b1a8eed" translate="yes" xml:space="preserve">
          <source>For me, I sometimes need to do this while editing a file using &lt;strong&gt;&lt;code&gt;Textpad&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">私にとっては、 &lt;strong&gt; &lt;code&gt;Textpad&lt;/code&gt; &lt;/strong&gt;を使用してファイルを編集しているときに、これを行う必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="ce940869d506a887a010eb773ba2c6af358bf25a" translate="yes" xml:space="preserve">
          <source>For more information about lookahead, please check out the great article: &lt;a href=&quot;http://www.rexegg.com/regex-lookarounds.html&quot;&gt;Mastering Lookahead and Lookbehind&lt;/a&gt;.</source>
          <target state="translated">先読みの詳細については、優れた記事「 &lt;a href=&quot;http://www.rexegg.com/regex-lookarounds.html&quot;&gt;Mastering Lookahead and Lookbehind&lt;/a&gt; 」をご覧ください。</target>
        </trans-unit>
        <trans-unit id="c25f2278c3b324ffc728c690b8635beda0a6a6d1" translate="yes" xml:space="preserve">
          <source>For those interested in the details, the technique employed is to convert the regular expression that matches the word into a finite automaton, then invert the automaton by changing every acceptance state to non-acceptance and vice versa, and then converting the resulting FA back to a regular expression.</source>
          <target state="translated">詳細に興味のある方のために、採用されている技術は、単語にマッチする正規表現を有限オートマトンに変換し、すべての受容状態を非受容状態に変えてオートマトンを反転させ、結果として得られたFAを正規表現に戻すというものです。</target>
        </trans-unit>
        <trans-unit id="e3b647855c42983ecd846d1757dfd4687da23b1b" translate="yes" xml:space="preserve">
          <source>Given a string: 
&lt;code&gt;
&amp;lt;span class=&quot;good&quot;&amp;gt;bar&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;bad&quot;&amp;gt;foo&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ugly&quot;&amp;gt;baz&amp;lt;/span&amp;gt;
&lt;/code&gt;</source>
          <target state="translated">文字列を指定： &lt;code&gt; &amp;lt;span class=&quot;good&quot;&amp;gt;bar&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;bad&quot;&amp;gt;foo&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ugly&quot;&amp;gt;baz&amp;lt;/span&amp;gt; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a41b37dc9eb2f2ea1a88a659b705994f14fc76f" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;http://jsfiddle.net/pvJL5/3/&quot;&gt;demo code&lt;/a&gt;.</source>
          <target state="translated">こちらが&lt;a href=&quot;http://jsfiddle.net/pvJL5/3/&quot;&gt;デモコード&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="440b25c25e75becc55b449c73a3491fe97d861e4" translate="yes" xml:space="preserve">
          <source>Here is the improved regex:</source>
          <target state="translated">ここに改良された正規表現があります。</target>
        </trans-unit>
        <trans-unit id="9a9a8952516d81a0b39d9122ade38c17c2ed9060" translate="yes" xml:space="preserve">
          <source>Here's &lt;a href=&quot;http://www.perlmonks.org/?node_id=588315#588368&quot;&gt;a good explanation&lt;/a&gt; of why it's not easy to negate an arbitrary regex. I have to agree with the other answers, though: if this is anything other than a hypothetical question, then a regex is not the right choice here.</source>
          <target state="translated">これは、任意の正規表現を否定することが容易ではない理由の&lt;a href=&quot;http://www.perlmonks.org/?node_id=588315#588368&quot;&gt;良い説明&lt;/a&gt;です。 ただし、他の回答にも同意する必要があります。これが架空の質問以外の場合、正規表現はここでは適切な選択ではありません。</target>
        </trans-unit>
        <trans-unit id="ddaef8476b8e3acafac4825d7b8f1ac998e71f92" translate="yes" xml:space="preserve">
          <source>Here's a method that I haven't seen used before:</source>
          <target state="translated">今まで使われているのを見たことがない方法がこちら。</target>
        </trans-unit>
        <trans-unit id="1dff1040ef948d2545fd38f5ddc5048a75c98520" translate="yes" xml:space="preserve">
          <source>Here's a script to test it (note it generates a file &lt;code&gt;testinput.txt&lt;/code&gt; in the current directory):</source>
          <target state="translated">これをテストするスクリプトを &lt;code&gt;testinput.txt&lt;/code&gt; ます（現在のディレクトリにtestinput.txtファイルを生成することに注意してください）。</target>
        </trans-unit>
        <trans-unit id="5f28c2737b2f0e2188d8328f330fac2b15157b53" translate="yes" xml:space="preserve">
          <source>Here's how I'd do it:</source>
          <target state="translated">私ならこうします。</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">どのように動作するか</target>
        </trans-unit>
        <trans-unit id="af4b2da81f792f5da8904c48f25a28f04b5d9a3c" translate="yes" xml:space="preserve">
          <source>How to use PCRE's backtracking control verbs to match a line not containing a word</source>
          <target state="translated">PCREの逆引き制御動詞を使って単語が含まれていない行を一致させる方法</target>
        </trans-unit>
        <trans-unit id="358f19a96883463715eb0b8d693998ffb417eb35" translate="yes" xml:space="preserve">
          <source>However, GNU &lt;code&gt;grep&lt;/code&gt; implements extensions that allow it. In particular, &lt;code&gt;\|&lt;/code&gt; is the alternation operator in GNU's implementation of BREs, and &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; are the parentheses. If your regular expression engine supports alternation, negative bracket expressions, parentheses and the Kleene star, and is able to anchor to the beginning and end of the string, that's all you need for this approach. Note however that negative sets &lt;code&gt;[^ ... ]&lt;/code&gt; are very convenient in addition to those, because otherwise, you need to replace them with an expression of the form &lt;code&gt;(a|b|c| ... )&lt;/code&gt; that lists every character that is not in the set, which is extremely tedious and overly long, even more so if the whole character set is Unicode.</source>
          <target state="translated">ただし、GNU &lt;code&gt;grep&lt;/code&gt; はそれを可能にする拡張機能を実装しています。 特に、 &lt;code&gt;\|&lt;/code&gt; GNUのBREの実装における代替演算子であり、 &lt;code&gt;\(&lt;/code&gt; と &lt;code&gt;\)&lt;/code&gt; が括弧です。 正規表現エンジンが代替、負のブラケット式、括弧、およびKleeneスターをサポートし、文字列の最初と最後にアンカーできる場合、この方法で必要なのはそれだけです。 ただし、ネガティブセット &lt;code&gt;[^ ... ]&lt;/code&gt; はこれらに加えて非常に便利です。それ以外の場合は、次の形式の式 &lt;code&gt;(a|b|c| ... )&lt;/code&gt; で置き換える必要があるためです。文字セット全体がUnicodeである場合、セット内ではなく、非常に退屈で長すぎます。</target>
        </trans-unit>
        <trans-unit id="87fce9ed530df5073b27f7dc4a7cb8a5bddaceaa" translate="yes" xml:space="preserve">
          <source>However, with Bart Kiers' answer, the lookahead part will test 1 to 4 characters ahead while matching any single character. We can avoid this and let the lookahead part check out the whole text, ensure there is no 'hede', and then the normal part (.*) can eat the whole text all at one time.</source>
          <target state="translated">しかし、Bart Kiersの解答では、ルックヘッド部は1文字でもマッチしている間に、1〜4文字先の文字をテストしてしまいます。これを回避するには、ルックヘッド部にテキスト全体をチェックさせ、「hede」がないことを確認してから、通常部(.*)にテキスト全体を一度に食べさせることができます。</target>
        </trans-unit>
        <trans-unit id="358d0378b2ab94ec8627f21e6e089dabbbed421a" translate="yes" xml:space="preserve">
          <source>I believe the designers of RegEx anticipated the use of not operators.</source>
          <target state="translated">RegExの設計者は、オペレータではない人の使用を想定していたのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="e798d46c6cfecdfa243d565a95292a06448c5bd4" translate="yes" xml:space="preserve">
          <source>I decided to evaluate some of the presented Options and compare their performance, as well as use some new Features.
Benchmarking on .NET Regex Engine: &lt;a href=&quot;http://regexhero.net/tester/&quot;&gt;http://regexhero.net/tester/&lt;/a&gt;</source>
          <target state="translated">提示されたオプションのいくつかを評価し、それらのパフォーマンスを比較することに加えて、いくつかの新しい機能を使用することにしました。 .NET Regexエンジンでのベンチマーク： &lt;a href=&quot;http://regexhero.net/tester/&quot;&gt;http&lt;/a&gt; : //regexhero.net/tester/</target>
        </trans-unit>
        <trans-unit id="fa66090b531a3943e8315caeac17d53e7fa5772a" translate="yes" xml:space="preserve">
          <source>I know it's possible to match a word and then reverse the matches using other tools (e.g. &lt;code&gt;grep -v&lt;/code&gt;). However, is it possible to match lines that do not contain a specific word, e.g. &lt;code&gt;hede&lt;/code&gt;, using a regular expression?</source>
          <target state="translated">単語を一致させてから、他のツール（ &lt;code&gt;grep -v&lt;/code&gt; など ）を使用して一致を逆にすることは可能です。 しかし、正規表現を使用して、 &lt;code&gt;hede&lt;/code&gt; などの特定の単語を含まない行を照合することは可能ですか？</target>
        </trans-unit>
        <trans-unit id="4065441f68e9c6020ab5a572b3efff079b3598f2" translate="yes" xml:space="preserve">
          <source>I tried to test most proposed solutions, some Optimizations are possible for certain words.
For Example if the First two letters of the search string are not the Same, answer 03 can be expanded to
&lt;code&gt;^(?&amp;gt;[^R]+|R+(?!egex Hero))*$&lt;/code&gt; resulting in a small performance gain.</source>
          <target state="translated">ほとんどの提案されたソリューションをテストしようとしましたが、特定の単語に対していくつかの最適化が可能です。 たとえば、検索文字列の最初の2文字が同じでない場合、回答03を &lt;code&gt;^(?&amp;gt;[^R]+|R+(?!egex Hero))*$&lt;/code&gt; すると、パフォーマンスが少し向上します。</target>
        </trans-unit>
        <trans-unit id="55152e4cb8b05e2398aff1b805ef864a7498c807" translate="yes" xml:space="preserve">
          <source>I want to match &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; tags which do not contain the substring &quot;bad&quot;.</source>
          <target state="translated">「bad」というサブストリングを含まない &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; タグに一致させたい。</target>
        </trans-unit>
        <trans-unit id="348fdb226d122d58a879e94920244cb659c2ff80" translate="yes" xml:space="preserve">
          <source>If I am looking to &lt;b&gt;&lt;i&gt;Do Something Else&lt;/i&gt;&lt;/b&gt; to only lines that &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, I would do it like this:</source>
          <target state="translated">文字列&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; を&lt;/strong&gt;含まない行のみに&lt;b&gt;&lt;i&gt;何か他の&lt;/i&gt;&lt;/b&gt;ことを行う場合、次のようにします。</target>
        </trans-unit>
        <trans-unit id="38622a9faba8a5ee89d14dd8753c178ec7f57e80" translate="yes" xml:space="preserve">
          <source>If I am looking to retain all lines that &lt;b&gt;&lt;i&gt;Do NOT&lt;/i&gt;&lt;/b&gt; contain the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt;, I would do it like this:</source>
          <target state="translated">文字列&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; を&lt;/strong&gt;含ま&lt;b&gt;&lt;i&gt;ない&lt;/i&gt;&lt;/b&gt;すべての行を保持したい場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="38763d6f5618ba3862a9ce1d1f4a6b9b7ba82b1e" translate="yes" xml:space="preserve">
          <source>If a line does not contain &quot;hede&quot; then the second alternative, an empty subpattern, successfully matches the subject string.</source>
          <target state="translated">行に &quot;hede &quot;が含まれていない場合、2番目の代替案である空のサブパターンは、サブジェクト文字列に正常にマッチします。</target>
        </trans-unit>
        <trans-unit id="d412617b77836527f5a7b6be35bc1f03d6769b94" translate="yes" xml:space="preserve">
          <source>If the DOT-ALL modifier is not available, you can mimic the same behavior with the character class &lt;code&gt;[\s\S]&lt;/code&gt;:</source>
          <target state="translated">DOT-ALL修飾子を使用できない場合は、文字クラス &lt;code&gt;[\s\S]&lt;/code&gt; 同じ動作を模倣できます。</target>
        </trans-unit>
        <trans-unit id="92f26649c4516946fcb1add8c4a8263d3b34b2bf" translate="yes" xml:space="preserve">
          <source>If you want the regex test to &lt;strong&gt;only&lt;/strong&gt; fail if the &lt;em&gt;entire string&lt;/em&gt; matches, the following will work:</source>
          <target state="translated">&lt;em&gt;文字列全体が&lt;/em&gt;一致する場合に&lt;strong&gt;のみ&lt;/strong&gt;正規表現テストを失敗させる場合は、次のように機能します。</target>
        </trans-unit>
        <trans-unit id="729b36879bb4e3767c9a57246277a86e711573a2" translate="yes" xml:space="preserve">
          <source>If you want to match a character to negate a word similar to negate character class:</source>
          <target state="translated">否定文字クラスと似たような言葉を否定する文字を一致させたい場合。</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="translated">Pythonで。</target>
        </trans-unit>
        <trans-unit id="f1be7176418bc2ec420699af8dfcaafdad7421f0" translate="yes" xml:space="preserve">
          <source>In my system it prints:</source>
          <target state="translated">私のシステムでは印刷されます。</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">Input:</target>
        </trans-unit>
        <trans-unit id="70b4e36c7616180b6c9127dc59657f047a94fe8b" translate="yes" xml:space="preserve">
          <source>It may be more maintainable to two regexes in your code, one to do the first match, and then if it matches run the second regex to check for outlier cases you wish to block for example &lt;code&gt;^.*(hede).*&lt;/code&gt; then have appropriate logic in your code.</source>
          <target state="translated">コード内の2つの正規表現で保守しやすくなる場合があります。1つは最初の一致を実行し、一致した場合は2番目の正規表現を実行して異常値のケースをチェックします &lt;code&gt;^.*(hede).*&lt;/code&gt; たとえば、 ^。*（hede）。*をブロックすると適切です。コード内のロジック。</target>
        </trans-unit>
        <trans-unit id="619838c3b0a02408fab5aaa30829a7d4c40bef84" translate="yes" xml:space="preserve">
          <source>Let us consider the above regex by splitting it into two parts.</source>
          <target state="translated">上記の正規表現を二つに分けて考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="5395b8e8626e7f4b1fd55874dc85b6775aa31200" translate="yes" xml:space="preserve">
          <source>Maybe you'll find this on Google while trying to write a regex that is able to match segments of a line (as opposed to entire lines) which do &lt;strong&gt;not&lt;/strong&gt; contain a substring. Tooke me a while to figure out, so I'll share:</source>
          <target state="translated">たぶん、部分文字列を含ま&lt;strong&gt;ない（&lt;/strong&gt;行全体では&lt;strong&gt;なく&lt;/strong&gt; ）行のセグメントに一致できる正規表現を書こうとしているときに、Googleでこれを見つけることができます。 理解するのにしばらくかかったので、共有します。</target>
        </trans-unit>
        <trans-unit id="f65015b6743116c0d591a6ecf9d76f8aaa121c4e" translate="yes" xml:space="preserve">
          <source>Not regex, but I've found it logical and useful to use serial greps with pipe to eliminate noise.</source>
          <target state="translated">正規表現ではありませんが、パイプでシリアルグープを使ってノイズを除去するのが論理的で便利だと感じました。</target>
        </trans-unit>
        <trans-unit id="081045e6b01eadb48d20a103dbb36df17d72fe50" translate="yes" xml:space="preserve">
          <source>Note that the solution to &lt;strong&gt;does not &lt;em&gt;start with&lt;/em&gt; &amp;ldquo;hede&amp;rdquo;&lt;/strong&gt;:</source>
          <target state="translated">へのソリューション&lt;strong&gt;&lt;em&gt;が&lt;/em&gt; 「hede」で&lt;em&gt;始まっ&lt;/em&gt;&lt;/strong&gt;て&lt;strong&gt;いない&lt;/strong&gt;ことに注意してください：</target>
        </trans-unit>
        <trans-unit id="26b82927c1805e4c7847c9a3577899e346640e6a" translate="yes" xml:space="preserve">
          <source>Note the (*?) lazy quantifier in the negative lookahead part is optional, you can use (*) greedy quantifier instead, depending on your data: if 'hede' does present and in the beginning half of the text, the lazy quantifier can be faster; otherwise, the greedy quantifier be faster. However if 'hede' does not present, both would be equal slow.</source>
          <target state="translated">データに応じて、(*)greedy quantifier を代わりに使用することができます:'hede' がテキストの最初の半分に存在している場合は、遅延量子化器の方が速く、そうでない場合は greedy quantifier の方が速くなります。しかし、'hede' が存在しない場合は、どちらも同じように遅くなります。</target>
        </trans-unit>
        <trans-unit id="0e9a29d02e68bcb3679deea8d109eb179570c686" translate="yes" xml:space="preserve">
          <source>Notice &lt;code&gt;&quot;(?!bbb).&quot;&lt;/code&gt; is neither lookbehind nor lookahead, it's lookcurrent, for example:</source>
          <target state="translated">&lt;code&gt;&quot;(?!bbb).&quot;&lt;/code&gt; 注意してください。 先読みでも先読みでもない、たとえば、現在のルックアップです。</target>
        </trans-unit>
        <trans-unit id="30d37c9788dcecf1fad3016f170ca9201ffa1d65" translate="yes" xml:space="preserve">
          <source>Notice that there are two sets (layers) of parentheses:</source>
          <target state="translated">括弧のセット(層)が2つあることに注目してください。</target>
        </trans-unit>
        <trans-unit id="a86f480c07344c42ab876520a48514924063ed70" translate="yes" xml:space="preserve">
          <source>Now you have the original text with all lines containing the string &lt;strong&gt;&lt;code&gt;hede&lt;/code&gt;&lt;/strong&gt; removed.</source>
          <target state="translated">これで、元のテキストに&lt;strong&gt; &lt;code&gt;hede&lt;/code&gt; &lt;/strong&gt;という文字列を含むすべての行が削除されました。</target>
        </trans-unit>
        <trans-unit id="dcc9367c99afe75c60c7432ea228375c0eed703b" translate="yes" xml:space="preserve">
          <source>OK, I admit this is not really an answer to the posted question posted and it may also use slightly more processing than a single regex. But for developers who came here looking for a fast emergency fix for an outlier case then this solution should not be overlooked.</source>
          <target state="translated">OK、私はこれが投稿された質問に対する答えではないことを認めます。しかし、異常なケースのための迅速な緊急修正を求めてここに来た開発者にとっては、この解決策は見逃せません。</target>
        </trans-unit>
        <trans-unit id="b217bc7b14d3698eeeed95b262a2782958f75640" translate="yes" xml:space="preserve">
          <source>Of course, if you're checking for &lt;em&gt;exact&lt;/em&gt; equality, a better general solution in this case is to check for string equality, i.e.</source>
          <target state="translated">もちろん、 &lt;em&gt;正確な&lt;/em&gt;等価性をチェックする場合、この場合のより一般的な解決策は、文字列の等価性をチェックすることです。</target>
        </trans-unit>
        <trans-unit id="92e4e642b4116921153d765748bceeb2a5d28218" translate="yes" xml:space="preserve">
          <source>Of course, it's possible to have multiple failure requirements:</source>
          <target state="translated">もちろん、複数の失敗要件を持つことも可能です。</target>
        </trans-unit>
        <trans-unit id="1676b6642119a6e78e273b06ef382dc642a9b8c8" translate="yes" xml:space="preserve">
          <source>Old answer:</source>
          <target state="translated">古い答えだ</target>
        </trans-unit>
        <trans-unit id="c25c62a5bc188579d5d23849efc8f31cf2a447d1" translate="yes" xml:space="preserve">
          <source>Part after the &lt;code&gt;|&lt;/code&gt; symbol. Part &lt;strong&gt;should be matched&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; の後の部分 シンボル。 パーツ&lt;strong&gt;を一致させる必要があります&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="73b61b7b35a3691f94481b52b729efe8e43baadb" translate="yes" xml:space="preserve">
          <source>Part before the &lt;code&gt;|&lt;/code&gt; symbol. Part &lt;strong&gt;shouldn't be matched&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; の前の部分 シンボル。 パーツ&lt;strong&gt;を一致させないでください&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7ae9fea9116fab8d5be9f40e43c9fe24123c8e9" translate="yes" xml:space="preserve">
          <source>RegEx Circuit</source>
          <target state="translated">レジックス回路</target>
        </trans-unit>
        <trans-unit id="41676a1dc090860fb04559a11f57d002c96d15af" translate="yes" xml:space="preserve">
          <source>Regex engine will start its execution from the first part.</source>
          <target state="translated">Regexエンジンは最初の部分から実行を開始します。</target>
        </trans-unit>
        <trans-unit id="71546fc265910c3ba4c3a0c33a7cfa6a7c857490" translate="yes" xml:space="preserve">
          <source>Regex negation is not particularly useful on its own but when you also have intersection, things get interesting, since you have a full set of boolean set operations: you can express &quot;the set which matches this, except for things which match that&quot;.</source>
          <target state="translated">Regexの否定はそれ自体では特に便利ではありませんが、交点がある場合には、ブーリアン集合演算の完全なセットがあるので、面白いことが起こります:&quot;これにマッチするものを除いて、これにマッチする集合 &quot;と表現できます。</target>
        </trans-unit>
        <trans-unit id="19997c21128f333f226b26bb698b36f34117927e" translate="yes" xml:space="preserve">
          <source>Regular Expressions in the meaning of theoretical computer sciences &lt;em&gt;ARE NOT ABLE&lt;/em&gt; do it like this. For them it had to look something like this:</source>
          <target state="translated">理論的なコンピュータサイエンスの意味での正規表現は、このようにすることはでき&lt;em&gt;ません&lt;/em&gt; 。 彼らにとって、それはこのようなものでなければなりませんでした：</target>
        </trans-unit>
        <trans-unit id="af38a3c1a9ef260f4705cde91de11408ba9cc3b3" translate="yes" xml:space="preserve">
          <source>Regular expression to match a line that doesn't contain a word</source>
          <target state="translated">単語を含まない行にマッチする正規表現</target>
        </trans-unit>
        <trans-unit id="e9a6ae937eb3ddd638ffc636c1c42607a3fc5a93" translate="yes" xml:space="preserve">
          <source>Results are Iterations per second as the median of 3 runs - &lt;strong&gt;Bigger Number = Better&lt;/strong&gt;</source>
          <target state="translated">結果は、3回の実行の中央値としての1秒あたりの反復&lt;strong&gt;数です&lt;/strong&gt; - &lt;strong&gt;大きい数=良い&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="2a8fa741fc245177c287037e3934f7b7d34f2900" translate="yes" xml:space="preserve">
          <source>Since .NET doesn't support action Verbs (*FAIL, etc.) I couldn't test the solutions P1 and P2.</source>
          <target state="translated">.NETは動作動詞(*FAILなど)をサポートしていないので、P1とP2をテストすることができませんでした。</target>
        </trans-unit>
        <trans-unit id="6e8ae50092c4781a2d7e2ceca8e2bcb82f39e2eb" translate="yes" xml:space="preserve">
          <source>Since no one else has given a direct answer to the question &lt;em&gt;that was asked&lt;/em&gt;, I'll do it.</source>
          <target state="translated">質問された質問に対して他の誰も直接回答していないので、私はそれをします。</target>
        </trans-unit>
        <trans-unit id="a53ab784ceaf12bbfbc9f16efc79e5e24d16d2c3" translate="yes" xml:space="preserve">
          <source>Since the introduction of ruby-2.4.1, we can use the new &lt;a href=&quot;https://github.com/k-takata/Onigmo/issues/82&quot;&gt;Absent Operator&lt;/a&gt; in Ruby&amp;rsquo;s Regular Expressions</source>
          <target state="translated">ruby-2.4.1の導入以来、Rubyの正規表現で新しい&lt;a href=&quot;https://github.com/k-takata/Onigmo/issues/82&quot;&gt;不在演算子を&lt;/a&gt;使用できます</target>
        </trans-unit>
        <trans-unit id="1692e723845d6b6032f0c8d3b96f35a2c9ce70d7" translate="yes" xml:space="preserve">
          <source>So the line which contains the string &lt;code&gt;hede&lt;/code&gt; would be matched. Once the regex engine sees the following &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; (&lt;em&gt;Note: You could write &lt;code&gt;(*F)&lt;/code&gt; as &lt;code&gt;(*FAIL)&lt;/code&gt;&lt;/em&gt;) verb, it skips and make the match to fail. &lt;code&gt;|&lt;/code&gt; called alteration or logical OR operator added next to the PCRE verb which inturn matches all the boundaries exists between each and every character on all the lines except the line contains the exact string &lt;code&gt;hede&lt;/code&gt;. See the demo &lt;a href=&quot;http://regex101.com/r/kR0tO2/2&quot;&gt;here&lt;/a&gt;. That is, it tries to match the characters from the remaining string. Now the regex in the second part would be executed.</source>
          <target state="translated">したがって、文字列 &lt;code&gt;hede&lt;/code&gt; を含む行が一致します。 正規表現エンジンが次の &lt;code&gt;(*SKIP)(*F)&lt;/code&gt; （ &lt;em&gt;注： &lt;code&gt;(*F)&lt;/code&gt; を &lt;code&gt;(*FAIL)&lt;/code&gt; と書くことができる&lt;/em&gt; ）動詞を検出すると、スキップして一致を失敗させます。 &lt;code&gt;|&lt;/code&gt; PCRE動詞の隣に追加と呼ばれる変更または論理OR演算子が追加されました。これは、行が正確な文字列 &lt;code&gt;hede&lt;/code&gt; を含む場合を除いて、すべての行のすべての文字間に存在するすべての境界に一致するすべての境界に一致します。 こちらのデモを&lt;a href=&quot;http://regex101.com/r/kR0tO2/2&quot;&gt;ご覧ください&lt;/a&gt; 。 つまり、残りの文字列の文字を照合しようとします。 これで、2番目の部分の正規表現が実行されます。</target>
        </trans-unit>
        <trans-unit id="b7a42192468575a7e5a39750585ef8b488514333" translate="yes" xml:space="preserve">
          <source>So, in my example, every empty string is first validated to see if there's no &lt;code&gt;&quot;hede&quot;&lt;/code&gt; up ahead, before a character is consumed by the &lt;code&gt;.&lt;/code&gt; (dot). The regex &lt;code&gt;(?!hede).&lt;/code&gt; will do that only once, so it is wrapped in a group, and repeated zero or more times: &lt;code&gt;((?!hede).)*&lt;/code&gt;. Finally, the start- and end-of-input are anchored to make sure the entire input is consumed: &lt;code&gt;^((?!hede).)*$&lt;/code&gt;</source>
          <target state="translated">したがって、私の例では、すべての空の文字列を最初に検証して、前に &lt;code&gt;&quot;hede&quot;&lt;/code&gt; ないかどうかを確認してから、文字がによって消費されます &lt;code&gt;.&lt;/code&gt; （ドット）。 正規表現 &lt;code&gt;(?!hede).&lt;/code&gt; これは1回だけ行われるため、グループでラップされ、0回以上繰り返されます： &lt;code&gt;((?!hede).)*&lt;/code&gt; 。 最後に、入力の開始と終了がアンカーされ、入力全体が確実に消費されるようにします。 &lt;code&gt;^((?!hede).)*$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="f117cb601daa3d4275b6f738d374bfc07fdd9f7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.nongnu.org/txr/&quot;&gt;TXR Language&lt;/a&gt; supports regex negation.</source>
          <target state="translated">&lt;a href=&quot;http://www.nongnu.org/txr/&quot;&gt;TXR言語&lt;/a&gt;は正規表現の否定をサポートしています。</target>
        </trans-unit>
        <trans-unit id="ebcf6058f2929ecc3e3b08aed979b745665af5ef" translate="yes" xml:space="preserve">
          <source>The OP did not specify or &lt;b&gt;&lt;kbd&gt;Tag&lt;/kbd&gt;&lt;/b&gt; the post to indicate the context (programming language, editor, tool) the Regex will be used within.</source>
          <target state="translated">OPは、Regexが使用されるコンテキスト（プログラミング言語、エディター、ツール）を示す投稿を指定または&lt;b&gt;&lt;kbd&gt;タグ付け&lt;/kbd&gt;&lt;/b&gt;しませんでした。</target>
        </trans-unit>
        <trans-unit id="11aa9db6100b5bf50fd1febfe3c053a2d5441f2d" translate="yes" xml:space="preserve">
          <source>The ^ anchor in the beginning is meant to represent the beginning of the line. The grep tool matches each line one at a time, in contexts where you're working with a multiline string, you can use the &quot;m&quot; flag:</source>
          <target state="translated">冒頭の ^ アンカーは、行の先頭を表しています。複数行の文字列を扱う場合には、&quot;m&quot; フラグを使うことができます。</target>
        </trans-unit>
        <trans-unit id="098ea33d53cc62129cfb7875bd9edba4f4bec259" translate="yes" xml:space="preserve">
          <source>The answer is that with POSIX &lt;code&gt;grep&lt;/code&gt;, it's impossible to literally satisfy this request:</source>
          <target state="translated">答えは、POSIX &lt;code&gt;grep&lt;/code&gt; では、この要求を文字通り満たすことは不可能であるということです。</target>
        </trans-unit>
        <trans-unit id="cc27072c8e8fa68ee8a4aecd5fdce94bfeb957de" translate="yes" xml:space="preserve">
          <source>The below function will help you get your desired output</source>
          <target state="translated">以下の関数は、希望する出力を得るのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="452667fef7f202d7937567d77ec3043088267fe1" translate="yes" xml:space="preserve">
          <source>The expression is explained on the top right panel of &lt;a href=&quot;https://regex101.com/r/S127jy/1/&quot;&gt;regex101.com&lt;/a&gt;, if you wish to explore/simplify/modify it, and in &lt;a href=&quot;https://regex101.com/r/S127jy/1/debugger&quot;&gt;this link&lt;/a&gt;, you can watch how it would match against some sample inputs, if you like.</source>
          <target state="translated">表現は&lt;a href=&quot;https://regex101.com/r/S127jy/1/&quot;&gt;regex101.comの&lt;/a&gt;右上のパネルで説明されています。これを探索/簡略化/変更したい場合は、 &lt;a href=&quot;https://regex101.com/r/S127jy/1/debugger&quot;&gt;このリンクで&lt;/a&gt; 、必要に応じてサンプル入力とどのように一致するかを確認できます。</target>
        </trans-unit>
        <trans-unit id="81d959c36f65aa571d1474a3105362386f4bce31" translate="yes" xml:space="preserve">
          <source>The first 7 lines should not match, since they contain the searched Expression, while the lower 7 lines should match!</source>
          <target state="translated">最初の7行は検索されたExpressionを含んでいるのでマッチしないはずですが、下の7行はマッチするはずです!</target>
        </trans-unit>
        <trans-unit id="30eca3e3a5dee91a29274eb92d118bf760f5f68b" translate="yes" xml:space="preserve">
          <source>The former checks for &amp;ldquo;hede&amp;rdquo; only at the input string&amp;rsquo;s first position, rather than at every position.</source>
          <target state="translated">前者は、すべての位置ではなく、入力文字列の最初の位置でのみ「hede」をチェックします。</target>
        </trans-unit>
        <trans-unit id="ec7560158d4afaeca7ad767df676f2c3f8316d2b" translate="yes" xml:space="preserve">
          <source>The given answers are perfectly fine, just an academic point:</source>
          <target state="translated">与えられた答えは全く問題ありません。</target>
        </trans-unit>
        <trans-unit id="2d09bbc95c0bd1eee8d3c6bb5adc11e14f4f00c5" translate="yes" xml:space="preserve">
          <source>The innermost one is for the negative lookahead (it is not a capture group)</source>
          <target state="translated">一番内側のものは、負のルックヘッド用です(キャプチャグループではありません</target>
        </trans-unit>
        <trans-unit id="29b7a8c9eb45daf61b377e68a90e0dacca34eb0c" translate="yes" xml:space="preserve">
          <source>The logic of serial grep's is (not a comment) and (matches dir)</source>
          <target state="translated">シリアルgrepのロジックは(コメントではない)と(dirにマッチする)</target>
        </trans-unit>
        <trans-unit id="1a96bded5f6ba78d21a0246672404cc4fdf84614" translate="yes" xml:space="preserve">
          <source>The notion that regex doesn't support inverse matching is not entirely true. You can mimic this behavior by using negative look-arounds:</source>
          <target state="translated">正規表現は逆マッチングをサポートしていないという考えは、完全に真実ではありません。負のルックアラウンドを使用することで、この動作を真似ることができます。</target>
        </trans-unit>
        <trans-unit id="3854f1c652980feef2e8f16cab154d60899f8027" translate="yes" xml:space="preserve">
          <source>The outermost was interpreted by Ruby as capture group but we don't want it to be a capture group, so I added ?: at it's beginning and it is no longer interpreted as a capture group.</source>
          <target state="translated">outermostはRubyではキャプチャグループと解釈されていましたが、キャプチャグループにはしてほしくないので、先頭に「?</target>
        </trans-unit>
        <trans-unit id="53549eab46883cf85fd1a09e3b5aed26dca85805" translate="yes" xml:space="preserve">
          <source>The reason is that POSIX &lt;code&gt;grep&lt;/code&gt; is only required to work with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003&quot;&gt;Basic Regular Expressions&lt;/a&gt;, which are simply not powerful enough for accomplishing that task (they are not capable of parsing regular languages, because of lack of alternation and parentheses).</source>
          <target state="translated">その理由は、POSIX &lt;code&gt;grep&lt;/code&gt; が必要とするのは、 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003&quot;&gt;基本的な正規表現&lt;/a&gt;でのみ機能することです。これは、そのタスクを実行するのに十分強力ではありません（代替と括弧がないため、正規言語を解析できません）。</target>
        </trans-unit>
        <trans-unit id="7ecb97c8fab3f5fb0b327ca5ef4661a1a4cf0f1f" translate="yes" xml:space="preserve">
          <source>The regex above will match any string, or line without a line break, &lt;strong&gt;not&lt;/strong&gt; containing the (sub)string 'hede'. As mentioned, this is not something regex is &quot;good&quot; at (or should do), but still, it &lt;em&gt;is&lt;/em&gt; possible.</source>
          <target state="translated">上記の正規表現は、任意の文字列、または（サブ）文字列 'hede'を含ま&lt;strong&gt;ない&lt;/strong&gt;改行なしの行に一致します。 既に述べたように、これは正規表現が「上手い」（またはすべきである）ものではありませんが、それでも可能です。</target>
        </trans-unit>
        <trans-unit id="8bc1736cb0d5560815fe759f45e070ec21870289" translate="yes" xml:space="preserve">
          <source>The regex solution at the top of this answer may be helpful, however, in situations where a positive regex test is required (perhaps by an API).</source>
          <target state="translated">この回答の一番上にある正規表現ソリューションが役に立つかもしれませんが、(おそらくAPIによって)正規表現テストが必要な状況では、正規表現テストが必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="18d6c0cc722c7bbc3e65fb8a5074dc1d497a9c6b" translate="yes" xml:space="preserve">
          <source>This method is no more efficient than a negative lookahead, but I figured I'd just throw it on here in case someone finds it nifty and finds a use for it for other, more interesting applications.</source>
          <target state="translated">この方法はネガティブルックヘッドよりも効率的ではありませんが、誰かがそれを見つけて、他のもっと面白いアプリケーションのためにそれを使用することを見つけた場合に備えて、私はここにそれを投げることを考えました。</target>
        </trans-unit>
        <trans-unit id="3886ebe4339f9490f06300de01ba2a2e949b872b" translate="yes" xml:space="preserve">
          <source>This only does a FULL match. Doing it for sub-matches would even be more awkward.</source>
          <target state="translated">これはフルマッチのみを行います。サブマッチのためにそれを行うと、さらに厄介なことになります。</target>
        </trans-unit>
        <trans-unit id="e922e950305ed79d2617ae1c8940572582dfcd3e" translate="yes" xml:space="preserve">
          <source>This simplification is ready to have &quot;AND&quot; clauses added:</source>
          <target state="translated">この単純化は、&quot;AND &quot;節を追加する準備ができています。</target>
        </trans-unit>
        <trans-unit id="31ba508b83d08df1a58027dfb2ff5193636dcc21" translate="yes" xml:space="preserve">
          <source>This would completely skips the line which contains the exact string &lt;code&gt;hede&lt;/code&gt; and matches all the remaining lines.</source>
          <target state="translated">これは、正確な文字列 &lt;code&gt;hede&lt;/code&gt; を含む行を完全にスキップし、残りのすべての行と一致します。</target>
        </trans-unit>
        <trans-unit id="bda56a9be7875939dbf47726436cb5a754e198c2" translate="yes" xml:space="preserve">
          <source>Thus, in your case &lt;code&gt;^(?~hede)$&lt;/code&gt; does the job for you</source>
          <target state="translated">したがって、あなたのケースでは &lt;code&gt;^(?~hede)$&lt;/code&gt; があなたのために仕事をします</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="e70838bc7b5ac1d8247c350d535a21945717c6a7" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.conyedit.com&quot;&gt;ConyEdit&lt;/a&gt;, you can use the command line &lt;code&gt;cc.gl !/hede/&lt;/code&gt; to get lines that do not contain the regex matching, or use the command line &lt;code&gt;cc.dl /hede/&lt;/code&gt; to delete lines that contain the regex matching. They have the same result.</source>
          <target state="translated">&lt;a href=&quot;https://www.conyedit.com&quot;&gt;ConyEdit&lt;/a&gt;では、コマンドライン &lt;code&gt;cc.gl !/hede/&lt;/code&gt; を使用して、正規表現一致を含まない行を取得するか、コマンドライン &lt;code&gt;cc.dl /hede/&lt;/code&gt; を使用して、正規表現一致を含む行を削除できます。 彼らは同じ結果を持っています。</target>
        </trans-unit>
        <trans-unit id="45f7d6f93e756fe076c6f4d4cc20e5bb4a0af7f1" translate="yes" xml:space="preserve">
          <source>With GNU &lt;code&gt;grep&lt;/code&gt;, the answer would be something like:</source>
          <target state="translated">GNU &lt;code&gt;grep&lt;/code&gt; を使用すると、答えは次のようになります。</target>
        </trans-unit>
        <trans-unit id="af3a7829ae5f96bbccfbc07b95bfc1b6818d038b" translate="yes" xml:space="preserve">
          <source>With negative lookahead, regular expression can match something not contains specific pattern. This is answered and explained by Bart Kiers. Great explanation!</source>
          <target state="translated">負のルックヘッドでは、正規表現は特定のパターンを含まないものと一致することができます。これはBart Kiersさんが回答し、説明してくれています。素晴らしい説明です。</target>
        </trans-unit>
        <trans-unit id="af97db013e5d443d690246871b2054ab1d1ebdfc" translate="yes" xml:space="preserve">
          <source>You can also use a tool that implements &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004&quot;&gt;Extended Regular Expressions&lt;/a&gt;, like &lt;code&gt;egrep&lt;/code&gt;, to get rid of the backslashes:</source>
          <target state="translated">&lt;code&gt;egrep&lt;/code&gt; などの&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004&quot;&gt;拡張正規表現&lt;/a&gt;を実装するツールを使用して、バックスラッシュを取り除くこともできます。</target>
        </trans-unit>
        <trans-unit id="3c3ead2f2a71a7f8de04237ee09b7ad0902ae6d3" translate="yes" xml:space="preserve">
          <source>You can see this example &lt;a href=&quot;https://stackoverflow.com/questions/406230&quot;&gt;here&lt;/a&gt;, and try Vcsn online &lt;a href=&quot;http://vcsn-sandbox.lrde.epita.fr/tree&quot;&gt;there&lt;/a&gt;.</source>
          <target state="translated">この例は&lt;a href=&quot;https://stackoverflow.com/questions/406230&quot;&gt;こちら&lt;/a&gt;で確認でき、Vcsnをオンライン&lt;a href=&quot;http://vcsn-sandbox.lrde.epita.fr/tree&quot;&gt;で&lt;/a&gt;試すことができます。</target>
        </trans-unit>
        <trans-unit id="9117813c61704c7f607c297794b874af93ed534d" translate="yes" xml:space="preserve">
          <source>You could even put the negation &lt;em&gt;outside&lt;/em&gt; the test if you need any regex features (here, case insensitivity and range matching):</source>
          <target state="translated">正規表現機能（ここでは、大文字と小文字の区別と範囲の一致）が必要な場合は、否定をテストの&lt;em&gt;外に&lt;/em&gt;置くこともできます。</target>
        </trans-unit>
        <trans-unit id="4e3bfb39813e0d54c6b52dba372f9b67a2de3789" translate="yes" xml:space="preserve">
          <source>You first define the type of your expressions: labels are letter (&lt;code&gt;lal_char&lt;/code&gt;) to pick from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; for instance (defining the alphabet when working with complementation is, of course, very important), and the &quot;value&quot; computed for each word is just a Boolean: &lt;code&gt;true&lt;/code&gt; the word is accepted, &lt;code&gt;false&lt;/code&gt;, rejected.</source>
          <target state="translated">まず、式のタイプを定義します。ラベルは、たとえば &lt;code&gt;a&lt;/code&gt; から &lt;code&gt;z&lt;/code&gt; まで選択する文字（ &lt;code&gt;lal_char&lt;/code&gt; ）です（もちろん、補完を処理するときにアルファベットを定義することが重要です）。各単語に対して計算される「値」は、単なるブール値： &lt;code&gt;true&lt;/code&gt; は単語が受け入れられ、 &lt;code&gt;false&lt;/code&gt; は拒否されます。</target>
        </trans-unit>
        <trans-unit id="8b92e959c52f5c967563185e1dc02103fcdeb744" translate="yes" xml:space="preserve">
          <source>Your &lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt; statement will need to match &quot;contains&quot; and not match &quot;excludes&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt;ステートメントは、「含む」と一致し、「除外」と一致しない必要があります。</target>
        </trans-unit>
        <trans-unit id="dc5f45feccd145875695bcee7ec9e44130e5b96f" translate="yes" xml:space="preserve">
          <source>^((?!hede).)*$ is an elegant solution, except since it consumes characters you won't be able to combine it with other criteria. For instance, say you wanted to check for the non-presence of &quot;hede&quot; and the presence of &quot;haha.&quot; This solution would work because it won't consume characters:</source>
          <target state="translated">はエレガントな解決策ですが、文字を消費するので、他の基準と組み合わせることができません。例えば、&quot;hede &quot;がないかどうかと &quot;haha &quot;があるかどうかをチェックしたいとします。この解決策は文字を消費しないので、うまくいくでしょう。</target>
        </trans-unit>
        <trans-unit id="3c24d7c6f693449c71187e2b53fec214d5e24eb3" translate="yes" xml:space="preserve">
          <source>^(?!.&lt;em&gt;\bhede\b)(?=.&lt;/em&gt;\bhaha\b)</source>
          <target state="translated">^(?!.&lt;em&gt;\bhede\b)(?=.&lt;/em&gt;\bhaha\b)</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="89c0d93ef605454f65fa159648fcc4f79d2c32ad" translate="yes" xml:space="preserve">
          <source>as expected.</source>
          <target state="translated">予想通り。</target>
        </trans-unit>
        <trans-unit id="78b9b44deba42148afa14f26da3512a067ed3f05" translate="yes" xml:space="preserve">
          <source>convert this expression to an automaton:</source>
          <target state="translated">この式をオートマトンに変換します。</target>
        </trans-unit>
        <trans-unit id="0c97c3b2e427dd08a2a22afc585bfb112e48c297" translate="yes" xml:space="preserve">
          <source>e.g. -- If you want to allow all values except &quot;foo&quot; (i.e. &quot;foofoo&quot;, &quot;barfoo&quot;, and &quot;foobar&quot; will pass, but &quot;foo&quot; will fail), use: &lt;code&gt;^(?!foo$).*&lt;/code&gt;</source>
          <target state="translated">例-「foo」以外のすべての値を許可する場合（つまり、「foofoo」、「barfoo」、および「foobar」は通過しますが、「foo」は失敗します）、 &lt;code&gt;^(?!foo$).*&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="e16583e5292c76975f4ece4ba1b17808d175dd82" translate="yes" xml:space="preserve">
          <source>eg.  search an apache config file without all the comments-</source>
          <target state="translated">例えば、すべてのコメントを含まないapacheの設定ファイルを検索します。</target>
        </trans-unit>
        <trans-unit id="81165d7e6d83159d5242d2e3447560267f5f0a15" translate="yes" xml:space="preserve">
          <source>equivalent to (for .net):</source>
          <target state="translated">(.netの場合)と同等です。</target>
        </trans-unit>
        <trans-unit id="b9c5a9fb1e9449b3cc8c15f7f902b1d5321d355e" translate="yes" xml:space="preserve">
          <source>finally, convert this automaton back to a simple expression.</source>
          <target state="translated">最後に、このオートマトンを単純な式に変換します。</target>
        </trans-unit>
        <trans-unit id="37e4a0d8a8bb537de21f7a46cd439c6814401bfd" translate="yes" xml:space="preserve">
          <source>from the official &lt;a href=&quot;https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f&quot;&gt;doc&lt;/a&gt;</source>
          <target state="translated">公式&lt;a href=&quot;https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f&quot;&gt;ドキュメント&lt;/a&gt;から</target>
        </trans-unit>
        <trans-unit id="52ac93fe88a76f92fd6cbc405e59f5efceaa621f" translate="yes" xml:space="preserve">
          <source>is generally much more efficient than the solution to &lt;strong&gt;does not &lt;em&gt;contain&lt;/em&gt; &amp;ldquo;hede&amp;rdquo;&lt;/strong&gt;:</source>
          <target state="translated">一般に&lt;strong&gt;&lt;em&gt;、&lt;/em&gt; 「hede」を&lt;em&gt;含ま&lt;/em&gt;ない&lt;/strong&gt;ソリューションよりもはるかに効率的です。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="86416a3c88475bb3fd86ea86b3fb79d0fa1fd2ab" translate="yes" xml:space="preserve">
          <source>or use it inline:</source>
          <target state="translated">またはインラインで使用します。</target>
        </trans-unit>
        <trans-unit id="ca91e5f012d312c0136c2de3497b8aa8ce4a805a" translate="yes" xml:space="preserve">
          <source>then you enter your expression:</source>
          <target state="translated">をクリックして、式を入力します。</target>
        </trans-unit>
        <trans-unit id="14ff5d9b2a6dee566d29abfb4bfc694ba905fd5b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;+&lt;/code&gt; is usually denoted &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt; denotes the empty word, and &lt;code&gt;[^]&lt;/code&gt; is usually written &lt;code&gt;.&lt;/code&gt; (any character).  So, with a bit of rewriting &lt;code&gt;()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; は通常示されます &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;\e&lt;/code&gt; は空の単語を示し、 &lt;code&gt;[^]&lt;/code&gt; は通常書き込まれ &lt;code&gt;.&lt;/code&gt; （任意の文字）。 したがって、少し書き直して &lt;code&gt;()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13a0d941cdbf53982cbc548e039164854ba5a26f" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;e&lt;/code&gt;'s are the empty strings. The regex &lt;code&gt;(?!hede).&lt;/code&gt; looks ahead to see if there's no substring &lt;code&gt;&quot;hede&quot;&lt;/code&gt; to be seen, and if that is the case (so something else is seen), then the &lt;code&gt;.&lt;/code&gt; (dot) will match any character except a line break. Look-arounds are also called &lt;em&gt;zero-width-assertions&lt;/em&gt; because they don't &lt;em&gt;consume&lt;/em&gt; any characters. They only assert/validate something.</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; は空の文字列です。 正規表現 &lt;code&gt;(?!hede).&lt;/code&gt; は、表示される部分文字列 &lt;code&gt;&quot;hede&quot;&lt;/code&gt; がないかどうかを確認し、それが当てはまる場合（したがって、他に何かが表示される場合）は、 （ドット）は、改行を除くすべての文字に一致します。 ルックアラウンドは文字を&lt;em&gt;消費&lt;/em&gt;しないため、 &lt;em&gt;ゼロ幅アサーション&lt;/em&gt;とも呼ばれ&lt;em&gt;ます&lt;/em&gt; 。 彼らは何かを主張/検証するだけです。</target>
        </trans-unit>
        <trans-unit id="88141f0aa6d0a5c8b71d83d50fe9878477ba508a" translate="yes" xml:space="preserve">
          <source>which is equivalent to the above.</source>
          <target state="translated">に相当する。</target>
        </trans-unit>
        <trans-unit id="b3f4587567dd91d6188f1c48f4e79ecf19e09aae" translate="yes" xml:space="preserve">
          <source>with this, you avoid to test a lookahead on each positions:</source>
          <target state="translated">これを使えば、各ポジションのルックヘッドのテストを避けることができます。</target>
        </trans-unit>
        <trans-unit id="a9f7501a4bb77ecb148f3a5340b3c2a4dc0e6caf" translate="yes" xml:space="preserve">
          <source>with word boundaries.</source>
          <target state="translated">言葉の境界線で</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
