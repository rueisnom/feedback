<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/40730">
    <body>
      <group id="40730">
        <trans-unit id="714e23cefc2e2c4e15d341e680dbcaf0530eb447" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.defaultvalueattribute?view=netframework-4.8&quot;&gt;&lt;code&gt;DefaultValueAttribute&lt;/code&gt;&lt;/a&gt; is intended to be used by the VS designer (or any other consumer) to specify a default value, not an initial value. (Even if in designed object, initial value is the default value).</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.defaultvalueattribute?view=netframework-4.8&quot;&gt; &lt;code&gt;DefaultValueAttribute&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;VS设计器（或任何其他使用者）打算使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; DefaultValueAttribute&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来指定默认值，而不是初始值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（即使在设计对象中，初始值也是默认值）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="91842727647d30c8647d83eb1dbf9308f4db7931" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; Using the Constructor:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 使用构造函数：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da10f12617f9bec055d9b4ccac1cc16f87520df2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C# 5 and below&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C＃5以下&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a6ce186c51205303005da54e527d8acd63e4a19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C# 6&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C＃6&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90a18f397ed6c6e8a27d3edbfd5d9d95f744e446" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edited on 1/2/15&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;于1/2/15编辑&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7509bc8dcc7e153bb827962523c606fa13d6bec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For Readonly properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于只读属性&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33b80ebb07d3fbca29ac0d15f8c2311c9d67b4ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For both Writable &amp;amp; Readable properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于可写和可读属性&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d77461559aa347ae48d83005e2901613b5f71aa4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Starting with C# 6.0&lt;/strong&gt;, We can assign default value to auto-implemented properties.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从C＃6.0开始&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我们可以将默认值分配给自动实现的属性。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3a926a3213825a97af03fdf67a6cec6845034df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using normal property syntax&lt;/strong&gt;  (with an initial value)</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用常规属性语法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; （带有初始值）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9118205298b983e6310161824394e853c61f8c58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can simple put like this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;你可以像这样简单地放&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="818427766702b1db479e9fd15cd05b94417964ec" translate="yes" xml:space="preserve">
          <source>@Darren Kopp - good answer, clean, and correct.  And to reiterate, you CAN write constructors for Abstract methods.  You just need to access them from the base class when writing the constructor:</source>
          <target state="translated">@Darren Kopp-很好的回答,很干净,也很正确。重申一下,你可以为抽象方法写构造函数。你只需要在写构造函数时从基类中访问它们。</target>
        </trans-unit>
        <trans-unit id="c0bd4be029e7bf1974649a54feb60cd9efa26eb9" translate="yes" xml:space="preserve">
          <source>As of C#6 there is a new way:</source>
          <target state="translated">从C#6开始,就有了新的方法。</target>
        </trans-unit>
        <trans-unit id="b91018ede0c5c2b781446e479554a284a8f85d77" translate="yes" xml:space="preserve">
          <source>As this gives you clear control of the order values are assigned.</source>
          <target state="translated">因为这让你可以清楚地控制订单值的分配。</target>
        </trans-unit>
        <trans-unit id="7fd2fc4fdbbfd55e9459e6c92366521e68f2b3e7" translate="yes" xml:space="preserve">
          <source>At compile time &lt;code&gt;DefaultValueAttribute&lt;/code&gt; will not impact the generated IL and it will not be read to initialize the property to that value (see &lt;a href=&quot;https://stackoverflow.com/questions/1980520/defaultvalue-attribute-is-not-working-with-my-auto-property&quot;&gt;DefaultValue attribute is not working with my Auto Property&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在编译时，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;DefaultValueAttribute&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不会影响生成的IL，也不会读取它来将属性初始化为该值（请参阅&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1980520/defaultvalue-attribute-is-not-working-with-my-auto-property&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DefaultValue属性不适用于我的Auto Property&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ad560ce299dc32f1b789984854c98f49f8027bf6" translate="yes" xml:space="preserve">
          <source>Constructor at Base Class:</source>
          <target state="translated">在基类的构造函数。</target>
        </trans-unit>
        <trans-unit id="64e3d768483703c127e3347f2d07542b52db2543" translate="yes" xml:space="preserve">
          <source>Constructor at Derived / Concrete / Sub-Class:</source>
          <target state="translated">在派生混凝土子类的构造者。</target>
        </trans-unit>
        <trans-unit id="81c1a5f25e1ffcc8fbcad8254b14fe40037ab92c" translate="yes" xml:space="preserve">
          <source>Details on &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/x9fsa0sw.aspx&quot;&gt;MSDN&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/x9fsa0sw.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MSDN的&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;详细信息&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e78a156db6ecbed17e0e062fd60e26d6115b348" translate="yes" xml:space="preserve">
          <source>Example of attributes that impact the IL are &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.threadstaticattribute?view=netframework-4.8&quot;&gt;&lt;code&gt;ThreadStaticAttribute&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.callermembernameattribute?view=netframework-4.8&quot;&gt;&lt;code&gt;CallerMemberNameAttribute&lt;/code&gt;&lt;/a&gt;, ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;影响IL的属性示例包括&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.threadstaticattribute?view=netframework-4.8&quot;&gt; &lt;code&gt;ThreadStaticAttribute&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.callermembernameattribute?view=netframework-4.8&quot;&gt; &lt;code&gt;CallerMemberNameAttribute&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="72a72fc0587dbd7b54f70217f6f0bb56d5026639" translate="yes" xml:space="preserve">
          <source>Have you tried using the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.componentmodel.defaultvalueattribute.aspx&quot;&gt;DefaultValueAttribute&lt;/a&gt; or &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/53b8022e%28VS.71%29.aspx&quot;&gt;ShouldSerialize and Reset methods&lt;/a&gt; in conjunction with the constructor?  I feel like one of these two methods is necessary if you're making a class that might show up on the designer surface or in a property grid.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您是否尝试过将&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.componentmodel.defaultvalueattribute.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DefaultValueAttribute&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/53b8022e%28VS.71%29.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ShouldSerialize和Reset方法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与构造函数结合使用？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我觉得如果要创建一个可能显示在设计器表面或属性网格中的类，则必须使用这两种方法之一。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ffcb42672def6cb234f448a552018f2b802fa4e" translate="yes" xml:space="preserve">
          <source>Hmm... maybe this will be the subject of it's own question later</source>
          <target state="translated">嗯......也许这将是以后的问题的主题。</target>
        </trans-unit>
        <trans-unit id="bb1cc6a87045d53086bd7c6363212085e878e92d" translate="yes" xml:space="preserve">
          <source>Hope that helps!</source>
          <target state="translated">希望对你有帮助!</target>
        </trans-unit>
        <trans-unit id="cc5160f1f43c6af1b685486a44a3df63bfb710c7" translate="yes" xml:space="preserve">
          <source>How do you give a C# auto-property an initial value?</source>
          <target state="translated">如何给C#自动属性一个初始值?</target>
        </trans-unit>
        <trans-unit id="30f1eac29f8fadccf9e9ea2f92599614c1a524ef" translate="yes" xml:space="preserve">
          <source>I either use the constructor, or revert to the old syntax.</source>
          <target state="translated">我要么使用构造函数,要么恢复到旧的语法。</target>
        </trans-unit>
        <trans-unit id="294a19adc842bd40c122613a4bf38fcafd45e131" translate="yes" xml:space="preserve">
          <source>I think this would do it for ya givng SomeFlag a default of false.</source>
          <target state="translated">我想这样做可以让你把SomeFlag默认为false。</target>
        </trans-unit>
        <trans-unit id="e3e16819c3e1e3a7fc5d692d2c867b961f8d0f77" translate="yes" xml:space="preserve">
          <source>I would argue that this syntax was best practice in C# up to 5:</source>
          <target state="translated">我认为这种语法是C#5之前的最佳实践。</target>
        </trans-unit>
        <trans-unit id="7d1da389e3d408009426ff5f0bc9e48b657d3427" translate="yes" xml:space="preserve">
          <source>I'd avoid adding a default to the constructor; leave that for dynamic assignments and avoid having two points at which the variable is assigned (i.e. the type default and in the constructor). Typically I'd simply write a normal property in such cases.</source>
          <target state="translated">我会避免在构造函数中添加一个默认值;将其留给动态分配,并避免在两个点上分配变量(即类型默认值和构造函数中)。通常情况下,我会简单地写一个普通属性,在这种情况下。</target>
        </trans-unit>
        <trans-unit id="ba44dec5e099eae52109afed430816c62175ba10" translate="yes" xml:space="preserve">
          <source>In C# 5 and earlier, to give auto implemented properties an initial value, you have to do it in a constructor.</source>
          <target state="translated">在C#5和更早的版本中,要给自动实现的属性一个初始值,你必须在构造函数中进行。</target>
        </trans-unit>
        <trans-unit id="66210d0d26b5f4286f5559b26b20d16dcd2e307b" translate="yes" xml:space="preserve">
          <source>In C# 6 and above you can simply use the syntax:</source>
          <target state="translated">在C#6及以上版本中,你可以简单地使用语法。</target>
        </trans-unit>
        <trans-unit id="7101bf65be0d5524bb0ea25e418d4e3d845db035" translate="yes" xml:space="preserve">
          <source>In C# 6.0 this is a breeze!</source>
          <target state="translated">在C#6.0中,这简直是轻而易举!</target>
        </trans-unit>
        <trans-unit id="b5d68322ad4675fc0f70d7107c9320d74b1ea8de" translate="yes" xml:space="preserve">
          <source>In Version of &lt;em&gt;C# (6.0) &amp;amp; greater&lt;/em&gt;, you can do :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C＃（6.0）及更高版本中&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您可以执行以下操作：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60401e067e3786ee3e16d62f9950ef4f7ed81104" translate="yes" xml:space="preserve">
          <source>In addition to the answer already accepted, for the scenario when you want to define a default property as a &lt;em&gt;function&lt;/em&gt; of other properties you can use &lt;strong&gt;&lt;em&gt;expression body notation&lt;/em&gt;&lt;/strong&gt; on C#6.0 (and higher) for even more elegant and concise constructs like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除了已经接受的答案外，对于要定义默认属性作为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其他属性&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数的情况&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C＃6.0（及更高版本）上&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表达式主体符号&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来实现更优雅，简洁的结构，例如：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5cd6d774f5a030e671b23830fab91011d48ee807" translate="yes" xml:space="preserve">
          <source>In current Version of &lt;em&gt;C# (7.0)&lt;/em&gt;, you can do : (The snippet rather displays how you can use expression bodied get/set accessors to make is more compact when using with backing fields)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在当前版本的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C＃（7.0）中&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您可以执行以下操作：（该代码段显示的是，在与后备字段一起使用时，如何使用表达式绑定的获取/设置访问器使表达式更紧凑）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="794fb949df187b39811af6d7644259ba7e4660c7" translate="yes" xml:space="preserve">
          <source>In order to be able to use the above &quot;=&amp;gt;&quot; notation, the property must be read only, and you do not use the get accessor keyword.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了能够使用上面的&amp;ldquo; =&amp;gt;&amp;rdquo;表示法，该属性必须是只读的，并且不要使用get accessor关键字。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7d54a7be1c5622cb4ea0a8043a79e2217d9ebf59" translate="yes" xml:space="preserve">
          <source>In the constructor.  The constructor's purpose is to initialized it's data members.</source>
          <target state="translated">在构造函数中。构造函数的目的是初始化它的数据成员。</target>
        </trans-unit>
        <trans-unit id="ba65ad098f85ce8e0fcd83fdc5b9cf9c3fab4426" translate="yes" xml:space="preserve">
          <source>Is there a better way?</source>
          <target state="translated">有没有更好的方法?</target>
        </trans-unit>
        <trans-unit id="11a986f617d07e6dbee601ec64a3f0b8c88b33ad" translate="yes" xml:space="preserve">
          <source>My solution is to use a custom attribute that provides default value property initialization by constant or using property type initializer.</source>
          <target state="translated">我的解决方案是使用自定义属性,通过常量或使用属性类型初始化器提供默认值属性初始化。</target>
        </trans-unit>
        <trans-unit id="8d717461faef04d94163ab001c93419cd0902fef" translate="yes" xml:space="preserve">
          <source>Note that to have a &lt;code&gt;readonly&lt;/code&gt; property simply omit the set, as so:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，要拥有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;属性，只需忽略该设置即可，如下所示：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="45f49c79ea5cc5e16b0d4619b13d5c736cdd7f8e" translate="yes" xml:space="preserve">
          <source>Obviously if it's not a string then I might make the object nullable ( double?, int? ) and check if it's null, return a default, or return the value it's set to.</source>
          <target state="translated">很明显,如果它不是字符串,那么我可能会让对象为nullable(double?,int?),并检查它是否为null,返回一个默认值,或者返回它的值。</target>
        </trans-unit>
        <trans-unit id="467b26f52af02e8a2806378b66e8797a53065fab" translate="yes" xml:space="preserve">
          <source>One other option is to do what ASP.Net does and define defaults via an attribute:</source>
          <target state="translated">另一个选择是像ASP.Net那样,通过属性定义默认值。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="b3a5cb824ff9aadde5b30af03d3dbb2b5f994af4" translate="yes" xml:space="preserve">
          <source>Personally, I don't see the point of making it a property at all if you're not going to do  anything at all beyond the auto-property.  Just leave it as a field.  The encapsulation benefit for these item are just red herrings, because there's nothing behind them to encapsulate.  If you ever need to change the underlying implementation you're still free to refactor them as properties without breaking any dependent code.</source>
          <target state="translated">就我个人而言,如果你不打算在自动属性之外做任何事情,我认为根本没有必要把它作为一个属性。就把它作为一个字段留着吧。这些项的封装好处只是红鲱鱼,因为背后没有什么东西可以封装。如果你需要改变底层实现,你仍然可以在不破坏任何依赖代码的情况下将它们作为属性重构。</target>
        </trans-unit>
        <trans-unit id="ceb09e6d8bf290034dd33caa29f2f4530d4bcf27" translate="yes" xml:space="preserve">
          <source>Prior to this I responded as below.</source>
          <target state="translated">在这之前,我的答复如下。</target>
        </trans-unit>
        <trans-unit id="930b3b23cff0eb68b2882853b258c5a52353c09b" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;http://blogs.msmvps.com/jonskeet/2014/04/04/c-6-first-reactions/&quot;&gt;C# 6: First reactions , Initializers for automatically implemented properties - By Jon Skeet&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参阅：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msmvps.com/jonskeet/2014/04/04/c-6-first-reactions/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C＃6：第一个反应，用于自动实现的属性的初始化程序-Jon Skeet&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae9966c7d7daf8ce67ffe3300908a118efbb770e" translate="yes" xml:space="preserve">
          <source>Since C# 6.0, you can specify initial value in-line. The syntax is:</source>
          <target state="translated">从C#6.0开始,你可以在线指定初始值。其语法是。</target>
        </trans-unit>
        <trans-unit id="7e43a357d3a0c38b1a995cd068429d833232155f" translate="yes" xml:space="preserve">
          <source>Sometimes I use this, if I don't want it to be actually set and persisted in my db:</source>
          <target state="translated">有时,如果我不希望它在我的数据库中被实际设置和坚持,我就会使用这个。</target>
        </trans-unit>
        <trans-unit id="20fc53e44f54098334182398215f384c4ffc06da" translate="yes" xml:space="preserve">
          <source>The point here is that the instance variable drawn from the base class may bury your base field name.  Setting the current instantiated object value using &quot;this.&quot; will allow you to correctly form your object with respect to the current instance and required permission levels (access modifiers) where you are instantiating it.</source>
          <target state="translated">这里的重点是,从基类中引出的实例变量可能会埋没你的基字段名。使用 &quot;this.&quot;设置当前实例化对象的值,可以让你正确地形成你的对象与当前实例和所需的权限级别(访问修改器)相关的实例化对象。</target>
        </trans-unit>
        <trans-unit id="b85aa3eee23d0718bceae9396501c0c468d1fbef" translate="yes" xml:space="preserve">
          <source>Then I can make a check in my repository to see if it's my default and not persist, or make a backdoor check in to see the true status of the backing value, before saving.</source>
          <target state="translated">然后我可以在我的存储库里做一个检查,看看是否是我默认的,不坚持,或者做一个后门检查,看一下备份值的真实状态,然后再保存。</target>
        </trans-unit>
        <trans-unit id="51d0c44fe22f09c90e085c9e3757dd10e83ef1de" translate="yes" xml:space="preserve">
          <source>Though the intended use of the attribute is not to actually set the values of the properties, you can use reflection to always set them anyway...</source>
          <target state="translated">虽然属性的预期用途不是实际设置属性的值,但你可以使用反射来始终设置属性的值......</target>
        </trans-unit>
        <trans-unit id="d057a1a916d855d00d2f4f9dbf3b8e67e04d7ff6" translate="yes" xml:space="preserve">
          <source>To clarify, yes, you need to set default values in the constructor for class derived objects.  You will need to ensure the constructor exists with the proper access modifier for construction where used.  If the object is not instantiated, e.g. it has no constructor (e.g. static methods) then the default value can be set by the field.  The reasoning here is that the object itself will be created only once and you do not instantiate it.</source>
          <target state="translated">为了澄清一下,是的,你需要在构造函数中为类派生对象设置默认值。你需要确保构造函数存在,并在使用构造的地方使用适当的访问修改器。如果对象没有被实例化,例如,它没有构造函数(例如静态方法),那么可以通过字段设置默认值。这里的理由是,对象本身只会被创建一次,而你不会实例化它。</target>
        </trans-unit>
        <trans-unit id="6dcc6663115112d3b2ea940d2425b20386b0f4dc" translate="yes" xml:space="preserve">
          <source>To use this attribute it's necessary to inherit a class from special base class-initializer or use a static helper method:</source>
          <target state="translated">要使用这个属性,必须从特殊的基类初始化器继承一个类,或者使用静态辅助方法。</target>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="translated">用例:</target>
        </trans-unit>
        <trans-unit id="324d1df68a2a46d27e8d85317d55003c4831e2cf" translate="yes" xml:space="preserve">
          <source>Use the constructor because &quot;When the constructor is finished, Construction should be finished&quot;. properties are like states your classes hold, if you had to initialize a default state, you would do that in your constructor.</source>
          <target state="translated">使用构造器,因为 &quot;当构造器完成后,构造就应该完成了&quot;,属性就像你的类所持有的状态一样,如果你要初始化一个默认状态,你就会在构造器中进行。</target>
        </trans-unit>
        <trans-unit id="8a7394bd66ec0dce7553b773603f227220dada72" translate="yes" xml:space="preserve">
          <source>We can also create read-only auto implemented property like:</source>
          <target state="translated">我们还可以创建只读的自动实现属性,比如。</target>
        </trans-unit>
        <trans-unit id="2a081ef4ca8b1b23e21bbb4bca004ca4172051c0" translate="yes" xml:space="preserve">
          <source>What is the best way to give a C# auto-property an initial value</source>
          <target state="translated">赋予C#自动属性一个初始值的最佳方法是什么?</target>
        </trans-unit>
        <trans-unit id="29a9336308d4fedeca1f9c87d1abe7a51487dbc0" translate="yes" xml:space="preserve">
          <source>When you inline an initial value for a variable it will be done implicitly in the constructor anyway.</source>
          <target state="translated">当你内联一个变量的初始值时,它将在构造函数中隐式地完成。</target>
        </trans-unit>
        <trans-unit id="85fba9a98cbb523590e8691a9c6900b1aa9233bb" translate="yes" xml:space="preserve">
          <source>With C# 6 you can initialize auto-properties directly (finally!), there are now other answers in the thread that describe that.</source>
          <target state="translated">在C#6中,你可以直接初始化自动属性(终于!),现在在线程中还有其他的答案描述了。</target>
        </trans-unit>
        <trans-unit id="450c27608618b95b7f54a7e888cad79a09a79fbb" translate="yes" xml:space="preserve">
          <source>You can also assign &lt;code&gt;readonly&lt;/code&gt; auto-properties from the constructor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您还可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从构造函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分配&lt;/font&gt;&lt;/font&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自动属性。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="43ef8484820fc9fd0489207cfa17de705c94f53c" translate="yes" xml:space="preserve">
          <source>You can do it in the &lt;code&gt;Class&lt;/code&gt; declaration itself, in the property declaration statements.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;声明本身的属性声明语句中进行操作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f6b49685c242a4eaa3cdb8af7ed7923149df4ae6" translate="yes" xml:space="preserve">
          <source>You can use the above in the following fashion</source>
          <target state="translated">你可以用下面的方式使用上述内容</target>
        </trans-unit>
        <trans-unit id="6335bceb1baad72e8a610cc0144ed8bef27a988d" translate="yes" xml:space="preserve">
          <source>little complete sample:</source>
          <target state="translated">有点完整的样本。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
