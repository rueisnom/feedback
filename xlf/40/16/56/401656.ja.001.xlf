<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/401656">
    <body>
      <group id="401656">
        <trans-unit id="4bd6398b6ec50d16e0ba8b718869fa0726943b47" translate="yes" xml:space="preserve">
          <source>(Emphasis mine.)</source>
          <target state="translated">(私が強調します)</target>
        </trans-unit>
        <trans-unit id="d54e60153602d914878e89e59608b8d75275ed9e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/sha1&quot;&gt;SHA1&lt;/a&gt; and a salt should suffice (depending, naturally, on whether you are coding something for &lt;a href=&quot;http://en.wikipedia.org/wiki/United_States_Bullion_Depository&quot;&gt;Fort Knox&lt;/a&gt; or a login system for your shopping list) for the foreseeable future. If SHA1 isn't good enough for you, use &lt;a href=&quot;http://php.net/manual/en/function.hash.php&quot;&gt;SHA256&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/sha1&quot;&gt;SHA1&lt;/a&gt;とソルトで十分なはずです（当然、 &lt;a href=&quot;http://en.wikipedia.org/wiki/United_States_Bullion_Depository&quot;&gt;Fort Knox&lt;/a&gt;用にコーディングするか、ショッピングリスト用のログインシステムにコーディングするかによって異なります）。 SHA1では不十分な場合は、 &lt;a href=&quot;http://php.net/manual/en/function.hash.php&quot;&gt;SHA256を&lt;/a&gt;使用してください 。</target>
        </trans-unit>
        <trans-unit id="a49d7ecc7c611924a2bdc550b87beda1e36e7adf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xkcd.com/936/&quot;&gt;Entropy&lt;/a&gt;. (Not that I fully subscribe to Randall's viewpoint.)</source>
          <target state="translated">&lt;a href=&quot;http://xkcd.com/936/&quot;&gt;エントロピー&lt;/a&gt; 。 （私がRandallの視点に完全に同意しているわけではありません。）</target>
        </trans-unit>
        <trans-unit id="331904e34fbc8be8527a2f2cc0ab551951a291a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919&quot;&gt;excellent answer&lt;/a&gt; with more about why &lt;code&gt;password_hash()&lt;/code&gt; or &lt;code&gt;phpass&lt;/code&gt; are the best way to go.</source>
          <target state="translated">&lt;code&gt;password_hash()&lt;/code&gt; または &lt;code&gt;phpass&lt;/code&gt; が最適な方法である理由についての詳しい&lt;a href=&quot;https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919&quot;&gt;回答&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6f914dd88be09eb21067092dec3c341a6e91895" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/&quot;&gt;good blog article&lt;/a&gt; giving recommmended 'work factors' (number of iterations) for main algorithms including bcrypt, scrypt and PBKDF2.</source>
          <target state="translated">bcrypt、scrypt、PBKDF2などの主要なアルゴリズムに推奨される「作業係数」（反復回数）を示す&lt;a href=&quot;https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/&quot;&gt;優れたブログ記事&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="55f55510afeb77726e0d50b49639b6d98210693b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_get_info()&lt;/code&gt; - returns information about the given hash</source>
          <target state="translated">&lt;code&gt;password_get_info()&lt;/code&gt; -指定されたハッシュに関する情報を返します</target>
        </trans-unit>
        <trans-unit id="511d82aef08cd670da59b1470aced89fce228ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_hash()&lt;/code&gt; - creates a password hash</source>
          <target state="translated">&lt;code&gt;password_hash()&lt;/code&gt; -パスワードハッシュを作成する</target>
        </trans-unit>
        <trans-unit id="e53608eb6b90132ef76064ce05e5793fc484cd3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_needs_rehash()&lt;/code&gt; - checks if the given hash matches the given options. Useful to check if the hash conforms to your current technique/cost scheme allowing you to rehash if necessary</source>
          <target state="translated">&lt;code&gt;password_needs_rehash()&lt;/code&gt; -指定されたハッシュが指定されたオプションと一致するかどうかを確認します。 ハッシュが現在の手法/コストスキームに準拠しているかどうかを確認するのに役立ち、必要に応じてハッシュを再作成できます。</target>
        </trans-unit>
        <trans-unit id="ab3126d5de685d9c71a7a339b3efcf5bed455a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_verify()&lt;/code&gt; - verifies that a password matches a hash</source>
          <target state="translated">&lt;code&gt;password_verify()&lt;/code&gt; -パスワードがハッシュと一致することを確認する</target>
        </trans-unit>
        <trans-unit id="b4b45af4d94ab99b5074596633ad5d1dd429fc9d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HASHING&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HASHING&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae35617fc2a3e929f057c2ac76f291842cfc1b34" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PASSWORD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PASSWORD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cc85735d6d4bc3f8eb14617d7b3510366c3c30c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PORTS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PORTS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f14c91feaf4967ef247273e68b9a406a2c8c581" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Related questions that don't quite cover my question:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;私の質問を完全にカバーしない関連質問：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed1c080c450a82285e50d7a816ddc03a0863f19a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SALTING&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SALTING&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5977b0e7ee94c66e337dded2dd5bbe8a4ad8b2cb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SERVER&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SERVER&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="23118db0e558706fb2facd763d94ae2dcff3c884" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USER&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;USER&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="603ff9cd887ac389320761a219db9bf3b57244d7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USERNAME&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;USERNAME&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f77d76027e0db3dd25ad0ea328da229ae899dcd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USERS CREATING PASSWORDS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;パスワードを作成するユーザー&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="896fefe79b5f0b7a660920e0a621a010a9b8870b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DATABASE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DATABASE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d67cf51a25a2a4dbc01f9a24286e1ab97db82f1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DISCLAIMER&lt;/strong&gt;: This answer was written in 2008.</source>
          <target state="translated">&lt;strong&gt;免責事項&lt;/strong&gt; ：この回答は2008年に書かれました。</target>
        </trans-unit>
        <trans-unit id="c0ea0dc97baa1d4c675361104fa844e8cea6bf02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PHP&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ff333e7b1ff670b7f3dc5b40367c60de2baedb6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Quick self-test:&lt;/strong&gt; what is password stretching and how many iterations should you use?  If you don't know the answer, you should use &lt;code&gt;password_hash()&lt;/code&gt;, as password stretching is now a critical feature of password mechanisms due to much faster CPUs and the use of &lt;a href=&quot;http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/&quot;&gt;GPUs and FPGAs&lt;/a&gt; to crack passwords at rates of &lt;a href=&quot;http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches&quot;&gt;billions of guesses per second&lt;/a&gt; (with GPUs).</source>
          <target state="translated">&lt;strong&gt;クイックセルフテスト：&lt;/strong&gt;パスワードストレッチングとは何ですか？また、何回反復する必要がありますか？ 答えがわからない場合は、 &lt;code&gt;password_hash()&lt;/code&gt; を使用する必要があります。これは、CPUの高速化と、 &lt;a href=&quot;http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/&quot;&gt;GPUおよびFPGA&lt;/a&gt;を使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches&quot;&gt;して1秒あたり数十億回の推測&lt;/a&gt;でパスワードを解読するため、パスワードメカニズムの重要な機能であるためです。 （GPUを使用）。</target>
        </trans-unit>
        <trans-unit id="aed0191173d72ecf54d46939a34acf7570a79ca0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SERVER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SERVER&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="551e0b7660ec60a1ba024654ebf85dd6e11ea8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;以下も参照してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ead3f7341c29026742f5a4b0dd3a0003a1ebcb6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THINGS TO REMEMBER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;覚えておくべきこと&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e902296e6d584c43a7b6d565ce2461560a6e091" translate="yes" xml:space="preserve">
          <source>A lot has been said about Password encryption for PHP, most of which is very good advice, but before you even start the process of using PHP for password encryption make sure you have the following implemented or ready to be implemented.</source>
          <target state="translated">PHP のパスワード暗号化については多くのことが言われていますが、そのほとんどは非常に良いアドバイスです。</target>
        </trans-unit>
        <trans-unit id="d338f3026e67ebbe13c96fce36d81cb026d9f87c" translate="yes" xml:space="preserve">
          <source>A much shorter and safer answer - &lt;strong&gt;don't write your own password mechanism at all&lt;/strong&gt;, use a tried and tested mechanism.</source>
          <target state="translated">はるかに短くて安全な答え- &lt;strong&gt;独自のパスワードメカニズムをまったく作成せず&lt;/strong&gt; 、実証済みのメカニズムを使用&lt;strong&gt;してください&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dd080286c78745102f80f80549cafcb94e6e124" translate="yes" xml:space="preserve">
          <source>Also make the user create a secure password, it is simple and should always be done, the user will be grateful for it in the end.</source>
          <target state="translated">また、ユーザーが安全なパスワードを作成するように、それは簡単であり、常に行われるべきである、ユーザーは最終的にはそれのために感謝されます。</target>
        </trans-unit>
        <trans-unit id="9a29f79b84bf18b505a34d003c5ea678dd34f78a" translate="yes" xml:space="preserve">
          <source>Also, double-hashing is generally regarded as bad method, because it diminishes the result space. All popular hashes are fixed-length. Thus, you can have only a finite values of this fixed length, and the results become less varied. This &lt;em&gt;could&lt;/em&gt; be regarded as another form of salting, but I wouldn't recommend it.</source>
          <target state="translated">また、ダブルハッシュは結果スペースを減少させるため、一般に悪い方法と見なされます。 すべての一般的なハッシュは固定長です。 したがって、この固定長の有限値のみを持つことができ、結果のばらつきは少なくなります。 これ&lt;em&gt;は&lt;/em&gt;別の形の塩漬けと見なす&lt;em&gt;こと&lt;/em&gt;も&lt;em&gt;でき&lt;/em&gt;ますが、お勧めしません。</target>
        </trans-unit>
        <trans-unit id="47b974489931634025c710e17d5db41c06e42742" translate="yes" xml:space="preserve">
          <source>Also, should I store two fields in the database (one using MD5 and another one using SHA, for example)? Would it make it safer or unsafer?</source>
          <target state="translated">また、データベースに2つのフィールド(1つはMD5を使用して、もう1つはSHAを使用して、例えば)を格納した方がいいのでしょうか?その方が安全でしょうか、それとも安全ではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="7689b604462baa981c885266a977b157013806aa" translate="yes" xml:space="preserve">
          <source>Always have your application have its own account to access the DB, and only give it the privileges it will need.</source>
          <target state="translated">常にアプリケーションに独自のアカウントを持たせてDBにアクセスさせ、必要な権限だけを与えるようにしましょう。</target>
        </trans-unit>
        <trans-unit id="3b1bb0601fe6d9e262b3597a1689b03d4b982615" translate="yes" xml:space="preserve">
          <source>Another reason that you want a good, robust hash on a user accounts is to give you enough time to change all the passwords in the system. If your database is compromised you will need enough time to at &lt;em&gt;least&lt;/em&gt; lock the system down, if not change every password in the database.</source>
          <target state="translated">ユーザーアカウントに適切で堅牢なハッシュが必要なもう1つの理由は、システム内のすべてのパスワードを変更するのに十分な時間を与えるためです。 データベースが危険にさらされている場合、データベースのすべてのパスワードを変更しない場合でも、 &lt;em&gt;少なくとも&lt;/em&gt;システムをロックダウンするのに十分な時間が必要です。</target>
        </trans-unit>
        <trans-unit id="fc8b9b7b7e69aecc8d6210a0592328219dceab04" translate="yes" xml:space="preserve">
          <source>As of PHP 5.5, PHP has simple, secure functions for hashing and verifying passwords, &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash()&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;password_verify()&lt;/a&gt;</source>
          <target state="translated">PHP 5.5以降、PHPにはパスワードのハッシュ化と検証のためのシンプルで安全な関数、 &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash（）&lt;/a&gt;と&lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;password_verify（）が&lt;/a&gt;あります。</target>
        </trans-unit>
        <trans-unit id="6ea99ddf0910092b785f4db900f1d1881fb27c6a" translate="yes" xml:space="preserve">
          <source>At the moment these functions accept the PASSWORD_BCRYPT and PASSWORD_DEFAULT password constants, which are synonymous at the moment, the difference being that PASSWORD_DEFAULT &quot;may change in newer PHP releases when newer, stronger hashing algorithms are supported.&quot; Using PASSWORD_DEFAULT and password_needs_rehash() on login (and rehashing if necessary) should ensure that your hashes are reasonably resilient to brute-force attacks with little to no work for you.</source>
          <target state="translated">現時点では、これらの関数はパスワード定数 PASSWORD_BCRYPT および PASSWORD_DEFAULT を受け付けており、これらは同義です。ログイン時にPASSWORD_DEFAULTとpassword_needs_rehash()を使用することで(必要に応じて再ハッシュを行うことで)、ハッシュはブルートフォース攻撃に耐えられるようになります。</target>
        </trans-unit>
        <trans-unit id="8bc33659ae93746ba57bab9705cc4dea91e1472b" translate="yes" xml:space="preserve">
          <source>Average practices</source>
          <target state="translated">平均的な実践</target>
        </trans-unit>
        <trans-unit id="f6015c3a8cc452ac75b47eabd9579dadfdb0ffe6" translate="yes" xml:space="preserve">
          <source>Bcrypt and &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;scrypt&lt;/a&gt; are the current best practices. &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;Scrypt&lt;/a&gt; will be better than bcrypt in time, but it hasn't seen adoption as a standard by Linux/Unix or by webservers, and hasn't had in-depth reviews of its algorithm posted yet. But still, the future of the algorithm does look promising. If you are working with Ruby there is an &lt;a href=&quot;http://rubygems.org/gems/scrypt&quot;&gt;scrypt gem&lt;/a&gt; that will help you out, and Node.js now has its own &lt;a href=&quot;https://npmjs.org/package/scrypt&quot;&gt;scrypt&lt;/a&gt; package. You can use Scrypt in PHP either via the &lt;a href=&quot;https://pecl.php.net/package/scrypt&quot;&gt;Scrypt&lt;/a&gt; extension or the &lt;a href=&quot;https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md&quot;&gt;Libsodium&lt;/a&gt; extension (both are available in PECL).</source>
          <target state="translated">Bcryptと&lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;scrypt&lt;/a&gt;は現在のベストプラクティスです。 &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;Scrypt&lt;/a&gt;は時間の経過とともにbcryptよりも優れていますが、Linux / UnixやWebサーバーによる標準としての採用は見られておらず、アルゴリズムの詳細なレビューはまだ投稿されていません。 しかし、それでも、アルゴリズムの将来は有望に見えます。 Rubyを使用している場合は、それを支援する&lt;a href=&quot;http://rubygems.org/gems/scrypt&quot;&gt;scrypt gem&lt;/a&gt;があり、Node.jsには独自の&lt;a href=&quot;https://npmjs.org/package/scrypt&quot;&gt;scrypt&lt;/a&gt;パッケージがあります。 PHPでScryptを使用するには、 &lt;a href=&quot;https://pecl.php.net/package/scrypt&quot;&gt;Scrypt&lt;/a&gt;拡張機能または&lt;a href=&quot;https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md&quot;&gt;Libsodium&lt;/a&gt;拡張機能を使用します（どちらもPECLで使用できます）。</target>
        </trans-unit>
        <trans-unit id="eb8de9ce8757ee3c542141ac80ff3b33dc04edff" translate="yes" xml:space="preserve">
          <source>Best practices</source>
          <target state="translated">ベストプラクティス</target>
        </trans-unit>
        <trans-unit id="2de241bdf77a55e27f8fca0e42659620a7b0aefe" translate="yes" xml:space="preserve">
          <source>But suppose that you cannot use bcrypt or PHPASS at all. What then?</source>
          <target state="translated">しかし、仮に bcrypt や PHPASS が全く使えないとします。その場合はどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="117f2a5735e534774bb47e831d678f2aadc64e41" translate="yes" xml:space="preserve">
          <source>By default it used strongest available encryption that is implemented in Phpass, which is &lt;code&gt;bcrypt&lt;/code&gt; and falls back to other encryptions down to MD5 to provide backward compatibility to frameworks like Wordpress.</source>
          <target state="translated">デフォルトでは、Phpassに実装されている使用可能な最も強力な暗号化を使用しました。これは &lt;code&gt;bcrypt&lt;/code&gt; であり、他の暗号化からMD5にフォールバックして、Wordpressなどのフレームワークに下位互換性を提供します。</target>
        </trans-unit>
        <trans-unit id="b633fdfaff7ad5fc7b721447cc8831c42591c4bc" translate="yes" xml:space="preserve">
          <source>Coming in PHP 5.5 is a &lt;a href=&quot;http://php.net/manual/en/ref.password.php&quot;&gt;full password protection library&lt;/a&gt; that abstracts away any pains of working with bcrypt. While most of us are stuck with PHP 5.2 and 5.3 in most common environments, especially shared hosts, @ircmaxell has built a &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility layer&lt;/a&gt; for the coming API that is backward compatible to PHP 5.3.7.</source>
          <target state="translated">PHP 5.5で登場するのは、bcryptでの作業の苦痛を取り除く&lt;a href=&quot;http://php.net/manual/en/ref.password.php&quot;&gt;完全なパスワード保護ライブラリ&lt;/a&gt;です。 私たちのほとんどは、ほとんどの一般的な環境、特に共有ホストでPHP 5.2と5.3を使い続けていますが、@ ircmaxellは、PHP 5.3.7と下位互換性のあるAPIの&lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;互換性レイヤー&lt;/a&gt;を構築しています。</target>
        </trans-unit>
        <trans-unit id="af9cf1efb4bd36a869c85c6db68040652b17d4ae" translate="yes" xml:space="preserve">
          <source>Cryptography Recap &amp;amp; Disclaimer</source>
          <target state="translated">暗号の要約と免責事項</target>
        </trans-unit>
        <trans-unit id="2ef42ffab4aacba15da77cf466976e72bd80c6f0" translate="yes" xml:space="preserve">
          <source>Don't limit the length of a password. If your users want a sentence with supercalifragilisticexpialidocious in it, don't prevent them from using it.</source>
          <target state="translated">パスワードの長さを制限しないでください。あなたのユーザーがsupercalifragilagilisticexpialidociousを含む文章を欲しがっているなら、それを使用することを妨げないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="b6a9c3be345b95b031149b5d719b84262d749a02" translate="yes" xml:space="preserve">
          <source>Don't limit what characters users can enter for passwords. Only idiots do this.</source>
          <target state="translated">パスワードにユーザーが入力できる文字数を制限しないでください。こんなことをするのはバカだけ。</target>
        </trans-unit>
        <trans-unit id="57b8188ffa4f6ec3553dfe244191b42014f16984" translate="yes" xml:space="preserve">
          <source>Don't mix &lt;a href=&quot;http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html&quot;&gt;bcrypt and with the &lt;em&gt;raw&lt;/em&gt; output of hash()&lt;/a&gt;, either use hex output or base64_encode it. (This applies to any input that may have a rogue &lt;code&gt;\0&lt;/code&gt; in it, which can seriously weaken security.)</source>
          <target state="translated">&lt;a href=&quot;http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html&quot;&gt;bcryptとhash（）の&lt;em&gt;生の&lt;/em&gt;出力を&lt;/a&gt;混在させないでください。16進出力を使用するか、base64_encodeを使用してください。 （これは、不正な &lt;code&gt;\0&lt;/code&gt; れている可能性のあるすべての入力に適用され、セキュリティが著しく低下する可能性があります。）</target>
        </trans-unit>
        <trans-unit id="b14bcf13287ceb3241fed3d968a38802da7cb034" translate="yes" xml:space="preserve">
          <source>Don't strip or escape HTML and special characters in the password.</source>
          <target state="translated">パスワードのHTMLや特殊文字を剥がしたり、エスケープしたりしないでください。</target>
        </trans-unit>
        <trans-unit id="093743f90c366f3346a4626e0147ea26113350c4" translate="yes" xml:space="preserve">
          <source>Don'ts</source>
          <target state="translated">Don'ts</target>
        </trans-unit>
        <trans-unit id="586c15c6fd8448116ae5a0f2e995d41e36f153b8" translate="yes" xml:space="preserve">
          <source>Dos</source>
          <target state="translated">Dos</target>
        </trans-unit>
        <trans-unit id="951e25161bf6bbd8580e18709c3c792954ee12e4" translate="yes" xml:space="preserve">
          <source>EDIT: I just realised that this is mentioned briefly in Robert K's answer. I'll leave this answer here since I think it provides a bit more information about how it works and the ease of use it provides for those who don't know security.</source>
          <target state="translated">EDIT:今気がついたのですが、Robert Kさんの回答の中でこのことが簡単に触れられています。この回答は、セキュリティを知らない人のために、その仕組みや使いやすさについて、もう少し詳しい情報を提供してくれると思うので、ここに残しておきます。</target>
        </trans-unit>
        <trans-unit id="5aed566d3e7f4533ea18f62aa39f7cec10ce35f6" translate="yes" xml:space="preserve">
          <source>Finally, no matter the security measures you take nothing is 100% secure, the more advanced the technology to protect becomes the more advanced the attacks become. But following these steps will make your site more secure and far less desirable for attackers to go after.</source>
          <target state="translated">最後に、どのようなセキュリティ対策を講じても、100%安全なものはありません。しかし、これらのステップに従うことで、あなたのサイトはより安全になり、攻撃者にとってははるかに望ましくないものになります。</target>
        </trans-unit>
        <trans-unit id="bfdae5a79adfab1e18ea1d0102894a2dccc076bf" translate="yes" xml:space="preserve">
          <source>Follow the same guidelines as with all good passwords. Also don't reuse the same password on any SERVER or DB accounts on the same system.</source>
          <target state="translated">すべての良いパスワードと同じガイドラインに従ってください。また、同じシステム上のサーバーやDBアカウントで同じパスワードを再利用しないでください。</target>
        </trans-unit>
        <trans-unit id="f46f0816adc340442cfbcc816c79aadee7d62c1c" translate="yes" xml:space="preserve">
          <source>For all that is good in the world do not use the username admin, root or something similar. Also if you are on a unix based system DO NOT make the root account login accessible, it should always be sudo only.</source>
          <target state="translated">世界のすべての良いことのために、ユーザー名をadmin、root、またはそれに似たものを使用しないでください。また、Unixベースのシステムを使用している場合は、rootアカウントのログインにアクセスできるようにしないでください。</target>
        </trans-unit>
        <trans-unit id="d9ea1176666f5e2cfe77b291548afa7d1dd3e910" translate="yes" xml:space="preserve">
          <source>For example, you can &lt;a href=&quot;http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/&quot;&gt;crack all 8-character Windows passwords in 6 hours&lt;/a&gt; using 25 GPUs installed in 5 desktop PCs.  This is brute-forcing i.e. enumerating and checking &lt;em&gt;every 8-character Windows password&lt;/em&gt;, including special characters, and is not a dictionary attack. That was in 2012, as of 2018 you could use fewer GPUs, or crack faster with 25 GPUs.</source>
          <target state="translated">たとえば、5台のデスクトップPCにインストールされた25個のGPUを使用&lt;a href=&quot;http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/&quot;&gt;すると、8文字のWindowsパスワードすべてを6時間で解読&lt;/a&gt;できます。 これはブルートフォースです。つまり、特殊文字を含む&lt;em&gt;すべての8文字のWindowsパスワードを&lt;/em&gt;列挙およびチェックするものであり、辞書攻撃ではありません。 それは2012年のことでしたが、2018年の時点で、使用するGPUの数を減らすか、25のGPUでクラックを高速化できました。</target>
        </trans-unit>
        <trans-unit id="5638ccd08221ca60e74b51eedce8f8691850aa0d" translate="yes" xml:space="preserve">
          <source>Future Practices</source>
          <target state="translated">今後の実践</target>
        </trans-unit>
        <trans-unit id="8cdb7a0b3b6ace5e886174a72b1782806543e80f" translate="yes" xml:space="preserve">
          <source>Google says SHA256 is available to PHP.</source>
          <target state="translated">Googleによると、PHPではSHA256が利用可能だそうです。</target>
        </trans-unit>
        <trans-unit id="6dfd63230af2892f2f367f0290c4dfd849f7dc6a" translate="yes" xml:space="preserve">
          <source>Here is a PHP class that creates a hash and salt for a password easily</source>
          <target state="translated">パスワードのハッシュとソルトを簡単に作成するPHPクラスは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="d3de020d4de5c9ec8acb08596101993264195d55" translate="yes" xml:space="preserve">
          <source>How would you implement salted passwords in Tomcat 5.5</source>
          <target state="translated">Tomcat 5.5で塩漬けパスワードを実装するには?</target>
        </trans-unit>
        <trans-unit id="094dfed6a03363f271cb6e9eb1fbbe95ffe3f66b" translate="yes" xml:space="preserve">
          <source>I almost can't imagine this situation anymore. &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt; supports PHP 3.0.18 through 5.3, so it is usable on almost every installation imaginable&amp;mdash;and should be used if you don't &lt;em&gt;know for certain&lt;/em&gt; that your environment supports bcrypt.</source>
          <target state="translated">このような状況はもうほとんど想像できません。 &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt;はPHP 3.0.18から5.3をサポートしているため、考えられるほとんどすべてのインストールで使用できます。また、環境がbcryptをサポートしている&lt;em&gt;か&lt;/em&gt;どうか不明な場合に使用してください。</target>
        </trans-unit>
        <trans-unit id="a7427fce65bccc8329b93c08c2c177aa8d900929" translate="yes" xml:space="preserve">
          <source>I changed my mind about using bcrypt when I learned that bcrypt only uses blowfish's key schedule, with a variable cost mechanism. The latter lets you increase the cost to brute-force a password by increasing blowfish's already expensive key schedule.</source>
          <target state="translated">bcryptを使おうと思っていたのですが、bcryptはblowfishのキースケジュールのみを使用しており、可変コストの仕組みを持っていることを知ってからは、bcryptを使おうと思っていました。後者では、blowfish の既に高価なキースケジュールを増やすことで、パスワードをブルートフォースするためのコストを増やすことができます。</target>
        </trans-unit>
        <trans-unit id="74d1dec78ea1f0d88fb883d96450938d3cd9d96d" translate="yes" xml:space="preserve">
          <source>I found perfect topic on this matter here: &lt;a href=&quot;https://crackstation.net/hashing-security.htm&quot;&gt;https://crackstation.net/hashing-security.htm&lt;/a&gt;, I wanted you to get benefit from it, here is source code also that provided prevention against time-based attack also.</source>
          <target state="translated">私はこの問題に関する完璧なトピックをここで見つけました： &lt;a href=&quot;https://crackstation.net/hashing-security.htm&quot;&gt;https&lt;/a&gt; : //crackstation.net/hashing-security.htm 、あなたはそれから利益を得てほしかった、これはまた時間ベースの攻撃に対する防止を提供したソースコードでもあります。</target>
        </trans-unit>
        <trans-unit id="878b969cae5ef5b116676174f4bba610ac895913" translate="yes" xml:space="preserve">
          <source>I highly suggest reading the documentation for the &lt;a href=&quot;http://us.php.net/crypt&quot;&gt;crypt function&lt;/a&gt; if you want to understand how to use bcrypt, or finding yourself a &lt;a href=&quot;https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021&quot;&gt;good&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/1070401&quot;&gt;wrapper&lt;/a&gt; or use something like &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt; for a more legacy implementation. I recommend a minimum of 12 rounds of bcrypt, if not 15 to 18.</source>
          <target state="translated">bcryptの使用方法を理解したい場合や、 &lt;a href=&quot;https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021&quot;&gt;優れた&lt;/a&gt; &lt;a href=&quot;https://gist.github.com/1070401&quot;&gt;ラッパーを&lt;/a&gt;見つけたり、よりレガシーな実装に&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASSの&lt;/a&gt;ようなものを使用したりする場合は、 &lt;a href=&quot;http://us.php.net/crypt&quot;&gt;crypt関数の&lt;/a&gt;ドキュメントを読むことを強くお勧めします。 15から18ではないにしても、最低12ラウンドのbcryptをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3acd6228038caf8487300f27ba32f185e5efc8f9" translate="yes" xml:space="preserve">
          <source>I just want to point out that PHP 5.5 includes a &lt;a href=&quot;http://www.php.net/manual/en/ref.password.php&quot;&gt;password hashing API&lt;/a&gt; that provides a wrapper around &lt;code&gt;crypt()&lt;/code&gt;. This API significantly simplifies the task of hashing, verifying and rehashing password hashes. The author has also released a &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility pack&lt;/a&gt; (in the form of a single password.php file that you simply &lt;code&gt;require&lt;/code&gt; to use), for those using PHP 5.3.7 and later and want to use this right now.</source>
          <target state="translated">PHP 5.5には、 &lt;code&gt;crypt()&lt;/code&gt; のラッパーを提供する&lt;a href=&quot;http://www.php.net/manual/en/ref.password.php&quot;&gt;パスワードハッシュAPI&lt;/a&gt;が含まれていることを指摘しておきます 。 このAPIは、パスワードハッシュのハッシュ、検証、および再ハッシュのタスクを大幅に簡略化します。 また、PHP 5.3.7以降を使用していて、今すぐ使用したいユーザー向けに、 &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;互換パック&lt;/a&gt; （単一のpassword.phpファイルの形式で使用するだけ）もリリースしました。</target>
        </trans-unit>
        <trans-unit id="021bc86837c1cf4ede09646fe8929f5646deb92f" translate="yes" xml:space="preserve">
          <source>I usually use SHA1 and salt with the user ID (or some other user-specific piece of information), and sometimes I additionally use a constant salt (so I have 2 parts to the salt).</source>
          <target state="translated">私は通常、SHA1とソルトをユーザーID(または他のユーザー固有の情報)と一緒に使用しています。</target>
        </trans-unit>
        <trans-unit id="1bc7ca4a9003d758e3158a03983889340d7b0ef9" translate="yes" xml:space="preserve">
          <source>I would not store the password hashed in two different ways, because then the system is at least as weak as the weakest of the hash algorithms in use.</source>
          <target state="translated">私はハッシュ化されたパスワードを2つの異なる方法で保存することはありません。なぜならば、システムは少なくとも使用中のハッシュアルゴリズムの中で最も弱いものと同じくらい弱いからです。</target>
        </trans-unit>
        <trans-unit id="462230903f4568427872db9e53f5786cbc3b5e7d" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;Phpass&lt;/a&gt; which is a simple one-file PHP class that could be implemented very easily in nearly every PHP project. See also &lt;a href=&quot;http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4&quot;&gt;The H&lt;/a&gt;.</source>
          <target state="translated">私は&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;Phpass&lt;/a&gt;を使用しています。これは、ほぼすべてのPHPプロジェクトで非常に簡単に実装できる単純な1ファイルのPHPクラスです。 &lt;a href=&quot;http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4&quot;&gt;H&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="2e7956166ff653d061a0f1fee8e6d1f242bac81e" translate="yes" xml:space="preserve">
          <source>I'm using PHP. I want a safe and fast password encryption system. Hashing a password a million times may be safer, but also slower. How to achieve a good balance between speed and safety? Also, I'd prefer the result to have a constant number of characters.</source>
          <target state="translated">PHPを使っている。安全で高速なパスワード暗号化システムが欲しい。パスワードを100万回ハッシュした方が安全かもしれませんが、速度も遅くなります。速度と安全性を両立させるにはどうすればいいのでしょうか?また、結果の文字数が一定の方がいいですね。</target>
        </trans-unit>
        <trans-unit id="6ff2c27f72547e5d2b06a5581aa37280ccb6a8db" translate="yes" xml:space="preserve">
          <source>Ideally you want your DB and APPLICATION on separate servers. This is not always possible due to cost, but it does allow for some safety as the attacker will have to go through two steps to fully access the system.</source>
          <target state="translated">理想的には、別のサーバ上のDBとアプリケーションが欲しいです。これはコストのために常に可能というわけではありませんが、攻撃者がシステムに完全にアクセスするために2つのステップを経なければならないので、ある程度の安全性は確保されています。</target>
        </trans-unit>
        <trans-unit id="3a9162bbf805570c30c3008fac626548ad008226" translate="yes" xml:space="preserve">
          <source>If the user is creating a password through the frontend that means it has to be sent to the server. This opens up a security issue because that means the unencrypted password is being sent to the server and if a attacker is able to listen and access that all your security in PHP is worthless. ALWAYS transmit the data SECURELY, this is done through SSL, but be weary even SSL is not flawless (OpenSSL's Heartbleed flaw is an example of this).</source>
          <target state="translated">ユーザーがフロントエンドでパスワードを作成している場合、それはサーバーに送信されなければならないことを意味します。これは、暗号化されていないパスワードがサーバーに送信されることを意味するので、セキュリティ上の問題が発生します。もし攻撃者がそれを聞いてアクセスすることができれば、PHPのセキュリティは無意味になります。データは常に安全に送信するようにしましょう。これはSSLを使って行われますが、SSLであっても完璧ではないことに注意してください (OpenSSLのHeartbleedの欠陥がその例です)。</target>
        </trans-unit>
        <trans-unit id="bfdaf953c79a7a6b68bb4199d7beacdee227846d" translate="yes" xml:space="preserve">
          <source>Implement a reasonable 8-10 character minimum length, plus require at least 1 upper case letter, 1 lower case letter, a number, and a symbol. This will improve the entropy of the password, in turn making it harder to crack. (See the &quot;What makes a good password?&quot; section for some debate.)</source>
          <target state="translated">合理的な8-10文字の最小長さを実装し、さらに少なくとも1つの大文字、1つの小文字、数字、および記号を必要とします。これはパスワードのエントロピーを改善し、クラックを難しくします。(いくつかの議論については、&quot;何が良いパスワードを作るのか?&quot;のセクションを参照してください)。</target>
        </trans-unit>
        <trans-unit id="db36d1a15c2eff2b9e586d75be21da1c305b8b6a" translate="yes" xml:space="preserve">
          <source>In case I wasn't clear enough, I want to know which hashing function(s) to use and how to pick a good salt in order to have a safe and fast password protection mechanism.</source>
          <target state="translated">念のため、安全で高速なパスワード保護機構を持つためには、どのハッシュ関数を使えばいいのか、どのようにして良い塩を選べばいいのかを知りたいです。</target>
        </trans-unit>
        <trans-unit id="4d685a0e94f3eab6cfef426e115b55c6d2ecd20c" translate="yes" xml:space="preserve">
          <source>In short, entropy is how much variation is within the password. When a password is only lowercase roman letters, that's only 26 characters. That isn't much variation. Alpha-numeric passwords are better, with 36 characters. But allowing upper and lower case, with symbols, is roughly 96 characters. That's a lot better than just letters. One problem is, to make our passwords memorable we insert patterns&amp;mdash;which reduces entropy. Oops!</source>
          <target state="translated">つまり、エントロピーとは、パスワード内の変動の量です。 パスワードが小文字のローマ字のみの場合、それは26文字だけです。 それはあまり変化ではありません。 英数字パスワードの方がよく、36文字です。 ただし、大文字と小文字を区別できる記号は、およそ96文字です。 それは単なる文字よりもはるかに優れています。 問題の1つは、パスワードを覚えやすくするために、パターンを挿入することです。これにより、エントロピーが減少します。 おっとっと！</target>
        </trans-unit>
        <trans-unit id="f5c756bd1a76be361873a30bd1bd4190227c361c" translate="yes" xml:space="preserve">
          <source>In the comments I talked with @popnoodles, who pointed out that &lt;em&gt;enforcing&lt;/em&gt; a password policy of X length with X many letters, numbers, symbols, etc, can actually reduce entropy by making the password scheme more predictable. I do agree. Randomess, as truly random as possible, is always the safest but least memorable solution.</source>
          <target state="translated">私が@popnoodlesと話したコメントで、Xの長さのパスワードポリシーをX個の文字、数字、記号などで&lt;em&gt;強制&lt;/em&gt;すると、パスワードスキームをより予測可能にして実際にエントロピーを減らすことができると指摘しました。 私は同意しますよ。 Randomessは、可能な限り真にランダムであり、常に最も安全ですが最も記憶に残る解決策です。</target>
        </trans-unit>
        <trans-unit id="b0a50c178288b0e09504dc0a677b514cf240abd4" translate="yes" xml:space="preserve">
          <source>In the end, double-hashing, mathematically, provides no benefit.  In practice, however, it is useful for preventing rainbow table-based attacks.  In other words, it is of no more benefit than hashing with a salt, which takes far less processor time in your application or on your server.</source>
          <target state="translated">結局、ダブルハッシュは数学的には何のメリットもありません。しかし、実際にはレインボーテーブルベースの攻撃を防ぐのに役立ちます。言い換えれば、ソルトを使ったハッシュよりも、アプリケーションやサーバの処理時間がはるかに短くて済むということです。</target>
        </trans-unit>
        <trans-unit id="7d25865b4d6182316faf089b42e9c22a190d279b" translate="yes" xml:space="preserve">
          <source>Increasing cost (which defaults to 10) makes the hash harder to brute-force but also means generating hashes and verifying passwords against them will be more work for your server's CPU.</source>
          <target state="translated">コストの増加(デフォルトは10)は、ハッシュをブルートフォースすることを難しくしますが、ハッシュを生成してパスワードを検証することは、サーバのCPUにとってより多くの作業になることを意味します。</target>
        </trans-unit>
        <trans-unit id="3819c766e1a237afa339d1b32fb8107d612fcdd2" translate="yes" xml:space="preserve">
          <source>Interestingly, in living out this nightmare, I learned A LOT I didn&amp;rsquo;t know about password cracking, storage, and complexity. &lt;em&gt;I&amp;rsquo;ve come to appreciate why password storage is ever so much more important than password complexity. If you don&amp;rsquo;t know how your password is stored, then all you really can depend upon is complexity.&lt;/em&gt; This might be common knowledge to password and crypto pros, but for the average InfoSec or Web Security expert, I highly doubt it.</source>
          <target state="translated">興味深いことに、この悪夢を乗り越えて、パスワードの解読、保存、複雑さについては知らなかったたくさんのことを学びました。 &lt;em&gt;パスワードの保存が、パスワードの複雑さよりもはるかに重要である理由を理解するようになりました。&lt;/em&gt; &lt;em&gt;パスワードの保存方法がわからない場合は、複雑さだけが信頼できます。&lt;/em&gt; これは、パスワードと暗号の専門家にとっては一般的な知識かもしれませんが、平均的なInfoSecまたはWebセキュリティの専門家にとっては、私は非常に疑っています。</target>
        </trans-unit>
        <trans-unit id="32aace1e6bd9db8789604b5d77b5b357f1a03eeb" translate="yes" xml:space="preserve">
          <source>It can use salt (in this case, are all salts equally good? Is there any way to generate good salts?)</source>
          <target state="translated">塩を使うことができます(この場合、全ての塩は同じように良い塩なのでしょうか?良い塩を生成する方法はありますか?)</target>
        </trans-unit>
        <trans-unit id="76532b90f399c161d14466cd2bb1c1a7e08c404d" translate="yes" xml:space="preserve">
          <source>It is currently said that MD5 is partially unsafe. Taking this into consideration, I'd like to know which mechanism to use for password protection.</source>
          <target state="translated">現在、MD5は部分的に安全性が低いと言われています。それを考慮して、パスワード保護にどのような仕組みを使えばいいのか知りたいですね。</target>
        </trans-unit>
        <trans-unit id="ec687b6fd5c605eabd26943ffe28b1856e82a532" translate="yes" xml:space="preserve">
          <source>It must be safe</source>
          <target state="translated">それは安全でなければなりません</target>
        </trans-unit>
        <trans-unit id="2deed719274cbd038881d457f177804efb08bba8" translate="yes" xml:space="preserve">
          <source>It only supports BCRYPT for now, but it aims to be easily extended to include other password hashing techniques and because the technique and cost is stored as part of the hash, changes to your prefered hashing technique/cost will not invalidate current hashes, the framework will automagically, use the correct technique/cost when validating. It also handles generating a &quot;secure&quot; salt if you do not explicitly define your own.</source>
          <target state="translated">今のところBCRYPTのみをサポートしていますが、他のパスワードハッシュ技術を含むように簡単に拡張できることを目指しており、技術とコストがハッシュの一部として保存されているため、あなたが好むハッシュテクニックの変更が現在のハッシュを無効にすることはありません。また、明示的に独自のソルトを定義しない場合は、「安全な」ソルトの生成も処理します。</target>
        </trans-unit>
        <trans-unit id="fbfb86f18fa274ab0a5bfb0be1ee04f715779f9f" translate="yes" xml:space="preserve">
          <source>Jeremiah Grossman, CTO of Whitehat Security, &lt;a href=&quot;https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/&quot;&gt;stated on White Hat Security blog&lt;/a&gt; after a recent password recovery that required brute-force breaking of his password protection:</source>
          <target state="translated">Whitehat SecurityのCTOであるJeremiah Grossman &lt;a href=&quot;https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/&quot;&gt;がWhite Hat Securityのブログ&lt;/a&gt;で、パスワード保護のブルートフォースでの破壊を必要とする最近のパスワード回復について述べています。</target>
        </trans-unit>
        <trans-unit id="a1b0239b75a0a79e1923e96b83331042b6c1cfea" translate="yes" xml:space="preserve">
          <source>Lastly: I am not a cryptographer. Whatever I've said is my opinion, but I happen to think it's based on good ol' common sense ... and lots of reading. Remember, be as paranoid as possible, make things as hard to intrude as possible, and then, if you are still worried, contact a white-hat hacker or cryptographer to see what they say about your code/system.</source>
          <target state="translated">最後に:私は暗号学者ではありません。私が言ったことはすべて私の意見ですが、それは古き良き常識に基づいていると思います。できるだけ被害妄想的になり、できるだけ侵入されにくいようにし、それでも心配なら、ホワイトハットのハッカーや暗号学者に連絡して、あなたのコードシステムについて彼らが何と言っているか確認してください。</target>
        </trans-unit>
        <trans-unit id="c3fdfe95f7d84ea072335ae939def14083cede1e" translate="yes" xml:space="preserve">
          <source>Like always DO NOT make this root or something similar.</source>
          <target state="translated">いつものように、この根っこのようなものを作ってはいけません。</target>
        </trans-unit>
        <trans-unit id="8272783154610ed637003d484b1ab9e70499174f" translate="yes" xml:space="preserve">
          <source>More explanation is available at- &lt;a href=&quot;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&quot;&gt;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&lt;/a&gt;</source>
          <target state="translated">詳細については、 &lt;a href=&quot;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&quot;&gt;http：&lt;/a&gt; //www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/をご覧ください。</target>
        </trans-unit>
        <trans-unit id="ccbd82ab1462c38ff0a96c985a99ed1447b09ef0" translate="yes" xml:space="preserve">
          <source>Most programmers just don't have the expertise to write crypto related code safely without introducing vulnerabilities.</source>
          <target state="translated">ほとんどのプログラマーは、脆弱性を導入せずに安全に暗号関連のコードを書くための専門知識を持っていないだけです。</target>
        </trans-unit>
        <trans-unit id="f4b758984e383af744fd6b70d1a44453fe5d02d5" translate="yes" xml:space="preserve">
          <source>NEVER EVER store a password in your DB, instead store the hash and unique salt, I will explain why later.</source>
          <target state="translated">決してあなたのDBにパスワードを格納することはありません、代わりにハッシュとユニークな塩を格納し、私は後で理由を説明します。</target>
        </trans-unit>
        <trans-unit id="b668a4bf2c2b13fda6ea44b2604e7cb52f134d07" translate="yes" xml:space="preserve">
          <source>Never email a password to your user &lt;em&gt;except when they have lost theirs, and you sent a temporary one.&lt;/em&gt;</source>
          <target state="translated">ユーザーがパスワードを&lt;em&gt;紛失して、一時的な&lt;/em&gt;パスワードを送信した場合&lt;em&gt;を除い&lt;/em&gt;て、ユーザーにパスワードを電子メールで送信しないでください&lt;em&gt;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a05bf77552bc683c933754926449ac35cd64a670" translate="yes" xml:space="preserve">
          <source>Never hash passwords with &lt;a href=&quot;http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/&quot;&gt;SHA1&lt;/a&gt; or MD5 or even SHA256! &lt;a href=&quot;http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/&quot;&gt;Modern crackers&lt;/a&gt; can exceed 60 and 180 billion hashes/second (respectively).</source>
          <target state="translated">&lt;a href=&quot;http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/&quot;&gt;SHA1&lt;/a&gt;またはMD5、さらにはSHA256でパスワードをハッシュしないでください！ &lt;a href=&quot;http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/&quot;&gt;現代のクラッカー&lt;/a&gt;は、（それぞれ）60および1,800億ハッシュ/秒を超える可能性があります。</target>
        </trans-unit>
        <trans-unit id="f8ba9091576887aa8ba6c61d6c8d8e6d54342993" translate="yes" xml:space="preserve">
          <source>Never store your user's password in plain-text.</source>
          <target state="translated">ユーザーのパスワードを平文で保存しないでください。</target>
        </trans-unit>
        <trans-unit id="e583d29870e1092a65f27803157c2c1944f2e8dd" translate="yes" xml:space="preserve">
          <source>Never, ever log passwords in any manner.</source>
          <target state="translated">どんな方法であれ、パスワードをログに記録することは絶対にしてはいけません。</target>
        </trans-unit>
        <trans-unit id="b0dd8e37f7458d33cf378742fcb833eb6f03eaa4" translate="yes" xml:space="preserve">
          <source>No matter how good your encryption is if you don't properly secure the server that runs the PHP and DB all your efforts are worthless. Most servers function relatively the same way, they have ports assigned to allow you to access them remotely either through ftp or shell. Make sure that you change the default port of which ever remote connection you have active. By not doing this you in effect have made the attacker do one less step in accessing your system.</source>
          <target state="translated">いくら暗号化が優れていても、PHPやDBを実行しているサーバを適切に保護しなければ、あなたの努力は無意味です。ほとんどのサーバは比較的同じように機能しています。リモート接続を有効にしている場合は、デフォルトのポートを変更するようにしてください。これをしないことで、事実上、攻撃者がシステムにアクセスするためのステップを一つ減らしたことになります。</target>
        </trans-unit>
        <trans-unit id="a0316a87f5c5e013f52649e477f4e70dd3e0acba" translate="yes" xml:space="preserve">
          <source>Note that even though the default hashing algorithm may change, old hashes will continue to verify just fine because the algorithm used is stored in the hash and &lt;code&gt;password_verify()&lt;/code&gt; picks up on it.</source>
          <target state="translated">デフォルトのハッシュアルゴリズムは変更される可能性がありますが、使用されるアルゴリズムはハッシュに格納され、 &lt;code&gt;password_verify()&lt;/code&gt; がそれを選択するため、古いハッシュは引き続き問題なく検証されます 。</target>
        </trans-unit>
        <trans-unit id="2008200dd1969bed81cd881c21332864a96d99ae" translate="yes" xml:space="preserve">
          <source>ONE WAY HASHING!!!!!!!, Never hash a password in a way that it can be reversed, Hashes should be one way, meaning you don't reverse them and compare them to the password, you instead hash the entered password the same way and compare the two hashes. This means that even if an attacker gets access to the DB he doesn't know what the actually password is, just its resulting hash. Which means more security for your users in the worst possible scenario.</source>
          <target state="translated">ONE WAY HASHING! 逆引きできるような方法でパスワードをハッシュしてはいけません。ハッシュはワンウェイであるべきです。これは、たとえ攻撃者がDBにアクセスしたとしても、実際のパスワードが何であるかはわからず、その結果のハッシュだけがわかることを意味します。つまり、最悪のシナリオでもユーザーの安全性を高めることができます。</target>
        </trans-unit>
        <trans-unit id="702aaf71948af0b0b28598e8e00fec24cf4962f6" translate="yes" xml:space="preserve">
          <source>Older PHP versions: OpenWall's &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;phpass&lt;/a&gt; library is much better than most custom code - used in WordPress, Drupal, etc.</source>
          <target state="translated">古いバージョンのPHP：OpenWallの&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;phpass&lt;/a&gt;ライブラリは、ほとんどのカスタムコードよりもはるかに優れています-WordPress 、Drupalなどで使用されます。</target>
        </trans-unit>
        <trans-unit id="bc886b63ca3b0eb383c458da407e533fe3d56755" translate="yes" xml:space="preserve">
          <source>One of the most common mistakes in hashing is that hashes are not unique to the users. This is mainly because salts are not uniquely generated.</source>
          <target state="translated">ハッシュ化の最も一般的な間違いの1つは、ハッシュが利用者に一意ではないということです。これは主に塩が一意に生成されないためです。</target>
        </trans-unit>
        <trans-unit id="c2385fa123d6a9984b6b1eddc74522697f2d9f20" translate="yes" xml:space="preserve">
          <source>P.s. for last 2 steps you can use your own algorithm...
but be sure that you can generate this hashed password in the future 
when you need to authorize user...</source>
          <target state="translated">P.s.最後の2つのステップでは、独自のアルゴリズムを使用することができます...しかし、将来、ユーザーを認証する必要がある場合には、このハッシュ化されたパスワードを生成できることを確認してください。</target>
        </trans-unit>
        <trans-unit id="7d080faa12a8ba859c71e8cfa04be086436076bf" translate="yes" xml:space="preserve">
          <source>PHP 5.5 or higher: &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash()&lt;/a&gt; is good quality and part of PHP core.</source>
          <target state="translated">PHP 5.5以降： &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash（）&lt;/a&gt;は良質でPHPコアの一部です。</target>
        </trans-unit>
        <trans-unit id="e441ae84ae0663d1c0b2f38792b0dada2e5cf183" translate="yes" xml:space="preserve">
          <source>Password entropy is &lt;a href=&quot;https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/&quot;&gt;approximated&lt;/a&gt; easily. Using the full range of ascii characters (roughly 96 typeable characters) yields an entropy of 6.6 per character, which at 8 characters for a password is still too low (52.679 bits of entropy) for future security. But the good news is: longer passwords, and passwords with unicode characters, really increase the entropy of a password and make it harder to crack.</source>
          <target state="translated">パスワードエントロピーは簡単に&lt;a href=&quot;https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/&quot;&gt;概算&lt;/a&gt;できます。 全範囲のASCII文字（約96文字の入力可能文字）を使用すると、1文字あたり6.6のエントロピーが得られますが、パスワードの8文字では、将来のセキュリティのためにまだ低すぎます（52.679ビットのエントロピー）。 しかし、朗報です。長いパスワード、およびUnicode文字を含むパスワードは、パスワードのエントロピーを実際に増加させ、解読を困難にします。</target>
        </trans-unit>
        <trans-unit id="6f90138bce65ffdcace9e2bb19f7963c1bd536d2" translate="yes" xml:space="preserve">
          <source>Passwords should always be salted before hashed. Salting adds a random string to the password so similar passwords don't appear the same in the DB. However if the salt is not unique to each user (ie: you use a hard coded salt) than you pretty much have made your salt worthless. Because once an attacker figures out one password salt he has the salt for all of them.</source>
          <target state="translated">パスワードは必ずハッシュ化する前に塩漬けにしなければなりません。ソルトすることでパスワードにランダムな文字列が追加されるので、似たようなパスワードが DB で同じように表示されることはありません。しかし、もしソルトが各ユーザに固有のものでない場合(例えばハードコード化されたソルトを使用している場合など)は、ソルトの価値がなくなってしまいます。なぜなら、一度攻撃者が一つのパスワードソルトを見つけ出したら、全てのパスワードのソルトを手に入れてしまうからです。</target>
        </trans-unit>
        <trans-unit id="48845b9c00008f76810e059c640d17fa100ba624" translate="yes" xml:space="preserve">
          <source>Providing the &lt;code&gt;PASSWORD_DEFAULT&lt;/code&gt; instructs PHP to use the default hashing algorithm of the installed version of PHP. Exactly which algorithm that means is intended to change over time in future versions, so that it will always be one of the strongest available algorithms.</source>
          <target state="translated">&lt;code&gt;PASSWORD_DEFAULT&lt;/code&gt; を指定すると、インストールされているバージョンのPHPのデフォルトのハッシュアルゴリズムを使用するようにPHPに指示されます。 正確にはどのアルゴリズムが将来のバージョンで時間の経過とともに変更されることを意図しているため、常に最も強力なアルゴリズムの1つになります。</target>
        </trans-unit>
        <trans-unit id="dd1d5612b63f3e6527355deb1eb2e9ab4b7c8d4c" translate="yes" xml:space="preserve">
          <source>Recently I had a discussion whether password hashes salted with random
  bits are more secure than the one salted with guessable or known
  salts. Let&amp;rsquo;s see: If the system storing password is compromised as
  well as the system which stores the random salt, the attacker will
  have access to hash as well as salt, so whether the salt is random or
  not, doesn&amp;rsquo;t matter. The attacker will can generate pre-computed
  rainbow tables to crack the hash. Here comes the interesting part- it
  is not so trivial to generate pre-computed tables. Let us take example
  of WPA security model. Your WPA password is actually never sent to
  Wireless Access Point. Instead, it is hashed with your SSID (the
  network name- like Linksys, Dlink etc). A very good explanation of how
  this works is here. In order to retrieve password from hash, you will
  need to know the password as well as salt (network name). Church of
  Wifi has already pre-computed hash tables which has top 1000 SSIDs and
  about 1 million passwords. The size is of all tables is about 40 GB.
  As you can read on their site, someone used 15 FGPA arrays for 3 days
  to generate  these tables. Assuming victim is using the SSID as
  &amp;ldquo;a387csf3&amp;Prime; and password as &amp;ldquo;123456&amp;Prime;, will it be cracked by those
  tables? No! .. it cannot. Even if the password is weak, the tables
  don&amp;rsquo;t have hashes for SSID a387csf3.  This is the beauty of having
  random salt. It will deter crackers who thrive upon pre-computed
  tables. Can it stop a determined hacker? Probably not. But using
  random salts does provide additional layer of defense. While we are on
  this topic, let us discuss additional advantage of storing random
  salts on a separate system. Scenario #1 : Password hashes are stored
  on system X and salt values used for hashing are stored on system Y.
  These salt values are guessable or known (e.g. username) Scenario#2 :
  Password hashes are stored on system X and salt values used for
  hashing are stored on system Y. These salt values are random. In case
  system X has been compromised, as you can guess, there is a huge
  advantage of using random salt on a separate system (Scenario #2) .
  The attacker will need to guess addition values to be able to crack
  hashes. If a 32 bit salt is used, 2^32= 4,294,967,296 (about 4.2
  billion) iterations will can be required for each password guessed.</source>
          <target state="translated">最近、ランダムビットでソルトされたパスワードハッシュが、推測可能なソルトまたは既知のソルトでソルトされたものよりも安全かどうかについて話し合いました。 見てみましょう：パスワードを保存するシステムとランダムなソルトを保存するシステムが侵害された場合、攻撃者はソルトだけでなくハッシュにもアクセスできるため、ソルトがランダムかどうかは関係ありません。 攻撃者は、事前に計算されたレインボーテーブルを生成してハッシュをクラックすることができます。 ここで興味深い部分があります。事前に計算されたテーブルを生成することはそれほど簡単ではありません。 WPAセキュリティモデルの例を見てみましょう。 WPAパスワードが実際にワイヤレスアクセスポイントに送信されることはありません。 代わりに、SSID（Linksys、Dlinkなどのネットワーク名）でハッシュされます。 これがどのように機能するかについての非常に良い説明がここにあります。 ハッシュからパスワードを取得するには、パスワードとソルト（ネットワーク名）を知っている必要があります。 Church of Wifiは、上位1000のSSIDと約100万のパスワードを持つハッシュテーブルを事前に計算しています。 すべてのテーブルのサイズは約40 GBです。 あなたのサイトで読むことができるように、誰かが15のFGPAアレイを3日間使用してこれらのテーブルを生成しました。 被害者がSSIDを「a387csf3」、パスワードを「123456」として使用しているとすると、これらのテーブルによってクラックされますか？ 番号！ .. できない。 パスワードが弱い場合でも、テーブルにはSSID a387csf3のハッシュがありません。 これが無作為な塩の美しさです。 事前に計算されたテーブルで成功するクラッカーを阻止します。 断固としたハッカーを止めることはできますか？ おそらく違います。 しかし、ランダムな塩を使用すると、追加の防御層が提供されます。 このトピックについて説明しますが、ランダムな塩を別のシステムに保存することのさらなる利点について説明します。 シナリオ＃1：パスワードハッシュはシステムXに格納され、ハッシュに使用されるソルト値はシステムYに格納されます。これらのソルト値は推測可能または既知（例：ユーザー名）シナリオ＃2：パスワードハッシュはシステムXに格納され、ソルト値はハッシュはシステムYに格納されます。これらのソルト値はランダムです。 ご想像のとおり、システムXが侵害された場合、別のシステムでランダムソルトを使用することには大きなメリットがあります（シナリオ＃2）。 攻撃者は、ハッシュをクラックするために追加の値を推測する必要があります。 32ビットのソルトを使用する場合、推測されたパスワードごとに2 ^ 32 = 4,294,967,296（約42億）の反復が必要になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="29cf51326e60ca7639ae8d61993a3e6af0924dbd" translate="yes" xml:space="preserve">
          <source>Reset everyone's passwords when the database is compromised.</source>
          <target state="translated">データベースが漏洩した場合、全員のパスワードをリセットします。</target>
        </trans-unit>
        <trans-unit id="99aba45ee7f729f62087c2a073d856536cd76908" translate="yes" xml:space="preserve">
          <source>SHA1 is now also considered somewhat compromised, but to a far lesser degree than MD5.  By using a salt (any salt), you're preventing the use of a generic &lt;a href=&quot;http://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;rainbow table&lt;/a&gt; to attack your hashes (some people have even had success using Google as a sort of rainbow table by searching for the hash).  An attacker could conceivably generate a rainbow table using your salt, so that's why you should include a user-specific salt.  That way, they will have to generate a rainbow table for each and every record in your system, not just one for your entire system!  With that type of salting, even MD5 is decently secure.</source>
          <target state="translated">SHA1は現在やや危険にさらされていると考えられていますが、MD5よりもはるかに劣っています。 ソルト（任意のソルト）を使用することで、一般的な&lt;a href=&quot;http://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;レインボーテーブル&lt;/a&gt;を使用してハッシュを攻撃するのを防ぐことができます（ハッシュを検索して、Googleを一種のレインボーテーブルとして使用することに成功した人もいます）。 攻撃者はおそらくソルトを使用してレインボーテーブルを生成する可能性があるため、ユーザー固有のソルトを含める必要があります。 そうすれば、システム全体の1つではなく、システム内のすべてのレコードについてレインボーテーブルを生成する必要があります。 そのタイプのソルティングを使用すると、MD5でもかなり安全です。</target>
        </trans-unit>
        <trans-unit id="4eda4093b78a303b74d4192d587dca2314fa4169" translate="yes" xml:space="preserve">
          <source>Secure hash and salt for PHP passwords</source>
          <target state="translated">PHP パスワード用の安全なハッシュとソルト</target>
        </trans-unit>
        <trans-unit id="f11fa153ab1a9133bcbd4157363d3c3c13723b94" translate="yes" xml:space="preserve">
          <source>Secure methods of storing keys, passwords for asp.net</source>
          <target state="translated">asp.net のキー、パスワードの安全な保存方法</target>
        </trans-unit>
        <trans-unit id="ff41ccecb888661f5547c2d4b885e0c114d66f5f" translate="yes" xml:space="preserve">
          <source>Simple Password Encryption</source>
          <target state="translated">簡単なパスワード暗号化</target>
        </trans-unit>
        <trans-unit id="02d7e2181d283624db40fc6185be390dccef0f3e" translate="yes" xml:space="preserve">
          <source>Since then, PHP has given us &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;&lt;code&gt;password_hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;&lt;code&gt;password_verify&lt;/code&gt;&lt;/a&gt; and, since their introduction, they are the recommended password hashing &amp;amp; checking method.</source>
          <target state="translated">それ以来、PHPから&lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt; &lt;code&gt;password_hash&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt; &lt;code&gt;password_verify&lt;/code&gt; &lt;/a&gt;が提供されており、それらが導入されて以来、これらは推奨されるパスワードハッシュおよびチェック方式です。</target>
        </trans-unit>
        <trans-unit id="6dd6c021f508c0340ebfdf5945ac1810408566d3" translate="yes" xml:space="preserve">
          <source>So far as I've been able to tell, making the world's best password is a Catch-22. Either its not memorable, too predictable, too short, too many unicode characters (hard to type on a Windows/Mobile device), too long, etc. No password is truly good enough for our purposes, so we must protect them as though they were in Fort Knox.</source>
          <target state="translated">私の知る限りでは、世界最高のパスワードを作ることはキャッチー22です。記憶に残らない、予測しやすい、短すぎる、ユニコード文字が多すぎる(WindowsMobile端末では入力しにくい)、長すぎる、などなど。どんなパスワードも私たちの目的には本当に十分に良いものではないので、フォートノックスのようにそれらを保護しなければなりません。</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="abc469ca9e1e32aad49a7fa70322810e433fbc73" translate="yes" xml:space="preserve">
          <source>The API exposes four functions:</source>
          <target state="translated">APIは4つの関数を公開しています。</target>
        </trans-unit>
        <trans-unit id="d1e5cbc852e92edf4f983cd9843ad840d31e7b05" translate="yes" xml:space="preserve">
          <source>The computational power required to actually &lt;em&gt;crack&lt;/em&gt; a hashed password doesn't exist. The only way for computers to &quot;crack&quot; a password is to recreate it and simulate the hashing algorithm used to secure it. The speed of the hash is linearly related to its ability to be brute-forced. Worse still, most hash algorithms can be easily parallelized to perform even faster. This is why costly schemes like bcrypt and scrypt are so important.</source>
          <target state="translated">ハッシュされたパスワードを実際に&lt;em&gt;解読&lt;/em&gt;するために必要な計算能力は存在しません。 コンピューターがパスワードを「解読」する唯一の方法は、パスワードを再作成して、パスワードを保護するために使用されるハッシュアルゴリズムをシミュレートすることです。 ハッシュの速度は、ブルートフォースされる能力と線形的に関連しています。 さらに悪いことに、ほとんどのハッシュアルゴリズムは簡単に並列化してさらに高速に実行できます。 これが、bcryptやscryptなどのコストのかかるスキームが非常に重要である理由です。</target>
        </trans-unit>
        <trans-unit id="cc82bec66b732bb33be65e32feee97dde8331a13" translate="yes" xml:space="preserve">
          <source>The hashing mechanism must be available in PHP</source>
          <target state="translated">ハッシュ化の仕組みは PHP で利用可能なものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="c967b55b3de7e43262a5ec3a53dd313fc5714961" translate="yes" xml:space="preserve">
          <source>The idea of a salt is to throw the hashing results off balance, so to say. It is known, for example, that the MD5-hash of an empty string is &lt;code&gt;d41d8cd98f00b204e9800998ecf8427e&lt;/code&gt;. So, if someone with good enough a memory would see that hash and know that it's the hash of an empty string. But if the string is salted (say, with the string &quot;&lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt;&quot;), the hash for the 'empty string' (i.e. &quot;&lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt;&quot;) becomes &lt;code&gt;aeac2612626724592271634fb14d3ea6&lt;/code&gt;, hence non-obvious to backtrace. What I'm trying to say, that it's better to use &lt;em&gt;any&lt;/em&gt; salt, than not to. Therefore, it's not too much of an importance to know &lt;em&gt;which&lt;/em&gt; salt to use.</source>
          <target state="translated">ソルトの考え方は、言うまでもなく、ハッシュ結果のバランスを崩すことです。 たとえば、空の文字列のMD5ハッシュは &lt;code&gt;d41d8cd98f00b204e9800998ecf8427e&lt;/code&gt; であることがわかっています。 したがって、十分なメモリを持つ誰かがそのハッシュを見て、それが空の文字列のハッシュであることを知っている場合。 ただし、文字列が &lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt; ている場合（たとえば、文字列「 MY_PERSONAL_SALT 」を使用）、「空の文字列」（つまり「 &lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt; 」）のハッシュは &lt;code&gt;aeac2612626724592271634fb14d3ea6&lt;/code&gt; になるため 、バックトレースがわかりにくくなります。 私が言おうとしていることは、使用&lt;em&gt;する&lt;/em&gt;より塩を使用&lt;em&gt;する&lt;/em&gt;方が良いということです。 したがって、使用する塩を知ることはそれほど重要ではありません。</target>
        </trans-unit>
        <trans-unit id="3e93c44acff31ed1b16a3be79f5aaf860521be39" translate="yes" xml:space="preserve">
          <source>The objective behind hashing passwords is simple: preventing malicious access to user accounts by compromising the database. So the goal of password hashing is to deter a hacker or cracker by costing them too much time or money to calculate the plain-text passwords. And time/cost are the best deterrents in your arsenal.</source>
          <target state="translated">パスワードのハッシュ化の目的は単純で、データベースを侵害することでユーザーアカウントへの悪意のあるアクセスを防ぐことです。つまり、パスワードハッシュの目的は、平文のパスワードを計算するために多くの時間やコストをかけることで、ハッカーやクラッカーを抑止することです。そして、タイムコストはあなたの武器庫の中で最高の抑止力となります。</target>
        </trans-unit>
        <trans-unit id="ca15458b1f6023e826d9e6c9d269e5b8847c24ab" translate="yes" xml:space="preserve">
          <source>The returned hash could be stored in database as it is. Sample use for generating hash is:</source>
          <target state="translated">返されたハッシュはそのままデータベースに保存することができます。ハッシュを生成するための利用例は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9336b71741fbd4b0fc7ebef42b5f931ca05fe080" translate="yes" xml:space="preserve">
          <source>The theory of the answer is still a good read though.</source>
          <target state="translated">答えの理論はともかく、読み応えがある。</target>
        </trans-unit>
        <trans-unit id="72fe41d63bb494eee2544c08c337e299e480e6db" translate="yes" xml:space="preserve">
          <source>Then have a separate user account for you that is not stored anywhere on the server, not even in the application.</source>
          <target state="translated">そして、あなたのために、サーバー上のどこにも保存されていない、アプリケーションの中にも保存されていない別のユーザーアカウントを持っています。</target>
        </trans-unit>
        <trans-unit id="a80224d4f8511d86bc794896685456f1282e0a56" translate="yes" xml:space="preserve">
          <source>There are a lot of good hashing functions out there (&lt;code&gt;password_hash&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, etc...) but you need to select a good algorithm for the hash to be effective. (bcrypt and ones similar to it are decent algorithms.)</source>
          <target state="translated">多くの優れたハッシュ関数（ &lt;code&gt;password_hash&lt;/code&gt; 、 &lt;code&gt;hash&lt;/code&gt; など）がありますが、ハッシュを効果的にするには、優れたアルゴリズムを選択する必要があります。 （bcryptとそれに似たものはまともなアルゴリズムです。）</target>
        </trans-unit>
        <trans-unit id="83d2f507ea07e3720cda34bd2cd662536b85bf9a" translate="yes" xml:space="preserve">
          <source>There are actually &lt;a href=&quot;http://gdataonline.com/seekhash.php&quot;&gt;websites that do just this&lt;/a&gt; - you can feed it a (md5) hash, and it spits out a known plaintext that generates that particular hash. If you would get access to a database that stores plain md5-hashes, it would be trivial for you to enter the hash for the admin to such a service, and log in. But, if the passwords were salted, such a service would become ineffective.</source>
          <target state="translated">実際に&lt;a href=&quot;http://gdataonline.com/seekhash.php&quot;&gt;これを行うウェブサイト&lt;/a&gt;があります-（md5）ハッシュをフィードすることができ、特定のハッシュを生成する既知の平文を吐き出します。 プレーンなmd5ハッシュを格納するデータベースにアクセスする場合、管理者がそのようなサービスにハッシュを入力してログインするのは簡単です。しかし、パスワードがソルトされている場合、そのようなサービスは次のようになります。効果がない。</target>
        </trans-unit>
        <trans-unit id="94dc7fd1014b141fac002eb97bbbe1edb127d32d" translate="yes" xml:space="preserve">
          <source>There are also many rainbow table attacks on Windows passwords that run on ordinary CPUs and are very fast.  All this is because Windows &lt;em&gt;still&lt;/em&gt;&lt;a href=&quot;https://superuser.com/a/118279/90231&quot;&gt;doesn't salt or stretch&lt;/a&gt; its passwords, &lt;a href=&quot;https://www.guidingtech.com/61991/cracking-windows-10-password-prevent/&quot;&gt;even in Windows 10&lt;/a&gt; - don't make the same mistake as Microsoft did!</source>
          <target state="translated">通常のCPUで実行され、非常に高速なWindowsパスワードへの多数のレインボーテーブル攻撃もあります。 これはすべて&lt;a href=&quot;https://www.guidingtech.com/61991/cracking-windows-10-password-prevent/&quot;&gt;、Windows 10&lt;/a&gt;であっても、Windowsがパスワードを&lt;a href=&quot;https://superuser.com/a/118279/90231&quot;&gt;ソルトしたり引き伸ばしたり&lt;/a&gt;しないためです。Microsoftの場合と同じミスをしないでください。</target>
        </trans-unit>
        <trans-unit id="7d78de6e30f57b4b7d0c6241b43daf6efe33858b" translate="yes" xml:space="preserve">
          <source>There's a longer discussion of password entropy on the &lt;a href=&quot;https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password&quot;&gt;Crypto StackExchange&lt;/a&gt; site. A good Google search will also turn up a lot of results.</source>
          <target state="translated">&lt;a href=&quot;https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password&quot;&gt;Crypto StackExchange&lt;/a&gt;サイトには、パスワードエントロピーに関するより長い議論があります。 優れたGoogle検索でも多くの結果が表示されます。</target>
        </trans-unit>
        <trans-unit id="eb3552eb4e3ab442dc5e9548665b050d60219300" translate="yes" xml:space="preserve">
          <source>This question, &lt;a href=&quot;https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once&quot;&gt;Is &amp;ldquo;double hashing&amp;rdquo; a password less secure than just hashing it once?&lt;/a&gt; 
suggests that hashing multiple times may be a good idea, whereas &lt;a href=&quot;https://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904&quot;&gt;How to implement password protection for individual files?&lt;/a&gt; suggests using salt.</source>
          <target state="translated">この質問は、 &lt;a href=&quot;https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once&quot;&gt;「ダブルハッシュ」は1回だけハッシュするよりも安全性が低いですか。&lt;/a&gt; 複数のハッシュを作成することは良い考えかもしれないが、 &lt;a href=&quot;https://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904&quot;&gt;個々のファイルにパスワード保護を実装する方法は？&lt;/a&gt; 塩の使用を提案しています。</target>
        </trans-unit>
        <trans-unit id="957441673ad43072032f00a3b5118222b26b20f1" translate="yes" xml:space="preserve">
          <source>Though the question has been answered, I just want to reiterate that salts used for hashing should be random and not like email address as suggested in first answer.</source>
          <target state="translated">質問には答えられていますが、ハッシュ化に使われる塩はランダムで、最初の回答で示唆されたようなメールアドレスのようなものではないことを再確認しておきたいと思います。</target>
        </trans-unit>
        <trans-unit id="0cf0236983335ce525d178c161a3dac43b40ad44" translate="yes" xml:space="preserve">
          <source>To verify password, one can use:</source>
          <target state="translated">パスワードを確認するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="ae24b36e98b286448b8f32e9eb9c4f5faa046188" translate="yes" xml:space="preserve">
          <source>Try an implementation of &lt;a href=&quot;http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard&quot;&gt;PDKBF2&lt;/a&gt; with the &lt;a href=&quot;https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256&quot;&gt;maximum number of rounds&lt;/a&gt; that your environment/application/user-perception can tolerate. The lowest number I'd recommend is 2500 rounds. Also, make sure to use &lt;a href=&quot;http://php.net/hash_hmac&quot;&gt;hash_hmac()&lt;/a&gt; if it is available to make the operation harder to reproduce.</source>
          <target state="translated">環境/アプリケーション/ユーザーの知覚が許容できる&lt;a href=&quot;https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256&quot;&gt;最大ラウンド数&lt;/a&gt;で&lt;a href=&quot;http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard&quot;&gt;PDKBF2&lt;/a&gt;の実装を試してください。 私がお勧めする最低数は2500ラウンドです。 また、操作の再現が困難な場合は、 &lt;a href=&quot;http://php.net/hash_hmac&quot;&gt;hash_hmac（）&lt;/a&gt;を使用してください 。</target>
        </trans-unit>
        <trans-unit id="068a6272a632b944b53a381b4d5400b18d5eafc9" translate="yes" xml:space="preserve">
          <source>Use PBKDF2 if you cannot use either bcrypt or scrypt, with SHA2 hashes.</source>
          <target state="translated">SHA2 ハッシュで bcrypt と scrypt のどちらも使用できない場合は PBKDF2 を使用します。</target>
        </trans-unit>
        <trans-unit id="3438f0875ced99f75e760bc602d283a350f5c224" translate="yes" xml:space="preserve">
          <source>Use scrypt when you can; bcrypt if you cannot.</source>
          <target state="translated">できれば scrypt を使い、できなければ bcrypt を使います。</target>
        </trans-unit>
        <trans-unit id="8a40715ff9e4ad938469f5e938fbc3461e5c29de" translate="yes" xml:space="preserve">
          <source>What makes a &lt;em&gt;good&lt;/em&gt; password anyway?</source>
          <target state="translated">とにかく&lt;em&gt;良い&lt;/em&gt;パスワードを作るものは何ですか？</target>
        </trans-unit>
        <trans-unit id="d324dbbd000686026c12d8aac03bc6761752e7ae" translate="yes" xml:space="preserve">
          <source>What's the difference between SHA and MD5 in PHP</source>
          <target state="translated">PHPにおけるSHAとMD5の違いは?</target>
        </trans-unit>
        <trans-unit id="3273a0f907bb9b658a5b510bdc764fef8f6fd55f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;password_hash()&lt;/code&gt; is used, it generates a random salt and includes it in the outputted hash (along with the the cost and algorithm used.) &lt;code&gt;password_verify()&lt;/code&gt; then reads that hash and determines the salt and encryption method used, and verifies it against the provided plaintext password.</source>
          <target state="translated">&lt;code&gt;password_hash()&lt;/code&gt; が使用されると、ランダムなソルトが生成され、出力されたハッシュに（使用されるコストとアルゴリズムとともに）含まれ &lt;code&gt;password_verify()&lt;/code&gt; 、そのハッシュを読み取り、使用されるソルトと暗号化方式を決定し、それを照合します。提供された平文パスワード。</target>
        </trans-unit>
        <trans-unit id="cdf0e49369640a78f1b0481bc29357ba77ff4067" translate="yes" xml:space="preserve">
          <source>When hashing speed is the key, the slower the more resistant to Brute Force attacks.</source>
          <target state="translated">ハッシュスピードが重要な場合は、遅い方がブルートフォース攻撃に強くなります。</target>
        </trans-unit>
        <trans-unit id="0ea7792c8765a8cc7d08846130a9f07954560526" translate="yes" xml:space="preserve">
          <source>When you create a salt make sure it is unique to the password it is salting, then store both the completed hash and salt in your DB. What this will do is make it so that an attacker will have to individually crack each salt and hash before they can gain access. This means a lot more work and time for the attacker.</source>
          <target state="translated">ソルトを作成する際には、ソルトを作成するパスワードに固有のものであることを確認し、完成したハッシュとソルトの両方をDBに保存してください。これは、攻撃者がアクセスする前に、それぞれのソルトとハッシュを個別にクラックしなければならないことを意味します。これは、攻撃者にとってより多くの作業と時間を意味します。</target>
        </trans-unit>
        <trans-unit id="4bcfb1507fa18c5813bf98587194789dfd7fc9fa" translate="yes" xml:space="preserve">
          <source>Why hash passwords anyway?</source>
          <target state="translated">なぜパスワードをハッシュ化するの?</target>
        </trans-unit>
        <trans-unit id="d9c509de30c734b1fbd267c99263e20b0ac2f8d4" translate="yes" xml:space="preserve">
          <source>You cannot possibly foresee all threats or avenues of attack, and so you must make your best effort to protect your users &lt;strong&gt;up front&lt;/strong&gt;. If you do not, then you might even miss the fact that you were attacked until it's too late... &lt;em&gt;and you're liable&lt;/em&gt;. To avoid that situation, act paranoid to begin with. Attack your own software (internally) and attempt to steal user credentials, or modify other user's accounts or access their data. If you don't test the security of your system, then you cannot blame anyone but yourself.</source>
          <target state="translated">すべての脅威や攻撃の経路を予測することはできないため、ユーザーを事前に保護するために最善を尽くす必要があります。 そうしないと、手遅れになるまで攻撃されたという事実を見逃す可能性が&lt;em&gt;あります&lt;/em&gt; ... &lt;em&gt;そしてあなたは責任を負い&lt;/em&gt;ます。 そのような状況を回避するには、まずは偏執狂的に行動します。 自分のソフトウェアを（内部で）攻撃し、ユーザーの資格情報を盗んだり、他のユーザーのアカウントを変更したり、データにアクセスしたりします。 システムのセキュリティをテストしない場合は、自分以外の誰のせいにもできません。</target>
        </trans-unit>
        <trans-unit id="6ecc62ca116f09be2ac8ccbf2dd2a17934a3f97a" translate="yes" xml:space="preserve">
          <source>You should definitely use a salt. I'd recommend using random bytes (and not restrict yourself to characters and numbers). As usually, the longer you choose, the safer, slower it gets. 64 bytes ought to be fine, i guess.</source>
          <target state="translated">絶対にソルトを使った方がいい ランダムバイト(文字や数字に限定しない)を使うのがいいと思います。いつものように、長ければ長いほど安全で遅くなります。64バイトでいいんじゃないかな。</target>
        </trans-unit>
        <trans-unit id="250c2ad56e4e9ddde57caded620862fba3c804d9" translate="yes" xml:space="preserve">
          <source>You tell your users to make good passwords to avoid getting hacked, do the same. What is the point in going through all the effort of locking your front door when you have the backdoor wide open.</source>
          <target state="translated">ハッキングされないように良いパスワードを作るようにユーザーに言っていますが、同じようにしましょう。バックドアが大きく開いているときに、玄関のドアをロックするためのすべての努力を経ることに何の意味がありますか?</target>
        </trans-unit>
        <trans-unit id="65de4781939078acdc51b27007cb200ec4c437c0" translate="yes" xml:space="preserve">
          <source>also we need the hash
I`m using sha512
it is the best and it is in php</source>
          <target state="translated">また、我々はハッシュを必要としています私は最高のsha512を使用して、それはphpにある</target>
        </trans-unit>
        <trans-unit id="28edb5e4d9749f27a128acb260e84492ffdd3323" translate="yes" xml:space="preserve">
          <source>and for authorize we will use same steps...</source>
          <target state="translated">認証には同じ手順を使用します...</target>
        </trans-unit>
        <trans-unit id="44c7073fa2fab130499078fde7b90431453ca675" translate="yes" xml:space="preserve">
          <source>it is the best way to safe our clients passwords...</source>
          <target state="translated">それは私たちのクライアントのパスワードを安全にするための最良の方法です...</target>
        </trans-unit>
        <trans-unit id="66f5061855cb204f427143765390a0e15cb4bb02" translate="yes" xml:space="preserve">
          <source>now we need to save in database our $hash_psw variable value and $salt variable</source>
          <target state="translated">今、私たちは$hash_psw変数の値と$salt変数をデータベースに保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="65b1ca7c9f59ee04049ba7f7cac979ffa197ee6a" translate="yes" xml:space="preserve">
          <source>ok
in the fitsy we need salt
salt must be unique
so let generate it</source>
          <target state="translated">仝それにしても、このようなことになってしまったのですね......</target>
        </trans-unit>
        <trans-unit id="83813ad92f95972794914dc4459ac7d1fb05a12a" translate="yes" xml:space="preserve">
          <source>so now we can use this functions to generate safe password</source>
          <target state="translated">これで、安全なパスワードを生成するためにこの関数を使うことができるようになりました。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
