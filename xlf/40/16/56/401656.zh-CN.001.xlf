<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/401656">
    <body>
      <group id="401656">
        <trans-unit id="4bd6398b6ec50d16e0ba8b718869fa0726943b47" translate="yes" xml:space="preserve">
          <source>(Emphasis mine.)</source>
          <target state="translated">(强调是我的)。</target>
        </trans-unit>
        <trans-unit id="d54e60153602d914878e89e59608b8d75275ed9e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/sha1&quot;&gt;SHA1&lt;/a&gt; and a salt should suffice (depending, naturally, on whether you are coding something for &lt;a href=&quot;http://en.wikipedia.org/wiki/United_States_Bullion_Depository&quot;&gt;Fort Knox&lt;/a&gt; or a login system for your shopping list) for the foreseeable future. If SHA1 isn't good enough for you, use &lt;a href=&quot;http://php.net/manual/en/function.hash.php&quot;&gt;SHA256&lt;/a&gt;.</source>
          <target state="translated">在可预见的将来， &lt;a href=&quot;http://php.net/sha1&quot;&gt;SHA1&lt;/a&gt;和一种盐就足够了（自然而然地取决于您是为&lt;a href=&quot;http://en.wikipedia.org/wiki/United_States_Bullion_Depository&quot;&gt;Fort Knox&lt;/a&gt;编码还是为购物清单输入登录系统）。 如果SHA1对您来说不够好，请使用&lt;a href=&quot;http://php.net/manual/en/function.hash.php&quot;&gt;SHA256&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a49d7ecc7c611924a2bdc550b87beda1e36e7adf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xkcd.com/936/&quot;&gt;Entropy&lt;/a&gt;. (Not that I fully subscribe to Randall's viewpoint.)</source>
          <target state="translated">&lt;a href=&quot;http://xkcd.com/936/&quot;&gt;熵&lt;/a&gt; 。 （并不是我完全赞同兰德尔的观点。）</target>
        </trans-unit>
        <trans-unit id="331904e34fbc8be8527a2f2cc0ab551951a291a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919&quot;&gt;excellent answer&lt;/a&gt; with more about why &lt;code&gt;password_hash()&lt;/code&gt; or &lt;code&gt;phpass&lt;/code&gt; are the best way to go.</source>
          <target state="translated">关于为何 &lt;code&gt;password_hash()&lt;/code&gt; 或 &lt;code&gt;phpass&lt;/code&gt; 是最佳方式的更多信息，这是一个&lt;a href=&quot;https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919&quot;&gt;很好的答案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6f914dd88be09eb21067092dec3c341a6e91895" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/&quot;&gt;good blog article&lt;/a&gt; giving recommmended 'work factors' (number of iterations) for main algorithms including bcrypt, scrypt and PBKDF2.</source>
          <target state="translated">&lt;a href=&quot;https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/&quot;&gt;一篇不错的博客文章&lt;/a&gt; ，为bcrypt，scrypt和PBKDF2等主要算法提供了建议的&amp;ldquo;工作因子&amp;rdquo;（迭代次数）。</target>
        </trans-unit>
        <trans-unit id="55f55510afeb77726e0d50b49639b6d98210693b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_get_info()&lt;/code&gt; - returns information about the given hash</source>
          <target state="translated">&lt;code&gt;password_get_info()&lt;/code&gt; -返回有关给定哈希的信息</target>
        </trans-unit>
        <trans-unit id="511d82aef08cd670da59b1470aced89fce228ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_hash()&lt;/code&gt; - creates a password hash</source>
          <target state="translated">&lt;code&gt;password_hash()&lt;/code&gt; -创建密码哈希</target>
        </trans-unit>
        <trans-unit id="e53608eb6b90132ef76064ce05e5793fc484cd3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_needs_rehash()&lt;/code&gt; - checks if the given hash matches the given options. Useful to check if the hash conforms to your current technique/cost scheme allowing you to rehash if necessary</source>
          <target state="translated">&lt;code&gt;password_needs_rehash()&lt;/code&gt; -检查给定的哈希值是否与给定的选项匹配。 有用的检查哈希是否符合您当前的技术/成本方案，允许您在必要时重新哈希</target>
        </trans-unit>
        <trans-unit id="ab3126d5de685d9c71a7a339b3efcf5bed455a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_verify()&lt;/code&gt; - verifies that a password matches a hash</source>
          <target state="translated">&lt;code&gt;password_verify()&lt;/code&gt; -验证密码是否与哈希匹配</target>
        </trans-unit>
        <trans-unit id="b4b45af4d94ab99b5074596633ad5d1dd429fc9d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HASHING&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HASHING&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae35617fc2a3e929f057c2ac76f291842cfc1b34" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PASSWORD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PASSWORD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cc85735d6d4bc3f8eb14617d7b3510366c3c30c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PORTS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PORTS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f14c91feaf4967ef247273e68b9a406a2c8c581" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Related questions that don't quite cover my question:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;尚未完全涵盖我的问题的相关问题：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed1c080c450a82285e50d7a816ddc03a0863f19a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SALTING&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SALTING&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5977b0e7ee94c66e337dded2dd5bbe8a4ad8b2cb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SERVER&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SERVER&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="23118db0e558706fb2facd763d94ae2dcff3c884" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USER&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;USER&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="603ff9cd887ac389320761a219db9bf3b57244d7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USERNAME&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;USERNAME&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f77d76027e0db3dd25ad0ea328da229ae899dcd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USERS CREATING PASSWORDS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;用户创建密码&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="896fefe79b5f0b7a660920e0a621a010a9b8870b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DATABASE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DATABASE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d67cf51a25a2a4dbc01f9a24286e1ab97db82f1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DISCLAIMER&lt;/strong&gt;: This answer was written in 2008.</source>
          <target state="translated">&lt;strong&gt;免责声明&lt;/strong&gt; ：该答案写于2008年。</target>
        </trans-unit>
        <trans-unit id="c0ea0dc97baa1d4c675361104fa844e8cea6bf02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PHP&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ff333e7b1ff670b7f3dc5b40367c60de2baedb6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Quick self-test:&lt;/strong&gt; what is password stretching and how many iterations should you use?  If you don't know the answer, you should use &lt;code&gt;password_hash()&lt;/code&gt;, as password stretching is now a critical feature of password mechanisms due to much faster CPUs and the use of &lt;a href=&quot;http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/&quot;&gt;GPUs and FPGAs&lt;/a&gt; to crack passwords at rates of &lt;a href=&quot;http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches&quot;&gt;billions of guesses per second&lt;/a&gt; (with GPUs).</source>
          <target state="translated">&lt;strong&gt;快速自我测试：&lt;/strong&gt;什么是密码扩展？您应该使用多少次迭代？ 如果您不知道答案，则应使用 &lt;code&gt;password_hash()&lt;/code&gt; ，因为由于CPU的运行速度更快以及使用&lt;a href=&quot;http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/&quot;&gt;GPU和FPGA&lt;/a&gt;以&lt;a href=&quot;http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches&quot;&gt;每秒数十亿次猜测的速度&lt;/a&gt;破解密码，所以密码扩展现在是密码机制的关键功能。 （使用GPU）。</target>
        </trans-unit>
        <trans-unit id="aed0191173d72ecf54d46939a34acf7570a79ca0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SERVER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SERVER&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="551e0b7660ec60a1ba024654ebf85dd6e11ea8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;也可以看看：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ead3f7341c29026742f5a4b0dd3a0003a1ebcb6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THINGS TO REMEMBER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;谨记&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e902296e6d584c43a7b6d565ce2461560a6e091" translate="yes" xml:space="preserve">
          <source>A lot has been said about Password encryption for PHP, most of which is very good advice, but before you even start the process of using PHP for password encryption make sure you have the following implemented or ready to be implemented.</source>
          <target state="translated">关于PHP的密码加密,已经说了很多,其中大部分都是非常好的建议,但是在开始使用PHP进行密码加密之前,请确保你已经实现或准备好了以下内容。</target>
        </trans-unit>
        <trans-unit id="d338f3026e67ebbe13c96fce36d81cb026d9f87c" translate="yes" xml:space="preserve">
          <source>A much shorter and safer answer - &lt;strong&gt;don't write your own password mechanism at all&lt;/strong&gt;, use a tried and tested mechanism.</source>
          <target state="translated">更简短，更安全的答案- &lt;strong&gt;根本不要编写自己的密码机制&lt;/strong&gt; ，而要使用经过考验的机制。</target>
        </trans-unit>
        <trans-unit id="4dd080286c78745102f80f80549cafcb94e6e124" translate="yes" xml:space="preserve">
          <source>Also make the user create a secure password, it is simple and should always be done, the user will be grateful for it in the end.</source>
          <target state="translated">同时让用户创建一个安全密码,这很简单,应该经常做,到最后用户会很感激。</target>
        </trans-unit>
        <trans-unit id="9a29f79b84bf18b505a34d003c5ea678dd34f78a" translate="yes" xml:space="preserve">
          <source>Also, double-hashing is generally regarded as bad method, because it diminishes the result space. All popular hashes are fixed-length. Thus, you can have only a finite values of this fixed length, and the results become less varied. This &lt;em&gt;could&lt;/em&gt; be regarded as another form of salting, but I wouldn't recommend it.</source>
          <target state="translated">同样，双重哈希通常被认为是不好的方法，因为它会减少结果空间。 所有流行的哈希都是固定长度的。 因此，您只能具有此固定长度的有限值，并且结果的变化也较少。 这&lt;em&gt;可以&lt;/em&gt;被视为另一种盐腌形式，但我不建议这样做。</target>
        </trans-unit>
        <trans-unit id="47b974489931634025c710e17d5db41c06e42742" translate="yes" xml:space="preserve">
          <source>Also, should I store two fields in the database (one using MD5 and another one using SHA, for example)? Would it make it safer or unsafer?</source>
          <target state="translated">另外,我是否应该在数据库中存储两个字段(例如一个使用MD5,另一个使用SHA)?这样做会更安全还是不安全?</target>
        </trans-unit>
        <trans-unit id="7689b604462baa981c885266a977b157013806aa" translate="yes" xml:space="preserve">
          <source>Always have your application have its own account to access the DB, and only give it the privileges it will need.</source>
          <target state="translated">始终让你的应用程序有自己的账户来访问DB,并且只给它所需要的权限。</target>
        </trans-unit>
        <trans-unit id="3b1bb0601fe6d9e262b3597a1689b03d4b982615" translate="yes" xml:space="preserve">
          <source>Another reason that you want a good, robust hash on a user accounts is to give you enough time to change all the passwords in the system. If your database is compromised you will need enough time to at &lt;em&gt;least&lt;/em&gt; lock the system down, if not change every password in the database.</source>
          <target state="translated">您想要对用户帐户进行良好而可靠的哈希处理的另一个原因是，给您足够的时间来更改系统中的所有密码。 如果您的数据库遭到破坏，您将需要足够的时间&lt;em&gt;至少&lt;/em&gt;锁定系统，如果不更改数据库中的每个密码。</target>
        </trans-unit>
        <trans-unit id="fc8b9b7b7e69aecc8d6210a0592328219dceab04" translate="yes" xml:space="preserve">
          <source>As of PHP 5.5, PHP has simple, secure functions for hashing and verifying passwords, &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash()&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;password_verify()&lt;/a&gt;</source>
          <target state="translated">从PHP 5.5开始，PHP具有简单，安全的功能，用于哈希和验证密码， &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash（）&lt;/a&gt;和&lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;password_verify（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ea99ddf0910092b785f4db900f1d1881fb27c6a" translate="yes" xml:space="preserve">
          <source>At the moment these functions accept the PASSWORD_BCRYPT and PASSWORD_DEFAULT password constants, which are synonymous at the moment, the difference being that PASSWORD_DEFAULT &quot;may change in newer PHP releases when newer, stronger hashing algorithms are supported.&quot; Using PASSWORD_DEFAULT and password_needs_rehash() on login (and rehashing if necessary) should ensure that your hashes are reasonably resilient to brute-force attacks with little to no work for you.</source>
          <target state="translated">目前,这些函数接受 PASSWORD_BCRYPT 和 PASSWORD_DEFAULT 两种密码常数,它们是目前的同义词,不同的是 PASSWORD_DEFAULT &quot;在较新的 PHP 版本中,当支持较新的、更强的散列算法时,PASSWORD_DEFAULT 可能会改变。在登录时使用 PASSWORD_DEFAULT 和 password_needs_rehash()(如果有必要的话,可以重新进行散列)应该可以确保你的散列算法对蛮力攻击有一定的抵抗力,而且几乎不需要你做任何工作。</target>
        </trans-unit>
        <trans-unit id="8bc33659ae93746ba57bab9705cc4dea91e1472b" translate="yes" xml:space="preserve">
          <source>Average practices</source>
          <target state="translated">平均做法</target>
        </trans-unit>
        <trans-unit id="f6015c3a8cc452ac75b47eabd9579dadfdb0ffe6" translate="yes" xml:space="preserve">
          <source>Bcrypt and &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;scrypt&lt;/a&gt; are the current best practices. &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;Scrypt&lt;/a&gt; will be better than bcrypt in time, but it hasn't seen adoption as a standard by Linux/Unix or by webservers, and hasn't had in-depth reviews of its algorithm posted yet. But still, the future of the algorithm does look promising. If you are working with Ruby there is an &lt;a href=&quot;http://rubygems.org/gems/scrypt&quot;&gt;scrypt gem&lt;/a&gt; that will help you out, and Node.js now has its own &lt;a href=&quot;https://npmjs.org/package/scrypt&quot;&gt;scrypt&lt;/a&gt; package. You can use Scrypt in PHP either via the &lt;a href=&quot;https://pecl.php.net/package/scrypt&quot;&gt;Scrypt&lt;/a&gt; extension or the &lt;a href=&quot;https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md&quot;&gt;Libsodium&lt;/a&gt; extension (both are available in PECL).</source>
          <target state="translated">Bcrypt和&lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;scrypt&lt;/a&gt;是当前的最佳实践。 &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;Scrypt&lt;/a&gt;在时间上会比bcrypt更好，但是它尚未被Linux / Unix或Web服务器视为采用标准，并且尚未对其算法进行深入审查。 但是，该算法的未来看起来确实很有希望。 如果您使用Ruby，那么有一个&lt;a href=&quot;http://rubygems.org/gems/scrypt&quot;&gt;scrypt gem&lt;/a&gt;可以为您提供帮助，而Node.js现在拥有自己的&lt;a href=&quot;https://npmjs.org/package/scrypt&quot;&gt;scrypt&lt;/a&gt;包。 您可以通过&lt;a href=&quot;https://pecl.php.net/package/scrypt&quot;&gt;Scrypt&lt;/a&gt;扩展或&lt;a href=&quot;https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md&quot;&gt;Libsodium&lt;/a&gt;扩展（在PECL中都可用）在PHP中使用Scrypt。</target>
        </trans-unit>
        <trans-unit id="eb8de9ce8757ee3c542141ac80ff3b33dc04edff" translate="yes" xml:space="preserve">
          <source>Best practices</source>
          <target state="translated">最佳做法</target>
        </trans-unit>
        <trans-unit id="2de241bdf77a55e27f8fca0e42659620a7b0aefe" translate="yes" xml:space="preserve">
          <source>But suppose that you cannot use bcrypt or PHPASS at all. What then?</source>
          <target state="translated">但假设你根本无法使用bcrypt或PHPASS。那怎么办?</target>
        </trans-unit>
        <trans-unit id="117f2a5735e534774bb47e831d678f2aadc64e41" translate="yes" xml:space="preserve">
          <source>By default it used strongest available encryption that is implemented in Phpass, which is &lt;code&gt;bcrypt&lt;/code&gt; and falls back to other encryptions down to MD5 to provide backward compatibility to frameworks like Wordpress.</source>
          <target state="translated">默认情况下，它使用Phpass中实现的最强大的可用加密，该加密是 &lt;code&gt;bcrypt&lt;/code&gt; 并回退到MD5的其他加密，以向与Wordpress等框架兼容。</target>
        </trans-unit>
        <trans-unit id="b633fdfaff7ad5fc7b721447cc8831c42591c4bc" translate="yes" xml:space="preserve">
          <source>Coming in PHP 5.5 is a &lt;a href=&quot;http://php.net/manual/en/ref.password.php&quot;&gt;full password protection library&lt;/a&gt; that abstracts away any pains of working with bcrypt. While most of us are stuck with PHP 5.2 and 5.3 in most common environments, especially shared hosts, @ircmaxell has built a &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility layer&lt;/a&gt; for the coming API that is backward compatible to PHP 5.3.7.</source>
          <target state="translated">PHP 5.5中引入了一个&lt;a href=&quot;http://php.net/manual/en/ref.password.php&quot;&gt;完整的密码保护库&lt;/a&gt; ，该库抽象了使用bcrypt的所有麻烦。 虽然我们大多数人在最常见的环境（尤其是共享主机）中都坚持使用PHP 5.2和5.3，但是@ircmaxell为即将到来的API构建了一个&lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;兼容层&lt;/a&gt; ，该层向后兼容PHP 5.3.7。</target>
        </trans-unit>
        <trans-unit id="af9cf1efb4bd36a869c85c6db68040652b17d4ae" translate="yes" xml:space="preserve">
          <source>Cryptography Recap &amp;amp; Disclaimer</source>
          <target state="translated">密码学回顾与免责声明</target>
        </trans-unit>
        <trans-unit id="2ef42ffab4aacba15da77cf466976e72bd80c6f0" translate="yes" xml:space="preserve">
          <source>Don't limit the length of a password. If your users want a sentence with supercalifragilisticexpialidocious in it, don't prevent them from using it.</source>
          <target state="translated">不要限制密码的长度。如果你的用户想让你的用户在里面有一句话是超级califragilisticexpialidocious,不要阻止他们使用。</target>
        </trans-unit>
        <trans-unit id="b6a9c3be345b95b031149b5d719b84262d749a02" translate="yes" xml:space="preserve">
          <source>Don't limit what characters users can enter for passwords. Only idiots do this.</source>
          <target state="translated">不要限制用户可以输入的密码字符。只有白痴才会这样做。</target>
        </trans-unit>
        <trans-unit id="57b8188ffa4f6ec3553dfe244191b42014f16984" translate="yes" xml:space="preserve">
          <source>Don't mix &lt;a href=&quot;http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html&quot;&gt;bcrypt and with the &lt;em&gt;raw&lt;/em&gt; output of hash()&lt;/a&gt;, either use hex output or base64_encode it. (This applies to any input that may have a rogue &lt;code&gt;\0&lt;/code&gt; in it, which can seriously weaken security.)</source>
          <target state="translated">不要将&lt;a href=&quot;http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html&quot;&gt;bcrypt与hash（）的&lt;em&gt;原始&lt;/em&gt;输出&lt;/a&gt;混合使用，请使用十六进制输出或base64_encode对其进行编码。 （这适用于其中可能包含流氓 &lt;code&gt;\0&lt;/code&gt; 任何输入，这会严重削弱安全性。）</target>
        </trans-unit>
        <trans-unit id="b14bcf13287ceb3241fed3d968a38802da7cb034" translate="yes" xml:space="preserve">
          <source>Don't strip or escape HTML and special characters in the password.</source>
          <target state="translated">不要在密码中剥离或转义HTML和特殊字符。</target>
        </trans-unit>
        <trans-unit id="093743f90c366f3346a4626e0147ea26113350c4" translate="yes" xml:space="preserve">
          <source>Don'ts</source>
          <target state="translated">Don'ts</target>
        </trans-unit>
        <trans-unit id="586c15c6fd8448116ae5a0f2e995d41e36f153b8" translate="yes" xml:space="preserve">
          <source>Dos</source>
          <target state="translated">Dos</target>
        </trans-unit>
        <trans-unit id="951e25161bf6bbd8580e18709c3c792954ee12e4" translate="yes" xml:space="preserve">
          <source>EDIT: I just realised that this is mentioned briefly in Robert K's answer. I'll leave this answer here since I think it provides a bit more information about how it works and the ease of use it provides for those who don't know security.</source>
          <target state="translated">EDIT:我刚刚意识到,在Robert K的回答中提到了这个问题。我把这个答案留在这里,因为我认为它提供了更多关于它的工作原理和它为不懂安全的人提供的易用性的信息。</target>
        </trans-unit>
        <trans-unit id="5aed566d3e7f4533ea18f62aa39f7cec10ce35f6" translate="yes" xml:space="preserve">
          <source>Finally, no matter the security measures you take nothing is 100% secure, the more advanced the technology to protect becomes the more advanced the attacks become. But following these steps will make your site more secure and far less desirable for attackers to go after.</source>
          <target state="translated">最后,无论你采取什么安全措施都不是100%安全的,保护技术越先进,攻击就会变得越先进。但遵循这些步骤,会让你的网站更安全,也更不容易被攻击者盯上。</target>
        </trans-unit>
        <trans-unit id="bfdae5a79adfab1e18ea1d0102894a2dccc076bf" translate="yes" xml:space="preserve">
          <source>Follow the same guidelines as with all good passwords. Also don't reuse the same password on any SERVER or DB accounts on the same system.</source>
          <target state="translated">遵循与所有好的密码相同的准则。另外,不要在同一系统中的任何SERVER或DB账户上重复使用相同的密码。</target>
        </trans-unit>
        <trans-unit id="f46f0816adc340442cfbcc816c79aadee7d62c1c" translate="yes" xml:space="preserve">
          <source>For all that is good in the world do not use the username admin, root or something similar. Also if you are on a unix based system DO NOT make the root account login accessible, it should always be sudo only.</source>
          <target state="translated">对于世界上所有的好东西,不要使用admin、root或类似的用户名。另外,如果你是基于unix系统,请不要让root账户登录,应该只用sudo。</target>
        </trans-unit>
        <trans-unit id="d9ea1176666f5e2cfe77b291548afa7d1dd3e910" translate="yes" xml:space="preserve">
          <source>For example, you can &lt;a href=&quot;http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/&quot;&gt;crack all 8-character Windows passwords in 6 hours&lt;/a&gt; using 25 GPUs installed in 5 desktop PCs.  This is brute-forcing i.e. enumerating and checking &lt;em&gt;every 8-character Windows password&lt;/em&gt;, including special characters, and is not a dictionary attack. That was in 2012, as of 2018 you could use fewer GPUs, or crack faster with 25 GPUs.</source>
          <target state="translated">例如，您可以使用5台台式计算机中安装的25个GPU &lt;a href=&quot;http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/&quot;&gt;在6小时内破解所有8个字符的Windows密码&lt;/a&gt; 。 这是蛮横的，即枚举和检查&lt;em&gt;每个8个字符的Windows密码&lt;/em&gt; （包括特殊字符），而不是字典攻击。 那是在2012年，到2018年，您可以使用更少的GPU，或者使用25个GPU更快地破解。</target>
        </trans-unit>
        <trans-unit id="5638ccd08221ca60e74b51eedce8f8691850aa0d" translate="yes" xml:space="preserve">
          <source>Future Practices</source>
          <target state="translated">今后的做法</target>
        </trans-unit>
        <trans-unit id="8cdb7a0b3b6ace5e886174a72b1782806543e80f" translate="yes" xml:space="preserve">
          <source>Google says SHA256 is available to PHP.</source>
          <target state="translated">谷歌表示,SHA256对PHP是可用的。</target>
        </trans-unit>
        <trans-unit id="6dfd63230af2892f2f367f0290c4dfd849f7dc6a" translate="yes" xml:space="preserve">
          <source>Here is a PHP class that creates a hash and salt for a password easily</source>
          <target state="translated">这里有一个PHP类,可以为密码创建一个散列和盐,很容易就能创建一个密码的散列和盐</target>
        </trans-unit>
        <trans-unit id="d3de020d4de5c9ec8acb08596101993264195d55" translate="yes" xml:space="preserve">
          <source>How would you implement salted passwords in Tomcat 5.5</source>
          <target state="translated">如何在Tomcat 5.5中实现盐化密码?</target>
        </trans-unit>
        <trans-unit id="094dfed6a03363f271cb6e9eb1fbbe95ffe3f66b" translate="yes" xml:space="preserve">
          <source>I almost can't imagine this situation anymore. &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt; supports PHP 3.0.18 through 5.3, so it is usable on almost every installation imaginable&amp;mdash;and should be used if you don't &lt;em&gt;know for certain&lt;/em&gt; that your environment supports bcrypt.</source>
          <target state="translated">我几乎无法想象这种情况了。 &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt;支持PHP 3.0.18到5.3，因此几乎可以在所有可以想到的安装中使用它-如果&lt;em&gt;不确定&lt;/em&gt;您的环境是否支持bcrypt，则应使用它。</target>
        </trans-unit>
        <trans-unit id="a7427fce65bccc8329b93c08c2c177aa8d900929" translate="yes" xml:space="preserve">
          <source>I changed my mind about using bcrypt when I learned that bcrypt only uses blowfish's key schedule, with a variable cost mechanism. The latter lets you increase the cost to brute-force a password by increasing blowfish's already expensive key schedule.</source>
          <target state="translated">当我了解到bcrypt只使用blowfish的密钥计划表时,我改变了使用bcrypt的想法,因为bcrypt只使用blowfish的密钥计划表,而且有一个可变成本机制。后者可以让你通过增加Blowfish本来就很贵的密钥计划表来增加密码的成本。</target>
        </trans-unit>
        <trans-unit id="74d1dec78ea1f0d88fb883d96450938d3cd9d96d" translate="yes" xml:space="preserve">
          <source>I found perfect topic on this matter here: &lt;a href=&quot;https://crackstation.net/hashing-security.htm&quot;&gt;https://crackstation.net/hashing-security.htm&lt;/a&gt;, I wanted you to get benefit from it, here is source code also that provided prevention against time-based attack also.</source>
          <target state="translated">我在这里找到了关于此问题的完美话题： &lt;a href=&quot;https://crackstation.net/hashing-security.htm&quot;&gt;https&lt;/a&gt; : //crackstation.net/hashing-security.htm ，我希望您能从中受益，这里的源代码也提供了针对基于时间的攻击的防护。</target>
        </trans-unit>
        <trans-unit id="878b969cae5ef5b116676174f4bba610ac895913" translate="yes" xml:space="preserve">
          <source>I highly suggest reading the documentation for the &lt;a href=&quot;http://us.php.net/crypt&quot;&gt;crypt function&lt;/a&gt; if you want to understand how to use bcrypt, or finding yourself a &lt;a href=&quot;https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021&quot;&gt;good&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/1070401&quot;&gt;wrapper&lt;/a&gt; or use something like &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt; for a more legacy implementation. I recommend a minimum of 12 rounds of bcrypt, if not 15 to 18.</source>
          <target state="translated">我强烈建议您阅读&lt;a href=&quot;http://us.php.net/crypt&quot;&gt;crypt函数&lt;/a&gt;的文档，如果您想了解如何使用bcrypt，或者为自己找到一个&lt;a href=&quot;https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021&quot;&gt;好的&lt;/a&gt; &lt;a href=&quot;https://gist.github.com/1070401&quot;&gt;包装器，&lt;/a&gt;或者将类似&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS的&lt;/a&gt;东西用于更传统的实现。 我建议至少12轮bcrypt，如果不是15到18。</target>
        </trans-unit>
        <trans-unit id="3acd6228038caf8487300f27ba32f185e5efc8f9" translate="yes" xml:space="preserve">
          <source>I just want to point out that PHP 5.5 includes a &lt;a href=&quot;http://www.php.net/manual/en/ref.password.php&quot;&gt;password hashing API&lt;/a&gt; that provides a wrapper around &lt;code&gt;crypt()&lt;/code&gt;. This API significantly simplifies the task of hashing, verifying and rehashing password hashes. The author has also released a &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility pack&lt;/a&gt; (in the form of a single password.php file that you simply &lt;code&gt;require&lt;/code&gt; to use), for those using PHP 5.3.7 and later and want to use this right now.</source>
          <target state="translated">我只想指出，PHP 5.5包含一个&lt;a href=&quot;http://www.php.net/manual/en/ref.password.php&quot;&gt;密码哈希API&lt;/a&gt; ，该API为 &lt;code&gt;crypt()&lt;/code&gt; 提供了包装器。 该API大大简化了哈希，验证和重新哈希密码哈希的任务。 作者还发布了一个&lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;兼容包&lt;/a&gt; （以您只 &lt;code&gt;require&lt;/code&gt; 使用的单个password.php文件的形式），适用于使用PHP 5.3.7及更高版本并希望立即使用此功能的用户。</target>
        </trans-unit>
        <trans-unit id="021bc86837c1cf4ede09646fe8929f5646deb92f" translate="yes" xml:space="preserve">
          <source>I usually use SHA1 and salt with the user ID (or some other user-specific piece of information), and sometimes I additionally use a constant salt (so I have 2 parts to the salt).</source>
          <target state="translated">我通常使用SHA1和盐与用户ID(或其他一些特定于用户的信息),有时我还会额外使用一个恒定的盐(所以我有2个部分的盐)。</target>
        </trans-unit>
        <trans-unit id="1bc7ca4a9003d758e3158a03983889340d7b0ef9" translate="yes" xml:space="preserve">
          <source>I would not store the password hashed in two different ways, because then the system is at least as weak as the weakest of the hash algorithms in use.</source>
          <target state="translated">我不会用两种不同的方式来存储密码的哈希算法,因为这样的话,系统至少和目前使用的哈希算法一样弱。</target>
        </trans-unit>
        <trans-unit id="462230903f4568427872db9e53f5786cbc3b5e7d" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;Phpass&lt;/a&gt; which is a simple one-file PHP class that could be implemented very easily in nearly every PHP project. See also &lt;a href=&quot;http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4&quot;&gt;The H&lt;/a&gt;.</source>
          <target state="translated">我正在使用&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;Phpass&lt;/a&gt; ，这是一个简单的单文件PHP类，几乎可以在每个PHP项目中轻松实现。 另请参见&lt;a href=&quot;http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4&quot;&gt;H。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e7956166ff653d061a0f1fee8e6d1f242bac81e" translate="yes" xml:space="preserve">
          <source>I'm using PHP. I want a safe and fast password encryption system. Hashing a password a million times may be safer, but also slower. How to achieve a good balance between speed and safety? Also, I'd prefer the result to have a constant number of characters.</source>
          <target state="translated">我使用的是PHP。我想要一个安全、快速的密码加密系统。对密码进行无数次的哈希特化可能更安全,但也比较慢。如何在速度和安全之间取得一个很好的平衡?另外,我希望结果是字符数不变。</target>
        </trans-unit>
        <trans-unit id="6ff2c27f72547e5d2b06a5581aa37280ccb6a8db" translate="yes" xml:space="preserve">
          <source>Ideally you want your DB and APPLICATION on separate servers. This is not always possible due to cost, but it does allow for some safety as the attacker will have to go through two steps to fully access the system.</source>
          <target state="translated">理想情况下,你希望你的数据库和应用程序在不同的服务器上。由于成本原因,这并不总是可行的,但它确实可以保证一定的安全性,因为攻击者必须经过两个步骤才能完全访问系统。</target>
        </trans-unit>
        <trans-unit id="3a9162bbf805570c30c3008fac626548ad008226" translate="yes" xml:space="preserve">
          <source>If the user is creating a password through the frontend that means it has to be sent to the server. This opens up a security issue because that means the unencrypted password is being sent to the server and if a attacker is able to listen and access that all your security in PHP is worthless. ALWAYS transmit the data SECURELY, this is done through SSL, but be weary even SSL is not flawless (OpenSSL's Heartbleed flaw is an example of this).</source>
          <target state="translated">如果用户通过前台创建密码,这意味着它必须被发送到服务器上。这就带来了一个安全问题,因为这意味着未加密的密码被发送到服务器上,如果攻击者能够监听和访问,那么你的PHP的所有安全保障就毫无价值。永远要安全地传输数据,这是通过SSL来完成的,但要小心,即使SSL也不是无懈可击的(OpenSSL的Heartbleed漏洞就是一个例子)。</target>
        </trans-unit>
        <trans-unit id="bfdaf953c79a7a6b68bb4199d7beacdee227846d" translate="yes" xml:space="preserve">
          <source>Implement a reasonable 8-10 character minimum length, plus require at least 1 upper case letter, 1 lower case letter, a number, and a symbol. This will improve the entropy of the password, in turn making it harder to crack. (See the &quot;What makes a good password?&quot; section for some debate.)</source>
          <target state="translated">实施合理的8-10个字符的最小长度,并要求至少有1个大写字母、1个小写字母、1个数字和1个符号。这将提高密码的熵,从而使其更难破解。(请参阅 &quot;什么才是好的密码?&quot;一节中的争论)。)</target>
        </trans-unit>
        <trans-unit id="db36d1a15c2eff2b9e586d75be21da1c305b8b6a" translate="yes" xml:space="preserve">
          <source>In case I wasn't clear enough, I want to know which hashing function(s) to use and how to pick a good salt in order to have a safe and fast password protection mechanism.</source>
          <target state="translated">为了防止我还不够清楚,我想知道应该使用哪种散列函数,以及如何挑选好的盐,才能有一个安全快速的密码保护机制。</target>
        </trans-unit>
        <trans-unit id="4d685a0e94f3eab6cfef426e115b55c6d2ecd20c" translate="yes" xml:space="preserve">
          <source>In short, entropy is how much variation is within the password. When a password is only lowercase roman letters, that's only 26 characters. That isn't much variation. Alpha-numeric passwords are better, with 36 characters. But allowing upper and lower case, with symbols, is roughly 96 characters. That's a lot better than just letters. One problem is, to make our passwords memorable we insert patterns&amp;mdash;which reduces entropy. Oops!</source>
          <target state="translated">简而言之，熵就是密码中的变化量。 当密码仅是小写罗马字母时，则只有26个字符。 差异不大。 字母数字密码最好使用36个字符。 但是允许带符号的大写和小写字母约为96个字符。 这比仅字母要好得多。 一个问题是，为了使密码令人难忘，我们插入了模式-从而减少了熵。 糟糕！</target>
        </trans-unit>
        <trans-unit id="f5c756bd1a76be361873a30bd1bd4190227c361c" translate="yes" xml:space="preserve">
          <source>In the comments I talked with @popnoodles, who pointed out that &lt;em&gt;enforcing&lt;/em&gt; a password policy of X length with X many letters, numbers, symbols, etc, can actually reduce entropy by making the password scheme more predictable. I do agree. Randomess, as truly random as possible, is always the safest but least memorable solution.</source>
          <target state="translated">在我与@popnoodles交谈的评论中，他指出&lt;em&gt;强制&lt;/em&gt; X长度为X的密码策略包含X个字母，数字，符号等，实际上可以通过使密码方案更可预测来减少熵。 我同意。 随机性，尽可能真正地随机性，始终是最安全但最难忘的解决方案。</target>
        </trans-unit>
        <trans-unit id="b0a50c178288b0e09504dc0a677b514cf240abd4" translate="yes" xml:space="preserve">
          <source>In the end, double-hashing, mathematically, provides no benefit.  In practice, however, it is useful for preventing rainbow table-based attacks.  In other words, it is of no more benefit than hashing with a salt, which takes far less processor time in your application or on your server.</source>
          <target state="translated">最后,从数学上来说,双切值,没有提供任何好处。然而,在实践中,它对于防止基于彩虹表的攻击是有用的。换句话说,它的好处不比用盐进行散列的好处多,因为它在你的应用程序或服务器上花费的处理器时间要少得多。</target>
        </trans-unit>
        <trans-unit id="7d25865b4d6182316faf089b42e9c22a190d279b" translate="yes" xml:space="preserve">
          <source>Increasing cost (which defaults to 10) makes the hash harder to brute-force but also means generating hashes and verifying passwords against them will be more work for your server's CPU.</source>
          <target state="translated">增加成本(默认为10)使得散列的难度增加,但也意味着生成散列和验证密码的难度增加了服务器的CPU。</target>
        </trans-unit>
        <trans-unit id="3819c766e1a237afa339d1b32fb8107d612fcdd2" translate="yes" xml:space="preserve">
          <source>Interestingly, in living out this nightmare, I learned A LOT I didn&amp;rsquo;t know about password cracking, storage, and complexity. &lt;em&gt;I&amp;rsquo;ve come to appreciate why password storage is ever so much more important than password complexity. If you don&amp;rsquo;t know how your password is stored, then all you really can depend upon is complexity.&lt;/em&gt; This might be common knowledge to password and crypto pros, but for the average InfoSec or Web Security expert, I highly doubt it.</source>
          <target state="translated">有趣的是，在摆脱这场噩梦的过程中，我学到了很多我不知道的有关密码破解，存储和复杂性的信息。 &lt;em&gt;我已经开始欣赏为什么密码存储比密码复杂性重要得多了。&lt;/em&gt; &lt;em&gt;如果您不知道密码的存储方式，那么您真正可以依靠的仅仅是复杂性。&lt;/em&gt; 这可能是密码和加密专家的常识，但是对于普通的InfoSec或Web安全专家而言，我对此表示高度怀疑。</target>
        </trans-unit>
        <trans-unit id="32aace1e6bd9db8789604b5d77b5b357f1a03eeb" translate="yes" xml:space="preserve">
          <source>It can use salt (in this case, are all salts equally good? Is there any way to generate good salts?)</source>
          <target state="translated">它可以用盐(这种情况下,是不是所有的盐都一样好?有没有什么方法可以产生好的盐?)</target>
        </trans-unit>
        <trans-unit id="76532b90f399c161d14466cd2bb1c1a7e08c404d" translate="yes" xml:space="preserve">
          <source>It is currently said that MD5 is partially unsafe. Taking this into consideration, I'd like to know which mechanism to use for password protection.</source>
          <target state="translated">目前有人说MD5部分不安全。考虑到这一点,我想知道密码保护用什么机制?</target>
        </trans-unit>
        <trans-unit id="ec687b6fd5c605eabd26943ffe28b1856e82a532" translate="yes" xml:space="preserve">
          <source>It must be safe</source>
          <target state="translated">一定是安全的</target>
        </trans-unit>
        <trans-unit id="2deed719274cbd038881d457f177804efb08bba8" translate="yes" xml:space="preserve">
          <source>It only supports BCRYPT for now, but it aims to be easily extended to include other password hashing techniques and because the technique and cost is stored as part of the hash, changes to your prefered hashing technique/cost will not invalidate current hashes, the framework will automagically, use the correct technique/cost when validating. It also handles generating a &quot;secure&quot; salt if you do not explicitly define your own.</source>
          <target state="translated">它目前只支持BCRYPT,但它的目标是很容易扩展到包括其他的密码散列技术,由于技术和成本作为散列的一部分存储在散列中,所以改变你喜欢的散列技术和成本不会使当前的散列失效,框架在验证时将自动使用正确的技术成本。如果你没有明确地定义自己的盐,它还可以处理生成一个 &quot;安全的 &quot;盐。</target>
        </trans-unit>
        <trans-unit id="fbfb86f18fa274ab0a5bfb0be1ee04f715779f9f" translate="yes" xml:space="preserve">
          <source>Jeremiah Grossman, CTO of Whitehat Security, &lt;a href=&quot;https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/&quot;&gt;stated on White Hat Security blog&lt;/a&gt; after a recent password recovery that required brute-force breaking of his password protection:</source>
          <target state="translated">Whitehat Security的首席技术官Jeremiah Grossman在最近的密码恢复后要求在蛮力破解他的密码保护之后， &lt;a href=&quot;https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/&quot;&gt;在White Hat Security博客上说。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1b0239b75a0a79e1923e96b83331042b6c1cfea" translate="yes" xml:space="preserve">
          <source>Lastly: I am not a cryptographer. Whatever I've said is my opinion, but I happen to think it's based on good ol' common sense ... and lots of reading. Remember, be as paranoid as possible, make things as hard to intrude as possible, and then, if you are still worried, contact a white-hat hacker or cryptographer to see what they say about your code/system.</source>
          <target state="translated">最后:我不是一个密码学家。无论我说的是什么,都是我的观点,但我恰好认为这是基于良好的常识......和大量的阅读。请记住,尽可能的偏执,尽可能的让事情尽可能的难于入侵,然后,如果你仍然担心,请联系白帽黑客或密码学家,看看他们对你的密码系统怎么说。</target>
        </trans-unit>
        <trans-unit id="c3fdfe95f7d84ea072335ae939def14083cede1e" translate="yes" xml:space="preserve">
          <source>Like always DO NOT make this root or something similar.</source>
          <target state="translated">像往常一样不要做这个根或类似的东西。</target>
        </trans-unit>
        <trans-unit id="8272783154610ed637003d484b1ab9e70499174f" translate="yes" xml:space="preserve">
          <source>More explanation is available at- &lt;a href=&quot;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&quot;&gt;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&lt;/a&gt;</source>
          <target state="translated">有关更多说明，请访问&lt;a href=&quot;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&quot;&gt;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ccbd82ab1462c38ff0a96c985a99ed1447b09ef0" translate="yes" xml:space="preserve">
          <source>Most programmers just don't have the expertise to write crypto related code safely without introducing vulnerabilities.</source>
          <target state="translated">大多数程序员只是没有专业知识来安全地写出与密码相关的代码而不引入漏洞。</target>
        </trans-unit>
        <trans-unit id="f4b758984e383af744fd6b70d1a44453fe5d02d5" translate="yes" xml:space="preserve">
          <source>NEVER EVER store a password in your DB, instead store the hash and unique salt, I will explain why later.</source>
          <target state="translated">永远不要在你的数据库中存储密码,而要存储哈希和唯一的盐,我稍后会解释为什么。</target>
        </trans-unit>
        <trans-unit id="b668a4bf2c2b13fda6ea44b2604e7cb52f134d07" translate="yes" xml:space="preserve">
          <source>Never email a password to your user &lt;em&gt;except when they have lost theirs, and you sent a temporary one.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;除非&lt;/em&gt;用户忘记了密码， &lt;em&gt;否则&lt;/em&gt;切勿将密码通过电子邮件发送给您的用户&lt;em&gt;，而是您发送了一个临时&lt;/em&gt;密码&lt;em&gt;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a05bf77552bc683c933754926449ac35cd64a670" translate="yes" xml:space="preserve">
          <source>Never hash passwords with &lt;a href=&quot;http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/&quot;&gt;SHA1&lt;/a&gt; or MD5 or even SHA256! &lt;a href=&quot;http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/&quot;&gt;Modern crackers&lt;/a&gt; can exceed 60 and 180 billion hashes/second (respectively).</source>
          <target state="translated">切勿使用&lt;a href=&quot;http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/&quot;&gt;SHA1&lt;/a&gt;或MD5甚至SHA256哈希密码！ &lt;a href=&quot;http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/&quot;&gt;现代饼干&lt;/a&gt;可以分别超过60和1800亿个哈希/秒。</target>
        </trans-unit>
        <trans-unit id="f8ba9091576887aa8ba6c61d6c8d8e6d54342993" translate="yes" xml:space="preserve">
          <source>Never store your user's password in plain-text.</source>
          <target state="translated">不要将用户的密码存储在纯文本中。</target>
        </trans-unit>
        <trans-unit id="e583d29870e1092a65f27803157c2c1944f2e8dd" translate="yes" xml:space="preserve">
          <source>Never, ever log passwords in any manner.</source>
          <target state="translated">永远不要以任何方式记录密码。</target>
        </trans-unit>
        <trans-unit id="b0dd8e37f7458d33cf378742fcb833eb6f03eaa4" translate="yes" xml:space="preserve">
          <source>No matter how good your encryption is if you don't properly secure the server that runs the PHP and DB all your efforts are worthless. Most servers function relatively the same way, they have ports assigned to allow you to access them remotely either through ftp or shell. Make sure that you change the default port of which ever remote connection you have active. By not doing this you in effect have made the attacker do one less step in accessing your system.</source>
          <target state="translated">无论你的加密技术有多好,如果你没有正确地保护运行PHP和DB的服务器,那么你所有的努力都是徒劳的。大多数服务器的功能相对来说都是一样的,它们有指定的端口,允许你通过ftp或shell远程访问。请确保你改变你的远程连接的默认端口。如果你不这样做,你实际上是让攻击者在访问你的系统时少了一个步骤。</target>
        </trans-unit>
        <trans-unit id="a0316a87f5c5e013f52649e477f4e70dd3e0acba" translate="yes" xml:space="preserve">
          <source>Note that even though the default hashing algorithm may change, old hashes will continue to verify just fine because the algorithm used is stored in the hash and &lt;code&gt;password_verify()&lt;/code&gt; picks up on it.</source>
          <target state="translated">请注意，即使默认的哈希算法可能会更改，但由于使用的算法存储在哈希中，并且 &lt;code&gt;password_verify()&lt;/code&gt; 会继续使用，因此旧哈希仍会继续验证得很好。</target>
        </trans-unit>
        <trans-unit id="2008200dd1969bed81cd881c21332864a96d99ae" translate="yes" xml:space="preserve">
          <source>ONE WAY HASHING!!!!!!!, Never hash a password in a way that it can be reversed, Hashes should be one way, meaning you don't reverse them and compare them to the password, you instead hash the entered password the same way and compare the two hashes. This means that even if an attacker gets access to the DB he doesn't know what the actually password is, just its resulting hash. Which means more security for your users in the worst possible scenario.</source>
          <target state="translated">单向散列! 这意味着,即使攻击者获得了数据库的访问权限,他也不知道实际的密码是什么,只是知道它的哈希值。这就意味着在最坏的情况下,你的用户可以得到更多的安全保障。</target>
        </trans-unit>
        <trans-unit id="702aaf71948af0b0b28598e8e00fec24cf4962f6" translate="yes" xml:space="preserve">
          <source>Older PHP versions: OpenWall's &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;phpass&lt;/a&gt; library is much better than most custom code - used in WordPress, Drupal, etc.</source>
          <target state="translated">较旧的PHP版本：OpenWall的&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;phpass&lt;/a&gt;库比大多数自定义代码要好得多-在WordPress，Drupal等中使用。</target>
        </trans-unit>
        <trans-unit id="bc886b63ca3b0eb383c458da407e533fe3d56755" translate="yes" xml:space="preserve">
          <source>One of the most common mistakes in hashing is that hashes are not unique to the users. This is mainly because salts are not uniquely generated.</source>
          <target state="translated">散列中最常见的错误之一是,散列不是用户唯一的。这主要是因为散列不是唯一生成的。</target>
        </trans-unit>
        <trans-unit id="c2385fa123d6a9984b6b1eddc74522697f2d9f20" translate="yes" xml:space="preserve">
          <source>P.s. for last 2 steps you can use your own algorithm...
but be sure that you can generate this hashed password in the future 
when you need to authorize user...</source>
          <target state="translated">P.s.s.对于最后两步,你可以使用你自己的算法...........但要确保你可以在将来需要授权用户的时候生成这个散列密码......</target>
        </trans-unit>
        <trans-unit id="7d080faa12a8ba859c71e8cfa04be086436076bf" translate="yes" xml:space="preserve">
          <source>PHP 5.5 or higher: &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash()&lt;/a&gt; is good quality and part of PHP core.</source>
          <target state="translated">PHP 5.5或更高版本： &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash（）&lt;/a&gt;是高质量的，并且是PHP核心的一部分。</target>
        </trans-unit>
        <trans-unit id="e441ae84ae0663d1c0b2f38792b0dada2e5cf183" translate="yes" xml:space="preserve">
          <source>Password entropy is &lt;a href=&quot;https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/&quot;&gt;approximated&lt;/a&gt; easily. Using the full range of ascii characters (roughly 96 typeable characters) yields an entropy of 6.6 per character, which at 8 characters for a password is still too low (52.679 bits of entropy) for future security. But the good news is: longer passwords, and passwords with unicode characters, really increase the entropy of a password and make it harder to crack.</source>
          <target state="translated">密码熵很容易&lt;a href=&quot;https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/&quot;&gt;近似&lt;/a&gt; 。 使用全部范围的ascii字符（大约96个可键入字符），每个字符的熵为6.6，而对于8个字符的密码，它的熵仍然太低（52.679位熵），对于将来的安全性而言。 但好消息是：更长的密码以及带有unicode字符的密码，确实增加了密码的熵并使其更难以破解。</target>
        </trans-unit>
        <trans-unit id="6f90138bce65ffdcace9e2bb19f7963c1bd536d2" translate="yes" xml:space="preserve">
          <source>Passwords should always be salted before hashed. Salting adds a random string to the password so similar passwords don't appear the same in the DB. However if the salt is not unique to each user (ie: you use a hard coded salt) than you pretty much have made your salt worthless. Because once an attacker figures out one password salt he has the salt for all of them.</source>
          <target state="translated">在进行散列前,密码应该先进行加盐处理。加盐会在密码中添加一个随机的字符串,这样类似的密码就不会在数据库中出现相同的密码。但是,如果盐分不是每个用户的唯一性(即:你使用的是硬编码的盐分),那么你的盐分就基本没有价值了。因为一旦攻击者知道了一个密码盐,他就会知道所有的密码盐。</target>
        </trans-unit>
        <trans-unit id="48845b9c00008f76810e059c640d17fa100ba624" translate="yes" xml:space="preserve">
          <source>Providing the &lt;code&gt;PASSWORD_DEFAULT&lt;/code&gt; instructs PHP to use the default hashing algorithm of the installed version of PHP. Exactly which algorithm that means is intended to change over time in future versions, so that it will always be one of the strongest available algorithms.</source>
          <target state="translated">提供 &lt;code&gt;PASSWORD_DEFAULT&lt;/code&gt; 可以指示PHP使用已安装版本的PHP的默认哈希算法。 确切地说，哪种算法打算在将来的版本中随着时间的推移而改变，因此它将始终是最强大的可用算法之一。</target>
        </trans-unit>
        <trans-unit id="dd1d5612b63f3e6527355deb1eb2e9ab4b7c8d4c" translate="yes" xml:space="preserve">
          <source>Recently I had a discussion whether password hashes salted with random
  bits are more secure than the one salted with guessable or known
  salts. Let&amp;rsquo;s see: If the system storing password is compromised as
  well as the system which stores the random salt, the attacker will
  have access to hash as well as salt, so whether the salt is random or
  not, doesn&amp;rsquo;t matter. The attacker will can generate pre-computed
  rainbow tables to crack the hash. Here comes the interesting part- it
  is not so trivial to generate pre-computed tables. Let us take example
  of WPA security model. Your WPA password is actually never sent to
  Wireless Access Point. Instead, it is hashed with your SSID (the
  network name- like Linksys, Dlink etc). A very good explanation of how
  this works is here. In order to retrieve password from hash, you will
  need to know the password as well as salt (network name). Church of
  Wifi has already pre-computed hash tables which has top 1000 SSIDs and
  about 1 million passwords. The size is of all tables is about 40 GB.
  As you can read on their site, someone used 15 FGPA arrays for 3 days
  to generate  these tables. Assuming victim is using the SSID as
  &amp;ldquo;a387csf3&amp;Prime; and password as &amp;ldquo;123456&amp;Prime;, will it be cracked by those
  tables? No! .. it cannot. Even if the password is weak, the tables
  don&amp;rsquo;t have hashes for SSID a387csf3.  This is the beauty of having
  random salt. It will deter crackers who thrive upon pre-computed
  tables. Can it stop a determined hacker? Probably not. But using
  random salts does provide additional layer of defense. While we are on
  this topic, let us discuss additional advantage of storing random
  salts on a separate system. Scenario #1 : Password hashes are stored
  on system X and salt values used for hashing are stored on system Y.
  These salt values are guessable or known (e.g. username) Scenario#2 :
  Password hashes are stored on system X and salt values used for
  hashing are stored on system Y. These salt values are random. In case
  system X has been compromised, as you can guess, there is a huge
  advantage of using random salt on a separate system (Scenario #2) .
  The attacker will need to guess addition values to be able to crack
  hashes. If a 32 bit salt is used, 2^32= 4,294,967,296 (about 4.2
  billion) iterations will can be required for each password guessed.</source>
          <target state="translated">最近，我讨论了用随机位加盐的密码散列是否比用可猜测或已知盐加盐的密码散列更安全。 让我们看看：如果存储密码的系统以及存储随机盐的系统遭到破坏，则攻击者将可以访问哈希和盐，因此盐是否是随机的都没有关系。 攻击者可以生成预先计算的彩虹表来破解哈希。 有趣的部分来了-生成预计算表并不是那么简单。 让我们以WPA安全模型为例。 实际上，您的WPA密码永远不会发送到Wireless Access Point。 而是使用您的SSID（网络名称，如Linksys，Dlink等）对它进行哈希处理。 这是一个很好的解释。 为了从哈希中检索密码，您将需要知道密码以及盐（网络名称）。 Wifi教堂已经预先计算了哈希表，该哈希表具有前1000个SSID和大约一百万个密码。 所有表的大小约为40 GB。 在您的网站上可以看到，有人使用15个FGPA阵列3天来生成这些表。 假设受害者使用的SSID为&amp;ldquo; a387csf3&amp;rdquo;，密码为&amp;ldquo; 123456&amp;rdquo;，那么这些表会破解它吗？ 没有！ .. 这不可以。 即使密码很弱，表也没有SSID a387csf3的哈希值。 这是无盐的美丽。 它将阻止在预计算表上蓬勃发展的饼干用户。 它可以阻止坚定的黑客吗？ 可能不是。 但是使用随机盐确实可以提供额外的防御层。 当我们处于这个主题上时，让我们讨论将随机盐存储在单独系统上的其他优点。 方案1：密码哈希存储在系统X上，用于哈希的盐值存储在系统Y。这些盐值是可猜测的或已知的（例如，用户名）方案2：密码哈希存储在系统X上，并且盐值用于哈希存储在系统Y中。这些盐值是随机的。 如您所料，如果系统X遭到破坏，则在单独的系统上使用随机盐具有巨大的优势（方案2）。 攻击者将需要猜测附加值才能破解哈希。 如果使用32位盐，则每个猜测的密码将需要2 ^ 32 = 4,294,967,296（约42亿）次迭代。</target>
        </trans-unit>
        <trans-unit id="29cf51326e60ca7639ae8d61993a3e6af0924dbd" translate="yes" xml:space="preserve">
          <source>Reset everyone's passwords when the database is compromised.</source>
          <target state="translated">当数据库遭到破坏时,重置每个人的密码。</target>
        </trans-unit>
        <trans-unit id="99aba45ee7f729f62087c2a073d856536cd76908" translate="yes" xml:space="preserve">
          <source>SHA1 is now also considered somewhat compromised, but to a far lesser degree than MD5.  By using a salt (any salt), you're preventing the use of a generic &lt;a href=&quot;http://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;rainbow table&lt;/a&gt; to attack your hashes (some people have even had success using Google as a sort of rainbow table by searching for the hash).  An attacker could conceivably generate a rainbow table using your salt, so that's why you should include a user-specific salt.  That way, they will have to generate a rainbow table for each and every record in your system, not just one for your entire system!  With that type of salting, even MD5 is decently secure.</source>
          <target state="translated">现在也认为SHA1受到了一定影响，但程度要比MD5小得多。 通过使用盐（任何盐），您可以防止使用通用的&lt;a href=&quot;http://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;彩虹表&lt;/a&gt;来攻击您的哈希（有些人甚至通过搜索哈希将Google用作一种彩虹表已获得成功）。 可以想象，攻击者可能会使用您的盐生成彩虹表，因此这就是为什么您应该包含用户特定的盐的原因。 这样，他们将不得不为系统中的每个记录生成一个彩虹表，而不仅仅是整个系统的一个！ 使用这种类型的盐腌，即使MD5也相当安全。</target>
        </trans-unit>
        <trans-unit id="4eda4093b78a303b74d4192d587dca2314fa4169" translate="yes" xml:space="preserve">
          <source>Secure hash and salt for PHP passwords</source>
          <target state="translated">PHP密码的安全散列和盐</target>
        </trans-unit>
        <trans-unit id="f11fa153ab1a9133bcbd4157363d3c3c13723b94" translate="yes" xml:space="preserve">
          <source>Secure methods of storing keys, passwords for asp.net</source>
          <target state="translated">asp.net的密钥和密码的安全存储方法</target>
        </trans-unit>
        <trans-unit id="ff41ccecb888661f5547c2d4b885e0c114d66f5f" translate="yes" xml:space="preserve">
          <source>Simple Password Encryption</source>
          <target state="translated">简单的密码加密</target>
        </trans-unit>
        <trans-unit id="02d7e2181d283624db40fc6185be390dccef0f3e" translate="yes" xml:space="preserve">
          <source>Since then, PHP has given us &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;&lt;code&gt;password_hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;&lt;code&gt;password_verify&lt;/code&gt;&lt;/a&gt; and, since their introduction, they are the recommended password hashing &amp;amp; checking method.</source>
          <target state="translated">从那时起，PHP就给了我们&lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt; &lt;code&gt;password_hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt; &lt;code&gt;password_verify&lt;/code&gt; ,&lt;/a&gt;并且自从引入以来，它们就是推荐的密码哈希和检查方法。</target>
        </trans-unit>
        <trans-unit id="6dd6c021f508c0340ebfdf5945ac1810408566d3" translate="yes" xml:space="preserve">
          <source>So far as I've been able to tell, making the world's best password is a Catch-22. Either its not memorable, too predictable, too short, too many unicode characters (hard to type on a Windows/Mobile device), too long, etc. No password is truly good enough for our purposes, so we must protect them as though they were in Fort Knox.</source>
          <target state="translated">到目前为止,就我所知,制作世界上最好的密码是一个Catch-22。要么是它不容易记住,太可预测,太短,太多unicode字符(在WindowsMobile设备上很难输入),太长等等。没有一个密码是真正适合我们的目的,所以我们必须像在诺克斯堡一样保护它们。</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="abc469ca9e1e32aad49a7fa70322810e433fbc73" translate="yes" xml:space="preserve">
          <source>The API exposes four functions:</source>
          <target state="translated">该 API 暴露了四个函数。</target>
        </trans-unit>
        <trans-unit id="d1e5cbc852e92edf4f983cd9843ad840d31e7b05" translate="yes" xml:space="preserve">
          <source>The computational power required to actually &lt;em&gt;crack&lt;/em&gt; a hashed password doesn't exist. The only way for computers to &quot;crack&quot; a password is to recreate it and simulate the hashing algorithm used to secure it. The speed of the hash is linearly related to its ability to be brute-forced. Worse still, most hash algorithms can be easily parallelized to perform even faster. This is why costly schemes like bcrypt and scrypt are so important.</source>
          <target state="translated">实际&lt;em&gt;破解&lt;/em&gt;散列密码所需的计算能力不存在。 计算机&amp;ldquo;破解&amp;rdquo;密码的唯一方法是重新创建密码并模拟用于保护密码的哈希算法。 哈希的速度与其被强行使用的能力成线性关系。 更糟糕的是，大多数哈希算法可以很容易地并行化以更快地执行。 这就是为什么像bcrypt和scrypt这样的昂贵方案如此重要的原因。</target>
        </trans-unit>
        <trans-unit id="cc82bec66b732bb33be65e32feee97dde8331a13" translate="yes" xml:space="preserve">
          <source>The hashing mechanism must be available in PHP</source>
          <target state="translated">散列机制在PHP中必须是可用的</target>
        </trans-unit>
        <trans-unit id="c967b55b3de7e43262a5ec3a53dd313fc5714961" translate="yes" xml:space="preserve">
          <source>The idea of a salt is to throw the hashing results off balance, so to say. It is known, for example, that the MD5-hash of an empty string is &lt;code&gt;d41d8cd98f00b204e9800998ecf8427e&lt;/code&gt;. So, if someone with good enough a memory would see that hash and know that it's the hash of an empty string. But if the string is salted (say, with the string &quot;&lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt;&quot;), the hash for the 'empty string' (i.e. &quot;&lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt;&quot;) becomes &lt;code&gt;aeac2612626724592271634fb14d3ea6&lt;/code&gt;, hence non-obvious to backtrace. What I'm trying to say, that it's better to use &lt;em&gt;any&lt;/em&gt; salt, than not to. Therefore, it's not too much of an importance to know &lt;em&gt;which&lt;/em&gt; salt to use.</source>
          <target state="translated">可以这么说，加盐的想法是使散列结果失去平衡。 例如，已知空字符串的 &lt;code&gt;d41d8cd98f00b204e9800998ecf8427e&lt;/code&gt; 哈希为d41d8cd98f00b204e9800998ecf8427e 。 因此，如果一个内存足够好的人会看到该哈希，并且知道它是一个空字符串的哈希。 但是，如果字符串是盐腌的（例如，使用字符串&amp;ldquo; &lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt; &amp;rdquo;），则&amp;ldquo;空字符串&amp;rdquo;（即&amp;ldquo; &lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt; &amp;rdquo;）的哈希将变为 &lt;code&gt;aeac2612626724592271634fb14d3ea6&lt;/code&gt; ，因此对于回溯而言并不明显。 我要说的是，使用&lt;em&gt;任何&lt;/em&gt;盐比不使用盐更好。 因此，知道使用&lt;em&gt;哪种&lt;/em&gt;盐并不是太重要。</target>
        </trans-unit>
        <trans-unit id="3e93c44acff31ed1b16a3be79f5aaf860521be39" translate="yes" xml:space="preserve">
          <source>The objective behind hashing passwords is simple: preventing malicious access to user accounts by compromising the database. So the goal of password hashing is to deter a hacker or cracker by costing them too much time or money to calculate the plain-text passwords. And time/cost are the best deterrents in your arsenal.</source>
          <target state="translated">散列密码背后的目的很简单,就是防止用户账户被恶意入侵数据库。所以,密码散列的目的是为了震慑黑客或破解者,让他们花费太多时间或金钱来计算明文密码,从而达到威慑的目的。而时间成本是你的武器库中最好的威慑手段。</target>
        </trans-unit>
        <trans-unit id="ca15458b1f6023e826d9e6c9d269e5b8847c24ab" translate="yes" xml:space="preserve">
          <source>The returned hash could be stored in database as it is. Sample use for generating hash is:</source>
          <target state="translated">返回的哈希值可以被存储在数据库中。生成散列的示例用途是:</target>
        </trans-unit>
        <trans-unit id="9336b71741fbd4b0fc7ebef42b5f931ca05fe080" translate="yes" xml:space="preserve">
          <source>The theory of the answer is still a good read though.</source>
          <target state="translated">理论上的答案虽然还是很好读的。</target>
        </trans-unit>
        <trans-unit id="72fe41d63bb494eee2544c08c337e299e480e6db" translate="yes" xml:space="preserve">
          <source>Then have a separate user account for you that is not stored anywhere on the server, not even in the application.</source>
          <target state="translated">然后为你拥有一个独立的用户账户,这个账户不存储在服务器上的任何地方,甚至不在应用程序中。</target>
        </trans-unit>
        <trans-unit id="a80224d4f8511d86bc794896685456f1282e0a56" translate="yes" xml:space="preserve">
          <source>There are a lot of good hashing functions out there (&lt;code&gt;password_hash&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, etc...) but you need to select a good algorithm for the hash to be effective. (bcrypt and ones similar to it are decent algorithms.)</source>
          <target state="translated">那里有很多好的哈希函数（ &lt;code&gt;password_hash&lt;/code&gt; ， &lt;code&gt;hash&lt;/code&gt; 等），但是您需要选择一个好的哈希算法才能使哈希有效。 （bcrypt及其类似的算法是不错的算法。）</target>
        </trans-unit>
        <trans-unit id="83d2f507ea07e3720cda34bd2cd662536b85bf9a" translate="yes" xml:space="preserve">
          <source>There are actually &lt;a href=&quot;http://gdataonline.com/seekhash.php&quot;&gt;websites that do just this&lt;/a&gt; - you can feed it a (md5) hash, and it spits out a known plaintext that generates that particular hash. If you would get access to a database that stores plain md5-hashes, it would be trivial for you to enter the hash for the admin to such a service, and log in. But, if the passwords were salted, such a service would become ineffective.</source>
          <target state="translated">实际上&lt;a href=&quot;http://gdataonline.com/seekhash.php&quot;&gt;，&lt;/a&gt;有一些网站可以做到这一点 -您可以向其提供（md5）哈希，它会吐出一个生成该哈希的已知明文。 如果您可以访问存储纯md5-哈希的数据库，那么对于管理员来说，输入此类服务的哈希值并登录就不那么容易了。但是，如果密码过盐，则该服务将变成无效的。</target>
        </trans-unit>
        <trans-unit id="94dc7fd1014b141fac002eb97bbbe1edb127d32d" translate="yes" xml:space="preserve">
          <source>There are also many rainbow table attacks on Windows passwords that run on ordinary CPUs and are very fast.  All this is because Windows &lt;em&gt;still&lt;/em&gt;&lt;a href=&quot;https://superuser.com/a/118279/90231&quot;&gt;doesn't salt or stretch&lt;/a&gt; its passwords, &lt;a href=&quot;https://www.guidingtech.com/61991/cracking-windows-10-password-prevent/&quot;&gt;even in Windows 10&lt;/a&gt; - don't make the same mistake as Microsoft did!</source>
          <target state="translated">在普通CPU上运行的Windows密码也有很多彩虹表攻击，而且攻击速度非常快。 这是因为&lt;a href=&quot;https://www.guidingtech.com/61991/cracking-windows-10-password-prevent/&quot;&gt;即使在Windows 10中&lt;/a&gt; ，Windows &lt;em&gt;仍然&lt;/em&gt; &lt;a href=&quot;https://superuser.com/a/118279/90231&quot;&gt;不会加盐或扩展&lt;/a&gt;其密码-不要犯与Microsoft相同的错误！</target>
        </trans-unit>
        <trans-unit id="7d78de6e30f57b4b7d0c6241b43daf6efe33858b" translate="yes" xml:space="preserve">
          <source>There's a longer discussion of password entropy on the &lt;a href=&quot;https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password&quot;&gt;Crypto StackExchange&lt;/a&gt; site. A good Google search will also turn up a lot of results.</source>
          <target state="translated">在&lt;a href=&quot;https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password&quot;&gt;Crypto StackExchange&lt;/a&gt;站点上，关于密码熵的讨论已经很长时间了。 良好的Google搜索也会带来很多结果。</target>
        </trans-unit>
        <trans-unit id="eb3552eb4e3ab442dc5e9548665b050d60219300" translate="yes" xml:space="preserve">
          <source>This question, &lt;a href=&quot;https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once&quot;&gt;Is &amp;ldquo;double hashing&amp;rdquo; a password less secure than just hashing it once?&lt;/a&gt; 
suggests that hashing multiple times may be a good idea, whereas &lt;a href=&quot;https://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904&quot;&gt;How to implement password protection for individual files?&lt;/a&gt; suggests using salt.</source>
          <target state="translated">这个问题， &lt;a href=&quot;https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once&quot;&gt;&amp;ldquo;双哈希&amp;rdquo;密码是否比仅哈希一次密码安全？&lt;/a&gt; 建议多次散列可能是一个好主意，而&lt;a href=&quot;https://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904&quot;&gt;如何对单个文件实施密码保护？&lt;/a&gt; 建议使用盐。</target>
        </trans-unit>
        <trans-unit id="957441673ad43072032f00a3b5118222b26b20f1" translate="yes" xml:space="preserve">
          <source>Though the question has been answered, I just want to reiterate that salts used for hashing should be random and not like email address as suggested in first answer.</source>
          <target state="translated">虽然这个问题已经回答了,但我只想重申一下,用于散列的盐分应该是随机的,而不是像第一个答案中建议的电子邮件地址那样。</target>
        </trans-unit>
        <trans-unit id="0cf0236983335ce525d178c161a3dac43b40ad44" translate="yes" xml:space="preserve">
          <source>To verify password, one can use:</source>
          <target state="translated">要验证密码,可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="ae24b36e98b286448b8f32e9eb9c4f5faa046188" translate="yes" xml:space="preserve">
          <source>Try an implementation of &lt;a href=&quot;http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard&quot;&gt;PDKBF2&lt;/a&gt; with the &lt;a href=&quot;https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256&quot;&gt;maximum number of rounds&lt;/a&gt; that your environment/application/user-perception can tolerate. The lowest number I'd recommend is 2500 rounds. Also, make sure to use &lt;a href=&quot;http://php.net/hash_hmac&quot;&gt;hash_hmac()&lt;/a&gt; if it is available to make the operation harder to reproduce.</source>
          <target state="translated">尝试以您的环境/应用程序/用户感知可以容忍的&lt;a href=&quot;https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256&quot;&gt;最大回合数来&lt;/a&gt;实现&lt;a href=&quot;http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard&quot;&gt;PDKBF2&lt;/a&gt; 。 我建议的最低数量是2500发。 另外，请确保使用&lt;a href=&quot;http://php.net/hash_hmac&quot;&gt;hash_hmac（）（&lt;/a&gt;如果可用）以使操作难以重现。</target>
        </trans-unit>
        <trans-unit id="068a6272a632b944b53a381b4d5400b18d5eafc9" translate="yes" xml:space="preserve">
          <source>Use PBKDF2 if you cannot use either bcrypt or scrypt, with SHA2 hashes.</source>
          <target state="translated">如果你不能使用bcrypt或scrypt,使用PBKDF2,使用SHA2散列的方式。</target>
        </trans-unit>
        <trans-unit id="3438f0875ced99f75e760bc602d283a350f5c224" translate="yes" xml:space="preserve">
          <source>Use scrypt when you can; bcrypt if you cannot.</source>
          <target state="translated">能用scrypt的时候就用scrypt,不能用的时候就用bcrypt。</target>
        </trans-unit>
        <trans-unit id="8a40715ff9e4ad938469f5e938fbc3461e5c29de" translate="yes" xml:space="preserve">
          <source>What makes a &lt;em&gt;good&lt;/em&gt; password anyway?</source>
          <target state="translated">无论如何，什么才是&lt;em&gt;好的&lt;/em&gt;密码？</target>
        </trans-unit>
        <trans-unit id="d324dbbd000686026c12d8aac03bc6761752e7ae" translate="yes" xml:space="preserve">
          <source>What's the difference between SHA and MD5 in PHP</source>
          <target state="translated">PHP中的SHA和MD5有什么区别?</target>
        </trans-unit>
        <trans-unit id="3273a0f907bb9b658a5b510bdc764fef8f6fd55f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;password_hash()&lt;/code&gt; is used, it generates a random salt and includes it in the outputted hash (along with the the cost and algorithm used.) &lt;code&gt;password_verify()&lt;/code&gt; then reads that hash and determines the salt and encryption method used, and verifies it against the provided plaintext password.</source>
          <target state="translated">使用 &lt;code&gt;password_hash()&lt;/code&gt; 时 ，它将生成一个随机盐，并将其包含在输出的哈希中（连同使用的成本和算法。） &lt;code&gt;password_verify()&lt;/code&gt; 然后读取该哈希，并确定所使用的盐和加密方法，并针对它进行验证提供的纯文本密码。</target>
        </trans-unit>
        <trans-unit id="cdf0e49369640a78f1b0481bc29357ba77ff4067" translate="yes" xml:space="preserve">
          <source>When hashing speed is the key, the slower the more resistant to Brute Force attacks.</source>
          <target state="translated">当哈希速度是关键,越慢越能抵抗蛮力攻击。</target>
        </trans-unit>
        <trans-unit id="0ea7792c8765a8cc7d08846130a9f07954560526" translate="yes" xml:space="preserve">
          <source>When you create a salt make sure it is unique to the password it is salting, then store both the completed hash and salt in your DB. What this will do is make it so that an attacker will have to individually crack each salt and hash before they can gain access. This means a lot more work and time for the attacker.</source>
          <target state="translated">当你创建一个盐时,确保它是唯一的盐,然后将完成的散列和盐都存储在你的数据库中。这样做会使攻击者必须单独破解每个盐和散列,然后才能获得访问权限。这意味着攻击者需要花费更多的工作和时间。</target>
        </trans-unit>
        <trans-unit id="4bcfb1507fa18c5813bf98587194789dfd7fc9fa" translate="yes" xml:space="preserve">
          <source>Why hash passwords anyway?</source>
          <target state="translated">为什么要用散列密码呢?</target>
        </trans-unit>
        <trans-unit id="d9c509de30c734b1fbd267c99263e20b0ac2f8d4" translate="yes" xml:space="preserve">
          <source>You cannot possibly foresee all threats or avenues of attack, and so you must make your best effort to protect your users &lt;strong&gt;up front&lt;/strong&gt;. If you do not, then you might even miss the fact that you were attacked until it's too late... &lt;em&gt;and you're liable&lt;/em&gt;. To avoid that situation, act paranoid to begin with. Attack your own software (internally) and attempt to steal user credentials, or modify other user's accounts or access their data. If you don't test the security of your system, then you cannot blame anyone but yourself.</source>
          <target state="translated">您可能无法预见所有威胁或攻击途径，因此必须尽最大努力来保护用户。 如果您不这样做，那么您甚至可能会错过被攻击的事实，直到为时已晚... &lt;em&gt;您&lt;/em&gt;才有&lt;em&gt;责任&lt;/em&gt; 。 为了避免这种情况，首先要采取偏执的态度。 （内部）攻击您自己的软件，并尝试窃取用户凭据，或修改其他用户的帐户或访问其数据。 如果您不测试系统的安全性，那么您就不能怪任何人。</target>
        </trans-unit>
        <trans-unit id="6ecc62ca116f09be2ac8ccbf2dd2a17934a3f97a" translate="yes" xml:space="preserve">
          <source>You should definitely use a salt. I'd recommend using random bytes (and not restrict yourself to characters and numbers). As usually, the longer you choose, the safer, slower it gets. 64 bytes ought to be fine, i guess.</source>
          <target state="translated">你一定要用盐。我建议用随机字节(不要限制在字符和数字上)。因为通常情况下,你选择的时间越长,越安全,速度越慢。我想64字节应该没问题吧。</target>
        </trans-unit>
        <trans-unit id="250c2ad56e4e9ddde57caded620862fba3c804d9" translate="yes" xml:space="preserve">
          <source>You tell your users to make good passwords to avoid getting hacked, do the same. What is the point in going through all the effort of locking your front door when you have the backdoor wide open.</source>
          <target state="translated">你告诉你的用户要做好密码,避免被黑客入侵,同样的道理。当你的后门大开的时候,你又何必费尽心思的把前门锁起来。</target>
        </trans-unit>
        <trans-unit id="65de4781939078acdc51b27007cb200ec4c437c0" translate="yes" xml:space="preserve">
          <source>also we need the hash
I`m using sha512
it is the best and it is in php</source>
          <target state="translated">我们还需要哈希值,我用的是sha512,它是最好的,而且是在php中。</target>
        </trans-unit>
        <trans-unit id="28edb5e4d9749f27a128acb260e84492ffdd3323" translate="yes" xml:space="preserve">
          <source>and for authorize we will use same steps...</source>
          <target state="translated">而对于授权,我们将使用同样的步骤......</target>
        </trans-unit>
        <trans-unit id="44c7073fa2fab130499078fde7b90431453ca675" translate="yes" xml:space="preserve">
          <source>it is the best way to safe our clients passwords...</source>
          <target state="translated">这是保护客户密码安全的最好方法......</target>
        </trans-unit>
        <trans-unit id="66f5061855cb204f427143765390a0e15cb4bb02" translate="yes" xml:space="preserve">
          <source>now we need to save in database our $hash_psw variable value and $salt variable</source>
          <target state="translated">现在我们需要将$hash_psw变量的值和$salt变量保存到数据库中。</target>
        </trans-unit>
        <trans-unit id="65b1ca7c9f59ee04049ba7f7cac979ffa197ee6a" translate="yes" xml:space="preserve">
          <source>ok
in the fitsy we need salt
salt must be unique
so let generate it</source>
          <target state="translated">好吧,在配合的时候,我们需要盐,盐必须是唯一的,所以让我们产生它</target>
        </trans-unit>
        <trans-unit id="83813ad92f95972794914dc4459ac7d1fb05a12a" translate="yes" xml:space="preserve">
          <source>so now we can use this functions to generate safe password</source>
          <target state="translated">所以现在我们可以用这个函数来生成安全密码了</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
