<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/401656">
    <body>
      <group id="401656">
        <trans-unit id="4bd6398b6ec50d16e0ba8b718869fa0726943b47" translate="yes" xml:space="preserve">
          <source>(Emphasis mine.)</source>
          <target state="translated">(Акцент мой.)</target>
        </trans-unit>
        <trans-unit id="d54e60153602d914878e89e59608b8d75275ed9e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/sha1&quot;&gt;SHA1&lt;/a&gt; and a salt should suffice (depending, naturally, on whether you are coding something for &lt;a href=&quot;http://en.wikipedia.org/wiki/United_States_Bullion_Depository&quot;&gt;Fort Knox&lt;/a&gt; or a login system for your shopping list) for the foreseeable future. If SHA1 isn't good enough for you, use &lt;a href=&quot;http://php.net/manual/en/function.hash.php&quot;&gt;SHA256&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/sha1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SHA1&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и соли должно хватить (в зависимости, естественно, от того, кодируете ли вы что-нибудь для &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/United_States_Bullion_Depository&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Fort Knox&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или систему входа в список покупок) в обозримом будущем. Если SHA1 недостаточно хорош для вас, используйте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://php.net/manual/en/function.hash.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SHA256&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a49d7ecc7c611924a2bdc550b87beda1e36e7adf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xkcd.com/936/&quot;&gt;Entropy&lt;/a&gt;. (Not that I fully subscribe to Randall's viewpoint.)</source>
          <target state="translated">&lt;a href=&quot;http://xkcd.com/936/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Энтропия&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Не то чтобы я полностью разделяю точку зрения Рэндалла.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="331904e34fbc8be8527a2f2cc0ab551951a291a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919&quot;&gt;excellent answer&lt;/a&gt; with more about why &lt;code&gt;password_hash()&lt;/code&gt; or &lt;code&gt;phpass&lt;/code&gt; are the best way to go.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;отличный ответ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с более подробной информацией о том, почему &lt;/font&gt;&lt;/font&gt; &lt;code&gt;password_hash()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;phpass&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - лучший путь.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f6f914dd88be09eb21067092dec3c341a6e91895" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/&quot;&gt;good blog article&lt;/a&gt; giving recommmended 'work factors' (number of iterations) for main algorithms including bcrypt, scrypt and PBKDF2.</source>
          <target state="translated">&lt;a href=&quot;https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;хорошая статья в блоге,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; содержащая рекомендуемые &amp;laquo;рабочие факторы&amp;raquo; (количество итераций) для основных алгоритмов, включая bcrypt, scrypt и PBKDF2.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="55f55510afeb77726e0d50b49639b6d98210693b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_get_info()&lt;/code&gt; - returns information about the given hash</source>
          <target state="translated">&lt;code&gt;password_get_info()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - возвращает информацию о данном хеше&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="511d82aef08cd670da59b1470aced89fce228ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_hash()&lt;/code&gt; - creates a password hash</source>
          <target state="translated">&lt;code&gt;password_hash()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - создает хеш пароля&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e53608eb6b90132ef76064ce05e5793fc484cd3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_needs_rehash()&lt;/code&gt; - checks if the given hash matches the given options. Useful to check if the hash conforms to your current technique/cost scheme allowing you to rehash if necessary</source>
          <target state="translated">&lt;code&gt;password_needs_rehash()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - проверяет, соответствует ли данный хеш заданным параметрам. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Полезно, чтобы проверить, соответствует ли хеш вашей текущей схеме техники / стоимости, позволяя вам при необходимости перефразировать&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab3126d5de685d9c71a7a339b3efcf5bed455a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_verify()&lt;/code&gt; - verifies that a password matches a hash</source>
          <target state="translated">&lt;code&gt;password_verify()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - проверяет, что пароль соответствует хешу&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b4b45af4d94ab99b5074596633ad5d1dd429fc9d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HASHING&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HASHING&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae35617fc2a3e929f057c2ac76f291842cfc1b34" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PASSWORD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PASSWORD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cc85735d6d4bc3f8eb14617d7b3510366c3c30c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PORTS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PORTS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f14c91feaf4967ef247273e68b9a406a2c8c581" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Related questions that don't quite cover my question:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Связанные вопросы, которые не совсем охватывают мой вопрос:&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed1c080c450a82285e50d7a816ddc03a0863f19a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SALTING&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SALTING&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5977b0e7ee94c66e337dded2dd5bbe8a4ad8b2cb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SERVER&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SERVER&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="23118db0e558706fb2facd763d94ae2dcff3c884" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USER&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;USER&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="603ff9cd887ac389320761a219db9bf3b57244d7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USERNAME&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;USERNAME&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f77d76027e0db3dd25ad0ea328da229ae899dcd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USERS CREATING PASSWORDS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ПОЛЬЗОВАТЕЛИ, СОЗДАЮЩИЕ ПАРОЛИ&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="896fefe79b5f0b7a660920e0a621a010a9b8870b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DATABASE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DATABASE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d67cf51a25a2a4dbc01f9a24286e1ab97db82f1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DISCLAIMER&lt;/strong&gt;: This answer was written in 2008.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ОТКАЗ ОТ ОТВЕТСТВЕННОСТИ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : Этот ответ был написан в 2008 году.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c0ea0dc97baa1d4c675361104fa844e8cea6bf02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PHP&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ff333e7b1ff670b7f3dc5b40367c60de2baedb6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Quick self-test:&lt;/strong&gt; what is password stretching and how many iterations should you use?  If you don't know the answer, you should use &lt;code&gt;password_hash()&lt;/code&gt;, as password stretching is now a critical feature of password mechanisms due to much faster CPUs and the use of &lt;a href=&quot;http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/&quot;&gt;GPUs and FPGAs&lt;/a&gt; to crack passwords at rates of &lt;a href=&quot;http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches&quot;&gt;billions of guesses per second&lt;/a&gt; (with GPUs).</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Быстрая самопроверка:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; что такое растяжение пароля и сколько итераций следует использовать? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы не знаете ответа, вам следует использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;password_hash()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , поскольку расширение пароля теперь является критически важной функцией механизмов паролей из-за гораздо более быстрых процессоров и использования &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;графических процессоров и FPGA&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для взлома паролей со скоростью &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;миллиардов угаданий в секунду.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (с графическими процессорами).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aed0191173d72ecf54d46939a34acf7570a79ca0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SERVER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SERVER&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="551e0b7660ec60a1ba024654ebf85dd6e11ea8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Смотрите также:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ead3f7341c29026742f5a4b0dd3a0003a1ebcb6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THINGS TO REMEMBER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ТО, ЧТО НУЖНО ЗАПОМНИТЬ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e902296e6d584c43a7b6d565ce2461560a6e091" translate="yes" xml:space="preserve">
          <source>A lot has been said about Password encryption for PHP, most of which is very good advice, but before you even start the process of using PHP for password encryption make sure you have the following implemented or ready to be implemented.</source>
          <target state="translated">Много было сказано о шифровании паролей для PHP,большинство из которых является очень хорошим советом,но еще до того,как вы начнете процесс использования PHP для шифрования паролей,убедитесь,что у вас есть следующие возможности или они готовы к использованию.</target>
        </trans-unit>
        <trans-unit id="d338f3026e67ebbe13c96fce36d81cb026d9f87c" translate="yes" xml:space="preserve">
          <source>A much shorter and safer answer - &lt;strong&gt;don't write your own password mechanism at all&lt;/strong&gt;, use a tried and tested mechanism.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Гораздо более короткий и безопасный ответ - &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не пишите свой собственный механизм паролей вообще&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , используйте проверенный и проверенный механизм.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4dd080286c78745102f80f80549cafcb94e6e124" translate="yes" xml:space="preserve">
          <source>Also make the user create a secure password, it is simple and should always be done, the user will be grateful for it in the end.</source>
          <target state="translated">Также заставьте пользователя создать безопасный пароль,это просто и должно быть сделано всегда,в конце концов пользователь будет благодарен за это.</target>
        </trans-unit>
        <trans-unit id="9a29f79b84bf18b505a34d003c5ea678dd34f78a" translate="yes" xml:space="preserve">
          <source>Also, double-hashing is generally regarded as bad method, because it diminishes the result space. All popular hashes are fixed-length. Thus, you can have only a finite values of this fixed length, and the results become less varied. This &lt;em&gt;could&lt;/em&gt; be regarded as another form of salting, but I wouldn't recommend it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, двойное хеширование обычно считается плохим методом, потому что оно уменьшает пространство результата. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Все популярные хэши имеют фиксированную длину. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, вы можете иметь только конечные значения этой фиксированной длины, и результаты станут менее разнообразными. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;можно&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; рассматривать как еще одну форму посола, но я бы не рекомендовал это.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="47b974489931634025c710e17d5db41c06e42742" translate="yes" xml:space="preserve">
          <source>Also, should I store two fields in the database (one using MD5 and another one using SHA, for example)? Would it make it safer or unsafer?</source>
          <target state="translated">Также следует ли хранить два поля в базе данных (одно с использованием MD5,а другое с использованием SHA,например)? Будет ли это безопаснее или небезопаснее?</target>
        </trans-unit>
        <trans-unit id="7689b604462baa981c885266a977b157013806aa" translate="yes" xml:space="preserve">
          <source>Always have your application have its own account to access the DB, and only give it the privileges it will need.</source>
          <target state="translated">У вашего приложения всегда есть своя учетная запись для доступа к БД,и оно должно обладать только теми привилегиями,которые ему потребуются.</target>
        </trans-unit>
        <trans-unit id="3b1bb0601fe6d9e262b3597a1689b03d4b982615" translate="yes" xml:space="preserve">
          <source>Another reason that you want a good, robust hash on a user accounts is to give you enough time to change all the passwords in the system. If your database is compromised you will need enough time to at &lt;em&gt;least&lt;/em&gt; lock the system down, if not change every password in the database.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Еще одна причина, по которой вам нужен хороший и надежный хэш для учетных записей пользователей, - это предоставление вам достаточно времени для изменения всех паролей в системе. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если ваша база данных взломана, вам понадобится достаточно времени, чтобы хотя &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;бы&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; заблокировать систему, если не поменять каждый пароль в базе данных.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fc8b9b7b7e69aecc8d6210a0592328219dceab04" translate="yes" xml:space="preserve">
          <source>As of PHP 5.5, PHP has simple, secure functions for hashing and verifying passwords, &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash()&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;password_verify()&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Начиная с PHP 5.5, PHP имеет простые, безопасные функции для хеширования и проверки паролей, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;password_hash ()&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;password_verify ()&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ea99ddf0910092b785f4db900f1d1881fb27c6a" translate="yes" xml:space="preserve">
          <source>At the moment these functions accept the PASSWORD_BCRYPT and PASSWORD_DEFAULT password constants, which are synonymous at the moment, the difference being that PASSWORD_DEFAULT &quot;may change in newer PHP releases when newer, stronger hashing algorithms are supported.&quot; Using PASSWORD_DEFAULT and password_needs_rehash() on login (and rehashing if necessary) should ensure that your hashes are reasonably resilient to brute-force attacks with little to no work for you.</source>
          <target state="translated">На данный момент эти функции принимают константы паролей PASSWORD_BCRYPT и PASSWORD_DEFAULT,которые на данный момент являются синонимами,с той лишь разницей,что PASSWORD_DEFAULT &quot;может меняться в новых релизах PHP,когда поддерживаются более новые,более сильные алгоритмы хэширования&quot;.Использование PASSWORD_DEFAULT и password_needs_rehash()при входе в систему (и,при необходимости,перепрошивание)должно гарантировать,что ваши хэши достаточно устойчивы к атакам перебором и малоэффективны.</target>
        </trans-unit>
        <trans-unit id="8bc33659ae93746ba57bab9705cc4dea91e1472b" translate="yes" xml:space="preserve">
          <source>Average practices</source>
          <target state="translated">Средние практики</target>
        </trans-unit>
        <trans-unit id="f6015c3a8cc452ac75b47eabd9579dadfdb0ffe6" translate="yes" xml:space="preserve">
          <source>Bcrypt and &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;scrypt&lt;/a&gt; are the current best practices. &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;Scrypt&lt;/a&gt; will be better than bcrypt in time, but it hasn't seen adoption as a standard by Linux/Unix or by webservers, and hasn't had in-depth reviews of its algorithm posted yet. But still, the future of the algorithm does look promising. If you are working with Ruby there is an &lt;a href=&quot;http://rubygems.org/gems/scrypt&quot;&gt;scrypt gem&lt;/a&gt; that will help you out, and Node.js now has its own &lt;a href=&quot;https://npmjs.org/package/scrypt&quot;&gt;scrypt&lt;/a&gt; package. You can use Scrypt in PHP either via the &lt;a href=&quot;https://pecl.php.net/package/scrypt&quot;&gt;Scrypt&lt;/a&gt; extension or the &lt;a href=&quot;https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md&quot;&gt;Libsodium&lt;/a&gt; extension (both are available in PECL).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bcrypt и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;scrypt&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это лучшие практики. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Scrypt&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет лучше, чем bcrypt во времени, но он не видел принятия в качестве стандарта Linux / Unix или веб-серверами и еще не опубликовал подробные обзоры своего алгоритма. Но все же будущее алгоритма выглядит многообещающим. Если вы работаете с Ruby &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, вам поможет &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://rubygems.org/gems/scrypt&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Scrypt Gem&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , и теперь у Node.js есть собственный &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;пакет &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://npmjs.org/package/scrypt&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Scrypt&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Вы можете использовать Scrypt в PHP либо через &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://pecl.php.net/package/scrypt&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Scrypt&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; расширения или &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Libsodium&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; расширения (оба доступны в PECL).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb8de9ce8757ee3c542141ac80ff3b33dc04edff" translate="yes" xml:space="preserve">
          <source>Best practices</source>
          <target state="translated">Передовые методы</target>
        </trans-unit>
        <trans-unit id="2de241bdf77a55e27f8fca0e42659620a7b0aefe" translate="yes" xml:space="preserve">
          <source>But suppose that you cannot use bcrypt or PHPASS at all. What then?</source>
          <target state="translated">Но предположим,что вы вообще не можете использовать bcrypt или PHPASS.Что тогда?</target>
        </trans-unit>
        <trans-unit id="117f2a5735e534774bb47e831d678f2aadc64e41" translate="yes" xml:space="preserve">
          <source>By default it used strongest available encryption that is implemented in Phpass, which is &lt;code&gt;bcrypt&lt;/code&gt; and falls back to other encryptions down to MD5 to provide backward compatibility to frameworks like Wordpress.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По умолчанию он использовал самое надежное из доступных шифрований, которое реализовано в Phpass, который является &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bcrypt&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и использует другие шифрования вплоть до MD5, чтобы обеспечить обратную совместимость с фреймворками, такими как Wordpress.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b633fdfaff7ad5fc7b721447cc8831c42591c4bc" translate="yes" xml:space="preserve">
          <source>Coming in PHP 5.5 is a &lt;a href=&quot;http://php.net/manual/en/ref.password.php&quot;&gt;full password protection library&lt;/a&gt; that abstracts away any pains of working with bcrypt. While most of us are stuck with PHP 5.2 and 5.3 in most common environments, especially shared hosts, @ircmaxell has built a &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility layer&lt;/a&gt; for the coming API that is backward compatible to PHP 5.3.7.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В PHP 5.5 появилась &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://php.net/manual/en/ref.password.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;библиотека&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;полной защитой паролем,&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; которая избавляет от любых трудностей при работе с bcrypt. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хотя большинство из нас придерживаются PHP 5.2 и 5.3 в большинстве распространенных сред, особенно на общих хостах, @ircmaxell создал &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;уровень совместимости&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для предстоящего API, который обратно совместим с PHP 5.3.7.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="af9cf1efb4bd36a869c85c6db68040652b17d4ae" translate="yes" xml:space="preserve">
          <source>Cryptography Recap &amp;amp; Disclaimer</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Криптография Резюме и отказ от ответственности&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2ef42ffab4aacba15da77cf466976e72bd80c6f0" translate="yes" xml:space="preserve">
          <source>Don't limit the length of a password. If your users want a sentence with supercalifragilisticexpialidocious in it, don't prevent them from using it.</source>
          <target state="translated">Не ограничивайте длину пароля.Если ваши пользователи хотят,чтобы в предложении было суперкалифрагилисционистское предложение,не мешайте им его использовать.</target>
        </trans-unit>
        <trans-unit id="b6a9c3be345b95b031149b5d719b84262d749a02" translate="yes" xml:space="preserve">
          <source>Don't limit what characters users can enter for passwords. Only idiots do this.</source>
          <target state="translated">Не ограничивайте,какие символы пользователи могут вводить для паролей.Это делают только идиоты.</target>
        </trans-unit>
        <trans-unit id="57b8188ffa4f6ec3553dfe244191b42014f16984" translate="yes" xml:space="preserve">
          <source>Don't mix &lt;a href=&quot;http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html&quot;&gt;bcrypt and with the &lt;em&gt;raw&lt;/em&gt; output of hash()&lt;/a&gt;, either use hex output or base64_encode it. (This applies to any input that may have a rogue &lt;code&gt;\0&lt;/code&gt; in it, which can seriously weaken security.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Не смешивайте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bcrypt и с &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;необработанным&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; выводом hash ()&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , либо используйте шестнадцатеричный вывод, либо base64_encode. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Это относится к любому входу, который может содержать мошенничество &lt;/font&gt;&lt;/font&gt; &lt;code&gt;\0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что может серьезно ослабить безопасность.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b14bcf13287ceb3241fed3d968a38802da7cb034" translate="yes" xml:space="preserve">
          <source>Don't strip or escape HTML and special characters in the password.</source>
          <target state="translated">Не удаляйте и не удаляйте HTML и специальные символы из пароля.</target>
        </trans-unit>
        <trans-unit id="093743f90c366f3346a4626e0147ea26113350c4" translate="yes" xml:space="preserve">
          <source>Don'ts</source>
          <target state="translated">Don'ts</target>
        </trans-unit>
        <trans-unit id="586c15c6fd8448116ae5a0f2e995d41e36f153b8" translate="yes" xml:space="preserve">
          <source>Dos</source>
          <target state="translated">Dos</target>
        </trans-unit>
        <trans-unit id="951e25161bf6bbd8580e18709c3c792954ee12e4" translate="yes" xml:space="preserve">
          <source>EDIT: I just realised that this is mentioned briefly in Robert K's answer. I'll leave this answer here since I think it provides a bit more information about how it works and the ease of use it provides for those who don't know security.</source>
          <target state="translated">ЭДИТ:Я только что поняла,что об этом кратко упоминается в ответе Роберта К.Я оставлю этот ответ здесь,так как думаю,что он дает немного больше информации о том,как он работает,и о простоте использования,которую он обеспечивает для тех,кто не знает безопасности.</target>
        </trans-unit>
        <trans-unit id="5aed566d3e7f4533ea18f62aa39f7cec10ce35f6" translate="yes" xml:space="preserve">
          <source>Finally, no matter the security measures you take nothing is 100% secure, the more advanced the technology to protect becomes the more advanced the attacks become. But following these steps will make your site more secure and far less desirable for attackers to go after.</source>
          <target state="translated">Наконец,неважно,какие меры безопасности вы не принимаете,они на 100% безопасны,но чем более продвинутая технология защиты,тем более продвинутыми становятся атаки.Но выполнение этих шагов сделает ваш сайт более безопасным и гораздо менее желательным для злоумышленников.</target>
        </trans-unit>
        <trans-unit id="bfdae5a79adfab1e18ea1d0102894a2dccc076bf" translate="yes" xml:space="preserve">
          <source>Follow the same guidelines as with all good passwords. Also don't reuse the same password on any SERVER or DB accounts on the same system.</source>
          <target state="translated">Следуйте тем же рекомендациям,что и для всех хороших паролей.Также не используйте один и тот же пароль на любых учетных записях SERVER или DB в одной и той же системе.</target>
        </trans-unit>
        <trans-unit id="f46f0816adc340442cfbcc816c79aadee7d62c1c" translate="yes" xml:space="preserve">
          <source>For all that is good in the world do not use the username admin, root or something similar. Also if you are on a unix based system DO NOT make the root account login accessible, it should always be sudo only.</source>
          <target state="translated">Для всего хорошего в мире не используйте имя пользователя admin,root или что-то подобное.Также,если вы используете unix,НЕ делайте логин учетной записи root доступным,он всегда должен быть только sudo.</target>
        </trans-unit>
        <trans-unit id="d9ea1176666f5e2cfe77b291548afa7d1dd3e910" translate="yes" xml:space="preserve">
          <source>For example, you can &lt;a href=&quot;http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/&quot;&gt;crack all 8-character Windows passwords in 6 hours&lt;/a&gt; using 25 GPUs installed in 5 desktop PCs.  This is brute-forcing i.e. enumerating and checking &lt;em&gt;every 8-character Windows password&lt;/em&gt;, including special characters, and is not a dictionary attack. That was in 2012, as of 2018 you could use fewer GPUs, or crack faster with 25 GPUs.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, вы можете &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;взломать все 8-символьные пароли Windows за 6 часов,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; используя 25 графических процессоров, установленных на 5 настольных ПК. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это перебор, то есть перечисление и проверка &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;каждого 8-символьного пароля Windows&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , включая специальные символы, и это не атака по словарю. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это было в 2012 году, по состоянию на 2018 год вы могли использовать меньше графических процессоров или быстрее взломать 25 графических процессоров.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5638ccd08221ca60e74b51eedce8f8691850aa0d" translate="yes" xml:space="preserve">
          <source>Future Practices</source>
          <target state="translated">Будущие практики</target>
        </trans-unit>
        <trans-unit id="8cdb7a0b3b6ace5e886174a72b1782806543e80f" translate="yes" xml:space="preserve">
          <source>Google says SHA256 is available to PHP.</source>
          <target state="translated">Google говорит,что SHA256 доступен для PHP.</target>
        </trans-unit>
        <trans-unit id="6dfd63230af2892f2f367f0290c4dfd849f7dc6a" translate="yes" xml:space="preserve">
          <source>Here is a PHP class that creates a hash and salt for a password easily</source>
          <target state="translated">Вот класс PHP,который легко создает хэш и соль для пароля.</target>
        </trans-unit>
        <trans-unit id="d3de020d4de5c9ec8acb08596101993264195d55" translate="yes" xml:space="preserve">
          <source>How would you implement salted passwords in Tomcat 5.5</source>
          <target state="translated">Как бы вы реализовали соленые пароли в Tomcat 5.5?</target>
        </trans-unit>
        <trans-unit id="094dfed6a03363f271cb6e9eb1fbbe95ffe3f66b" translate="yes" xml:space="preserve">
          <source>I almost can't imagine this situation anymore. &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt; supports PHP 3.0.18 through 5.3, so it is usable on almost every installation imaginable&amp;mdash;and should be used if you don't &lt;em&gt;know for certain&lt;/em&gt; that your environment supports bcrypt.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я почти не могу представить эту ситуацию больше. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PHPASS&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поддерживает PHP 3.0.18&amp;ndash;5.3, поэтому его можно использовать практически во всех возможных установках, и его следует использовать, если вы точно не &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;знаете,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; что ваша среда поддерживает bcrypt.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a7427fce65bccc8329b93c08c2c177aa8d900929" translate="yes" xml:space="preserve">
          <source>I changed my mind about using bcrypt when I learned that bcrypt only uses blowfish's key schedule, with a variable cost mechanism. The latter lets you increase the cost to brute-force a password by increasing blowfish's already expensive key schedule.</source>
          <target state="translated">Я передумал использовать bcrypt,когда узнал,что bcrypt использует только расписание клавиш blowfish,с механизмом переменной стоимости.Последний позволяет увеличить стоимость перебора пароля путем увеличения и без того дорогостоящего расписания клавиш blowfish.</target>
        </trans-unit>
        <trans-unit id="74d1dec78ea1f0d88fb883d96450938d3cd9d96d" translate="yes" xml:space="preserve">
          <source>I found perfect topic on this matter here: &lt;a href=&quot;https://crackstation.net/hashing-security.htm&quot;&gt;https://crackstation.net/hashing-security.htm&lt;/a&gt;, I wanted you to get benefit from it, here is source code also that provided prevention against time-based attack also.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я нашел идеальную тему по этому вопросу здесь: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://crackstation.net/hashing-security.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://crackstation.net/hashing-security.htm&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , я хотел, чтобы вы получили от этого выгоду, вот также исходный код, который обеспечил защиту от атак на основе времени.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="878b969cae5ef5b116676174f4bba610ac895913" translate="yes" xml:space="preserve">
          <source>I highly suggest reading the documentation for the &lt;a href=&quot;http://us.php.net/crypt&quot;&gt;crypt function&lt;/a&gt; if you want to understand how to use bcrypt, or finding yourself a &lt;a href=&quot;https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021&quot;&gt;good&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/1070401&quot;&gt;wrapper&lt;/a&gt; or use something like &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt; for a more legacy implementation. I recommend a minimum of 12 rounds of bcrypt, if not 15 to 18.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я настоятельно рекомендую прочитать документацию по &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://us.php.net/crypt&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функции crypt,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; если вы хотите понять, как использовать bcrypt, или найти себе &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;хорошую &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/1070401&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обертку,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или использовать что-то вроде &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PHPASS&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для более унаследованной реализации. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я рекомендую минимум 12 раундов bcrypt, если не 15-18.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3acd6228038caf8487300f27ba32f185e5efc8f9" translate="yes" xml:space="preserve">
          <source>I just want to point out that PHP 5.5 includes a &lt;a href=&quot;http://www.php.net/manual/en/ref.password.php&quot;&gt;password hashing API&lt;/a&gt; that provides a wrapper around &lt;code&gt;crypt()&lt;/code&gt;. This API significantly simplifies the task of hashing, verifying and rehashing password hashes. The author has also released a &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility pack&lt;/a&gt; (in the form of a single password.php file that you simply &lt;code&gt;require&lt;/code&gt; to use), for those using PHP 5.3.7 and later and want to use this right now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я просто хочу отметить, что PHP 5.5 включает &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.php.net/manual/en/ref.password.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;API хеширования паролей,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; который предоставляет обертку для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;crypt()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот API-интерфейс значительно упрощает задачу хеширования, проверки и перефразирования хэшей паролей. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Автор также выпустил &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;пакет совместимости&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (в виде одного файла password.php, который вам просто &lt;/font&gt;&lt;/font&gt; &lt;code&gt;require&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) для тех, кто использует PHP 5.3.7 и более поздние версии и хочет использовать его прямо сейчас.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="021bc86837c1cf4ede09646fe8929f5646deb92f" translate="yes" xml:space="preserve">
          <source>I usually use SHA1 and salt with the user ID (or some other user-specific piece of information), and sometimes I additionally use a constant salt (so I have 2 parts to the salt).</source>
          <target state="translated">Обычно я использую SHA1 и соль с идентификатором пользователя (или какую-либо другую специфическую для пользователя информацию),а иногда я дополнительно использую постоянную соль (поэтому у меня есть 2 части к соли).</target>
        </trans-unit>
        <trans-unit id="1bc7ca4a9003d758e3158a03983889340d7b0ef9" translate="yes" xml:space="preserve">
          <source>I would not store the password hashed in two different ways, because then the system is at least as weak as the weakest of the hash algorithms in use.</source>
          <target state="translated">Я бы не стал хранить хэшированный пароль двумя разными способами,потому что тогда система как минимум так же слаба,как и самые слабые из используемых хэш-алгоритмов.</target>
        </trans-unit>
        <trans-unit id="462230903f4568427872db9e53f5786cbc3b5e7d" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;Phpass&lt;/a&gt; which is a simple one-file PHP class that could be implemented very easily in nearly every PHP project. See also &lt;a href=&quot;http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4&quot;&gt;The H&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я использую &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Phpass&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - простой &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;однофайловый&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; PHP-класс, который можно очень легко реализовать практически в каждом PHP-проекте. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Смотрите также &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Н&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e7956166ff653d061a0f1fee8e6d1f242bac81e" translate="yes" xml:space="preserve">
          <source>I'm using PHP. I want a safe and fast password encryption system. Hashing a password a million times may be safer, but also slower. How to achieve a good balance between speed and safety? Also, I'd prefer the result to have a constant number of characters.</source>
          <target state="translated">Я использую PHP.Я хочу безопасную и быструю систему шифрования паролей.Хранение пароля миллион раз может быть безопаснее,но и медленнее.Как достичь хорошего баланса между скоростью и безопасностью? Также,я бы предпочел,чтобы результат был с постоянным количеством символов.</target>
        </trans-unit>
        <trans-unit id="6ff2c27f72547e5d2b06a5581aa37280ccb6a8db" translate="yes" xml:space="preserve">
          <source>Ideally you want your DB and APPLICATION on separate servers. This is not always possible due to cost, but it does allow for some safety as the attacker will have to go through two steps to fully access the system.</source>
          <target state="translated">В идеале вы хотите,чтобы ваши БД и ПРИЛОЖЕНИЕ были на разных серверах.Это не всегда возможно из-за стоимости,но это позволяет обеспечить некоторую безопасность,поскольку злоумышленнику придется пройти через два шага,чтобы получить полный доступ к системе.</target>
        </trans-unit>
        <trans-unit id="3a9162bbf805570c30c3008fac626548ad008226" translate="yes" xml:space="preserve">
          <source>If the user is creating a password through the frontend that means it has to be sent to the server. This opens up a security issue because that means the unencrypted password is being sent to the server and if a attacker is able to listen and access that all your security in PHP is worthless. ALWAYS transmit the data SECURELY, this is done through SSL, but be weary even SSL is not flawless (OpenSSL's Heartbleed flaw is an example of this).</source>
          <target state="translated">Если пользователь создает пароль через фронтенд,это означает,что он должен быть отправлен на сервер.Это открывает проблему безопасности,поскольку это означает,что на сервер отправляется незашифрованный пароль,и если злоумышленник может прослушать и получить доступ,то вся ваша безопасность в PHP ничего не стоит.ВСЕГДА передавайте данные БЕЗОПАСНО,это делается через SSL,но будьте уставшими,даже SSL не безупречен (примером этого является дефект OpenSSL's Heartbleed).</target>
        </trans-unit>
        <trans-unit id="bfdaf953c79a7a6b68bb4199d7beacdee227846d" translate="yes" xml:space="preserve">
          <source>Implement a reasonable 8-10 character minimum length, plus require at least 1 upper case letter, 1 lower case letter, a number, and a symbol. This will improve the entropy of the password, in turn making it harder to crack. (See the &quot;What makes a good password?&quot; section for some debate.)</source>
          <target state="translated">Реализуйте разумную минимальную длину в 8-10 символов,плюс требуйте не менее 1 прописной буквы,1 строчной буквы,цифры и символа.Это улучшит энтропию пароля,в свою очередь усложнит процесс взлома.(См.раздел &quot;Что делает хороший пароль?&quot; для некоторых дебатов).</target>
        </trans-unit>
        <trans-unit id="db36d1a15c2eff2b9e586d75be21da1c305b8b6a" translate="yes" xml:space="preserve">
          <source>In case I wasn't clear enough, I want to know which hashing function(s) to use and how to pick a good salt in order to have a safe and fast password protection mechanism.</source>
          <target state="translated">В случае,если я не был достаточно ясен,я хочу знать,какую функцию хэширования использовать и как подобрать хорошую соль для того,чтобы иметь безопасный и быстрый механизм парольной защиты.</target>
        </trans-unit>
        <trans-unit id="4d685a0e94f3eab6cfef426e115b55c6d2ecd20c" translate="yes" xml:space="preserve">
          <source>In short, entropy is how much variation is within the password. When a password is only lowercase roman letters, that's only 26 characters. That isn't much variation. Alpha-numeric passwords are better, with 36 characters. But allowing upper and lower case, with symbols, is roughly 96 characters. That's a lot better than just letters. One problem is, to make our passwords memorable we insert patterns&amp;mdash;which reduces entropy. Oops!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Короче говоря, энтропия - это то, насколько сильно варьируется пароль. Когда пароль состоит только из строчных латинских букв, это всего 26 символов. Это не большая вариация. Буквенно-цифровые пароли лучше, с 36 символами. Но допускается верхний и нижний регистр с символами, примерно 96 символов. Это намного лучше, чем просто буквы. Одна проблема состоит в том, чтобы сделать наши пароли запоминающимися, мы вставляем шаблоны, что уменьшает энтропию. К сожалению!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5c756bd1a76be361873a30bd1bd4190227c361c" translate="yes" xml:space="preserve">
          <source>In the comments I talked with @popnoodles, who pointed out that &lt;em&gt;enforcing&lt;/em&gt; a password policy of X length with X many letters, numbers, symbols, etc, can actually reduce entropy by making the password scheme more predictable. I do agree. Randomess, as truly random as possible, is always the safest but least memorable solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В комментариях я говорил с @popnoodles, который указал, что &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;применение&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; политики паролей длиной X с множеством букв, цифр, символов и т. Д. На самом деле может снизить энтропию, сделав схему паролей более предсказуемой. Я согласен. Randomess, как можно более случайный, всегда является самым безопасным, но наименее запоминающимся решением.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0a50c178288b0e09504dc0a677b514cf240abd4" translate="yes" xml:space="preserve">
          <source>In the end, double-hashing, mathematically, provides no benefit.  In practice, however, it is useful for preventing rainbow table-based attacks.  In other words, it is of no more benefit than hashing with a salt, which takes far less processor time in your application or on your server.</source>
          <target state="translated">В конце концов,двойное хэширование,математически,не приносит никакой пользы.На практике,однако,это полезно для предотвращения атак по радужным таблицам.Другими словами,это не более полезно,чем хэширование с солью,которое занимает намного меньше процессорного времени в вашем приложении или на вашем сервере.</target>
        </trans-unit>
        <trans-unit id="7d25865b4d6182316faf089b42e9c22a190d279b" translate="yes" xml:space="preserve">
          <source>Increasing cost (which defaults to 10) makes the hash harder to brute-force but also means generating hashes and verifying passwords against them will be more work for your server's CPU.</source>
          <target state="translated">Увеличение стоимости (по умолчанию 10)усложняет перебор хэшей,но также означает,что генерация хэшей и проверка паролей к ним будет более трудоемкой задачей для процессора вашего сервера.</target>
        </trans-unit>
        <trans-unit id="3819c766e1a237afa339d1b32fb8107d612fcdd2" translate="yes" xml:space="preserve">
          <source>Interestingly, in living out this nightmare, I learned A LOT I didn&amp;rsquo;t know about password cracking, storage, and complexity. &lt;em&gt;I&amp;rsquo;ve come to appreciate why password storage is ever so much more important than password complexity. If you don&amp;rsquo;t know how your password is stored, then all you really can depend upon is complexity.&lt;/em&gt; This might be common knowledge to password and crypto pros, but for the average InfoSec or Web Security expert, I highly doubt it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Интересно, что, живя в этом кошмаре, я узнал много, чего не знал о взломе паролей, хранении и сложности. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я понял, почему хранение паролей намного важнее, чем сложность пароля. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы не знаете, как хранится ваш пароль, то все, на что вы действительно можете рассчитывать - это сложность. &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это может быть общеизвестно для паролей и крипто-профессионалов, но для среднего специалиста по InfoSec или веб-безопасности я в этом сильно сомневаюсь.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="32aace1e6bd9db8789604b5d77b5b357f1a03eeb" translate="yes" xml:space="preserve">
          <source>It can use salt (in this case, are all salts equally good? Is there any way to generate good salts?)</source>
          <target state="translated">Он может использовать соль (в данном случае,все ли соли одинаково хороши? Есть ли способ генерировать хорошие соли?)</target>
        </trans-unit>
        <trans-unit id="76532b90f399c161d14466cd2bb1c1a7e08c404d" translate="yes" xml:space="preserve">
          <source>It is currently said that MD5 is partially unsafe. Taking this into consideration, I'd like to know which mechanism to use for password protection.</source>
          <target state="translated">В настоящее время утверждается,что MD5 частично небезопасен.Учитывая это,хотелось бы знать,какой механизм использовать для парольной защиты.</target>
        </trans-unit>
        <trans-unit id="ec687b6fd5c605eabd26943ffe28b1856e82a532" translate="yes" xml:space="preserve">
          <source>It must be safe</source>
          <target state="translated">Это должно быть безопасно</target>
        </trans-unit>
        <trans-unit id="2deed719274cbd038881d457f177804efb08bba8" translate="yes" xml:space="preserve">
          <source>It only supports BCRYPT for now, but it aims to be easily extended to include other password hashing techniques and because the technique and cost is stored as part of the hash, changes to your prefered hashing technique/cost will not invalidate current hashes, the framework will automagically, use the correct technique/cost when validating. It also handles generating a &quot;secure&quot; salt if you do not explicitly define your own.</source>
          <target state="translated">Пока что она поддерживает только BCRYPT,но ее цель-легко расширить и включить в нее другие техники хэширования паролей,а так как техника и стоимость сохраняются как часть хэша,то изменения в предложенной Вами технике хэширования не сделают недействительными текущие хэши,рамки будут автоматически использовать правильную технику хэширования при валидации.Кроме того,он обрабатывает &quot;безопасную&quot; соль,если Вы не определили свою собственную соль.</target>
        </trans-unit>
        <trans-unit id="fbfb86f18fa274ab0a5bfb0be1ee04f715779f9f" translate="yes" xml:space="preserve">
          <source>Jeremiah Grossman, CTO of Whitehat Security, &lt;a href=&quot;https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/&quot;&gt;stated on White Hat Security blog&lt;/a&gt; after a recent password recovery that required brute-force breaking of his password protection:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Иеремия Гроссман, технический директор Whitehat Security, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;заявил в блоге White Hat Security&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; после недавнего восстановления пароля, которое требовало взлома его защиты паролем:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a1b0239b75a0a79e1923e96b83331042b6c1cfea" translate="yes" xml:space="preserve">
          <source>Lastly: I am not a cryptographer. Whatever I've said is my opinion, but I happen to think it's based on good ol' common sense ... and lots of reading. Remember, be as paranoid as possible, make things as hard to intrude as possible, and then, if you are still worried, contact a white-hat hacker or cryptographer to see what they say about your code/system.</source>
          <target state="translated">Наконец:я не криптограф.Что бы я ни говорил,это мое мнение,но я думаю,что оно основано на здравом смысле...и большом количестве чтения.Помните,будьте как можно более параноидальным,делайте вещи как можно сложнее,а затем,если вы все еще беспокоитесь,свяжитесь с белым хакером или криптографом,чтобы увидеть,что они говорят о вашей кодовой системе.</target>
        </trans-unit>
        <trans-unit id="c3fdfe95f7d84ea072335ae939def14083cede1e" translate="yes" xml:space="preserve">
          <source>Like always DO NOT make this root or something similar.</source>
          <target state="translated">Как всегда,НЕ делайте этот корень или что-то подобное.</target>
        </trans-unit>
        <trans-unit id="8272783154610ed637003d484b1ab9e70499174f" translate="yes" xml:space="preserve">
          <source>More explanation is available at- &lt;a href=&quot;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&quot;&gt;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Более подробное объяснение доступно на &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ccbd82ab1462c38ff0a96c985a99ed1447b09ef0" translate="yes" xml:space="preserve">
          <source>Most programmers just don't have the expertise to write crypto related code safely without introducing vulnerabilities.</source>
          <target state="translated">Большинство программистов просто не имеют опыта,чтобы безопасно писать криптографический код без введения уязвимостей.</target>
        </trans-unit>
        <trans-unit id="f4b758984e383af744fd6b70d1a44453fe5d02d5" translate="yes" xml:space="preserve">
          <source>NEVER EVER store a password in your DB, instead store the hash and unique salt, I will explain why later.</source>
          <target state="translated">НИКОГДА не храните пароль в своей БД,вместо того,чтобы хранить хэш и уникальную соль,я объясню почему позже.</target>
        </trans-unit>
        <trans-unit id="b668a4bf2c2b13fda6ea44b2604e7cb52f134d07" translate="yes" xml:space="preserve">
          <source>Never email a password to your user &lt;em&gt;except when they have lost theirs, and you sent a temporary one.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Никогда &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не отправляйте&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; пароль пользователю по электронной почте, за &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;исключением случаев, когда он потерял свой, и вы отправили временный&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; пароль &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a05bf77552bc683c933754926449ac35cd64a670" translate="yes" xml:space="preserve">
          <source>Never hash passwords with &lt;a href=&quot;http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/&quot;&gt;SHA1&lt;/a&gt; or MD5 or even SHA256! &lt;a href=&quot;http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/&quot;&gt;Modern crackers&lt;/a&gt; can exceed 60 and 180 billion hashes/second (respectively).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Никогда не хэшируйте пароли с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SHA1&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или MD5 или даже с SHA256! &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Современные взломщики&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; могут превышать 60 и 180 миллиардов хэшей в секунду (соответственно).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8ba9091576887aa8ba6c61d6c8d8e6d54342993" translate="yes" xml:space="preserve">
          <source>Never store your user's password in plain-text.</source>
          <target state="translated">Никогда не храните пароль пользователя в открытом виде.</target>
        </trans-unit>
        <trans-unit id="e583d29870e1092a65f27803157c2c1944f2e8dd" translate="yes" xml:space="preserve">
          <source>Never, ever log passwords in any manner.</source>
          <target state="translated">Никогда,никогда не запоминайте пароли.</target>
        </trans-unit>
        <trans-unit id="b0dd8e37f7458d33cf378742fcb833eb6f03eaa4" translate="yes" xml:space="preserve">
          <source>No matter how good your encryption is if you don't properly secure the server that runs the PHP and DB all your efforts are worthless. Most servers function relatively the same way, they have ports assigned to allow you to access them remotely either through ftp or shell. Make sure that you change the default port of which ever remote connection you have active. By not doing this you in effect have made the attacker do one less step in accessing your system.</source>
          <target state="translated">Как бы хорошо ни было ваше шифрование,если вы не обеспечиваете должную защиту сервера,на котором работают PHP и БД,все ваши усилия ничего не стоят.Большинство серверов работают относительно одинаково,им назначены порты,позволяющие вам получить к ним удаленный доступ либо через ftp,либо через оболочку командной строки.Убедитесь,что вы изменили порт по умолчанию,на котором когда-либо было установлено удаленное соединение.Не сделав этого,вы фактически заставили злоумышленника сделать на один шаг меньше для доступа к вашей системе.</target>
        </trans-unit>
        <trans-unit id="a0316a87f5c5e013f52649e477f4e70dd3e0acba" translate="yes" xml:space="preserve">
          <source>Note that even though the default hashing algorithm may change, old hashes will continue to verify just fine because the algorithm used is stored in the hash and &lt;code&gt;password_verify()&lt;/code&gt; picks up on it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что, хотя алгоритм хеширования по умолчанию может измениться, старые хэши будут продолжать проверяться очень хорошо, потому что используемый алгоритм хранится в хеш-коде, и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;password_verify()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; забирает его.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2008200dd1969bed81cd881c21332864a96d99ae" translate="yes" xml:space="preserve">
          <source>ONE WAY HASHING!!!!!!!, Never hash a password in a way that it can be reversed, Hashes should be one way, meaning you don't reverse them and compare them to the password, you instead hash the entered password the same way and compare the two hashes. This means that even if an attacker gets access to the DB he doesn't know what the actually password is, just its resulting hash. Which means more security for your users in the worst possible scenario.</source>
          <target state="translated">НИКОГДА НЕ ХЭШИРОВАТЬ!!!!,Никогда не хэшируйте пароль таким образом,чтобы его можно было перевернуть,Хэш должен быть одним из способов,то есть Вы не перевернете их и не сравните с паролем,вместо этого Вы хэшируете введенный пароль таким же способом и сравниваете два хэша.Это означает,что даже если злоумышленник получит доступ к БД,он не знает,что такое на самом деле пароль,а только его результирующий хэш.Что означает большую безопасность для ваших пользователей в худшем из возможных сценариев.</target>
        </trans-unit>
        <trans-unit id="702aaf71948af0b0b28598e8e00fec24cf4962f6" translate="yes" xml:space="preserve">
          <source>Older PHP versions: OpenWall's &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;phpass&lt;/a&gt; library is much better than most custom code - used in WordPress, Drupal, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Старые версии PHP: &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;библиотека &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;phpass &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OpenWall&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; намного лучше, чем большинство других пользовательских кодов - используется в WordPress, Drupal и т. Д.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc886b63ca3b0eb383c458da407e533fe3d56755" translate="yes" xml:space="preserve">
          <source>One of the most common mistakes in hashing is that hashes are not unique to the users. This is mainly because salts are not uniquely generated.</source>
          <target state="translated">Одна из наиболее распространенных ошибок в хэшировании заключается в том,что хэши не являются уникальными для пользователей.В основном это связано с тем,что соли не являются уникальными.</target>
        </trans-unit>
        <trans-unit id="c2385fa123d6a9984b6b1eddc74522697f2d9f20" translate="yes" xml:space="preserve">
          <source>P.s. for last 2 steps you can use your own algorithm...
but be sure that you can generate this hashed password in the future 
when you need to authorize user...</source>
          <target state="translated">P.s.для последних двух шагов вы можете использовать свой собственный алгоритм...но будьте уверены,что вы сможете сгенерировать этот хэшированный пароль в будущем при необходимости авторизации пользователя...</target>
        </trans-unit>
        <trans-unit id="7d080faa12a8ba859c71e8cfa04be086436076bf" translate="yes" xml:space="preserve">
          <source>PHP 5.5 or higher: &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash()&lt;/a&gt; is good quality and part of PHP core.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PHP 5.5 или выше: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;password_hash ()&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; хорошего качества и является частью ядра PHP.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e441ae84ae0663d1c0b2f38792b0dada2e5cf183" translate="yes" xml:space="preserve">
          <source>Password entropy is &lt;a href=&quot;https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/&quot;&gt;approximated&lt;/a&gt; easily. Using the full range of ascii characters (roughly 96 typeable characters) yields an entropy of 6.6 per character, which at 8 characters for a password is still too low (52.679 bits of entropy) for future security. But the good news is: longer passwords, and passwords with unicode characters, really increase the entropy of a password and make it harder to crack.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Энтропия пароля &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;легко &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;аппроксимируется&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Использование полного диапазона символов ascii (примерно 96 набираемых символов) дает энтропию 6,6 на символ, что при 8 символах для пароля все еще слишком мало (52,679 бит энтропии) для будущей безопасности. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но есть и хорошая новость: более длинные пароли и пароли с символами Юникода действительно увеличивают энтропию пароля и усложняют его взлом.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f90138bce65ffdcace9e2bb19f7963c1bd536d2" translate="yes" xml:space="preserve">
          <source>Passwords should always be salted before hashed. Salting adds a random string to the password so similar passwords don't appear the same in the DB. However if the salt is not unique to each user (ie: you use a hard coded salt) than you pretty much have made your salt worthless. Because once an attacker figures out one password salt he has the salt for all of them.</source>
          <target state="translated">Пароли всегда должны быть солеными перед хэшированием.Соль добавляет к паролю случайную строку,чтобы похожие пароли не выглядели одинаковыми в БД.Однако,если соль не уникальна для каждого пользователя (т.е.вы используете жестко закодированную соль),то вы практически сделали вашу соль бесполезной.Потому что как только злоумышленник вычислит одну соль для пароля,у него будет соль для всех паролей.</target>
        </trans-unit>
        <trans-unit id="48845b9c00008f76810e059c640d17fa100ba624" translate="yes" xml:space="preserve">
          <source>Providing the &lt;code&gt;PASSWORD_DEFAULT&lt;/code&gt; instructs PHP to use the default hashing algorithm of the installed version of PHP. Exactly which algorithm that means is intended to change over time in future versions, so that it will always be one of the strongest available algorithms.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предоставление &lt;/font&gt;&lt;/font&gt; &lt;code&gt;PASSWORD_DEFAULT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; указывает PHP на использование алгоритма хеширования по умолчанию установленной версии PHP. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Какой именно этот алгоритм предназначен для изменения со временем в будущих версиях, так что он всегда будет одним из самых сильных доступных алгоритмов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dd1d5612b63f3e6527355deb1eb2e9ab4b7c8d4c" translate="yes" xml:space="preserve">
          <source>Recently I had a discussion whether password hashes salted with random
  bits are more secure than the one salted with guessable or known
  salts. Let&amp;rsquo;s see: If the system storing password is compromised as
  well as the system which stores the random salt, the attacker will
  have access to hash as well as salt, so whether the salt is random or
  not, doesn&amp;rsquo;t matter. The attacker will can generate pre-computed
  rainbow tables to crack the hash. Here comes the interesting part- it
  is not so trivial to generate pre-computed tables. Let us take example
  of WPA security model. Your WPA password is actually never sent to
  Wireless Access Point. Instead, it is hashed with your SSID (the
  network name- like Linksys, Dlink etc). A very good explanation of how
  this works is here. In order to retrieve password from hash, you will
  need to know the password as well as salt (network name). Church of
  Wifi has already pre-computed hash tables which has top 1000 SSIDs and
  about 1 million passwords. The size is of all tables is about 40 GB.
  As you can read on their site, someone used 15 FGPA arrays for 3 days
  to generate  these tables. Assuming victim is using the SSID as
  &amp;ldquo;a387csf3&amp;Prime; and password as &amp;ldquo;123456&amp;Prime;, will it be cracked by those
  tables? No! .. it cannot. Even if the password is weak, the tables
  don&amp;rsquo;t have hashes for SSID a387csf3.  This is the beauty of having
  random salt. It will deter crackers who thrive upon pre-computed
  tables. Can it stop a determined hacker? Probably not. But using
  random salts does provide additional layer of defense. While we are on
  this topic, let us discuss additional advantage of storing random
  salts on a separate system. Scenario #1 : Password hashes are stored
  on system X and salt values used for hashing are stored on system Y.
  These salt values are guessable or known (e.g. username) Scenario#2 :
  Password hashes are stored on system X and salt values used for
  hashing are stored on system Y. These salt values are random. In case
  system X has been compromised, as you can guess, there is a huge
  advantage of using random salt on a separate system (Scenario #2) .
  The attacker will need to guess addition values to be able to crack
  hashes. If a 32 bit salt is used, 2^32= 4,294,967,296 (about 4.2
  billion) iterations will can be required for each password guessed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Недавно я обсуждал вопрос о том, являются ли хеши паролей со случайными битами более безопасными, чем хэши с вероятными или известными солями. Давайте посмотрим: если система, хранящая пароль, скомпрометирована так же, как и система, которая хранит случайную соль, злоумышленник будет иметь доступ к хешу, а также к соли, так что, является ли соль случайной или нет, не имеет значения. Атакующий может генерировать предварительно вычисленные радужные таблицы, чтобы взломать хеш. Здесь возникает интересная часть - это не так тривиально генерировать предварительно вычисленные таблицы. Давайте рассмотрим пример модели безопасности WPA. Ваш пароль WPA фактически никогда не отправляется беспроводной точке доступа. Вместо этого он хэшируется с вашим SSID (сетевое имя, такое как Linksys, Dlink и т. Д.). Очень хорошее объяснение того, как это работает, здесь. Чтобы восстановить пароль из хэша,вам нужно будет знать как пароль, так и соль (имя сети). Church of Wifi уже предварительно вычислил хеш-таблицы, которые имеют 1000 лучших SSID и около 1 миллиона паролей. Размер всех таблиц составляет около 40 ГБ. Как вы можете прочитать на их сайте, кто-то использовал 15 массивов FGPA в течение 3 дней для генерации этих таблиц. Предполагая, что жертва использует SSID в качестве &amp;laquo;a387csf3&amp;raquo; и пароль в качестве &amp;laquo;123456&amp;raquo;, будут ли они взломаны этими таблицами? Нет! .. оно не может. Даже если пароль слабый, в таблицах нет хэшей для SSID a387csf3. Это красота наличия случайной соли. Это будет сдерживать взломщиков, которые процветают на предварительно вычисленных столах Может ли это остановить решительного хакера? Возможно нет. Но использование случайных солей обеспечивает дополнительный уровень защиты. Пока мы на эту тему,давайте обсудим дополнительное преимущество хранения случайных солей в отдельной системе. Сценарий # 1: хеши паролей хранятся в системе X, а значения соли, используемые для хеширования, хранятся в системе Y. Эти солт-значения являются предположительными или известными (например, имя пользователя). Сценарий # 2: хеши паролей хранятся в системе X, а значения соли используются для хеширование хранится в системе Y. Эти значения соли являются случайными. Как вы можете догадаться, если система X была скомпрометирована, то использование случайной соли в отдельной системе дает огромное преимущество (сценарий № 2). Атакующий должен будет угадать дополнительные значения, чтобы иметь возможность взломать хэши. Если используется 32-битная соль, для каждого угаданного пароля может потребоваться 2 ^ 32 = 4 294 967 296 (около 4,2 миллиарда) итераций.Хеши паролей хранятся в системе X, а значения солей, используемые для хеширования, хранятся в системе Y. Эти солт-значения являются предположительными или известными (например, имя пользователя) Сценарий # 2: Хеши паролей хранятся в системе X, а значения солей, используемых для хеширования, сохраняются в Система Y. Эти значения соли являются случайными. Как вы можете догадаться, если система X была скомпрометирована, то использование случайной соли в отдельной системе дает огромное преимущество (сценарий № 2). Атакующий должен будет угадать дополнительные значения, чтобы иметь возможность взломать хэши. Если используется 32-битная соль, для каждого угаданного пароля может потребоваться 2 ^ 32 = 4 294 967 296 (около 4,2 миллиарда) итераций.Хеши паролей хранятся в системе X, а значения солей, используемые для хеширования, хранятся в системе Y. Эти солт-значения являются предположительными или известными (например, имя пользователя) Сценарий # 2: Хеши паролей хранятся в системе X, а значения солей, используемых для хеширования, сохраняются в Система Y. Эти значения соли являются случайными. Как вы можете догадаться, если система X была скомпрометирована, то использование случайной соли в отдельной системе дает огромное преимущество (сценарий № 2). Атакующий должен будет угадать дополнительные значения, чтобы иметь возможность взломать хэши. Если используется 32-битная соль, для каждого угаданного пароля может потребоваться 2 ^ 32 = 4 294 967 296 (около 4,2 миллиарда) итераций.Эти значения соли являются случайными. Как вы можете догадаться, если система X была скомпрометирована, то использование случайной соли в отдельной системе дает огромное преимущество (сценарий № 2). Атакующий должен будет угадать дополнительные значения, чтобы иметь возможность взломать хэши. Если используется 32-битная соль, для каждого угаданного пароля может потребоваться 2 ^ 32 = 4 294 967 296 (около 4,2 миллиарда) итераций.Эти значения соли являются случайными. Как вы можете догадаться, если система X была скомпрометирована, то использование случайной соли в отдельной системе дает огромное преимущество (сценарий № 2). Атакующий должен будет угадать дополнительные значения, чтобы иметь возможность взломать хэши. Если используется 32-битная соль, для каждого угаданного пароля может потребоваться 2 ^ 32 = 4 294 967 296 (около 4,2 миллиарда) итераций.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29cf51326e60ca7639ae8d61993a3e6af0924dbd" translate="yes" xml:space="preserve">
          <source>Reset everyone's passwords when the database is compromised.</source>
          <target state="translated">Сброс всех паролей,когда база данных взломана.</target>
        </trans-unit>
        <trans-unit id="99aba45ee7f729f62087c2a073d856536cd76908" translate="yes" xml:space="preserve">
          <source>SHA1 is now also considered somewhat compromised, but to a far lesser degree than MD5.  By using a salt (any salt), you're preventing the use of a generic &lt;a href=&quot;http://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;rainbow table&lt;/a&gt; to attack your hashes (some people have even had success using Google as a sort of rainbow table by searching for the hash).  An attacker could conceivably generate a rainbow table using your salt, so that's why you should include a user-specific salt.  That way, they will have to generate a rainbow table for each and every record in your system, not just one for your entire system!  With that type of salting, even MD5 is decently secure.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SHA1 теперь также считается несколько скомпрометированным, но в гораздо меньшей степени, чем MD5. Используя соль (любую соль), вы предотвращаете использование универсальной &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;радужной таблицы&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для атаки на ваши хэши (некоторые люди даже добились успеха, используя Google как своего рода радужную таблицу при поиске хеша). Злоумышленник может сгенерировать радужную таблицу, используя вашу соль, поэтому вы должны добавить соль, специфичную для пользователя. Таким образом, им придется генерировать радужную таблицу для каждой записи в вашей системе, а не только для всей вашей системы! При таком типе посола даже MD5 прилично безопасен.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4eda4093b78a303b74d4192d587dca2314fa4169" translate="yes" xml:space="preserve">
          <source>Secure hash and salt for PHP passwords</source>
          <target state="translated">Безопасный хэш и соль для паролей PHP</target>
        </trans-unit>
        <trans-unit id="f11fa153ab1a9133bcbd4157363d3c3c13723b94" translate="yes" xml:space="preserve">
          <source>Secure methods of storing keys, passwords for asp.net</source>
          <target state="translated">Безопасные методы хранения ключей,паролей для asp.net</target>
        </trans-unit>
        <trans-unit id="ff41ccecb888661f5547c2d4b885e0c114d66f5f" translate="yes" xml:space="preserve">
          <source>Simple Password Encryption</source>
          <target state="translated">Простое шифрование пароля</target>
        </trans-unit>
        <trans-unit id="02d7e2181d283624db40fc6185be390dccef0f3e" translate="yes" xml:space="preserve">
          <source>Since then, PHP has given us &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;&lt;code&gt;password_hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;&lt;code&gt;password_verify&lt;/code&gt;&lt;/a&gt; and, since their introduction, they are the recommended password hashing &amp;amp; checking method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С тех пор PHP предоставил нам &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt; &lt;code&gt;password_hash&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt; &lt;code&gt;password_verify&lt;/code&gt; ,&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и с момента их появления они являются рекомендуемым методом хеширования и проверки паролей.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6dd6c021f508c0340ebfdf5945ac1810408566d3" translate="yes" xml:space="preserve">
          <source>So far as I've been able to tell, making the world's best password is a Catch-22. Either its not memorable, too predictable, too short, too many unicode characters (hard to type on a Windows/Mobile device), too long, etc. No password is truly good enough for our purposes, so we must protect them as though they were in Fort Knox.</source>
          <target state="translated">Насколько я могу судить,сделать лучший в мире пароль-это Catch-22.Либо он не запоминается,либо слишком предсказуем,либо слишком короток,либо слишком много символов юникода (сложно набрать на устройстве WindowsMobile),слишком длинен и т.д.Ни один пароль не является по-настоящему хорошим для наших целей,поэтому мы должны защищать их так,как будто они находятся в Форт Ноксе.</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="abc469ca9e1e32aad49a7fa70322810e433fbc73" translate="yes" xml:space="preserve">
          <source>The API exposes four functions:</source>
          <target state="translated">API раскрывает четыре функции:</target>
        </trans-unit>
        <trans-unit id="d1e5cbc852e92edf4f983cd9843ad840d31e7b05" translate="yes" xml:space="preserve">
          <source>The computational power required to actually &lt;em&gt;crack&lt;/em&gt; a hashed password doesn't exist. The only way for computers to &quot;crack&quot; a password is to recreate it and simulate the hashing algorithm used to secure it. The speed of the hash is linearly related to its ability to be brute-forced. Worse still, most hash algorithms can be easily parallelized to perform even faster. This is why costly schemes like bcrypt and scrypt are so important.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вычислительная мощность, необходимая для &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;взлома&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; хешированного пароля, не существует. Единственный способ &amp;laquo;взломать&amp;raquo; пароль для компьютеров - это воссоздать его и смоделировать алгоритм хеширования, используемый для его защиты. Скорость хэша линейно связана с его способностью к грубому принуждению. Хуже того, большинство алгоритмов хеширования можно легко распараллелить, чтобы они работали еще быстрее. Вот почему такие дорогостоящие схемы, как bcrypt и scrypt, так важны.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc82bec66b732bb33be65e32feee97dde8331a13" translate="yes" xml:space="preserve">
          <source>The hashing mechanism must be available in PHP</source>
          <target state="translated">Механизм хеширования должен быть доступен в PHP</target>
        </trans-unit>
        <trans-unit id="c967b55b3de7e43262a5ec3a53dd313fc5714961" translate="yes" xml:space="preserve">
          <source>The idea of a salt is to throw the hashing results off balance, so to say. It is known, for example, that the MD5-hash of an empty string is &lt;code&gt;d41d8cd98f00b204e9800998ecf8427e&lt;/code&gt;. So, if someone with good enough a memory would see that hash and know that it's the hash of an empty string. But if the string is salted (say, with the string &quot;&lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt;&quot;), the hash for the 'empty string' (i.e. &quot;&lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt;&quot;) becomes &lt;code&gt;aeac2612626724592271634fb14d3ea6&lt;/code&gt;, hence non-obvious to backtrace. What I'm trying to say, that it's better to use &lt;em&gt;any&lt;/em&gt; salt, than not to. Therefore, it's not too much of an importance to know &lt;em&gt;which&lt;/em&gt; salt to use.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Идея соли состоит в том, чтобы вывести из равновесия результаты хеширования. Например, известно, что MD5-хэш пустой строки имеет вид &lt;/font&gt;&lt;/font&gt; &lt;code&gt;d41d8cd98f00b204e9800998ecf8427e&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Итак, если кто-то с достаточно хорошей памятью увидит этот хэш и узнает, что это хэш пустой строки. Но если строка соленая (скажем, со строкой &amp;laquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;), хеш для &amp;laquo;пустой строки&amp;raquo; (т. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;laquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MY_PERSONAL_SALT&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;) становится &lt;/font&gt;&lt;/font&gt; &lt;code&gt;aeac2612626724592271634fb14d3ea6&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , следовательно, не является очевидным для &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обратной&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; трассировки. Что я пытаюсь сказать, что лучше использовать &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;любую&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; соль, чем не делать этого. Поэтому не так уж важно знать, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;какую&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; соль использовать.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e93c44acff31ed1b16a3be79f5aaf860521be39" translate="yes" xml:space="preserve">
          <source>The objective behind hashing passwords is simple: preventing malicious access to user accounts by compromising the database. So the goal of password hashing is to deter a hacker or cracker by costing them too much time or money to calculate the plain-text passwords. And time/cost are the best deterrents in your arsenal.</source>
          <target state="translated">Цель хэширования паролей проста:предотвратить злонамеренный доступ к учетным записям пользователей путем компрометации базы данных.Таким образом,цель хэширования паролей состоит в том,чтобы отпугнуть хакера или взломщика,потратив на это слишком много времени или денег,чтобы вычислить пароли из чистого текста.А затраты времени являются лучшим сдерживающим фактором в вашем арсенале.</target>
        </trans-unit>
        <trans-unit id="ca15458b1f6023e826d9e6c9d269e5b8847c24ab" translate="yes" xml:space="preserve">
          <source>The returned hash could be stored in database as it is. Sample use for generating hash is:</source>
          <target state="translated">Возвращаемый хэш может быть сохранен в базе данных как есть.Пример использования для генерации хэша:</target>
        </trans-unit>
        <trans-unit id="9336b71741fbd4b0fc7ebef42b5f931ca05fe080" translate="yes" xml:space="preserve">
          <source>The theory of the answer is still a good read though.</source>
          <target state="translated">Хотя теория ответа все еще хорошо прочитана.</target>
        </trans-unit>
        <trans-unit id="72fe41d63bb494eee2544c08c337e299e480e6db" translate="yes" xml:space="preserve">
          <source>Then have a separate user account for you that is not stored anywhere on the server, not even in the application.</source>
          <target state="translated">Тогда у вас будет отдельная учетная запись пользователя,которая нигде не хранится на сервере,даже в приложении.</target>
        </trans-unit>
        <trans-unit id="a80224d4f8511d86bc794896685456f1282e0a56" translate="yes" xml:space="preserve">
          <source>There are a lot of good hashing functions out there (&lt;code&gt;password_hash&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, etc...) but you need to select a good algorithm for the hash to be effective. (bcrypt and ones similar to it are decent algorithms.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Существует множество хороших хеш-функций ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;password_hash&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;hash&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и т. Д.), Но вам нужно выбрать хороший алгоритм, чтобы хеш был эффективным. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(bcrypt и подобные ему являются достойными алгоритмами.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83d2f507ea07e3720cda34bd2cd662536b85bf9a" translate="yes" xml:space="preserve">
          <source>There are actually &lt;a href=&quot;http://gdataonline.com/seekhash.php&quot;&gt;websites that do just this&lt;/a&gt; - you can feed it a (md5) hash, and it spits out a known plaintext that generates that particular hash. If you would get access to a database that stores plain md5-hashes, it would be trivial for you to enter the hash for the admin to such a service, and log in. But, if the passwords were salted, such a service would become ineffective.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На самом деле, есть &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://gdataonline.com/seekhash.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сайты, которые делают именно это&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - вы можете передать ему хэш (md5), и он выплевывает известный открытый текст, который генерирует этот конкретный хеш. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если бы вы получили доступ к базе данных, в которой хранятся простые md5-хэши, для вас было бы тривиально ввести хеш для администратора для такой службы и войти в систему. Но если бы пароли были засолены, такая служба стала бы неэффективны.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94dc7fd1014b141fac002eb97bbbe1edb127d32d" translate="yes" xml:space="preserve">
          <source>There are also many rainbow table attacks on Windows passwords that run on ordinary CPUs and are very fast.  All this is because Windows &lt;em&gt;still&lt;/em&gt;&lt;a href=&quot;https://superuser.com/a/118279/90231&quot;&gt;doesn't salt or stretch&lt;/a&gt; its passwords, &lt;a href=&quot;https://www.guidingtech.com/61991/cracking-windows-10-password-prevent/&quot;&gt;even in Windows 10&lt;/a&gt; - don't make the same mistake as Microsoft did!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Существует также множество атак &amp;laquo;радужных таблиц&amp;raquo; на пароли Windows, которые выполняются на обычных процессорах и очень быстры. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Все это потому, что Windows &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;до сих пор &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;a href=&quot;https://superuser.com/a/118279/90231&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не искажает и не растягивает&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; свои пароли, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.guidingtech.com/61991/cracking-windows-10-password-prevent/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;даже в Windows 10&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - не делайте ту же ошибку, что и Microsoft!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7d78de6e30f57b4b7d0c6241b43daf6efe33858b" translate="yes" xml:space="preserve">
          <source>There's a longer discussion of password entropy on the &lt;a href=&quot;https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password&quot;&gt;Crypto StackExchange&lt;/a&gt; site. A good Google search will also turn up a lot of results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сайте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Crypto StackExchange&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; обсуждается вопрос об энтропии &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;паролей&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хороший поиск в Google также даст много результатов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb3552eb4e3ab442dc5e9548665b050d60219300" translate="yes" xml:space="preserve">
          <source>This question, &lt;a href=&quot;https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once&quot;&gt;Is &amp;ldquo;double hashing&amp;rdquo; a password less secure than just hashing it once?&lt;/a&gt; 
suggests that hashing multiple times may be a good idea, whereas &lt;a href=&quot;https://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904&quot;&gt;How to implement password protection for individual files?&lt;/a&gt; suggests using salt.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот вопрос, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;является ли &amp;laquo;двойное хеширование&amp;raquo; паролем менее безопасным, чем однократное хеширование? &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; предполагает, что хэширование несколько раз может быть хорошей идеей, тогда как &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;как реализовать защиту паролем для отдельных файлов? &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;предлагает использовать соль.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="957441673ad43072032f00a3b5118222b26b20f1" translate="yes" xml:space="preserve">
          <source>Though the question has been answered, I just want to reiterate that salts used for hashing should be random and not like email address as suggested in first answer.</source>
          <target state="translated">Хотя на вопрос был дан ответ,я просто хочу повторить,что соли,используемые для хеширования,должны быть случайными и не похожими на электронный адрес,как было предложено в первом ответе.</target>
        </trans-unit>
        <trans-unit id="0cf0236983335ce525d178c161a3dac43b40ad44" translate="yes" xml:space="preserve">
          <source>To verify password, one can use:</source>
          <target state="translated">Для проверки пароля можно использовать:</target>
        </trans-unit>
        <trans-unit id="ae24b36e98b286448b8f32e9eb9c4f5faa046188" translate="yes" xml:space="preserve">
          <source>Try an implementation of &lt;a href=&quot;http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard&quot;&gt;PDKBF2&lt;/a&gt; with the &lt;a href=&quot;https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256&quot;&gt;maximum number of rounds&lt;/a&gt; that your environment/application/user-perception can tolerate. The lowest number I'd recommend is 2500 rounds. Also, make sure to use &lt;a href=&quot;http://php.net/hash_hmac&quot;&gt;hash_hmac()&lt;/a&gt; if it is available to make the operation harder to reproduce.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Попробуйте реализовать &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PDKBF2&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;максимальным количеством раундов,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; которое может выдержать ваша среда / приложение / восприятие пользователя. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Наименьшее число, которое я бы порекомендовал - 2500 раундов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, обязательно используйте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://php.net/hash_hmac&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;hash_hmac (),&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; если он доступен, чтобы сделать операцию труднее воспроизвести.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="068a6272a632b944b53a381b4d5400b18d5eafc9" translate="yes" xml:space="preserve">
          <source>Use PBKDF2 if you cannot use either bcrypt or scrypt, with SHA2 hashes.</source>
          <target state="translated">Используйте PBKDF2,если вы не можете использовать ни bcrypt,ни scrypt,с SHA2 хэшами.</target>
        </trans-unit>
        <trans-unit id="3438f0875ced99f75e760bc602d283a350f5c224" translate="yes" xml:space="preserve">
          <source>Use scrypt when you can; bcrypt if you cannot.</source>
          <target state="translated">Используйте шифрование,когда можете;шифрование,если не можете.</target>
        </trans-unit>
        <trans-unit id="8a40715ff9e4ad938469f5e938fbc3461e5c29de" translate="yes" xml:space="preserve">
          <source>What makes a &lt;em&gt;good&lt;/em&gt; password anyway?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что делает &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;хороший&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; пароль в любом случае?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d324dbbd000686026c12d8aac03bc6761752e7ae" translate="yes" xml:space="preserve">
          <source>What's the difference between SHA and MD5 in PHP</source>
          <target state="translated">В чем разница между SHA и MD5 в PHP.</target>
        </trans-unit>
        <trans-unit id="3273a0f907bb9b658a5b510bdc764fef8f6fd55f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;password_hash()&lt;/code&gt; is used, it generates a random salt and includes it in the outputted hash (along with the the cost and algorithm used.) &lt;code&gt;password_verify()&lt;/code&gt; then reads that hash and determines the salt and encryption method used, and verifies it against the provided plaintext password.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда &lt;/font&gt;&lt;/font&gt; &lt;code&gt;password_hash()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; используется, он генерирует случайную соль и включает его в выводимый хэш (наряду с ценой и используемого алгоритма.) &lt;/font&gt;&lt;/font&gt; &lt;code&gt;password_verify()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; затем считывает , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что хэш и определяет способ соли и шифрования , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;используемый, и проверяет его против предоставленный незашифрованный пароль.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdf0e49369640a78f1b0481bc29357ba77ff4067" translate="yes" xml:space="preserve">
          <source>When hashing speed is the key, the slower the more resistant to Brute Force attacks.</source>
          <target state="translated">Когда ключевым моментом является скорость хеширования,чем медленнее,тем более устойчивы к атакам с применением грубой силы.</target>
        </trans-unit>
        <trans-unit id="0ea7792c8765a8cc7d08846130a9f07954560526" translate="yes" xml:space="preserve">
          <source>When you create a salt make sure it is unique to the password it is salting, then store both the completed hash and salt in your DB. What this will do is make it so that an attacker will have to individually crack each salt and hash before they can gain access. This means a lot more work and time for the attacker.</source>
          <target state="translated">Когда вы создаете соль,убедитесь,что она уникальна для пароля,который она посолила,затем сохраните и готовый хэш,и соль в вашей БД.Это позволит злоумышленнику взломать каждый соль и хэш по отдельности,прежде чем получить доступ к нему.Это означает гораздо больше работы и времени для атакующего.</target>
        </trans-unit>
        <trans-unit id="4bcfb1507fa18c5813bf98587194789dfd7fc9fa" translate="yes" xml:space="preserve">
          <source>Why hash passwords anyway?</source>
          <target state="translated">Зачем вообще хэш-пароли?</target>
        </trans-unit>
        <trans-unit id="d9c509de30c734b1fbd267c99263e20b0ac2f8d4" translate="yes" xml:space="preserve">
          <source>You cannot possibly foresee all threats or avenues of attack, and so you must make your best effort to protect your users &lt;strong&gt;up front&lt;/strong&gt;. If you do not, then you might even miss the fact that you were attacked until it's too late... &lt;em&gt;and you're liable&lt;/em&gt;. To avoid that situation, act paranoid to begin with. Attack your own software (internally) and attempt to steal user credentials, or modify other user's accounts or access their data. If you don't test the security of your system, then you cannot blame anyone but yourself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы не можете , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;возможно , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;предвидеть все угрозы и пути атак, и поэтому вы должны сделать ваши лучшие усилия , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чтобы защитить пользователей &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;фронт&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы этого не сделаете, то вы можете даже упустить тот факт, что на вас напали, пока не стало слишком поздно ... &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и вы несете ответственность&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы избежать этой ситуации, начните действовать параноиком. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Атакуйте свое собственное программное обеспечение (внутренне) и пытайтесь украсть учетные данные пользователя или изменить учетные записи других пользователей или получить доступ к их данным. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы не проверяете безопасность своей системы, вы не можете винить никого, кроме себя.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6ecc62ca116f09be2ac8ccbf2dd2a17934a3f97a" translate="yes" xml:space="preserve">
          <source>You should definitely use a salt. I'd recommend using random bytes (and not restrict yourself to characters and numbers). As usually, the longer you choose, the safer, slower it gets. 64 bytes ought to be fine, i guess.</source>
          <target state="translated">Тебе определенно стоит использовать соль.Я бы рекомендовал использовать случайные байты (и не ограничивать себя символами и цифрами).Как обычно,чем дольше вы выбираете,тем безопаснее,медленнее.64 байта должны быть в порядке,я думаю.</target>
        </trans-unit>
        <trans-unit id="250c2ad56e4e9ddde57caded620862fba3c804d9" translate="yes" xml:space="preserve">
          <source>You tell your users to make good passwords to avoid getting hacked, do the same. What is the point in going through all the effort of locking your front door when you have the backdoor wide open.</source>
          <target state="translated">Вы говорите пользователям делать хорошие пароли,чтобы избежать взлома,делайте то же самое.Какой смысл проходить через все усилия по блокировке входной двери,когда задняя дверь широко открыта.</target>
        </trans-unit>
        <trans-unit id="65de4781939078acdc51b27007cb200ec4c437c0" translate="yes" xml:space="preserve">
          <source>also we need the hash
I`m using sha512
it is the best and it is in php</source>
          <target state="translated">Также нам нужен хэш,который я использую sha512,он лучший и он на php.</target>
        </trans-unit>
        <trans-unit id="28edb5e4d9749f27a128acb260e84492ffdd3323" translate="yes" xml:space="preserve">
          <source>and for authorize we will use same steps...</source>
          <target state="translated">и для разрешения мы будем использовать те же меры...</target>
        </trans-unit>
        <trans-unit id="44c7073fa2fab130499078fde7b90431453ca675" translate="yes" xml:space="preserve">
          <source>it is the best way to safe our clients passwords...</source>
          <target state="translated">это лучший способ сохранить пароли наших клиентов...</target>
        </trans-unit>
        <trans-unit id="66f5061855cb204f427143765390a0e15cb4bb02" translate="yes" xml:space="preserve">
          <source>now we need to save in database our $hash_psw variable value and $salt variable</source>
          <target state="translated">теперь нам нужно сохранить в базе данных значение переменной $hash_psw и переменной $salt.</target>
        </trans-unit>
        <trans-unit id="65b1ca7c9f59ee04049ba7f7cac979ffa197ee6a" translate="yes" xml:space="preserve">
          <source>ok
in the fitsy we need salt
salt must be unique
so let generate it</source>
          <target state="translated">Хорошо,если нам нужна соль,она должна быть уникальной,так что пусть она генерируется.</target>
        </trans-unit>
        <trans-unit id="83813ad92f95972794914dc4459ac7d1fb05a12a" translate="yes" xml:space="preserve">
          <source>so now we can use this functions to generate safe password</source>
          <target state="translated">так что теперь мы можем использовать эти функции для генерации безопасного пароля.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
