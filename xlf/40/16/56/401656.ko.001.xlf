<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/401656">
    <body>
      <group id="401656">
        <trans-unit id="4bd6398b6ec50d16e0ba8b718869fa0726943b47" translate="yes" xml:space="preserve">
          <source>(Emphasis mine.)</source>
          <target state="translated">(Emphasis mine.)</target>
        </trans-unit>
        <trans-unit id="d54e60153602d914878e89e59608b8d75275ed9e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/sha1&quot;&gt;SHA1&lt;/a&gt; and a salt should suffice (depending, naturally, on whether you are coding something for &lt;a href=&quot;http://en.wikipedia.org/wiki/United_States_Bullion_Depository&quot;&gt;Fort Knox&lt;/a&gt; or a login system for your shopping list) for the foreseeable future. If SHA1 isn't good enough for you, use &lt;a href=&quot;http://php.net/manual/en/function.hash.php&quot;&gt;SHA256&lt;/a&gt;.</source>
          <target state="translated">가까운 미래에는 &lt;a href=&quot;http://php.net/sha1&quot;&gt;SHA1&lt;/a&gt; 과 소금이 충분해야합니다 (당연히 &lt;a href=&quot;http://en.wikipedia.org/wiki/United_States_Bullion_Depository&quot;&gt;Fort Knox&lt;/a&gt; 용 코드를 코딩하는지 또는 쇼핑 목록을위한 로그인 시스템에 따라). SHA1이 충분하지 않으면 &lt;a href=&quot;http://php.net/manual/en/function.hash.php&quot;&gt;SHA256을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a49d7ecc7c611924a2bdc550b87beda1e36e7adf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xkcd.com/936/&quot;&gt;Entropy&lt;/a&gt;. (Not that I fully subscribe to Randall's viewpoint.)</source>
          <target state="translated">&lt;a href=&quot;http://xkcd.com/936/&quot;&gt;엔트로피&lt;/a&gt; . (난 랜달의 관점에 전적으로 동의하지는 않는다.)</target>
        </trans-unit>
        <trans-unit id="331904e34fbc8be8527a2f2cc0ab551951a291a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919&quot;&gt;excellent answer&lt;/a&gt; with more about why &lt;code&gt;password_hash()&lt;/code&gt; or &lt;code&gt;phpass&lt;/code&gt; are the best way to go.</source>
          <target state="translated">&lt;code&gt;password_hash()&lt;/code&gt; 또는 &lt;code&gt;phpass&lt;/code&gt; 가 가장 좋은 방법 인 이유에 대한 &lt;a href=&quot;https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919&quot;&gt;훌륭한 답변&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f914dd88be09eb21067092dec3c341a6e91895" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/&quot;&gt;good blog article&lt;/a&gt; giving recommmended 'work factors' (number of iterations) for main algorithms including bcrypt, scrypt and PBKDF2.</source>
          <target state="translated">bcrypt, scrypt 및 PBKDF2를 포함한 주요 알고리즘에 대해 권장되는 '작업 요소'(반복 횟수)를 제공하는 &lt;a href=&quot;https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/&quot;&gt;좋은 블로그 기사&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55f55510afeb77726e0d50b49639b6d98210693b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_get_info()&lt;/code&gt; - returns information about the given hash</source>
          <target state="translated">&lt;code&gt;password_get_info()&lt;/code&gt; -주어진 해시에 대한 정보를 반환</target>
        </trans-unit>
        <trans-unit id="511d82aef08cd670da59b1470aced89fce228ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_hash()&lt;/code&gt; - creates a password hash</source>
          <target state="translated">&lt;code&gt;password_hash()&lt;/code&gt; -비밀번호 해시를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e53608eb6b90132ef76064ce05e5793fc484cd3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_needs_rehash()&lt;/code&gt; - checks if the given hash matches the given options. Useful to check if the hash conforms to your current technique/cost scheme allowing you to rehash if necessary</source>
          <target state="translated">&lt;code&gt;password_needs_rehash()&lt;/code&gt; -주어진 해시가 주어진 옵션과 일치하는지 확인합니다. 해시가 현재 기술 / 비용 체계를 준수하는지 확인하여 필요한 경우 다시 해시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3126d5de685d9c71a7a339b3efcf5bed455a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_verify()&lt;/code&gt; - verifies that a password matches a hash</source>
          <target state="translated">&lt;code&gt;password_verify()&lt;/code&gt; -암호가 해시와 일치하는지 확인</target>
        </trans-unit>
        <trans-unit id="b4b45af4d94ab99b5074596633ad5d1dd429fc9d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HASHING&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HASHING&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae35617fc2a3e929f057c2ac76f291842cfc1b34" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PASSWORD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PASSWORD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cc85735d6d4bc3f8eb14617d7b3510366c3c30c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PORTS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PORTS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f14c91feaf4967ef247273e68b9a406a2c8c581" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Related questions that don't quite cover my question:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;내 질문에 잘 맞지 않는 관련 질문 :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed1c080c450a82285e50d7a816ddc03a0863f19a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SALTING&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SALTING&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5977b0e7ee94c66e337dded2dd5bbe8a4ad8b2cb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SERVER&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SERVER&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="23118db0e558706fb2facd763d94ae2dcff3c884" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USER&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;USER&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="603ff9cd887ac389320761a219db9bf3b57244d7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USERNAME&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;USERNAME&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f77d76027e0db3dd25ad0ea328da229ae899dcd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;USERS CREATING PASSWORDS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;비밀번호를 만드는 사용자&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="896fefe79b5f0b7a660920e0a621a010a9b8870b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DATABASE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DATABASE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d67cf51a25a2a4dbc01f9a24286e1ab97db82f1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DISCLAIMER&lt;/strong&gt;: This answer was written in 2008.</source>
          <target state="translated">&lt;strong&gt;면책 조항&lt;/strong&gt; :이 답변은 2008 년에 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="c0ea0dc97baa1d4c675361104fa844e8cea6bf02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PHP&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ff333e7b1ff670b7f3dc5b40367c60de2baedb6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Quick self-test:&lt;/strong&gt; what is password stretching and how many iterations should you use?  If you don't know the answer, you should use &lt;code&gt;password_hash()&lt;/code&gt;, as password stretching is now a critical feature of password mechanisms due to much faster CPUs and the use of &lt;a href=&quot;http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/&quot;&gt;GPUs and FPGAs&lt;/a&gt; to crack passwords at rates of &lt;a href=&quot;http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches&quot;&gt;billions of guesses per second&lt;/a&gt; (with GPUs).</source>
          <target state="translated">&lt;strong&gt;빠른 자체 테스트 :&lt;/strong&gt; 비밀번호 확장이란 무엇이며 얼마나 많은 반복을 사용해야합니까? 답을 모른다면 &lt;code&gt;password_hash()&lt;/code&gt; 사용해야 합니다. 암호 확장은 이제 훨씬 더 빠른 CPU와 &lt;a href=&quot;http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/&quot;&gt;GPU 및 FPGA&lt;/a&gt; 를 사용하여 &lt;a href=&quot;http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches&quot;&gt;초당 수십억 번의 추측으로&lt;/a&gt; 암호를 해독하기 때문에 암호 메커니즘의 중요한 기능이므로 암호를 사용해야합니다. (GPU 포함).</target>
        </trans-unit>
        <trans-unit id="aed0191173d72ecf54d46939a34acf7570a79ca0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SERVER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SERVER&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="551e0b7660ec60a1ba024654ebf85dd6e11ea8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;또한보십시오:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ead3f7341c29026742f5a4b0dd3a0003a1ebcb6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THINGS TO REMEMBER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기억해야 할 것들&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e902296e6d584c43a7b6d565ce2461560a6e091" translate="yes" xml:space="preserve">
          <source>A lot has been said about Password encryption for PHP, most of which is very good advice, but before you even start the process of using PHP for password encryption make sure you have the following implemented or ready to be implemented.</source>
          <target state="translated">PHP의 암호 암호화에 대해 많은 의견이 있었지만 대부분의 경우 좋은 조언이지만 암호 암호화에 PHP를 사용하기 전에 다음을 구현하거나 구현할 준비가되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d338f3026e67ebbe13c96fce36d81cb026d9f87c" translate="yes" xml:space="preserve">
          <source>A much shorter and safer answer - &lt;strong&gt;don't write your own password mechanism at all&lt;/strong&gt;, use a tried and tested mechanism.</source>
          <target state="translated">훨씬 짧고 안전한 답변- &lt;strong&gt;비밀번호 메커니즘을 전혀 쓰지 말고&lt;/strong&gt; 검증 된 메커니즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4dd080286c78745102f80f80549cafcb94e6e124" translate="yes" xml:space="preserve">
          <source>Also make the user create a secure password, it is simple and should always be done, the user will be grateful for it in the end.</source>
          <target state="translated">또한 사용자가 보안 암호를 만들도록하십시오. 간단하고 항상 수행해야하며 결국 사용자에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="9a29f79b84bf18b505a34d003c5ea678dd34f78a" translate="yes" xml:space="preserve">
          <source>Also, double-hashing is generally regarded as bad method, because it diminishes the result space. All popular hashes are fixed-length. Thus, you can have only a finite values of this fixed length, and the results become less varied. This &lt;em&gt;could&lt;/em&gt; be regarded as another form of salting, but I wouldn't recommend it.</source>
          <target state="translated">또한 이중 해싱은 일반적으로 결과 공간이 줄어들 기 때문에 잘못된 방법으로 간주됩니다. 모든 인기있는 해시는 고정 길이입니다. 따라서이 고정 길이의 유한 값만 가질 수 있으며 결과의 변동이 줄어 듭니다. 이것은 다른 형태의 소금으로 간주 &lt;em&gt;될&lt;/em&gt; 수 있지만 권장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="47b974489931634025c710e17d5db41c06e42742" translate="yes" xml:space="preserve">
          <source>Also, should I store two fields in the database (one using MD5 and another one using SHA, for example)? Would it make it safer or unsafer?</source>
          <target state="translated">또한 데이터베이스에 두 개의 필드 (예 : MD5를 사용하는 필드와 SHA를 사용하는 필드)를 저장해야합니까? 더 안전하거나 안전하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="7689b604462baa981c885266a977b157013806aa" translate="yes" xml:space="preserve">
          <source>Always have your application have its own account to access the DB, and only give it the privileges it will need.</source>
          <target state="translated">응용 프로그램은 항상 DB에 액세스하기 위해 자신의 계정을 가지고 있어야하며 필요한 권한 만 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="3b1bb0601fe6d9e262b3597a1689b03d4b982615" translate="yes" xml:space="preserve">
          <source>Another reason that you want a good, robust hash on a user accounts is to give you enough time to change all the passwords in the system. If your database is compromised you will need enough time to at &lt;em&gt;least&lt;/em&gt; lock the system down, if not change every password in the database.</source>
          <target state="translated">사용자 계정에서 강력하고 강력한 해시를 원하는 또 다른 이유는 시스템의 모든 암호를 변경할 수있는 충분한 시간을 제공하기 위해서입니다. 데이터베이스가 손상된 경우 데이터베이스의 모든 비밀번호를 변경하지 않으면 시스템을 잠그는 데 충분한 시간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fc8b9b7b7e69aecc8d6210a0592328219dceab04" translate="yes" xml:space="preserve">
          <source>As of PHP 5.5, PHP has simple, secure functions for hashing and verifying passwords, &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash()&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;password_verify()&lt;/a&gt;</source>
          <target state="translated">PHP 5.5부터 PHP는 암호 해시 및 확인을위한 간단하고 안전한 함수, &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash ()&lt;/a&gt; 및 &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;password_verify ()를 가지고 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ea99ddf0910092b785f4db900f1d1881fb27c6a" translate="yes" xml:space="preserve">
          <source>At the moment these functions accept the PASSWORD_BCRYPT and PASSWORD_DEFAULT password constants, which are synonymous at the moment, the difference being that PASSWORD_DEFAULT &quot;may change in newer PHP releases when newer, stronger hashing algorithms are supported.&quot; Using PASSWORD_DEFAULT and password_needs_rehash() on login (and rehashing if necessary) should ensure that your hashes are reasonably resilient to brute-force attacks with little to no work for you.</source>
          <target state="translated">현재이 함수는 PASSWORD_BCRYPT 및 PASSWORD_DEFAULT 비밀번호 상수를 허용합니다. 이는 현재 동의어이며, PASSWORD_DEFAULT는 &quot;보다 새롭고 강력한 해싱 알고리즘이 지원 될 때 최신 PHP 릴리스에서 변경 될 수 있습니다.&quot; 로그인시 PASSWORD_DEFAULT 및 password_needs_rehash ()를 사용하고 (필요한 경우 리 해싱) 해시가 거의 또는 전혀 작동하지 않는 무차별 대입 공격에 합리적으로 탄력성을 갖도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bc33659ae93746ba57bab9705cc4dea91e1472b" translate="yes" xml:space="preserve">
          <source>Average practices</source>
          <target state="translated">평균 관행</target>
        </trans-unit>
        <trans-unit id="f6015c3a8cc452ac75b47eabd9579dadfdb0ffe6" translate="yes" xml:space="preserve">
          <source>Bcrypt and &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;scrypt&lt;/a&gt; are the current best practices. &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;Scrypt&lt;/a&gt; will be better than bcrypt in time, but it hasn't seen adoption as a standard by Linux/Unix or by webservers, and hasn't had in-depth reviews of its algorithm posted yet. But still, the future of the algorithm does look promising. If you are working with Ruby there is an &lt;a href=&quot;http://rubygems.org/gems/scrypt&quot;&gt;scrypt gem&lt;/a&gt; that will help you out, and Node.js now has its own &lt;a href=&quot;https://npmjs.org/package/scrypt&quot;&gt;scrypt&lt;/a&gt; package. You can use Scrypt in PHP either via the &lt;a href=&quot;https://pecl.php.net/package/scrypt&quot;&gt;Scrypt&lt;/a&gt; extension or the &lt;a href=&quot;https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md&quot;&gt;Libsodium&lt;/a&gt; extension (both are available in PECL).</source>
          <target state="translated">Bcrypt와 &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;Scrypt&lt;/a&gt; 는 현재 모범 사례입니다. &lt;a href=&quot;http://www.tarsnap.com/scrypt.html&quot;&gt;Scrypt&lt;/a&gt; 는 시간에 비해 bcrypt보다 낫지 만 Linux / Unix 또는 웹 서버에서 표준으로 채택하지 않았으며 아직 알고리즘에 대한 심층적 인 검토를하지 않았습니다. 그러나 여전히 알고리즘의 미래는 유망 해 보입니다. Ruby로 작업하는 경우 도움이되는 &lt;a href=&quot;http://rubygems.org/gems/scrypt&quot;&gt;scrypt gem&lt;/a&gt; 이 있으며 Node.js에는 자체 &lt;a href=&quot;https://npmjs.org/package/scrypt&quot;&gt;scrypt&lt;/a&gt; 패키지가 있습니다. &lt;a href=&quot;https://pecl.php.net/package/scrypt&quot;&gt;Scrypt&lt;/a&gt; 확장 또는 &lt;a href=&quot;https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md&quot;&gt;Libsodium&lt;/a&gt; 확장을 통해 PHP에서 Scrypt를 사용할 수 있습니다 (둘 다 PECL에서 사용 가능).</target>
        </trans-unit>
        <trans-unit id="eb8de9ce8757ee3c542141ac80ff3b33dc04edff" translate="yes" xml:space="preserve">
          <source>Best practices</source>
          <target state="translated">모범 사례</target>
        </trans-unit>
        <trans-unit id="2de241bdf77a55e27f8fca0e42659620a7b0aefe" translate="yes" xml:space="preserve">
          <source>But suppose that you cannot use bcrypt or PHPASS at all. What then?</source>
          <target state="translated">그러나 bcrypt 또는 PHPASS를 전혀 사용할 수 없다고 가정하십시오. 그럼 뭐야?</target>
        </trans-unit>
        <trans-unit id="117f2a5735e534774bb47e831d678f2aadc64e41" translate="yes" xml:space="preserve">
          <source>By default it used strongest available encryption that is implemented in Phpass, which is &lt;code&gt;bcrypt&lt;/code&gt; and falls back to other encryptions down to MD5 to provide backward compatibility to frameworks like Wordpress.</source>
          <target state="translated">기본적으로 Phpass에서 구현 된 가장 강력한 암호화를 사용했습니다.이 암호는 &lt;code&gt;bcrypt&lt;/code&gt; 이며 다른 암호화로 MD5로 대체 되어 Wordpress와 같은 프레임 워크와의 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b633fdfaff7ad5fc7b721447cc8831c42591c4bc" translate="yes" xml:space="preserve">
          <source>Coming in PHP 5.5 is a &lt;a href=&quot;http://php.net/manual/en/ref.password.php&quot;&gt;full password protection library&lt;/a&gt; that abstracts away any pains of working with bcrypt. While most of us are stuck with PHP 5.2 and 5.3 in most common environments, especially shared hosts, @ircmaxell has built a &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility layer&lt;/a&gt; for the coming API that is backward compatible to PHP 5.3.7.</source>
          <target state="translated">PHP 5.5는 &lt;a href=&quot;http://php.net/manual/en/ref.password.php&quot;&gt;완전한 암호 보호 라이브러리&lt;/a&gt; 로, bcrypt 작업의 어려움을 없애줍니다. @ircmaxell은 대부분의 일반적인 환경, 특히 공유 호스트에서 PHP 5.2 및 5.3을 사용하고 있지만 @ircmaxell은 PHP 5.3.7과 호환되는 향후 API에 대한 &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;호환성 계층&lt;/a&gt; 을 구축했습니다.</target>
        </trans-unit>
        <trans-unit id="af9cf1efb4bd36a869c85c6db68040652b17d4ae" translate="yes" xml:space="preserve">
          <source>Cryptography Recap &amp;amp; Disclaimer</source>
          <target state="translated">암호화 요약 및 면책</target>
        </trans-unit>
        <trans-unit id="2ef42ffab4aacba15da77cf466976e72bd80c6f0" translate="yes" xml:space="preserve">
          <source>Don't limit the length of a password. If your users want a sentence with supercalifragilisticexpialidocious in it, don't prevent them from using it.</source>
          <target state="translated">비밀번호 길이를 제한하지 마십시오. 사용자가 supercalifragilisticexpialidocious가 포함 된 문장을 원한다면 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b6a9c3be345b95b031149b5d719b84262d749a02" translate="yes" xml:space="preserve">
          <source>Don't limit what characters users can enter for passwords. Only idiots do this.</source>
          <target state="translated">사용자가 비밀번호로 입력 할 수있는 문자를 제한하지 마십시오. 바보 만이 일을합니다.</target>
        </trans-unit>
        <trans-unit id="57b8188ffa4f6ec3553dfe244191b42014f16984" translate="yes" xml:space="preserve">
          <source>Don't mix &lt;a href=&quot;http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html&quot;&gt;bcrypt and with the &lt;em&gt;raw&lt;/em&gt; output of hash()&lt;/a&gt;, either use hex output or base64_encode it. (This applies to any input that may have a rogue &lt;code&gt;\0&lt;/code&gt; in it, which can seriously weaken security.)</source>
          <target state="translated">&lt;a href=&quot;http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html&quot;&gt;bcrypt와 hash ()의 &lt;em&gt;원시&lt;/em&gt; 출력을&lt;/a&gt; 혼합하지 마십시오. 16 진수 출력 또는 base64_encode를 사용하십시오. (이는 불량 &lt;code&gt;\0&lt;/code&gt; 을 가질 수있는 모든 입력에 적용되며, 이는 보안을 심각하게 약화시킬 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="b14bcf13287ceb3241fed3d968a38802da7cb034" translate="yes" xml:space="preserve">
          <source>Don't strip or escape HTML and special characters in the password.</source>
          <target state="translated">비밀번호에서 HTML 및 특수 문자를 제거하거나 이스케이프 처리하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="093743f90c366f3346a4626e0147ea26113350c4" translate="yes" xml:space="preserve">
          <source>Don'ts</source>
          <target state="translated">Don'ts</target>
        </trans-unit>
        <trans-unit id="586c15c6fd8448116ae5a0f2e995d41e36f153b8" translate="yes" xml:space="preserve">
          <source>Dos</source>
          <target state="translated">Dos</target>
        </trans-unit>
        <trans-unit id="951e25161bf6bbd8580e18709c3c792954ee12e4" translate="yes" xml:space="preserve">
          <source>EDIT: I just realised that this is mentioned briefly in Robert K's answer. I'll leave this answer here since I think it provides a bit more information about how it works and the ease of use it provides for those who don't know security.</source>
          <target state="translated">편집 : 나는 이것이 Robert K의 대답에 간략하게 언급되어 있음을 깨달았습니다. 이 답변은 작동 방식과 보안을 모르는 사람들에게 제공하는 사용 편의성에 대해 조금 더 많은 정보를 제공한다고 생각하므로 여기에 남겨 두겠습니다.</target>
        </trans-unit>
        <trans-unit id="5aed566d3e7f4533ea18f62aa39f7cec10ce35f6" translate="yes" xml:space="preserve">
          <source>Finally, no matter the security measures you take nothing is 100% secure, the more advanced the technology to protect becomes the more advanced the attacks become. But following these steps will make your site more secure and far less desirable for attackers to go after.</source>
          <target state="translated">마지막으로, 아무 것도 취하지 않는 보안 조치가 100 % 안전하더라도 보호하는 기술이 향상 될수록 공격이 더욱 발전합니다. 그러나이 단계를 따르면 사이트를보다 안전하고 안전하게 공격자가 방문하는 것이 훨씬 바람직하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="bfdae5a79adfab1e18ea1d0102894a2dccc076bf" translate="yes" xml:space="preserve">
          <source>Follow the same guidelines as with all good passwords. Also don't reuse the same password on any SERVER or DB accounts on the same system.</source>
          <target state="translated">모든 올바른 비밀번호와 동일한 지침을 따르십시오. 또한 동일한 시스템의 SERVER 또는 DB 계정에서 동일한 비밀번호를 재사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f46f0816adc340442cfbcc816c79aadee7d62c1c" translate="yes" xml:space="preserve">
          <source>For all that is good in the world do not use the username admin, root or something similar. Also if you are on a unix based system DO NOT make the root account login accessible, it should always be sudo only.</source>
          <target state="translated">세계에서 좋은 모든 사용자 이름 admin, root 또는 이와 유사한 것을 사용하지 마십시오. 또한 유닉스 기반 시스템을 사용하는 경우 루트 계정 로그인에 액세스 할 수 없도록 설정하면 항상 sudo 전용이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d9ea1176666f5e2cfe77b291548afa7d1dd3e910" translate="yes" xml:space="preserve">
          <source>For example, you can &lt;a href=&quot;http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/&quot;&gt;crack all 8-character Windows passwords in 6 hours&lt;/a&gt; using 25 GPUs installed in 5 desktop PCs.  This is brute-forcing i.e. enumerating and checking &lt;em&gt;every 8-character Windows password&lt;/em&gt;, including special characters, and is not a dictionary attack. That was in 2012, as of 2018 you could use fewer GPUs, or crack faster with 25 GPUs.</source>
          <target state="translated">예를 들어, 5 대의 데스크탑 PC에 설치된 25 개의 GPU를 사용하여 &lt;a href=&quot;http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/&quot;&gt;6 시간 안에 8 자의 Windows 암호를 모두 해독&lt;/a&gt; 할 수 있습니다. 이는 특수 문자를 포함하여 &lt;em&gt;모든 8 자 Windows 암호를&lt;/em&gt; 열거하고 확인하는 무차별 강제이며 사전 공격이 아닙니다. 2018 년 기준으로, 2018 년 현재 GPU를 더 적게 사용하거나 25 개의 GPU로 더 빨리 크랙 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5638ccd08221ca60e74b51eedce8f8691850aa0d" translate="yes" xml:space="preserve">
          <source>Future Practices</source>
          <target state="translated">미래의 관행</target>
        </trans-unit>
        <trans-unit id="8cdb7a0b3b6ace5e886174a72b1782806543e80f" translate="yes" xml:space="preserve">
          <source>Google says SHA256 is available to PHP.</source>
          <target state="translated">구글은 SHA256이 PHP에서 사용 가능하다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="6dfd63230af2892f2f367f0290c4dfd849f7dc6a" translate="yes" xml:space="preserve">
          <source>Here is a PHP class that creates a hash and salt for a password easily</source>
          <target state="translated">다음은 비밀번호에 쉽게 해시와 솔트를 생성하는 PHP 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d3de020d4de5c9ec8acb08596101993264195d55" translate="yes" xml:space="preserve">
          <source>How would you implement salted passwords in Tomcat 5.5</source>
          <target state="translated">Tomcat 5.5에서 소금에 절인 암호를 어떻게 구현 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="094dfed6a03363f271cb6e9eb1fbbe95ffe3f66b" translate="yes" xml:space="preserve">
          <source>I almost can't imagine this situation anymore. &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt; supports PHP 3.0.18 through 5.3, so it is usable on almost every installation imaginable&amp;mdash;and should be used if you don't &lt;em&gt;know for certain&lt;/em&gt; that your environment supports bcrypt.</source>
          <target state="translated">나는 더 이상이 상황을 거의 상상할 수 없다. &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt; 는 PHP 3.0.18부터 5.3까지 지원하므로 상상할 수있는 거의 모든 설치에서 사용할 수 있으며 환경에서 bcrypt를 지원하는지 &lt;em&gt;확실&lt;/em&gt; 하지 않은 경우 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7427fce65bccc8329b93c08c2c177aa8d900929" translate="yes" xml:space="preserve">
          <source>I changed my mind about using bcrypt when I learned that bcrypt only uses blowfish's key schedule, with a variable cost mechanism. The latter lets you increase the cost to brute-force a password by increasing blowfish's already expensive key schedule.</source>
          <target state="translated">나는 bcrypt가 가변 비용 메커니즘과 함께 복어의 주요 일정 만 사용한다는 것을 알았을 때 bcrypt 사용에 대한 마음을 바꿨습니다. 후자는 복어의 이미 비싼 키 일정을 늘려 암호를 무차별 처리하는 비용을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="74d1dec78ea1f0d88fb883d96450938d3cd9d96d" translate="yes" xml:space="preserve">
          <source>I found perfect topic on this matter here: &lt;a href=&quot;https://crackstation.net/hashing-security.htm&quot;&gt;https://crackstation.net/hashing-security.htm&lt;/a&gt;, I wanted you to get benefit from it, here is source code also that provided prevention against time-based attack also.</source>
          <target state="translated">&lt;a href=&quot;https://crackstation.net/hashing-security.htm&quot;&gt;https://crackstation.net/hashing-security.htm&lt;/a&gt; 에서이 문제에 대한 완벽한 주제를 찾았습니다. 여기서 이점을 얻고 싶었습니다. 시간 기반 공격에 대한 예방도 제공하는 소스 코드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="878b969cae5ef5b116676174f4bba610ac895913" translate="yes" xml:space="preserve">
          <source>I highly suggest reading the documentation for the &lt;a href=&quot;http://us.php.net/crypt&quot;&gt;crypt function&lt;/a&gt; if you want to understand how to use bcrypt, or finding yourself a &lt;a href=&quot;https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021&quot;&gt;good&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/1070401&quot;&gt;wrapper&lt;/a&gt; or use something like &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt; for a more legacy implementation. I recommend a minimum of 12 rounds of bcrypt, if not 15 to 18.</source>
          <target state="translated">bcrypt를 사용하는 방법을 이해하거나 &lt;a href=&quot;https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021&quot;&gt;좋은&lt;/a&gt; &lt;a href=&quot;https://gist.github.com/1070401&quot;&gt;래퍼를&lt;/a&gt; 찾거나보다 기존 구현을 위해 &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;PHPASS&lt;/a&gt; 와 같은 것을 사용하려면 &lt;a href=&quot;http://us.php.net/crypt&quot;&gt;crypt 함수에&lt;/a&gt; 대한 설명서를 읽는 것이 좋습니다. 15 ~ 18이 아닌 경우 최소 12 라운드의 bcrypt를 권장합니다.</target>
        </trans-unit>
        <trans-unit id="3acd6228038caf8487300f27ba32f185e5efc8f9" translate="yes" xml:space="preserve">
          <source>I just want to point out that PHP 5.5 includes a &lt;a href=&quot;http://www.php.net/manual/en/ref.password.php&quot;&gt;password hashing API&lt;/a&gt; that provides a wrapper around &lt;code&gt;crypt()&lt;/code&gt;. This API significantly simplifies the task of hashing, verifying and rehashing password hashes. The author has also released a &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility pack&lt;/a&gt; (in the form of a single password.php file that you simply &lt;code&gt;require&lt;/code&gt; to use), for those using PHP 5.3.7 and later and want to use this right now.</source>
          <target state="translated">PHP 5.5에 &lt;code&gt;crypt()&lt;/code&gt; 주위에 래퍼를 제공하는 &lt;a href=&quot;http://www.php.net/manual/en/ref.password.php&quot;&gt;암호 해싱 API&lt;/a&gt; 가 포함되어 있음을 지적하고 싶습니다. 이 API는 암호 해시 해시, 확인 및 재해시 작업을 크게 단순화합니다. 필자는 PHP 5.3.7 이상을 사용하는 사용자를 &lt;code&gt;require&lt;/code&gt; &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;호환성 팩&lt;/a&gt; (단일 사용하기 만하면되는 단일 password.php 파일의 형태)을 출시했으며 지금이 기능을 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="021bc86837c1cf4ede09646fe8929f5646deb92f" translate="yes" xml:space="preserve">
          <source>I usually use SHA1 and salt with the user ID (or some other user-specific piece of information), and sometimes I additionally use a constant salt (so I have 2 parts to the salt).</source>
          <target state="translated">나는 보통 사용자 ID (또는 다른 사용자 특정 정보)와 함께 SHA1과 소금을 사용하고 때로는 일정한 소금을 사용합니다 (따라서 소금에 2 부분이 있습니다).</target>
        </trans-unit>
        <trans-unit id="1bc7ca4a9003d758e3158a03983889340d7b0ef9" translate="yes" xml:space="preserve">
          <source>I would not store the password hashed in two different ways, because then the system is at least as weak as the weakest of the hash algorithms in use.</source>
          <target state="translated">암호 해시를 두 가지 방법으로 저장하지 않을 것입니다. 시스템이 사용중인 해시 알고리즘 중 가장 약한 것보다 약하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="462230903f4568427872db9e53f5786cbc3b5e7d" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;Phpass&lt;/a&gt; which is a simple one-file PHP class that could be implemented very easily in nearly every PHP project. See also &lt;a href=&quot;http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4&quot;&gt;The H&lt;/a&gt;.</source>
          <target state="translated">필자는 거의 모든 PHP 프로젝트에서 매우 쉽게 구현할 수있는 간단한 단일 파일 PHP 클래스 인 &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;Phpass&lt;/a&gt; 를 사용하고 있습니다. &lt;a href=&quot;http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4&quot;&gt;H&lt;/a&gt; 참조.</target>
        </trans-unit>
        <trans-unit id="2e7956166ff653d061a0f1fee8e6d1f242bac81e" translate="yes" xml:space="preserve">
          <source>I'm using PHP. I want a safe and fast password encryption system. Hashing a password a million times may be safer, but also slower. How to achieve a good balance between speed and safety? Also, I'd prefer the result to have a constant number of characters.</source>
          <target state="translated">PHP를 사용하고 있습니다. 안전하고 빠른 비밀번호 암호화 시스템을 원합니다. 암호를 백만 번 해싱하는 것이 더 안전하지만 느려질 수 있습니다. 속도와 안전의 균형을 잘 유지하는 방법은 무엇입니까? 또한 결과가 일정한 수의 문자를 갖는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="6ff2c27f72547e5d2b06a5581aa37280ccb6a8db" translate="yes" xml:space="preserve">
          <source>Ideally you want your DB and APPLICATION on separate servers. This is not always possible due to cost, but it does allow for some safety as the attacker will have to go through two steps to fully access the system.</source>
          <target state="translated">DB와 APPLICATION을 별도의 서버에 두는 것이 이상적입니다. 비용 때문에 항상 가능한 것은 아니지만 공격자가 시스템에 완전히 액세스하려면 두 단계를 거쳐야하기 때문에 약간의 안전이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a9162bbf805570c30c3008fac626548ad008226" translate="yes" xml:space="preserve">
          <source>If the user is creating a password through the frontend that means it has to be sent to the server. This opens up a security issue because that means the unencrypted password is being sent to the server and if a attacker is able to listen and access that all your security in PHP is worthless. ALWAYS transmit the data SECURELY, this is done through SSL, but be weary even SSL is not flawless (OpenSSL's Heartbleed flaw is an example of this).</source>
          <target state="translated">사용자가 프론트 엔드를 통해 비밀번호를 작성하는 경우 서버로 비밀번호를 보내야합니다. 이것은 암호화되지 않은 암호가 서버로 전송되고 공격자가 PHP의 모든 보안을 듣고 쓸 수 없다면 보안 문제를 야기합니다. 항상 데이터를 안전하게 전송하십시오. 이것은 SSL을 통해 이루어 지지만 SSL이 완벽하지 않더라도 지칠 수 있습니다 (OpenSSL의 Heartbleed 결함이 그 예입니다).</target>
        </trans-unit>
        <trans-unit id="bfdaf953c79a7a6b68bb4199d7beacdee227846d" translate="yes" xml:space="preserve">
          <source>Implement a reasonable 8-10 character minimum length, plus require at least 1 upper case letter, 1 lower case letter, a number, and a symbol. This will improve the entropy of the password, in turn making it harder to crack. (See the &quot;What makes a good password?&quot; section for some debate.)</source>
          <target state="translated">8 ~ 10 자 이상의 적절한 길이를 구현하고 최소 1 개의 대문자, 1 개의 소문자, 숫자 및 기호가 필요합니다. 암호의 엔트로피가 향상되어 암호 해독이 어려워집니다. (일부 토론에 대해서는 &quot;무엇이 좋은 암호를 만드는가?&quot;섹션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="db36d1a15c2eff2b9e586d75be21da1c305b8b6a" translate="yes" xml:space="preserve">
          <source>In case I wasn't clear enough, I want to know which hashing function(s) to use and how to pick a good salt in order to have a safe and fast password protection mechanism.</source>
          <target state="translated">충분히 명확하지 않은 경우 안전하고 빠른 암호 보호 메커니즘을 사용하기 위해 사용할 해싱 기능과 좋은 소금을 선택하는 방법을 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="4d685a0e94f3eab6cfef426e115b55c6d2ecd20c" translate="yes" xml:space="preserve">
          <source>In short, entropy is how much variation is within the password. When a password is only lowercase roman letters, that's only 26 characters. That isn't much variation. Alpha-numeric passwords are better, with 36 characters. But allowing upper and lower case, with symbols, is roughly 96 characters. That's a lot better than just letters. One problem is, to make our passwords memorable we insert patterns&amp;mdash;which reduces entropy. Oops!</source>
          <target state="translated">요컨대, 엔트로피는 암호 내에 얼마나 많은 변형이 있는지입니다. 암호가 소문자 로마자이면 26 자입니다. 큰 차이는 없습니다. 영숫자 암호는 36 자로 더 좋습니다. 그러나 기호와 함께 대소 문자를 허용하는 것은 대략 96 자입니다. 그것은 편지보다 훨씬 낫습니다. 한 가지 문제는 암호를 기억하기 쉽게하기 위해 엔트로피를 줄이는 패턴을 삽입하는 것입니다. 죄송합니다!</target>
        </trans-unit>
        <trans-unit id="f5c756bd1a76be361873a30bd1bd4190227c361c" translate="yes" xml:space="preserve">
          <source>In the comments I talked with @popnoodles, who pointed out that &lt;em&gt;enforcing&lt;/em&gt; a password policy of X length with X many letters, numbers, symbols, etc, can actually reduce entropy by making the password scheme more predictable. I do agree. Randomess, as truly random as possible, is always the safest but least memorable solution.</source>
          <target state="translated">@ popnoodles와의 의견에서 X 문자의 암호 정책을 X 문자, 숫자, 기호 등으로 적용하면 암호 체계를보다 예측 가능하게하여 실제로 엔트로피를 줄일 수 있다고 지적한 의견입니다. 동의합니다. 랜덤은 가능한 한 무작위로 항상 가장 안전하지만 가장 기억에 남는 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="b0a50c178288b0e09504dc0a677b514cf240abd4" translate="yes" xml:space="preserve">
          <source>In the end, double-hashing, mathematically, provides no benefit.  In practice, however, it is useful for preventing rainbow table-based attacks.  In other words, it is of no more benefit than hashing with a salt, which takes far less processor time in your application or on your server.</source>
          <target state="translated">결국, 이중 해싱은 수학적으로 아무런 이점을 제공하지 않습니다. 그러나 실제로는 레인보우 테이블 기반 공격을 방지하는 데 유용합니다. 다시 말해, 애플리케이션이나 서버에서 프로세서 시간이 훨씬 적게 걸리는 솔트를 사용한 해싱보다 더 큰 이점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d25865b4d6182316faf089b42e9c22a190d279b" translate="yes" xml:space="preserve">
          <source>Increasing cost (which defaults to 10) makes the hash harder to brute-force but also means generating hashes and verifying passwords against them will be more work for your server's CPU.</source>
          <target state="translated">비용을 높이면 (기본값은 10) 해시는 무차별 대입이 어려워 지지만 해시를 생성하고 이에 대한 암호를 확인하면 서버의 CPU에서 더 많은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3819c766e1a237afa339d1b32fb8107d612fcdd2" translate="yes" xml:space="preserve">
          <source>Interestingly, in living out this nightmare, I learned A LOT I didn&amp;rsquo;t know about password cracking, storage, and complexity. &lt;em&gt;I&amp;rsquo;ve come to appreciate why password storage is ever so much more important than password complexity. If you don&amp;rsquo;t know how your password is stored, then all you really can depend upon is complexity.&lt;/em&gt; This might be common knowledge to password and crypto pros, but for the average InfoSec or Web Security expert, I highly doubt it.</source>
          <target state="translated">흥미롭게도,이 악몽을 극복하면서 암호 해독, 저장 및 복잡성에 대해 몰랐던 많은 것을 배웠습니다. &lt;em&gt;암호 저장이 암호 복잡성보다 훨씬 중요한 이유에 대해 알게되었습니다.&lt;/em&gt; &lt;em&gt;암호가 어떻게 저장되는지 모르는 경우 복잡 할 수 있습니다.&lt;/em&gt; 이것은 암호 및 암호 전문가에게는 일반적인 지식 일 수 있지만 일반적인 InfoSec 또는 웹 보안 전문가에게는 의심의 여지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="32aace1e6bd9db8789604b5d77b5b357f1a03eeb" translate="yes" xml:space="preserve">
          <source>It can use salt (in this case, are all salts equally good? Is there any way to generate good salts?)</source>
          <target state="translated">소금을 사용할 수 있습니다 (이 경우 모든 소금이 똑같이 좋습니까? 좋은 소금을 생성하는 방법이 있습니까?)</target>
        </trans-unit>
        <trans-unit id="76532b90f399c161d14466cd2bb1c1a7e08c404d" translate="yes" xml:space="preserve">
          <source>It is currently said that MD5 is partially unsafe. Taking this into consideration, I'd like to know which mechanism to use for password protection.</source>
          <target state="translated">현재 MD5는 부분적으로 안전하지 않다고합니다. 이것을 고려하여 암호 보호에 사용할 메커니즘을 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="ec687b6fd5c605eabd26943ffe28b1856e82a532" translate="yes" xml:space="preserve">
          <source>It must be safe</source>
          <target state="translated">안전해야합니다</target>
        </trans-unit>
        <trans-unit id="2deed719274cbd038881d457f177804efb08bba8" translate="yes" xml:space="preserve">
          <source>It only supports BCRYPT for now, but it aims to be easily extended to include other password hashing techniques and because the technique and cost is stored as part of the hash, changes to your prefered hashing technique/cost will not invalidate current hashes, the framework will automagically, use the correct technique/cost when validating. It also handles generating a &quot;secure&quot; salt if you do not explicitly define your own.</source>
          <target state="translated">현재는 BCRYPT 만 지원하지만 다른 암호 해싱 기술을 포함하도록 쉽게 확장하는 것이 목표이며 기술과 비용이 해시의 일부로 저장되므로 원하는 해싱 기술 / 비용을 변경해도 현재 해시, 프레임 워크가 무효화되지 않습니다. 자동으로 검증 할 때 올바른 기술 / 비용을 사용합니다. 또한 명시 적으로 자신을 정의하지 않은 경우 &quot;보안&quot;소금 생성을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fbfb86f18fa274ab0a5bfb0be1ee04f715779f9f" translate="yes" xml:space="preserve">
          <source>Jeremiah Grossman, CTO of Whitehat Security, &lt;a href=&quot;https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/&quot;&gt;stated on White Hat Security blog&lt;/a&gt; after a recent password recovery that required brute-force breaking of his password protection:</source>
          <target state="translated">Whitehat Security의 CTO 인 Jeremiah Grossman은 최근 비밀번호 복구 후 비밀번호 보호를 무차별 적으로 차단해야하는 &lt;a href=&quot;https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/&quot;&gt;White Hat Security 블로그에&lt;/a&gt; 다음과 같이 언급했습니다 .</target>
        </trans-unit>
        <trans-unit id="a1b0239b75a0a79e1923e96b83331042b6c1cfea" translate="yes" xml:space="preserve">
          <source>Lastly: I am not a cryptographer. Whatever I've said is my opinion, but I happen to think it's based on good ol' common sense ... and lots of reading. Remember, be as paranoid as possible, make things as hard to intrude as possible, and then, if you are still worried, contact a white-hat hacker or cryptographer to see what they say about your code/system.</source>
          <target state="translated">마지막으로 : 나는 암호 전문가가 아닙니다. 내가 말한 것은 내 의견이지만, 그것이 좋은 상식과 많은 독서에 근거한다고 생각합니다. 가능한 한 편집증을 가지고 가능한 한 침입을 어렵게 한 다음, 여전히 걱정이된다면 화이트 햇 해커 나 암호 전문가에게 연락하여 코드 / 시스템에 대해 어떻게 말하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c3fdfe95f7d84ea072335ae939def14083cede1e" translate="yes" xml:space="preserve">
          <source>Like always DO NOT make this root or something similar.</source>
          <target state="translated">항상이 루트 나 비슷한 것을 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8272783154610ed637003d484b1ab9e70499174f" translate="yes" xml:space="preserve">
          <source>More explanation is available at- &lt;a href=&quot;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&quot;&gt;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&lt;/a&gt;</source>
          <target state="translated">자세한 설명은 &lt;a href=&quot;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/&quot;&gt;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/에서 확인할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccbd82ab1462c38ff0a96c985a99ed1447b09ef0" translate="yes" xml:space="preserve">
          <source>Most programmers just don't have the expertise to write crypto related code safely without introducing vulnerabilities.</source>
          <target state="translated">대부분의 프로그래머에게는 취약점을 도입하지 않고 암호화 관련 코드를 안전하게 작성할 수있는 전문 지식이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4b758984e383af744fd6b70d1a44453fe5d02d5" translate="yes" xml:space="preserve">
          <source>NEVER EVER store a password in your DB, instead store the hash and unique salt, I will explain why later.</source>
          <target state="translated">절대로 DB에 암호를 저장하지 말고 해시와 고유 한 소금을 저장하지 마십시오. 나중에 이유를 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="b668a4bf2c2b13fda6ea44b2604e7cb52f134d07" translate="yes" xml:space="preserve">
          <source>Never email a password to your user &lt;em&gt;except when they have lost theirs, and you sent a temporary one.&lt;/em&gt;</source>
          <target state="translated">비밀번호를 &lt;em&gt;분실 한 경우를 제외하고&lt;/em&gt; 사용자에게 비밀번호를 이메일로 보내지 말고 &lt;em&gt;임시&lt;/em&gt; 비밀번호를 &lt;em&gt;보냈습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a05bf77552bc683c933754926449ac35cd64a670" translate="yes" xml:space="preserve">
          <source>Never hash passwords with &lt;a href=&quot;http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/&quot;&gt;SHA1&lt;/a&gt; or MD5 or even SHA256! &lt;a href=&quot;http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/&quot;&gt;Modern crackers&lt;/a&gt; can exceed 60 and 180 billion hashes/second (respectively).</source>
          <target state="translated">&lt;a href=&quot;http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/&quot;&gt;SHA1&lt;/a&gt; 또는 MD5 또는 심지어 SHA256으로 비밀번호를 해시하지 마십시오! &lt;a href=&quot;http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/&quot;&gt;현대 크래커&lt;/a&gt; 는 (각각) 초당 60-180 억 해시를 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8ba9091576887aa8ba6c61d6c8d8e6d54342993" translate="yes" xml:space="preserve">
          <source>Never store your user's password in plain-text.</source>
          <target state="translated">사용자의 비밀번호를 일반 텍스트로 저장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e583d29870e1092a65f27803157c2c1944f2e8dd" translate="yes" xml:space="preserve">
          <source>Never, ever log passwords in any manner.</source>
          <target state="translated">절대 어떤 식 으로든 비밀번호를 기록하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b0dd8e37f7458d33cf378742fcb833eb6f03eaa4" translate="yes" xml:space="preserve">
          <source>No matter how good your encryption is if you don't properly secure the server that runs the PHP and DB all your efforts are worthless. Most servers function relatively the same way, they have ports assigned to allow you to access them remotely either through ftp or shell. Make sure that you change the default port of which ever remote connection you have active. By not doing this you in effect have made the attacker do one less step in accessing your system.</source>
          <target state="translated">PHP와 DB를 실행하는 서버를 제대로 보호하지 않으면 암호화 성능이 아무리 우수하더라도 모든 노력이 가치가 없습니다. 대부분의 서버는 상대적으로 동일한 방식으로 작동하며, 포트는 ftp 또는 셸을 통해 원격으로 액세스 할 수 있도록 할당되어 있습니다. 원격 연결이 활성화 된 기본 포트를 변경해야합니다. 이 작업을 수행하지 않으면 침입자가 시스템에 액세스 할 때 한 단계 더 적은 작업을 수행하게됩니다.</target>
        </trans-unit>
        <trans-unit id="a0316a87f5c5e013f52649e477f4e70dd3e0acba" translate="yes" xml:space="preserve">
          <source>Note that even though the default hashing algorithm may change, old hashes will continue to verify just fine because the algorithm used is stored in the hash and &lt;code&gt;password_verify()&lt;/code&gt; picks up on it.</source>
          <target state="translated">기본 해싱 알고리즘이 변경 될 수 있지만 사용 된 알고리즘이 해시에 저장되고 &lt;code&gt;password_verify()&lt;/code&gt; 선택하기 때문에 이전 해시는 계속해서 잘 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="2008200dd1969bed81cd881c21332864a96d99ae" translate="yes" xml:space="preserve">
          <source>ONE WAY HASHING!!!!!!!, Never hash a password in a way that it can be reversed, Hashes should be one way, meaning you don't reverse them and compare them to the password, you instead hash the entered password the same way and compare the two hashes. This means that even if an attacker gets access to the DB he doesn't know what the actually password is, just its resulting hash. Which means more security for your users in the worst possible scenario.</source>
          <target state="translated">단방향 해싱 !!!!!!!, 비밀번호를 되돌릴 수있는 방식으로 비밀번호를 해시하지 마십시오. 해시는 비밀번호를 반대로 바꾸지 않고 비밀번호와 비교하지 않고 비밀번호를 해시하지 않아야한다는 것을 의미합니다. 같은 방법으로 두 해시를 비교하십시오. 즉, 침입자가 DB에 액세스하더라도 실제 암호가 무엇인지 모르고 결과 해시 만 알 수 있습니다. 이는 최악의 시나리오에서 사용자에게 더 많은 보안을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="702aaf71948af0b0b28598e8e00fec24cf4962f6" translate="yes" xml:space="preserve">
          <source>Older PHP versions: OpenWall's &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;phpass&lt;/a&gt; library is much better than most custom code - used in WordPress, Drupal, etc.</source>
          <target state="translated">이전 PHP 버전 : OpenWall의 &lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;phpass&lt;/a&gt; 라이브러리는 WordPress, Drupal 등에 사용되는 대부분의 사용자 정의 코드보다 훨씬 낫습니다.</target>
        </trans-unit>
        <trans-unit id="bc886b63ca3b0eb383c458da407e533fe3d56755" translate="yes" xml:space="preserve">
          <source>One of the most common mistakes in hashing is that hashes are not unique to the users. This is mainly because salts are not uniquely generated.</source>
          <target state="translated">해싱에서 가장 일반적인 실수 중 하나는 해시가 사용자에게 고유하지 않다는 것입니다. 이것은 주로 소금이 고유하게 생성되지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c2385fa123d6a9984b6b1eddc74522697f2d9f20" translate="yes" xml:space="preserve">
          <source>P.s. for last 2 steps you can use your own algorithm...
but be sure that you can generate this hashed password in the future 
when you need to authorize user...</source>
          <target state="translated">마지막 2 단계의 PS는 자신의 알고리즘을 사용할 수 있지만 나중에 사용자에게 권한을 부여해야 할 때이 해시 암호를 생성 할 수 있는지 확인하십시오 ...</target>
        </trans-unit>
        <trans-unit id="7d080faa12a8ba859c71e8cfa04be086436076bf" translate="yes" xml:space="preserve">
          <source>PHP 5.5 or higher: &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash()&lt;/a&gt; is good quality and part of PHP core.</source>
          <target state="translated">PHP 5.5 이상 : &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;password_hash ()&lt;/a&gt; 는 좋은 품질이며 PHP 코어의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="e441ae84ae0663d1c0b2f38792b0dada2e5cf183" translate="yes" xml:space="preserve">
          <source>Password entropy is &lt;a href=&quot;https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/&quot;&gt;approximated&lt;/a&gt; easily. Using the full range of ascii characters (roughly 96 typeable characters) yields an entropy of 6.6 per character, which at 8 characters for a password is still too low (52.679 bits of entropy) for future security. But the good news is: longer passwords, and passwords with unicode characters, really increase the entropy of a password and make it harder to crack.</source>
          <target state="translated">암호 엔트로피는 쉽게 &lt;a href=&quot;https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/&quot;&gt;근사&lt;/a&gt; 됩니다. 전체 범위의 ASCII 문자 (대략 96 자 입력 가능 문자)를 사용하면 문자 당 6.6의 엔트로피가 생성되며, 암호의 경우 8 자에서 미래 보안을 위해 여전히 너무 낮습니다 (52.679 비트의 엔트로피) 그러나 좋은 소식은 더 긴 암호와 유니 코드 문자가있는 암호는 실제로 암호의 엔트로피를 높이고 해독하기가 더 어렵다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f90138bce65ffdcace9e2bb19f7963c1bd536d2" translate="yes" xml:space="preserve">
          <source>Passwords should always be salted before hashed. Salting adds a random string to the password so similar passwords don't appear the same in the DB. However if the salt is not unique to each user (ie: you use a hard coded salt) than you pretty much have made your salt worthless. Because once an attacker figures out one password salt he has the salt for all of them.</source>
          <target state="translated">비밀번호는 해시하기 전에 항상 소금에 절 여야합니다. Salting은 암호에 임의의 문자열을 추가하므로 DB에서 유사한 암호가 동일하게 표시되지 않습니다. 그러나 소금이 각 사용자에게 고유하지 않은 경우 (즉, 하드 코딩 된 소금을 사용하는 경우) 소금을 무가치하게 만든 것보다 많이 사용합니다. 일단 공격자가 하나의 암호 소금을 알아 내기 때문에 모든 암호 소금이 있습니다.</target>
        </trans-unit>
        <trans-unit id="48845b9c00008f76810e059c640d17fa100ba624" translate="yes" xml:space="preserve">
          <source>Providing the &lt;code&gt;PASSWORD_DEFAULT&lt;/code&gt; instructs PHP to use the default hashing algorithm of the installed version of PHP. Exactly which algorithm that means is intended to change over time in future versions, so that it will always be one of the strongest available algorithms.</source>
          <target state="translated">&lt;code&gt;PASSWORD_DEFAULT&lt;/code&gt; 를 제공하면 설치된 PHP 버전의 기본 해싱 알고리즘을 사용하도록 PHP에 지시합니다. 정확히 어떤 알고리즘을 의미하는지는 이후 버전에서 시간이 지남에 따라 변경되어 항상 가장 강력한 알고리즘 중 하나가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="dd1d5612b63f3e6527355deb1eb2e9ab4b7c8d4c" translate="yes" xml:space="preserve">
          <source>Recently I had a discussion whether password hashes salted with random
  bits are more secure than the one salted with guessable or known
  salts. Let&amp;rsquo;s see: If the system storing password is compromised as
  well as the system which stores the random salt, the attacker will
  have access to hash as well as salt, so whether the salt is random or
  not, doesn&amp;rsquo;t matter. The attacker will can generate pre-computed
  rainbow tables to crack the hash. Here comes the interesting part- it
  is not so trivial to generate pre-computed tables. Let us take example
  of WPA security model. Your WPA password is actually never sent to
  Wireless Access Point. Instead, it is hashed with your SSID (the
  network name- like Linksys, Dlink etc). A very good explanation of how
  this works is here. In order to retrieve password from hash, you will
  need to know the password as well as salt (network name). Church of
  Wifi has already pre-computed hash tables which has top 1000 SSIDs and
  about 1 million passwords. The size is of all tables is about 40 GB.
  As you can read on their site, someone used 15 FGPA arrays for 3 days
  to generate  these tables. Assuming victim is using the SSID as
  &amp;ldquo;a387csf3&amp;Prime; and password as &amp;ldquo;123456&amp;Prime;, will it be cracked by those
  tables? No! .. it cannot. Even if the password is weak, the tables
  don&amp;rsquo;t have hashes for SSID a387csf3.  This is the beauty of having
  random salt. It will deter crackers who thrive upon pre-computed
  tables. Can it stop a determined hacker? Probably not. But using
  random salts does provide additional layer of defense. While we are on
  this topic, let us discuss additional advantage of storing random
  salts on a separate system. Scenario #1 : Password hashes are stored
  on system X and salt values used for hashing are stored on system Y.
  These salt values are guessable or known (e.g. username) Scenario#2 :
  Password hashes are stored on system X and salt values used for
  hashing are stored on system Y. These salt values are random. In case
  system X has been compromised, as you can guess, there is a huge
  advantage of using random salt on a separate system (Scenario #2) .
  The attacker will need to guess addition values to be able to crack
  hashes. If a 32 bit salt is used, 2^32= 4,294,967,296 (about 4.2
  billion) iterations will can be required for each password guessed.</source>
          <target state="translated">최근에 무작위 비트로 소금에 절인 암호 해시가 추측 가능하거나 알려진 소금으로 소금에 절인 암호 해시보다 더 안전한지에 대한 토론이있었습니다. 보자 : 무작위 소금을 저장하는 시스템뿐만 아니라 암호를 저장하는 시스템이 손상되면 공격자는 소금이 무작위이든 아니든 상관없이 해시와 소금에 액세스 할 수 있습니다. 공격자는 미리 계산 된 레인보우 테이블을 생성하여 해시를 해독 할 수 있습니다. 흥미로운 부분이 있습니다. 미리 계산 된 테이블을 생성하는 것은 그리 쉬운 일이 아닙니다. WPA 보안 모델을 예로 들어 보겠습니다. WPA 암호는 실제로 무선 액세스 포인트로 전송되지 않습니다. 대신 SSID (Linksys, Dlink 등의 네트워크 이름)로 해시됩니다. 이것이 어떻게 작동하는지에 대한 아주 좋은 설명이 여기 있습니다. 해시에서 비밀번호를 검색하려면 비밀번호와 솔트 (네트워크 이름)를 알아야합니다. Church of Wifi는 이미 1000 개의 상위 SSID와 약 1 백만 개의 암호를 가진 사전 계산 된 해시 테이블을 가지고 있습니다. 모든 테이블의 크기는 약 40GB입니다. 사이트에서 읽을 수 있듯이 누군가가 3 일 동안 15 개의 FGPA 어레이를 사용하여 이러한 테이블을 생성했습니다. 피해자가 SSID를 &quot;a387csf3&quot;로 사용하고 암호를 &quot;123456&quot;으로 사용한다고 가정하면 해당 테이블에 의해 크랙됩니까? 아니! .. 그럴 순 없어. 암호가 약하더라도 테이블에 SSID a387csf3에 대한 해시가 없습니다. 이것이 무작위 소금의 아름다움입니다. 사전 계산 테이블에서 번성하는 크래커를 막을 것입니다. 결정된 해커를 막을 수 있습니까? 아마 아닙니다. 그러나 무작위 소금을 사용하면 추가적인 방어 층이 제공됩니다. 우리가이 주제에있는 동안, 임의의 소금을 별도의 시스템에 저장하는 추가 이점에 대해 논의 해 보자. 시나리오 # 1 : 비밀번호 해시는 시스템 X에 저장되고 해싱에 사용 된 솔트 값은 시스템 Y에 저장됩니다. 이러한 솔트 값은 추측 가능하거나 알려져 있습니다 (예 : 사용자 이름) 시나리오 # 2 : 비밀번호 해시는 시스템 X에 저장되며 솔트 값은 해싱은 시스템 Y에 저장됩니다. 이러한 솔트 값은 임의적입니다. 추측 할 수 있듯이 시스템 X가 손상된 경우 별도의 시스템 (시나리오 # 2)에서 랜덤 솔트를 사용하면 큰 이점이 있습니다. 공격자는 해시를 해독 할 수 있도록 추가 값을 추측해야합니다. 32 비트 솔트를 사용하는 경우 추측되는 각 비밀번호마다 2 ^ 32 = 4,294,967,296 (약 42 억 건)의 반복이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29cf51326e60ca7639ae8d61993a3e6af0924dbd" translate="yes" xml:space="preserve">
          <source>Reset everyone's passwords when the database is compromised.</source>
          <target state="translated">데이터베이스가 손상되면 모든 사람의 비밀번호를 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="99aba45ee7f729f62087c2a073d856536cd76908" translate="yes" xml:space="preserve">
          <source>SHA1 is now also considered somewhat compromised, but to a far lesser degree than MD5.  By using a salt (any salt), you're preventing the use of a generic &lt;a href=&quot;http://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;rainbow table&lt;/a&gt; to attack your hashes (some people have even had success using Google as a sort of rainbow table by searching for the hash).  An attacker could conceivably generate a rainbow table using your salt, so that's why you should include a user-specific salt.  That way, they will have to generate a rainbow table for each and every record in your system, not just one for your entire system!  With that type of salting, even MD5 is decently secure.</source>
          <target state="translated">SHA1은 이제 다소 손상되었지만 MD5보다 훨씬 낮은 수준으로 간주됩니다. 소금 (모든 소금)을 사용하면 해시를 공격하기 위해 일반 &lt;a href=&quot;http://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;레인보우 테이블&lt;/a&gt; 을 사용하지 못하게됩니다 (일부 사람들은 해시를 검색하여 일종의 레인보우 테이블로 Google을 사용하는 경우도있었습니다). 공격자는 소금을 사용하여 무지개 테이블을 생성 할 수 있으므로 사용자 별 소금을 포함시켜야합니다. 이렇게하면 전체 시스템에 대한 것이 아니라 시스템의 모든 레코드에 대해 레인보우 테이블을 생성해야합니다! 이러한 유형의 염분을 사용하면 MD5조차도 상당히 안전합니다.</target>
        </trans-unit>
        <trans-unit id="4eda4093b78a303b74d4192d587dca2314fa4169" translate="yes" xml:space="preserve">
          <source>Secure hash and salt for PHP passwords</source>
          <target state="translated">PHP 암호를위한 안전한 해시 및 솔트</target>
        </trans-unit>
        <trans-unit id="f11fa153ab1a9133bcbd4157363d3c3c13723b94" translate="yes" xml:space="preserve">
          <source>Secure methods of storing keys, passwords for asp.net</source>
          <target state="translated">asp.net의 안전한 키 저장 방법</target>
        </trans-unit>
        <trans-unit id="ff41ccecb888661f5547c2d4b885e0c114d66f5f" translate="yes" xml:space="preserve">
          <source>Simple Password Encryption</source>
          <target state="translated">간단한 비밀번호 암호화</target>
        </trans-unit>
        <trans-unit id="02d7e2181d283624db40fc6185be390dccef0f3e" translate="yes" xml:space="preserve">
          <source>Since then, PHP has given us &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;&lt;code&gt;password_hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;&lt;code&gt;password_verify&lt;/code&gt;&lt;/a&gt; and, since their introduction, they are the recommended password hashing &amp;amp; checking method.</source>
          <target state="translated">그 이후로, PHP는 우리에게 &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt; &lt;code&gt;password_hash&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt; &lt;code&gt;password_verify&lt;/code&gt; 를&lt;/a&gt; 주었으며, 소개 된 이후로 권장되는 암호 해싱 및 검사 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6dd6c021f508c0340ebfdf5945ac1810408566d3" translate="yes" xml:space="preserve">
          <source>So far as I've been able to tell, making the world's best password is a Catch-22. Either its not memorable, too predictable, too short, too many unicode characters (hard to type on a Windows/Mobile device), too long, etc. No password is truly good enough for our purposes, so we must protect them as though they were in Fort Knox.</source>
          <target state="translated">내가 알 수있는 한, 세계 최고의 암호를 만드는 것은 Catch-22입니다. 기억하기 어렵고, 예측 가능하고, 짧고, 너무 많은 유니 코드 문자 (Windows / 모바일 장치에서 입력하기 어렵다), 너무 길다. 암호가 실제로 목적에 충분하지 않으므로 암호를 보호해야합니다. 포트 녹스에있었습니다.</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="abc469ca9e1e32aad49a7fa70322810e433fbc73" translate="yes" xml:space="preserve">
          <source>The API exposes four functions:</source>
          <target state="translated">API는 다음과 같은 네 가지 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d1e5cbc852e92edf4f983cd9843ad840d31e7b05" translate="yes" xml:space="preserve">
          <source>The computational power required to actually &lt;em&gt;crack&lt;/em&gt; a hashed password doesn't exist. The only way for computers to &quot;crack&quot; a password is to recreate it and simulate the hashing algorithm used to secure it. The speed of the hash is linearly related to its ability to be brute-forced. Worse still, most hash algorithms can be easily parallelized to perform even faster. This is why costly schemes like bcrypt and scrypt are so important.</source>
          <target state="translated">실제로 해시 된 암호를 &lt;em&gt;해독&lt;/em&gt; 하는 데 필요한 계산 능력은 존재하지 않습니다. 컴퓨터가 암호를 &quot;크래킹&quot;하는 유일한 방법은 암호를 다시 작성하고 보안에 사용되는 해싱 알고리즘을 시뮬레이션하는 것입니다. 해시의 속도는 무차별 강제 기능과 선형으로 관련됩니다. 더 나쁜 것은 여전히 ​​대부분의 해시 알고리즘을 쉽게 병렬화하여 더 빠르게 수행 할 수 있다는 것입니다. 이것이 bcrypt 및 scrypt와 같은 비용이 많이 드는 구성표가 중요한 이유입니다.</target>
        </trans-unit>
        <trans-unit id="cc82bec66b732bb33be65e32feee97dde8331a13" translate="yes" xml:space="preserve">
          <source>The hashing mechanism must be available in PHP</source>
          <target state="translated">해싱 메커니즘은 PHP에서 사용할 수 있어야합니다</target>
        </trans-unit>
        <trans-unit id="c967b55b3de7e43262a5ec3a53dd313fc5714961" translate="yes" xml:space="preserve">
          <source>The idea of a salt is to throw the hashing results off balance, so to say. It is known, for example, that the MD5-hash of an empty string is &lt;code&gt;d41d8cd98f00b204e9800998ecf8427e&lt;/code&gt;. So, if someone with good enough a memory would see that hash and know that it's the hash of an empty string. But if the string is salted (say, with the string &quot;&lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt;&quot;), the hash for the 'empty string' (i.e. &quot;&lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt;&quot;) becomes &lt;code&gt;aeac2612626724592271634fb14d3ea6&lt;/code&gt;, hence non-obvious to backtrace. What I'm trying to say, that it's better to use &lt;em&gt;any&lt;/em&gt; salt, than not to. Therefore, it's not too much of an importance to know &lt;em&gt;which&lt;/em&gt; salt to use.</source>
          <target state="translated">소금의 아이디어는 해싱 결과를 균형에서 벗어나게하는 것입니다. 예를 들어, 빈 문자열의 MD5 해시는 &lt;code&gt;d41d8cd98f00b204e9800998ecf8427e&lt;/code&gt; 인 것으로 알려져 있습니다. 따라서 충분한 메모리를 가진 사람이 해시를보고 빈 문자열의 해시임을 알 수 있습니다. 그러나 문자열이 솔트 된 경우 (예 : 문자열 &quot; &lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt; &quot;로) '빈 문자열'에 대한 해시 (예 : &quot; &lt;code&gt;MY_PERSONAL_SALT&lt;/code&gt; &quot;)는 &lt;code&gt;aeac2612626724592271634fb14d3ea6&lt;/code&gt; 이되므로 역 추적에는 명백하지 않습니다. 내가 말하려는 것은 소금을 사용 &lt;em&gt;하지&lt;/em&gt; 않는 것보다 낫다는 것입니다. 그러므로 &lt;em&gt;어떤&lt;/em&gt; 소금을 사용해야하는지 아는 것은 그리 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e93c44acff31ed1b16a3be79f5aaf860521be39" translate="yes" xml:space="preserve">
          <source>The objective behind hashing passwords is simple: preventing malicious access to user accounts by compromising the database. So the goal of password hashing is to deter a hacker or cracker by costing them too much time or money to calculate the plain-text passwords. And time/cost are the best deterrents in your arsenal.</source>
          <target state="translated">암호 해싱의 목표는 간단합니다. 데이터베이스를 손상시켜 사용자 계정에 악의적으로 액세스하는 것을 방지합니다. 따라서 비밀번호 해싱의 목표는 일반 텍스트 비밀번호를 계산하기 위해 너무 많은 시간이나 비용을 들여 해커 나 크래커를 막는 것입니다. 그리고 시간 / 비용은 당신의 무기고에서 최고의 억제력입니다.</target>
        </trans-unit>
        <trans-unit id="ca15458b1f6023e826d9e6c9d269e5b8847c24ab" translate="yes" xml:space="preserve">
          <source>The returned hash could be stored in database as it is. Sample use for generating hash is:</source>
          <target state="translated">반환 된 해시는 그대로 데이터베이스에 저장 될 수 있습니다. 해시 생성을위한 샘플 사용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9336b71741fbd4b0fc7ebef42b5f931ca05fe080" translate="yes" xml:space="preserve">
          <source>The theory of the answer is still a good read though.</source>
          <target state="translated">대답의 이론은 여전히 ​​잘 읽습니다.</target>
        </trans-unit>
        <trans-unit id="72fe41d63bb494eee2544c08c337e299e480e6db" translate="yes" xml:space="preserve">
          <source>Then have a separate user account for you that is not stored anywhere on the server, not even in the application.</source>
          <target state="translated">그런 다음 응용 프로그램에서도 서버의 어느 곳에도 저장되지 않은 별도의 사용자 계정이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a80224d4f8511d86bc794896685456f1282e0a56" translate="yes" xml:space="preserve">
          <source>There are a lot of good hashing functions out there (&lt;code&gt;password_hash&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, etc...) but you need to select a good algorithm for the hash to be effective. (bcrypt and ones similar to it are decent algorithms.)</source>
          <target state="translated">거기에는 좋은 해싱 함수가 많이 있지만 ( &lt;code&gt;password_hash&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; 등 ...) 해시 를 적용하려면 좋은 알고리즘을 선택해야합니다. (bcrypt와 비슷한 알고리즘은 괜찮은 알고리즘입니다.)</target>
        </trans-unit>
        <trans-unit id="83d2f507ea07e3720cda34bd2cd662536b85bf9a" translate="yes" xml:space="preserve">
          <source>There are actually &lt;a href=&quot;http://gdataonline.com/seekhash.php&quot;&gt;websites that do just this&lt;/a&gt; - you can feed it a (md5) hash, and it spits out a known plaintext that generates that particular hash. If you would get access to a database that stores plain md5-hashes, it would be trivial for you to enter the hash for the admin to such a service, and log in. But, if the passwords were salted, such a service would become ineffective.</source>
          <target state="translated">실제로이 &lt;a href=&quot;http://gdataonline.com/seekhash.php&quot;&gt;작업을 수행하는 웹 사이트가&lt;/a&gt; 있습니다-(md5) 해시를 제공 할 수 있으며 해당 해시를 생성하는 알려진 평문을 뱉어냅니다. 일반 md5 해시를 저장하는 데이터베이스에 액세스하는 경우 관리자가 해당 서비스에 대한 해시를 입력하고 로그인하는 것이 쉽지 않을 것입니다. 그러나 암호가 소금에 절인 경우 이러한 서비스는 효과적인.</target>
        </trans-unit>
        <trans-unit id="94dc7fd1014b141fac002eb97bbbe1edb127d32d" translate="yes" xml:space="preserve">
          <source>There are also many rainbow table attacks on Windows passwords that run on ordinary CPUs and are very fast.  All this is because Windows &lt;em&gt;still&lt;/em&gt;&lt;a href=&quot;https://superuser.com/a/118279/90231&quot;&gt;doesn't salt or stretch&lt;/a&gt; its passwords, &lt;a href=&quot;https://www.guidingtech.com/61991/cracking-windows-10-password-prevent/&quot;&gt;even in Windows 10&lt;/a&gt; - don't make the same mistake as Microsoft did!</source>
          <target state="translated">일반 CPU에서 실행되며 매우 빠른 Windows 암호에 대한 레인보우 테이블 공격이 많이 있습니다. &lt;a href=&quot;https://www.guidingtech.com/61991/cracking-windows-10-password-prevent/&quot;&gt;Windows 10에서도&lt;/a&gt; Windows가 &lt;em&gt;여전히&lt;/em&gt; 암호를 변경 &lt;a href=&quot;https://superuser.com/a/118279/90231&quot;&gt;하거나 확장하지&lt;/a&gt; 않기 때문입니다. Microsoft와 같은 실수를하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="7d78de6e30f57b4b7d0c6241b43daf6efe33858b" translate="yes" xml:space="preserve">
          <source>There's a longer discussion of password entropy on the &lt;a href=&quot;https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password&quot;&gt;Crypto StackExchange&lt;/a&gt; site. A good Google search will also turn up a lot of results.</source>
          <target state="translated">&lt;a href=&quot;https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password&quot;&gt;Crypto StackExchange&lt;/a&gt; 사이트에서 암호 엔트로피에 대한 자세한 설명이 있습니다. 좋은 Google 검색은 많은 결과를 낳습니다.</target>
        </trans-unit>
        <trans-unit id="eb3552eb4e3ab442dc5e9548665b050d60219300" translate="yes" xml:space="preserve">
          <source>This question, &lt;a href=&quot;https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once&quot;&gt;Is &amp;ldquo;double hashing&amp;rdquo; a password less secure than just hashing it once?&lt;/a&gt; 
suggests that hashing multiple times may be a good idea, whereas &lt;a href=&quot;https://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904&quot;&gt;How to implement password protection for individual files?&lt;/a&gt; suggests using salt.</source>
          <target state="translated">이 질문 &lt;a href=&quot;https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once&quot;&gt;은 &quot;이중 해싱&quot;이 비밀번호를 한 번 해시하는 것보다 덜 안전합니까?&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904&quot;&gt;개별 파일에 대한 암호 보호를 구현&lt;/a&gt; 하는 방법 은 있지만 여러 번 해싱하는 것이 좋습니다 . 소금 사용을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="957441673ad43072032f00a3b5118222b26b20f1" translate="yes" xml:space="preserve">
          <source>Though the question has been answered, I just want to reiterate that salts used for hashing should be random and not like email address as suggested in first answer.</source>
          <target state="translated">질문에 대한 답변이 있지만 해싱에 사용되는 솔트는 무작위이며 첫 번째 답변에서 제안한 이메일 주소와 같지 않아야한다는 점을 반복하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="0cf0236983335ce525d178c161a3dac43b40ad44" translate="yes" xml:space="preserve">
          <source>To verify password, one can use:</source>
          <target state="translated">비밀번호를 확인하기 위해 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae24b36e98b286448b8f32e9eb9c4f5faa046188" translate="yes" xml:space="preserve">
          <source>Try an implementation of &lt;a href=&quot;http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard&quot;&gt;PDKBF2&lt;/a&gt; with the &lt;a href=&quot;https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256&quot;&gt;maximum number of rounds&lt;/a&gt; that your environment/application/user-perception can tolerate. The lowest number I'd recommend is 2500 rounds. Also, make sure to use &lt;a href=&quot;http://php.net/hash_hmac&quot;&gt;hash_hmac()&lt;/a&gt; if it is available to make the operation harder to reproduce.</source>
          <target state="translated">환경 / 응용 프로그램 / 사용자 인식이 허용 할 수있는 &lt;a href=&quot;https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256&quot;&gt;최대 라운드 수로&lt;/a&gt; &lt;a href=&quot;http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard&quot;&gt;PDKBF2&lt;/a&gt; 를 구현해보십시오. 내가 추천하는 가장 낮은 숫자는 2500 라운드입니다. 또한 조작을 재현하기 어렵게 만들 수있는 경우 &lt;a href=&quot;http://php.net/hash_hmac&quot;&gt;hash_hmac ()&lt;/a&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="068a6272a632b944b53a381b4d5400b18d5eafc9" translate="yes" xml:space="preserve">
          <source>Use PBKDF2 if you cannot use either bcrypt or scrypt, with SHA2 hashes.</source>
          <target state="translated">SHA2 해시와 함께 bcrypt 또는 scrypt를 사용할 수없는 경우 PBKDF2를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3438f0875ced99f75e760bc602d283a350f5c224" translate="yes" xml:space="preserve">
          <source>Use scrypt when you can; bcrypt if you cannot.</source>
          <target state="translated">가능하면 scrypt를 사용하십시오. 당신이 할 수 없다면 bcrypt.</target>
        </trans-unit>
        <trans-unit id="8a40715ff9e4ad938469f5e938fbc3461e5c29de" translate="yes" xml:space="preserve">
          <source>What makes a &lt;em&gt;good&lt;/em&gt; password anyway?</source>
          <target state="translated">어쨌든 &lt;em&gt;좋은&lt;/em&gt; 암호는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d324dbbd000686026c12d8aac03bc6761752e7ae" translate="yes" xml:space="preserve">
          <source>What's the difference between SHA and MD5 in PHP</source>
          <target state="translated">PHP에서 SHA와 MD5의 차이점은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="3273a0f907bb9b658a5b510bdc764fef8f6fd55f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;password_hash()&lt;/code&gt; is used, it generates a random salt and includes it in the outputted hash (along with the the cost and algorithm used.) &lt;code&gt;password_verify()&lt;/code&gt; then reads that hash and determines the salt and encryption method used, and verifies it against the provided plaintext password.</source>
          <target state="translated">&lt;code&gt;password_hash()&lt;/code&gt; 를 사용하면 임의의 솔트를 생성하고이를 사용 된 비용 및 알고리즘과 함께 출력 된 해시에 포함합니다. &lt;code&gt;password_verify()&lt;/code&gt; 는 해당 해시를 읽고 사용 된 솔트 및 암호화 방법을 결정하여이를 검증합니다. 제공된 일반 텍스트 비밀번호</target>
        </trans-unit>
        <trans-unit id="cdf0e49369640a78f1b0481bc29357ba77ff4067" translate="yes" xml:space="preserve">
          <source>When hashing speed is the key, the slower the more resistant to Brute Force attacks.</source>
          <target state="translated">해싱 속도가 핵심 일 때는 Brute Force 공격에 대한 내성이 느릴수록 느려집니다.</target>
        </trans-unit>
        <trans-unit id="0ea7792c8765a8cc7d08846130a9f07954560526" translate="yes" xml:space="preserve">
          <source>When you create a salt make sure it is unique to the password it is salting, then store both the completed hash and salt in your DB. What this will do is make it so that an attacker will have to individually crack each salt and hash before they can gain access. This means a lot more work and time for the attacker.</source>
          <target state="translated">솔트를 생성 할 때 솔트가 암호에 고유한지 확인한 다음 완성 된 해시와 솔트를 DB에 저장하십시오. 이것이하는 일은 공격자가 접근하기 전에 각각의 소금과 해시를 개별적으로 해독해야하는 것입니다. 이는 공격자에게 더 많은 작업과 시간을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4bcfb1507fa18c5813bf98587194789dfd7fc9fa" translate="yes" xml:space="preserve">
          <source>Why hash passwords anyway?</source>
          <target state="translated">어쨌든 암호를 해시해야하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d9c509de30c734b1fbd267c99263e20b0ac2f8d4" translate="yes" xml:space="preserve">
          <source>You cannot possibly foresee all threats or avenues of attack, and so you must make your best effort to protect your users &lt;strong&gt;up front&lt;/strong&gt;. If you do not, then you might even miss the fact that you were attacked until it's too late... &lt;em&gt;and you're liable&lt;/em&gt;. To avoid that situation, act paranoid to begin with. Attack your own software (internally) and attempt to steal user credentials, or modify other user's accounts or access their data. If you don't test the security of your system, then you cannot blame anyone but yourself.</source>
          <target state="translated">모든 위협이나 공격의 경로를 예견 할 수는 없으므로 사용자를 먼저 보호해야합니다. 그렇지 않으면 너무 늦을 때까지 공격을 받았다는 사실을 놓칠 수도 있습니다. 그러한 상황을 피하려면 먼저 편집증을 행동하십시오. 자신의 소프트웨어를 내부적으로 공격하고 사용자 자격 증명을 도용하거나 다른 사용자의 계정을 수정하거나 데이터에 액세스하십시오. 시스템의 보안을 테스트하지 않으면 자신 외에 다른 사람을 비난 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ecc62ca116f09be2ac8ccbf2dd2a17934a3f97a" translate="yes" xml:space="preserve">
          <source>You should definitely use a salt. I'd recommend using random bytes (and not restrict yourself to characters and numbers). As usually, the longer you choose, the safer, slower it gets. 64 bytes ought to be fine, i guess.</source>
          <target state="translated">반드시 소금을 사용해야합니다. 임의의 바이트를 사용하는 것이 좋습니다 (문자와 숫자로 제한하지 마십시오). 일반적으로 더 오래 선택할수록 더 안전하고 느려집니다. 64 바이트는 괜찮을 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="250c2ad56e4e9ddde57caded620862fba3c804d9" translate="yes" xml:space="preserve">
          <source>You tell your users to make good passwords to avoid getting hacked, do the same. What is the point in going through all the effort of locking your front door when you have the backdoor wide open.</source>
          <target state="translated">해킹 당하지 않도록 사용자에게 올바른 비밀번호를 만들도록 지시하십시오. 백도어를 넓게 열었을 때 현관 문을 잠그는 모든 노력을 기울이는 요점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="65de4781939078acdc51b27007cb200ec4c437c0" translate="yes" xml:space="preserve">
          <source>also we need the hash
I`m using sha512
it is the best and it is in php</source>
          <target state="translated">또한 우리는 sha512를 사용하는 해시가 필요합니다. 최고이며 PHP입니다.</target>
        </trans-unit>
        <trans-unit id="28edb5e4d9749f27a128acb260e84492ffdd3323" translate="yes" xml:space="preserve">
          <source>and for authorize we will use same steps...</source>
          <target state="translated">승인을 위해 동일한 단계를 사용합니다 ...</target>
        </trans-unit>
        <trans-unit id="44c7073fa2fab130499078fde7b90431453ca675" translate="yes" xml:space="preserve">
          <source>it is the best way to safe our clients passwords...</source>
          <target state="translated">고객 비밀번호를 보호하는 가장 좋은 방법입니다 ...</target>
        </trans-unit>
        <trans-unit id="66f5061855cb204f427143765390a0e15cb4bb02" translate="yes" xml:space="preserve">
          <source>now we need to save in database our $hash_psw variable value and $salt variable</source>
          <target state="translated">이제 $ hash_psw 변수 값과 $ salt 변수를 데이터베이스에 저장해야합니다</target>
        </trans-unit>
        <trans-unit id="65b1ca7c9f59ee04049ba7f7cac979ffa197ee6a" translate="yes" xml:space="preserve">
          <source>ok
in the fitsy we need salt
salt must be unique
so let generate it</source>
          <target state="translated">맞습니다. 소금 소금이 필요합니다. 소금 소금은 독특해야합니다.</target>
        </trans-unit>
        <trans-unit id="83813ad92f95972794914dc4459ac7d1fb05a12a" translate="yes" xml:space="preserve">
          <source>so now we can use this functions to generate safe password</source>
          <target state="translated">이제이 기능을 사용하여 안전한 비밀번호를 생성 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
