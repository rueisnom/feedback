<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/949433">
    <body>
      <group id="949433">
        <trans-unit id="279b28cc873ec1c827682711f3c25217acbae1fe" translate="yes" xml:space="preserve">
          <source>(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)</source>
          <target state="translated">(我...........假设0x00000014指令是编译器的某种优化?)</target>
        </trans-unit>
        <trans-unit id="bfd7cdbaee11e47493e6a76cbda42efed8c089b4" translate="yes" xml:space="preserve">
          <source>6.5 Expressions:</source>
          <target state="translated">6.5 表达方式:</target>
        </trans-unit>
        <trans-unit id="88c039b7efd50e8beeced317de42cd545759369b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/17935062/2455888&quot;&gt;An important point&lt;/a&gt; regarding Postfix &lt;code&gt;++&lt;/code&gt; operator is that:</source>
          <target state="translated">关于Postfix &lt;code&gt;++&lt;/code&gt; 运算符&lt;a href=&quot;https://stackoverflow.com/a/17935062/2455888&quot;&gt;的重要一点&lt;/a&gt;是：</target>
        </trans-unit>
        <trans-unit id="a38d1a7059ef11574a41d6295e5c3ee36deea981" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This&lt;/em&gt; answer tries to answer that question: why did your code not give you the answer you expected, and how can you learn to recognize (and avoid) expressions that will not work as expected.</source>
          <target state="translated">&lt;em&gt;这个&lt;/em&gt;答案试图回答这个问题：为什么您的代码没有给您期望的答案，以及如何学习识别（并避免）不能按预期工作的表达式。</target>
        </trans-unit>
        <trans-unit id="cede1476cbfbaa036e6ccf5fced4facf59ce7d1f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unspecified behavior&lt;/em&gt; is defined in the &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;draft c99 standard&lt;/a&gt; in section &lt;code&gt;3.4.4&lt;/code&gt; as:</source>
          <target state="translated">&lt;em&gt;未指定的行为&lt;/em&gt;在&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;c99标准草案的&lt;/a&gt; &lt;code&gt;3.4.4&lt;/code&gt; 节中定义为：</target>
        </trans-unit>
        <trans-unit id="44b34df450374fa00c3d7262a922fe635b3fb310" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.4, unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.4.4，未指定的行为&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b687a63b4511aca324bdbbc7328acb8be568d38d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Annex J, unspecified behaviours&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;附件J，未指明的行为&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad5e622d7c3f20a8ca11dc4608457c04512caa38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Between the previous and next sequence point an object shall have its stored value
  modified at most once&lt;/strong&gt; by the evaluation of an expression. Furthermore, &lt;strong&gt;the prior value
  shall be read only to determine the value to be stored&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;在上一个序列点与下一个序列点之间，对象的存储值最多只能&lt;/strong&gt;通过对表达式的求&lt;strong&gt;值来修改&lt;/strong&gt; 。 此外， &lt;strong&gt;先验值应仅被读取以确定要存储的值&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="14c69e77d03fc3b5c073134689c8f8428458e027" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If a side effect on a scalar object is unsequenced relative to&lt;/strong&gt; either &lt;strong&gt;a different side effect on the same scalar object&lt;/strong&gt; or a value computation using the value of the same scalar object, &lt;strong&gt;the behavior is undefined&lt;/strong&gt;. [...]</source>
          <target state="translated">&lt;strong&gt;如果相对于&lt;/strong&gt; &lt;strong&gt;对相同标量对象的不同副作用&lt;/strong&gt;或使用&lt;strong&gt;相同标量对象&lt;/strong&gt;的值进行的值计算， &lt;strong&gt;相对于标量对象的副作用未排序&lt;/strong&gt; ， &lt;strong&gt;则行为未定义&lt;/strong&gt; 。 [...]</target>
        </trans-unit>
        <trans-unit id="05664d00aa9e447fc1d30a0bcf56db0f328bd362" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequence Point:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;顺序点：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9f49591f9696f388f781605342ac7b9ab2f5c5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequenced:&lt;/strong&gt; (5.1.2.3)</source>
          <target state="translated">&lt;strong&gt;顺序：&lt;/strong&gt; （5.1.2.3）</target>
        </trans-unit>
        <trans-unit id="64839962132bef2e8207e819c9d365f8efa46d5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unsequenced:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Unsequenced:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b35e23674ba2c887d039ae8bc54926f2a2c920fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;just because the &lt;code&gt;++&lt;/code&gt; comes after the variable does not mean that the increment happens late&lt;/strong&gt;. The increment can happen as early as the compiler likes &lt;em&gt;as long as the compiler ensures that the original value is used&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;仅仅因为 &lt;code&gt;++&lt;/code&gt; 紧随变量之后并不意味着增量会延迟&lt;/strong&gt; 。 &lt;em&gt;只要编译器确保使用原始值&lt;/em&gt; ，增量就可以在编译器喜欢的时候发生。</target>
        </trans-unit>
        <trans-unit id="f47bde17809faf3152a9c49b5ed547c7193a8237" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;side effects&lt;/strong&gt;, which are modifications of objects.</source>
          <target state="translated">&lt;strong&gt;副作用&lt;/strong&gt; ，是对对象的修改。</target>
        </trans-unit>
        <trans-unit id="91ed0c6955be889d3390ace27c7202751c8e2aa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;value computations&lt;/strong&gt;, which work out the result of an expression; and</source>
          <target state="translated">&lt;strong&gt;值计算&lt;/strong&gt; ， &lt;strong&gt;计算&lt;/strong&gt;出表达式的结果； 和</target>
        </trans-unit>
        <trans-unit id="98e847c09ebd5e2f7d780741347784a05d1e1490" translate="yes" xml:space="preserve">
          <source>A good explanation about what happens in this kind of computation is provided in the document &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf&quot;&gt;n1188&lt;/a&gt; from &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/&quot;&gt;the ISO W14 site&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/&quot;&gt;ISO W14网站上&lt;/a&gt;的文档&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf&quot;&gt;n1188&lt;/a&gt;提供了有关这种计算会发生什么的很好的解释。</target>
        </trans-unit>
        <trans-unit id="0e34012ee0723c9314bf3543db136c35ba444eab" translate="yes" xml:space="preserve">
          <source>After the actions associated with each formatted input/output function conversion specifier (7.21.6, 7.29.2).</source>
          <target state="translated">在与每个格式化输入输出函数转换指定器相关联的操作之后(7.21.6、7.29.2)。</target>
        </trans-unit>
        <trans-unit id="34ab97668a5cbf8c450a7a5d95e5097551fcfcaf" translate="yes" xml:space="preserve">
          <source>And the last question is, how can you tell which expressions are well-defined, and which expressions are undefined?</source>
          <target state="translated">而最后一个问题是,如何区分哪些表达式是定义好的,哪些表达式是未定义的?</target>
        </trans-unit>
        <trans-unit id="bae6a155cfc89c64a4a764fc6787a9b2227f41ac" translate="yes" xml:space="preserve">
          <source>Another detail is that the &lt;em&gt;comma&lt;/em&gt; involved in the printf() call is a &lt;em&gt;separator&lt;/em&gt;, not the &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma_operator&quot;&gt;&lt;em&gt;comma operator&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">另一个细节是，printf（）调用中涉及的&lt;em&gt;逗号&lt;/em&gt;是&lt;em&gt;分隔符&lt;/em&gt; ，而不是&lt;a href=&quot;https://en.wikipedia.org/wiki/Comma_operator&quot;&gt;&lt;em&gt;逗号运算符&lt;/em&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="03d05f648939561cc5196d6a1b460c6d6f3ae2fc" translate="yes" xml:space="preserve">
          <source>Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, &lt;em&gt;what are they supposed to mean?&lt;/em&gt;&lt;em&gt;What was the programmer trying to do?&lt;/em&gt;</source>
          <target state="translated">回答这个问题的另一种方法，而不是被序列点和未定义行为的奥秘细节所困扰，只是问&lt;em&gt;他们应该意味着什么？&lt;/em&gt; &lt;em&gt;程序员想做什么？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="454a87205b7cae96f48455860ea1befd4d1fe414" translate="yes" xml:space="preserve">
          <source>As I said earlier, the undefined expressions are the ones where there's too much going at once, where you can't be sure what order things happen in, and where the order matters:</source>
          <target state="translated">就像我前面说的,未定义的表达式是指一下子发生了太多的事情,你不能确定事情发生的顺序,而且顺序很重要。</target>
        </trans-unit>
        <trans-unit id="81111bf67780917ba78bc4f0f400157e26a8fb24" translate="yes" xml:space="preserve">
          <source>As an example of #1, in the expression</source>
          <target state="translated">作为#1的一个例子,在表达式中</target>
        </trans-unit>
        <trans-unit id="53c019261927786950c4738a085953640d98c525" translate="yes" xml:space="preserve">
          <source>As an example of #2, in the expression</source>
          <target state="translated">作为#2的一个例子,在表达式中</target>
        </trans-unit>
        <trans-unit id="55b849835da5250ac9a738c42f912f2f425d1886" translate="yes" xml:space="preserve">
          <source>As far as I know, the standard doesn't explicitly say &lt;em&gt;why&lt;/em&gt; the concept of undefined behavior exists. In my mind, it's simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.</source>
          <target state="translated">据我所知，该标准并未明确说明&lt;em&gt;为什么&lt;/em&gt;存在未定义行为的概念。 在我看来，这仅仅是因为语言设计师希望语义上有一些余地，而不是要求所有实现以完全相同的方式处理整数溢出，这很可能会带来严重的性能损失，他们只是放弃了行为未定义，因此如果您编写导致整数溢出的代码，则可能会发生任何事情。</target>
        </trans-unit>
        <trans-unit id="d8c378a722c25ac92808308a2ac719cb4b3053ff" translate="yes" xml:space="preserve">
          <source>As you've heard by now, all of these expressions are &lt;em&gt;undefined&lt;/em&gt;, which means that the C language makes no guarantee about what they'll do.  This is a strange and surprising result, because you probably thought that any program you could write, as long as it compiled and ran, would generate a unique, well-defined output.  But in the case of undefined behavior, that's not so.</source>
          <target state="translated">正如您现在所听到的，所有这些表达式都是&lt;em&gt;undefined&lt;/em&gt; ，这意味着C语言不能保证它们会做什么。 这是一个奇怪且令人惊讶的结果，因为您可能认为只要编写并运行该程序，您便可以生成任何唯一的，定义明确的输出。 但是对于未定义的行为，事实并非如此。</target>
        </trans-unit>
        <trans-unit id="22983dcf22f5d87d51da07d6260b26d0e70bc867" translate="yes" xml:space="preserve">
          <source>Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions: an initializer that is not part of a compound literal (6.7.9); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (if or switch) (6.8.4); the controlling expression of a while or do statement (6.8.5); each of the (optional) expressions of a for statement (6.8.5.3); the (optional) expression in a return statement (6.8.6.4).</source>
          <target state="translated">在评价一个完整表达式和下一个要评价的完整表达式之间。以下是完整表达式:不属于复合字面意义的初始化器(6.7.9);表达式语句中的表达式(6.8.3);选择语句(if或switch)的控制表达式(6.8.4);while或do语句的控制表达式(6.8.5);for语句的每个(可选)表达式(6.8.5.3);返回语句中的(可选)表达式(6.8.6.4)。</target>
        </trans-unit>
        <trans-unit id="040e4fe9d9fa542dc4ba06a43851d6aa5a72dd54" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the first and second operands of the following operators: logical AND &amp;amp;&amp;amp; (6.5.13); logical OR || (6.5.14); comma , (6.5.17).</source>
          <target state="translated">在以下运算符的第一和第二操作数的求值之间：逻辑AND &amp;amp;&amp;amp;（6.5.13）; 逻辑或|| （6.5.14）； 逗号（6.5.17）。</target>
        </trans-unit>
        <trans-unit id="4ad551d09f57149aadd870dc2cb52328b435e78b" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the first operand of the conditional ? : operator and whichever of the second and third operands is evaluated (6.5.15).</source>
          <target state="translated">在条件运算符的第一个运算符的第一个执行项和第二个和第三个执行项中的任何一个被评价(6.5.15)。</target>
        </trans-unit>
        <trans-unit id="c5fd30fab6709015ef08a8e61b2e1f1954973f1f" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the function designator and actual arguments in a function call and the actual call. (6.5.2.2).</source>
          <target state="translated">在函数调用中的函数代号和实际参数的评价与实际调用之间。(6.5.2.2).</target>
        </trans-unit>
        <trans-unit id="a81e8350af213ee569d9aa330eca2c02262e4edf" translate="yes" xml:space="preserve">
          <source>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.   Furthermore, the prior value shall be read only to determine the value to be stored.</source>
          <target state="translated">在上一个序列点和下一个序列点之间,一个对象的存储值最多只能被一个表达式的评价修改一次。此外,前一个值只能被读取,以确定要存储的值。</target>
        </trans-unit>
        <trans-unit id="63273c8e87c71a3a8d9d6a1d10757a35596fab39" translate="yes" xml:space="preserve">
          <source>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]</source>
          <target state="translated">在上一个序列点和下一个序列点之间,一个对象的存储值最多只能被一个表达式的评价修改一次。[72]此外,对前一个值的读取只能是为了确定要存储的值[73]。</target>
        </trans-unit>
        <trans-unit id="7a87c40d2167a7f023df7ecb1485eff49c8549a2" translate="yes" xml:space="preserve">
          <source>But, to your surprise, this program did &lt;em&gt;not&lt;/em&gt; help you understand -- it printed some strange, unexpected, inexplicable output, suggesting that maybe &lt;code&gt;++&lt;/code&gt; does something completely different, not at all what you thought it did.</source>
          <target state="translated">但是，令您惊讶的是，该程序并&lt;em&gt;没有&lt;/em&gt;帮助您理解-它打印了一些奇怪的，意想不到的，无法解释的输出，表明 &lt;code&gt;++&lt;/code&gt; 也许所做的事情完全不同，而根本没有您想像的那样。</target>
        </trans-unit>
        <trans-unit id="47b2772f5f51e294039858c5f54b8729f2f5faff" translate="yes" xml:space="preserve">
          <source>C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can't predict the behavior when the code is run.</source>
          <target state="translated">C语言有未定义行为的概念,即有些语言构造的语法上是有效的,但你无法预测代码运行时的行为。</target>
        </trans-unit>
        <trans-unit id="8b35348453822488b14536bba94a12260b7b744a" translate="yes" xml:space="preserve">
          <source>C, of course, has a handy shortcut:</source>
          <target state="translated">C,当然也有一个方便的捷径。</target>
        </trans-unit>
        <trans-unit id="313385540ea390474e5c604236fc46b3e7089c47" translate="yes" xml:space="preserve">
          <source>Depending on whether assignment occurs before or after the increment, different results will be produced and that's the one of the case of &lt;strong&gt;undefined behavior&lt;/strong&gt;.</source>
          <target state="translated">根据赋值是在增量之前还是之后进行，将产生不同的结果，这就是&lt;strong&gt;不确定行为的一种&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="2134df76c62a65d697e36a56132e1c70153997df" translate="yes" xml:space="preserve">
          <source>Doesn't operator precedence determine the order of evaluation?</source>
          <target state="translated">操作者的优先级不决定评价顺序吗?</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="7ab87e9f1e4738df5111adf51d681da54745c555" translate="yes" xml:space="preserve">
          <source>EXAMPLE An example of unspecified behavior is the order in which the
  arguments to a function are evaluated.</source>
          <target state="translated">例子 未指定行为的一个例子是对一个函数的参数进行评价的顺序。</target>
        </trans-unit>
        <trans-unit id="d272d8479ec26da7fb7b5e1ab650055e01f0dee7" translate="yes" xml:space="preserve">
          <source>Evaluations can be one of two things:</source>
          <target state="translated">评价可以是两种情况之一。</target>
        </trans-unit>
        <trans-unit id="ea93a535df109ca0d906a45b2cc9253d643f49d8" translate="yes" xml:space="preserve">
          <source>For the expressions we're talking about what makes them undefined is when there's too much going on at once, when we're not sure what order things will happen in, but when the order matters to the result we get.</source>
          <target state="translated">对于我们所说的表达式来说,让它们无法定义的是,当一次发生的事情太多了,当我们不确定事情会按照什么顺序发生,但当顺序对我们得到的结果很重要的时候。</target>
        </trans-unit>
        <trans-unit id="57433c0a1b88252b7699f889dbc52ef5538d3c60" translate="yes" xml:space="preserve">
          <source>For those who are new to &lt;em&gt;undefined behaviour&lt;/em&gt; would benefit from reading &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&quot;&gt;What Every C Programmer Should Know About Undefined Behavior&lt;/a&gt;  to understand the concept and many other variants of undefined behaviour in C.</source>
          <target state="translated">对于那些&lt;em&gt;不熟悉行为的人&lt;/em&gt;来说，阅读&lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&quot;&gt;每位C程序员应了解的&lt;/a&gt;有关&lt;em&gt;未定义行为的知识，&lt;/em&gt;将从中受益，以了解C中未定义行为的概念和许多其他变体。</target>
        </trans-unit>
        <trans-unit id="a21b34979360402374873c62d1af6606d5786e66" translate="yes" xml:space="preserve">
          <source>Given any two evaluations &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, if &lt;code&gt;A&lt;/code&gt; is sequenced before &lt;code&gt;B&lt;/code&gt;, then the execution of &lt;code&gt;A&lt;/code&gt; shall precede the execution of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">给定 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 中的任何两个评估，如果 &lt;code&gt;A&lt;/code&gt; 在 &lt;code&gt;B&lt;/code&gt; 之前排序，则A的执行应在 &lt;code&gt;B&lt;/code&gt; 的执行之前。</target>
        </trans-unit>
        <trans-unit id="006ec1d5652cc2abca4a9e550b4b2c9adaa218a5" translate="yes" xml:space="preserve">
          <source>How does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).</source>
          <target state="translated">GCC是如何工作的? 它以从左到右的顺序对子表达式进行评估,然后将值分配给左手(RHS)。这正是Java和C#的工作方式和定义标准。是的,Java和C#中的对等软件都有定义行为)。它按照从左到右的顺序逐一评价RHS语句中的每个子表达式;对于每个子表达式:先评价++c(前增量),然后再评价值c(后增量c++)。</target>
        </trans-unit>
        <trans-unit id="2bdbd46fa92ff631f11ad5cb03611cba2db7660a" translate="yes" xml:space="preserve">
          <source>How does visual studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass.</source>
          <target state="translated">visual studio是如何工作的,它采取了另一种方法,它在第一遍中评估所有的前增量表达式,然后在第二遍中使用操作中的变量值,在第三遍中从RHS到LHS分配,然后在最后一遍中评估所有的后增量表达式。</target>
        </trans-unit>
        <trans-unit id="c72c73363ab17f40ba3f10293b5bd49072e48feb" translate="yes" xml:space="preserve">
          <source>However if you stick to one compiler, you will find the behavior persistent, as long as you don't add function calls or pointers, which would make the behavior more messy.</source>
          <target state="translated">但是如果你坚持使用一个编译器,你会发现这个行为是持久性的,只要你不添加函数调用或指针,这样的行为就会变得更加混乱。</target>
        </trans-unit>
        <trans-unit id="7da8149973e9017187a301f4973c6be9158d15d5" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;,&lt;/code&gt; in function argument lists is &lt;em&gt;not&lt;/em&gt; a comma operator, and there is no sequence point between evaluations of distinct arguments; instead their evaluations are unsequenced with regard to each other; so the function call</source>
          <target state="translated">但是，函数参数列表中的in &lt;em&gt;不是&lt;/em&gt;逗号运算符，并且不同参数的求值之间没有顺序点。 相反，他们的评估彼此之间没有先后顺序； 所以函数调用</target>
        </trans-unit>
        <trans-unit id="8ff4f957f0bef850d0e13306eb783d225574c291" translate="yes" xml:space="preserve">
          <source>However, two different variables can be incremented between two sequence points.</source>
          <target state="translated">但是,两个不同的变量可以在两个序列点之间递增。</target>
        </trans-unit>
        <trans-unit id="a4e9fd2fb6e6a52790d78e1ea1a9104776d97482" translate="yes" xml:space="preserve">
          <source>I assume you've heard the basic definition of C's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; operators by now, and how the prefix form &lt;code&gt;++x&lt;/code&gt; differs from the postfix form &lt;code&gt;x++&lt;/code&gt;.  But these operators are hard to think about, so to make sure you understood, perhaps you wrote a tiny little test program involving something like</source>
          <target state="translated">我假设您现在已经听说过C的 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 运算符的基本定义，以及前缀形式 &lt;code&gt;++x&lt;/code&gt; 与后缀形式 &lt;code&gt;x++&lt;/code&gt; 有何不同。 但是这些运算符很难考虑，因此为了确保您理解，也许您编写了一个包含以下内容的小型测试程序：</target>
        </trans-unit>
        <trans-unit id="d2b970b978a071c4f163f23f1f4e314def839a10" translate="yes" xml:space="preserve">
          <source>I explain the ideas.</source>
          <target state="translated">我解释了一下思路。</target>
        </trans-unit>
        <trans-unit id="7e1cdd37254f419dc8e9ee3785767a5fcd30479d" translate="yes" xml:space="preserve">
          <source>I think the relevant parts of the C99 standard are 6.5 Expressions, &amp;sect;2</source>
          <target state="translated">我认为C99标准的相关部分是6.5表达式，&amp;sect;2</target>
        </trans-unit>
        <trans-unit id="ebb30d2d2d8387aa698cfa701d3a0b2ef943f61b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is not sequenced before or after &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are unsequenced.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 在 &lt;code&gt;B&lt;/code&gt; 之前或之后未排序，则 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 不排序。</target>
        </trans-unit>
        <trans-unit id="2e8615005607bfaf839090f5116302468a3077a1" translate="yes" xml:space="preserve">
          <source>If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84)</source>
          <target state="translated">如果一个标量对象上的边效相对于同一标量对象上的不同边效或使用同一标量对象的值计算的值来说是无序的,那么该行为是未定义的。如果一个表达式的子表达式有多个允许的顺序,那么,如果在任何一个顺序中出现了这样的无序侧效应,该行为是未定义的。)</target>
        </trans-unit>
        <trans-unit id="6b364d00d6c222691294e1d715a9d3195c3b8d0b" translate="yes" xml:space="preserve">
          <source>If the compiler were to write &lt;code&gt;i++&lt;/code&gt; as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn't happen to notice that one of the other instructions happened to access &lt;code&gt;i&lt;/code&gt;, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable &lt;code&gt;i&lt;/code&gt; is used in both places, but if a routine accepts references to two pointers &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;, and uses &lt;code&gt;(*p)&lt;/code&gt; and &lt;code&gt;(*q)&lt;/code&gt; in the above expression (rather than using &lt;code&gt;i&lt;/code&gt; twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same object's address were passed for both &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">如果编译器按照上述指示编写 &lt;code&gt;i++&lt;/code&gt; （根据标准合法）并在整个表达式求值过程中散布上述指令（也是合法的），并且没有注意到其他指令之一碰巧访问了 &lt;code&gt;i&lt;/code&gt; ，编译器可能会（并且合法）生成一系列死锁的指令。 可以肯定的是，在两个地方都使用相同变量 &lt;code&gt;i&lt;/code&gt; 的情况下，但是如果例程接受对两个指针 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; 的引用，并使用 &lt;code&gt;(*p)&lt;/code&gt; 和 &lt;code&gt;(*q)&lt;/code&gt; ，则编译器几乎可以检测到问题。在上面的表达式中（而不是使用 &lt;code&gt;i&lt;/code&gt; 两次），不需要编译器识别或避免如果为 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; 传递了相同对象的地址时将发生死锁。</target>
        </trans-unit>
        <trans-unit id="c74bddb68bd6a38d49d02706436102a8da2c6744" translate="yes" xml:space="preserve">
          <source>If there's a variable that's getting modified in one place, and having its value used in another place, how do you know whether it uses the old value or the new value?</source>
          <target state="translated">如果有一个变量在一个地方被修改,而它的值在另一个地方被使用,你怎么知道它使用的是旧值还是新值?</target>
        </trans-unit>
        <trans-unit id="4647db1287f30dfb23b1f0e049be0ffce3ceebe7" translate="yes" xml:space="preserve">
          <source>If there's one variable that's getting modified (assigned to) in two or more different places, how do you know which modification happens first?</source>
          <target state="translated">如果有一个变量在两个或多个不同的地方被修改(分配到),你怎么知道哪个修改是先发生的?</target>
        </trans-unit>
        <trans-unit id="ee1d81c9d526b617cd5db47f0b9129a56d6d92fc" translate="yes" xml:space="preserve">
          <source>Immediately before a library function returns (7.1.4).</source>
          <target state="translated">紧接在库函数返回之前(7.1.4)。</target>
        </trans-unit>
        <trans-unit id="ccc935207dc7de3d090caefd6346b4420b8001d0" translate="yes" xml:space="preserve">
          <source>Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.22.5).</source>
          <target state="translated">在每次调用一个比较函数之前和之后,以及在调用一个比较函数和作为参数传递给该调用的对象的任何移动之间(7.22.5)。</target>
        </trans-unit>
        <trans-unit id="60ed5174c21627240c96b7033c369a5233234943" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&quot;&gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&lt;/a&gt; someone asked about a statement like:</source>
          <target state="translated">在&lt;a href=&quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&quot;&gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c中，&lt;/a&gt;有人问到以下语句：</target>
        </trans-unit>
        <trans-unit id="e29fa6906c297000780a6ab5da38fae509305f9d" translate="yes" xml:space="preserve">
          <source>In GCC C++,  the precedence of the operators controls the order in
  which the individual operators are evaluated</source>
          <target state="translated">在GCC C++中,运算符的优先级控制了单个运算符的评估顺序。</target>
        </trans-unit>
        <trans-unit id="eb8013ee2895e4b793b24f5480886aca31c43b1e" translate="yes" xml:space="preserve">
          <source>In all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the &lt;code&gt;;&lt;/code&gt; in each one of these cases:</source>
          <target state="translated">在所有这些示例中，代码都试图在同一序列点中多次修改对象，这些对象将以 &lt;code&gt;;&lt;/code&gt; 结尾。 在以下每种情况下：</target>
        </trans-unit>
        <trans-unit id="85af2d68b64dacc2ecae8e6b8fe0626d9c55f451" translate="yes" xml:space="preserve">
          <source>In the following statement:</source>
          <target state="translated">在以下声明中:</target>
        </trans-unit>
        <trans-unit id="57437b57542ff5ccdb46668e495487b9f29b828e" translate="yes" xml:space="preserve">
          <source>In the paper that I quoted above it is explained that you can figure out the program as being formed by small boxes, each box containing the instructions between 2 consecutive sequence points.  The sequence points are defined in annex C of the standard, in the case of &lt;code&gt;i=i++&lt;/code&gt; there are 2 sequence points that delimit a full-expression.  Such an expression is syntactically equivalent with an entry of &lt;code&gt;expression-statement&lt;/code&gt; in the Backus-Naur form of the grammar (a grammar is provided in annex A of the Standard).</source>
          <target state="translated">在上面引用的论文中，我们解释了您可以认为程序是由小盒子组成的，每个小盒子都包含2个连续序列点之间的指令。 序列点在标准的附录C中定义，在 &lt;code&gt;i=i++&lt;/code&gt; 的情况下，有2个序列点界定完整表达。 这样的表达在语法上等同于以Backus-Naur格式的语法（在标准的附件A中提供了一种语法）形式的 &lt;code&gt;expression-statement&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dab7f2edb9365a8a8024bd3b99b725247b21d547" translate="yes" xml:space="preserve">
          <source>It means the expression &lt;code&gt;il = ir++&lt;/code&gt; could be evaluated either as</source>
          <target state="translated">这意味着表达式 &lt;code&gt;il = ir++&lt;/code&gt; 可以计算为</target>
        </trans-unit>
        <trans-unit id="6d4bde792ab173fc5f3953aa5c52bd9c3b953ae4" translate="yes" xml:space="preserve">
          <source>Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.</source>
          <target state="translated">只要编译和拆解你的那行代码就可以了,如果你这么想知道到底是怎么得到的,你就会得到你所得到的东西。</target>
        </trans-unit>
        <trans-unit id="139c53c1c422cb855e5ab14ec329f7d3e7293cf2" translate="yes" xml:space="preserve">
          <source>Let's go back to the two examples I've used in this answer.  When I wrote</source>
          <target state="translated">我们再来看看我在这个答案中用过的两个例子。当我写到</target>
        </trans-unit>
        <trans-unit id="007b8d5a96beaf6791ee66ac241a455d31c8ebee" translate="yes" xml:space="preserve">
          <source>Lets rename the &lt;code&gt;i&lt;/code&gt; at left of assignment be &lt;code&gt;il&lt;/code&gt; and at the right of assignment (in the expression &lt;code&gt;i++&lt;/code&gt;) be &lt;code&gt;ir&lt;/code&gt;, then the expression be like</source>
          <target state="translated">让重命名赋值左边的 &lt;code&gt;i&lt;/code&gt; 为 &lt;code&gt;il&lt;/code&gt; ,并赋值右边的 &lt;code&gt;i++&lt;/code&gt; （在表达式i ++中 ）为 &lt;code&gt;ir&lt;/code&gt; ，则表达式类似</target>
        </trans-unit>
        <trans-unit id="0e79c62d8a96cc83c832406559fd72c325b73755" translate="yes" xml:space="preserve">
          <source>Modern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).</source>
          <target state="translated">现代编译器会很好地优化这个问题。事实上,可能比你最初写的代码要好(假设它按你希望的方式工作)。</target>
        </trans-unit>
        <trans-unit id="abffaa693417a99890a9f9f411f179a50d8a1f83" translate="yes" xml:space="preserve">
          <source>Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand &lt;strong&gt;why the behavior of these constructs are undefined&lt;/strong&gt;, let's understand these terms first in the light of C11 standard:</source>
          <target state="translated">这里大多数引用C标准的答案都强调这些构造的行为是不确定的。 要理解&lt;strong&gt;为什么未定义这些构造的行为&lt;/strong&gt; ，让我们首先根据C11标准来理解这些术语：</target>
        </trans-unit>
        <trans-unit id="65659095c4721a9366d72724c0af8686528c6a8e" translate="yes" xml:space="preserve">
          <source>Now coming to the question, for the expressions like</source>
          <target state="translated">现在说到这个问题,对于像这样的表达方式,如</target>
        </trans-unit>
        <trans-unit id="b011b82c9d0b255b15ca16ab67361428cc130072" translate="yes" xml:space="preserve">
          <source>Often this question is linked as a duplicate of questions related to code like</source>
          <target state="translated">通常情况下,这个问题是作为与代码相关的问题的重复链接,如</target>
        </trans-unit>
        <trans-unit id="80af210ba078168ac8aed18f4c289fb13eafe061" translate="yes" xml:space="preserve">
          <source>Or, perhaps you're looking at a hard-to-understand expression like</source>
          <target state="translated">或者,也许你看到的是一种难以理解的表达方式,如</target>
        </trans-unit>
        <trans-unit id="7814f3637cef69793eb4cd0c35453c057b2b2e5b" translate="yes" xml:space="preserve">
          <source>Other good source for explaining such ambiguities are the entries from &lt;a href=&quot;http://c-faq.com/&quot;&gt;c-faq&lt;/a&gt; site (also published &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201845199&quot;&gt;as a book&lt;/a&gt;) , namely &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://c-faq.com/expr/evalorder4.html&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://c-faq.com/expr/confused.html&quot;&gt;here&lt;/a&gt; .</source>
          <target state="translated">其他解释此类歧义的好方法是来自&lt;a href=&quot;http://c-faq.com/&quot;&gt;c-faq&lt;/a&gt;网站（也&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201845199&quot;&gt;作为书出版&lt;/a&gt; ）的条目，即&lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;此处&lt;/a&gt; ， &lt;a href=&quot;http://c-faq.com/expr/evalorder4.html&quot;&gt;此处&lt;/a&gt;和&lt;a href=&quot;http://c-faq.com/expr/confused.html&quot;&gt;此处&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="270467ed08a16c4189f257fa18a363287c860a70" translate="yes" xml:space="preserve">
          <source>Perhaps someone gave you that code as a puzzle.  This code also makes no sense, especially if you run it -- and if you compile and run it under two different compilers, you're likely to get two different answers!  What's up with that?  Which answer is correct?  (And the answer is that both of them are, or neither of them are.)</source>
          <target state="translated">也许有人把这段代码作为谜题给了你。这段代码也没有任何意义,尤其是当你运行它的时候--如果你在两个不同的编译器下编译和运行它,你很可能得到两个不同的答案!这段代码是什么意思?这到底是怎么回事?哪一个答案是正确的?答案是两个都是,或者两个都不是)。</target>
        </trans-unit>
        <trans-unit id="9830e65c22471dbb5ae76ba87a9754d88a6b0759" translate="yes" xml:space="preserve">
          <source>Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</source>
          <target state="translated">可能出现的未定义的行为,从完全无视情况,结果不可预知,到在翻译或程序执行过程中以环境特征的记录方式(有或没有发出诊断信息),再到终止翻译或执行(发出诊断信息)。</target>
        </trans-unit>
        <trans-unit id="d4ec24e520c2deaf639afba4b9f783d5aac04aab" translate="yes" xml:space="preserve">
          <source>Realistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, &quot;If it's not obvious what an expression using ++ means, don't write it.&quot;</source>
          <target state="translated">现实上,这些疯狂的表达方式唯一被写出来的时候,就是人们把这些疯狂的表达方式作为+++应该如何工作的人为例子。当然,理解+++的工作原理也很重要。但使用+++的一个实际规则是,&quot;如果使用++的表达式的意思不明显,就不要写它。&quot;</target>
        </trans-unit>
        <trans-unit id="6343a0dd7d4a3cce5612fb2bd80119beebcf602a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;question 3.8&lt;/a&gt; and the rest of the questions in &lt;a href=&quot;http://c-faq.com/expr/index.html&quot;&gt;section 3&lt;/a&gt; of the &lt;a href=&quot;http://c-faq.com/&quot;&gt;C FAQ list&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;问题3.8&lt;/a&gt;和&lt;a href=&quot;http://c-faq.com/&quot;&gt;C常见问题解答列表&lt;/a&gt; &lt;a href=&quot;http://c-faq.com/expr/index.html&quot;&gt;第3节中&lt;/a&gt;的其余问题 。</target>
        </trans-unit>
        <trans-unit id="8b00a321a9495c839c828a507be825ff13a7800c" translate="yes" xml:space="preserve">
          <source>So a sequence point can be seen by the beginning and the end of each box that composes the program [the boxes are atomic units in C] and inside a box the order of instructions is not defined in all cases.  Changing that order one can change the result sometimes.</source>
          <target state="translated">所以一个序列点可以通过组成程序的每一个框的开头和结尾看到[框是C语言中的原子单位],而在一个框内,指令的顺序并不是在所有情况下都是确定的。改变这个顺序有时会改变结果。</target>
        </trans-unit>
        <trans-unit id="d21ba0d230406e77017c4520bffdb2aae21a3660" translate="yes" xml:space="preserve">
          <source>So every statement of the form:</source>
          <target state="translated">所以,每一个声明的形式。</target>
        </trans-unit>
        <trans-unit id="647883dff5588a701bbd3395f0dfc501b2bb13be" translate="yes" xml:space="preserve">
          <source>So first the GCC:
Using &lt;a href=&quot;https://nuwen.net/mingw.html&quot;&gt;Nuwen MinGW&lt;/a&gt; 15 GCC 7.1 you will get:</source>
          <target state="translated">所以首先是GCC：使用&lt;a href=&quot;https://nuwen.net/mingw.html&quot;&gt;Nuwen MinGW&lt;/a&gt; 15 GCC 7.1，您将获得：</target>
        </trans-unit>
        <trans-unit id="e1619e58534e7a9257bad023ee9910dd4500fdf3" translate="yes" xml:space="preserve">
          <source>So if the &lt;em&gt;comma&lt;/em&gt; in the function call were to be a comma operator then</source>
          <target state="translated">因此，如果函数调用中的逗号是逗号运算符，则</target>
        </trans-unit>
        <trans-unit id="d80658b592df0803b15a8dd4666f791a7e32f7f1" translate="yes" xml:space="preserve">
          <source>So moving on to &lt;em&gt;unspecified behavior&lt;/em&gt;, in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;draft c99 standard&lt;/a&gt; section&lt;code&gt;6.5&lt;/code&gt; paragraph &lt;em&gt;3&lt;/em&gt; says(&lt;em&gt;emphasis mine&lt;/em&gt;):</source>
          <target state="translated">因此，继续进行&lt;em&gt;未指定的行为&lt;/em&gt; ，在&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;c99标准草案&lt;/a&gt;第 &lt;code&gt;6.5&lt;/code&gt; 节第&lt;em&gt;3&lt;/em&gt;段中说（ &lt;em&gt;重点是我&lt;/em&gt; ）：</target>
        </trans-unit>
        <trans-unit id="de08ea26a98f633b8bc219b190df93d9fb9ddf4e" translate="yes" xml:space="preserve">
          <source>So that's the answer: make sure that in any expression you write, each variable is modified at most once, and if a variable is modified, you don't also attempt to use the value of that variable somewhere else.</source>
          <target state="translated">所以这就是答案:确保在你写的任何表达式中,每个变量最多修改一次,如果一个变量被修改了,你不要同时尝试在其他地方使用该变量的值。</target>
        </trans-unit>
        <trans-unit id="fe5b5ad4189e6c54f36de1b0cb2dd509ca3eedca" translate="yes" xml:space="preserve">
          <source>So the equivalent in defined behavior C++ as Visual C++ understands:</source>
          <target state="translated">所以Visual C++理解的定义行为C++中的等价物。</target>
        </trans-unit>
        <trans-unit id="39e26ec98db22aab7bb548688a3cf6b65be062cd" translate="yes" xml:space="preserve">
          <source>So the order of instructions inside a box has no clear order.</source>
          <target state="translated">所以一个盒子里面的指示顺序没有明确的顺序。</target>
        </trans-unit>
        <trans-unit id="0813b942e4187634ff676479cc7529a6a62bd091" translate="yes" xml:space="preserve">
          <source>So when we have a line like this:</source>
          <target state="translated">所以,当我们有这样一条线的时候。</target>
        </trans-unit>
        <trans-unit id="51bff8d93419b8b376c49a4c4c1c6942815bd3f1" translate="yes" xml:space="preserve">
          <source>So with all that background and introduction out of the way, if you want to make sure that all your programs are well-defined, which expressions can you write, and which ones can you not write?</source>
          <target state="translated">那么,说了这么多的背景和介绍,如果你想保证你的程序都能很好的定义,那么哪些表达式可以写,哪些不能写呢?</target>
        </trans-unit>
        <trans-unit id="418454311311342d72ab9381129cfc784f14f285" translate="yes" xml:space="preserve">
          <source>So, with that in mind, why are these &quot;issues&quot;? The language clearly says that certain things lead to &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;undefined behavior&lt;/a&gt;. There is no problem, there is no &quot;should&quot; involved. If the undefined behavior changes when one of the involved variables is declared &lt;code&gt;volatile&lt;/code&gt;, that doesn't prove or change anything. It is &lt;em&gt;undefined&lt;/em&gt;; you cannot reason about the behavior.</source>
          <target state="translated">因此，考虑到这些原因，为什么会出现这些&amp;ldquo;问题&amp;rdquo;？ 该语言清楚地指出，某些事情会导致&lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;不确定的行为&lt;/a&gt; 。 没问题，没有&amp;ldquo;应该&amp;rdquo;涉及。 如果在将其中一个涉及的变量声明为 &lt;code&gt;volatile&lt;/code&gt; 时未定义的行为发生了变化，则不会证明或更改任何内容。 它是&lt;em&gt;未定义的&lt;/em&gt; ; 您无法对此行为进行推理。</target>
        </trans-unit>
        <trans-unit id="52169783c5f1f44d70c71ae0d258a149699e59f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;++i&lt;/code&gt; increments aren't guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 &lt;code&gt;++i&lt;/code&gt; executed, then the values of &lt;code&gt;k[]&lt;/code&gt; were read, then the last &lt;code&gt;++i&lt;/code&gt; then &lt;code&gt;k[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;++i&lt;/code&gt; 增量不能保证在其余计算之前全部完成。 实际上，不同的编译器在这里会得到不同的结果。 在您提供的示例中，首先执行2个 &lt;code&gt;++i&lt;/code&gt; ，然后读取 &lt;code&gt;k[]&lt;/code&gt; 的值，然后读取最后一个 &lt;code&gt;++i&lt;/code&gt; ，然后读取 &lt;code&gt;k[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b497b90b5e9411034420efd2bf3531f465b5abe8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;unspecified behaviour&lt;/em&gt; itself is NOT an issue. Consider this example:</source>
          <target state="translated">&lt;em&gt;未指定的行为&lt;/em&gt;本身不是问题。 考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="aef2dc12b657421591a01f033cfac67b5ba2c01f" translate="yes" xml:space="preserve">
          <source>The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point.</source>
          <target state="translated">C标准规定,一个变量最多只能在两个序列点之间分配一次。例如,分号就是一个序列点。</target>
        </trans-unit>
        <trans-unit id="310e41e0df172a9305a8811318f58058e4fed9e9" translate="yes" xml:space="preserve">
          <source>The above is a common coding practice while copying/analysing strings.</source>
          <target state="translated">以上是复制分析字符串时常用的编码做法。</target>
        </trans-unit>
        <trans-unit id="c5e1fbdb0b52dfbb81762c5648cb9c71849abbe4" translate="yes" xml:space="preserve">
          <source>The behavior can't really be explained because it invokes both &lt;a href=&quot;http://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;unspecified behavior&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;undefined behavior&lt;/a&gt;, so we can not make any general predictions about this code, although if you read &lt;em&gt;Olve Maudal's&lt;/em&gt; work such as &lt;a href=&quot;http://www.slideshare.net/olvemaudal/deep-c&quot;&gt;Deep C&lt;/a&gt; and &lt;a href=&quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf&quot;&gt;Unspecified and Undefined&lt;/a&gt; sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don't do that anywhere near production.</source>
          <target state="translated">该行为无法真正解释，因为它同时调用了&lt;a href=&quot;http://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;未指定的行为&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;未定义的行为&lt;/a&gt; ，因此我们无法对此代码做出任何一般性的预测，尽管如果您阅读&lt;em&gt;Olve Maudal的&lt;/em&gt;著作（例如&lt;a href=&quot;http://www.slideshare.net/olvemaudal/deep-c&quot;&gt;Deep C&lt;/a&gt;和&lt;a href=&quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf&quot;&gt;Unspecified and Undefined），&lt;/a&gt;有时可以在特定情况下使用特定的编译器和环境进行猜测，但请不要在生产环境附近这样做。</target>
        </trans-unit>
        <trans-unit id="27ec791e6f2a00a49e0a8a0ed54e4616a7f3a094" translate="yes" xml:space="preserve">
          <source>The comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in &lt;code&gt;j = (++i, i++);&lt;/code&gt;, &lt;code&gt;++i&lt;/code&gt; increments &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; and &lt;code&gt;i++&lt;/code&gt; yields old value of &lt;code&gt;i&lt;/code&gt; (&lt;code&gt;6&lt;/code&gt;) which is assigned to &lt;code&gt;j&lt;/code&gt;. Then &lt;code&gt;i&lt;/code&gt; becomes &lt;code&gt;7&lt;/code&gt; due to post-increment.</source>
          <target state="translated">逗号运算符从左到右评估其操作数，并且仅产生最后一个操作数的值。 所以在 &lt;code&gt;j = (++i, i++);&lt;/code&gt; ， &lt;code&gt;++i&lt;/code&gt; 将i递增到 &lt;code&gt;6&lt;/code&gt; ,而 &lt;code&gt;i++&lt;/code&gt; 产生 &lt;code&gt;i&lt;/code&gt; （ &lt;code&gt;6&lt;/code&gt; ）的旧值，该值分配给 &lt;code&gt;j&lt;/code&gt; 。 然后由于后增量， &lt;code&gt;i&lt;/code&gt; 变成 &lt;code&gt;7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b67dbcc4d76d135a5736d6b29c5429827a1f48d3" translate="yes" xml:space="preserve">
          <source>The end of a full declarator: declarators (6.7.6);</source>
          <target state="translated">完整声明者的结局:声明者(6.7.6)。</target>
        </trans-unit>
        <trans-unit id="0108968d37f78fc724b69ab92c9f870191ada9e6" translate="yes" xml:space="preserve">
          <source>The first fragment asked about, &lt;code&gt;i = i++ + ++i&lt;/code&gt;, is pretty clearly insane in my book.  No one would ever write it in a real program, it's not obvious what it does, there's no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it's not obvious to you and me what it's supposed to do, it's fine in my book if the compiler can't figure out what it's supposed to do, either.</source>
          <target state="translated">问到的第一个片段 &lt;code&gt;i = i++ + ++i&lt;/code&gt; 在我的书中显然很疯狂。 没有人会在一个真实的程序中编写它，它的作用尚不明确，没有一种可以想象的算法，有人试图编写会导致这种特殊的操作序列的算法。 而且由于您和我都不知道应该做什么，因此如果编译器也无法弄清楚应该做什么，那么在我的书中也可以。</target>
        </trans-unit>
        <trans-unit id="90a68f87988cd45f4bd6311c6ab3e5a1dc45538e" translate="yes" xml:space="preserve">
          <source>The following are the sequence points described in 5.1.2.3:</source>
          <target state="translated">以下是5.1.2.3中描述的顺序点。</target>
        </trans-unit>
        <trans-unit id="902611ed1501ed869ca53ff5d324e744ab75270b" translate="yes" xml:space="preserve">
          <source>The grouping of operators and operands is indicated by the syntax.74) Except as specified
  later (for the function-call (), &amp;amp;&amp;amp;, ||, ?:, and comma operators), &lt;strong&gt;the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.&lt;/strong&gt;</source>
          <target state="translated">语法表示运算符和操作数的分组。74）除非后面有指定（对于函数调用（），&amp;amp;&amp;amp;，||，？：和逗号运算符）， &lt;strong&gt;子表达式的求值顺序和哪种副作用都未指定。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71b9fec95a5c0e3f3bf5d039dad362d79f0e9e56" translate="yes" xml:space="preserve">
          <source>The important part is to know &lt;a href=&quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c&quot;&gt;what a sequence point is -- and &lt;em&gt;what is&lt;/em&gt; a sequence point and what &lt;em&gt;isn't&lt;/em&gt;&lt;/a&gt;. For example the &lt;em&gt;comma operator&lt;/em&gt; is a sequence point, so</source>
          <target state="translated">重要的部分是知道&lt;a href=&quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c&quot;&gt;什么是序列点， &lt;em&gt;什么是&lt;/em&gt;序列点，什么&lt;em&gt;不是&lt;/em&gt;&lt;/a&gt; 。 例如， &lt;em&gt;逗号运算符&lt;/em&gt;是一个序列点，因此</target>
        </trans-unit>
        <trans-unit id="51f661df914e1e2ea77746de6aaa11f9b46f6347" translate="yes" xml:space="preserve">
          <source>The main rule from the standard ISO 9899 that applies in this situation is  6.5p2.</source>
          <target state="translated">ISO 9899标准中适用于这种情况的主要规则是6.5p2。</target>
        </trans-unit>
        <trans-unit id="88392b333617da7906af6f1c9e71bc7a0011c98f" translate="yes" xml:space="preserve">
          <source>The order in which the function designator, arguments, and
  subexpressions within the arguments are evaluated in a function call
  (6.5.2.2).</source>
          <target state="translated">函数代号、参数和参数内的子表达式在函数调用中的评价顺序(6.5.2.2)。</target>
        </trans-unit>
        <trans-unit id="c9968c66bc17adf0cf66c21f5fc4281778fad8b3" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands is unspecified. If an attempt is made to modify
  the result of an assignment operator or to access it after the next sequence point, the
  behavior is undefined.</source>
          <target state="translated">运算子的评价顺序是未指定的。如果试图修改一个赋值运算符的结果或在下一个序列点之后访问它,则该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="57d772c677ab734e951cb65c9f5a9c6ad1025dbd" translate="yes" xml:space="preserve">
          <source>The presence of a sequence point between the evaluation of expressions &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; implies that every &lt;em&gt;value computation&lt;/em&gt; and &lt;em&gt;side effect&lt;/em&gt; associated with &lt;code&gt;A&lt;/code&gt; is sequenced before every &lt;em&gt;value computation&lt;/em&gt; and &lt;em&gt;side effect&lt;/em&gt; associated with &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">在表达式 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的求值之间存在序列点意味着，与 &lt;code&gt;A&lt;/code&gt; 关联的每个&lt;em&gt;值计算&lt;/em&gt;和&lt;em&gt;副作用都在&lt;/em&gt;与 &lt;code&gt;B&lt;/code&gt; 关联的每个&lt;em&gt;值计算&lt;/em&gt;和&lt;em&gt;副作用&lt;/em&gt;之前进行排序。</target>
        </trans-unit>
        <trans-unit id="3fa757362c1545c0b1bfa0b4971c8bcf9a5fa705" translate="yes" xml:space="preserve">
          <source>The problem with this expression is that it contains three different attempts to modify the value of x: (1) the &lt;code&gt;x++&lt;/code&gt; part tries to add 1 to x, store the new value in &lt;code&gt;x&lt;/code&gt;, and return the old value of &lt;code&gt;x&lt;/code&gt;; (2) the &lt;code&gt;++x&lt;/code&gt; part tries to add 1 to x, store the new value in &lt;code&gt;x&lt;/code&gt;, and return the new value of &lt;code&gt;x&lt;/code&gt;; and (3) the &lt;code&gt;x =&lt;/code&gt; part tries to assign the sum of the other two back to x.  Which of those three attempted assignments will &quot;win&quot;?  Which of the three values will actually get assigned to &lt;code&gt;x&lt;/code&gt;?  Again, and perhaps surprisingly, there's no rule in C to tell us.</source>
          <target state="translated">该表达式的问题在于，它包含三种不同的尝试来修改x的值：（1） &lt;code&gt;x++&lt;/code&gt; 部分尝试向x加1，将新值存储在 &lt;code&gt;x&lt;/code&gt; 中 ，并返回x的旧值； （2） &lt;code&gt;++x&lt;/code&gt; 部分尝试将x加1，将新值存储在 &lt;code&gt;x&lt;/code&gt; 中 ，然后返回x的新值； （3） &lt;code&gt;x =&lt;/code&gt; 部分尝试将其他两个的和分配回x。 这三项尝试中的哪一项将&amp;ldquo;获胜&amp;rdquo;？ 这三个值中的哪一个实际上将分配给 &lt;code&gt;x&lt;/code&gt; ？ 同样，也许令人惊讶的是，C语言中没有规则可以告诉我们。</target>
        </trans-unit>
        <trans-unit id="8cf9f511dc75b3a4a079a7021f4a602979571d13" translate="yes" xml:space="preserve">
          <source>The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).</source>
          <target state="translated">原因是程序运行时出现了未定义的行为。问题在于评价顺序,因为按照C++98标准,没有要求的顺序点(按照C++11的术语,没有操作的顺序在前或在后)。</target>
        </trans-unit>
        <trans-unit id="44562ae2bb8fdbc35628d635d10e98d6d60b8571" translate="yes" xml:space="preserve">
          <source>The second fragment, &lt;code&gt;i = i++&lt;/code&gt;, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:</source>
          <target state="translated">第二个片段 &lt;code&gt;i = i++&lt;/code&gt; 有点容易理解。 显然有人在尝试递增i，并将结果分配回i。 但是用C语言有两种方法。在几乎所有编程语言中，将1加到i并将结果分配回i的最基本方法是相同的：</target>
        </trans-unit>
        <trans-unit id="6c93396d9e2d8c2a40d78d9071566b25f416ee2f" translate="yes" xml:space="preserve">
          <source>The sequence points in an expression like &lt;code&gt;i=i++&lt;/code&gt; are before &lt;code&gt;i=&lt;/code&gt; and after &lt;code&gt;i++&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;i=i++&lt;/code&gt; 这样的表达式中的序列点在i =之前和 &lt;code&gt;i++&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c90d0fb8a0d148c282b3883e977c9bc9699153f" translate="yes" xml:space="preserve">
          <source>The various sequence points are listed in Annex C of &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#C&quot;&gt;C11&lt;/a&gt; (and &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#C&quot;&gt;C99&lt;/a&gt;):</source>
          <target state="translated">&lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#C&quot;&gt;C11&lt;/a&gt; （和&lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#C&quot;&gt;C99&lt;/a&gt; ）的附件C中列出了各个序列点：</target>
        </trans-unit>
        <trans-unit id="a79c3a06a2a5a93d7c630437550bdbcddba0807b" translate="yes" xml:space="preserve">
          <source>The wording of the same &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2&quot;&gt;paragraph in C11&lt;/a&gt; is:</source>
          <target state="translated">&lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2&quot;&gt;C11中&lt;/a&gt;同一段的措词为：</target>
        </trans-unit>
        <trans-unit id="2a85af3330f4c3a70b16dc7300fc5a565d163704" translate="yes" xml:space="preserve">
          <source>Then we go to &lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;Visual Studio&lt;/a&gt;. Visual Studio 2015, you get:</source>
          <target state="translated">然后我们转到&lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;Visual Studio&lt;/a&gt; 。 使用Visual Studio 2015，您将获得：</target>
        </trans-unit>
        <trans-unit id="97e693ad3a0c6aa731e9685496e0af87463aa908" translate="yes" xml:space="preserve">
          <source>Therefore, the above expression invokes UB because two side effects on the same object &lt;code&gt;i&lt;/code&gt; is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to &lt;code&gt;i&lt;/code&gt; will be done before or after the side effect by &lt;code&gt;++&lt;/code&gt;.</source>
          <target state="translated">因此，上面的表达式调用UB，因为对同一对象 &lt;code&gt;i&lt;/code&gt; 的两个副作用相对于彼此没有顺序。 这就意味着，对赋给 &lt;code&gt;i&lt;/code&gt; 的副作用是否要在 &lt;code&gt;++&lt;/code&gt; 的副作用之前或之后进行，尚无定论。</target>
        </trans-unit>
        <trans-unit id="f5f8681d077917f909bd82bb366210d3de854d2d" translate="yes" xml:space="preserve">
          <source>These expressions are all fine:</source>
          <target state="translated">这些表达方式都很好。</target>
        </trans-unit>
        <trans-unit id="6c0f3f70b94c0e683794c748069be9306f3ff862" translate="yes" xml:space="preserve">
          <source>These expressions are all undefined:</source>
          <target state="translated">这些表达式都是未定义的。</target>
        </trans-unit>
        <trans-unit id="49e143bed893ac3c1f966d9961175fea9f0097a4" translate="yes" xml:space="preserve">
          <source>This is an important distinction because the &lt;em&gt;comma operator&lt;/em&gt; does introduce a &lt;em&gt;sequence point&lt;/em&gt; between the evaluation of their operands, which makes the following legal:</source>
          <target state="translated">这是一个重要的区别，因为&lt;em&gt;逗号运算符&lt;/em&gt;的确在操作数的评估之间引入了一个&lt;em&gt;序列点&lt;/em&gt; ，这使得以下合法性：</target>
        </trans-unit>
        <trans-unit id="a7eadbdf6cf106addacc1280459303a5771a264b" translate="yes" xml:space="preserve">
          <source>This is what I get on my machine, together with what I think is going on:</source>
          <target state="translated">这是我的机器上得到的,加上我认为的情况。</target>
        </trans-unit>
        <trans-unit id="d2348ba3f2dbca0683d0f6e3794c5adfe460c3d4" translate="yes" xml:space="preserve">
          <source>This means, &quot;add 1 to i, and assign the result back to i&quot;.  So if we construct a hodgepodge of the two, by writing</source>
          <target state="translated">这意味着,&quot;把1加到i上,把结果分配给i&quot;。所以,如果我们把这两者构造成一个大杂烩,通过写出</target>
        </trans-unit>
        <trans-unit id="caa5ad4107546a13712ed7838fa8b42e3b4db460" translate="yes" xml:space="preserve">
          <source>This paragraph renders undefined statement expressions such as</source>
          <target state="translated">本段将未定义的语句表达式,如</target>
        </trans-unit>
        <trans-unit id="46439927e625ecb8b33bd34e881c3e524a95e1a1" translate="yes" xml:space="preserve">
          <source>This post: &lt;a href=&quot;https://stackoverflow.com/a/4105123/1275169&quot;&gt;Undefined, unspecified and implementation-defined behavior&lt;/a&gt; is also relevant.</source>
          <target state="translated">这篇文章： &lt;a href=&quot;https://stackoverflow.com/a/4105123/1275169&quot;&gt;未定义，未指定和实现定义的行为&lt;/a&gt;也很重要。</target>
        </trans-unit>
        <trans-unit id="a26b12aa6128b35356b8372db3a8257837f5a20c" translate="yes" xml:space="preserve">
          <source>This too has &lt;em&gt;unspecified behaviour&lt;/em&gt; because the order of evaluation of &lt;code&gt;++x&lt;/code&gt; and &lt;code&gt;y++&lt;/code&gt; is unspecified. But it's perfectly legal and valid statement. There's &lt;em&gt;no&lt;/em&gt; undefined behaviour in this statement. Because the modifications (&lt;code&gt;++x&lt;/code&gt; and &lt;code&gt;y++&lt;/code&gt;) are done to &lt;em&gt;distinct&lt;/em&gt; objects.</source>
          <target state="translated">这也具有&lt;em&gt;未指定的行为，&lt;/em&gt;因为 &lt;code&gt;++x&lt;/code&gt; 和 &lt;code&gt;y++&lt;/code&gt; 的求值顺序未指定。 但这是完全合法有效的声明。 此语句中&lt;em&gt;没有&lt;/em&gt;未定义的行为。 因为修改（ &lt;code&gt;++x&lt;/code&gt; 和 &lt;code&gt;y++&lt;/code&gt; ）是针对&lt;em&gt;不同的&lt;/em&gt;对象进行的。</target>
        </trans-unit>
        <trans-unit id="b8ab8d4d3501671ee98b37c6896a7b30e0cb64eb" translate="yes" xml:space="preserve">
          <source>Use of an unspecified value, or other behavior where this
  International Standard provides two or more possibilities and imposes
  no further requirements on which is chosen in any instance.</source>
          <target state="translated">使用未指定的值,或本国际标准规定了两种或两种以上的可能性,并且在任何情况下都不对选择哪种可能性提出进一步要求的其他行为。</target>
        </trans-unit>
        <trans-unit id="98e776ec343640985fafdd3ff42f5002ea7be9bc" translate="yes" xml:space="preserve">
          <source>We also have &lt;em&gt;undefined behavior&lt;/em&gt; here as well since the program is modifying variables(&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, etc..) more than once between &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;sequence points&lt;/a&gt;. From draft standard section &lt;code&gt;6.5&lt;/code&gt; paragraph &lt;em&gt;2&lt;/em&gt;(&lt;em&gt;emphasis mine&lt;/em&gt;):</source>
          <target state="translated">由于程序在&lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;序列点&lt;/a&gt;之间多次修改变量（ &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;u&lt;/code&gt; 等），因此我们在这里也具有&lt;em&gt;未定义的行为&lt;/em&gt; 。 从标准草案第 &lt;code&gt;6.5&lt;/code&gt; 条第&lt;em&gt;2&lt;/em&gt;款（ &lt;em&gt;重点是我的&lt;/em&gt; ）：</target>
        </trans-unit>
        <trans-unit id="d79ca31d503a8992b19d27638ae0bfeab48383d7" translate="yes" xml:space="preserve">
          <source>We used to spend countless hours on comp.lang.c discussing expressions like these and &lt;em&gt;why&lt;/em&gt; they're undefined.  Two of my longer answers, that try to really explain why, are archived on the web:</source>
          <target state="translated">过去，我们在comp.lang.c上花费了无数的时间来讨论诸如此类的表达式以及它们&lt;em&gt;为何&lt;/em&gt;未定义的原因。 我的两个较长的答案（试图真正解释原因）已存储在网络上：</target>
        </trans-unit>
        <trans-unit id="97f59d311b736479c8957dda049a60daf7519890" translate="yes" xml:space="preserve">
          <source>What about this crazy expression?</source>
          <target state="translated">那么这个疯狂的表情呢?</target>
        </trans-unit>
        <trans-unit id="5a6d959c80919c189d983a0e8445a43a2b8edc68" translate="yes" xml:space="preserve">
          <source>What makes an expression undefined?  Are expressions involving &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; always undefined?  Of course not: these are useful operators, and if you use them properly, they're perfectly well-defined.</source>
          <target state="translated">是什么使表达式不确定？ 表达式是否涉及 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 始终未定义？ 当然不是：它们是有用的运算符，如果正确使用它们，它们的定义就很好。</target>
        </trans-unit>
        <trans-unit id="8dbebc0ad8d152d87c6b7a7b4477c7a754623049" translate="yes" xml:space="preserve">
          <source>What renders the following statement</source>
          <target state="translated">是什么使下面这句话变成了</target>
        </trans-unit>
        <trans-unit id="620723367c219dcaa50fd9cc14c519910605f4ac" translate="yes" xml:space="preserve">
          <source>Where several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators.</source>
          <target state="translated">当几个运算符一起出现时,它们具有同等的优先级,并根据它们的关联性进行评估。表中的运算符在从后缀运算符开始的章节中描述。</target>
        </trans-unit>
        <trans-unit id="993c059bb0f33b91c747d106d7f878acf62fa429" translate="yes" xml:space="preserve">
          <source>While I don't think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, &lt;code&gt;i&lt;/code&gt; would get incremented by two) and it's not totally inconceivable that some future processor might provide a feature something like that.</source>
          <target state="translated">虽然我不认为任何处理器都支持硬件来有效地完成这样的事情，但人们可以轻松想象这种行为会使多线程代码更容易的情况（例如，如果两个线程尝试执行上述操作，则可以保证这种情况）序列同时， &lt;code&gt;i&lt;/code&gt; 将增加两个），并且将来的处理器可能会提供类似的功能并不是完全不可想象的。</target>
        </trans-unit>
        <trans-unit id="654bf105e22463883f4cc71645479f80ad720b8c" translate="yes" xml:space="preserve">
          <source>While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement &quot;i++&quot; with the sequence:</source>
          <target state="translated">虽然不太可能有任何编译器和处理器真的会这样做,但在C标准下,编译器用序列实现 &quot;i++&quot;是合法的。</target>
        </trans-unit>
        <trans-unit id="c4fc6b93cb14a30318f792c85ba1d6fcdb5593c0" translate="yes" xml:space="preserve">
          <source>While the &lt;strong&gt;syntax&lt;/strong&gt; of the expressions like &lt;code&gt;a = a++&lt;/code&gt; or &lt;code&gt;a++ + a++&lt;/code&gt; is legal, the &lt;strong&gt;behaviour&lt;/strong&gt; of these constructs is &lt;strong&gt;undefined&lt;/strong&gt; because a &lt;strong&gt;&lt;em&gt;shall&lt;/em&gt;&lt;/strong&gt; in C standard is not obeyed. &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2&quot;&gt;C99 6.5p2&lt;/a&gt;:</source>
          <target state="translated">尽管像 &lt;code&gt;a = a++&lt;/code&gt; 或 &lt;code&gt;a++ + a++&lt;/code&gt; 之类的表达式的&lt;strong&gt;语法&lt;/strong&gt;是合法的，但&lt;strong&gt;未定义&lt;/strong&gt;这些构造的&lt;strong&gt;行为&lt;/strong&gt; ，因为未遵循C标准中的a must。 &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2&quot;&gt;C99 6.5p2&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="fa7f3099f3e8212233573bcc53199fbb0f2d7dd7" translate="yes" xml:space="preserve">
          <source>While this is also &lt;a href=&quot;https://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;&lt;em&gt;undefined behaviour&lt;/em&gt;&lt;/a&gt; as stated already, there are subtle differences when &lt;code&gt;printf()&lt;/code&gt; is involved when comparing to a statement such as:</source>
          <target state="translated">如上所述，虽然这也是&lt;a href=&quot;https://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;&lt;em&gt;未定义的行为&lt;/em&gt;&lt;/a&gt; ，但是与以下语句进行比较时，在涉及 &lt;code&gt;printf()&lt;/code&gt; 时仍存在细微差别：</target>
        </trans-unit>
        <trans-unit id="1bbd03ec9871c64e9c4395ce30be95e323064e65" translate="yes" xml:space="preserve">
          <source>Why are these constructs using pre and post-increment undefined behavior</source>
          <target state="translated">为什么这些构造物使用了增量前和增量后的未定义行为?</target>
        </trans-unit>
        <trans-unit id="e9fa82e28ce977203f961d7a07d8a2d4b273fe03" translate="yes" xml:space="preserve">
          <source>Why doesn't the Standard define what these do?</source>
          <target state="translated">为什么《标准》不规定这些是干什么的?</target>
        </trans-unit>
        <trans-unit id="5d24bed798cadce6efcf21855671e0a3bd9b02cf" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#note73&quot;&gt;footnote 73&lt;/a&gt; further clarifying that</source>
          <target state="translated">&lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#note73&quot;&gt;脚注73&lt;/a&gt;进一步阐明了这一点</target>
        </trans-unit>
        <trans-unit id="29f531dd817ce6695c7df2a686b84fe974c07a2d" translate="yes" xml:space="preserve">
          <source>You can detect such errors in a program by for example using a recent version of GCC with &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-Werror&lt;/code&gt;, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:</source>
          <target state="translated">您可以通过例如使用带有 &lt;code&gt;-Wall&lt;/code&gt; 和 &lt;code&gt;-Werror&lt;/code&gt; 的最新版本的GCC来检测程序中的此类错误，然后GCC将完全拒绝编译您的程序。 以下是gcc（Ubuntu 6.2.0-5ubuntu12）6.2.0 20161005的输出：</target>
        </trans-unit>
        <trans-unit id="1e657852dfeb599a907d4ece570953de09d22b6a" translate="yes" xml:space="preserve">
          <source>You might imagine that precedence or associativity or left-to-right evaluation tells you what order things happen in, but they do not.  You may not believe me, but please take my word for it, and I'll say it again: precedence and associativity do not determine every aspect of the evaluation order of an expression in C.  In particular, if within one expression there are multiple different spots where we try to assign a new value to something like &lt;code&gt;x&lt;/code&gt;, precedence and associativity do &lt;em&gt;not&lt;/em&gt; tell us which of those attempts happens first, or last, or anything.</source>
          <target state="translated">您可能会想象优先级，关联性或从左至右的评估告诉您事情发生的顺序，但事实却并非如此。 您可能不相信我，但请您信守我的诺言，我再说一遍：优先级和关联性并不能确定C中表达式的求值顺序的每个方面。特别是，如果一个表达式中有多个在我们尝试为 &lt;code&gt;x&lt;/code&gt; ，优先级和关联性之类的值分配新值的不同地方，并&lt;em&gt;不能&lt;/em&gt;告诉我们这些尝试中的哪一个首先发生，最后发生或发生什么。</target>
        </trans-unit>
        <trans-unit id="16d53ac224d610d74a2b157b47df1e799121e503" translate="yes" xml:space="preserve">
          <source>Your most interesting-looking example, the one with</source>
          <target state="translated">你最有趣的例子,就是那个有</target>
        </trans-unit>
        <trans-unit id="6b59ba518c972237e1ab9cf07eace07655c0ba1c" translate="yes" xml:space="preserve">
          <source>Your question was probably not, &quot;Why are these constructs undefined behavior in C?&quot;.  Your question was probably, &quot;Why did this code (using &lt;code&gt;++&lt;/code&gt;) not give me the value I expected?&quot;, and someone marked your question as a duplicate, and sent you here.</source>
          <target state="translated">您的问题可能不是，&amp;ldquo;为什么这些构造在C中未定义行为？&amp;rdquo;。 您的问题可能是，&amp;ldquo;为什么这段代码（使用 &lt;code&gt;++&lt;/code&gt; ）没有给我期望的值？&amp;rdquo;，有人将您的问题标记为重复，然后将您发送给这里。</target>
        </trans-unit>
        <trans-unit id="3ab35cf324056d865ffa5f8f1bbb4c026674124f" translate="yes" xml:space="preserve">
          <source>according to &lt;a href=&quot;http://helpcentreonline.com/article/operator_console_gcc.pdf&quot;&gt;GCC C++: Operators&lt;/a&gt;</source>
          <target state="translated">根据&lt;a href=&quot;http://helpcentreonline.com/article/operator_console_gcc.pdf&quot;&gt;GCC C ++：运算符&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01fa57d8ce0823fdd6a263ffa07b47583f555303" translate="yes" xml:space="preserve">
          <source>and 6.5.16 Assignment operators, &amp;sect;4:</source>
          <target state="translated">和6.5.16赋值运算符，第4节：</target>
        </trans-unit>
        <trans-unit id="ce12358f2d210e399abcf4e1e573533bddc18601" translate="yes" xml:space="preserve">
          <source>and &lt;em&gt;undefined behavior&lt;/em&gt; is defined in section &lt;code&gt;3.4.3&lt;/code&gt; as:</source>
          <target state="translated">&lt;em&gt;未定义的行为&lt;/em&gt;在 &lt;code&gt;3.4.3&lt;/code&gt; 节中定义为：</target>
        </trans-unit>
        <trans-unit id="2b052e36279e4939f15bff3095a49e8060b7a8a2" translate="yes" xml:space="preserve">
          <source>and notes that:</source>
          <target state="translated">并注意到:</target>
        </trans-unit>
        <trans-unit id="8e6dfcce434b9d0dda3cc6631136727fcce69183" translate="yes" xml:space="preserve">
          <source>and so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.</source>
          <target state="translated">等违反了该规则。标准还说,行为是未定义的,不是未指定的。有些编译器确实会检测到这些,并产生一些结果,但这不是按标准规定的。</target>
        </trans-unit>
        <trans-unit id="1b3734024b41bb3f0676c1c39247d799a3758dbe" translate="yes" xml:space="preserve">
          <source>as &lt;em&gt;undefined behaviour&lt;/em&gt; is the fact that these two expressions modify the &lt;em&gt;same&lt;/em&gt; object &lt;code&gt;i&lt;/code&gt; without an intervening &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;em&gt;sequence point&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">由于&lt;em&gt;未定义的行为&lt;/em&gt; ，这两个表达式修改了&lt;em&gt;同一&lt;/em&gt;对象 &lt;code&gt;i&lt;/code&gt; 而中间没有&lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;em&gt;序列点&lt;/em&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9059279af0d58499da7f4421366ab030ce5ce24f" translate="yes" xml:space="preserve">
          <source>as Visual Studio documentation states at &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx&quot;&gt;Precedence and Order of Evaluation&lt;/a&gt;:</source>
          <target state="translated">正如Visual Studio文档在&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx&quot;&gt;评估的优先级和顺序中&lt;/a&gt;指出的那样 ：</target>
        </trans-unit>
        <trans-unit id="a66c60f4b925de32bda6e418bb9241ab007d19d2" translate="yes" xml:space="preserve">
          <source>because both all these forms to interpret the code &lt;code&gt;i=i++&lt;/code&gt; are valid and because both generate different answers, the behavior is undefined.</source>
          <target state="translated">因为所有这两种解释代码 &lt;code&gt;i=i++&lt;/code&gt; 都是有效的，并且因为两者都生成不同的答案，所以行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="9ca0589f3b903598d63dbbb1bd82e05ec06430e2" translate="yes" xml:space="preserve">
          <source>behavior, upon use of a nonportable or erroneous program construct or of erroneous data,
  for which this International Standard imposes no requirements</source>
          <target state="translated">在使用非便携式或错误的程序结构或错误的数据时的行为,本国际标准没有规定任何要求。</target>
        </trans-unit>
        <trans-unit id="0adcd950d55decdb39e49fe9bd1350b81dcb1ba8" translate="yes" xml:space="preserve">
          <source>can be interpreted as</source>
          <target state="translated">可以理解为</target>
        </trans-unit>
        <trans-unit id="79800df6fd474ca1c30984dcd3f7b04c26a5c2ea" translate="yes" xml:space="preserve">
          <source>has &lt;em&gt;undefined behaviour&lt;/em&gt; because &lt;strong&gt;there is no sequence point between the evaluations of &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; in function arguments&lt;/strong&gt;, and the value of &lt;code&gt;i&lt;/code&gt; is therefore modified twice, by both &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt;, between the previous and the next sequence point.</source>
          <target state="translated">之所以具有&lt;em&gt;未定义的行为&lt;/em&gt; &lt;strong&gt;，是&lt;/strong&gt;因为&lt;strong&gt;在函数参数中 &lt;code&gt;i++&lt;/code&gt; 和 &lt;code&gt;++i&lt;/code&gt; 的求值之间没有序列点，&lt;/strong&gt;因此 &lt;code&gt;i&lt;/code&gt; 的值被 &lt;code&gt;i++&lt;/code&gt; 和 &lt;code&gt;++i&lt;/code&gt; 两次修改了前一个和下一个序列点之间。</target>
        </trans-unit>
        <trans-unit id="7e0c4a46af008bea7bd274279fd48605405877be" translate="yes" xml:space="preserve">
          <source>is a text-book example of undefined behavior (see Wikipedia's entry on &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;sequence points&lt;/a&gt;).</source>
          <target state="translated">是未定义行为的教科书示例（请参阅Wikipedia关于&lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;序列点&lt;/a&gt;的条目）。</target>
        </trans-unit>
        <trans-unit id="d6afca40014c337d879e759974a1ca723b9ba3d5" translate="yes" xml:space="preserve">
          <source>is well-defined, and will increment &lt;code&gt;i&lt;/code&gt; by one, yielding the old value, discard that value; then at comma operator, settle the side effects; and then increment &lt;code&gt;i&lt;/code&gt; by one, and the resulting value becomes the value of the expression - i.e. this is just a contrived way to write &lt;code&gt;j = (i += 2)&lt;/code&gt; which is yet again a &quot;clever&quot; way to write</source>
          <target state="translated">定义明确，将 &lt;code&gt;i&lt;/code&gt; 加1，得到旧值，然后舍弃该值； 然后在逗号运算符处解决副作用； 然后将 &lt;code&gt;i&lt;/code&gt; 加1，结果值就成为表达式的值-即，这只是编写 &lt;code&gt;j = (i += 2)&lt;/code&gt; 一种人为方式，而这又是一种&amp;ldquo;聪明&amp;rdquo;的编写方式</target>
        </trans-unit>
        <trans-unit id="fbe75bf13ae46462a9f46964973c095ec8c518fa" translate="yes" xml:space="preserve">
          <source>it cites the following code examples as being undefined:</source>
          <target state="translated">它引用了以下未定义的代码示例:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="64c3747b998e7ea9d774b1fd5a1400f0310b6691" translate="yes" xml:space="preserve">
          <source>or as</source>
          <target state="translated">或作为</target>
        </trans-unit>
        <trans-unit id="e279a190f96b43bb236230286cb53b2703d35e62" translate="yes" xml:space="preserve">
          <source>or similar variants.</source>
          <target state="translated">或类似的变体。</target>
        </trans-unit>
        <trans-unit id="9702e27e29837c876ff819f4fdde0b4010e5e3ca" translate="yes" xml:space="preserve">
          <source>resulting in two different results &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; which depends on the sequence of side effects by assignment and &lt;code&gt;++&lt;/code&gt; and hence invokes UB.</source>
          <target state="translated">产生两个不同的结果 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; ，这取决于赋值和 &lt;code&gt;++&lt;/code&gt; 的副作用序列，因此调用UB。</target>
        </trans-unit>
        <trans-unit id="36547a3fb0d1b37ceaa06275e8ecd615d0e3cca7" translate="yes" xml:space="preserve">
          <source>standard says that:</source>
          <target state="translated">标准是这样说的。</target>
        </trans-unit>
        <trans-unit id="99eb919d06fc8a202d8b26c45f6410f8dd8cfde9" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;http://en.cppreference.com/w/c/language/eval_order&quot;&gt;&lt;em&gt;order of evaluation&lt;/em&gt;&lt;/a&gt; of arguments in &lt;code&gt;printf()&lt;/code&gt; is &lt;a href=&quot;https://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/a&gt;. That means, expressions &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; could be evaluated in any order. &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html&quot;&gt;C11 standard&lt;/a&gt; has some relevant descriptions on this:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;&lt;em&gt;未指定&lt;/em&gt;&lt;/a&gt; &lt;code&gt;printf()&lt;/code&gt; 中参数&lt;a href=&quot;http://en.cppreference.com/w/c/language/eval_order&quot;&gt;&lt;em&gt;的求值顺序&lt;/em&gt;&lt;/a&gt; 。 这意味着表达式 &lt;code&gt;i++&lt;/code&gt; 和 &lt;code&gt;++i&lt;/code&gt; 可以按任何顺序求值。 &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html&quot;&gt;C11标准&lt;/a&gt;对此有一些相关描述：</target>
        </trans-unit>
        <trans-unit id="31da7bc042367a36b94b0573d521d30381601aa7" translate="yes" xml:space="preserve">
          <source>the equivalent code in defined behavior C++ as   GCC understands:</source>
          <target state="translated">GCC理解的定义行为C++中的等价代码。</target>
        </trans-unit>
        <trans-unit id="b66a1df4b25aa4baacf0d81920e5b8592ea38a0a" translate="yes" xml:space="preserve">
          <source>the question is, before calling &lt;code&gt;printf&lt;/code&gt;, does the compiler compute the value of &lt;code&gt;x&lt;/code&gt; first, or &lt;code&gt;x++&lt;/code&gt;, or maybe &lt;code&gt;++x&lt;/code&gt;?  But it turns out &lt;em&gt;we don't know&lt;/em&gt;.  There's no rule in C which says that the arguments to a function get evaluated left-to-right, or right-to-left, or in some other order.  So we can't say whether the compiler will do &lt;code&gt;x&lt;/code&gt; first, then &lt;code&gt;++x&lt;/code&gt;, then &lt;code&gt;x++&lt;/code&gt;, or &lt;code&gt;x++&lt;/code&gt; then &lt;code&gt;++x&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt;, or some other order.  But the order clearly matters, because depending on which order the compiler uses, we'll clearly get different results printed by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">问题是，在调用 &lt;code&gt;printf&lt;/code&gt; 之前，编译器会先计算 &lt;code&gt;x&lt;/code&gt; 的值，还是 &lt;code&gt;x++&lt;/code&gt; 或 &lt;code&gt;++x&lt;/code&gt; ？ 但是事实证明&lt;em&gt;我们不知道&lt;/em&gt; 。 C语言中没有规则说函数的参数从左到右或从右到左或以其他顺序求值。 所以我们不能说编译器是先执行 &lt;code&gt;x&lt;/code&gt; ，然后执行 &lt;code&gt;++x&lt;/code&gt; ，然后执行 &lt;code&gt;x++&lt;/code&gt; ，还是先执行 &lt;code&gt;x++&lt;/code&gt; 然后执行 &lt;code&gt;++x&lt;/code&gt; 然后执行 &lt;code&gt;x&lt;/code&gt; ，或执行其他一些顺序。 但是顺序显然很重要，因为根据编译器使用的顺序，我们显然会得到由 &lt;code&gt;printf&lt;/code&gt; 打印的不同结果。</target>
        </trans-unit>
        <trans-unit id="b145a546526acfd63eaed2096d7c03ce76dc170c" translate="yes" xml:space="preserve">
          <source>there are three attempts to modify `x.</source>
          <target state="translated">有三次修改`x的尝试:</target>
        </trans-unit>
        <trans-unit id="fe89eef81018d9dbe7f6e45a8c1cb937a477767e" translate="yes" xml:space="preserve">
          <source>use of an unspecified value, or other behavior where this International Standard provides
  two or more possibilities and imposes no further requirements on which is chosen in any
  instance</source>
          <target state="translated">使用未指定的值,或本国际标准提供了两种或两种以上的可能性,并且在任何情况下都不对选择哪种可能性提出进一步要求的其他行为</target>
        </trans-unit>
        <trans-unit id="be6fb6ef9ffc50a3a93ef857ea42b104c0acfc49" translate="yes" xml:space="preserve">
          <source>we both use the value of &lt;code&gt;x&lt;/code&gt;, and modify it.</source>
          <target state="translated">我们都使用 &lt;code&gt;x&lt;/code&gt; 的值，并对其进行修改。</target>
        </trans-unit>
        <trans-unit id="26c3baa763591157c51a290b7c8be38622c3e920" translate="yes" xml:space="preserve">
          <source>we do not know whether &lt;code&gt;i++&lt;/code&gt; or &lt;code&gt;++i&lt;/code&gt; will be evaluated first. This is mainly to give the compiler &lt;a href=&quot;https://stackoverflow.com/a/12540468/1708801&quot;&gt;better options for optimization&lt;/a&gt;.</source>
          <target state="translated">我们不知道会先评估 &lt;code&gt;i++&lt;/code&gt; 还是 &lt;code&gt;++i&lt;/code&gt; 。 这主要是为编译器提供&lt;a href=&quot;https://stackoverflow.com/a/12540468/1708801&quot;&gt;更好的优化选项&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb233158d14cbec62b14e57272c4bcc2a0ceed2f" translate="yes" xml:space="preserve">
          <source>what we're really saying is &quot;add 1 to i, and assign the result back to i, and assign the result back to i&quot;.  We're confused, so it doesn't bother me too much if the compiler gets confused, too.</source>
          <target state="translated">我们真正要说的是 &quot;把1加到i上,把结果赋给i,再把结果赋给i,再把结果赋给i&quot;。我们是糊涂了,所以如果编译器也糊涂了,我也不会太在意。</target>
        </trans-unit>
        <trans-unit id="e22cbfb6c2ae366e16c7c6a3fd5d852b0ea277ba" translate="yes" xml:space="preserve">
          <source>which prints 7... the OP expected it to print 6.</source>
          <target state="translated">打印的是7.........OP希望它打印的是6。</target>
        </trans-unit>
        <trans-unit id="0976677eed8a072a2d2ba8c68e6d46be04d02d10" translate="yes" xml:space="preserve">
          <source>while allowing</source>
          <target state="translated">同时,允许</target>
        </trans-unit>
        <trans-unit id="7144af9b44794b287d95deb872a3d9bc96df4726" translate="yes" xml:space="preserve">
          <source>will not be a problem. But it invokes &lt;em&gt;undefined behaviour&lt;/em&gt; because the &lt;em&gt;comma&lt;/em&gt; here is a &lt;em&gt;separator&lt;/em&gt;.</source>
          <target state="translated">不会有问题。 但是它调用&lt;em&gt;未定义的行为，&lt;/em&gt;因为这里的&lt;em&gt;逗号&lt;/em&gt;是&lt;em&gt;分隔符&lt;/em&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
