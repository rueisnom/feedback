<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/949433">
    <body>
      <group id="949433">
        <trans-unit id="279b28cc873ec1c827682711f3c25217acbae1fe" translate="yes" xml:space="preserve">
          <source>(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)</source>
          <target state="translated">(Я...предположим,что инструкция 0x00000014 была какой-то оптимизацией компилятора?)</target>
        </trans-unit>
        <trans-unit id="bfd7cdbaee11e47493e6a76cbda42efed8c089b4" translate="yes" xml:space="preserve">
          <source>6.5 Expressions:</source>
          <target state="translated">6.5 Выражения:</target>
        </trans-unit>
        <trans-unit id="88c039b7efd50e8beeced317de42cd545759369b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/17935062/2455888&quot;&gt;An important point&lt;/a&gt; regarding Postfix &lt;code&gt;++&lt;/code&gt; operator is that:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/17935062/2455888&quot;&gt;Важным моментом в&lt;/a&gt; отношении оператора Postfix &lt;code&gt;++&lt;/code&gt; является то, что:</target>
        </trans-unit>
        <trans-unit id="a38d1a7059ef11574a41d6295e5c3ee36deea981" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This&lt;/em&gt; answer tries to answer that question: why did your code not give you the answer you expected, and how can you learn to recognize (and avoid) expressions that will not work as expected.</source>
          <target state="translated">&lt;em&gt;Этот&lt;/em&gt; ответ пытается ответить на этот вопрос: почему ваш код не дал ожидаемого вами ответа, и как вы можете научиться распознавать (и избегать) выражения, которые не будут работать должным образом.</target>
        </trans-unit>
        <trans-unit id="cede1476cbfbaa036e6ccf5fced4facf59ce7d1f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unspecified behavior&lt;/em&gt; is defined in the &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;draft c99 standard&lt;/a&gt; in section &lt;code&gt;3.4.4&lt;/code&gt; as:</source>
          <target state="translated">&lt;em&gt;Неопределенное поведение&lt;/em&gt; определено в &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;проекте стандарта c99&lt;/a&gt; в разделе &lt;code&gt;3.4.4&lt;/code&gt; как:</target>
        </trans-unit>
        <trans-unit id="44b34df450374fa00c3d7262a922fe635b3fb310" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.4, unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.4.4, неопределенное поведение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b687a63b4511aca324bdbbc7328acb8be568d38d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Annex J, unspecified behaviours&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Приложение J, неопределенное поведение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad5e622d7c3f20a8ca11dc4608457c04512caa38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Between the previous and next sequence point an object shall have its stored value
  modified at most once&lt;/strong&gt; by the evaluation of an expression. Furthermore, &lt;strong&gt;the prior value
  shall be read only to determine the value to be stored&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Между предыдущей и следующей точкой последовательности объект должен иметь свое сохраненное значение, измененное не более одного раза&lt;/strong&gt; путем оценки выражения. Кроме того, &lt;strong&gt;предыдущее значение должно быть только для чтения, чтобы определить значение, которое будет сохранено&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="14c69e77d03fc3b5c073134689c8f8428458e027" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If a side effect on a scalar object is unsequenced relative to&lt;/strong&gt; either &lt;strong&gt;a different side effect on the same scalar object&lt;/strong&gt; or a value computation using the value of the same scalar object, &lt;strong&gt;the behavior is undefined&lt;/strong&gt;. [...]</source>
          <target state="translated">&lt;strong&gt;Если побочный эффект на скалярный объект не секвенирован относительно&lt;/strong&gt; &lt;strong&gt;другого побочного эффекта на тот же скалярный объект&lt;/strong&gt; или вычисления значения с использованием значения того же скалярного объекта, &lt;strong&gt;поведение не определено&lt;/strong&gt; . [...]</target>
        </trans-unit>
        <trans-unit id="05664d00aa9e447fc1d30a0bcf56db0f328bd362" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequence Point:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Точка последовательности:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9f49591f9696f388f781605342ac7b9ab2f5c5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequenced:&lt;/strong&gt; (5.1.2.3)</source>
          <target state="translated">&lt;strong&gt;Последовательность:&lt;/strong&gt; (5.1.2.3)</target>
        </trans-unit>
        <trans-unit id="64839962132bef2e8207e819c9d365f8efa46d5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unsequenced:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Unsequenced:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b35e23674ba2c887d039ae8bc54926f2a2c920fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;just because the &lt;code&gt;++&lt;/code&gt; comes after the variable does not mean that the increment happens late&lt;/strong&gt;. The increment can happen as early as the compiler likes &lt;em&gt;as long as the compiler ensures that the original value is used&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;просто потому, что &lt;code&gt;++&lt;/code&gt; идет после переменной, не означает, что приращение происходит поздно&lt;/strong&gt; . Приращение может произойти, как только компилятор захочет, &lt;em&gt;если компилятор гарантирует, что используется исходное значение&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f47bde17809faf3152a9c49b5ed547c7193a8237" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;side effects&lt;/strong&gt;, which are modifications of objects.</source>
          <target state="translated">&lt;strong&gt;побочные эффекты&lt;/strong&gt; , которые представляют собой модификации объектов.</target>
        </trans-unit>
        <trans-unit id="91ed0c6955be889d3390ace27c7202751c8e2aa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;value computations&lt;/strong&gt;, which work out the result of an expression; and</source>
          <target state="translated">&lt;strong&gt;вычисления значений&lt;/strong&gt; , которые вырабатывают результат выражения; и</target>
        </trans-unit>
        <trans-unit id="98e847c09ebd5e2f7d780741347784a05d1e1490" translate="yes" xml:space="preserve">
          <source>A good explanation about what happens in this kind of computation is provided in the document &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf&quot;&gt;n1188&lt;/a&gt; from &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/&quot;&gt;the ISO W14 site&lt;/a&gt;.</source>
          <target state="translated">Хорошее объяснение того, что происходит при такого рода вычислениях, приведено в документе &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf&quot;&gt;n1188&lt;/a&gt; с &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/&quot;&gt;сайта ISO W14&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e34012ee0723c9314bf3543db136c35ba444eab" translate="yes" xml:space="preserve">
          <source>After the actions associated with each formatted input/output function conversion specifier (7.21.6, 7.29.2).</source>
          <target state="translated">После действий,связанных с каждым форматированным спецификатором преобразования входных и выходных функций (7.21.6,7.29.2).</target>
        </trans-unit>
        <trans-unit id="34ab97668a5cbf8c450a7a5d95e5097551fcfcaf" translate="yes" xml:space="preserve">
          <source>And the last question is, how can you tell which expressions are well-defined, and which expressions are undefined?</source>
          <target state="translated">И последний вопрос-как определить,какие выражения хорошо определены,а какие нет?</target>
        </trans-unit>
        <trans-unit id="bae6a155cfc89c64a4a764fc6787a9b2227f41ac" translate="yes" xml:space="preserve">
          <source>Another detail is that the &lt;em&gt;comma&lt;/em&gt; involved in the printf() call is a &lt;em&gt;separator&lt;/em&gt;, not the &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma_operator&quot;&gt;&lt;em&gt;comma operator&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Другая деталь заключается в том, что &lt;em&gt;запятая,&lt;/em&gt; используемая в вызове printf (), является &lt;em&gt;разделителем&lt;/em&gt; , а не &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma_operator&quot;&gt;&lt;em&gt;оператором запятой&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03d05f648939561cc5196d6a1b460c6d6f3ae2fc" translate="yes" xml:space="preserve">
          <source>Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, &lt;em&gt;what are they supposed to mean?&lt;/em&gt;&lt;em&gt;What was the programmer trying to do?&lt;/em&gt;</source>
          <target state="translated">Другой способ ответить на этот вопрос, а не увязнуть в тайных деталях точек последовательности и неопределенного поведения, - просто спросить, &lt;em&gt;что они должны означать?&lt;/em&gt; &lt;em&gt;Что пытался сделать программист?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="454a87205b7cae96f48455860ea1befd4d1fe414" translate="yes" xml:space="preserve">
          <source>As I said earlier, the undefined expressions are the ones where there's too much going at once, where you can't be sure what order things happen in, and where the order matters:</source>
          <target state="translated">Как я уже говорил,неопределенные выражения-это те,в которых за один раз слишком много всего происходит,где нельзя быть уверенным,в каком порядке происходят вещи,и где порядок имеет значение:</target>
        </trans-unit>
        <trans-unit id="81111bf67780917ba78bc4f0f400157e26a8fb24" translate="yes" xml:space="preserve">
          <source>As an example of #1, in the expression</source>
          <target state="translated">В качестве примера #1,в выражении</target>
        </trans-unit>
        <trans-unit id="53c019261927786950c4738a085953640d98c525" translate="yes" xml:space="preserve">
          <source>As an example of #2, in the expression</source>
          <target state="translated">В качестве примера #2,в выражении</target>
        </trans-unit>
        <trans-unit id="55b849835da5250ac9a738c42f912f2f425d1886" translate="yes" xml:space="preserve">
          <source>As far as I know, the standard doesn't explicitly say &lt;em&gt;why&lt;/em&gt; the concept of undefined behavior exists. In my mind, it's simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.</source>
          <target state="translated">Насколько я знаю, в стандарте прямо не говорится, &lt;em&gt;почему существует&lt;/em&gt; понятие неопределенного поведения. На мой взгляд, это просто потому, что разработчики языка хотели, чтобы в семантике была некоторая свобода, вместо того, чтобы требовать, чтобы все реализации обрабатывали целочисленное переполнение точно таким же образом, что, скорее всего, повлекло бы за собой серьезные потери производительности, они просто оставили поведение undefined, так что если вы напишите код, который вызывает целочисленное переполнение, все может произойти.</target>
        </trans-unit>
        <trans-unit id="d8c378a722c25ac92808308a2ac719cb4b3053ff" translate="yes" xml:space="preserve">
          <source>As you've heard by now, all of these expressions are &lt;em&gt;undefined&lt;/em&gt;, which means that the C language makes no guarantee about what they'll do.  This is a strange and surprising result, because you probably thought that any program you could write, as long as it compiled and ran, would generate a unique, well-defined output.  But in the case of undefined behavior, that's not so.</source>
          <target state="translated">Как вы уже слышали, все эти выражения не &lt;em&gt;определены&lt;/em&gt; , что означает, что язык C не дает никаких гарантий относительно того, что они будут делать. Это странный и удивительный результат, потому что вы, вероятно, думали, что любая программа, которую вы можете написать, пока она компилируется и запускается, будет генерировать уникальный, четко определенный вывод. Но в случае неопределенного поведения это не так.</target>
        </trans-unit>
        <trans-unit id="22983dcf22f5d87d51da07d6260b26d0e70bc867" translate="yes" xml:space="preserve">
          <source>Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions: an initializer that is not part of a compound literal (6.7.9); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (if or switch) (6.8.4); the controlling expression of a while or do statement (6.8.5); each of the (optional) expressions of a for statement (6.8.5.3); the (optional) expression in a return statement (6.8.6.4).</source>
          <target state="translated">Между оценкой полного выражения и следующей оценкой полного выражения.Полными являются следующие выражения:инициализатор,не являющийся частью составного литерала (6.7.9);выражение в операторе выражений (6.8.3);контрольное выражение оператора выбора (если или переключаться)(6.8.4);контрольное выражение оператора while или do (6.8.5);каждое из (необязательных)выражений оператора for (6.8.5.3);(необязательное)выражение в возвращаемом операторе (6.8.6.4).</target>
        </trans-unit>
        <trans-unit id="040e4fe9d9fa542dc4ba06a43851d6aa5a72dd54" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the first and second operands of the following operators: logical AND &amp;amp;&amp;amp; (6.5.13); logical OR || (6.5.14); comma , (6.5.17).</source>
          <target state="translated">Между вычислениями первого и второго операндов используются следующие операторы: логическое И &amp;amp; &amp;amp; (6.5.13); логическое ИЛИ || (6.5.14); запятая, (6.5.17).</target>
        </trans-unit>
        <trans-unit id="4ad551d09f57149aadd870dc2cb52328b435e78b" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the first operand of the conditional ? : operator and whichever of the second and third operands is evaluated (6.5.15).</source>
          <target state="translated">Между оценками первого операнда условного оператора ?:и тем,какой из операндов второго и третьего вычисляется (6.5.15).</target>
        </trans-unit>
        <trans-unit id="c5fd30fab6709015ef08a8e61b2e1f1954973f1f" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the function designator and actual arguments in a function call and the actual call. (6.5.2.2).</source>
          <target state="translated">Между вычислениями обозначения функции и фактическими аргументами в вызове функции и фактическим вызовом.(6.5.2.2).</target>
        </trans-unit>
        <trans-unit id="a81e8350af213ee569d9aa330eca2c02262e4edf" translate="yes" xml:space="preserve">
          <source>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.   Furthermore, the prior value shall be read only to determine the value to be stored.</source>
          <target state="translated">Между предыдущей и следующей точкой следования объект должен иметь сохраненное значение,измененное не более одного раза путем оценки выражения.Кроме того,предыдущее значение должно быть прочитано только для определения хранимого значения.</target>
        </trans-unit>
        <trans-unit id="63273c8e87c71a3a8d9d6a1d10757a35596fab39" translate="yes" xml:space="preserve">
          <source>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]</source>
          <target state="translated">Между предыдущей и следующей точкой следования объект должен иметь сохраненное значение,измененное не более одного раза путем оценки выражения.Кроме того,предыдущее значение должно считываться только для определения хранимого значения [73].</target>
        </trans-unit>
        <trans-unit id="7a87c40d2167a7f023df7ecb1485eff49c8549a2" translate="yes" xml:space="preserve">
          <source>But, to your surprise, this program did &lt;em&gt;not&lt;/em&gt; help you understand -- it printed some strange, unexpected, inexplicable output, suggesting that maybe &lt;code&gt;++&lt;/code&gt; does something completely different, not at all what you thought it did.</source>
          <target state="translated">Но, к вашему удивлению, эта программа &lt;em&gt;не&lt;/em&gt; помогла вам понять - она ​​напечатала какой-то странный, неожиданный, необъяснимый вывод, предполагая, что, возможно, &lt;code&gt;++&lt;/code&gt; делает что-то совершенно другое, совсем не то, что вы думали, что оно сделало.</target>
        </trans-unit>
        <trans-unit id="47b2772f5f51e294039858c5f54b8729f2f5faff" translate="yes" xml:space="preserve">
          <source>C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can't predict the behavior when the code is run.</source>
          <target state="translated">В языке C есть понятие неопределённого поведения,т.е.некоторые конструкции языка являются синтаксически действительными,но вы не можете предсказать поведение при выполнении кода.</target>
        </trans-unit>
        <trans-unit id="8b35348453822488b14536bba94a12260b7b744a" translate="yes" xml:space="preserve">
          <source>C, of course, has a handy shortcut:</source>
          <target state="translated">У C,конечно,есть удобный короткий путь:</target>
        </trans-unit>
        <trans-unit id="313385540ea390474e5c604236fc46b3e7089c47" translate="yes" xml:space="preserve">
          <source>Depending on whether assignment occurs before or after the increment, different results will be produced and that's the one of the case of &lt;strong&gt;undefined behavior&lt;/strong&gt;.</source>
          <target state="translated">В зависимости от того, происходит ли присвоение до или после приращения, будут получены разные результаты, и это один из случаев &lt;strong&gt;неопределенного поведения&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2134df76c62a65d697e36a56132e1c70153997df" translate="yes" xml:space="preserve">
          <source>Doesn't operator precedence determine the order of evaluation?</source>
          <target state="translated">Разве приоритет оператора не определяет порядок оценки?</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="7ab87e9f1e4738df5111adf51d681da54745c555" translate="yes" xml:space="preserve">
          <source>EXAMPLE An example of unspecified behavior is the order in which the
  arguments to a function are evaluated.</source>
          <target state="translated">ПРИМЕР Пример неуказанного поведения-порядок вычисления аргументов к функции.</target>
        </trans-unit>
        <trans-unit id="d272d8479ec26da7fb7b5e1ab650055e01f0dee7" translate="yes" xml:space="preserve">
          <source>Evaluations can be one of two things:</source>
          <target state="translated">Оценка может быть одной из двух вещей:</target>
        </trans-unit>
        <trans-unit id="ea93a535df109ca0d906a45b2cc9253d643f49d8" translate="yes" xml:space="preserve">
          <source>For the expressions we're talking about what makes them undefined is when there's too much going on at once, when we're not sure what order things will happen in, but when the order matters to the result we get.</source>
          <target state="translated">Для выражений,о которых мы говорим,что делает их неопределенными,это когда происходит слишком много сразу,когда мы не уверены,в каком порядке будут происходить вещи,но когда порядок имеет значение для результата,который мы получаем.</target>
        </trans-unit>
        <trans-unit id="57433c0a1b88252b7699f889dbc52ef5538d3c60" translate="yes" xml:space="preserve">
          <source>For those who are new to &lt;em&gt;undefined behaviour&lt;/em&gt; would benefit from reading &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&quot;&gt;What Every C Programmer Should Know About Undefined Behavior&lt;/a&gt;  to understand the concept and many other variants of undefined behaviour in C.</source>
          <target state="translated">Для тех, кто &lt;em&gt;плохо знаком&lt;/em&gt; с &lt;em&gt;неопределенным поведением,&lt;/em&gt; было бы полезно прочитать, &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&quot;&gt;что каждый программист C должен знать о неопределенном поведении,&lt;/a&gt; чтобы понять концепцию и многие другие варианты неопределенного поведения на C.</target>
        </trans-unit>
        <trans-unit id="a21b34979360402374873c62d1af6606d5786e66" translate="yes" xml:space="preserve">
          <source>Given any two evaluations &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, if &lt;code&gt;A&lt;/code&gt; is sequenced before &lt;code&gt;B&lt;/code&gt;, then the execution of &lt;code&gt;A&lt;/code&gt; shall precede the execution of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">При любых двух оценках &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; , если &lt;code&gt;A&lt;/code&gt; упорядочен перед &lt;code&gt;B&lt;/code&gt; , тогда выполнение &lt;code&gt;A&lt;/code&gt; должно предшествовать выполнению &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="006ec1d5652cc2abca4a9e550b4b2c9adaa218a5" translate="yes" xml:space="preserve">
          <source>How does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).</source>
          <target state="translated">Как работает GCC? он оценивает подвыражения в порядке справа налево для правой стороны (RHS),затем присваивает значение левой стороне (LHS).Именно так ведут себя Java и C#и определяют свои стандарты.(Да,эквивалентное программное обеспечение на Java и C#определяет поведение).Оно оценивает каждое подвыражение по одному в RHS-операторе в порядке слева направо;для каждого подвыражения:сначала вычисляется ++c (пре-инкремент),затем для операции используется значение c,затем пост-инкремент c++).</target>
        </trans-unit>
        <trans-unit id="2bdbd46fa92ff631f11ad5cb03611cba2db7660a" translate="yes" xml:space="preserve">
          <source>How does visual studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass.</source>
          <target state="translated">Как работает визуальная студия,она использует другой подход,в первом проходе вычисляет все преинкрементные выражения,во втором проходе использует значения переменных,в третьем проходе присваивает из RHS в LHS,а в последнем проходе вычисляет все постинкрементные выражения за один проход.</target>
        </trans-unit>
        <trans-unit id="c72c73363ab17f40ba3f10293b5bd49072e48feb" translate="yes" xml:space="preserve">
          <source>However if you stick to one compiler, you will find the behavior persistent, as long as you don't add function calls or pointers, which would make the behavior more messy.</source>
          <target state="translated">Однако,если вы будете придерживаться одного компилятора,поведение будет продолжаться до тех пор,пока вы не добавите вызовы функций или указатели,что сделает поведение более грязным.</target>
        </trans-unit>
        <trans-unit id="7da8149973e9017187a301f4973c6be9158d15d5" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;,&lt;/code&gt; in function argument lists is &lt;em&gt;not&lt;/em&gt; a comma operator, and there is no sequence point between evaluations of distinct arguments; instead their evaluations are unsequenced with regard to each other; so the function call</source>
          <target state="translated">Однако списки аргументов функции &lt;em&gt;не&lt;/em&gt; являются запятыми, и между оценками различных аргументов нет точки последовательности; вместо этого их оценки не последовательны по отношению друг к другу; поэтому вызов функции</target>
        </trans-unit>
        <trans-unit id="8ff4f957f0bef850d0e13306eb783d225574c291" translate="yes" xml:space="preserve">
          <source>However, two different variables can be incremented between two sequence points.</source>
          <target state="translated">Однако между двумя точками следования могут быть увеличены две различные переменные.</target>
        </trans-unit>
        <trans-unit id="a4e9fd2fb6e6a52790d78e1ea1a9104776d97482" translate="yes" xml:space="preserve">
          <source>I assume you've heard the basic definition of C's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; operators by now, and how the prefix form &lt;code&gt;++x&lt;/code&gt; differs from the postfix form &lt;code&gt;x++&lt;/code&gt;.  But these operators are hard to think about, so to make sure you understood, perhaps you wrote a tiny little test program involving something like</source>
          <target state="translated">Я предполагаю, что вы уже слышали базовое определение операторов C &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; , и чем префиксная форма &lt;code&gt;++x&lt;/code&gt; отличается от постфиксной формы &lt;code&gt;x++&lt;/code&gt; . Но об этих операторах трудно думать, поэтому, чтобы убедиться, что вы поняли, возможно, вы написали крошечную тестовую программу, включающую что-то вроде</target>
        </trans-unit>
        <trans-unit id="d2b970b978a071c4f163f23f1f4e314def839a10" translate="yes" xml:space="preserve">
          <source>I explain the ideas.</source>
          <target state="translated">Я объясняю идеи.</target>
        </trans-unit>
        <trans-unit id="7e1cdd37254f419dc8e9ee3785767a5fcd30479d" translate="yes" xml:space="preserve">
          <source>I think the relevant parts of the C99 standard are 6.5 Expressions, &amp;sect;2</source>
          <target state="translated">Я думаю, что соответствующие части стандарта C99 - 6,5 выражений, &amp;sect;2</target>
        </trans-unit>
        <trans-unit id="ebb30d2d2d8387aa698cfa701d3a0b2ef943f61b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is not sequenced before or after &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are unsequenced.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; не секвенируется до или после &lt;code&gt;B&lt;/code&gt; , то &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; не секвенируются.</target>
        </trans-unit>
        <trans-unit id="2e8615005607bfaf839090f5116302468a3077a1" translate="yes" xml:space="preserve">
          <source>If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84)</source>
          <target state="translated">Если побочный эффект на скалярном объекте является непоследовательным относительно либо другого побочного эффекта на одном и том же скалярном объекте,либо вычисления значения с использованием значения одного и того же скалярного объекта,поведение является неопределенным.Если существует несколько допустимых порядков подвыражений выражения,поведение не определено,если такой непоследовательный побочный эффект возникает в любом из порядков84).</target>
        </trans-unit>
        <trans-unit id="6b364d00d6c222691294e1d715a9d3195c3b8d0b" translate="yes" xml:space="preserve">
          <source>If the compiler were to write &lt;code&gt;i++&lt;/code&gt; as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn't happen to notice that one of the other instructions happened to access &lt;code&gt;i&lt;/code&gt;, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable &lt;code&gt;i&lt;/code&gt; is used in both places, but if a routine accepts references to two pointers &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;, and uses &lt;code&gt;(*p)&lt;/code&gt; and &lt;code&gt;(*q)&lt;/code&gt; in the above expression (rather than using &lt;code&gt;i&lt;/code&gt; twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same object's address were passed for both &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">Если бы компилятор должен был написать &lt;code&gt;i++&lt;/code&gt; как указано выше (юридически согласно стандарту), и должен был перемежать вышеприведенные инструкции во время оценки общего выражения (также легально), и если не случилось, заметил, что одна из других инструкций в случае доступа к &lt;code&gt;i&lt;/code&gt; , для компилятора было бы возможно (и законно) сгенерировать последовательность инструкций, которые бы зашли в тупик. Безусловно, компилятор почти наверняка обнаружит проблему в случае, когда одна и та же переменная &lt;code&gt;i&lt;/code&gt; используется в обоих местах, но если подпрограмма принимает ссылки на два указателя &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;q&lt;/code&gt; и использует &lt;code&gt;(*p)&lt;/code&gt; и &lt;code&gt;(*q)&lt;/code&gt; в приведенном выше выражении (вместо использования &lt;code&gt;i&lt;/code&gt; дважды) компилятору не потребуется распознавать или избегать тупиковой ситуации, которая возникнет, если один и тот же адрес объекта будет передан как для &lt;code&gt;p&lt;/code&gt; ,так и для &lt;code&gt;q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c74bddb68bd6a38d49d02706436102a8da2c6744" translate="yes" xml:space="preserve">
          <source>If there's a variable that's getting modified in one place, and having its value used in another place, how do you know whether it uses the old value or the new value?</source>
          <target state="translated">Если есть переменная,которая изменяется в одном месте,и ее значение используется в другом месте,как узнать,использует ли она старое или новое значение?</target>
        </trans-unit>
        <trans-unit id="4647db1287f30dfb23b1f0e049be0ffce3ceebe7" translate="yes" xml:space="preserve">
          <source>If there's one variable that's getting modified (assigned to) in two or more different places, how do you know which modification happens first?</source>
          <target state="translated">Если есть одна переменная,которая модифицируется (присваивается)в двух или более разных местах,как узнать,какая модификация происходит в первую очередь?</target>
        </trans-unit>
        <trans-unit id="ee1d81c9d526b617cd5db47f0b9129a56d6d92fc" translate="yes" xml:space="preserve">
          <source>Immediately before a library function returns (7.1.4).</source>
          <target state="translated">Непосредственно перед возвращением библиотечной функции (7.1.4).</target>
        </trans-unit>
        <trans-unit id="ccc935207dc7de3d090caefd6346b4420b8001d0" translate="yes" xml:space="preserve">
          <source>Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.22.5).</source>
          <target state="translated">Непосредственно перед и сразу после каждого вызова функции сравнения,а также между любым вызовом функции сравнения и любым движением объектов,переданных в качестве аргументов этому вызову (7.22.5).</target>
        </trans-unit>
        <trans-unit id="60ed5174c21627240c96b7033c369a5233234943" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&quot;&gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&lt;/a&gt; someone asked about a statement like:</source>
          <target state="translated">В &lt;a href=&quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&quot;&gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&lt;/a&gt; кто-то спросил о таком утверждении, как:</target>
        </trans-unit>
        <trans-unit id="e29fa6906c297000780a6ab5da38fae509305f9d" translate="yes" xml:space="preserve">
          <source>In GCC C++,  the precedence of the operators controls the order in
  which the individual operators are evaluated</source>
          <target state="translated">В GCC C++приоритет операторов контролирует порядок,в котором оцениваются отдельные операторы</target>
        </trans-unit>
        <trans-unit id="eb8013ee2895e4b793b24f5480886aca31c43b1e" translate="yes" xml:space="preserve">
          <source>In all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the &lt;code&gt;;&lt;/code&gt; in each one of these cases:</source>
          <target state="translated">Во всех этих примерах код пытается изменить объект более одного раза в одной и той же точке последовательности, что заканчивается на &lt;code&gt;;&lt;/code&gt; в каждом из этих случаев:</target>
        </trans-unit>
        <trans-unit id="85af2d68b64dacc2ecae8e6b8fe0626d9c55f451" translate="yes" xml:space="preserve">
          <source>In the following statement:</source>
          <target state="translated">В следующем заявлении:</target>
        </trans-unit>
        <trans-unit id="57437b57542ff5ccdb46668e495487b9f29b828e" translate="yes" xml:space="preserve">
          <source>In the paper that I quoted above it is explained that you can figure out the program as being formed by small boxes, each box containing the instructions between 2 consecutive sequence points.  The sequence points are defined in annex C of the standard, in the case of &lt;code&gt;i=i++&lt;/code&gt; there are 2 sequence points that delimit a full-expression.  Such an expression is syntactically equivalent with an entry of &lt;code&gt;expression-statement&lt;/code&gt; in the Backus-Naur form of the grammar (a grammar is provided in annex A of the Standard).</source>
          <target state="translated">В статье, которую я цитировал выше, объясняется, что вы можете понять, что программа состоит из маленьких прямоугольников, каждый из которых содержит инструкции между двумя последовательными точками последовательности. Точки последовательности определены в приложении C к стандарту, в случае &lt;code&gt;i=i++&lt;/code&gt; есть две точки последовательности, которые ограничивают полное выражение. Такое выражение синтаксически эквивалентно записи &lt;code&gt;expression-statement&lt;/code&gt; в форме грамматики Бэкуса-Наура (грамматика приведена в приложении А к Стандарту).</target>
        </trans-unit>
        <trans-unit id="dab7f2edb9365a8a8024bd3b99b725247b21d547" translate="yes" xml:space="preserve">
          <source>It means the expression &lt;code&gt;il = ir++&lt;/code&gt; could be evaluated either as</source>
          <target state="translated">Это означает, что выражение &lt;code&gt;il = ir++&lt;/code&gt; может быть оценено как</target>
        </trans-unit>
        <trans-unit id="6d4bde792ab173fc5f3953aa5c52bd9c3b953ae4" translate="yes" xml:space="preserve">
          <source>Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.</source>
          <target state="translated">Просто скомпилируйте и разберите ваш код,если вы так склонны знать,как именно вы получаете то,что получаете.</target>
        </trans-unit>
        <trans-unit id="139c53c1c422cb855e5ab14ec329f7d3e7293cf2" translate="yes" xml:space="preserve">
          <source>Let's go back to the two examples I've used in this answer.  When I wrote</source>
          <target state="translated">Давайте вернемся к двум примерам,которые я использовал в этом ответе.Когда я писал</target>
        </trans-unit>
        <trans-unit id="007b8d5a96beaf6791ee66ac241a455d31c8ebee" translate="yes" xml:space="preserve">
          <source>Lets rename the &lt;code&gt;i&lt;/code&gt; at left of assignment be &lt;code&gt;il&lt;/code&gt; and at the right of assignment (in the expression &lt;code&gt;i++&lt;/code&gt;) be &lt;code&gt;ir&lt;/code&gt;, then the expression be like</source>
          <target state="translated">Давайте переименуем &lt;code&gt;i&lt;/code&gt; слева от присваивания быть &lt;code&gt;il&lt;/code&gt; , а справа от присваивания (в выражении &lt;code&gt;i++&lt;/code&gt; ) - &lt;code&gt;ir&lt;/code&gt; , тогда выражение будет похоже</target>
        </trans-unit>
        <trans-unit id="0e79c62d8a96cc83c832406559fd72c325b73755" translate="yes" xml:space="preserve">
          <source>Modern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).</source>
          <target state="translated">Современные компиляторы очень хорошо это оптимизируют.На самом деле,возможно,лучше,чем код,который вы написали изначально (предполагая,что он работал так,как вы надеялись).</target>
        </trans-unit>
        <trans-unit id="abffaa693417a99890a9f9f411f179a50d8a1f83" translate="yes" xml:space="preserve">
          <source>Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand &lt;strong&gt;why the behavior of these constructs are undefined&lt;/strong&gt;, let's understand these terms first in the light of C11 standard:</source>
          <target state="translated">Большинство ответов здесь процитированы из стандарта C, подчеркивая, что поведение этих конструкций не определено. Чтобы понять, &lt;strong&gt;почему поведение этих конструкций не определено&lt;/strong&gt; , давайте сначала разберемся в этих терминах в свете стандарта C11:</target>
        </trans-unit>
        <trans-unit id="65659095c4721a9366d72724c0af8686528c6a8e" translate="yes" xml:space="preserve">
          <source>Now coming to the question, for the expressions like</source>
          <target state="translated">Теперь перейдем к вопросу,для таких выражений,как</target>
        </trans-unit>
        <trans-unit id="b011b82c9d0b255b15ca16ab67361428cc130072" translate="yes" xml:space="preserve">
          <source>Often this question is linked as a duplicate of questions related to code like</source>
          <target state="translated">Часто этот вопрос связан как дубликат вопросов,относящихся к коду типа</target>
        </trans-unit>
        <trans-unit id="80af210ba078168ac8aed18f4c289fb13eafe061" translate="yes" xml:space="preserve">
          <source>Or, perhaps you're looking at a hard-to-understand expression like</source>
          <target state="translated">Или,возможно,вы смотрите на труднопонятное выражение вроде</target>
        </trans-unit>
        <trans-unit id="7814f3637cef69793eb4cd0c35453c057b2b2e5b" translate="yes" xml:space="preserve">
          <source>Other good source for explaining such ambiguities are the entries from &lt;a href=&quot;http://c-faq.com/&quot;&gt;c-faq&lt;/a&gt; site (also published &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201845199&quot;&gt;as a book&lt;/a&gt;) , namely &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://c-faq.com/expr/evalorder4.html&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://c-faq.com/expr/confused.html&quot;&gt;here&lt;/a&gt; .</source>
          <target state="translated">Другим хорошим источником для объяснения такой неоднозначности являются записи с сайта &lt;a href=&quot;http://c-faq.com/&quot;&gt;c-faq&lt;/a&gt; (также опубликованные &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201845199&quot;&gt;в виде книги&lt;/a&gt; ), а именно &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;здесь,&lt;/a&gt; &lt;a href=&quot;http://c-faq.com/expr/evalorder4.html&quot;&gt;здесь&lt;/a&gt; и &lt;a href=&quot;http://c-faq.com/expr/confused.html&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="270467ed08a16c4189f257fa18a363287c860a70" translate="yes" xml:space="preserve">
          <source>Perhaps someone gave you that code as a puzzle.  This code also makes no sense, especially if you run it -- and if you compile and run it under two different compilers, you're likely to get two different answers!  What's up with that?  Which answer is correct?  (And the answer is that both of them are, or neither of them are.)</source>
          <target state="translated">Возможно,кто-то дал тебе этот код в качестве головоломки.Этот код также не имеет смысла,особенно если вы его запускаете --и если вы скомпилируете и запустите его под двумя разными компиляторами,вы,скорее всего,получите два разных ответа! Что это такое? Какой ответ правильный? (И ответ в том,что оба они или ни один из них).</target>
        </trans-unit>
        <trans-unit id="9830e65c22471dbb5ae76ba87a9754d88a6b0759" translate="yes" xml:space="preserve">
          <source>Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</source>
          <target state="translated">Возможное неопределённое поведение варьируется от игнорирования ситуации полностью с непредсказуемыми результатами,до поведения во время трансляции или выполнения программы в документированной форме,характерной для данной среды (с выдачей или без выдачи диагностического сообщения),до прекращения трансляции или выполнения (с выдачей диагностического сообщения).</target>
        </trans-unit>
        <trans-unit id="d4ec24e520c2deaf639afba4b9f783d5aac04aab" translate="yes" xml:space="preserve">
          <source>Realistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, &quot;If it's not obvious what an expression using ++ means, don't write it.&quot;</source>
          <target state="translated">Реалистично эти сумасшедшие выражения пишутся только тогда,когда люди используют их в качестве искусственных примеров того,как должен работать ++.И,конечно же,важно понимать,как работает ++.Но одно практическое правило использования ++:&quot;Если не очевидно,что означает выражение,использующее ++,не пишите его&quot;.</target>
        </trans-unit>
        <trans-unit id="6343a0dd7d4a3cce5612fb2bd80119beebcf602a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;question 3.8&lt;/a&gt; and the rest of the questions in &lt;a href=&quot;http://c-faq.com/expr/index.html&quot;&gt;section 3&lt;/a&gt; of the &lt;a href=&quot;http://c-faq.com/&quot;&gt;C FAQ list&lt;/a&gt;.</source>
          <target state="translated">См. Также &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;вопрос 3.8&lt;/a&gt; и остальные вопросы в &lt;a href=&quot;http://c-faq.com/expr/index.html&quot;&gt;разделе 3&lt;/a&gt; &lt;a href=&quot;http://c-faq.com/&quot;&gt;списка C FAQ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b00a321a9495c839c828a507be825ff13a7800c" translate="yes" xml:space="preserve">
          <source>So a sequence point can be seen by the beginning and the end of each box that composes the program [the boxes are atomic units in C] and inside a box the order of instructions is not defined in all cases.  Changing that order one can change the result sometimes.</source>
          <target state="translated">Таким образом,точка следования видна по началу и концу каждого ящика,составляющего программу [ящики являются атомными единицами в C],а внутри ящика не во всех случаях определен порядок следования инструкций.Изменяя этот порядок иногда можно изменить результат.</target>
        </trans-unit>
        <trans-unit id="d21ba0d230406e77017c4520bffdb2aae21a3660" translate="yes" xml:space="preserve">
          <source>So every statement of the form:</source>
          <target state="translated">Так что каждое утверждение формы:</target>
        </trans-unit>
        <trans-unit id="647883dff5588a701bbd3395f0dfc501b2bb13be" translate="yes" xml:space="preserve">
          <source>So first the GCC:
Using &lt;a href=&quot;https://nuwen.net/mingw.html&quot;&gt;Nuwen MinGW&lt;/a&gt; 15 GCC 7.1 you will get:</source>
          <target state="translated">Итак, сначала GCC: Используя &lt;a href=&quot;https://nuwen.net/mingw.html&quot;&gt;Nuwen MinGW&lt;/a&gt; 15 GCC 7.1, вы получите:</target>
        </trans-unit>
        <trans-unit id="e1619e58534e7a9257bad023ee9910dd4500fdf3" translate="yes" xml:space="preserve">
          <source>So if the &lt;em&gt;comma&lt;/em&gt; in the function call were to be a comma operator then</source>
          <target state="translated">Так что, если &lt;em&gt;запятая&lt;/em&gt; в вызове функции должна быть оператором запятой, то</target>
        </trans-unit>
        <trans-unit id="d80658b592df0803b15a8dd4666f791a7e32f7f1" translate="yes" xml:space="preserve">
          <source>So moving on to &lt;em&gt;unspecified behavior&lt;/em&gt;, in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;draft c99 standard&lt;/a&gt; section&lt;code&gt;6.5&lt;/code&gt; paragraph &lt;em&gt;3&lt;/em&gt; says(&lt;em&gt;emphasis mine&lt;/em&gt;):</source>
          <target state="translated">Итак, переходя к &lt;em&gt;неопределенному поведению&lt;/em&gt; , в &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;черновике c99 стандарта c99&lt;/a&gt; параграф &lt;em&gt;3&lt;/em&gt; гласит ( &lt;em&gt;выделено мной&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="de08ea26a98f633b8bc219b190df93d9fb9ddf4e" translate="yes" xml:space="preserve">
          <source>So that's the answer: make sure that in any expression you write, each variable is modified at most once, and if a variable is modified, you don't also attempt to use the value of that variable somewhere else.</source>
          <target state="translated">Вот и ответ:убедитесь,что в любом написанном вами выражении каждая переменная изменяется максимум один раз,и если переменная изменяется,вы также не пытаетесь использовать значение этой переменной где-то еще.</target>
        </trans-unit>
        <trans-unit id="fe5b5ad4189e6c54f36de1b0cb2dd509ca3eedca" translate="yes" xml:space="preserve">
          <source>So the equivalent in defined behavior C++ as Visual C++ understands:</source>
          <target state="translated">То есть эквивалент в определенном поведении С++,как понимает Visual C++:</target>
        </trans-unit>
        <trans-unit id="39e26ec98db22aab7bb548688a3cf6b65be062cd" translate="yes" xml:space="preserve">
          <source>So the order of instructions inside a box has no clear order.</source>
          <target state="translated">Таким образом,порядок указания внутри коробки не имеет четкого порядка.</target>
        </trans-unit>
        <trans-unit id="0813b942e4187634ff676479cc7529a6a62bd091" translate="yes" xml:space="preserve">
          <source>So when we have a line like this:</source>
          <target state="translated">Так что,когда у нас есть такая линия:</target>
        </trans-unit>
        <trans-unit id="51bff8d93419b8b376c49a4c4c1c6942815bd3f1" translate="yes" xml:space="preserve">
          <source>So with all that background and introduction out of the way, if you want to make sure that all your programs are well-defined, which expressions can you write, and which ones can you not write?</source>
          <target state="translated">Итак,со всем этим фоном и введением,если Вы хотите удостовериться,что все Ваши программы хорошо определены,какие выражения Вы можете писать,а какие нет?</target>
        </trans-unit>
        <trans-unit id="418454311311342d72ab9381129cfc784f14f285" translate="yes" xml:space="preserve">
          <source>So, with that in mind, why are these &quot;issues&quot;? The language clearly says that certain things lead to &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;undefined behavior&lt;/a&gt;. There is no problem, there is no &quot;should&quot; involved. If the undefined behavior changes when one of the involved variables is declared &lt;code&gt;volatile&lt;/code&gt;, that doesn't prove or change anything. It is &lt;em&gt;undefined&lt;/em&gt;; you cannot reason about the behavior.</source>
          <target state="translated">Итак, с учетом этого, почему эти &quot;проблемы&quot;? Язык ясно говорит, что определенные вещи приводят к &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;неопределенному поведению&lt;/a&gt; . Нет проблем, нет &amp;laquo;надо&amp;raquo; участвовать. Если неопределенное поведение изменяется, когда одна из задействованных переменных объявлена ​​как &lt;code&gt;volatile&lt;/code&gt; , это ничего не доказывает и не меняет. Это не &lt;em&gt;определено&lt;/em&gt; ; Вы не можете рассуждать о поведении.</target>
        </trans-unit>
        <trans-unit id="52169783c5f1f44d70c71ae0d258a149699e59f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;++i&lt;/code&gt; increments aren't guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 &lt;code&gt;++i&lt;/code&gt; executed, then the values of &lt;code&gt;k[]&lt;/code&gt; were read, then the last &lt;code&gt;++i&lt;/code&gt; then &lt;code&gt;k[]&lt;/code&gt;.</source>
          <target state="translated">Инкременты &lt;code&gt;++i&lt;/code&gt; не гарантируются для всех завершенных до остальных вычислений. Фактически, разные компиляторы будут получать разные результаты здесь. В приведенном вами примере сначала были выполнены 2 &lt;code&gt;++i&lt;/code&gt; , затем были прочитаны значения &lt;code&gt;k[]&lt;/code&gt; , затем последний &lt;code&gt;++i&lt;/code&gt; и &lt;code&gt;k[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b497b90b5e9411034420efd2bf3531f465b5abe8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;unspecified behaviour&lt;/em&gt; itself is NOT an issue. Consider this example:</source>
          <target state="translated">&lt;em&gt;Неопределенное поведение&lt;/em&gt; само по себе НЕ является проблемой. Рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="aef2dc12b657421591a01f033cfac67b5ba2c01f" translate="yes" xml:space="preserve">
          <source>The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point.</source>
          <target state="translated">Стандарт С гласит,что переменная должна присваиваться не более одного раза между двумя точками следования.Полуколонна,например,является точкой следования.</target>
        </trans-unit>
        <trans-unit id="310e41e0df172a9305a8811318f58058e4fed9e9" translate="yes" xml:space="preserve">
          <source>The above is a common coding practice while copying/analysing strings.</source>
          <target state="translated">Вышеизложенное является обычной практикой кодирования при копировании строк.</target>
        </trans-unit>
        <trans-unit id="c5e1fbdb0b52dfbb81762c5648cb9c71849abbe4" translate="yes" xml:space="preserve">
          <source>The behavior can't really be explained because it invokes both &lt;a href=&quot;http://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;unspecified behavior&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;undefined behavior&lt;/a&gt;, so we can not make any general predictions about this code, although if you read &lt;em&gt;Olve Maudal's&lt;/em&gt; work such as &lt;a href=&quot;http://www.slideshare.net/olvemaudal/deep-c&quot;&gt;Deep C&lt;/a&gt; and &lt;a href=&quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf&quot;&gt;Unspecified and Undefined&lt;/a&gt; sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don't do that anywhere near production.</source>
          <target state="translated">Поведение на самом деле не может быть объяснено, потому что оно вызывает как &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;неопределенное поведение&lt;/a&gt; , так и неопределенное поведение , поэтому мы не можем делать какие-либо общие предсказания об этом коде, хотя, если вы читаете работы &lt;em&gt;Олве Модала,&lt;/em&gt; такие как &lt;a href=&quot;http://www.slideshare.net/olvemaudal/deep-c&quot;&gt;Deep C&lt;/a&gt; и &lt;a href=&quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf&quot;&gt;Unspecified и Undefined,&lt;/a&gt; иногда вы можете сделать хорошо угадывает в очень специфических случаях с конкретным компилятором и средой, но, пожалуйста, не делайте этого где-нибудь рядом с производством</target>
        </trans-unit>
        <trans-unit id="27ec791e6f2a00a49e0a8a0ed54e4616a7f3a094" translate="yes" xml:space="preserve">
          <source>The comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in &lt;code&gt;j = (++i, i++);&lt;/code&gt;, &lt;code&gt;++i&lt;/code&gt; increments &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; and &lt;code&gt;i++&lt;/code&gt; yields old value of &lt;code&gt;i&lt;/code&gt; (&lt;code&gt;6&lt;/code&gt;) which is assigned to &lt;code&gt;j&lt;/code&gt;. Then &lt;code&gt;i&lt;/code&gt; becomes &lt;code&gt;7&lt;/code&gt; due to post-increment.</source>
          <target state="translated">Оператор запятой оценивает свои операнды слева направо и выдает только значение последнего операнда. Так в &lt;code&gt;j = (++i, i++);&lt;/code&gt; , &lt;code&gt;++i&lt;/code&gt; увеличивает &lt;code&gt;i&lt;/code&gt; до &lt;code&gt;6&lt;/code&gt; , а &lt;code&gt;i++&lt;/code&gt; возвращает старое значение &lt;code&gt;i&lt;/code&gt; ( &lt;code&gt;6&lt;/code&gt; ), которое присваивается &lt;code&gt;j&lt;/code&gt; . Тогда &lt;code&gt;i&lt;/code&gt; становлюсь &lt;code&gt;7&lt;/code&gt; из-за постинкремента.</target>
        </trans-unit>
        <trans-unit id="b67dbcc4d76d135a5736d6b29c5429827a1f48d3" translate="yes" xml:space="preserve">
          <source>The end of a full declarator: declarators (6.7.6);</source>
          <target state="translated">Конец полного декларатора:деклараторы (6.7.6);</target>
        </trans-unit>
        <trans-unit id="0108968d37f78fc724b69ab92c9f870191ada9e6" translate="yes" xml:space="preserve">
          <source>The first fragment asked about, &lt;code&gt;i = i++ + ++i&lt;/code&gt;, is pretty clearly insane in my book.  No one would ever write it in a real program, it's not obvious what it does, there's no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it's not obvious to you and me what it's supposed to do, it's fine in my book if the compiler can't figure out what it's supposed to do, either.</source>
          <target state="translated">Первый фрагмент, о котором &lt;code&gt;i = i++ + ++i&lt;/code&gt; спрашиваю, i = i ++ + ++ i , в моей книге совершенно безумен. Никто никогда не напишет ее в реальной программе, не очевидно, что она делает, нет мыслимого алгоритма, который кто-то мог бы пытаться кодировать, который привел бы к этой конкретной надуманной последовательности операций. И поскольку для нас и для нас не очевидно, что он должен делать, в моей книге хорошо, если компилятор не может понять, что он должен делать.</target>
        </trans-unit>
        <trans-unit id="90a68f87988cd45f4bd6311c6ab3e5a1dc45538e" translate="yes" xml:space="preserve">
          <source>The following are the sequence points described in 5.1.2.3:</source>
          <target state="translated">Ниже приведены точки следования,описанные в пункте 5.1.2.3:</target>
        </trans-unit>
        <trans-unit id="902611ed1501ed869ca53ff5d324e744ab75270b" translate="yes" xml:space="preserve">
          <source>The grouping of operators and operands is indicated by the syntax.74) Except as specified
  later (for the function-call (), &amp;amp;&amp;amp;, ||, ?:, and comma operators), &lt;strong&gt;the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.&lt;/strong&gt;</source>
          <target state="translated">Группировка операторов и операндов указывается синтаксисом.74) За исключением случаев, указанных позднее (для операторов function-call (), &amp;amp;&amp;amp;, ||,?: И запятых), &lt;strong&gt;порядок вычисления подвыражений и порядок в какие побочные эффекты имеют место, оба не определены.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71b9fec95a5c0e3f3bf5d039dad362d79f0e9e56" translate="yes" xml:space="preserve">
          <source>The important part is to know &lt;a href=&quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c&quot;&gt;what a sequence point is -- and &lt;em&gt;what is&lt;/em&gt; a sequence point and what &lt;em&gt;isn't&lt;/em&gt;&lt;/a&gt;. For example the &lt;em&gt;comma operator&lt;/em&gt; is a sequence point, so</source>
          <target state="translated">Важная часть состоит в &lt;a href=&quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c&quot;&gt;том,&lt;/a&gt; чтобы знать, что такое точка последовательности - и &lt;em&gt;что такое&lt;/em&gt; точка последовательности, а что &lt;em&gt;нет&lt;/em&gt; . Например, &lt;em&gt;оператор запятой&lt;/em&gt; является точкой последовательности, поэтому</target>
        </trans-unit>
        <trans-unit id="51f661df914e1e2ea77746de6aaa11f9b46f6347" translate="yes" xml:space="preserve">
          <source>The main rule from the standard ISO 9899 that applies in this situation is  6.5p2.</source>
          <target state="translated">Основное правило из стандарта ISO 9899,которое применяется в этой ситуации-6.5p2.</target>
        </trans-unit>
        <trans-unit id="88392b333617da7906af6f1c9e71bc7a0011c98f" translate="yes" xml:space="preserve">
          <source>The order in which the function designator, arguments, and
  subexpressions within the arguments are evaluated in a function call
  (6.5.2.2).</source>
          <target state="translated">Порядок,в котором обозначение функции,аргументы и подвыражения внутри аргументов вычисляются при вызове функции (6.5.2.2).</target>
        </trans-unit>
        <trans-unit id="c9968c66bc17adf0cf66c21f5fc4281778fad8b3" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands is unspecified. If an attempt is made to modify
  the result of an assignment operator or to access it after the next sequence point, the
  behavior is undefined.</source>
          <target state="translated">Порядок оценки операндов не определен.Если предпринимается попытка изменить результат оператора присваивания или получить к нему доступ после следующей точки следования,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="57d772c677ab734e951cb65c9f5a9c6ad1025dbd" translate="yes" xml:space="preserve">
          <source>The presence of a sequence point between the evaluation of expressions &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; implies that every &lt;em&gt;value computation&lt;/em&gt; and &lt;em&gt;side effect&lt;/em&gt; associated with &lt;code&gt;A&lt;/code&gt; is sequenced before every &lt;em&gt;value computation&lt;/em&gt; and &lt;em&gt;side effect&lt;/em&gt; associated with &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Наличие точки последовательности между оценками выражений &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; подразумевает, что каждое &lt;em&gt;вычисление значения&lt;/em&gt; и &lt;em&gt;побочный эффект,&lt;/em&gt; связанный с &lt;code&gt;A&lt;/code&gt; , упорядочивается перед каждым &lt;em&gt;вычислением значения&lt;/em&gt; и &lt;em&gt;побочным эффектом,&lt;/em&gt; связанным с &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa757362c1545c0b1bfa0b4971c8bcf9a5fa705" translate="yes" xml:space="preserve">
          <source>The problem with this expression is that it contains three different attempts to modify the value of x: (1) the &lt;code&gt;x++&lt;/code&gt; part tries to add 1 to x, store the new value in &lt;code&gt;x&lt;/code&gt;, and return the old value of &lt;code&gt;x&lt;/code&gt;; (2) the &lt;code&gt;++x&lt;/code&gt; part tries to add 1 to x, store the new value in &lt;code&gt;x&lt;/code&gt;, and return the new value of &lt;code&gt;x&lt;/code&gt;; and (3) the &lt;code&gt;x =&lt;/code&gt; part tries to assign the sum of the other two back to x.  Which of those three attempted assignments will &quot;win&quot;?  Which of the three values will actually get assigned to &lt;code&gt;x&lt;/code&gt;?  Again, and perhaps surprisingly, there's no rule in C to tell us.</source>
          <target state="translated">Проблема с этим выражением состоит в том, что оно содержит три различные попытки изменить значение x: (1) часть &lt;code&gt;x++&lt;/code&gt; пытается добавить 1 к x, сохранить новое значение в &lt;code&gt;x&lt;/code&gt; и вернуть старое значение &lt;code&gt;x&lt;/code&gt; ; (2) часть &lt;code&gt;++x&lt;/code&gt; пытается добавить 1 к x, сохранить новое значение в &lt;code&gt;x&lt;/code&gt; и вернуть новое значение &lt;code&gt;x&lt;/code&gt; ; и (3) часть &lt;code&gt;x =&lt;/code&gt; пытается присвоить сумму двух других обратно x. Какое из этих трех попыток будет &amp;laquo;выиграно&amp;raquo;? Какое из трех значений будет присвоено &lt;code&gt;x&lt;/code&gt; ? Опять же, и, возможно, что удивительно, в Си нет правил, чтобы говорить нам.</target>
        </trans-unit>
        <trans-unit id="8cf9f511dc75b3a4a079a7021f4a602979571d13" translate="yes" xml:space="preserve">
          <source>The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).</source>
          <target state="translated">Причина в том,что программа работает с неопределённым поведением.Проблема заключается в порядке вычислений,так как согласно стандарту C++98 не требуется никаких точек следования (согласно терминологии C++11 никакие операции не выполняются до или после).</target>
        </trans-unit>
        <trans-unit id="44562ae2bb8fdbc35628d635d10e98d6d60b8571" translate="yes" xml:space="preserve">
          <source>The second fragment, &lt;code&gt;i = i++&lt;/code&gt;, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:</source>
          <target state="translated">Второй фрагмент, &lt;code&gt;i = i++&lt;/code&gt; , немного проще для понимания. Кто-то явно пытается увеличить i и присвоить результат обратно i. Но есть несколько способов сделать это в C. Самый простой способ добавить 1 к i и присвоить результат обратно i, одинаков почти для любого языка программирования:</target>
        </trans-unit>
        <trans-unit id="6c93396d9e2d8c2a40d78d9071566b25f416ee2f" translate="yes" xml:space="preserve">
          <source>The sequence points in an expression like &lt;code&gt;i=i++&lt;/code&gt; are before &lt;code&gt;i=&lt;/code&gt; and after &lt;code&gt;i++&lt;/code&gt;.</source>
          <target state="translated">Точки последовательности в выражении типа &lt;code&gt;i=i++&lt;/code&gt; находятся перед &lt;code&gt;i=&lt;/code&gt; и после &lt;code&gt;i++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c90d0fb8a0d148c282b3883e977c9bc9699153f" translate="yes" xml:space="preserve">
          <source>The various sequence points are listed in Annex C of &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#C&quot;&gt;C11&lt;/a&gt; (and &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#C&quot;&gt;C99&lt;/a&gt;):</source>
          <target state="translated">Различные точки последовательности перечислены в Приложении C к &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#C&quot;&gt;C11&lt;/a&gt; (и &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#C&quot;&gt;C99&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="a79c3a06a2a5a93d7c630437550bdbcddba0807b" translate="yes" xml:space="preserve">
          <source>The wording of the same &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2&quot;&gt;paragraph in C11&lt;/a&gt; is:</source>
          <target state="translated">Формулировка того же &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2&quot;&gt;параграфа в C11&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2a85af3330f4c3a70b16dc7300fc5a565d163704" translate="yes" xml:space="preserve">
          <source>Then we go to &lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;Visual Studio&lt;/a&gt;. Visual Studio 2015, you get:</source>
          <target state="translated">Затем мы идем в &lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;Visual Studio&lt;/a&gt; . Visual Studio 2015, вы получаете:</target>
        </trans-unit>
        <trans-unit id="97e693ad3a0c6aa731e9685496e0af87463aa908" translate="yes" xml:space="preserve">
          <source>Therefore, the above expression invokes UB because two side effects on the same object &lt;code&gt;i&lt;/code&gt; is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to &lt;code&gt;i&lt;/code&gt; will be done before or after the side effect by &lt;code&gt;++&lt;/code&gt;.</source>
          <target state="translated">Следовательно, вышеприведенное выражение вызывает UB, потому что два побочных эффекта для одного &lt;code&gt;i&lt;/code&gt; того же объекта i не секвенированы относительно друг друга. Это означает, что не определено, будет ли побочный эффект путем присвоения &lt;code&gt;i&lt;/code&gt; выполняться до или после побочного эффекта &lt;code&gt;++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5f8681d077917f909bd82bb366210d3de854d2d" translate="yes" xml:space="preserve">
          <source>These expressions are all fine:</source>
          <target state="translated">Все эти выражения в порядке:</target>
        </trans-unit>
        <trans-unit id="6c0f3f70b94c0e683794c748069be9306f3ff862" translate="yes" xml:space="preserve">
          <source>These expressions are all undefined:</source>
          <target state="translated">Все эти выражения неопределенны:</target>
        </trans-unit>
        <trans-unit id="49e143bed893ac3c1f966d9961175fea9f0097a4" translate="yes" xml:space="preserve">
          <source>This is an important distinction because the &lt;em&gt;comma operator&lt;/em&gt; does introduce a &lt;em&gt;sequence point&lt;/em&gt; between the evaluation of their operands, which makes the following legal:</source>
          <target state="translated">Это важное различие, потому что &lt;em&gt;оператор запятой&lt;/em&gt; вводит &lt;em&gt;точку последовательности&lt;/em&gt; между оценкой их операндов, что делает следующее законным:</target>
        </trans-unit>
        <trans-unit id="a7eadbdf6cf106addacc1280459303a5771a264b" translate="yes" xml:space="preserve">
          <source>This is what I get on my machine, together with what I think is going on:</source>
          <target state="translated">Это то,что я получаю на своей машине,вместе с тем,что я думаю,что происходит:</target>
        </trans-unit>
        <trans-unit id="d2348ba3f2dbca0683d0f6e3794c5adfe460c3d4" translate="yes" xml:space="preserve">
          <source>This means, &quot;add 1 to i, and assign the result back to i&quot;.  So if we construct a hodgepodge of the two, by writing</source>
          <target state="translated">Это означает &quot;добавить 1 к i,а результат присвоить обратно i&quot;.Итак,если мы построим из них ходжподж,написав</target>
        </trans-unit>
        <trans-unit id="caa5ad4107546a13712ed7838fa8b42e3b4db460" translate="yes" xml:space="preserve">
          <source>This paragraph renders undefined statement expressions such as</source>
          <target state="translated">В этом пункте приводятся неопределенные выражения высказываний,такие как</target>
        </trans-unit>
        <trans-unit id="46439927e625ecb8b33bd34e881c3e524a95e1a1" translate="yes" xml:space="preserve">
          <source>This post: &lt;a href=&quot;https://stackoverflow.com/a/4105123/1275169&quot;&gt;Undefined, unspecified and implementation-defined behavior&lt;/a&gt; is also relevant.</source>
          <target state="translated">Этот пост: &lt;a href=&quot;https://stackoverflow.com/a/4105123/1275169&quot;&gt;неопределенное, неопределенное и определяемое реализацией поведение&lt;/a&gt; также имеет отношение к делу.</target>
        </trans-unit>
        <trans-unit id="a26b12aa6128b35356b8372db3a8257837f5a20c" translate="yes" xml:space="preserve">
          <source>This too has &lt;em&gt;unspecified behaviour&lt;/em&gt; because the order of evaluation of &lt;code&gt;++x&lt;/code&gt; and &lt;code&gt;y++&lt;/code&gt; is unspecified. But it's perfectly legal and valid statement. There's &lt;em&gt;no&lt;/em&gt; undefined behaviour in this statement. Because the modifications (&lt;code&gt;++x&lt;/code&gt; and &lt;code&gt;y++&lt;/code&gt;) are done to &lt;em&gt;distinct&lt;/em&gt; objects.</source>
          <target state="translated">Это также имеет &lt;em&gt;неопределенное поведение,&lt;/em&gt; потому что порядок вычисления &lt;code&gt;++x&lt;/code&gt; и &lt;code&gt;y++&lt;/code&gt; не указан. Но это совершенно законное и обоснованное утверждение. Там &lt;em&gt;нет&lt;/em&gt; неопределенного поведения в этом утверждении. Потому что изменения ( &lt;code&gt;++x&lt;/code&gt; и &lt;code&gt;y++&lt;/code&gt; ) выполняются для &lt;em&gt;разных&lt;/em&gt; объектов.</target>
        </trans-unit>
        <trans-unit id="b8ab8d4d3501671ee98b37c6896a7b30e0cb64eb" translate="yes" xml:space="preserve">
          <source>Use of an unspecified value, or other behavior where this
  International Standard provides two or more possibilities and imposes
  no further requirements on which is chosen in any instance.</source>
          <target state="translated">Использование неопределенного значения,или другое поведение,когда данный международный стандарт предоставляет две или более возможности и не налагает никаких дополнительных требований,которые выбраны в любом случае.</target>
        </trans-unit>
        <trans-unit id="98e776ec343640985fafdd3ff42f5002ea7be9bc" translate="yes" xml:space="preserve">
          <source>We also have &lt;em&gt;undefined behavior&lt;/em&gt; here as well since the program is modifying variables(&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, etc..) more than once between &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;sequence points&lt;/a&gt;. From draft standard section &lt;code&gt;6.5&lt;/code&gt; paragraph &lt;em&gt;2&lt;/em&gt;(&lt;em&gt;emphasis mine&lt;/em&gt;):</source>
          <target state="translated">У нас также есть &lt;em&gt;неопределенное поведение,&lt;/em&gt; так как программа изменяет переменные ( &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; и т. Д.) Более одного раза между &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;точками последовательности&lt;/a&gt; . Из проекта стандарта раздела &lt;code&gt;6.5&lt;/code&gt; , параграф &lt;em&gt;2&lt;/em&gt; ( &lt;em&gt;выделено мной&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="d79ca31d503a8992b19d27638ae0bfeab48383d7" translate="yes" xml:space="preserve">
          <source>We used to spend countless hours on comp.lang.c discussing expressions like these and &lt;em&gt;why&lt;/em&gt; they're undefined.  Two of my longer answers, that try to really explain why, are archived on the web:</source>
          <target state="translated">Мы привыкли тратить бесчисленные часы на comp.lang.c, обсуждая подобные выражения и &lt;em&gt;почему&lt;/em&gt; они не определены. Два моих более длинных ответа, которые пытаются действительно объяснить, почему, заархивированы в Интернете:</target>
        </trans-unit>
        <trans-unit id="97f59d311b736479c8957dda049a60daf7519890" translate="yes" xml:space="preserve">
          <source>What about this crazy expression?</source>
          <target state="translated">А как же это безумное выражение?</target>
        </trans-unit>
        <trans-unit id="5a6d959c80919c189d983a0e8445a43a2b8edc68" translate="yes" xml:space="preserve">
          <source>What makes an expression undefined?  Are expressions involving &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; always undefined?  Of course not: these are useful operators, and if you use them properly, they're perfectly well-defined.</source>
          <target state="translated">Что делает выражение неопределенным? Выражения с участием &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; всегда неопределены? Конечно, нет: это полезные операторы, и если вы используете их правильно, они совершенно четко определены.</target>
        </trans-unit>
        <trans-unit id="8dbebc0ad8d152d87c6b7a7b4477c7a754623049" translate="yes" xml:space="preserve">
          <source>What renders the following statement</source>
          <target state="translated">Что делает следующее заявление</target>
        </trans-unit>
        <trans-unit id="620723367c219dcaa50fd9cc14c519910605f4ac" translate="yes" xml:space="preserve">
          <source>Where several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators.</source>
          <target state="translated">Там,где несколько операторов появляются вместе,они имеют одинаковый приоритет и оцениваются в соответствии с их ассоциативностью.Операторы в таблице описаны в разделах,начинающихся с Постфиксных операторов.</target>
        </trans-unit>
        <trans-unit id="993c059bb0f33b91c747d106d7f878acf62fa429" translate="yes" xml:space="preserve">
          <source>While I don't think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, &lt;code&gt;i&lt;/code&gt; would get incremented by two) and it's not totally inconceivable that some future processor might provide a feature something like that.</source>
          <target state="translated">Хотя я не думаю, что какие-либо процессоры поддерживают аппаратное обеспечение, позволяющее эффективно выполнять такие действия, можно легко представить себе ситуации, в которых такое поведение могло бы упростить многопоточный код (например, это гарантировало бы, что если два потока попытаются выполнить описанное выше) Последовательность одновременно, &lt;code&gt;i&lt;/code&gt; бы увеличился на два), и не исключено, что какой-нибудь будущий процессор может обеспечить такую ​​функцию.</target>
        </trans-unit>
        <trans-unit id="654bf105e22463883f4cc71645479f80ad720b8c" translate="yes" xml:space="preserve">
          <source>While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement &quot;i++&quot; with the sequence:</source>
          <target state="translated">Хотя маловероятно,что какие-либо компиляторы и процессоры на самом деле сделают это,было бы законно,согласно стандарту Си,чтобы компилятор реализовывал &quot;i++&quot; с этой последовательностью:</target>
        </trans-unit>
        <trans-unit id="c4fc6b93cb14a30318f792c85ba1d6fcdb5593c0" translate="yes" xml:space="preserve">
          <source>While the &lt;strong&gt;syntax&lt;/strong&gt; of the expressions like &lt;code&gt;a = a++&lt;/code&gt; or &lt;code&gt;a++ + a++&lt;/code&gt; is legal, the &lt;strong&gt;behaviour&lt;/strong&gt; of these constructs is &lt;strong&gt;undefined&lt;/strong&gt; because a &lt;strong&gt;&lt;em&gt;shall&lt;/em&gt;&lt;/strong&gt; in C standard is not obeyed. &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2&quot;&gt;C99 6.5p2&lt;/a&gt;:</source>
          <target state="translated">Хотя &lt;strong&gt;синтаксис&lt;/strong&gt; выражений, таких как &lt;code&gt;a = a++&lt;/code&gt; или &lt;code&gt;a++ + a++&lt;/code&gt; является допустимым, &lt;strong&gt;поведение&lt;/strong&gt; этих конструкций не &lt;strong&gt;определено,&lt;/strong&gt; поскольку в стандарте C не соблюдается. &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2&quot;&gt;C99 6.5p2&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fa7f3099f3e8212233573bcc53199fbb0f2d7dd7" translate="yes" xml:space="preserve">
          <source>While this is also &lt;a href=&quot;https://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;&lt;em&gt;undefined behaviour&lt;/em&gt;&lt;/a&gt; as stated already, there are subtle differences when &lt;code&gt;printf()&lt;/code&gt; is involved when comparing to a statement such as:</source>
          <target state="translated">Хотя это также &lt;a href=&quot;https://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;&lt;em&gt;неопределенное поведение,&lt;/em&gt;&lt;/a&gt; как уже говорилось, есть небольшие различия, когда &lt;code&gt;printf()&lt;/code&gt; участвует в сравнении с таким утверждением, как:</target>
        </trans-unit>
        <trans-unit id="1bbd03ec9871c64e9c4395ce30be95e323064e65" translate="yes" xml:space="preserve">
          <source>Why are these constructs using pre and post-increment undefined behavior</source>
          <target state="translated">Почему эти конструкции используют пред-и пост-инкрементное неопределённое поведение.</target>
        </trans-unit>
        <trans-unit id="e9fa82e28ce977203f961d7a07d8a2d4b273fe03" translate="yes" xml:space="preserve">
          <source>Why doesn't the Standard define what these do?</source>
          <target state="translated">Почему бы Стандарту не определить,что они делают?</target>
        </trans-unit>
        <trans-unit id="5d24bed798cadce6efcf21855671e0a3bd9b02cf" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#note73&quot;&gt;footnote 73&lt;/a&gt; further clarifying that</source>
          <target state="translated">В &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#note73&quot;&gt;сноске 73&lt;/a&gt; уточняется, что</target>
        </trans-unit>
        <trans-unit id="29f531dd817ce6695c7df2a686b84fe974c07a2d" translate="yes" xml:space="preserve">
          <source>You can detect such errors in a program by for example using a recent version of GCC with &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-Werror&lt;/code&gt;, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:</source>
          <target state="translated">Вы можете обнаружить такие ошибки в программе, например, используя последнюю версию GCC с &lt;code&gt;-Wall&lt;/code&gt; и &lt;code&gt;-Werror&lt;/code&gt; , и тогда GCC полностью откажется компилировать вашу программу. Ниже приведен вывод gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:</target>
        </trans-unit>
        <trans-unit id="1e657852dfeb599a907d4ece570953de09d22b6a" translate="yes" xml:space="preserve">
          <source>You might imagine that precedence or associativity or left-to-right evaluation tells you what order things happen in, but they do not.  You may not believe me, but please take my word for it, and I'll say it again: precedence and associativity do not determine every aspect of the evaluation order of an expression in C.  In particular, if within one expression there are multiple different spots where we try to assign a new value to something like &lt;code&gt;x&lt;/code&gt;, precedence and associativity do &lt;em&gt;not&lt;/em&gt; tell us which of those attempts happens first, or last, or anything.</source>
          <target state="translated">Вы можете себе представить, что приоритет или ассоциативность или оценка слева направо говорит вам, в каком порядке происходят вещи, но это не так. Вы можете не верить мне, но, пожалуйста, поверьте мне на слово, и я скажу это снова: приоритет и ассоциативность не определяют каждый аспект порядка вычисления выражения в C. В частности, если в одном выражении есть несколько различные места, где мы пытаемся присвоить новое значение чему-либо, например, &lt;code&gt;x&lt;/code&gt; , приоритет и ассоциативность, &lt;em&gt;не&lt;/em&gt; говорят нам, какая из этих попыток происходит первой, последней или какой-либо другой.</target>
        </trans-unit>
        <trans-unit id="16d53ac224d610d74a2b157b47df1e799121e503" translate="yes" xml:space="preserve">
          <source>Your most interesting-looking example, the one with</source>
          <target state="translated">Твой самый интересный пример,тот,что с</target>
        </trans-unit>
        <trans-unit id="6b59ba518c972237e1ab9cf07eace07655c0ba1c" translate="yes" xml:space="preserve">
          <source>Your question was probably not, &quot;Why are these constructs undefined behavior in C?&quot;.  Your question was probably, &quot;Why did this code (using &lt;code&gt;++&lt;/code&gt;) not give me the value I expected?&quot;, and someone marked your question as a duplicate, and sent you here.</source>
          <target state="translated">Ваш вопрос был, вероятно, не &amp;laquo;Почему эти конструкции неопределенного поведения в C?&amp;raquo;. Ваш вопрос был, вероятно, &amp;laquo;Почему этот код (с использованием &lt;code&gt;++&lt;/code&gt; ) не дал мне ожидаемого значения?&amp;raquo;, И кто-то пометил ваш вопрос как дубликат и отправил вас сюда.</target>
        </trans-unit>
        <trans-unit id="3ab35cf324056d865ffa5f8f1bbb4c026674124f" translate="yes" xml:space="preserve">
          <source>according to &lt;a href=&quot;http://helpcentreonline.com/article/operator_console_gcc.pdf&quot;&gt;GCC C++: Operators&lt;/a&gt;</source>
          <target state="translated">согласно &lt;a href=&quot;http://helpcentreonline.com/article/operator_console_gcc.pdf&quot;&gt;GCC C ++: операторы&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01fa57d8ce0823fdd6a263ffa07b47583f555303" translate="yes" xml:space="preserve">
          <source>and 6.5.16 Assignment operators, &amp;sect;4:</source>
          <target state="translated">и 6.5.16 Операторы присваивания, &amp;sect;4:</target>
        </trans-unit>
        <trans-unit id="ce12358f2d210e399abcf4e1e573533bddc18601" translate="yes" xml:space="preserve">
          <source>and &lt;em&gt;undefined behavior&lt;/em&gt; is defined in section &lt;code&gt;3.4.3&lt;/code&gt; as:</source>
          <target state="translated">и &lt;em&gt;неопределенное поведение&lt;/em&gt; определяется в разделе &lt;code&gt;3.4.3&lt;/code&gt; как:</target>
        </trans-unit>
        <trans-unit id="2b052e36279e4939f15bff3095a49e8060b7a8a2" translate="yes" xml:space="preserve">
          <source>and notes that:</source>
          <target state="translated">и отмечает это:</target>
        </trans-unit>
        <trans-unit id="8e6dfcce434b9d0dda3cc6631136727fcce69183" translate="yes" xml:space="preserve">
          <source>and so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.</source>
          <target state="translated">и так далее нарушать это правило.Стандарт также говорит о том,что поведение не определено и не является неопределенным.Некоторые компиляторы обнаруживают их и дают некоторый результат,но это не соответствует стандарту.</target>
        </trans-unit>
        <trans-unit id="1b3734024b41bb3f0676c1c39247d799a3758dbe" translate="yes" xml:space="preserve">
          <source>as &lt;em&gt;undefined behaviour&lt;/em&gt; is the fact that these two expressions modify the &lt;em&gt;same&lt;/em&gt; object &lt;code&gt;i&lt;/code&gt; without an intervening &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;em&gt;sequence point&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;неопределенным поведением&lt;/em&gt; является тот факт, что эти два выражения модифицируют один и тот &lt;em&gt;же&lt;/em&gt; объект &lt;code&gt;i&lt;/code&gt; без промежуточной &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;em&gt;точки последовательности&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9059279af0d58499da7f4421366ab030ce5ce24f" translate="yes" xml:space="preserve">
          <source>as Visual Studio documentation states at &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx&quot;&gt;Precedence and Order of Evaluation&lt;/a&gt;:</source>
          <target state="translated">как указано в документации Visual Studio в порядке &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx&quot;&gt;приоритета и порядке оценки&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a66c60f4b925de32bda6e418bb9241ab007d19d2" translate="yes" xml:space="preserve">
          <source>because both all these forms to interpret the code &lt;code&gt;i=i++&lt;/code&gt; are valid and because both generate different answers, the behavior is undefined.</source>
          <target state="translated">поскольку обе эти формы для интерпретации кода &lt;code&gt;i=i++&lt;/code&gt; являются допустимыми, и поскольку обе выдают разные ответы, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="9ca0589f3b903598d63dbbb1bd82e05ec06430e2" translate="yes" xml:space="preserve">
          <source>behavior, upon use of a nonportable or erroneous program construct or of erroneous data,
  for which this International Standard imposes no requirements</source>
          <target state="translated">поведение,при использовании некорректной или ошибочной программной конструкции или ошибочных данных,к которым настоящий Международный стандарт не предъявляет требований</target>
        </trans-unit>
        <trans-unit id="0adcd950d55decdb39e49fe9bd1350b81dcb1ba8" translate="yes" xml:space="preserve">
          <source>can be interpreted as</source>
          <target state="translated">может быть истолковано как</target>
        </trans-unit>
        <trans-unit id="79800df6fd474ca1c30984dcd3f7b04c26a5c2ea" translate="yes" xml:space="preserve">
          <source>has &lt;em&gt;undefined behaviour&lt;/em&gt; because &lt;strong&gt;there is no sequence point between the evaluations of &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; in function arguments&lt;/strong&gt;, and the value of &lt;code&gt;i&lt;/code&gt; is therefore modified twice, by both &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt;, between the previous and the next sequence point.</source>
          <target state="translated">имеет &lt;em&gt;неопределенное поведение,&lt;/em&gt; потому &lt;strong&gt;что между значениями &lt;code&gt;i++&lt;/code&gt; и &lt;code&gt;++i&lt;/code&gt; в аргументах функции отсутствует точка последовательности&lt;/strong&gt; , и поэтому значение &lt;code&gt;i&lt;/code&gt; изменяется дважды, как &lt;code&gt;i++&lt;/code&gt; и &lt;code&gt;++i&lt;/code&gt; , между предыдущей и следующей точкой последовательности.</target>
        </trans-unit>
        <trans-unit id="7e0c4a46af008bea7bd274279fd48605405877be" translate="yes" xml:space="preserve">
          <source>is a text-book example of undefined behavior (see Wikipedia's entry on &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;sequence points&lt;/a&gt;).</source>
          <target state="translated">пример учебника из неопределенного поведения (см. статью Википедии о &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;точках последовательности&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d6afca40014c337d879e759974a1ca723b9ba3d5" translate="yes" xml:space="preserve">
          <source>is well-defined, and will increment &lt;code&gt;i&lt;/code&gt; by one, yielding the old value, discard that value; then at comma operator, settle the side effects; and then increment &lt;code&gt;i&lt;/code&gt; by one, and the resulting value becomes the value of the expression - i.e. this is just a contrived way to write &lt;code&gt;j = (i += 2)&lt;/code&gt; which is yet again a &quot;clever&quot; way to write</source>
          <target state="translated">четко определен и будет увеличивать &lt;code&gt;i&lt;/code&gt; на единицу, давая старое значение, отбрасывать это значение; затем в оператор запятой, урегулировать побочные эффекты; и затем увеличиваем &lt;code&gt;i&lt;/code&gt; на единицу, и результирующее значение становится значением выражения - т.е. это просто надуманный способ записи &lt;code&gt;j = (i += 2)&lt;/code&gt; который снова является &amp;laquo;умным&amp;raquo; способом записи</target>
        </trans-unit>
        <trans-unit id="fbe75bf13ae46462a9f46964973c095ec8c518fa" translate="yes" xml:space="preserve">
          <source>it cites the following code examples as being undefined:</source>
          <target state="translated">он приводит следующие примеры кода как неопределенные:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="64c3747b998e7ea9d774b1fd5a1400f0310b6691" translate="yes" xml:space="preserve">
          <source>or as</source>
          <target state="translated">или как</target>
        </trans-unit>
        <trans-unit id="e279a190f96b43bb236230286cb53b2703d35e62" translate="yes" xml:space="preserve">
          <source>or similar variants.</source>
          <target state="translated">или похожие варианты.</target>
        </trans-unit>
        <trans-unit id="9702e27e29837c876ff819f4fdde0b4010e5e3ca" translate="yes" xml:space="preserve">
          <source>resulting in two different results &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; which depends on the sequence of side effects by assignment and &lt;code&gt;++&lt;/code&gt; and hence invokes UB.</source>
          <target state="translated">в результате получаются два разных результата &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;2&lt;/code&gt; , которые зависят от последовательности побочных эффектов при назначении и &lt;code&gt;++&lt;/code&gt; и, следовательно, вызывают UB.</target>
        </trans-unit>
        <trans-unit id="36547a3fb0d1b37ceaa06275e8ecd615d0e3cca7" translate="yes" xml:space="preserve">
          <source>standard says that:</source>
          <target state="translated">Стандарт так говорит:</target>
        </trans-unit>
        <trans-unit id="99eb919d06fc8a202d8b26c45f6410f8dd8cfde9" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;http://en.cppreference.com/w/c/language/eval_order&quot;&gt;&lt;em&gt;order of evaluation&lt;/em&gt;&lt;/a&gt; of arguments in &lt;code&gt;printf()&lt;/code&gt; is &lt;a href=&quot;https://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/a&gt;. That means, expressions &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; could be evaluated in any order. &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html&quot;&gt;C11 standard&lt;/a&gt; has some relevant descriptions on this:</source>
          <target state="translated">&lt;a href=&quot;http://en.cppreference.com/w/c/language/eval_order&quot;&gt;&lt;em&gt;порядок вычисления&lt;/em&gt;&lt;/a&gt; аргументов в &lt;code&gt;printf()&lt;/code&gt; не &lt;a href=&quot;https://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;&lt;em&gt;указан&lt;/em&gt;&lt;/a&gt; . Это означает, что выражения &lt;code&gt;i++&lt;/code&gt; и &lt;code&gt;++i&lt;/code&gt; можно вычислять в любом порядке. &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html&quot;&gt;Стандарт C11&lt;/a&gt; имеет некоторые соответствующие описания по этому вопросу:</target>
        </trans-unit>
        <trans-unit id="31da7bc042367a36b94b0573d521d30381601aa7" translate="yes" xml:space="preserve">
          <source>the equivalent code in defined behavior C++ as   GCC understands:</source>
          <target state="translated">эквивалентный код в определенном поведении Си++,как понимает GCC:</target>
        </trans-unit>
        <trans-unit id="b66a1df4b25aa4baacf0d81920e5b8592ea38a0a" translate="yes" xml:space="preserve">
          <source>the question is, before calling &lt;code&gt;printf&lt;/code&gt;, does the compiler compute the value of &lt;code&gt;x&lt;/code&gt; first, or &lt;code&gt;x++&lt;/code&gt;, or maybe &lt;code&gt;++x&lt;/code&gt;?  But it turns out &lt;em&gt;we don't know&lt;/em&gt;.  There's no rule in C which says that the arguments to a function get evaluated left-to-right, or right-to-left, or in some other order.  So we can't say whether the compiler will do &lt;code&gt;x&lt;/code&gt; first, then &lt;code&gt;++x&lt;/code&gt;, then &lt;code&gt;x++&lt;/code&gt;, or &lt;code&gt;x++&lt;/code&gt; then &lt;code&gt;++x&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt;, or some other order.  But the order clearly matters, because depending on which order the compiler uses, we'll clearly get different results printed by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">вопрос перед вызовом &lt;code&gt;printf&lt;/code&gt; : компилятор сначала вычисляет значение &lt;code&gt;x&lt;/code&gt; , или &lt;code&gt;x++&lt;/code&gt; , или, возможно, &lt;code&gt;++x&lt;/code&gt; ? Но оказывается, что &lt;em&gt;мы не знаем&lt;/em&gt; . В C нет правила, согласно которому аргументы функции оцениваются слева направо, справа налево или в каком-либо другом порядке. Поэтому мы не можем сказать, будет ли компилятор делать сначала &lt;code&gt;x&lt;/code&gt; , затем &lt;code&gt;++x&lt;/code&gt; , затем &lt;code&gt;x++&lt;/code&gt; или &lt;code&gt;x++&lt;/code&gt; затем &lt;code&gt;++x&lt;/code&gt; , затем &lt;code&gt;x&lt;/code&gt; или какой-то другой порядок. Но порядок явно имеет значение, потому что в зависимости от того, какой порядок использует компилятор, мы ясно получим разные результаты, напечатанные &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b145a546526acfd63eaed2096d7c03ce76dc170c" translate="yes" xml:space="preserve">
          <source>there are three attempts to modify `x.</source>
          <target state="translated">есть три попытки изменить `x.</target>
        </trans-unit>
        <trans-unit id="fe89eef81018d9dbe7f6e45a8c1cb937a477767e" translate="yes" xml:space="preserve">
          <source>use of an unspecified value, or other behavior where this International Standard provides
  two or more possibilities and imposes no further requirements on which is chosen in any
  instance</source>
          <target state="translated">использование неопределенного значения или иное поведение,когда данный международный стандарт предоставляет две или более возможности и не налагает никаких дополнительных требований,которые выбраны ни в одном из случаев</target>
        </trans-unit>
        <trans-unit id="be6fb6ef9ffc50a3a93ef857ea42b104c0acfc49" translate="yes" xml:space="preserve">
          <source>we both use the value of &lt;code&gt;x&lt;/code&gt;, and modify it.</source>
          <target state="translated">мы оба используем значение &lt;code&gt;x&lt;/code&gt; и модифицируем его.</target>
        </trans-unit>
        <trans-unit id="26c3baa763591157c51a290b7c8be38622c3e920" translate="yes" xml:space="preserve">
          <source>we do not know whether &lt;code&gt;i++&lt;/code&gt; or &lt;code&gt;++i&lt;/code&gt; will be evaluated first. This is mainly to give the compiler &lt;a href=&quot;https://stackoverflow.com/a/12540468/1708801&quot;&gt;better options for optimization&lt;/a&gt;.</source>
          <target state="translated">мы не знаем, будет ли &lt;code&gt;i++&lt;/code&gt; или &lt;code&gt;++i&lt;/code&gt; оценены первыми. Это главным образом для того, чтобы дать компилятору &lt;a href=&quot;https://stackoverflow.com/a/12540468/1708801&quot;&gt;лучшие возможности для оптимизации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb233158d14cbec62b14e57272c4bcc2a0ceed2f" translate="yes" xml:space="preserve">
          <source>what we're really saying is &quot;add 1 to i, and assign the result back to i, and assign the result back to i&quot;.  We're confused, so it doesn't bother me too much if the compiler gets confused, too.</source>
          <target state="translated">На самом деле мы говорим,что &quot;добавьте 1 к i,и присваивайте результат обратно i,и присваивайте результат обратно i&quot;.Мы запутались,так что меня не слишком беспокоит,если компилятор тоже запутается.</target>
        </trans-unit>
        <trans-unit id="e22cbfb6c2ae366e16c7c6a3fd5d852b0ea277ba" translate="yes" xml:space="preserve">
          <source>which prints 7... the OP expected it to print 6.</source>
          <target state="translated">который напечатал 7...ОП ожидало,что напечатает 6.</target>
        </trans-unit>
        <trans-unit id="0976677eed8a072a2d2ba8c68e6d46be04d02d10" translate="yes" xml:space="preserve">
          <source>while allowing</source>
          <target state="translated">позволяя</target>
        </trans-unit>
        <trans-unit id="7144af9b44794b287d95deb872a3d9bc96df4726" translate="yes" xml:space="preserve">
          <source>will not be a problem. But it invokes &lt;em&gt;undefined behaviour&lt;/em&gt; because the &lt;em&gt;comma&lt;/em&gt; here is a &lt;em&gt;separator&lt;/em&gt;.</source>
          <target state="translated">не будет проблемой. Но это вызывает &lt;em&gt;неопределенное поведение,&lt;/em&gt; потому что &lt;em&gt;запятая&lt;/em&gt; здесь является &lt;em&gt;разделителем&lt;/em&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
