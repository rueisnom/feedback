<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/949433">
    <body>
      <group id="949433">
        <trans-unit id="279b28cc873ec1c827682711f3c25217acbae1fe" translate="yes" xml:space="preserve">
          <source>(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)</source>
          <target state="translated">(저는 0x00000014 명령이 일종의 컴파일러 최적화라고 가정합니다.)</target>
        </trans-unit>
        <trans-unit id="bfd7cdbaee11e47493e6a76cbda42efed8c089b4" translate="yes" xml:space="preserve">
          <source>6.5 Expressions:</source>
          <target state="translated">6.5 표현 :</target>
        </trans-unit>
        <trans-unit id="88c039b7efd50e8beeced317de42cd545759369b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/17935062/2455888&quot;&gt;An important point&lt;/a&gt; regarding Postfix &lt;code&gt;++&lt;/code&gt; operator is that:</source>
          <target state="translated">Postfix &lt;code&gt;++&lt;/code&gt; 연산자와 관련하여 &lt;a href=&quot;https://stackoverflow.com/a/17935062/2455888&quot;&gt;중요한 점&lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a38d1a7059ef11574a41d6295e5c3ee36deea981" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This&lt;/em&gt; answer tries to answer that question: why did your code not give you the answer you expected, and how can you learn to recognize (and avoid) expressions that will not work as expected.</source>
          <target state="translated">&lt;em&gt;이&lt;/em&gt; 답변은 그 질문에 답하려고합니다 : 왜 당신의 코드가 당신에게 기대 한 대답을주지 않았으며, 예상대로 작동하지 않을 표현을 인식하고 피하는 법을 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cede1476cbfbaa036e6ccf5fced4facf59ce7d1f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unspecified behavior&lt;/em&gt; is defined in the &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;draft c99 standard&lt;/a&gt; in section &lt;code&gt;3.4.4&lt;/code&gt; as:</source>
          <target state="translated">&lt;em&gt;지정되지 않은 동작&lt;/em&gt; 은 섹션 &lt;code&gt;3.4.4&lt;/code&gt; 의 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;c99 표준 초안에&lt;/a&gt; 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="44b34df450374fa00c3d7262a922fe635b3fb310" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.4, unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.4.4, 불특정 행동&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b687a63b4511aca324bdbbc7328acb8be568d38d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Annex J, unspecified behaviours&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;부록 J, 불특정 행동&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad5e622d7c3f20a8ca11dc4608457c04512caa38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Between the previous and next sequence point an object shall have its stored value
  modified at most once&lt;/strong&gt; by the evaluation of an expression. Furthermore, &lt;strong&gt;the prior value
  shall be read only to determine the value to be stored&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;이전과 다음 시퀀스 포인트 사이에서 객체는&lt;/strong&gt; 표현식의 평가에 의해 &lt;strong&gt;저장된 값을 최대 한 번 수정해야&lt;/strong&gt; 합니다. 또한, &lt;strong&gt;저장 될 값을 결정하기 위해 이전 값은 읽기 전용이어야한다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="14c69e77d03fc3b5c073134689c8f8428458e027" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If a side effect on a scalar object is unsequenced relative to&lt;/strong&gt; either &lt;strong&gt;a different side effect on the same scalar object&lt;/strong&gt; or a value computation using the value of the same scalar object, &lt;strong&gt;the behavior is undefined&lt;/strong&gt;. [...]</source>
          <target state="translated">&lt;strong&gt;스칼라 객체의&lt;/strong&gt; &lt;strong&gt;부작용이 동일한 스칼라 객체의 다른 부작용&lt;/strong&gt; 또는 &lt;strong&gt;동일한 스칼라 객체&lt;/strong&gt; 의 값을 사용한 값 계산과 관련하여 순서 &lt;strong&gt;가 지정되지 않은 경우 동작이 정의되지 않습니다&lt;/strong&gt; . [...]</target>
        </trans-unit>
        <trans-unit id="05664d00aa9e447fc1d30a0bcf56db0f328bd362" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequence Point:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;시퀀스 포인트 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9f49591f9696f388f781605342ac7b9ab2f5c5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequenced:&lt;/strong&gt; (5.1.2.3)</source>
          <target state="translated">&lt;strong&gt;순서 :&lt;/strong&gt; (5.1.2.3)</target>
        </trans-unit>
        <trans-unit id="64839962132bef2e8207e819c9d365f8efa46d5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unsequenced:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Unsequenced:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b35e23674ba2c887d039ae8bc54926f2a2c920fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;just because the &lt;code&gt;++&lt;/code&gt; comes after the variable does not mean that the increment happens late&lt;/strong&gt;. The increment can happen as early as the compiler likes &lt;em&gt;as long as the compiler ensures that the original value is used&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;++&lt;/code&gt; 가 변수 뒤에 온다고해서 증분이 늦게 발생하는 것은 아닙니다&lt;/strong&gt; . 컴파일러가 &lt;em&gt;원래 값을 사용&lt;/em&gt; 하는 한 컴파일러가 원하는 &lt;em&gt;만큼&lt;/em&gt; 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f47bde17809faf3152a9c49b5ed547c7193a8237" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;side effects&lt;/strong&gt;, which are modifications of objects.</source>
          <target state="translated">&lt;strong&gt;부작용&lt;/strong&gt; 은 객체의 수정입니다.</target>
        </trans-unit>
        <trans-unit id="91ed0c6955be889d3390ace27c7202751c8e2aa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;value computations&lt;/strong&gt;, which work out the result of an expression; and</source>
          <target state="translated">식의 결과를 &lt;strong&gt;산출&lt;/strong&gt; 하는 &lt;strong&gt;값 계산&lt;/strong&gt; ; 과</target>
        </trans-unit>
        <trans-unit id="98e847c09ebd5e2f7d780741347784a05d1e1490" translate="yes" xml:space="preserve">
          <source>A good explanation about what happens in this kind of computation is provided in the document &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf&quot;&gt;n1188&lt;/a&gt; from &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/&quot;&gt;the ISO W14 site&lt;/a&gt;.</source>
          <target state="translated">이런 종류의 계산에서 발생하는 것에 대한 좋은 설명은 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/&quot;&gt;ISO W14 사이트&lt;/a&gt; 의 문서 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf&quot;&gt;n1188에&lt;/a&gt; 제공되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e34012ee0723c9314bf3543db136c35ba444eab" translate="yes" xml:space="preserve">
          <source>After the actions associated with each formatted input/output function conversion specifier (7.21.6, 7.29.2).</source>
          <target state="translated">형식화 된 각 입력 / 출력 기능 변환 지정자와 연관된 조치 후 (7.21.6, 7.29.2)</target>
        </trans-unit>
        <trans-unit id="34ab97668a5cbf8c450a7a5d95e5097551fcfcaf" translate="yes" xml:space="preserve">
          <source>And the last question is, how can you tell which expressions are well-defined, and which expressions are undefined?</source>
          <target state="translated">마지막 질문은 어떤식이 잘 정의되어 있고 어떤식이 정의되어 있지 않은지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="bae6a155cfc89c64a4a764fc6787a9b2227f41ac" translate="yes" xml:space="preserve">
          <source>Another detail is that the &lt;em&gt;comma&lt;/em&gt; involved in the printf() call is a &lt;em&gt;separator&lt;/em&gt;, not the &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma_operator&quot;&gt;&lt;em&gt;comma operator&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">또 다른 세부 사항은 printf () 호출과 관련된 &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma_operator&quot;&gt;&lt;em&gt;쉼표가 쉼표 연산자&lt;/em&gt;&lt;/a&gt; 가 아니라 &lt;em&gt;분리&lt;/em&gt; &lt;em&gt;자라는 것입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="03d05f648939561cc5196d6a1b460c6d6f3ae2fc" translate="yes" xml:space="preserve">
          <source>Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, &lt;em&gt;what are they supposed to mean?&lt;/em&gt;&lt;em&gt;What was the programmer trying to do?&lt;/em&gt;</source>
          <target state="translated">시퀀스 포인트와 정의되지 않은 동작의 세부적인 세부 사항에 얽매이지 않고 이것을 대답하는 또 다른 방법은 단순히 묻는 것입니다. &lt;em&gt;무엇을 의미합니까?&lt;/em&gt; &lt;em&gt;프로그래머는 무엇을하려고 했습니까?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="454a87205b7cae96f48455860ea1befd4d1fe414" translate="yes" xml:space="preserve">
          <source>As I said earlier, the undefined expressions are the ones where there's too much going at once, where you can't be sure what order things happen in, and where the order matters:</source>
          <target state="translated">앞에서 말했듯이, 정의되지 않은 표현식은 한 번에 너무 많은 일이 발생하고 순서가 어떻게 진행되는지 확실하지 않은 순서와 순서가 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="81111bf67780917ba78bc4f0f400157e26a8fb24" translate="yes" xml:space="preserve">
          <source>As an example of #1, in the expression</source>
          <target state="translated">식에서 # 1의 예로서</target>
        </trans-unit>
        <trans-unit id="53c019261927786950c4738a085953640d98c525" translate="yes" xml:space="preserve">
          <source>As an example of #2, in the expression</source>
          <target state="translated"># 2의 예로서, 표현에서</target>
        </trans-unit>
        <trans-unit id="55b849835da5250ac9a738c42f912f2f425d1886" translate="yes" xml:space="preserve">
          <source>As far as I know, the standard doesn't explicitly say &lt;em&gt;why&lt;/em&gt; the concept of undefined behavior exists. In my mind, it's simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.</source>
          <target state="translated">내가 아는 한, 표준은 &lt;em&gt;왜&lt;/em&gt; 정의되지 않은 행동의 개념이 존재 &lt;em&gt;하는지&lt;/em&gt; 명시하지 않습니다. 제 생각에는 언어 디자이너가 의미론에 약간의 여유가 있기를 원했기 때문입니다. 즉, 모든 구현이 정확히 동일한 방식으로 정수 오버플로를 처리하도록 요구하기 때문에 심각한 성능 비용이 발생할 가능성이 매우 높습니다. 정수 오버플로를 일으키는 코드를 작성하면 어떤 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8c378a722c25ac92808308a2ac719cb4b3053ff" translate="yes" xml:space="preserve">
          <source>As you've heard by now, all of these expressions are &lt;em&gt;undefined&lt;/em&gt;, which means that the C language makes no guarantee about what they'll do.  This is a strange and surprising result, because you probably thought that any program you could write, as long as it compiled and ran, would generate a unique, well-defined output.  But in the case of undefined behavior, that's not so.</source>
          <target state="translated">지금까지 들었 듯이,이 모든 표현들은 &lt;em&gt;정의&lt;/em&gt; 되어 &lt;em&gt;있지 않습니다&lt;/em&gt; . 즉, C 언어는 그들이 할 일을 보증하지 않습니다. 컴파일하고 실행하는 한 작성할 수있는 모든 프로그램이 고유하고 잘 정의 된 출력을 생성 할 것이라고 생각했기 때문에 이것은 이상하고 놀라운 결과입니다. 그러나 정의되지 않은 동작의 경우에는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22983dcf22f5d87d51da07d6260b26d0e70bc867" translate="yes" xml:space="preserve">
          <source>Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions: an initializer that is not part of a compound literal (6.7.9); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (if or switch) (6.8.4); the controlling expression of a while or do statement (6.8.5); each of the (optional) expressions of a for statement (6.8.5.3); the (optional) expression in a return statement (6.8.6.4).</source>
          <target state="translated">전체 표현식의 평가와 평가할 다음 전체 표현식 사이. 다음은 전체 표현식입니다. 복합 리터럴 (6.7.9)의 일부가 아닌 이니셜 라이저; 표현 문의 표현 (6.8.3); 선택문 (if 또는 switch)의 제어식 (6.8.4); while 또는 do 문의 제어 표현 (6.8.5); for 문 (6.8.5.3)의 각각의 (선택적) 표현; 리턴 명령문의 (선택 사항) 표현식 (6.8.6.4)</target>
        </trans-unit>
        <trans-unit id="040e4fe9d9fa542dc4ba06a43851d6aa5a72dd54" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the first and second operands of the following operators: logical AND &amp;amp;&amp;amp; (6.5.13); logical OR || (6.5.14); comma , (6.5.17).</source>
          <target state="translated">다음 연산자의 첫 번째 피연산자와 두 번째 피연산자의 평가 사이 : 논리 AND &amp;amp;&amp;amp; (6.5.13); 논리 OR || (6.5.14); 쉼표 (6.5.17)</target>
        </trans-unit>
        <trans-unit id="4ad551d09f57149aadd870dc2cb52328b435e78b" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the first operand of the conditional ? : operator and whichever of the second and third operands is evaluated (6.5.15).</source>
          <target state="translated">조건부?의 첫 번째 피연산자 평가 사이 : 연산자와 두 번째 및 세 번째 피연산자 중 어느 것이 든 평가됩니다 (6.5.15).</target>
        </trans-unit>
        <trans-unit id="c5fd30fab6709015ef08a8e61b2e1f1954973f1f" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the function designator and actual arguments in a function call and the actual call. (6.5.2.2).</source>
          <target state="translated">함수 지정자의 평가와 함수 호출의 실제 인수 및 실제 호출 사이. (6.5.2.2).</target>
        </trans-unit>
        <trans-unit id="a81e8350af213ee569d9aa330eca2c02262e4edf" translate="yes" xml:space="preserve">
          <source>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.   Furthermore, the prior value shall be read only to determine the value to be stored.</source>
          <target state="translated">이전과 다음 시퀀스 포인트 사이에서 객체는 표현식의 평가에 의해 저장된 값을 최대 한 번 수정해야합니다. 또한, 저장 될 값을 결정하기 위해 이전 값은 읽기 전용이어야한다.</target>
        </trans-unit>
        <trans-unit id="63273c8e87c71a3a8d9d6a1d10757a35596fab39" translate="yes" xml:space="preserve">
          <source>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]</source>
          <target state="translated">이전과 다음 시퀀스 포인트 사이에서 객체는 표현식의 평가에 의해 저장된 값을 최대 한 번 수정해야합니다. [72] 또한, 저장 될 값을 결정하기 위해 사전 값이 판독 될 것 [73]</target>
        </trans-unit>
        <trans-unit id="7a87c40d2167a7f023df7ecb1485eff49c8549a2" translate="yes" xml:space="preserve">
          <source>But, to your surprise, this program did &lt;em&gt;not&lt;/em&gt; help you understand -- it printed some strange, unexpected, inexplicable output, suggesting that maybe &lt;code&gt;++&lt;/code&gt; does something completely different, not at all what you thought it did.</source>
          <target state="translated">그러나 놀랍게도이 프로그램은 이해하기 &lt;em&gt;어렵&lt;/em&gt; 습니다. 이상하고, 예상치 못한, 설명 할 수없는 결과물이 인쇄되어, &lt;code&gt;++&lt;/code&gt; 가 생각했던 것과 전혀 다른 것이 아니라 ++ 가 완전히 다른 것을 할 수 있음을 시사합니다.</target>
        </trans-unit>
        <trans-unit id="47b2772f5f51e294039858c5f54b8729f2f5faff" translate="yes" xml:space="preserve">
          <source>C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can't predict the behavior when the code is run.</source>
          <target state="translated">C에는 정의되지 않은 동작의 개념이 있습니다. 즉 일부 언어 구문은 구문 상 유효하지만 코드가 실행될 때 동작을 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b35348453822488b14536bba94a12260b7b744a" translate="yes" xml:space="preserve">
          <source>C, of course, has a handy shortcut:</source>
          <target state="translated">물론 C에는 편리한 단축키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="313385540ea390474e5c604236fc46b3e7089c47" translate="yes" xml:space="preserve">
          <source>Depending on whether assignment occurs before or after the increment, different results will be produced and that's the one of the case of &lt;strong&gt;undefined behavior&lt;/strong&gt;.</source>
          <target state="translated">할당이 증분 이전 또는 이후에 발생하는지에 따라 다른 결과가 생성되며 이는 &lt;strong&gt;정의되지 않은 동작&lt;/strong&gt; 의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="2134df76c62a65d697e36a56132e1c70153997df" translate="yes" xml:space="preserve">
          <source>Doesn't operator precedence determine the order of evaluation?</source>
          <target state="translated">운영자 우선 순위가 평가 순서를 결정하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="7ab87e9f1e4738df5111adf51d681da54745c555" translate="yes" xml:space="preserve">
          <source>EXAMPLE An example of unspecified behavior is the order in which the
  arguments to a function are evaluated.</source>
          <target state="translated">예 지정되지 않은 동작의 예는 함수의 인수가 평가되는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="d272d8479ec26da7fb7b5e1ab650055e01f0dee7" translate="yes" xml:space="preserve">
          <source>Evaluations can be one of two things:</source>
          <target state="translated">평가는 다음 두 가지 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea93a535df109ca0d906a45b2cc9253d643f49d8" translate="yes" xml:space="preserve">
          <source>For the expressions we're talking about what makes them undefined is when there's too much going on at once, when we're not sure what order things will happen in, but when the order matters to the result we get.</source>
          <target state="translated">표현을 위해 우리가 그것들을 정의하지 않는 것은 한 번에 너무 많은 일이 발생하는 경우, 어떤 일이 일어날 지 확실하지 않지만 결과가 우리의 결과에 중요 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="57433c0a1b88252b7699f889dbc52ef5538d3c60" translate="yes" xml:space="preserve">
          <source>For those who are new to &lt;em&gt;undefined behaviour&lt;/em&gt; would benefit from reading &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&quot;&gt;What Every C Programmer Should Know About Undefined Behavior&lt;/a&gt;  to understand the concept and many other variants of undefined behaviour in C.</source>
          <target state="translated">&lt;em&gt;정의되지 않은 행동을&lt;/em&gt; 처음 접하는 사람들에게는 &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&quot;&gt;모든 C 프로그래머가 정의되지 않은 행동&lt;/a&gt; 에 대해 알아야 할 내용 을 읽으면 C에서 정의되지 않은 행동 의 개념과 다른 많은 변형을 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a21b34979360402374873c62d1af6606d5786e66" translate="yes" xml:space="preserve">
          <source>Given any two evaluations &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, if &lt;code&gt;A&lt;/code&gt; is sequenced before &lt;code&gt;B&lt;/code&gt;, then the execution of &lt;code&gt;A&lt;/code&gt; shall precede the execution of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">두 가지 평가 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 주어지면, &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 보다 먼저 시퀀싱되면 A 의 실행이 &lt;code&gt;B&lt;/code&gt; 의 실행보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="006ec1d5652cc2abca4a9e550b4b2c9adaa218a5" translate="yes" xml:space="preserve">
          <source>How does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).</source>
          <target state="translated">GCC는 어떻게 작동합니까? 오른쪽 (RHS)에 대해 왼쪽에서 오른쪽 순서로 하위 표현식을 평가 한 다음 값을 왼쪽 (LHS)에 지정합니다. 이것이 바로 Java와 C #이 동작하고 표준을 정의하는 방식입니다. (예, Java 및 C #의 해당 소프트웨어는 동작을 정의했습니다). RHS 선언문에서 각 하위 표현식을 왼쪽에서 오른쪽으로 하나씩 평가합니다. 각 하위 표현식에 대해 : ++ c (사전 증가)가 먼저 평가 된 다음 c 값이 연산에 사용 된 후 사후 증가 c ++)가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2bdbd46fa92ff631f11ad5cb03611cba2db7660a" translate="yes" xml:space="preserve">
          <source>How does visual studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass.</source>
          <target state="translated">Visual Studio는 어떻게 작동하고 다른 접근 방식을 취하며 첫 번째 단계에서 모든 사전 증분 식을 평가 한 다음 두 번째 단계에서 연산의 변수 값을 사용하고 세 번째 단계에서 RHS에서 LHS로 할당 한 다음 마지막으로 모든 단계를 평가합니다. 한 번에 증가 후 표현식.</target>
        </trans-unit>
        <trans-unit id="c72c73363ab17f40ba3f10293b5bd49072e48feb" translate="yes" xml:space="preserve">
          <source>However if you stick to one compiler, you will find the behavior persistent, as long as you don't add function calls or pointers, which would make the behavior more messy.</source>
          <target state="translated">그러나 하나의 컴파일러를 고수하면 함수 호출이나 포인터를 추가하지 않으면 동작이 더 지저분해질 것입니다.</target>
        </trans-unit>
        <trans-unit id="7da8149973e9017187a301f4973c6be9158d15d5" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;,&lt;/code&gt; in function argument lists is &lt;em&gt;not&lt;/em&gt; a comma operator, and there is no sequence point between evaluations of distinct arguments; instead their evaluations are unsequenced with regard to each other; so the function call</source>
          <target state="translated">그러나 함수 인수 목록에서 &lt;code&gt;,&lt;/code&gt; 는 쉼표 연산자가 &lt;em&gt;아니며&lt;/em&gt; 고유 인수 평가 사이에 시퀀스 포인트가 없습니다. 대신 그들의 평가는 서로에 대해 순서가 정해지지 않습니다. 그래서 함수 호출</target>
        </trans-unit>
        <trans-unit id="8ff4f957f0bef850d0e13306eb783d225574c291" translate="yes" xml:space="preserve">
          <source>However, two different variables can be incremented between two sequence points.</source>
          <target state="translated">그러나 두 시퀀스 포인트간에 서로 다른 두 변수를 증분시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4e9fd2fb6e6a52790d78e1ea1a9104776d97482" translate="yes" xml:space="preserve">
          <source>I assume you've heard the basic definition of C's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; operators by now, and how the prefix form &lt;code&gt;++x&lt;/code&gt; differs from the postfix form &lt;code&gt;x++&lt;/code&gt;.  But these operators are hard to think about, so to make sure you understood, perhaps you wrote a tiny little test program involving something like</source>
          <target state="translated">지금까지 C의 &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 연산자에 대한 기본 정의를들은 것으로 가정하고 접두사 형식 &lt;code&gt;++x&lt;/code&gt; 가 접미사 형식 &lt;code&gt;x++&lt;/code&gt; 과 어떻게 다른지 알고 있습니다. 그러나 이러한 연산자는 생각하기가 어렵습니다. 이해를 돕기 위해 아마도 다음과 같은 작은 테스트 프로그램을 작성했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d2b970b978a071c4f163f23f1f4e314def839a10" translate="yes" xml:space="preserve">
          <source>I explain the ideas.</source>
          <target state="translated">나는 아이디어를 설명한다.</target>
        </trans-unit>
        <trans-unit id="7e1cdd37254f419dc8e9ee3785767a5fcd30479d" translate="yes" xml:space="preserve">
          <source>I think the relevant parts of the C99 standard are 6.5 Expressions, &amp;sect;2</source>
          <target state="translated">C99 표준의 관련 부분은 6.5 식, &amp;sect;2라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ebb30d2d2d8387aa698cfa701d3a0b2ef943f61b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is not sequenced before or after &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are unsequenced.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 전후에 시퀀싱되지 않으면 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 는 순서가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e8615005607bfaf839090f5116302468a3077a1" translate="yes" xml:space="preserve">
          <source>If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84)</source>
          <target state="translated">스칼라 오브젝트의 부작용이 동일한 스칼라 오브젝트의 다른 부작용 또는 동일한 스칼라 오브젝트의 값을 사용한 값 계산과 관련하여 순서가 지정되지 않으면 동작이 정의되지 않습니다. 표현식의 하위 표현식에 허용되는 순서가 여러 개인 경우 순서에 상관없이 이러한 부작용이 발생하면 동작이 정의되지 않습니다 .84)</target>
        </trans-unit>
        <trans-unit id="6b364d00d6c222691294e1d715a9d3195c3b8d0b" translate="yes" xml:space="preserve">
          <source>If the compiler were to write &lt;code&gt;i++&lt;/code&gt; as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn't happen to notice that one of the other instructions happened to access &lt;code&gt;i&lt;/code&gt;, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable &lt;code&gt;i&lt;/code&gt; is used in both places, but if a routine accepts references to two pointers &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;, and uses &lt;code&gt;(*p)&lt;/code&gt; and &lt;code&gt;(*q)&lt;/code&gt; in the above expression (rather than using &lt;code&gt;i&lt;/code&gt; twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same object's address were passed for both &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 위에서 명시한대로 (표준에 따라) &lt;code&gt;i++&lt;/code&gt; 를 작성하고 전체 표현의 평가를 통해 위의 지시 사항을 산재하고 (법적) 다른 지시 사항 중 하나를 발견하지 못한 경우 &lt;code&gt;i&lt;/code&gt; 에 액세스하면 컴파일러가 교착 상태에 빠질 수있는 일련의 명령어를 생성하는 것이 가능하고 합법적입니다. 확실히하기 위해 컴파일러는 동일한 변수 &lt;code&gt;i&lt;/code&gt; 가 두 곳에서 사용되는 경우 거의 확실하게 문제를 감지하지만 루틴이 두 포인터 &lt;code&gt;p&lt;/code&gt; 와 &lt;code&gt;q&lt;/code&gt; 에 대한 참조를 허용하고 &lt;code&gt;(*p)&lt;/code&gt; 와 &lt;code&gt;(*q)&lt;/code&gt; 를 사용하는 경우 위의 표현식에서 ( &lt;code&gt;i&lt;/code&gt; 를 두 번 사용하는 대신) 컴파일러는 동일한 객체의 주소가 &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;q&lt;/code&gt; 모두에 대해 전달 된 경우 발생할 수있는 교착 상태를 인식하거나 피할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c74bddb68bd6a38d49d02706436102a8da2c6744" translate="yes" xml:space="preserve">
          <source>If there's a variable that's getting modified in one place, and having its value used in another place, how do you know whether it uses the old value or the new value?</source>
          <target state="translated">한 곳에서 수정되고 다른 곳에서 값을 사용하는 변수가있는 경우 이전 값을 사용하는지 새 값을 사용하는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4647db1287f30dfb23b1f0e049be0ffce3ceebe7" translate="yes" xml:space="preserve">
          <source>If there's one variable that's getting modified (assigned to) in two or more different places, how do you know which modification happens first?</source>
          <target state="translated">둘 이상의 다른 위치에서 수정 (할당)되는 변수가 하나 있으면 어떤 수정이 먼저 발생하는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ee1d81c9d526b617cd5db47f0b9129a56d6d92fc" translate="yes" xml:space="preserve">
          <source>Immediately before a library function returns (7.1.4).</source>
          <target state="translated">라이브러리 함수가 (7.1.4)를 반환하기 직전에.</target>
        </trans-unit>
        <trans-unit id="ccc935207dc7de3d090caefd6346b4420b8001d0" translate="yes" xml:space="preserve">
          <source>Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.22.5).</source>
          <target state="translated">비교 함수에 대한 각 호출 직전과 직후 그리고 비교 함수에 대한 호출과 해당 호출에 대한 인수로 전달 된 객체의 이동 사이 (7.22.5).</target>
        </trans-unit>
        <trans-unit id="60ed5174c21627240c96b7033c369a5233234943" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&quot;&gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&lt;/a&gt; someone asked about a statement like:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&quot;&gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c에서&lt;/a&gt; 누군가가 다음과 같은 진술에 대해 물었습니다.</target>
        </trans-unit>
        <trans-unit id="e29fa6906c297000780a6ab5da38fae509305f9d" translate="yes" xml:space="preserve">
          <source>In GCC C++,  the precedence of the operators controls the order in
  which the individual operators are evaluated</source>
          <target state="translated">GCC C ++에서 연산자의 우선 순위는 개별 연산자가 평가되는 순서를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="eb8013ee2895e4b793b24f5480886aca31c43b1e" translate="yes" xml:space="preserve">
          <source>In all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the &lt;code&gt;;&lt;/code&gt; in each one of these cases:</source>
          <target state="translated">이 모든 예제에서 코드는 동일한 시퀀스 포인트에서 객체를 두 번 이상 수정하려고 시도합니다 &lt;code&gt;;&lt;/code&gt; 이러한 경우 각각 :</target>
        </trans-unit>
        <trans-unit id="85af2d68b64dacc2ecae8e6b8fe0626d9c55f451" translate="yes" xml:space="preserve">
          <source>In the following statement:</source>
          <target state="translated">다음 진술에서 :</target>
        </trans-unit>
        <trans-unit id="57437b57542ff5ccdb46668e495487b9f29b828e" translate="yes" xml:space="preserve">
          <source>In the paper that I quoted above it is explained that you can figure out the program as being formed by small boxes, each box containing the instructions between 2 consecutive sequence points.  The sequence points are defined in annex C of the standard, in the case of &lt;code&gt;i=i++&lt;/code&gt; there are 2 sequence points that delimit a full-expression.  Such an expression is syntactically equivalent with an entry of &lt;code&gt;expression-statement&lt;/code&gt; in the Backus-Naur form of the grammar (a grammar is provided in annex A of the Standard).</source>
          <target state="translated">위에서 인용 한 논문에서는 프로그램이 작은 상자로 구성되는 것으로 파악할 수 있다고 설명합니다. 각 상자에는 두 개의 연속적인 시퀀스 지점 사이의 명령이 들어 있습니다. 서열 점은 표준의 부속서 C에 정의되어 있으며, &lt;code&gt;i=i++&lt;/code&gt; 경우, 완전한 발현을 한정하는 2 개의 서열 점이 존재한다. 이러한 표현은 문법의 Backus-Naur 형태의 &lt;code&gt;expression-statement&lt;/code&gt; 입력과 구문 적으로 동등합니다 (문법은 표준의 부록 A에 제공됨).</target>
        </trans-unit>
        <trans-unit id="dab7f2edb9365a8a8024bd3b99b725247b21d547" translate="yes" xml:space="preserve">
          <source>It means the expression &lt;code&gt;il = ir++&lt;/code&gt; could be evaluated either as</source>
          <target state="translated">이는 &lt;code&gt;il = ir++&lt;/code&gt; 표현식을 다음과 같이 평가할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6d4bde792ab173fc5f3953aa5c52bd9c3b953ae4" translate="yes" xml:space="preserve">
          <source>Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.</source>
          <target state="translated">당신이 얻는 것을 얼마나 정확하게 얻는 지 알고 싶다면 코드 라인을 컴파일하고 분해하십시오.</target>
        </trans-unit>
        <trans-unit id="139c53c1c422cb855e5ab14ec329f7d3e7293cf2" translate="yes" xml:space="preserve">
          <source>Let's go back to the two examples I've used in this answer.  When I wrote</source>
          <target state="translated">이 답변에서 사용한 두 가지 예로 돌아가 보겠습니다. 내가 쓸 때</target>
        </trans-unit>
        <trans-unit id="007b8d5a96beaf6791ee66ac241a455d31c8ebee" translate="yes" xml:space="preserve">
          <source>Lets rename the &lt;code&gt;i&lt;/code&gt; at left of assignment be &lt;code&gt;il&lt;/code&gt; and at the right of assignment (in the expression &lt;code&gt;i++&lt;/code&gt;) be &lt;code&gt;ir&lt;/code&gt;, then the expression be like</source>
          <target state="translated">과제의 왼쪽에있는 &lt;code&gt;i&lt;/code&gt; 의 이름을 &lt;code&gt;il&lt;/code&gt; 로 하고 과제의 오른쪽에있는 &lt;code&gt;i++&lt;/code&gt; (식 i ++에서 )의 이름을 &lt;code&gt;ir&lt;/code&gt; 로 바꾸면 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e79c62d8a96cc83c832406559fd72c325b73755" translate="yes" xml:space="preserve">
          <source>Modern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).</source>
          <target state="translated">최신 컴파일러는 이것을 잘 최적화합니다. 실제로, 원래 작성한 코드보다 더 좋을 수 있습니다 (원하는 방식으로 작동했다고 가정).</target>
        </trans-unit>
        <trans-unit id="abffaa693417a99890a9f9f411f179a50d8a1f83" translate="yes" xml:space="preserve">
          <source>Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand &lt;strong&gt;why the behavior of these constructs are undefined&lt;/strong&gt;, let's understand these terms first in the light of C11 standard:</source>
          <target state="translated">여기에 나오는 대부분의 답변은 C 표준에서 인용 한 것으로, 이러한 구성의 동작이 정의되어 있지 않음을 강조합니다. &lt;strong&gt;이러한 구성의 동작이 정의되지 않은 이유&lt;/strong&gt; 를 이해하려면 C11 표준에 비추어 먼저이 용어를 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="65659095c4721a9366d72724c0af8686528c6a8e" translate="yes" xml:space="preserve">
          <source>Now coming to the question, for the expressions like</source>
          <target state="translated">이제 질문에옵니다.</target>
        </trans-unit>
        <trans-unit id="b011b82c9d0b255b15ca16ab67361428cc130072" translate="yes" xml:space="preserve">
          <source>Often this question is linked as a duplicate of questions related to code like</source>
          <target state="translated">종종이 질문은 다음과 같은 코드와 관련된 질문의 중복으로 연결됩니다</target>
        </trans-unit>
        <trans-unit id="80af210ba078168ac8aed18f4c289fb13eafe061" translate="yes" xml:space="preserve">
          <source>Or, perhaps you're looking at a hard-to-understand expression like</source>
          <target state="translated">또는 아마도 이해하기 어려운 표현을보고있을 것입니다</target>
        </trans-unit>
        <trans-unit id="7814f3637cef69793eb4cd0c35453c057b2b2e5b" translate="yes" xml:space="preserve">
          <source>Other good source for explaining such ambiguities are the entries from &lt;a href=&quot;http://c-faq.com/&quot;&gt;c-faq&lt;/a&gt; site (also published &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201845199&quot;&gt;as a book&lt;/a&gt;) , namely &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://c-faq.com/expr/evalorder4.html&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://c-faq.com/expr/confused.html&quot;&gt;here&lt;/a&gt; .</source>
          <target state="translated">이러한 모호성을 설명하는 또 다른 좋은 출처는 &lt;a href=&quot;http://c-faq.com/&quot;&gt;c-faq&lt;/a&gt; 사이트 ( &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201845199&quot;&gt;도서로&lt;/a&gt; 도 게시 됨 )의 항목, 즉 &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;여기&lt;/a&gt; 와 &lt;a href=&quot;http://c-faq.com/expr/evalorder4.html&quot;&gt;여기&lt;/a&gt; 및 &lt;a href=&quot;http://c-faq.com/expr/confused.html&quot;&gt;여기&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="270467ed08a16c4189f257fa18a363287c860a70" translate="yes" xml:space="preserve">
          <source>Perhaps someone gave you that code as a puzzle.  This code also makes no sense, especially if you run it -- and if you compile and run it under two different compilers, you're likely to get two different answers!  What's up with that?  Which answer is correct?  (And the answer is that both of them are, or neither of them are.)</source>
          <target state="translated">아마도 누군가 당신에게 그 코드를 퍼즐로 줬을 것입니다. 이 코드는 특히 실행하는 경우 의미가 없으며 두 개의 다른 컴파일러에서 컴파일하고 실행하면 두 가지 다른 답변을 얻을 수 있습니다! 무슨 일이야? 어떤 대답이 맞습니까? (그리고 대답은 둘 다 또는 둘 다 없다는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="9830e65c22471dbb5ae76ba87a9754d88a6b0759" translate="yes" xml:space="preserve">
          <source>Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</source>
          <target state="translated">정의되지 않은 동작은 예측할 수없는 결과로 상황을 완전히 무시하는 것, 환경의 특징적인 문서화 된 방식으로 진단 또는 프로그램 실행 중 (진단 메시지 발행 여부에 관계없이), 번역 또는 실행 종료 (발급 포함)에 이르기까지 다양합니다. 진단 메시지).</target>
        </trans-unit>
        <trans-unit id="d4ec24e520c2deaf639afba4b9f783d5aac04aab" translate="yes" xml:space="preserve">
          <source>Realistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, &quot;If it's not obvious what an expression using ++ means, don't write it.&quot;</source>
          <target state="translated">현실적으로,이 미친 표현은 사람들이 ++가 어떻게 작동해야하는지에 대한 인공적인 예로서 사용하는 경우에만 가능합니다. 물론 ++ 작동 방식을 이해하는 것이 중요합니다. 그러나 ++를 사용하는 실질적인 규칙 중 하나는 &quot;++를 사용한 표현의 의미가 확실하지 않으면 쓰지 마십시오&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6343a0dd7d4a3cce5612fb2bd80119beebcf602a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;question 3.8&lt;/a&gt; and the rest of the questions in &lt;a href=&quot;http://c-faq.com/expr/index.html&quot;&gt;section 3&lt;/a&gt; of the &lt;a href=&quot;http://c-faq.com/&quot;&gt;C FAQ list&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;질문 3.8&lt;/a&gt; 및 &lt;a href=&quot;http://c-faq.com/&quot;&gt;C FAQ 목록&lt;/a&gt; 의 &lt;a href=&quot;http://c-faq.com/expr/index.html&quot;&gt;섹션 3&lt;/a&gt; 에있는 나머지 질문 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b00a321a9495c839c828a507be825ff13a7800c" translate="yes" xml:space="preserve">
          <source>So a sequence point can be seen by the beginning and the end of each box that composes the program [the boxes are atomic units in C] and inside a box the order of instructions is not defined in all cases.  Changing that order one can change the result sometimes.</source>
          <target state="translated">따라서 프로그램을 구성하는 각 상자의 시작과 끝에서 시퀀스 포인트를 볼 수 있습니다 (상자는 C의 원자 단위 임). 상자 안의 지시 순서는 모든 경우에 정의되지 않습니다. 순서를 변경하면 결과가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d21ba0d230406e77017c4520bffdb2aae21a3660" translate="yes" xml:space="preserve">
          <source>So every statement of the form:</source>
          <target state="translated">따라서 양식의 모든 진술 :</target>
        </trans-unit>
        <trans-unit id="647883dff5588a701bbd3395f0dfc501b2bb13be" translate="yes" xml:space="preserve">
          <source>So first the GCC:
Using &lt;a href=&quot;https://nuwen.net/mingw.html&quot;&gt;Nuwen MinGW&lt;/a&gt; 15 GCC 7.1 you will get:</source>
          <target state="translated">먼저 GCC : &lt;a href=&quot;https://nuwen.net/mingw.html&quot;&gt;Nuwen MinGW&lt;/a&gt; 15 GCC 7.1을 사용하면 다음과 같은 이점 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1619e58534e7a9257bad023ee9910dd4500fdf3" translate="yes" xml:space="preserve">
          <source>So if the &lt;em&gt;comma&lt;/em&gt; in the function call were to be a comma operator then</source>
          <target state="translated">따라서 함수 호출의 쉼표가 쉼표 연산자 인 경우</target>
        </trans-unit>
        <trans-unit id="d80658b592df0803b15a8dd4666f791a7e32f7f1" translate="yes" xml:space="preserve">
          <source>So moving on to &lt;em&gt;unspecified behavior&lt;/em&gt;, in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;draft c99 standard&lt;/a&gt; section&lt;code&gt;6.5&lt;/code&gt; paragraph &lt;em&gt;3&lt;/em&gt; says(&lt;em&gt;emphasis mine&lt;/em&gt;):</source>
          <target state="translated">따라서 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;c99 표준 초안&lt;/a&gt; &lt;code&gt;6.5&lt;/code&gt; 단락 &lt;em&gt;3&lt;/em&gt; 에서 &lt;em&gt;지정되지 않은 동작으로&lt;/em&gt; 이동하면 다음과 같이 말합니다 ( &lt;em&gt;강조 광산&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="de08ea26a98f633b8bc219b190df93d9fb9ddf4e" translate="yes" xml:space="preserve">
          <source>So that's the answer: make sure that in any expression you write, each variable is modified at most once, and if a variable is modified, you don't also attempt to use the value of that variable somewhere else.</source>
          <target state="translated">이것이 바로 답입니다. 작성한 표현식에서 각 변수는 최대 한 번 수정되고 변수가 수정 된 경우 해당 변수의 값을 다른 곳에서도 사용하려고 시도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fe5b5ad4189e6c54f36de1b0cb2dd509ca3eedca" translate="yes" xml:space="preserve">
          <source>So the equivalent in defined behavior C++ as Visual C++ understands:</source>
          <target state="translated">따라서 Visual C ++이 이해하는 정의 된 동작 C ++과 동등한 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39e26ec98db22aab7bb548688a3cf6b65be062cd" translate="yes" xml:space="preserve">
          <source>So the order of instructions inside a box has no clear order.</source>
          <target state="translated">따라서 상자 안의 지시 순서는 명확한 순서가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0813b942e4187634ff676479cc7529a6a62bd091" translate="yes" xml:space="preserve">
          <source>So when we have a line like this:</source>
          <target state="translated">따라서 다음과 같은 줄이있을 때 :</target>
        </trans-unit>
        <trans-unit id="51bff8d93419b8b376c49a4c4c1c6942815bd3f1" translate="yes" xml:space="preserve">
          <source>So with all that background and introduction out of the way, if you want to make sure that all your programs are well-defined, which expressions can you write, and which ones can you not write?</source>
          <target state="translated">따라서 모든 배경과 소개를 벗어난 상태에서 모든 프로그램을 잘 정의하고 싶다면 어떤 표현을 작성할 수 있고 어떤 표현을 쓸 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="418454311311342d72ab9381129cfc784f14f285" translate="yes" xml:space="preserve">
          <source>So, with that in mind, why are these &quot;issues&quot;? The language clearly says that certain things lead to &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;undefined behavior&lt;/a&gt;. There is no problem, there is no &quot;should&quot; involved. If the undefined behavior changes when one of the involved variables is declared &lt;code&gt;volatile&lt;/code&gt;, that doesn't prove or change anything. It is &lt;em&gt;undefined&lt;/em&gt;; you cannot reason about the behavior.</source>
          <target state="translated">그래서, 그 점을 염두에두고 왜 이러한 &quot;문제&quot;가 있습니까? 언어는 특정 사물이 &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;정의되지 않은 행동으로&lt;/a&gt; 이어진다 고 분명히 말합니다. 문제는 없습니다. 관련된 &quot;해야합니다&quot;없습니다. 관련 변수 중 하나가 &lt;code&gt;volatile&lt;/code&gt; 로 선언 될 때 정의되지 않은 동작이 변경되면 아무 것도 증명하거나 변경하지 않습니다. &lt;em&gt;정의되어 있지 않습니다&lt;/em&gt; . 당신은 그 행동에 대해 추론 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="52169783c5f1f44d70c71ae0d258a149699e59f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;++i&lt;/code&gt; increments aren't guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 &lt;code&gt;++i&lt;/code&gt; executed, then the values of &lt;code&gt;k[]&lt;/code&gt; were read, then the last &lt;code&gt;++i&lt;/code&gt; then &lt;code&gt;k[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;++i&lt;/code&gt; 증분이 나머지 계산 전에 모두 완료되는 것은 아닙니다. 실제로 다른 컴파일러는 다른 결과를 얻습니다. 제공 한 예제에서 처음 두 &lt;code&gt;++i&lt;/code&gt; 가 실행 된 다음 &lt;code&gt;k[]&lt;/code&gt; 의 값을 읽은 다음 마지막 &lt;code&gt;++i&lt;/code&gt; 와 k [] 를 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="b497b90b5e9411034420efd2bf3531f465b5abe8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;unspecified behaviour&lt;/em&gt; itself is NOT an issue. Consider this example:</source>
          <target state="translated">&lt;em&gt;지정되지 않은 동작&lt;/em&gt; 자체는 문제가되지 않습니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aef2dc12b657421591a01f033cfac67b5ba2c01f" translate="yes" xml:space="preserve">
          <source>The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point.</source>
          <target state="translated">C 표준에 따르면 변수는 두 시퀀스 포인트 사이에 최대 한 번만 할당해야합니다. 예를 들어 세미콜론은 시퀀스 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="310e41e0df172a9305a8811318f58058e4fed9e9" translate="yes" xml:space="preserve">
          <source>The above is a common coding practice while copying/analysing strings.</source>
          <target state="translated">위의 내용은 문자열을 복사 / 분석하는 동안 일반적인 코딩 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c5e1fbdb0b52dfbb81762c5648cb9c71849abbe4" translate="yes" xml:space="preserve">
          <source>The behavior can't really be explained because it invokes both &lt;a href=&quot;http://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;unspecified behavior&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;undefined behavior&lt;/a&gt;, so we can not make any general predictions about this code, although if you read &lt;em&gt;Olve Maudal's&lt;/em&gt; work such as &lt;a href=&quot;http://www.slideshare.net/olvemaudal/deep-c&quot;&gt;Deep C&lt;/a&gt; and &lt;a href=&quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf&quot;&gt;Unspecified and Undefined&lt;/a&gt; sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don't do that anywhere near production.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;지정되지 않은 동작&lt;/a&gt; 과 &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;정의되지&lt;/a&gt; 않은 동작을 모두 호출하기 때문에 동작을 실제로 설명 할 수 없으므로 &lt;a href=&quot;http://www.slideshare.net/olvemaudal/deep-c&quot;&gt;Deep C&lt;/a&gt; 및 &lt;a href=&quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf&quot;&gt;Unspecified 및 Undefined&lt;/a&gt; 와 같은 &lt;em&gt;Olve Maudal의&lt;/em&gt; 작업을 읽으면 &lt;em&gt;때때로이&lt;/em&gt; 코드를 만들 수는 있지만이 코드에 대한 일반적인 예측을 할 수는 없습니다. 특정 컴파일러와 환경에서 매우 구체적인 경우를 추측하지만 프로덕션 근처에서는 그렇게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="27ec791e6f2a00a49e0a8a0ed54e4616a7f3a094" translate="yes" xml:space="preserve">
          <source>The comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in &lt;code&gt;j = (++i, i++);&lt;/code&gt;, &lt;code&gt;++i&lt;/code&gt; increments &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; and &lt;code&gt;i++&lt;/code&gt; yields old value of &lt;code&gt;i&lt;/code&gt; (&lt;code&gt;6&lt;/code&gt;) which is assigned to &lt;code&gt;j&lt;/code&gt;. Then &lt;code&gt;i&lt;/code&gt; becomes &lt;code&gt;7&lt;/code&gt; due to post-increment.</source>
          <target state="translated">쉼표 연산자는 피연산자를 왼쪽에서 오른쪽으로 평가하고 마지막 피연산자 값만 산출합니다. 따라서 &lt;code&gt;j = (++i, i++);&lt;/code&gt; &lt;code&gt;++i&lt;/code&gt; 는 &lt;code&gt;i&lt;/code&gt; 를 &lt;code&gt;6&lt;/code&gt; 으로 증가시키고 &lt;code&gt;i++&lt;/code&gt; 는 &lt;code&gt;j&lt;/code&gt; 에 할당 된 &lt;code&gt;i&lt;/code&gt; ( &lt;code&gt;6&lt;/code&gt; )의 오래된 값을 산출합니다. 그런 다음 증가 후로 &lt;code&gt;7&lt;/code&gt; 이됩니다.</target>
        </trans-unit>
        <trans-unit id="b67dbcc4d76d135a5736d6b29c5429827a1f48d3" translate="yes" xml:space="preserve">
          <source>The end of a full declarator: declarators (6.7.6);</source>
          <target state="translated">완전한 선언의 끝 : 선언자 (6.7.6);</target>
        </trans-unit>
        <trans-unit id="0108968d37f78fc724b69ab92c9f870191ada9e6" translate="yes" xml:space="preserve">
          <source>The first fragment asked about, &lt;code&gt;i = i++ + ++i&lt;/code&gt;, is pretty clearly insane in my book.  No one would ever write it in a real program, it's not obvious what it does, there's no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it's not obvious to you and me what it's supposed to do, it's fine in my book if the compiler can't figure out what it's supposed to do, either.</source>
          <target state="translated">&lt;code&gt;i = i++ + ++i&lt;/code&gt; 에 대해 묻는 첫 번째 조각은 필자의 책에서 분명히 미쳤습니다. 아무도 실제 프로그램으로 작성하지 않았으며, 그것이 무엇을하는지 명확하지 않으며, 누군가가이 특별한 계획된 조작 순서를 초래할 수있는 코딩을 시도했을지도 모를 알고리즘도 없습니다. 그리고 당신과 나에게해야 할 일이 분명하지 않기 때문에 컴파일러가해야 할 일을 이해할 수 없다면 내 책에서 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="90a68f87988cd45f4bd6311c6ab3e5a1dc45538e" translate="yes" xml:space="preserve">
          <source>The following are the sequence points described in 5.1.2.3:</source>
          <target state="translated">다음은 5.1.2.3에 설명 된 시퀀스 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="902611ed1501ed869ca53ff5d324e744ab75270b" translate="yes" xml:space="preserve">
          <source>The grouping of operators and operands is indicated by the syntax.74) Except as specified
  later (for the function-call (), &amp;amp;&amp;amp;, ||, ?:, and comma operators), &lt;strong&gt;the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.&lt;/strong&gt;</source>
          <target state="translated">연산자와 피연산자의 그룹화는 구문으로 표시됩니다 .74) 나중에 지정된 경우 (함수 호출 (), &amp;amp;&amp;amp;, ||,? : 및 쉼표 연산자의 경우), &lt;strong&gt;하위 표현식의 평가 순서 및 순서 어떤 부작용이 발생하는지는 명시되어 있지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71b9fec95a5c0e3f3bf5d039dad362d79f0e9e56" translate="yes" xml:space="preserve">
          <source>The important part is to know &lt;a href=&quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c&quot;&gt;what a sequence point is -- and &lt;em&gt;what is&lt;/em&gt; a sequence point and what &lt;em&gt;isn't&lt;/em&gt;&lt;/a&gt;. For example the &lt;em&gt;comma operator&lt;/em&gt; is a sequence point, so</source>
          <target state="translated">중요한 부분은 &lt;a href=&quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c&quot;&gt;시퀀스 포인트가 무엇인지, 시퀀스 포인트가 무엇인지 &lt;em&gt;아닌지&lt;/em&gt;&lt;/a&gt; 아는 것 입니다. 예를 들어 &lt;em&gt;쉼표 연산자&lt;/em&gt; 는 시퀀스 포인트이므로</target>
        </trans-unit>
        <trans-unit id="51f661df914e1e2ea77746de6aaa11f9b46f6347" translate="yes" xml:space="preserve">
          <source>The main rule from the standard ISO 9899 that applies in this situation is  6.5p2.</source>
          <target state="translated">이 상황에 적용되는 표준 ISO 9899의 기본 규칙은 6.5p2입니다.</target>
        </trans-unit>
        <trans-unit id="88392b333617da7906af6f1c9e71bc7a0011c98f" translate="yes" xml:space="preserve">
          <source>The order in which the function designator, arguments, and
  subexpressions within the arguments are evaluated in a function call
  (6.5.2.2).</source>
          <target state="translated">인수 내의 함수 지정자, 인수 및 부속 식의 순서는 함수 호출 (6.5.2.2)에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c9968c66bc17adf0cf66c21f5fc4281778fad8b3" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands is unspecified. If an attempt is made to modify
  the result of an assignment operator or to access it after the next sequence point, the
  behavior is undefined.</source>
          <target state="translated">피연산자의 평가 순서는 지정되어 있지 않습니다. 할당 연산자의 결과를 수정하거나 다음 시퀀스 포인트 이후에 액세스하려고하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57d772c677ab734e951cb65c9f5a9c6ad1025dbd" translate="yes" xml:space="preserve">
          <source>The presence of a sequence point between the evaluation of expressions &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; implies that every &lt;em&gt;value computation&lt;/em&gt; and &lt;em&gt;side effect&lt;/em&gt; associated with &lt;code&gt;A&lt;/code&gt; is sequenced before every &lt;em&gt;value computation&lt;/em&gt; and &lt;em&gt;side effect&lt;/em&gt; associated with &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">식 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 평가 사이에 서열 지점이 존재한다는 것은 A 와 관련된 모든 &lt;em&gt;값 계산&lt;/em&gt; 및 &lt;em&gt;부작용&lt;/em&gt; 이 &lt;code&gt;B&lt;/code&gt; 와 관련된 모든 &lt;em&gt;값 계산&lt;/em&gt; 및 &lt;em&gt;부작용&lt;/em&gt; 전에 순서화됨을 의미한다.</target>
        </trans-unit>
        <trans-unit id="3fa757362c1545c0b1bfa0b4971c8bcf9a5fa705" translate="yes" xml:space="preserve">
          <source>The problem with this expression is that it contains three different attempts to modify the value of x: (1) the &lt;code&gt;x++&lt;/code&gt; part tries to add 1 to x, store the new value in &lt;code&gt;x&lt;/code&gt;, and return the old value of &lt;code&gt;x&lt;/code&gt;; (2) the &lt;code&gt;++x&lt;/code&gt; part tries to add 1 to x, store the new value in &lt;code&gt;x&lt;/code&gt;, and return the new value of &lt;code&gt;x&lt;/code&gt;; and (3) the &lt;code&gt;x =&lt;/code&gt; part tries to assign the sum of the other two back to x.  Which of those three attempted assignments will &quot;win&quot;?  Which of the three values will actually get assigned to &lt;code&gt;x&lt;/code&gt;?  Again, and perhaps surprisingly, there's no rule in C to tell us.</source>
          <target state="translated">이 표현식의 문제점은 x의 값을 수정하려는 세 가지 다른 시도를 포함한다는 것입니다. (1) &lt;code&gt;x++&lt;/code&gt; 부분은 x 를 1에 더하고 x에 새 값을 저장하고 &lt;code&gt;x&lt;/code&gt; 의 이전 값을 리턴합니다. (2) &lt;code&gt;++x&lt;/code&gt; 부분은 1을 x에 더하고 x에 새로운 값을 저장하고 &lt;code&gt;x&lt;/code&gt; 의 새로운 값을 반환하려고 시도합니다. 그리고 (3) &lt;code&gt;x =&lt;/code&gt; 부분은 다른 두 개의 합을 다시 x에 할당하려고 시도합니다. 이 세 번의 과제 중 어느 것이 &quot;승리&quot;할 것인가? 세 값 중 실제로 &lt;code&gt;x&lt;/code&gt; 에 할당되는 값은 무엇입니까? 다시 말하지만 놀랍게도 C에는 우리에게 말할 규칙이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8cf9f511dc75b3a4a079a7021f4a602979571d13" translate="yes" xml:space="preserve">
          <source>The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).</source>
          <target state="translated">그 이유는 프로그램이 정의되지 않은 동작을 실행하고 있기 때문입니다. 문제는 C ++ 98 표준에 따라 필요한 시퀀스 포인트가 없기 때문에 평가 순서에 있습니다 (C ++ 11 용어에 따라 다른 작업 전후에 시퀀스가 ​​수행되지 않음).</target>
        </trans-unit>
        <trans-unit id="44562ae2bb8fdbc35628d635d10e98d6d60b8571" translate="yes" xml:space="preserve">
          <source>The second fragment, &lt;code&gt;i = i++&lt;/code&gt;, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:</source>
          <target state="translated">두 번째 조각 인 &lt;code&gt;i = i++&lt;/code&gt; 는 이해하기 조금 더 쉽습니다. 누군가가 분명히 i를 증가시키고 결과를 i에 다시 할당하려고합니다. 그러나 C에서 이것을 수행하는 몇 가지 방법이 있습니다. 1을 i에 더하고 결과를 다시 i에 할당하는 가장 기본적인 방법은 거의 모든 프로그래밍 언어에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6c93396d9e2d8c2a40d78d9071566b25f416ee2f" translate="yes" xml:space="preserve">
          <source>The sequence points in an expression like &lt;code&gt;i=i++&lt;/code&gt; are before &lt;code&gt;i=&lt;/code&gt; and after &lt;code&gt;i++&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i=i++&lt;/code&gt; 와 같은 표현식의 시퀀스 포인트는 i = 이전과 &lt;code&gt;i++&lt;/code&gt; 이후입니다.</target>
        </trans-unit>
        <trans-unit id="9c90d0fb8a0d148c282b3883e977c9bc9699153f" translate="yes" xml:space="preserve">
          <source>The various sequence points are listed in Annex C of &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#C&quot;&gt;C11&lt;/a&gt; (and &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#C&quot;&gt;C99&lt;/a&gt;):</source>
          <target state="translated">다양한 시퀀스 포인트가 &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#C&quot;&gt;C11&lt;/a&gt; (및 &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#C&quot;&gt;C99&lt;/a&gt; )의 부록 C에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a79c3a06a2a5a93d7c630437550bdbcddba0807b" translate="yes" xml:space="preserve">
          <source>The wording of the same &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2&quot;&gt;paragraph in C11&lt;/a&gt; is:</source>
          <target state="translated">&lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2&quot;&gt;C11&lt;/a&gt; 에서 동일한 단락 의 문구는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a85af3330f4c3a70b16dc7300fc5a565d163704" translate="yes" xml:space="preserve">
          <source>Then we go to &lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;Visual Studio&lt;/a&gt;. Visual Studio 2015, you get:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;Visual Studio&lt;/a&gt; 로갑니다. Visual Studio 2015는 다음과 같은 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="97e693ad3a0c6aa731e9685496e0af87463aa908" translate="yes" xml:space="preserve">
          <source>Therefore, the above expression invokes UB because two side effects on the same object &lt;code&gt;i&lt;/code&gt; is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to &lt;code&gt;i&lt;/code&gt; will be done before or after the side effect by &lt;code&gt;++&lt;/code&gt;.</source>
          <target state="translated">따라서 동일한 객체 &lt;code&gt;i&lt;/code&gt; 에 대한 두 부작용이 서로에 대해 순서가 다르지 않기 때문에 위의 표현식은 UB를 호출합니다. 즉, &lt;code&gt;i&lt;/code&gt; 에 할당하여 부작용을 &lt;code&gt;++&lt;/code&gt; 로 부작용 전후에 수행할지 여부는 순서가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5f8681d077917f909bd82bb366210d3de854d2d" translate="yes" xml:space="preserve">
          <source>These expressions are all fine:</source>
          <target state="translated">이 표현들은 모두 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="6c0f3f70b94c0e683794c748069be9306f3ff862" translate="yes" xml:space="preserve">
          <source>These expressions are all undefined:</source>
          <target state="translated">이 표현식은 모두 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49e143bed893ac3c1f966d9961175fea9f0097a4" translate="yes" xml:space="preserve">
          <source>This is an important distinction because the &lt;em&gt;comma operator&lt;/em&gt; does introduce a &lt;em&gt;sequence point&lt;/em&gt; between the evaluation of their operands, which makes the following legal:</source>
          <target state="translated">&lt;em&gt;쉼표 연산자&lt;/em&gt; 가 피연산자 평가 사이에 &lt;em&gt;시퀀스 포인트&lt;/em&gt; 를 도입하여 다음을 합법화하기 때문에 이는 중요한 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="a7eadbdf6cf106addacc1280459303a5771a264b" translate="yes" xml:space="preserve">
          <source>This is what I get on my machine, together with what I think is going on:</source>
          <target state="translated">이것이 내가 생각하는 것과 함께 내 컴퓨터에 얻는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d2348ba3f2dbca0683d0f6e3794c5adfe460c3d4" translate="yes" xml:space="preserve">
          <source>This means, &quot;add 1 to i, and assign the result back to i&quot;.  So if we construct a hodgepodge of the two, by writing</source>
          <target state="translated">이는 &quot;i에 1을 추가하고 결과를 i에 다시 할당&quot;을 의미합니다. 따라서 우리가이 두 가지를 만들어서</target>
        </trans-unit>
        <trans-unit id="caa5ad4107546a13712ed7838fa8b42e3b4db460" translate="yes" xml:space="preserve">
          <source>This paragraph renders undefined statement expressions such as</source>
          <target state="translated">이 단락은 다음과 같은 정의되지 않은 명령문 표현식을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="46439927e625ecb8b33bd34e881c3e524a95e1a1" translate="yes" xml:space="preserve">
          <source>This post: &lt;a href=&quot;https://stackoverflow.com/a/4105123/1275169&quot;&gt;Undefined, unspecified and implementation-defined behavior&lt;/a&gt; is also relevant.</source>
          <target state="translated">이 게시물 : &lt;a href=&quot;https://stackoverflow.com/a/4105123/1275169&quot;&gt;정의되지 않은 지정되지 않은 구현 정의 동작&lt;/a&gt; 도 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a26b12aa6128b35356b8372db3a8257837f5a20c" translate="yes" xml:space="preserve">
          <source>This too has &lt;em&gt;unspecified behaviour&lt;/em&gt; because the order of evaluation of &lt;code&gt;++x&lt;/code&gt; and &lt;code&gt;y++&lt;/code&gt; is unspecified. But it's perfectly legal and valid statement. There's &lt;em&gt;no&lt;/em&gt; undefined behaviour in this statement. Because the modifications (&lt;code&gt;++x&lt;/code&gt; and &lt;code&gt;y++&lt;/code&gt;) are done to &lt;em&gt;distinct&lt;/em&gt; objects.</source>
          <target state="translated">&lt;code&gt;++x&lt;/code&gt; 및 &lt;code&gt;y++&lt;/code&gt; 의 평가 순서가 &lt;em&gt;지정되어 있지&lt;/em&gt; 않기 때문에 이것도 &lt;em&gt;지정되지 않은 동작을&lt;/em&gt; 합니다. 그러나 그것은 완벽하게 합법적이고 유효한 진술입니다. 이 문장 &lt;em&gt;에는&lt;/em&gt; 정의되지 않은 동작이 &lt;em&gt;없습니다&lt;/em&gt; . 객체를 &lt;em&gt;구별&lt;/em&gt; 하기 위해 수정 ( &lt;code&gt;++x&lt;/code&gt; 및 &lt;code&gt;y++&lt;/code&gt; )이 수행되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b8ab8d4d3501671ee98b37c6896a7b30e0cb64eb" translate="yes" xml:space="preserve">
          <source>Use of an unspecified value, or other behavior where this
  International Standard provides two or more possibilities and imposes
  no further requirements on which is chosen in any instance.</source>
          <target state="translated">지정되지 않은 값 또는이 국제 표준이 둘 이상의 가능성을 제공하고 어떤 경우에도 선택되는 추가 요구 사항을 부과하지 않는 기타 행동의 사용.</target>
        </trans-unit>
        <trans-unit id="98e776ec343640985fafdd3ff42f5002ea7be9bc" translate="yes" xml:space="preserve">
          <source>We also have &lt;em&gt;undefined behavior&lt;/em&gt; here as well since the program is modifying variables(&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, etc..) more than once between &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;sequence points&lt;/a&gt;. From draft standard section &lt;code&gt;6.5&lt;/code&gt; paragraph &lt;em&gt;2&lt;/em&gt;(&lt;em&gt;emphasis mine&lt;/em&gt;):</source>
          <target state="translated">프로그램이 &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;시퀀스 포인트&lt;/a&gt; 사이에서 변수 ( &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; 등)를 두 번 이상 수정하기 때문에 여기에도 &lt;em&gt;정의되지 않은 동작이&lt;/em&gt; 있습니다. 표준 섹션 &lt;code&gt;6.5&lt;/code&gt; 단락 &lt;em&gt;2&lt;/em&gt; ( &lt;em&gt;강조 광산&lt;/em&gt; )에서 :</target>
        </trans-unit>
        <trans-unit id="d79ca31d503a8992b19d27638ae0bfeab48383d7" translate="yes" xml:space="preserve">
          <source>We used to spend countless hours on comp.lang.c discussing expressions like these and &lt;em&gt;why&lt;/em&gt; they're undefined.  Two of my longer answers, that try to really explain why, are archived on the web:</source>
          <target state="translated">우리는 comp.lang.c에서 이와 같은 표현과 &lt;em&gt;왜&lt;/em&gt; 정의되지 &lt;em&gt;않은지에&lt;/em&gt; 대해 많은 시간을 보냈습니다. 이유를 설명하려는 더 긴 두 가지 답변이 웹에 보관됩니다.</target>
        </trans-unit>
        <trans-unit id="97f59d311b736479c8957dda049a60daf7519890" translate="yes" xml:space="preserve">
          <source>What about this crazy expression?</source>
          <target state="translated">이 미친 표현은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="5a6d959c80919c189d983a0e8445a43a2b8edc68" translate="yes" xml:space="preserve">
          <source>What makes an expression undefined?  Are expressions involving &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; always undefined?  Of course not: these are useful operators, and if you use them properly, they're perfectly well-defined.</source>
          <target state="translated">식이 정의되지 않은 이유는 무엇입니까? &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 와 관련된 표현식이 항상 정의되어 있지 않습니까? 물론 아닙니다 : 이들은 유용한 연산자이며 올바르게 사용하면 완벽하게 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8dbebc0ad8d152d87c6b7a7b4477c7a754623049" translate="yes" xml:space="preserve">
          <source>What renders the following statement</source>
          <target state="translated">다음 진술을하는 것</target>
        </trans-unit>
        <trans-unit id="620723367c219dcaa50fd9cc14c519910605f4ac" translate="yes" xml:space="preserve">
          <source>Where several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators.</source>
          <target state="translated">여러 연산자가 함께 나타나는 경우 우선 순위가 같고 연관성에 따라 평가됩니다. 표의 연산자는 접미사 연산자로 시작하는 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="993c059bb0f33b91c747d106d7f878acf62fa429" translate="yes" xml:space="preserve">
          <source>While I don't think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, &lt;code&gt;i&lt;/code&gt; would get incremented by two) and it's not totally inconceivable that some future processor might provide a feature something like that.</source>
          <target state="translated">프로세서가 그러한 일을 효율적으로 수행 할 수 있도록 하드웨어를 지원한다고 생각하지는 않지만 그러한 행동으로 인해 멀티 스레드 코드를 더 쉽게 만드는 상황을 쉽게 상상할 수 있습니다 (예 : 두 개의 스레드가 위의 작업을 수행하려고하면 보장 할 것입니다) 동시에 두 개씩 증가합니다) 그리고 미래의 일부 프로세서가 이와 같은 기능을 제공 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="654bf105e22463883f4cc71645479f80ad720b8c" translate="yes" xml:space="preserve">
          <source>While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement &quot;i++&quot; with the sequence:</source>
          <target state="translated">컴파일러와 프로세서가 실제로 그렇게 할 가능성은 낮지 만 C 표준에 따라 컴파일러가 시퀀스로 &quot;i ++&quot;를 구현하는 것이 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="c4fc6b93cb14a30318f792c85ba1d6fcdb5593c0" translate="yes" xml:space="preserve">
          <source>While the &lt;strong&gt;syntax&lt;/strong&gt; of the expressions like &lt;code&gt;a = a++&lt;/code&gt; or &lt;code&gt;a++ + a++&lt;/code&gt; is legal, the &lt;strong&gt;behaviour&lt;/strong&gt; of these constructs is &lt;strong&gt;undefined&lt;/strong&gt; because a &lt;strong&gt;&lt;em&gt;shall&lt;/em&gt;&lt;/strong&gt; in C standard is not obeyed. &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2&quot;&gt;C99 6.5p2&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;a = a++&lt;/code&gt; 또는 &lt;code&gt;a++ + a++&lt;/code&gt; 와 같은 표현식의 &lt;strong&gt;구문&lt;/strong&gt; 은 합법적이지만 C 표준의 &lt;strong&gt;&lt;em&gt;shall&lt;/em&gt;&lt;/strong&gt; 이 준수 &lt;strong&gt;되지&lt;/strong&gt; 않기 때문에 이러한 구문의 &lt;strong&gt;동작&lt;/strong&gt; 은 &lt;strong&gt;정의되지&lt;/strong&gt; 않습니다. &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2&quot;&gt;C99 6.5p2&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fa7f3099f3e8212233573bcc53199fbb0f2d7dd7" translate="yes" xml:space="preserve">
          <source>While this is also &lt;a href=&quot;https://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;&lt;em&gt;undefined behaviour&lt;/em&gt;&lt;/a&gt; as stated already, there are subtle differences when &lt;code&gt;printf()&lt;/code&gt; is involved when comparing to a statement such as:</source>
          <target state="translated">이것은 이미 언급 한 바와 같이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;&lt;em&gt;정의되지 않은 동작&lt;/em&gt;&lt;/a&gt; 이지만, &lt;code&gt;printf()&lt;/code&gt; 가 다음과 같은 명령문과 비교할 때 미묘한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bbd03ec9871c64e9c4395ce30be95e323064e65" translate="yes" xml:space="preserve">
          <source>Why are these constructs using pre and post-increment undefined behavior</source>
          <target state="translated">사전 및 사후 증가 정의되지 않은 동작을 사용하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e9fa82e28ce977203f961d7a07d8a2d4b273fe03" translate="yes" xml:space="preserve">
          <source>Why doesn't the Standard define what these do?</source>
          <target state="translated">왜 표준이 이것들을 무엇으로 정의하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="5d24bed798cadce6efcf21855671e0a3bd9b02cf" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#note73&quot;&gt;footnote 73&lt;/a&gt; further clarifying that</source>
          <target state="translated">&lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#note73&quot;&gt;각주 73&lt;/a&gt; 더 명확하게</target>
        </trans-unit>
        <trans-unit id="29f531dd817ce6695c7df2a686b84fe974c07a2d" translate="yes" xml:space="preserve">
          <source>You can detect such errors in a program by for example using a recent version of GCC with &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-Werror&lt;/code&gt;, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:</source>
          <target state="translated">예를 들어 &lt;code&gt;-Wall&lt;/code&gt; 및 &lt;code&gt;-Werror&lt;/code&gt; 와 함께 최신 버전의 GCC를 사용하여 프로그램에서 이러한 오류를 감지하면 GCC가 프로그램 컴파일을 거부합니다. 다음은 gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005의 출력입니다.</target>
        </trans-unit>
        <trans-unit id="1e657852dfeb599a907d4ece570953de09d22b6a" translate="yes" xml:space="preserve">
          <source>You might imagine that precedence or associativity or left-to-right evaluation tells you what order things happen in, but they do not.  You may not believe me, but please take my word for it, and I'll say it again: precedence and associativity do not determine every aspect of the evaluation order of an expression in C.  In particular, if within one expression there are multiple different spots where we try to assign a new value to something like &lt;code&gt;x&lt;/code&gt;, precedence and associativity do &lt;em&gt;not&lt;/em&gt; tell us which of those attempts happens first, or last, or anything.</source>
          <target state="translated">우선 순위 또는 연관성 또는 왼쪽에서 오른쪽으로 평가하면 어떤 순서로 발생하는지 알 수 있지만 그렇지 않습니다. 당신은 저를 믿지 않을 수도 있지만, 제 말을 들어주세요. 다시 말하겠습니다. 우선 순위와 연관성은 C에서 표현식의 평가 순서의 모든 측면을 결정하지는 않습니다. 특히, 하나의 표현식 내에 여러 개가있는 경우 &lt;code&gt;x&lt;/code&gt; , 우선 순위 및 연관성에 새로운 값을 할당하려고하는 다른 지점은 이러한 시도 중 어느 것이 처음 또는 마지막으로 발생하는지 또는 다른 것을 알려주지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="16d53ac224d610d74a2b157b47df1e799121e503" translate="yes" xml:space="preserve">
          <source>Your most interesting-looking example, the one with</source>
          <target state="translated">가장 흥미로운 예,</target>
        </trans-unit>
        <trans-unit id="6b59ba518c972237e1ab9cf07eace07655c0ba1c" translate="yes" xml:space="preserve">
          <source>Your question was probably not, &quot;Why are these constructs undefined behavior in C?&quot;.  Your question was probably, &quot;Why did this code (using &lt;code&gt;++&lt;/code&gt;) not give me the value I expected?&quot;, and someone marked your question as a duplicate, and sent you here.</source>
          <target state="translated">귀하의 질문은 아마도 &quot;왜 이러한 구성이 C에서 정의되지 않은 동작입니까?&quot; 귀하의 질문은 아마도 &quot;이 코드 ( &lt;code&gt;++&lt;/code&gt; 사용)가 나에게 기대 한 값을주지 않은 이유는 무엇입니까?&quot;였을 것이고 누군가 누군가 귀하의 질문을 중복으로 표시하고 여기로 보냈습니다.</target>
        </trans-unit>
        <trans-unit id="3ab35cf324056d865ffa5f8f1bbb4c026674124f" translate="yes" xml:space="preserve">
          <source>according to &lt;a href=&quot;http://helpcentreonline.com/article/operator_console_gcc.pdf&quot;&gt;GCC C++: Operators&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://helpcentreonline.com/article/operator_console_gcc.pdf&quot;&gt;GCC C ++&lt;/a&gt; 에 따르면 : 연산자</target>
        </trans-unit>
        <trans-unit id="01fa57d8ce0823fdd6a263ffa07b47583f555303" translate="yes" xml:space="preserve">
          <source>and 6.5.16 Assignment operators, &amp;sect;4:</source>
          <target state="translated">6.5.16 할당 연산자, &amp;sect;4 :</target>
        </trans-unit>
        <trans-unit id="ce12358f2d210e399abcf4e1e573533bddc18601" translate="yes" xml:space="preserve">
          <source>and &lt;em&gt;undefined behavior&lt;/em&gt; is defined in section &lt;code&gt;3.4.3&lt;/code&gt; as:</source>
          <target state="translated">&lt;em&gt;정의되지 않은 동작&lt;/em&gt; 은 섹션 &lt;code&gt;3.4.3&lt;/code&gt; 에서 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2b052e36279e4939f15bff3095a49e8060b7a8a2" translate="yes" xml:space="preserve">
          <source>and notes that:</source>
          <target state="translated">그리고 메모 :</target>
        </trans-unit>
        <trans-unit id="8e6dfcce434b9d0dda3cc6631136727fcce69183" translate="yes" xml:space="preserve">
          <source>and so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.</source>
          <target state="translated">그 규칙에 위배됩니다. 이 표준은 또한 행동이 정의되지 않았으며 지정되지 않았다고 말합니다. 일부 컴파일러는이를 감지하여 일부 결과를 생성하지만 이는 표준에 맞지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b3734024b41bb3f0676c1c39247d799a3758dbe" translate="yes" xml:space="preserve">
          <source>as &lt;em&gt;undefined behaviour&lt;/em&gt; is the fact that these two expressions modify the &lt;em&gt;same&lt;/em&gt; object &lt;code&gt;i&lt;/code&gt; without an intervening &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;em&gt;sequence point&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;정의되지 않은 동작&lt;/em&gt; 은이 두 표현식이 중간 &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;em&gt;시퀀스 포인트&lt;/em&gt;&lt;/a&gt; 없이 &lt;em&gt;동일한&lt;/em&gt; 객체 &lt;code&gt;i&lt;/code&gt; 를 수정한다는 사실입니다.</target>
        </trans-unit>
        <trans-unit id="9059279af0d58499da7f4421366ab030ce5ce24f" translate="yes" xml:space="preserve">
          <source>as Visual Studio documentation states at &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx&quot;&gt;Precedence and Order of Evaluation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx&quot;&gt;우선 순위 및 평가 순서에&lt;/a&gt; Visual Studio 설명서가 명시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a66c60f4b925de32bda6e418bb9241ab007d19d2" translate="yes" xml:space="preserve">
          <source>because both all these forms to interpret the code &lt;code&gt;i=i++&lt;/code&gt; are valid and because both generate different answers, the behavior is undefined.</source>
          <target state="translated">코드 &lt;code&gt;i=i++&lt;/code&gt; 를 해석하는 이러한 모든 형식이 유효하고 둘 다 다른 응답을 생성하기 때문에 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ca0589f3b903598d63dbbb1bd82e05ec06430e2" translate="yes" xml:space="preserve">
          <source>behavior, upon use of a nonportable or erroneous program construct or of erroneous data,
  for which this International Standard imposes no requirements</source>
          <target state="translated">휴대 할 수 없거나 잘못된 프로그램 구조 또는 잘못된 데이터를 사용하는 경우,이 표준에 요구 사항이없는 행동</target>
        </trans-unit>
        <trans-unit id="0adcd950d55decdb39e49fe9bd1350b81dcb1ba8" translate="yes" xml:space="preserve">
          <source>can be interpreted as</source>
          <target state="translated">로 해석 될 수있다</target>
        </trans-unit>
        <trans-unit id="79800df6fd474ca1c30984dcd3f7b04c26a5c2ea" translate="yes" xml:space="preserve">
          <source>has &lt;em&gt;undefined behaviour&lt;/em&gt; because &lt;strong&gt;there is no sequence point between the evaluations of &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; in function arguments&lt;/strong&gt;, and the value of &lt;code&gt;i&lt;/code&gt; is therefore modified twice, by both &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt;, between the previous and the next sequence point.</source>
          <target state="translated">&lt;strong&gt;함수 인수에서 &lt;code&gt;i++&lt;/code&gt; 와 &lt;code&gt;++i&lt;/code&gt; 의 평가 사이에 시퀀스 포인트가 없으므로 i&lt;/strong&gt; 의 값이 이전과 다음 시퀀스 포인트 사이에서 &lt;code&gt;i++&lt;/code&gt; 와 &lt;code&gt;++i&lt;/code&gt; 에 의해 두 번 수정되므로 &lt;em&gt;정의되지 않은 동작&lt;/em&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e0c4a46af008bea7bd274279fd48605405877be" translate="yes" xml:space="preserve">
          <source>is a text-book example of undefined behavior (see Wikipedia's entry on &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;sequence points&lt;/a&gt;).</source>
          <target state="translated">정의되지 않은 동작의 교과서 예제입니다 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;시퀀스 포인트&lt;/a&gt; 에 대한 Wikipedia의 항목 참조).</target>
        </trans-unit>
        <trans-unit id="d6afca40014c337d879e759974a1ca723b9ba3d5" translate="yes" xml:space="preserve">
          <source>is well-defined, and will increment &lt;code&gt;i&lt;/code&gt; by one, yielding the old value, discard that value; then at comma operator, settle the side effects; and then increment &lt;code&gt;i&lt;/code&gt; by one, and the resulting value becomes the value of the expression - i.e. this is just a contrived way to write &lt;code&gt;j = (i += 2)&lt;/code&gt; which is yet again a &quot;clever&quot; way to write</source>
          <target state="translated">잘 정의되어 있으며 &lt;code&gt;i&lt;/code&gt; 를 1 씩 증가시켜 이전 값을 산출하고 해당 값을 버립니다. 그런 다음 쉼표 연산자에서 부작용을 해결하십시오. 그리고 &lt;code&gt;i&lt;/code&gt; 를 1 씩 증가 시키면 결과 값은 표현식의 값이됩니다. 즉 이것은 &lt;code&gt;j = (i += 2)&lt;/code&gt; 하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="fbe75bf13ae46462a9f46964973c095ec8c518fa" translate="yes" xml:space="preserve">
          <source>it cites the following code examples as being undefined:</source>
          <target state="translated">다음 코드 예제는 정의되지 않은 것으로 인용합니다.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="64c3747b998e7ea9d774b1fd5a1400f0310b6691" translate="yes" xml:space="preserve">
          <source>or as</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="e279a190f96b43bb236230286cb53b2703d35e62" translate="yes" xml:space="preserve">
          <source>or similar variants.</source>
          <target state="translated">또는 유사한 변형.</target>
        </trans-unit>
        <trans-unit id="9702e27e29837c876ff819f4fdde0b4010e5e3ca" translate="yes" xml:space="preserve">
          <source>resulting in two different results &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; which depends on the sequence of side effects by assignment and &lt;code&gt;++&lt;/code&gt; and hence invokes UB.</source>
          <target state="translated">할당과 &lt;code&gt;++&lt;/code&gt; 에 의한 부작용 순서에 따라 두 가지 다른 결과 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;2&lt;/code&gt; 가되므로 UB를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="36547a3fb0d1b37ceaa06275e8ecd615d0e3cca7" translate="yes" xml:space="preserve">
          <source>standard says that:</source>
          <target state="translated">표준은 말합니다 :</target>
        </trans-unit>
        <trans-unit id="99eb919d06fc8a202d8b26c45f6410f8dd8cfde9" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;http://en.cppreference.com/w/c/language/eval_order&quot;&gt;&lt;em&gt;order of evaluation&lt;/em&gt;&lt;/a&gt; of arguments in &lt;code&gt;printf()&lt;/code&gt; is &lt;a href=&quot;https://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/a&gt;. That means, expressions &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; could be evaluated in any order. &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html&quot;&gt;C11 standard&lt;/a&gt; has some relevant descriptions on this:</source>
          <target state="translated">&lt;code&gt;printf()&lt;/code&gt; 의 인수 &lt;a href=&quot;http://en.cppreference.com/w/c/language/eval_order&quot;&gt;&lt;em&gt;평가 순서&lt;/em&gt;&lt;/a&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;&lt;em&gt;지정되어 있지 않습니다&lt;/em&gt;&lt;/a&gt; . 즉, 식 &lt;code&gt;i++&lt;/code&gt; 및 &lt;code&gt;++i&lt;/code&gt; 는 임의의 순서로 평가 될 수 있습니다. &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html&quot;&gt;C11 표준&lt;/a&gt; 에는 다음과 같은 관련 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="31da7bc042367a36b94b0573d521d30381601aa7" translate="yes" xml:space="preserve">
          <source>the equivalent code in defined behavior C++ as   GCC understands:</source>
          <target state="translated">GCC가 이해하는 정의 된 동작 C ++의 해당 코드 :</target>
        </trans-unit>
        <trans-unit id="b66a1df4b25aa4baacf0d81920e5b8592ea38a0a" translate="yes" xml:space="preserve">
          <source>the question is, before calling &lt;code&gt;printf&lt;/code&gt;, does the compiler compute the value of &lt;code&gt;x&lt;/code&gt; first, or &lt;code&gt;x++&lt;/code&gt;, or maybe &lt;code&gt;++x&lt;/code&gt;?  But it turns out &lt;em&gt;we don't know&lt;/em&gt;.  There's no rule in C which says that the arguments to a function get evaluated left-to-right, or right-to-left, or in some other order.  So we can't say whether the compiler will do &lt;code&gt;x&lt;/code&gt; first, then &lt;code&gt;++x&lt;/code&gt;, then &lt;code&gt;x++&lt;/code&gt;, or &lt;code&gt;x++&lt;/code&gt; then &lt;code&gt;++x&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt;, or some other order.  But the order clearly matters, because depending on which order the compiler uses, we'll clearly get different results printed by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">문제는 &lt;code&gt;printf&lt;/code&gt; 를 호출하기 전에 컴파일러가 &lt;code&gt;x&lt;/code&gt; 의 값을 먼저 계산합니까, &lt;code&gt;x++&lt;/code&gt; 또는 &lt;code&gt;++x&lt;/code&gt; 입니까? 그러나 &lt;em&gt;우리는 모른다&lt;/em&gt; . C에는 함수에 대한 인수가 왼쪽에서 오른쪽으로, 오른쪽에서 왼쪽으로 또는 다른 순서로 평가된다는 규칙이 없습니다. 따라서 컴파일러가 &lt;code&gt;x&lt;/code&gt; 를 먼저 수행 한 다음 &lt;code&gt;++x&lt;/code&gt; , &lt;code&gt;x++&lt;/code&gt; 또는 &lt;code&gt;x++&lt;/code&gt; 를 수행하고 &lt;code&gt;++x&lt;/code&gt; 다음에 &lt;code&gt;x&lt;/code&gt; 또는 다른 순서를 수행할지 여부를 알 수 없습니다. 그러나 순서는 분명히 중요합니다. 컴파일러가 사용하는 순서에 따라 &lt;code&gt;printf&lt;/code&gt; 에 의해 다른 결과가 명확하게 인쇄되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b145a546526acfd63eaed2096d7c03ce76dc170c" translate="yes" xml:space="preserve">
          <source>there are three attempts to modify `x.</source>
          <target state="translated">`x를 수정하려는 세 가지 시도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe89eef81018d9dbe7f6e45a8c1cb937a477767e" translate="yes" xml:space="preserve">
          <source>use of an unspecified value, or other behavior where this International Standard provides
  two or more possibilities and imposes no further requirements on which is chosen in any
  instance</source>
          <target state="translated">불특정 한 가치의 사용, 또는이 국제 표준이 둘 이상의 가능성을 제공하고 어떤 경우에도 선택되는 추가 요구 사항을 부과하지 않는 기타 행동</target>
        </trans-unit>
        <trans-unit id="be6fb6ef9ffc50a3a93ef857ea42b104c0acfc49" translate="yes" xml:space="preserve">
          <source>we both use the value of &lt;code&gt;x&lt;/code&gt;, and modify it.</source>
          <target state="translated">우리는 &lt;code&gt;x&lt;/code&gt; 값을 사용하고 수정합니다.</target>
        </trans-unit>
        <trans-unit id="26c3baa763591157c51a290b7c8be38622c3e920" translate="yes" xml:space="preserve">
          <source>we do not know whether &lt;code&gt;i++&lt;/code&gt; or &lt;code&gt;++i&lt;/code&gt; will be evaluated first. This is mainly to give the compiler &lt;a href=&quot;https://stackoverflow.com/a/12540468/1708801&quot;&gt;better options for optimization&lt;/a&gt;.</source>
          <target state="translated">우리는 &lt;code&gt;i++&lt;/code&gt; 또는 &lt;code&gt;++i&lt;/code&gt; 가 먼저 평가되는지 알 수 없습니다. 이것은 주로 컴파일러에게 &lt;a href=&quot;https://stackoverflow.com/a/12540468/1708801&quot;&gt;최적화를위한 더 나은 옵션을 제공하기위한 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb233158d14cbec62b14e57272c4bcc2a0ceed2f" translate="yes" xml:space="preserve">
          <source>what we're really saying is &quot;add 1 to i, and assign the result back to i, and assign the result back to i&quot;.  We're confused, so it doesn't bother me too much if the compiler gets confused, too.</source>
          <target state="translated">우리가 실제로 말하는 것은 &quot;i에 1을 더하고 결과를 다시 i에 할당하고 결과를 다시 i에 할당&quot;입니다. 우리는 혼란스러워서 컴파일러가 혼란스러워도 너무 귀찮게하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e22cbfb6c2ae366e16c7c6a3fd5d852b0ea277ba" translate="yes" xml:space="preserve">
          <source>which prints 7... the OP expected it to print 6.</source>
          <target state="translated">7을 인쇄합니다. OP는 6을 인쇄 할 것으로 예상했습니다.</target>
        </trans-unit>
        <trans-unit id="0976677eed8a072a2d2ba8c68e6d46be04d02d10" translate="yes" xml:space="preserve">
          <source>while allowing</source>
          <target state="translated">허용하면서</target>
        </trans-unit>
        <trans-unit id="7144af9b44794b287d95deb872a3d9bc96df4726" translate="yes" xml:space="preserve">
          <source>will not be a problem. But it invokes &lt;em&gt;undefined behaviour&lt;/em&gt; because the &lt;em&gt;comma&lt;/em&gt; here is a &lt;em&gt;separator&lt;/em&gt;.</source>
          <target state="translated">문제가되지 않습니다. 그러나 여기서 &lt;em&gt;쉼표&lt;/em&gt; 는 &lt;em&gt;구분 기호&lt;/em&gt; 이므로 &lt;em&gt;정의되지 않은 동작을&lt;/em&gt; 호출합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
