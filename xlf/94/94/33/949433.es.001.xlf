<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/949433">
    <body>
      <group id="949433">
        <trans-unit id="279b28cc873ec1c827682711f3c25217acbae1fe" translate="yes" xml:space="preserve">
          <source>(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)</source>
          <target state="translated">(Yo...supongo que la instrucción 0x00000014 era algún tipo de optimización del compilador?)</target>
        </trans-unit>
        <trans-unit id="bfd7cdbaee11e47493e6a76cbda42efed8c089b4" translate="yes" xml:space="preserve">
          <source>6.5 Expressions:</source>
          <target state="translated">6.5 Expresiones:</target>
        </trans-unit>
        <trans-unit id="88c039b7efd50e8beeced317de42cd545759369b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/17935062/2455888&quot;&gt;An important point&lt;/a&gt; regarding Postfix &lt;code&gt;++&lt;/code&gt; operator is that:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/17935062/2455888&quot;&gt;Un punto importante con&lt;/a&gt; respecto al operador Postfix &lt;code&gt;++&lt;/code&gt; es que:</target>
        </trans-unit>
        <trans-unit id="a38d1a7059ef11574a41d6295e5c3ee36deea981" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This&lt;/em&gt; answer tries to answer that question: why did your code not give you the answer you expected, and how can you learn to recognize (and avoid) expressions that will not work as expected.</source>
          <target state="translated">&lt;em&gt;Esta&lt;/em&gt; respuesta intenta responder a esa pregunta: por qu&amp;eacute; su c&amp;oacute;digo no le dio la respuesta que esperaba y c&amp;oacute;mo puede aprender a reconocer (y evitar) expresiones que no funcionar&amp;aacute;n como se esperaba.</target>
        </trans-unit>
        <trans-unit id="cede1476cbfbaa036e6ccf5fced4facf59ce7d1f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unspecified behavior&lt;/em&gt; is defined in the &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;draft c99 standard&lt;/a&gt; in section &lt;code&gt;3.4.4&lt;/code&gt; as:</source>
          <target state="translated">&lt;em&gt;El comportamiento no especificado&lt;/em&gt; se define en el &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;borrador del est&amp;aacute;ndar c99&lt;/a&gt; en la secci&amp;oacute;n &lt;code&gt;3.4.4&lt;/code&gt; como:</target>
        </trans-unit>
        <trans-unit id="44b34df450374fa00c3d7262a922fe635b3fb310" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.4, unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.4.4, comportamiento no especificado&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b687a63b4511aca324bdbbc7328acb8be568d38d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Annex J, unspecified behaviours&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Anexo J, comportamientos no especificados&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad5e622d7c3f20a8ca11dc4608457c04512caa38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Between the previous and next sequence point an object shall have its stored value
  modified at most once&lt;/strong&gt; by the evaluation of an expression. Furthermore, &lt;strong&gt;the prior value
  shall be read only to determine the value to be stored&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Entre el punto de secuencia anterior y el siguiente, un objeto tendr&amp;aacute; su valor almacenado modificado como m&amp;aacute;ximo una vez&lt;/strong&gt; por la evaluaci&amp;oacute;n de una expresi&amp;oacute;n. Adem&amp;aacute;s, &lt;strong&gt;el valor anterior se leer&amp;aacute; solo para determinar el valor que se almacenar&amp;aacute;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="14c69e77d03fc3b5c073134689c8f8428458e027" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If a side effect on a scalar object is unsequenced relative to&lt;/strong&gt; either &lt;strong&gt;a different side effect on the same scalar object&lt;/strong&gt; or a value computation using the value of the same scalar object, &lt;strong&gt;the behavior is undefined&lt;/strong&gt;. [...]</source>
          <target state="translated">&lt;strong&gt;Si un efecto secundario en un objeto escalar no est&amp;aacute; secuenciado en relaci&amp;oacute;n con&lt;/strong&gt; &lt;strong&gt;un efecto secundario diferente en el mismo objeto escalar&lt;/strong&gt; o un c&amp;aacute;lculo de valor utilizando el valor del mismo objeto escalar, &lt;strong&gt;el comportamiento es indefinido&lt;/strong&gt; . [...]</target>
        </trans-unit>
        <trans-unit id="05664d00aa9e447fc1d30a0bcf56db0f328bd362" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequence Point:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Punto de secuencia:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9f49591f9696f388f781605342ac7b9ab2f5c5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequenced:&lt;/strong&gt; (5.1.2.3)</source>
          <target state="translated">&lt;strong&gt;Secuenciado:&lt;/strong&gt; (5.1.2.3)</target>
        </trans-unit>
        <trans-unit id="64839962132bef2e8207e819c9d365f8efa46d5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unsequenced:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Unsequenced:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b35e23674ba2c887d039ae8bc54926f2a2c920fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;just because the &lt;code&gt;++&lt;/code&gt; comes after the variable does not mean that the increment happens late&lt;/strong&gt;. The increment can happen as early as the compiler likes &lt;em&gt;as long as the compiler ensures that the original value is used&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;el hecho de que &lt;code&gt;++&lt;/code&gt; aparezca despu&amp;eacute;s de la variable no significa que el incremento ocurra tarde&lt;/strong&gt; . El incremento puede ocurrir tan pronto como le guste al compilador &lt;em&gt;, siempre y cuando el compilador se asegure de que se use el valor original&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f47bde17809faf3152a9c49b5ed547c7193a8237" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;side effects&lt;/strong&gt;, which are modifications of objects.</source>
          <target state="translated">&lt;strong&gt;efectos secundarios&lt;/strong&gt; , que son modificaciones de objetos.</target>
        </trans-unit>
        <trans-unit id="91ed0c6955be889d3390ace27c7202751c8e2aa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;value computations&lt;/strong&gt;, which work out the result of an expression; and</source>
          <target state="translated">&lt;strong&gt;c&amp;aacute;lculos de valor&lt;/strong&gt; , que resuelven el resultado de una expresi&amp;oacute;n; y</target>
        </trans-unit>
        <trans-unit id="98e847c09ebd5e2f7d780741347784a05d1e1490" translate="yes" xml:space="preserve">
          <source>A good explanation about what happens in this kind of computation is provided in the document &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf&quot;&gt;n1188&lt;/a&gt; from &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/&quot;&gt;the ISO W14 site&lt;/a&gt;.</source>
          <target state="translated">Se proporciona una buena explicaci&amp;oacute;n sobre lo que sucede en este tipo de c&amp;aacute;lculo en el documento &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf&quot;&gt;n1188&lt;/a&gt; del &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/&quot;&gt;sitio ISO W14&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e34012ee0723c9314bf3543db136c35ba444eab" translate="yes" xml:space="preserve">
          <source>After the actions associated with each formatted input/output function conversion specifier (7.21.6, 7.29.2).</source>
          <target state="translated">Después de las acciones asociadas a cada especificador de conversión de la función de inputoutput formateada (7.21.6,7.29.2).</target>
        </trans-unit>
        <trans-unit id="34ab97668a5cbf8c450a7a5d95e5097551fcfcaf" translate="yes" xml:space="preserve">
          <source>And the last question is, how can you tell which expressions are well-defined, and which expressions are undefined?</source>
          <target state="translated">Y la última pregunta es,¿cómo se puede saber qué expresiones están bien definidas y cuáles no?</target>
        </trans-unit>
        <trans-unit id="bae6a155cfc89c64a4a764fc6787a9b2227f41ac" translate="yes" xml:space="preserve">
          <source>Another detail is that the &lt;em&gt;comma&lt;/em&gt; involved in the printf() call is a &lt;em&gt;separator&lt;/em&gt;, not the &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma_operator&quot;&gt;&lt;em&gt;comma operator&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Otro detalle es que la &lt;em&gt;coma&lt;/em&gt; involucrada en la llamada printf () es un &lt;em&gt;separador&lt;/em&gt; , no el &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma_operator&quot;&gt;&lt;em&gt;operador de coma&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03d05f648939561cc5196d6a1b460c6d6f3ae2fc" translate="yes" xml:space="preserve">
          <source>Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, &lt;em&gt;what are they supposed to mean?&lt;/em&gt;&lt;em&gt;What was the programmer trying to do?&lt;/em&gt;</source>
          <target state="translated">Otra forma de responder a esto, en lugar de atascarse en detalles arcanos de puntos de secuencia y comportamiento indefinido, es simplemente preguntar, &lt;em&gt;&amp;iquest;qu&amp;eacute; se supone que significan?&lt;/em&gt; &lt;em&gt;&amp;iquest;Qu&amp;eacute; intentaba hacer el programador?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="454a87205b7cae96f48455860ea1befd4d1fe414" translate="yes" xml:space="preserve">
          <source>As I said earlier, the undefined expressions are the ones where there's too much going at once, where you can't be sure what order things happen in, and where the order matters:</source>
          <target state="translated">Como dije antes,las expresiones indefinidas son aquellas en las que hay demasiadas cosas a la vez,en las que no se puede estar seguro del orden en que suceden las cosas,y en las que el orden importa:</target>
        </trans-unit>
        <trans-unit id="81111bf67780917ba78bc4f0f400157e26a8fb24" translate="yes" xml:space="preserve">
          <source>As an example of #1, in the expression</source>
          <target state="translated">Como ejemplo del número 1,en la expresión</target>
        </trans-unit>
        <trans-unit id="53c019261927786950c4738a085953640d98c525" translate="yes" xml:space="preserve">
          <source>As an example of #2, in the expression</source>
          <target state="translated">Como ejemplo del número 2,en la expresión</target>
        </trans-unit>
        <trans-unit id="55b849835da5250ac9a738c42f912f2f425d1886" translate="yes" xml:space="preserve">
          <source>As far as I know, the standard doesn't explicitly say &lt;em&gt;why&lt;/em&gt; the concept of undefined behavior exists. In my mind, it's simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.</source>
          <target state="translated">Hasta donde yo s&amp;eacute;, el est&amp;aacute;ndar no dice expl&amp;iacute;citamente &lt;em&gt;por qu&amp;eacute;&lt;/em&gt; existe el concepto de comportamiento indefinido. En mi opini&amp;oacute;n, es simplemente porque los dise&amp;ntilde;adores de lenguaje quer&amp;iacute;an que hubiera un margen de maniobra en la sem&amp;aacute;ntica, en lugar de exigir que todas las implementaciones manejen el desbordamiento de enteros exactamente de la misma manera, lo que probablemente impondr&amp;iacute;a serios costos de rendimiento, simplemente dejaron el comportamiento indefinido para que si escribe c&amp;oacute;digo que causa un desbordamiento de enteros, cualquier cosa puede suceder.</target>
        </trans-unit>
        <trans-unit id="d8c378a722c25ac92808308a2ac719cb4b3053ff" translate="yes" xml:space="preserve">
          <source>As you've heard by now, all of these expressions are &lt;em&gt;undefined&lt;/em&gt;, which means that the C language makes no guarantee about what they'll do.  This is a strange and surprising result, because you probably thought that any program you could write, as long as it compiled and ran, would generate a unique, well-defined output.  But in the case of undefined behavior, that's not so.</source>
          <target state="translated">Como ya ha escuchado, todas estas expresiones &lt;em&gt;no&lt;/em&gt; est&amp;aacute;n &lt;em&gt;definidas&lt;/em&gt; , lo que significa que el lenguaje C no garantiza lo que har&amp;aacute;n. Este es un resultado extra&amp;ntilde;o y sorprendente, porque probablemente pens&amp;oacute; que cualquier programa que pudiera escribir, siempre y cuando se compilara y ejecutara, generar&amp;iacute;a un resultado &amp;uacute;nico y bien definido. Pero en el caso de un comportamiento indefinido, eso no es as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="22983dcf22f5d87d51da07d6260b26d0e70bc867" translate="yes" xml:space="preserve">
          <source>Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions: an initializer that is not part of a compound literal (6.7.9); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (if or switch) (6.8.4); the controlling expression of a while or do statement (6.8.5); each of the (optional) expressions of a for statement (6.8.5.3); the (optional) expression in a return statement (6.8.6.4).</source>
          <target state="translated">Entre la evaluación de una expresión completa y la siguiente expresión completa a evaluar.Las siguientes son expresiones completas:un inicializador que no forma parte de un literal compuesto (6.7.9);la expresión en una declaración de expresión (6.8.3);la expresión controladora de una declaración de selección (si o cambio)(6.8.4);la expresión controladora de una declaración &quot;while or do&quot; (6.8.5);cada una de las expresiones (facultativas)de una declaración &quot;for&quot; (6.8.5.3);la expresión (facultativa)de una declaración &quot;return&quot; (6.8.6.4).</target>
        </trans-unit>
        <trans-unit id="040e4fe9d9fa542dc4ba06a43851d6aa5a72dd54" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the first and second operands of the following operators: logical AND &amp;amp;&amp;amp; (6.5.13); logical OR || (6.5.14); comma , (6.5.17).</source>
          <target state="translated">Entre las evaluaciones del primer y segundo operandos de los siguientes operadores: l&amp;oacute;gico AND &amp;amp;&amp;amp; (6.5.13); OR l&amp;oacute;gico || (6.5.14); coma, (6.5.17).</target>
        </trans-unit>
        <trans-unit id="4ad551d09f57149aadd870dc2cb52328b435e78b" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the first operand of the conditional ? : operator and whichever of the second and third operands is evaluated (6.5.15).</source>
          <target state="translated">Entre las evaluaciones del primer operando del operador condicional ?:y el que se evalúe del segundo y tercer operando (6.5.15).</target>
        </trans-unit>
        <trans-unit id="c5fd30fab6709015ef08a8e61b2e1f1954973f1f" translate="yes" xml:space="preserve">
          <source>Between the evaluations of the function designator and actual arguments in a function call and the actual call. (6.5.2.2).</source>
          <target state="translated">Entre las evaluaciones del designador de la función y los argumentos reales en una llamada de la función y la llamada real.(6.5.2.2).</target>
        </trans-unit>
        <trans-unit id="a81e8350af213ee569d9aa330eca2c02262e4edf" translate="yes" xml:space="preserve">
          <source>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.   Furthermore, the prior value shall be read only to determine the value to be stored.</source>
          <target state="translated">Entre el punto de secuencia anterior y el siguiente un objeto tendrá su valor almacenado modificado como máximo una vez por la evaluación de una expresión.Además,el valor anterior se leerá sólo para determinar el valor que se almacenará.</target>
        </trans-unit>
        <trans-unit id="63273c8e87c71a3a8d9d6a1d10757a35596fab39" translate="yes" xml:space="preserve">
          <source>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]</source>
          <target state="translated">Entre el punto de secuencia anterior y el siguiente un objeto tendrá su valor almacenado modificado como máximo una vez por la evaluación de una expresión.72]Además,el valor anterior se leerá sólo para determinar el valor que se almacenará [73].</target>
        </trans-unit>
        <trans-unit id="7a87c40d2167a7f023df7ecb1485eff49c8549a2" translate="yes" xml:space="preserve">
          <source>But, to your surprise, this program did &lt;em&gt;not&lt;/em&gt; help you understand -- it printed some strange, unexpected, inexplicable output, suggesting that maybe &lt;code&gt;++&lt;/code&gt; does something completely different, not at all what you thought it did.</source>
          <target state="translated">Pero, para su sorpresa, este programa no &lt;em&gt;lo&lt;/em&gt; ayud&amp;oacute; a comprender: imprimi&amp;oacute; un resultado extra&amp;ntilde;o, inesperado e inexplicable, lo que sugiere que quiz&amp;aacute;s &lt;code&gt;++&lt;/code&gt; hace algo completamente diferente, en absoluto lo que pensaba que hizo.</target>
        </trans-unit>
        <trans-unit id="47b2772f5f51e294039858c5f54b8729f2f5faff" translate="yes" xml:space="preserve">
          <source>C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can't predict the behavior when the code is run.</source>
          <target state="translated">C tiene el concepto de comportamiento indefinido,es decir,algunas construcciones del lenguaje son sintácticamente válidas pero no se puede predecir el comportamiento cuando se ejecuta el código.</target>
        </trans-unit>
        <trans-unit id="8b35348453822488b14536bba94a12260b7b744a" translate="yes" xml:space="preserve">
          <source>C, of course, has a handy shortcut:</source>
          <target state="translated">C,por supuesto,tiene un atajo práctico:</target>
        </trans-unit>
        <trans-unit id="313385540ea390474e5c604236fc46b3e7089c47" translate="yes" xml:space="preserve">
          <source>Depending on whether assignment occurs before or after the increment, different results will be produced and that's the one of the case of &lt;strong&gt;undefined behavior&lt;/strong&gt;.</source>
          <target state="translated">Dependiendo de si la asignaci&amp;oacute;n ocurre antes o despu&amp;eacute;s del incremento, se producir&amp;aacute;n resultados diferentes y ese es el caso del &lt;strong&gt;comportamiento indefinido&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2134df76c62a65d697e36a56132e1c70153997df" translate="yes" xml:space="preserve">
          <source>Doesn't operator precedence determine the order of evaluation?</source>
          <target state="translated">¿No determina la precedencia del operador el orden de la evaluación?</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="7ab87e9f1e4738df5111adf51d681da54745c555" translate="yes" xml:space="preserve">
          <source>EXAMPLE An example of unspecified behavior is the order in which the
  arguments to a function are evaluated.</source>
          <target state="translated">EJEMPLO Un ejemplo de comportamiento no especificado es el orden en que se evalúan los argumentos de una función.</target>
        </trans-unit>
        <trans-unit id="d272d8479ec26da7fb7b5e1ab650055e01f0dee7" translate="yes" xml:space="preserve">
          <source>Evaluations can be one of two things:</source>
          <target state="translated">Las evaluaciones pueden ser una de dos cosas:</target>
        </trans-unit>
        <trans-unit id="ea93a535df109ca0d906a45b2cc9253d643f49d8" translate="yes" xml:space="preserve">
          <source>For the expressions we're talking about what makes them undefined is when there's too much going on at once, when we're not sure what order things will happen in, but when the order matters to the result we get.</source>
          <target state="translated">Porque las expresiones de las que hablamos lo que las hace indefinidas es cuando ocurren demasiadas cosas a la vez,cuando no estamos seguros de en qué orden ocurrirán las cosas,pero cuando el orden importa para el resultado que obtenemos.</target>
        </trans-unit>
        <trans-unit id="57433c0a1b88252b7699f889dbc52ef5538d3c60" translate="yes" xml:space="preserve">
          <source>For those who are new to &lt;em&gt;undefined behaviour&lt;/em&gt; would benefit from reading &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&quot;&gt;What Every C Programmer Should Know About Undefined Behavior&lt;/a&gt;  to understand the concept and many other variants of undefined behaviour in C.</source>
          <target state="translated">Para aquellos que son nuevos en el &lt;em&gt;comportamiento indefinido,&lt;/em&gt; se beneficiar&amp;iacute;an de leer &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&quot;&gt;Lo que todo programador de C debe saber sobre el comportamiento indefinido&lt;/a&gt; para comprender el concepto y muchas otras variantes del comportamiento indefinido en C.</target>
        </trans-unit>
        <trans-unit id="a21b34979360402374873c62d1af6606d5786e66" translate="yes" xml:space="preserve">
          <source>Given any two evaluations &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, if &lt;code&gt;A&lt;/code&gt; is sequenced before &lt;code&gt;B&lt;/code&gt;, then the execution of &lt;code&gt;A&lt;/code&gt; shall precede the execution of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Dadas cualesquiera dos evaluaciones &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; , si &lt;code&gt;A&lt;/code&gt; se secuencia antes que &lt;code&gt;B&lt;/code&gt; , entonces la ejecuci&amp;oacute;n de &lt;code&gt;A&lt;/code&gt; preceder&amp;aacute; a la ejecuci&amp;oacute;n de &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="006ec1d5652cc2abca4a9e550b4b2c9adaa218a5" translate="yes" xml:space="preserve">
          <source>How does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).</source>
          <target state="translated">¿Cómo funciona el GCC? Evalúa las subexpresiones en un orden de izquierda a derecha para el lado derecho (RHS),luego asigna el valor al lado izquierdo (LHS).Así es exactamente como Java y C#se comportan y definen sus estándares.(Sí,el software equivalente en Java y C#tiene comportamientos definidos).Evalúa cada subexpresión una por una en la Declaración RHS en un orden de izquierda a derecha;para cada subexpresión:primero se evalúa el ++c (preincremento),luego se utiliza el valor c para la operación,luego el post incremento c++).</target>
        </trans-unit>
        <trans-unit id="2bdbd46fa92ff631f11ad5cb03611cba2db7660a" translate="yes" xml:space="preserve">
          <source>How does visual studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass.</source>
          <target state="translated">Cómo funciona el estudio visual,toma otro enfoque,evalúa todas las expresiones pre-incrementales en la primera pasada,luego usa valores de variables en las operaciones en la segunda pasada,asigna de RHS a LHS en la tercera pasada,luego en la última pasada evalúa todas las expresiones post-incrementales en una sola pasada.</target>
        </trans-unit>
        <trans-unit id="c72c73363ab17f40ba3f10293b5bd49072e48feb" translate="yes" xml:space="preserve">
          <source>However if you stick to one compiler, you will find the behavior persistent, as long as you don't add function calls or pointers, which would make the behavior more messy.</source>
          <target state="translated">Sin embargo,si te aferras a un compilador,encontrarás que el comportamiento es persistente,siempre y cuando no añadas llamadas a funciones o punteros,lo que haría que el comportamiento fuera más desordenado.</target>
        </trans-unit>
        <trans-unit id="7da8149973e9017187a301f4973c6be9158d15d5" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;,&lt;/code&gt; in function argument lists is &lt;em&gt;not&lt;/em&gt; a comma operator, and there is no sequence point between evaluations of distinct arguments; instead their evaluations are unsequenced with regard to each other; so the function call</source>
          <target state="translated">Sin embargo, la lista de argumentos en funci&amp;oacute;n &lt;em&gt;no&lt;/em&gt; es un operador de coma y no hay un punto de secuencia entre las evaluaciones de argumentos distintos; en cambio, sus evaluaciones no tienen secuencia entre s&amp;iacute;; entonces la llamada a la funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="8ff4f957f0bef850d0e13306eb783d225574c291" translate="yes" xml:space="preserve">
          <source>However, two different variables can be incremented between two sequence points.</source>
          <target state="translated">Sin embargo,dos variables diferentes pueden incrementarse entre dos puntos de secuencia.</target>
        </trans-unit>
        <trans-unit id="a4e9fd2fb6e6a52790d78e1ea1a9104776d97482" translate="yes" xml:space="preserve">
          <source>I assume you've heard the basic definition of C's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; operators by now, and how the prefix form &lt;code&gt;++x&lt;/code&gt; differs from the postfix form &lt;code&gt;x++&lt;/code&gt;.  But these operators are hard to think about, so to make sure you understood, perhaps you wrote a tiny little test program involving something like</source>
          <target state="translated">Supongo que ya ha escuchado la definici&amp;oacute;n b&amp;aacute;sica de C's &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; operadores, y c&amp;oacute;mo la forma del prefijo &lt;code&gt;++x&lt;/code&gt; difiere de la forma del postfix &lt;code&gt;x++&lt;/code&gt; . Pero es dif&amp;iacute;cil pensar en estos operadores, as&amp;iacute; que para asegurarte de que entiendes, tal vez escribiste un peque&amp;ntilde;o programa de prueba que involucra algo como</target>
        </trans-unit>
        <trans-unit id="d2b970b978a071c4f163f23f1f4e314def839a10" translate="yes" xml:space="preserve">
          <source>I explain the ideas.</source>
          <target state="translated">Explico las ideas.</target>
        </trans-unit>
        <trans-unit id="7e1cdd37254f419dc8e9ee3785767a5fcd30479d" translate="yes" xml:space="preserve">
          <source>I think the relevant parts of the C99 standard are 6.5 Expressions, &amp;sect;2</source>
          <target state="translated">Creo que las partes relevantes del est&amp;aacute;ndar C99 son 6.5 Expresiones, &amp;sect;2</target>
        </trans-unit>
        <trans-unit id="ebb30d2d2d8387aa698cfa701d3a0b2ef943f61b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is not sequenced before or after &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are unsequenced.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; no est&amp;aacute; secuenciado antes o despu&amp;eacute;s de &lt;code&gt;B&lt;/code&gt; , entonces &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; no est&amp;aacute;n secuenciados.</target>
        </trans-unit>
        <trans-unit id="2e8615005607bfaf839090f5116302468a3077a1" translate="yes" xml:space="preserve">
          <source>If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84)</source>
          <target state="translated">Si un efecto secundario en un objeto escalar no está secuenciado en relación con un efecto secundario diferente en el mismo objeto escalar o con un cálculo de valores utilizando el valor del mismo objeto escalar,el comportamiento es indefinido.Si hay múltiples ordenamientos permitidos de las subexpresiones de una expresión,el comportamiento es indefinido si tal efecto secundario no secuenciado se produce en cualquiera de los ordenamientos.84)</target>
        </trans-unit>
        <trans-unit id="6b364d00d6c222691294e1d715a9d3195c3b8d0b" translate="yes" xml:space="preserve">
          <source>If the compiler were to write &lt;code&gt;i++&lt;/code&gt; as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn't happen to notice that one of the other instructions happened to access &lt;code&gt;i&lt;/code&gt;, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable &lt;code&gt;i&lt;/code&gt; is used in both places, but if a routine accepts references to two pointers &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;, and uses &lt;code&gt;(*p)&lt;/code&gt; and &lt;code&gt;(*q)&lt;/code&gt; in the above expression (rather than using &lt;code&gt;i&lt;/code&gt; twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same object's address were passed for both &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">Si el compilador escribiera &lt;code&gt;i++&lt;/code&gt; como se indic&amp;oacute; anteriormente (legal seg&amp;uacute;n el est&amp;aacute;ndar) e intercalara las instrucciones anteriores a lo largo de la evaluaci&amp;oacute;n de la expresi&amp;oacute;n general (tambi&amp;eacute;n legal), y si no se notara que una de las otras instrucciones si tuviera acceso a &lt;code&gt;i&lt;/code&gt; , ser&amp;iacute;a posible (y legal) para el compilador generar una secuencia de instrucciones que se estancar&amp;iacute;an. Sin duda, un compilador seguramente detectar&amp;aacute; el problema en el caso en que se use la misma variable &lt;code&gt;i&lt;/code&gt; en ambos lugares, pero si una rutina acepta referencias a dos punteros &lt;code&gt;p&lt;/code&gt; y &lt;code&gt;q&lt;/code&gt; , y usa &lt;code&gt;(*p)&lt;/code&gt; y &lt;code&gt;(*q)&lt;/code&gt; en la expresi&amp;oacute;n anterior (en lugar de usar &lt;code&gt;i&lt;/code&gt; dos veces) no se requerir&amp;iacute;a que el compilador reconozca o evite el punto muerto que ocurrir&amp;iacute;a si se pasara la misma direcci&amp;oacute;n del objeto para &lt;code&gt;p&lt;/code&gt; y &lt;code&gt;q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c74bddb68bd6a38d49d02706436102a8da2c6744" translate="yes" xml:space="preserve">
          <source>If there's a variable that's getting modified in one place, and having its value used in another place, how do you know whether it uses the old value or the new value?</source>
          <target state="translated">Si hay una variable que se modifica en un lugar,y se utiliza su valor en otro lugar,¿cómo sabes si utiliza el valor antiguo o el nuevo?</target>
        </trans-unit>
        <trans-unit id="4647db1287f30dfb23b1f0e049be0ffce3ceebe7" translate="yes" xml:space="preserve">
          <source>If there's one variable that's getting modified (assigned to) in two or more different places, how do you know which modification happens first?</source>
          <target state="translated">Si hay una variable que se está modificando (asignando)en dos o más lugares diferentes,¿cómo sabes qué modificación ocurre primero?</target>
        </trans-unit>
        <trans-unit id="ee1d81c9d526b617cd5db47f0b9129a56d6d92fc" translate="yes" xml:space="preserve">
          <source>Immediately before a library function returns (7.1.4).</source>
          <target state="translated">Inmediatamente antes de que regrese una función de la biblioteca (7.1.4).</target>
        </trans-unit>
        <trans-unit id="ccc935207dc7de3d090caefd6346b4420b8001d0" translate="yes" xml:space="preserve">
          <source>Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.22.5).</source>
          <target state="translated">Inmediatamente antes e inmediatamente después de cada llamada a una función de comparación,y también entre cualquier llamada a una función de comparación y cualquier movimiento de los objetos pasados como argumentos a esa llamada (7.22.5).</target>
        </trans-unit>
        <trans-unit id="60ed5174c21627240c96b7033c369a5233234943" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&quot;&gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&lt;/a&gt; someone asked about a statement like:</source>
          <target state="translated">En &lt;a href=&quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&quot;&gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&lt;/a&gt; alguien pregunt&amp;oacute; acerca de una declaraci&amp;oacute;n como:</target>
        </trans-unit>
        <trans-unit id="e29fa6906c297000780a6ab5da38fae509305f9d" translate="yes" xml:space="preserve">
          <source>In GCC C++,  the precedence of the operators controls the order in
  which the individual operators are evaluated</source>
          <target state="translated">En GCC C++,la precedencia de los operadores controla el orden en que se evalúan los operadores individuales</target>
        </trans-unit>
        <trans-unit id="eb8013ee2895e4b793b24f5480886aca31c43b1e" translate="yes" xml:space="preserve">
          <source>In all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the &lt;code&gt;;&lt;/code&gt; in each one of these cases:</source>
          <target state="translated">En todos estos ejemplos, el c&amp;oacute;digo intenta modificar un objeto m&amp;aacute;s de una vez en el mismo punto de secuencia, que terminar&amp;aacute; con &lt;code&gt;;&lt;/code&gt; en cada uno de estos casos:</target>
        </trans-unit>
        <trans-unit id="85af2d68b64dacc2ecae8e6b8fe0626d9c55f451" translate="yes" xml:space="preserve">
          <source>In the following statement:</source>
          <target state="translated">En la siguiente declaración:</target>
        </trans-unit>
        <trans-unit id="57437b57542ff5ccdb46668e495487b9f29b828e" translate="yes" xml:space="preserve">
          <source>In the paper that I quoted above it is explained that you can figure out the program as being formed by small boxes, each box containing the instructions between 2 consecutive sequence points.  The sequence points are defined in annex C of the standard, in the case of &lt;code&gt;i=i++&lt;/code&gt; there are 2 sequence points that delimit a full-expression.  Such an expression is syntactically equivalent with an entry of &lt;code&gt;expression-statement&lt;/code&gt; in the Backus-Naur form of the grammar (a grammar is provided in annex A of the Standard).</source>
          <target state="translated">En el documento que cit&amp;eacute; anteriormente, se explica que puede descubrir que el programa est&amp;aacute; formado por peque&amp;ntilde;os cuadros, cada cuadro contiene las instrucciones entre 2 puntos de secuencia consecutivos. Los puntos de secuencia se definen en el anexo C de la norma, en el caso de &lt;code&gt;i=i++&lt;/code&gt; hay 2 puntos de secuencia que delimitan una expresi&amp;oacute;n completa. Tal expresi&amp;oacute;n es sint&amp;aacute;cticamente equivalente con una entrada de &lt;code&gt;expression-statement&lt;/code&gt; en la forma de la gram&amp;aacute;tica Backus-Naur (se proporciona una gram&amp;aacute;tica en el anexo A de la Norma).</target>
        </trans-unit>
        <trans-unit id="dab7f2edb9365a8a8024bd3b99b725247b21d547" translate="yes" xml:space="preserve">
          <source>It means the expression &lt;code&gt;il = ir++&lt;/code&gt; could be evaluated either as</source>
          <target state="translated">Significa que la expresi&amp;oacute;n &lt;code&gt;il = ir++&lt;/code&gt; podr&amp;iacute;a evaluarse como</target>
        </trans-unit>
        <trans-unit id="6d4bde792ab173fc5f3953aa5c52bd9c3b953ae4" translate="yes" xml:space="preserve">
          <source>Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.</source>
          <target state="translated">Sólo compila y desmonta tu línea de código,si estás tan inclinado a saber cómo exactamente es que obtienes lo que obtienes.</target>
        </trans-unit>
        <trans-unit id="139c53c1c422cb855e5ab14ec329f7d3e7293cf2" translate="yes" xml:space="preserve">
          <source>Let's go back to the two examples I've used in this answer.  When I wrote</source>
          <target state="translated">Volvamos a los dos ejemplos que he usado en esta respuesta.Cuando escribí</target>
        </trans-unit>
        <trans-unit id="007b8d5a96beaf6791ee66ac241a455d31c8ebee" translate="yes" xml:space="preserve">
          <source>Lets rename the &lt;code&gt;i&lt;/code&gt; at left of assignment be &lt;code&gt;il&lt;/code&gt; and at the right of assignment (in the expression &lt;code&gt;i++&lt;/code&gt;) be &lt;code&gt;ir&lt;/code&gt;, then the expression be like</source>
          <target state="translated">Cambiemos el nombre de &lt;code&gt;i&lt;/code&gt; a la izquierda de la asignaci&amp;oacute;n por &lt;code&gt;il&lt;/code&gt; y a la derecha de la asignaci&amp;oacute;n (en la expresi&amp;oacute;n &lt;code&gt;i++&lt;/code&gt; ) sea &lt;code&gt;ir&lt;/code&gt; , entonces la expresi&amp;oacute;n ser&amp;aacute; como</target>
        </trans-unit>
        <trans-unit id="0e79c62d8a96cc83c832406559fd72c325b73755" translate="yes" xml:space="preserve">
          <source>Modern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).</source>
          <target state="translated">Los compiladores modernos optimizarán esto muy bien.De hecho,posiblemente mejor que el código que escribió originalmente (suponiendo que haya funcionado de la manera que esperaba).</target>
        </trans-unit>
        <trans-unit id="abffaa693417a99890a9f9f411f179a50d8a1f83" translate="yes" xml:space="preserve">
          <source>Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand &lt;strong&gt;why the behavior of these constructs are undefined&lt;/strong&gt;, let's understand these terms first in the light of C11 standard:</source>
          <target state="translated">La mayor&amp;iacute;a de las respuestas aqu&amp;iacute; citadas del est&amp;aacute;ndar C enfatizan que el comportamiento de estas construcciones no est&amp;aacute; definido. Para comprender &lt;strong&gt;por qu&amp;eacute; el comportamiento de estas construcciones no est&amp;aacute; definido&lt;/strong&gt; , comprendamos primero estos t&amp;eacute;rminos a la luz del est&amp;aacute;ndar C11:</target>
        </trans-unit>
        <trans-unit id="65659095c4721a9366d72724c0af8686528c6a8e" translate="yes" xml:space="preserve">
          <source>Now coming to the question, for the expressions like</source>
          <target state="translated">Ahora llegando a la pregunta,por las expresiones como</target>
        </trans-unit>
        <trans-unit id="b011b82c9d0b255b15ca16ab67361428cc130072" translate="yes" xml:space="preserve">
          <source>Often this question is linked as a duplicate of questions related to code like</source>
          <target state="translated">A menudo esta pregunta se vincula como un duplicado de las preguntas relacionadas con el código como</target>
        </trans-unit>
        <trans-unit id="80af210ba078168ac8aed18f4c289fb13eafe061" translate="yes" xml:space="preserve">
          <source>Or, perhaps you're looking at a hard-to-understand expression like</source>
          <target state="translated">O,tal vez estás viendo una expresión difícil de entender como</target>
        </trans-unit>
        <trans-unit id="7814f3637cef69793eb4cd0c35453c057b2b2e5b" translate="yes" xml:space="preserve">
          <source>Other good source for explaining such ambiguities are the entries from &lt;a href=&quot;http://c-faq.com/&quot;&gt;c-faq&lt;/a&gt; site (also published &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201845199&quot;&gt;as a book&lt;/a&gt;) , namely &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://c-faq.com/expr/evalorder4.html&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://c-faq.com/expr/confused.html&quot;&gt;here&lt;/a&gt; .</source>
          <target state="translated">Otra buena fuente para explicar tales ambig&amp;uuml;edades son las entradas del sitio &lt;a href=&quot;http://c-faq.com/&quot;&gt;c-faq&lt;/a&gt; (tambi&amp;eacute;n publicado &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201845199&quot;&gt;como libro&lt;/a&gt; ), es decir, &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt; y &lt;a href=&quot;http://c-faq.com/expr/evalorder4.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt; y &lt;a href=&quot;http://c-faq.com/expr/confused.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="270467ed08a16c4189f257fa18a363287c860a70" translate="yes" xml:space="preserve">
          <source>Perhaps someone gave you that code as a puzzle.  This code also makes no sense, especially if you run it -- and if you compile and run it under two different compilers, you're likely to get two different answers!  What's up with that?  Which answer is correct?  (And the answer is that both of them are, or neither of them are.)</source>
          <target state="translated">Tal vez alguien le dio ese código como un rompecabezas.Este código tampoco tiene sentido,especialmente si lo ejecutas...y si lo compilas y ejecutas en dos compiladores diferentes,¡es probable que obtengas dos respuestas diferentes! ¿Qué pasa con eso? ¿Qué respuesta es correcta? (Y la respuesta es que ambas lo son,o ninguna de ellas lo es.)</target>
        </trans-unit>
        <trans-unit id="9830e65c22471dbb5ae76ba87a9754d88a6b0759" translate="yes" xml:space="preserve">
          <source>Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</source>
          <target state="translated">El posible comportamiento indefinido va desde ignorar completamente la situación con resultados impredecibles,hasta comportarse durante la traducción o la ejecución del programa de manera documentada y característica del entorno (con o sin la emisión de un mensaje de diagnóstico).</target>
        </trans-unit>
        <trans-unit id="d4ec24e520c2deaf639afba4b9f783d5aac04aab" translate="yes" xml:space="preserve">
          <source>Realistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, &quot;If it's not obvious what an expression using ++ means, don't write it.&quot;</source>
          <target state="translated">Siendo realistas,la única vez que estas locas expresiones se escriben es cuando la gente las usa como ejemplos artificiales de cómo se supone que funciona el ++.Y por supuesto es importante entender cómo funciona el ++.Pero una regla práctica para usar ++es,&quot;Si no es obvio lo que significa una expresión que usa ++,no la escribas&quot;.</target>
        </trans-unit>
        <trans-unit id="6343a0dd7d4a3cce5612fb2bd80119beebcf602a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;question 3.8&lt;/a&gt; and the rest of the questions in &lt;a href=&quot;http://c-faq.com/expr/index.html&quot;&gt;section 3&lt;/a&gt; of the &lt;a href=&quot;http://c-faq.com/&quot;&gt;C FAQ list&lt;/a&gt;.</source>
          <target state="translated">Consulte tambi&amp;eacute;n la &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot;&gt;pregunta 3.8&lt;/a&gt; y el resto de las preguntas en la &lt;a href=&quot;http://c-faq.com/expr/index.html&quot;&gt;secci&amp;oacute;n 3&lt;/a&gt; de la &lt;a href=&quot;http://c-faq.com/&quot;&gt;lista de preguntas frecuentes de C.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b00a321a9495c839c828a507be825ff13a7800c" translate="yes" xml:space="preserve">
          <source>So a sequence point can be seen by the beginning and the end of each box that composes the program [the boxes are atomic units in C] and inside a box the order of instructions is not defined in all cases.  Changing that order one can change the result sometimes.</source>
          <target state="translated">Así que se puede ver un punto de secuencia por el principio y el final de cada caja que compone el programa [las cajas son unidades atómicas en C]y dentro de una caja el orden de las instrucciones no está definido en todos los casos.Cambiando ese orden se puede cambiar el resultado a veces.</target>
        </trans-unit>
        <trans-unit id="d21ba0d230406e77017c4520bffdb2aae21a3660" translate="yes" xml:space="preserve">
          <source>So every statement of the form:</source>
          <target state="translated">Así que cada declaración del formulario:</target>
        </trans-unit>
        <trans-unit id="647883dff5588a701bbd3395f0dfc501b2bb13be" translate="yes" xml:space="preserve">
          <source>So first the GCC:
Using &lt;a href=&quot;https://nuwen.net/mingw.html&quot;&gt;Nuwen MinGW&lt;/a&gt; 15 GCC 7.1 you will get:</source>
          <target state="translated">Primero el GCC: Usando &lt;a href=&quot;https://nuwen.net/mingw.html&quot;&gt;Nuwen MinGW&lt;/a&gt; 15 GCC 7.1 obtendr&amp;aacute;s:</target>
        </trans-unit>
        <trans-unit id="e1619e58534e7a9257bad023ee9910dd4500fdf3" translate="yes" xml:space="preserve">
          <source>So if the &lt;em&gt;comma&lt;/em&gt; in the function call were to be a comma operator then</source>
          <target state="translated">Entonces, si la &lt;em&gt;coma&lt;/em&gt; en la llamada de funci&amp;oacute;n fuera un operador de coma, entonces</target>
        </trans-unit>
        <trans-unit id="d80658b592df0803b15a8dd4666f791a7e32f7f1" translate="yes" xml:space="preserve">
          <source>So moving on to &lt;em&gt;unspecified behavior&lt;/em&gt;, in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;draft c99 standard&lt;/a&gt; section&lt;code&gt;6.5&lt;/code&gt; paragraph &lt;em&gt;3&lt;/em&gt; says(&lt;em&gt;emphasis mine&lt;/em&gt;):</source>
          <target state="translated">Entonces, pasando al &lt;em&gt;comportamiento no especificado&lt;/em&gt; , en el &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;borrador de la&lt;/a&gt; secci&amp;oacute;n &lt;code&gt;6.5&lt;/code&gt; del est&amp;aacute;ndar c99 , el p&amp;aacute;rrafo &lt;em&gt;3&lt;/em&gt; dice ( &lt;em&gt;&amp;eacute;nfasis m&amp;iacute;o&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="de08ea26a98f633b8bc219b190df93d9fb9ddf4e" translate="yes" xml:space="preserve">
          <source>So that's the answer: make sure that in any expression you write, each variable is modified at most once, and if a variable is modified, you don't also attempt to use the value of that variable somewhere else.</source>
          <target state="translated">Así que esa es la respuesta:asegúrate de que en cualquier expresión que escribas,cada variable se modifique a lo sumo una vez,y si una variable se modifica,no intentes también utilizar el valor de esa variable en otro lugar.</target>
        </trans-unit>
        <trans-unit id="fe5b5ad4189e6c54f36de1b0cb2dd509ca3eedca" translate="yes" xml:space="preserve">
          <source>So the equivalent in defined behavior C++ as Visual C++ understands:</source>
          <target state="translated">Así que el equivalente en comportamiento definido C++como Visual C++entiende:</target>
        </trans-unit>
        <trans-unit id="39e26ec98db22aab7bb548688a3cf6b65be062cd" translate="yes" xml:space="preserve">
          <source>So the order of instructions inside a box has no clear order.</source>
          <target state="translated">Así que el orden de las instrucciones dentro de una caja no tiene un orden claro.</target>
        </trans-unit>
        <trans-unit id="0813b942e4187634ff676479cc7529a6a62bd091" translate="yes" xml:space="preserve">
          <source>So when we have a line like this:</source>
          <target state="translated">Así que cuando tenemos una línea como esta:</target>
        </trans-unit>
        <trans-unit id="51bff8d93419b8b376c49a4c4c1c6942815bd3f1" translate="yes" xml:space="preserve">
          <source>So with all that background and introduction out of the way, if you want to make sure that all your programs are well-defined, which expressions can you write, and which ones can you not write?</source>
          <target state="translated">Así que con todos esos antecedentes e introducción fuera del camino,si quieres asegurarte de que todos tus programas están bien definidos,¿qué expresiones puedes escribir y cuáles no?</target>
        </trans-unit>
        <trans-unit id="418454311311342d72ab9381129cfc784f14f285" translate="yes" xml:space="preserve">
          <source>So, with that in mind, why are these &quot;issues&quot;? The language clearly says that certain things lead to &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;undefined behavior&lt;/a&gt;. There is no problem, there is no &quot;should&quot; involved. If the undefined behavior changes when one of the involved variables is declared &lt;code&gt;volatile&lt;/code&gt;, that doesn't prove or change anything. It is &lt;em&gt;undefined&lt;/em&gt;; you cannot reason about the behavior.</source>
          <target state="translated">Entonces, con eso en mente, &amp;iquest;por qu&amp;eacute; son estos &quot;problemas&quot;? El lenguaje dice claramente que ciertas cosas conducen a &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;un comportamiento indefinido&lt;/a&gt; . No hay problema, no hay &quot;deber&amp;iacute;a&quot; involucrado. Si el comportamiento indefinido cambia cuando una de las variables involucradas se declara &lt;code&gt;volatile&lt;/code&gt; , eso no prueba ni cambia nada. Es &lt;em&gt;indefinido&lt;/em&gt; ; No puedes razonar sobre el comportamiento.</target>
        </trans-unit>
        <trans-unit id="52169783c5f1f44d70c71ae0d258a149699e59f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;++i&lt;/code&gt; increments aren't guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 &lt;code&gt;++i&lt;/code&gt; executed, then the values of &lt;code&gt;k[]&lt;/code&gt; were read, then the last &lt;code&gt;++i&lt;/code&gt; then &lt;code&gt;k[]&lt;/code&gt;.</source>
          <target state="translated">No se garantiza que los incrementos de &lt;code&gt;++i&lt;/code&gt; se completen antes del resto de los c&amp;aacute;lculos. De hecho, diferentes compiladores obtendr&amp;aacute;n diferentes resultados aqu&amp;iacute;. En el ejemplo que proporcion&amp;oacute;, se ejecutaron los primeros 2 &lt;code&gt;++i&lt;/code&gt; , luego se leyeron los valores de &lt;code&gt;k[]&lt;/code&gt; , luego el &amp;uacute;ltimo &lt;code&gt;++i&lt;/code&gt; luego &lt;code&gt;k[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b497b90b5e9411034420efd2bf3531f465b5abe8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;unspecified behaviour&lt;/em&gt; itself is NOT an issue. Consider this example:</source>
          <target state="translated">El &lt;em&gt;comportamiento no especificado en&lt;/em&gt; s&amp;iacute; NO es un problema. Considere este ejemplo:</target>
        </trans-unit>
        <trans-unit id="aef2dc12b657421591a01f033cfac67b5ba2c01f" translate="yes" xml:space="preserve">
          <source>The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point.</source>
          <target state="translated">La norma C dice que una variable sólo debe ser asignada como máximo una vez entre dos puntos de secuencia.Un punto y coma,por ejemplo,es un punto de secuencia.</target>
        </trans-unit>
        <trans-unit id="310e41e0df172a9305a8811318f58058e4fed9e9" translate="yes" xml:space="preserve">
          <source>The above is a common coding practice while copying/analysing strings.</source>
          <target state="translated">Lo anterior es una práctica común de codificación mientras se copian y analizan las cuerdas.</target>
        </trans-unit>
        <trans-unit id="c5e1fbdb0b52dfbb81762c5648cb9c71849abbe4" translate="yes" xml:space="preserve">
          <source>The behavior can't really be explained because it invokes both &lt;a href=&quot;http://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;unspecified behavior&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;undefined behavior&lt;/a&gt;, so we can not make any general predictions about this code, although if you read &lt;em&gt;Olve Maudal's&lt;/em&gt; work such as &lt;a href=&quot;http://www.slideshare.net/olvemaudal/deep-c&quot;&gt;Deep C&lt;/a&gt; and &lt;a href=&quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf&quot;&gt;Unspecified and Undefined&lt;/a&gt; sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don't do that anywhere near production.</source>
          <target state="translated">El comportamiento realmente no se puede explicar porque invoca tanto el &lt;a href=&quot;http://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;comportamiento no especificado como el comportamiento&lt;/a&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;indefinido&lt;/a&gt; , por lo que no podemos hacer predicciones generales sobre este c&amp;oacute;digo, aunque si lee &lt;em&gt;el&lt;/em&gt; trabajo de &lt;em&gt;Olve Maudal&lt;/em&gt; , como &lt;a href=&quot;http://www.slideshare.net/olvemaudal/deep-c&quot;&gt;Deep C&lt;/a&gt; y &lt;a href=&quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf&quot;&gt;Unspecified and Undefined, a&lt;/a&gt; veces puede ser bueno adivina en casos muy espec&amp;iacute;ficos con un compilador y un entorno espec&amp;iacute;ficos, pero no lo haga cerca de la producci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="27ec791e6f2a00a49e0a8a0ed54e4616a7f3a094" translate="yes" xml:space="preserve">
          <source>The comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in &lt;code&gt;j = (++i, i++);&lt;/code&gt;, &lt;code&gt;++i&lt;/code&gt; increments &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; and &lt;code&gt;i++&lt;/code&gt; yields old value of &lt;code&gt;i&lt;/code&gt; (&lt;code&gt;6&lt;/code&gt;) which is assigned to &lt;code&gt;j&lt;/code&gt;. Then &lt;code&gt;i&lt;/code&gt; becomes &lt;code&gt;7&lt;/code&gt; due to post-increment.</source>
          <target state="translated">El operador de coma eval&amp;uacute;a sus operandos de izquierda a derecha y produce solo el valor del &amp;uacute;ltimo operando. Entonces en &lt;code&gt;j = (++i, i++);&lt;/code&gt; , &lt;code&gt;++i&lt;/code&gt; incrementa &lt;code&gt;i&lt;/code&gt; a &lt;code&gt;6&lt;/code&gt; e &lt;code&gt;i++&lt;/code&gt; produce el antiguo valor de &lt;code&gt;i&lt;/code&gt; ( &lt;code&gt;6&lt;/code&gt; ) que se asigna a &lt;code&gt;j&lt;/code&gt; . Entonces &lt;code&gt;i&lt;/code&gt; convierto en &lt;code&gt;7&lt;/code&gt; debido al incremento posterior.</target>
        </trans-unit>
        <trans-unit id="b67dbcc4d76d135a5736d6b29c5429827a1f48d3" translate="yes" xml:space="preserve">
          <source>The end of a full declarator: declarators (6.7.6);</source>
          <target state="translated">El fin de un declarante completo:declarantes (6.7.6);</target>
        </trans-unit>
        <trans-unit id="0108968d37f78fc724b69ab92c9f870191ada9e6" translate="yes" xml:space="preserve">
          <source>The first fragment asked about, &lt;code&gt;i = i++ + ++i&lt;/code&gt;, is pretty clearly insane in my book.  No one would ever write it in a real program, it's not obvious what it does, there's no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it's not obvious to you and me what it's supposed to do, it's fine in my book if the compiler can't figure out what it's supposed to do, either.</source>
          <target state="translated">El primer fragmento sobre el que se pregunt&amp;oacute;, &lt;code&gt;i = i++ + ++i&lt;/code&gt; , es bastante loco en mi libro. Nadie lo escribir&amp;iacute;a en un programa real, no es obvio lo que hace, no hay un algoritmo concebible que alguien podr&amp;iacute;a haber intentado codificar que hubiera resultado en esta secuencia de operaciones artificial. Y dado que no es obvio para ti y para m&amp;iacute; lo que se supone que debe hacer, est&amp;aacute; bien en mi libro si el compilador tampoco puede entender qu&amp;eacute; se supone que debe hacer.</target>
        </trans-unit>
        <trans-unit id="90a68f87988cd45f4bd6311c6ab3e5a1dc45538e" translate="yes" xml:space="preserve">
          <source>The following are the sequence points described in 5.1.2.3:</source>
          <target state="translated">Los siguientes son los puntos de la secuencia descritos en 5.1.2.3:</target>
        </trans-unit>
        <trans-unit id="902611ed1501ed869ca53ff5d324e744ab75270b" translate="yes" xml:space="preserve">
          <source>The grouping of operators and operands is indicated by the syntax.74) Except as specified
  later (for the function-call (), &amp;amp;&amp;amp;, ||, ?:, and comma operators), &lt;strong&gt;the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.&lt;/strong&gt;</source>
          <target state="translated">La agrupaci&amp;oacute;n de operadores y operandos se indica mediante la sintaxis.74) Excepto como se especifica m&amp;aacute;s adelante (para los operadores call-function (), &amp;amp;&amp;amp;, ||,?: Y coma), &lt;strong&gt;el orden de evaluaci&amp;oacute;n de subexpresiones y el orden en qu&amp;eacute; efectos secundarios tienen lugar no est&amp;aacute;n especificados.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71b9fec95a5c0e3f3bf5d039dad362d79f0e9e56" translate="yes" xml:space="preserve">
          <source>The important part is to know &lt;a href=&quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c&quot;&gt;what a sequence point is -- and &lt;em&gt;what is&lt;/em&gt; a sequence point and what &lt;em&gt;isn't&lt;/em&gt;&lt;/a&gt;. For example the &lt;em&gt;comma operator&lt;/em&gt; is a sequence point, so</source>
          <target state="translated">La parte importante es saber &lt;a href=&quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c&quot;&gt;qu&amp;eacute; es un punto de secuencia, y &lt;em&gt;qu&amp;eacute; es&lt;/em&gt; un punto de secuencia y qu&amp;eacute; &lt;em&gt;no&lt;/em&gt; lo &lt;em&gt;es&lt;/em&gt;&lt;/a&gt; . Por ejemplo, el &lt;em&gt;operador de coma&lt;/em&gt; es un punto de secuencia, entonces</target>
        </trans-unit>
        <trans-unit id="51f661df914e1e2ea77746de6aaa11f9b46f6347" translate="yes" xml:space="preserve">
          <source>The main rule from the standard ISO 9899 that applies in this situation is  6.5p2.</source>
          <target state="translated">La principal regla de la norma ISO 9899 que se aplica en esta situación es 6,5p2.</target>
        </trans-unit>
        <trans-unit id="88392b333617da7906af6f1c9e71bc7a0011c98f" translate="yes" xml:space="preserve">
          <source>The order in which the function designator, arguments, and
  subexpressions within the arguments are evaluated in a function call
  (6.5.2.2).</source>
          <target state="translated">El orden en que se evalúan el designador de la función,los argumentos y las subexpresiones dentro de los argumentos en una llamada a la función (6.5.2.2).</target>
        </trans-unit>
        <trans-unit id="c9968c66bc17adf0cf66c21f5fc4281778fad8b3" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands is unspecified. If an attempt is made to modify
  the result of an assignment operator or to access it after the next sequence point, the
  behavior is undefined.</source>
          <target state="translated">El orden de evaluación de los operandos no está especificado.Si se intenta modificar el resultado de un operador de asignación o acceder a él después del siguiente punto de la secuencia,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="57d772c677ab734e951cb65c9f5a9c6ad1025dbd" translate="yes" xml:space="preserve">
          <source>The presence of a sequence point between the evaluation of expressions &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; implies that every &lt;em&gt;value computation&lt;/em&gt; and &lt;em&gt;side effect&lt;/em&gt; associated with &lt;code&gt;A&lt;/code&gt; is sequenced before every &lt;em&gt;value computation&lt;/em&gt; and &lt;em&gt;side effect&lt;/em&gt; associated with &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">La presencia de un punto de secuencia entre la evaluaci&amp;oacute;n de las expresiones &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; implica que cada &lt;em&gt;c&amp;aacute;lculo de valor&lt;/em&gt; y &lt;em&gt;efecto secundario&lt;/em&gt; asociado con &lt;code&gt;A&lt;/code&gt; se secuencia antes de cada &lt;em&gt;c&amp;aacute;lculo de valor&lt;/em&gt; y &lt;em&gt;efecto secundario&lt;/em&gt; asociado con &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa757362c1545c0b1bfa0b4971c8bcf9a5fa705" translate="yes" xml:space="preserve">
          <source>The problem with this expression is that it contains three different attempts to modify the value of x: (1) the &lt;code&gt;x++&lt;/code&gt; part tries to add 1 to x, store the new value in &lt;code&gt;x&lt;/code&gt;, and return the old value of &lt;code&gt;x&lt;/code&gt;; (2) the &lt;code&gt;++x&lt;/code&gt; part tries to add 1 to x, store the new value in &lt;code&gt;x&lt;/code&gt;, and return the new value of &lt;code&gt;x&lt;/code&gt;; and (3) the &lt;code&gt;x =&lt;/code&gt; part tries to assign the sum of the other two back to x.  Which of those three attempted assignments will &quot;win&quot;?  Which of the three values will actually get assigned to &lt;code&gt;x&lt;/code&gt;?  Again, and perhaps surprisingly, there's no rule in C to tell us.</source>
          <target state="translated">El problema con esta expresi&amp;oacute;n es que contiene tres intentos diferentes de modificar el valor de x: (1) la parte &lt;code&gt;x++&lt;/code&gt; intenta agregar 1 a x, almacenar el nuevo valor en &lt;code&gt;x&lt;/code&gt; y devolver el valor anterior de &lt;code&gt;x&lt;/code&gt; ; (2) la parte &lt;code&gt;++x&lt;/code&gt; intenta agregar 1 a x, almacenar el nuevo valor en &lt;code&gt;x&lt;/code&gt; y devolver el nuevo valor de &lt;code&gt;x&lt;/code&gt; ; y (3) la parte &lt;code&gt;x =&lt;/code&gt; intenta asignar la suma de los otros dos a x. &amp;iquest;Cu&amp;aacute;l de esos tres intentos de tareas &quot;ganar&amp;aacute;&quot;? &amp;iquest;Cu&amp;aacute;l de los tres valores se asignar&amp;aacute; realmente a &lt;code&gt;x&lt;/code&gt; ? De nuevo, y quiz&amp;aacute;s sorprendentemente, no hay una regla en C que nos diga.</target>
        </trans-unit>
        <trans-unit id="8cf9f511dc75b3a4a079a7021f4a602979571d13" translate="yes" xml:space="preserve">
          <source>The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).</source>
          <target state="translated">La razón es que el programa está ejecutando un comportamiento indefinido.El problema radica en el orden de evaluación,porque no se requieren puntos de secuencia según el estándar C++98 (no se secuencian operaciones antes o después de otra según la terminología C++11).</target>
        </trans-unit>
        <trans-unit id="44562ae2bb8fdbc35628d635d10e98d6d60b8571" translate="yes" xml:space="preserve">
          <source>The second fragment, &lt;code&gt;i = i++&lt;/code&gt;, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:</source>
          <target state="translated">El segundo fragmento, &lt;code&gt;i = i++&lt;/code&gt; , es un poco m&amp;aacute;s f&amp;aacute;cil de entender. Alguien claramente est&amp;aacute; tratando de incrementar i, y asignar el resultado nuevamente a i. Pero hay un par de formas de hacer esto en C. La forma m&amp;aacute;s b&amp;aacute;sica de agregar 1 a i, y asignar el resultado a i, es la misma en casi cualquier lenguaje de programaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="6c93396d9e2d8c2a40d78d9071566b25f416ee2f" translate="yes" xml:space="preserve">
          <source>The sequence points in an expression like &lt;code&gt;i=i++&lt;/code&gt; are before &lt;code&gt;i=&lt;/code&gt; and after &lt;code&gt;i++&lt;/code&gt;.</source>
          <target state="translated">Los puntos de secuencia en una expresi&amp;oacute;n como &lt;code&gt;i=i++&lt;/code&gt; son antes de &lt;code&gt;i=&lt;/code&gt; y despu&amp;eacute;s de &lt;code&gt;i++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c90d0fb8a0d148c282b3883e977c9bc9699153f" translate="yes" xml:space="preserve">
          <source>The various sequence points are listed in Annex C of &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#C&quot;&gt;C11&lt;/a&gt; (and &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#C&quot;&gt;C99&lt;/a&gt;):</source>
          <target state="translated">Los diversos puntos de secuencia se enumeran en el Anexo C de &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#C&quot;&gt;C11&lt;/a&gt; (y &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#C&quot;&gt;C99&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="a79c3a06a2a5a93d7c630437550bdbcddba0807b" translate="yes" xml:space="preserve">
          <source>The wording of the same &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2&quot;&gt;paragraph in C11&lt;/a&gt; is:</source>
          <target state="translated">La redacci&amp;oacute;n del mismo &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2&quot;&gt;p&amp;aacute;rrafo en C11&lt;/a&gt; es:</target>
        </trans-unit>
        <trans-unit id="2a85af3330f4c3a70b16dc7300fc5a565d163704" translate="yes" xml:space="preserve">
          <source>Then we go to &lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;Visual Studio&lt;/a&gt;. Visual Studio 2015, you get:</source>
          <target state="translated">Luego vamos a &lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;Visual Studio&lt;/a&gt; . Visual Studio 2015, obtienes:</target>
        </trans-unit>
        <trans-unit id="97e693ad3a0c6aa731e9685496e0af87463aa908" translate="yes" xml:space="preserve">
          <source>Therefore, the above expression invokes UB because two side effects on the same object &lt;code&gt;i&lt;/code&gt; is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to &lt;code&gt;i&lt;/code&gt; will be done before or after the side effect by &lt;code&gt;++&lt;/code&gt;.</source>
          <target state="translated">Por lo tanto, la expresi&amp;oacute;n anterior invoca UB porque dos efectos secundarios en el mismo objeto &lt;code&gt;i&lt;/code&gt; no est&amp;aacute;n secuenciados entre s&amp;iacute;. Eso significa que no se secuencia si el efecto secundario por asignaci&amp;oacute;n a &lt;code&gt;i&lt;/code&gt; se realizar&amp;aacute; antes o despu&amp;eacute;s del efecto secundario por &lt;code&gt;++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5f8681d077917f909bd82bb366210d3de854d2d" translate="yes" xml:space="preserve">
          <source>These expressions are all fine:</source>
          <target state="translated">Estas expresiones están bien:</target>
        </trans-unit>
        <trans-unit id="6c0f3f70b94c0e683794c748069be9306f3ff862" translate="yes" xml:space="preserve">
          <source>These expressions are all undefined:</source>
          <target state="translated">Estas expresiones son todas indefinidas:</target>
        </trans-unit>
        <trans-unit id="49e143bed893ac3c1f966d9961175fea9f0097a4" translate="yes" xml:space="preserve">
          <source>This is an important distinction because the &lt;em&gt;comma operator&lt;/em&gt; does introduce a &lt;em&gt;sequence point&lt;/em&gt; between the evaluation of their operands, which makes the following legal:</source>
          <target state="translated">Esta es una distinci&amp;oacute;n importante porque el &lt;em&gt;operador de coma&lt;/em&gt; introduce un &lt;em&gt;punto de secuencia&lt;/em&gt; entre la evaluaci&amp;oacute;n de sus operandos, lo que hace que lo siguiente sea legal:</target>
        </trans-unit>
        <trans-unit id="a7eadbdf6cf106addacc1280459303a5771a264b" translate="yes" xml:space="preserve">
          <source>This is what I get on my machine, together with what I think is going on:</source>
          <target state="translated">Esto es lo que tengo en mi máquina,junto con lo que creo que está pasando:</target>
        </trans-unit>
        <trans-unit id="d2348ba3f2dbca0683d0f6e3794c5adfe460c3d4" translate="yes" xml:space="preserve">
          <source>This means, &quot;add 1 to i, and assign the result back to i&quot;.  So if we construct a hodgepodge of the two, by writing</source>
          <target state="translated">Esto significa,&quot;sumar 1 a i,y asignar el resultado de nuevo a i&quot;.Así que si construimos una mezcolanza de los dos,escribiendo</target>
        </trans-unit>
        <trans-unit id="caa5ad4107546a13712ed7838fa8b42e3b4db460" translate="yes" xml:space="preserve">
          <source>This paragraph renders undefined statement expressions such as</source>
          <target state="translated">En este párrafo se presentan expresiones de declaración no definidas como</target>
        </trans-unit>
        <trans-unit id="46439927e625ecb8b33bd34e881c3e524a95e1a1" translate="yes" xml:space="preserve">
          <source>This post: &lt;a href=&quot;https://stackoverflow.com/a/4105123/1275169&quot;&gt;Undefined, unspecified and implementation-defined behavior&lt;/a&gt; is also relevant.</source>
          <target state="translated">Esta publicaci&amp;oacute;n: El &lt;a href=&quot;https://stackoverflow.com/a/4105123/1275169&quot;&gt;comportamiento indefinido, no especificado y definido por la implementaci&amp;oacute;n&lt;/a&gt; tambi&amp;eacute;n es relevante.</target>
        </trans-unit>
        <trans-unit id="a26b12aa6128b35356b8372db3a8257837f5a20c" translate="yes" xml:space="preserve">
          <source>This too has &lt;em&gt;unspecified behaviour&lt;/em&gt; because the order of evaluation of &lt;code&gt;++x&lt;/code&gt; and &lt;code&gt;y++&lt;/code&gt; is unspecified. But it's perfectly legal and valid statement. There's &lt;em&gt;no&lt;/em&gt; undefined behaviour in this statement. Because the modifications (&lt;code&gt;++x&lt;/code&gt; and &lt;code&gt;y++&lt;/code&gt;) are done to &lt;em&gt;distinct&lt;/em&gt; objects.</source>
          <target state="translated">Esto tambi&amp;eacute;n tiene &lt;em&gt;un comportamiento no especificado&lt;/em&gt; porque el orden de evaluaci&amp;oacute;n de &lt;code&gt;++x&lt;/code&gt; e &lt;code&gt;y++&lt;/code&gt; no est&amp;aacute; especificado. Pero es una declaraci&amp;oacute;n perfectamente legal y v&amp;aacute;lida. No &lt;em&gt;hay&lt;/em&gt; comportamiento indefinido en esta declaraci&amp;oacute;n. Porque las modificaciones ( &lt;code&gt;++x&lt;/code&gt; e &lt;code&gt;y++&lt;/code&gt; ) se realizan a objetos &lt;em&gt;distintos&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b8ab8d4d3501671ee98b37c6896a7b30e0cb64eb" translate="yes" xml:space="preserve">
          <source>Use of an unspecified value, or other behavior where this
  International Standard provides two or more possibilities and imposes
  no further requirements on which is chosen in any instance.</source>
          <target state="translated">Utilización de un valor no especificado,u otro comportamiento en el que esta Norma Internacional proporcione dos o más posibilidades y no imponga ningún otro requisito sobre el que se elija en ningún caso.</target>
        </trans-unit>
        <trans-unit id="98e776ec343640985fafdd3ff42f5002ea7be9bc" translate="yes" xml:space="preserve">
          <source>We also have &lt;em&gt;undefined behavior&lt;/em&gt; here as well since the program is modifying variables(&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, etc..) more than once between &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;sequence points&lt;/a&gt;. From draft standard section &lt;code&gt;6.5&lt;/code&gt; paragraph &lt;em&gt;2&lt;/em&gt;(&lt;em&gt;emphasis mine&lt;/em&gt;):</source>
          <target state="translated">Tambi&amp;eacute;n tenemos &lt;em&gt;un comportamiento indefinido&lt;/em&gt; aqu&amp;iacute;, ya que el programa est&amp;aacute; modificando variables ( &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; , etc.) m&amp;aacute;s de una vez entre &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;puntos de secuencia&lt;/a&gt; . Del borrador de la secci&amp;oacute;n &lt;code&gt;6.5&lt;/code&gt; , p&amp;aacute;rrafo &lt;em&gt;2&lt;/em&gt; ( &lt;em&gt;&amp;eacute;nfasis m&amp;iacute;o&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="d79ca31d503a8992b19d27638ae0bfeab48383d7" translate="yes" xml:space="preserve">
          <source>We used to spend countless hours on comp.lang.c discussing expressions like these and &lt;em&gt;why&lt;/em&gt; they're undefined.  Two of my longer answers, that try to really explain why, are archived on the web:</source>
          <target state="translated">Sol&amp;iacute;amos pasar innumerables horas comp.lang.c discutiendo expresiones como estas y &lt;em&gt;por qu&amp;eacute;&lt;/em&gt; no est&amp;aacute;n definidas. Dos de mis respuestas m&amp;aacute;s largas, que intentan explicar realmente por qu&amp;eacute;, est&amp;aacute;n archivadas en la web:</target>
        </trans-unit>
        <trans-unit id="97f59d311b736479c8957dda049a60daf7519890" translate="yes" xml:space="preserve">
          <source>What about this crazy expression?</source>
          <target state="translated">¿Qué hay de esta expresión de locura?</target>
        </trans-unit>
        <trans-unit id="5a6d959c80919c189d983a0e8445a43a2b8edc68" translate="yes" xml:space="preserve">
          <source>What makes an expression undefined?  Are expressions involving &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; always undefined?  Of course not: these are useful operators, and if you use them properly, they're perfectly well-defined.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; hace que una expresi&amp;oacute;n sea indefinida? &amp;iquest;Las expresiones que involucran &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; siempre est&amp;aacute;n indefinidas? Por supuesto que no: estos son operadores &amp;uacute;tiles, y si los usa correctamente, est&amp;aacute;n perfectamente bien definidos.</target>
        </trans-unit>
        <trans-unit id="8dbebc0ad8d152d87c6b7a7b4477c7a754623049" translate="yes" xml:space="preserve">
          <source>What renders the following statement</source>
          <target state="translated">Lo que hace que la siguiente declaración</target>
        </trans-unit>
        <trans-unit id="620723367c219dcaa50fd9cc14c519910605f4ac" translate="yes" xml:space="preserve">
          <source>Where several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators.</source>
          <target state="translated">Cuando varios operadores aparecen juntos,tienen igual precedencia y se evalúan según su asociatividad.Los operadores de la tabla se describen en las secciones que comienzan con Operadores de Postfix.</target>
        </trans-unit>
        <trans-unit id="993c059bb0f33b91c747d106d7f878acf62fa429" translate="yes" xml:space="preserve">
          <source>While I don't think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, &lt;code&gt;i&lt;/code&gt; would get incremented by two) and it's not totally inconceivable that some future processor might provide a feature something like that.</source>
          <target state="translated">Si bien no creo que ning&amp;uacute;n procesador sea compatible con el hardware para permitir que tal cosa se haga de manera eficiente, uno puede imaginar f&amp;aacute;cilmente situaciones en las que tal comportamiento har&amp;iacute;a m&amp;aacute;s f&amp;aacute;cil el c&amp;oacute;digo multiproceso (por ejemplo, garantizar&amp;iacute;a que si dos hilos intentan realizar lo anterior secuencia simult&amp;aacute;nea, &lt;code&gt;i&lt;/code&gt; incrementar&amp;iacute;a en dos) y no es totalmente inconcebible que alg&amp;uacute;n procesador futuro pueda proporcionar una caracter&amp;iacute;stica como esa.</target>
        </trans-unit>
        <trans-unit id="654bf105e22463883f4cc71645479f80ad720b8c" translate="yes" xml:space="preserve">
          <source>While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement &quot;i++&quot; with the sequence:</source>
          <target state="translated">Si bien es poco probable que ningún compilador o procesador lo haga realmente,sería legal,con arreglo a la norma C,que el compilador implementara &quot;i++&quot; con la secuencia:</target>
        </trans-unit>
        <trans-unit id="c4fc6b93cb14a30318f792c85ba1d6fcdb5593c0" translate="yes" xml:space="preserve">
          <source>While the &lt;strong&gt;syntax&lt;/strong&gt; of the expressions like &lt;code&gt;a = a++&lt;/code&gt; or &lt;code&gt;a++ + a++&lt;/code&gt; is legal, the &lt;strong&gt;behaviour&lt;/strong&gt; of these constructs is &lt;strong&gt;undefined&lt;/strong&gt; because a &lt;strong&gt;&lt;em&gt;shall&lt;/em&gt;&lt;/strong&gt; in C standard is not obeyed. &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2&quot;&gt;C99 6.5p2&lt;/a&gt;:</source>
          <target state="translated">Si bien la &lt;strong&gt;sintaxis&lt;/strong&gt; de las expresiones como &lt;code&gt;a = a++&lt;/code&gt; o &lt;code&gt;a++ + a++&lt;/code&gt; es legal, el &lt;strong&gt;comportamiento&lt;/strong&gt; de estas construcciones &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute; &lt;strong&gt;definido&lt;/strong&gt; porque no se obedece un &lt;strong&gt;&lt;em&gt;will&lt;/em&gt;&lt;/strong&gt; en el est&amp;aacute;ndar C. &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2&quot;&gt;C99 6.5p2&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fa7f3099f3e8212233573bcc53199fbb0f2d7dd7" translate="yes" xml:space="preserve">
          <source>While this is also &lt;a href=&quot;https://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;&lt;em&gt;undefined behaviour&lt;/em&gt;&lt;/a&gt; as stated already, there are subtle differences when &lt;code&gt;printf()&lt;/code&gt; is involved when comparing to a statement such as:</source>
          <target state="translated">Si bien esto tambi&amp;eacute;n es &lt;a href=&quot;https://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;&lt;em&gt;un comportamiento indefinido,&lt;/em&gt;&lt;/a&gt; como ya se dijo, existen diferencias sutiles cuando &lt;code&gt;printf()&lt;/code&gt; est&amp;aacute; involucrado cuando se compara con una declaraci&amp;oacute;n como:</target>
        </trans-unit>
        <trans-unit id="1bbd03ec9871c64e9c4395ce30be95e323064e65" translate="yes" xml:space="preserve">
          <source>Why are these constructs using pre and post-increment undefined behavior</source>
          <target state="translated">¿Por qué estas construcciones usan un comportamiento indefinido pre y post-incremento</target>
        </trans-unit>
        <trans-unit id="e9fa82e28ce977203f961d7a07d8a2d4b273fe03" translate="yes" xml:space="preserve">
          <source>Why doesn't the Standard define what these do?</source>
          <target state="translated">¿Por qué el Estándar no define lo que estos hacen?</target>
        </trans-unit>
        <trans-unit id="5d24bed798cadce6efcf21855671e0a3bd9b02cf" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#note73&quot;&gt;footnote 73&lt;/a&gt; further clarifying that</source>
          <target state="translated">Con la &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#note73&quot;&gt;nota a pie de p&amp;aacute;gina 73&lt;/a&gt; aclarando m&amp;aacute;s que</target>
        </trans-unit>
        <trans-unit id="29f531dd817ce6695c7df2a686b84fe974c07a2d" translate="yes" xml:space="preserve">
          <source>You can detect such errors in a program by for example using a recent version of GCC with &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-Werror&lt;/code&gt;, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:</source>
          <target state="translated">Puede detectar dichos errores en un programa, por ejemplo, utilizando una versi&amp;oacute;n reciente de GCC con &lt;code&gt;-Wall&lt;/code&gt; y &lt;code&gt;-Werror&lt;/code&gt; , y luego GCC se negar&amp;aacute; por completo a compilar su programa. La siguiente es la salida de gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:</target>
        </trans-unit>
        <trans-unit id="1e657852dfeb599a907d4ece570953de09d22b6a" translate="yes" xml:space="preserve">
          <source>You might imagine that precedence or associativity or left-to-right evaluation tells you what order things happen in, but they do not.  You may not believe me, but please take my word for it, and I'll say it again: precedence and associativity do not determine every aspect of the evaluation order of an expression in C.  In particular, if within one expression there are multiple different spots where we try to assign a new value to something like &lt;code&gt;x&lt;/code&gt;, precedence and associativity do &lt;em&gt;not&lt;/em&gt; tell us which of those attempts happens first, or last, or anything.</source>
          <target state="translated">Puede imaginar que la precedencia o la asociatividad o la evaluaci&amp;oacute;n de izquierda a derecha le dicen en qu&amp;eacute; orden suceden las cosas, pero no es as&amp;iacute;. Puede que no me creas, pero por favor toma mi palabra y lo dir&amp;eacute; nuevamente: la precedencia y la asociatividad no determinan todos los aspectos del orden de evaluaci&amp;oacute;n de una expresi&amp;oacute;n en C. En particular, si dentro de una expresi&amp;oacute;n hay m&amp;uacute;ltiples diferentes lugares donde tratamos de asignar un nuevo valor a algo como &lt;code&gt;x&lt;/code&gt; , la precedencia y la asociatividad &lt;em&gt;no&lt;/em&gt; nos dicen cu&amp;aacute;l de esos intentos ocurre primero, o el &amp;uacute;ltimo, o algo as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="16d53ac224d610d74a2b157b47df1e799121e503" translate="yes" xml:space="preserve">
          <source>Your most interesting-looking example, the one with</source>
          <target state="translated">Su ejemplo más interesante,el que tiene</target>
        </trans-unit>
        <trans-unit id="6b59ba518c972237e1ab9cf07eace07655c0ba1c" translate="yes" xml:space="preserve">
          <source>Your question was probably not, &quot;Why are these constructs undefined behavior in C?&quot;.  Your question was probably, &quot;Why did this code (using &lt;code&gt;++&lt;/code&gt;) not give me the value I expected?&quot;, and someone marked your question as a duplicate, and sent you here.</source>
          <target state="translated">Su pregunta probablemente no fue, &quot;&amp;iquest;Por qu&amp;eacute; estas construcciones no tienen un comportamiento definido en C?&quot;. Probablemente su pregunta fue: &quot;&amp;iquest;Por qu&amp;eacute; este c&amp;oacute;digo (usando &lt;code&gt;++&lt;/code&gt; ) no me dio el valor que esperaba?&quot;, Y alguien marc&amp;oacute; su pregunta como un duplicado y lo envi&amp;oacute; aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="3ab35cf324056d865ffa5f8f1bbb4c026674124f" translate="yes" xml:space="preserve">
          <source>according to &lt;a href=&quot;http://helpcentreonline.com/article/operator_console_gcc.pdf&quot;&gt;GCC C++: Operators&lt;/a&gt;</source>
          <target state="translated">seg&amp;uacute;n &lt;a href=&quot;http://helpcentreonline.com/article/operator_console_gcc.pdf&quot;&gt;GCC C ++: operadores&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01fa57d8ce0823fdd6a263ffa07b47583f555303" translate="yes" xml:space="preserve">
          <source>and 6.5.16 Assignment operators, &amp;sect;4:</source>
          <target state="translated">y 6.5.16 Operadores de asignaci&amp;oacute;n, &amp;sect;4:</target>
        </trans-unit>
        <trans-unit id="ce12358f2d210e399abcf4e1e573533bddc18601" translate="yes" xml:space="preserve">
          <source>and &lt;em&gt;undefined behavior&lt;/em&gt; is defined in section &lt;code&gt;3.4.3&lt;/code&gt; as:</source>
          <target state="translated">y el &lt;em&gt;comportamiento indefinido&lt;/em&gt; se define en la secci&amp;oacute;n &lt;code&gt;3.4.3&lt;/code&gt; como:</target>
        </trans-unit>
        <trans-unit id="2b052e36279e4939f15bff3095a49e8060b7a8a2" translate="yes" xml:space="preserve">
          <source>and notes that:</source>
          <target state="translated">y toma nota de eso:</target>
        </trans-unit>
        <trans-unit id="8e6dfcce434b9d0dda3cc6631136727fcce69183" translate="yes" xml:space="preserve">
          <source>and so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.</source>
          <target state="translated">y así sucesivamente violar esa regla.La norma también dice que el comportamiento es indefinido y no sin especificar.Algunos compiladores los detectan y producen algún resultado,pero esto no es por el estándar.</target>
        </trans-unit>
        <trans-unit id="1b3734024b41bb3f0676c1c39247d799a3758dbe" translate="yes" xml:space="preserve">
          <source>as &lt;em&gt;undefined behaviour&lt;/em&gt; is the fact that these two expressions modify the &lt;em&gt;same&lt;/em&gt; object &lt;code&gt;i&lt;/code&gt; without an intervening &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;em&gt;sequence point&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">como &lt;em&gt;comportamiento indefinido&lt;/em&gt; es el hecho de que estas dos expresiones modifican el &lt;em&gt;mismo&lt;/em&gt; objeto &lt;code&gt;i&lt;/code&gt; sin un &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;em&gt;punto de secuencia&lt;/em&gt;&lt;/a&gt; intermedio.</target>
        </trans-unit>
        <trans-unit id="9059279af0d58499da7f4421366ab030ce5ce24f" translate="yes" xml:space="preserve">
          <source>as Visual Studio documentation states at &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx&quot;&gt;Precedence and Order of Evaluation&lt;/a&gt;:</source>
          <target state="translated">como lo indica la documentaci&amp;oacute;n de Visual Studio en &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx&quot;&gt;Precedencia y orden de evaluaci&amp;oacute;n&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a66c60f4b925de32bda6e418bb9241ab007d19d2" translate="yes" xml:space="preserve">
          <source>because both all these forms to interpret the code &lt;code&gt;i=i++&lt;/code&gt; are valid and because both generate different answers, the behavior is undefined.</source>
          <target state="translated">porque ambas formas para interpretar el c&amp;oacute;digo &lt;code&gt;i=i++&lt;/code&gt; son v&amp;aacute;lidas y porque ambas generan respuestas diferentes, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="9ca0589f3b903598d63dbbb1bd82e05ec06430e2" translate="yes" xml:space="preserve">
          <source>behavior, upon use of a nonportable or erroneous program construct or of erroneous data,
  for which this International Standard imposes no requirements</source>
          <target state="translated">comportamiento,al utilizar una construcción de programa no portátil o errónea o de datos erróneos,para los cuales esta Norma Internacional no impone ningún requisito</target>
        </trans-unit>
        <trans-unit id="0adcd950d55decdb39e49fe9bd1350b81dcb1ba8" translate="yes" xml:space="preserve">
          <source>can be interpreted as</source>
          <target state="translated">puede ser interpretado como</target>
        </trans-unit>
        <trans-unit id="79800df6fd474ca1c30984dcd3f7b04c26a5c2ea" translate="yes" xml:space="preserve">
          <source>has &lt;em&gt;undefined behaviour&lt;/em&gt; because &lt;strong&gt;there is no sequence point between the evaluations of &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; in function arguments&lt;/strong&gt;, and the value of &lt;code&gt;i&lt;/code&gt; is therefore modified twice, by both &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt;, between the previous and the next sequence point.</source>
          <target state="translated">tiene &lt;em&gt;un comportamiento indefinido&lt;/em&gt; porque &lt;strong&gt;no hay un punto de secuencia entre las evaluaciones de &lt;code&gt;i++&lt;/code&gt; y &lt;code&gt;++i&lt;/code&gt; en los argumentos de la funci&amp;oacute;n&lt;/strong&gt; y, por lo tanto, el valor de &lt;code&gt;i&lt;/code&gt; se modifica dos veces, tanto por &lt;code&gt;i++&lt;/code&gt; como por &lt;code&gt;++i&lt;/code&gt; , entre el punto de secuencia anterior y el siguiente.</target>
        </trans-unit>
        <trans-unit id="7e0c4a46af008bea7bd274279fd48605405877be" translate="yes" xml:space="preserve">
          <source>is a text-book example of undefined behavior (see Wikipedia's entry on &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;sequence points&lt;/a&gt;).</source>
          <target state="translated">es un ejemplo de libro de texto de comportamiento indefinido (vea la entrada de Wikipedia sobre &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot;&gt;puntos de secuencia&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d6afca40014c337d879e759974a1ca723b9ba3d5" translate="yes" xml:space="preserve">
          <source>is well-defined, and will increment &lt;code&gt;i&lt;/code&gt; by one, yielding the old value, discard that value; then at comma operator, settle the side effects; and then increment &lt;code&gt;i&lt;/code&gt; by one, and the resulting value becomes the value of the expression - i.e. this is just a contrived way to write &lt;code&gt;j = (i += 2)&lt;/code&gt; which is yet again a &quot;clever&quot; way to write</source>
          <target state="translated">est&amp;aacute; bien definido e incrementar&amp;aacute; &lt;code&gt;i&lt;/code&gt; en uno, produciendo el valor anterior, descarte ese valor; luego, en el operador de coma, resuelva los efectos secundarios; y luego incrementa &lt;code&gt;i&lt;/code&gt; en uno, y el valor resultante se convierte en el valor de la expresi&amp;oacute;n, es decir, esta es solo una forma artificial de escribir &lt;code&gt;j = (i += 2)&lt;/code&gt; que nuevamente es una forma &quot;inteligente&quot; de escribir</target>
        </trans-unit>
        <trans-unit id="fbe75bf13ae46462a9f46964973c095ec8c518fa" translate="yes" xml:space="preserve">
          <source>it cites the following code examples as being undefined:</source>
          <target state="translated">cita los siguientes ejemplos de código como no definidos:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="64c3747b998e7ea9d774b1fd5a1400f0310b6691" translate="yes" xml:space="preserve">
          <source>or as</source>
          <target state="translated">o como</target>
        </trans-unit>
        <trans-unit id="e279a190f96b43bb236230286cb53b2703d35e62" translate="yes" xml:space="preserve">
          <source>or similar variants.</source>
          <target state="translated">o variantes similares.</target>
        </trans-unit>
        <trans-unit id="9702e27e29837c876ff819f4fdde0b4010e5e3ca" translate="yes" xml:space="preserve">
          <source>resulting in two different results &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; which depends on the sequence of side effects by assignment and &lt;code&gt;++&lt;/code&gt; and hence invokes UB.</source>
          <target state="translated">resultando en dos resultados diferentes &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;2&lt;/code&gt; que dependen de la secuencia de efectos secundarios por asignaci&amp;oacute;n y &lt;code&gt;++&lt;/code&gt; y, por lo tanto, invoca UB.</target>
        </trans-unit>
        <trans-unit id="36547a3fb0d1b37ceaa06275e8ecd615d0e3cca7" translate="yes" xml:space="preserve">
          <source>standard says that:</source>
          <target state="translated">El estándar dice eso:</target>
        </trans-unit>
        <trans-unit id="99eb919d06fc8a202d8b26c45f6410f8dd8cfde9" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;http://en.cppreference.com/w/c/language/eval_order&quot;&gt;&lt;em&gt;order of evaluation&lt;/em&gt;&lt;/a&gt; of arguments in &lt;code&gt;printf()&lt;/code&gt; is &lt;a href=&quot;https://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/a&gt;. That means, expressions &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; could be evaluated in any order. &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html&quot;&gt;C11 standard&lt;/a&gt; has some relevant descriptions on this:</source>
          <target state="translated">El &lt;a href=&quot;http://en.cppreference.com/w/c/language/eval_order&quot;&gt;&lt;em&gt;orden de evaluaci&amp;oacute;n&lt;/em&gt;&lt;/a&gt; de los argumentos en &lt;code&gt;printf()&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Unspecified_behavior&quot;&gt;&lt;em&gt;no&lt;/em&gt;&lt;/a&gt; est&amp;aacute; &lt;em&gt;especificado&lt;/em&gt; . Eso significa que las expresiones &lt;code&gt;i++&lt;/code&gt; y &lt;code&gt;++i&lt;/code&gt; podr&amp;iacute;an evaluarse en cualquier orden. &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html&quot;&gt;El est&amp;aacute;ndar C11&lt;/a&gt; tiene algunas descripciones relevantes sobre esto:</target>
        </trans-unit>
        <trans-unit id="31da7bc042367a36b94b0573d521d30381601aa7" translate="yes" xml:space="preserve">
          <source>the equivalent code in defined behavior C++ as   GCC understands:</source>
          <target state="translated">el código equivalente en el comportamiento definido C++como entiende GCC:</target>
        </trans-unit>
        <trans-unit id="b66a1df4b25aa4baacf0d81920e5b8592ea38a0a" translate="yes" xml:space="preserve">
          <source>the question is, before calling &lt;code&gt;printf&lt;/code&gt;, does the compiler compute the value of &lt;code&gt;x&lt;/code&gt; first, or &lt;code&gt;x++&lt;/code&gt;, or maybe &lt;code&gt;++x&lt;/code&gt;?  But it turns out &lt;em&gt;we don't know&lt;/em&gt;.  There's no rule in C which says that the arguments to a function get evaluated left-to-right, or right-to-left, or in some other order.  So we can't say whether the compiler will do &lt;code&gt;x&lt;/code&gt; first, then &lt;code&gt;++x&lt;/code&gt;, then &lt;code&gt;x++&lt;/code&gt;, or &lt;code&gt;x++&lt;/code&gt; then &lt;code&gt;++x&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt;, or some other order.  But the order clearly matters, because depending on which order the compiler uses, we'll clearly get different results printed by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">la pregunta es, antes de llamar a &lt;code&gt;printf&lt;/code&gt; , &amp;iquest;el compilador calcula el valor de &lt;code&gt;x&lt;/code&gt; primero, o &lt;code&gt;x++&lt;/code&gt; , o tal vez &lt;code&gt;++x&lt;/code&gt; ? Pero resulta &lt;em&gt;que no lo sabemos&lt;/em&gt; . No hay una regla en C que diga que los argumentos de una funci&amp;oacute;n se eval&amp;uacute;an de izquierda a derecha, o de derecha a izquierda, o en alg&amp;uacute;n otro orden. Por lo tanto, no podemos decir si el compilador har&amp;aacute; &lt;code&gt;x&lt;/code&gt; primero, luego &lt;code&gt;++x&lt;/code&gt; , luego &lt;code&gt;x++&lt;/code&gt; o &lt;code&gt;x++&lt;/code&gt; luego &lt;code&gt;++x&lt;/code&gt; luego &lt;code&gt;x&lt;/code&gt; , o alg&amp;uacute;n otro orden. Pero el orden claramente importa, porque dependiendo del orden que use el compilador, claramente obtendremos diferentes resultados impresos por &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b145a546526acfd63eaed2096d7c03ce76dc170c" translate="yes" xml:space="preserve">
          <source>there are three attempts to modify `x.</source>
          <target state="translated">hay tres intentos de modificar `x.</target>
        </trans-unit>
        <trans-unit id="fe89eef81018d9dbe7f6e45a8c1cb937a477767e" translate="yes" xml:space="preserve">
          <source>use of an unspecified value, or other behavior where this International Standard provides
  two or more possibilities and imposes no further requirements on which is chosen in any
  instance</source>
          <target state="translated">uso de un valor no especificado,u otro comportamiento en el que esta Norma Internacional proporcione dos o más posibilidades y no imponga ningún otro requisito sobre el que se elija en ningún caso</target>
        </trans-unit>
        <trans-unit id="be6fb6ef9ffc50a3a93ef857ea42b104c0acfc49" translate="yes" xml:space="preserve">
          <source>we both use the value of &lt;code&gt;x&lt;/code&gt;, and modify it.</source>
          <target state="translated">ambos usamos el valor de &lt;code&gt;x&lt;/code&gt; y lo modificamos.</target>
        </trans-unit>
        <trans-unit id="26c3baa763591157c51a290b7c8be38622c3e920" translate="yes" xml:space="preserve">
          <source>we do not know whether &lt;code&gt;i++&lt;/code&gt; or &lt;code&gt;++i&lt;/code&gt; will be evaluated first. This is mainly to give the compiler &lt;a href=&quot;https://stackoverflow.com/a/12540468/1708801&quot;&gt;better options for optimization&lt;/a&gt;.</source>
          <target state="translated">no sabemos si &lt;code&gt;i++&lt;/code&gt; o &lt;code&gt;++i&lt;/code&gt; ser&amp;aacute;n evaluados primero. Esto es principalmente para dar al compilador &lt;a href=&quot;https://stackoverflow.com/a/12540468/1708801&quot;&gt;mejores opciones para la optimizaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb233158d14cbec62b14e57272c4bcc2a0ceed2f" translate="yes" xml:space="preserve">
          <source>what we're really saying is &quot;add 1 to i, and assign the result back to i, and assign the result back to i&quot;.  We're confused, so it doesn't bother me too much if the compiler gets confused, too.</source>
          <target state="translated">lo que realmente estamos diciendo es &quot;agregue 1 a i,y asigne el resultado de nuevo a i,y asigne el resultado de nuevo a i&quot;.Estamos confundidos,así que no me molesta demasiado si el compilador también se confunde.</target>
        </trans-unit>
        <trans-unit id="e22cbfb6c2ae366e16c7c6a3fd5d852b0ea277ba" translate="yes" xml:space="preserve">
          <source>which prints 7... the OP expected it to print 6.</source>
          <target state="translated">que imprime 7...la OP esperaba que imprimiera 6.</target>
        </trans-unit>
        <trans-unit id="0976677eed8a072a2d2ba8c68e6d46be04d02d10" translate="yes" xml:space="preserve">
          <source>while allowing</source>
          <target state="translated">mientras que permite</target>
        </trans-unit>
        <trans-unit id="7144af9b44794b287d95deb872a3d9bc96df4726" translate="yes" xml:space="preserve">
          <source>will not be a problem. But it invokes &lt;em&gt;undefined behaviour&lt;/em&gt; because the &lt;em&gt;comma&lt;/em&gt; here is a &lt;em&gt;separator&lt;/em&gt;.</source>
          <target state="translated">No ser&amp;aacute; un problema. Pero invoca &lt;em&gt;un comportamiento indefinido&lt;/em&gt; porque la &lt;em&gt;coma&lt;/em&gt; aqu&amp;iacute; es un &lt;em&gt;separador&lt;/em&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
