<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/7745609">
    <body>
      <group id="7745609">
        <trans-unit id="04c57be5b9e3b9472146536311d773ab598c075b" translate="yes" xml:space="preserve">
          <source>3.2    becomes    1003.201</source>
          <target state="translated">3,2 se convierte en 1003,201</target>
        </trans-unit>
        <trans-unit id="7ee9358b03aa8d5e6b7ff5f87ff1c6c61fa1840d" translate="yes" xml:space="preserve">
          <source>57     becomes    1057.001</source>
          <target state="translated">57 se convierte en 1057.001</target>
        </trans-unit>
        <trans-unit id="d7e7caf3da371e1159ed08c93e06650d3673a2aa" translate="yes" xml:space="preserve">
          <source>923.88 becomes    1923.881</source>
          <target state="translated">923,88 se convierte en 1923,881</target>
        </trans-unit>
        <trans-unit id="27f0e6e0472c758e2b2f6cf7c9816fcea152f9aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(SELECT *...)&lt;/code&gt; subquery : Return all people, sorted by Salary.</source>
          <target state="translated">&lt;code&gt;(SELECT *...)&lt;/code&gt; subconsulta: Devuelve todas las personas, ordenadas por Salario.</target>
        </trans-unit>
        <trans-unit id="4a3646e38f6b0d40250be24a8869360f600bf40d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FROM Employee&lt;/code&gt; : Table searched on.</source>
          <target state="translated">&lt;code&gt;FROM Employee&lt;/code&gt; : tabla buscada.</target>
        </trans-unit>
        <trans-unit id="51b27a498c28cb1978a214b508f3379f27cbf666" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GROUP BY Table1.id&lt;/code&gt;: Force the top-sorted, Salary row of each employee to be the returned result.</source>
          <target state="translated">&lt;code&gt;GROUP BY Table1.id&lt;/code&gt; : Forzar la fila de Salario de cada empleado para que sea el resultado devuelto.</target>
        </trans-unit>
        <trans-unit id="a1b951f0bc26d85d82b83ff57fc600c0fb43a981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GROUP BY employeesub.Salary&lt;/code&gt;: Force the top-sorted, Salary row of each employee to be the returned result.</source>
          <target state="translated">&lt;code&gt;GROUP BY employeesub.Salary&lt;/code&gt; : Obliga a la fila de Salario de cada empleado ordenada como el resultado devuelto.</target>
        </trans-unit>
        <trans-unit id="b108dac77b8b8d7940ca436cb584a45df60efc79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JOIN Table1 AS Table2 ON Table2.rev = Table1.rev&lt;/code&gt; : Join the second table on the first, because, we need to get the max(table1.rev)'s comment.</source>
          <target state="translated">&lt;code&gt;JOIN Table1 AS Table2 ON Table2.rev = Table1.rev&lt;/code&gt; : &amp;Uacute;nete a la segunda tabla en la primera, porque necesitamos obtener el comentario de max (table1.rev).</target>
        </trans-unit>
        <trans-unit id="5d64ca2c6f022a9050f895a8140f2d84845c927e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT *&lt;/code&gt; : Return all fields.</source>
          <target state="translated">&lt;code&gt;SELECT *&lt;/code&gt; : devuelve todos los campos.</target>
        </trans-unit>
        <trans-unit id="f1728fe7d07f6f81ae312d65bccb6428f5d4d2d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT DISTINCT Table1.id, max(Table1.rev), max(Table2.content)&lt;/code&gt; : Return &lt;code&gt;DISTINCT&lt;/code&gt; somefield, &lt;code&gt;MAX()&lt;/code&gt; some otherfield, the last &lt;code&gt;MAX()&lt;/code&gt; is redundant, because I know it's just one row, but it's required by the query.</source>
          <target state="translated">&lt;code&gt;SELECT DISTINCT Table1.id, max(Table1.rev), max(Table2.content)&lt;/code&gt; : Devuelve &lt;code&gt;DISTINCT&lt;/code&gt; somefield, &lt;code&gt;MAX()&lt;/code&gt; somefield, el &amp;uacute;ltimo &lt;code&gt;MAX()&lt;/code&gt; es redundante, porque s&amp;eacute; que es solo una fila, pero es requerido por la consulta.</target>
        </trans-unit>
        <trans-unit id="694f2b69df9ba4223789e351dba806643efc9f3c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&quot;Can you return me the records in this group of records (based on same id) that have the highest version number&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&quot;&amp;iquest;Puede devolverme los registros en este grupo de registros (basados ​​en la misma identificaci&amp;oacute;n) que tienen el n&amp;uacute;mero de versi&amp;oacute;n m&amp;aacute;s alto&quot;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="747dc8ef6e9397eda6d614ec751270837eb5d1cc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why is it clean?&lt;/em&gt;&lt;code&gt;DISTINCT()&lt;/code&gt;, &lt;code&gt;MAX()&lt;/code&gt;, etc., all make wonderful use of MySQL indices.  This will be faster.  Or, it will be much faster, if you have indexing, and you compare it to a query that looks at all rows.</source>
          <target state="translated">&lt;em&gt;&amp;iquest;Por qu&amp;eacute; est&amp;aacute; limpio?&lt;/em&gt; &lt;code&gt;DISTINCT()&lt;/code&gt; , &lt;code&gt;MAX()&lt;/code&gt; , etc., todos hacen un uso maravilloso de los &amp;iacute;ndices MySQL. Esto ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido O bien, ser&amp;aacute; mucho m&amp;aacute;s r&amp;aacute;pido si tiene indexaci&amp;oacute;n y lo compara con una consulta que examina todas las filas.</target>
        </trans-unit>
        <trans-unit id="ef6990676e8cbc396ebc34b6bbb2006bd98ee19c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;APPROACH&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;APPROACH&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f2f1d3f876ca275d587648c0854a40f7d75ceda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cleanest Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Soluci&amp;oacute;n m&amp;aacute;s limpia&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23eda03e232c7b276914d29d144368844246997f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; though this solution works for many people it may not be stable in the long run, since MySQL doesn't guarantee that GROUP BY statement will return meaningful values for columns not in GROUP BY list. So use this solution at your own risk!</source>
          <target state="translated">&lt;strong&gt;Editar:&lt;/strong&gt; aunque esta soluci&amp;oacute;n funciona para muchas personas, puede no ser estable a largo plazo, ya que MySQL no garantiza que la declaraci&amp;oacute;n GROUP BY devolver&amp;aacute; valores significativos para las columnas que no est&amp;aacute;n en la lista GROUP BY. &amp;iexcl;Utilice esta soluci&amp;oacute;n bajo su propio riesgo!</target>
        </trans-unit>
        <trans-unit id="403b25e1010d5c08346c35cf961dc40d8e1f56f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;GOOD STUFF&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;BUEN MATERIAL&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a9b0dfc8a396405726470595ea946d489db2ab7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOT mySQL&lt;/strong&gt;, but for other people finding this question and using SQL, another way to resolve the &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt; problem is using &lt;a href=&quot;http://technet.microsoft.com/en-us/library/ms175156(v=sql.105).aspx&quot;&gt;&lt;code&gt;Cross Apply&lt;/code&gt;&lt;/a&gt; in MS SQL</source>
          <target state="translated">&lt;strong&gt;NO mySQL&lt;/strong&gt; , pero para otras personas que encuentren esta pregunta y usen SQL, otra forma de resolver el &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;mayor problema de n-por-grupo&lt;/a&gt; es usar &lt;a href=&quot;http://technet.microsoft.com/en-us/library/ms175156(v=sql.105).aspx&quot;&gt; &lt;code&gt;Cross Apply&lt;/code&gt; &lt;/a&gt; en MS SQL</target>
        </trans-unit>
        <trans-unit id="59f292915a0a09f846bffdf80a1afb5aad2aa92f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Soluci&amp;oacute;n original&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c747eb526637be44701505482fa8cb37152fb689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please credit answer of user Bohemian&lt;/strong&gt; in &lt;a href=&quot;https://stackoverflow.com/questions/12102200/get-records-with-max-value-for-each-group-of-grouped-sql-results&quot;&gt;this question&lt;/a&gt; for providing such a concise and elegant answer to this problem.</source>
          <target state="translated">&lt;strong&gt;Por favor, acredite la respuesta del usuario Bohemian&lt;/strong&gt; en &lt;a href=&quot;https://stackoverflow.com/questions/12102200/get-records-with-max-value-for-each-group-of-grouped-sql-results&quot;&gt;esta pregunta&lt;/a&gt; por proporcionar una respuesta tan concisa y elegante a este problema.</target>
        </trans-unit>
        <trans-unit id="2add4d2b2581dbb1b5b57f680ba41943bb912e83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unique-Row Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Soluci&amp;oacute;n de fila &amp;uacute;nica&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e7ad05d289224982e0cbf5785062d94a875a509" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f68ee9c7511d534eda217dbc3387c2ea2bf2888d" translate="yes" xml:space="preserve">
          <source>A third solution I hardly ever see mentioned is MySQL specific and looks like this:</source>
          <target state="translated">Una tercera solución que casi nunca veo que se mencione es específica de MySQL y se ve así:</target>
        </trans-unit>
        <trans-unit id="0359601a6c3c733dad134b61901f5ac2843959e2" translate="yes" xml:space="preserve">
          <source>Added in SQL standard ANSI/ISO Standard SQL:2003  and later extended with ANSI/ISO Standard SQL:2008, window (or windowing) functions are available with all major vendors now. There are more types of rank functions available to deal with a tie issue: &lt;code&gt;RANK, DENSE_RANK, PERSENT_RANK&lt;/code&gt;.</source>
          <target state="translated">Agregado en el est&amp;aacute;ndar SQL ANSI / ISO est&amp;aacute;ndar SQL: 2003 y luego extendido con ANSI / ISO est&amp;aacute;ndar SQL: 2008, las funciones de ventana (o ventana) est&amp;aacute;n disponibles con todos los principales proveedores ahora. Hay m&amp;aacute;s tipos de funciones de clasificaci&amp;oacute;n disponibles para tratar un problema de empate: &lt;code&gt;RANK, DENSE_RANK, PERSENT_RANK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f6c5649c468f3c5b9f11dd0b6bb5bd2dcb42b60" translate="yes" xml:space="preserve">
          <source>All you need is a &lt;code&gt;GROUP BY&lt;/code&gt; clause with the &lt;code&gt;MAX&lt;/code&gt; aggregate function:</source>
          <target state="translated">Todo lo que necesita es una cl&amp;aacute;usula &lt;code&gt;GROUP BY&lt;/code&gt; con la funci&amp;oacute;n agregada &lt;code&gt;MAX&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f6746f8d362c92efc81f829dc623802dbc041661" translate="yes" xml:space="preserve">
          <source>Another manner to do the job is using &lt;code&gt;MAX()&lt;/code&gt; analytic function in OVER PARTITION clause</source>
          <target state="translated">Otra forma de hacer el trabajo es usar la funci&amp;oacute;n anal&amp;iacute;tica &lt;code&gt;MAX()&lt;/code&gt; en la cl&amp;aacute;usula OVER PARTITION</target>
        </trans-unit>
        <trans-unit id="2db20964a9cb8621f5afa10d678b2d245436b758" translate="yes" xml:space="preserve">
          <source>Anyway, the above doesn't directly work if your content field is already text. In that case you probably want to use a different separator, like \0 maybe. You'll also run into the &lt;code&gt;group_concat_max_len&lt;/code&gt; limit quicker.</source>
          <target state="translated">De todos modos, lo anterior no funciona directamente si su campo de contenido ya es texto. En ese caso, probablemente desee usar un separador diferente, como \ 0 quiz&amp;aacute;s. Tambi&amp;eacute;n te encontrar&amp;aacute;s con el l&amp;iacute;mite &lt;code&gt;group_concat_max_len&lt;/code&gt; m&amp;aacute;s r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="3dc54dc2faa3dd8f7aa080b02153c1129681f558" translate="yes" xml:space="preserve">
          <source>As the answers suggest, there &lt;em&gt;is&lt;/em&gt; a SQL solution, and &lt;a href=&quot;http://sqlfiddle.com/#!9/3d74dc/1&quot;&gt;here a sqlfiddle demo&lt;/a&gt;.</source>
          <target state="translated">Como sugieren las respuestas, hay una soluci&amp;oacute;n SQL, y &lt;a href=&quot;http://sqlfiddle.com/#!9/3d74dc/1&quot;&gt;aqu&amp;iacute; una demostraci&amp;oacute;n sqlfiddle&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18684a622d455407c3ef979634241c7c2b8bb5c1" translate="yes" xml:space="preserve">
          <source>At first glance...</source>
          <target state="translated">A primera vista...</target>
        </trans-unit>
        <trans-unit id="7d20eb576a5bf5c43a34a93487e4603496ff5cfd" translate="yes" xml:space="preserve">
          <source>Basically, you have two approaches to solve that problem:</source>
          <target state="translated">Básicamente,tienes dos enfoques para resolver ese problema:</target>
        </trans-unit>
        <trans-unit id="aff13b294275d46a1233bde52ba0a2304518a57e" translate="yes" xml:space="preserve">
          <source>Both approaches are SQL ANSI compatible, thus, will work with your favorite RDBMS, regardless of its &quot;flavor&quot;.</source>
          <target state="translated">Ambos enfoques son compatibles con SQL ANSI,por lo tanto,funcionará con su RDBMS favorito,independientemente de su &quot;sabor&quot;.</target>
        </trans-unit>
        <trans-unit id="a069f75e85cfd757d1237e33836f5a5c9a7933b8" translate="yes" xml:space="preserve">
          <source>Both approaches are also performance friendly, however your mileage may vary (RDBMS, DB Structure, Indexes, etc.). So when you pick one approach over the other, &lt;em&gt;benchmark&lt;/em&gt;. And make sure you pick the one which make most of sense to you.</source>
          <target state="translated">Ambos enfoques tambi&amp;eacute;n son amigables con el rendimiento, sin embargo, su kilometraje puede variar (RDBMS, Estructura de DB, &amp;Iacute;ndices, etc.). Entonces, cuando elige un enfoque sobre el otro, &lt;em&gt;punto de referencia&lt;/em&gt; . Y aseg&amp;uacute;rese de elegir el que tenga m&amp;aacute;s sentido para usted.</target>
        </trans-unit>
        <trans-unit id="19563c10db076085d9b0b4f5dba8b52984789ac2" translate="yes" xml:space="preserve">
          <source>Both approaches bring the exact same result.</source>
          <target state="translated">Ambos enfoques dan exactamente el mismo resultado.</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="573dbbd0ba5f01ad2edaf25718f8fd20afb0f654" translate="yes" xml:space="preserve">
          <source>Currently I use checks in the &lt;code&gt;while&lt;/code&gt; loop to detect and over-write old revs from the resultset. But is this the only method to achieve the result? Isn't there a &lt;strong&gt;SQL&lt;/strong&gt; solution?</source>
          <target state="translated">Actualmente utilizo verificaciones en el bucle while para detectar y sobreescribir revoluciones antiguas del conjunto de resultados. &amp;iquest;Pero es este el &amp;uacute;nico m&amp;eacute;todo para lograr el resultado? &amp;iquest;No hay una soluci&amp;oacute;n &lt;strong&gt;SQL&lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="3bedaf93cca4db2c2a031f628273b205d4c103de" translate="yes" xml:space="preserve">
          <source>DB Fiddle</source>
          <target state="translated">DB Fiddle</target>
        </trans-unit>
        <trans-unit id="af49ccd16ea8ee6847aa18e5e026d91269d1340a" translate="yes" xml:space="preserve">
          <source>Even so, we can simply select &lt;code&gt;DISTINCT&lt;/code&gt;&lt;em&gt;someuniquefield&lt;/em&gt;, &lt;code&gt;MAX(&lt;/code&gt;&lt;em&gt;whateverotherfieldtoselect&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt; *somethirdfield &lt;code&gt;)&lt;/code&gt;, etc., and have no worries understanding the result or how the query works :</source>
          <target state="translated">Aun as&amp;iacute;, simplemente podemos seleccionar &lt;code&gt;DISTINCT&lt;/code&gt; &lt;em&gt;someuniquefield&lt;/em&gt; , &lt;code&gt;MAX(&lt;/code&gt; &lt;em&gt;whateverotherfieldtoselect&lt;/em&gt; &lt;code&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;/code&gt; * somethirdfield &lt;code&gt;)&lt;/code&gt; , etc., y no nos preocupamos de comprender el resultado o c&amp;oacute;mo funciona la consulta:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="000d91fadfba91936529d79d0821bb7195a90ba6" translate="yes" xml:space="preserve">
          <source>Following are comparisons to the solutions in @AdrianCarneiro's answer (subquery, leftjoin), based on MySQL measurements with InnoDB table of ~1million records, group size being: 1-3.</source>
          <target state="translated">A continuación se comparan las soluciones de la respuesta de @AdrianCarneiro (subconsulta,izquierda),basadas en las mediciones de MySQL con la tabla InnoDB de ~1 millón de registros,siendo el tamaño del grupo:1-3.</target>
        </trans-unit>
        <trans-unit id="995071277e83cf1d1f1c4a8ccb804e62ea4b68dd" translate="yes" xml:space="preserve">
          <source>Having an index on (id,rev) renders the subquery almost as a simple lookup...</source>
          <target state="translated">Tener un índice en (id,rev)hace que la subconsulta sea casi como una simple búsqueda...</target>
        </trans-unit>
        <trans-unit id="314d916008f70bef56e0b0d15d12dfe541cea6a1" translate="yes" xml:space="preserve">
          <source>Here is a nice way of doing that</source>
          <target state="translated">Esta es una buena manera de hacerlo</target>
        </trans-unit>
        <trans-unit id="471fa8e0858c0f841233c444b4700b23aee1ab66" translate="yes" xml:space="preserve">
          <source>Here's an example in SqlFiddle</source>
          <target state="translated">Aquí hay un ejemplo en SqlFiddle</target>
        </trans-unit>
        <trans-unit id="9164d1faed37c4623fd975150fe3872405f41423" translate="yes" xml:space="preserve">
          <source>Here's another solution to retrieving the records only with a field that has the maximum value for that field. This works for SQL400 which is the platform I work on. In this example, the records with the maximum value in field FIELD5 will be retrieved by the following SQL statement.</source>
          <target state="translated">He aquí otra solución para recuperar los registros sólo con un campo que tenga el valor máximo para ese campo.Esto funciona para SQL400 que es la plataforma en la que trabajo.En este ejemplo,los registros con el valor máximo en el campo FIELD5 serán recuperados por la siguiente sentencia SQL.</target>
        </trans-unit>
        <trans-unit id="a6f33200f27d1f02a32897ce39b81c9ee560e6d6" translate="yes" xml:space="preserve">
          <source>Here's how it looks with the above example, written in SQL</source>
          <target state="translated">Así es como se ve con el ejemplo anterior,escrito en SQL</target>
        </trans-unit>
        <trans-unit id="9e3a68cc958a74ba34c6bcb6c78f492a33cda5ba" translate="yes" xml:space="preserve">
          <source>Hopefully this is a solution that solves the problem and helps everyone better understand what's happening in the DB.</source>
          <target state="translated">Esperemos que esta sea una solución que resuelva el problema y ayude a todo el mundo a entender mejor lo que está pasando en la DB.</target>
        </trans-unit>
        <trans-unit id="17aca0cf466b23a9d66f040adc39824d44c21641" translate="yes" xml:space="preserve">
          <source>How about this:</source>
          <target state="translated">Qué tal esto:</target>
        </trans-unit>
        <trans-unit id="10913cb8e1a0c820785850e0e7d418afaaf3b084" translate="yes" xml:space="preserve">
          <source>How do I select one row per id and only the greatest rev?</source>
          <target state="translated">¿Cómo selecciono una fila por identificación y sólo la mayor de las revoluciones?</target>
        </trans-unit>
        <trans-unit id="19cbcd14e6b2211943bc8ae571c9613a49c99e92" translate="yes" xml:space="preserve">
          <source>I am flabbergasted that no answer offered SQL window function solution:</source>
          <target state="translated">Estoy atónito de que ninguna respuesta ofrezca la solución de la función de la ventana SQL:</target>
        </trans-unit>
        <trans-unit id="c63f6bb578d3ae9db96662ba13e29dc33c243f8f" translate="yes" xml:space="preserve">
          <source>I came here looking for SQLAlchemy help, so I will duplicate Adrian Carneiro's answer with the python/SQLAlchemy version, specifically the outer join part.</source>
          <target state="translated">Vine aquí buscando la ayuda de SQLAlchemy,así que duplicaré la respuesta de Adrian Carneiro con la versión de pythonSQLAlchemy,específicamente la parte exterior de la unión.</target>
        </trans-unit>
        <trans-unit id="c10b9ffc525b97bcbece3250c202bd16cad8beb3" translate="yes" xml:space="preserve">
          <source>I can't vouch for the performance, but here's a trick inspired by the limitations of Microsoft Excel.  It has some good features</source>
          <target state="translated">No puedo responder por la actuación,pero aquí hay un truco inspirado en las limitaciones de Microsoft Excel.Tiene algunas buenas características</target>
        </trans-unit>
        <trans-unit id="67a7d23c38d29857f72aac73ca9af605f944a2d1" translate="yes" xml:space="preserve">
          <source>I have this table for documents (simplified version here):</source>
          <target state="translated">Tengo esta tabla de documentos (versión simplificada aquí):</target>
        </trans-unit>
        <trans-unit id="d582544f0807601e4b6511e7bdec729115bf914b" translate="yes" xml:space="preserve">
          <source>I just noticed you need the &lt;code&gt;content&lt;/code&gt; column as well.</source>
          <target state="translated">Acabo de notar que tambi&amp;eacute;n necesitas la columna de &lt;code&gt;content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8dfea75f00120de3d7deedb3de7608fd0c28237" translate="yes" xml:space="preserve">
          <source>I like to do this by ranking the records by some column. In this case, rank &lt;code&gt;rev&lt;/code&gt; values grouped by &lt;code&gt;id&lt;/code&gt;. Those with higher &lt;code&gt;rev&lt;/code&gt; will have lower rankings. So highest &lt;code&gt;rev&lt;/code&gt; will have ranking of 1.</source>
          <target state="translated">Me gusta hacer esto clasificando los registros por alguna columna. En este caso, clasifique los valores de &lt;code&gt;rev&lt;/code&gt; oluciones agrupados por &lt;code&gt;id&lt;/code&gt; . Aquellos con mayores &lt;code&gt;rev&lt;/code&gt; oluciones tendr&amp;aacute;n clasificaciones m&amp;aacute;s bajas. Por lo tanto, las &lt;code&gt;rev&lt;/code&gt; oluciones m&amp;aacute;s altas tendr&amp;aacute;n una clasificaci&amp;oacute;n de 1.</target>
        </trans-unit>
        <trans-unit id="33448d590cc783d19b7e088f10f0cc5625c1e617" translate="yes" xml:space="preserve">
          <source>I like to use a &lt;code&gt;NOT EXIST&lt;/code&gt;-based solution for this problem:</source>
          <target state="translated">Me gusta usar una soluci&amp;oacute;n basada en &lt;code&gt;NOT EXIST&lt;/code&gt; para este problema:</target>
        </trans-unit>
        <trans-unit id="3a69c1874c939239de03ecc1482256501bce00b2" translate="yes" xml:space="preserve">
          <source>I noticed after adding the above &lt;em&gt;sqlfiddle&lt;/em&gt;, the rate at which the question is upvoted has surpassed the upvote rate of the answers. That has not been the intention! The fiddle is based on the answers, especially the accepted answer.</source>
          <target state="translated">Not&amp;eacute; que despu&amp;eacute;s de agregar el &lt;em&gt;sqlfiddle&lt;/em&gt; anterior, la tasa a la que se vota la pregunta ha superado la tasa de voto positivo de las respuestas. &amp;iexcl;Esa no ha sido la intenci&amp;oacute;n! El viol&amp;iacute;n se basa en las respuestas, especialmente la respuesta aceptada.</target>
        </trans-unit>
        <trans-unit id="31b46e90abba135e2e191919836bd8d723638c3d" translate="yes" xml:space="preserve">
          <source>I then joined these max values (#temp1) to all of the possible id/content combinations. By doing this, I naturally filter out the non-maximum id/content combinations, and am left with the only max rev values for each.</source>
          <target state="translated">Luego uní estos valores máximos (#temp1)a todas las combinaciones posibles de idcontentos.Al hacer esto,naturalmente filtro las combinaciones de idcontentos no máximos,y me quedo con los únicos valores máximos de revoluciones para cada uno.</target>
        </trans-unit>
        <trans-unit id="eedb27620fc870cd05408ec33312da837f122366" translate="yes" xml:space="preserve">
          <source>I think, You want this?</source>
          <target state="translated">Creo que,¿quieres esto?</target>
        </trans-unit>
        <trans-unit id="475f1dbf29984af602be998bcf11558846a40db9" translate="yes" xml:space="preserve">
          <source>I used the below to solve a problem of my own. I first created a temp table and inserted the max rev value per unique id.</source>
          <target state="translated">Utilicé lo siguiente para resolver un problema propio.Primero creé una tabla temporal e inserté el valor máximo de revoluciones por identificación única.</target>
        </trans-unit>
        <trans-unit id="90195caa2158153b6d15ffbd881bc0002f84edd8" translate="yes" xml:space="preserve">
          <source>I would use this:</source>
          <target state="translated">Yo usaría esto:</target>
        </trans-unit>
        <trans-unit id="91840954cb9c4ea1b61596b1a83ee83e2ea511b0" translate="yes" xml:space="preserve">
          <source>I wouldn't use IN clause (as it is mentioned somewhere above). IN is given to use with short lists of constans, and not as to be the query filter built on subquery. It is because subquery in IN is performed for every scanned record which can made query taking very loooong time.</source>
          <target state="translated">Yo no usaría la cláusula IN (como se menciona en algún lugar arriba).IN se da para usar con listas cortas de constantes,y no como el filtro de consulta construido sobre la subconsulta.Es porque la subconsulta en IN se realiza para cada registro escaneado que puede hacer la consulta tomando mucho tiempo.</target>
        </trans-unit>
        <trans-unit id="fb74c49395db7bba931e909d22e83547acbf985a" translate="yes" xml:space="preserve">
          <source>If you do it right, string comparison of two numbers should yield the same &quot;max&quot; as numeric comparison of the two numbers and it's easy to convert back to the original number using the substring function (which is available in one form or another pretty much everywhere).</source>
          <target state="translated">Si se hace bien,la comparación de cadenas de dos números debería dar el mismo &quot;máximo&quot; que la comparación numérica de los dos números y es fácil volver a convertir al número original utilizando la función de subcadena (que está disponible de una forma u otra prácticamente en todas partes).</target>
        </trans-unit>
        <trans-unit id="cd760119a0c1ae1b56d494acb1a10a8a2ca548fe" translate="yes" xml:space="preserve">
          <source>If you have many fields in select statement and you want latest  value for all of those fields through optimized code:</source>
          <target state="translated">Si tienes muchos campos en la declaración de selección y quieres el último valor para todos esos campos a través de un código optimizado:</target>
        </trans-unit>
        <trans-unit id="ee8b53705cdf9b09c80c28fb4dd6809e10ff922e" translate="yes" xml:space="preserve">
          <source>If you have two rows with &lt;code&gt;max-value-in-group&lt;/code&gt; for &lt;code&gt;group-identifier&lt;/code&gt;, both rows will be in the result in both approaches.</source>
          <target state="translated">Si tiene dos filas con &lt;code&gt;max-value-in-group&lt;/code&gt; para &lt;code&gt;group-identifier&lt;/code&gt; , ambas filas estar&amp;aacute;n en el resultado en ambos enfoques.</target>
        </trans-unit>
        <trans-unit id="d387732b9dd594cea09224c99e2e3db7eda6d1c9" translate="yes" xml:space="preserve">
          <source>In this approach, you first find the &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; (already solved above) in a sub-query. Then you join your table to the sub-query with equality on both &lt;code&gt;group-identifier&lt;/code&gt; and &lt;code&gt;max-value-in-group&lt;/code&gt;:</source>
          <target state="translated">En este enfoque, primero encuentra el &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; (ya resuelto anteriormente) en una subconsulta. Luego, une su tabla a la subconsulta con igualdad tanto &lt;code&gt;group-identifier&lt;/code&gt; como &lt;code&gt;max-value-in-group&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0e261b8d5be6a8e3499be83152da6b96e488a4fc" translate="yes" xml:space="preserve">
          <source>In this approach, you left join the table with itself. Equality goes in the &lt;code&gt;group-identifier&lt;/code&gt;. Then, 2 smart moves:</source>
          <target state="translated">En este enfoque, dej&amp;oacute; unirse a la tabla consigo mismo. La igualdad va en el &lt;code&gt;group-identifier&lt;/code&gt; . Luego, 2 movimientos inteligentes:</target>
        </trans-unit>
        <trans-unit id="4b8e5c4e8addfc03069074421a8e679d4db14df8" translate="yes" xml:space="preserve">
          <source>It doesn't require a join</source>
          <target state="translated">No requiere una unión</target>
        </trans-unit>
        <trans-unit id="ee669ad8ba2e0f5f2ee33e7468179e58169574b2" translate="yes" xml:space="preserve">
          <source>It is a little bit ugly and requires that you know something about the range of valid values of the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column.  Let us assume that we know the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column is a number between 0.00 and 999 including decimals but that there will only ever be two digits to the right of the decimal point (e.g. 34.17 would be a valid value).</source>
          <target state="translated">Es un poco feo y requiere que sepas algo sobre el rango de valores v&amp;aacute;lidos de la columna &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; . Supongamos que sabemos que la columna &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; es un n&amp;uacute;mero entre 0.00 y 999 que incluye decimales, pero que solo habr&amp;aacute; dos d&amp;iacute;gitos a la derecha del punto decimal (por ejemplo, 34.17 ser&amp;iacute;a un valor v&amp;aacute;lido).</target>
        </trans-unit>
        <trans-unit id="d052da643334c91fbd79130f435ea2036f8d231e" translate="yes" xml:space="preserve">
          <source>It is asked on tables having teens thusands of records, and it takes less then 0,01 second on really not too strong machine.</source>
          <target state="translated">Se pregunta en las mesas que tienen adolescentes así como en los registros,y toma menos de 0,01 segundos en una máquina realmente no muy fuerte.</target>
        </trans-unit>
        <trans-unit id="58fd729f1264da5befb4f9b9d51e8f280f1269ec" translate="yes" xml:space="preserve">
          <source>It is, actually, so common that StackOverflow community has created a single tag just to deal with questions like that: &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt;.</source>
          <target state="translated">En realidad, es tan com&amp;uacute;n que la comunidad StackOverflow ha creado una sola etiqueta solo para tratar preguntas como esa: &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;great-n-per-group&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d0650392a80d6352d1134ecbd14115eaa3db77a" translate="yes" xml:space="preserve">
          <source>It looks like there is simpler way to do this (but &lt;strong&gt;only in MySQL&lt;/strong&gt;):</source>
          <target state="translated">Parece que hay una manera m&amp;aacute;s simple de hacer esto (pero &lt;strong&gt;solo en MySQL&lt;/strong&gt; ):</target>
        </trans-unit>
        <trans-unit id="452d3ec3e5e3af71a122522390dfdc81b35a82a8" translate="yes" xml:space="preserve">
          <source>It should force return of only one &quot;max record&quot; even if there is a tie (sometimes useful)</source>
          <target state="translated">Debe forzar el retorno de un solo &quot;registro máximo&quot; incluso si hay un empate (a veces útil)</target>
        </trans-unit>
        <trans-unit id="4d2d5d921b83099b6badb0edcc209baf412da434" translate="yes" xml:space="preserve">
          <source>It's never that simple, is it?</source>
          <target state="translated">Nunca es tan simple,¿verdad?</target>
        </trans-unit>
        <trans-unit id="11aed3f58968adfc7e701f0ecba96fda74515ce8" translate="yes" xml:space="preserve">
          <source>Joining with simple &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; Sub-query</source>
          <target state="translated">Unirse con un simple &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="460920821f4309de220f91dcb815a79c7b3c9156" translate="yes" xml:space="preserve">
          <source>Left Joining with self, tweaking join conditions and filters</source>
          <target state="translated">Izquierda Uniéndose con uno mismo,ajustando las condiciones de la unión y los filtros</target>
        </trans-unit>
        <trans-unit id="31d0f030330e9a305782ce8d95a2c9b90fec6b29" translate="yes" xml:space="preserve">
          <source>MAX() solution runs certainly FASTER that &lt;code&gt;ROW_NUMBER()&lt;/code&gt; solution because &lt;code&gt;MAX()&lt;/code&gt; complexity is &lt;code&gt;O(n)&lt;/code&gt; while &lt;code&gt;ROW_NUMBER()&lt;/code&gt; complexity is at minimum &lt;code&gt;O(n.log(n))&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; represent the number of records in table !</source>
          <target state="translated">La soluci&amp;oacute;n MAX () se ejecuta sin duda M&amp;Aacute;S &lt;code&gt;ROW_NUMBER()&lt;/code&gt; que la soluci&amp;oacute;n ROW_NUMBER () porque la complejidad &lt;code&gt;MAX()&lt;/code&gt; es &lt;code&gt;O(n)&lt;/code&gt; mientras que la complejidad &lt;code&gt;ROW_NUMBER()&lt;/code&gt; es m&amp;iacute;nima &lt;code&gt;O(n.log(n))&lt;/code&gt; donde &lt;code&gt;n&lt;/code&gt; representa el n&amp;uacute;mero de registros en la tabla.</target>
        </trans-unit>
        <trans-unit id="f784dda051b71346905b94e12f1c6ce43f3e7fb7" translate="yes" xml:space="preserve">
          <source>My preference is to use as little code as possible...</source>
          <target state="translated">Mi preferencia es usar el menor código posible...</target>
        </trans-unit>
        <trans-unit id="460b741c73cbd00e64b87f5e4e2284a80c063282" translate="yes" xml:space="preserve">
          <source>Newer versions of MySQL come with &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; enabled by default, and many of the solutions here will &lt;em&gt;fail&lt;/em&gt; in testing with this condition.</source>
          <target state="translated">Las versiones m&amp;aacute;s recientes de MySQL vienen con &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; habilitado de forma predeterminada, y muchas de las soluciones aqu&amp;iacute; &lt;em&gt;fallar&amp;aacute;n&lt;/em&gt; en las pruebas con esta condici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dd15a32e927c00c615558f8c6498a2cdc048de59" translate="yes" xml:space="preserve">
          <source>None of these answers have worked for me.</source>
          <target state="translated">Ninguna de estas respuestas me ha funcionado.</target>
        </trans-unit>
        <trans-unit id="2735d006f0f78c77077d2a8f7b369c24f3a71501" translate="yes" xml:space="preserve">
          <source>Not sure if introducing variables makes the whole thing slower. But at least I'm not querying &lt;code&gt;YOURTABLE&lt;/code&gt; twice.</source>
          <target state="translated">No estoy seguro si la introducci&amp;oacute;n de variables hace que todo sea m&amp;aacute;s lento. Pero al menos no estoy consultando &lt;code&gt;YOURTABLE&lt;/code&gt; dos veces.</target>
        </trans-unit>
        <trans-unit id="87119c137f4237ae2ffed9b612a2cd3bc86e9351" translate="yes" xml:space="preserve">
          <source>Note that since &quot;content&quot; was &quot;...&quot; in OP's question, there's no way to test that this works.  So, I changed that to &quot;..a&quot;, &quot;..b&quot;, so, we can actually now see that the results are correct:</source>
          <target state="translated">Tenga en cuenta que como &quot;contenido&quot; era &quot;...&quot; en la pregunta de OP,no hay manera de probar que esto funciona.Por lo tanto,cambié eso a &quot;...a&quot;,&quot;...b&quot;,así que,ahora podemos ver que los resultados son correctos:</target>
        </trans-unit>
        <trans-unit id="0fcce481af6c969086f7a3a5178c3e328716610a" translate="yes" xml:space="preserve">
          <source>Note the &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database&quot;&gt;Definition of a Relational Database&lt;/a&gt;: &quot;Each row in a table has its own unique key.&quot;  This would mean that, in the question's example, id would &lt;em&gt;have to be&lt;/em&gt; unique, and in that case, we can just do :</source>
          <target state="translated">Tenga en cuenta la &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database&quot;&gt;definici&amp;oacute;n de una base de datos relacional&lt;/a&gt; : &quot;Cada fila de una tabla tiene su propia clave &amp;uacute;nica&quot;. Esto significar&amp;iacute;a que, en el ejemplo de la pregunta, la identificaci&amp;oacute;n tendr&amp;iacute;a &lt;em&gt;que ser&lt;/em&gt; &amp;uacute;nica y, en ese caso, podemos hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="cd37664721ce22baa58bcd661cd5cbf26ebc9693" translate="yes" xml:space="preserve">
          <source>One final note, as leftjoin creates n*(n+1)/2 joins in groups, its performance can be heavily affected by the size of groups...</source>
          <target state="translated">Una nota final,como leftjoin crea n*(n+1)2 se une en grupos,su rendimiento puede ser muy afectado por el tamaño de los grupos...</target>
        </trans-unit>
        <trans-unit id="5d6a717a9edad23dd4bea1b698581b82bc5a20e9" translate="yes" xml:space="preserve">
          <source>One important thing is that GROUP_CONCAT has a maximum length for the string it can build up. You probably want to raise this limit by setting the &lt;code&gt;group_concat_max_len&lt;/code&gt; variable. And keep in mind that this will be a limit on scaling if you have a large number of rows.</source>
          <target state="translated">Una cosa importante es que GROUP_CONCAT tiene una longitud m&amp;aacute;xima para la cadena que puede construir. Probablemente quiera aumentar este l&amp;iacute;mite configurando la variable &lt;code&gt;group_concat_max_len&lt;/code&gt; . Y tenga en cuenta que esto ser&amp;aacute; un l&amp;iacute;mite en la escala si tiene una gran cantidad de filas.</target>
        </trans-unit>
        <trans-unit id="91c7270a2e10bd5cc0fdda4e69065666aee3c4f2" translate="yes" xml:space="preserve">
          <source>SQL Fiddle :
&lt;a href=&quot;http://sqlfiddle.com/#!9/a6c585/82473/0&quot;&gt;Check here&lt;/a&gt;</source>
          <target state="translated">SQL Fiddle: &lt;a href=&quot;http://sqlfiddle.com/#!9/a6c585/82473/0&quot;&gt;Marque aqu&amp;iacute;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4fdc1b974c1790e82135708cc7cfea1d1ffb439b" translate="yes" xml:space="preserve">
          <source>SQL select only rows with max value on a column</source>
          <target state="translated">SQL seleccionar sólo las filas con el valor máximo en una columna</target>
        </trans-unit>
        <trans-unit id="3b76449895ac57983b7b2b65399182f3103db7fa" translate="yes" xml:space="preserve">
          <source>Since this is most popular question with regard to this problem, I'll re-post another answer to it here as well:</source>
          <target state="translated">Como esta es la pregunta más popular con respecto a este problema,volveré a poner otra respuesta aquí también:</target>
        </trans-unit>
        <trans-unit id="d00e076b8322dcd61d6eb23264c22bf08e04282e" translate="yes" xml:space="preserve">
          <source>So you end up with:</source>
          <target state="translated">Así que terminas con:</target>
        </trans-unit>
        <trans-unit id="94f01ead7218d9d39d0a9e5560ffc936f4a0187b" translate="yes" xml:space="preserve">
          <source>Something like this?</source>
          <target state="translated">¿Algo como esto?</target>
        </trans-unit>
        <trans-unit id="fcea27228c354bcef2642a5bc557c693423693fc" translate="yes" xml:space="preserve">
          <source>Sorted the rev field in reverse order and then grouped by id which gave the first row of each grouping which is the one with the highest rev value.</source>
          <target state="translated">Ordenó el campo de revoluciones en orden inverso y luego agrupó por id que dio la primera fila de cada agrupación que es la que tiene el valor de revoluciones más alto.</target>
        </trans-unit>
        <trans-unit id="6a3870fad3df63029f67f8ef1f65f56e452059d7" translate="yes" xml:space="preserve">
          <source>Subquery SELECT is not too eficient maybe, but in JOIN clause seems to be usable. I'm not an expert in optimizing queries, but I've tried at MySQL, PostgreSQL, FireBird and it does work very good.</source>
          <target state="translated">La subconsulta SELECCIÓN no es demasiado eficiente,pero en la cláusula de JOIN parece ser utilizable.No soy experto en optimizar consultas,pero he probado en MySQL,PostgreSQL,FireBird y funciona muy bien.</target>
        </trans-unit>
        <trans-unit id="5dc7723780e3da28e4fb6d9bc359f0075239e170" translate="yes" xml:space="preserve">
          <source>Tested in &lt;a href=&quot;http://sqlfiddle.com/&quot;&gt;http://sqlfiddle.com/&lt;/a&gt; with the following data</source>
          <target state="translated">Probado en &lt;a href=&quot;http://sqlfiddle.com/&quot;&gt;http://sqlfiddle.com/&lt;/a&gt; con los siguientes datos</target>
        </trans-unit>
        <trans-unit id="94226523059a44fd6d0823e04d1320c06cbf47ec" translate="yes" xml:space="preserve">
          <source>Tested on a PostgreSQL database.</source>
          <target state="translated">Probado en una base de datos PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="b3309e51317016b3d5b0a251f24e195795b03f73" translate="yes" xml:space="preserve">
          <source>The above combination is simple with bit functions when &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; are &lt;code&gt;INT UNSIGNED&lt;/code&gt; (32 bit) and combined value fits to &lt;code&gt;BIGINT UNSIGNED&lt;/code&gt; (64 bit). When the &lt;code&gt;id&lt;/code&gt; &amp;amp; &lt;code&gt;rev&lt;/code&gt; are larger than 32-bit values or made of multiple columns, you need combine the value into e.g. a binary value with suitable padding for &lt;code&gt;MAX()&lt;/code&gt;.</source>
          <target state="translated">La combinaci&amp;oacute;n anterior es simple con funciones de bit cuando &lt;code&gt;rev&lt;/code&gt; e &lt;code&gt;id&lt;/code&gt; son &lt;code&gt;INT UNSIGNED&lt;/code&gt; (32 bit) y el valor combinado se ajusta a &lt;code&gt;BIGINT UNSIGNED&lt;/code&gt; (64 bit). Cuando el &lt;code&gt;id&lt;/code&gt; y &lt;code&gt;rev&lt;/code&gt; son mayores que los valores de 32 bits o est&amp;aacute;n formados por varias columnas, debe combinar el valor en, por ejemplo, un valor binario con un relleno adecuado para &lt;code&gt;MAX()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd706fecc71dd4b48d2d2b09b1613cf3d0b105e" translate="yes" xml:space="preserve">
          <source>The gist of the thing is that you create a single synthetic column by string concatenating/packing the primary comparison field along with the data you want.  In this way, you can force SQL's MAX() aggregate function to return all of the data (because it has been packed into a single column).  Then you have to unpack the data.</source>
          <target state="translated">Lo esencial es que se crea una sola columna sintética por cadena concatenando el campo de comparación primaria junto con los datos que se desean.De esta manera,puede forzar la función de agregación MAX()de SQL para que devuelva todos los datos (porque se ha empaquetado en una sola columna).Luego tiene que desempaquetar los datos.</target>
        </trans-unit>
        <trans-unit id="00ab94e8e1f472a0caf4245bb6004e0fd4761b29" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;ROW_NUMBER()&lt;/code&gt; OVER PARTITION solution already documented in this post is</source>
          <target state="translated">La otra &lt;code&gt;ROW_NUMBER()&lt;/code&gt; OVER PARTITION ya documentada en esta publicaci&amp;oacute;n es</target>
        </trans-unit>
        <trans-unit id="33daa53cf1139c305a3e6de8aaaf4c6d74e63949" translate="yes" xml:space="preserve">
          <source>The packing begins by forcing the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column to be a number of known character length regardless of the value of &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; so that for example</source>
          <target state="translated">El empaque comienza forzando a la columna de &lt;strong&gt;&lt;em&gt;revoluciones&lt;/em&gt;&lt;/strong&gt; a que tenga una longitud de caracteres conocida independientemente del valor de &lt;strong&gt;&lt;em&gt;revoluciones,&lt;/em&gt;&lt;/strong&gt; por ejemplo</target>
        </trans-unit>
        <trans-unit id="8f02bdcb5aaad48ff64e99bf617a644fa990ddcf" translate="yes" xml:space="preserve">
          <source>The second join condition is having left side value less than right value</source>
          <target state="translated">La segunda condición de unión es tener el valor del lado izquierdo menos que el valor del derecho</target>
        </trans-unit>
        <trans-unit id="0bbc6aadc07a842d6fc9d1f88ded92b6a1b29149" translate="yes" xml:space="preserve">
          <source>This 2 SELECT work well on Oracle 10g.</source>
          <target state="translated">Este 2 SELECT funciona bien en Oracle 10g.</target>
        </trans-unit>
        <trans-unit id="8c0d4d65d2b2336eff8eda436b0051d18840475e" translate="yes" xml:space="preserve">
          <source>This allows me to duplicate the record, update it, increment its version number, and have the copy of the old version in such a way that I can show change over time.</source>
          <target state="translated">Esto me permite duplicar el registro,actualizarlo,incrementar su número de versión,y tener la copia de la versión antigua de tal manera que pueda mostrar el cambio con el tiempo.</target>
        </trans-unit>
        <trans-unit id="2301e8326e919ecb8afe49e6e514de6a09cce684" translate="yes" xml:space="preserve">
          <source>This gave the following result in MySql 5.5 and 5.6</source>
          <target state="translated">Esto dio el siguiente resultado en MySql 5.5 y 5.6</target>
        </trans-unit>
        <trans-unit id="887c512cd9ff837fd1c9fc4808909508ea838546" translate="yes" xml:space="preserve">
          <source>This is a very common question in SQL: find the whole data for the row with some max value in a column per some group identifier. I heard that a lot during my career. Actually, it was one the questions I answered in my current job's technical interview.</source>
          <target state="translated">Esta es una pregunta muy común en SQL:encontrar todos los datos de la fila con algún valor máximo en una columna por algún identificador de grupo.Escuché mucho eso durante mi carrera.En realidad,fue una de las preguntas que respondí en la entrevista técnica de mi actual trabajo.</target>
        </trans-unit>
        <trans-unit id="ee5febc8aebb31700d3b2dcee3dd28e23632667e" translate="yes" xml:space="preserve">
          <source>This is especially fast when there is a complex join instead of a single table. With the traditional approaches the complex join would be done twice.</source>
          <target state="translated">Esto es especialmente rápido cuando hay una unión compleja en lugar de una sola mesa.Con los enfoques tradicionales la unión compleja se haría dos veces.</target>
        </trans-unit>
        <trans-unit id="bf4b0ede672dafca43e39e677b31d17ea3f43666" translate="yes" xml:space="preserve">
          <source>This is not pure SQL. This will use the SQLAlchemy ORM.</source>
          <target state="translated">Esto no es puro SQL.Esto usará el SQLAlchemy ORM.</target>
        </trans-unit>
        <trans-unit id="e525543a18c8b2f059c99fd1eafb0e14a4a32dc4" translate="yes" xml:space="preserve">
          <source>This is what worked for me.</source>
          <target state="translated">Esto es lo que funcionó para mí.</target>
        </trans-unit>
        <trans-unit id="0b48e75dada78a122caea17e73852eaaddb6181b" translate="yes" xml:space="preserve">
          <source>This query answers the question of:</source>
          <target state="translated">Esta pregunta responde a la pregunta de:</target>
        </trans-unit>
        <trans-unit id="59b379b84cff9d86d45433e27b3a690e1bbc3911" translate="yes" xml:space="preserve">
          <source>This solution makes only one selection from YourTable, therefore it's faster. It works only for MySQL and SQLite(for SQLite remove DESC) according to test on sqlfiddle.com. Maybe it can be tweaked to work on other languages which I am not familiar with.</source>
          <target state="translated">Esta solución sólo hace una selección de YourTable,por lo tanto es más rápida.Funciona sólo para MySQL y SQLite (para SQLite eliminar DESC)según el test de sqlfiddle.com.Tal vez pueda ser ajustado para que funcione en otros lenguajes con los que no estoy familiarizado.</target>
        </trans-unit>
        <trans-unit id="922fda0f734f15029de1e6477a7c86dcb4d18c7c" translate="yes" xml:space="preserve">
          <source>This will select all records with max value within the group and allows you to select other columns.</source>
          <target state="translated">Esto seleccionará todos los registros con valor máximo dentro del grupo y le permitirá seleccionar otras columnas.</target>
        </trans-unit>
        <trans-unit id="66639bc2c3849de3b1308222ecb4a4eb01a37f90" translate="yes" xml:space="preserve">
          <source>Use following code :</source>
          <target state="translated">Use el siguiente código:</target>
        </trans-unit>
        <trans-unit id="1d992c7af6b12bdffa0c4708f603e830d452ab3a" translate="yes" xml:space="preserve">
          <source>When you do step 1, the row(s) that actually have the max value will have &lt;code&gt;NULL&lt;/code&gt; in the right side (it's a &lt;code&gt;LEFT JOIN&lt;/code&gt;, remember?). Then, we filter the joined result, showing only the rows where the right side is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Cuando realice el paso 1, la (s) fila (s) que realmente tienen el valor m&amp;aacute;ximo tendr&amp;aacute; &lt;code&gt;NULL&lt;/code&gt; en el lado derecho (es una &lt;code&gt;LEFT JOIN&lt;/code&gt; , &amp;iquest;recuerda?). Luego, filtramos el resultado unido, mostrando solo las filas donde el lado derecho es &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9f5100d135261032402eee1426608998aac7beb" translate="yes" xml:space="preserve">
          <source>While for full table scans subquery/leftjoin/correlated timings relate to each other as 6/8/9, when it comes to direct lookups or batch (&lt;code&gt;id in (1,2,3)&lt;/code&gt;), subquery is much slower then the others (Due to rerunning the subquery). However I couldnt differentiate between leftjoin and correlated solutions in speed.</source>
          <target state="translated">Mientras que para los escaneos de tablas completas, los tiempos de subconsulta / leftjoin / correlacionados se relacionan entre s&amp;iacute; como 6/8/9, cuando se trata de b&amp;uacute;squedas directas o por lotes ( &lt;code&gt;id in (1,2,3)&lt;/code&gt; ), la subconsulta es mucho m&amp;aacute;s lenta que las dem&amp;aacute;s ( Debido a volver a ejecutar la subconsulta). Sin embargo, no pude diferenciar entre soluciones leftjoin y correlacionadas en velocidad.</target>
        </trans-unit>
        <trans-unit id="59c4f1cbf0a942eb4eb3e4a90d93e9070d57b26d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; disabled, we can use still use &lt;code&gt;GROUP BY&lt;/code&gt;, but then we are only using it on the Salary, and not the id:</source>
          <target state="translated">Con &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; deshabilitado, todav&amp;iacute;a podemos usar &lt;code&gt;GROUP BY&lt;/code&gt; , pero solo lo usamos en el Salario, y no en la identificaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a54ed92f38bc881fb7562aedd94827fd1f8b7927" translate="yes" xml:space="preserve">
          <source>With the above data, the result should contain two rows: &lt;code&gt;[1, 3, ...]&lt;/code&gt; and &lt;code&gt;[2, 1, ..]&lt;/code&gt;. I'm using &lt;strong&gt;&lt;em&gt;MySQL&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">Con los datos anteriores, el resultado debe contener dos filas: &lt;code&gt;[1, 3, ...]&lt;/code&gt; y &lt;code&gt;[2, 1, ..]&lt;/code&gt; . Estoy usando &lt;strong&gt;&lt;em&gt;MySQL&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b040793081e54b56e0ea00ab6ff5580f6556d4ae" translate="yes" xml:space="preserve">
          <source>Yes it looks awful (converting to string and back etc.) but in my experience it's usually faster than the other solutions. Maybe that just for my use cases, but I have used it on tables with millions of records and many unique ids. Maybe it's because MySQL is pretty bad at optimizing the other solutions (at least in the 5.0 days when I came up with this solution).</source>
          <target state="translated">Sí,tiene un aspecto horrible (convertir en cuerda y espalda,etc.)pero en mi experiencia suele ser más rápido que las otras soluciones.Tal vez sólo para mis casos de uso,pero lo he usado en tablas con millones de registros y muchas identificaciones únicas.Tal vez sea porque MySQL es bastante malo para optimizar las otras soluciones (al menos en los 5 días en que se me ocurrió esta solución).</target>
        </trans-unit>
        <trans-unit id="27f562e6f1eb4744f3a84f65dab865c4653ea720" translate="yes" xml:space="preserve">
          <source>Yet another solution is to use a correlated subquery:</source>
          <target state="translated">Otra solución es utilizar una subconsulta correlacionada:</target>
        </trans-unit>
        <trans-unit id="1394ac848a2275fcc727163db03ae442b55038a4" translate="yes" xml:space="preserve">
          <source>You can do it using &lt;code&gt;IN&lt;/code&gt;
try this:</source>
          <target state="translated">Puede hacerlo usando &lt;code&gt;IN&lt;/code&gt; intente esto:</target>
        </trans-unit>
        <trans-unit id="453880e233710a43167c94bccdd5a1dd285b388f" translate="yes" xml:space="preserve">
          <source>You can make the select without a join when you combine the &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; into one &lt;code&gt;maxRevId&lt;/code&gt; value for &lt;code&gt;MAX()&lt;/code&gt; and then split it back to original values:</source>
          <target state="translated">Puede hacer la selecci&amp;oacute;n sin una combinaci&amp;oacute;n cuando combina la &lt;code&gt;rev&lt;/code&gt; y la &lt;code&gt;id&lt;/code&gt; en un valor &lt;code&gt;maxRevId&lt;/code&gt; para &lt;code&gt;MAX()&lt;/code&gt; y luego lo divide de nuevo a los valores originales:</target>
        </trans-unit>
        <trans-unit id="de4507bccd6edb68f154ba28cbcd9e35a8a477f0" translate="yes" xml:space="preserve">
          <source>You can use this schema in multiple joins and with WHERE clause. It is my working example (solving identical to yours problem with table &quot;firmy&quot;):</source>
          <target state="translated">Puedes usar este esquema en múltiples uniones y con la cláusula WHERE.Es mi ejemplo de trabajo (resolviendo idéntico a su problema con la tabla &quot;firmy&quot;):</target>
        </trans-unit>
        <trans-unit id="f94f563922394ff422dd19d7db9d395cc093c872" translate="yes" xml:space="preserve">
          <source>here is another solution hope it will help someone</source>
          <target state="translated">Aquí hay otra solución,espero que ayude a alguien...</target>
        </trans-unit>
        <trans-unit id="7c7f285565dd90fe18340d6bf0386ae80d43766d" translate="yes" xml:space="preserve">
          <source>to my mind it is less complicated... easier to read and maintain.</source>
          <target state="translated">En mi opinión es menos complicado...más fácil de leer y mantener.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
