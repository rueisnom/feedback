<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/7745609">
    <body>
      <group id="7745609">
        <trans-unit id="04c57be5b9e3b9472146536311d773ab598c075b" translate="yes" xml:space="preserve">
          <source>3.2    becomes    1003.201</source>
          <target state="translated">3.2는 1003.201이됩니다</target>
        </trans-unit>
        <trans-unit id="7ee9358b03aa8d5e6b7ff5f87ff1c6c61fa1840d" translate="yes" xml:space="preserve">
          <source>57     becomes    1057.001</source>
          <target state="translated">57은 1057.001이됩니다</target>
        </trans-unit>
        <trans-unit id="d7e7caf3da371e1159ed08c93e06650d3673a2aa" translate="yes" xml:space="preserve">
          <source>923.88 becomes    1923.881</source>
          <target state="translated">923.88은 1923.881이됩니다.</target>
        </trans-unit>
        <trans-unit id="27f0e6e0472c758e2b2f6cf7c9816fcea152f9aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(SELECT *...)&lt;/code&gt; subquery : Return all people, sorted by Salary.</source>
          <target state="translated">&lt;code&gt;(SELECT *...)&lt;/code&gt; subquery : 급여로 정렬 된 모든 사람을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4a3646e38f6b0d40250be24a8869360f600bf40d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FROM Employee&lt;/code&gt; : Table searched on.</source>
          <target state="translated">&lt;code&gt;FROM Employee&lt;/code&gt; : 테이블을 검색했습니다.</target>
        </trans-unit>
        <trans-unit id="51b27a498c28cb1978a214b508f3379f27cbf666" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GROUP BY Table1.id&lt;/code&gt;: Force the top-sorted, Salary row of each employee to be the returned result.</source>
          <target state="translated">&lt;code&gt;GROUP BY Table1.id&lt;/code&gt; : 각 직원의 최상위 급여 행을 반환 결과로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a1b951f0bc26d85d82b83ff57fc600c0fb43a981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GROUP BY employeesub.Salary&lt;/code&gt;: Force the top-sorted, Salary row of each employee to be the returned result.</source>
          <target state="translated">&lt;code&gt;GROUP BY employeesub.Salary&lt;/code&gt; : 각 직원의 최상위 정렬 급여 행이 리턴 된 결과가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="b108dac77b8b8d7940ca436cb584a45df60efc79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JOIN Table1 AS Table2 ON Table2.rev = Table1.rev&lt;/code&gt; : Join the second table on the first, because, we need to get the max(table1.rev)'s comment.</source>
          <target state="translated">&lt;code&gt;JOIN Table1 AS Table2 ON Table2.rev = Table1.rev&lt;/code&gt; : max (table1.rev)의 설명을 얻어야하므로 첫 번째 두 번째 테이블을 조인하십시오.</target>
        </trans-unit>
        <trans-unit id="5d64ca2c6f022a9050f895a8140f2d84845c927e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT *&lt;/code&gt; : Return all fields.</source>
          <target state="translated">&lt;code&gt;SELECT *&lt;/code&gt; : 모든 필드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f1728fe7d07f6f81ae312d65bccb6428f5d4d2d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT DISTINCT Table1.id, max(Table1.rev), max(Table2.content)&lt;/code&gt; : Return &lt;code&gt;DISTINCT&lt;/code&gt; somefield, &lt;code&gt;MAX()&lt;/code&gt; some otherfield, the last &lt;code&gt;MAX()&lt;/code&gt; is redundant, because I know it's just one row, but it's required by the query.</source>
          <target state="translated">&lt;code&gt;SELECT DISTINCT Table1.id, max(Table1.rev), max(Table2.content)&lt;/code&gt; : &lt;code&gt;DISTINCT&lt;/code&gt; somefield, &lt;code&gt;MAX()&lt;/code&gt; 일부 다른 필드를 반환합니다. 마지막 &lt;code&gt;MAX()&lt;/code&gt; 는 하나의 행이라는 것을 알고 있기 때문에 중복됩니다. 쿼리</target>
        </trans-unit>
        <trans-unit id="694f2b69df9ba4223789e351dba806643efc9f3c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&quot;Can you return me the records in this group of records (based on same id) that have the highest version number&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&quot;버전 번호가 가장 높은이 레코드 그룹 (동일한 ID를 기준으로)의 레코드를 반환 할 수 있습니다.&quot;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="747dc8ef6e9397eda6d614ec751270837eb5d1cc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why is it clean?&lt;/em&gt;&lt;code&gt;DISTINCT()&lt;/code&gt;, &lt;code&gt;MAX()&lt;/code&gt;, etc., all make wonderful use of MySQL indices.  This will be faster.  Or, it will be much faster, if you have indexing, and you compare it to a query that looks at all rows.</source>
          <target state="translated">&lt;em&gt;왜 깨끗한가요?&lt;/em&gt; &lt;code&gt;DISTINCT()&lt;/code&gt; , &lt;code&gt;MAX()&lt;/code&gt; 등은 모두 MySQL 인덱스를 훌륭하게 사용합니다. 이것은 더 빠를 것입니다. 또는 인덱싱이 있으면 훨씬 빠르며 모든 행을 보는 쿼리와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef6990676e8cbc396ebc34b6bbb2006bd98ee19c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;APPROACH&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;APPROACH&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f2f1d3f876ca275d587648c0854a40f7d75ceda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cleanest Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가장 깨끗한 솔루션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23eda03e232c7b276914d29d144368844246997f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; though this solution works for many people it may not be stable in the long run, since MySQL doesn't guarantee that GROUP BY statement will return meaningful values for columns not in GROUP BY list. So use this solution at your own risk!</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 이 솔루션은 많은 사람들에게 효과적이지만 MySQL은 GROUP BY 문이 GROUP BY 목록에없는 열에 대해 의미있는 값을 반환한다고 보장하지 않기 때문에 장기적으로 안정적이지 않을 수 있습니다. 따라서이 솔루션을 모든 책임은 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="403b25e1010d5c08346c35cf961dc40d8e1f56f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;GOOD STUFF&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;좋은 스터프&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a9b0dfc8a396405726470595ea946d489db2ab7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOT mySQL&lt;/strong&gt;, but for other people finding this question and using SQL, another way to resolve the &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt; problem is using &lt;a href=&quot;http://technet.microsoft.com/en-us/library/ms175156(v=sql.105).aspx&quot;&gt;&lt;code&gt;Cross Apply&lt;/code&gt;&lt;/a&gt; in MS SQL</source>
          <target state="translated">&lt;strong&gt;mySQL&lt;/strong&gt; 은 아니지만 다른 사람들 이이 질문을 찾고 SQL을 사용하는 경우 &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;그룹 당 가장 큰&lt;/a&gt; 문제를 해결하는 또 다른 방법은 MS SQL에서 &lt;a href=&quot;http://technet.microsoft.com/en-us/library/ms175156(v=sql.105).aspx&quot;&gt; &lt;code&gt;Cross Apply&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다</target>
        </trans-unit>
        <trans-unit id="59f292915a0a09f846bffdf80a1afb5aad2aa92f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;독창적 인 솔루션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c747eb526637be44701505482fa8cb37152fb689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please credit answer of user Bohemian&lt;/strong&gt; in &lt;a href=&quot;https://stackoverflow.com/questions/12102200/get-records-with-max-value-for-each-group-of-grouped-sql-results&quot;&gt;this question&lt;/a&gt; for providing such a concise and elegant answer to this problem.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/12102200/get-records-with-max-value-for-each-group-of-grouped-sql-results&quot;&gt;이 문제에&lt;/a&gt; 대한 간결하고 우아한 답변을 제공 한이 질문 &lt;strong&gt;에 사용자 Bohemian의 답변을 적어주십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2add4d2b2581dbb1b5b57f680ba41943bb912e83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unique-Row Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;고유 한 행 솔루션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e7ad05d289224982e0cbf5785062d94a875a509" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;업데이트 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f68ee9c7511d534eda217dbc3387c2ea2bf2888d" translate="yes" xml:space="preserve">
          <source>A third solution I hardly ever see mentioned is MySQL specific and looks like this:</source>
          <target state="translated">내가 거의 언급하지 않은 세 번째 솔루션은 MySQL과 관련이 있으며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0359601a6c3c733dad134b61901f5ac2843959e2" translate="yes" xml:space="preserve">
          <source>Added in SQL standard ANSI/ISO Standard SQL:2003  and later extended with ANSI/ISO Standard SQL:2008, window (or windowing) functions are available with all major vendors now. There are more types of rank functions available to deal with a tie issue: &lt;code&gt;RANK, DENSE_RANK, PERSENT_RANK&lt;/code&gt;.</source>
          <target state="translated">SQL 표준 ANSI / ISO 표준 SQL : 2003 이상에 ANSI / ISO 표준 SQL : 2008로 확장 된 이후에 창 (또는 창) 기능을 모든 주요 공급 업체에서 사용할 수 있습니다. &lt;code&gt;RANK, DENSE_RANK, PERSENT_RANK&lt;/code&gt; 와 같은 타이 문제를 처리하는 데 사용할 수있는 순위 함수 유형이 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f6c5649c468f3c5b9f11dd0b6bb5bd2dcb42b60" translate="yes" xml:space="preserve">
          <source>All you need is a &lt;code&gt;GROUP BY&lt;/code&gt; clause with the &lt;code&gt;MAX&lt;/code&gt; aggregate function:</source>
          <target state="translated">&lt;code&gt;MAX&lt;/code&gt; 집계 함수가있는 &lt;code&gt;GROUP BY&lt;/code&gt; 절만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="f6746f8d362c92efc81f829dc623802dbc041661" translate="yes" xml:space="preserve">
          <source>Another manner to do the job is using &lt;code&gt;MAX()&lt;/code&gt; analytic function in OVER PARTITION clause</source>
          <target state="translated">작업을 수행하는 다른 방법은 OVER PARTITION 절에서 &lt;code&gt;MAX()&lt;/code&gt; 분석 함수를 사용하는 것입니다</target>
        </trans-unit>
        <trans-unit id="2db20964a9cb8621f5afa10d678b2d245436b758" translate="yes" xml:space="preserve">
          <source>Anyway, the above doesn't directly work if your content field is already text. In that case you probably want to use a different separator, like \0 maybe. You'll also run into the &lt;code&gt;group_concat_max_len&lt;/code&gt; limit quicker.</source>
          <target state="translated">어쨌든 내용 필드가 이미 텍스트 인 경우 위의 내용이 직접 작동하지 않습니다. 이 경우 아마도 \ 0과 같은 다른 구분 기호를 사용하고 싶을 것입니다. 또한 &lt;code&gt;group_concat_max_len&lt;/code&gt; 한도를 더 빨리 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc54dc2faa3dd8f7aa080b02153c1129681f558" translate="yes" xml:space="preserve">
          <source>As the answers suggest, there &lt;em&gt;is&lt;/em&gt; a SQL solution, and &lt;a href=&quot;http://sqlfiddle.com/#!9/3d74dc/1&quot;&gt;here a sqlfiddle demo&lt;/a&gt;.</source>
          <target state="translated">답변에서 알 수 있듯이 SQL 솔루션과 &lt;a href=&quot;http://sqlfiddle.com/#!9/3d74dc/1&quot;&gt;sqlfiddle 데모가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="18684a622d455407c3ef979634241c7c2b8bb5c1" translate="yes" xml:space="preserve">
          <source>At first glance...</source>
          <target state="translated">첫눈에...</target>
        </trans-unit>
        <trans-unit id="7d20eb576a5bf5c43a34a93487e4603496ff5cfd" translate="yes" xml:space="preserve">
          <source>Basically, you have two approaches to solve that problem:</source>
          <target state="translated">기본적으로이 문제를 해결하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aff13b294275d46a1233bde52ba0a2304518a57e" translate="yes" xml:space="preserve">
          <source>Both approaches are SQL ANSI compatible, thus, will work with your favorite RDBMS, regardless of its &quot;flavor&quot;.</source>
          <target state="translated">두 가지 방법 모두 SQL ANSI와 호환되므로 &quot;향기&quot;에 관계없이 자주 사용하는 RDBMS와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a069f75e85cfd757d1237e33836f5a5c9a7933b8" translate="yes" xml:space="preserve">
          <source>Both approaches are also performance friendly, however your mileage may vary (RDBMS, DB Structure, Indexes, etc.). So when you pick one approach over the other, &lt;em&gt;benchmark&lt;/em&gt;. And make sure you pick the one which make most of sense to you.</source>
          <target state="translated">두 방법 모두 성능에 친숙하지만 마일리지는 다를 수 있습니다 (RDBMS, DB 구조, 색인 등). 따라서 다른 접근 방식 중 하나를 선택할 때 &lt;em&gt;벤치 마크를 수행하십시오&lt;/em&gt; . 그리고 당신에게 가장 적합한 것을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="19563c10db076085d9b0b4f5dba8b52984789ac2" translate="yes" xml:space="preserve">
          <source>Both approaches bring the exact same result.</source>
          <target state="translated">두 방법 모두 동일한 결과를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="573dbbd0ba5f01ad2edaf25718f8fd20afb0f654" translate="yes" xml:space="preserve">
          <source>Currently I use checks in the &lt;code&gt;while&lt;/code&gt; loop to detect and over-write old revs from the resultset. But is this the only method to achieve the result? Isn't there a &lt;strong&gt;SQL&lt;/strong&gt; solution?</source>
          <target state="translated">현재 &lt;code&gt;while&lt;/code&gt; 루프의 검사를 사용하여 결과 집합에서 오래된 개정을 감지하고 덮어 씁니다. 그러나 이것이 결과를 얻는 유일한 방법입니까? &lt;strong&gt;SQL&lt;/strong&gt; 솔루션이 없습니까?</target>
        </trans-unit>
        <trans-unit id="3bedaf93cca4db2c2a031f628273b205d4c103de" translate="yes" xml:space="preserve">
          <source>DB Fiddle</source>
          <target state="translated">DB 피들</target>
        </trans-unit>
        <trans-unit id="af49ccd16ea8ee6847aa18e5e026d91269d1340a" translate="yes" xml:space="preserve">
          <source>Even so, we can simply select &lt;code&gt;DISTINCT&lt;/code&gt;&lt;em&gt;someuniquefield&lt;/em&gt;, &lt;code&gt;MAX(&lt;/code&gt;&lt;em&gt;whateverotherfieldtoselect&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt; *somethirdfield &lt;code&gt;)&lt;/code&gt;, etc., and have no worries understanding the result or how the query works :</source>
          <target state="translated">그럼에도 불구하고 &lt;code&gt;DISTINCT&lt;/code&gt; &lt;em&gt;someuniquefield&lt;/em&gt; , &lt;code&gt;MAX(&lt;/code&gt; &lt;em&gt;whateverotherfieldtoselect&lt;/em&gt; &lt;code&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;/code&gt; * somethirdfield &lt;code&gt;)&lt;/code&gt; 등을 간단히 선택할 수 있으며 결과를 이해하거나 쿼리 작동 방식에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="000d91fadfba91936529d79d0821bb7195a90ba6" translate="yes" xml:space="preserve">
          <source>Following are comparisons to the solutions in @AdrianCarneiro's answer (subquery, leftjoin), based on MySQL measurements with InnoDB table of ~1million records, group size being: 1-3.</source>
          <target state="translated">다음은 ~ 1 백만 레코드의 InnoDB 테이블을 사용한 MySQL 측정치, 그룹 크기가 1-3 인 @AdrianCarneiro의 답변 (하위 쿼리, 왼쪽 조인)의 솔루션과 비교 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="995071277e83cf1d1f1c4a8ccb804e62ea4b68dd" translate="yes" xml:space="preserve">
          <source>Having an index on (id,rev) renders the subquery almost as a simple lookup...</source>
          <target state="translated">인덱스를 (id, rev) 설정하면 하위 쿼리가 거의 간단한 조회로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="314d916008f70bef56e0b0d15d12dfe541cea6a1" translate="yes" xml:space="preserve">
          <source>Here is a nice way of doing that</source>
          <target state="translated">여기에 좋은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="471fa8e0858c0f841233c444b4700b23aee1ab66" translate="yes" xml:space="preserve">
          <source>Here's an example in SqlFiddle</source>
          <target state="translated">다음은 SqlFiddle의 예입니다.</target>
        </trans-unit>
        <trans-unit id="9164d1faed37c4623fd975150fe3872405f41423" translate="yes" xml:space="preserve">
          <source>Here's another solution to retrieving the records only with a field that has the maximum value for that field. This works for SQL400 which is the platform I work on. In this example, the records with the maximum value in field FIELD5 will be retrieved by the following SQL statement.</source>
          <target state="translated">다음은 해당 필드의 최대 값을 가진 필드로만 레코드를 검색하는 또 다른 솔루션입니다. 이것은 내가 작업하는 플랫폼 인 SQL400에서 작동합니다. 이 예에서, 필드 FIELD5에 최대 값을 갖는 레코드는 다음 SQL 문에 의해 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="a6f33200f27d1f02a32897ce39b81c9ee560e6d6" translate="yes" xml:space="preserve">
          <source>Here's how it looks with the above example, written in SQL</source>
          <target state="translated">위의 예에서 SQL로 작성된 모습은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e3a68cc958a74ba34c6bcb6c78f492a33cda5ba" translate="yes" xml:space="preserve">
          <source>Hopefully this is a solution that solves the problem and helps everyone better understand what's happening in the DB.</source>
          <target state="translated">바라건대 이것은 문제를 해결하고 모든 사람들이 DB에서 무슨 일이 일어나고 있는지 더 잘 이해하도록 도와주는 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="17aca0cf466b23a9d66f040adc39824d44c21641" translate="yes" xml:space="preserve">
          <source>How about this:</source>
          <target state="translated">이것은 어떤가요:</target>
        </trans-unit>
        <trans-unit id="10913cb8e1a0c820785850e0e7d418afaaf3b084" translate="yes" xml:space="preserve">
          <source>How do I select one row per id and only the greatest rev?</source>
          <target state="translated">id 당 하나의 행을 선택하고 가장 큰 rev 만 어떻게 선택합니까?</target>
        </trans-unit>
        <trans-unit id="19cbcd14e6b2211943bc8ae571c9613a49c99e92" translate="yes" xml:space="preserve">
          <source>I am flabbergasted that no answer offered SQL window function solution:</source>
          <target state="translated">나는 대답이 SQL 창 기능 솔루션을 제공하지 않았다는 것에 화를 냈다.</target>
        </trans-unit>
        <trans-unit id="c63f6bb578d3ae9db96662ba13e29dc33c243f8f" translate="yes" xml:space="preserve">
          <source>I came here looking for SQLAlchemy help, so I will duplicate Adrian Carneiro's answer with the python/SQLAlchemy version, specifically the outer join part.</source>
          <target state="translated">SQLAlchemy 도움말을 찾기 위해 여기에 왔으므로 Adrian Carneiro의 답변을 python / SQLAlchemy 버전, 특히 외부 조인 부분과 복제합니다.</target>
        </trans-unit>
        <trans-unit id="c10b9ffc525b97bcbece3250c202bd16cad8beb3" translate="yes" xml:space="preserve">
          <source>I can't vouch for the performance, but here's a trick inspired by the limitations of Microsoft Excel.  It has some good features</source>
          <target state="translated">성능을 보증 할 수는 없지만 Microsoft Excel의 한계에서 영감을 얻은 트릭이 있습니다. 좋은 기능이 있습니다</target>
        </trans-unit>
        <trans-unit id="67a7d23c38d29857f72aac73ca9af605f944a2d1" translate="yes" xml:space="preserve">
          <source>I have this table for documents (simplified version here):</source>
          <target state="translated">문서에 대한이 표가 있습니다 (단순 버전).</target>
        </trans-unit>
        <trans-unit id="d582544f0807601e4b6511e7bdec729115bf914b" translate="yes" xml:space="preserve">
          <source>I just noticed you need the &lt;code&gt;content&lt;/code&gt; column as well.</source>
          <target state="translated">방금 &lt;code&gt;content&lt;/code&gt; 열이 필요하다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="a8dfea75f00120de3d7deedb3de7608fd0c28237" translate="yes" xml:space="preserve">
          <source>I like to do this by ranking the records by some column. In this case, rank &lt;code&gt;rev&lt;/code&gt; values grouped by &lt;code&gt;id&lt;/code&gt;. Those with higher &lt;code&gt;rev&lt;/code&gt; will have lower rankings. So highest &lt;code&gt;rev&lt;/code&gt; will have ranking of 1.</source>
          <target state="translated">열별로 레코드 순위를 지정 하여이 작업을 수행하고 싶습니다. 이 경우 &lt;code&gt;id&lt;/code&gt; 로 그룹화 된 &lt;code&gt;rev&lt;/code&gt; 값을 순위 지정하십시오. &lt;code&gt;rev&lt;/code&gt; 가 높을수록 순위가 낮아집니다. 따라서 가장 높은 &lt;code&gt;rev&lt;/code&gt; 는 1의 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="33448d590cc783d19b7e088f10f0cc5625c1e617" translate="yes" xml:space="preserve">
          <source>I like to use a &lt;code&gt;NOT EXIST&lt;/code&gt;-based solution for this problem:</source>
          <target state="translated">이 문제에 &lt;code&gt;NOT EXIST&lt;/code&gt; 기반 솔루션을 사용하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="3a69c1874c939239de03ecc1482256501bce00b2" translate="yes" xml:space="preserve">
          <source>I noticed after adding the above &lt;em&gt;sqlfiddle&lt;/em&gt;, the rate at which the question is upvoted has surpassed the upvote rate of the answers. That has not been the intention! The fiddle is based on the answers, especially the accepted answer.</source>
          <target state="translated">위의 &lt;em&gt;sqlfiddle&lt;/em&gt; 을 추가 한 후 질문의 &lt;em&gt;투표&lt;/em&gt; 속도가 답변의 &lt;em&gt;투표&lt;/em&gt; 속도를 능가하는 것으로 나타났습니다. 그것은 의도가 아니었다! 바이올린은 답변, 특히 허용되는 답변을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="31b46e90abba135e2e191919836bd8d723638c3d" translate="yes" xml:space="preserve">
          <source>I then joined these max values (#temp1) to all of the possible id/content combinations. By doing this, I naturally filter out the non-maximum id/content combinations, and am left with the only max rev values for each.</source>
          <target state="translated">그런 다음이 최대 값 (# temp1)을 가능한 모든 ID / 콘텐츠 조합에 결합했습니다. 이렇게하면 자연스럽게 최대가 아닌 id / content 조합을 필터링하고 각 최대 rev 값만 남습니다.</target>
        </trans-unit>
        <trans-unit id="eedb27620fc870cd05408ec33312da837f122366" translate="yes" xml:space="preserve">
          <source>I think, You want this?</source>
          <target state="translated">나는 당신이 이것을 원한다고 생각합니까?</target>
        </trans-unit>
        <trans-unit id="475f1dbf29984af602be998bcf11558846a40db9" translate="yes" xml:space="preserve">
          <source>I used the below to solve a problem of my own. I first created a temp table and inserted the max rev value per unique id.</source>
          <target state="translated">나는 내 자신의 문제를 해결하기 위해 아래를 사용했습니다. 먼저 임시 테이블을 만들고 고유 ID 당 최대 rev 값을 삽입했습니다.</target>
        </trans-unit>
        <trans-unit id="90195caa2158153b6d15ffbd881bc0002f84edd8" translate="yes" xml:space="preserve">
          <source>I would use this:</source>
          <target state="translated">나는 이것을 사용할 것이다 :</target>
        </trans-unit>
        <trans-unit id="91840954cb9c4ea1b61596b1a83ee83e2ea511b0" translate="yes" xml:space="preserve">
          <source>I wouldn't use IN clause (as it is mentioned somewhere above). IN is given to use with short lists of constans, and not as to be the query filter built on subquery. It is because subquery in IN is performed for every scanned record which can made query taking very loooong time.</source>
          <target state="translated">IN 절을 사용하지 않을 것입니다 (위의 어딘가에 언급되어 있음). IN은 짧은 constans 목록과 함께 사용하도록 제공되며 하위 쿼리에 빌드 된 쿼리 필터가 아닙니다. IN의 서브 쿼리가 스캔 된 모든 레코드에 대해 수행되기 때문에 쿼리 시간이 매우 오래 걸리기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fb74c49395db7bba931e909d22e83547acbf985a" translate="yes" xml:space="preserve">
          <source>If you do it right, string comparison of two numbers should yield the same &quot;max&quot; as numeric comparison of the two numbers and it's easy to convert back to the original number using the substring function (which is available in one form or another pretty much everywhere).</source>
          <target state="translated">올바르게 수행하면 두 숫자의 문자열 비교에서 두 숫자의 숫자 비교와 동일한 &quot;최대&quot;가 생성되고 하위 문자열 함수 (한 형태 또는 다른 형태로 제공)를 사용하여 원래 숫자로 쉽게 변환 할 수 있습니다. 어디에나).</target>
        </trans-unit>
        <trans-unit id="cd760119a0c1ae1b56d494acb1a10a8a2ca548fe" translate="yes" xml:space="preserve">
          <source>If you have many fields in select statement and you want latest  value for all of those fields through optimized code:</source>
          <target state="translated">select 문에 많은 필드가 있고 최적화 된 코드를 통해 해당 필드 모두에 대한 최신 값을 원하는 경우 :</target>
        </trans-unit>
        <trans-unit id="ee8b53705cdf9b09c80c28fb4dd6809e10ff922e" translate="yes" xml:space="preserve">
          <source>If you have two rows with &lt;code&gt;max-value-in-group&lt;/code&gt; for &lt;code&gt;group-identifier&lt;/code&gt;, both rows will be in the result in both approaches.</source>
          <target state="translated">&lt;code&gt;group-identifier&lt;/code&gt; 에 대해 그룹 &lt;code&gt;max-value-in-group&lt;/code&gt; 을 갖는 두 개의 행이있는 경우 두 행 모두 두 가지 방법으로 결과에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d387732b9dd594cea09224c99e2e3db7eda6d1c9" translate="yes" xml:space="preserve">
          <source>In this approach, you first find the &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; (already solved above) in a sub-query. Then you join your table to the sub-query with equality on both &lt;code&gt;group-identifier&lt;/code&gt; and &lt;code&gt;max-value-in-group&lt;/code&gt;:</source>
          <target state="translated">이 방법에서는 먼저 하위 쿼리에서 &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; (위에서 이미 해결됨)을 찾습니다. 그런 다음 &lt;code&gt;group-identifier&lt;/code&gt; 와 &lt;code&gt;max-value-in-group&lt;/code&gt; 모두에서 동등하게 하위 쿼리에 테이블을 조인합니다.</target>
        </trans-unit>
        <trans-unit id="0e261b8d5be6a8e3499be83152da6b96e488a4fc" translate="yes" xml:space="preserve">
          <source>In this approach, you left join the table with itself. Equality goes in the &lt;code&gt;group-identifier&lt;/code&gt;. Then, 2 smart moves:</source>
          <target state="translated">이 방법에서는 테이블 자체를 조인 한 상태로 둡니다. 평등은 &lt;code&gt;group-identifier&lt;/code&gt; 에 들어갑니다. 그런 다음 두 가지 똑똑한 움직임 :</target>
        </trans-unit>
        <trans-unit id="4b8e5c4e8addfc03069074421a8e679d4db14df8" translate="yes" xml:space="preserve">
          <source>It doesn't require a join</source>
          <target state="translated">조인이 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="ee669ad8ba2e0f5f2ee33e7468179e58169574b2" translate="yes" xml:space="preserve">
          <source>It is a little bit ugly and requires that you know something about the range of valid values of the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column.  Let us assume that we know the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column is a number between 0.00 and 999 including decimals but that there will only ever be two digits to the right of the decimal point (e.g. 34.17 would be a valid value).</source>
          <target state="translated">약간 추악하고 &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; 열의 유효한 값 범위에 대해 알고 있어야합니다. &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; 열이 소수점을 포함하여 0.00에서 999 사이의 숫자이지만 소수점 오른쪽에 두 자리 만있을 것입니다 (예 : 34.17은 유효한 값임).</target>
        </trans-unit>
        <trans-unit id="d052da643334c91fbd79130f435ea2036f8d231e" translate="yes" xml:space="preserve">
          <source>It is asked on tables having teens thusands of records, and it takes less then 0,01 second on really not too strong machine.</source>
          <target state="translated">10 대의 레코드가있는 테이블에 대해 묻고 실제로 너무 강한 기계에서는 0.01 초 미만의 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="58fd729f1264da5befb4f9b9d51e8f280f1269ec" translate="yes" xml:space="preserve">
          <source>It is, actually, so common that StackOverflow community has created a single tag just to deal with questions like that: &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt;.</source>
          <target state="translated">실제로 StackOverflow 커뮤니티는 다음과 같은 질문을 처리하기 위해 하나의 태그를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="9d0650392a80d6352d1134ecbd14115eaa3db77a" translate="yes" xml:space="preserve">
          <source>It looks like there is simpler way to do this (but &lt;strong&gt;only in MySQL&lt;/strong&gt;):</source>
          <target state="translated">이 작업을 수행하는 더 간단한 방법이있는 것처럼 보입니다 (하지만 &lt;strong&gt;MySQL에서만&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="452d3ec3e5e3af71a122522390dfdc81b35a82a8" translate="yes" xml:space="preserve">
          <source>It should force return of only one &quot;max record&quot; even if there is a tie (sometimes useful)</source>
          <target state="translated">동점이있는 경우에도 하나의 &quot;최대 레코드&quot;만 반환해야합니다 (때로는 유용함)</target>
        </trans-unit>
        <trans-unit id="4d2d5d921b83099b6badb0edcc209baf412da434" translate="yes" xml:space="preserve">
          <source>It's never that simple, is it?</source>
          <target state="translated">결코 그렇게 간단하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="11aed3f58968adfc7e701f0ecba96fda74515ce8" translate="yes" xml:space="preserve">
          <source>Joining with simple &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; Sub-query</source>
          <target state="translated">간단한 &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; 하위 쿼리와 결합</target>
        </trans-unit>
        <trans-unit id="460920821f4309de220f91dcb815a79c7b3c9156" translate="yes" xml:space="preserve">
          <source>Left Joining with self, tweaking join conditions and filters</source>
          <target state="translated">자가 결합, 조인 조건 및 필터 조정</target>
        </trans-unit>
        <trans-unit id="31d0f030330e9a305782ce8d95a2c9b90fec6b29" translate="yes" xml:space="preserve">
          <source>MAX() solution runs certainly FASTER that &lt;code&gt;ROW_NUMBER()&lt;/code&gt; solution because &lt;code&gt;MAX()&lt;/code&gt; complexity is &lt;code&gt;O(n)&lt;/code&gt; while &lt;code&gt;ROW_NUMBER()&lt;/code&gt; complexity is at minimum &lt;code&gt;O(n.log(n))&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; represent the number of records in table !</source>
          <target state="translated">MAX () 솔루션은 &lt;code&gt;MAX()&lt;/code&gt; 복잡도는 &lt;code&gt;O(n)&lt;/code&gt; 이고 &lt;code&gt;ROW_NUMBER()&lt;/code&gt; 복잡도는 최소 &lt;code&gt;O(n.log(n))&lt;/code&gt; 이므로 &lt;code&gt;n&lt;/code&gt; 은 테이블의 레코드 수를 나타 내기 때문에 &lt;code&gt;ROW_NUMBER()&lt;/code&gt; 솔루션보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f784dda051b71346905b94e12f1c6ce43f3e7fb7" translate="yes" xml:space="preserve">
          <source>My preference is to use as little code as possible...</source>
          <target state="translated">내 선호는 가능한 한 작은 코드를 사용하는 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="460b741c73cbd00e64b87f5e4e2284a80c063282" translate="yes" xml:space="preserve">
          <source>Newer versions of MySQL come with &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; enabled by default, and many of the solutions here will &lt;em&gt;fail&lt;/em&gt; in testing with this condition.</source>
          <target state="translated">최신 버전의 MySQL에는 기본적으로 &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; 가 활성화되어 있으며 여기에서 많은 솔루션이이 조건에서 테스트에 &lt;em&gt;실패&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="dd15a32e927c00c615558f8c6498a2cdc048de59" translate="yes" xml:space="preserve">
          <source>None of these answers have worked for me.</source>
          <target state="translated">이 답변들 중 어느 것도 나를 위해 일한 적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2735d006f0f78c77077d2a8f7b369c24f3a71501" translate="yes" xml:space="preserve">
          <source>Not sure if introducing variables makes the whole thing slower. But at least I'm not querying &lt;code&gt;YOURTABLE&lt;/code&gt; twice.</source>
          <target state="translated">변수를 도입하면 전체 속도가 느려지는지 확실하지 않습니다. 그러나 적어도 나는 &lt;code&gt;YOURTABLE&lt;/code&gt; 을 두 번 쿼리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87119c137f4237ae2ffed9b612a2cd3bc86e9351" translate="yes" xml:space="preserve">
          <source>Note that since &quot;content&quot; was &quot;...&quot; in OP's question, there's no way to test that this works.  So, I changed that to &quot;..a&quot;, &quot;..b&quot;, so, we can actually now see that the results are correct:</source>
          <target state="translated">OP의 질문에서 &quot;content&quot;는 &quot;...&quot;이므로이 기능이 작동하는지 테스트 할 방법이 없습니다. 따라서 &quot;..a&quot;, &quot;..b&quot;로 변경 했으므로 이제 결과가 올바른지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fcce481af6c969086f7a3a5178c3e328716610a" translate="yes" xml:space="preserve">
          <source>Note the &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database&quot;&gt;Definition of a Relational Database&lt;/a&gt;: &quot;Each row in a table has its own unique key.&quot;  This would mean that, in the question's example, id would &lt;em&gt;have to be&lt;/em&gt; unique, and in that case, we can just do :</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database&quot;&gt;관계형 데이터베이스&lt;/a&gt; 의 정의에 유의하십시오. &quot;테이블의 각 행에는 고유 한 키가 있습니다.&quot; 즉, 질문의 예에서 id는 고유 &lt;em&gt;해야&lt;/em&gt; 하며 그 경우에는 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd37664721ce22baa58bcd661cd5cbf26ebc9693" translate="yes" xml:space="preserve">
          <source>One final note, as leftjoin creates n*(n+1)/2 joins in groups, its performance can be heavily affected by the size of groups...</source>
          <target state="translated">마지막으로, 왼쪽 조인은 그룹에서 n * (n + 1) / 2 조인을 생성하므로 그룹의 크기에 따라 성능이 크게 영향을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d6a717a9edad23dd4bea1b698581b82bc5a20e9" translate="yes" xml:space="preserve">
          <source>One important thing is that GROUP_CONCAT has a maximum length for the string it can build up. You probably want to raise this limit by setting the &lt;code&gt;group_concat_max_len&lt;/code&gt; variable. And keep in mind that this will be a limit on scaling if you have a large number of rows.</source>
          <target state="translated">한 가지 중요한 점은 GROUP_CONCAT에 빌드 할 수있는 문자열의 최대 길이가 있다는 것입니다. &lt;code&gt;group_concat_max_len&lt;/code&gt; 변수를 설정하여이 한계를 높이고 싶을 것입니다. 행 수가 많은 경우에는 크기 조정에 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="91c7270a2e10bd5cc0fdda4e69065666aee3c4f2" translate="yes" xml:space="preserve">
          <source>SQL Fiddle :
&lt;a href=&quot;http://sqlfiddle.com/#!9/a6c585/82473/0&quot;&gt;Check here&lt;/a&gt;</source>
          <target state="translated">SQL Fiddle : &lt;a href=&quot;http://sqlfiddle.com/#!9/a6c585/82473/0&quot;&gt;여기를 확인하십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4fdc1b974c1790e82135708cc7cfea1d1ffb439b" translate="yes" xml:space="preserve">
          <source>SQL select only rows with max value on a column</source>
          <target state="translated">SQL은 열에서 최대 값을 가진 행만 선택합니다</target>
        </trans-unit>
        <trans-unit id="3b76449895ac57983b7b2b65399182f3103db7fa" translate="yes" xml:space="preserve">
          <source>Since this is most popular question with regard to this problem, I'll re-post another answer to it here as well:</source>
          <target state="translated">이 문제와 관련하여 가장 인기있는 질문이므로 여기에 다른 답변을 다시 게시하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d00e076b8322dcd61d6eb23264c22bf08e04282e" translate="yes" xml:space="preserve">
          <source>So you end up with:</source>
          <target state="translated">그래서 당신은 결국 :</target>
        </trans-unit>
        <trans-unit id="94f01ead7218d9d39d0a9e5560ffc936f4a0187b" translate="yes" xml:space="preserve">
          <source>Something like this?</source>
          <target state="translated">이 같은?</target>
        </trans-unit>
        <trans-unit id="fcea27228c354bcef2642a5bc557c693423693fc" translate="yes" xml:space="preserve">
          <source>Sorted the rev field in reverse order and then grouped by id which gave the first row of each grouping which is the one with the highest rev value.</source>
          <target state="translated">rev 필드를 역순으로 정렬 한 다음 id별로 그룹화하여 rev 값이 가장 높은 각 그룹의 첫 번째 행을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6a3870fad3df63029f67f8ef1f65f56e452059d7" translate="yes" xml:space="preserve">
          <source>Subquery SELECT is not too eficient maybe, but in JOIN clause seems to be usable. I'm not an expert in optimizing queries, but I've tried at MySQL, PostgreSQL, FireBird and it does work very good.</source>
          <target state="translated">하위 쿼리 SELECT가 너무 효율적이지는 않지만 JOIN 절에서 사용할 수있는 것 같습니다. 쿼리 최적화 전문가는 아니지만 MySQL, PostgreSQL, FireBird에서 사용해 보았지만 매우 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5dc7723780e3da28e4fb6d9bc359f0075239e170" translate="yes" xml:space="preserve">
          <source>Tested in &lt;a href=&quot;http://sqlfiddle.com/&quot;&gt;http://sqlfiddle.com/&lt;/a&gt; with the following data</source>
          <target state="translated">다음 데이터를 사용하여 &lt;a href=&quot;http://sqlfiddle.com/&quot;&gt;http://sqlfiddle.com/&lt;/a&gt; 에서 테스트되었습니다 .</target>
        </trans-unit>
        <trans-unit id="94226523059a44fd6d0823e04d1320c06cbf47ec" translate="yes" xml:space="preserve">
          <source>Tested on a PostgreSQL database.</source>
          <target state="translated">PostgreSQL 데이터베이스에서 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="b3309e51317016b3d5b0a251f24e195795b03f73" translate="yes" xml:space="preserve">
          <source>The above combination is simple with bit functions when &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; are &lt;code&gt;INT UNSIGNED&lt;/code&gt; (32 bit) and combined value fits to &lt;code&gt;BIGINT UNSIGNED&lt;/code&gt; (64 bit). When the &lt;code&gt;id&lt;/code&gt; &amp;amp; &lt;code&gt;rev&lt;/code&gt; are larger than 32-bit values or made of multiple columns, you need combine the value into e.g. a binary value with suitable padding for &lt;code&gt;MAX()&lt;/code&gt;.</source>
          <target state="translated">위의 조합은 &lt;code&gt;rev&lt;/code&gt; 및 &lt;code&gt;id&lt;/code&gt; 가 &lt;code&gt;INT UNSIGNED&lt;/code&gt; (32 비트)이고 결합 된 값이 &lt;code&gt;BIGINT UNSIGNED&lt;/code&gt; (64 비트)에 맞는 경우 비트 기능으로 간단합니다. &lt;code&gt;id&lt;/code&gt; &amp;amp; &lt;code&gt;rev&lt;/code&gt; 가 32 비트 값보다 크거나 여러 열로 구성된 경우 &lt;code&gt;MAX()&lt;/code&gt; 적합한 패딩을 사용하여 이진 값으로 값을 결합해야합니다.</target>
        </trans-unit>
        <trans-unit id="1dd706fecc71dd4b48d2d2b09b1613cf3d0b105e" translate="yes" xml:space="preserve">
          <source>The gist of the thing is that you create a single synthetic column by string concatenating/packing the primary comparison field along with the data you want.  In this way, you can force SQL's MAX() aggregate function to return all of the data (because it has been packed into a single column).  Then you have to unpack the data.</source>
          <target state="translated">중요한 것은 기본 비교 필드를 원하는 데이터와 함께 문자열로 연결 / 포장하여 단일 합성 열을 생성한다는 것입니다. 이런 식으로 SQL의 MAX () 집계 함수가 모든 데이터를 반환하도록 할 수 있습니다 (단일 열로 압축 되었기 때문에). 그런 다음 데이터를 압축 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="00ab94e8e1f472a0caf4245bb6004e0fd4761b29" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;ROW_NUMBER()&lt;/code&gt; OVER PARTITION solution already documented in this post is</source>
          <target state="translated">이 게시물에 이미 문서화 된 다른 &lt;code&gt;ROW_NUMBER()&lt;/code&gt; OVER PARTITION 솔루션은</target>
        </trans-unit>
        <trans-unit id="33daa53cf1139c305a3e6de8aaaf4c6d74e63949" translate="yes" xml:space="preserve">
          <source>The packing begins by forcing the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column to be a number of known character length regardless of the value of &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; so that for example</source>
          <target state="translated">패킹은 &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; 값에 관계없이 &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; 열을 알려진 문자 길이로 강제하여 시작합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8f02bdcb5aaad48ff64e99bf617a644fa990ddcf" translate="yes" xml:space="preserve">
          <source>The second join condition is having left side value less than right value</source>
          <target state="translated">두 번째 결합 조건이 왼쪽 값이 오른쪽 값보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="0bbc6aadc07a842d6fc9d1f88ded92b6a1b29149" translate="yes" xml:space="preserve">
          <source>This 2 SELECT work well on Oracle 10g.</source>
          <target state="translated">이 2 SELECT는 Oracle 10g에서 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8c0d4d65d2b2336eff8eda436b0051d18840475e" translate="yes" xml:space="preserve">
          <source>This allows me to duplicate the record, update it, increment its version number, and have the copy of the old version in such a way that I can show change over time.</source>
          <target state="translated">이를 통해 레코드를 복제하고 업데이트하며 버전 번호를 늘리고 시간이 지남에 따라 변경 사항을 표시 할 수있는 방식으로 이전 버전의 사본을 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2301e8326e919ecb8afe49e6e514de6a09cce684" translate="yes" xml:space="preserve">
          <source>This gave the following result in MySql 5.5 and 5.6</source>
          <target state="translated">MySql 5.5 및 5.6에서 다음과 같은 결과를 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="887c512cd9ff837fd1c9fc4808909508ea838546" translate="yes" xml:space="preserve">
          <source>This is a very common question in SQL: find the whole data for the row with some max value in a column per some group identifier. I heard that a lot during my career. Actually, it was one the questions I answered in my current job's technical interview.</source>
          <target state="translated">이것은 SQL에서 매우 일반적인 질문입니다. 일부 그룹 식별자 당 열에 최대 값이있는 행의 전체 데이터를 찾으십시오. 나는 경력 동안 그 말을 많이 들었다. 실제로, 그것은 현재 직업 기술 인터뷰에서 내가 대답 한 질문 중 하나였습니다.</target>
        </trans-unit>
        <trans-unit id="ee5febc8aebb31700d3b2dcee3dd28e23632667e" translate="yes" xml:space="preserve">
          <source>This is especially fast when there is a complex join instead of a single table. With the traditional approaches the complex join would be done twice.</source>
          <target state="translated">단일 테이블 대신 복잡한 조인이있는 경우 특히 빠릅니다. 전통적인 접근 방식으로 복잡한 결합은 두 번 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="bf4b0ede672dafca43e39e677b31d17ea3f43666" translate="yes" xml:space="preserve">
          <source>This is not pure SQL. This will use the SQLAlchemy ORM.</source>
          <target state="translated">이것은 순수한 SQL이 아닙니다. SQLAlchemy ORM을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e525543a18c8b2f059c99fd1eafb0e14a4a32dc4" translate="yes" xml:space="preserve">
          <source>This is what worked for me.</source>
          <target state="translated">이것이 나를 위해 일한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b48e75dada78a122caea17e73852eaaddb6181b" translate="yes" xml:space="preserve">
          <source>This query answers the question of:</source>
          <target state="translated">이 쿼리는 다음 질문에 답합니다.</target>
        </trans-unit>
        <trans-unit id="59b379b84cff9d86d45433e27b3a690e1bbc3911" translate="yes" xml:space="preserve">
          <source>This solution makes only one selection from YourTable, therefore it's faster. It works only for MySQL and SQLite(for SQLite remove DESC) according to test on sqlfiddle.com. Maybe it can be tweaked to work on other languages which I am not familiar with.</source>
          <target state="translated">이 솔루션은 YourTable에서 하나만 선택하므로 더 빠릅니다. sqlfiddle.com의 테스트에 따라 MySQL 및 SQLite (SQLite 제거 DESC)에서만 작동합니다. 어쩌면 내가 익숙하지 않은 다른 언어로 작업하는 것이 좋을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="922fda0f734f15029de1e6477a7c86dcb4d18c7c" translate="yes" xml:space="preserve">
          <source>This will select all records with max value within the group and allows you to select other columns.</source>
          <target state="translated">그룹 내에서 최대 값을 가진 모든 레코드를 선택하고 다른 열을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66639bc2c3849de3b1308222ecb4a4eb01a37f90" translate="yes" xml:space="preserve">
          <source>Use following code :</source>
          <target state="translated">다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1d992c7af6b12bdffa0c4708f603e830d452ab3a" translate="yes" xml:space="preserve">
          <source>When you do step 1, the row(s) that actually have the max value will have &lt;code&gt;NULL&lt;/code&gt; in the right side (it's a &lt;code&gt;LEFT JOIN&lt;/code&gt;, remember?). Then, we filter the joined result, showing only the rows where the right side is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">1 단계를 수행하면 실제로 최대 값을 가진 행은 오른쪽에 &lt;code&gt;NULL&lt;/code&gt; 을 갖습니다 ( &lt;code&gt;LEFT JOIN&lt;/code&gt; . 기억하십니까?). 그런 다음 결합 된 결과를 필터링하여 오른쪽이 &lt;code&gt;NULL&lt;/code&gt; 인 행만 표시 합니다 .</target>
        </trans-unit>
        <trans-unit id="a9f5100d135261032402eee1426608998aac7beb" translate="yes" xml:space="preserve">
          <source>While for full table scans subquery/leftjoin/correlated timings relate to each other as 6/8/9, when it comes to direct lookups or batch (&lt;code&gt;id in (1,2,3)&lt;/code&gt;), subquery is much slower then the others (Due to rerunning the subquery). However I couldnt differentiate between leftjoin and correlated solutions in speed.</source>
          <target state="translated">전체 테이블 스캔의 경우 서브 쿼리 / 왼쪽 조인 / 상관 타이밍은 6/8/9로 서로 관련되지만 직접 조회 또는 배치 ( &lt;code&gt;id in (1,2,3)&lt;/code&gt; )에 대해서는 서브 쿼리가 다른 것보다 훨씬 느립니다 ( 하위 쿼리를 다시 실행하기 때문에). 그러나 왼쪽 조인과 상관 솔루션을 속도로 구별 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="59c4f1cbf0a942eb4eb3e4a90d93e9070d57b26d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; disabled, we can use still use &lt;code&gt;GROUP BY&lt;/code&gt;, but then we are only using it on the Salary, and not the id:</source>
          <target state="translated">&lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; 를 비활성화하면 여전히 &lt;code&gt;GROUP BY&lt;/code&gt; 를 사용할 수 있지만 급여는 ID가 아닌 급여에서만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a54ed92f38bc881fb7562aedd94827fd1f8b7927" translate="yes" xml:space="preserve">
          <source>With the above data, the result should contain two rows: &lt;code&gt;[1, 3, ...]&lt;/code&gt; and &lt;code&gt;[2, 1, ..]&lt;/code&gt;. I'm using &lt;strong&gt;&lt;em&gt;MySQL&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">위의 데이터를 사용하면 결과에 &lt;code&gt;[1, 3, ...]&lt;/code&gt; 및 &lt;code&gt;[2, 1, ..]&lt;/code&gt; 두 행이 포함되어야합니다. &lt;strong&gt;&lt;em&gt;MySQL을&lt;/em&gt;&lt;/strong&gt; 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b040793081e54b56e0ea00ab6ff5580f6556d4ae" translate="yes" xml:space="preserve">
          <source>Yes it looks awful (converting to string and back etc.) but in my experience it's usually faster than the other solutions. Maybe that just for my use cases, but I have used it on tables with millions of records and many unique ids. Maybe it's because MySQL is pretty bad at optimizing the other solutions (at least in the 5.0 days when I came up with this solution).</source>
          <target state="translated">예, 끔찍한 것처럼 보이지만 (문자열 및 등으로 변환) 내 경험상 일반적으로 다른 솔루션보다 빠릅니다. 어쩌면 그것은 내 유스 케이스에 대해서만 가능하지만 수백만 개의 레코드와 많은 고유 ID가있는 테이블에서 사용했습니다. 아마도 MySQL이 다른 솔루션을 최적화하는 데 상당히 나쁘기 때문일 수 있습니다 (적어도이 솔루션을 만든 후 5.0 일).</target>
        </trans-unit>
        <trans-unit id="27f562e6f1eb4744f3a84f65dab865c4653ea720" translate="yes" xml:space="preserve">
          <source>Yet another solution is to use a correlated subquery:</source>
          <target state="translated">또 다른 해결책은 상관 하위 쿼리를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1394ac848a2275fcc727163db03ae442b55038a4" translate="yes" xml:space="preserve">
          <source>You can do it using &lt;code&gt;IN&lt;/code&gt;
try this:</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; 을 사용 하여이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="453880e233710a43167c94bccdd5a1dd285b388f" translate="yes" xml:space="preserve">
          <source>You can make the select without a join when you combine the &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; into one &lt;code&gt;maxRevId&lt;/code&gt; value for &lt;code&gt;MAX()&lt;/code&gt; and then split it back to original values:</source>
          <target state="translated">&lt;code&gt;rev&lt;/code&gt; 와 &lt;code&gt;id&lt;/code&gt; 를 &lt;code&gt;MAX()&lt;/code&gt; 대한 하나의 &lt;code&gt;maxRevId&lt;/code&gt; 값으로 결합한 다음 원래 값으로 다시 분할 할 때 조인없이 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de4507bccd6edb68f154ba28cbcd9e35a8a477f0" translate="yes" xml:space="preserve">
          <source>You can use this schema in multiple joins and with WHERE clause. It is my working example (solving identical to yours problem with table &quot;firmy&quot;):</source>
          <target state="translated">이 스키마는 여러 조인에서 WHERE 절과 함께 사용할 수 있습니다. 내 작업 예입니다 (테이블 &quot;firmy&quot;의 문제와 동일하게 해결).</target>
        </trans-unit>
        <trans-unit id="f94f563922394ff422dd19d7db9d395cc093c872" translate="yes" xml:space="preserve">
          <source>here is another solution hope it will help someone</source>
          <target state="translated">여기 누군가를 도울 수있는 또 다른 해결책이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c7f285565dd90fe18340d6bf0386ae80d43766d" translate="yes" xml:space="preserve">
          <source>to my mind it is less complicated... easier to read and maintain.</source>
          <target state="translated">내 마음에 그것은 덜 복잡합니다 ... 읽기 쉽고 유지 보수가 쉽습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
