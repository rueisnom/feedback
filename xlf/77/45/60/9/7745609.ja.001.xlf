<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/7745609">
    <body>
      <group id="7745609">
        <trans-unit id="04c57be5b9e3b9472146536311d773ab598c075b" translate="yes" xml:space="preserve">
          <source>3.2    becomes    1003.201</source>
          <target state="translated">3.2 は 1003.201 になります。</target>
        </trans-unit>
        <trans-unit id="7ee9358b03aa8d5e6b7ff5f87ff1c6c61fa1840d" translate="yes" xml:space="preserve">
          <source>57     becomes    1057.001</source>
          <target state="translated">57 は 1057.001 になります。</target>
        </trans-unit>
        <trans-unit id="d7e7caf3da371e1159ed08c93e06650d3673a2aa" translate="yes" xml:space="preserve">
          <source>923.88 becomes    1923.881</source>
          <target state="translated">923.88が1923.881になる</target>
        </trans-unit>
        <trans-unit id="27f0e6e0472c758e2b2f6cf7c9816fcea152f9aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(SELECT *...)&lt;/code&gt; subquery : Return all people, sorted by Salary.</source>
          <target state="translated">&lt;code&gt;(SELECT *...)&lt;/code&gt; subquery：すべての人を、給与順にソートして返します。</target>
        </trans-unit>
        <trans-unit id="4a3646e38f6b0d40250be24a8869360f600bf40d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FROM Employee&lt;/code&gt; : Table searched on.</source>
          <target state="translated">&lt;code&gt;FROM Employee&lt;/code&gt; ：テーブルが検索されました。</target>
        </trans-unit>
        <trans-unit id="51b27a498c28cb1978a214b508f3379f27cbf666" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GROUP BY Table1.id&lt;/code&gt;: Force the top-sorted, Salary row of each employee to be the returned result.</source>
          <target state="translated">&lt;code&gt;GROUP BY Table1.id&lt;/code&gt; ：各従業員の最上位にソートされた給与行を、返される結果にします。</target>
        </trans-unit>
        <trans-unit id="a1b951f0bc26d85d82b83ff57fc600c0fb43a981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GROUP BY employeesub.Salary&lt;/code&gt;: Force the top-sorted, Salary row of each employee to be the returned result.</source>
          <target state="translated">&lt;code&gt;GROUP BY employeesub.Salary&lt;/code&gt; ：各従業員の最上位の給与行を強制的に返される結果にします。</target>
        </trans-unit>
        <trans-unit id="b108dac77b8b8d7940ca436cb584a45df60efc79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JOIN Table1 AS Table2 ON Table2.rev = Table1.rev&lt;/code&gt; : Join the second table on the first, because, we need to get the max(table1.rev)'s comment.</source>
          <target state="translated">&lt;code&gt;JOIN Table1 AS Table2 ON Table2.rev = Table1.rev&lt;/code&gt; ：2番目のテーブルを最初に結合します。これは、max（table1.rev）のコメントを取得する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="5d64ca2c6f022a9050f895a8140f2d84845c927e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT *&lt;/code&gt; : Return all fields.</source>
          <target state="translated">&lt;code&gt;SELECT *&lt;/code&gt; ：すべてのフィールドを返します。</target>
        </trans-unit>
        <trans-unit id="f1728fe7d07f6f81ae312d65bccb6428f5d4d2d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT DISTINCT Table1.id, max(Table1.rev), max(Table2.content)&lt;/code&gt; : Return &lt;code&gt;DISTINCT&lt;/code&gt; somefield, &lt;code&gt;MAX()&lt;/code&gt; some otherfield, the last &lt;code&gt;MAX()&lt;/code&gt; is redundant, because I know it's just one row, but it's required by the query.</source>
          <target state="translated">&lt;code&gt;SELECT DISTINCT Table1.id, max(Table1.rev), max(Table2.content)&lt;/code&gt; ： &lt;code&gt;DISTINCT&lt;/code&gt; somefield、 &lt;code&gt;MAX()&lt;/code&gt; some otherfieldを返します。最後の &lt;code&gt;MAX()&lt;/code&gt; は冗長です。これは、1行だけであることを知っているためですが、クエリ。</target>
        </trans-unit>
        <trans-unit id="694f2b69df9ba4223789e351dba806643efc9f3c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&quot;Can you return me the records in this group of records (based on same id) that have the highest version number&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;「このレコードグループ（同じIDに基づく）の中で、バージョン番号が最も高いレコードを私に返すことができますか？」&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="747dc8ef6e9397eda6d614ec751270837eb5d1cc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why is it clean?&lt;/em&gt;&lt;code&gt;DISTINCT()&lt;/code&gt;, &lt;code&gt;MAX()&lt;/code&gt;, etc., all make wonderful use of MySQL indices.  This will be faster.  Or, it will be much faster, if you have indexing, and you compare it to a query that looks at all rows.</source>
          <target state="translated">&lt;em&gt;なぜきれいなの？&lt;/em&gt; &lt;code&gt;DISTINCT()&lt;/code&gt; 、 &lt;code&gt;MAX()&lt;/code&gt; などはすべて、MySQLインデックスをうまく利用しています。 これはより速くなります。 または、インデックスがあり、すべての行を調べるクエリと比較すると、はるかに高速になります。</target>
        </trans-unit>
        <trans-unit id="ef6990676e8cbc396ebc34b6bbb2006bd98ee19c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;APPROACH&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;APPROACH&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f2f1d3f876ca275d587648c0854a40f7d75ceda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cleanest Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最もクリーンなソリューション&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23eda03e232c7b276914d29d144368844246997f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; though this solution works for many people it may not be stable in the long run, since MySQL doesn't guarantee that GROUP BY statement will return meaningful values for columns not in GROUP BY list. So use this solution at your own risk!</source>
          <target state="translated">&lt;strong&gt;編集：&lt;/strong&gt; MySQLはGROUP BYステートメントがGROUP BYリストにない列に対して意味のある値を返すことをMySQLが保証しないため、このソリューションは多くの人に有効ですが、長期的には安定しない可能性があります。 したがって、このソリューションは自己責任で使用してください。</target>
        </trans-unit>
        <trans-unit id="403b25e1010d5c08346c35cf961dc40d8e1f56f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;GOOD STUFF&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;良いもの&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a9b0dfc8a396405726470595ea946d489db2ab7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOT mySQL&lt;/strong&gt;, but for other people finding this question and using SQL, another way to resolve the &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt; problem is using &lt;a href=&quot;http://technet.microsoft.com/en-us/library/ms175156(v=sql.105).aspx&quot;&gt;&lt;code&gt;Cross Apply&lt;/code&gt;&lt;/a&gt; in MS SQL</source>
          <target state="translated">&lt;strong&gt;mySQL&lt;/strong&gt;ではあり&lt;strong&gt;ません&lt;/strong&gt;が、この質問を見つけてSQLを使用する他の人にとって、 &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;グループごとの最大の&lt;/a&gt;問題を解決する別の方法は、MS SQLで&lt;a href=&quot;http://technet.microsoft.com/en-us/library/ms175156(v=sql.105).aspx&quot;&gt; &lt;code&gt;Cross Apply&lt;/code&gt; &lt;/a&gt;を使用することです</target>
        </trans-unit>
        <trans-unit id="59f292915a0a09f846bffdf80a1afb5aad2aa92f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;元のソリューション&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c747eb526637be44701505482fa8cb37152fb689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please credit answer of user Bohemian&lt;/strong&gt; in &lt;a href=&quot;https://stackoverflow.com/questions/12102200/get-records-with-max-value-for-each-group-of-grouped-sql-results&quot;&gt;this question&lt;/a&gt; for providing such a concise and elegant answer to this problem.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/12102200/get-records-with-max-value-for-each-group-of-grouped-sql-results&quot;&gt;この問題&lt;/a&gt;に対するこのような簡潔でエレガントな回答を提供したこの質問 &lt;strong&gt;におけるユーザーBohemianの回答を信用してください&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="2add4d2b2581dbb1b5b57f680ba41943bb912e83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unique-Row Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ユニークな列のソリューション&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e7ad05d289224982e0cbf5785062d94a875a509" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アップデート2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f68ee9c7511d534eda217dbc3387c2ea2bf2888d" translate="yes" xml:space="preserve">
          <source>A third solution I hardly ever see mentioned is MySQL specific and looks like this:</source>
          <target state="translated">3つ目の解決策は、MySQLに特化したもので、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="0359601a6c3c733dad134b61901f5ac2843959e2" translate="yes" xml:space="preserve">
          <source>Added in SQL standard ANSI/ISO Standard SQL:2003  and later extended with ANSI/ISO Standard SQL:2008, window (or windowing) functions are available with all major vendors now. There are more types of rank functions available to deal with a tie issue: &lt;code&gt;RANK, DENSE_RANK, PERSENT_RANK&lt;/code&gt;.</source>
          <target state="translated">SQL標準ANSI / ISO標準SQL：2003以降に追加され、ANSI / ISO標準SQL：2008で拡張されたウィンドウ（またはウィンドウ）関数は、現在すべての主要ベンダーで利用できます。 結合の問題を処理するために使用できるランク関数には、 &lt;code&gt;RANK, DENSE_RANK, PERSENT_RANK&lt;/code&gt; さらに多くのタイプがあります。</target>
        </trans-unit>
        <trans-unit id="6f6c5649c468f3c5b9f11dd0b6bb5bd2dcb42b60" translate="yes" xml:space="preserve">
          <source>All you need is a &lt;code&gt;GROUP BY&lt;/code&gt; clause with the &lt;code&gt;MAX&lt;/code&gt; aggregate function:</source>
          <target state="translated">必要なのは、 &lt;code&gt;MAX&lt;/code&gt; 集約関数を使用した &lt;code&gt;GROUP BY&lt;/code&gt; 句だけです。</target>
        </trans-unit>
        <trans-unit id="f6746f8d362c92efc81f829dc623802dbc041661" translate="yes" xml:space="preserve">
          <source>Another manner to do the job is using &lt;code&gt;MAX()&lt;/code&gt; analytic function in OVER PARTITION clause</source>
          <target state="translated">ジョブを実行する別の方法は、OVER PARTITION句で &lt;code&gt;MAX()&lt;/code&gt; 分析関数を使用することです</target>
        </trans-unit>
        <trans-unit id="2db20964a9cb8621f5afa10d678b2d245436b758" translate="yes" xml:space="preserve">
          <source>Anyway, the above doesn't directly work if your content field is already text. In that case you probably want to use a different separator, like \0 maybe. You'll also run into the &lt;code&gt;group_concat_max_len&lt;/code&gt; limit quicker.</source>
          <target state="translated">とにかく、コンテンツフィールドが既にテキストの場合、上記は直接機能しません。 その場合、おそらく\ 0のような別の区切り文字を使用したいと思うでしょう。 また、 &lt;code&gt;group_concat_max_len&lt;/code&gt; 制限にすばやく到達します。</target>
        </trans-unit>
        <trans-unit id="3dc54dc2faa3dd8f7aa080b02153c1129681f558" translate="yes" xml:space="preserve">
          <source>As the answers suggest, there &lt;em&gt;is&lt;/em&gt; a SQL solution, and &lt;a href=&quot;http://sqlfiddle.com/#!9/3d74dc/1&quot;&gt;here a sqlfiddle demo&lt;/a&gt;.</source>
          <target state="translated">答えが示唆するように、SQLソリューションがあり、 &lt;a href=&quot;http://sqlfiddle.com/#!9/3d74dc/1&quot;&gt;ここにsqlfiddleデモがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="18684a622d455407c3ef979634241c7c2b8bb5c1" translate="yes" xml:space="preserve">
          <source>At first glance...</source>
          <target state="translated">一見すると...。</target>
        </trans-unit>
        <trans-unit id="7d20eb576a5bf5c43a34a93487e4603496ff5cfd" translate="yes" xml:space="preserve">
          <source>Basically, you have two approaches to solve that problem:</source>
          <target state="translated">基本的には、その問題を解決するために2つのアプローチがあります。</target>
        </trans-unit>
        <trans-unit id="aff13b294275d46a1233bde52ba0a2304518a57e" translate="yes" xml:space="preserve">
          <source>Both approaches are SQL ANSI compatible, thus, will work with your favorite RDBMS, regardless of its &quot;flavor&quot;.</source>
          <target state="translated">どちらのアプローチもSQL ANSIと互換性があり、したがって、その &quot;味 &quot;に関係なく、お気に入りのRDBMSで動作します。</target>
        </trans-unit>
        <trans-unit id="a069f75e85cfd757d1237e33836f5a5c9a7933b8" translate="yes" xml:space="preserve">
          <source>Both approaches are also performance friendly, however your mileage may vary (RDBMS, DB Structure, Indexes, etc.). So when you pick one approach over the other, &lt;em&gt;benchmark&lt;/em&gt;. And make sure you pick the one which make most of sense to you.</source>
          <target state="translated">どちらのアプローチもパフォーマンスに優しいですが、マイレージは異なります（RDBMS、DB構造、インデックスなど）。 したがって、他のアプローチよりも1つのアプローチを選択する場合は、 &lt;em&gt;ベンチマークを使用します&lt;/em&gt; 。 そして、あなたがあなたにとって最も意味のあるものを選ぶようにしてください。</target>
        </trans-unit>
        <trans-unit id="19563c10db076085d9b0b4f5dba8b52984789ac2" translate="yes" xml:space="preserve">
          <source>Both approaches bring the exact same result.</source>
          <target state="translated">どちらのアプローチも全く同じ結果をもたらします。</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="573dbbd0ba5f01ad2edaf25718f8fd20afb0f654" translate="yes" xml:space="preserve">
          <source>Currently I use checks in the &lt;code&gt;while&lt;/code&gt; loop to detect and over-write old revs from the resultset. But is this the only method to achieve the result? Isn't there a &lt;strong&gt;SQL&lt;/strong&gt; solution?</source>
          <target state="translated">現在、 &lt;code&gt;while&lt;/code&gt; ループでチェックを使用して、結果セットから古いリビジョンを検出して上書きしています。 しかし、これが結果を達成する唯一の方法ですか？ &lt;strong&gt;SQL&lt;/strong&gt;ソリューションはありませんか？</target>
        </trans-unit>
        <trans-unit id="3bedaf93cca4db2c2a031f628273b205d4c103de" translate="yes" xml:space="preserve">
          <source>DB Fiddle</source>
          <target state="translated">DBフィドル</target>
        </trans-unit>
        <trans-unit id="af49ccd16ea8ee6847aa18e5e026d91269d1340a" translate="yes" xml:space="preserve">
          <source>Even so, we can simply select &lt;code&gt;DISTINCT&lt;/code&gt;&lt;em&gt;someuniquefield&lt;/em&gt;, &lt;code&gt;MAX(&lt;/code&gt;&lt;em&gt;whateverotherfieldtoselect&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt; *somethirdfield &lt;code&gt;)&lt;/code&gt;, etc., and have no worries understanding the result or how the query works :</source>
          <target state="translated">それでも、単純に &lt;code&gt;DISTINCT&lt;/code&gt; &lt;em&gt;someuniquefield&lt;/em&gt; 、 &lt;code&gt;MAX(&lt;/code&gt; &lt;em&gt;whateverotherfieldtoselect&lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 、 &lt;code&gt;(&lt;/code&gt; * somethirdfield &lt;code&gt;)&lt;/code&gt; などを選択でき、結果やクエリの仕組みを理解する心配がありません。</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="000d91fadfba91936529d79d0821bb7195a90ba6" translate="yes" xml:space="preserve">
          <source>Following are comparisons to the solutions in @AdrianCarneiro's answer (subquery, leftjoin), based on MySQL measurements with InnoDB table of ~1million records, group size being: 1-3.</source>
          <target state="translated">以下は、@AdrianCarneiro氏の回答(サブクエリ、leftjoin)のソリューションとの比較で、100万レコード、グループサイズがあるInnoDBテーブルでのMySQLの測定に基づいています。1-3.</target>
        </trans-unit>
        <trans-unit id="995071277e83cf1d1f1c4a8ccb804e62ea4b68dd" translate="yes" xml:space="preserve">
          <source>Having an index on (id,rev) renders the subquery almost as a simple lookup...</source>
          <target state="translated">(id,rev)にインデックスを持つことで、副問い合わせはほとんど単純な検索のようになります。</target>
        </trans-unit>
        <trans-unit id="314d916008f70bef56e0b0d15d12dfe541cea6a1" translate="yes" xml:space="preserve">
          <source>Here is a nice way of doing that</source>
          <target state="translated">素敵な方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="471fa8e0858c0f841233c444b4700b23aee1ab66" translate="yes" xml:space="preserve">
          <source>Here's an example in SqlFiddle</source>
          <target state="translated">以下はSqlFiddleの例です。</target>
        </trans-unit>
        <trans-unit id="9164d1faed37c4623fd975150fe3872405f41423" translate="yes" xml:space="preserve">
          <source>Here's another solution to retrieving the records only with a field that has the maximum value for that field. This works for SQL400 which is the platform I work on. In this example, the records with the maximum value in field FIELD5 will be retrieved by the following SQL statement.</source>
          <target state="translated">ここに、そのフィールドの最大値を持つフィールドのみでレコードを取得する別の解決策があります。これは私が使用しているプラットフォームであるSQL400で動作します。この例では、フィールドFIELD5の最大値を持つレコードは、次のSQL文で取得されます。</target>
        </trans-unit>
        <trans-unit id="a6f33200f27d1f02a32897ce39b81c9ee560e6d6" translate="yes" xml:space="preserve">
          <source>Here's how it looks with the above example, written in SQL</source>
          <target state="translated">SQLで書かれた上記の例ではどのように見えますか?</target>
        </trans-unit>
        <trans-unit id="9e3a68cc958a74ba34c6bcb6c78f492a33cda5ba" translate="yes" xml:space="preserve">
          <source>Hopefully this is a solution that solves the problem and helps everyone better understand what's happening in the DB.</source>
          <target state="translated">これが問題を解決し、DBで何が起こっているのかを誰もがよりよく理解できるような解決策であることを願っています。</target>
        </trans-unit>
        <trans-unit id="17aca0cf466b23a9d66f040adc39824d44c21641" translate="yes" xml:space="preserve">
          <source>How about this:</source>
          <target state="translated">これはどうでしょうか。</target>
        </trans-unit>
        <trans-unit id="10913cb8e1a0c820785850e0e7d418afaaf3b084" translate="yes" xml:space="preserve">
          <source>How do I select one row per id and only the greatest rev?</source>
          <target state="translated">idごとに1列ずつ選択して最大回転数のみを選択する方法は?</target>
        </trans-unit>
        <trans-unit id="19cbcd14e6b2211943bc8ae571c9613a49c99e92" translate="yes" xml:space="preserve">
          <source>I am flabbergasted that no answer offered SQL window function solution:</source>
          <target state="translated">私はどの答えがSQLウィンドウ関数のソリューションを提供していないことをフラッバーグしています。</target>
        </trans-unit>
        <trans-unit id="c63f6bb578d3ae9db96662ba13e29dc33c243f8f" translate="yes" xml:space="preserve">
          <source>I came here looking for SQLAlchemy help, so I will duplicate Adrian Carneiro's answer with the python/SQLAlchemy version, specifically the outer join part.</source>
          <target state="translated">私はSQLAlchemyのヘルプを探してここに来たので、私はPythonSQLAlchemyバージョン、具体的には外側の結合部分でAdrian Carneiroの答えを複製します。</target>
        </trans-unit>
        <trans-unit id="c10b9ffc525b97bcbece3250c202bd16cad8beb3" translate="yes" xml:space="preserve">
          <source>I can't vouch for the performance, but here's a trick inspired by the limitations of Microsoft Excel.  It has some good features</source>
          <target state="translated">性能を保証するものではありませんが、Microsoft Excelの限界に触発された仕掛けがここにあります。それはいくつかの良い機能を持っています</target>
        </trans-unit>
        <trans-unit id="67a7d23c38d29857f72aac73ca9af605f944a2d1" translate="yes" xml:space="preserve">
          <source>I have this table for documents (simplified version here):</source>
          <target state="translated">資料用にこの表を持っています(簡易版はこちら)。</target>
        </trans-unit>
        <trans-unit id="d582544f0807601e4b6511e7bdec729115bf914b" translate="yes" xml:space="preserve">
          <source>I just noticed you need the &lt;code&gt;content&lt;/code&gt; column as well.</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; 列も必要だと気づきました。</target>
        </trans-unit>
        <trans-unit id="a8dfea75f00120de3d7deedb3de7608fd0c28237" translate="yes" xml:space="preserve">
          <source>I like to do this by ranking the records by some column. In this case, rank &lt;code&gt;rev&lt;/code&gt; values grouped by &lt;code&gt;id&lt;/code&gt;. Those with higher &lt;code&gt;rev&lt;/code&gt; will have lower rankings. So highest &lt;code&gt;rev&lt;/code&gt; will have ranking of 1.</source>
          <target state="translated">レコードをいくつかの列でランク付けしてこれを行うのが好きです。 この場合、 &lt;code&gt;rev&lt;/code&gt; の値を &lt;code&gt;id&lt;/code&gt; でグループ化してランク付けします。 &lt;code&gt;rev&lt;/code&gt; が高いものは、ランキングが低くなります。 したがって、最高の &lt;code&gt;rev&lt;/code&gt; は1のランクになります。</target>
        </trans-unit>
        <trans-unit id="33448d590cc783d19b7e088f10f0cc5625c1e617" translate="yes" xml:space="preserve">
          <source>I like to use a &lt;code&gt;NOT EXIST&lt;/code&gt;-based solution for this problem:</source>
          <target state="translated">この問題には &lt;code&gt;NOT EXIST&lt;/code&gt; ベースのソリューションを使用したい：</target>
        </trans-unit>
        <trans-unit id="3a69c1874c939239de03ecc1482256501bce00b2" translate="yes" xml:space="preserve">
          <source>I noticed after adding the above &lt;em&gt;sqlfiddle&lt;/em&gt;, the rate at which the question is upvoted has surpassed the upvote rate of the answers. That has not been the intention! The fiddle is based on the answers, especially the accepted answer.</source>
          <target state="translated">上記の&lt;em&gt;sqlfiddleを&lt;/em&gt;追加した後、質問の賛成率が回答の賛成率を上回っていることに気付きました。 それは意図されていません！ フィドルは答え、特に受け入れられた答えに基づいています。</target>
        </trans-unit>
        <trans-unit id="31b46e90abba135e2e191919836bd8d723638c3d" translate="yes" xml:space="preserve">
          <source>I then joined these max values (#temp1) to all of the possible id/content combinations. By doing this, I naturally filter out the non-maximum id/content combinations, and am left with the only max rev values for each.</source>
          <target state="translated">そして、これらの最大値(#temp1)をすべての可能性のあるidcontentの組み合わせに結合しました。このようにすることで、自然と最大でないidcontentの組み合わせはフィルタリングされ、それぞれの最大回転数の値だけが残されます。</target>
        </trans-unit>
        <trans-unit id="eedb27620fc870cd05408ec33312da837f122366" translate="yes" xml:space="preserve">
          <source>I think, You want this?</source>
          <target state="translated">これが欲しいのか?</target>
        </trans-unit>
        <trans-unit id="475f1dbf29984af602be998bcf11558846a40db9" translate="yes" xml:space="preserve">
          <source>I used the below to solve a problem of my own. I first created a temp table and inserted the max rev value per unique id.</source>
          <target state="translated">私自身の問題を解決するために以下を使用しました。最初にテンポラリテーブルを作成して、ユニークIDごとの最大Rev値を挿入しました。</target>
        </trans-unit>
        <trans-unit id="90195caa2158153b6d15ffbd881bc0002f84edd8" translate="yes" xml:space="preserve">
          <source>I would use this:</source>
          <target state="translated">私ならこれを使います。</target>
        </trans-unit>
        <trans-unit id="91840954cb9c4ea1b61596b1a83ee83e2ea511b0" translate="yes" xml:space="preserve">
          <source>I wouldn't use IN clause (as it is mentioned somewhere above). IN is given to use with short lists of constans, and not as to be the query filter built on subquery. It is because subquery in IN is performed for every scanned record which can made query taking very loooong time.</source>
          <target state="translated">私はIN句を使用しません(上記のどこかで言及されているように)。INはconstanの短いリストで使用するために与えられたものであり、副問い合わせの上に構築されたクエリフィルタではありません。INでの副問い合わせはスキャンされたレコードごとに実行されるため、問い合わせに非常に時間がかかるからです。</target>
        </trans-unit>
        <trans-unit id="fb74c49395db7bba931e909d22e83547acbf985a" translate="yes" xml:space="preserve">
          <source>If you do it right, string comparison of two numbers should yield the same &quot;max&quot; as numeric comparison of the two numbers and it's easy to convert back to the original number using the substring function (which is available in one form or another pretty much everywhere).</source>
          <target state="translated">正しく行えば、2つの数字の文字列比較は、2つの数字の数値比較と同じ &quot;最大 &quot;を得ることができます。</target>
        </trans-unit>
        <trans-unit id="cd760119a0c1ae1b56d494acb1a10a8a2ca548fe" translate="yes" xml:space="preserve">
          <source>If you have many fields in select statement and you want latest  value for all of those fields through optimized code:</source>
          <target state="translated">select文に多くのフィールドがあり、最適化されたコードでそれらのフィールドすべての最新の値を取得したい場合。</target>
        </trans-unit>
        <trans-unit id="ee8b53705cdf9b09c80c28fb4dd6809e10ff922e" translate="yes" xml:space="preserve">
          <source>If you have two rows with &lt;code&gt;max-value-in-group&lt;/code&gt; for &lt;code&gt;group-identifier&lt;/code&gt;, both rows will be in the result in both approaches.</source>
          <target state="translated">&lt;code&gt;group-identifier&lt;/code&gt; に &lt;code&gt;max-value-in-group&lt;/code&gt; を含む2つの行がある場合、両方の行が両方のアプローチの結果になります。</target>
        </trans-unit>
        <trans-unit id="d387732b9dd594cea09224c99e2e3db7eda6d1c9" translate="yes" xml:space="preserve">
          <source>In this approach, you first find the &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; (already solved above) in a sub-query. Then you join your table to the sub-query with equality on both &lt;code&gt;group-identifier&lt;/code&gt; and &lt;code&gt;max-value-in-group&lt;/code&gt;:</source>
          <target state="translated">このアプローチでは、最初にサブクエリで &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; （上記で解決済み）を見つけます。 次に、 &lt;code&gt;group-identifier&lt;/code&gt; と &lt;code&gt;max-value-in-group&lt;/code&gt; の両方が等しいテーブルをサブクエリに結合します。</target>
        </trans-unit>
        <trans-unit id="0e261b8d5be6a8e3499be83152da6b96e488a4fc" translate="yes" xml:space="preserve">
          <source>In this approach, you left join the table with itself. Equality goes in the &lt;code&gt;group-identifier&lt;/code&gt;. Then, 2 smart moves:</source>
          <target state="translated">このアプローチでは、テーブル自体を結合したままにしました。 平等は &lt;code&gt;group-identifier&lt;/code&gt; ます。 次に、2つのスマートな動き：</target>
        </trans-unit>
        <trans-unit id="4b8e5c4e8addfc03069074421a8e679d4db14df8" translate="yes" xml:space="preserve">
          <source>It doesn't require a join</source>
          <target state="translated">ジョインを必要としません。</target>
        </trans-unit>
        <trans-unit id="ee669ad8ba2e0f5f2ee33e7468179e58169574b2" translate="yes" xml:space="preserve">
          <source>It is a little bit ugly and requires that you know something about the range of valid values of the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column.  Let us assume that we know the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column is a number between 0.00 and 999 including decimals but that there will only ever be two digits to the right of the decimal point (e.g. 34.17 would be a valid value).</source>
          <target state="translated">これは少し見苦しく、 &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt;列の有効な値の範囲について知っている必要があります。 &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt;カラムが小数を含めて0.00から999の間の数値であるが、小数点の右側に2桁しかないことを知っているとします（たとえば、34.17は有効な値です）。</target>
        </trans-unit>
        <trans-unit id="d052da643334c91fbd79130f435ea2036f8d231e" translate="yes" xml:space="preserve">
          <source>It is asked on tables having teens thusands of records, and it takes less then 0,01 second on really not too strong machine.</source>
          <target state="translated">それはレコードの十代のsheandsを持っているテーブルで尋ねられ、それは本当にあまりにも強力なマシンではなく、0,01秒以下を取ります。</target>
        </trans-unit>
        <trans-unit id="58fd729f1264da5befb4f9b9d51e8f280f1269ec" translate="yes" xml:space="preserve">
          <source>It is, actually, so common that StackOverflow community has created a single tag just to deal with questions like that: &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt;.</source>
          <target state="translated">実際、StackOverflowコミュニティがそのような質問に対処するためだけに1つのタグ、 &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt;を作成したことは非常に一般的です。</target>
        </trans-unit>
        <trans-unit id="9d0650392a80d6352d1134ecbd14115eaa3db77a" translate="yes" xml:space="preserve">
          <source>It looks like there is simpler way to do this (but &lt;strong&gt;only in MySQL&lt;/strong&gt;):</source>
          <target state="translated">これを行う簡単な方法があるようです（ただし&lt;strong&gt;、MySQLのみ&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="452d3ec3e5e3af71a122522390dfdc81b35a82a8" translate="yes" xml:space="preserve">
          <source>It should force return of only one &quot;max record&quot; even if there is a tie (sometimes useful)</source>
          <target state="translated">同点の場合でも、強制的に &quot;最大レコード &quot;を1つだけ返すようにすべきです(便利な場合もあります)</target>
        </trans-unit>
        <trans-unit id="4d2d5d921b83099b6badb0edcc209baf412da434" translate="yes" xml:space="preserve">
          <source>It's never that simple, is it?</source>
          <target state="translated">そんな単純なことはないだろう?</target>
        </trans-unit>
        <trans-unit id="11aed3f58968adfc7e701f0ecba96fda74515ce8" translate="yes" xml:space="preserve">
          <source>Joining with simple &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; Sub-query</source>
          <target state="translated">単純な &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; サブクエリを使用した結合</target>
        </trans-unit>
        <trans-unit id="460920821f4309de220f91dcb815a79c7b3c9156" translate="yes" xml:space="preserve">
          <source>Left Joining with self, tweaking join conditions and filters</source>
          <target state="translated">左 自己との結合、結合条件とフィルタの微調整</target>
        </trans-unit>
        <trans-unit id="31d0f030330e9a305782ce8d95a2c9b90fec6b29" translate="yes" xml:space="preserve">
          <source>MAX() solution runs certainly FASTER that &lt;code&gt;ROW_NUMBER()&lt;/code&gt; solution because &lt;code&gt;MAX()&lt;/code&gt; complexity is &lt;code&gt;O(n)&lt;/code&gt; while &lt;code&gt;ROW_NUMBER()&lt;/code&gt; complexity is at minimum &lt;code&gt;O(n.log(n))&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; represent the number of records in table !</source>
          <target state="translated">MAX（）ソリューションは &lt;code&gt;ROW_NUMBER()&lt;/code&gt; ソリューションよりも確実に高速に実行されます。これは、 &lt;code&gt;MAX()&lt;/code&gt; の複雑度が &lt;code&gt;O(n)&lt;/code&gt; であるのに対し、 &lt;code&gt;ROW_NUMBER()&lt;/code&gt; の複雑度は最低でも &lt;code&gt;O(n.log(n))&lt;/code&gt; であり、 &lt;code&gt;n&lt;/code&gt; はテーブル内のレコード数を表す！</target>
        </trans-unit>
        <trans-unit id="f784dda051b71346905b94e12f1c6ce43f3e7fb7" translate="yes" xml:space="preserve">
          <source>My preference is to use as little code as possible...</source>
          <target state="translated">私の好みは、できるだけコードを使わないことです...。</target>
        </trans-unit>
        <trans-unit id="460b741c73cbd00e64b87f5e4e2284a80c063282" translate="yes" xml:space="preserve">
          <source>Newer versions of MySQL come with &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; enabled by default, and many of the solutions here will &lt;em&gt;fail&lt;/em&gt; in testing with this condition.</source>
          <target state="translated">新しいバージョンのMySQLでは、デフォルトで &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; が有効になっているため、ここでのソリューションの多くは、この条件でのテストに&lt;em&gt;失敗&lt;/em&gt;します。</target>
        </trans-unit>
        <trans-unit id="dd15a32e927c00c615558f8c6498a2cdc048de59" translate="yes" xml:space="preserve">
          <source>None of these answers have worked for me.</source>
          <target state="translated">どれも私には効かなかった</target>
        </trans-unit>
        <trans-unit id="2735d006f0f78c77077d2a8f7b369c24f3a71501" translate="yes" xml:space="preserve">
          <source>Not sure if introducing variables makes the whole thing slower. But at least I'm not querying &lt;code&gt;YOURTABLE&lt;/code&gt; twice.</source>
          <target state="translated">変数を導入すると全体が遅くなるかどうかはわかりません。 しかし、少なくとも &lt;code&gt;YOURTABLE&lt;/code&gt; を 2回クエリすることはありません。</target>
        </trans-unit>
        <trans-unit id="87119c137f4237ae2ffed9b612a2cd3bc86e9351" translate="yes" xml:space="preserve">
          <source>Note that since &quot;content&quot; was &quot;...&quot; in OP's question, there's no way to test that this works.  So, I changed that to &quot;..a&quot;, &quot;..b&quot;, so, we can actually now see that the results are correct:</source>
          <target state="translated">OPの質問では「内容」が「...」になっていたので、これが機能するかどうかテストする方法がないことに注意してください。そこで、それを「...a」「...b」に変更したので、実際に結果が正しいことが確認できるようになりました。</target>
        </trans-unit>
        <trans-unit id="0fcce481af6c969086f7a3a5178c3e328716610a" translate="yes" xml:space="preserve">
          <source>Note the &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database&quot;&gt;Definition of a Relational Database&lt;/a&gt;: &quot;Each row in a table has its own unique key.&quot;  This would mean that, in the question's example, id would &lt;em&gt;have to be&lt;/em&gt; unique, and in that case, we can just do :</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database&quot;&gt;リレーショナルデータベースの定義に&lt;/a&gt;注意してください。「テーブルの各行には独自のキーがあります。」 これは、質問の例では、idは一意である&lt;em&gt;必要がある&lt;/em&gt;ことを意味&lt;em&gt;します。&lt;/em&gt;その場合、次のようにすることができます。</target>
        </trans-unit>
        <trans-unit id="cd37664721ce22baa58bcd661cd5cbf26ebc9693" translate="yes" xml:space="preserve">
          <source>One final note, as leftjoin creates n*(n+1)/2 joins in groups, its performance can be heavily affected by the size of groups...</source>
          <target state="translated">最後の注意点として、leftjoinはグループ内にn*(n+1)2個のjoinを作成するので、パフォーマンスはグループのサイズに大きく影響されます。</target>
        </trans-unit>
        <trans-unit id="5d6a717a9edad23dd4bea1b698581b82bc5a20e9" translate="yes" xml:space="preserve">
          <source>One important thing is that GROUP_CONCAT has a maximum length for the string it can build up. You probably want to raise this limit by setting the &lt;code&gt;group_concat_max_len&lt;/code&gt; variable. And keep in mind that this will be a limit on scaling if you have a large number of rows.</source>
          <target state="translated">重要なことの1つは、GROUP_CONCATには、構築できる文字列の最大長があることです。 &lt;code&gt;group_concat_max_len&lt;/code&gt; 変数を設定して、この制限を引き上げることができます。 また、行数が多い場合は、これがスケーリングの制限になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="91c7270a2e10bd5cc0fdda4e69065666aee3c4f2" translate="yes" xml:space="preserve">
          <source>SQL Fiddle :
&lt;a href=&quot;http://sqlfiddle.com/#!9/a6c585/82473/0&quot;&gt;Check here&lt;/a&gt;</source>
          <target state="translated">SQL Fiddle： &lt;a href=&quot;http://sqlfiddle.com/#!9/a6c585/82473/0&quot;&gt;ここをチェック&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4fdc1b974c1790e82135708cc7cfea1d1ffb439b" translate="yes" xml:space="preserve">
          <source>SQL select only rows with max value on a column</source>
          <target state="translated">SQLは、列の最大値を持つ行のみを選択する</target>
        </trans-unit>
        <trans-unit id="3b76449895ac57983b7b2b65399182f3103db7fa" translate="yes" xml:space="preserve">
          <source>Since this is most popular question with regard to this problem, I'll re-post another answer to it here as well:</source>
          <target state="translated">この問題に関しては、この問題が最も人気のある問題なので、ここにも別の回答を再投稿しておきます。</target>
        </trans-unit>
        <trans-unit id="d00e076b8322dcd61d6eb23264c22bf08e04282e" translate="yes" xml:space="preserve">
          <source>So you end up with:</source>
          <target state="translated">だから、最後には</target>
        </trans-unit>
        <trans-unit id="94f01ead7218d9d39d0a9e5560ffc936f4a0187b" translate="yes" xml:space="preserve">
          <source>Something like this?</source>
          <target state="translated">こんな感じかな?</target>
        </trans-unit>
        <trans-unit id="fcea27228c354bcef2642a5bc557c693423693fc" translate="yes" xml:space="preserve">
          <source>Sorted the rev field in reverse order and then grouped by id which gave the first row of each grouping which is the one with the highest rev value.</source>
          <target state="translated">revフィールドを逆順にソートし、idでグループ化しました。</target>
        </trans-unit>
        <trans-unit id="6a3870fad3df63029f67f8ef1f65f56e452059d7" translate="yes" xml:space="preserve">
          <source>Subquery SELECT is not too eficient maybe, but in JOIN clause seems to be usable. I'm not an expert in optimizing queries, but I've tried at MySQL, PostgreSQL, FireBird and it does work very good.</source>
          <target state="translated">副問い合わせのSELECTはあまり有効ではないかもしれませんが、JOIN句では使えそうです。私はクエリの最適化の専門家ではありませんが、MySQL、PostgreSQL、FireBirdで試してみましたが、非常にうまくいきました。</target>
        </trans-unit>
        <trans-unit id="5dc7723780e3da28e4fb6d9bc359f0075239e170" translate="yes" xml:space="preserve">
          <source>Tested in &lt;a href=&quot;http://sqlfiddle.com/&quot;&gt;http://sqlfiddle.com/&lt;/a&gt; with the following data</source>
          <target state="translated">次のデータを使用して&lt;a href=&quot;http://sqlfiddle.com/&quot;&gt;http://sqlfiddle.com/&lt;/a&gt;でテスト</target>
        </trans-unit>
        <trans-unit id="94226523059a44fd6d0823e04d1320c06cbf47ec" translate="yes" xml:space="preserve">
          <source>Tested on a PostgreSQL database.</source>
          <target state="translated">PostgreSQLデータベースでテストしました。</target>
        </trans-unit>
        <trans-unit id="b3309e51317016b3d5b0a251f24e195795b03f73" translate="yes" xml:space="preserve">
          <source>The above combination is simple with bit functions when &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; are &lt;code&gt;INT UNSIGNED&lt;/code&gt; (32 bit) and combined value fits to &lt;code&gt;BIGINT UNSIGNED&lt;/code&gt; (64 bit). When the &lt;code&gt;id&lt;/code&gt; &amp;amp; &lt;code&gt;rev&lt;/code&gt; are larger than 32-bit values or made of multiple columns, you need combine the value into e.g. a binary value with suitable padding for &lt;code&gt;MAX()&lt;/code&gt;.</source>
          <target state="translated">上記の組み合わせは、 &lt;code&gt;rev&lt;/code&gt; と &lt;code&gt;id&lt;/code&gt; が &lt;code&gt;INT UNSIGNED&lt;/code&gt; （32ビット）であり、組み合わせた値が &lt;code&gt;BIGINT UNSIGNED&lt;/code&gt; （64ビット）に適合する場合、ビット関数で単純です。 &lt;code&gt;id&lt;/code&gt; ＆ &lt;code&gt;rev&lt;/code&gt; が32ビット値よりも大きいか、複数の列で構成されている場合は、値を結合して、たとえば &lt;code&gt;MAX()&lt;/code&gt; に適切なパディングを使用してバイナリ値にする必要があります。</target>
        </trans-unit>
        <trans-unit id="1dd706fecc71dd4b48d2d2b09b1613cf3d0b105e" translate="yes" xml:space="preserve">
          <source>The gist of the thing is that you create a single synthetic column by string concatenating/packing the primary comparison field along with the data you want.  In this way, you can force SQL's MAX() aggregate function to return all of the data (because it has been packed into a single column).  Then you have to unpack the data.</source>
          <target state="translated">要は、一次比較フィールドに必要なデータと一緒に、一次比較フィールドを文字列連結して単一の合成カラムを作成するということです。このようにして、SQLのMAX()集約関数に強制的にすべてのデータを返すようにすることができます(1つの列にパックされているので)。その後、データを解凍する必要があります。</target>
        </trans-unit>
        <trans-unit id="00ab94e8e1f472a0caf4245bb6004e0fd4761b29" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;ROW_NUMBER()&lt;/code&gt; OVER PARTITION solution already documented in this post is</source>
          <target state="translated">この投稿にすでに記載されている他の &lt;code&gt;ROW_NUMBER()&lt;/code&gt; OVER PARTITIONソリューションは</target>
        </trans-unit>
        <trans-unit id="33daa53cf1139c305a3e6de8aaaf4c6d74e63949" translate="yes" xml:space="preserve">
          <source>The packing begins by forcing the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column to be a number of known character length regardless of the value of &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; so that for example</source>
          <target state="translated">パッキングは、 &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt;の値に関係なく、 &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt;列を既知の文字長にすることから始まります。たとえば、</target>
        </trans-unit>
        <trans-unit id="8f02bdcb5aaad48ff64e99bf617a644fa990ddcf" translate="yes" xml:space="preserve">
          <source>The second join condition is having left side value less than right value</source>
          <target state="translated">第2の結合条件は、左辺の値が右辺の値よりも小さいことです。</target>
        </trans-unit>
        <trans-unit id="0bbc6aadc07a842d6fc9d1f88ded92b6a1b29149" translate="yes" xml:space="preserve">
          <source>This 2 SELECT work well on Oracle 10g.</source>
          <target state="translated">この2つのSELECTは、Oracle 10g上でうまく動作します。</target>
        </trans-unit>
        <trans-unit id="8c0d4d65d2b2336eff8eda436b0051d18840475e" translate="yes" xml:space="preserve">
          <source>This allows me to duplicate the record, update it, increment its version number, and have the copy of the old version in such a way that I can show change over time.</source>
          <target state="translated">これにより、レコードを複製し、それを更新し、そのバージョン番号をインクリメントし、時間の経過とともに変化を示すことができるような方法で古いバージョンのコピーを持つことができます。</target>
        </trans-unit>
        <trans-unit id="2301e8326e919ecb8afe49e6e514de6a09cce684" translate="yes" xml:space="preserve">
          <source>This gave the following result in MySql 5.5 and 5.6</source>
          <target state="translated">これにより、MySql 5.5 と 5.6 では以下のような結果が得られました。</target>
        </trans-unit>
        <trans-unit id="887c512cd9ff837fd1c9fc4808909508ea838546" translate="yes" xml:space="preserve">
          <source>This is a very common question in SQL: find the whole data for the row with some max value in a column per some group identifier. I heard that a lot during my career. Actually, it was one the questions I answered in my current job's technical interview.</source>
          <target state="translated">これは、SQLでは非常に一般的な質問です:いくつかのグループ識別子ごとに列内のいくつかの最大値を持つ行のデータ全体を見つけます。これは私のキャリアの中でよく聞きました。実は、今の仕事の技術面接で答えた質問の一つでした。</target>
        </trans-unit>
        <trans-unit id="ee5febc8aebb31700d3b2dcee3dd28e23632667e" translate="yes" xml:space="preserve">
          <source>This is especially fast when there is a complex join instead of a single table. With the traditional approaches the complex join would be done twice.</source>
          <target state="translated">これは、単一のテーブルではなく複雑な結合がある場合に特に高速です。従来のアプローチでは、複雑な結合は2回行われていました。</target>
        </trans-unit>
        <trans-unit id="bf4b0ede672dafca43e39e677b31d17ea3f43666" translate="yes" xml:space="preserve">
          <source>This is not pure SQL. This will use the SQLAlchemy ORM.</source>
          <target state="translated">これは純粋なSQLではありません。これはSQLAlchemy ORMを使用します。</target>
        </trans-unit>
        <trans-unit id="e525543a18c8b2f059c99fd1eafb0e14a4a32dc4" translate="yes" xml:space="preserve">
          <source>This is what worked for me.</source>
          <target state="translated">これが私には効果がありました。</target>
        </trans-unit>
        <trans-unit id="0b48e75dada78a122caea17e73852eaaddb6181b" translate="yes" xml:space="preserve">
          <source>This query answers the question of:</source>
          <target state="translated">このクエリは、次の質問に答えています。</target>
        </trans-unit>
        <trans-unit id="59b379b84cff9d86d45433e27b3a690e1bbc3911" translate="yes" xml:space="preserve">
          <source>This solution makes only one selection from YourTable, therefore it's faster. It works only for MySQL and SQLite(for SQLite remove DESC) according to test on sqlfiddle.com. Maybe it can be tweaked to work on other languages which I am not familiar with.</source>
          <target state="translated">このソリューションはYourTableからの選択を1つだけにしているので、より高速です。sqlfiddle.comのテストによると、MySQLとSQLite(SQLiteではDESCを削除)でのみ動作します。私がよく知らない他の言語でも動作するように調整できるかもしれません。</target>
        </trans-unit>
        <trans-unit id="922fda0f734f15029de1e6477a7c86dcb4d18c7c" translate="yes" xml:space="preserve">
          <source>This will select all records with max value within the group and allows you to select other columns.</source>
          <target state="translated">これにより、グループ内の最大値を持つすべてのレコードが選択され、他の列を選択することができます。</target>
        </trans-unit>
        <trans-unit id="66639bc2c3849de3b1308222ecb4a4eb01a37f90" translate="yes" xml:space="preserve">
          <source>Use following code :</source>
          <target state="translated">以下のコードを使用してください。</target>
        </trans-unit>
        <trans-unit id="1d992c7af6b12bdffa0c4708f603e830d452ab3a" translate="yes" xml:space="preserve">
          <source>When you do step 1, the row(s) that actually have the max value will have &lt;code&gt;NULL&lt;/code&gt; in the right side (it's a &lt;code&gt;LEFT JOIN&lt;/code&gt;, remember?). Then, we filter the joined result, showing only the rows where the right side is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">手順1を実行すると、実際に最大値を持つ行の右側に &lt;code&gt;NULL&lt;/code&gt; が表示されます （これは &lt;code&gt;LEFT JOIN&lt;/code&gt; です。覚えていますか？）。 次に、結合された結果をフィルタリングして、右側が &lt;code&gt;NULL&lt;/code&gt; である行のみを表示します 。</target>
        </trans-unit>
        <trans-unit id="a9f5100d135261032402eee1426608998aac7beb" translate="yes" xml:space="preserve">
          <source>While for full table scans subquery/leftjoin/correlated timings relate to each other as 6/8/9, when it comes to direct lookups or batch (&lt;code&gt;id in (1,2,3)&lt;/code&gt;), subquery is much slower then the others (Due to rerunning the subquery). However I couldnt differentiate between leftjoin and correlated solutions in speed.</source>
          <target state="translated">フルテーブルスキャンでは、サブクエリ/レフトジョイン/相関タイミングは6/8/9として互いに関連していますが、直接ルックアップまたはバッチ（ &lt;code&gt;id in (1,2,3)&lt;/code&gt; ）になると、サブクエリは他のクエリよりもはるかに遅くなります（サブクエリを再実行したため）。 しかし、速度の点で、左結合と相関ソリューションを区別できませんでした。</target>
        </trans-unit>
        <trans-unit id="59c4f1cbf0a942eb4eb3e4a90d93e9070d57b26d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; disabled, we can use still use &lt;code&gt;GROUP BY&lt;/code&gt;, but then we are only using it on the Salary, and not the id:</source>
          <target state="translated">&lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; を無効にしても、 &lt;code&gt;GROUP BY&lt;/code&gt; を引き続き使用できますが、給与でのみ使用し、IDでは使用しません。</target>
        </trans-unit>
        <trans-unit id="a54ed92f38bc881fb7562aedd94827fd1f8b7927" translate="yes" xml:space="preserve">
          <source>With the above data, the result should contain two rows: &lt;code&gt;[1, 3, ...]&lt;/code&gt; and &lt;code&gt;[2, 1, ..]&lt;/code&gt;. I'm using &lt;strong&gt;&lt;em&gt;MySQL&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">上記のデータを使用すると、結果には &lt;code&gt;[1, 3, ...]&lt;/code&gt; と &lt;code&gt;[2, 1, ..]&lt;/code&gt; 2つの行が含まれます 。 &lt;strong&gt;&lt;em&gt;MySQL&lt;/em&gt;&lt;/strong&gt;を使用してい&lt;strong&gt;&lt;em&gt;ます&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b040793081e54b56e0ea00ab6ff5580f6556d4ae" translate="yes" xml:space="preserve">
          <source>Yes it looks awful (converting to string and back etc.) but in my experience it's usually faster than the other solutions. Maybe that just for my use cases, but I have used it on tables with millions of records and many unique ids. Maybe it's because MySQL is pretty bad at optimizing the other solutions (at least in the 5.0 days when I came up with this solution).</source>
          <target state="translated">確かに見た目はひどいですが(文字列に変換して戻ってくるなど)、私の経験では他のソリューションよりも高速です。私のユースケースに限ったことかもしれませんが、私は何百万ものレコードと多くのユニークなIDを持つテーブルで使用したことがあります。MySQLが他のソリューションの最適化をかなり苦手としているからかもしれません(少なくとも私がこのソリューションを思いついた5.0時代には)。</target>
        </trans-unit>
        <trans-unit id="27f562e6f1eb4744f3a84f65dab865c4653ea720" translate="yes" xml:space="preserve">
          <source>Yet another solution is to use a correlated subquery:</source>
          <target state="translated">さらに別の解決策は、相関副問い合わせを使用することです。</target>
        </trans-unit>
        <trans-unit id="1394ac848a2275fcc727163db03ae442b55038a4" translate="yes" xml:space="preserve">
          <source>You can do it using &lt;code&gt;IN&lt;/code&gt;
try this:</source>
          <target state="translated">あなたは &lt;code&gt;IN&lt;/code&gt; を使ってそれを行うことができますこれを試してください：</target>
        </trans-unit>
        <trans-unit id="453880e233710a43167c94bccdd5a1dd285b388f" translate="yes" xml:space="preserve">
          <source>You can make the select without a join when you combine the &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; into one &lt;code&gt;maxRevId&lt;/code&gt; value for &lt;code&gt;MAX()&lt;/code&gt; and then split it back to original values:</source>
          <target state="translated">&lt;code&gt;rev&lt;/code&gt; と &lt;code&gt;id&lt;/code&gt; を &lt;code&gt;MAX()&lt;/code&gt; の 1つの &lt;code&gt;maxRevId&lt;/code&gt; 値に組み合わせ、元の値に戻す場合は、結合なしで選択を行うことができます。</target>
        </trans-unit>
        <trans-unit id="de4507bccd6edb68f154ba28cbcd9e35a8a477f0" translate="yes" xml:space="preserve">
          <source>You can use this schema in multiple joins and with WHERE clause. It is my working example (solving identical to yours problem with table &quot;firmy&quot;):</source>
          <target state="translated">このスキーマは複数の結合とWHERE句で使用することができます。これは私の作業例です(テーブル &quot;Firmy &quot;であなたの問題と同じ問題を解決しています)。</target>
        </trans-unit>
        <trans-unit id="f94f563922394ff422dd19d7db9d395cc093c872" translate="yes" xml:space="preserve">
          <source>here is another solution hope it will help someone</source>
          <target state="translated">ここでは別の解決策は、それが誰かを助けることを願っています</target>
        </trans-unit>
        <trans-unit id="7c7f285565dd90fe18340d6bf0386ae80d43766d" translate="yes" xml:space="preserve">
          <source>to my mind it is less complicated... easier to read and maintain.</source>
          <target state="translated">私の心の中では、その方が複雑さが少なくて...読みやすく、メンテナンスも簡単です。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
