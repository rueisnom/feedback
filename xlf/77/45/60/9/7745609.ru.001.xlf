<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/7745609">
    <body>
      <group id="7745609">
        <trans-unit id="04c57be5b9e3b9472146536311d773ab598c075b" translate="yes" xml:space="preserve">
          <source>3.2    becomes    1003.201</source>
          <target state="translated">3,2 становится 1003,201</target>
        </trans-unit>
        <trans-unit id="7ee9358b03aa8d5e6b7ff5f87ff1c6c61fa1840d" translate="yes" xml:space="preserve">
          <source>57     becomes    1057.001</source>
          <target state="translated">57 становится 1057.001</target>
        </trans-unit>
        <trans-unit id="d7e7caf3da371e1159ed08c93e06650d3673a2aa" translate="yes" xml:space="preserve">
          <source>923.88 becomes    1923.881</source>
          <target state="translated">923,88 становится 1923,881</target>
        </trans-unit>
        <trans-unit id="27f0e6e0472c758e2b2f6cf7c9816fcea152f9aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(SELECT *...)&lt;/code&gt; subquery : Return all people, sorted by Salary.</source>
          <target state="translated">&lt;code&gt;(SELECT *...)&lt;/code&gt; подзапрос: Вернуть всех людей, отсортированных по зарплате.</target>
        </trans-unit>
        <trans-unit id="4a3646e38f6b0d40250be24a8869360f600bf40d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FROM Employee&lt;/code&gt; : Table searched on.</source>
          <target state="translated">&lt;code&gt;FROM Employee&lt;/code&gt; : Таблица искалась.</target>
        </trans-unit>
        <trans-unit id="51b27a498c28cb1978a214b508f3379f27cbf666" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GROUP BY Table1.id&lt;/code&gt;: Force the top-sorted, Salary row of each employee to be the returned result.</source>
          <target state="translated">&lt;code&gt;GROUP BY Table1.id&lt;/code&gt; : Принудительная сортировка строки Зарплата каждого сотрудника в качестве возвращаемого результата.</target>
        </trans-unit>
        <trans-unit id="a1b951f0bc26d85d82b83ff57fc600c0fb43a981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GROUP BY employeesub.Salary&lt;/code&gt;: Force the top-sorted, Salary row of each employee to be the returned result.</source>
          <target state="translated">&lt;code&gt;GROUP BY employeesub.Salary&lt;/code&gt; : Принудительное возвращение результата в строке зарплаты каждого сотрудника.</target>
        </trans-unit>
        <trans-unit id="b108dac77b8b8d7940ca436cb584a45df60efc79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JOIN Table1 AS Table2 ON Table2.rev = Table1.rev&lt;/code&gt; : Join the second table on the first, because, we need to get the max(table1.rev)'s comment.</source>
          <target state="translated">&lt;code&gt;JOIN Table1 AS Table2 ON Table2.rev = Table1.rev&lt;/code&gt; : Соедините вторую таблицу с первой, потому что нам нужно получить комментарий max (table1.rev).</target>
        </trans-unit>
        <trans-unit id="5d64ca2c6f022a9050f895a8140f2d84845c927e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT *&lt;/code&gt; : Return all fields.</source>
          <target state="translated">&lt;code&gt;SELECT *&lt;/code&gt; : вернуть все поля.</target>
        </trans-unit>
        <trans-unit id="f1728fe7d07f6f81ae312d65bccb6428f5d4d2d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT DISTINCT Table1.id, max(Table1.rev), max(Table2.content)&lt;/code&gt; : Return &lt;code&gt;DISTINCT&lt;/code&gt; somefield, &lt;code&gt;MAX()&lt;/code&gt; some otherfield, the last &lt;code&gt;MAX()&lt;/code&gt; is redundant, because I know it's just one row, but it's required by the query.</source>
          <target state="translated">&lt;code&gt;SELECT DISTINCT Table1.id, max(Table1.rev), max(Table2.content)&lt;/code&gt; : возвращать &lt;code&gt;DISTINCT&lt;/code&gt; somefield, &lt;code&gt;MAX()&lt;/code&gt; некоторое другое поле, последнее &lt;code&gt;MAX()&lt;/code&gt; является избыточным, потому что я знаю, что это всего одна строка, но это требуется для запрос.</target>
        </trans-unit>
        <trans-unit id="694f2b69df9ba4223789e351dba806643efc9f3c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&quot;Can you return me the records in this group of records (based on same id) that have the highest version number&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;laquo;Можете ли вы вернуть мне записи в этой группе записей (на основе одного и того же идентификатора), которые имеют наибольший номер версии&amp;raquo;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="747dc8ef6e9397eda6d614ec751270837eb5d1cc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why is it clean?&lt;/em&gt;&lt;code&gt;DISTINCT()&lt;/code&gt;, &lt;code&gt;MAX()&lt;/code&gt;, etc., all make wonderful use of MySQL indices.  This will be faster.  Or, it will be much faster, if you have indexing, and you compare it to a query that looks at all rows.</source>
          <target state="translated">&lt;em&gt;Почему это чисто?&lt;/em&gt; &lt;code&gt;DISTINCT()&lt;/code&gt; , &lt;code&gt;MAX()&lt;/code&gt; и т. Д. Прекрасно используют индексы MySQL. Это будет быстрее. Или это будет намного быстрее, если у вас есть индексирование, и вы сравниваете его с запросом, который просматривает все строки.</target>
        </trans-unit>
        <trans-unit id="ef6990676e8cbc396ebc34b6bbb2006bd98ee19c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;APPROACH&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;APPROACH&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f2f1d3f876ca275d587648c0854a40f7d75ceda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cleanest Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Чистое решение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23eda03e232c7b276914d29d144368844246997f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; though this solution works for many people it may not be stable in the long run, since MySQL doesn't guarantee that GROUP BY statement will return meaningful values for columns not in GROUP BY list. So use this solution at your own risk!</source>
          <target state="translated">&lt;strong&gt;Редактировать:&lt;/strong&gt; хотя это решение работает для многих людей, оно может быть нестабильным в долгосрочной перспективе, поскольку MySQL не гарантирует, что оператор GROUP BY будет возвращать значимые значения для столбцов, не входящих в список GROUP BY. Так что используйте это решение на свой страх и риск!</target>
        </trans-unit>
        <trans-unit id="403b25e1010d5c08346c35cf961dc40d8e1f56f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;GOOD STUFF&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ХОРОШАЯ ВЕЩЬ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a9b0dfc8a396405726470595ea946d489db2ab7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOT mySQL&lt;/strong&gt;, but for other people finding this question and using SQL, another way to resolve the &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt; problem is using &lt;a href=&quot;http://technet.microsoft.com/en-us/library/ms175156(v=sql.105).aspx&quot;&gt;&lt;code&gt;Cross Apply&lt;/code&gt;&lt;/a&gt; in MS SQL</source>
          <target state="translated">&lt;strong&gt;НЕ mySQL&lt;/strong&gt; , но для других людей, которые находят этот вопрос и используют SQL, еще один способ решения проблемы &amp;laquo; &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;наибольшие числа групп&amp;raquo;&lt;/a&gt; - это использование &lt;a href=&quot;http://technet.microsoft.com/en-us/library/ms175156(v=sql.105).aspx&quot;&gt; &lt;code&gt;Cross Apply&lt;/code&gt; &lt;/a&gt; в MS SQL.</target>
        </trans-unit>
        <trans-unit id="59f292915a0a09f846bffdf80a1afb5aad2aa92f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Оригинальное решение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c747eb526637be44701505482fa8cb37152fb689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please credit answer of user Bohemian&lt;/strong&gt; in &lt;a href=&quot;https://stackoverflow.com/questions/12102200/get-records-with-max-value-for-each-group-of-grouped-sql-results&quot;&gt;this question&lt;/a&gt; for providing such a concise and elegant answer to this problem.</source>
          <target state="translated">&lt;strong&gt;Пожалуйста, отметьте ответ пользователя Bohemian&lt;/strong&gt; в &lt;a href=&quot;https://stackoverflow.com/questions/12102200/get-records-with-max-value-for-each-group-of-grouped-sql-results&quot;&gt;этом вопросе&lt;/a&gt; за краткий и элегантный ответ на эту проблему.</target>
        </trans-unit>
        <trans-unit id="2add4d2b2581dbb1b5b57f680ba41943bb912e83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unique-Row Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Уникальное решение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e7ad05d289224982e0cbf5785062d94a875a509" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обновление 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f68ee9c7511d534eda217dbc3387c2ea2bf2888d" translate="yes" xml:space="preserve">
          <source>A third solution I hardly ever see mentioned is MySQL specific and looks like this:</source>
          <target state="translated">Третье решение,о котором я почти никогда не упоминал,является специфичным для MySQL и выглядит так:</target>
        </trans-unit>
        <trans-unit id="0359601a6c3c733dad134b61901f5ac2843959e2" translate="yes" xml:space="preserve">
          <source>Added in SQL standard ANSI/ISO Standard SQL:2003  and later extended with ANSI/ISO Standard SQL:2008, window (or windowing) functions are available with all major vendors now. There are more types of rank functions available to deal with a tie issue: &lt;code&gt;RANK, DENSE_RANK, PERSENT_RANK&lt;/code&gt;.</source>
          <target state="translated">Добавленные в стандарт SQL ANSI / ISO Standard SQL: 2003 и более поздние, дополненные ANSI / ISO Standard SQL: 2008, функции окна (или управления окнами) теперь доступны для всех основных поставщиков. Есть еще несколько типов функций ранга, доступных для решения проблемы связи: &lt;code&gt;RANK, DENSE_RANK, PERSENT_RANK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f6c5649c468f3c5b9f11dd0b6bb5bd2dcb42b60" translate="yes" xml:space="preserve">
          <source>All you need is a &lt;code&gt;GROUP BY&lt;/code&gt; clause with the &lt;code&gt;MAX&lt;/code&gt; aggregate function:</source>
          <target state="translated">Все, что вам нужно, это предложение &lt;code&gt;GROUP BY&lt;/code&gt; с агрегатной функцией &lt;code&gt;MAX&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f6746f8d362c92efc81f829dc623802dbc041661" translate="yes" xml:space="preserve">
          <source>Another manner to do the job is using &lt;code&gt;MAX()&lt;/code&gt; analytic function in OVER PARTITION clause</source>
          <target state="translated">Другой способ выполнить работу - использовать аналитическую функцию &lt;code&gt;MAX()&lt;/code&gt; в предложении OVER PARTITION.</target>
        </trans-unit>
        <trans-unit id="2db20964a9cb8621f5afa10d678b2d245436b758" translate="yes" xml:space="preserve">
          <source>Anyway, the above doesn't directly work if your content field is already text. In that case you probably want to use a different separator, like \0 maybe. You'll also run into the &lt;code&gt;group_concat_max_len&lt;/code&gt; limit quicker.</source>
          <target state="translated">В любом случае, вышеприведенное не работает напрямую, если ваше поле контента уже текстовое. В этом случае вы, вероятно, захотите использовать другой разделитель, например, \ 0. Вы также быстрее &lt;code&gt;group_concat_max_len&lt;/code&gt; лимитом group_concat_max_len .</target>
        </trans-unit>
        <trans-unit id="3dc54dc2faa3dd8f7aa080b02153c1129681f558" translate="yes" xml:space="preserve">
          <source>As the answers suggest, there &lt;em&gt;is&lt;/em&gt; a SQL solution, and &lt;a href=&quot;http://sqlfiddle.com/#!9/3d74dc/1&quot;&gt;here a sqlfiddle demo&lt;/a&gt;.</source>
          <target state="translated">Как показывают ответы, существует решение SQL, а &lt;a href=&quot;http://sqlfiddle.com/#!9/3d74dc/1&quot;&gt;здесь демонстрация sqlfiddle&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18684a622d455407c3ef979634241c7c2b8bb5c1" translate="yes" xml:space="preserve">
          <source>At first glance...</source>
          <target state="translated">На первый взгляд...</target>
        </trans-unit>
        <trans-unit id="7d20eb576a5bf5c43a34a93487e4603496ff5cfd" translate="yes" xml:space="preserve">
          <source>Basically, you have two approaches to solve that problem:</source>
          <target state="translated">По сути,у вас есть два подхода к решению этой проблемы:</target>
        </trans-unit>
        <trans-unit id="aff13b294275d46a1233bde52ba0a2304518a57e" translate="yes" xml:space="preserve">
          <source>Both approaches are SQL ANSI compatible, thus, will work with your favorite RDBMS, regardless of its &quot;flavor&quot;.</source>
          <target state="translated">Оба подхода совместимы с SQL ANSI,таким образом,будут работать с вашей любимой СУБД,независимо от ее &quot;вкуса&quot;.</target>
        </trans-unit>
        <trans-unit id="a069f75e85cfd757d1237e33836f5a5c9a7933b8" translate="yes" xml:space="preserve">
          <source>Both approaches are also performance friendly, however your mileage may vary (RDBMS, DB Structure, Indexes, etc.). So when you pick one approach over the other, &lt;em&gt;benchmark&lt;/em&gt;. And make sure you pick the one which make most of sense to you.</source>
          <target state="translated">Оба подхода также влияют на производительность, однако ваш пробег может отличаться (СУБД, структура БД, индексы и т. Д.). Поэтому, когда вы выбираете один подход, а другой - &lt;em&gt;эталонный&lt;/em&gt; . И убедитесь, что вы выбрали тот, который имеет наибольшее значение для вас.</target>
        </trans-unit>
        <trans-unit id="19563c10db076085d9b0b4f5dba8b52984789ac2" translate="yes" xml:space="preserve">
          <source>Both approaches bring the exact same result.</source>
          <target state="translated">Оба подхода дают один и тот же результат.</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="573dbbd0ba5f01ad2edaf25718f8fd20afb0f654" translate="yes" xml:space="preserve">
          <source>Currently I use checks in the &lt;code&gt;while&lt;/code&gt; loop to detect and over-write old revs from the resultset. But is this the only method to achieve the result? Isn't there a &lt;strong&gt;SQL&lt;/strong&gt; solution?</source>
          <target state="translated">В настоящее время я использую проверки в цикле while для обнаружения и перезаписи старых оборотов из набора результатов. Но является ли это единственным методом достижения результата? Разве нет решения &lt;strong&gt;SQL&lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="3bedaf93cca4db2c2a031f628273b205d4c103de" translate="yes" xml:space="preserve">
          <source>DB Fiddle</source>
          <target state="translated">ДБ скрипка</target>
        </trans-unit>
        <trans-unit id="af49ccd16ea8ee6847aa18e5e026d91269d1340a" translate="yes" xml:space="preserve">
          <source>Even so, we can simply select &lt;code&gt;DISTINCT&lt;/code&gt;&lt;em&gt;someuniquefield&lt;/em&gt;, &lt;code&gt;MAX(&lt;/code&gt;&lt;em&gt;whateverotherfieldtoselect&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt; *somethirdfield &lt;code&gt;)&lt;/code&gt;, etc., and have no worries understanding the result or how the query works :</source>
          <target state="translated">Тем не менее, мы можем просто выбрать &lt;code&gt;DISTINCT&lt;/code&gt; &lt;em&gt;someuniquefield&lt;/em&gt; , &lt;code&gt;MAX(&lt;/code&gt; &lt;em&gt;whateverotherfieldtoselect&lt;/em&gt; &lt;code&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;/code&gt; * somethird field &lt;code&gt;)&lt;/code&gt; и т. Д. И не беспокоиться о результате или о том, как работает запрос:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="000d91fadfba91936529d79d0821bb7195a90ba6" translate="yes" xml:space="preserve">
          <source>Following are comparisons to the solutions in @AdrianCarneiro's answer (subquery, leftjoin), based on MySQL measurements with InnoDB table of ~1million records, group size being: 1-3.</source>
          <target state="translated">Ниже приведены сравнения с решениями в ответе @AdrianCarneiro (подзапрос,левое соединение),основанном на измерениях MySQL с таблицей InnoDB ~1 миллион записей,при этом размер группы равен @AdrianCarneiro:1-3.</target>
        </trans-unit>
        <trans-unit id="995071277e83cf1d1f1c4a8ccb804e62ea4b68dd" translate="yes" xml:space="preserve">
          <source>Having an index on (id,rev) renders the subquery almost as a simple lookup...</source>
          <target state="translated">Наличие индекса на (id,rev)делает подзапрос почти простым поиском...</target>
        </trans-unit>
        <trans-unit id="314d916008f70bef56e0b0d15d12dfe541cea6a1" translate="yes" xml:space="preserve">
          <source>Here is a nice way of doing that</source>
          <target state="translated">Вот хороший способ сделать это</target>
        </trans-unit>
        <trans-unit id="471fa8e0858c0f841233c444b4700b23aee1ab66" translate="yes" xml:space="preserve">
          <source>Here's an example in SqlFiddle</source>
          <target state="translated">Вот пример в SqlFiddle.</target>
        </trans-unit>
        <trans-unit id="9164d1faed37c4623fd975150fe3872405f41423" translate="yes" xml:space="preserve">
          <source>Here's another solution to retrieving the records only with a field that has the maximum value for that field. This works for SQL400 which is the platform I work on. In this example, the records with the maximum value in field FIELD5 will be retrieved by the following SQL statement.</source>
          <target state="translated">Вот еще одно решение для получения записей только с полем,которое имеет максимальное значение для этого поля.Это работает для SQL400-платформы,над которой я работаю.В данном примере записи с максимальным значением в поле FIELD5 будут извлекаться следующим оператором SQL.</target>
        </trans-unit>
        <trans-unit id="a6f33200f27d1f02a32897ce39b81c9ee560e6d6" translate="yes" xml:space="preserve">
          <source>Here's how it looks with the above example, written in SQL</source>
          <target state="translated">Вот как это выглядит на примере,написанном на SQL.</target>
        </trans-unit>
        <trans-unit id="9e3a68cc958a74ba34c6bcb6c78f492a33cda5ba" translate="yes" xml:space="preserve">
          <source>Hopefully this is a solution that solves the problem and helps everyone better understand what's happening in the DB.</source>
          <target state="translated">Надеюсь,что это решение решит проблему и поможет всем лучше понять,что происходит в БД.</target>
        </trans-unit>
        <trans-unit id="17aca0cf466b23a9d66f040adc39824d44c21641" translate="yes" xml:space="preserve">
          <source>How about this:</source>
          <target state="translated">Как насчет этого:</target>
        </trans-unit>
        <trans-unit id="10913cb8e1a0c820785850e0e7d418afaaf3b084" translate="yes" xml:space="preserve">
          <source>How do I select one row per id and only the greatest rev?</source>
          <target state="translated">Как выбрать одну строку на id и только величайший обход?</target>
        </trans-unit>
        <trans-unit id="19cbcd14e6b2211943bc8ae571c9613a49c99e92" translate="yes" xml:space="preserve">
          <source>I am flabbergasted that no answer offered SQL window function solution:</source>
          <target state="translated">Я поражен тем,что ни один из ответов не предложил решения для SQL-окновой функции:</target>
        </trans-unit>
        <trans-unit id="c63f6bb578d3ae9db96662ba13e29dc33c243f8f" translate="yes" xml:space="preserve">
          <source>I came here looking for SQLAlchemy help, so I will duplicate Adrian Carneiro's answer with the python/SQLAlchemy version, specifically the outer join part.</source>
          <target state="translated">Я пришел сюда в поисках помощи SQLAlchemy,так что я буду дублировать ответ Адриана Карнейро с версией pythonSQLAlchemy,а именно с внешней соединительной частью.</target>
        </trans-unit>
        <trans-unit id="c10b9ffc525b97bcbece3250c202bd16cad8beb3" translate="yes" xml:space="preserve">
          <source>I can't vouch for the performance, but here's a trick inspired by the limitations of Microsoft Excel.  It has some good features</source>
          <target state="translated">Я не могу поручиться за производительность,но вот трюк,вдохновленный ограничениями Microsoft Excel.У него есть несколько хороших функций.</target>
        </trans-unit>
        <trans-unit id="67a7d23c38d29857f72aac73ca9af605f944a2d1" translate="yes" xml:space="preserve">
          <source>I have this table for documents (simplified version here):</source>
          <target state="translated">У меня есть эта таблица для документов (упрощенная версия здесь):</target>
        </trans-unit>
        <trans-unit id="d582544f0807601e4b6511e7bdec729115bf914b" translate="yes" xml:space="preserve">
          <source>I just noticed you need the &lt;code&gt;content&lt;/code&gt; column as well.</source>
          <target state="translated">Я только что заметил, что вам нужен столбец &lt;code&gt;content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8dfea75f00120de3d7deedb3de7608fd0c28237" translate="yes" xml:space="preserve">
          <source>I like to do this by ranking the records by some column. In this case, rank &lt;code&gt;rev&lt;/code&gt; values grouped by &lt;code&gt;id&lt;/code&gt;. Those with higher &lt;code&gt;rev&lt;/code&gt; will have lower rankings. So highest &lt;code&gt;rev&lt;/code&gt; will have ranking of 1.</source>
          <target state="translated">Мне нравится делать это, ранжируя записи по некоторым столбцам. В этом случае &lt;code&gt;rev&lt;/code&gt; значения rev сгруппированы по &lt;code&gt;id&lt;/code&gt; . Те, у кого более высокие &lt;code&gt;rev&lt;/code&gt; будут иметь более низкий рейтинг. Таким образом, самый высокий &lt;code&gt;rev&lt;/code&gt; будет иметь рейтинг 1.</target>
        </trans-unit>
        <trans-unit id="33448d590cc783d19b7e088f10f0cc5625c1e617" translate="yes" xml:space="preserve">
          <source>I like to use a &lt;code&gt;NOT EXIST&lt;/code&gt;-based solution for this problem:</source>
          <target state="translated">Мне нравится использовать решение &lt;code&gt;NOT EXIST&lt;/code&gt; для этой проблемы:</target>
        </trans-unit>
        <trans-unit id="3a69c1874c939239de03ecc1482256501bce00b2" translate="yes" xml:space="preserve">
          <source>I noticed after adding the above &lt;em&gt;sqlfiddle&lt;/em&gt;, the rate at which the question is upvoted has surpassed the upvote rate of the answers. That has not been the intention! The fiddle is based on the answers, especially the accepted answer.</source>
          <target state="translated">Я заметил, что после добавления вышеупомянутого &lt;em&gt;sqlfiddle&lt;/em&gt; , скорость, с которой вопрос поднимается, превзошла скорость ответов. Это не было намерением! Скрипка основана на ответах, особенно принятых ответах.</target>
        </trans-unit>
        <trans-unit id="31b46e90abba135e2e191919836bd8d723638c3d" translate="yes" xml:space="preserve">
          <source>I then joined these max values (#temp1) to all of the possible id/content combinations. By doing this, I naturally filter out the non-maximum id/content combinations, and am left with the only max rev values for each.</source>
          <target state="translated">Затем я присоединил эти максимальные значения (#temp1)ко всем возможным комбинациям idcontent.Таким образом,я естественным образом отфильтровываю немаксимальные комбинации идконтента,и для каждой из них остаётся только одно максимальное значение оборотов.</target>
        </trans-unit>
        <trans-unit id="eedb27620fc870cd05408ec33312da837f122366" translate="yes" xml:space="preserve">
          <source>I think, You want this?</source>
          <target state="translated">Я думаю,ты хочешь этого?</target>
        </trans-unit>
        <trans-unit id="475f1dbf29984af602be998bcf11558846a40db9" translate="yes" xml:space="preserve">
          <source>I used the below to solve a problem of my own. I first created a temp table and inserted the max rev value per unique id.</source>
          <target state="translated">Я использовал ниже,чтобы решить свою собственную проблему.Сначала я создал временную таблицу и вставил максимальное значение оборотов для уникального идентификатора.</target>
        </trans-unit>
        <trans-unit id="90195caa2158153b6d15ffbd881bc0002f84edd8" translate="yes" xml:space="preserve">
          <source>I would use this:</source>
          <target state="translated">Я бы использовал это:</target>
        </trans-unit>
        <trans-unit id="91840954cb9c4ea1b61596b1a83ee83e2ea511b0" translate="yes" xml:space="preserve">
          <source>I wouldn't use IN clause (as it is mentioned somewhere above). IN is given to use with short lists of constans, and not as to be the query filter built on subquery. It is because subquery in IN is performed for every scanned record which can made query taking very loooong time.</source>
          <target state="translated">Я бы не стал использовать IN-пункт (как упомянуто где-то выше).IN дано для использования с короткими списками констант,а не как фильтр запросов,построенный на подзапросах.А потому,что подзапрос в IN выполняется для каждой сканируемой записи,что может сделать запрос,занимающий очень мало времени.</target>
        </trans-unit>
        <trans-unit id="fb74c49395db7bba931e909d22e83547acbf985a" translate="yes" xml:space="preserve">
          <source>If you do it right, string comparison of two numbers should yield the same &quot;max&quot; as numeric comparison of the two numbers and it's easy to convert back to the original number using the substring function (which is available in one form or another pretty much everywhere).</source>
          <target state="translated">Если делать это правильно,то сравнение строк двух чисел должно давать то же самое &quot;max&quot;,что и численное сравнение двух чисел,и его легко преобразовать обратно в исходное число с помощью функции подстроки (которая доступна в том или ином виде практически везде).</target>
        </trans-unit>
        <trans-unit id="cd760119a0c1ae1b56d494acb1a10a8a2ca548fe" translate="yes" xml:space="preserve">
          <source>If you have many fields in select statement and you want latest  value for all of those fields through optimized code:</source>
          <target state="translated">Если у вас много полей в операторе выбора и вы хотите,чтобы последнее значение для всех этих полей было оптимизированным кодом:</target>
        </trans-unit>
        <trans-unit id="ee8b53705cdf9b09c80c28fb4dd6809e10ff922e" translate="yes" xml:space="preserve">
          <source>If you have two rows with &lt;code&gt;max-value-in-group&lt;/code&gt; for &lt;code&gt;group-identifier&lt;/code&gt;, both rows will be in the result in both approaches.</source>
          <target state="translated">Если у вас есть две строки с &lt;code&gt;max-value-in-group&lt;/code&gt; для &lt;code&gt;group-identifier&lt;/code&gt; , обе строки будут в результате в обоих подходах.</target>
        </trans-unit>
        <trans-unit id="d387732b9dd594cea09224c99e2e3db7eda6d1c9" translate="yes" xml:space="preserve">
          <source>In this approach, you first find the &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; (already solved above) in a sub-query. Then you join your table to the sub-query with equality on both &lt;code&gt;group-identifier&lt;/code&gt; and &lt;code&gt;max-value-in-group&lt;/code&gt;:</source>
          <target state="translated">При таком подходе вы сначала находите &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; (уже решенный выше) в подзапросе. Затем вы присоединяете свою таблицу к подзапросу с равенством как по &lt;code&gt;group-identifier&lt;/code&gt; и по &lt;code&gt;max-value-in-group&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0e261b8d5be6a8e3499be83152da6b96e488a4fc" translate="yes" xml:space="preserve">
          <source>In this approach, you left join the table with itself. Equality goes in the &lt;code&gt;group-identifier&lt;/code&gt;. Then, 2 smart moves:</source>
          <target state="translated">При таком подходе вы оставляете за столом присоединение к себе. Равенство идет в &lt;code&gt;group-identifier&lt;/code&gt; . Затем 2 умных хода:</target>
        </trans-unit>
        <trans-unit id="4b8e5c4e8addfc03069074421a8e679d4db14df8" translate="yes" xml:space="preserve">
          <source>It doesn't require a join</source>
          <target state="translated">Это не требует соединения</target>
        </trans-unit>
        <trans-unit id="ee669ad8ba2e0f5f2ee33e7468179e58169574b2" translate="yes" xml:space="preserve">
          <source>It is a little bit ugly and requires that you know something about the range of valid values of the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column.  Let us assume that we know the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column is a number between 0.00 and 999 including decimals but that there will only ever be two digits to the right of the decimal point (e.g. 34.17 would be a valid value).</source>
          <target state="translated">Это немного уродливо и требует, чтобы вы что-то знали о диапазоне допустимых значений столбца &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; . Предположим, что мы знаем, что столбец &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; - это число от 0,00 до 999, включая десятичные дроби, но справа от десятичной точки будут только две цифры (например, 34.17 будет допустимым значением).</target>
        </trans-unit>
        <trans-unit id="d052da643334c91fbd79130f435ea2036f8d231e" translate="yes" xml:space="preserve">
          <source>It is asked on tables having teens thusands of records, and it takes less then 0,01 second on really not too strong machine.</source>
          <target state="translated">Он спрашивается на столах,имеющих подростки при этом и записи,и занимает менее 0,01 секунды на действительно не слишком сильной машине.</target>
        </trans-unit>
        <trans-unit id="58fd729f1264da5befb4f9b9d51e8f280f1269ec" translate="yes" xml:space="preserve">
          <source>It is, actually, so common that StackOverflow community has created a single tag just to deal with questions like that: &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt;.</source>
          <target state="translated">На самом деле, это настолько распространено, что сообщество StackOverflow создало единый тег для решения таких вопросов: &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;наибольший-на-группу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d0650392a80d6352d1134ecbd14115eaa3db77a" translate="yes" xml:space="preserve">
          <source>It looks like there is simpler way to do this (but &lt;strong&gt;only in MySQL&lt;/strong&gt;):</source>
          <target state="translated">Похоже, есть более простой способ сделать это (но &lt;strong&gt;только в MySQL&lt;/strong&gt; ):</target>
        </trans-unit>
        <trans-unit id="452d3ec3e5e3af71a122522390dfdc81b35a82a8" translate="yes" xml:space="preserve">
          <source>It should force return of only one &quot;max record&quot; even if there is a tie (sometimes useful)</source>
          <target state="translated">Она должна принудительно возвращать только одну &quot;максимальную запись&quot;,даже если есть галстук (иногда полезно).</target>
        </trans-unit>
        <trans-unit id="4d2d5d921b83099b6badb0edcc209baf412da434" translate="yes" xml:space="preserve">
          <source>It's never that simple, is it?</source>
          <target state="translated">Это никогда не бывает так просто,не так ли?</target>
        </trans-unit>
        <trans-unit id="11aed3f58968adfc7e701f0ecba96fda74515ce8" translate="yes" xml:space="preserve">
          <source>Joining with simple &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; Sub-query</source>
          <target state="translated">Объединение с простым &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; подзапросом max-value-in-group</target>
        </trans-unit>
        <trans-unit id="460920821f4309de220f91dcb815a79c7b3c9156" translate="yes" xml:space="preserve">
          <source>Left Joining with self, tweaking join conditions and filters</source>
          <target state="translated">Слева Соединяясь с собой,подстраивая условия соединения и фильтры</target>
        </trans-unit>
        <trans-unit id="31d0f030330e9a305782ce8d95a2c9b90fec6b29" translate="yes" xml:space="preserve">
          <source>MAX() solution runs certainly FASTER that &lt;code&gt;ROW_NUMBER()&lt;/code&gt; solution because &lt;code&gt;MAX()&lt;/code&gt; complexity is &lt;code&gt;O(n)&lt;/code&gt; while &lt;code&gt;ROW_NUMBER()&lt;/code&gt; complexity is at minimum &lt;code&gt;O(n.log(n))&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; represent the number of records in table !</source>
          <target state="translated">Решение MAX (), безусловно, &lt;code&gt;ROW_NUMBER()&lt;/code&gt; решение ROW_NUMBER (), поскольку сложность &lt;code&gt;MAX()&lt;/code&gt; равна &lt;code&gt;O(n)&lt;/code&gt; а сложность &lt;code&gt;ROW_NUMBER()&lt;/code&gt; - как минимум &lt;code&gt;O(n.log(n))&lt;/code&gt; где &lt;code&gt;n&lt;/code&gt; представляет количество записей в таблице!</target>
        </trans-unit>
        <trans-unit id="f784dda051b71346905b94e12f1c6ce43f3e7fb7" translate="yes" xml:space="preserve">
          <source>My preference is to use as little code as possible...</source>
          <target state="translated">Я предпочитаю использовать как можно меньше кода...</target>
        </trans-unit>
        <trans-unit id="460b741c73cbd00e64b87f5e4e2284a80c063282" translate="yes" xml:space="preserve">
          <source>Newer versions of MySQL come with &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; enabled by default, and many of the solutions here will &lt;em&gt;fail&lt;/em&gt; in testing with this condition.</source>
          <target state="translated">Более новые версии MySQL поставляются с &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; , включенным по умолчанию, и многие решения здесь не пройдут тестирование с этим условием.</target>
        </trans-unit>
        <trans-unit id="dd15a32e927c00c615558f8c6498a2cdc048de59" translate="yes" xml:space="preserve">
          <source>None of these answers have worked for me.</source>
          <target state="translated">Ни один из этих ответов не сработал на меня.</target>
        </trans-unit>
        <trans-unit id="2735d006f0f78c77077d2a8f7b369c24f3a71501" translate="yes" xml:space="preserve">
          <source>Not sure if introducing variables makes the whole thing slower. But at least I'm not querying &lt;code&gt;YOURTABLE&lt;/code&gt; twice.</source>
          <target state="translated">Не уверен, что введение переменных замедляет процесс. Но, по крайней мере, я не запрашиваю &lt;code&gt;YOURTABLE&lt;/code&gt; дважды.</target>
        </trans-unit>
        <trans-unit id="87119c137f4237ae2ffed9b612a2cd3bc86e9351" translate="yes" xml:space="preserve">
          <source>Note that since &quot;content&quot; was &quot;...&quot; in OP's question, there's no way to test that this works.  So, I changed that to &quot;..a&quot;, &quot;..b&quot;, so, we can actually now see that the results are correct:</source>
          <target state="translated">Обратите внимание,что поскольку &quot;содержание&quot; было &quot;...&quot; в вопросе ОП,нет способа проверить,что это работает.Поэтому я изменил это на &quot;...а&quot;,&quot;...б&quot;,так что теперь мы можем видеть,что результаты верны:</target>
        </trans-unit>
        <trans-unit id="0fcce481af6c969086f7a3a5178c3e328716610a" translate="yes" xml:space="preserve">
          <source>Note the &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database&quot;&gt;Definition of a Relational Database&lt;/a&gt;: &quot;Each row in a table has its own unique key.&quot;  This would mean that, in the question's example, id would &lt;em&gt;have to be&lt;/em&gt; unique, and in that case, we can just do :</source>
          <target state="translated">Обратите внимание на &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database&quot;&gt;определение реляционной базы данных&lt;/a&gt; : &amp;laquo;Каждая строка в таблице имеет свой уникальный ключ&amp;raquo;. Это будет означать, что в примере вопроса id должен &lt;em&gt;быть&lt;/em&gt; уникальным, и в этом случае мы можем просто сделать:</target>
        </trans-unit>
        <trans-unit id="cd37664721ce22baa58bcd661cd5cbf26ebc9693" translate="yes" xml:space="preserve">
          <source>One final note, as leftjoin creates n*(n+1)/2 joins in groups, its performance can be heavily affected by the size of groups...</source>
          <target state="translated">И последнее замечание,так как левое соединение создает n*(n+1)2 соединения в группы,на его производительность может сильно повлиять размер групп....</target>
        </trans-unit>
        <trans-unit id="5d6a717a9edad23dd4bea1b698581b82bc5a20e9" translate="yes" xml:space="preserve">
          <source>One important thing is that GROUP_CONCAT has a maximum length for the string it can build up. You probably want to raise this limit by setting the &lt;code&gt;group_concat_max_len&lt;/code&gt; variable. And keep in mind that this will be a limit on scaling if you have a large number of rows.</source>
          <target state="translated">Одна важная вещь заключается в том, что GROUP_CONCAT имеет максимальную длину для строки, которую он может создать. Возможно, вы захотите поднять этот предел, установив переменную &lt;code&gt;group_concat_max_len&lt;/code&gt; . И имейте в виду, что это будет предел для масштабирования, если у вас есть большое количество строк.</target>
        </trans-unit>
        <trans-unit id="91c7270a2e10bd5cc0fdda4e69065666aee3c4f2" translate="yes" xml:space="preserve">
          <source>SQL Fiddle :
&lt;a href=&quot;http://sqlfiddle.com/#!9/a6c585/82473/0&quot;&gt;Check here&lt;/a&gt;</source>
          <target state="translated">SQL Fiddle: &lt;a href=&quot;http://sqlfiddle.com/#!9/a6c585/82473/0&quot;&gt;проверьте здесь&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4fdc1b974c1790e82135708cc7cfea1d1ffb439b" translate="yes" xml:space="preserve">
          <source>SQL select only rows with max value on a column</source>
          <target state="translated">SQL выбирает только строки с максимальным значением в столбце</target>
        </trans-unit>
        <trans-unit id="3b76449895ac57983b7b2b65399182f3103db7fa" translate="yes" xml:space="preserve">
          <source>Since this is most popular question with regard to this problem, I'll re-post another answer to it here as well:</source>
          <target state="translated">Так как это самый популярный вопрос в связи с этой проблемой,я перепоставлю другой ответ на него и здесь:</target>
        </trans-unit>
        <trans-unit id="d00e076b8322dcd61d6eb23264c22bf08e04282e" translate="yes" xml:space="preserve">
          <source>So you end up with:</source>
          <target state="translated">Так что в конце концов:</target>
        </trans-unit>
        <trans-unit id="94f01ead7218d9d39d0a9e5560ffc936f4a0187b" translate="yes" xml:space="preserve">
          <source>Something like this?</source>
          <target state="translated">Что-то вроде этого?</target>
        </trans-unit>
        <trans-unit id="fcea27228c354bcef2642a5bc557c693423693fc" translate="yes" xml:space="preserve">
          <source>Sorted the rev field in reverse order and then grouped by id which gave the first row of each grouping which is the one with the highest rev value.</source>
          <target state="translated">Сортировка поля rev в обратном порядке,а затем группировка по id,которая дала первую строку каждой группировки,которая является той,которая имеет наибольшее значение оборотов.</target>
        </trans-unit>
        <trans-unit id="6a3870fad3df63029f67f8ef1f65f56e452059d7" translate="yes" xml:space="preserve">
          <source>Subquery SELECT is not too eficient maybe, but in JOIN clause seems to be usable. I'm not an expert in optimizing queries, but I've tried at MySQL, PostgreSQL, FireBird and it does work very good.</source>
          <target state="translated">Подзапрос SELECT,возможно,не слишком эффективен,но в пункте JOIN кажется,что его можно использовать.Я не эксперт по оптимизации запросов,но я пробовал на MySQL,PostgreSQL,FireBird и он работает очень хорошо.</target>
        </trans-unit>
        <trans-unit id="5dc7723780e3da28e4fb6d9bc359f0075239e170" translate="yes" xml:space="preserve">
          <source>Tested in &lt;a href=&quot;http://sqlfiddle.com/&quot;&gt;http://sqlfiddle.com/&lt;/a&gt; with the following data</source>
          <target state="translated">Протестировано в &lt;a href=&quot;http://sqlfiddle.com/&quot;&gt;http://sqlfiddle.com/&lt;/a&gt; со следующими данными</target>
        </trans-unit>
        <trans-unit id="94226523059a44fd6d0823e04d1320c06cbf47ec" translate="yes" xml:space="preserve">
          <source>Tested on a PostgreSQL database.</source>
          <target state="translated">Протестировано на базе данных PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="b3309e51317016b3d5b0a251f24e195795b03f73" translate="yes" xml:space="preserve">
          <source>The above combination is simple with bit functions when &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; are &lt;code&gt;INT UNSIGNED&lt;/code&gt; (32 bit) and combined value fits to &lt;code&gt;BIGINT UNSIGNED&lt;/code&gt; (64 bit). When the &lt;code&gt;id&lt;/code&gt; &amp;amp; &lt;code&gt;rev&lt;/code&gt; are larger than 32-bit values or made of multiple columns, you need combine the value into e.g. a binary value with suitable padding for &lt;code&gt;MAX()&lt;/code&gt;.</source>
          <target state="translated">Приведенная выше комбинация проста с битовыми функциями, когда &lt;code&gt;rev&lt;/code&gt; и &lt;code&gt;id&lt;/code&gt; имеют значение &lt;code&gt;INT UNSIGNED&lt;/code&gt; (32 бита), а объединенное значение соответствует значению &lt;code&gt;BIGINT UNSIGNED&lt;/code&gt; (64 бита). Когда &lt;code&gt;id&lt;/code&gt; &amp;amp; &lt;code&gt;rev&lt;/code&gt; больше 32-битных значений или состоят из нескольких столбцов, необходимо объединить значение, например, в двоичное значение с подходящим заполнением для &lt;code&gt;MAX()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd706fecc71dd4b48d2d2b09b1613cf3d0b105e" translate="yes" xml:space="preserve">
          <source>The gist of the thing is that you create a single synthetic column by string concatenating/packing the primary comparison field along with the data you want.  In this way, you can force SQL's MAX() aggregate function to return all of the data (because it has been packed into a single column).  Then you have to unpack the data.</source>
          <target state="translated">Суть в том,что вы создаете один синтетический столбец строкой,конкатенуя упаковку первичного поля сравнения вместе с данными,которые вам нужны.Таким образом,вы можете заставить SQL функцию агрегации MAX()вернуть все данные (потому что они были упакованы в один столбец).Затем Вам необходимо распаковать данные.</target>
        </trans-unit>
        <trans-unit id="00ab94e8e1f472a0caf4245bb6004e0fd4761b29" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;ROW_NUMBER()&lt;/code&gt; OVER PARTITION solution already documented in this post is</source>
          <target state="translated">Другое &lt;code&gt;ROW_NUMBER()&lt;/code&gt; OVER PARTITION, уже задокументированное в этом посте,</target>
        </trans-unit>
        <trans-unit id="33daa53cf1139c305a3e6de8aaaf4c6d74e63949" translate="yes" xml:space="preserve">
          <source>The packing begins by forcing the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column to be a number of known character length regardless of the value of &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; so that for example</source>
          <target state="translated">Упаковка начинается с того, что значение столбца &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; будет равным известной длине символа независимо от значения &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; , например,</target>
        </trans-unit>
        <trans-unit id="8f02bdcb5aaad48ff64e99bf617a644fa990ddcf" translate="yes" xml:space="preserve">
          <source>The second join condition is having left side value less than right value</source>
          <target state="translated">Второе условие соединения имеет значение с левой стороны меньше,чем с правой.</target>
        </trans-unit>
        <trans-unit id="0bbc6aadc07a842d6fc9d1f88ded92b6a1b29149" translate="yes" xml:space="preserve">
          <source>This 2 SELECT work well on Oracle 10g.</source>
          <target state="translated">Этот 2 SELECT хорошо работает на Oracle 10g.</target>
        </trans-unit>
        <trans-unit id="8c0d4d65d2b2336eff8eda436b0051d18840475e" translate="yes" xml:space="preserve">
          <source>This allows me to duplicate the record, update it, increment its version number, and have the copy of the old version in such a way that I can show change over time.</source>
          <target state="translated">Это позволяет мне дублировать запись,обновлять ее,увеличивать ее номер версии и иметь копию старой версии таким образом,чтобы я мог показывать изменения с течением времени.</target>
        </trans-unit>
        <trans-unit id="2301e8326e919ecb8afe49e6e514de6a09cce684" translate="yes" xml:space="preserve">
          <source>This gave the following result in MySql 5.5 and 5.6</source>
          <target state="translated">Это дало следующий результат в MySql 5.5 и 5.6.</target>
        </trans-unit>
        <trans-unit id="887c512cd9ff837fd1c9fc4808909508ea838546" translate="yes" xml:space="preserve">
          <source>This is a very common question in SQL: find the whole data for the row with some max value in a column per some group identifier. I heard that a lot during my career. Actually, it was one the questions I answered in my current job's technical interview.</source>
          <target state="translated">В SQL это очень распространенный вопрос:найти целые данные для строки с некоторым максимальным значением в столбце на какой-то идентификатор группы.Я много об этом слышал за свою карьеру.На самом деле,это был один из вопросов,на который я ответил на собеседовании по технической части моей текущей работы.</target>
        </trans-unit>
        <trans-unit id="ee5febc8aebb31700d3b2dcee3dd28e23632667e" translate="yes" xml:space="preserve">
          <source>This is especially fast when there is a complex join instead of a single table. With the traditional approaches the complex join would be done twice.</source>
          <target state="translated">Это особенно быстро,когда вместо одного стола есть сложное соединение.При традиционных подходах сложное соединение выполняется дважды.</target>
        </trans-unit>
        <trans-unit id="bf4b0ede672dafca43e39e677b31d17ea3f43666" translate="yes" xml:space="preserve">
          <source>This is not pure SQL. This will use the SQLAlchemy ORM.</source>
          <target state="translated">Это не чистый SQL.Для этого будет использоваться SQLAlchemy ORM.</target>
        </trans-unit>
        <trans-unit id="e525543a18c8b2f059c99fd1eafb0e14a4a32dc4" translate="yes" xml:space="preserve">
          <source>This is what worked for me.</source>
          <target state="translated">Это то,что сработало со мной.</target>
        </trans-unit>
        <trans-unit id="0b48e75dada78a122caea17e73852eaaddb6181b" translate="yes" xml:space="preserve">
          <source>This query answers the question of:</source>
          <target state="translated">Этот вопрос отвечает на вопрос:</target>
        </trans-unit>
        <trans-unit id="59b379b84cff9d86d45433e27b3a690e1bbc3911" translate="yes" xml:space="preserve">
          <source>This solution makes only one selection from YourTable, therefore it's faster. It works only for MySQL and SQLite(for SQLite remove DESC) according to test on sqlfiddle.com. Maybe it can be tweaked to work on other languages which I am not familiar with.</source>
          <target state="translated">Это решение делает только один выбор из YourTable,поэтому оно быстрее.Оно работает только для MySQL и SQLite (для SQLite удалить DESC)в соответствии с тестом на sqlfiddle.com.Возможно,его можно настроить на работу с другими языками,с которыми я не знаком.</target>
        </trans-unit>
        <trans-unit id="922fda0f734f15029de1e6477a7c86dcb4d18c7c" translate="yes" xml:space="preserve">
          <source>This will select all records with max value within the group and allows you to select other columns.</source>
          <target state="translated">При этом будут выбраны все записи с максимальным значением внутри группы,а также будут выбраны другие столбцы.</target>
        </trans-unit>
        <trans-unit id="66639bc2c3849de3b1308222ecb4a4eb01a37f90" translate="yes" xml:space="preserve">
          <source>Use following code :</source>
          <target state="translated">Используйте следующий код :</target>
        </trans-unit>
        <trans-unit id="1d992c7af6b12bdffa0c4708f603e830d452ab3a" translate="yes" xml:space="preserve">
          <source>When you do step 1, the row(s) that actually have the max value will have &lt;code&gt;NULL&lt;/code&gt; in the right side (it's a &lt;code&gt;LEFT JOIN&lt;/code&gt;, remember?). Then, we filter the joined result, showing only the rows where the right side is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Когда вы выполните шаг 1, строки (строки), которые на самом деле имеют максимальное значение, будут иметь &lt;code&gt;NULL&lt;/code&gt; с правой стороны (это &lt;code&gt;LEFT JOIN&lt;/code&gt; , помните?). Затем мы фильтруем объединенный результат, показывая только те строки, где правая сторона равна &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9f5100d135261032402eee1426608998aac7beb" translate="yes" xml:space="preserve">
          <source>While for full table scans subquery/leftjoin/correlated timings relate to each other as 6/8/9, when it comes to direct lookups or batch (&lt;code&gt;id in (1,2,3)&lt;/code&gt;), subquery is much slower then the others (Due to rerunning the subquery). However I couldnt differentiate between leftjoin and correlated solutions in speed.</source>
          <target state="translated">В то время как для полных сканирований таблицы подзапрос / левостороннее / коррелированное время соотносятся друг с другом как 6/8/9, когда речь идет о прямом поиске или пакетной обработке ( &lt;code&gt;id in (1,2,3)&lt;/code&gt; ), подзапрос намного медленнее, чем другие ( Из-за перезапуска подзапроса). Однако я не мог отличить левое соединение от коррелированных решений по скорости.</target>
        </trans-unit>
        <trans-unit id="59c4f1cbf0a942eb4eb3e4a90d93e9070d57b26d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; disabled, we can use still use &lt;code&gt;GROUP BY&lt;/code&gt;, but then we are only using it on the Salary, and not the id:</source>
          <target state="translated">Когда &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; отключен, мы можем по-прежнему использовать &lt;code&gt;GROUP BY&lt;/code&gt; , но тогда мы используем его только в Salary, а не в id:</target>
        </trans-unit>
        <trans-unit id="a54ed92f38bc881fb7562aedd94827fd1f8b7927" translate="yes" xml:space="preserve">
          <source>With the above data, the result should contain two rows: &lt;code&gt;[1, 3, ...]&lt;/code&gt; and &lt;code&gt;[2, 1, ..]&lt;/code&gt;. I'm using &lt;strong&gt;&lt;em&gt;MySQL&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">С учетом приведенных выше данных результат должен содержать две строки: &lt;code&gt;[1, 3, ...]&lt;/code&gt; и &lt;code&gt;[2, 1, ..]&lt;/code&gt; . Я использую &lt;strong&gt;&lt;em&gt;MySQL&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b040793081e54b56e0ea00ab6ff5580f6556d4ae" translate="yes" xml:space="preserve">
          <source>Yes it looks awful (converting to string and back etc.) but in my experience it's usually faster than the other solutions. Maybe that just for my use cases, but I have used it on tables with millions of records and many unique ids. Maybe it's because MySQL is pretty bad at optimizing the other solutions (at least in the 5.0 days when I came up with this solution).</source>
          <target state="translated">Да,это выглядит ужасно (преобразование в строку и обратно и т.д.),но по моему опыту это обычно быстрее,чем другие решения.Может быть,это только для моих случаев использования,но я использовал его на таблицах с миллионами записей и множеством уникальных идентификаторов.Может быть,это потому,что MySQL довольно плохо оптимизирует другие решения (по крайней мере,за 5.0 дней,когда я придумал это решение).</target>
        </trans-unit>
        <trans-unit id="27f562e6f1eb4744f3a84f65dab865c4653ea720" translate="yes" xml:space="preserve">
          <source>Yet another solution is to use a correlated subquery:</source>
          <target state="translated">Еще одним решением является использование коррелированного подзапроса:</target>
        </trans-unit>
        <trans-unit id="1394ac848a2275fcc727163db03ae442b55038a4" translate="yes" xml:space="preserve">
          <source>You can do it using &lt;code&gt;IN&lt;/code&gt;
try this:</source>
          <target state="translated">Вы можете сделать это с помощью &lt;code&gt;IN&lt;/code&gt; попробуйте это:</target>
        </trans-unit>
        <trans-unit id="453880e233710a43167c94bccdd5a1dd285b388f" translate="yes" xml:space="preserve">
          <source>You can make the select without a join when you combine the &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; into one &lt;code&gt;maxRevId&lt;/code&gt; value for &lt;code&gt;MAX()&lt;/code&gt; and then split it back to original values:</source>
          <target state="translated">Вы можете сделать выбор без объединения, когда вы объединяете &lt;code&gt;rev&lt;/code&gt; и &lt;code&gt;id&lt;/code&gt; в одно значение &lt;code&gt;maxRevId&lt;/code&gt; для &lt;code&gt;MAX()&lt;/code&gt; а затем разделяете его на исходные значения:</target>
        </trans-unit>
        <trans-unit id="de4507bccd6edb68f154ba28cbcd9e35a8a477f0" translate="yes" xml:space="preserve">
          <source>You can use this schema in multiple joins and with WHERE clause. It is my working example (solving identical to yours problem with table &quot;firmy&quot;):</source>
          <target state="translated">Вы можете использовать эту схему в нескольких соединениях и с пунктом ГДЕ.Это мой рабочий пример (решение идентичной вашей проблемы с таблицей &quot;firmy&quot;):</target>
        </trans-unit>
        <trans-unit id="f94f563922394ff422dd19d7db9d395cc093c872" translate="yes" xml:space="preserve">
          <source>here is another solution hope it will help someone</source>
          <target state="translated">вот еще одно решение,надеюсь,оно поможет кому-нибудь</target>
        </trans-unit>
        <trans-unit id="7c7f285565dd90fe18340d6bf0386ae80d43766d" translate="yes" xml:space="preserve">
          <source>to my mind it is less complicated... easier to read and maintain.</source>
          <target state="translated">на мой взгляд,это менее сложно...легче читать и обслуживать.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
