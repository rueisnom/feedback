<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/7745609">
    <body>
      <group id="7745609">
        <trans-unit id="04c57be5b9e3b9472146536311d773ab598c075b" translate="yes" xml:space="preserve">
          <source>3.2    becomes    1003.201</source>
          <target state="translated">3.2改为1003.201</target>
        </trans-unit>
        <trans-unit id="7ee9358b03aa8d5e6b7ff5f87ff1c6c61fa1840d" translate="yes" xml:space="preserve">
          <source>57     becomes    1057.001</source>
          <target state="translated">57改为1057.001</target>
        </trans-unit>
        <trans-unit id="d7e7caf3da371e1159ed08c93e06650d3673a2aa" translate="yes" xml:space="preserve">
          <source>923.88 becomes    1923.881</source>
          <target state="translated">923.88改为1923.881</target>
        </trans-unit>
        <trans-unit id="27f0e6e0472c758e2b2f6cf7c9816fcea152f9aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(SELECT *...)&lt;/code&gt; subquery : Return all people, sorted by Salary.</source>
          <target state="translated">&lt;code&gt;(SELECT *...)&lt;/code&gt; 子查询：返回所有人，按薪水排序。</target>
        </trans-unit>
        <trans-unit id="4a3646e38f6b0d40250be24a8869360f600bf40d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FROM Employee&lt;/code&gt; : Table searched on.</source>
          <target state="translated">&lt;code&gt;FROM Employee&lt;/code&gt; ：已搜索表格。</target>
        </trans-unit>
        <trans-unit id="51b27a498c28cb1978a214b508f3379f27cbf666" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GROUP BY Table1.id&lt;/code&gt;: Force the top-sorted, Salary row of each employee to be the returned result.</source>
          <target state="translated">&lt;code&gt;GROUP BY Table1.id&lt;/code&gt; ：强制将每位员工的排序最高的薪水行作为返回结果。</target>
        </trans-unit>
        <trans-unit id="a1b951f0bc26d85d82b83ff57fc600c0fb43a981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GROUP BY employeesub.Salary&lt;/code&gt;: Force the top-sorted, Salary row of each employee to be the returned result.</source>
          <target state="translated">&lt;code&gt;GROUP BY employeesub.Salary&lt;/code&gt; ：强制将每个雇员的排在最前的Salary行作为返回结果。</target>
        </trans-unit>
        <trans-unit id="b108dac77b8b8d7940ca436cb584a45df60efc79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JOIN Table1 AS Table2 ON Table2.rev = Table1.rev&lt;/code&gt; : Join the second table on the first, because, we need to get the max(table1.rev)'s comment.</source>
          <target state="translated">&lt;code&gt;JOIN Table1 AS Table2 ON Table2.rev = Table1.rev&lt;/code&gt; 联接到Table2.rev = Table1.rev上 ：将第二个表联接到第一个表上，因为我们需要获取max（table1.rev）的注释。</target>
        </trans-unit>
        <trans-unit id="5d64ca2c6f022a9050f895a8140f2d84845c927e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT *&lt;/code&gt; : Return all fields.</source>
          <target state="translated">&lt;code&gt;SELECT *&lt;/code&gt; ：返回所有字段。</target>
        </trans-unit>
        <trans-unit id="f1728fe7d07f6f81ae312d65bccb6428f5d4d2d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT DISTINCT Table1.id, max(Table1.rev), max(Table2.content)&lt;/code&gt; : Return &lt;code&gt;DISTINCT&lt;/code&gt; somefield, &lt;code&gt;MAX()&lt;/code&gt; some otherfield, the last &lt;code&gt;MAX()&lt;/code&gt; is redundant, because I know it's just one row, but it's required by the query.</source>
          <target state="translated">&lt;code&gt;SELECT DISTINCT Table1.id, max(Table1.rev), max(Table2.content)&lt;/code&gt; ：返回 &lt;code&gt;DISTINCT&lt;/code&gt; somefield， &lt;code&gt;MAX()&lt;/code&gt; someotherfield，最后一个 &lt;code&gt;MAX()&lt;/code&gt; 是多余的，因为我知道它只是一行，但是它是必需的查询。</target>
        </trans-unit>
        <trans-unit id="694f2b69df9ba4223789e351dba806643efc9f3c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&quot;Can you return me the records in this group of records (based on same id) that have the highest version number&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;ldquo;您能否将具有最高版本号的该记录组（基于相同的ID）中的记录退还给我&amp;rdquo;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="747dc8ef6e9397eda6d614ec751270837eb5d1cc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why is it clean?&lt;/em&gt;&lt;code&gt;DISTINCT()&lt;/code&gt;, &lt;code&gt;MAX()&lt;/code&gt;, etc., all make wonderful use of MySQL indices.  This will be faster.  Or, it will be much faster, if you have indexing, and you compare it to a query that looks at all rows.</source>
          <target state="translated">&lt;em&gt;为什么干净？&lt;/em&gt; &lt;code&gt;DISTINCT()&lt;/code&gt; ， &lt;code&gt;MAX()&lt;/code&gt; 等都很好地利用了MySQL索引。 这样会更快。 或者，如果您有索引，并将其与查询所有行的查询进行比较，它将更快。</target>
        </trans-unit>
        <trans-unit id="ef6990676e8cbc396ebc34b6bbb2006bd98ee19c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;APPROACH&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;APPROACH&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f2f1d3f876ca275d587648c0854a40f7d75ceda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cleanest Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最清洁的解决方案&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23eda03e232c7b276914d29d144368844246997f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; though this solution works for many people it may not be stable in the long run, since MySQL doesn't guarantee that GROUP BY statement will return meaningful values for columns not in GROUP BY list. So use this solution at your own risk!</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;尽管这种解决方案对许多人都有效，但从长远来看可能并不稳定，因为MySQL不保证GROUP BY语句将为不在GROUP BY列表中的列返回有意义的值。 因此，使用此解决方案需您自担风险！</target>
        </trans-unit>
        <trans-unit id="403b25e1010d5c08346c35cf961dc40d8e1f56f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;GOOD STUFF&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;好东西&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a9b0dfc8a396405726470595ea946d489db2ab7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOT mySQL&lt;/strong&gt;, but for other people finding this question and using SQL, another way to resolve the &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt; problem is using &lt;a href=&quot;http://technet.microsoft.com/en-us/library/ms175156(v=sql.105).aspx&quot;&gt;&lt;code&gt;Cross Apply&lt;/code&gt;&lt;/a&gt; in MS SQL</source>
          <target state="translated">&lt;strong&gt;不是mySQL&lt;/strong&gt; ，但是对于其他人发现此问题并使用SQL的方法，解决&lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;最大每组最大&lt;/a&gt;问题的另一种方法是在MS SQL中使用&lt;a href=&quot;http://technet.microsoft.com/en-us/library/ms175156(v=sql.105).aspx&quot;&gt; &lt;code&gt;Cross Apply&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59f292915a0a09f846bffdf80a1afb5aad2aa92f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;原始解决方案&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c747eb526637be44701505482fa8cb37152fb689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please credit answer of user Bohemian&lt;/strong&gt; in &lt;a href=&quot;https://stackoverflow.com/questions/12102200/get-records-with-max-value-for-each-group-of-grouped-sql-results&quot;&gt;this question&lt;/a&gt; for providing such a concise and elegant answer to this problem.</source>
          <target state="translated">&lt;strong&gt;请&lt;/strong&gt; &lt;a href=&quot;https://stackoverflow.com/questions/12102200/get-records-with-max-value-for-each-group-of-grouped-sql-results&quot;&gt;将此问题&lt;/a&gt; &lt;strong&gt;的用户Bohemian答案归功于&lt;/strong&gt; 为该问题提供了简洁明了的答案。</target>
        </trans-unit>
        <trans-unit id="2add4d2b2581dbb1b5b57f680ba41943bb912e83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unique-Row Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;独行解决方案&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e7ad05d289224982e0cbf5785062d94a875a509" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更新2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f68ee9c7511d534eda217dbc3387c2ea2bf2888d" translate="yes" xml:space="preserve">
          <source>A third solution I hardly ever see mentioned is MySQL specific and looks like this:</source>
          <target state="translated">第三种解决方案我几乎没有看到有人提到过,是MySQL特有的,看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="0359601a6c3c733dad134b61901f5ac2843959e2" translate="yes" xml:space="preserve">
          <source>Added in SQL standard ANSI/ISO Standard SQL:2003  and later extended with ANSI/ISO Standard SQL:2008, window (or windowing) functions are available with all major vendors now. There are more types of rank functions available to deal with a tie issue: &lt;code&gt;RANK, DENSE_RANK, PERSENT_RANK&lt;/code&gt;.</source>
          <target state="translated">在SQL标准ANSI / ISO标准SQL：2003中添加，并在以后通过ANSI / ISO标准SQL：2008进行了扩展，现在所有主要供应商都可以使用窗口（或窗口）功能。 有更多类型的等级函数可用于处理平局问题： &lt;code&gt;RANK, DENSE_RANK, PERSENT_RANK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f6c5649c468f3c5b9f11dd0b6bb5bd2dcb42b60" translate="yes" xml:space="preserve">
          <source>All you need is a &lt;code&gt;GROUP BY&lt;/code&gt; clause with the &lt;code&gt;MAX&lt;/code&gt; aggregate function:</source>
          <target state="translated">您需要的是带有 &lt;code&gt;MAX&lt;/code&gt; 聚合函数的 &lt;code&gt;GROUP BY&lt;/code&gt; 子句：</target>
        </trans-unit>
        <trans-unit id="f6746f8d362c92efc81f829dc623802dbc041661" translate="yes" xml:space="preserve">
          <source>Another manner to do the job is using &lt;code&gt;MAX()&lt;/code&gt; analytic function in OVER PARTITION clause</source>
          <target state="translated">完成这项工作的另一种方法是在OVER PARTITION子句中使用 &lt;code&gt;MAX()&lt;/code&gt; 分析函数</target>
        </trans-unit>
        <trans-unit id="2db20964a9cb8621f5afa10d678b2d245436b758" translate="yes" xml:space="preserve">
          <source>Anyway, the above doesn't directly work if your content field is already text. In that case you probably want to use a different separator, like \0 maybe. You'll also run into the &lt;code&gt;group_concat_max_len&lt;/code&gt; limit quicker.</source>
          <target state="translated">无论如何，如果您的内容字段已经是文本，则以上内容无法直接起作用。 在这种情况下，您可能希望使用其他分隔符，例如\ 0。 您还将更快地遇到 &lt;code&gt;group_concat_max_len&lt;/code&gt; 限制。</target>
        </trans-unit>
        <trans-unit id="3dc54dc2faa3dd8f7aa080b02153c1129681f558" translate="yes" xml:space="preserve">
          <source>As the answers suggest, there &lt;em&gt;is&lt;/em&gt; a SQL solution, and &lt;a href=&quot;http://sqlfiddle.com/#!9/3d74dc/1&quot;&gt;here a sqlfiddle demo&lt;/a&gt;.</source>
          <target state="translated">如答案所示，有一个SQL解决方案， &lt;a href=&quot;http://sqlfiddle.com/#!9/3d74dc/1&quot;&gt;这里是sqlfiddle演示&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="18684a622d455407c3ef979634241c7c2b8bb5c1" translate="yes" xml:space="preserve">
          <source>At first glance...</source>
          <target state="translated">乍一看.....</target>
        </trans-unit>
        <trans-unit id="7d20eb576a5bf5c43a34a93487e4603496ff5cfd" translate="yes" xml:space="preserve">
          <source>Basically, you have two approaches to solve that problem:</source>
          <target state="translated">基本上,你有两种方法来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="aff13b294275d46a1233bde52ba0a2304518a57e" translate="yes" xml:space="preserve">
          <source>Both approaches are SQL ANSI compatible, thus, will work with your favorite RDBMS, regardless of its &quot;flavor&quot;.</source>
          <target state="translated">这两种方法都是SQL ANSI兼容的,因此,不管它的 &quot;味道 &quot;如何,都能与你最喜欢的RDBMS一起工作。</target>
        </trans-unit>
        <trans-unit id="a069f75e85cfd757d1237e33836f5a5c9a7933b8" translate="yes" xml:space="preserve">
          <source>Both approaches are also performance friendly, however your mileage may vary (RDBMS, DB Structure, Indexes, etc.). So when you pick one approach over the other, &lt;em&gt;benchmark&lt;/em&gt;. And make sure you pick the one which make most of sense to you.</source>
          <target state="translated">两种方法也都是性能友好的，但是您的工作量可能会有所不同（RDBMS，数据库结构，索引等）。 因此，当您选择一种方法而不是另一种方法时，请进行&lt;em&gt;基准测试&lt;/em&gt; 。 并确保选择最适合您的一种。</target>
        </trans-unit>
        <trans-unit id="19563c10db076085d9b0b4f5dba8b52984789ac2" translate="yes" xml:space="preserve">
          <source>Both approaches bring the exact same result.</source>
          <target state="translated">这两种方法带来的结果完全一样。</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="573dbbd0ba5f01ad2edaf25718f8fd20afb0f654" translate="yes" xml:space="preserve">
          <source>Currently I use checks in the &lt;code&gt;while&lt;/code&gt; loop to detect and over-write old revs from the resultset. But is this the only method to achieve the result? Isn't there a &lt;strong&gt;SQL&lt;/strong&gt; solution?</source>
          <target state="translated">目前，我在 &lt;code&gt;while&lt;/code&gt; 循环中使用检查来检测和覆盖结果集中的旧版本。 但这是获得结果的唯一方法吗？ 没有&lt;strong&gt;SQL&lt;/strong&gt;解决方案吗？</target>
        </trans-unit>
        <trans-unit id="3bedaf93cca4db2c2a031f628273b205d4c103de" translate="yes" xml:space="preserve">
          <source>DB Fiddle</source>
          <target state="translated">DB Fiddle</target>
        </trans-unit>
        <trans-unit id="af49ccd16ea8ee6847aa18e5e026d91269d1340a" translate="yes" xml:space="preserve">
          <source>Even so, we can simply select &lt;code&gt;DISTINCT&lt;/code&gt;&lt;em&gt;someuniquefield&lt;/em&gt;, &lt;code&gt;MAX(&lt;/code&gt;&lt;em&gt;whateverotherfieldtoselect&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt; *somethirdfield &lt;code&gt;)&lt;/code&gt;, etc., and have no worries understanding the result or how the query works :</source>
          <target state="translated">即使这样，我们也可以简单地选择 &lt;code&gt;DISTINCT&lt;/code&gt; &lt;em&gt;someuniquefield&lt;/em&gt; ， &lt;code&gt;MAX(&lt;/code&gt; &lt;em&gt;whatotherfieldtoselect&lt;/em&gt; &lt;code&gt;)&lt;/code&gt; ， &lt;code&gt;(&lt;/code&gt; * somethirdfield &lt;code&gt;)&lt;/code&gt; 等，而不必担心结果或查询的工作方式：</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="000d91fadfba91936529d79d0821bb7195a90ba6" translate="yes" xml:space="preserve">
          <source>Following are comparisons to the solutions in @AdrianCarneiro's answer (subquery, leftjoin), based on MySQL measurements with InnoDB table of ~1million records, group size being: 1-3.</source>
          <target state="translated">以下是与@AdrianCarneiro的答案中的解决方案的比较(子查询,左键连接),基于MySQL的测量结果,InnoDB表约100万条记录,组大小为。1-3.</target>
        </trans-unit>
        <trans-unit id="995071277e83cf1d1f1c4a8ccb804e62ea4b68dd" translate="yes" xml:space="preserve">
          <source>Having an index on (id,rev) renders the subquery almost as a simple lookup...</source>
          <target state="translated">在(id,rev)上有一个索引,使子查询几乎变成了一个简单的查询。</target>
        </trans-unit>
        <trans-unit id="314d916008f70bef56e0b0d15d12dfe541cea6a1" translate="yes" xml:space="preserve">
          <source>Here is a nice way of doing that</source>
          <target state="translated">这里有一个很好的方法</target>
        </trans-unit>
        <trans-unit id="471fa8e0858c0f841233c444b4700b23aee1ab66" translate="yes" xml:space="preserve">
          <source>Here's an example in SqlFiddle</source>
          <target state="translated">下面是SqlFiddle中的一个例子</target>
        </trans-unit>
        <trans-unit id="9164d1faed37c4623fd975150fe3872405f41423" translate="yes" xml:space="preserve">
          <source>Here's another solution to retrieving the records only with a field that has the maximum value for that field. This works for SQL400 which is the platform I work on. In this example, the records with the maximum value in field FIELD5 will be retrieved by the following SQL statement.</source>
          <target state="translated">这里有另一个解决方案,只检索记录的字段有最大值的字段。这个方案适用于我工作的SQL400平台。在这个例子中,下面的SQL语句将检索字段FIELD5中的最大值的记录。</target>
        </trans-unit>
        <trans-unit id="a6f33200f27d1f02a32897ce39b81c9ee560e6d6" translate="yes" xml:space="preserve">
          <source>Here's how it looks with the above example, written in SQL</source>
          <target state="translated">上面的例子是这样的,用SQL写的。</target>
        </trans-unit>
        <trans-unit id="9e3a68cc958a74ba34c6bcb6c78f492a33cda5ba" translate="yes" xml:space="preserve">
          <source>Hopefully this is a solution that solves the problem and helps everyone better understand what's happening in the DB.</source>
          <target state="translated">希望这个方案能解决这个问题,帮助大家更好地了解DB的情况。</target>
        </trans-unit>
        <trans-unit id="17aca0cf466b23a9d66f040adc39824d44c21641" translate="yes" xml:space="preserve">
          <source>How about this:</source>
          <target state="translated">这个怎么样?</target>
        </trans-unit>
        <trans-unit id="10913cb8e1a0c820785850e0e7d418afaaf3b084" translate="yes" xml:space="preserve">
          <source>How do I select one row per id and only the greatest rev?</source>
          <target state="translated">如何在每个ID中选择一个行,并且只选择最大转数?</target>
        </trans-unit>
        <trans-unit id="19cbcd14e6b2211943bc8ae571c9613a49c99e92" translate="yes" xml:space="preserve">
          <source>I am flabbergasted that no answer offered SQL window function solution:</source>
          <target state="translated">我很惊讶,没有人提供SQL窗口功能的解决方案。</target>
        </trans-unit>
        <trans-unit id="c63f6bb578d3ae9db96662ba13e29dc33c243f8f" translate="yes" xml:space="preserve">
          <source>I came here looking for SQLAlchemy help, so I will duplicate Adrian Carneiro's answer with the python/SQLAlchemy version, specifically the outer join part.</source>
          <target state="translated">我来到这里寻找SQLAlchemy的帮助,所以我将用pythonSQLAlchemy版本复制Adrian Carneiro的答案,特别是外链部分。</target>
        </trans-unit>
        <trans-unit id="c10b9ffc525b97bcbece3250c202bd16cad8beb3" translate="yes" xml:space="preserve">
          <source>I can't vouch for the performance, but here's a trick inspired by the limitations of Microsoft Excel.  It has some good features</source>
          <target state="translated">我不能打包票,但这里有一个小窍门,是受微软Excel的局限性启发。它有一些好的功能</target>
        </trans-unit>
        <trans-unit id="67a7d23c38d29857f72aac73ca9af605f944a2d1" translate="yes" xml:space="preserve">
          <source>I have this table for documents (simplified version here):</source>
          <target state="translated">我有这个文件的表格(这里是简化版)。</target>
        </trans-unit>
        <trans-unit id="d582544f0807601e4b6511e7bdec729115bf914b" translate="yes" xml:space="preserve">
          <source>I just noticed you need the &lt;code&gt;content&lt;/code&gt; column as well.</source>
          <target state="translated">我只是注意到您也需要 &lt;code&gt;content&lt;/code&gt; 列。</target>
        </trans-unit>
        <trans-unit id="a8dfea75f00120de3d7deedb3de7608fd0c28237" translate="yes" xml:space="preserve">
          <source>I like to do this by ranking the records by some column. In this case, rank &lt;code&gt;rev&lt;/code&gt; values grouped by &lt;code&gt;id&lt;/code&gt;. Those with higher &lt;code&gt;rev&lt;/code&gt; will have lower rankings. So highest &lt;code&gt;rev&lt;/code&gt; will have ranking of 1.</source>
          <target state="translated">我喜欢通过按列对记录进行排名来做到这一点。 在这种情况下，按 &lt;code&gt;id&lt;/code&gt; 分组对 &lt;code&gt;rev&lt;/code&gt; 值进行排名。 &lt;code&gt;rev&lt;/code&gt; 较高的人排名较低。 因此最高 &lt;code&gt;rev&lt;/code&gt; 将排在第一位 。</target>
        </trans-unit>
        <trans-unit id="33448d590cc783d19b7e088f10f0cc5625c1e617" translate="yes" xml:space="preserve">
          <source>I like to use a &lt;code&gt;NOT EXIST&lt;/code&gt;-based solution for this problem:</source>
          <target state="translated">我喜欢针对此问题使用基于 &lt;code&gt;NOT EXIST&lt;/code&gt; 的解决方案：</target>
        </trans-unit>
        <trans-unit id="3a69c1874c939239de03ecc1482256501bce00b2" translate="yes" xml:space="preserve">
          <source>I noticed after adding the above &lt;em&gt;sqlfiddle&lt;/em&gt;, the rate at which the question is upvoted has surpassed the upvote rate of the answers. That has not been the intention! The fiddle is based on the answers, especially the accepted answer.</source>
          <target state="translated">在添加上述&lt;em&gt;sqlfiddle之后&lt;/em&gt; ，我注意到问题被投票的速率已经超过答案的投票率。 那不是意图！ 小提琴基于答案，尤其是已接受的答案。</target>
        </trans-unit>
        <trans-unit id="31b46e90abba135e2e191919836bd8d723638c3d" translate="yes" xml:space="preserve">
          <source>I then joined these max values (#temp1) to all of the possible id/content combinations. By doing this, I naturally filter out the non-maximum id/content combinations, and am left with the only max rev values for each.</source>
          <target state="translated">然后我将这些最大值(#temp1)连接到所有可能的idcontent组合中。通过这样做,我很自然地过滤掉了非最大的idcontent组合,只剩下每个组合的最大值。</target>
        </trans-unit>
        <trans-unit id="eedb27620fc870cd05408ec33312da837f122366" translate="yes" xml:space="preserve">
          <source>I think, You want this?</source>
          <target state="translated">我想,你想要这个吗?</target>
        </trans-unit>
        <trans-unit id="475f1dbf29984af602be998bcf11558846a40db9" translate="yes" xml:space="preserve">
          <source>I used the below to solve a problem of my own. I first created a temp table and inserted the max rev value per unique id.</source>
          <target state="translated">我用下面的方法来解决我自己的一个问题。我首先创建了一个temp表,并插入了每个唯一的id的最大转数值。</target>
        </trans-unit>
        <trans-unit id="90195caa2158153b6d15ffbd881bc0002f84edd8" translate="yes" xml:space="preserve">
          <source>I would use this:</source>
          <target state="translated">我想用这个。</target>
        </trans-unit>
        <trans-unit id="91840954cb9c4ea1b61596b1a83ee83e2ea511b0" translate="yes" xml:space="preserve">
          <source>I wouldn't use IN clause (as it is mentioned somewhere above). IN is given to use with short lists of constans, and not as to be the query filter built on subquery. It is because subquery in IN is performed for every scanned record which can made query taking very loooong time.</source>
          <target state="translated">我不会使用IN子句(因为它在上面的某个地方提到了)。IN子句是给与短的 constans 列表,而不是建立在子查询上的查询过滤器。这是因为IN中的子查询是对每一条扫描的记录都要进行子查询,这可能会导致查询时间非常长。</target>
        </trans-unit>
        <trans-unit id="fb74c49395db7bba931e909d22e83547acbf985a" translate="yes" xml:space="preserve">
          <source>If you do it right, string comparison of two numbers should yield the same &quot;max&quot; as numeric comparison of the two numbers and it's easy to convert back to the original number using the substring function (which is available in one form or another pretty much everywhere).</source>
          <target state="translated">如果你做对了,两个数字的字符串比较应该可以得到和两个数字的数字比较一样的 &quot;最大值&quot;,而且很容易用子串函数(几乎每个地方都有这样或那样的形式)转换回原来的数字。</target>
        </trans-unit>
        <trans-unit id="cd760119a0c1ae1b56d494acb1a10a8a2ca548fe" translate="yes" xml:space="preserve">
          <source>If you have many fields in select statement and you want latest  value for all of those fields through optimized code:</source>
          <target state="translated">如果你在select语句中有很多字段,而你希望通过优化的代码为所有的字段提供最新的值。</target>
        </trans-unit>
        <trans-unit id="ee8b53705cdf9b09c80c28fb4dd6809e10ff922e" translate="yes" xml:space="preserve">
          <source>If you have two rows with &lt;code&gt;max-value-in-group&lt;/code&gt; for &lt;code&gt;group-identifier&lt;/code&gt;, both rows will be in the result in both approaches.</source>
          <target state="translated">如果您有两行带有用于 &lt;code&gt;group-identifier&lt;/code&gt; 的 &lt;code&gt;max-value-in-group&lt;/code&gt; ，则两种方法的结果都将出现在这两行中。</target>
        </trans-unit>
        <trans-unit id="d387732b9dd594cea09224c99e2e3db7eda6d1c9" translate="yes" xml:space="preserve">
          <source>In this approach, you first find the &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; (already solved above) in a sub-query. Then you join your table to the sub-query with equality on both &lt;code&gt;group-identifier&lt;/code&gt; and &lt;code&gt;max-value-in-group&lt;/code&gt;:</source>
          <target state="translated">通过这种方法，您首先可以在子查询中找到 &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; 即组中的最大值 （已在上面解决）。 然后，在 &lt;code&gt;group-identifier&lt;/code&gt; 和 &lt;code&gt;max-value-in-group&lt;/code&gt; 中相等的情况下，将表连接到子查询：</target>
        </trans-unit>
        <trans-unit id="0e261b8d5be6a8e3499be83152da6b96e488a4fc" translate="yes" xml:space="preserve">
          <source>In this approach, you left join the table with itself. Equality goes in the &lt;code&gt;group-identifier&lt;/code&gt;. Then, 2 smart moves:</source>
          <target state="translated">在这种方法中，您将表与其自身保持连接。 平等在 &lt;code&gt;group-identifier&lt;/code&gt; 。 然后，有2个明智的举动：</target>
        </trans-unit>
        <trans-unit id="4b8e5c4e8addfc03069074421a8e679d4db14df8" translate="yes" xml:space="preserve">
          <source>It doesn't require a join</source>
          <target state="translated">它不需要加入</target>
        </trans-unit>
        <trans-unit id="ee669ad8ba2e0f5f2ee33e7468179e58169574b2" translate="yes" xml:space="preserve">
          <source>It is a little bit ugly and requires that you know something about the range of valid values of the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column.  Let us assume that we know the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column is a number between 0.00 and 999 including decimals but that there will only ever be two digits to the right of the decimal point (e.g. 34.17 would be a valid value).</source>
          <target state="translated">这有点丑陋，要求您了解&lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt;列的有效值范围。 让我们假设我们知道&lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt;列是介于0.00和999之间的数字，包括小数，但小数点右边永远只有两位数字（例如34.17是有效值）。</target>
        </trans-unit>
        <trans-unit id="d052da643334c91fbd79130f435ea2036f8d231e" translate="yes" xml:space="preserve">
          <source>It is asked on tables having teens thusands of records, and it takes less then 0,01 second on really not too strong machine.</source>
          <target state="translated">它被要求在有十几条记录的桌子上,它需要不到0,01秒的时间,在真正不是太强的机器上。</target>
        </trans-unit>
        <trans-unit id="58fd729f1264da5befb4f9b9d51e8f280f1269ec" translate="yes" xml:space="preserve">
          <source>It is, actually, so common that StackOverflow community has created a single tag just to deal with questions like that: &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;greatest-n-per-group&lt;/a&gt;.</source>
          <target state="translated">实际上，是如此普遍，以至于StackOverflow社区创建了一个标签来处理这样的问题： &lt;a href=&quot;/questions/tagged/greatest-n-per-group&quot;&gt;great-n-per-group&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d0650392a80d6352d1134ecbd14115eaa3db77a" translate="yes" xml:space="preserve">
          <source>It looks like there is simpler way to do this (but &lt;strong&gt;only in MySQL&lt;/strong&gt;):</source>
          <target state="translated">看起来有更简单的方法可以做到这一点（但&lt;strong&gt;仅限于MySQL&lt;/strong&gt; ）：</target>
        </trans-unit>
        <trans-unit id="452d3ec3e5e3af71a122522390dfdc81b35a82a8" translate="yes" xml:space="preserve">
          <source>It should force return of only one &quot;max record&quot; even if there is a tie (sometimes useful)</source>
          <target state="translated">即使出现平局,也应该强制返回一个 &quot;最大记录&quot;(有时是有用的)</target>
        </trans-unit>
        <trans-unit id="4d2d5d921b83099b6badb0edcc209baf412da434" translate="yes" xml:space="preserve">
          <source>It's never that simple, is it?</source>
          <target state="translated">事情从来没有那么简单,不是吗?</target>
        </trans-unit>
        <trans-unit id="11aed3f58968adfc7e701f0ecba96fda74515ce8" translate="yes" xml:space="preserve">
          <source>Joining with simple &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; Sub-query</source>
          <target state="translated">与简单的 &lt;code&gt;group-identifier, max-value-in-group&lt;/code&gt; 子查询结合</target>
        </trans-unit>
        <trans-unit id="460920821f4309de220f91dcb815a79c7b3c9156" translate="yes" xml:space="preserve">
          <source>Left Joining with self, tweaking join conditions and filters</source>
          <target state="translated">左边与自己连接,调整连接条件和过滤器</target>
        </trans-unit>
        <trans-unit id="31d0f030330e9a305782ce8d95a2c9b90fec6b29" translate="yes" xml:space="preserve">
          <source>MAX() solution runs certainly FASTER that &lt;code&gt;ROW_NUMBER()&lt;/code&gt; solution because &lt;code&gt;MAX()&lt;/code&gt; complexity is &lt;code&gt;O(n)&lt;/code&gt; while &lt;code&gt;ROW_NUMBER()&lt;/code&gt; complexity is at minimum &lt;code&gt;O(n.log(n))&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; represent the number of records in table !</source>
          <target state="translated">MAX（）解决方案肯定比 &lt;code&gt;ROW_NUMBER()&lt;/code&gt; 解决方案运行得更快，因为 &lt;code&gt;MAX()&lt;/code&gt; 复杂度为 &lt;code&gt;O(n)&lt;/code&gt; ,而 &lt;code&gt;ROW_NUMBER()&lt;/code&gt; 复杂度最小为 &lt;code&gt;O(n.log(n))&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 表示表中的记录数！</target>
        </trans-unit>
        <trans-unit id="f784dda051b71346905b94e12f1c6ce43f3e7fb7" translate="yes" xml:space="preserve">
          <source>My preference is to use as little code as possible...</source>
          <target state="translated">我倾向于尽量少用代码......</target>
        </trans-unit>
        <trans-unit id="460b741c73cbd00e64b87f5e4e2284a80c063282" translate="yes" xml:space="preserve">
          <source>Newer versions of MySQL come with &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; enabled by default, and many of the solutions here will &lt;em&gt;fail&lt;/em&gt; in testing with this condition.</source>
          <target state="translated">默认情况下，较新版本的MySQL带有 &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; ，默认情况下启用，此处的许多解决方案在这种情况下都&lt;em&gt;无法&lt;/em&gt;通过测试。</target>
        </trans-unit>
        <trans-unit id="dd15a32e927c00c615558f8c6498a2cdc048de59" translate="yes" xml:space="preserve">
          <source>None of these answers have worked for me.</source>
          <target state="translated">这些答案都没有对我有效。</target>
        </trans-unit>
        <trans-unit id="2735d006f0f78c77077d2a8f7b369c24f3a71501" translate="yes" xml:space="preserve">
          <source>Not sure if introducing variables makes the whole thing slower. But at least I'm not querying &lt;code&gt;YOURTABLE&lt;/code&gt; twice.</source>
          <target state="translated">不知道引入变量是否会使整个过程变慢。 但是至少我没有两次查询 &lt;code&gt;YOURTABLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87119c137f4237ae2ffed9b612a2cd3bc86e9351" translate="yes" xml:space="preserve">
          <source>Note that since &quot;content&quot; was &quot;...&quot; in OP's question, there's no way to test that this works.  So, I changed that to &quot;..a&quot;, &quot;..b&quot;, so, we can actually now see that the results are correct:</source>
          <target state="translated">注意,由于OP的问题中的 &quot;内容 &quot;是&quot;...........&quot;,所以没有办法检验这个结果是否有效。所以,我把它改成了&quot;...a&quot;,&quot;...b&quot;,所以,我们现在实际上可以看到结果是正确的。</target>
        </trans-unit>
        <trans-unit id="0fcce481af6c969086f7a3a5178c3e328716610a" translate="yes" xml:space="preserve">
          <source>Note the &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database&quot;&gt;Definition of a Relational Database&lt;/a&gt;: &quot;Each row in a table has its own unique key.&quot;  This would mean that, in the question's example, id would &lt;em&gt;have to be&lt;/em&gt; unique, and in that case, we can just do :</source>
          <target state="translated">请注意&lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database&quot;&gt;关系数据库&lt;/a&gt;的定义 ：&amp;ldquo;表中的每一行都有其自己的唯一键。&amp;rdquo; 这意味着，在问题的示例中，id &lt;em&gt;必须是&lt;/em&gt;唯一的，在这种情况下，我们可以这样做：</target>
        </trans-unit>
        <trans-unit id="cd37664721ce22baa58bcd661cd5cbf26ebc9693" translate="yes" xml:space="preserve">
          <source>One final note, as leftjoin creates n*(n+1)/2 joins in groups, its performance can be heavily affected by the size of groups...</source>
          <target state="translated">最后一点要注意的是,由于左键键在组中创建n*(n+1)2的联接,所以它的性能会受到组的大小的影响很大.....</target>
        </trans-unit>
        <trans-unit id="5d6a717a9edad23dd4bea1b698581b82bc5a20e9" translate="yes" xml:space="preserve">
          <source>One important thing is that GROUP_CONCAT has a maximum length for the string it can build up. You probably want to raise this limit by setting the &lt;code&gt;group_concat_max_len&lt;/code&gt; variable. And keep in mind that this will be a limit on scaling if you have a large number of rows.</source>
          <target state="translated">重要的一点是，GROUP_CONCAT具有可以建立的字符串的最大长度。 您可能想通过设置 &lt;code&gt;group_concat_max_len&lt;/code&gt; 变量来提高此限制。 并且请记住，如果您有大量的行，这将是缩放的限制。</target>
        </trans-unit>
        <trans-unit id="91c7270a2e10bd5cc0fdda4e69065666aee3c4f2" translate="yes" xml:space="preserve">
          <source>SQL Fiddle :
&lt;a href=&quot;http://sqlfiddle.com/#!9/a6c585/82473/0&quot;&gt;Check here&lt;/a&gt;</source>
          <target state="translated">SQL小提琴： &lt;a href=&quot;http://sqlfiddle.com/#!9/a6c585/82473/0&quot;&gt;在这里检查&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4fdc1b974c1790e82135708cc7cfea1d1ffb439b" translate="yes" xml:space="preserve">
          <source>SQL select only rows with max value on a column</source>
          <target state="translated">SQL只选择列上有最大值的记录。</target>
        </trans-unit>
        <trans-unit id="3b76449895ac57983b7b2b65399182f3103db7fa" translate="yes" xml:space="preserve">
          <source>Since this is most popular question with regard to this problem, I'll re-post another answer to it here as well:</source>
          <target state="translated">因为这个问题是大家最关心的问题,所以我在这里再贴一个答案。</target>
        </trans-unit>
        <trans-unit id="d00e076b8322dcd61d6eb23264c22bf08e04282e" translate="yes" xml:space="preserve">
          <source>So you end up with:</source>
          <target state="translated">所以你的结局是:</target>
        </trans-unit>
        <trans-unit id="94f01ead7218d9d39d0a9e5560ffc936f4a0187b" translate="yes" xml:space="preserve">
          <source>Something like this?</source>
          <target state="translated">这样的东西?</target>
        </trans-unit>
        <trans-unit id="fcea27228c354bcef2642a5bc557c693423693fc" translate="yes" xml:space="preserve">
          <source>Sorted the rev field in reverse order and then grouped by id which gave the first row of each grouping which is the one with the highest rev value.</source>
          <target state="translated">按相反的顺序排序,然后按id进行分组,每个组中的第一行是最高值的那一行。</target>
        </trans-unit>
        <trans-unit id="6a3870fad3df63029f67f8ef1f65f56e452059d7" translate="yes" xml:space="preserve">
          <source>Subquery SELECT is not too eficient maybe, but in JOIN clause seems to be usable. I'm not an expert in optimizing queries, but I've tried at MySQL, PostgreSQL, FireBird and it does work very good.</source>
          <target state="translated">Subquery SELECT也许不是太无力,但在JOIN子句中似乎是可以用的。我不是优化查询方面的专家,但我在MySQL、PostgreSQL、FireBird都试过,效果很好。</target>
        </trans-unit>
        <trans-unit id="5dc7723780e3da28e4fb6d9bc359f0075239e170" translate="yes" xml:space="preserve">
          <source>Tested in &lt;a href=&quot;http://sqlfiddle.com/&quot;&gt;http://sqlfiddle.com/&lt;/a&gt; with the following data</source>
          <target state="translated">在&lt;a href=&quot;http://sqlfiddle.com/&quot;&gt;http://sqlfiddle.com/中&lt;/a&gt;使用以下数据进行了测试</target>
        </trans-unit>
        <trans-unit id="94226523059a44fd6d0823e04d1320c06cbf47ec" translate="yes" xml:space="preserve">
          <source>Tested on a PostgreSQL database.</source>
          <target state="translated">在PostgreSQL数据库中测试。</target>
        </trans-unit>
        <trans-unit id="b3309e51317016b3d5b0a251f24e195795b03f73" translate="yes" xml:space="preserve">
          <source>The above combination is simple with bit functions when &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; are &lt;code&gt;INT UNSIGNED&lt;/code&gt; (32 bit) and combined value fits to &lt;code&gt;BIGINT UNSIGNED&lt;/code&gt; (64 bit). When the &lt;code&gt;id&lt;/code&gt; &amp;amp; &lt;code&gt;rev&lt;/code&gt; are larger than 32-bit values or made of multiple columns, you need combine the value into e.g. a binary value with suitable padding for &lt;code&gt;MAX()&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;rev&lt;/code&gt; 和 &lt;code&gt;id&lt;/code&gt; 为 &lt;code&gt;INT UNSIGNED&lt;/code&gt; （32位）并且组合值适合 &lt;code&gt;BIGINT UNSIGNED&lt;/code&gt; （64位）时，上述组合使用位函数很简单。 当 &lt;code&gt;id&lt;/code&gt; ＆ &lt;code&gt;rev&lt;/code&gt; 大于32位值或由多列组成时，您需要将该值组合到一个二进制值中，并使用适当的 &lt;code&gt;MAX()&lt;/code&gt; 填充。</target>
        </trans-unit>
        <trans-unit id="1dd706fecc71dd4b48d2d2b09b1613cf3d0b105e" translate="yes" xml:space="preserve">
          <source>The gist of the thing is that you create a single synthetic column by string concatenating/packing the primary comparison field along with the data you want.  In this way, you can force SQL's MAX() aggregate function to return all of the data (because it has been packed into a single column).  Then you have to unpack the data.</source>
          <target state="translated">事情的要点是,你通过将主比较字段与你想要的数据一起串联打包,创建一个单一的合成列。通过这种方式,你可以强迫SQL的MAX()聚合函数返回所有的数据(因为它已经被打包成一个列)。然后,你必须解开数据的包装。</target>
        </trans-unit>
        <trans-unit id="00ab94e8e1f472a0caf4245bb6004e0fd4761b29" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;ROW_NUMBER()&lt;/code&gt; OVER PARTITION solution already documented in this post is</source>
          <target state="translated">这篇文章中已经记录的其他 &lt;code&gt;ROW_NUMBER()&lt;/code&gt; OVER PARTITION解决方案是</target>
        </trans-unit>
        <trans-unit id="33daa53cf1139c305a3e6de8aaaf4c6d74e63949" translate="yes" xml:space="preserve">
          <source>The packing begins by forcing the &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; column to be a number of known character length regardless of the value of &lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt; so that for example</source>
          <target state="translated">打包首先通过将&lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt;列强制为一定数量的已知字符长度，而不管&lt;strong&gt;&lt;em&gt;rev&lt;/em&gt;&lt;/strong&gt;的值如何，例如</target>
        </trans-unit>
        <trans-unit id="8f02bdcb5aaad48ff64e99bf617a644fa990ddcf" translate="yes" xml:space="preserve">
          <source>The second join condition is having left side value less than right value</source>
          <target state="translated">第二个连接条件是左边的值小于右边的值</target>
        </trans-unit>
        <trans-unit id="0bbc6aadc07a842d6fc9d1f88ded92b6a1b29149" translate="yes" xml:space="preserve">
          <source>This 2 SELECT work well on Oracle 10g.</source>
          <target state="translated">这2个SELECT在Oracle 10g上运行良好。</target>
        </trans-unit>
        <trans-unit id="8c0d4d65d2b2336eff8eda436b0051d18840475e" translate="yes" xml:space="preserve">
          <source>This allows me to duplicate the record, update it, increment its version number, and have the copy of the old version in such a way that I can show change over time.</source>
          <target state="translated">这样我就可以复制记录,更新它,增加它的版本号,并拥有旧版本的副本,这样我就可以随着时间的推移显示变化。</target>
        </trans-unit>
        <trans-unit id="2301e8326e919ecb8afe49e6e514de6a09cce684" translate="yes" xml:space="preserve">
          <source>This gave the following result in MySql 5.5 and 5.6</source>
          <target state="translated">这在MySql 5.5和5.6中给出了以下结果</target>
        </trans-unit>
        <trans-unit id="887c512cd9ff837fd1c9fc4808909508ea838546" translate="yes" xml:space="preserve">
          <source>This is a very common question in SQL: find the whole data for the row with some max value in a column per some group identifier. I heard that a lot during my career. Actually, it was one the questions I answered in my current job's technical interview.</source>
          <target state="translated">这是一个在SQL中很常见的问题:按某组标识符找到某列中的某组最大值的行的整个数据。在我的职业生涯中,我经常听到这个问题。其实,这也是我在现在工作的技术面试中回答的问题之一。</target>
        </trans-unit>
        <trans-unit id="ee5febc8aebb31700d3b2dcee3dd28e23632667e" translate="yes" xml:space="preserve">
          <source>This is especially fast when there is a complex join instead of a single table. With the traditional approaches the complex join would be done twice.</source>
          <target state="translated">当有一个复杂的联接而不是单一的表时,这样做的速度特别快。在传统的方法中,复杂的联接要做两次。</target>
        </trans-unit>
        <trans-unit id="bf4b0ede672dafca43e39e677b31d17ea3f43666" translate="yes" xml:space="preserve">
          <source>This is not pure SQL. This will use the SQLAlchemy ORM.</source>
          <target state="translated">这不是纯粹的SQL。这将使用SQLAlchemy ORM。</target>
        </trans-unit>
        <trans-unit id="e525543a18c8b2f059c99fd1eafb0e14a4a32dc4" translate="yes" xml:space="preserve">
          <source>This is what worked for me.</source>
          <target state="translated">这是对我有效的方法。</target>
        </trans-unit>
        <trans-unit id="0b48e75dada78a122caea17e73852eaaddb6181b" translate="yes" xml:space="preserve">
          <source>This query answers the question of:</source>
          <target state="translated">这个问题的答案是:</target>
        </trans-unit>
        <trans-unit id="59b379b84cff9d86d45433e27b3a690e1bbc3911" translate="yes" xml:space="preserve">
          <source>This solution makes only one selection from YourTable, therefore it's faster. It works only for MySQL and SQLite(for SQLite remove DESC) according to test on sqlfiddle.com. Maybe it can be tweaked to work on other languages which I am not familiar with.</source>
          <target state="translated">这个方案只从YourTable中进行一次选择,因此速度更快。根据sqllfiddle.com上的测试,它只适用于MySQL和SQLite(对于SQLite删除DESC)。也许它可以被调整到其他语言上,但我不熟悉的语言。</target>
        </trans-unit>
        <trans-unit id="922fda0f734f15029de1e6477a7c86dcb4d18c7c" translate="yes" xml:space="preserve">
          <source>This will select all records with max value within the group and allows you to select other columns.</source>
          <target state="translated">这将选择组内所有有最大值的记录,并允许你选择其他列。</target>
        </trans-unit>
        <trans-unit id="66639bc2c3849de3b1308222ecb4a4eb01a37f90" translate="yes" xml:space="preserve">
          <source>Use following code :</source>
          <target state="translated">使用以下代码。</target>
        </trans-unit>
        <trans-unit id="1d992c7af6b12bdffa0c4708f603e830d452ab3a" translate="yes" xml:space="preserve">
          <source>When you do step 1, the row(s) that actually have the max value will have &lt;code&gt;NULL&lt;/code&gt; in the right side (it's a &lt;code&gt;LEFT JOIN&lt;/code&gt;, remember?). Then, we filter the joined result, showing only the rows where the right side is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">当您执行步骤1时，实际具有最大值的行的右侧将为 &lt;code&gt;NULL&lt;/code&gt; （这是 &lt;code&gt;LEFT JOIN&lt;/code&gt; ，还记得吗？）。 然后，我们过滤联接的结果，仅显示右侧为 &lt;code&gt;NULL&lt;/code&gt; 的行。</target>
        </trans-unit>
        <trans-unit id="a9f5100d135261032402eee1426608998aac7beb" translate="yes" xml:space="preserve">
          <source>While for full table scans subquery/leftjoin/correlated timings relate to each other as 6/8/9, when it comes to direct lookups or batch (&lt;code&gt;id in (1,2,3)&lt;/code&gt;), subquery is much slower then the others (Due to rerunning the subquery). However I couldnt differentiate between leftjoin and correlated solutions in speed.</source>
          <target state="translated">虽然对于全表扫描，子查询/ leftjoin /相关时间之间的相互关系为6/8/9，但在直接查找或批处理（ &lt;code&gt;id in (1,2,3)&lt;/code&gt; ）时，子查询要比其他查询慢得多（由于重新运行子查询）。 但是，我无法区分左连接和相关解决方案的速度。</target>
        </trans-unit>
        <trans-unit id="59c4f1cbf0a942eb4eb3e4a90d93e9070d57b26d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; disabled, we can use still use &lt;code&gt;GROUP BY&lt;/code&gt;, but then we are only using it on the Salary, and not the id:</source>
          <target state="translated">在禁用 &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt; 的情况下 ，我们仍然可以使用 &lt;code&gt;GROUP BY&lt;/code&gt; ，但是我们仅在Salary上使用它，而不是id：</target>
        </trans-unit>
        <trans-unit id="a54ed92f38bc881fb7562aedd94827fd1f8b7927" translate="yes" xml:space="preserve">
          <source>With the above data, the result should contain two rows: &lt;code&gt;[1, 3, ...]&lt;/code&gt; and &lt;code&gt;[2, 1, ..]&lt;/code&gt;. I'm using &lt;strong&gt;&lt;em&gt;MySQL&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">使用上述数据，结果应包含两行： &lt;code&gt;[1, 3, ...]&lt;/code&gt; 和 &lt;code&gt;[2, 1, ..]&lt;/code&gt; 。 我正在使用&lt;strong&gt;&lt;em&gt;MySQL&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b040793081e54b56e0ea00ab6ff5580f6556d4ae" translate="yes" xml:space="preserve">
          <source>Yes it looks awful (converting to string and back etc.) but in my experience it's usually faster than the other solutions. Maybe that just for my use cases, but I have used it on tables with millions of records and many unique ids. Maybe it's because MySQL is pretty bad at optimizing the other solutions (at least in the 5.0 days when I came up with this solution).</source>
          <target state="translated">是的,它看起来很糟糕(转换为字符串和返回等),但根据我的经验,它通常比其他解决方案要快。也许这只是针对我的用例,但我曾在有数百万条记录和许多唯一ID的表上使用过它。也许这是因为MySQL在优化其他解决方案方面相当糟糕(至少在5.0时代,当我想出这个解决方案的时候,至少在5.0时代)。</target>
        </trans-unit>
        <trans-unit id="27f562e6f1eb4744f3a84f65dab865c4653ea720" translate="yes" xml:space="preserve">
          <source>Yet another solution is to use a correlated subquery:</source>
          <target state="translated">然而,另一个解决方案是使用相关的子查询。</target>
        </trans-unit>
        <trans-unit id="1394ac848a2275fcc727163db03ae442b55038a4" translate="yes" xml:space="preserve">
          <source>You can do it using &lt;code&gt;IN&lt;/code&gt;
try this:</source>
          <target state="translated">您可以使用 &lt;code&gt;IN&lt;/code&gt; 尝试以下操作：</target>
        </trans-unit>
        <trans-unit id="453880e233710a43167c94bccdd5a1dd285b388f" translate="yes" xml:space="preserve">
          <source>You can make the select without a join when you combine the &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; into one &lt;code&gt;maxRevId&lt;/code&gt; value for &lt;code&gt;MAX()&lt;/code&gt; and then split it back to original values:</source>
          <target state="translated">将 &lt;code&gt;rev&lt;/code&gt; 和 &lt;code&gt;id&lt;/code&gt; 合并为 &lt;code&gt;MAX()&lt;/code&gt; 的一个 &lt;code&gt;maxRevId&lt;/code&gt; 值，然后将其拆分回原始值时，可以不使用联接进行选择：</target>
        </trans-unit>
        <trans-unit id="de4507bccd6edb68f154ba28cbcd9e35a8a477f0" translate="yes" xml:space="preserve">
          <source>You can use this schema in multiple joins and with WHERE clause. It is my working example (solving identical to yours problem with table &quot;firmy&quot;):</source>
          <target state="translated">你可以在多个连接和WHERE子句中使用这种模式。这是我的工作例子(解决与你的问题相同的表 &quot;firmy&quot;)。</target>
        </trans-unit>
        <trans-unit id="f94f563922394ff422dd19d7db9d395cc093c872" translate="yes" xml:space="preserve">
          <source>here is another solution hope it will help someone</source>
          <target state="translated">这里是另一个解决方案,希望能帮到你</target>
        </trans-unit>
        <trans-unit id="7c7f285565dd90fe18340d6bf0386ae80d43766d" translate="yes" xml:space="preserve">
          <source>to my mind it is less complicated... easier to read and maintain.</source>
          <target state="translated">在我看来,它没有那么复杂......更容易阅读和维护。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
