<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/141088">
    <body>
      <group id="141088">
        <trans-unit id="eb62bf8162ffc815e7e0a450233ae73344cf26b4" translate="yes" xml:space="preserve">
          <source>(Take note that the &lt;code&gt;var&lt;/code&gt; keyword is an optional C# 3.0 and above feature, you could also use the exact type of your keys/values here)</source>
          <target state="translated">（请注意， &lt;code&gt;var&lt;/code&gt; 关键字是可选的C＃3.0及更高版本的功能，您还可以在此处使用键/值的确切类型）</target>
        </trans-unit>
        <trans-unit id="026743e8cb8670bfc15d3538a9ad2479fe83c402" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt790184.aspx&quot;&gt;&lt;em&gt;C# 7.0&lt;/em&gt; introduced &lt;strong&gt;Deconstructors&lt;/strong&gt;&lt;/a&gt; and if you are using &lt;em&gt;.NET Core 2.0+&lt;/em&gt; Application, the struct &lt;code&gt;KeyValuePair&amp;lt;&amp;gt;&lt;/code&gt; already include a &lt;code&gt;Deconstruct()&lt;/code&gt; for you. So you can do:</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt790184.aspx&quot;&gt;&lt;em&gt;C＃7.0&lt;/em&gt;引入了&lt;strong&gt;Deconstructors&lt;/strong&gt;&lt;/a&gt; ，如果您使用的是&lt;em&gt;.NET Core 2.0+&lt;/em&gt;应用程序，则结构 &lt;code&gt;KeyValuePair&amp;lt;&amp;gt;&lt;/code&gt; 已经为您提供了 &lt;code&gt;Deconstruct()&lt;/code&gt; 。 因此，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="330db4cc5e1b70f828267dc0892a7a0945a2ddbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; is fastest and if you only iterate over &lt;code&gt;___.Values&lt;/code&gt;, it is also faster</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 是最快的，并且如果仅迭代 &lt;code&gt;___.Values&lt;/code&gt; ，它也会更快</target>
        </trans-unit>
        <trans-unit id="79c0b346684aceccc675b3227ae87626592f99a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dictionary&amp;lt; TKey,&amp;ensp;TValue &amp;gt;&lt;/strong&gt; It is a generic collection class in c# and it stores the data in the key value format.Key must be unique and it can not be null whereas value can be duplicate and null.As each item in the dictionary is treated as KeyValuePair&amp;lt; TKey,&amp;ensp;TValue &amp;gt; structure representing a key and its value. and hence we should take the element type  KeyValuePair&amp;lt; TKey,&amp;ensp;TValue&amp;gt; during the iteration of element.&lt;strong&gt;Below is the example.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Dictionary &amp;lt;TKey，TValue&amp;gt;&lt;/strong&gt;这是c＃中的通用集合类，它以键值格式存储数据。键必须是唯一的，并且不能为null，而值可以重复和为null。视为表示键及其值的KeyValuePair &amp;lt;TKey，TValue&amp;gt;结构。 因此，我们应该在元素迭代期间采用元素类型KeyValuePair &amp;lt;TKey，TValue&amp;gt;。 &lt;strong&gt;以下是示例。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91a956d0b808239ab6cec3a04a363af766520cb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edited To Add:&lt;/strong&gt;
Reading some of the other answers made me question what would happen if I used Dictionary instead of Dictionary. In this example the array took 0.0120024 seconds, the list 0.0185037 seconds and the dictionary 0.0465093 seconds. It's reasonable to expect that the data type makes a difference on how much slower the dictionary is.</source>
          <target state="translated">&lt;strong&gt;编辑添加：&lt;/strong&gt;阅读其他一些答案使我怀疑如果我使用词典而不是词典会发生什么。 在此示例中，数组花费0.0120024秒，列表花费0.0185037秒，字典花费0.0465093秒。 可以合理预期数据类型会影响字典的运行速度。</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7248e135957a14fe596c2f11af12e99c6868b5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What are my Conclusions&lt;/strong&gt;?</source>
          <target state="translated">&lt;strong&gt;我的结论是&lt;/strong&gt;什么？</target>
        </trans-unit>
        <trans-unit id="9100164962c2669d80ab417d22f39cd1aa29af8e" translate="yes" xml:space="preserve">
          <source>Again you might only need the value. LINQ also provides a concise solution to:</source>
          <target state="translated">同样,你可能只需要值。LINQ也提供了一个简明的解决方案。</target>
        </trans-unit>
        <trans-unit id="4f5370435b9afedf2acebdb4888721858ecbf6f9" translate="yes" xml:space="preserve">
          <source>Also, please note that you wont be able to assign values to the 'Value' property inside a foreach-loop. On the other hand, you will be able to manipulate the 'Key' as well, possibly getting you into trouble at runtime.</source>
          <target state="translated">另外,请注意,你不能在foreach-loop中给'Value'属性赋值。另一方面,你也可以操纵'Key',可能会在运行时给你带来麻烦。</target>
        </trans-unit>
        <trans-unit id="76f5e18ba91fd6b70cb9adaefc5933941f851c20" translate="yes" xml:space="preserve">
          <source>Altought this adds a additional call of '.ToList()', there might be a slight performance-improvement (as pointed out here &lt;a href=&quot;https://stackoverflow.com/questions/225937/foreach-vs-somelist-foreach&quot;&gt;foreach vs someList.Foreach(){}&lt;/a&gt;), 
espacially when working with large Dictionaries and running in parallel is no option / won't have an effect at all.</source>
          <target state="translated">可选地，这增加了一个附加的'.ToList（）'调用，可能会稍微改善性能（如此&lt;a href=&quot;https://stackoverflow.com/questions/225937/foreach-vs-somelist-foreach&quot;&gt;处所&lt;/a&gt;指出的foreach与someList.Foreach（）{} ），特别是在使用大型Dictionary并并行运行时选项/根本不会起作用。</target>
        </trans-unit>
        <trans-unit id="497a1c51557e3717356f3865a1603f5a2d32c9e2" translate="yes" xml:space="preserve">
          <source>And lastly, if you're only interested in the values:</source>
          <target state="translated">最后,如果你只对价值观感兴趣的话。</target>
        </trans-unit>
        <trans-unit id="7e38ec34611de5a1fac9cfab4885031bbb66ff1c" translate="yes" xml:space="preserve">
          <source>And use this simple syntax</source>
          <target state="translated">并使用这个简单的语法</target>
        </trans-unit>
        <trans-unit id="92bfa14da3d176a49eb5942098fe4a5e0ee847b8" translate="yes" xml:space="preserve">
          <source>As of C# 7, you can deconstruct objects into variables. I believe this to be the best way to iterate over a dictionary.</source>
          <target state="translated">从C#7开始,你可以将对象解构成变量。我认为这是迭代字典的最佳方式。</target>
        </trans-unit>
        <trans-unit id="9a69642663084ba779311a272e9dd900ea850114" translate="yes" xml:space="preserve">
          <source>Avoid iterating over a dictionary if you can, they are substantially slower than iterating over an array with the same data in it.</source>
          <target state="translated">如果可以的话,避免在字典上迭代,它们比在数组上迭代相同数据的数组要慢很多。</target>
        </trans-unit>
        <trans-unit id="8ca89494efd9d4b2e9284f9172599aafaa794b3f" translate="yes" xml:space="preserve">
          <source>Check this out: &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/&quot;&gt;MSDN Blog - New features in C# 7&lt;/a&gt;</source>
          <target state="translated">签出： &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/&quot;&gt;MSDN博客-C＃7中的新功能&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf9de95bf6f48a9389484e0472b57cafffa12b52" translate="yes" xml:space="preserve">
          <source>Create an extension method on &lt;code&gt;KeyValuePair&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; that deconstructs it:</source>
          <target state="translated">在 &lt;code&gt;KeyValuePair&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; 上创建扩展方法以对其进行解构：</target>
        </trans-unit>
        <trans-unit id="a5d7f786e4ff8d0de7f07cea81a0650c70803c3b" translate="yes" xml:space="preserve">
          <source>Depends on whether you're after the keys or the values...</source>
          <target state="translated">这要看你追求的是按键还是数值......</target>
        </trans-unit>
        <trans-unit id="7f5693528b649c7c6467a276acd2ed66b5c6a0fc" translate="yes" xml:space="preserve">
          <source>Dictionaries are optimised for lookups, so with that in mind I've created two methods. One simply does a foreach, the other iterates the keys then looks up.</source>
          <target state="translated">Dictionaries是为查找而优化的,所以考虑到这一点,我创建了两种方法。一种是简单的foreach,另一种是迭代键,然后进行查找。</target>
        </trans-unit>
        <trans-unit id="eaebe6020d43cd89f479e33d92042d4d05f09fc6" translate="yes" xml:space="preserve">
          <source>Dictionaries are special lists, whereas every value in the list has a key 
   which is also a variable. A good example of a dictionary is a phone book.</source>
          <target state="translated">字典是一个特殊的列表,而列表中的每个值都有一个键,这个键也是一个变量。词典的一个很好的例子就是电话簿。</target>
        </trans-unit>
        <trans-unit id="f66e268e3c61815f0a9aadfa11d0435990b81948" translate="yes" xml:space="preserve">
          <source>FYI, &lt;code&gt;foreach&lt;/code&gt; doesn't work if the value are of type object.</source>
          <target state="translated">仅供参考，如果该值是object类型的，则 &lt;code&gt;foreach&lt;/code&gt; 不起作用。</target>
        </trans-unit>
        <trans-unit id="f8bb288146578f1426d12059b105c4248ba3bf95" translate="yes" xml:space="preserve">
          <source>For a final test I've performed my iteration ten times to see if there are any benefits to using the keys here (by this point I was just curious):</source>
          <target state="translated">作为最后的测试,我在这里进行了十次的迭代,看看在这里使用按键是否有什么好处(此时我只是好奇)。</target>
        </trans-unit>
        <trans-unit id="a95e7b2352f925500843c695ae42c8305794770c" translate="yes" xml:space="preserve">
          <source>From the MSDN &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xfhwa508.aspx&quot;&gt;&lt;code&gt;Dictionary(TKey, TValue)&lt;/code&gt;&lt;/a&gt; Class description:</source>
          <target state="translated">来自MSDN &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xfhwa508.aspx&quot;&gt; &lt;code&gt;Dictionary(TKey, TValue)&lt;/code&gt; &lt;/a&gt;类描述：</target>
        </trans-unit>
        <trans-unit id="0090de992f60b579dc8ed0ae062ff55e83f6c9d4" translate="yes" xml:space="preserve">
          <source>Generally, asking for &quot;the best way&quot; without a specific context is like asking 
&lt;em&gt;what is the best color&lt;/em&gt;?</source>
          <target state="translated">通常，在没有特定上下文的情况下询问&amp;ldquo;最佳方法&amp;rdquo;就像在询问&lt;em&gt;最佳颜色是&lt;/em&gt;什么？</target>
        </trans-unit>
        <trans-unit id="7329ec82a6123d339bb60b69d3500067815fe184" translate="yes" xml:space="preserve">
          <source>Generally, beginners are surprised about order of enumeration of a Dictionary.</source>
          <target state="translated">一般来说,初学者都会对词典的列举顺序感到惊讶。</target>
        </trans-unit>
        <trans-unit id="5ef0e3e404407e991996a23ad4564c3121299baa" translate="yes" xml:space="preserve">
          <source>Here it is:</source>
          <target state="translated">就在这里。</target>
        </trans-unit>
        <trans-unit id="d9350c4847221cf90bedbefd5403e04396a9af43" translate="yes" xml:space="preserve">
          <source>Here the normal foreach run took 0.2820564 seconds (around ten times longer than a single iteration took - as you'd expect). The iteration over the keys took 2.2249449 seconds.</source>
          <target state="translated">在这里,正常的foreach运行时间为0.2820564秒(比单次迭代时间长十倍左右--正如你所期望的那样)。迭代键的时间为2.2249449秒。</target>
        </trans-unit>
        <trans-unit id="2c477bee0d68beb1a51f1cd6faae233ddaf703e8" translate="yes" xml:space="preserve">
          <source>Here's the RunTest method if that helps you visualise what's going on.</source>
          <target state="translated">下面是RunTest的方法,如果这能帮助你直观地看到发生了什么事。</target>
        </trans-unit>
        <trans-unit id="d8bf4f0dde39aae9200beafeade042e6eef6528d" translate="yes" xml:space="preserve">
          <source>However, that is like comparing apples and oranges. My point is that iterating over dictionaries is slow.</source>
          <target state="translated">然而,这就好比是苹果和橘子的比较。我的观点是,迭代字典是很慢的。</target>
        </trans-unit>
        <trans-unit id="a8d167b3a491226f6e12a59d62715ca577941f73" translate="yes" xml:space="preserve">
          <source>I appreciate this question has already had a lot of responses but I wanted to throw in a little research.</source>
          <target state="translated">我很感激这个问题已经有很多人回答了,但我想抛出一点研究。</target>
        </trans-unit>
        <trans-unit id="087718cc256ab6d2e3aa86090f4dff4746dd35b4" translate="yes" xml:space="preserve">
          <source>I found this method in the documentation for the DictionaryBase class on MSDN:</source>
          <target state="translated">我在MSDN上的DictionaryBase类的文档中找到了这个方法。</target>
        </trans-unit>
        <trans-unit id="a0d3a4cfc425a3e0a8768e7618e2f448e7d4a006" translate="yes" xml:space="preserve">
          <source>I know this is a very old question, but I created some extension methods that might be useful:</source>
          <target state="translated">我知道这是一个很老的问题,但我创造了一些扩展方法,可能会有用。</target>
        </trans-unit>
        <trans-unit id="022f337ac135568be545886f9660c8aa25366900" translate="yes" xml:space="preserve">
          <source>I will take the advantage of .NET 4.0+ and provide an updated answer to the originally accepted one:</source>
          <target state="translated">我将利用.NET 4.0+的优势,对最初接受的那一个进行更新的回答。</target>
        </trans-unit>
        <trans-unit id="665b68985ca020cff37a421433dacf69dab38b90" translate="yes" xml:space="preserve">
          <source>I would say foreach is the standard way, though it obviously depends on what you're looking for</source>
          <target state="translated">我想说foreach是标准的方法,不过这显然要看你要找的是什么了</target>
        </trans-unit>
        <trans-unit id="c48c72f51d0a484a1a84eb7af0928b9f44c8b892" translate="yes" xml:space="preserve">
          <source>I wrote an extension to loop over a dictionary.</source>
          <target state="translated">我写了一个扩展来在字典上循环。</target>
        </trans-unit>
        <trans-unit id="2ac3f8179ccd0d030b87d697d99ca03d616f062e" translate="yes" xml:space="preserve">
          <source>I've seen a few different ways to iterate over a dictionary in C#.  Is there a standard way?</source>
          <target state="translated">我见过几种不同的方法来迭代C#中的字典。有没有一个标准的方法?</target>
        </trans-unit>
        <trans-unit id="c94e1b7e69d2dee4055b44d61ee7263b89c08118" translate="yes" xml:space="preserve">
          <source>If say, you want to iterate over the values collection by default, I believe you can implement IEnumerable&amp;lt;&amp;gt;, Where T is the type of the values object in the dictionary, and &quot;this&quot; is a Dictionary.</source>
          <target state="translated">如果说，您想在默认情况下遍历值集合，我相信您可以实现IEnumerable &amp;lt;&amp;gt;，其中T是字典中values对象的类型，而&amp;ldquo; this&amp;rdquo;是Dictionary。</target>
        </trans-unit>
        <trans-unit id="5d589805b05fde41a07bac29079c4d138b37e600" translate="yes" xml:space="preserve">
          <source>If you are trying to use a generic Dictionary in C# like you would use an associative array in another language:</source>
          <target state="translated">如果你想在C#中使用通用字典,就像在其他语言中使用关联数组一样。</target>
        </trans-unit>
        <trans-unit id="225f3d8b8aba090c50b8267620c2a20c558fb879" translate="yes" xml:space="preserve">
          <source>If you do choose to iterate over a dictionary don't try to be too clever, although slower you could do a lot worse than using the standard foreach method.</source>
          <target state="translated">如果你选择在字典上进行迭代,不要太过聪明,虽然比使用标准的foreach方法要慢很多。</target>
        </trans-unit>
        <trans-unit id="8c6850798a250101039b1c803e1f0aa0bfaf7a6f" translate="yes" xml:space="preserve">
          <source>If you need a specific sort order</source>
          <target state="translated">如果您需要特定的排序顺序</target>
        </trans-unit>
        <trans-unit id="72122c33e7e269d2437cc77c6a6dabad50e50d09" translate="yes" xml:space="preserve">
          <source>If you need only the value (allows to call it &lt;code&gt;item&lt;/code&gt;, more readable than &lt;code&gt;kvp.Value&lt;/code&gt;).</source>
          <target state="translated">如果只需要该值（允许将其称为 &lt;code&gt;item&lt;/code&gt; ，则比 &lt;code&gt;kvp.Value&lt;/code&gt; 更具可读性）。</target>
        </trans-unit>
        <trans-unit id="4eb81bd43d3ac692872a05660c909d3b0ce288ab" translate="yes" xml:space="preserve">
          <source>In place of the traditional</source>
          <target state="translated">取而代之的是传统的</target>
        </trans-unit>
        <trans-unit id="1f92c68b2be2630fe633591fd3b21b630d437ef5" translate="yes" xml:space="preserve">
          <source>In practice, this new syntax suits very well for most cases, except for low-level ultra-high performance scenarios, where you still have the option to simply not use it on that specific spot.</source>
          <target state="translated">在实践中,这种新的语法很适合大多数情况下,除了低级超高性能的场景,你仍然可以选择干脆不在那个特定的点上使用。</target>
        </trans-unit>
        <trans-unit id="c6c6c6ff7fee12c22582376bd7ab848207b260bf" translate="yes" xml:space="preserve">
          <source>In some cases you may need a counter that may be provided by for-loop implementation. For that, LINQ provides &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx&quot;&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/a&gt; which enables the following:</source>
          <target state="translated">在某些情况下，您可能需要一个由for循环实现提供的计数器。 为此，LINQ提供了&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx&quot;&gt; &lt;code&gt;ElementAt&lt;/code&gt; &lt;/a&gt; ，它可以实现以下功能：</target>
        </trans-unit>
        <trans-unit id="14cd2de22272c6bf242c99d4bdaf33377d866818" translate="yes" xml:space="preserve">
          <source>Is that what you're looking for?</source>
          <target state="translated">这就是你要找的东西吗?</target>
        </trans-unit>
        <trans-unit id="1b5a5787fcfada038cc95ac0f53477decb94de59" translate="yes" xml:space="preserve">
          <source>It converts -just- the required dictionary entries to &lt;code&gt;tuples&lt;/code&gt;, so it does NOT converts the whole dictionary to &lt;code&gt;tuples&lt;/code&gt;, so there are no performance concerns related to that.</source>
          <target state="translated">它将所需的字典条目仅转换为 &lt;code&gt;tuples&lt;/code&gt; ，因此不会将整个字典转换为 &lt;code&gt;tuples&lt;/code&gt; ，因此不存在与性能相关的问题。</target>
        </trans-unit>
        <trans-unit id="a1cb1752fca818aa6ba5c1e1d61b985e10cddfec" translate="yes" xml:space="preserve">
          <source>Iterate over any &lt;code&gt;Dictionary&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; in the following manner</source>
          <target state="translated">以下列方式遍历任何 &lt;code&gt;Dictionary&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb2d3fba103eca2485423e3fb51dc4e236fbd0ce" translate="yes" xml:space="preserve">
          <source>Iterating over a dictionary can be rather slow when compared with iterating over something like an array. In my tests an iteration over an array took 0.015003 seconds whereas an iteration over a dictionary (with the same number of elements) took 0.0365073 seconds that's 2.4 times as long! Although I have seen much bigger differences. For comparison a List was somewhere in between at 0.00215043 seconds.</source>
          <target state="translated">在字典上的迭代与在数组上的迭代相比,可能会比较慢。在我的测试中,在数组上的迭代需要0.015003秒,而在字典上的迭代(元素数量相同)需要0.0365073秒,是数组的2.4倍!虽然我看到了更大的差异。虽然我看到的差异要大得多。相比之下,List的时间在0.00215043秒之间。</target>
        </trans-unit>
        <trans-unit id="a30af6777f73b0b81eafe94ebef2f42d18285976" translate="yes" xml:space="preserve">
          <source>Just wanted to add my 2 cent, as the most answers relate to foreach-loop.
Please, take a look at the following code:</source>
          <target state="translated">只是想补充一下我的2分钱,因为大部分的答案都和foreach-loop有关。请大家看一下下面的代码。</target>
        </trans-unit>
        <trans-unit id="0a312e402e1aefeb15436d8d429a387734134010" translate="yes" xml:space="preserve">
          <source>LINQ provides a concise syntax that allows to specify order (and many other things), e.g.:</source>
          <target state="translated">LINQ提供了一个简明的语法,允许指定顺序(和许多其他事情),例如。</target>
        </trans-unit>
        <trans-unit id="56a3d1d4a9f3c543ec2f04e96ad6e723eacbd1c6" translate="yes" xml:space="preserve">
          <source>Most straightforward way</source>
          <target state="translated">最直接的方法</target>
        </trans-unit>
        <trans-unit id="6939829ecad0770c1f2854c706760a6aad96113e" translate="yes" xml:space="preserve">
          <source>Notice that when defining a dictionary, we need to provide a generic 
   definition with two types - the type of the key and the type of the value. In this case, the key is a string whereas the value is an integer.</source>
          <target state="translated">注意,在定义一个字典时,我们需要提供一个通用的定义,其中包含两种类型--键的类型和值的类型。在这种情况下,键是一个字符串,而值是一个整数。</target>
        </trans-unit>
        <trans-unit id="c2687d7fa52a2592c8abbc6f420259028139b52c" translate="yes" xml:space="preserve">
          <source>On the other hand, there are many ways to iterate over a Dictionary in C# and there's no best way. It depends on the need and often on taste, too.</source>
          <target state="translated">另一方面,C#中迭代字典的方法有很多,没有最好的方法。这要看需要,往往也要看口味。</target>
        </trans-unit>
        <trans-unit id="12901374eb2c7fd59c9860f5abf06b72a4bb681c" translate="yes" xml:space="preserve">
          <source>One the one hand, there are many colors and there's no best color.  It depends on the need and often on taste, too.</source>
          <target state="translated">一方面,颜色有很多种,没有最好的颜色。这要看需要,往往也要看口味。</target>
        </trans-unit>
        <trans-unit id="9c2bcf06294a90e8e083763566b9deae7c61faa9" translate="yes" xml:space="preserve">
          <source>Or this one, if you prefer</source>
          <target state="translated">如果你喜欢的话,也可以是这个</target>
        </trans-unit>
        <trans-unit id="61e638ebf858c1f563ec3104471c16d5c2b33444" translate="yes" xml:space="preserve">
          <source>Or, if you only need to iterate over the collection of keys, use</source>
          <target state="translated">或者,如果你只需要迭代键的集合,使用</target>
        </trans-unit>
        <trans-unit id="cd47115f2beda73a07079a12612fb07fbf287c47" translate="yes" xml:space="preserve">
          <source>Reported by this post which states it is the fastest method:
&lt;a href=&quot;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&quot;&gt;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&lt;/a&gt;</source>
          <target state="translated">这篇文章报道说这是最快的方法： &lt;a href=&quot;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&quot;&gt;http&lt;/a&gt; : //alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html</target>
        </trans-unit>
        <trans-unit id="da423e06f316e7ef8aa1cb69bd467a47205d94ad" translate="yes" xml:space="preserve">
          <source>Simplest form to iterate a dictionary:</source>
          <target state="translated">迭代字典的最简单形式。</target>
        </trans-unit>
        <trans-unit id="3266a6cd5309e4591b0f00524a9a57f4b4865ecd" translate="yes" xml:space="preserve">
          <source>Sometimes if you only needs the values to be enumerated, use the dictionary's value collection:</source>
          <target state="translated">有时如果你只需要枚举值,可以使用字典中的值集合。</target>
        </trans-unit>
        <trans-unit id="d495734261a4228a062272f11bfaaa266e315883" translate="yes" xml:space="preserve">
          <source>The extension method transforms the &lt;code&gt;KeyValuePair&lt;/code&gt; of your &lt;code&gt;IDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; into a strongly typed &lt;code&gt;tuple&lt;/code&gt;, allowing you to use this new comfortable syntax.</source>
          <target state="translated">扩展方法将您的 &lt;code&gt;IDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; 的 &lt;code&gt;KeyValuePair&lt;/code&gt; 转换为强类型的 &lt;code&gt;tuple&lt;/code&gt; ，从而使您可以使用这种新的舒适语法。</target>
        </trans-unit>
        <trans-unit id="04b1fb11f6c618e8f6576b6be78983440400acfe" translate="yes" xml:space="preserve">
          <source>The standard way to iterate over a Dictionary, according to official documentation on MSDN is:</source>
          <target state="translated">根据MSDN上的官方文档,对字典进行迭代的标准方法是。</target>
        </trans-unit>
        <trans-unit id="5c5db52c67a7720b7c781aa83c84b6a7d4078cff" translate="yes" xml:space="preserve">
          <source>Then you can call</source>
          <target state="translated">那么你可以打电话给</target>
        </trans-unit>
        <trans-unit id="f35263d7d55bb1cc907239b11f8f7a8702c56214" translate="yes" xml:space="preserve">
          <source>There are also two ways of adding a single value to the dictionary, either using the brackets operator or using the Add method.</source>
          <target state="translated">在字典中添加单值的方法也有两种,一是使用括号操作符,二是使用Add方法。</target>
        </trans-unit>
        <trans-unit id="af00928700168d8333d32e85c9816e62844f0cc2" translate="yes" xml:space="preserve">
          <source>There are many more real-world use case you can do from these examples.
If you don't need a specific order, just stick to the &quot;most straightforward way&quot; (see above)!</source>
          <target state="translated">从这些例子中,你可以做的实际用例还有很多。如果你不需要特定的命令,就坚持用 &quot;最直接的方法&quot;(见上图)!</target>
        </trans-unit>
        <trans-unit id="cbe911091640f53097aaa45e1b69c726cffdc605" translate="yes" xml:space="preserve">
          <source>There are plenty of options. My personal favorite is by KeyValuePair</source>
          <target state="translated">有很多的选择。我个人最喜欢的是KeyValuePair</target>
        </trans-unit>
        <trans-unit id="58dc2fee9700cb4d481b705fc61ae688a1068e85" translate="yes" xml:space="preserve">
          <source>There is a only minor cost calling the extension method for creating a &lt;code&gt;tuple&lt;/code&gt; in comparison with using the &lt;code&gt;KeyValuePair&lt;/code&gt; directly, which should NOT be an issue if you are assigning the &lt;code&gt;KeyValuePair&lt;/code&gt;'s properties &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; to new loop variables anyway.</source>
          <target state="translated">与直接使用 &lt;code&gt;KeyValuePair&lt;/code&gt; 相比，调用扩展方法来创建 &lt;code&gt;tuple&lt;/code&gt; 只有很少的花费，如果无论如何要将 &lt;code&gt;KeyValuePair&lt;/code&gt; 的属性 &lt;code&gt;Key&lt;/code&gt; 和 &lt;code&gt;Value&lt;/code&gt; 分配给新的循环变量，这应该不是问题。</target>
        </trans-unit>
        <trans-unit id="be499d7dd68e14f2114cfde873ca49059efc393f" translate="yes" xml:space="preserve">
          <source>This one loads the keys and iterates over them instead (I did also try pulling the keys into a string[] but the difference was negligible.</source>
          <target state="translated">这一个加载键,并对它们进行迭代(我也尝试过将键拉到一个字符串[]中,但差别可以忽略不计。</target>
        </trans-unit>
        <trans-unit id="00690079c2a4e1bf43ab84d2f19bcb896eb4878a" translate="yes" xml:space="preserve">
          <source>This was the only one I was able to get functioning correctly in a class that inherited from the DictionaryBase.</source>
          <target state="translated">这是我唯一一个能够在继承自DictionaryBase的类中正常运行的类。</target>
        </trans-unit>
        <trans-unit id="931954f05d1cefa1f2835133f3657de4a6c2d35b" translate="yes" xml:space="preserve">
          <source>This way I can write code like this:</source>
          <target state="translated">这样我就可以写出这样的代码了。</target>
        </trans-unit>
        <trans-unit id="2a656f1ac324e97541d2983757ff92a90334a431" translate="yes" xml:space="preserve">
          <source>To check whether a dictionary has a certain key in it, we can use the ContainsKey method:</source>
          <target state="translated">要检查一个字典中是否有某个键,我们可以使用 ContainsKey 方法。</target>
        </trans-unit>
        <trans-unit id="28addee6cedf87e3145cfbfd1410ddb4937da311" translate="yes" xml:space="preserve">
          <source>To make this code work on lower C# versions, add &lt;code&gt;System.ValueTuple NuGet package&lt;/code&gt; and write somewhere</source>
          <target state="translated">要使此代码在较低的C＃版本上运行，请添加 &lt;code&gt;System.ValueTuple NuGet package&lt;/code&gt; 并在某处编写</target>
        </trans-unit>
        <trans-unit id="6e440ac8f22b4b54d8858e18f05ed7e2f1f9fb3c" translate="yes" xml:space="preserve">
          <source>To remove an item from a dictionary, we can use the Remove method. Removing an item from a dictionary by its key is fast and very efficient. When removing an item from a List using its value, the process is slow and inefficient, unlike the dictionary Remove function.</source>
          <target state="translated">要从字典中删除一个项目,我们可以使用Remove方法。通过键从字典中删除一个项,速度很快,效率很高。而使用值从List中删除一个项目时,这个过程比较慢,效率很低,不像字典中的Remove函数。</target>
        </trans-unit>
        <trans-unit id="561e6208f8daae64c5bf6a710fd669c6e1d73db0" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;C# 7&lt;/strong&gt;, add this &lt;strong&gt;extension method&lt;/strong&gt; to any project of your solution:</source>
          <target state="translated">使用&lt;strong&gt;C＃7&lt;/strong&gt; ，将此&lt;strong&gt;扩展方法&lt;/strong&gt;添加到解决方案的任何项目中：</target>
        </trans-unit>
        <trans-unit id="25b2893d19aeea1311a5246ea8feadc8bddd54c7" translate="yes" xml:space="preserve">
          <source>What is the best way to iterate over a dictionary</source>
          <target state="translated">迭代字典的最佳方法是什么?</target>
        </trans-unit>
        <trans-unit id="35b69990e0e3a3bead58a6d1d0b26f1f2e48bfb1" translate="yes" xml:space="preserve">
          <source>When you just want to &quot;read&quot; Keys and Values, you might also use IEnumerable.Select().</source>
          <target state="translated">当你只想 &quot;读取 &quot;键和值时,你也可以使用IEnumerable.Select()。</target>
        </trans-unit>
        <trans-unit id="d5e5c20123cee839590aadc6944acfc8b6ba57b0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.NET Framework 4.7&lt;/code&gt; one can use &lt;em&gt;decomposition&lt;/em&gt;</source>
          <target state="translated">使用 &lt;code&gt;.NET Framework 4.7&lt;/code&gt; ,可以使用&lt;em&gt;分解&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adddc5ba674bb912706e0bc6e404e69342e046de" translate="yes" xml:space="preserve">
          <source>With this example the normal foreach test took 0.0310062 and the keys version took 0.2205441. Loading all the keys and iterating over all the lookups is clearly a LOT slower!</source>
          <target state="translated">在这个例子中,正常的foreach测试用了0.0310062,而keys版本用了0.2205441。加载所有的键并迭代所有的查找结果显然要慢很多!</target>
        </trans-unit>
        <trans-unit id="74a7440666a25dae99e6a51679822864419959f7" translate="yes" xml:space="preserve">
          <source>You can also try this on big dictionaries for multithreaded processing.</source>
          <target state="translated">你也可以在大字典上尝试一下,进行多线程处理。</target>
        </trans-unit>
        <trans-unit id="89dbe6661417ad0ac5d04a14f040438e17c79f9e" translate="yes" xml:space="preserve">
          <source>You can also use the Keys and Values Collections</source>
          <target state="translated">您也可以使用密钥和值集合</target>
        </trans-unit>
        <trans-unit id="8bde3ca31d73fcbcb92dbfcc529338d5f8eebf16" translate="yes" xml:space="preserve">
          <source>You suggested below to iterate</source>
          <target state="translated">您在下文中建议进行迭代</target>
        </trans-unit>
        <trans-unit id="a79b7064f585723bd2a6d43d8ede72db3bc54422" translate="yes" xml:space="preserve">
          <source>but sorted by the keys</source>
          <target state="translated">但按键排序</target>
        </trans-unit>
        <trans-unit id="3107d23c2c12366f1af56b42170c59f9dff15fdc" translate="yes" xml:space="preserve">
          <source>in addition to the highest ranking posts where there is a discussion between using</source>
          <target state="translated">排名靠前的帖子中,除了有讨论使用</target>
        </trans-unit>
        <trans-unit id="52622b7a5d5b59d00e8b4165042de57215a2bb93" translate="yes" xml:space="preserve">
          <source>iterate directly on the value (allows to call it &lt;code&gt;item&lt;/code&gt;, more readable than &lt;code&gt;kvp.Value&lt;/code&gt;)</source>
          <target state="translated">直接在值上进行迭代（允许将其称为 &lt;code&gt;item&lt;/code&gt; ，比 &lt;code&gt;kvp.Value&lt;/code&gt; 更具可读性）</target>
        </trans-unit>
        <trans-unit id="becfe9c4e9a3d53784bb97c520dc78c924051aeb" translate="yes" xml:space="preserve">
          <source>most complete is the following because you can see the dictionary type from the initialization, kvp is KeyValuePair</source>
          <target state="translated">最完整的是下面这个,因为从初始化中可以看到字典的类型,kvp是KeyValuePair,是KeyValuePair</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
