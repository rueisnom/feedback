<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/141088">
    <body>
      <group id="141088">
        <trans-unit id="eb62bf8162ffc815e7e0a450233ae73344cf26b4" translate="yes" xml:space="preserve">
          <source>(Take note that the &lt;code&gt;var&lt;/code&gt; keyword is an optional C# 3.0 and above feature, you could also use the exact type of your keys/values here)</source>
          <target state="translated">（ &lt;code&gt;var&lt;/code&gt; キーワードはC＃3.0以降のオプション機能であり、ここではキー/値の正確なタイプを使用することもできます）</target>
        </trans-unit>
        <trans-unit id="026743e8cb8670bfc15d3538a9ad2479fe83c402" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt790184.aspx&quot;&gt;&lt;em&gt;C# 7.0&lt;/em&gt; introduced &lt;strong&gt;Deconstructors&lt;/strong&gt;&lt;/a&gt; and if you are using &lt;em&gt;.NET Core 2.0+&lt;/em&gt; Application, the struct &lt;code&gt;KeyValuePair&amp;lt;&amp;gt;&lt;/code&gt; already include a &lt;code&gt;Deconstruct()&lt;/code&gt; for you. So you can do:</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt790184.aspx&quot;&gt;&lt;em&gt;C＃7.0&lt;/em&gt;は&lt;strong&gt;Deconstructors&lt;/strong&gt;&lt;/a&gt;を導入しました &lt;em&gt;。.NETCore 2.0+&lt;/em&gt;アプリケーションを使用している場合、struct &lt;code&gt;KeyValuePair&amp;lt;&amp;gt;&lt;/code&gt; すでに &lt;code&gt;Deconstruct()&lt;/code&gt; が含まれています。 だからあなたはできる：</target>
        </trans-unit>
        <trans-unit id="330db4cc5e1b70f828267dc0892a7a0945a2ddbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; is fastest and if you only iterate over &lt;code&gt;___.Values&lt;/code&gt;, it is also faster</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; が最も高速で、 &lt;code&gt;___.Values&lt;/code&gt; 反復するだけの場合も高速です</target>
        </trans-unit>
        <trans-unit id="79c0b346684aceccc675b3227ae87626592f99a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dictionary&amp;lt; TKey,&amp;ensp;TValue &amp;gt;&lt;/strong&gt; It is a generic collection class in c# and it stores the data in the key value format.Key must be unique and it can not be null whereas value can be duplicate and null.As each item in the dictionary is treated as KeyValuePair&amp;lt; TKey,&amp;ensp;TValue &amp;gt; structure representing a key and its value. and hence we should take the element type  KeyValuePair&amp;lt; TKey,&amp;ensp;TValue&amp;gt; during the iteration of element.&lt;strong&gt;Below is the example.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Dictionary &amp;lt;TKey、TValue&amp;gt;&lt;/strong&gt;これはc＃のジェネリックコレクションクラスであり、データをキー値形式で格納します。キーは一意である必要があり、nullにすることはできませんが、値は重複してnullにすることができます。ディクショナリ内の各アイテムはキーとその値を表すKeyValuePair &amp;lt;TKey、TValue&amp;gt;構造として扱われます。 したがって、要素の反復中に要素型KeyValuePair &amp;lt;TKey、TValue&amp;gt;を取得する必要があります。 &lt;strong&gt;以下はその例です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91a956d0b808239ab6cec3a04a363af766520cb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edited To Add:&lt;/strong&gt;
Reading some of the other answers made me question what would happen if I used Dictionary instead of Dictionary. In this example the array took 0.0120024 seconds, the list 0.0185037 seconds and the dictionary 0.0465093 seconds. It's reasonable to expect that the data type makes a difference on how much slower the dictionary is.</source>
          <target state="translated">&lt;strong&gt;追加編集：&lt;/strong&gt;他の回答のいくつかを読んで、辞書ではなく辞書を使用するとどうなるか疑問に思いました。 この例では、配列は0.0120024秒、リストは0.0185037秒、辞書は0.0465093秒かかりました。 データ型によって、ディクショナリの速度がどれほど遅くなるかを予測するのは妥当です。</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7248e135957a14fe596c2f11af12e99c6868b5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What are my Conclusions&lt;/strong&gt;?</source>
          <target state="translated">&lt;strong&gt;私の結論は何&lt;/strong&gt;ですか？</target>
        </trans-unit>
        <trans-unit id="9100164962c2669d80ab417d22f39cd1aa29af8e" translate="yes" xml:space="preserve">
          <source>Again you might only need the value. LINQ also provides a concise solution to:</source>
          <target state="translated">ここでも必要なのは値だけかもしれません。LINQはまた、以下のような簡潔なソリューションを提供します。</target>
        </trans-unit>
        <trans-unit id="4f5370435b9afedf2acebdb4888721858ecbf6f9" translate="yes" xml:space="preserve">
          <source>Also, please note that you wont be able to assign values to the 'Value' property inside a foreach-loop. On the other hand, you will be able to manipulate the 'Key' as well, possibly getting you into trouble at runtime.</source>
          <target state="translated">また、foreach ループ内では 'Value' プロパティに値を代入することができないことに注意してください。一方で、'Key'も操作できるようになるので、実行時にトラブルに巻き込まれる可能性があります。</target>
        </trans-unit>
        <trans-unit id="76f5e18ba91fd6b70cb9adaefc5933941f851c20" translate="yes" xml:space="preserve">
          <source>Altought this adds a additional call of '.ToList()', there might be a slight performance-improvement (as pointed out here &lt;a href=&quot;https://stackoverflow.com/questions/225937/foreach-vs-somelist-foreach&quot;&gt;foreach vs someList.Foreach(){}&lt;/a&gt;), 
espacially when working with large Dictionaries and running in parallel is no option / won't have an effect at all.</source>
          <target state="translated">これは、「。ToList（）」の追加の呼び出しを追加します。大きなディクショナリを使用して並列実行している場合は特に、 &lt;a href=&quot;https://stackoverflow.com/questions/225937/foreach-vs-somelist-foreach&quot;&gt;foreachとsomeList.Foreach（）{}で&lt;/a&gt;指摘されているように、パフォーマンスが若干向上する可能性があります。オプション/はまったく効果がありません。</target>
        </trans-unit>
        <trans-unit id="497a1c51557e3717356f3865a1603f5a2d32c9e2" translate="yes" xml:space="preserve">
          <source>And lastly, if you're only interested in the values:</source>
          <target state="translated">最後に、価値観だけに興味がある人は</target>
        </trans-unit>
        <trans-unit id="7e38ec34611de5a1fac9cfab4885031bbb66ff1c" translate="yes" xml:space="preserve">
          <source>And use this simple syntax</source>
          <target state="translated">そして、このシンプルな構文を使用します。</target>
        </trans-unit>
        <trans-unit id="92bfa14da3d176a49eb5942098fe4a5e0ee847b8" translate="yes" xml:space="preserve">
          <source>As of C# 7, you can deconstruct objects into variables. I believe this to be the best way to iterate over a dictionary.</source>
          <target state="translated">C#7の時点では、オブジェクトを変数に分解できるようになっています。辞書の反復処理にはこれが最適だと思います。</target>
        </trans-unit>
        <trans-unit id="9a69642663084ba779311a272e9dd900ea850114" translate="yes" xml:space="preserve">
          <source>Avoid iterating over a dictionary if you can, they are substantially slower than iterating over an array with the same data in it.</source>
          <target state="translated">可能であれば辞書の反復処理は避けてください。</target>
        </trans-unit>
        <trans-unit id="8ca89494efd9d4b2e9284f9172599aafaa794b3f" translate="yes" xml:space="preserve">
          <source>Check this out: &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/&quot;&gt;MSDN Blog - New features in C# 7&lt;/a&gt;</source>
          <target state="translated">これをチェックしてください： &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/&quot;&gt;MSDNブログ-C＃7の新機能&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf9de95bf6f48a9389484e0472b57cafffa12b52" translate="yes" xml:space="preserve">
          <source>Create an extension method on &lt;code&gt;KeyValuePair&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; that deconstructs it:</source>
          <target state="translated">&lt;code&gt;KeyValuePair&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; 拡張メソッドを作成します。</target>
        </trans-unit>
        <trans-unit id="a5d7f786e4ff8d0de7f07cea81a0650c70803c3b" translate="yes" xml:space="preserve">
          <source>Depends on whether you're after the keys or the values...</source>
          <target state="translated">キーか値のどちらを狙うかにもよりますが...。</target>
        </trans-unit>
        <trans-unit id="7f5693528b649c7c6467a276acd2ed66b5c6a0fc" translate="yes" xml:space="preserve">
          <source>Dictionaries are optimised for lookups, so with that in mind I've created two methods. One simply does a foreach, the other iterates the keys then looks up.</source>
          <target state="translated">辞書は検索に最適化されているので、それを考慮して2つの方法を作りました。1つは単純にforeachを行い、もう1つはキーを反復処理してから検索します。</target>
        </trans-unit>
        <trans-unit id="eaebe6020d43cd89f479e33d92042d4d05f09fc6" translate="yes" xml:space="preserve">
          <source>Dictionaries are special lists, whereas every value in the list has a key 
   which is also a variable. A good example of a dictionary is a phone book.</source>
          <target state="translated">辞書は特殊なリストであり、リスト内のすべての値は変数でもあるキーを持っています。辞書の良い例は電話帳です。</target>
        </trans-unit>
        <trans-unit id="f66e268e3c61815f0a9aadfa11d0435990b81948" translate="yes" xml:space="preserve">
          <source>FYI, &lt;code&gt;foreach&lt;/code&gt; doesn't work if the value are of type object.</source>
          <target state="translated">参考までに、値がオブジェクト型の場合、 &lt;code&gt;foreach&lt;/code&gt; は機能しません。</target>
        </trans-unit>
        <trans-unit id="f8bb288146578f1426d12059b105c4248ba3bf95" translate="yes" xml:space="preserve">
          <source>For a final test I've performed my iteration ten times to see if there are any benefits to using the keys here (by this point I was just curious):</source>
          <target state="translated">最後のテストとして、ここでキーを使用することに何かメリットがあるかどうかを確認するために、私は10回のイテレーションを実行しました(この時点までに私はただ興味を持っていました)。</target>
        </trans-unit>
        <trans-unit id="a95e7b2352f925500843c695ae42c8305794770c" translate="yes" xml:space="preserve">
          <source>From the MSDN &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xfhwa508.aspx&quot;&gt;&lt;code&gt;Dictionary(TKey, TValue)&lt;/code&gt;&lt;/a&gt; Class description:</source>
          <target state="translated">MSDN &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xfhwa508.aspx&quot;&gt; &lt;code&gt;Dictionary(TKey, TValue)&lt;/code&gt; &lt;/a&gt;クラスの説明から：</target>
        </trans-unit>
        <trans-unit id="0090de992f60b579dc8ed0ae062ff55e83f6c9d4" translate="yes" xml:space="preserve">
          <source>Generally, asking for &quot;the best way&quot; without a specific context is like asking 
&lt;em&gt;what is the best color&lt;/em&gt;?</source>
          <target state="translated">一般的に、特定のコンテキストなしで「最良の方法」を求めるの&lt;em&gt;は、何が最良の色なの&lt;/em&gt;かを求めるような&lt;em&gt;もの&lt;/em&gt;です</target>
        </trans-unit>
        <trans-unit id="7329ec82a6123d339bb60b69d3500067815fe184" translate="yes" xml:space="preserve">
          <source>Generally, beginners are surprised about order of enumeration of a Dictionary.</source>
          <target state="translated">一般的に初心者は、辞書の列挙順に驚く。</target>
        </trans-unit>
        <trans-unit id="5ef0e3e404407e991996a23ad4564c3121299baa" translate="yes" xml:space="preserve">
          <source>Here it is:</source>
          <target state="translated">ここにあります。</target>
        </trans-unit>
        <trans-unit id="d9350c4847221cf90bedbefd5403e04396a9af43" translate="yes" xml:space="preserve">
          <source>Here the normal foreach run took 0.2820564 seconds (around ten times longer than a single iteration took - as you'd expect). The iteration over the keys took 2.2249449 seconds.</source>
          <target state="translated">ここでは、通常のforeachの実行には0.2820564秒かかっている(1回のイテレーションにかかった時間の約10倍の時間がかかっている-期待通り)。キーの反復処理には2.2249449秒かかりました。</target>
        </trans-unit>
        <trans-unit id="2c477bee0d68beb1a51f1cd6faae233ddaf703e8" translate="yes" xml:space="preserve">
          <source>Here's the RunTest method if that helps you visualise what's going on.</source>
          <target state="translated">何が起こっているかを視覚化するのに役立つならば、これがRunTestメソッドです。</target>
        </trans-unit>
        <trans-unit id="d8bf4f0dde39aae9200beafeade042e6eef6528d" translate="yes" xml:space="preserve">
          <source>However, that is like comparing apples and oranges. My point is that iterating over dictionaries is slow.</source>
          <target state="translated">しかし、それはリンゴとオレンジを比較するようなものです。私が言いたいのは、辞書の反復処理は遅いということです。</target>
        </trans-unit>
        <trans-unit id="a8d167b3a491226f6e12a59d62715ca577941f73" translate="yes" xml:space="preserve">
          <source>I appreciate this question has already had a lot of responses but I wanted to throw in a little research.</source>
          <target state="translated">私はこの質問がすでに多くの応答を持っていた感謝しますが、私は少しの研究でスローしたかった。</target>
        </trans-unit>
        <trans-unit id="087718cc256ab6d2e3aa86090f4dff4746dd35b4" translate="yes" xml:space="preserve">
          <source>I found this method in the documentation for the DictionaryBase class on MSDN:</source>
          <target state="translated">MSDNのDictionaryBaseクラスのドキュメントにこのメソッドを見つけました。</target>
        </trans-unit>
        <trans-unit id="a0d3a4cfc425a3e0a8768e7618e2f448e7d4a006" translate="yes" xml:space="preserve">
          <source>I know this is a very old question, but I created some extension methods that might be useful:</source>
          <target state="translated">これは非常に古い質問だとは思いますが、便利そうな拡張メソッドをいくつか作りました。</target>
        </trans-unit>
        <trans-unit id="022f337ac135568be545886f9660c8aa25366900" translate="yes" xml:space="preserve">
          <source>I will take the advantage of .NET 4.0+ and provide an updated answer to the originally accepted one:</source>
          <target state="translated">私は.NET 4.0+の利点を活かし、元々受け入れられていたものに対して最新の回答を提供していきます。</target>
        </trans-unit>
        <trans-unit id="665b68985ca020cff37a421433dacf69dab38b90" translate="yes" xml:space="preserve">
          <source>I would say foreach is the standard way, though it obviously depends on what you're looking for</source>
          <target state="translated">foreachが標準的な方法だと思いますが、何を探しているのかにもよりますが</target>
        </trans-unit>
        <trans-unit id="c48c72f51d0a484a1a84eb7af0928b9f44c8b892" translate="yes" xml:space="preserve">
          <source>I wrote an extension to loop over a dictionary.</source>
          <target state="translated">辞書をループさせる拡張機能を書きました。</target>
        </trans-unit>
        <trans-unit id="2ac3f8179ccd0d030b87d697d99ca03d616f062e" translate="yes" xml:space="preserve">
          <source>I've seen a few different ways to iterate over a dictionary in C#.  Is there a standard way?</source>
          <target state="translated">C#で辞書を反復処理する方法をいくつか見てきましたが、標準的な方法はありますか?標準的な方法はありますか?</target>
        </trans-unit>
        <trans-unit id="c94e1b7e69d2dee4055b44d61ee7263b89c08118" translate="yes" xml:space="preserve">
          <source>If say, you want to iterate over the values collection by default, I believe you can implement IEnumerable&amp;lt;&amp;gt;, Where T is the type of the values object in the dictionary, and &quot;this&quot; is a Dictionary.</source>
          <target state="translated">たとえば、デフォルトで値のコレクションを反復処理したい場合、IEnumerable &amp;lt;&amp;gt;を実装できると思います。Tはディクショナリ内の値オブジェクトのタイプで、「this」はディクショナリです。</target>
        </trans-unit>
        <trans-unit id="5d589805b05fde41a07bac29079c4d138b37e600" translate="yes" xml:space="preserve">
          <source>If you are trying to use a generic Dictionary in C# like you would use an associative array in another language:</source>
          <target state="translated">他の言語で連想配列を使うのと同じように、C#で汎用辞書を使おうとしている場合。</target>
        </trans-unit>
        <trans-unit id="225f3d8b8aba090c50b8267620c2a20c558fb879" translate="yes" xml:space="preserve">
          <source>If you do choose to iterate over a dictionary don't try to be too clever, although slower you could do a lot worse than using the standard foreach method.</source>
          <target state="translated">辞書を反復処理することを選択した場合は、標準のforeachメソッドを使用するよりも多くの悪いことを行うことができますが、遅くなりますが、あまりにも賢いことをしようとしないでください。</target>
        </trans-unit>
        <trans-unit id="8c6850798a250101039b1c803e1f0aa0bfaf7a6f" translate="yes" xml:space="preserve">
          <source>If you need a specific sort order</source>
          <target state="translated">特定のソート順が必要な場合</target>
        </trans-unit>
        <trans-unit id="72122c33e7e269d2437cc77c6a6dabad50e50d09" translate="yes" xml:space="preserve">
          <source>If you need only the value (allows to call it &lt;code&gt;item&lt;/code&gt;, more readable than &lt;code&gt;kvp.Value&lt;/code&gt;).</source>
          <target state="translated">値のみが必要な場合（これを &lt;code&gt;item&lt;/code&gt; と呼ぶことができ、 &lt;code&gt;kvp.Value&lt;/code&gt; よりも読みやすくなります ）。</target>
        </trans-unit>
        <trans-unit id="4eb81bd43d3ac692872a05660c909d3b0ce288ab" translate="yes" xml:space="preserve">
          <source>In place of the traditional</source>
          <target state="translated">伝統的なものの代わりに</target>
        </trans-unit>
        <trans-unit id="1f92c68b2be2630fe633591fd3b21b630d437ef5" translate="yes" xml:space="preserve">
          <source>In practice, this new syntax suits very well for most cases, except for low-level ultra-high performance scenarios, where you still have the option to simply not use it on that specific spot.</source>
          <target state="translated">実際には、この新しい構文は、低レベルの超高性能シナリオを除いて、ほとんどの場合に非常に適しています。</target>
        </trans-unit>
        <trans-unit id="c6c6c6ff7fee12c22582376bd7ab848207b260bf" translate="yes" xml:space="preserve">
          <source>In some cases you may need a counter that may be provided by for-loop implementation. For that, LINQ provides &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx&quot;&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/a&gt; which enables the following:</source>
          <target state="translated">場合によっては、forループの実装によって提供されるカウンターが必要になることがあります。 そのために、LINQは以下を可能にする&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx&quot;&gt; &lt;code&gt;ElementAt&lt;/code&gt; &lt;/a&gt;を提供します。</target>
        </trans-unit>
        <trans-unit id="14cd2de22272c6bf242c99d4bdaf33377d866818" translate="yes" xml:space="preserve">
          <source>Is that what you're looking for?</source>
          <target state="translated">それはあなたが探しているものですか?</target>
        </trans-unit>
        <trans-unit id="1b5a5787fcfada038cc95ac0f53477decb94de59" translate="yes" xml:space="preserve">
          <source>It converts -just- the required dictionary entries to &lt;code&gt;tuples&lt;/code&gt;, so it does NOT converts the whole dictionary to &lt;code&gt;tuples&lt;/code&gt;, so there are no performance concerns related to that.</source>
          <target state="translated">必要なディクショナリエントリだけを &lt;code&gt;tuples&lt;/code&gt; に変換するため、ディクショナリ全体を &lt;code&gt;tuples&lt;/code&gt; 変換することはないため、パフォーマンスに関する問題は発生しません。</target>
        </trans-unit>
        <trans-unit id="a1cb1752fca818aa6ba5c1e1d61b985e10cddfec" translate="yes" xml:space="preserve">
          <source>Iterate over any &lt;code&gt;Dictionary&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; in the following manner</source>
          <target state="translated">次の方法で、 &lt;code&gt;Dictionary&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; を反復処理します</target>
        </trans-unit>
        <trans-unit id="cb2d3fba103eca2485423e3fb51dc4e236fbd0ce" translate="yes" xml:space="preserve">
          <source>Iterating over a dictionary can be rather slow when compared with iterating over something like an array. In my tests an iteration over an array took 0.015003 seconds whereas an iteration over a dictionary (with the same number of elements) took 0.0365073 seconds that's 2.4 times as long! Although I have seen much bigger differences. For comparison a List was somewhere in between at 0.00215043 seconds.</source>
          <target state="translated">配列のようなものの反復処理と比較すると、辞書の反復処理はかなり遅くなります。私のテストでは、配列の反復処理に0.015003秒かかったのに対し、辞書(同じ要素数の)の反復処理に0.0365073秒かかったので、2.4倍の時間がかかりました! 私はもっと大きな違いを見てきましたが。比較のために、リストは0.00215043秒の間のどこかにありました。</target>
        </trans-unit>
        <trans-unit id="a30af6777f73b0b81eafe94ebef2f42d18285976" translate="yes" xml:space="preserve">
          <source>Just wanted to add my 2 cent, as the most answers relate to foreach-loop.
Please, take a look at the following code:</source>
          <target state="translated">ほとんどの回答がforeach-loopに関連しているので、私の2セントを追加したかっただけです。次のコードを見てみてください。</target>
        </trans-unit>
        <trans-unit id="0a312e402e1aefeb15436d8d429a387734134010" translate="yes" xml:space="preserve">
          <source>LINQ provides a concise syntax that allows to specify order (and many other things), e.g.:</source>
          <target state="translated">LINQは簡潔な構文を提供しており、例えば順序を指定することができます(他にも多くのことができます)。</target>
        </trans-unit>
        <trans-unit id="56a3d1d4a9f3c543ec2f04e96ad6e723eacbd1c6" translate="yes" xml:space="preserve">
          <source>Most straightforward way</source>
          <target state="translated">最も簡単な方法</target>
        </trans-unit>
        <trans-unit id="6939829ecad0770c1f2854c706760a6aad96113e" translate="yes" xml:space="preserve">
          <source>Notice that when defining a dictionary, we need to provide a generic 
   definition with two types - the type of the key and the type of the value. In this case, the key is a string whereas the value is an integer.</source>
          <target state="translated">辞書を定義する際には、キーの型と値の型という2つの型を持つ一般的な定義を提供する必要があることに注意してください。この場合、キーは文字列で、値は整数です。</target>
        </trans-unit>
        <trans-unit id="c2687d7fa52a2592c8abbc6f420259028139b52c" translate="yes" xml:space="preserve">
          <source>On the other hand, there are many ways to iterate over a Dictionary in C# and there's no best way. It depends on the need and often on taste, too.</source>
          <target state="translated">一方、C#で辞書を反復処理する方法はたくさんあり、最適な方法はありません。必要性にもよりますし、好みにもよることが多いです。</target>
        </trans-unit>
        <trans-unit id="12901374eb2c7fd59c9860f5abf06b72a4bb681c" translate="yes" xml:space="preserve">
          <source>One the one hand, there are many colors and there's no best color.  It depends on the need and often on taste, too.</source>
          <target state="translated">一方では、色がたくさんあって、ベストな色はありません。必要性にもよるし、好みにもよることが多い。</target>
        </trans-unit>
        <trans-unit id="9c2bcf06294a90e8e083763566b9deae7c61faa9" translate="yes" xml:space="preserve">
          <source>Or this one, if you prefer</source>
          <target state="translated">または、これがお好みなら</target>
        </trans-unit>
        <trans-unit id="61e638ebf858c1f563ec3104471c16d5c2b33444" translate="yes" xml:space="preserve">
          <source>Or, if you only need to iterate over the collection of keys, use</source>
          <target state="translated">あるいは、キーのコレクションを反復処理する必要があるだけなら、次のようにします。</target>
        </trans-unit>
        <trans-unit id="cd47115f2beda73a07079a12612fb07fbf287c47" translate="yes" xml:space="preserve">
          <source>Reported by this post which states it is the fastest method:
&lt;a href=&quot;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&quot;&gt;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&lt;/a&gt;</source>
          <target state="translated">それが最速の方法であると述べているこの投稿によって報告されました： &lt;a href=&quot;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&quot;&gt;http&lt;/a&gt; : //alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html</target>
        </trans-unit>
        <trans-unit id="da423e06f316e7ef8aa1cb69bd467a47205d94ad" translate="yes" xml:space="preserve">
          <source>Simplest form to iterate a dictionary:</source>
          <target state="translated">辞書を反復処理するための最も単純な形式。</target>
        </trans-unit>
        <trans-unit id="3266a6cd5309e4591b0f00524a9a57f4b4865ecd" translate="yes" xml:space="preserve">
          <source>Sometimes if you only needs the values to be enumerated, use the dictionary's value collection:</source>
          <target state="translated">値の列挙だけが必要な場合は、辞書の値コレクションを使用することもあります。</target>
        </trans-unit>
        <trans-unit id="d495734261a4228a062272f11bfaaa266e315883" translate="yes" xml:space="preserve">
          <source>The extension method transforms the &lt;code&gt;KeyValuePair&lt;/code&gt; of your &lt;code&gt;IDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; into a strongly typed &lt;code&gt;tuple&lt;/code&gt;, allowing you to use this new comfortable syntax.</source>
          <target state="translated">拡張メソッドは、 &lt;code&gt;IDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; の &lt;code&gt;KeyValuePair&lt;/code&gt; を強く型付けされた &lt;code&gt;tuple&lt;/code&gt; に変換し、この新しい快適な構文を使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="04b1fb11f6c618e8f6576b6be78983440400acfe" translate="yes" xml:space="preserve">
          <source>The standard way to iterate over a Dictionary, according to official documentation on MSDN is:</source>
          <target state="translated">MSDNの公式ドキュメントによると、辞書を反復処理する標準的な方法は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5c5db52c67a7720b7c781aa83c84b6a7d4078cff" translate="yes" xml:space="preserve">
          <source>Then you can call</source>
          <target state="translated">それから、あなたは</target>
        </trans-unit>
        <trans-unit id="f35263d7d55bb1cc907239b11f8f7a8702c56214" translate="yes" xml:space="preserve">
          <source>There are also two ways of adding a single value to the dictionary, either using the brackets operator or using the Add method.</source>
          <target state="translated">また、辞書に1つの値を追加するには、括弧演算子を使用する方法とAddメソッドを使用する方法の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="af00928700168d8333d32e85c9816e62844f0cc2" translate="yes" xml:space="preserve">
          <source>There are many more real-world use case you can do from these examples.
If you don't need a specific order, just stick to the &quot;most straightforward way&quot; (see above)!</source>
          <target state="translated">これらの例からできる実際のユースケースは他にもたくさんあります。特定の順序を必要としない場合は、「最もわかりやすい方法」(上記参照)に固執してください!</target>
        </trans-unit>
        <trans-unit id="cbe911091640f53097aaa45e1b69c726cffdc605" translate="yes" xml:space="preserve">
          <source>There are plenty of options. My personal favorite is by KeyValuePair</source>
          <target state="translated">オプションはたくさんあります。私の個人的なお気に入りは KeyValuePair による</target>
        </trans-unit>
        <trans-unit id="58dc2fee9700cb4d481b705fc61ae688a1068e85" translate="yes" xml:space="preserve">
          <source>There is a only minor cost calling the extension method for creating a &lt;code&gt;tuple&lt;/code&gt; in comparison with using the &lt;code&gt;KeyValuePair&lt;/code&gt; directly, which should NOT be an issue if you are assigning the &lt;code&gt;KeyValuePair&lt;/code&gt;'s properties &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; to new loop variables anyway.</source>
          <target state="translated">&lt;code&gt;KeyValuePair&lt;/code&gt; を直接使用する場合と比較して、 &lt;code&gt;tuple&lt;/code&gt; を作成するための拡張メソッドの呼び出しにはわずかなコストしかかかりません。とにかく、 &lt;code&gt;KeyValuePair&lt;/code&gt; のプロパティ &lt;code&gt;Key&lt;/code&gt; および &lt;code&gt;Value&lt;/code&gt; を新しいループ変数に割り当てる場合は問題になりません。</target>
        </trans-unit>
        <trans-unit id="be499d7dd68e14f2114cfde873ca49059efc393f" translate="yes" xml:space="preserve">
          <source>This one loads the keys and iterates over them instead (I did also try pulling the keys into a string[] but the difference was negligible.</source>
          <target state="translated">これはキーをロードして、代わりにそれらを反復処理します(キーを文字列[]に引っ張ってみましたが、その違いは無視できるほどでした。</target>
        </trans-unit>
        <trans-unit id="00690079c2a4e1bf43ab84d2f19bcb896eb4878a" translate="yes" xml:space="preserve">
          <source>This was the only one I was able to get functioning correctly in a class that inherited from the DictionaryBase.</source>
          <target state="translated">DictionaryBaseを継承したクラスで正常に機能させることができたのはこれだけでした。</target>
        </trans-unit>
        <trans-unit id="931954f05d1cefa1f2835133f3657de4a6c2d35b" translate="yes" xml:space="preserve">
          <source>This way I can write code like this:</source>
          <target state="translated">このようにコードを書くことができます。</target>
        </trans-unit>
        <trans-unit id="2a656f1ac324e97541d2983757ff92a90334a431" translate="yes" xml:space="preserve">
          <source>To check whether a dictionary has a certain key in it, we can use the ContainsKey method:</source>
          <target state="translated">辞書に特定のキーが含まれているかどうかを確認するには、ContainsKeyメソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="28addee6cedf87e3145cfbfd1410ddb4937da311" translate="yes" xml:space="preserve">
          <source>To make this code work on lower C# versions, add &lt;code&gt;System.ValueTuple NuGet package&lt;/code&gt; and write somewhere</source>
          <target state="translated">このコードを以前のC＃バージョンで動作させるには、 &lt;code&gt;System.ValueTuple NuGet package&lt;/code&gt; を追加してどこかに書き込みます</target>
        </trans-unit>
        <trans-unit id="6e440ac8f22b4b54d8858e18f05ed7e2f1f9fb3c" translate="yes" xml:space="preserve">
          <source>To remove an item from a dictionary, we can use the Remove method. Removing an item from a dictionary by its key is fast and very efficient. When removing an item from a List using its value, the process is slow and inefficient, unlike the dictionary Remove function.</source>
          <target state="translated">辞書から項目を削除するには、Removeメソッドを使用します。キーを使って辞書から項目を削除するのは、高速で非常に効率的です。リストから値を使って項目を削除する場合は、辞書のRemove関数とは異なり、処理が遅く非効率的です。</target>
        </trans-unit>
        <trans-unit id="561e6208f8daae64c5bf6a710fd669c6e1d73db0" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;C# 7&lt;/strong&gt;, add this &lt;strong&gt;extension method&lt;/strong&gt; to any project of your solution:</source>
          <target state="translated">&lt;strong&gt;C＃7&lt;/strong&gt;を使用して、この&lt;strong&gt;拡張メソッド&lt;/strong&gt;をソリューションのプロジェクトに追加します。</target>
        </trans-unit>
        <trans-unit id="25b2893d19aeea1311a5246ea8feadc8bddd54c7" translate="yes" xml:space="preserve">
          <source>What is the best way to iterate over a dictionary</source>
          <target state="translated">辞書を反復処理する最良の方法は何ですか?</target>
        </trans-unit>
        <trans-unit id="35b69990e0e3a3bead58a6d1d0b26f1f2e48bfb1" translate="yes" xml:space="preserve">
          <source>When you just want to &quot;read&quot; Keys and Values, you might also use IEnumerable.Select().</source>
          <target state="translated">キーと値を「読む」だけの場合は、IEnumerable.Select()を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="d5e5c20123cee839590aadc6944acfc8b6ba57b0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.NET Framework 4.7&lt;/code&gt; one can use &lt;em&gt;decomposition&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;.NET Framework 4.7&lt;/code&gt; では、 &lt;em&gt;分解&lt;/em&gt;を使用できます</target>
        </trans-unit>
        <trans-unit id="adddc5ba674bb912706e0bc6e404e69342e046de" translate="yes" xml:space="preserve">
          <source>With this example the normal foreach test took 0.0310062 and the keys version took 0.2205441. Loading all the keys and iterating over all the lookups is clearly a LOT slower!</source>
          <target state="translated">この例では、通常のforeachテストでは0.0310062、キーバージョンでは0.2205441となりました。すべてのキーをロードして、すべてのルックアップを繰り返し実行すると、明らかに遅くなります。</target>
        </trans-unit>
        <trans-unit id="74a7440666a25dae99e6a51679822864419959f7" translate="yes" xml:space="preserve">
          <source>You can also try this on big dictionaries for multithreaded processing.</source>
          <target state="translated">マルチスレッド処理のための大きな辞書でも試してみてください。</target>
        </trans-unit>
        <trans-unit id="89dbe6661417ad0ac5d04a14f040438e17c79f9e" translate="yes" xml:space="preserve">
          <source>You can also use the Keys and Values Collections</source>
          <target state="translated">キーと値のコレクションを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="8bde3ca31d73fcbcb92dbfcc529338d5f8eebf16" translate="yes" xml:space="preserve">
          <source>You suggested below to iterate</source>
          <target state="translated">あなたは以下のような提案をしました。</target>
        </trans-unit>
        <trans-unit id="a79b7064f585723bd2a6d43d8ede72db3bc54422" translate="yes" xml:space="preserve">
          <source>but sorted by the keys</source>
          <target state="translated">が、キーでソートされています。</target>
        </trans-unit>
        <trans-unit id="3107d23c2c12366f1af56b42170c59f9dff15fdc" translate="yes" xml:space="preserve">
          <source>in addition to the highest ranking posts where there is a discussion between using</source>
          <target state="translated">を使うかどうかの議論が行われているランキング上位の投稿に加えて</target>
        </trans-unit>
        <trans-unit id="52622b7a5d5b59d00e8b4165042de57215a2bb93" translate="yes" xml:space="preserve">
          <source>iterate directly on the value (allows to call it &lt;code&gt;item&lt;/code&gt;, more readable than &lt;code&gt;kvp.Value&lt;/code&gt;)</source>
          <target state="translated">値を直接反復します（ &lt;code&gt;kvp.Value&lt;/code&gt; よりも読みやすい &lt;code&gt;item&lt;/code&gt; と呼ぶことができます）</target>
        </trans-unit>
        <trans-unit id="becfe9c4e9a3d53784bb97c520dc78c924051aeb" translate="yes" xml:space="preserve">
          <source>most complete is the following because you can see the dictionary type from the initialization, kvp is KeyValuePair</source>
          <target state="translated">最も完全なのは、初期化から辞書の型を見ることができるので、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
