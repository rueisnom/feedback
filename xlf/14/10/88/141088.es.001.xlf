<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/141088">
    <body>
      <group id="141088">
        <trans-unit id="eb62bf8162ffc815e7e0a450233ae73344cf26b4" translate="yes" xml:space="preserve">
          <source>(Take note that the &lt;code&gt;var&lt;/code&gt; keyword is an optional C# 3.0 and above feature, you could also use the exact type of your keys/values here)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Tenga en cuenta que la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;palabra clave &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es una caracter&amp;iacute;stica opcional C # 3.0 y superior, tambi&amp;eacute;n puede usar el tipo exacto de sus claves / valores aqu&amp;iacute;)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="026743e8cb8670bfc15d3538a9ad2479fe83c402" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt790184.aspx&quot;&gt;&lt;em&gt;C# 7.0&lt;/em&gt; introduced &lt;strong&gt;Deconstructors&lt;/strong&gt;&lt;/a&gt; and if you are using &lt;em&gt;.NET Core 2.0+&lt;/em&gt; Application, the struct &lt;code&gt;KeyValuePair&amp;lt;&amp;gt;&lt;/code&gt; already include a &lt;code&gt;Deconstruct()&lt;/code&gt; for you. So you can do:</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt790184.aspx&quot;&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C # 7.0&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; introdujo &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Deconstructors&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y si est&amp;aacute; utilizando la aplicaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .NET Core 2.0+&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , la estructura&lt;/font&gt;&lt;/font&gt; &lt;code&gt;KeyValuePair&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ya incluye un&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Deconstruct()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para usted. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces puedes hacer:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="330db4cc5e1b70f828267dc0892a7a0945a2ddbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; is fastest and if you only iterate over &lt;code&gt;___.Values&lt;/code&gt;, it is also faster</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es m&amp;aacute;s r&amp;aacute;pido y si solo itera sobre &lt;/font&gt;&lt;/font&gt; &lt;code&gt;___.Values&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , tambi&amp;eacute;n es m&amp;aacute;s r&amp;aacute;pido&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79c0b346684aceccc675b3227ae87626592f99a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dictionary&amp;lt; TKey,&amp;ensp;TValue &amp;gt;&lt;/strong&gt; It is a generic collection class in c# and it stores the data in the key value format.Key must be unique and it can not be null whereas value can be duplicate and null.As each item in the dictionary is treated as KeyValuePair&amp;lt; TKey,&amp;ensp;TValue &amp;gt; structure representing a key and its value. and hence we should take the element type  KeyValuePair&amp;lt; TKey,&amp;ensp;TValue&amp;gt; during the iteration of element.&lt;strong&gt;Below is the example.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dictionary &amp;lt;TKey, TValue&amp;gt;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Es una clase de colecci&amp;oacute;n gen&amp;eacute;rica en c # y almacena los datos en el formato de valor de clave. La clave debe ser &amp;uacute;nica y no puede ser nula, mientras que el valor puede ser duplicado y nulo. Como cada elemento del diccionario es tratada como KeyValuePair &amp;lt;TKey, TValue&amp;gt; estructura que representa una clave y su valor. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;y, por lo tanto, deber&amp;iacute;amos tomar el tipo de elemento KeyValuePair &amp;lt;TKey, TValue&amp;gt; durante la iteraci&amp;oacute;n del elemento. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A continuaci&amp;oacute;n se muestra el ejemplo.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91a956d0b808239ab6cec3a04a363af766520cb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edited To Add:&lt;/strong&gt;
Reading some of the other answers made me question what would happen if I used Dictionary instead of Dictionary. In this example the array took 0.0120024 seconds, the list 0.0185037 seconds and the dictionary 0.0465093 seconds. It's reasonable to expect that the data type makes a difference on how much slower the dictionary is.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Editado para agregar:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Leer algunas de las otras respuestas me hizo preguntarme qu&amp;eacute; pasar&amp;iacute;a si usara Dictionary en lugar de Dictionary. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En este ejemplo, la matriz tard&amp;oacute; 0.0120024 segundos, la lista 0.0185037 segundos y el diccionario 0.0465093 segundos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es razonable esperar que el tipo de datos marque la diferencia en la lentitud del diccionario.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7248e135957a14fe596c2f11af12e99c6868b5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What are my Conclusions&lt;/strong&gt;?</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Cu&amp;aacute;les son mis conclusiones&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9100164962c2669d80ab417d22f39cd1aa29af8e" translate="yes" xml:space="preserve">
          <source>Again you might only need the value. LINQ also provides a concise solution to:</source>
          <target state="translated">De nuevo,puede que sólo necesites el valor.LINQ también proporciona una solución concisa para:</target>
        </trans-unit>
        <trans-unit id="4f5370435b9afedf2acebdb4888721858ecbf6f9" translate="yes" xml:space="preserve">
          <source>Also, please note that you wont be able to assign values to the 'Value' property inside a foreach-loop. On the other hand, you will be able to manipulate the 'Key' as well, possibly getting you into trouble at runtime.</source>
          <target state="translated">Además,ten en cuenta que no podrás asignar valores a la propiedad &quot;Valor&quot; dentro de un bucle de proa.Por otro lado,podrás manipular la 'Llave' también,posiblemente metiéndote en problemas en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="76f5e18ba91fd6b70cb9adaefc5933941f851c20" translate="yes" xml:space="preserve">
          <source>Altought this adds a additional call of '.ToList()', there might be a slight performance-improvement (as pointed out here &lt;a href=&quot;https://stackoverflow.com/questions/225937/foreach-vs-somelist-foreach&quot;&gt;foreach vs someList.Foreach(){}&lt;/a&gt;), 
espacially when working with large Dictionaries and running in parallel is no option / won't have an effect at all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aunque esto agrega una llamada adicional de '.ToList ()', podr&amp;iacute;a haber una ligera mejora en el rendimiento (como se se&amp;ntilde;ala aqu&amp;iacute; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/225937/foreach-vs-somelist-foreach&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;foreach vs someList.Foreach () {}&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), espacialmente cuando se trabaja con grandes diccionarios y se ejecuta en paralelo no La opci&amp;oacute;n / no tendr&amp;aacute; ning&amp;uacute;n efecto.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="497a1c51557e3717356f3865a1603f5a2d32c9e2" translate="yes" xml:space="preserve">
          <source>And lastly, if you're only interested in the values:</source>
          <target state="translated">Y por último,si sólo te interesan los valores:</target>
        </trans-unit>
        <trans-unit id="7e38ec34611de5a1fac9cfab4885031bbb66ff1c" translate="yes" xml:space="preserve">
          <source>And use this simple syntax</source>
          <target state="translated">Y usa esta simple sintaxis</target>
        </trans-unit>
        <trans-unit id="92bfa14da3d176a49eb5942098fe4a5e0ee847b8" translate="yes" xml:space="preserve">
          <source>As of C# 7, you can deconstruct objects into variables. I believe this to be the best way to iterate over a dictionary.</source>
          <target state="translated">A partir de C#7,puedes deconstruir objetos en variables.Creo que esta es la mejor manera de iterar sobre un diccionario.</target>
        </trans-unit>
        <trans-unit id="9a69642663084ba779311a272e9dd900ea850114" translate="yes" xml:space="preserve">
          <source>Avoid iterating over a dictionary if you can, they are substantially slower than iterating over an array with the same data in it.</source>
          <target state="translated">Evita iterar sobre un diccionario si puedes,son sustancialmente más lentos que iterar sobre una matriz con los mismos datos en ella.</target>
        </trans-unit>
        <trans-unit id="8ca89494efd9d4b2e9284f9172599aafaa794b3f" translate="yes" xml:space="preserve">
          <source>Check this out: &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/&quot;&gt;MSDN Blog - New features in C# 7&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mira esto: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Blog de MSDN - Nuevas caracter&amp;iacute;sticas en C # 7&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf9de95bf6f48a9389484e0472b57cafffa12b52" translate="yes" xml:space="preserve">
          <source>Create an extension method on &lt;code&gt;KeyValuePair&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; that deconstructs it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cree un m&amp;eacute;todo de extensi&amp;oacute;n en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;KeyValuePair&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que lo deconstruya:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5d7f786e4ff8d0de7f07cea81a0650c70803c3b" translate="yes" xml:space="preserve">
          <source>Depends on whether you're after the keys or the values...</source>
          <target state="translated">Depende de si vas detrás de las llaves o de los valores...</target>
        </trans-unit>
        <trans-unit id="7f5693528b649c7c6467a276acd2ed66b5c6a0fc" translate="yes" xml:space="preserve">
          <source>Dictionaries are optimised for lookups, so with that in mind I've created two methods. One simply does a foreach, the other iterates the keys then looks up.</source>
          <target state="translated">Los diccionarios están optimizados para las búsquedas,así que con eso en mente he creado dos métodos.Uno simplemente hace un acercamiento,el otro itera las teclas y luego mira hacia arriba.</target>
        </trans-unit>
        <trans-unit id="eaebe6020d43cd89f479e33d92042d4d05f09fc6" translate="yes" xml:space="preserve">
          <source>Dictionaries are special lists, whereas every value in the list has a key 
   which is also a variable. A good example of a dictionary is a phone book.</source>
          <target state="translated">Los diccionarios son listas especiales,mientras que cada valor de la lista tiene una clave que también es una variable.Un buen ejemplo de un diccionario es una guía telefónica.</target>
        </trans-unit>
        <trans-unit id="f66e268e3c61815f0a9aadfa11d0435990b81948" translate="yes" xml:space="preserve">
          <source>FYI, &lt;code&gt;foreach&lt;/code&gt; doesn't work if the value are of type object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para su informaci&amp;oacute;n, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;foreach&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no funciona si los valores son de tipo objeto.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8bb288146578f1426d12059b105c4248ba3bf95" translate="yes" xml:space="preserve">
          <source>For a final test I've performed my iteration ten times to see if there are any benefits to using the keys here (by this point I was just curious):</source>
          <target state="translated">Para una prueba final he realizado mi iteración diez veces para ver si hay algún beneficio en el uso de las teclas aquí (a estas alturas sólo tenía curiosidad):</target>
        </trans-unit>
        <trans-unit id="a95e7b2352f925500843c695ae42c8305794770c" translate="yes" xml:space="preserve">
          <source>From the MSDN &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xfhwa508.aspx&quot;&gt;&lt;code&gt;Dictionary(TKey, TValue)&lt;/code&gt;&lt;/a&gt; Class description:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;De la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;descripci&amp;oacute;n de la clase del &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xfhwa508.aspx&quot;&gt; &lt;code&gt;Dictionary(TKey, TValue)&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; MSDN &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(TKey, TValue)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0090de992f60b579dc8ed0ae062ff55e83f6c9d4" translate="yes" xml:space="preserve">
          <source>Generally, asking for &quot;the best way&quot; without a specific context is like asking 
&lt;em&gt;what is the best color&lt;/em&gt;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En general, preguntar por &quot;la mejor manera&quot; sin un contexto espec&amp;iacute;fico es como preguntar &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cu&amp;aacute;l es el mejor color&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7329ec82a6123d339bb60b69d3500067815fe184" translate="yes" xml:space="preserve">
          <source>Generally, beginners are surprised about order of enumeration of a Dictionary.</source>
          <target state="translated">Generalmente,los principiantes se sorprenden por el orden de enumeración de un diccionario.</target>
        </trans-unit>
        <trans-unit id="5ef0e3e404407e991996a23ad4564c3121299baa" translate="yes" xml:space="preserve">
          <source>Here it is:</source>
          <target state="translated">Aquí está:</target>
        </trans-unit>
        <trans-unit id="d9350c4847221cf90bedbefd5403e04396a9af43" translate="yes" xml:space="preserve">
          <source>Here the normal foreach run took 0.2820564 seconds (around ten times longer than a single iteration took - as you'd expect). The iteration over the keys took 2.2249449 seconds.</source>
          <target state="translated">Aquí el recorrido normal de la frente tomó 0.2820564 segundos (alrededor de diez veces más de lo que tomó una sola iteración,como es de esperarse).La iteración sobre las teclas tomó 2.2249449 segundos.</target>
        </trans-unit>
        <trans-unit id="2c477bee0d68beb1a51f1cd6faae233ddaf703e8" translate="yes" xml:space="preserve">
          <source>Here's the RunTest method if that helps you visualise what's going on.</source>
          <target state="translated">Aquí está el método RunTest si eso te ayuda a visualizar lo que está pasando.</target>
        </trans-unit>
        <trans-unit id="d8bf4f0dde39aae9200beafeade042e6eef6528d" translate="yes" xml:space="preserve">
          <source>However, that is like comparing apples and oranges. My point is that iterating over dictionaries is slow.</source>
          <target state="translated">Sin embargo,eso es como comparar manzanas y naranjas.Mi punto es que iterar sobre los diccionarios es lento.</target>
        </trans-unit>
        <trans-unit id="a8d167b3a491226f6e12a59d62715ca577941f73" translate="yes" xml:space="preserve">
          <source>I appreciate this question has already had a lot of responses but I wanted to throw in a little research.</source>
          <target state="translated">Aprecio que esta pregunta ya haya tenido muchas respuestas,pero quería investigar un poco.</target>
        </trans-unit>
        <trans-unit id="087718cc256ab6d2e3aa86090f4dff4746dd35b4" translate="yes" xml:space="preserve">
          <source>I found this method in the documentation for the DictionaryBase class on MSDN:</source>
          <target state="translated">Encontré este método en la documentación de la clase DictionaryBase en MSDN:</target>
        </trans-unit>
        <trans-unit id="a0d3a4cfc425a3e0a8768e7618e2f448e7d4a006" translate="yes" xml:space="preserve">
          <source>I know this is a very old question, but I created some extension methods that might be useful:</source>
          <target state="translated">Sé que es una pregunta muy antigua,pero he creado algunos métodos de extensión que podrían ser útiles:</target>
        </trans-unit>
        <trans-unit id="022f337ac135568be545886f9660c8aa25366900" translate="yes" xml:space="preserve">
          <source>I will take the advantage of .NET 4.0+ and provide an updated answer to the originally accepted one:</source>
          <target state="translated">Aprovecharé el .NET 4.0+y daré una respuesta actualizada a la aceptada originalmente:</target>
        </trans-unit>
        <trans-unit id="665b68985ca020cff37a421433dacf69dab38b90" translate="yes" xml:space="preserve">
          <source>I would say foreach is the standard way, though it obviously depends on what you're looking for</source>
          <target state="translated">Diría que el foreach es la forma estándar,aunque obviamente depende de lo que busques...</target>
        </trans-unit>
        <trans-unit id="c48c72f51d0a484a1a84eb7af0928b9f44c8b892" translate="yes" xml:space="preserve">
          <source>I wrote an extension to loop over a dictionary.</source>
          <target state="translated">Escribí una extensión para pasar por encima de un diccionario.</target>
        </trans-unit>
        <trans-unit id="2ac3f8179ccd0d030b87d697d99ca03d616f062e" translate="yes" xml:space="preserve">
          <source>I've seen a few different ways to iterate over a dictionary in C#.  Is there a standard way?</source>
          <target state="translated">He visto algunas formas diferentes de iterar sobre un diccionario en C#.¿Hay una forma estándar?</target>
        </trans-unit>
        <trans-unit id="c94e1b7e69d2dee4055b44d61ee7263b89c08118" translate="yes" xml:space="preserve">
          <source>If say, you want to iterate over the values collection by default, I believe you can implement IEnumerable&amp;lt;&amp;gt;, Where T is the type of the values object in the dictionary, and &quot;this&quot; is a Dictionary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si dice, desea iterar sobre la colecci&amp;oacute;n de valores de forma predeterminada, creo que puede implementar IEnumerable &amp;lt;&amp;gt;, donde T es el tipo de objeto de valores en el diccionario y &quot;esto&quot; es un Diccionario.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d589805b05fde41a07bac29079c4d138b37e600" translate="yes" xml:space="preserve">
          <source>If you are trying to use a generic Dictionary in C# like you would use an associative array in another language:</source>
          <target state="translated">Si está tratando de usar un diccionario genérico en C#como lo haría con una matriz asociativa en otro idioma:</target>
        </trans-unit>
        <trans-unit id="225f3d8b8aba090c50b8267620c2a20c558fb879" translate="yes" xml:space="preserve">
          <source>If you do choose to iterate over a dictionary don't try to be too clever, although slower you could do a lot worse than using the standard foreach method.</source>
          <target state="translated">Si decides iterar sobre un diccionario no trates de ser demasiado inteligente,aunque más despacio podrías hacerlo mucho peor que usando el método estándar de foreach.</target>
        </trans-unit>
        <trans-unit id="8c6850798a250101039b1c803e1f0aa0bfaf7a6f" translate="yes" xml:space="preserve">
          <source>If you need a specific sort order</source>
          <target state="translated">Si necesitas un orden de clasificación específico</target>
        </trans-unit>
        <trans-unit id="72122c33e7e269d2437cc77c6a6dabad50e50d09" translate="yes" xml:space="preserve">
          <source>If you need only the value (allows to call it &lt;code&gt;item&lt;/code&gt;, more readable than &lt;code&gt;kvp.Value&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si solo necesita el valor (permite llamarlo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;item&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , m&amp;aacute;s legible que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;kvp.Value&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4eb81bd43d3ac692872a05660c909d3b0ce288ab" translate="yes" xml:space="preserve">
          <source>In place of the traditional</source>
          <target state="translated">En lugar de la tradicional</target>
        </trans-unit>
        <trans-unit id="1f92c68b2be2630fe633591fd3b21b630d437ef5" translate="yes" xml:space="preserve">
          <source>In practice, this new syntax suits very well for most cases, except for low-level ultra-high performance scenarios, where you still have the option to simply not use it on that specific spot.</source>
          <target state="translated">En la práctica,esta nueva sintaxis se adapta muy bien a la mayoría de los casos,excepto en los escenarios de bajo nivel de rendimiento ultra-alto,en los que todavía se tiene la opción de simplemente no utilizarla en ese punto específico.</target>
        </trans-unit>
        <trans-unit id="c6c6c6ff7fee12c22582376bd7ab848207b260bf" translate="yes" xml:space="preserve">
          <source>In some cases you may need a counter that may be provided by for-loop implementation. For that, LINQ provides &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx&quot;&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/a&gt; which enables the following:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En algunos casos, puede necesitar un contador que puede proporcionar la implementaci&amp;oacute;n for-loop. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para eso, LINQ proporciona &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx&quot;&gt; &lt;code&gt;ElementAt&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que permite lo siguiente:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14cd2de22272c6bf242c99d4bdaf33377d866818" translate="yes" xml:space="preserve">
          <source>Is that what you're looking for?</source>
          <target state="translated">¿Es eso lo que estás buscando?</target>
        </trans-unit>
        <trans-unit id="1b5a5787fcfada038cc95ac0f53477decb94de59" translate="yes" xml:space="preserve">
          <source>It converts -just- the required dictionary entries to &lt;code&gt;tuples&lt;/code&gt;, so it does NOT converts the whole dictionary to &lt;code&gt;tuples&lt;/code&gt;, so there are no performance concerns related to that.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Convierte -solo- las entradas de diccionario requeridas en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;tuples&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por lo que NO convierte todo el diccionario en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;tuples&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por lo que no hay problemas de rendimiento relacionados con eso.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a1cb1752fca818aa6ba5c1e1d61b985e10cddfec" translate="yes" xml:space="preserve">
          <source>Iterate over any &lt;code&gt;Dictionary&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; in the following manner</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Iterar sobre cualquier &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Dictionary&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de la siguiente manera&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb2d3fba103eca2485423e3fb51dc4e236fbd0ce" translate="yes" xml:space="preserve">
          <source>Iterating over a dictionary can be rather slow when compared with iterating over something like an array. In my tests an iteration over an array took 0.015003 seconds whereas an iteration over a dictionary (with the same number of elements) took 0.0365073 seconds that's 2.4 times as long! Although I have seen much bigger differences. For comparison a List was somewhere in between at 0.00215043 seconds.</source>
          <target state="translated">Iterar sobre un diccionario puede ser bastante lento cuando se compara con iterar sobre algo como una matriz.En mis pruebas,una iteración sobre una matriz tomó 0,015003 segundos mientras que una iteración sobre un diccionario (con el mismo número de elementos)tomó 0,0365073 segundos,¡eso es 2,4 veces más largo! Aunque he visto diferencias mucho más grandes.Para comparar,una lista estaba en algún punto intermedio a 0,00215043 segundos.</target>
        </trans-unit>
        <trans-unit id="a30af6777f73b0b81eafe94ebef2f42d18285976" translate="yes" xml:space="preserve">
          <source>Just wanted to add my 2 cent, as the most answers relate to foreach-loop.
Please, take a look at the following code:</source>
          <target state="translated">Sólo quería añadir mis 2 centavos,ya que la mayoría de las respuestas se refieren al bucle de proa.Por favor,echa un vistazo al siguiente código:</target>
        </trans-unit>
        <trans-unit id="0a312e402e1aefeb15436d8d429a387734134010" translate="yes" xml:space="preserve">
          <source>LINQ provides a concise syntax that allows to specify order (and many other things), e.g.:</source>
          <target state="translated">El LINQ proporciona una sintaxis concisa que permite especificar el orden (y muchas otras cosas),por ejemplo:</target>
        </trans-unit>
        <trans-unit id="56a3d1d4a9f3c543ec2f04e96ad6e723eacbd1c6" translate="yes" xml:space="preserve">
          <source>Most straightforward way</source>
          <target state="translated">La manera más directa</target>
        </trans-unit>
        <trans-unit id="6939829ecad0770c1f2854c706760a6aad96113e" translate="yes" xml:space="preserve">
          <source>Notice that when defining a dictionary, we need to provide a generic 
   definition with two types - the type of the key and the type of the value. In this case, the key is a string whereas the value is an integer.</source>
          <target state="translated">Obsérvese que al definir un diccionario,debemos proporcionar una definición genérica con dos tipos:el tipo de la clave y el tipo del valor.En este caso,la clave es una cadena mientras que el valor es un entero.</target>
        </trans-unit>
        <trans-unit id="c2687d7fa52a2592c8abbc6f420259028139b52c" translate="yes" xml:space="preserve">
          <source>On the other hand, there are many ways to iterate over a Dictionary in C# and there's no best way. It depends on the need and often on taste, too.</source>
          <target state="translated">Por otro lado,hay muchas maneras de iterar sobre un diccionario en C#y no hay una mejor manera.Depende de la necesidad y a menudo del gusto,también.</target>
        </trans-unit>
        <trans-unit id="12901374eb2c7fd59c9860f5abf06b72a4bb681c" translate="yes" xml:space="preserve">
          <source>One the one hand, there are many colors and there's no best color.  It depends on the need and often on taste, too.</source>
          <target state="translated">Por un lado,hay muchos colores y no hay un mejor color.Depende de la necesidad y a menudo del gusto,también.</target>
        </trans-unit>
        <trans-unit id="9c2bcf06294a90e8e083763566b9deae7c61faa9" translate="yes" xml:space="preserve">
          <source>Or this one, if you prefer</source>
          <target state="translated">O éste,si lo prefieres.</target>
        </trans-unit>
        <trans-unit id="61e638ebf858c1f563ec3104471c16d5c2b33444" translate="yes" xml:space="preserve">
          <source>Or, if you only need to iterate over the collection of keys, use</source>
          <target state="translated">O,si sólo necesitas iterar sobre la colección de llaves,usa</target>
        </trans-unit>
        <trans-unit id="cd47115f2beda73a07079a12612fb07fbf287c47" translate="yes" xml:space="preserve">
          <source>Reported by this post which states it is the fastest method:
&lt;a href=&quot;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&quot;&gt;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Reportado por esta publicaci&amp;oacute;n que dice que es el m&amp;eacute;todo m&amp;aacute;s r&amp;aacute;pido: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da423e06f316e7ef8aa1cb69bd467a47205d94ad" translate="yes" xml:space="preserve">
          <source>Simplest form to iterate a dictionary:</source>
          <target state="translated">La forma más simple para iterar un diccionario:</target>
        </trans-unit>
        <trans-unit id="3266a6cd5309e4591b0f00524a9a57f4b4865ecd" translate="yes" xml:space="preserve">
          <source>Sometimes if you only needs the values to be enumerated, use the dictionary's value collection:</source>
          <target state="translated">A veces,si sólo necesita que se enumeren los valores,utilice la colección de valores del diccionario:</target>
        </trans-unit>
        <trans-unit id="d495734261a4228a062272f11bfaaa266e315883" translate="yes" xml:space="preserve">
          <source>The extension method transforms the &lt;code&gt;KeyValuePair&lt;/code&gt; of your &lt;code&gt;IDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; into a strongly typed &lt;code&gt;tuple&lt;/code&gt;, allowing you to use this new comfortable syntax.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El m&amp;eacute;todo de extensi&amp;oacute;n transforma el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;KeyValuePair&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de su &lt;/font&gt;&lt;/font&gt; &lt;code&gt;IDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en una &lt;/font&gt;&lt;/font&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; fuertemente &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tipada&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , lo que le permite usar esta nueva y c&amp;oacute;moda sintaxis.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04b1fb11f6c618e8f6576b6be78983440400acfe" translate="yes" xml:space="preserve">
          <source>The standard way to iterate over a Dictionary, according to official documentation on MSDN is:</source>
          <target state="translated">La forma estándar de iterar sobre un diccionario,según la documentación oficial en MSDN es:</target>
        </trans-unit>
        <trans-unit id="5c5db52c67a7720b7c781aa83c84b6a7d4078cff" translate="yes" xml:space="preserve">
          <source>Then you can call</source>
          <target state="translated">Entonces puedes llamar</target>
        </trans-unit>
        <trans-unit id="f35263d7d55bb1cc907239b11f8f7a8702c56214" translate="yes" xml:space="preserve">
          <source>There are also two ways of adding a single value to the dictionary, either using the brackets operator or using the Add method.</source>
          <target state="translated">También hay dos maneras de agregar un valor único al diccionario,ya sea mediante el operador de paréntesis o mediante el método Add.</target>
        </trans-unit>
        <trans-unit id="af00928700168d8333d32e85c9816e62844f0cc2" translate="yes" xml:space="preserve">
          <source>There are many more real-world use case you can do from these examples.
If you don't need a specific order, just stick to the &quot;most straightforward way&quot; (see above)!</source>
          <target state="translated">Hay muchos más casos de uso en el mundo real que puedes hacer a partir de estos ejemplos.Si no necesitas un orden específico,sólo apégate a la &quot;manera más directa&quot; (ver arriba)!</target>
        </trans-unit>
        <trans-unit id="cbe911091640f53097aaa45e1b69c726cffdc605" translate="yes" xml:space="preserve">
          <source>There are plenty of options. My personal favorite is by KeyValuePair</source>
          <target state="translated">Hay muchas opciones.Mi favorita es la de KeyValuePair</target>
        </trans-unit>
        <trans-unit id="58dc2fee9700cb4d481b705fc61ae688a1068e85" translate="yes" xml:space="preserve">
          <source>There is a only minor cost calling the extension method for creating a &lt;code&gt;tuple&lt;/code&gt; in comparison with using the &lt;code&gt;KeyValuePair&lt;/code&gt; directly, which should NOT be an issue if you are assigning the &lt;code&gt;KeyValuePair&lt;/code&gt;'s properties &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; to new loop variables anyway.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay un costo menor que llama al m&amp;eacute;todo de extensi&amp;oacute;n para crear una &lt;/font&gt;&lt;/font&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en comparaci&amp;oacute;n con el uso de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;KeyValuePair&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; directamente, lo cual NO deber&amp;iacute;a ser un problema si de todos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;KeyValuePair&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; est&amp;aacute; asignando las &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;propiedades &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;KeyValuePair &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Key&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Value&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a nuevas variables de bucle.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be499d7dd68e14f2114cfde873ca49059efc393f" translate="yes" xml:space="preserve">
          <source>This one loads the keys and iterates over them instead (I did also try pulling the keys into a string[] but the difference was negligible.</source>
          <target state="translated">Este carga las teclas e itera sobre ellas en su lugar (también intenté meter las teclas en una cuerda[]pero la diferencia fue insignificante.</target>
        </trans-unit>
        <trans-unit id="00690079c2a4e1bf43ab84d2f19bcb896eb4878a" translate="yes" xml:space="preserve">
          <source>This was the only one I was able to get functioning correctly in a class that inherited from the DictionaryBase.</source>
          <target state="translated">Esta fue la única que pude hacer funcionar correctamente en una clase que heredé del DictionaryBase.</target>
        </trans-unit>
        <trans-unit id="931954f05d1cefa1f2835133f3657de4a6c2d35b" translate="yes" xml:space="preserve">
          <source>This way I can write code like this:</source>
          <target state="translated">De esta manera puedo escribir un código como este:</target>
        </trans-unit>
        <trans-unit id="2a656f1ac324e97541d2983757ff92a90334a431" translate="yes" xml:space="preserve">
          <source>To check whether a dictionary has a certain key in it, we can use the ContainsKey method:</source>
          <target state="translated">Para comprobar si un diccionario tiene una determinada clave,podemos utilizar el método ContainsKey:</target>
        </trans-unit>
        <trans-unit id="28addee6cedf87e3145cfbfd1410ddb4937da311" translate="yes" xml:space="preserve">
          <source>To make this code work on lower C# versions, add &lt;code&gt;System.ValueTuple NuGet package&lt;/code&gt; and write somewhere</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para que este c&amp;oacute;digo funcione en versiones inferiores de C #, agregue el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.ValueTuple NuGet package&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y escriba en alguna parte&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e440ac8f22b4b54d8858e18f05ed7e2f1f9fb3c" translate="yes" xml:space="preserve">
          <source>To remove an item from a dictionary, we can use the Remove method. Removing an item from a dictionary by its key is fast and very efficient. When removing an item from a List using its value, the process is slow and inefficient, unlike the dictionary Remove function.</source>
          <target state="translated">Para eliminar un elemento de un diccionario,podemos usar el método de Eliminar.Quitar un elemento de un diccionario por su clave es rápido y muy eficiente.Cuando se elimina un elemento de una Lista utilizando su valor,el proceso es lento e ineficiente,a diferencia de la función de Eliminar del diccionario.</target>
        </trans-unit>
        <trans-unit id="561e6208f8daae64c5bf6a710fd669c6e1d73db0" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;C# 7&lt;/strong&gt;, add this &lt;strong&gt;extension method&lt;/strong&gt; to any project of your solution:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Con &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C # 7&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , agregue este &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo de extensi&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a cualquier proyecto de su soluci&amp;oacute;n:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25b2893d19aeea1311a5246ea8feadc8bddd54c7" translate="yes" xml:space="preserve">
          <source>What is the best way to iterate over a dictionary</source>
          <target state="translated">¿Cuál es la mejor manera de iterar sobre un diccionario</target>
        </trans-unit>
        <trans-unit id="35b69990e0e3a3bead58a6d1d0b26f1f2e48bfb1" translate="yes" xml:space="preserve">
          <source>When you just want to &quot;read&quot; Keys and Values, you might also use IEnumerable.Select().</source>
          <target state="translated">Cuando sólo quieres &quot;leer&quot; Claves y Valores,también puedes usar IEnumerable.Select().</target>
        </trans-unit>
        <trans-unit id="d5e5c20123cee839590aadc6944acfc8b6ba57b0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.NET Framework 4.7&lt;/code&gt; one can use &lt;em&gt;decomposition&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.NET Framework 4.7&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se puede usar la &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;descomposici&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adddc5ba674bb912706e0bc6e404e69342e046de" translate="yes" xml:space="preserve">
          <source>With this example the normal foreach test took 0.0310062 and the keys version took 0.2205441. Loading all the keys and iterating over all the lookups is clearly a LOT slower!</source>
          <target state="translated">Con este ejemplo,la prueba normal de foreach tomó 0.0310062 y la versión de las llaves tomó 0.2205441.¡Cargar todas las teclas e iterar en todas las búsquedas es claramente MUCHO más lento!</target>
        </trans-unit>
        <trans-unit id="74a7440666a25dae99e6a51679822864419959f7" translate="yes" xml:space="preserve">
          <source>You can also try this on big dictionaries for multithreaded processing.</source>
          <target state="translated">También puedes probar esto en grandes diccionarios para el procesamiento multihilo.</target>
        </trans-unit>
        <trans-unit id="89dbe6661417ad0ac5d04a14f040438e17c79f9e" translate="yes" xml:space="preserve">
          <source>You can also use the Keys and Values Collections</source>
          <target state="translated">También puedes usar las Colecciones de Llaves y Valores</target>
        </trans-unit>
        <trans-unit id="8bde3ca31d73fcbcb92dbfcc529338d5f8eebf16" translate="yes" xml:space="preserve">
          <source>You suggested below to iterate</source>
          <target state="translated">Usted sugirió a continuación para iterar</target>
        </trans-unit>
        <trans-unit id="a79b7064f585723bd2a6d43d8ede72db3bc54422" translate="yes" xml:space="preserve">
          <source>but sorted by the keys</source>
          <target state="translated">pero ordenados por las teclas</target>
        </trans-unit>
        <trans-unit id="3107d23c2c12366f1af56b42170c59f9dff15fdc" translate="yes" xml:space="preserve">
          <source>in addition to the highest ranking posts where there is a discussion between using</source>
          <target state="translated">además de los puestos de mayor rango en los que se discute entre el uso de</target>
        </trans-unit>
        <trans-unit id="52622b7a5d5b59d00e8b4165042de57215a2bb93" translate="yes" xml:space="preserve">
          <source>iterate directly on the value (allows to call it &lt;code&gt;item&lt;/code&gt;, more readable than &lt;code&gt;kvp.Value&lt;/code&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;iterar directamente sobre el valor (permite llamarlo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;item&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , m&amp;aacute;s legible que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;kvp.Value&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="becfe9c4e9a3d53784bb97c520dc78c924051aeb" translate="yes" xml:space="preserve">
          <source>most complete is the following because you can see the dictionary type from the initialization, kvp is KeyValuePair</source>
          <target state="translated">más completo es el siguiente porque se puede ver el tipo de diccionario desde la inicialización,kvp es KeyValuePair</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
