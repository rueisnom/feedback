<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/141088">
    <body>
      <group id="141088">
        <trans-unit id="eb62bf8162ffc815e7e0a450233ae73344cf26b4" translate="yes" xml:space="preserve">
          <source>(Take note that the &lt;code&gt;var&lt;/code&gt; keyword is an optional C# 3.0 and above feature, you could also use the exact type of your keys/values here)</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 키워드는 선택적 C # 3.0 이상의 기능이므로 여기서 정확한 키 / 값 유형을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="026743e8cb8670bfc15d3538a9ad2479fe83c402" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt790184.aspx&quot;&gt;&lt;em&gt;C# 7.0&lt;/em&gt; introduced &lt;strong&gt;Deconstructors&lt;/strong&gt;&lt;/a&gt; and if you are using &lt;em&gt;.NET Core 2.0+&lt;/em&gt; Application, the struct &lt;code&gt;KeyValuePair&amp;lt;&amp;gt;&lt;/code&gt; already include a &lt;code&gt;Deconstruct()&lt;/code&gt; for you. So you can do:</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt790184.aspx&quot;&gt;&lt;em&gt;C # 7.0&lt;/em&gt; 은 &lt;strong&gt;Deconstructors를&lt;/strong&gt; 도입&lt;/a&gt; 했으며 &lt;em&gt;.NET Core 2.0+&lt;/em&gt; Application을 사용하는 경우 struct &lt;code&gt;KeyValuePair&amp;lt;&amp;gt;&lt;/code&gt; 에는 이미 &lt;code&gt;Deconstruct()&lt;/code&gt; 되어 있습니다. 그래서 당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="330db4cc5e1b70f828267dc0892a7a0945a2ddbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; is fastest and if you only iterate over &lt;code&gt;___.Values&lt;/code&gt;, it is also faster</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 가 가장 빠르며 &lt;code&gt;___.Values&lt;/code&gt; 이상 반복하면 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="79c0b346684aceccc675b3227ae87626592f99a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dictionary&amp;lt; TKey,&amp;ensp;TValue &amp;gt;&lt;/strong&gt; It is a generic collection class in c# and it stores the data in the key value format.Key must be unique and it can not be null whereas value can be duplicate and null.As each item in the dictionary is treated as KeyValuePair&amp;lt; TKey,&amp;ensp;TValue &amp;gt; structure representing a key and its value. and hence we should take the element type  KeyValuePair&amp;lt; TKey,&amp;ensp;TValue&amp;gt; during the iteration of element.&lt;strong&gt;Below is the example.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Dictionary &amp;lt;TKey, TValue&amp;gt;&lt;/strong&gt; c #의 제네릭 컬렉션 클래스이며 데이터를 키 값 형식으로 저장합니다 .Key는 고유해야하며 null 일 수없는 반면 값은 중복되고 null 일 수 있습니다. 키와 그 값을 나타내는 KeyValuePair &amp;lt;TKey, TValue&amp;gt; 구조로 처리됩니다. 따라서 요소를 반복하는 동안 KeyValuePair &amp;lt;TKey, TValue&amp;gt; 요소 유형을 가져와야합니다. &lt;strong&gt;아래는 예입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91a956d0b808239ab6cec3a04a363af766520cb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edited To Add:&lt;/strong&gt;
Reading some of the other answers made me question what would happen if I used Dictionary instead of Dictionary. In this example the array took 0.0120024 seconds, the list 0.0185037 seconds and the dictionary 0.0465093 seconds. It's reasonable to expect that the data type makes a difference on how much slower the dictionary is.</source>
          <target state="translated">&lt;strong&gt;추가 편집 :&lt;/strong&gt; 다른 답변 중 일부를 읽으면 Dictionary 대신 Dictionary를 사용하면 어떻게 될지 의문이 생겼습니다. 이 예제에서 배열은 0.0120024 초, 목록 0.0185037 초 및 사전 0.0465093 초가 걸렸습니다. 데이터 유형이 사전의 속도를 얼마나 느리게 만드는지 예상하는 것이 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7248e135957a14fe596c2f11af12e99c6868b5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What are my Conclusions&lt;/strong&gt;?</source>
          <target state="translated">&lt;strong&gt;내 결론은 무엇입니까&lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="9100164962c2669d80ab417d22f39cd1aa29af8e" translate="yes" xml:space="preserve">
          <source>Again you might only need the value. LINQ also provides a concise solution to:</source>
          <target state="translated">다시 한 번만 값이 필요할 수 있습니다. LINQ는 또한 다음과 같은 간결한 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4f5370435b9afedf2acebdb4888721858ecbf6f9" translate="yes" xml:space="preserve">
          <source>Also, please note that you wont be able to assign values to the 'Value' property inside a foreach-loop. On the other hand, you will be able to manipulate the 'Key' as well, possibly getting you into trouble at runtime.</source>
          <target state="translated">또한 foreach 루프 내에서 'Value'속성에 값을 할당 할 수 없습니다. 반면에 '키'도 조작 할 수있어 런타임시 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76f5e18ba91fd6b70cb9adaefc5933941f851c20" translate="yes" xml:space="preserve">
          <source>Altought this adds a additional call of '.ToList()', there might be a slight performance-improvement (as pointed out here &lt;a href=&quot;https://stackoverflow.com/questions/225937/foreach-vs-somelist-foreach&quot;&gt;foreach vs someList.Foreach(){}&lt;/a&gt;), 
espacially when working with large Dictionaries and running in parallel is no option / won't have an effect at all.</source>
          <target state="translated">이로 인해 '.ToList ()'의 추가 호출이 추가 &lt;a href=&quot;https://stackoverflow.com/questions/225937/foreach-vs-somelist-foreach&quot;&gt;되었으므로&lt;/a&gt; 큰 사전으로 작업하고 병렬로 실행할 때 간헐적 으로 약간의 성능 향상이있을 수 있습니다 (여기에서 foreach vs someList.Foreach () {} ). 옵션 / 전혀 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="497a1c51557e3717356f3865a1603f5a2d32c9e2" translate="yes" xml:space="preserve">
          <source>And lastly, if you're only interested in the values:</source>
          <target state="translated">마지막으로, 값에만 관심이 있다면 :</target>
        </trans-unit>
        <trans-unit id="7e38ec34611de5a1fac9cfab4885031bbb66ff1c" translate="yes" xml:space="preserve">
          <source>And use this simple syntax</source>
          <target state="translated">이 간단한 구문을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="92bfa14da3d176a49eb5942098fe4a5e0ee847b8" translate="yes" xml:space="preserve">
          <source>As of C# 7, you can deconstruct objects into variables. I believe this to be the best way to iterate over a dictionary.</source>
          <target state="translated">C # 7부터 객체를 변수로 분해 할 수 있습니다. 나는 이것이 사전을 반복하는 가장 좋은 방법이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="9a69642663084ba779311a272e9dd900ea850114" translate="yes" xml:space="preserve">
          <source>Avoid iterating over a dictionary if you can, they are substantially slower than iterating over an array with the same data in it.</source>
          <target state="translated">가능한 경우 사전을 반복하지 마십시오. 사전에 동일한 데이터가있는 배열을 반복하는 것보다 속도가 느립니다.</target>
        </trans-unit>
        <trans-unit id="8ca89494efd9d4b2e9284f9172599aafaa794b3f" translate="yes" xml:space="preserve">
          <source>Check this out: &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/&quot;&gt;MSDN Blog - New features in C# 7&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/&quot;&gt;MSDN 블로그-C # 7의 새로운 기능&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf9de95bf6f48a9389484e0472b57cafffa12b52" translate="yes" xml:space="preserve">
          <source>Create an extension method on &lt;code&gt;KeyValuePair&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; that deconstructs it:</source>
          <target state="translated">&lt;code&gt;KeyValuePair&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; 에서이를 확장하는 확장 메소드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a5d7f786e4ff8d0de7f07cea81a0650c70803c3b" translate="yes" xml:space="preserve">
          <source>Depends on whether you're after the keys or the values...</source>
          <target state="translated">키 또는 값 뒤에 있는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7f5693528b649c7c6467a276acd2ed66b5c6a0fc" translate="yes" xml:space="preserve">
          <source>Dictionaries are optimised for lookups, so with that in mind I've created two methods. One simply does a foreach, the other iterates the keys then looks up.</source>
          <target state="translated">사전은 조회에 최적화되어 있으므로이를 염두에두고 두 가지 방법을 만들었습니다. 하나는 단순히 foreach를 수행하고 다른 하나는 키를 반복 한 다음 조회합니다.</target>
        </trans-unit>
        <trans-unit id="eaebe6020d43cd89f479e33d92042d4d05f09fc6" translate="yes" xml:space="preserve">
          <source>Dictionaries are special lists, whereas every value in the list has a key 
   which is also a variable. A good example of a dictionary is a phone book.</source>
          <target state="translated">사전은 특수 목록이지만 목록의 모든 값에는 변수 인 키가 있습니다. 사전의 좋은 예는 전화 번호부입니다.</target>
        </trans-unit>
        <trans-unit id="f66e268e3c61815f0a9aadfa11d0435990b81948" translate="yes" xml:space="preserve">
          <source>FYI, &lt;code&gt;foreach&lt;/code&gt; doesn't work if the value are of type object.</source>
          <target state="translated">참고로, 값이 object 유형 인 경우 &lt;code&gt;foreach&lt;/code&gt; 가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8bb288146578f1426d12059b105c4248ba3bf95" translate="yes" xml:space="preserve">
          <source>For a final test I've performed my iteration ten times to see if there are any benefits to using the keys here (by this point I was just curious):</source>
          <target state="translated">최종 테스트를 위해 여기에서 키를 사용하면 이점이 있는지 확인하기 위해 반복을 10 번 수행했습니다 (이 시점에서 나는 단지 궁금했습니다).</target>
        </trans-unit>
        <trans-unit id="a95e7b2352f925500843c695ae42c8305794770c" translate="yes" xml:space="preserve">
          <source>From the MSDN &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xfhwa508.aspx&quot;&gt;&lt;code&gt;Dictionary(TKey, TValue)&lt;/code&gt;&lt;/a&gt; Class description:</source>
          <target state="translated">MSDN &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xfhwa508.aspx&quot;&gt; &lt;code&gt;Dictionary(TKey, TValue)&lt;/code&gt; &lt;/a&gt; 클래스 설명에서 :</target>
        </trans-unit>
        <trans-unit id="0090de992f60b579dc8ed0ae062ff55e83f6c9d4" translate="yes" xml:space="preserve">
          <source>Generally, asking for &quot;the best way&quot; without a specific context is like asking 
&lt;em&gt;what is the best color&lt;/em&gt;?</source>
          <target state="translated">일반적으로 특정 상황없이 &quot;최상의 방법&quot;을 요구 &lt;em&gt;하는 것은 최상의 색상이 무엇인지&lt;/em&gt; 묻는 &lt;em&gt;것과&lt;/em&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="7329ec82a6123d339bb60b69d3500067815fe184" translate="yes" xml:space="preserve">
          <source>Generally, beginners are surprised about order of enumeration of a Dictionary.</source>
          <target state="translated">일반적으로 초보자는 사전의 열거 순서에 놀랐습니다.</target>
        </trans-unit>
        <trans-unit id="5ef0e3e404407e991996a23ad4564c3121299baa" translate="yes" xml:space="preserve">
          <source>Here it is:</source>
          <target state="translated">여기있어:</target>
        </trans-unit>
        <trans-unit id="d9350c4847221cf90bedbefd5403e04396a9af43" translate="yes" xml:space="preserve">
          <source>Here the normal foreach run took 0.2820564 seconds (around ten times longer than a single iteration took - as you'd expect). The iteration over the keys took 2.2249449 seconds.</source>
          <target state="translated">여기에서 정상적인 foreach 실행은 0.2820564 초가 걸렸습니다 (예상대로 단일 반복보다 약 10 배 길었습니다). 키를 반복하는 데 2.2249449 초가 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="2c477bee0d68beb1a51f1cd6faae233ddaf703e8" translate="yes" xml:space="preserve">
          <source>Here's the RunTest method if that helps you visualise what's going on.</source>
          <target state="translated">진행 상황을 시각화하는 데 도움이되는 RunTest 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8bf4f0dde39aae9200beafeade042e6eef6528d" translate="yes" xml:space="preserve">
          <source>However, that is like comparing apples and oranges. My point is that iterating over dictionaries is slow.</source>
          <target state="translated">그러나 그것은 사과와 오렌지를 비교하는 것과 같습니다. 내 요점은 사전을 반복하는 것이 느리다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a8d167b3a491226f6e12a59d62715ca577941f73" translate="yes" xml:space="preserve">
          <source>I appreciate this question has already had a lot of responses but I wanted to throw in a little research.</source>
          <target state="translated">이 질문에 이미 많은 답변이 있었지만 약간의 연구를하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="087718cc256ab6d2e3aa86090f4dff4746dd35b4" translate="yes" xml:space="preserve">
          <source>I found this method in the documentation for the DictionaryBase class on MSDN:</source>
          <target state="translated">MSDN의 DictionaryBase 클래스 설명서에서이 방법을 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="a0d3a4cfc425a3e0a8768e7618e2f448e7d4a006" translate="yes" xml:space="preserve">
          <source>I know this is a very old question, but I created some extension methods that might be useful:</source>
          <target state="translated">나는 이것이 매우 오래된 질문이라는 것을 알고 있지만 유용한 확장 방법을 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="022f337ac135568be545886f9660c8aa25366900" translate="yes" xml:space="preserve">
          <source>I will take the advantage of .NET 4.0+ and provide an updated answer to the originally accepted one:</source>
          <target state="translated">.NET 4.0 이상을 활용하고 원래 승인 된 것에 대한 업데이트 된 답변을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="665b68985ca020cff37a421433dacf69dab38b90" translate="yes" xml:space="preserve">
          <source>I would say foreach is the standard way, though it obviously depends on what you're looking for</source>
          <target state="translated">나는 foreach가 표준 방법이라고 말하고 싶지만 분명히 당신이 찾고있는 것에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="c48c72f51d0a484a1a84eb7af0928b9f44c8b892" translate="yes" xml:space="preserve">
          <source>I wrote an extension to loop over a dictionary.</source>
          <target state="translated">사전을 반복하는 확장 프로그램을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="2ac3f8179ccd0d030b87d697d99ca03d616f062e" translate="yes" xml:space="preserve">
          <source>I've seen a few different ways to iterate over a dictionary in C#.  Is there a standard way?</source>
          <target state="translated">C #에서 사전을 반복하는 몇 가지 방법을 보았습니다. 표준적인 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="c94e1b7e69d2dee4055b44d61ee7263b89c08118" translate="yes" xml:space="preserve">
          <source>If say, you want to iterate over the values collection by default, I believe you can implement IEnumerable&amp;lt;&amp;gt;, Where T is the type of the values object in the dictionary, and &quot;this&quot; is a Dictionary.</source>
          <target state="translated">말하자면, 기본적으로 값 컬렉션을 반복하려면 IEnumerable &amp;lt;&amp;gt;을 구현할 수 있다고 생각합니다. 여기서 T는 사전의 값 개체 유형이고 &quot;this&quot;는 사전입니다.</target>
        </trans-unit>
        <trans-unit id="5d589805b05fde41a07bac29079c4d138b37e600" translate="yes" xml:space="preserve">
          <source>If you are trying to use a generic Dictionary in C# like you would use an associative array in another language:</source>
          <target state="translated">C #에서 일반 사전을 사용하려는 경우 다른 언어로 연관 배열을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="225f3d8b8aba090c50b8267620c2a20c558fb879" translate="yes" xml:space="preserve">
          <source>If you do choose to iterate over a dictionary don't try to be too clever, although slower you could do a lot worse than using the standard foreach method.</source>
          <target state="translated">사전을 반복하도록 선택하면 너무 영리하려고하지 마십시오. 느리기는하지만 표준 foreach 방법을 사용하는 것보다 훨씬 나쁠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c6850798a250101039b1c803e1f0aa0bfaf7a6f" translate="yes" xml:space="preserve">
          <source>If you need a specific sort order</source>
          <target state="translated">특정 정렬 순서가 필요한 경우</target>
        </trans-unit>
        <trans-unit id="72122c33e7e269d2437cc77c6a6dabad50e50d09" translate="yes" xml:space="preserve">
          <source>If you need only the value (allows to call it &lt;code&gt;item&lt;/code&gt;, more readable than &lt;code&gt;kvp.Value&lt;/code&gt;).</source>
          <target state="translated">값만 필요한 경우 ( &lt;code&gt;kvp.Value&lt;/code&gt; 보다 읽기 쉬운 &lt;code&gt;item&lt;/code&gt; 이라고 부를 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="4eb81bd43d3ac692872a05660c909d3b0ce288ab" translate="yes" xml:space="preserve">
          <source>In place of the traditional</source>
          <target state="translated">전통 대신</target>
        </trans-unit>
        <trans-unit id="1f92c68b2be2630fe633591fd3b21b630d437ef5" translate="yes" xml:space="preserve">
          <source>In practice, this new syntax suits very well for most cases, except for low-level ultra-high performance scenarios, where you still have the option to simply not use it on that specific spot.</source>
          <target state="translated">실제로,이 새로운 구문은 저수준 초 고성능 시나리오를 제외하고는 대부분의 경우에 매우 적합합니다.이 시나리오에서는 여전히 특정 지점에서 사용하지 않는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6c6c6ff7fee12c22582376bd7ab848207b260bf" translate="yes" xml:space="preserve">
          <source>In some cases you may need a counter that may be provided by for-loop implementation. For that, LINQ provides &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx&quot;&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/a&gt; which enables the following:</source>
          <target state="translated">경우에 따라 for 루프 구현에서 제공 할 수있는 카운터가 필요할 수 있습니다. 이를 위해 LINQ는 다음을 가능하게하는 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx&quot;&gt; &lt;code&gt;ElementAt&lt;/code&gt; &lt;/a&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="14cd2de22272c6bf242c99d4bdaf33377d866818" translate="yes" xml:space="preserve">
          <source>Is that what you're looking for?</source>
          <target state="translated">찾고 계십니까?</target>
        </trans-unit>
        <trans-unit id="1b5a5787fcfada038cc95ac0f53477decb94de59" translate="yes" xml:space="preserve">
          <source>It converts -just- the required dictionary entries to &lt;code&gt;tuples&lt;/code&gt;, so it does NOT converts the whole dictionary to &lt;code&gt;tuples&lt;/code&gt;, so there are no performance concerns related to that.</source>
          <target state="translated">필수 사전 항목을 &lt;code&gt;tuples&lt;/code&gt; 로 변환하므로 전체 사전을 &lt;code&gt;tuples&lt;/code&gt; 로 변환하지 않으므로 성능 관련 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a1cb1752fca818aa6ba5c1e1d61b985e10cddfec" translate="yes" xml:space="preserve">
          <source>Iterate over any &lt;code&gt;Dictionary&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; in the following manner</source>
          <target state="translated">다음과 같은 방식으로 모든 &lt;code&gt;Dictionary&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; 을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="cb2d3fba103eca2485423e3fb51dc4e236fbd0ce" translate="yes" xml:space="preserve">
          <source>Iterating over a dictionary can be rather slow when compared with iterating over something like an array. In my tests an iteration over an array took 0.015003 seconds whereas an iteration over a dictionary (with the same number of elements) took 0.0365073 seconds that's 2.4 times as long! Although I have seen much bigger differences. For comparison a List was somewhere in between at 0.00215043 seconds.</source>
          <target state="translated">배열과 같은 것을 반복하는 것과 비교할 때 사전을 반복하는 것이 다소 느릴 수 있습니다. 내 테스트에서 배열을 반복하는 데 0.015003 초가 걸리고 사전 (동일한 수의 요소가있는)을 반복하는 데 0.0365073 초가 걸리는 시간은 2.4 배입니다! 나는 훨씬 더 큰 차이를 보았지만. 비교를 위해 List는 0.00215043 초 사이에있었습니다.</target>
        </trans-unit>
        <trans-unit id="a30af6777f73b0b81eafe94ebef2f42d18285976" translate="yes" xml:space="preserve">
          <source>Just wanted to add my 2 cent, as the most answers relate to foreach-loop.
Please, take a look at the following code:</source>
          <target state="translated">대부분의 대답은 foreach-loop와 관련이 있으므로 2 센트를 추가하고 싶었습니다. 다음 코드를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="0a312e402e1aefeb15436d8d429a387734134010" translate="yes" xml:space="preserve">
          <source>LINQ provides a concise syntax that allows to specify order (and many other things), e.g.:</source>
          <target state="translated">LINQ는 순서 (및 기타 여러 가지)를 지정할 수있는 간결한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="56a3d1d4a9f3c543ec2f04e96ad6e723eacbd1c6" translate="yes" xml:space="preserve">
          <source>Most straightforward way</source>
          <target state="translated">가장 간단한 방법</target>
        </trans-unit>
        <trans-unit id="6939829ecad0770c1f2854c706760a6aad96113e" translate="yes" xml:space="preserve">
          <source>Notice that when defining a dictionary, we need to provide a generic 
   definition with two types - the type of the key and the type of the value. In this case, the key is a string whereas the value is an integer.</source>
          <target state="translated">사전을 정의 할 때 키 유형과 값 유형의 두 가지 유형으로 일반 정의를 제공해야합니다. 이 경우 키는 문자열이고 값은 정수입니다.</target>
        </trans-unit>
        <trans-unit id="c2687d7fa52a2592c8abbc6f420259028139b52c" translate="yes" xml:space="preserve">
          <source>On the other hand, there are many ways to iterate over a Dictionary in C# and there's no best way. It depends on the need and often on taste, too.</source>
          <target state="translated">반면에 C #에서 Dictionary를 반복하는 방법은 여러 가지가 있으며 최선의 방법은 없습니다. 그것은 필요와 종종 맛에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="12901374eb2c7fd59c9860f5abf06b72a4bb681c" translate="yes" xml:space="preserve">
          <source>One the one hand, there are many colors and there's no best color.  It depends on the need and often on taste, too.</source>
          <target state="translated">한 손으로 많은 색상이 있으며 최상의 색상이 없습니다. 그것은 필요와 종종 맛에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c2bcf06294a90e8e083763566b9deae7c61faa9" translate="yes" xml:space="preserve">
          <source>Or this one, if you prefer</source>
          <target state="translated">아니면 이걸 원한다면</target>
        </trans-unit>
        <trans-unit id="61e638ebf858c1f563ec3104471c16d5c2b33444" translate="yes" xml:space="preserve">
          <source>Or, if you only need to iterate over the collection of keys, use</source>
          <target state="translated">또는 키 컬렉션 만 반복해야하는 경우</target>
        </trans-unit>
        <trans-unit id="cd47115f2beda73a07079a12612fb07fbf287c47" translate="yes" xml:space="preserve">
          <source>Reported by this post which states it is the fastest method:
&lt;a href=&quot;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&quot;&gt;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&lt;/a&gt;</source>
          <target state="translated">이 게시물에 의해 가장 빠른 방법이라고 알려졌습니다 : &lt;a href=&quot;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&quot;&gt;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da423e06f316e7ef8aa1cb69bd467a47205d94ad" translate="yes" xml:space="preserve">
          <source>Simplest form to iterate a dictionary:</source>
          <target state="translated">사전을 반복하는 가장 간단한 양식 :</target>
        </trans-unit>
        <trans-unit id="3266a6cd5309e4591b0f00524a9a57f4b4865ecd" translate="yes" xml:space="preserve">
          <source>Sometimes if you only needs the values to be enumerated, use the dictionary's value collection:</source>
          <target state="translated">때때로 값을 열거해야하는 경우 사전의 값 콜렉션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d495734261a4228a062272f11bfaaa266e315883" translate="yes" xml:space="preserve">
          <source>The extension method transforms the &lt;code&gt;KeyValuePair&lt;/code&gt; of your &lt;code&gt;IDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; into a strongly typed &lt;code&gt;tuple&lt;/code&gt;, allowing you to use this new comfortable syntax.</source>
          <target state="translated">확장 메소드는 &lt;code&gt;IDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; 의 &lt;code&gt;KeyValuePair&lt;/code&gt; 를 강력한 유형의 &lt;code&gt;tuple&lt;/code&gt; 로 변환하여이 새로운 편안한 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04b1fb11f6c618e8f6576b6be78983440400acfe" translate="yes" xml:space="preserve">
          <source>The standard way to iterate over a Dictionary, according to official documentation on MSDN is:</source>
          <target state="translated">MSDN의 공식 문서에 따르면 사전을 반복하는 표준 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c5db52c67a7720b7c781aa83c84b6a7d4078cff" translate="yes" xml:space="preserve">
          <source>Then you can call</source>
          <target state="translated">그럼 당신은 전화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f35263d7d55bb1cc907239b11f8f7a8702c56214" translate="yes" xml:space="preserve">
          <source>There are also two ways of adding a single value to the dictionary, either using the brackets operator or using the Add method.</source>
          <target state="translated">대괄호 연산자를 사용하거나 Add 메서드를 사용하여 사전에 단일 값을 추가하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af00928700168d8333d32e85c9816e62844f0cc2" translate="yes" xml:space="preserve">
          <source>There are many more real-world use case you can do from these examples.
If you don't need a specific order, just stick to the &quot;most straightforward way&quot; (see above)!</source>
          <target state="translated">이 예제에서 수행 할 수있는 더 많은 실제 사용 사례가 있습니다. 특정 주문이 필요하지 않은 경우 &quot;가장 간단한 방법&quot;(위 참조)을 고수하십시오!</target>
        </trans-unit>
        <trans-unit id="cbe911091640f53097aaa45e1b69c726cffdc605" translate="yes" xml:space="preserve">
          <source>There are plenty of options. My personal favorite is by KeyValuePair</source>
          <target state="translated">많은 옵션이 있습니다. 내가 개인적으로 가장 좋아하는 것은 KeyValuePair입니다</target>
        </trans-unit>
        <trans-unit id="58dc2fee9700cb4d481b705fc61ae688a1068e85" translate="yes" xml:space="preserve">
          <source>There is a only minor cost calling the extension method for creating a &lt;code&gt;tuple&lt;/code&gt; in comparison with using the &lt;code&gt;KeyValuePair&lt;/code&gt; directly, which should NOT be an issue if you are assigning the &lt;code&gt;KeyValuePair&lt;/code&gt;'s properties &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; to new loop variables anyway.</source>
          <target state="translated">&lt;code&gt;KeyValuePair&lt;/code&gt; 를 직접 사용하는 것과 비교하여 &lt;code&gt;tuple&lt;/code&gt; 을 만들기 위해 확장 메서드를 호출하는 데에는 약간의 비용이 들지만, &lt;code&gt;KeyValuePair&lt;/code&gt; 속성 &lt;code&gt;Key&lt;/code&gt; 및 &lt;code&gt;Value&lt;/code&gt; 를 새 루프 변수에 할당하는 경우에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be499d7dd68e14f2114cfde873ca49059efc393f" translate="yes" xml:space="preserve">
          <source>This one loads the keys and iterates over them instead (I did also try pulling the keys into a string[] but the difference was negligible.</source>
          <target state="translated">이것은 키를로드하고 대신 반복합니다 (키를 문자열로 가져 오려고 시도했지만 차이는 무시할 만했습니다.</target>
        </trans-unit>
        <trans-unit id="00690079c2a4e1bf43ab84d2f19bcb896eb4878a" translate="yes" xml:space="preserve">
          <source>This was the only one I was able to get functioning correctly in a class that inherited from the DictionaryBase.</source>
          <target state="translated">이것은 DictionaryBase에서 상속 된 클래스에서 올바르게 작동 할 수있는 유일한 방법이었습니다.</target>
        </trans-unit>
        <trans-unit id="931954f05d1cefa1f2835133f3657de4a6c2d35b" translate="yes" xml:space="preserve">
          <source>This way I can write code like this:</source>
          <target state="translated">이 방법으로 다음과 같은 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a656f1ac324e97541d2983757ff92a90334a431" translate="yes" xml:space="preserve">
          <source>To check whether a dictionary has a certain key in it, we can use the ContainsKey method:</source>
          <target state="translated">사전에 특정 키가 있는지 확인하려면 ContainsKey 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28addee6cedf87e3145cfbfd1410ddb4937da311" translate="yes" xml:space="preserve">
          <source>To make this code work on lower C# versions, add &lt;code&gt;System.ValueTuple NuGet package&lt;/code&gt; and write somewhere</source>
          <target state="translated">이 코드가 더 낮은 C # 버전에서 작동하게하려면 &lt;code&gt;System.ValueTuple NuGet package&lt;/code&gt; 추가하고 어딘가에 작성하십시오</target>
        </trans-unit>
        <trans-unit id="6e440ac8f22b4b54d8858e18f05ed7e2f1f9fb3c" translate="yes" xml:space="preserve">
          <source>To remove an item from a dictionary, we can use the Remove method. Removing an item from a dictionary by its key is fast and very efficient. When removing an item from a List using its value, the process is slow and inefficient, unlike the dictionary Remove function.</source>
          <target state="translated">사전에서 항목을 제거하기 위해 Remove 메서드를 사용할 수 있습니다. 키를 사용하여 사전에서 항목을 제거하는 것이 빠르고 매우 효율적입니다. 값을 사용하여 List에서 항목을 제거하면 사전 제거 기능과 달리 프로세스가 느리고 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="561e6208f8daae64c5bf6a710fd669c6e1d73db0" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;C# 7&lt;/strong&gt;, add this &lt;strong&gt;extension method&lt;/strong&gt; to any project of your solution:</source>
          <target state="translated">&lt;strong&gt;C # 7을&lt;/strong&gt; 사용하여 솔루션의 모든 프로젝트에이 &lt;strong&gt;확장 메소드&lt;/strong&gt; 를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="25b2893d19aeea1311a5246ea8feadc8bddd54c7" translate="yes" xml:space="preserve">
          <source>What is the best way to iterate over a dictionary</source>
          <target state="translated">사전을 반복하는 가장 좋은 방법은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="35b69990e0e3a3bead58a6d1d0b26f1f2e48bfb1" translate="yes" xml:space="preserve">
          <source>When you just want to &quot;read&quot; Keys and Values, you might also use IEnumerable.Select().</source>
          <target state="translated">키와 값을 &quot;읽고&quot;싶을 때 IEnumerable.Select ()를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5e5c20123cee839590aadc6944acfc8b6ba57b0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.NET Framework 4.7&lt;/code&gt; one can use &lt;em&gt;decomposition&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;.NET Framework 4.7&lt;/code&gt; 에서는 &lt;em&gt;분해&lt;/em&gt; 를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="adddc5ba674bb912706e0bc6e404e69342e046de" translate="yes" xml:space="preserve">
          <source>With this example the normal foreach test took 0.0310062 and the keys version took 0.2205441. Loading all the keys and iterating over all the lookups is clearly a LOT slower!</source>
          <target state="translated">이 예제에서 일반적인 foreach 테스트는 0.0310062를, 키 버전은 0.2205441을 사용했습니다. 모든 키를로드하고 모든 조회를 반복하는 것은 분명히 느립니다!</target>
        </trans-unit>
        <trans-unit id="74a7440666a25dae99e6a51679822864419959f7" translate="yes" xml:space="preserve">
          <source>You can also try this on big dictionaries for multithreaded processing.</source>
          <target state="translated">멀티 스레드 처리를 위해 큰 사전에서이를 시도 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89dbe6661417ad0ac5d04a14f040438e17c79f9e" translate="yes" xml:space="preserve">
          <source>You can also use the Keys and Values Collections</source>
          <target state="translated">키 및 값 컬렉션을 사용할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="8bde3ca31d73fcbcb92dbfcc529338d5f8eebf16" translate="yes" xml:space="preserve">
          <source>You suggested below to iterate</source>
          <target state="translated">아래에서 반복하도록 제안했습니다.</target>
        </trans-unit>
        <trans-unit id="a79b7064f585723bd2a6d43d8ede72db3bc54422" translate="yes" xml:space="preserve">
          <source>but sorted by the keys</source>
          <target state="translated">그러나 키로 정렬</target>
        </trans-unit>
        <trans-unit id="3107d23c2c12366f1af56b42170c59f9dff15fdc" translate="yes" xml:space="preserve">
          <source>in addition to the highest ranking posts where there is a discussion between using</source>
          <target state="translated">사용 사이에 토론이있는 최고 순위 게시물 외에도</target>
        </trans-unit>
        <trans-unit id="52622b7a5d5b59d00e8b4165042de57215a2bb93" translate="yes" xml:space="preserve">
          <source>iterate directly on the value (allows to call it &lt;code&gt;item&lt;/code&gt;, more readable than &lt;code&gt;kvp.Value&lt;/code&gt;)</source>
          <target state="translated">값을 직접 반복하십시오 ( &lt;code&gt;kvp.Value&lt;/code&gt; 보다 읽기 쉬운 &lt;code&gt;item&lt;/code&gt; 이라고 부를 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="becfe9c4e9a3d53784bb97c520dc78c924051aeb" translate="yes" xml:space="preserve">
          <source>most complete is the following because you can see the dictionary type from the initialization, kvp is KeyValuePair</source>
          <target state="translated">초기화에서 사전 유형을 볼 수 있기 때문에 가장 완전한 것은 다음과 같습니다. kvp는 KeyValuePair입니다.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
