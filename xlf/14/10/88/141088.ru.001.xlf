<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/141088">
    <body>
      <group id="141088">
        <trans-unit id="eb62bf8162ffc815e7e0a450233ae73344cf26b4" translate="yes" xml:space="preserve">
          <source>(Take note that the &lt;code&gt;var&lt;/code&gt; keyword is an optional C# 3.0 and above feature, you could also use the exact type of your keys/values here)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Обратите внимание, что &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ключевое слово &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является дополнительной функцией C # 3.0 и выше, вы также можете использовать точный тип ваших ключей / значений здесь)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="026743e8cb8670bfc15d3538a9ad2479fe83c402" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt790184.aspx&quot;&gt;&lt;em&gt;C# 7.0&lt;/em&gt; introduced &lt;strong&gt;Deconstructors&lt;/strong&gt;&lt;/a&gt; and if you are using &lt;em&gt;.NET Core 2.0+&lt;/em&gt; Application, the struct &lt;code&gt;KeyValuePair&amp;lt;&amp;gt;&lt;/code&gt; already include a &lt;code&gt;Deconstruct()&lt;/code&gt; for you. So you can do:</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt790184.aspx&quot;&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В C # 7.0&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; появились &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;деконструкторы,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и если вы используете приложение&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .NET Core 2.0+&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , struct&lt;/font&gt;&lt;/font&gt; &lt;code&gt;KeyValuePair&amp;lt;&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; уже включает в себя&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Deconstruct()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для вас. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так что вы можете сделать:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="330db4cc5e1b70f828267dc0892a7a0945a2ddbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; is fastest and if you only iterate over &lt;code&gt;___.Values&lt;/code&gt;, it is also faster</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; самый быстрый и если вы перебираете только &lt;/font&gt;&lt;/font&gt; &lt;code&gt;___.Values&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , он также быстрее&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79c0b346684aceccc675b3227ae87626592f99a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dictionary&amp;lt; TKey,&amp;ensp;TValue &amp;gt;&lt;/strong&gt; It is a generic collection class in c# and it stores the data in the key value format.Key must be unique and it can not be null whereas value can be duplicate and null.As each item in the dictionary is treated as KeyValuePair&amp;lt; TKey,&amp;ensp;TValue &amp;gt; structure representing a key and its value. and hence we should take the element type  KeyValuePair&amp;lt; TKey,&amp;ensp;TValue&amp;gt; during the iteration of element.&lt;strong&gt;Below is the example.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dictionary &amp;lt;TKey, TValue&amp;gt;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Это универсальный класс коллекции в c #, в котором хранятся данные в формате значения ключа. Ключ должен быть уникальным и не может быть нулевым, тогда как значение может быть повторяющимся и нулевым. Поскольку каждый элемент в словаре рассматривается как структура KeyValuePair &amp;lt;TKey, TValue&amp;gt;, представляющая ключ и его значение. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и, следовательно, мы должны взять тип элемента KeyValuePair &amp;lt;TKey, TValue&amp;gt; во время итерации элемента. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ниже приведен пример.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91a956d0b808239ab6cec3a04a363af766520cb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edited To Add:&lt;/strong&gt;
Reading some of the other answers made me question what would happen if I used Dictionary instead of Dictionary. In this example the array took 0.0120024 seconds, the list 0.0185037 seconds and the dictionary 0.0465093 seconds. It's reasonable to expect that the data type makes a difference on how much slower the dictionary is.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Отредактировано, чтобы добавить:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Чтение некоторых других ответов заставило меня задуматься, что произойдет, если я воспользуюсь словарем вместо словаря. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этом примере массив занял 0,0120024 секунды, список 0,0185037 секунд и словарь 0,0465093 секунд. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Разумно ожидать, что тип данных влияет на то, насколько медленнее словарь.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7248e135957a14fe596c2f11af12e99c6868b5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What are my Conclusions&lt;/strong&gt;?</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Каковы мои выводы&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9100164962c2669d80ab417d22f39cd1aa29af8e" translate="yes" xml:space="preserve">
          <source>Again you might only need the value. LINQ also provides a concise solution to:</source>
          <target state="translated">Опять же,тебе может понадобиться только ценность.LINQ также предоставляет краткое решение:</target>
        </trans-unit>
        <trans-unit id="4f5370435b9afedf2acebdb4888721858ecbf6f9" translate="yes" xml:space="preserve">
          <source>Also, please note that you wont be able to assign values to the 'Value' property inside a foreach-loop. On the other hand, you will be able to manipulate the 'Key' as well, possibly getting you into trouble at runtime.</source>
          <target state="translated">Также,пожалуйста,обратите внимание,что вы не сможете присвоить значения свойству 'Value' внутри foreach-loop.С другой стороны,вы также сможете манипулировать 'Ключом',что может привести к проблемам во время выполнения.</target>
        </trans-unit>
        <trans-unit id="76f5e18ba91fd6b70cb9adaefc5933941f851c20" translate="yes" xml:space="preserve">
          <source>Altought this adds a additional call of '.ToList()', there might be a slight performance-improvement (as pointed out here &lt;a href=&quot;https://stackoverflow.com/questions/225937/foreach-vs-somelist-foreach&quot;&gt;foreach vs someList.Foreach(){}&lt;/a&gt;), 
espacially when working with large Dictionaries and running in parallel is no option / won't have an effect at all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хотя это добавляет дополнительный вызов .ToList (), может произойти небольшое улучшение производительности (как указано здесь &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/225937/foreach-vs-somelist-foreach&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;foreach vs someList.Foreach () {}&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), особенно при работе с большими словарями и параллельной работе нет опция / не будет иметь никакого эффекта вообще.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="497a1c51557e3717356f3865a1603f5a2d32c9e2" translate="yes" xml:space="preserve">
          <source>And lastly, if you're only interested in the values:</source>
          <target state="translated">И,наконец,если тебя интересуют только ценности:</target>
        </trans-unit>
        <trans-unit id="7e38ec34611de5a1fac9cfab4885031bbb66ff1c" translate="yes" xml:space="preserve">
          <source>And use this simple syntax</source>
          <target state="translated">И используйте этот простой синтаксис</target>
        </trans-unit>
        <trans-unit id="92bfa14da3d176a49eb5942098fe4a5e0ee847b8" translate="yes" xml:space="preserve">
          <source>As of C# 7, you can deconstruct objects into variables. I believe this to be the best way to iterate over a dictionary.</source>
          <target state="translated">Начиная с C#7,можно деконструировать объекты на переменные.Я считаю,что это лучший способ итерации по словарю.</target>
        </trans-unit>
        <trans-unit id="9a69642663084ba779311a272e9dd900ea850114" translate="yes" xml:space="preserve">
          <source>Avoid iterating over a dictionary if you can, they are substantially slower than iterating over an array with the same data in it.</source>
          <target state="translated">Избегайте итераций по словарю,если можете,они значительно медленнее,чем итерации по массиву с теми же самыми данными в нем.</target>
        </trans-unit>
        <trans-unit id="8ca89494efd9d4b2e9284f9172599aafaa794b3f" translate="yes" xml:space="preserve">
          <source>Check this out: &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/&quot;&gt;MSDN Blog - New features in C# 7&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Проверьте это: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/03/09/new-features-in-c-7-0/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Блог MSDN - Новые функции в C # 7&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf9de95bf6f48a9389484e0472b57cafffa12b52" translate="yes" xml:space="preserve">
          <source>Create an extension method on &lt;code&gt;KeyValuePair&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; that deconstructs it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Создайте метод расширения для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;KeyValuePair&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; который его деконструирует:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5d7f786e4ff8d0de7f07cea81a0650c70803c3b" translate="yes" xml:space="preserve">
          <source>Depends on whether you're after the keys or the values...</source>
          <target state="translated">Зависит от того,что вы ищете-ключи или значения...</target>
        </trans-unit>
        <trans-unit id="7f5693528b649c7c6467a276acd2ed66b5c6a0fc" translate="yes" xml:space="preserve">
          <source>Dictionaries are optimised for lookups, so with that in mind I've created two methods. One simply does a foreach, the other iterates the keys then looks up.</source>
          <target state="translated">Словари оптимизированы для поиска,поэтому,учитывая это,я создал два метода.Один просто делает форач,другой итерацию клавиш,а затем смотрит вверх.</target>
        </trans-unit>
        <trans-unit id="eaebe6020d43cd89f479e33d92042d4d05f09fc6" translate="yes" xml:space="preserve">
          <source>Dictionaries are special lists, whereas every value in the list has a key 
   which is also a variable. A good example of a dictionary is a phone book.</source>
          <target state="translated">Словари-это специальные списки,в то время как каждое значение в списке имеет ключ,который также является переменной.Хорошим примером словаря является телефонная книга.</target>
        </trans-unit>
        <trans-unit id="f66e268e3c61815f0a9aadfa11d0435990b81948" translate="yes" xml:space="preserve">
          <source>FYI, &lt;code&gt;foreach&lt;/code&gt; doesn't work if the value are of type object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;К вашему сведению, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;foreach&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не работает, если значение имеет тип объекта.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8bb288146578f1426d12059b105c4248ba3bf95" translate="yes" xml:space="preserve">
          <source>For a final test I've performed my iteration ten times to see if there are any benefits to using the keys here (by this point I was just curious):</source>
          <target state="translated">Для финального теста я выполнил свою итерацию десять раз,чтобы посмотреть,есть ли здесь какие-то преимущества в использовании ключей (к этому моменту мне было просто любопытно):</target>
        </trans-unit>
        <trans-unit id="a95e7b2352f925500843c695ae42c8305794770c" translate="yes" xml:space="preserve">
          <source>From the MSDN &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xfhwa508.aspx&quot;&gt;&lt;code&gt;Dictionary(TKey, TValue)&lt;/code&gt;&lt;/a&gt; Class description:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Из &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xfhwa508.aspx&quot;&gt; &lt;code&gt;Dictionary(TKey, TValue)&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; MSDN &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(TKey, TValue)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Описание класса:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0090de992f60b579dc8ed0ae062ff55e83f6c9d4" translate="yes" xml:space="preserve">
          <source>Generally, asking for &quot;the best way&quot; without a specific context is like asking 
&lt;em&gt;what is the best color&lt;/em&gt;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как правило, спрашивать &amp;laquo;лучший способ&amp;raquo; без конкретного контекста - это все равно, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; спрашивать, &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;какой цвет лучше&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7329ec82a6123d339bb60b69d3500067815fe184" translate="yes" xml:space="preserve">
          <source>Generally, beginners are surprised about order of enumeration of a Dictionary.</source>
          <target state="translated">Как правило,новички удивляются порядку перечисления словаря.</target>
        </trans-unit>
        <trans-unit id="5ef0e3e404407e991996a23ad4564c3121299baa" translate="yes" xml:space="preserve">
          <source>Here it is:</source>
          <target state="translated">Вот оно:</target>
        </trans-unit>
        <trans-unit id="d9350c4847221cf90bedbefd5403e04396a9af43" translate="yes" xml:space="preserve">
          <source>Here the normal foreach run took 0.2820564 seconds (around ten times longer than a single iteration took - as you'd expect). The iteration over the keys took 2.2249449 seconds.</source>
          <target state="translated">Здесь обычный пробег фореаса занял 0.2820564 секунды (примерно в десять раз дольше,чем одна итерация-как и следовало ожидать).Итерация над клавишами заняла 2,2249449 секунды.</target>
        </trans-unit>
        <trans-unit id="2c477bee0d68beb1a51f1cd6faae233ddaf703e8" translate="yes" xml:space="preserve">
          <source>Here's the RunTest method if that helps you visualise what's going on.</source>
          <target state="translated">Вот метод RunTest,если он помогает вам визуализировать происходящее.</target>
        </trans-unit>
        <trans-unit id="d8bf4f0dde39aae9200beafeade042e6eef6528d" translate="yes" xml:space="preserve">
          <source>However, that is like comparing apples and oranges. My point is that iterating over dictionaries is slow.</source>
          <target state="translated">Однако это все равно,что сравнивать яблоки и апельсины.Я хочу сказать,что итерация по словарям происходит медленно.</target>
        </trans-unit>
        <trans-unit id="a8d167b3a491226f6e12a59d62715ca577941f73" translate="yes" xml:space="preserve">
          <source>I appreciate this question has already had a lot of responses but I wanted to throw in a little research.</source>
          <target state="translated">Я ценю,что на этот вопрос уже было получено много ответов,но мне захотелось провести небольшое исследование.</target>
        </trans-unit>
        <trans-unit id="087718cc256ab6d2e3aa86090f4dff4746dd35b4" translate="yes" xml:space="preserve">
          <source>I found this method in the documentation for the DictionaryBase class on MSDN:</source>
          <target state="translated">Я нашел этот метод в документации к классу DictionaryBase на MSDN:</target>
        </trans-unit>
        <trans-unit id="a0d3a4cfc425a3e0a8768e7618e2f448e7d4a006" translate="yes" xml:space="preserve">
          <source>I know this is a very old question, but I created some extension methods that might be useful:</source>
          <target state="translated">Я знаю,что это очень старый вопрос,но я создал некоторые методы расширения,которые могут быть полезны:</target>
        </trans-unit>
        <trans-unit id="022f337ac135568be545886f9660c8aa25366900" translate="yes" xml:space="preserve">
          <source>I will take the advantage of .NET 4.0+ and provide an updated answer to the originally accepted one:</source>
          <target state="translated">Я воспользуюсь преимуществом .NET 4.0+и представлю обновленный ответ на изначально принятый:</target>
        </trans-unit>
        <trans-unit id="665b68985ca020cff37a421433dacf69dab38b90" translate="yes" xml:space="preserve">
          <source>I would say foreach is the standard way, though it obviously depends on what you're looking for</source>
          <target state="translated">Я бы сказал,что форач-это стандартный способ,хотя,очевидно,это зависит от того,что вы ищете.</target>
        </trans-unit>
        <trans-unit id="c48c72f51d0a484a1a84eb7af0928b9f44c8b892" translate="yes" xml:space="preserve">
          <source>I wrote an extension to loop over a dictionary.</source>
          <target state="translated">Я написал расширение для петли над словарем.</target>
        </trans-unit>
        <trans-unit id="2ac3f8179ccd0d030b87d697d99ca03d616f062e" translate="yes" xml:space="preserve">
          <source>I've seen a few different ways to iterate over a dictionary in C#.  Is there a standard way?</source>
          <target state="translated">Я видел несколько разных способов итераций по словарю на C#.Есть ли стандартный способ?</target>
        </trans-unit>
        <trans-unit id="c94e1b7e69d2dee4055b44d61ee7263b89c08118" translate="yes" xml:space="preserve">
          <source>If say, you want to iterate over the values collection by default, I believe you can implement IEnumerable&amp;lt;&amp;gt;, Where T is the type of the values object in the dictionary, and &quot;this&quot; is a Dictionary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если, скажем, вы хотите перебрать коллекцию значений по умолчанию, я полагаю, что вы можете реализовать IEnumerable &amp;lt;&amp;gt;, где T - это тип объекта значений в словаре, а &amp;laquo;this&amp;raquo; - словарь.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d589805b05fde41a07bac29079c4d138b37e600" translate="yes" xml:space="preserve">
          <source>If you are trying to use a generic Dictionary in C# like you would use an associative array in another language:</source>
          <target state="translated">Если вы пытаетесь использовать общий словарь на C#,как будто вы используете ассоциативный массив на другом языке:</target>
        </trans-unit>
        <trans-unit id="225f3d8b8aba090c50b8267620c2a20c558fb879" translate="yes" xml:space="preserve">
          <source>If you do choose to iterate over a dictionary don't try to be too clever, although slower you could do a lot worse than using the standard foreach method.</source>
          <target state="translated">Если вы все-таки решили провести итерацию по словарю,не пытайтесь быть слишком умным,хотя и медленнее,чем при использовании стандартного метода фораха.</target>
        </trans-unit>
        <trans-unit id="8c6850798a250101039b1c803e1f0aa0bfaf7a6f" translate="yes" xml:space="preserve">
          <source>If you need a specific sort order</source>
          <target state="translated">Если вам нужен определенный порядок сортировки</target>
        </trans-unit>
        <trans-unit id="72122c33e7e269d2437cc77c6a6dabad50e50d09" translate="yes" xml:space="preserve">
          <source>If you need only the value (allows to call it &lt;code&gt;item&lt;/code&gt;, more readable than &lt;code&gt;kvp.Value&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вам нужно только значение (позволяет назвать его &lt;/font&gt;&lt;/font&gt; &lt;code&gt;item&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , более читабельным, чем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;kvp.Value&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4eb81bd43d3ac692872a05660c909d3b0ce288ab" translate="yes" xml:space="preserve">
          <source>In place of the traditional</source>
          <target state="translated">Вместо традиционного</target>
        </trans-unit>
        <trans-unit id="1f92c68b2be2630fe633591fd3b21b630d437ef5" translate="yes" xml:space="preserve">
          <source>In practice, this new syntax suits very well for most cases, except for low-level ultra-high performance scenarios, where you still have the option to simply not use it on that specific spot.</source>
          <target state="translated">На практике этот новый синтаксис очень хорошо подходит для большинства случаев,за исключением сценариев с низким уровнем ультравысокой производительности,где у вас все еще есть возможность просто не использовать его в этом конкретном месте.</target>
        </trans-unit>
        <trans-unit id="c6c6c6ff7fee12c22582376bd7ab848207b260bf" translate="yes" xml:space="preserve">
          <source>In some cases you may need a counter that may be provided by for-loop implementation. For that, LINQ provides &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx&quot;&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/a&gt; which enables the following:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В некоторых случаях вам может понадобиться счетчик, который может быть предоставлен реализацией цикла for. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для этого LINQ предоставляет &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx&quot;&gt; &lt;code&gt;ElementAt&lt;/code&gt; ,&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; который включает следующее:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14cd2de22272c6bf242c99d4bdaf33377d866818" translate="yes" xml:space="preserve">
          <source>Is that what you're looking for?</source>
          <target state="translated">Это то,что ты ищешь?</target>
        </trans-unit>
        <trans-unit id="1b5a5787fcfada038cc95ac0f53477decb94de59" translate="yes" xml:space="preserve">
          <source>It converts -just- the required dictionary entries to &lt;code&gt;tuples&lt;/code&gt;, so it does NOT converts the whole dictionary to &lt;code&gt;tuples&lt;/code&gt;, so there are no performance concerns related to that.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он преобразует-просто необходимые словарные записи в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;tuples&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , поэтому он НЕ преобразует весь словарь в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;tuples&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , поэтому никаких проблем с производительностью, связанных с этим.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a1cb1752fca818aa6ba5c1e1d61b985e10cddfec" translate="yes" xml:space="preserve">
          <source>Iterate over any &lt;code&gt;Dictionary&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; in the following manner</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Переберите любой &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Dictionary&amp;lt;TKey, TVal&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; следующим образом&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb2d3fba103eca2485423e3fb51dc4e236fbd0ce" translate="yes" xml:space="preserve">
          <source>Iterating over a dictionary can be rather slow when compared with iterating over something like an array. In my tests an iteration over an array took 0.015003 seconds whereas an iteration over a dictionary (with the same number of elements) took 0.0365073 seconds that's 2.4 times as long! Although I have seen much bigger differences. For comparison a List was somewhere in between at 0.00215043 seconds.</source>
          <target state="translated">Итерация по словарю может быть довольно медленной по сравнению с итерацией по чему-то вроде массива.В моих тестах итерация по массиву занимала 0.015003 секунды,а по словарю (с таким же количеством элементов)-0.0365073 секунды,что в 2.4 раза больше! Хотя я видел гораздо большие различия.Для сравнения Список был где-то между 0.00215043 секунды.</target>
        </trans-unit>
        <trans-unit id="a30af6777f73b0b81eafe94ebef2f42d18285976" translate="yes" xml:space="preserve">
          <source>Just wanted to add my 2 cent, as the most answers relate to foreach-loop.
Please, take a look at the following code:</source>
          <target state="translated">Просто хотел добавить свои 2 цента,так как большинство ответов относятся к foreach-loop.Пожалуйста,взгляните на следующий код:</target>
        </trans-unit>
        <trans-unit id="0a312e402e1aefeb15436d8d429a387734134010" translate="yes" xml:space="preserve">
          <source>LINQ provides a concise syntax that allows to specify order (and many other things), e.g.:</source>
          <target state="translated">LINQ предоставляет лаконичный синтаксис,позволяющий указывать порядок (и многое другое),например:</target>
        </trans-unit>
        <trans-unit id="56a3d1d4a9f3c543ec2f04e96ad6e723eacbd1c6" translate="yes" xml:space="preserve">
          <source>Most straightforward way</source>
          <target state="translated">Самый прямой путь</target>
        </trans-unit>
        <trans-unit id="6939829ecad0770c1f2854c706760a6aad96113e" translate="yes" xml:space="preserve">
          <source>Notice that when defining a dictionary, we need to provide a generic 
   definition with two types - the type of the key and the type of the value. In this case, the key is a string whereas the value is an integer.</source>
          <target state="translated">Обратите внимание,что при определении словаря необходимо дать общее определение с двумя типами-типом ключа и типом значения.В этом случае ключ является строкой,а значение-целым числом.</target>
        </trans-unit>
        <trans-unit id="c2687d7fa52a2592c8abbc6f420259028139b52c" translate="yes" xml:space="preserve">
          <source>On the other hand, there are many ways to iterate over a Dictionary in C# and there's no best way. It depends on the need and often on taste, too.</source>
          <target state="translated">С другой стороны,есть много способов провести итерацию по словарю на C#и нет лучшего способа.Это зависит от необходимости,а часто и от вкуса.</target>
        </trans-unit>
        <trans-unit id="12901374eb2c7fd59c9860f5abf06b72a4bb681c" translate="yes" xml:space="preserve">
          <source>One the one hand, there are many colors and there's no best color.  It depends on the need and often on taste, too.</source>
          <target state="translated">С одной стороны,есть много цветов,и нет лучшего цвета.Это зависит от необходимости,а часто и от вкуса.</target>
        </trans-unit>
        <trans-unit id="9c2bcf06294a90e8e083763566b9deae7c61faa9" translate="yes" xml:space="preserve">
          <source>Or this one, if you prefer</source>
          <target state="translated">Или этот,если ты предпочитаешь</target>
        </trans-unit>
        <trans-unit id="61e638ebf858c1f563ec3104471c16d5c2b33444" translate="yes" xml:space="preserve">
          <source>Or, if you only need to iterate over the collection of keys, use</source>
          <target state="translated">Или,если вам нужно только выполнить итерацию над коллекцией ключей,используйте</target>
        </trans-unit>
        <trans-unit id="cd47115f2beda73a07079a12612fb07fbf287c47" translate="yes" xml:space="preserve">
          <source>Reported by this post which states it is the fastest method:
&lt;a href=&quot;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&quot;&gt;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Об этом сообщает этот пост, в котором говорится, что это самый быстрый метод: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://alexpinsker.blogspot.hk/2010/02/c-fastest-way-to-iterate-over.html.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da423e06f316e7ef8aa1cb69bd467a47205d94ad" translate="yes" xml:space="preserve">
          <source>Simplest form to iterate a dictionary:</source>
          <target state="translated">Простейшая форма для итерации словаря:</target>
        </trans-unit>
        <trans-unit id="3266a6cd5309e4591b0f00524a9a57f4b4865ecd" translate="yes" xml:space="preserve">
          <source>Sometimes if you only needs the values to be enumerated, use the dictionary's value collection:</source>
          <target state="translated">Иногда,если вам нужно только перечислить значения,воспользуйтесь коллекцией значений словаря:</target>
        </trans-unit>
        <trans-unit id="d495734261a4228a062272f11bfaaa266e315883" translate="yes" xml:space="preserve">
          <source>The extension method transforms the &lt;code&gt;KeyValuePair&lt;/code&gt; of your &lt;code&gt;IDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; into a strongly typed &lt;code&gt;tuple&lt;/code&gt;, allowing you to use this new comfortable syntax.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Метод расширения преобразует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;KeyValuePair&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вашего &lt;/font&gt;&lt;/font&gt; &lt;code&gt;IDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в сильно типизированный &lt;/font&gt;&lt;/font&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;позволяет использовать этот новый комфортабельный синтаксис.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04b1fb11f6c618e8f6576b6be78983440400acfe" translate="yes" xml:space="preserve">
          <source>The standard way to iterate over a Dictionary, according to official documentation on MSDN is:</source>
          <target state="translated">Стандартным способом итерации по Словарю,согласно официальной документации на MSDN является:</target>
        </trans-unit>
        <trans-unit id="5c5db52c67a7720b7c781aa83c84b6a7d4078cff" translate="yes" xml:space="preserve">
          <source>Then you can call</source>
          <target state="translated">Тогда вы можете позвонить</target>
        </trans-unit>
        <trans-unit id="f35263d7d55bb1cc907239b11f8f7a8702c56214" translate="yes" xml:space="preserve">
          <source>There are also two ways of adding a single value to the dictionary, either using the brackets operator or using the Add method.</source>
          <target state="translated">Существует также два способа добавления одного значения в словарь-либо с помощью оператора скобок,либо с помощью метода Add.</target>
        </trans-unit>
        <trans-unit id="af00928700168d8333d32e85c9816e62844f0cc2" translate="yes" xml:space="preserve">
          <source>There are many more real-world use case you can do from these examples.
If you don't need a specific order, just stick to the &quot;most straightforward way&quot; (see above)!</source>
          <target state="translated">Есть гораздо больше реальных случаев использования,которые вы можете сделать из этих примеров.Если вам не нужен конкретный порядок,просто придерживайтесь &quot;самого простого способа&quot; (см.выше)!</target>
        </trans-unit>
        <trans-unit id="cbe911091640f53097aaa45e1b69c726cffdc605" translate="yes" xml:space="preserve">
          <source>There are plenty of options. My personal favorite is by KeyValuePair</source>
          <target state="translated">Есть много вариантов.Мой личный любимый-KeyValuePair.</target>
        </trans-unit>
        <trans-unit id="58dc2fee9700cb4d481b705fc61ae688a1068e85" translate="yes" xml:space="preserve">
          <source>There is a only minor cost calling the extension method for creating a &lt;code&gt;tuple&lt;/code&gt; in comparison with using the &lt;code&gt;KeyValuePair&lt;/code&gt; directly, which should NOT be an issue if you are assigning the &lt;code&gt;KeyValuePair&lt;/code&gt;'s properties &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; to new loop variables anyway.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Существует только незначительная стоимость вызова метода расширения для создания &lt;/font&gt;&lt;/font&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; по сравнению с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;непосредственным &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;использованием &lt;/font&gt;&lt;/font&gt; &lt;code&gt;KeyValuePair&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что не должно вызывать проблем, если вы все &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;равно &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;назначаете &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;свойства &lt;/font&gt;&lt;/font&gt; &lt;code&gt;KeyValuePair&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;Key&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Value&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; новым переменным цикла.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be499d7dd68e14f2114cfde873ca49059efc393f" translate="yes" xml:space="preserve">
          <source>This one loads the keys and iterates over them instead (I did also try pulling the keys into a string[] but the difference was negligible.</source>
          <target state="translated">Этот загружает ключи и вместо этого выполняет над ними итерацию (я также пытался вытянуть ключи в строку[],но разница была незначительной.</target>
        </trans-unit>
        <trans-unit id="00690079c2a4e1bf43ab84d2f19bcb896eb4878a" translate="yes" xml:space="preserve">
          <source>This was the only one I was able to get functioning correctly in a class that inherited from the DictionaryBase.</source>
          <target state="translated">Это был единственный класс,который мне удалось правильно работать в классе,унаследованном от DictionaryBase.</target>
        </trans-unit>
        <trans-unit id="931954f05d1cefa1f2835133f3657de4a6c2d35b" translate="yes" xml:space="preserve">
          <source>This way I can write code like this:</source>
          <target state="translated">Так я смогу писать код:</target>
        </trans-unit>
        <trans-unit id="2a656f1ac324e97541d2983757ff92a90334a431" translate="yes" xml:space="preserve">
          <source>To check whether a dictionary has a certain key in it, we can use the ContainsKey method:</source>
          <target state="translated">Чтобы проверить,есть ли в словаре определенный ключ,можно воспользоваться методом ContainsKey:</target>
        </trans-unit>
        <trans-unit id="28addee6cedf87e3145cfbfd1410ddb4937da311" translate="yes" xml:space="preserve">
          <source>To make this code work on lower C# versions, add &lt;code&gt;System.ValueTuple NuGet package&lt;/code&gt; and write somewhere</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы этот код работал на более низких версиях C #, добавьте &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.ValueTuple NuGet package&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и напишите куда-нибудь&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e440ac8f22b4b54d8858e18f05ed7e2f1f9fb3c" translate="yes" xml:space="preserve">
          <source>To remove an item from a dictionary, we can use the Remove method. Removing an item from a dictionary by its key is fast and very efficient. When removing an item from a List using its value, the process is slow and inefficient, unlike the dictionary Remove function.</source>
          <target state="translated">Чтобы удалить элемент из словаря,можно воспользоваться методом Remove.Удаление элемента из словаря по его ключу происходит быстро и очень эффективно.При удалении элемента из Списка по его значению,в отличие от функции удаления из словаря,этот процесс происходит медленно и неэффективно.</target>
        </trans-unit>
        <trans-unit id="561e6208f8daae64c5bf6a710fd669c6e1d73db0" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;C# 7&lt;/strong&gt;, add this &lt;strong&gt;extension method&lt;/strong&gt; to any project of your solution:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используя &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C # 7&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , добавьте этот &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метод расширения&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в любой проект вашего решения:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25b2893d19aeea1311a5246ea8feadc8bddd54c7" translate="yes" xml:space="preserve">
          <source>What is the best way to iterate over a dictionary</source>
          <target state="translated">Как лучше всего провести итерацию по словарю.</target>
        </trans-unit>
        <trans-unit id="35b69990e0e3a3bead58a6d1d0b26f1f2e48bfb1" translate="yes" xml:space="preserve">
          <source>When you just want to &quot;read&quot; Keys and Values, you might also use IEnumerable.Select().</source>
          <target state="translated">Когда вы просто хотите &quot;прочитать&quot; Ключи и Значения,вы также можете использовать IEnumerable.Select().</target>
        </trans-unit>
        <trans-unit id="d5e5c20123cee839590aadc6944acfc8b6ba57b0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.NET Framework 4.7&lt;/code&gt; one can use &lt;em&gt;decomposition&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.NET Framework 4.7&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; можно использовать &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;декомпозицию&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adddc5ba674bb912706e0bc6e404e69342e046de" translate="yes" xml:space="preserve">
          <source>With this example the normal foreach test took 0.0310062 and the keys version took 0.2205441. Loading all the keys and iterating over all the lookups is clearly a LOT slower!</source>
          <target state="translated">В этом примере обычный тест форач принял 0.0310062,а версия ключей-0.2205441.Загрузка всех клавиш и итерация по всем поискам,безусловно,LOT медленнее!</target>
        </trans-unit>
        <trans-unit id="74a7440666a25dae99e6a51679822864419959f7" translate="yes" xml:space="preserve">
          <source>You can also try this on big dictionaries for multithreaded processing.</source>
          <target state="translated">Вы также можете попробовать это в больших словарях для многопоточной обработки.</target>
        </trans-unit>
        <trans-unit id="89dbe6661417ad0ac5d04a14f040438e17c79f9e" translate="yes" xml:space="preserve">
          <source>You can also use the Keys and Values Collections</source>
          <target state="translated">Вы также можете использовать Клавиши и коллекции значений</target>
        </trans-unit>
        <trans-unit id="8bde3ca31d73fcbcb92dbfcc529338d5f8eebf16" translate="yes" xml:space="preserve">
          <source>You suggested below to iterate</source>
          <target state="translated">Вы предложили ниже выполнить итерацию</target>
        </trans-unit>
        <trans-unit id="a79b7064f585723bd2a6d43d8ede72db3bc54422" translate="yes" xml:space="preserve">
          <source>but sorted by the keys</source>
          <target state="translated">но отсортированный по клавишам</target>
        </trans-unit>
        <trans-unit id="3107d23c2c12366f1af56b42170c59f9dff15fdc" translate="yes" xml:space="preserve">
          <source>in addition to the highest ranking posts where there is a discussion between using</source>
          <target state="translated">в дополнение к должностям самого высокого ранга,где обсуждается использование</target>
        </trans-unit>
        <trans-unit id="52622b7a5d5b59d00e8b4165042de57215a2bb93" translate="yes" xml:space="preserve">
          <source>iterate directly on the value (allows to call it &lt;code&gt;item&lt;/code&gt;, more readable than &lt;code&gt;kvp.Value&lt;/code&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;итерация непосредственно по значению (позволяет назвать его &lt;/font&gt;&lt;/font&gt; &lt;code&gt;item&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , более читаемым, чем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;kvp.Value&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="becfe9c4e9a3d53784bb97c520dc78c924051aeb" translate="yes" xml:space="preserve">
          <source>most complete is the following because you can see the dictionary type from the initialization, kvp is KeyValuePair</source>
          <target state="translated">наиболее полным является следующее,потому что вы можете увидеть тип словаря из инициализации,kvp является KeyValuePair</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
