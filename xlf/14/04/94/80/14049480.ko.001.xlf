<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/14049480">
    <body>
      <group id="14049480">
        <trans-unit id="362bc9e9f2395367fb43cf442b2292ab7399efc1" translate="yes" xml:space="preserve">
          <source>(I colored one line gray just so that it is clear where it is going.)</source>
          <target state="translated">(가는 곳이 명확하도록 한 줄을 회색으로 칠했습니다.)</target>
        </trans-unit>
        <trans-unit id="9c2aca2ce080196d80035e8f58fd11cf1e5830a2" translate="yes" xml:space="preserve">
          <source>(If you really want to share data via controllers scope inheritance, there is nothing you need to do.  The child scope will have access to all of the parent scope properties.
See also &lt;a href=&quot;https://stackoverflow.com/questions/13825419/controller-load-order-differs-when-loading-or-navigating/13843771#13843771&quot;&gt;Controller load order differs when loading or navigating&lt;/a&gt;)</source>
          <target state="translated">(컨트롤러 범위 상속을 통해 데이터를 실제로 공유하려면 할 필요가 없습니다. 하위 범위는 모든 상위 범위 속성에 액세스 할 수 있습니다. &lt;a href=&quot;https://stackoverflow.com/questions/13825419/controller-load-order-differs-when-loading-or-navigating/13843771#13843771&quot;&gt;로드 또는 탐색시 컨트롤러로드 순서가 다름&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="6abdf5e252c173cf61f961b6ff4d944694989e8b" translate="yes" xml:space="preserve">
          <source>(Note that to save space, I show the &lt;code&gt;anArray&lt;/code&gt; object as a single blue object with its three values, rather than an single blue object with three separate gray literals.)</source>
          <target state="translated">공간을 절약하기 위해 &lt;code&gt;anArray&lt;/code&gt; 객체를 세 개의 회색 문자가있는 단일 파란색 객체가 아닌 세 개의 값을 가진 단일 파란색 객체로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8941d57a8e655af45677490b9e8bcf3f00abc03d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;my-directive interpolated=&quot;{{parentProp1}}&quot; twowayBinding=&quot;parentProp2&quot;&amp;gt;&lt;/code&gt; and</source>
          <target state="translated">&lt;code&gt;&amp;lt;my-directive interpolated=&quot;{{parentProp1}}&quot; twowayBinding=&quot;parentProp2&quot;&amp;gt;&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="b352e34f8d41798496797eea2a8bb57e8ed408f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope: true&lt;/code&gt; - the directive creates a new child scope that prototypically inherits from the parent scope.  If more than one directive (on the same DOM element) requests a new scope, only one new child scope is created.  Since we have &quot;normal&quot; prototypal inheritance, this is like ng-include and ng-switch, so be wary of 2-way data binding to parent scope primitives, and child scope hiding/shadowing of parent scope properties.</source>
          <target state="translated">&lt;code&gt;scope: true&lt;/code&gt; 지시문은 부모 범위에서 프로토 타입으로 상속되는 새로운 자식 범위를 만듭니다. 동일한 DOM 요소에 둘 이상의 지시문이 새 범위를 요청하면 하나의 새 하위 범위 만 작성됩니다. 우리는 &quot;일반적인&quot;프로토 타입 상속을 가지고 있기 때문에 이것은 ng-include 및 ng-switch와 유사하므로 부모 범위 프리미티브에 대한 양방향 데이터 바인딩과 부모 범위 속성의 자식 범위 숨기기 / 섀도 잉에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="835213763afd5946d0090cecedf505f83435ec77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope: { ... }&lt;/code&gt; - the directive creates a new isolate/isolated scope.  It does not prototypically inherit.  This is usually your best choice when creating reusable components, since the directive cannot accidentally read or modify the parent scope.  However, such directives often need access to a few parent scope properties.  The object hash is used to set up two-way binding (using '=') or one-way binding (using '@') between the parent scope and the isolate scope.  There is also '&amp;amp;' to bind to parent scope expressions.  So, these all create local scope properties that are derived from the parent scope.
Note that attributes are used to help set up the binding -- you can't just reference parent scope property names in the object hash, you have to use an attribute.  E.g., this won't work if you want to bind to parent property &lt;code&gt;parentProp&lt;/code&gt; in the isolated scope: &lt;code&gt;&amp;lt;div my-directive&amp;gt;&lt;/code&gt; and &lt;code&gt;scope: { localProp: '@parentProp' }&lt;/code&gt;.  An attribute must be used to specify each parent property that the directive wants to bind to: &lt;code&gt;&amp;lt;div my-directive the-Parent-Prop=parentProp&amp;gt;&lt;/code&gt; and &lt;code&gt;scope: { localProp: '@theParentProp' }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scope: { ... }&lt;/code&gt; -지시문은 새로운 분리 / 분리 범위를 작성합니다. 프로토 타입으로 상속하지 않습니다. 지시문이 실수로 상위 범위를 읽거나 수정할 수 없으므로 재사용 가능한 구성 요소를 작성할 때 일반적으로 최선의 선택입니다. 그러나 이러한 지시문은 종종 몇 가지 상위 범위 속성에 액세스해야합니다. 개체 해시는 부모 범위와 격리 범위 사이에 양방향 바인딩 ( '='사용) 또는 단방향 바인딩 ( '@'사용)을 설정하는 데 사용됩니다. 부모 범위 식에 바인딩 할 '&amp;amp;'도 있습니다. 따라서 이들은 모두 부모 범위에서 파생 된 로컬 범위 속성을 만듭니다. 속성은 바인딩을 설정하는 데 도움이됩니다. 객체 해시에서 부모 범위 속성 이름을 참조 할 수없고 속성을 사용해야합니다. 예를 들어 격리 된 범위 &lt;code&gt;&amp;lt;div my-directive&amp;gt;&lt;/code&gt; 및 &lt;code&gt;scope: { localProp: '@parentProp' }&lt;/code&gt; 에서 부모 속성 &lt;code&gt;parentProp&lt;/code&gt; 에 바인딩하려는 경우에는 작동하지 않습니다. 지시문이 바인딩하려는 각 상위 특성을 지정하려면 속성을 사용해야합니다. &lt;code&gt;&amp;lt;div my-directive the-Parent-Prop=parentProp&amp;gt;&lt;/code&gt; 및 &lt;code&gt;scope: { localProp: '@theParentProp' }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63c2b4504aad72d404557032a2480a14ed8d5ff5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transclude: true&lt;/code&gt; - the directive creates a new &quot;transcluded&quot; child scope, which prototypically inherits from the parent scope.  The transcluded and the isolated scope (if any) are siblings -- the $parent property of each scope references the same parent scope.  When a transcluded and an isolate scope both exist, isolate scope property $$nextSibling will reference the transcluded scope.  I'm not aware of any nuances with the transcluded scope.</source>
          <target state="translated">&lt;code&gt;transclude: true&lt;/code&gt; 지시문은 새로운 &quot;번역 된&quot;하위 범위를 작성하며, 이는 상위 범위에서 프로토 타입으로 상속됩니다. 변환 된 범위와 격리 된 범위 (있는 경우)는 형제입니다. 각 범위의 $ parent 속성은 동일한 부모 범위를 참조합니다. 포함 된 범위와 격리 범위가 모두 존재하면 격리 범위 속성 $$ nextSibling은 포함 된 범위를 참조합니다. 나는 포함 된 범위의 뉘앙스를 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="bbff377660b20abffad7a6d418423be860f4fc17" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Check the results.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;결과를 확인하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b15b86c1b80fabe2aabd774598b38aa8e612eb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Also placed on the AngularJS wiki:&lt;/strong&gt;&lt;a href=&quot;https://github.com/angular/angular.js/wiki/Understanding-Scopes&quot;&gt;https://github.com/angular/angular.js/wiki/Understanding-Scopes&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;AngularJS 위키에도 있습니다 :&lt;/strong&gt; &lt;a href=&quot;https://github.com/angular/angular.js/wiki/Understanding-Scopes&quot;&gt;https://github.com/angular/angular.js/wiki/Understanding-Scopes&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0449a09c1348a6a0f43c8e8b64a0a9bf4e617d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;L-o-n-g answer&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;긴 대답&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="1d556e0b5d60936a8ec25e7a4314e53c446c74b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only property reads search the prototype chain, not writes.&lt;/strong&gt; So when you set</source>
          <target state="translated">&lt;strong&gt;속성 만 쓰기가 아닌 프로토 타입 체인을 검색합니다.&lt;/strong&gt; 그래서 당신이 설정할 때</target>
        </trans-unit>
        <trans-unit id="8cfea32fb3dfc1fc810909a8f8a65f811513413f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Quick answer&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;빠른 답변&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e06154976179776fe34c6a025af4919585fcf6bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;there's a subtle read going on within that write operation&lt;/strong&gt; that tries to look up myThing before writing to its prop. So that's why writing to object.properties from the child gets at the parent's objects.</source>
          <target state="translated">&lt;strong&gt;해당 쓰기 작업 내에서 미묘한 읽기가 진행되어&lt;/strong&gt; 소품에 쓰기 전에 myThing을 찾습니다. 따라서 자식에서 object.properties에 쓰는 것이 부모의 개체에 도달하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="13c918f981c68e456ab5bc890ab4c0ec502977dc" translate="yes" xml:space="preserve">
          <source>A child scope normally prototypically inherits from its parent scope, but not always.  One exception to this rule is a directive with &lt;code&gt;scope: { ... }&lt;/code&gt; -- this creates an &quot;isolate&quot; scope that does not prototypically inherit.  This construct is often used when creating a &quot;reusable component&quot; directive.</source>
          <target state="translated">자식 범위는 일반적으로 부모 범위에서 프로토 타입으로 상속되지만 항상 그런 것은 아닙니다. 이 규칙에 대한 한 가지 예외는 &lt;code&gt;scope: { ... }&lt;/code&gt; 지시문입니다 . 이것은 프로토 타입으로 상속되지 않는 &quot;격리 된&quot;범위를 만듭니다. 이 구성은 &quot;재사용 가능한 구성 요소&quot;지시문을 작성할 때 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fe358764520311848c1bc91fb5c17d29cb979406" translate="yes" xml:space="preserve">
          <source>A scope (prototypically) inherits properties from its parent scope.</source>
          <target state="translated">범위는 (시제품 적으로) 부모 범위에서 속성을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="d1d8bffbf559d5536f6500ea0a1d093618886336" translate="yes" xml:space="preserve">
          <source>A scope &lt;em&gt;can&lt;/em&gt; inherit from a parent scope.</source>
          <target state="translated">범위 &lt;em&gt;는&lt;/em&gt; 상위 범위에서 상속 &lt;em&gt;할 수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5ddc19a49f4aeae5b69a08fb93c799e9c9d7b697" translate="yes" xml:space="preserve">
          <source>Add method &quot;changeProps&quot; to a child prototype, which will rewrite &quot;primitive&quot; property value in Child object and change &quot;object.one&quot; value  both in Child and Parent objects</source>
          <target state="translated">자식 프로토 타입에 &quot;changeProps&quot;메소드를 추가하면 자식 개체의 &quot;기본&quot;속성 값을 다시 작성하고 자식 개체와 부모 개체의 &quot;object.one&quot;값을 변경합니다</target>
        </trans-unit>
        <trans-unit id="d81280e6f9424c6ac30ad9caa6dffbfbd01910fa" translate="yes" xml:space="preserve">
          <source>Also, assume the directive does this in its linking function: &lt;code&gt;scope.someIsolateProp = &quot;I'm isolated&quot;&lt;/code&gt;</source>
          <target state="translated">또한 지시문이 연결 함수에서이를 수행한다고 가정합니다. &lt;code&gt;scope.someIsolateProp = &quot;I'm isolated&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a451079fcc06fda672c9171e72986125dacf31a" translate="yes" xml:space="preserve">
          <source>And in our HTML:</source>
          <target state="translated">그리고 우리의 HTML에서 :</target>
        </trans-unit>
        <trans-unit id="a9a0f24354599619f9de8e6d6028a558064ab0cb" translate="yes" xml:space="preserve">
          <source>Angular Scope Inheritance</source>
          <target state="translated">각도 범위 상속</target>
        </trans-unit>
        <trans-unit id="04edf7c89b9f81715bbe002e006477ad0ecd1ebf" translate="yes" xml:space="preserve">
          <source>As for the nuances, scope inheritance is normally straightfoward... until you need &lt;strong&gt;2-way data binding&lt;/strong&gt; (i.e., form elements, ng-model) in the child scope.  Ng-repeat, ng-switch, and ng-include can trip you up if you try to bind to a &lt;strong&gt;primitive&lt;/strong&gt; (e.g., number, string, boolean) in the parent scope from inside the child scope.  It doesn't work the way most people expect it should work.  The child scope gets its own property that hides/shadows the parent property of the same name.  Your workarounds are</source>
          <target state="translated">뉘앙스의 경우 범위 상속은 일반적으로 간단합니다 ... 자식 범위에서 &lt;strong&gt;양방향 데이터 바인딩&lt;/strong&gt; (예 : 양식 요소, ng 모델)이 필요할 때까지. 자식 범위 내에서 부모 범위의 &lt;strong&gt;기본&lt;/strong&gt; (예 : 숫자, 문자열, 부울)에 바인딩하려고하면 Ng-repeat, ng-switch 및 ng-include가 트립 될 수 있습니다. 대부분의 사람들이 예상대로 작동하지 않습니다. 자식 범위는 같은 이름의 부모 속성을 숨기거나 가리는 자체 속성을 가져옵니다. 해결 방법은</target>
        </trans-unit>
        <trans-unit id="4ed249b8cae7519efef1d54e83355e59137f1469" translate="yes" xml:space="preserve">
          <source>Assign child prototype (Make child prototype inherit from parent prototype)</source>
          <target state="translated">자식 프로토 타입 할당 (자식 프로토 타입을 부모 프로토 타입에서 상속하게 함)</target>
        </trans-unit>
        <trans-unit id="2996f5993b5b26bf797d1e78ed5e38759f07c7bb" translate="yes" xml:space="preserve">
          <source>Assign proper &quot;Child&quot; prototype constructor</source>
          <target state="translated">적절한 &quot;자식&quot;프로토 타입 생성자 할당</target>
        </trans-unit>
        <trans-unit id="b5081c09c76c448c8f28cf7a987c299007621686" translate="yes" xml:space="preserve">
          <source>Call Child (son) changeProps method</source>
          <target state="translated">하위 (아들) changeProps 메소드 호출</target>
        </trans-unit>
        <trans-unit id="8a364885c600d88f272a42d908f8846ef75358c2" translate="yes" xml:space="preserve">
          <source>Child primitive property changed (rewritten)</source>
          <target state="translated">자식 기본 속성이 변경됨 (재 작성 됨)</target>
        </trans-unit>
        <trans-unit id="1ffec34742859a8b858a2042f314ba6bb9712a26" translate="yes" xml:space="preserve">
          <source>Create &quot;Child&quot; object function</source>
          <target state="translated">&quot;자식&quot;객체 함수 생성</target>
        </trans-unit>
        <trans-unit id="d05ba29982ee4adb0294fdfc09f8849d4dae68fb" translate="yes" xml:space="preserve">
          <source>Diagrams were generated with &lt;a href=&quot;/questions/tagged/graphviz&quot;&gt;graphviz&lt;/a&gt; &quot;*.dot&quot; files, which are on &lt;a href=&quot;https://github.com/mrajcok/angularjs-prototypal-inheritance-diagrams&quot;&gt;github&lt;/a&gt;. Tim Caswell's &quot;&lt;a href=&quot;http://howtonode.org/object-graphs&quot;&gt;Learning JavaScript with Object Graphs&lt;/a&gt;&quot; was the inspiration for using GraphViz for the diagrams.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mrajcok/angularjs-prototypal-inheritance-diagrams&quot;&gt;github에&lt;/a&gt; 있는 &lt;a href=&quot;/questions/tagged/graphviz&quot;&gt;graphviz&lt;/a&gt; &quot;* .dot&quot;파일로 다이어그램이 생성되었습니다. Tim Caswell의 &quot; &lt;a href=&quot;http://howtonode.org/object-graphs&quot;&gt;오브젝트 그래프로 JavaScript 학습&lt;/a&gt; &quot;은 다이어그램에 GraphViz를 사용하는 데 영감을주었습니다.</target>
        </trans-unit>
        <trans-unit id="224f881f49f35e408bbcfa7028d153590b37fec0" translate="yes" xml:space="preserve">
          <source>Each ng-include generates a new child scope, which prototypically inherits from the parent scope.</source>
          <target state="translated">각 ng-include는 새 하위 범위를 생성하며,이 하위 범위는 부모 범위에서 프로토 타입으로 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="f0f83f9d583818dd44d3f9d04d8204b2b0d352a8" translate="yes" xml:space="preserve">
          <source>First we create &quot;Parent&quot; object function</source>
          <target state="translated">먼저 &quot;부모&quot;객체 함수를 만듭니다</target>
        </trans-unit>
        <trans-unit id="76003c9c8e1d358158e7998b80eba506f2cddf5c" translate="yes" xml:space="preserve">
          <source>For all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via properties $parent and $$childHead and $$childTail.</source>
          <target state="translated">프로토 타입이든 아니든 모든 범위에 대해 Angular는 항상 $ parent 및 $$ childHead 및 $$ childTail 속성을 통해 부모-자식 관계 (예 : 계층)를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="d68a226c6237d24500cc2414bd86f74041060caa" translate="yes" xml:space="preserve">
          <source>For all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via scope properties $parent, $$childHead and $$childTail.  I normally don't show these scope properties in the diagrams.</source>
          <target state="translated">모든 범위 (prototypal 또는 not)에 대해 Angular는 범위 속성 $ parent, $$ childHead 및 $$ childTail을 통해 항상 부모-자식 관계 (예 : 계층 구조)를 추적합니다. 일반적으로 다이어그램에 이러한 범위 속성을 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b883a122a0ff99a0160d4dd55f990d7e4e400f28" translate="yes" xml:space="preserve">
          <source>For each item/iteration, ng-repeat creates a new scope, which prototypically inherits from the parent scope, &lt;strong&gt;but it also assigns the item's value to a new property on the new child scope&lt;/strong&gt;.  (The name of the new property is the loop variable's name.)  Here's what the Angular source code for ng-repeat actually is:</source>
          <target state="translated">각 항목 / 반복에 대해 ng-repeat는 새 범위를 작성합니다.이 범위는 부모 범위에서 프로토 타입으로 상속 &lt;strong&gt;되지만 항목 값을 새 하위 범위의 새 특성에 지정합니다&lt;/strong&gt; . (새 속성의 이름은 루프 변수의 이름입니다.) ng-repeat의 Angular 소스 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d22a4e3b74d54cfd3eda148ac16ef352c95fcccd" translate="yes" xml:space="preserve">
          <source>For more information on isolate scopes see &lt;a href=&quot;http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/&quot;&gt;http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/&lt;/a&gt;</source>
          <target state="translated">분리 범위에 대한 자세한 내용은 &lt;a href=&quot;http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/&quot;&gt;http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5f28c07f801f81133a48ea659f76557041efbb55" translate="yes" xml:space="preserve">
          <source>For scenarios where form elements are not involved, another solution is to define a function on the parent scope to modify the primitive.  Then ensure the child always calls this function, which will be available to the child scope due to prototypal inheritance. E.g.,</source>
          <target state="translated">양식 요소가 관련되지 않은 시나리오의 경우 다른 솔루션은 상위 범위에서 함수를 정의하여 기본 요소를 수정하는 것입니다. 그런 다음 자식이 항상이 함수를 호출하는지 확인하십시오.이 함수는 프로토 타입 상속으로 인해 자식 범위에서 사용할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="39de2c52b338823dcf28717c0da794fd864f6e31" translate="yes" xml:space="preserve">
          <source>For the picture below we have</source>
          <target state="translated">아래 그림은</target>
        </trans-unit>
        <trans-unit id="25a4a3b828e0fdd290235d69c7a56465278b9b20" translate="yes" xml:space="preserve">
          <source>For the picture below, assume the same directive as above with this addition: &lt;code&gt;transclude: true&lt;/code&gt;</source>
          <target state="translated">아래 그림의 경우 위와 같은 지시문을 추가하여 다음과 같이 가정하십시오. &lt;code&gt;transclude: true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a17ac04579a8099173830d945d577b08efd0e95c" translate="yes" xml:space="preserve">
          <source>Having a '.' in your models will ensure that prototypal inheritance is in play. So, use</source>
          <target state="translated">가있는 '.' 모델에서 프로토 타입 상속이 작동하는지 확인합니다. 따라서 사용</target>
        </trans-unit>
        <trans-unit id="cf13bf79e05888c8ce47a05548ac7b8463808a88" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;http://jsfiddle.net/mrajcok/jNxyE/&quot;&gt;sample fiddle&lt;/a&gt; that uses this &quot;parent function&quot; approach.  (The fiddle was written as part of this answer: &lt;a href=&quot;https://stackoverflow.com/a/14104318/215945&quot;&gt;https://stackoverflow.com/a/14104318/215945&lt;/a&gt;.)</source>
          <target state="translated">다음은이 &quot;부모 함수&quot;접근 방식을 사용하는 &lt;a href=&quot;http://jsfiddle.net/mrajcok/jNxyE/&quot;&gt;샘플 바이올린&lt;/a&gt; 입니다. (바이들은이 답변의 일부로 작성되었습니다 : &lt;a href=&quot;https://stackoverflow.com/a/14104318/215945&quot;&gt;https://stackoverflow.com/a/14104318/215945&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="78d9d8c7814ea8c0bc54dc3db2d80fadc8541048" translate="yes" xml:space="preserve">
          <source>I in no way want to compete with Mark's answer, but just wanted to highlight the piece that finally made everything click as someone new to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;Javascript inheritance and its prototype chain&lt;/a&gt;.</source>
          <target state="translated">Mark의 답변과 경쟁하고 싶지는 않지만 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;Javascript 상속 및 프로토 타입 체인에 익숙하지 않은&lt;/a&gt; 모든 사람을 마침내 클릭하게 만든 부분을 강조하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="343a19234efc27bcc15d07110b0015da8503ed16" translate="yes" xml:space="preserve">
          <source>I would like to add an example of prototypical inheritance with javascript to @Scott Driscoll answer. We'll be using classical inheritance pattern with Object.create() which is a part of  EcmaScript 5 specification.</source>
          <target state="translated">@Scott Driscoll 답변에 javascript를 사용한 프로토 타입 상속 예제를 추가하고 싶습니다. 우리는 EcmaScript 5 사양의 일부인 Object.create ()와 함께 고전적인 상속 패턴을 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="802781ec18af22b8b318435ab4f3e32318e26ccc" translate="yes" xml:space="preserve">
          <source>If item is a primitive (as in myArrayOfPrimitives), essentially a copy of the value is assigned to the new child scope property.  Changing the child scope property's value (i.e., using ng-model, hence child scope &lt;code&gt;num&lt;/code&gt;) does &lt;strong&gt;not&lt;/strong&gt; change the array the parent scope references.  So in the first ng-repeat above, each child scope gets a &lt;code&gt;num&lt;/code&gt; property that is independent of the myArrayOfPrimitives array:</source>
          <target state="translated">item이 기본 요소 인 경우 (myArrayOfPrimitives에서와 같이) 기본적으로 값의 사본이 새 하위 범위 특성에 지정됩니다. 자식 범위 속성 값을 변경하면 (즉, ng-model 사용, 따라서 자식 범위 &lt;code&gt;num&lt;/code&gt; ) 부모 범위가 참조하는 배열은 변경되지 &lt;strong&gt;않습니다&lt;/strong&gt; . 따라서 위의 첫 번째 ng-repeat에서 각 자식 범위는 myArrayOfPrimitives 배열과 독립적 인 &lt;code&gt;num&lt;/code&gt; 속성을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4866d5c72997fb88595861f951b716f4b48a2c00" translate="yes" xml:space="preserve">
          <source>If we read childScope.propertyX, and childScope has propertyX, then the prototype chain is not consulted.</source>
          <target state="translated">childScope.propertyX를 읽고 childScope에 propertyX가 있으면 프로토 타입 체인을 참조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="557b0df6a8ad1c719a17070ca1480aff70f73067" translate="yes" xml:space="preserve">
          <source>If we set childScope.propertyX, the prototype chain is not consulted.</source>
          <target state="translated">childScope.propertyX를 설정하면 프로토 타입 체인을 참조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d680be6d3dd2682e10431ab13158d61b069cf24d" translate="yes" xml:space="preserve">
          <source>If we try to access a property defined on the parentScope from the child scope, JavaScript will first look in the child scope, not find the property, then look in the inherited scope, and find the property.  (If it didn't find the property in the parentScope, it would continue up the prototype chain... all the way up to the root scope). So, these are all true:</source>
          <target state="translated">자식 범위에서 parentScope에 정의 된 속성에 액세스하려고하면 JavaScript는 먼저 자식 범위를 확인하고 속성을 찾은 다음 상속 된 범위를 찾고 속성을 찾습니다. (parentScope에서 속성을 찾지 못하면 루트 체인까지 프로토 타입 체인을 계속합니다). 그래서 이것들은 모두 사실입니다 :</target>
        </trans-unit>
        <trans-unit id="4aa54311fd9a9a8128dded66c00d21f4fcfb64e3" translate="yes" xml:space="preserve">
          <source>Initiate Parent (dad) and Child (son) objects.</source>
          <target state="translated">부모 (아빠) 및 자식 (아들) 개체를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="19e47d935ce82b089f07b281873a3517222fa41b" translate="yes" xml:space="preserve">
          <source>Isolate scope's &lt;code&gt;__proto__&lt;/code&gt; references Object.
Isolate scope's $parent references the parent scope, so although it is isolated and doesn't inherit prototypically from the parent scope, it is still a child scope.</source>
          <target state="translated">범위의 &lt;code&gt;__proto__&lt;/code&gt; 참조 객체를 분리합니다. 범위의 $ parent를 격리하면 부모 범위가 참조되므로 격리되고 부모 범위에서 프로토 타입으로 상속되지 않더라도 여전히 자식 범위입니다.</target>
        </trans-unit>
        <trans-unit id="a1cb23b18b0ca50c3a0a704b077fee50b3d6f174" translate="yes" xml:space="preserve">
          <source>It doesn't look up the chain, but when you set</source>
          <target state="translated">체인을 찾지 않지만 설정하면</target>
        </trans-unit>
        <trans-unit id="b0be3f5d2d9159cde42e618e5abe2a242f9b35b2" translate="yes" xml:space="preserve">
          <source>It is important to first have a solid understanding of prototypal inheritance, especially if you are coming from a server-side background and you are more familiar with class-ical inheritance.  So let's review that first.</source>
          <target state="translated">프로토 타입 상속에 대해 확실히 이해하는 것이 중요합니다. 특히 서버 측 배경에서 왔으며 클래스 논리 상속에 더 익숙한 경우 특히 그렇습니다. 먼저 검토하겠습니다.</target>
        </trans-unit>
        <trans-unit id="1851c59bc3075bb17267a2a94b26d1a8cbcc1f23" translate="yes" xml:space="preserve">
          <source>JavaScript Prototypal Inheritance</source>
          <target state="translated">자바 스크립트 프로토 타입 상속</target>
        </trans-unit>
        <trans-unit id="81e79922be316c42d992eacbd258ccdc9e61e020" translate="yes" xml:space="preserve">
          <source>More info on Object.create here &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create&lt;/a&gt;</source>
          <target state="translated">Object.create에 대한 자세한 내용은 여기 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17b26fc30b1512c9e24a72c572b1f77391a20540" translate="yes" xml:space="preserve">
          <source>Nesting controllers using ng-controller results in normal prototypal inheritance, just like ng-include and ng-switch, so the same techniques apply.
However, &quot;it is considered bad form for two controllers to share information via $scope inheritance&quot; -- &lt;a href=&quot;http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/&quot;&gt;http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/&lt;/a&gt;
A service should be used to share data between controllers instead.</source>
          <target state="translated">ng-controller를 사용하는 중첩 컨트롤러는 ng-include 및 ng-switch와 마찬가지로 일반적인 프로토 타입 상속을 수행하므로 동일한 기술이 적용됩니다. 그러나 &quot;두 개의 컨트롤러가 $ scope 상속을 통해 정보를 공유하는 것은 잘못된 형식으로 간주됩니다&quot; &lt;a href=&quot;http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/&quot;&gt;-http&lt;/a&gt; : //onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/ 서비스는 데이터를 공유하는 데 사용해야합니다 대신 컨트롤러.</target>
        </trans-unit>
        <trans-unit id="bdfea434bdc407230ae5f60034419d37fb129edd" translate="yes" xml:space="preserve">
          <source>New AngularJS developers often do not realize that &lt;code&gt;ng-repeat&lt;/code&gt;, &lt;code&gt;ng-switch&lt;/code&gt;, &lt;code&gt;ng-view&lt;/code&gt;, &lt;code&gt;ng-include&lt;/code&gt; and &lt;code&gt;ng-if&lt;/code&gt; all create new child scopes, so the problem often shows up when these directives are involved. (See &lt;a href=&quot;http://plnkr.co/edit/zZfUQN?p=preview&quot;&gt;this example&lt;/a&gt; for a quick illustration of the problem.)</source>
          <target state="translated">새로운 AngularJS 개발자들은 종종 &lt;code&gt;ng-repeat&lt;/code&gt; , &lt;code&gt;ng-switch&lt;/code&gt; , &lt;code&gt;ng-view&lt;/code&gt; , &lt;code&gt;ng-include&lt;/code&gt; 및 &lt;code&gt;ng-if&lt;/code&gt; 모두 새로운 자식 범위를 생성한다는 것을 인식하지 못하기 때문에 이러한 지시어가 관련 될 때 종종 문제가 나타납니다. (문제에 대한 간략한 설명은 &lt;a href=&quot;http://plnkr.co/edit/zZfUQN?p=preview&quot;&gt;이 예&lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="3c51eaa7a8ebfbc7717269ec1e43a6a1a4e5edd9" translate="yes" xml:space="preserve">
          <source>Ng-repeat works a little differently.  Suppose we have in our controller:</source>
          <target state="translated">Ng-repeat는 약간 다르게 작동합니다. 컨트롤러에 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="c7ee5ad42887cfc364ac2ae6c87e55321fd13ccc" translate="yes" xml:space="preserve">
          <source>Note, by default, directives do not create new scope -- i.e., the default is &lt;code&gt;scope: false&lt;/code&gt;.</source>
          <target state="translated">기본적으로 지시문은 새 범위를 만들지 않습니다. 즉, 기본값은 &lt;code&gt;scope: false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c221036d1055470cf610288db1253caab6ef6104" translate="yes" xml:space="preserve">
          <source>One last scenario:</source>
          <target state="translated">마지막 시나리오 :</target>
        </trans-unit>
        <trans-unit id="e0f4a686f88d43bf71f098468123a0d1b2480522" translate="yes" xml:space="preserve">
          <source>Parent and Child object.one properties changed</source>
          <target state="translated">부모 및 자식 개체 하나의 속성이 변경됨</target>
        </trans-unit>
        <trans-unit id="f1755d0d23e3e1b31d2d35a7c30e78c25e37675e" translate="yes" xml:space="preserve">
          <source>Parent primitive property did not change</source>
          <target state="translated">부모 기본 속성이 변경되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="33e340f444883767e95f1138224ae3c363df1354" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/a/13782671/215945&quot;&gt;https://stackoverflow.com/a/13782671/215945&lt;/a&gt; and &lt;a href=&quot;https://github.com/angular/angular.js/issues/1267&quot;&gt;https://github.com/angular/angular.js/issues/1267&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/13782671/215945&quot;&gt;https://stackoverflow.com/a/13782671/215945&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/angular/angular.js/issues/1267&quot;&gt;https://github.com/angular/angular.js/issues/1267&lt;/a&gt; 도 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fec6ce6579046ec5e7f88479a74428b8d21a89a9" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/questions/12405005/angularjs-bind-scope-of-a-switch-case/12414410&quot;&gt;AngularJS, bind scope of a switch-case?&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/12405005/angularjs-bind-scope-of-a-switch-case/12414410&quot;&gt;스위치 케이스의 바인드 범위 인 AngularJS&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e719ff46b30c8a375d9fec4a2f353bfcc4f0efc2" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/questions/13714884/difficulty-with-ng-model-ng-repeat-and-inputs&quot;&gt;Difficulty with ng-model, ng-repeat, and inputs&lt;/a&gt; and 
&lt;a href=&quot;https://stackoverflow.com/a/13782671/215945&quot;&gt;https://stackoverflow.com/a/13782671/215945&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/13714884/difficulty-with-ng-model-ng-repeat-and-inputs&quot;&gt;ng-model, ng-repeat 및 입력&lt;/a&gt; 및 &lt;a href=&quot;https://stackoverflow.com/a/13782671/215945&quot;&gt;https://stackoverflow.com/a/13782671/215945의&lt;/a&gt; 난이도 참조</target>
        </trans-unit>
        <trans-unit id="9a4b9917ddd787e8d62b82f045df5b9f2c17092e" translate="yes" xml:space="preserve">
          <source>So, does a child scope always prototypically inherit from its parent scope? Are there exceptions? When it does inherit, is it always normal JavaScript prototypal inheritance?</source>
          <target state="translated">따라서 자식 범위는 항상 부모 범위에서 프로토 타입으로 상속됩니까? 예외가 있습니까? 상속 할 때 항상 정상적인 JavaScript 프로토 타입 상속입니까?</target>
        </trans-unit>
        <trans-unit id="9e6369804c78f7f810d1a2f16ee7cb0a8e521992" translate="yes" xml:space="preserve">
          <source>So, if item is an object, a reference to the original object (not a copy) is assigned to the new child scope property.  Changing the child scope property's value (i.e., using ng-model, hence &lt;code&gt;obj.num&lt;/code&gt;) &lt;strong&gt;does&lt;/strong&gt; change the object the parent scope references.  So in the second ng-repeat above, we have:</source>
          <target state="translated">따라서 item이 객체 인 경우 사본이 아닌 원본 객체에 대한 참조가 새 자식 범위 속성에 할당됩니다. 자식 범위 속성 값을 변경하면 (즉, ng-model을 사용하여 &lt;code&gt;obj.num&lt;/code&gt; ) 부모 범위가 참조하는 개체 &lt;strong&gt;가&lt;/strong&gt; 변경됩니다. 위의 두 번째 ng-repeat에서 우리는 다음을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="cc4d3539063b02aa54ad5dda83c79896a3067f88" translate="yes" xml:space="preserve">
          <source>Suppose parentScope has properties aString, aNumber, anArray, anObject, and aFunction.  If childScope prototypically inherits from parentScope, we have:</source>
          <target state="translated">parentScope에 속성 aString, aNumber, anArray, anObject 및 aFunction이 있다고 가정하십시오. childScope가 프로토 타입으로 parentScope에서 상속되는 경우 다음이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e425db46930aa754cb8074fc1c831cb164b51bd2" translate="yes" xml:space="preserve">
          <source>Suppose we have in our controller:</source>
          <target state="translated">컨트롤러에 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="a1633172dfdf4a530f7d467aceec66485f144710" translate="yes" xml:space="preserve">
          <source>Suppose we then do this:</source>
          <target state="translated">그런 다음이 작업을 수행한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="bba48911b62c99d44cbc4f4088dedb4a1a4ee050" translate="yes" xml:space="preserve">
          <source>Takeaways:</source>
          <target state="translated">Takeaways:</target>
        </trans-unit>
        <trans-unit id="2cb274acb022d6adbcd46abc2c49043f6a50a791" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.angularjs.org/api/ng.$rootScope.Scope&quot;&gt;API Reference Scope page&lt;/a&gt; says:</source>
          <target state="translated">&lt;a href=&quot;http://docs.angularjs.org/api/ng.$rootScope.Scope&quot;&gt;API 참조 범위 페이지&lt;/a&gt; 는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="6ece9a032e06e6d7a13d6f923e60f3c3759a8bf2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.angularjs.org/guide/scope&quot;&gt;Developer Guide Scope page&lt;/a&gt; says:</source>
          <target state="translated">&lt;a href=&quot;http://docs.angularjs.org/guide/scope&quot;&gt;개발자 안내서 범위 페이지&lt;/a&gt; 는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="1effa6eab1a807614c56859066cc710880afa491" translate="yes" xml:space="preserve">
          <source>The contenders:</source>
          <target state="translated">경쟁자 :</target>
        </trans-unit>
        <trans-unit id="5a245f54b8cc6be3fdde1e33a7363c01930e01fe" translate="yes" xml:space="preserve">
          <source>The following create new scopes, and inherit prototypically: ng-repeat, ng-include, ng-switch, ng-controller, directive with &lt;code&gt;scope: true&lt;/code&gt;, directive with &lt;code&gt;transclude: true&lt;/code&gt;.</source>
          <target state="translated">다음은 새 범위를 만들고 프로토 타입으로 상속합니다. ng-repeat, ng-include, ng-switch, ng-controller, &lt;code&gt;scope: true&lt;/code&gt; 지시문 : true , &lt;code&gt;transclude: true&lt;/code&gt; 가 있는 지시문 : true .</target>
        </trans-unit>
        <trans-unit id="a8cbb9552e324fab0129a77cc1ae823eb0817c84" translate="yes" xml:space="preserve">
          <source>The following creates a new scope which does not inherit prototypically: directive with &lt;code&gt;scope: { ... }&lt;/code&gt;.  This creates an &quot;isolate&quot; scope instead.</source>
          <target state="translated">다음은 프로토 타입을 상속하지 않는 새 범위를 작성합니다. 지시문이있는 지시문 &lt;code&gt;scope: { ... }&lt;/code&gt; . 대신 &quot;격리&quot;범위가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e3193a8d2f9764731db9796b762232331fe4c06e" translate="yes" xml:space="preserve">
          <source>The prototype chain is consulted because the objects (anArray and anObject) are not found in the childScope.  The objects are found in the parentScope, and the property values are updated on the original objects.  No new properties are added to the childScope;  no new objects are created.  (Note that in JavaScript arrays and functions are also objects.)</source>
          <target state="translated">오브젝트 (anArray 및 anObject)가 childScope에 없으므로 프로토 타입 체인을 참조하십시오. 개체는 parentScope에 있으며 속성 값은 원래 개체에서 업데이트됩니다. childScope에 새 속성이 추가되지 않습니다. 새로운 객체가 생성되지 않습니다. (자바 스크립트에서 배열과 함수도 객체입니다.)</target>
        </trans-unit>
        <trans-unit id="ddc297ce30d1c5e731cb81f6c86632fa1dfaa612" translate="yes" xml:space="preserve">
          <source>The prototype chain is not consulted, and a new aString property is added to the childScope.  &lt;strong&gt;This new property hides/shadows the parentScope property with the same name.&lt;/strong&gt;  This will become very important when we discuss ng-repeat and ng-include below.</source>
          <target state="translated">프로토 타입 체인은 참조되지 않으며 새로운 aString 속성이 childScope에 추가됩니다. &lt;strong&gt;이 새로운 속성은 동일한 이름으로 parentScope 속성을 숨기거나 그림자로 만듭니다.&lt;/strong&gt; 이것은 ng-repeat와 ng-include에 대해 아래에서 논의 할 때 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="942d42a24d1cc10fb1ea338258bb011bcb714618" translate="yes" xml:space="preserve">
          <source>The prototype chain is not consulted, and child scope gets two new object properties that hide/shadow the parentScope object properties with the same names.</source>
          <target state="translated">프로토 타입 체인은 참조되지 않으며 자식 범위는 동일한 이름을 가진 parentScope 개체 속성을 숨기거나 음영 처리하는 두 가지 새로운 개체 속성을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5872b3ca634f4e1f14cb4befbf0b13a06e096db5" translate="yes" xml:space="preserve">
          <source>Then add a prototype to &quot;Parent&quot; object function</source>
          <target state="translated">그런 다음 &quot;부모&quot;개체 함수에 프로토 타입을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="35f7fbf3fa1d3a4b9cdfa29fa721275206b27d50" translate="yes" xml:space="preserve">
          <source>There are four types of scopes:</source>
          <target state="translated">범위에는 네 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58fda558452d6dbbc530387b7a71b1f7218fc6f2" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;http://jsfiddle.net/mrajcok/7g3QM/&quot;&gt;fiddle&lt;/a&gt; has a &lt;code&gt;showScope()&lt;/code&gt; function that can be used to examine an isolate and transcluded scope.  See the instructions in the comments in the fiddle.</source>
          <target state="translated">이 &lt;a href=&quot;http://jsfiddle.net/mrajcok/7g3QM/&quot;&gt;바이올린&lt;/a&gt; 에는 &lt;code&gt;showScope()&lt;/code&gt; 함수가있어 격리 및 포함 된 범위를 검사하는 데 사용할 수 있습니다. 바이올린 주석의 지침을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b6a5000175f5778b88f085776bf0da1c77aa040" translate="yes" xml:space="preserve">
          <source>This issue with primitives can be easily avoided by following the &quot;best practice&quot; of &lt;a href=&quot;http://www.youtube.com/watch?v=ZhfUv0spHCY&amp;amp;feature=youtu.be&amp;amp;t=30m&quot;&gt;always have a '.' in your ng-models&lt;/a&gt; &amp;ndash; watch 3 minutes worth. Misko demonstrates the primitive binding issue with &lt;code&gt;ng-switch&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.youtube.com/watch?v=ZhfUv0spHCY&amp;amp;feature=youtu.be&amp;amp;t=30m&quot;&gt;항상 '.'을 갖는&lt;/a&gt; &quot;모범 사례&quot;를 따르면 프리미티브의이 문제를 쉽게 피할 수 있습니다 . 당신의 ng-models에서 &amp;ndash; 3 분 가치가있는 것을보십시오. Misko는 &lt;code&gt;ng-switch&lt;/code&gt; 의 기본 바인딩 문제를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4c0202c6ca940503ffce3f2fa915f6ef7f7755ae" translate="yes" xml:space="preserve">
          <source>This ng-repeat will not work (like you want/expect it to).  Typing into the textboxes changes the values in the gray boxes, which are only visible in the child scopes.  What we want is for the inputs to affect the myArrayOfPrimitives array, not a child scope primitive property.  To accomplish this, we need to change the model to be an array of objects.</source>
          <target state="translated">이 ng-repeat는 작동하지 않습니다 (원하는대로). 텍스트 상자에 입력하면 회색 상자의 값이 변경되어 하위 범위에서만 볼 수 있습니다. 우리가 원하는 것은 입력이 자식 범위 기본 속성이 아닌 myArrayOfPrimitives 배열에 영향을 미치는 것입니다. 이를 위해서는 모델을 객체 배열로 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="b1a9027cd710b57f1f8bc341338c25f8f6fcef46" translate="yes" xml:space="preserve">
          <source>This works as expected.  Typing into the textboxes changes the values in the gray boxes, which are visible to both the child and parent scopes.</source>
          <target state="translated">이것은 예상대로 작동합니다. 텍스트 상자에 입력하면 회색 상자의 값이 변경되어 자식 범위와 부모 범위 모두에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2735a892bde0fac77b60fc1ad9ecb60ccdef800d" translate="yes" xml:space="preserve">
          <source>Typing (say, &quot;22&quot;) into this input textbox does not result in a new child property.  The model is now bound to a property of the parent scope (because $parent is a child scope property that references the parent scope).</source>
          <target state="translated">이 입력 텍스트 상자에 입력 (예 : &quot;22&quot;)해도 새로운 자식 속성이 생성되지 않습니다. 모델은 이제 부모 범위의 속성에 바인딩됩니다 ($ parent는 부모 범위를 참조하는 자식 범위 속성이므로).</target>
        </trans-unit>
        <trans-unit id="47d0d3a86ac79a9f76da91b2fd9f3a8aedb85fae" translate="yes" xml:space="preserve">
          <source>Typing (say, &quot;77&quot;) into the first input textbox causes the child scope to get a new &lt;code&gt;myPrimitive&lt;/code&gt; scope property that hides/shadows the parent scope property of the same name.  This is probably not what you want/expect.</source>
          <target state="translated">첫 번째 입력 텍스트 상자에 입력 (예 : &quot;77&quot;)하면 하위 범위가 동일한 이름의 상위 범위 속성을 숨기거나 음영 처리하는 새로운 &lt;code&gt;myPrimitive&lt;/code&gt; 범위 속성을 가져옵니다. 이것은 아마도 당신이 원하거나 기대하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c3ad716f56bb492e391fbe53da39e07eb8b12282" translate="yes" xml:space="preserve">
          <source>Typing (say, &quot;99&quot;) into the second input textbox does not result in a new child property.  Because tpl2.html binds the model to an object property, prototypal inheritance kicks in when the ngModel looks for object myObject -- it finds it in the parent scope.</source>
          <target state="translated">두 번째 입력 텍스트 상자에 입력 (예 : &quot;99&quot;)해도 새 자식 속성이 생성되지 않습니다. tpl2.html은 모델을 객체 속성에 바인딩하기 때문에 ngModel이 객체 myObject를 찾을 때 프로토 타입 상속이 시작됩니다. 상위 범위에서 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ab8ed7a4dd8872f800f71c44f823cffbdd129693" translate="yes" xml:space="preserve">
          <source>We can rewrite the first template to use $parent, if we don't want to change our model from a primitive to an object:</source>
          <target state="translated">모델을 기본에서 객체로 변경하지 않으려는 경우 $ parent를 사용하도록 첫 번째 템플릿을 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7625c1d4a0c7673afd934025f8f220fcfab5353d" translate="yes" xml:space="preserve">
          <source>We deleted the childScope property first, then when we try to access the property again, the prototype chain is consulted.</source>
          <target state="translated">childScope 속성을 먼저 삭제 한 다음 속성에 다시 액세스하려고하면 프로토 타입 체인을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="2bc2e06693640b04d006a3e5bfec8b61c441b22a" translate="yes" xml:space="preserve">
          <source>What are the nuances of scope prototypal / prototypical inheritance in AngularJS</source>
          <target state="translated">AngularJS에서 스코프 프로토 타입 / 프로토 타입 상속의 뉘앙스는 무엇입니까</target>
        </trans-unit>
        <trans-unit id="1c8fa7a6cb664f88272907fcc27cd0145f211d78" translate="yes" xml:space="preserve">
          <source>Working example here &lt;a href=&quot;http://jsbin.com/xexurukiso/1/edit/&quot;&gt;http://jsbin.com/xexurukiso/1/edit/&lt;/a&gt;</source>
          <target state="translated">실제 예제는 &lt;a href=&quot;http://jsbin.com/xexurukiso/1/edit/&quot;&gt;http://jsbin.com/xexurukiso/1/edit/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d0dec12c98280606d2778a4bcb1abfb0e7f8d0c" translate="yes" xml:space="preserve">
          <source>default (&lt;code&gt;scope: false&lt;/code&gt;) - the directive does not create a new scope, so there is no inheritance here.  This is easy, but also dangerous because, e.g., a directive might think it is creating a new property on the scope, when in fact it is clobbering an existing property.  This is not a good choice for writing directives that are intended as reusable components.</source>
          <target state="translated">default ( &lt;code&gt;scope: false&lt;/code&gt; )-지시문이 새 범위를 작성하지 않으므로 여기에는 상속이 없습니다. 예를 들어 지시어가 실제로 기존 속성을 방해 할 때 스코프에서 새로운 속성을 생성한다고 생각할 수 있기 때문에 이것은 쉽지만 위험합니다. 재사용 가능한 구성 요소로 사용되는 지시문 작성에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba1842f28a57fe23a90d2efec05d224744c39651" translate="yes" xml:space="preserve">
          <source>define a function on the parent scope, and call it from the child (not always possible)</source>
          <target state="translated">부모 범위에서 함수를 정의하고 자식에서 호출하십시오 (항상 가능한 것은 아님)</target>
        </trans-unit>
        <trans-unit id="27ea3d35983ed18a7ab56325d8423ae0f39bbc5b" translate="yes" xml:space="preserve">
          <source>define objects in the parent for your model, then reference a property of that object  in the child:  parentObj.someProp</source>
          <target state="translated">모델의 부모에서 개체를 정의한 다음 자식에서 해당 개체의 속성을 참조하십시오 : parentObj.someProp</target>
        </trans-unit>
        <trans-unit id="5b41ba2601e37104d54d7666ca68c4f5e11a1c4c" translate="yes" xml:space="preserve">
          <source>directives</source>
          <target state="translated">directives</target>
        </trans-unit>
        <trans-unit id="f4549b6f57b926059ceb24f113afc3e54afffa58" translate="yes" xml:space="preserve">
          <source>isolate scope -- directive with &lt;code&gt;scope: {...}&lt;/code&gt;.  This one is not prototypal, but '=', '@', and '&amp;amp;' provide a mechanism to access parent scope properties, via attributes.</source>
          <target state="translated">격리 범위- &lt;code&gt;scope: {...}&lt;/code&gt; 지시문. 이것은 프로토 타입이 아니지만 '=', '@'및 '&amp;amp;'는 속성을 통해 부모 범위 속성에 액세스하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c942ad93a5be36ba73a8752c3c44b6797b79ac69" translate="yes" xml:space="preserve">
          <source>ng-controller</source>
          <target state="translated">ng-controller</target>
        </trans-unit>
        <trans-unit id="19a68c5679f612b19da24843d5d39d5c934d28f4" translate="yes" xml:space="preserve">
          <source>ng-include</source>
          <target state="translated">ng-include</target>
        </trans-unit>
        <trans-unit id="0e45397994cf73af09c27e90f79ceb5606ed2a7d" translate="yes" xml:space="preserve">
          <source>ng-repeat</source>
          <target state="translated">ng-repeat</target>
        </trans-unit>
        <trans-unit id="18b8f4fb887d618b0516df6042f780fb3da97f38" translate="yes" xml:space="preserve">
          <source>ng-switch</source>
          <target state="translated">ng-switch</target>
        </trans-unit>
        <trans-unit id="4e8683d937e4339a8c800fa795e3f1be28867631" translate="yes" xml:space="preserve">
          <source>ng-switch scope inheritance works just like ng-include.  So if you need 2-way data binding to a primitive in the parent scope, use $parent, or change the model to be an object and then bind to a property of that object.  This will avoid child scope hiding/shadowing of parent scope properties.</source>
          <target state="translated">ng- 스위치 범위 상속은 ng-include와 동일하게 작동합니다. 따라서 부모 범위의 프리미티브에 양방향 데이터 바인딩이 필요한 경우 $ parent를 사용하거나 모델을 객체로 변경 한 다음 해당 객체의 속성에 바인딩합니다. 이렇게하면 자식 범위 숨기기 / 부모 범위 속성이 숨겨지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ab5ad0e9b0dd449ed7192dc1a78c8e697023091" translate="yes" xml:space="preserve">
          <source>normal prototypal scope inheritance -- ng-include, ng-switch, ng-controller, directive with &lt;code&gt;scope: true&lt;/code&gt;</source>
          <target state="translated">일반적인 프로토 타입 범위 상속-ng-include, ng-switch, ng-controller, &lt;code&gt;scope: true&lt;/code&gt; 지시어 : true</target>
        </trans-unit>
        <trans-unit id="2ddefe75ff60bb0b45a230e1492152cbebae9d6e" translate="yes" xml:space="preserve">
          <source>normal prototypal scope inheritance with a copy/assignment -- ng-repeat.  Each iteration of ng-repeat creates a new child scope, and that new child scope always gets a new property.</source>
          <target state="translated">복사 / 할당-ng-repeat를 사용한 일반적인 프로토 타입 범위 상속 ng-repeat를 반복 할 때마다 새 자식 범위가 만들어지고 새 자식 범위는 항상 새 속성을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="135c88242dc85baeb3e79543a0c7a8e5a6803c4e" translate="yes" xml:space="preserve">
          <source>transcluded scope -- directive with &lt;code&gt;transclude: true&lt;/code&gt;.  This one is also normal prototypal scope inheritance, but it is also a sibling of any isolate scope.</source>
          <target state="translated">transcluded scope-transclude를 포함한 지시문 &lt;code&gt;transclude: true&lt;/code&gt; . 이것은 또한 일반적인 프로토 타입 범위 상속이지만 격리 범위의 형제이기도합니다.</target>
        </trans-unit>
        <trans-unit id="995ad0b731059826a9125c627e28cc9351e5bcf3" translate="yes" xml:space="preserve">
          <source>use $parent.parentScopeProperty (not always possible, but easier than 1. where possible)</source>
          <target state="translated">$ parent.parentScopeProperty를 사용하십시오 (항상 가능하지는 않지만 가능하면 1보다 쉬움).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
