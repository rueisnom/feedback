<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/14220321">
    <body>
      <group id="14220321">
        <trans-unit id="927d598b66027a146baa1781e637b904c6aa330f" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://stackoverflow.com/a/30180679/1348195&quot;&gt;Note, for those using the new &lt;code&gt;fetch&lt;/code&gt; API, Angular or promises I've added another answer below&lt;/a&gt;)</source>
          <target state="translated">（ &lt;a href=&quot;https://stackoverflow.com/a/30180679/1348195&quot;&gt;注、新しい &lt;code&gt;fetch&lt;/code&gt; API、Angular、またはpromiseを使用している場合は、以下に別の回答を追加しました&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="99f4d532491d1864e1be89ab9b7b1d7432912746" translate="yes" xml:space="preserve">
          <source>(Although it can be written in Javascript, I prefer to write it in Python, and compile it to Javascript using &lt;a href=&quot;https://github.com/QQuick/Transcrypt&quot;&gt;Transcrypt&lt;/a&gt;. It will be clear enough.)</source>
          <target state="translated">（JavaScriptで記述できますが、Pythonで記述し、 &lt;a href=&quot;https://github.com/QQuick/Transcrypt&quot;&gt;Transcrypt&lt;/a&gt;を使用してJavascriptにコンパイルすることをお勧めします。十分に明確になります。）</target>
        </trans-unit>
        <trans-unit id="5bdb200d65235570c1b58c9e91da7f158c793d35" translate="yes" xml:space="preserve">
          <source>(Fiddle)</source>
          <target state="translated">(Fiddle)</target>
        </trans-unit>
        <trans-unit id="5db09589cf8459f3d38f5553fbde8bce31d35a4c" translate="yes" xml:space="preserve">
          <source>(fiddle)</source>
          <target state="translated">(fiddle)</target>
        </trans-unit>
        <trans-unit id="7766903fe90c705c4ed71e3573241c83b2c69193" translate="yes" xml:space="preserve">
          <source>...which is less cumbersome with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015+ arrow functions&lt;/a&gt;:</source>
          <target state="translated">... &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015 +の矢印機能&lt;/a&gt;を使用する方が煩雑ではありません。</target>
        </trans-unit>
        <trans-unit id="f927aed5b9c420c5e6e8550a2e4521837fcb377c" translate="yes" xml:space="preserve">
          <source>1)Event Loop</source>
          <target state="translated">1)イベントループ</target>
        </trans-unit>
        <trans-unit id="0742a4064775d4cda76aa61598d18d11036418f9" translate="yes" xml:space="preserve">
          <source>1. Synchronous AJAX - Don't do it!!</source>
          <target state="translated">1.同期AJAX-それをしないでください!</target>
        </trans-unit>
        <trans-unit id="f24ae07c22d1eb6bb318aa04f411d2319b454d6c" translate="yes" xml:space="preserve">
          <source>2)Web API</source>
          <target state="translated">2)Web API</target>
        </trans-unit>
        <trans-unit id="f76660e7f2f317741f7b6f9a679f94b6aae6c47e" translate="yes" xml:space="preserve">
          <source>2. Restructure code</source>
          <target state="translated">2.コードの再構築</target>
        </trans-unit>
        <trans-unit id="44d7b3b36c7446cc15b0aafbdc4f232450505779" translate="yes" xml:space="preserve">
          <source>2017 answer: you can now do exactly what you want in every current browser and node</source>
          <target state="translated">2017年の答え:現在のすべてのブラウザとノードで、あなたが望むことを正確に行うことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="0d76585d726fac5212bc15c005d34dc57ae870eb" translate="yes" xml:space="preserve">
          <source>3)Event Queue</source>
          <target state="translated">3)イベントキュー</target>
        </trans-unit>
        <trans-unit id="68333d073e4f567370e4ebd9e36d796f8c754911" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/&quot;&gt;Here&lt;/a&gt; it says,</source>
          <target state="translated">&lt;a href=&quot;http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/&quot;&gt;ここ&lt;/a&gt;で言う、</target>
        </trans-unit>
        <trans-unit id="d569b34dd010230f2b5736a91066fe31f29056f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; - A promise library for JavaScript</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; -JavaScriptのpromiseライブラリ</target>
        </trans-unit>
        <trans-unit id="8be840693df3eefddf69835e766647c8f3935f38" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/4866721/what-are-deferred-objects&quot;&gt;Deferred objects&lt;/a&gt; are jQuery's custom implementation of promises (before the Promise API was standardized). They behave almost like promises but expose a slightly different API.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4866721/what-are-deferred-objects&quot;&gt;遅延オブジェクト&lt;/a&gt;は、jQueryのプロミスのカスタム実装です（Promise APIが標準化される前）。 これらはpromiseとほとんど同じように動作しますが、少し異なるAPIを公開します。</target>
        </trans-unit>
        <trans-unit id="3c3877fa4d4bea86aa540d1d00c51cba27671903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fibers&lt;/code&gt; helps in solving the issue.</source>
          <target state="translated">&lt;code&gt;Fibers&lt;/code&gt; は問題の解決に役立ちます。</target>
        </trans-unit>
        <trans-unit id="d4de38eeff0914f72435ab92aacf70919fd4db58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async/await&lt;/code&gt; builds on top of promises: an &lt;code&gt;async&lt;/code&gt; function always returns a promise. &lt;code&gt;await&lt;/code&gt; &quot;unwraps&quot; a promise and either result in the value the promise was resolved with or throws an error if the promise was rejected.</source>
          <target state="translated">&lt;code&gt;async/await&lt;/code&gt; はpromiseの上に構築されます &lt;code&gt;async&lt;/code&gt; 関数は常にpromiseを返します。 プロミスが「アンラップ」されるのを待ち、プロミスが解決された値になるか、プロミスが拒否された場合はエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="472c34ad7218489081303afcad61fe244feeb0fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt; will refer to the function we pass to &lt;code&gt;foo&lt;/code&gt; when we call it and we simply pass it on to &lt;code&gt;success&lt;/code&gt;. I.e. once the Ajax request is successful, &lt;code&gt;$.ajax&lt;/code&gt; will call &lt;code&gt;callback&lt;/code&gt; and pass the response to the callback (which can be referred to with &lt;code&gt;result&lt;/code&gt;, since this is how we defined the callback).</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; は、それを呼び出すときに &lt;code&gt;foo&lt;/code&gt; に渡す関数を参照し、単純にそれを &lt;code&gt;success&lt;/code&gt; 渡します。 つまり、Ajaxリクエストが成功すると、 &lt;code&gt;$.ajax&lt;/code&gt; はコール &lt;code&gt;callback&lt;/code&gt; を呼び出し、そのコールバックに応答を渡します（これはコールバックの定義方法である &lt;code&gt;result&lt;/code&gt; 、 resultで参照できます）。</target>
        </trans-unit>
        <trans-unit id="0cdc633c16019e6c8b41e52704499a8c4fdbc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo&lt;/code&gt; itself is defined as follows:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 自体は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="5bc50c14ccc34523a427f339d4f6b0d89980a4cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order_milk&lt;/code&gt; kicks off, orders the milk, then, when and only when it arrives, it invokes &lt;code&gt;put_in_coffee&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;order_milk&lt;/code&gt; はキックオフして牛乳を注文し、牛乳が到着したときにいつでも &lt;code&gt;put_in_coffee&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="5486986e826b7ca20e7b32edb333416cf0cafa81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;rarr; For a more general explanation of async behaviour with different examples, please see&lt;/em&gt;&lt;a href=&quot;https://stackoverflow.com/q/23667086/218196&quot;&gt;Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;&amp;rarr;さまざまな例での非同期動作のより一般的な説明について&lt;/em&gt; &lt;a href=&quot;https://stackoverflow.com/q/23667086/218196&quot;&gt;は、関数内で変数を変更した後、なぜ変数が変更されないのか&lt;/a&gt; &lt;em&gt;を参照してください&lt;/em&gt; 。 -非同期コードリファレンス</target>
        </trans-unit>
        <trans-unit id="eb1f5ef8b32f66be0ebf85bab611e6a46d561b3a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;rarr; If you already understand the problem, skip to the possible solutions below.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;rarr;すでに問題を理解している場合は、以下の可能な解決策に進んでください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5326aa0d4ea5b09f0c635a23b58323c8c2e39d46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Or alternately, you could make a wrapper for &lt;code&gt;doSomethingAsync&lt;/code&gt; that returns a promise, and then do the below...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（あるいは、promiseを返す &lt;code&gt;doSomethingAsync&lt;/code&gt; のラッパーを作成して、以下を実行することもできます...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e53fbd340f4f3003e06110183cb83b82789a7984" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Or, again, build a wrapper for &lt;code&gt;doSomethingAsync&lt;/code&gt; that gives you a promise and do the below...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（または、もう一度、約束を与える &lt;code&gt;doSomethingAsync&lt;/code&gt; のラッパーを作成し、以下を実行します...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1c2279af365b10752ed22cb3ac6e9f7c78b75a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Since we're doing the work in series, we can just use &lt;code&gt;results.push(result)&lt;/code&gt; since we know we won't get results out of order. In the above we could have used &lt;code&gt;results[index] = result;&lt;/code&gt;, but in some of the following examples we don't have an index to use.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（連続して作業を行っているため、結果が順不同になることはないため、 &lt;code&gt;results.push(result)&lt;/code&gt; を使用できます。上記では、 &lt;code&gt;results[index] = result;&lt;/code&gt; を使用することもできましたが、次の例の一部では、使用するインデックスがありません。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0dca3ab11483f31910ef1b76a0f2b57827edfed0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(We could do away with &lt;code&gt;expecting&lt;/code&gt; and just use &lt;code&gt;results.length === theArray.length&lt;/code&gt;, but that leaves us open to the possibility that &lt;code&gt;theArray&lt;/code&gt; is changed while the calls are outstanding...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（ &lt;code&gt;expecting&lt;/code&gt; せずに &lt;code&gt;results.length === theArray.length&lt;/code&gt; 使用することもできますが、呼び出しが未解決の間に &lt;code&gt;theArray&lt;/code&gt; が変更される可能性があることにご注意ください...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c79ef9a065b5b6d162c99553810bc34db9b4c98" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A Image from one of the answers here, Correctly explains callback use...&lt;/em&gt;
We give our function(function utilising data returned from server) to function calling server.</source>
          <target state="translated">&lt;em&gt;ここで答えの1つからの画像、コールバックの使用を正しく説明しています...&lt;/em&gt;関数（サーバーから返されたデータを利用する関数）を関数呼び出しサーバーに渡します。</target>
        </trans-unit>
        <trans-unit id="575713933b89fb879752fb918e398d207981e848" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Error handler&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;エラーハンドラー&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb7a5019ca58e906cfe2794d7f8ae19085308f37" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Of course, if &lt;code&gt;doSomethingAsync&lt;/code&gt; passed us errors, we'd use &lt;code&gt;reject&lt;/code&gt; to reject the promise when we got an error.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;もちろん、 &lt;code&gt;doSomethingAsync&lt;/code&gt; がエラーを渡した場合は、エラーが発生したときに &lt;code&gt;reject&lt;/code&gt; を使用してpromiseを拒否します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29ac499569a5a06c4d82ef94c11d97109d312692" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PS: As the first test I wrote x('x', displayAjax)..., and it totally got a response...??? So I checked the folder where the HTML is located, and there was a file called 'x.xml'. So even if you forget the extension of your file XMLHttpRequest 2 WILL FIND IT&lt;/em&gt;. I LOL'd</source>
          <target state="translated">&lt;em&gt;PS：最初のテストとして、私はx（ 'x'、displayAjax）と書いた...そしてそれは完全に応答を得た... ???&lt;/em&gt; &lt;em&gt;そこで、HTMLが置かれているフォルダーを確認したところ、「x.xml」というファイルがありました。&lt;/em&gt; &lt;em&gt;したがって、ファイルの拡張子を忘れた場合でもXMLHttpRequest 2はそれを見つけます&lt;/em&gt; 。 私は笑いました</target>
        </trans-unit>
        <trans-unit id="a453fdc787181e5194220141468f98edcb49264c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Read a file synchronous&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ファイルを同期的に読み取る&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f873c1d50c07030d55b6897f696affcc44c234c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 2&lt;/strong&gt; (first of all read the answers from &lt;a href=&quot;https://stackoverflow.com/a/16825593/19068&quot;&gt;Benjamin Gruenbaum&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://stackoverflow.com/a/14220323/19068&quot;&gt;Felix Kling&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 2&lt;/strong&gt; （まず、 &lt;a href=&quot;https://stackoverflow.com/a/16825593/19068&quot;&gt;Benjamin Gruenbaum&lt;/a&gt;と&lt;a href=&quot;https://stackoverflow.com/a/14220323/19068&quot;&gt;Felix Kling&lt;/a&gt;からの回答を読んでください）</target>
        </trans-unit>
        <trans-unit id="7bb7d03442a106c3a66906d1c9d76fc88badb345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;The Event Loop and Concurrency Model&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;イベントループと同時実行モデル&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc4c0812139669b4b9302dd36333c2148a9da551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All three are available in current browsers, and node 7+.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3つすべては、現在のブラウザーとノード7以降で使用できます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="890ea8c5734449e60d41906d358b6206ed712f11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt; (popular in node)</source>
          <target state="translated">&lt;strong&gt;コールバック&lt;/strong&gt; （ノードで人気）</target>
        </trans-unit>
        <trans-unit id="e2ab2f71e857cb3d2466201010b62a27fd2e5e37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't do that.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;それをしないでください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="afaf690b015b9a3ab311cb3b9d55efc3bab713ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 way (async - await)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6ウェイ（非同期-待機）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d78b4767222f91ac61373691a4d965d332d201f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Embrace the asynchronous nature of JavaScript!&lt;/strong&gt; While certain asynchronous operations provide synchronous counterparts (so does &quot;Ajax&quot;), it's generally discouraged to use them, especially in a browser context.</source>
          <target state="translated">&lt;strong&gt;JavaScriptの非同期性を受け入れてください！&lt;/strong&gt; 特定の非同期操作は対応する同期操作を提供しますが（「Ajax」も同様）、特にブラウザーのコンテキストでは、それらを使用することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="109d60edc3e638d2bab113fbb027ee1e4e879a32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Have a look at this example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;この例を見てください：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09004b4c20addc68d6df669ac50a41fb497dea47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heads up!&lt;/strong&gt; It is not possible to make a synchronous &lt;a href=&quot;https://stackoverflow.com/questions/2067472/please-explain-jsonp&quot;&gt;JSONP&lt;/a&gt; request. JSONP by its very nature is always asynchronous (one more reason to not even consider this option).</source>
          <target state="translated">&lt;strong&gt;注意喚起！&lt;/strong&gt; 同期&lt;a href=&quot;https://stackoverflow.com/questions/2067472/please-explain-jsonp&quot;&gt;JSONP&lt;/a&gt;リクエストを行うことはできません。 その性質上、JSONPは常に非同期です（このオプションを考慮しない理由はもう1つあります）。</target>
        </trans-unit>
        <trans-unit id="db3e68b8187a2a11a0f5fea968a2add5f24c4dfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; You can only use &lt;code&gt;await&lt;/code&gt; inside an &lt;code&gt;async&lt;/code&gt; function. Right now, top-level &lt;code&gt;await&lt;/code&gt; isn't yet supported, so you might have to make an async IIFE (&lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately_invoked_function_expression&quot;&gt;Immediately Invoked Function Expression&lt;/a&gt;) to start an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="translated">&lt;strong&gt;重要：&lt;/strong&gt; &lt;code&gt;await&lt;/code&gt; は &lt;code&gt;async&lt;/code&gt; 関数内でのみ使用できます。 現在、トップレベルの &lt;code&gt;await&lt;/code&gt; はまだサポートされていないため、非同期IIFE（ &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately_invoked_function_expression&quot;&gt;即時に呼び出される関数式&lt;/a&gt; ）を作成して &lt;code&gt;async&lt;/code&gt; コンテキストを開始する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="d1a2d5a4642c349de8193773228017c7500f4e56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;
Recent Spotify &lt;code&gt;search&lt;/code&gt; APIs will require an access token to be specified in the request headers:</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;最近のSpotify &lt;code&gt;search&lt;/code&gt; APIでは、リクエストヘッダーでアクセストークンを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="4b966ba6c20e45f447ff2e8f03f268e29a52a4f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises with &lt;code&gt;async/await&lt;/code&gt;&lt;/strong&gt; (ES2017+, available in older browsers if you use a transpiler or regenerator)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;async/await&lt;/code&gt; での約束&lt;/strong&gt; （ES2017 +、トランスパイラーまたは再生器を使用する場合は古いブラウザーで使用可能）</target>
        </trans-unit>
        <trans-unit id="6473a819e62a6a22028f1318142e8cba26e9b5a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises with &lt;code&gt;then()&lt;/code&gt;&lt;/strong&gt; (ES2015+, available in older browsers if you use one of the many promise libraries)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;then()&lt;/code&gt; を&lt;/strong&gt;使用したプロミス（ES2015 +、多くのプロミスライブラリのいずれかを使用している場合、古いブラウザで使用可能）</target>
        </trans-unit>
        <trans-unit id="04c41fa090162049f70a4e607252fab3dd0bb0ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short answer&lt;/strong&gt;: Your &lt;code&gt;foo()&lt;/code&gt; method returns immediately, while the &lt;code&gt;$ajax()&lt;/code&gt; call executes asynchronously &lt;em&gt;after the function returns&lt;/em&gt;. The problem is then how or where to store the results retrieved by the async call once it returns.</source>
          <target state="translated">&lt;strong&gt;短い答え&lt;/strong&gt; ： &lt;code&gt;foo()&lt;/code&gt; メソッドはすぐに戻りますが、 &lt;code&gt;$ajax()&lt;/code&gt; 呼び出しは&lt;em&gt;関数が戻った後に&lt;/em&gt;非同期で実行され&lt;em&gt;ます&lt;/em&gt; 。 問題は、非同期呼び出しによって返された結果をどのようにまたはどこに格納するかです。</target>
        </trans-unit>
        <trans-unit id="f4645089306c6a1d783c20f54349274a135ed097" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, how do we tackle this issue?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;では、この問題にどのように取り組むのでしょうか。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ab003d485f673dee9ae9f1e5a74cdd4ee60e809" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key thing here is the order of execution. That is&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ここで重要なのは、実行の順序です。&lt;/strong&gt; &lt;strong&gt;あれは&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fac01d33af22c926036bf26176e2ea876531efc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the plnkr:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これはplnkrです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ed0d7ce5e48365488a89a8f5818cd02ab54aa58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WHEN is something going to run&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;いつ実行されるか&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8fb2f83aee2cbeff4ac6fcb5ea50cce08e5c218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fulfilled&lt;/strong&gt; meaning that the computation completed successfully.</source>
          <target state="translated">&lt;strong&gt;満たされた&lt;/strong&gt;という意味は、計算が正常に完了したことです。</target>
        </trans-unit>
        <trans-unit id="3030d3b7a04661fbb4185df915ebeef20d9e0313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rejected&lt;/strong&gt; meaning that the computation failed.</source>
          <target state="translated">&lt;strong&gt;拒否&lt;/strong&gt;は、計算が失敗したことを意味します。</target>
        </trans-unit>
        <trans-unit id="e9da82d285e8df3659dc9d639d7f7999131d7220" translate="yes" xml:space="preserve">
          <source>A Promise is a &lt;em&gt;value over time&lt;/em&gt;. Promises have state, they start as pending with no value and can settle to:</source>
          <target state="translated">約束は&lt;em&gt;時間の経過に&lt;/em&gt;伴う&lt;em&gt;価値&lt;/em&gt;です。 プロミスには状態があり、値なしで保留中として開始し、次のように解決できます。</target>
        </trans-unit>
        <trans-unit id="0fa2ed570336fff9061c7fed76b7c10d8559bca9" translate="yes" xml:space="preserve">
          <source>A callback is simply a function passed to another function. That other function can call the function passed whenever it is ready. In the context of an asynchronous process, the callback will be called whenever the asynchronous process is done. Usually, the result is passed to the callback.</source>
          <target state="translated">コールバックとは、他の関数に渡された関数のことです。その別の関数は、準備ができたらいつでも渡された関数を呼び出すことができます。非同期プロセスのコンテキストでは、コールバックは非同期プロセスが完了するたびに呼び出されます。通常、結果はコールバックに渡されます。</target>
        </trans-unit>
        <trans-unit id="f9e8a04c6605f9a32383dcbf481370c3e715820d" translate="yes" xml:space="preserve">
          <source>A promise can only change states &lt;em&gt;once&lt;/em&gt; after which it will always stay at the same state forever. You can attach &lt;code&gt;then&lt;/code&gt; handlers to promises to extract their value and handle errors. &lt;code&gt;then&lt;/code&gt; handlers allow &lt;a href=&quot;https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks&quot;&gt;chaining&lt;/a&gt; of calls. Promises are created by &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;using APIs that return them&lt;/a&gt;. For example, the more modern AJAX replacement &lt;code&gt;fetch&lt;/code&gt; or jQuery's &lt;code&gt;$.get&lt;/code&gt; return promises.</source>
          <target state="translated">プロミスは状態を&lt;em&gt;一度&lt;/em&gt;だけ変更でき&lt;em&gt;、&lt;/em&gt;その後は常に永遠に同じ状態に留まります。 &lt;code&gt;then&lt;/code&gt; ハンドラーをpromiseに接続して、値を抽出し、エラーを処理することができます。 &lt;code&gt;then&lt;/code&gt; ハンドラーは呼び出しの&lt;a href=&quot;https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks&quot;&gt;チェーン&lt;/a&gt;を許可します 。 プロミスは、プロミス&lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;を返すAPIを使用し&lt;/a&gt;て作成されます 。 たとえば、より最近のAJAX置換 &lt;code&gt;fetch&lt;/code&gt; またはjQueryの &lt;code&gt;$.get&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="d64b3ccbf97c56e6baf992073261e3d4c261d264" translate="yes" xml:space="preserve">
          <source>A+ Promises.js</source>
          <target state="translated">A+Promises.js</target>
        </trans-unit>
        <trans-unit id="7b2622a1b73a931e6ca38a355f7e3e8ea446ddb8" translate="yes" xml:space="preserve">
          <source>Above, we said, &quot;JS has no way to know that it needs to &lt;strong&gt;wait&lt;/strong&gt; for the first call to finish before it executes the second&quot;. Wouldn't it be nice if there &lt;strong&gt;was&lt;/strong&gt; some way to tell JS that? It turns out that there is--the &lt;code&gt;await&lt;/code&gt; keyword, used inside a special type of function called an &quot;async&quot; function. This feature is part of the upcoming version of ES but is already available in transpilers such as Babel given the right presets. This allows us to simply write</source>
          <target state="translated">上記では、「JSは、最初の呼び出しが完了するのを&lt;strong&gt;待っ&lt;/strong&gt;てから2番目の呼び出しを実行する必要があることを知る方法がない」と述べました。 JSにそれを伝える方法が&lt;strong&gt;あっ&lt;/strong&gt;たらいいのではないでしょうか？ 「async」関数と呼ばれる特別なタイプの関数内で使用される &lt;code&gt;await&lt;/code&gt; キーワードがあることがわかります。 この機能は、ESの次期バージョンの一部ですが、適切なプリセットが与えられていれば、Babelなどのトランスパイラーですでに利用可能です。 これにより、簡単に書くことができます</target>
        </trans-unit>
        <trans-unit id="e1ca54ffb7b2f8af43c2a3bf761dc7cd1da55e53" translate="yes" xml:space="preserve">
          <source>Actually, all we've done is added a &lt;code&gt;return&lt;/code&gt; to the call to &lt;code&gt;$.ajax&lt;/code&gt;. This works because jQuery's &lt;code&gt;$.ajax&lt;/code&gt; already returns a kind of promise-like thing. (In practice, without getting into details, we would prefer to wrap this call so as for return a real promise, or use some alternative to &lt;code&gt;$.ajax&lt;/code&gt; that does so.) Now, if we want to load the file and wait for it to finish and then do something, we can simply say</source>
          <target state="translated">実際、私たちが行ったのは、 &lt;code&gt;$.ajax&lt;/code&gt; 呼び出しへの &lt;code&gt;return&lt;/code&gt; を追加すること だけです。 これは、jQueryの &lt;code&gt;$.ajax&lt;/code&gt; すでに一種のpromiseのようなものを返しているため機能します。 （実際には、詳細に &lt;code&gt;$.ajax&lt;/code&gt; ずに、この呼び出しをラップして実際のプロミスを返すか、そうする$ .ajaxの代替を使用することをお勧めします。）次に、ファイルをロードしてそれを待つ場合終了して何かを行うには、簡単に言うことができます</target>
        </trans-unit>
        <trans-unit id="8806f1d6f77f315f3c6459851ebdd89a11e28f02" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;'async'&lt;/a&gt; keyword to the parent function</source>
          <target state="translated">親関数に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;「async」&lt;/a&gt;キーワードを追加します</target>
        </trans-unit>
        <trans-unit id="529deb621e57605154d7312ba8f12b3f554d9040" translate="yes" xml:space="preserve">
          <source>Additionally here is the promises &lt;a href=&quot;https://github.com/promises-aplus/promises-spec&quot;&gt;spec&lt;/a&gt; define here.</source>
          <target state="translated">さらに、ここに定義されているpromise &lt;a href=&quot;https://github.com/promises-aplus/promises-spec&quot;&gt;仕様が&lt;/a&gt;あります。</target>
        </trans-unit>
        <trans-unit id="ab38701d1301596d1056dacff49b4a862d011ba3" translate="yes" xml:space="preserve">
          <source>Again ... it's a very short function, but it does get &amp;amp; post.</source>
          <target state="translated">繰り返しますが、これは非常に短い関数ですが、取得および投稿します。</target>
        </trans-unit>
        <trans-unit id="54729d47d0181e621bfce461fcd3befc07e5b989" translate="yes" xml:space="preserve">
          <source>All of this is really bad user experience. The user won't be able to tell whether everything is working fine or not. Furthermore, the effect will be worse for users with a slow connection.</source>
          <target state="translated">このすべては、本当に悪いユーザー体験です。ユーザーは、すべてが正常に動作しているかどうかを見分けることができません。さらに、接続速度が遅いユーザーには影響が悪化します。</target>
        </trans-unit>
        <trans-unit id="644cfe271cac18a474c99dd756307f08b1e0e327" translate="yes" xml:space="preserve">
          <source>And executing it like this.</source>
          <target state="translated">そして、このように実行します。</target>
        </trans-unit>
        <trans-unit id="761067f16b11d2d1e088fb27ee5a3facce3b502f" translate="yes" xml:space="preserve">
          <source>Angular1</source>
          <target state="translated">Angular1</target>
        </trans-unit>
        <trans-unit id="a6f848c2ffe2ed313ae1ff7c87a3e8f4231023f9" translate="yes" xml:space="preserve">
          <source>Angular2 and Later</source>
          <target state="translated">Angular2以降</target>
        </trans-unit>
        <trans-unit id="700b18f544e30a3391a16d96b67c29e5dd7f4d12" translate="yes" xml:space="preserve">
          <source>Another approach to return a value from an asynchronous function, is to pass in an object that will store the result from the asynchronous function.</source>
          <target state="translated">非同期関数から値を返すもう一つの方法は、非同期関数の結果を保存するオブジェクトを渡すことです。</target>
        </trans-unit>
        <trans-unit id="6e0e29ebcd867f1dca1b8c6b1fb3343ba7d8745a" translate="yes" xml:space="preserve">
          <source>Another point is... if you work with APIs or just your own list's files or whatever you always use different functions for each request...</source>
          <target state="translated">もう一つのポイントは...API を使って作業する場合、あるいは自分のリストのファイルを使って作業する場合など、リクエストごとに異なる関数を使うことになります...</target>
        </trans-unit>
        <trans-unit id="64aef2853dbea8a1653b08bcdf147b457091ff7b" translate="yes" xml:space="preserve">
          <source>Another solution is to execute code via sequential executor &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt;.</source>
          <target state="translated">別の解決策は、シーケンシャルエグゼキュー&lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;ターnsynjsを&lt;/a&gt;介してコードを実行することです。</target>
        </trans-unit>
        <trans-unit id="b2cb720802474bc4792fbb02842d36aeeabbeceb" translate="yes" xml:space="preserve">
          <source>Apart from using &lt;code&gt;then/catch&lt;/code&gt; to work with promises, there exists one more approach. The idea is to &lt;em&gt;recognize an asynchronous function&lt;/em&gt; and then &lt;em&gt;wait for the promises&lt;/em&gt; to resolve, before moving to the next line of code. It's still just the &lt;code&gt;promises&lt;/code&gt; under the hood, but with a different syntactical approach. To make things clearer, you can find a comparison below:</source>
          <target state="translated">&lt;code&gt;then/catch&lt;/code&gt; を使用してpromiseを処理する以外に、もう1つの方法があります。 &lt;em&gt;非同期関数&lt;/em&gt;を&lt;em&gt;認識&lt;/em&gt; &lt;em&gt;し、promise&lt;/em&gt;が解決さ&lt;em&gt;れるのを待って&lt;/em&gt;から、コードの次の行に移動するという考え方です。 それはまだ &lt;code&gt;promises&lt;/code&gt; での約束に過ぎませんが、構文上のアプローチは異なります。 物事をより明確にするために、以下の比較を見つけることができます：</target>
        </trans-unit>
        <trans-unit id="4d6935922dd9171b57188004a7345d312359feff" translate="yes" xml:space="preserve">
          <source>Applied to our Ajax call we could use promises like this:</source>
          <target state="translated">Ajax コールに適用すると、このようなプロミスを使うことができます。</target>
        </trans-unit>
        <trans-unit id="1ef6615c95aa80cbc5318149fff9515811e8e9d4" translate="yes" xml:space="preserve">
          <source>Applying this</source>
          <target state="translated">これを適用すると</target>
        </trans-unit>
        <trans-unit id="f1a34583be1c0d1698743056ac6453867467e99a" translate="yes" xml:space="preserve">
          <source>As I mentioned, some(!) asynchronous operations have synchronous counterparts. I don't advocate their use, but for completeness' sake, here is how you would perform a synchronous call:</source>
          <target state="translated">先ほども述べたように、いくつかの(!)非同期操作には同期的な対応があります。これを使うことを推奨するわけではありませんが、完全性を期すために、以下に同期呼び出しを実行する方法を示します。</target>
        </trans-unit>
        <trans-unit id="d690325261d4ed328617f51bcb035e4e34411085" translate="yes" xml:space="preserve">
          <source>As for synchronous AJAX, &lt;strong&gt;don't do it!&lt;/strong&gt; Felix's answer raises some compelling arguments about why it's a bad idea. To sum it up, it'll freeze the user's browser until the server returns the response and create a very bad user experience. Here is another short summary taken from MDN on why:</source>
          <target state="translated">同期AJAXについて&lt;strong&gt;は&lt;/strong&gt; 、 &lt;strong&gt;実行しないでください。&lt;/strong&gt; フェリックスの答えは、なぜそれが悪い考えであるかについていくつかの説得力のある議論を引き起こします。 要約すると、サーバーが応答を返し、非常に悪いユーザーエクスペリエンスを作成するまで、ユーザーのブラウザーを凍結します。 MDNから抜粋した別の短い要約を以下に示します。</target>
        </trans-unit>
        <trans-unit id="4406a09393c68f9778335e6efa2ba72dfa43398d" translate="yes" xml:space="preserve">
          <source>As mentioned in the comment the use of error &amp;amp;&amp;amp; synchronous does completely break the point of the answer. Which is a nice short way to use Ajax in the proper way?</source>
          <target state="translated">コメントで述べたように、エラー&amp;amp;&amp;amp;同期の使用は、回答の要点を完全に壊します。 適切な方法でAjaxを使用するための良い短い方法はどれですか？</target>
        </trans-unit>
        <trans-unit id="3d039321bb1e1655c4cd32eb77e5d556b9a9d4cc" translate="yes" xml:space="preserve">
          <source>As you can see &lt;code&gt;getJoke&lt;/code&gt; is &lt;strong&gt;returning a&lt;/strong&gt; resolved &lt;strong&gt;promise&lt;/strong&gt; (it is resolved when returning &lt;code&gt;res.data.value&lt;/code&gt;). So you wait until the &lt;strong&gt;$http.get&lt;/strong&gt; request is completed and then &lt;strong&gt;console.log(res.joke)&lt;/strong&gt; is executed (as a normal asynchronous flow).</source>
          <target state="translated">ご覧の &lt;code&gt;getJoke&lt;/code&gt; は解決された&lt;strong&gt;promiseを&lt;/strong&gt; &lt;strong&gt;返してい&lt;/strong&gt;ます（ res.data.valueを&lt;strong&gt;返すと&lt;/strong&gt;解決され &lt;code&gt;res.data.value&lt;/code&gt; ）。 したがって、 &lt;strong&gt;$ http.get&lt;/strong&gt;リクエストが完了するまで待機してから、 &lt;strong&gt;console.log（res.joke）&lt;/strong&gt;が（通常の非同期フローとして&lt;strong&gt;）&lt;/strong&gt;実行されます。</target>
        </trans-unit>
        <trans-unit id="6be3c4864e2a35cc4ac8cfd91a74da6e56a1ee18" translate="yes" xml:space="preserve">
          <source>As you can see I didn't implement sync... it's a bad thing.</source>
          <target state="translated">見ての通り同期を実装していなかったのが悪いんだよね。</target>
        </trans-unit>
        <trans-unit id="3e214af7884162cf40fb2934293a2a307f51fd46" translate="yes" xml:space="preserve">
          <source>As you can see:</source>
          <target state="translated">ご覧の通りです。</target>
        </trans-unit>
        <trans-unit id="3d7fac7964f752248f02c5aa61c85fd417dcfbcf" translate="yes" xml:space="preserve">
          <source>Asynchronous</source>
          <target state="translated">Asynchronous</target>
        </trans-unit>
        <trans-unit id="9ce552a69176ba76938ef8727847cfb9c28c9943" translate="yes" xml:space="preserve">
          <source>Basically, instead of returning a &lt;em&gt;value&lt;/em&gt; which we can't do because of the concurrency model - we're returning a &lt;em&gt;wrapper&lt;/em&gt; for a value that we can &lt;em&gt;unwrap&lt;/em&gt; with &lt;code&gt;then&lt;/code&gt;. It's like a box you can open with &lt;code&gt;then&lt;/code&gt;.</source>
          <target state="translated">基本的には、並行処理モデルのために実行できない&lt;em&gt;値&lt;/em&gt;を返す代わりに、 &lt;code&gt;then&lt;/code&gt; で &lt;em&gt;アンラップ&lt;/em&gt;できる値の&lt;em&gt;ラッパー&lt;/em&gt;を返します。 それはあなたがそれで開くことができる箱のようなものです。</target>
        </trans-unit>
        <trans-unit id="eab484a08dfc236925e2ba1434abe3c27155a03c" translate="yes" xml:space="preserve">
          <source>Because JS has no way to know that it needs to &lt;strong&gt;wait&lt;/strong&gt; for &lt;code&gt;order_milk&lt;/code&gt; to finish before it executes &lt;code&gt;put_in_coffee&lt;/code&gt;. In other words, it does not know that &lt;code&gt;order_milk&lt;/code&gt; is &lt;strong&gt;asynchronous&lt;/strong&gt;--is something that is not going to result in milk until some future time. JS, and other declarative languages execute one statement after another without waiting.</source>
          <target state="translated">JSには、 &lt;code&gt;order_milk&lt;/code&gt; を実行する前にorder_milkが完了するのを&lt;strong&gt;待つ&lt;/strong&gt;必要があることを知る方法がないため &lt;code&gt;put_in_coffee&lt;/code&gt; 。 言い換えると、 &lt;code&gt;order_milk&lt;/code&gt; が&lt;strong&gt;非同期で&lt;/strong&gt;あることはわかりません-将来のある時点まで、ミルクが発生しないものです。 JSおよび他の宣言型言語は、待機することなく1つのステートメントを次々に実行します。</target>
        </trans-unit>
        <trans-unit id="4fb46d91439c44dca8be62ad2c6da7e246ac7424" translate="yes" xml:space="preserve">
          <source>Because a callback is not executed immediately but at a later time it's important to pass the reference to the function not it executed. so</source>
          <target state="translated">コールバックはすぐに実行されるのではなく、後になってから実行されるので、実行された関数ではなく、その関数への参照を渡すことが重要です。</target>
        </trans-unit>
        <trans-unit id="e949293bb3141d39921183faafd54e8bcb4089c2" translate="yes" xml:space="preserve">
          <source>Becomes:</source>
          <target state="translated">Becomes:</target>
        </trans-unit>
        <trans-unit id="33e41fa8d678aeb4e035f2f254faf9c3f81da31a" translate="yes" xml:space="preserve">
          <source>Browser Promise object</source>
          <target state="translated">ブラウザプロミスオブジェクト</target>
        </trans-unit>
        <trans-unit id="765bf6bf6d4dba7ff5f829d9d93bb123d301ca4a" translate="yes" xml:space="preserve">
          <source>Browser can be divided into three parts:</source>
          <target state="translated">ブラウザは3つの部分に分けることができます。</target>
        </trans-unit>
        <trans-unit id="d450093edec3c9a5aeeeb0beef75d475c35a50cd" translate="yes" xml:space="preserve">
          <source>But how you can do it in pure &lt;strong&gt;javascript&lt;/strong&gt; or &lt;strong&gt;jQuery&lt;/strong&gt; for example as you asked in this question?</source>
          <target state="translated">しかし、たとえばこの質問で尋ねたように、純粋な&lt;strong&gt;JavaScript&lt;/strong&gt;または&lt;strong&gt;jQuery&lt;/strong&gt;でそれを行うにはどうすればよいでしょうか。</target>
        </trans-unit>
        <trans-unit id="a64b0676afddefea547c307ed3e8295760faffaa" translate="yes" xml:space="preserve">
          <source>But the fix is easy:</source>
          <target state="translated">しかし、修正は簡単です。</target>
        </trans-unit>
        <trans-unit id="77d296e55d0766d8200053d7f3cfd7c13d9226be" translate="yes" xml:space="preserve">
          <source>But the question here is how to return an Ajax response... (I added an easy way.)</source>
          <target state="translated">しかし、ここで問題になるのはAjaxのレスポンスをどうやって返すか・・・。(簡単な方法を追加してみました)</target>
        </trans-unit>
        <trans-unit id="871ea55bfadd9c09cdde6b012a015872456c8c66" translate="yes" xml:space="preserve">
          <source>But there's still something vaguely dissatisfying about having to write code one way if synchronous and a quite different way if asynchronous. For synchronous, we write</source>
          <target state="translated">しかし、同期の場合は一方通行で、非同期の場合は全く別の方法でコードを書かなければならないことには、何か漠然とした不満があります。同期の場合は、次のように書きます</target>
        </trans-unit>
        <trans-unit id="6662b4c845488fe6c8b6ee72b41f77fa73bca428" translate="yes" xml:space="preserve">
          <source>But to really get out an error the &lt;strong&gt;only&lt;/strong&gt; way is to write a wrong URL in which case every browser throws an error.</source>
          <target state="translated">しかし、本当にエラーを発生させるには、すべてのブラウザがエラーをスローする場合、 &lt;strong&gt;唯一の&lt;/strong&gt;方法は間違ったURLを書き込むことです。</target>
        </trans-unit>
        <trans-unit id="b6fe1615524c00038c401cf5c333c9dc307f8bd8" translate="yes" xml:space="preserve">
          <source>But wait...!</source>
          <target state="translated">でも待って......!</target>
        </trans-unit>
        <trans-unit id="dfb64faad30b77313e3dfe8cbd9a6f1d588843af" translate="yes" xml:space="preserve">
          <source>But what if you need to &lt;em&gt;return&lt;/em&gt; those results from a function? As the other answers have pointed out, you can't; you have to have your function accept and call a callback (or return a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;). Here's a callback version:</source>
          <target state="translated">しかし、関数からこれらの結果を&lt;em&gt;返す&lt;/em&gt;必要がある場合はどうでしょうか。 他の答えが指摘したように、あなたはできません。 関数に受け入れてコールバックを呼び出す（または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promiseを&lt;/a&gt;返す）必要があります。 これがコールバックバージョンです。</target>
        </trans-unit>
        <trans-unit id="53f5926dc5af0fddf203c78ec84b5d65b51a2f52" translate="yes" xml:space="preserve">
          <source>But you can do a lot of stuff with XMLHttpRequest 2:</source>
          <target state="translated">しかし、XMLHttpRequest 2を使えば色々なことができます。</target>
        </trans-unit>
        <trans-unit id="b0d6941afab03ca7758a76da0c336ec6d021825e" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;http://caniuse.com/xhr2&quot;&gt;XMLHttpRequest advanced features&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://caniuse.com/xhr2&quot;&gt;XMLHttpRequestの高度な機能を&lt;/a&gt;確認する</target>
        </trans-unit>
        <trans-unit id="31ebfd440a69ecc3715e49c5b6a6c1dd6d4b0371" translate="yes" xml:space="preserve">
          <source>Consider an example. You call the milkman and order some milk. When it comes, you want to put it in your coffee. You can't put the milk in your coffee right now, because it is not here yet. You have to wait for it to come before putting it in your coffee. In other words, the following won't work:</source>
          <target state="translated">例を考えてみましょう。あなたは牛乳屋さんに電話して牛乳を注文します。それが来たら、あなたはそれをコーヒーに入れたいと思います。牛乳はまだ来ていないので、今すぐにコーヒーに入れることはできません。それが来るのを待ってからコーヒーに入れなければなりません。つまり、以下のようなことはうまくいきません。</target>
        </trans-unit>
        <trans-unit id="84b2d3dacc41e20a8047eac062d786928aeea668" translate="yes" xml:space="preserve">
          <source>Context. The example is querying the &lt;a href=&quot;https://developer.spotify.com/web-api/endpoint-reference/&quot;&gt;Spotify Web API&lt;/a&gt; endpoint in order to search for &lt;code&gt;playlist&lt;/code&gt; objects for a given set of query strings:</source>
          <target state="translated">環境。 この例は、 &lt;a href=&quot;https://developer.spotify.com/web-api/endpoint-reference/&quot;&gt;Spotify Web API&lt;/a&gt;エンドポイントにクエリを実行して、特定のクエリ文字列セットの &lt;code&gt;playlist&lt;/code&gt; オブジェクトを検索します。</target>
        </trans-unit>
        <trans-unit id="b985b8de161adfd30380ec1c45ac41353ff18286" translate="yes" xml:space="preserve">
          <source>Current &lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-async_functions&quot;&gt;browser&lt;/a&gt; and &lt;a href=&quot;http://node.green/#ES2017-features-async-functions&quot;&gt;node&lt;/a&gt; versions support &lt;code&gt;async/await&lt;/code&gt;. You can also support older environments by transforming your code to ES5 with the help of &lt;a href=&quot;https://github.com/facebook/regenerator&quot;&gt;regenerator&lt;/a&gt; (or tools that use regenerator, such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;).</source>
          <target state="translated">現在の&lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-async_functions&quot;&gt;ブラウザ&lt;/a&gt;と&lt;a href=&quot;http://node.green/#ES2017-features-async-functions&quot;&gt;ノードの&lt;/a&gt;バージョンは &lt;code&gt;async/await&lt;/code&gt; をサポートしています。 &lt;a href=&quot;https://github.com/facebook/regenerator&quot;&gt;リジェネレータ&lt;/a&gt; （または&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;などのリジェネレータを使用するツール）を使用してコードをES5に変換することにより、古い環境をサポートすることもできます。</target>
        </trans-unit>
        <trans-unit id="23b9d4749a9f206dd4aecf7d5fe1ab0fe7998221" translate="yes" xml:space="preserve">
          <source>Define a function which returns a &lt;strong&gt;Promise&lt;/strong&gt;, in this case an Ajax call:</source>
          <target state="translated">&lt;strong&gt;Promise&lt;/strong&gt;を返す関数を定義します。この場合はAjax呼び出しです。</target>
        </trans-unit>
        <trans-unit id="3047a156238e05c9e91f44e59216ce4350e7d875" translate="yes" xml:space="preserve">
          <source>Describing all the advantages that promise offer is beyond the scope of this answer, but if you write new code, you should seriously consider them. They provide a great abstraction and separation of your code.</source>
          <target state="translated">プロミスが提供するすべての利点を説明することは、この回答の範囲を超えていますが、新しいコードを書く場合は、真剣にプロミスを検討する必要があります。プロミスはコードの大きな抽象化と分離を提供してくれます。</target>
        </trans-unit>
        <trans-unit id="d24cf059acad77f2348de6ab9a950dcb953d0c1e" translate="yes" xml:space="preserve">
          <source>Difficulties could arise when you have to work with third-party code, but most problems can be solved by just thinking through the application flow.</source>
          <target state="translated">サードパーティのコードを使用しなければならない場合には困難が生じる可能性がありますが、ほとんどの問題はアプリケーションの流れを考えるだけで解決することができます。</target>
        </trans-unit>
        <trans-unit id="291b4e6259557593d37f6433293f59fe5f76d601" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 has 'generators' which allow you to easily program in an asynchronous style.</source>
          <target state="translated">ECMAScript 6 には、非同期スタイルで簡単にプログラミングできる「ジェネレータ」があります。</target>
        </trans-unit>
        <trans-unit id="e3af59b16940b2e81235ebbcb74c7f1a75b7e5e5" translate="yes" xml:space="preserve">
          <source>ES2015 (ES6)</source>
          <target state="translated">ES2015(ES6</target>
        </trans-unit>
        <trans-unit id="7dbb3904074ff18348bd30e832250b33427cdc38" translate="yes" xml:space="preserve">
          <source>ES2015+: Promises with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;then()&lt;/a&gt;</source>
          <target state="translated">ES2015 +： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;then（）で&lt;/a&gt;約束</target>
        </trans-unit>
        <trans-unit id="35bf367fe5ced0d619315d0cc8f147a296348c43" translate="yes" xml:space="preserve">
          <source>ES2016 (ES7)</source>
          <target state="translated">ES2016(ES7</target>
        </trans-unit>
        <trans-unit id="1542f3c49056454d75a06101c17c1785c445d891" translate="yes" xml:space="preserve">
          <source>ES2017+: Promises with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async/await&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ES2017 +： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async/await&lt;/code&gt; &lt;/a&gt;待機での約束</target>
        </trans-unit>
        <trans-unit id="967cf59859743f73ba18a11fe55a168a8034039e" translate="yes" xml:space="preserve">
          <source>ES6 introduces &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generators&lt;/a&gt; which are functions that can return in the middle and then resume the point they were at. This is typically useful for sequences, for example:</source>
          <target state="translated">ES6は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;ジェネレーター&lt;/a&gt;を導入しています。 ジェネレーターは、途中で戻って、それらがあったポイントを再開できる関数です。 これは通常、たとえば次のようなシーケンスに役立ちます。</target>
        </trans-unit>
        <trans-unit id="4b08c5e49b030b945e2f126cefe3cc1039afa94b" translate="yes" xml:space="preserve">
          <source>Enter promises</source>
          <target state="translated">約束事を入力してください</target>
        </trans-unit>
        <trans-unit id="80993d0449ad6680943f4a71d58a1facc8010c69" translate="yes" xml:space="preserve">
          <source>Error handlers are maybe useful if you set custom headers, set the responseType to blob array buffer or whatever...</source>
          <target state="translated">エラーハンドラは、カスタムヘッダを設定したり、レスポンスタイプを blob 配列バッファに設定したりすると便利です。</target>
        </trans-unit>
        <trans-unit id="52397d788ea7c6b60de8f942da7edb5fd927e6c4" translate="yes" xml:space="preserve">
          <source>Even if you pass 'POSTAPAPAP' as the method it won't throw an error.</source>
          <target state="translated">メソッドに 'POSTAPAPAP' を渡してもエラーは出ません。</target>
        </trans-unit>
        <trans-unit id="ed627f8185515e40e63ef82e28b0e78972fa2fad" translate="yes" xml:space="preserve">
          <source>Even if you pass 'fdggdgilfdghfldj' as formdata it won't throw an error.</source>
          <target state="translated">formdata に 'fdggdgilfdghfldj' を渡してもエラーにはなりません。</target>
        </trans-unit>
        <trans-unit id="c920a57596f644008ba32598f248afdb53f17307" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;findItem&lt;/code&gt; might take a long time to execute, any code coming after &lt;code&gt;var item = findItem();&lt;/code&gt; has to &lt;em&gt;wait&lt;/em&gt; until the function returns the result.</source>
          <target state="translated">&lt;code&gt;findItem&lt;/code&gt; の実行には時間がかかる場合がありますが、 &lt;code&gt;var item = findItem();&lt;/code&gt; 後に続くコードはすべて、 関数が結果を返すまで&lt;em&gt;待つ必要&lt;/em&gt;があります。</target>
        </trans-unit>
        <trans-unit id="af30fe5dce2e46682e9e3add89a73ab9d1afd392" translate="yes" xml:space="preserve">
          <source>Event Loop runs for forever i.e kind of infinite loop.Event Queue is where all your function are pushed on some event(example:click) this is one by one carried out of queue and put into Event loop which execute this function and prepares it self for next one after first one is executed.This means Execution of one function doesn't starts till the function before it in queue is executed in event loop.</source>
          <target state="translated">イベントループは永遠に無限ループのようなものです。イベントキューは、すべての関数が何らかのイベント(例:クリック)にプッシュされる場所です。これは、キューから一つずつ持ち出され、この関数を実行し、最初の関数が実行された後、次の関数のためにそれ自身を準備するイベントループに入れられます。</target>
        </trans-unit>
        <trans-unit id="ba81b013536dce95c24ccc172a06bd722742bb6a" translate="yes" xml:space="preserve">
          <source>Every Ajax method of jQuery already returns a &quot;deferred object&quot; (actually a promise of a deferred object) which you can just return from your function:</source>
          <target state="translated">jQueryのすべてのAjaxメソッドは、すでに「繰延オブジェクト」(実際には繰延オブジェクトの約束)を返しており、関数から返すことができます。</target>
        </trans-unit>
        <trans-unit id="197abe1392101850410c061421129e3d1b59f596" translate="yes" xml:space="preserve">
          <source>Example found in &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$q&quot;&gt;docs&lt;/a&gt; mentioned below.</source>
          <target state="translated">下記の&lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$q&quot;&gt;ドキュメントにある&lt;/a&gt;例。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="77810a758bab3888ba66659f3df788816aeb992b" translate="yes" xml:space="preserve">
          <source>Example: jQuery deferred implementation to work with multiple requests</source>
          <target state="translated">例:複数のリクエストに対応するためのjQueryの遅延実装</target>
        </trans-unit>
        <trans-unit id="6b5bea21483cbaba11f47e563b491712cd328829" translate="yes" xml:space="preserve">
          <source>Examples of usage:</source>
          <target state="translated">使用例を紹介します。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="2bb87a5dd963da02345343f24198c82aa718d522" translate="yes" xml:space="preserve">
          <source>Felix Kling did a fine job writing an answer for people using jQuery for AJAX, I've decided to provide an alternative for people who aren't.</source>
          <target state="translated">Felix KlingはAJAXのためにjQueryを使用している人のための回答を書いてくれましたが、そうでない人のために代替案を提供することにしました。</target>
        </trans-unit>
        <trans-unit id="61b6cad34a7477f709f8134369511744282bf7b8" translate="yes" xml:space="preserve">
          <source>Felix Kling did a fine job writing an answer for people using jQuery with callbacks for AJAX. I have an answer for native XHR. This answer is for generic usage of promises either on the frontend or backend.</source>
          <target state="translated">Felix Kling氏は、AJAX用のコールバックを使用してjQueryを使用している人のための回答を書いてくれました。私はネイティブXHRのための回答を持っています。この回答は、フロントエンドとバックエンドのいずれかでプロミスを一般的に使用するためのものである。</target>
        </trans-unit>
        <trans-unit id="635e0097e3c51f900f56e2ff15075d9128740b8b" translate="yes" xml:space="preserve">
          <source>For each item, a new Promise will fire a block - &lt;code&gt;ExecutionBlock&lt;/code&gt;, parse the result, schedule a new set of promises based on the result array, that is a list of Spotify &lt;code&gt;user&lt;/code&gt; objects and execute the new HTTP call within the &lt;code&gt;ExecutionProfileBlock&lt;/code&gt; asynchronously.</source>
          <target state="translated">アイテムごとに、新しいPromiseはブロックを &lt;code&gt;ExecutionBlock&lt;/code&gt; します-ExecutionBlock、結果を解析し、結果配列（Spotify &lt;code&gt;user&lt;/code&gt; オブジェクトのリスト）に基づいて新しいPromiseのセットをスケジュールし、 &lt;code&gt;ExecutionProfileBlock&lt;/code&gt; 内で新しいHTTP呼び出しを非同期に実行します。</target>
        </trans-unit>
        <trans-unit id="686ea421444c498a952e65a5b7b7b8ef0e77b9a4" translate="yes" xml:space="preserve">
          <source>For example in your case which you are using &lt;strong&gt;jQuery&lt;/strong&gt;, you can do something like this:</source>
          <target state="translated">たとえば、 &lt;strong&gt;jQuery&lt;/strong&gt;を使用している場合、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="5e7f2f5c0f405e9a5beea0b22dfdc929a77c6dbf" translate="yes" xml:space="preserve">
          <source>For more details on how this sort of callback design is done, check Felix's answer.</source>
          <target state="translated">この種のコールバック設計の詳細については、Felix の回答を参照してください。</target>
        </trans-unit>
        <trans-unit id="9ae95c96ff6e523f358968e03ed28b68223e6cc4" translate="yes" xml:space="preserve">
          <source>For more information study about &lt;strong&gt;promises&lt;/strong&gt; and &lt;strong&gt;observables&lt;/strong&gt; which are newer ways to do this async stuffs.</source>
          <target state="translated">詳細については、この非同期処理を行うための新しい方法である&lt;strong&gt;プロミス&lt;/strong&gt;と&lt;strong&gt;オブザーバブル&lt;/strong&gt;について検討してください。</target>
        </trans-unit>
        <trans-unit id="d2c8933d706e47b9253dd050c3950ebb59a4178f" translate="yes" xml:space="preserve">
          <source>For people who are using &lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;, can handle this situation using &lt;code&gt;Promises&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;を使用している人は、 Promiseを使用してこの状況を処理できます。</target>
        </trans-unit>
        <trans-unit id="9244ed786ac52489080bb2ed73727df2582f9b46" translate="yes" xml:space="preserve">
          <source>Handle asynchronous HTTP calls;</source>
          <target state="translated">非同期 HTTP 呼び出しを処理します。</target>
        </trans-unit>
        <trans-unit id="93478a618140fa661d81ab91258f1a651409d131" translate="yes" xml:space="preserve">
          <source>Having said that ... why don't do it the easy way?</source>
          <target state="translated">それを言うならば......なぜ簡単な方法でやらないのか?</target>
        </trans-unit>
        <trans-unit id="51d1de74537d4867e5318491d300b2040b09329d" translate="yes" xml:space="preserve">
          <source>Here are some approaches to work with asynchronous requests:</source>
          <target state="translated">ここでは、非同期リクエストを扱うためのいくつかのアプローチを紹介します。</target>
        </trans-unit>
        <trans-unit id="089375b0e7ad3fd4224f7a969d79cd0949c40a9f" translate="yes" xml:space="preserve">
          <source>Here is a simple analogy</source>
          <target state="translated">ここで簡単な例え話をします。</target>
        </trans-unit>
        <trans-unit id="a3e19bd4dc54096f28f69d4061c9289827b6d622" translate="yes" xml:space="preserve">
          <source>Here is a simple analogy for the issue:</source>
          <target state="translated">ここで、問題の簡単な例え話を紹介します。</target>
        </trans-unit>
        <trans-unit id="66783b0ea79ce0b229e6872b71ad5253987aee77" translate="yes" xml:space="preserve">
          <source>Here is a simple example of using a promise:</source>
          <target state="translated">ここでは、簡単にプロミスを使った例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="3f98c5fe445eb6aa095ee0b24083a641538f5e28" translate="yes" xml:space="preserve">
          <source>Here is an analogy which hopefully makes the difference between synchronous and asynchronous flow clearer:</source>
          <target state="translated">ここでは、うまくいけば同期フローと非同期フローの違いがより明確になるような例えがあります。</target>
        </trans-unit>
        <trans-unit id="e18b9e6f0b7383abbecaa82bf04e6ad414de12c8" translate="yes" xml:space="preserve">
          <source>Here is an example of the same:</source>
          <target state="translated">ここではその一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="bd9e15afe641187b36f9279675ba8535db066ca8" translate="yes" xml:space="preserve">
          <source>Here is an example that builds on top of delay above:</source>
          <target state="translated">ここでは、上記の遅延の上に構築する例を示します。</target>
        </trans-unit>
        <trans-unit id="1197d1f4a9d4cf3b8d6f5178c3cec6d0874a533a" translate="yes" xml:space="preserve">
          <source>Here we defined the function &quot;inline&quot; but you can pass any function reference:</source>
          <target state="translated">ここでは &quot;inline &quot;関数を定義しましたが、任意の関数参照を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="164b78f47e3ef1dc3e0cef0b751ea196374fd668" translate="yes" xml:space="preserve">
          <source>Here we passed an anonymous function, but we could just as easily pass a reference to an existing function, making it look like:</source>
          <target state="translated">ここでは匿名の関数を渡しましたが、既存の関数への参照を渡すのと同じように簡単に渡すことができ、次のようになります。</target>
        </trans-unit>
        <trans-unit id="1e64ad5b4497aa10277e2076d4284da48c62d379" translate="yes" xml:space="preserve">
          <source>Here's a working version of your code:</source>
          <target state="translated">これがあなたのコードの作業バージョンです。</target>
        </trans-unit>
        <trans-unit id="7e3c8edd9d78bba7e3a4b76a43bc5bd629037a8e" translate="yes" xml:space="preserve">
          <source>Hopefully that will make some sense. When you encounter things like this that seem confusing - i highly recommend reading the documentation fully to at least get an understanding of it. It will make you a much better developer.</source>
          <target state="translated">これで少しは理解してもらえるといいのですが。このように混乱しているように見えることに遭遇したときは、少なくとも理解するためにドキュメントを完全に読むことを強くお勧めします。それはあなたをより良い開発者にしてくれるでしょう。</target>
        </trans-unit>
        <trans-unit id="156541c40984a4a3ee70fd44f32c4e4796080910" translate="yes" xml:space="preserve">
          <source>How do I return the response from an asynchronous call</source>
          <target state="translated">非同期呼び出しからレスポンスを返すには</target>
        </trans-unit>
        <trans-unit id="450c3e475d5ba28aa9f650174becd8bb359d1260" translate="yes" xml:space="preserve">
          <source>How do I return the response from an asynchronous call?</source>
          <target state="translated">非同期呼び出しからレスポンスを返すには?</target>
        </trans-unit>
        <trans-unit id="89fed459f83d0d8bc59f73a0c70d136088949d94" translate="yes" xml:space="preserve">
          <source>How to make &lt;strong&gt;asynchronous&lt;/strong&gt; code look &lt;strong&gt;synchronous&lt;/strong&gt;?</source>
          <target state="translated">&lt;strong&gt;非同期&lt;/strong&gt;コードを&lt;strong&gt;同期的に&lt;/strong&gt;見えるようにする方法は？</target>
        </trans-unit>
        <trans-unit id="c25df1a995ff1bfc26f40ebfff6e38eed0cf9af3" translate="yes" xml:space="preserve">
          <source>I am using the &lt;code&gt;result&lt;/code&gt; object to store the value during the asynchronous operation. This allows the result be available even after the asynchronous job.</source>
          <target state="translated">&lt;code&gt;result&lt;/code&gt; オブジェクトを使用して、非同期操作中に値を格納しています。 これにより、非同期ジョブの後でも結果を利用できます。</target>
        </trans-unit>
        <trans-unit id="3082b7f700f005a0779967fd6b3615c7a09694bd" translate="yes" xml:space="preserve">
          <source>I have a function &lt;code&gt;foo&lt;/code&gt; which makes an Ajax request. How can I return the response from &lt;code&gt;foo&lt;/code&gt;?</source>
          <target state="translated">Ajaxリクエストを行う関数 &lt;code&gt;foo&lt;/code&gt; があります。 &lt;code&gt;foo&lt;/code&gt; からの応答を返すにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="d16b97c7b8f99c277ca18e31f4f0499acffc903b" translate="yes" xml:space="preserve">
          <source>I have extensively discussed this solution &lt;a href=&quot;https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">このソリューションについては、 &lt;a href=&quot;https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774&quot;&gt;ここで&lt;/a&gt;詳しく説明しました 。</target>
        </trans-unit>
        <trans-unit id="871db57e2d8a1b8bb628280aec3e9abeafe80bbf" translate="yes" xml:space="preserve">
          <source>I made a download manager (using ranges on both sides with resume, filereader, filesystem), various image resizers converters using canvas, populate web SQL databases with base64images and much more... But in these cases you should create a function only for that purpose... sometimes you need a blob, array buffers, you can set headers, override mimetype and there is a lot more...</source>
          <target state="translated">私はダウンロードマネージャ(レジューム、ファイルリーダ、ファイルシステムで両側に範囲を使用)、canvasを使った様々なイメージリサイザコンバータ、base64イメージを使ったWeb SQLデータベースの生成などを作りました...。しかし、これらのケースでは、その目的のためだけに関数を作成する必要があります...時にはブロブや配列バッファが必要になることもありますし、ヘッダを設定したり、mimetypeをオーバーライドしたり、他にもたくさんのことがあります...</target>
        </trans-unit>
        <trans-unit id="aabb558dc219037662405ce169cc7769e808b314" translate="yes" xml:space="preserve">
          <source>I tried returning the value from the &lt;code&gt;success&lt;/code&gt; callback, as well as assigning the response to a local variable inside the function and returning that one, but none of those ways actually return the response.</source>
          <target state="translated">関数内のローカル変数に応答を割り当ててその値を返すだけでなく、 &lt;code&gt;success&lt;/code&gt; コールバックから値を返そうとしましたが、実際には応答を返しません。</target>
        </trans-unit>
        <trans-unit id="805d9303f1d1e40a739086bcb503bea0dd8a07cd" translate="yes" xml:space="preserve">
          <source>I use this approach a lot. I would be interested to know how well this approach works where wiring the result back through consecutive modules is involved.</source>
          <target state="translated">私はこのアプローチをよく使っています。連続したモジュールを介して結果を配線する場合に、このアプローチがどの程度うまく機能するのか知りたいですね。</target>
        </trans-unit>
        <trans-unit id="96fd1cbea3405a357b87787e1ea700f496799a2f" translate="yes" xml:space="preserve">
          <source>I was using this solution for a while until I figured out there is an error in old browsers:</source>
          <target state="translated">古いブラウザでエラーが出ていることが分かるまでは、しばらくこの解決策を使っていました。</target>
        </trans-unit>
        <trans-unit id="404b02c50355c8c0582c7d04c555e4cc95c4e8cb" translate="yes" xml:space="preserve">
          <source>I will answer with a horrible-looking, hand-drawn comic. The second image is the reason why &lt;code&gt;result&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; in your code example.</source>
          <target state="translated">恐ろしい手描きの漫画でお答えします。 2番目の画像は、コード例で &lt;code&gt;result&lt;/code&gt; が &lt;code&gt;undefined&lt;/code&gt; れていない理由です。</target>
        </trans-unit>
        <trans-unit id="3967fbf9c99e4d431884df5be7bd68f466e20960" translate="yes" xml:space="preserve">
          <source>I would like to give an example for a Ajax request.</source>
          <target state="translated">Ajaxリクエストの例を挙げてみたいと思います。</target>
        </trans-unit>
        <trans-unit id="e1ef9ad0b4029d883d48f869147c3caa394f24cd" translate="yes" xml:space="preserve">
          <source>I'm using a lot of APIs and one of the first functions I integrate into every HTML page is the first Ajax function in this answer, with GET only...</source>
          <target state="translated">私は多くのAPIを使用していて、私がすべてのHTMLページに統合する最初の関数の1つは、この回答の最初のAjax関数で、GETのみで...</target>
        </trans-unit>
        <trans-unit id="0a86d08347ddae45aa9f3764c8e9705b92f76fe2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doSomethingAsync&lt;/code&gt; gives you a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt;が&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;を提供する場合は、 Promise.allを使用できます。</target>
        </trans-unit>
        <trans-unit id="97dfce1b14fd80ba22d599c23dd5f550c7f63ef9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doSomethingAsync&lt;/code&gt; gives you a Promise, if you can use ES2017+ syntax (perhaps with a transpiler like &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;), you can use an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt; function&lt;/a&gt; with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for-of&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">doSomethingAsyncがPromiseを提供する場合、ES2017 +構文を使用できる場合（おそらく&lt;a href=&quot;http://babeljs.io&quot;&gt;Babelの&lt;/a&gt;ようなトランスパイラーで）、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; 関数&lt;/a&gt;を&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for-of&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; で&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="163754b0a641fcc79050c0cc9adbe06a5d149a2e" translate="yes" xml:space="preserve">
          <source>If the sequence we're producing is a sequence of actions rather than numbers - we can pause the function whenever an action is yielded and wait for it before we resume the function. So instead of a sequence of numbers, we need a sequence of &lt;em&gt;future&lt;/em&gt; values - that is: promises.</source>
          <target state="translated">作成するシーケンスが数値ではなくアクションのシーケンスである場合、アクションが生成されるたびに関数を一時停止し、それを待ってから関数を再開できます。 したがって、一連の数値の代わりに、 &lt;em&gt;将来の&lt;/em&gt;値のシーケンスが必要です。つまり、約束です。</target>
        </trans-unit>
        <trans-unit id="afa00a6b4070ffcc7e4d6431383806ca509e451d" translate="yes" xml:space="preserve">
          <source>If underlying function is not promisified</source>
          <target state="translated">基礎となる機能が促進されていない場合</target>
        </trans-unit>
        <trans-unit id="b1be43c2bc654592ef71349407fe409b8835e049" translate="yes" xml:space="preserve">
          <source>If underlying function is promisified</source>
          <target state="translated">基礎となる機能が促進されている場合</target>
        </trans-unit>
        <trans-unit id="a2a2af534201c965a8a5307d8256309bf76d379b" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;have&lt;/em&gt; to do it, you can pass a flag: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request&quot;&gt;Here is how:&lt;/a&gt;</source>
          <target state="translated">あなた&lt;em&gt;がそれ&lt;/em&gt;をしなければならないなら、あなたはフラグを渡すことができます： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request&quot;&gt;以下はその方法です：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e69ab6f2f9d1e92d40998e6452f1feaaddfbbee5" translate="yes" xml:space="preserve">
          <source>If you can't use ES2017+ syntax (yet), you can use a variation on the &lt;a href=&quot;https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all&quot;&gt;&quot;Promise reduce&quot; pattern&lt;/a&gt; (this is more complex than the usual Promise reduce because we're not passing the result from one into the next, but instead gathering up their results in an array):</source>
          <target state="translated">ES2017 +構文を（まだ）使用できない場合は、 &lt;a href=&quot;https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all&quot;&gt;「Promise削減」パターンの&lt;/a&gt;バリエーションを使用できます（これは通常のPromise削減よりも複雑です。なぜなら、結果を次の結果に渡さないためですが、代わりに結果を配列にまとめる）：</target>
        </trans-unit>
        <trans-unit id="9b961004352fb6c26e593f096a006f3382d2c3af" translate="yes" xml:space="preserve">
          <source>If you directly use a &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/&quot;&gt;&lt;code&gt;XMLHTTPRequest&lt;/code&gt;&lt;/a&gt; object, pass &lt;code&gt;false&lt;/code&gt; as third argument to &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/#the-open%28%29-method&quot;&gt;&lt;code&gt;.open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/&quot;&gt; &lt;code&gt;XMLHTTPRequest&lt;/code&gt; &lt;/a&gt;オブジェクトを直接使用する場合は、 &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/#the-open%28%29-method&quot;&gt; &lt;code&gt;.open&lt;/code&gt; の&lt;/a&gt; 3番目の引数として &lt;code&gt;false&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="458c0f1aba3bbec14d8c4e49ddecf559a0d3074c" translate="yes" xml:space="preserve">
          <source>If you don't use jQuery and want a nice short XMLHttpRequest 2 which works on the modern browsers and also on the mobile browsers I suggest to use it this way:</source>
          <target state="translated">もしあなたがjQueryを使用しておらず、最新のブラウザやモバイルブラウザで動作する短いXMLHttpRequest 2が欲しいのであれば、この方法を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="55afcac8cc3cf8d87fcc46044f624ddede12707e" translate="yes" xml:space="preserve">
          <source>If you know that &lt;code&gt;doSomethingAsync&lt;/code&gt; will ignore a second and third argument, you can just pass it directly to &lt;code&gt;map&lt;/code&gt; (&lt;code&gt;map&lt;/code&gt; calls its callback with three arguments, but most people only use the first most of the time):</source>
          <target state="translated">&lt;code&gt;doSomethingAsync&lt;/code&gt; が2番目と3番目の引数を無視することがわかっている場合は、それを直接 &lt;code&gt;map&lt;/code&gt; に渡すことができます （ &lt;code&gt;map&lt;/code&gt; は3つの引数を使用してコールバックを呼び出しますが、ほとんどの場合、最初の引数のみを使用します）。</target>
        </trans-unit>
        <trans-unit id="c790a5aebe01811818eef515dc847f0886c8d6c4" translate="yes" xml:space="preserve">
          <source>If you need to target browsers that don't support ES6 you can run the code through Babel or closure-compiler to generate ECMAScript 5.</source>
          <target state="translated">ES6 をサポートしていないブラウザをターゲットにする必要がある場合は、Babel やクロージャコンパイラを使ってコードを実行して ECMAScript 5 を生成することができます。</target>
        </trans-unit>
        <trans-unit id="3630077cc579c9376d3c4c87878034e415200376" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery&lt;/a&gt;, you can set the &lt;code&gt;async&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;. Note that this option is &lt;em&gt;deprecated&lt;/em&gt; since jQuery 1.8.
You can then either still use a &lt;code&gt;success&lt;/code&gt; callback or access the &lt;code&gt;responseText&lt;/code&gt; property of the &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/#jqXHR&quot;&gt;jqXHR object&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery&lt;/a&gt;を使用する場合は、 &lt;code&gt;async&lt;/code&gt; オプションを &lt;code&gt;false&lt;/code&gt; に設定できます 。 このオプションはjQuery 1.8以降&lt;em&gt;廃止され&lt;/em&gt;ていることに注意してください。 その後、引き続き &lt;code&gt;success&lt;/code&gt; コールバックを使用するか、 &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/#jqXHR&quot;&gt;jqXHRオブジェクトの&lt;/a&gt; &lt;code&gt;responseText&lt;/code&gt; プロパティにアクセスできます 。</target>
        </trans-unit>
        <trans-unit id="15eeba4207bfa4d204303f8eb467ce459a91861c" translate="yes" xml:space="preserve">
          <source>If you use any other jQuery Ajax method, such as &lt;code&gt;$.get&lt;/code&gt;, &lt;code&gt;$.getJSON&lt;/code&gt;, etc., you have to change it to &lt;code&gt;$.ajax&lt;/code&gt; (since you can only pass configuration parameters to &lt;code&gt;$.ajax&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;$.get&lt;/code&gt; 、 &lt;code&gt;$.getJSON&lt;/code&gt; などの他のjQuery Ajaxメソッドを使用する場合は、 $ .ajaxに変更する必要があります（構成パラメーターは &lt;code&gt;$.ajax&lt;/code&gt; のみ渡すことができるため）。</target>
        </trans-unit>
        <trans-unit id="3c715363204b6b0c4a698fa23da4f0f9dc888e78" translate="yes" xml:space="preserve">
          <source>If you want to EXTEND the function...</source>
          <target state="translated">機能をEXTENDしたい場合は</target>
        </trans-unit>
        <trans-unit id="abe47fc3c57755c3997a845ee0b5aa49beefed3e" translate="yes" xml:space="preserve">
          <source>If you want to block the browser for a while load a nice big &lt;code&gt;.txt&lt;/code&gt; file synchronous.</source>
          <target state="translated">しばらくブラウザをブロックしたい場合は、大きな &lt;code&gt;.txt&lt;/code&gt; ファイルを同期してロードしてください。</target>
        </trans-unit>
        <trans-unit id="4e422421958cc1f0c9d4abcefec9c5f99bb57a7b" translate="yes" xml:space="preserve">
          <source>If you're &lt;em&gt;not&lt;/em&gt; using jQuery in your code, this answer is for you</source>
          <target state="translated">コードでjQueryを使用してい&lt;em&gt;ない&lt;/em&gt;場合、この答えはあなたのためです</target>
        </trans-unit>
        <trans-unit id="ab8a1b500c194cbfba3513d7de0dea72d3a034e8" translate="yes" xml:space="preserve">
          <source>If you're still having a hard time understanding this &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&quot;&gt;read the AJAX getting started guide&lt;/a&gt; at MDN.</source>
          <target state="translated">それでも理解できない場合は、MDNの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&quot;&gt;AJAX&lt;/a&gt;入門ガイドをお読みください 。</target>
        </trans-unit>
        <trans-unit id="18f9b9e612918f51948f6cc2126155b3c549bdae" translate="yes" xml:space="preserve">
          <source>If you're using promises, this answer is for you.</source>
          <target state="translated">プロミスを利用しているなら、この答えはあなたのためのものです。</target>
        </trans-unit>
        <trans-unit id="80fc972e4356d8ced60d608ce0baaf96427cd4b5" translate="yes" xml:space="preserve">
          <source>Imagine you make a phone call to a friend and ask him to look something up for you. Although it might take a while, you wait on the phone and stare into space, until your friend gives you the answer that you needed.</source>
          <target state="translated">あなたが友人に電話をかけて、あなたのために何かを調べてくれるように頼んだとしましょう。それはしばらくかかるかもしれませんが、あなたの友人があなたが必要としていた答えを与えるまで、あなたは電話で待って、スペースに凝視します。</target>
        </trans-unit>
        <trans-unit id="ca8f184ee30d4a232f354261c37cbb9af43a876b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Angular2&lt;/code&gt; with look at the following example, but its &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html&quot;&gt;recommended&lt;/a&gt; to use &lt;code&gt;Observables&lt;/code&gt; with &lt;code&gt;Angular2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Angular2&lt;/code&gt; では、次の例を見てくださいが、 &lt;code&gt;Observables&lt;/code&gt; を &lt;code&gt;Angular2&lt;/code&gt; で使用する&lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html&quot;&gt;こと&lt;/a&gt;をお勧めします。</target>
        </trans-unit>
        <trans-unit id="9164c254eac90254b881079ff36f34d077268d4b" translate="yes" xml:space="preserve">
          <source>In ES7, this is further standardized, there are several proposals right now but in all of them you can &lt;code&gt;await&lt;/code&gt; promise. This is just &quot;sugar&quot; (nicer syntax) for the ES6 proposal above by adding the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; keywords. Making the above example:</source>
          <target state="translated">ES7では、これはさらに標準化されており、現在いくつかの提案がありますが、それらすべてで約束を &lt;code&gt;await&lt;/code&gt; ことができます。 これは、 &lt;code&gt;async&lt;/code&gt; キーワードと &lt;code&gt;await&lt;/code&gt; キーワードを追加することによる、上記のES6提案の単なる「シュガー」（より良い構文）です。 上記の例を作る：</target>
        </trans-unit>
        <trans-unit id="05677a4350495d3e2b8c6f4b68ebe3c7de4458e1" translate="yes" xml:space="preserve">
          <source>In broad, simplistic terms, the event loop is like the project manager, it is constantly listening for any functions that want to run and communicates between the queue and the stack.</source>
          <target state="translated">広く単純化すると、イベントループはプロジェクトマネージャのようなもので、実行したい関数を常に待ち受けていて、キューとスタックの間で通信しています。</target>
        </trans-unit>
        <trans-unit id="cd02d6973d3ea865653a48e911c2e50a8c25776e" translate="yes" xml:space="preserve">
          <source>In my Code it is called as</source>
          <target state="translated">私のコードでは</target>
        </trans-unit>
        <trans-unit id="5cb5ee146291e3428e4c2fcba91cef4c63579d3d" translate="yes" xml:space="preserve">
          <source>In short, synchronous requests block the execution of code... ...this can cause serious issues...</source>
          <target state="translated">要するに、同期要求はコードの実行をブロックする・・・これは重大な問題を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="c37241c1d0bfe0ae8498665ddda9cb54f035c670" translate="yes" xml:space="preserve">
          <source>In the above script, you have an error handler which is statically defined so it does not compromise the function. The error handler can be used for other functions too.</source>
          <target state="translated">上記のスクリプトでは、エラーハンドラが静的に定義されているので、関数を損なうことはありません。エラーハンドラは他の関数にも使用できます。</target>
        </trans-unit>
        <trans-unit id="1fee4a9e013a60a7958cc7ec190286ed94e8f8f3" translate="yes" xml:space="preserve">
          <source>In the case of our milk and coffee, we design &lt;code&gt;order_milk&lt;/code&gt; to return a promise for the milk arriving, then specify &lt;code&gt;put_in_coffee&lt;/code&gt; as a &lt;code&gt;then&lt;/code&gt; action, as follows:</source>
          <target state="translated">私たちのミルクとコーヒーの場合、次のように、 &lt;code&gt;put_in_coffee&lt;/code&gt; れたミルクの約束を返すように &lt;code&gt;order_milk&lt;/code&gt; を設計し &lt;code&gt;then&lt;/code&gt; アクションとしてput_in_coffeeを指定します。</target>
        </trans-unit>
        <trans-unit id="a9724168875ccef827ffb62e3e3dac4f3c469e74" translate="yes" xml:space="preserve">
          <source>In the error response, there are no error codes.</source>
          <target state="translated">エラー応答では、エラーコードはありません。</target>
        </trans-unit>
        <trans-unit id="1a6a81cb0fe27a1ef73a694660e522eaf40baa80" translate="yes" xml:space="preserve">
          <source>In the example of the question, you can make &lt;code&gt;foo&lt;/code&gt; accept a callback and use it as &lt;code&gt;success&lt;/code&gt; callback. So this</source>
          <target state="translated">質問の例では、 &lt;code&gt;foo&lt;/code&gt; にコールバックを受け入れさせ、それを &lt;code&gt;success&lt;/code&gt; コールバックとして使用できます。 したがって、この</target>
        </trans-unit>
        <trans-unit id="f64c26e8bf33e53e89ffa065ce2af5f6dae03e32" translate="yes" xml:space="preserve">
          <source>In the first case the error is inside the &lt;code&gt;displayAjax()&lt;/code&gt; under &lt;code&gt;this.statusText&lt;/code&gt; as &lt;code&gt;Method not Allowed&lt;/code&gt;.</source>
          <target state="translated">最初の場合、エラーは &lt;code&gt;displayAjax()&lt;/code&gt; 下のdisplayAjax（）内の &lt;code&gt;Method not Allowed&lt;/code&gt; として発生します。</target>
        </trans-unit>
        <trans-unit id="8fe42b9b5d9a878fe339729448805008fb45dfb5" translate="yes" xml:space="preserve">
          <source>In the following we will look at three different solutions that are all building on top of each other:</source>
          <target state="translated">以下では、すべてがお互いの上に構築されている3つの異なるソリューションを見ていきます。</target>
        </trans-unit>
        <trans-unit id="ffdebc5331a7e7297d48ecb0f27d85f259e2d630" translate="yes" xml:space="preserve">
          <source>In the second case, it simply works. You have to check at the server side if you passed the right post data.</source>
          <target state="translated">2つ目の場合は、単純に動作します。正しいポストデータを渡したかどうかをサーバ側で確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="0f588f48cb190b6ff210dbc0bc1dc76feaba12bc" translate="yes" xml:space="preserve">
          <source>In this case, we could rewrite the code in the question as:</source>
          <target state="translated">この場合、質問のコードを次のように書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="8e5bc1f12b6bd30221b97d821033adfc0819696f" translate="yes" xml:space="preserve">
          <source>In your case, you would be able to write something like</source>
          <target state="translated">あなたの場合は、次のようなことを書くことができます。</target>
        </trans-unit>
        <trans-unit id="5ae61ff136e6d353245434234270f433244231c2" translate="yes" xml:space="preserve">
          <source>Instead of waiting for the response, the execution continues immediately and the statement after the Ajax call is executed. To get the response eventually, you provide a function to be called once the response was received, a &lt;em&gt;callback&lt;/em&gt; (notice something? &lt;em&gt;call back&lt;/em&gt; ?). Any statement coming after that call is executed before the callback is called.</source>
          <target state="translated">応答を待つのではなく、実行は直ちに続行され、Ajax呼び出しの後のステートメントが実行されます。 最終的に応答を取得するには、応答が受信されたときに呼び出される関数、 &lt;em&gt;コールバック&lt;/em&gt; （何か通知？ &lt;em&gt;コールバック&lt;/em&gt; ？）を提供します。 その呼び出しの後に続くステートメントは、コールバックが呼び出される前に実行されます。</target>
        </trans-unit>
        <trans-unit id="5a176ccd898f71da5498417dd981558178ba5429" translate="yes" xml:space="preserve">
          <source>Is a function that returns an &lt;em&gt;iterator&lt;/em&gt; over the sequence &lt;code&gt;1,2,3,3,3,3,....&lt;/code&gt; which can be iterated. While this is interesting on its own and opens room for a lot of possibility there is one particular interesting case.</source>
          <target state="translated">反復可能なシーケンス &lt;code&gt;1,2,3,3,3,3,....&lt;/code&gt; &lt;em&gt;反復子&lt;/em&gt;を返す関数です。 これはそれ自体興味深いものであり、多くの可能性の余地を開いていますが、1つの特定の興味深い事例があります。</target>
        </trans-unit>
        <trans-unit id="3bfc5cd8986cc4b5d384c982f8dbec35078eb9aa" translate="yes" xml:space="preserve">
          <source>It still returns a promise just the same :)</source>
          <target state="translated">それはまだ同じように約束を返します :)</target>
        </trans-unit>
        <trans-unit id="ef1f71df2861c22e656b28c20ac85577923d64df" translate="yes" xml:space="preserve">
          <source>It supported all *modern browsers. And I can confirm as I'm using this approach since XMLHttpRequest 2 exists. I never had any type of problem on all browsers I use.</source>
          <target state="translated">すべての*モダンブラウザに対応しています。また、XMLHttpRequest 2が存在するので、この方法を使用していることが確認できます。私は私が使用しているすべてのブラウザでどのような種類の問題を持っていたことはありませんでした。</target>
        </trans-unit>
        <trans-unit id="72465754e74ca9abdcff6be99e29d6961cffe62f" translate="yes" xml:space="preserve">
          <source>It uses the new onload (so you don't have to check for readystate &amp;amp;&amp;amp; status)</source>
          <target state="translated">新しいオンロードを使用します（したがって、readystate &amp;amp;&amp;amp;ステータスを確認する必要はありません）。</target>
        </trans-unit>
        <trans-unit id="dc11dae9acba94421bf901ebfd0a99a469f66bba" translate="yes" xml:space="preserve">
          <source>It's a very common issue we face while struggling with the 'mysteries' of JavaScript. Let me try demystifying this mystery today.</source>
          <target state="translated">JavaScriptの「謎」に悩んでいるときによくある問題です。今日はこの謎を解き明かしてみたいと思います。</target>
        </trans-unit>
        <trans-unit id="ad52914796d378e861e608f5f5c6f3f574df3d10" translate="yes" xml:space="preserve">
          <source>It's easier to write code using callbacks than it may seem. After all, JavaScript in the browser is heavily event driven (DOM events). Receiving the Ajax response is nothing else but an event.</source>
          <target state="translated">コールバックを使ったコードを書くのは意外と簡単です。結局のところ、ブラウザの JavaScript はイベント駆動型 (DOM イベント)です。Ajax のレスポンスを受信することはイベント以外の何物でもありません。</target>
        </trans-unit>
        <trans-unit id="cdbb5508c06d9ebb504456c083faa19b12343a7a" translate="yes" xml:space="preserve">
          <source>It's shorter than all other functions Listed.</source>
          <target state="translated">他の全ての機能よりも短いです。</target>
        </trans-unit>
        <trans-unit id="dfa79b24d359ed76614774ecdc6d3f1f1fedbc1b" translate="yes" xml:space="preserve">
          <source>JavaScript runs in the UI thread of the browser and any long-running process will lock the UI, making it unresponsive. Additionally, there is an upper limit on the execution time for JavaScript and the browser will ask the user whether to continue the execution or not.</source>
          <target state="translated">JavaScript はブラウザの UI スレッドで実行され、長時間実行されたプロセスは UI をロックし、応答性が悪くなります。さらに、JavaScriptの実行時間には上限があり、ブラウザはユーザーに実行を継続するかどうかを尋ねます。</target>
        </trans-unit>
        <trans-unit id="e2b5e177110c45130bd6de8833741d43ceee63e1" translate="yes" xml:space="preserve">
          <source>Javscript.info callback</source>
          <target state="translated">Javscript.info コールバック</target>
        </trans-unit>
        <trans-unit id="bbbd4891d7699a852c6406a296c2fcf52f3c3e57" translate="yes" xml:space="preserve">
          <source>Js is a single threaded.</source>
          <target state="translated">Jsはシングルスレッドです。</target>
        </trans-unit>
        <trans-unit id="e54a9bcf7595f53be50f3d461e5136cdeac9c123" translate="yes" xml:space="preserve">
          <source>Keep in mind that promises and deferred objects are just &lt;em&gt;containers&lt;/em&gt; for a future value, they are not the value itself. For example, suppose you had the following:</source>
          <target state="translated">promiseとdeferredオブジェクトは単なる将来の値の&lt;em&gt;コンテナー&lt;/em&gt;であり、値そのものではないことに注意してください。 たとえば、次のような場合を考えます。</target>
        </trans-unit>
        <trans-unit id="a450dc9bb252815e0a34be6965a19e24021fbb40" translate="yes" xml:space="preserve">
          <source>Let functions accept &lt;em&gt;callbacks&lt;/em&gt;</source>
          <target state="translated">関数に&lt;em&gt;コールバックを&lt;/em&gt;受け入れさせる</target>
        </trans-unit>
        <trans-unit id="5142ad643e1ca5f1c54df798209cf3a4e972be1a" translate="yes" xml:space="preserve">
          <source>Let suppose our serverRequest() function had a return statement in a code, when we get back data from server Web API will push it in queue at the end of queue.
As it get pushed at end in queue we cannot utilise its data as there is no function left in our queue to utilise this data.&lt;strong&gt;Thus it is not possible to return something from Async Call.&lt;/strong&gt;</source>
          <target state="translated">serverRequest（）関数のコードにreturnステートメントがあったとしましょう。サーバーからデータを取得すると、Web APIはそれをキューの最後のキューにプッシュします。 キューの最後にプッシュされると、このデータを利用するためのキューに残っている関数がないため、データを利用できません。 &lt;strong&gt;したがって、非同期呼び出しから何かを返すことはできません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29816c85c3b63dc23d798455274fc320da92a3db" translate="yes" xml:space="preserve">
          <source>Let your function accept a callback. In the example code &lt;code&gt;foo&lt;/code&gt; can be made to accept a callback. We'll be telling our code how to &lt;em&gt;react&lt;/em&gt; when &lt;code&gt;foo&lt;/code&gt; completes.</source>
          <target state="translated">関数にコールバックを受け入れさせます。 例のコードでは、コールバックを受け入れるように &lt;code&gt;foo&lt;/code&gt; を作成できます。 &lt;code&gt;foo&lt;/code&gt; が完了したときにどのように&lt;em&gt;反応&lt;/em&gt;するかをコードに伝えます。</target>
        </trans-unit>
        <trans-unit id="2b907de8cd2ea70a0a07b7b3951542f8bc4bf8bc" translate="yes" xml:space="preserve">
          <source>Let's apply promises to your particular problem. We will wrap our request logic inside a function, which returns a promise:</source>
          <target state="translated">特定の問題にプロミスを適用してみましょう。リクエストロジックを関数の中でラップし、プロミスを返します。</target>
        </trans-unit>
        <trans-unit id="d30dd5f759cc5533cfc4d9a5b1b61f8383c8dbb1" translate="yes" xml:space="preserve">
          <source>Let's ask our function for a &lt;strong&gt;PROMISE&lt;/strong&gt;.
Promise is really about what it means : it means that the function guarantees you to provide with any output it gets in future. so let's see it in action for our little problem above :</source>
          <target state="translated">関数に&lt;strong&gt;PROMISEを&lt;/strong&gt;要求してみましょう。 約束は本当にそれが何を意味するかについてです：それは関数があなたが将来得るあらゆる出力を提供することを保証することを意味します。 上記の小さな問題の動作を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="f03473dc33a9b7108d06e897d4c147d809acee67" translate="yes" xml:space="preserve">
          <source>Let's see how we can solve the above issue with promises. First, let's demonstrate our understanding of promise states from above by using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise&quot;&gt;Promise constructor&lt;/a&gt; for creating a delay function:</source>
          <target state="translated">上記の問題をpromiseでどのように解決できるかを見てみましょう。 まず、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise&quot;&gt;Promiseコンストラクター&lt;/a&gt;を使用して遅延関数を作成することにより、上から見たPromiseの状態の理解を示しましょう。</target>
        </trans-unit>
        <trans-unit id="097a1fd4f4dd6ae948cf296ebf5e3fed29d827b1" translate="yes" xml:space="preserve">
          <source>Let's start with a simple JavaScript function:</source>
          <target state="translated">まずは簡単なJavaScriptの関数を使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="012b3ad7e2336b480f233ac7230671a56ff96505" translate="yes" xml:space="preserve">
          <source>Lets first enable JQuery usage, to have &lt;code&gt;$&lt;/code&gt; available as &lt;code&gt;S&lt;/code&gt;:</source>
          <target state="translated">最初にJQueryの使用を有効にして、 &lt;code&gt;$&lt;/code&gt; を &lt;code&gt;S&lt;/code&gt; として使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="3ac2a3b85bfb179de3d5fd9a6d1778a34a10d96e" translate="yes" xml:space="preserve">
          <source>Make the AJAX call synchronous (lets call it SJAX).</source>
          <target state="translated">AJAXコールを同期化します(SJAXと呼ぶことにします)。</target>
        </trans-unit>
        <trans-unit id="4149f095bdea0d897f44292f13870fb2ca675c68" translate="yes" xml:space="preserve">
          <source>More examples here: &lt;a href=&quot;https://github.com/amaksr/nsynjs/tree/master/examples&quot;&gt;https://github.com/amaksr/nsynjs/tree/master/examples&lt;/a&gt;</source>
          <target state="translated">その他の例： &lt;a href=&quot;https://github.com/amaksr/nsynjs/tree/master/examples&quot;&gt;https&lt;/a&gt; : //github.com/amaksr/nsynjs/tree/master/examples</target>
        </trans-unit>
        <trans-unit id="416843538915a12d446291b1a92446755e1f2268" translate="yes" xml:space="preserve">
          <source>More information about promises: &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;HTML5 rocks - JavaScript Promises&lt;/a&gt;</source>
          <target state="translated">プロミスに関する詳細情報： &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;HTML5のロック-JavaScriptプロミス&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25f50452665d503e55acf0b8c965da53f9e2eb1f" translate="yes" xml:space="preserve">
          <source>Most of the answers here give useful suggestions for when you have a single async operation, but sometimes, this comes up when you need to do an asynchronous operation for &lt;em&gt;each&lt;/em&gt; entry in an array or other list-like structure. The temptation is to do this:</source>
          <target state="translated">ここでの回答のほとんどは、単一の非同期操作がある場合に役立つ提案ですが、配列またはその他のリストのような構造の&lt;em&gt;各&lt;/em&gt;エントリに対して非同期操作を実行する必要がある場合に、この問題が発生することがあります。 誘惑はこれをすることです：</target>
        </trans-unit>
        <trans-unit id="7ace0f986a8d32fe40488522b23a55438cb0b782" translate="yes" xml:space="preserve">
          <source>Not recommended: Synchronous &quot;Ajax&quot; calls</source>
          <target state="translated">お勧めしません。同期的な「Ajax」コール</target>
        </trans-unit>
        <trans-unit id="a3266b1005a3a1afba35c5209761885a8ad47be3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Promise.all&lt;/code&gt; resolves its promise with an array of the results of all of the promises you give it when they are all resolved, or rejects its promise when the &lt;em&gt;first&lt;/em&gt; of the promises you give it rejects.</source>
          <target state="translated">&lt;code&gt;Promise.all&lt;/code&gt; は、すべてが解決されたときに提供したすべての約束の結果の配列でその約束を解決するか、 &lt;em&gt;最初&lt;/em&gt;に提供した約束が拒否されたときに約束を拒否することに注意してください。</target>
        </trans-unit>
        <trans-unit id="ce6df39941058908a0b980171b83775c7db609fa" translate="yes" xml:space="preserve">
          <source>Note that the call to &lt;code&gt;foo()&lt;/code&gt; will still return nothing useful. However, the result of the async call will now be stored in &lt;code&gt;result.response&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; の呼び出しは、まだ何も返さないことに注意してください。 ただし、非同期呼び出しの結果は &lt;code&gt;result.response&lt;/code&gt; に格納されます 。</target>
        </trans-unit>
        <trans-unit id="d9c2dea7d7e7a3411da1773762e08918f5674124" translate="yes" xml:space="preserve">
          <source>Nothing easier.</source>
          <target state="translated">何も簡単なことはありません。</target>
        </trans-unit>
        <trans-unit id="353e455e2b68dea72cd422384a4b460cd47300c4" translate="yes" xml:space="preserve">
          <source>Notice how we use the &lt;code&gt;index&lt;/code&gt; from &lt;code&gt;forEach&lt;/code&gt; to save the result in &lt;code&gt;results&lt;/code&gt; in the same position as the entry it relates to, even if the results arrive out of order (since async calls don't necessarily complete in the order in which they were started).</source>
          <target state="translated">結果が順不同で到着した場合でも、 &lt;code&gt;forEach&lt;/code&gt; からの &lt;code&gt;index&lt;/code&gt; を使用して結果を関連するエントリと同じ位置に &lt;code&gt;results&lt;/code&gt; を保存する方法に注意してください（非同期呼び出しは必ずしも開始された順序で完了するとは限らないため） ）。</target>
        </trans-unit>
        <trans-unit id="929ed6885fc0b5c2a602a91186d7a6db6f5f8584" translate="yes" xml:space="preserve">
          <source>Now if you want something more complex using post and FormData you can easily extend this function:</source>
          <target state="translated">ポストやFormDataを使ってもっと複雑なことをしたい場合は、この関数を簡単に拡張することができます。</target>
        </trans-unit>
        <trans-unit id="d974961b0a397dae3ab443eb46237547fe41139f" translate="yes" xml:space="preserve">
          <source>Now let us think we pushed two functions in a queue one is for getting a data from server and another utilises that data.We pushed the serverRequest() function in queue first then utiliseData() function. serverRequest function goes in event loop and makes a call to server as we never know how much time it will take to get data from server
so this process is expected to take time and so we busy our event loop thus hanging our page, that's where Web API come into role it take this function from event loop and deals with server making event loop free so that we can execute next function from queue.The next function in queue is utiliseData() which goes in loop but because of no data available it goes waste and execution of next function continues till end of the queue.(This is called Async calling i.e we can do something else till we get data)</source>
          <target state="translated">ここで、2つの関数をキューに入れたとします。1つはサーバからデータを取得するためのもので、もう1つはそのデータを利用するためのものです。serverRequest関数はイベントループに入り、サーバーへの呼び出しを行います。サーバーからデータを取得するのにどれだけの時間がかかるかわからないので、このプロセスには時間がかかることが予想され、イベントループをビジーにしてページをぶら下げてしまいます。 キューの次の関数は、ループに入るutiliseData()ですが、利用可能なデータがないため、それは無駄になり、次の関数の実行はキューの最後まで継続されます。 これは非同期呼び出しと呼ばれていますすなわち、我々はデータを取得するまで、他の何かを行うことができます</target>
        </trans-unit>
        <trans-unit id="e0a63d4292a004be42ee890cb652815050847bb1" translate="yes" xml:space="preserve">
          <source>Now let's add a bit of twist, by introducing little delay in our function, so that all lines of code are not 'finished' in sequence. Thus, it will emulate the asynchronous behavior of function :</source>
          <target state="translated">ここで、関数に少しだけ遅延を導入して、コードのすべての行が連続して「終了」しないようにしてみましょう。このようにして、関数 .NET の非同期動作をエミュレートします。</target>
        </trans-unit>
        <trans-unit id="42c38f982e0c169feb7e086aabc21246bff1aad8" translate="yes" xml:space="preserve">
          <source>Now some people will probably say that it's better to use onreadystatechange or the even the XMLHttpRequest variable name. That's wrong.</source>
          <target state="translated">さて、onreadystatechangeやXMLHttpRequestの変数名まで使った方が良いと言う人もいるでしょう。これは間違っています。</target>
        </trans-unit>
        <trans-unit id="a2fab3eea51d1e71a6c436e1f5c97b56ccdd5071" translate="yes" xml:space="preserve">
          <source>Now you can do</source>
          <target state="translated">今、あなたは以下のことができます。</target>
        </trans-unit>
        <trans-unit id="da89b3c0dfa9111f27c794ec1b03edd3bdfde2dd" translate="yes" xml:space="preserve">
          <source>Now, after we converted setTimeout to use promises, we can use &lt;code&gt;then&lt;/code&gt; to make it count:</source>
          <target state="translated">ここで、setTimeoutをpromiseを使用するように変換した後、 &lt;code&gt;then&lt;/code&gt; を使用してそれをカウントすることができます。</target>
        </trans-unit>
        <trans-unit id="8914db3fb9a1d0494f5a0d8fd668ced73c34d069" translate="yes" xml:space="preserve">
          <source>Now, let's define foo itself to act accordingly</source>
          <target state="translated">では、それに応じて動作するように foo 自体を定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="99be19d54cf7652a1615ab27cbc8bbf0aed5749c" translate="yes" xml:space="preserve">
          <source>Nsynjs will evaluate all operators and expressions step-by-step, pausing execution in case if result of some slow function is not ready.</source>
          <target state="translated">Nsynjs はすべての演算子と式を段階的に評価し、遅い関数の結果が準備できていない場合は実行を一時停止します。</target>
        </trans-unit>
        <trans-unit id="5a64163c890c0896f46f25e78ce25b037738ed57" translate="yes" xml:space="preserve">
          <source>Of course there are many approaches like synchronous request, promise, but from my experience I think you should use the callback approach. It's natural to asynchronous behavior of Javascript.
So, your code snippet can be rewrite a little different:</source>
          <target state="translated">もちろん同期リクエストやプロミスなどいろいろなアプローチがありますが、私の経験上、コールバックのアプローチを使うべきだと思います。これはJavascriptの非同期的な振る舞いには自然なことです。ということで、あなたのコードスニペットは少し違った書き方ができます。</target>
        </trans-unit>
        <trans-unit id="2e78929c9a21094861197c3ba952c175f274cc77" translate="yes" xml:space="preserve">
          <source>Once it receives a message to run something it adds it to the queue. The queue is the list of things that are waiting to execute (like your AJAX request). imagine it like this:</source>
          <target state="translated">いったん何かを実行するためのメッセージを受け取ると、それをキューに追加します。キューは実行を待っているもののリストです(AJAXリクエストのような)。</target>
        </trans-unit>
        <trans-unit id="9d39748eb9ce2dc97c87c582527e55724204f745" translate="yes" xml:space="preserve">
          <source>One advantage of this is that we can string these together to create sequences of future occurrences (&quot;chaining&quot;):</source>
          <target state="translated">これの利点の一つは、これらを文字列化して未来の発生のシーケンスを作成できることです(「連鎖」)。</target>
        </trans-unit>
        <trans-unit id="54016dfcceb363844e7cc4be09ec8ae272d45106" translate="yes" xml:space="preserve">
          <source>One possible solution to this problem is to code &lt;em&gt;re-actively&lt;/em&gt; , telling your program what to do when the calculation completed.</source>
          <target state="translated">この問題の考えられる解決策の1つは、コードを&lt;em&gt;再アクティブ&lt;/em&gt;にして、計算が完了したときに何をするかをプログラムに指示することです。</target>
        </trans-unit>
        <trans-unit id="6a68116dc884c578869074c6236313ddd089faa1" translate="yes" xml:space="preserve">
          <source>One possible solution to this problem is to code &lt;em&gt;re-actively&lt;/em&gt; , telling your program what to do when the calculation completed. Promises actively enable this by being temporal (time-sensitive) in nature.</source>
          <target state="translated">この問題の考えられる解決策の1つは、コードを&lt;em&gt;再アクティブ&lt;/em&gt;にして、計算が完了したときに何をするかをプログラムに指示することです。 プロミスは、本質的に時間的（時間依存）であることによってこれを積極的に有効にします。</target>
        </trans-unit>
        <trans-unit id="e3fe8189fb8e3a9175a9246ff74a29655859c5dc" translate="yes" xml:space="preserve">
          <source>Only if you have a page where you load always the same XML/JSON or whatever you need only one function. In that case, modify a little the Ajax function and replace b with your special function.</source>
          <target state="translated">常に同じXMLJSONなどを読み込んでいるページがある場合に限り、1つの関数だけで済みます。その場合は、Ajax関数を少し修正して、bをあなたの特別な関数に置き換えてください。</target>
        </trans-unit>
        <trans-unit id="5266da9d163f68f6d914c71fc5ace6c79a2e3aaa" translate="yes" xml:space="preserve">
          <source>Or (the above one is better anonymous functions are always a problem):</source>
          <target state="translated">あるいは(上の方が良いのですが、匿名関数は常に問題になります)。</target>
        </trans-unit>
        <trans-unit id="7574e85e254349a76f9eb280b8d26c2fcd432db0" translate="yes" xml:space="preserve">
          <source>Or here's a version returning a &lt;code&gt;Promise&lt;/code&gt; instead:</source>
          <target state="translated">または、代わりに &lt;code&gt;Promise&lt;/code&gt; を返すバージョンがあります。</target>
        </trans-unit>
        <trans-unit id="912172dfb14be8eb490ece32e4e426ffa381d626" translate="yes" xml:space="preserve">
          <source>Or if for some reason you &lt;code&gt;bind()&lt;/code&gt; the callback to a class:</source>
          <target state="translated">または、何らかの理由でコールバックをクラスに &lt;code&gt;bind()&lt;/code&gt; した場合：</target>
        </trans-unit>
        <trans-unit id="97548c9db4d27ac2b95bbc49510f16af46cc2fde" translate="yes" xml:space="preserve">
          <source>Or pass a full form element (&lt;code&gt;document.getElementsByTagName('form')[0]&lt;/code&gt;):</source>
          <target state="translated">または、完全なフォーム要素を渡します（ &lt;code&gt;document.getElementsByTagName('form')[0]&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="e22be26c55a52d473b9811210f17414624c87259" translate="yes" xml:space="preserve">
          <source>Or set some custom values:</source>
          <target state="translated">またはカスタム値を設定します。</target>
        </trans-unit>
        <trans-unit id="68f819f1f89dc9e0529ac2892b6d2f288badbd02" translate="yes" xml:space="preserve">
          <source>Or the Promise syntax</source>
          <target state="translated">またはプロミス構文</target>
        </trans-unit>
        <trans-unit id="afc129571bf06499cb7e3b0ffe14106bdb906a2f" translate="yes" xml:space="preserve">
          <source>Parallel</source>
          <target state="translated">Parallel</target>
        </trans-unit>
        <trans-unit id="3768a1e6d49da0cac1c978e4121bcf5a453c81eb" translate="yes" xml:space="preserve">
          <source>Possible solutions</source>
          <target state="translated">可能な解決策</target>
        </trans-unit>
        <trans-unit id="7bb1c6338f84ef633dbff9dc2ca5d6404721463d" translate="yes" xml:space="preserve">
          <source>Promises are containers for &lt;em&gt;future&lt;/em&gt; values. When the promise receives the value (it is &lt;em&gt;resolved&lt;/em&gt;) or when it is canceled (&lt;em&gt;rejected&lt;/em&gt;), it notifies all of its &quot;listeners&quot; who want to access this value.</source>
          <target state="translated">約束は&lt;em&gt;将来の&lt;/em&gt;価値のためのコンテナです。 プロミスが値を受け取る（ &lt;em&gt;解決される&lt;/em&gt; ）か、キャンセルされる（ &lt;em&gt;拒否される&lt;/em&gt; ）と、この値にアクセスするすべての「リスナー」に通知&lt;em&gt;され&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8350b08167777968ab876b41274f64fe1318e1bf" translate="yes" xml:space="preserve">
          <source>Promises can be used to unnest asynchronous functions and allows one to chain multiple functions together.</source>
          <target state="translated">プロミスは非同期関数をアンネストするために使用することができ、複数の関数を一緒に連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="c32135d34ac0c0221572109c3dfc7f43a9751b94" translate="yes" xml:space="preserve">
          <source>Quick recap on promises</source>
          <target state="translated">約束事の簡単な復習</target>
        </trans-unit>
        <trans-unit id="c235eb24c95a5e9981695eb449944a162b57ebf2" translate="yes" xml:space="preserve">
          <source>Rather than throwing code at you, there are 2 concepts that are key to understanding how JS handles callbacks and asynchronicity. (is that even a word?)</source>
          <target state="translated">コードを投げつけるのではなく、JSがコールバックと非同期性をどのように扱うかを理解する上で重要な2つの概念があります。(そんな言葉があるのか?)</target>
        </trans-unit>
        <trans-unit id="29bff7173029217e94f4afcceb94f3ce6f4a8162" translate="yes" xml:space="preserve">
          <source>Restructure your code to work properly with callbacks.</source>
          <target state="translated">コールバックで適切に動作するようにコードを再構築します。</target>
        </trans-unit>
        <trans-unit id="062f9fe8caa07becb814606e66f0cdd8c44eccb5" translate="yes" xml:space="preserve">
          <source>Return a Promise</source>
          <target state="translated">約束を返す</target>
        </trans-unit>
        <trans-unit id="da07fe527d40396d3dc18ff2bbee2077e9679bf6" translate="yes" xml:space="preserve">
          <source>Returning anything in the submit handler will not do anything. You must instead either hand off the data, or do what you want with it directly inside the success function.</source>
          <target state="translated">submit ハンドラで何かを返しても何もしません。その代わりに、データを渡すか、あるいはサクセス関数の中で直接データを処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="be64c83fb64f3829b56366e909fbacc0081629bd" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html&quot;&gt;original&lt;/a&gt; post here. But Typescript does not support &lt;a href=&quot;http://www.datchley.name/es6-promises/&quot;&gt;native es6 Promises&lt;/a&gt;, if you want to use it, you might need plugin for that.</source>
          <target state="translated">&lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html&quot;&gt;元の&lt;/a&gt;投稿はこちらです。 ただし、 &lt;a href=&quot;http://www.datchley.name/es6-promises/&quot;&gt;Typescriptはネイティブes6 Promisesを&lt;/a&gt;サポートしていません。使用する場合は、プラグインが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="40c20d94e78fa142819df8cc9440d30e65329975" translate="yes" xml:space="preserve">
          <source>Series</source>
          <target state="translated">Series</target>
        </trans-unit>
        <trans-unit id="7e56c5c8aa16c1ef6db37ada8a6266e68cceb09e" translate="yes" xml:space="preserve">
          <source>Several solutions have been given in this thread. Perhaps the easiest way is to pass an object to the &lt;code&gt;foo()&lt;/code&gt; method, and to store the results in a member of that object after the async call completes.</source>
          <target state="translated">このスレッドではいくつかの解決策が提供されています。 おそらく最も簡単な方法は、オブジェクトを &lt;code&gt;foo()&lt;/code&gt; メソッドに渡し、非同期呼び出しの完了後にそのオブジェクトのメンバーに結果を格納することです。</target>
        </trans-unit>
        <trans-unit id="2148a375d3f6b7a16b65d3a1f82733a29815e073" translate="yes" xml:space="preserve">
          <source>Short answer is, &lt;strong&gt;you have to implement a callback like this:&lt;/strong&gt;</source>
          <target state="translated">簡単に言え&lt;strong&gt;ば&lt;/strong&gt; 、 &lt;strong&gt;次のようなコールバックを実装する必要があります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">コードスニペットを表示</target>
        </trans-unit>
        <trans-unit id="ff1c87cac36b81c6f91891fbd54132c4334c4e46" translate="yes" xml:space="preserve">
          <source>Side note: Promise gotchas</source>
          <target state="translated">サイドノート:プロミスのゲッチャ</target>
        </trans-unit>
        <trans-unit id="05506c4ac3acb4d27c65c550acf4b39c197cd038" translate="yes" xml:space="preserve">
          <source>Side note: jQuery's deferred objects</source>
          <target state="translated">余談:jQueryの繰延オブジェクト</target>
        </trans-unit>
        <trans-unit id="fa5759978602e0fa347526198e20ed43cc048568" translate="yes" xml:space="preserve">
          <source>Simple usage example:</source>
          <target state="translated">簡単な使用例。</target>
        </trans-unit>
        <trans-unit id="4096759186b4f9723934ec713d75bc04761b5820" translate="yes" xml:space="preserve">
          <source>Since the operation did not happen yet (AJAX, server call, IO, timer) you're returning the value before the request got the chance to tell your code what that value is.</source>
          <target state="translated">操作はまだ起きていないので(AJAX、サーバーコール、IO、タイマー)、リクエストがその値が何であるかをコードに伝える機会を得る前に値を返しています。</target>
        </trans-unit>
        <trans-unit id="5a7e4ac52f20fc5994d25a70f507d562ec34a41e" translate="yes" xml:space="preserve">
          <source>So anything that foobarFunc needs to execute (in our case &lt;code&gt;anotherFunction&lt;/code&gt;) will get pushed onto the stack. executed, and then forgotten about - the event loop will then move onto the next thing in the queue (or listen for messages)</source>
          <target state="translated">したがって、foobarFuncを実行する必要があるもの（この場合は &lt;code&gt;anotherFunction&lt;/code&gt; ）はスタックにプッシュされます。 実行され、その後忘れられました-イベントループはキュー内の次のものに移動します（またはメッセージをリッスンします）</target>
        </trans-unit>
        <trans-unit id="4130aa961d9f8a1abff39f8f3f11e49af247d9a2" translate="yes" xml:space="preserve">
          <source>So i decided to implement my own Promise class for &lt;strong&gt;ES3 to below&lt;/strong&gt; js compilers if its not defined. Just add this code before your main code and then safely use Promise!</source>
          <target state="translated">したがって、 &lt;strong&gt;ES3の&lt;/strong&gt;独自のPromiseクラスを、それが定義されていない場合はjsコンパイラ&lt;strong&gt;以下&lt;/strong&gt;に実装することにしました。 このコードをメインコードの前に追加して、Promiseを安全に使用してください！</target>
        </trans-unit>
        <trans-unit id="519e6b95ba34166e61a9a33a9c6412ef034c0b19" translate="yes" xml:space="preserve">
          <source>So if you are using &lt;strong&gt;Angular, React&lt;/strong&gt; or any other frameworks which do &lt;strong&gt;two ways data binding&lt;/strong&gt; or &lt;strong&gt;store concept&lt;/strong&gt; this issue is simply fixed for you, so in easy word, your result is &lt;code&gt;undefined&lt;/code&gt; at the first stage, so you have got &lt;code&gt;result = undefined&lt;/code&gt; before you receive the data, then as soon as you get the result, it will be updated and get assigned to the new value which response of your Ajax call...</source>
          <target state="translated">したがって、 &lt;strong&gt;Angular、React、&lt;/strong&gt;または&lt;strong&gt;データバインディング&lt;/strong&gt;または&lt;strong&gt;ストアコンセプトの&lt;/strong&gt; &lt;strong&gt;2つの方法&lt;/strong&gt;を実行するその他のフレームワークを使用している場合、この問題は単純に修正されるため、簡単に言うと、最初の段階で結果が &lt;code&gt;undefined&lt;/code&gt; になるため、 &lt;code&gt;result = undefined&lt;/code&gt; データを受け取る前に、結果が得られるとすぐに、データが更新され、Ajax呼び出しの応答である新しい値に割り当てられます...</target>
        </trans-unit>
        <trans-unit id="456834897466e279954c59b225ffcd0a611dc23f" translate="yes" xml:space="preserve">
          <source>So there you go, that delay just broke the functionality we expected! But what exactly happened ? Well, it's actually pretty logical if you look at the code. the function &lt;code&gt;foo()&lt;/code&gt;, upon execution, returns nothing (thus returned value is &lt;code&gt;undefined&lt;/code&gt;), but it does start a timer, which executes a function after 1s to return 'wohoo'. But as you can see, the value that's assigned to bar is the immediately returned stuff from foo(), which is nothing i.e. just &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">さて、あなたはそれで終わりです、その遅延は私たちが期待した機能を壊しました！ しかし、正確には何が起こったのですか？ まあ、コードを見ると、それは実際にはかなり論理的です。 関数 &lt;code&gt;foo()&lt;/code&gt; は実行時に何も返しません（したがって、戻り値は &lt;code&gt;undefined&lt;/code&gt; です ）が、タイマーを開始し、1秒後に関数を実行して 'wohoo'を返します。 しかし、ご覧のとおり、barに割り当てられている値は、foo（）からすぐに返されるものであり、何もない、つまり単に &lt;code&gt;undefined&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3ebd3c140905d6a71bb22361b04f8129d104582a" translate="yes" xml:space="preserve">
          <source>So this works just as well. We've learned we can't return values from already asynchronous calls but we can use promises and chain them to perform processing. We now know how to return the response from an asynchronous call.</source>
          <target state="translated">ということで、これも同じように動作します。すでに非同期呼び出しをしている場合は値を返すことができないことがわかりましたが、プロミスを使ってチェーン化して処理を行うことはできます。これで、非同期呼び出しからレスポンスを返す方法がわかりました。</target>
        </trans-unit>
        <trans-unit id="16474dcce86aac08469b81e9bbfe841fd4c01c7d" translate="yes" xml:space="preserve">
          <source>So what you need to do is pass a function that is promised to execute at some point with data that is passed to it.</source>
          <target state="translated">そこで必要なのは、ある時点での実行が約束されている関数に渡されたデータを渡すことです。</target>
        </trans-unit>
        <trans-unit id="0efce20ff147121d241f07ae7346392a017a7c29" translate="yes" xml:space="preserve">
          <source>So, if you have an array (or list of some kind) and want to do async operations for each entry, you have two options: Do the operations in parallel (overlapping), or in series (one after another in sequence).</source>
          <target state="translated">つまり、配列 (あるいは何らかの種類のリスト)を持っていて、各エントリに対して非同期操作を行いたい場合、2つの選択肢があります。並行して (重複して)操作を行うか、直列に (連続して)操作を行うかです。</target>
        </trans-unit>
        <trans-unit id="4549b38f6f564b62d621d5aaa8f137985559a5b5" translate="yes" xml:space="preserve">
          <source>So, you to run the following example you need to put your access token in the request headers:</source>
          <target state="translated">そのため、以下の例を実行するには、リクエストヘッダにアクセストークンを記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="b9a422a9be9b2bc191da989656816034a1f6eee5" translate="yes" xml:space="preserve">
          <source>So: No need for error checks if you're able to copy and paste the URL properly. ;)</source>
          <target state="translated">ということで。URLをきちんとコピペすればエラーチェックの必要はありません。)</target>
        </trans-unit>
        <trans-unit id="958cd629e68ed77d9824bb75c9b43a7f1cf49e0a" translate="yes" xml:space="preserve">
          <source>Solution(s)</source>
          <target state="translated">Solution(s)</target>
        </trans-unit>
        <trans-unit id="9dbffa1e0ccfddb501d678c507c62423968b4d1e" translate="yes" xml:space="preserve">
          <source>Step 1. Wrap function with callback into nsynjs-aware wrapper (if it has promisified version, you can skip this step):</source>
          <target state="translated">ステップ1.コールバック付きの関数をnsynjs-awareのラッパーにラップします (プロミス版がある場合は、このステップはスキップできます)。</target>
        </trans-unit>
        <trans-unit id="fcdabda0acdbf7ed77f27dcb6841a85fbda15814" translate="yes" xml:space="preserve">
          <source>Step 2. Put synchronous logic into function:</source>
          <target state="translated">ステップ2.同期ロジックを関数に入れる。</target>
        </trans-unit>
        <trans-unit id="80eb86c9950baf665d77b6ad1ffb913a4fa504e2" translate="yes" xml:space="preserve">
          <source>Step 3. Run function in synchronous manner via nsynjs:</source>
          <target state="translated">ステップ3.nsynjs経由で関数を同期的に実行します。</target>
        </trans-unit>
        <trans-unit id="e79e3d8d02a013d89691c298f6bd299451c74b8a" translate="yes" xml:space="preserve">
          <source>Suppose you don't want the operations to be in parallel? If you want to run them one after another, you need to wait for each operation to complete before you start the next. Here's an example of a function that does that and calls a callback with the result:</source>
          <target state="translated">操作を並行して実行したくないとします。次から次へと実行したい場合は、それぞれの操作が完了するのを待ってから次の操作を開始する必要があります。これを実行し、その結果をコールバックとして呼び出す関数の例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="77c61919f7c0335c38d9155372ee85055a736cc1" translate="yes" xml:space="preserve">
          <source>Synchronous</source>
          <target state="translated">Synchronous</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">それは</target>
        </trans-unit>
        <trans-unit id="9111ae84fd392e9454be6a96907483945425e257" translate="yes" xml:space="preserve">
          <source>That's a simple synchronous function call (where each line of code is 'finished with its job' before the next one in sequence), and the result is same as expected.</source>
          <target state="translated">これは単純な同期関数呼び出し(コードの各行が次の行の前に「ジョブを終了」している)であり、結果は期待通りです。</target>
        </trans-unit>
        <trans-unit id="6dadcf5d4da4a50438dd8a46454bbf9f5c8a3d23" translate="yes" xml:space="preserve">
          <source>That's exactly what's happening when you do an Ajax request.</source>
          <target state="translated">まさにAjaxリクエストをした時に起こっていることです。</target>
        </trans-unit>
        <trans-unit id="c7cfbaca7087cb7a7879162ad5a4e04b1f217824" translate="yes" xml:space="preserve">
          <source>That's why with asynchronous functionality we use things called &lt;strong&gt;callbacks&lt;/strong&gt;. It's kinda like a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;promise&lt;/a&gt; quite literally. As in I &lt;em&gt;promise to return something at some point&lt;/em&gt; jQuery uses specific callbacks called &lt;code&gt;deffered.done&lt;/code&gt;&lt;code&gt;deffered.fail&lt;/code&gt; and &lt;code&gt;deffered.always&lt;/code&gt; (amongst others). You can see them all &lt;a href=&quot;https://api.jquery.com/category/deferred-object/&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">これが、非同期機能で&lt;strong&gt;コールバック&lt;/strong&gt;と呼ばれるものを使用する理由です。 それは文字通り&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;約束の&lt;/a&gt;ようなものです。 ある時点で&lt;em&gt;何かを返すこと&lt;/em&gt;を&lt;em&gt;約束するように、&lt;/em&gt; jQueryは、（とりわけ） &lt;code&gt;deffered.fail&lt;/code&gt; 、 &lt;code&gt;deffered.always&lt;/code&gt; 、およびdeffered.alwaysと呼ばれる特定のコールバックを使用します。 あなたは&lt;a href=&quot;https://api.jquery.com/category/deferred-object/&quot;&gt;ここで&lt;/a&gt;それらすべてを見ることができます</target>
        </trans-unit>
        <trans-unit id="15bb754ff5cde7f28dcd0bb70e024c67cb821f55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise API&lt;/a&gt; is a new feature of ECMAScript 6 (ES2015), but it has good &lt;a href=&quot;http://caniuse.com/#feat=promises&quot;&gt;browser support&lt;/a&gt; already. There are also many libraries which implement the standard Promises API and provide additional methods to ease the use and composition of asynchronous functions (e.g. &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;bluebird&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise API&lt;/a&gt;はECMAScript 6（ES2015）の新機能ですが、 &lt;a href=&quot;http://caniuse.com/#feat=promises&quot;&gt;ブラウザーのサポートは&lt;/a&gt;すでに良好です 。 標準のPromises APIを実装し、非同期関数の使用と構成を容易にするための追加メソッドを提供する多くのライブラリもあります（例： &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;bluebird&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8863ecce1e4cf6263ca3b1bcde858dda65b7c8db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; キーワード</target>
        </trans-unit>
        <trans-unit id="eb35c6a9a9151152e061add9aab9caeda5223463" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;A&lt;/strong&gt; in &lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;Ajax&lt;/a&gt; stands for &lt;a href=&quot;https://www.merriam-webster.com/dictionary/asynchronous&quot;&gt;&lt;strong&gt;asynchronous&lt;/strong&gt;&lt;/a&gt; . That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, &lt;code&gt;$.ajax&lt;/code&gt; returns immediately and the next statement, &lt;code&gt;return result;&lt;/code&gt;, is executed before the function you passed as &lt;code&gt;success&lt;/code&gt; callback was even called.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;Ajax&lt;/a&gt;の&lt;strong&gt;A&lt;/strong&gt;は&lt;a href=&quot;https://www.merriam-webster.com/dictionary/asynchronous&quot;&gt;&lt;strong&gt;非同期を&lt;/strong&gt;&lt;/a&gt;意味し&lt;strong&gt;ます&lt;/strong&gt; 。 つまり、要求の送信（または応答の受信）は、通常の実行フローから除外されます。 あなたの例では、 &lt;code&gt;$.ajax&lt;/code&gt; はすぐに戻り、次のステートメントは &lt;code&gt;return result;&lt;/code&gt; 、 &lt;code&gt;success&lt;/code&gt; コールバックとして渡された関数が呼び出される前に実行されます。</target>
        </trans-unit>
        <trans-unit id="fd66ac85793821d3ff7fcc5fd0246ae36ee7397a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;A&lt;/strong&gt; in AJAX stands for &lt;strong&gt;asynchronous&lt;/strong&gt;. That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29&quot;&gt;&lt;code&gt;.send&lt;/code&gt;&lt;/a&gt; returns immediately and the next statement, &lt;code&gt;return result;&lt;/code&gt;, is executed before the function you passed as &lt;code&gt;success&lt;/code&gt; callback was even called.</source>
          <target state="translated">AJAXの&lt;strong&gt;A&lt;/strong&gt;は&lt;strong&gt;非同期の&lt;/strong&gt;略です。 つまり、要求の送信（または応答の受信）は、通常の実行フローから除外されます。 あなたの例では、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29&quot;&gt; &lt;code&gt;.send&lt;/code&gt; &lt;/a&gt;はすぐに戻り、次のステートメントは &lt;code&gt;return result;&lt;/code&gt; 、 &lt;code&gt;success&lt;/code&gt; コールバックとして渡された関数が呼び出される前に実行されます。</target>
        </trans-unit>
        <trans-unit id="16490f52af9e1a9f1fc6768f3e186d1abc950e53" translate="yes" xml:space="preserve">
          <source>The ECMAScript version released in 2017 introduced &lt;em&gt;syntax-level support&lt;/em&gt; for asynchronous functions. With the help of &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;, you can write asynchronous in a &quot;synchronous style&quot;. The code is still asynchronous, but it's easier to read/understand.</source>
          <target state="translated">2017年にリリースされたECMAScriptバージョンでは、非同期関数の&lt;em&gt;構文レベルのサポートが&lt;/em&gt;導入されました。 &lt;code&gt;async&lt;/code&gt; と &lt;code&gt;await&lt;/code&gt; の助けを借りて、 非同期を「同期スタイル」で書くことができます。 コードはまだ非同期ですが、読みやすく、理解しやすくなっています。</target>
        </trans-unit>
        <trans-unit id="ecce31767a1b5e77be58da7962c0d01b010e4473" translate="yes" xml:space="preserve">
          <source>The JavaScript concurrency model in the browser and on the server with NodeJS/io.js is &lt;em&gt;asynchronous&lt;/em&gt; and &lt;em&gt;reactive&lt;/em&gt;.</source>
          <target state="translated">ブラウザおよびNodeJS / io.jsを備えたサーバーのJavaScript並行性モデルは&lt;em&gt;非同期&lt;/em&gt;で&lt;em&gt;反応し&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ca67c883bbbb71564bf5ac5f9cf7f2adffad99d0" translate="yes" xml:space="preserve">
          <source>The advantage over plain callbacks is that they allow you to decouple your code and they are easier to compose.</source>
          <target state="translated">プレーンなコールバックと比較した場合の利点は、コードを切り離すことができることと、コンパイルが容易であることです。</target>
        </trans-unit>
        <trans-unit id="480a14931d5a0da5ce02043bf95ba5bba1ea1b46" translate="yes" xml:space="preserve">
          <source>The big question is when will it get the response? The answer is we don't know - so the event loop is waiting for that message to say &quot;hey run me&quot;. If JS just waited around for that message synchronously your app would freeze and it will suck. So JS carries on executing the next item in the queue whilst waiting for the message to get added back to the queue.</source>
          <target state="translated">大きな問題は、いつレスポンスが返ってくるかということです。答えは「わからない」ということです。イベント ループは「HEY RUN ME」というメッセージを待っています。もしJSがそのメッセージを同期して待っていたら、アプリはフリーズしてしまい、最悪の結果になるでしょう。そこで JS は、メッセージがキューに追加されるのを待つ間、キューの次の項目を実行し続けます。</target>
        </trans-unit>
        <trans-unit id="ccbf0ca2fcdd4c3a3e86689a782e66920dbfdb25" translate="yes" xml:space="preserve">
          <source>The callback &lt;code&gt;...args&lt;/code&gt; are wrapped in an array and destructured when you read them so that the pattern can cope with callbacks that have multiple arguments. For example with &lt;a href=&quot;https://nodejs.org/api/fs.html&quot;&gt;node fs&lt;/a&gt;:</source>
          <target state="translated">コールバック &lt;code&gt;...args&lt;/code&gt; は配列にラップされ、それらを読み取るときに分解されるため、パターンは複数の引数を持つコールバックに対応できます。 たとえば、 &lt;a href=&quot;https://nodejs.org/api/fs.html&quot;&gt;ノードfsの場合&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="77a6ce0e24e45311bbbc8af933b3454cde1bc3ae" translate="yes" xml:space="preserve">
          <source>The callback is set directly (so no extra unnecessary closures).</source>
          <target state="translated">コールバックが直接設定されています(だから余計なクローズはしません)。</target>
        </trans-unit>
        <trans-unit id="64f9a89935bc0aec8bd8d2c2f2163e48c2e4e0d3" translate="yes" xml:space="preserve">
          <source>The classic JS approach to this problem, taking advantage of the fact that JS supports functions as first-class objects which can be passed around, is to pass a function as a parameter to the asynchronous request, which it will then invoke when it has completed its task sometime in the future. That is the &quot;callback&quot; approach. It looks like this:</source>
          <target state="translated">この問題に対するJSの古典的なアプローチは、JSが関数をファーストクラスのオブジェクトとしてサポートしていることを利用して、関数を非同期リクエストのパラメータとして渡し、将来的にタスクが完了したときに呼び出すというものです。これが「コールバック」アプローチです。これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="a4b7cb494bc59feaa54149492dcd2fc6736593a6" translate="yes" xml:space="preserve">
          <source>The computer systems we build--more and more--have time as an important dimension. Certain things are set up to happen in the future. Then other things need to happen after those first things eventually occur. This is the basic notion called &quot;asynchronicity&quot;. In our increasingly networked world, the most common case of asynchronicity is waiting for some remote system to respond to some request.</source>
          <target state="translated">私たちが構築するコンピュータシステムは-より多くの-重要な次元としての時間を持っています。ある特定のことが未来に起こるように設定されています。そして、それらの最初のことが最終的に発生した後に、他のことが起こる必要があります。これが「非同期性」と呼ばれる基本的な概念です。ますますネットワーク化が進んでいる私たちの世界では、非同期性の最も一般的なケースは、どこかのリモートシステムからのリクエストへの応答を待つことです。</target>
        </trans-unit>
        <trans-unit id="68c3c910b7e388c8ca698170706eac7d163f356e" translate="yes" xml:space="preserve">
          <source>The core issue</source>
          <target state="translated">核心的な問題</target>
        </trans-unit>
        <trans-unit id="edbb0afa295f70fd7b961434a3ea023d105f1de1" translate="yes" xml:space="preserve">
          <source>The following example I have written shows how to</source>
          <target state="translated">私が書いた次の例では、次のようにしています。</target>
        </trans-unit>
        <trans-unit id="7e2482274ea8174623353a79961f7e409558a384" translate="yes" xml:space="preserve">
          <source>The functions above are for basic use.</source>
          <target state="translated">上記の機能は基本的な使い方です。</target>
        </trans-unit>
        <trans-unit id="f0b5d408edc15ee4ab49f75c3a45e0e83fe085b1" translate="yes" xml:space="preserve">
          <source>The most perfect answer to this question is using &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">この質問に対する最も完璧な答えは、 &lt;code&gt;Promise&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">問題点</target>
        </trans-unit>
        <trans-unit id="bc0f50fb62db74196eb462d4435dbc048d27bedc" translate="yes" xml:space="preserve">
          <source>The problem with this callback approach is that it pollutes the normal semantics of a function reporting its result with &lt;code&gt;return&lt;/code&gt;; instead, functions must not reports their results by calling a callback given as a parameter. Also, this approach can rapidly become unwieldy when dealing with longer sequences of events. For example, let's say that I want to wait for the milk to be put in the coffee, and then and only then perform a third step, namely drinking the coffee. I end up needing to write something like this:</source>
          <target state="translated">このコールバックアプローチの問題は、 &lt;code&gt;return&lt;/code&gt; で結果を報告する関数の通常のセマンティクスを汚染することです。 代わりに、関数は、パラメーターとして指定されたコールバックを呼び出して結果を報告してはなりません。 また、このアプローチは、より長いイベントのシーケンスを処理するときに、急速に扱いにくくなる可能性があります。 たとえば、ミルクがコーヒーに入れられるのを待ってから、3番目のステップ、つまりコーヒーを飲むことを実行したいとします。 私はこのようなものを書く必要があります：</target>
        </trans-unit>
        <trans-unit id="32dd7ece0413b20c7f6465adba94961d1fd0156b" translate="yes" xml:space="preserve">
          <source>The question was:</source>
          <target state="translated">質問の内容は</target>
        </trans-unit>
        <trans-unit id="9865311a25d22afa6e2a491b6a5b84a1c39aeb10" translate="yes" xml:space="preserve">
          <source>The reason that doesn't work is that the callbacks from &lt;code&gt;doSomethingAsync&lt;/code&gt; haven't run yet by the time you're trying to use the results.</source>
          <target state="translated">機能しない理由は、結果を使用しようとしているときには、 &lt;code&gt;doSomethingAsync&lt;/code&gt; からのコールバックがまだ実行されていないためです。</target>
        </trans-unit>
        <trans-unit id="a2739b5dbb10ebfc12b5d81d5d32fb7cd061a55e" translate="yes" xml:space="preserve">
          <source>The same is happening when you make a function call containing &quot;normal&quot; code:</source>
          <target state="translated">普通の」コードを含む関数呼び出しをしても同じことが起きています。</target>
        </trans-unit>
        <trans-unit id="98c7c4ba758c9126f0cfa1f1637747d0674ee4fd" translate="yes" xml:space="preserve">
          <source>The simplest solution is create a JavaScript function and call it for the Ajax &lt;code&gt;success&lt;/code&gt; callback.</source>
          <target state="translated">最も簡単な解決策は、JavaScript関数を作成し、それをAjax &lt;code&gt;success&lt;/code&gt; コールバックのために呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="3d2b25517bf2d94a474aa03573586b145df347ce" translate="yes" xml:space="preserve">
          <source>The simplest:</source>
          <target state="translated">一番シンプルなのは</target>
        </trans-unit>
        <trans-unit id="6fe5eb2395efd41f10b91e16726041602d6e3143" translate="yes" xml:space="preserve">
          <source>The solution will be to avoid callbacks, and use a combination of &lt;strong&gt;Promises&lt;/strong&gt; and &lt;strong&gt;async/await&lt;/strong&gt;.</source>
          <target state="translated">解決策は、コールバックを回避し、 &lt;strong&gt;Promise&lt;/strong&gt;と&lt;strong&gt;async / awaitの&lt;/strong&gt;組み合わせを使用することです。</target>
        </trans-unit>
        <trans-unit id="9dec62eb819ee8ace8aad60238eecf9a7f4fb514" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a&lt;/code&gt; returned is &lt;code&gt;undefined&lt;/code&gt; since the &lt;code&gt;a=5&lt;/code&gt; part has not executed yet. AJAX acts like this, you're returning the value before the server got the chance to tell your browser what that value is.</source>
          <target state="translated">&lt;code&gt;a=5&lt;/code&gt; の部分はまだ実行されていないため、返される値は &lt;code&gt;undefined&lt;/code&gt; です。 AJAXはこのように動作し、サーバーがブラウザーにその値が何であるかを伝える機会を得る前に値を返します。</target>
        </trans-unit>
        <trans-unit id="8d1a490aef5366b80c665df9adb0416c82e381c5" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; since the &lt;code&gt;data = 5&lt;/code&gt; part has not executed yet. It will likely execute in a second but by that time it is irrelevant to the returned value.</source>
          <target state="translated">&lt;code&gt;data = 5&lt;/code&gt; パートはまだ実行されていないため、 dataの値は &lt;code&gt;undefined&lt;/code&gt; です。 おそらく1秒で実行されますが、その時点では戻り値とは無関係です。</target>
        </trans-unit>
        <trans-unit id="587b206c7db5b969cdb5a40887824aa9c5099e73" translate="yes" xml:space="preserve">
          <source>There are basically two ways how to solve this:</source>
          <target state="translated">基本的には2つの解決方法があります。</target>
        </trans-unit>
        <trans-unit id="2cf0b130ac11e32c400e435be4fa43654576f982" translate="yes" xml:space="preserve">
          <source>There are some other situations which I don't remember that make the XMLHttpRequest 1 annoying.</source>
          <target state="translated">他にも、XMLHttpRequest1がめんどくさいと思うような状況がいくつかありますが、私は覚えていません。</target>
        </trans-unit>
        <trans-unit id="dd643d6829dc9f26a331e2bce21e4a3e98d834bc" translate="yes" xml:space="preserve">
          <source>There are three things you need to be aware of; &lt;strong&gt;The queue; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop&quot;&gt;the event loop&lt;/a&gt; and the stack&lt;/strong&gt;</source>
          <target state="translated">注意する必要のある3つの点があります。 &lt;strong&gt;待ち行列;&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop&quot;&gt;イベントループ&lt;/a&gt;とスタック&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4498030a163e78ec8715dffc1c0ce5911aba4b0c" translate="yes" xml:space="preserve">
          <source>There are two ways to get the response of this Ajax call (three using the XMLHttpRequest var name):</source>
          <target state="translated">このAjaxコールのレスポンスを取得するには2つの方法があります(XMLHttpRequest var名を使った3つの方法)。</target>
        </trans-unit>
        <trans-unit id="37cfc454d35f84e510806797d964ad848a95604e" translate="yes" xml:space="preserve">
          <source>There is a problem with using promises!</source>
          <target state="translated">プロミスを使うことに問題がある!</target>
        </trans-unit>
        <trans-unit id="7d46baf54c6d620b802f531b3e92d3841965a2a5" translate="yes" xml:space="preserve">
          <source>There is no other way to do this in a non-asynchronous way. (Yeah, with setTimeout loop... but seriously?)</source>
          <target state="translated">非同期でやる方法は他にない。(ええ、setTimeoutループで...でもマジで?)</target>
        </trans-unit>
        <trans-unit id="8511f0c06778d891bba10da5d78a325fa162981f" translate="yes" xml:space="preserve">
          <source>There is only the &lt;code&gt;this.type&lt;/code&gt; which is set to error.</source>
          <target state="translated">エラーに設定されている &lt;code&gt;this.type&lt;/code&gt; のみがあります。</target>
        </trans-unit>
        <trans-unit id="c974cb400663a76c12df4912d445ea3637c72efb" translate="yes" xml:space="preserve">
          <source>This code misunderstands the above asynchrony issues. Specifically, &lt;code&gt;$.ajax()&lt;/code&gt; doesn't freeze the code while it checks the '/password' page on your server - it sends a request to the server and while it waits, it immediately returns a jQuery Ajax Deferred object, not the response from the server. That means the &lt;code&gt;if&lt;/code&gt; statement is going to always get this Deferred object, treat it as &lt;code&gt;true&lt;/code&gt;, and proceed as though the user is logged in. Not good.</source>
          <target state="translated">このコードは、上記の非同期の問題を誤解しています。 具体的には、 &lt;code&gt;$.ajax()&lt;/code&gt; はサーバーの「/ password」ページをチェックしている間はコードをフリーズしません-サーバーにリクエストを送信し、待機している間、応答ではなくjQuery Ajax Deferredオブジェクトをすぐに返しますサーバーから。 つまり、 &lt;code&gt;if&lt;/code&gt; ステートメントは常にこのDeferredオブジェクトを取得し、それを &lt;code&gt;true&lt;/code&gt; として扱い、ユーザーがログインしているように処理します。</target>
        </trans-unit>
        <trans-unit id="244afc8d38402f6d7c12baa9c3d841505fe06988" translate="yes" xml:space="preserve">
          <source>This is a short summary of &quot;Explanation of the problem&quot; from the other answer, if you're not sure after reading this, read that.</source>
          <target state="translated">他の解答から「問題の解説」を簡潔にまとめたものですので、これを読んでわからなくなった方はそちらを読んでみてください。</target>
        </trans-unit>
        <trans-unit id="bec8301fa7c95d68f2971235b818a4ec00cf9186" translate="yes" xml:space="preserve">
          <source>This is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt;. Basically, we're passing &lt;code&gt;getFive&lt;/code&gt; an action to perform when it completes, we're telling our code how to react when an event completes (like our AJAX call, or in this case the timeout).</source>
          <target state="translated">これは&lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt;と呼ばれます。 基本的に、 &lt;code&gt;getFive&lt;/code&gt; にアクションが完了したときに実行するアクションを渡し、イベントが完了したとき（AJAX呼び出し、またはこの場合はタイムアウト）にどのように反応するかをコードに指示しています。</target>
        </trans-unit>
        <trans-unit id="e37cc018b8dd7866206ff24c3bd04692ca34d6e0" translate="yes" xml:space="preserve">
          <source>This is one of the places which &lt;strong&gt;two ways data binding&lt;/strong&gt; or &lt;strong&gt;store concept&lt;/strong&gt; that's used in many new JavaScript frameworks will work great for you...</source>
          <target state="translated">これは、多くの新しいJavaScriptフレームワークで使用されている&lt;strong&gt;2つの方法のデータバインディング&lt;/strong&gt;または&lt;strong&gt;ストアコンセプト&lt;/strong&gt;がうまく機能する場所の1つです...</target>
        </trans-unit>
        <trans-unit id="87baabf09170470e02be100dac74857e2ebc1619" translate="yes" xml:space="preserve">
          <source>This is quite simple:</source>
          <target state="translated">これはかなりシンプルです。</target>
        </trans-unit>
        <trans-unit id="95b540890727eecbe058d586198261782083d7c0" translate="yes" xml:space="preserve">
          <source>This means AngularJS, jQuery (with deferred), native XHR's replacement (fetch), EmberJS, BackboneJS's save or any node library that returns promises.</source>
          <target state="translated">これは、AngularJS、jQuery(with deferred)、ネイティブXHRの置換(fetch)、EmberJS、BackboneJSのsave、またはプロミスを返す任意のノードライブラリを意味します。</target>
        </trans-unit>
        <trans-unit id="b3d9c5469e4b15f9c162fb643af29c9f5ca05645" translate="yes" xml:space="preserve">
          <source>This means when you're returning &lt;code&gt;data&lt;/code&gt; the &lt;code&gt;then&lt;/code&gt; handler you've defined did not execute yet. This in turn means that the value you're returning has not been set to the correct value in time.</source>
          <target state="translated">これは、 &lt;code&gt;data&lt;/code&gt; 返すときに、定義した &lt;code&gt;then&lt;/code&gt; ハンドラがまだ実行されていないことを意味します。 これは、返される値が時間内に正しい値に設定されていないことを意味します。</target>
        </trans-unit>
        <trans-unit id="f01778d1944777ab6b8f39abe10e8afdd7a72058" translate="yes" xml:space="preserve">
          <source>This means when you're returning, the listener you've defined did not execute yet, which means the value you're returning has not been defined.</source>
          <target state="translated">これは、返すときに定義したリスナーがまだ実行されていないことを意味します。</target>
        </trans-unit>
        <trans-unit id="61ed4646f32a3a1ac23ad5fb1d6851ea5f3992d0" translate="yes" xml:space="preserve">
          <source>This method returns a promise itself, which we can consume from other coroutines. For example:</source>
          <target state="translated">このメソッドは、他のコルーチンから消費できるプロミスそのものを返します。例えば</target>
        </trans-unit>
        <trans-unit id="6d9e63f07d1d652a68998572e1a51ce636590916" translate="yes" xml:space="preserve">
          <source>This somewhat tricky but very powerful trick lets us write asynchronous code in a synchronous manner. There are several &quot;runners&quot; that do this for you, writing one is a short few lines of code but is beyond the scope of this answer. I'll be using Bluebird's &lt;code&gt;Promise.coroutine&lt;/code&gt; here, but there are other wrappers like &lt;code&gt;co&lt;/code&gt; or &lt;code&gt;Q.async&lt;/code&gt;.</source>
          <target state="translated">このややトリッキーですが非常に強力なトリックにより、非同期コードを同期的に記述できます。 これを実行する「ランナー」がいくつかあります。1つは短いコード行ですが、この回答の範囲を超えています。 ここではBluebirdの &lt;code&gt;Promise.coroutine&lt;/code&gt; を使用しますが、 &lt;code&gt;co&lt;/code&gt; や &lt;code&gt;Q.async&lt;/code&gt; などの他のラッパーもあります。</target>
        </trans-unit>
        <trans-unit id="7419d91a7773bb18e95de8945a17e396a7138932" translate="yes" xml:space="preserve">
          <source>This stands the same for your original API call, you can:</source>
          <target state="translated">これは、あなたの元のAPIコールのために同じ立っている、あなたはすることができます。</target>
        </trans-unit>
        <trans-unit id="b4c2a28333fa2716b1c47a4f0a2e18a4d80475ff" translate="yes" xml:space="preserve">
          <source>This was the motivation for the notion of a &quot;promise&quot;, which is a particular type of value which represents a &lt;strong&gt;future&lt;/strong&gt; or &lt;strong&gt;asynchronous&lt;/strong&gt; outcome of some sort. It can represent something that already happened, or that is going to happen in the future, or might never happen at all. Promises have a single method, named &lt;code&gt;then&lt;/code&gt;, to which you pass an action to be executed when the outcome the promise represents has been realized.</source>
          <target state="translated">これが、「約束」という概念の動機でした。これは、ある種の&lt;strong&gt;将来&lt;/strong&gt;または&lt;strong&gt;非同期の&lt;/strong&gt;結果を表す特定のタイプの値です。 これは、すでに発生した、または将来発生する、またはまったく発生しない可能性のある何かを表すことができます。 Promiseには &lt;code&gt;then&lt;/code&gt; という名前の単一のメソッドがあり、Promiseが表す結果が実現されたときに実行するアクションを渡します。</target>
        </trans-unit>
        <trans-unit id="c88099e25e362faf93b5c34442314fc0efbfd023" translate="yes" xml:space="preserve">
          <source>This working example is self-contained. It will define a simple request object that uses the window &lt;code&gt;XMLHttpRequest&lt;/code&gt; object to make calls. It will define a simple function to wait for a bunch of promises to be completed.</source>
          <target state="translated">この作業例は自己完結型です。 これは、ウィンドウ &lt;code&gt;XMLHttpRequest&lt;/code&gt; オブジェクトを使用して呼び出しを行う単純な要求オブジェクトを定義します。 一連の約束が完了するのを待つ単純な関数を定義します。</target>
        </trans-unit>
        <trans-unit id="bb4a902028592cca405a4e54f7447a6dd933acce" translate="yes" xml:space="preserve">
          <source>Thus Solution to this is &lt;em&gt;callback&lt;/em&gt; or &lt;em&gt;promise&lt;/em&gt;.</source>
          <target state="translated">したがって、これに対する解決策は、 &lt;em&gt;コールバック&lt;/em&gt;または&lt;em&gt;約束&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="7a4ac77e33ad1dc33272e4765092ee238e7b4067" translate="yes" xml:space="preserve">
          <source>Thus, the summary is - to tackle the asynchronous functions like ajax based calls etc., you can use a promise to &lt;code&gt;resolve&lt;/code&gt; the value (which you intend to return). Thus, in short you &lt;strong&gt;resolve&lt;/strong&gt; value instead of &lt;strong&gt;returning&lt;/strong&gt;, in asynchronous functions.</source>
          <target state="translated">したがって、要約は-ajaxベースの呼び出しなどの非同期関数に取り組む &lt;code&gt;resolve&lt;/code&gt; 、値を解決するためにプロミスを使用できます（返すことを意図しています）。 したがって、要するに、非同期関数でを&lt;strong&gt;返す&lt;/strong&gt;代わりに値を&lt;strong&gt;解決し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a0a2dcdf916f3c7cf3b91ae00bbe537935bc5316" translate="yes" xml:space="preserve">
          <source>To run the above code you do this:</source>
          <target state="translated">上記のコードを実行するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="2e8f0671297e82a3357b05f76d4c39dd6732c8f7" translate="yes" xml:space="preserve">
          <source>UPDATE (Promises with async/await)</source>
          <target state="translated">UPDATE (asyncawaitによるプロミス)</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e3b2c87fbdfa81069562e3801f3b834f583f3068" translate="yes" xml:space="preserve">
          <source>Usage would be:</source>
          <target state="translated">使用法はこうだろう。</target>
        </trans-unit>
        <trans-unit id="4ba1f4e931dcc6adc1af6d22a6e4e7abed5a85b2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt; pattern to join multiple HTTP calls;</source>
          <target state="translated">複数のHTTP呼び出しに参加するには、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt;パターンを使用します。</target>
        </trans-unit>
        <trans-unit id="e698b02ca0c7b2228f7ccbc8c4b111e743e10e2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;Promise&lt;/a&gt; pattern;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;Promise&lt;/a&gt;パターンを使用します。</target>
        </trans-unit>
        <trans-unit id="0e9a58ba6887bb7e51147aa2da4a49a0486ce969" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;callback()&lt;/code&gt; function inside the &lt;code&gt;foo()&lt;/code&gt; success.
Try in this way. It is simple and easy to understand. &amp;nbsp;</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; 成功内で &lt;code&gt;callback()&lt;/code&gt; 関数を使用します 。 このようにしてみてください。 シンプルでわかりやすいです。</target>
        </trans-unit>
        <trans-unit id="606944b24d98d72b39627fdefe858efa8d964a89" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;'await'&lt;/a&gt;, which will tell JavaScript to await the promise to be resolved into a value (like the HTTP response)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;「await」を&lt;/a&gt;使用します。これにより、JavaScriptが値に解決されるという約束（HTTP応答など）を待つように指示されます。</target>
        </trans-unit>
        <trans-unit id="a11fcc742eebbcfca3c5bb6597892f401f073e0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;strong&gt;asynchronous&lt;/strong&gt; code as if it were &lt;strong&gt;synchronous&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;非同期&lt;/strong&gt;コードを&lt;strong&gt;同期の&lt;/strong&gt;ように使用し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="50df00102216ee2fa6b8d3f60a71c04beba81fe1" translate="yes" xml:space="preserve">
          <source>Using ES2017 you should have this as the function declaration</source>
          <target state="translated">ES2017を使用すると、関数宣言として以下のようになるはずです。</target>
        </trans-unit>
        <trans-unit id="cc12d7b012ca1bfa32bf1aa97b798db2031c84f8" translate="yes" xml:space="preserve">
          <source>Using Promise</source>
          <target state="translated">プロミスの利用</target>
        </trans-unit>
        <trans-unit id="28685eec146d7abeed631f689f722a157cd3cd31" translate="yes" xml:space="preserve">
          <source>Using callback concept - As implementation in first answer</source>
          <target state="translated">コールバックの概念を使う-ファーストアンサーでの実装として</target>
        </trans-unit>
        <trans-unit id="c787b69b8c1dad213e2bced9dc421d4fbabcda2a" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;XMLHttpRequest&lt;/code&gt; variable name is another big error as you need to execute the callback inside the onload/oreadystatechange closures else you lost it.</source>
          <target state="translated">&lt;code&gt;XMLHttpRequest&lt;/code&gt; 変数名を使用すると、もう1つの大きなエラーになります。それは、onload / oreadystatechangeクロージャー内でコールバックを実行する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="b7ce43e50f1c7276c7fa06bbf7c04a9872a17966" translate="yes" xml:space="preserve">
          <source>Wait for response from each API call;</source>
          <target state="translated">各APIコールからのレスポンスを待ちます。</target>
        </trans-unit>
        <trans-unit id="35c239d949f8723db6cf2fca7425f52803d0c967" translate="yes" xml:space="preserve">
          <source>We find ourselves in a universe which appears to progress along a dimension we call &quot;time&quot;. We don't really understand what time is, but we have developed abstractions and vocabulary that let us reason and talk about it: &quot;past&quot;, &quot;present&quot;, &quot;future&quot;, &quot;before&quot;, &quot;after&quot;.</source>
          <target state="translated">私たちは、私たちが「時間」と呼ぶ次元に沿って進行しているように見える宇宙の中にいる。私たちは時間が何であるか理解していませんが、私たちは時間について推論したり話したりするための抽象化と語彙を開発してきました。&quot;過去」「現在」「未来」「前」「後」。</target>
        </trans-unit>
        <trans-unit id="cf190ebdec93ca0293df429352a161bff1aed4e0" translate="yes" xml:space="preserve">
          <source>We have now made our foo function accept an action to run when the AJAX completes successfully, we can extend this further by checking if the response status is not 200 and acting accordingly (create a fail handler and such). Effectively solving our issue.</source>
          <target state="translated">AJAXが正常に完了したときに実行されるアクションを受け入れるようにfoo関数を作ったので、レスポンスのステータスが200でないかどうかをチェックして、それに応じて行動することでこれをさらに拡張することができます(failハンドラなどを作る)。実質的に問題を解決しています。</target>
        </trans-unit>
        <trans-unit id="ac71c9a45e5e5d552a308fe3128d89db33f20f8b" translate="yes" xml:space="preserve">
          <source>What you're facing</source>
          <target state="translated">あなたが直面していること</target>
        </trans-unit>
        <trans-unit id="d9e7e738a86ea5326f809837e5b5ea81f305f671" translate="yes" xml:space="preserve">
          <source>When one of these messages is going to execute it pops the message from the queue and creates a stack, the stack is everything JS needs to execute to perform the instruction in the message. So in our example it's being told to call &lt;code&gt;foobarFunc&lt;/code&gt;</source>
          <target state="translated">これらのメッセージの1つが実行されると、メッセージがキューからポップされ、スタックが作成されます。スタックは、JSがメッセージ内の命令を実行するために実行する必要があるすべてのものです。 したがって、この例では、 &lt;code&gt;foobarFunc&lt;/code&gt; を呼び出すように指示されています。</target>
        </trans-unit>
        <trans-unit id="46e5db5a04236061d5766214e29fc62f17454cbf" translate="yes" xml:space="preserve">
          <source>When using promises, we end up passing lots of functions into &lt;code&gt;then&lt;/code&gt;, so it's often helpful to use the more compact ES6-style arrow functions:</source>
          <target state="translated">promiseを使用すると、多くの関数が &lt;code&gt;then&lt;/code&gt; に渡されるため、よりコンパクトなES6スタイルの矢印関数を使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="b23496e842dceff9fb3a521cbe84a712262e3f34" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;.then&lt;/code&gt; on a promise and &lt;em&gt;return&lt;/em&gt; something from it - we get a promise for &lt;em&gt;the processed value&lt;/em&gt;. If we return another promise we'll get amazing things, but let's hold our horses.</source>
          <target state="translated">&lt;code&gt;.then&lt;/code&gt; をプロミスで呼び出し、そこから何かを&lt;em&gt;返す&lt;/em&gt;と&lt;em&gt;、処理された値の&lt;/em&gt;プロミスが得られ&lt;em&gt;ます&lt;/em&gt; 。 別の約束を返せば素晴らしいものを手に入れられますが、馬を抱きましょう。</target>
        </trans-unit>
        <trans-unit id="d987b91f60f98a1b758f0e53d90290815d18964e" translate="yes" xml:space="preserve">
          <source>When you make a call using AJAX to an external party or run any asynchronous code (a setTimeout for example), Javascript is dependant upon a response before it can proceed.</source>
          <target state="translated">外部パーティへのAJAXを使用して呼び出しを行うか、任意の非同期コード(例えばsetTimeout)を実行するとき、Javascriptはそれが進むことができる前に応答に依存しています。</target>
        </trans-unit>
        <trans-unit id="380b904db5976f20d5318f6cc1191c770d1da13f" translate="yes" xml:space="preserve">
          <source>Whenever you call a method that returns a promise, the &lt;code&gt;then&lt;/code&gt; handlers are &lt;em&gt;always&lt;/em&gt; executed asynchronously - that is, &lt;strong&gt;after&lt;/strong&gt; the code below them that is not in a &lt;code&gt;.then&lt;/code&gt; handler.</source>
          <target state="translated">promiseを返すメソッドを呼び出すと、 &lt;code&gt;then&lt;/code&gt; ハンドラーは&lt;em&gt;常に&lt;/em&gt;非同期で実行されます。つまり、 &lt;code&gt;.then&lt;/code&gt; ハンドラー内にない、その下のコードの&lt;strong&gt;後に&lt;/strong&gt;あります。</target>
        </trans-unit>
        <trans-unit id="42feb8ea413f33209ece4d328587c570e4d54ebe" translate="yes" xml:space="preserve">
          <source>Which should alert &quot;5&quot; to the screen. &lt;a href=&quot;http://jsfiddle.net/PAjZR/&quot;&gt;(Fiddle)&lt;/a&gt;.</source>
          <target state="translated">画面に「5」を警告する必要があります。 &lt;a href=&quot;http://jsfiddle.net/PAjZR/&quot;&gt;（フィドル）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec5557762b5410ae1ddd3eb2b67bfdb2da22a4ce" translate="yes" xml:space="preserve">
          <source>While it is &lt;em&gt;okay&lt;/em&gt; in small examples it gets annoying when you have a lot of similar cases and error handling involved.</source>
          <target state="translated">小さな例では&lt;em&gt;問題あり&lt;/em&gt;ませんが、同様のケースが多く、エラー処理が関係している場合は、煩わしくなります。</target>
        </trans-unit>
        <trans-unit id="1450bd8677cf37b475780df43411df3cca8f006a" translate="yes" xml:space="preserve">
          <source>While promises and callbacks work fine in many situations, it is a pain in the rear to express something like:</source>
          <target state="translated">約束やコールバックは多くの場面でうまく機能しますが、何かを表現するのは後ろめんどくさいです。</target>
        </trans-unit>
        <trans-unit id="448c4cc13812bccdb5367397d714ad86dd6ea552" translate="yes" xml:space="preserve">
          <source>Why add an error handler if you totally have no control over errors?
Most of the errors are returned inside this in the callback function &lt;code&gt;displayAjax()&lt;/code&gt;.</source>
          <target state="translated">エラーを完全に制御できないのに、なぜエラーハンドラを追加するのですか？ ほとんどのエラーは、コールバック関数 &lt;code&gt;displayAjax()&lt;/code&gt; でこの内部に返されます。</target>
        </trans-unit>
        <trans-unit id="5edfc082aa90912642ae681f74a76ece5088c8fa" translate="yes" xml:space="preserve">
          <source>Why is it bad do you ask?</source>
          <target state="translated">なぜそれが悪いことなのか、あなたは尋ねますか?</target>
        </trans-unit>
        <trans-unit id="1229758f7e8ec3a149e87560402cc78e508a43de" translate="yes" xml:space="preserve">
          <source>Why should we use our own custom Promise?</source>
          <target state="translated">なぜ独自のカスタムプロミスを利用する必要があるのか?</target>
        </trans-unit>
        <trans-unit id="ece375bff4b483047da3749860748c38927e530d" translate="yes" xml:space="preserve">
          <source>With promises</source>
          <target state="translated">約束事で</target>
        </trans-unit>
        <trans-unit id="0c0a59fb074de0fc1fd7cee2f49870f337cc9102" translate="yes" xml:space="preserve">
          <source>Without jQuery</source>
          <target state="translated">jQueryを使わずに</target>
        </trans-unit>
        <trans-unit id="b5fea0abea018388c5315d97c39b4081a7cb703a" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest API</source>
          <target state="translated">XMLHttpRequest API</target>
        </trans-unit>
        <trans-unit id="e73644d1d710900fb613359a5f23e329c06b46fe" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest supports both synchronous and asynchronous communications. In general, however, asynchronous requests should be preferred to synchronous requests for performance reasons.</source>
          <target state="translated">XMLHttpRequest は同期通信と非同期通信の両方をサポートしています。しかし一般的には、パフォーマンス上の理由から同期通信よりも非同期通信の方が優先されるべきです。</target>
        </trans-unit>
        <trans-unit id="b9b7f311a0fbfaead32e2e31dba1d379c239df35" translate="yes" xml:space="preserve">
          <source>Yes, you can.</source>
          <target state="translated">はい、できます。</target>
        </trans-unit>
        <trans-unit id="83fb6a0fad9feb9e391f4aec4d78ee5495226649" translate="yes" xml:space="preserve">
          <source>You are using Ajax incorrectly. The idea is not to have it return anything, but instead hand off the data to something called a callback function, which handles the data.</source>
          <target state="translated">Ajaxの使い方が間違っています。何かを返すのではなく、コールバック関数と呼ばれるものにデータを渡して、そのデータを処理するという考え方です。</target>
        </trans-unit>
        <trans-unit id="f394fee622b97599e0a31a6f0f4cd4cc68870f7c" translate="yes" xml:space="preserve">
          <source>You call your friend again for the same reason. But this time you tell him that you are in a hurry and he should &lt;em&gt;call you back&lt;/em&gt; on your mobile phone. You hang up, leave the house and do whatever you planned to do. Once your friend calls you back, you are dealing with the information he gave to you.</source>
          <target state="translated">同じ理由で友達に再度電話をかけます。 しかし、今度はあなたが急いでいるので、彼はあなたの携帯電話に&lt;em&gt;かけ直す&lt;/em&gt;べきだと彼に&lt;em&gt;言います&lt;/em&gt; 。 あなたは電話を切り、家を出て、あなたが計画していたことを何でもします。 あなたの友人があなたに電話をかけたら、あなたは彼があなたに与えた情報を扱います。</target>
        </trans-unit>
        <trans-unit id="d2bd21947364482b0aca338a6b437d78f80037e7" translate="yes" xml:space="preserve">
          <source>You can also process the response before passing it to the callback:</source>
          <target state="translated">また、コールバックに渡す前にレスポンスを処理することもできます。</target>
        </trans-unit>
        <trans-unit id="3beb8e59419ebd09fc9891e40ffa62d7e41da4e2" translate="yes" xml:space="preserve">
          <source>You can checkout the project &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;ここで&lt;/a&gt;プロジェクトをチェックアウトできます 。</target>
        </trans-unit>
        <trans-unit id="9a399a6f3ef2aa4bf612fdbeaabb5190ec6b5790" translate="yes" xml:space="preserve">
          <source>You can consume that in this way,</source>
          <target state="translated">このように消費することができます。</target>
        </trans-unit>
        <trans-unit id="0c470949a5de51b9f217c1f0fc0cf12e324c19e0" translate="yes" xml:space="preserve">
          <source>You can find a nice explanation &lt;a href=&quot;http://andyshora.com/promises-angularjs-explained-as-cartoon.html&quot;&gt;here&lt;/a&gt; also.</source>
          <target state="translated">&lt;a href=&quot;http://andyshora.com/promises-angularjs-explained-as-cartoon.html&quot;&gt;ここに&lt;/a&gt;も素敵な説明があります。</target>
        </trans-unit>
        <trans-unit id="3a480682174de8f801e99da50379e04d8ac8ac06" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; on MDN.</source>
          <target state="translated">あなたは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;についてもっと読むことができ、MDNで&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="ca259db921dc5475dee1f9c068034b544e83ec7f" translate="yes" xml:space="preserve">
          <source>You can start all of them and keep track of how many callbacks you're expecting, and then use the results when you've gotten that many callbacks:</source>
          <target state="translated">全部起動して、どれだけのコールバックを期待しているのかを記録しておき、それだけのコールバックを得たときに結果を利用することができます。</target>
        </trans-unit>
        <trans-unit id="00f65b8b36a713a1b70d47398be1c721ed3fffd5" translate="yes" xml:space="preserve">
          <source>You can then see a nested Promise structure, that lets you spawn multiple and completely asynchronous nested HTTP calls, and join the results from each subset of calls through &lt;code&gt;Promise.all&lt;/code&gt;.</source>
          <target state="translated">次に、ネストされたPromise構造を確認できます。これにより、複数の完全に非同期のネストされたHTTP呼び出しを生成し、 &lt;code&gt;Promise.all&lt;/code&gt; を介して呼び出しの各サブセットの結果を結合できます。</target>
        </trans-unit>
        <trans-unit id="5637817dac7360e2bf1c7c2d1626c7be889d259e" translate="yes" xml:space="preserve">
          <source>You can use a &lt;strong&gt;callback&lt;/strong&gt;, &lt;strong&gt;promise&lt;/strong&gt; and recently &lt;strong&gt;observable&lt;/strong&gt; to handle it for you, for example in promises we have some function like &lt;code&gt;success()&lt;/code&gt; or &lt;code&gt;then()&lt;/code&gt; which will be executed when your data is ready for you, same with callback or &lt;strong&gt;subscribe&lt;/strong&gt; function on &lt;strong&gt;observable&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;コールバック&lt;/strong&gt; 、 &lt;strong&gt;promise&lt;/strong&gt; 、最近&lt;strong&gt;観察可能に&lt;/strong&gt;してそれを処理できます。たとえば&lt;strong&gt;promise&lt;/strong&gt;には、データの準備ができたときに実行される &lt;code&gt;success()&lt;/code&gt; または &lt;code&gt;then()&lt;/code&gt; などの関数があり、コールバックまたは&lt;strong&gt;サブスクライブ&lt;/strong&gt;関数と同じです。 &lt;strong&gt;観測可能&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="3aedc25db58a4804737e831c476a6e6a972dbab8" translate="yes" xml:space="preserve">
          <source>You can use this custom library (written using Promise) to make a remote call.</source>
          <target state="translated">このカスタムライブラリ(Promiseを使って書かれています)を使って、リモートコールを行うことができます。</target>
        </trans-unit>
        <trans-unit id="dd6628c5f45797d9ea0f78c8fc099d6704e851a0" translate="yes" xml:space="preserve">
          <source>You'd end up going through &lt;code&gt;async1&lt;/code&gt;; check if &lt;code&gt;name&lt;/code&gt; is undefined or not and call the callback accordingly.</source>
          <target state="translated">最終的に &lt;code&gt;async1&lt;/code&gt; を通過することになります。 &lt;code&gt;name&lt;/code&gt; が未定義かどうかを確認し、それに応じてコールバックを呼び出します。</target>
        </trans-unit>
        <trans-unit id="bd8715a64e94539f3c8b8df1772b0c03d902cf35" translate="yes" xml:space="preserve">
          <source>Your code should be something along the lines of this:</source>
          <target state="translated">あなたのコードは以下のようなものになるはずです。</target>
        </trans-unit>
        <trans-unit id="79d239c9d4dd6e9398d601a54d23e6f15a901265" translate="yes" xml:space="preserve">
          <source>async/await version:</source>
          <target state="translated">asyncawaitバージョン。</target>
        </trans-unit>
        <trans-unit id="5fa5455b316d09922e2556fd3e7db0992016d6bb" translate="yes" xml:space="preserve">
          <source>await is supported in all current browsers and node 8</source>
          <target state="translated">await は現在のすべてのブラウザとノード 8 でサポートされています。</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="6cdd908e77bf13956316a9dfb985f596f59e72fe" translate="yes" xml:space="preserve">
          <source>but if &lt;code&gt;a&lt;/code&gt; is asynchronous, with promises we have to write</source>
          <target state="translated">しかし、 &lt;code&gt;a&lt;/code&gt; が非同期の場合、約束を付けて、</target>
        </trans-unit>
        <trans-unit id="ba1108cd1f24e45036a47d4005ece995c5fe8b5d" translate="yes" xml:space="preserve">
          <source>cross-domain not allowed throws error automatically.</source>
          <target state="translated">クロスドメインが許可されていない場合は自動的にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="3691b5c9d0eec5124fbea2e6256064c9e642e83e" translate="yes" xml:space="preserve">
          <source>for instance,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="00853d73f19844948fadbc48d500f997c46f7ee4" translate="yes" xml:space="preserve">
          <source>jQuery</source>
          <target state="translated">jQuery</target>
        </trans-unit>
        <trans-unit id="c6ba4cdd11e1a3db37a54109474e9c73534b938a" translate="yes" xml:space="preserve">
          <source>jQuery deferred</source>
          <target state="translated">じゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅくじゅじょ</target>
        </trans-unit>
        <trans-unit id="fba0ae53da33f0cd5e54603774b1229ca748fbd7" translate="yes" xml:space="preserve">
          <source>nsynjs will evaluate all promises sequentially, and put promise result into &lt;code&gt;data&lt;/code&gt; property:</source>
          <target state="translated">nsynjsはすべてのpromiseを順番に評価し、promiseの結果を &lt;code&gt;data&lt;/code&gt; プロパティに入れます：</target>
        </trans-unit>
        <trans-unit id="e1a5e2d288843cc0d03987443a6fc38bffe1ef80" translate="yes" xml:space="preserve">
          <source>onreadystatechange is only useful if you want to get the headers on state 2.</source>
          <target state="translated">onreadystatechange は、状態 2 のヘッダを取得したい場合にのみ有用です。</target>
        </trans-unit>
        <trans-unit id="0458efd542acc1a7aebda8d34461df3c13d76b38" translate="yes" xml:space="preserve">
          <source>so most of the time (but not always) you'll pass &lt;code&gt;foo&lt;/code&gt; not &lt;code&gt;foo()&lt;/code&gt;</source>
          <target state="translated">ほとんどの場合（常にではありませんが） &lt;code&gt;foo()&lt;/code&gt; ではなくfooを渡します</target>
        </trans-unit>
        <trans-unit id="88018d8629c033501aa21a3ab6e24d7aebd65b57" translate="yes" xml:space="preserve">
          <source>then/catch version:</source>
          <target state="translated">をキャッチしたバージョンです。</target>
        </trans-unit>
        <trans-unit id="3aee67424c6f45abebfaef894361e9c0e7ddd958" translate="yes" xml:space="preserve">
          <source>where I am passing to &lt;code&gt;put_in_coffee&lt;/code&gt; both the milk to put in it, and also the action (&lt;code&gt;drink_coffee&lt;/code&gt;) to execute once the milk has been put in. Such code becomes hard to write, and read, and debug.</source>
          <target state="translated">&lt;code&gt;put_in_coffee&lt;/code&gt; に渡すのは、牛乳を入れるだけでなく、牛乳を入れたら実行するアクション（ &lt;code&gt;drink_coffee&lt;/code&gt; ）の両方です。このようなコードは、書き込み、読み取り、デバッグが難しくなります。</target>
        </trans-unit>
        <trans-unit id="a861995ce1d879a17b5c91a26cf0e7eb75c29caf" translate="yes" xml:space="preserve">
          <source>which CAN be interpreted as:</source>
          <target state="translated">と解釈することができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
