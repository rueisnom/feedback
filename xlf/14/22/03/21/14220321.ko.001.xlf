<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/14220321">
    <body>
      <group id="14220321">
        <trans-unit id="927d598b66027a146baa1781e637b904c6aa330f" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://stackoverflow.com/a/30180679/1348195&quot;&gt;Note, for those using the new &lt;code&gt;fetch&lt;/code&gt; API, Angular or promises I've added another answer below&lt;/a&gt;)</source>
          <target state="translated">( &lt;a href=&quot;https://stackoverflow.com/a/30180679/1348195&quot;&gt;참고, 새로운 &lt;code&gt;fetch&lt;/code&gt; API, Angular 또는 약속을 사용하는 사람들에게는 아래에 다른 답변을 추가했습니다&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="99f4d532491d1864e1be89ab9b7b1d7432912746" translate="yes" xml:space="preserve">
          <source>(Although it can be written in Javascript, I prefer to write it in Python, and compile it to Javascript using &lt;a href=&quot;https://github.com/QQuick/Transcrypt&quot;&gt;Transcrypt&lt;/a&gt;. It will be clear enough.)</source>
          <target state="translated">(Javascript로 작성할 수는 있지만 Python으로 작성하고 &lt;a href=&quot;https://github.com/QQuick/Transcrypt&quot;&gt;Transcrypt를&lt;/a&gt; 사용하여 Javascript로 컴파일하는 것을 선호합니다. 충분히 명확합니다.)</target>
        </trans-unit>
        <trans-unit id="5bdb200d65235570c1b58c9e91da7f158c793d35" translate="yes" xml:space="preserve">
          <source>(Fiddle)</source>
          <target state="translated">(Fiddle)</target>
        </trans-unit>
        <trans-unit id="5db09589cf8459f3d38f5553fbde8bce31d35a4c" translate="yes" xml:space="preserve">
          <source>(fiddle)</source>
          <target state="translated">(fiddle)</target>
        </trans-unit>
        <trans-unit id="7766903fe90c705c4ed71e3573241c83b2c69193" translate="yes" xml:space="preserve">
          <source>...which is less cumbersome with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015+ arrow functions&lt;/a&gt;:</source>
          <target state="translated">... &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015 + 화살표 기능&lt;/a&gt; 으로 번거롭지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f927aed5b9c420c5e6e8550a2e4521837fcb377c" translate="yes" xml:space="preserve">
          <source>1)Event Loop</source>
          <target state="translated">1) 이벤트 루프</target>
        </trans-unit>
        <trans-unit id="0742a4064775d4cda76aa61598d18d11036418f9" translate="yes" xml:space="preserve">
          <source>1. Synchronous AJAX - Don't do it!!</source>
          <target state="translated">1. 동기식 AJAX-하지 마라 !!</target>
        </trans-unit>
        <trans-unit id="f24ae07c22d1eb6bb318aa04f411d2319b454d6c" translate="yes" xml:space="preserve">
          <source>2)Web API</source>
          <target state="translated">2) 웹 API</target>
        </trans-unit>
        <trans-unit id="f76660e7f2f317741f7b6f9a679f94b6aae6c47e" translate="yes" xml:space="preserve">
          <source>2. Restructure code</source>
          <target state="translated">2. 코드 재구성</target>
        </trans-unit>
        <trans-unit id="44d7b3b36c7446cc15b0aafbdc4f232450505779" translate="yes" xml:space="preserve">
          <source>2017 answer: you can now do exactly what you want in every current browser and node</source>
          <target state="translated">2017 답변 : 이제 모든 현재 브라우저 및 노드에서 원하는 것을 정확하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d76585d726fac5212bc15c005d34dc57ae870eb" translate="yes" xml:space="preserve">
          <source>3)Event Queue</source>
          <target state="translated">3) 이벤트 큐</target>
        </trans-unit>
        <trans-unit id="68333d073e4f567370e4ebd9e36d796f8c754911" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/&quot;&gt;Here&lt;/a&gt; it says,</source>
          <target state="translated">&lt;a href=&quot;http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/&quot;&gt;여기에&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="d569b34dd010230f2b5736a91066fe31f29056f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; - A promise library for JavaScript</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; -JavaScript를위한 약속 라이브러리</target>
        </trans-unit>
        <trans-unit id="8be840693df3eefddf69835e766647c8f3935f38" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/4866721/what-are-deferred-objects&quot;&gt;Deferred objects&lt;/a&gt; are jQuery's custom implementation of promises (before the Promise API was standardized). They behave almost like promises but expose a slightly different API.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4866721/what-are-deferred-objects&quot;&gt;지연된 객체&lt;/a&gt; 는 Promise API가 표준화되기 전에 jQuery의 사용자 지정 약속 구현입니다. 그것들은 거의 약속처럼 행동하지만 약간 다른 API를 노출시킵니다.</target>
        </trans-unit>
        <trans-unit id="3c3877fa4d4bea86aa540d1d00c51cba27671903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fibers&lt;/code&gt; helps in solving the issue.</source>
          <target state="translated">&lt;code&gt;Fibers&lt;/code&gt; 는이 문제를 해결하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="d4de38eeff0914f72435ab92aacf70919fd4db58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async/await&lt;/code&gt; builds on top of promises: an &lt;code&gt;async&lt;/code&gt; function always returns a promise. &lt;code&gt;await&lt;/code&gt; &quot;unwraps&quot; a promise and either result in the value the promise was resolved with or throws an error if the promise was rejected.</source>
          <target state="translated">&lt;code&gt;async/await&lt;/code&gt; 는 약속 위에 빌드됩니다. &lt;code&gt;async&lt;/code&gt; 함수는 항상 약속을 반환합니다. 약속을 &quot;포장 해제&quot;하고 약속이 해결 된 값을 얻거나 약속이 거부되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="472c34ad7218489081303afcad61fe244feeb0fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt; will refer to the function we pass to &lt;code&gt;foo&lt;/code&gt; when we call it and we simply pass it on to &lt;code&gt;success&lt;/code&gt;. I.e. once the Ajax request is successful, &lt;code&gt;$.ajax&lt;/code&gt; will call &lt;code&gt;callback&lt;/code&gt; and pass the response to the callback (which can be referred to with &lt;code&gt;result&lt;/code&gt;, since this is how we defined the callback).</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; 은 호출 할 때 &lt;code&gt;foo&lt;/code&gt; 에 전달하는 함수를 참조하며 단순히 &lt;code&gt;success&lt;/code&gt; 에 전달합니다. 즉, Ajax 요청이 성공하면 &lt;code&gt;$.ajax&lt;/code&gt; 는 &lt;code&gt;callback&lt;/code&gt; 을 콜하고 콜백 에 응답을 전달합니다 (이것은 콜백을 정의한 방식이므로 &lt;code&gt;result&lt;/code&gt; 로 참조 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="0cdc633c16019e6c8b41e52704499a8c4fdbc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo&lt;/code&gt; itself is defined as follows:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 자체는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5bc50c14ccc34523a427f339d4f6b0d89980a4cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order_milk&lt;/code&gt; kicks off, orders the milk, then, when and only when it arrives, it invokes &lt;code&gt;put_in_coffee&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;order_milk&lt;/code&gt; 가 시작되고 우유를 주문한 다음 도착했을 때만 &lt;code&gt;put_in_coffee&lt;/code&gt; 를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5486986e826b7ca20e7b32edb333416cf0cafa81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;rarr; For a more general explanation of async behaviour with different examples, please see&lt;/em&gt;&lt;a href=&quot;https://stackoverflow.com/q/23667086/218196&quot;&gt;Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;&amp;rarr; 다른 예제와의 비동기 동작에 대한 일반적인 설명은&lt;/em&gt; &lt;a href=&quot;https://stackoverflow.com/q/23667086/218196&quot;&gt;함수 내에서 변수를 수정 한 후 왜 변수가 변경되지 않습니까?&lt;/a&gt; &lt;em&gt;를 참조하십시오&lt;/em&gt; . -비동기 코드 참조</target>
        </trans-unit>
        <trans-unit id="eb1f5ef8b32f66be0ebf85bab611e6a46d561b3a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;rarr; If you already understand the problem, skip to the possible solutions below.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;rarr; 문제를 이미 이해 한 경우 아래 가능한 해결 방법으로 건너 뛰십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5326aa0d4ea5b09f0c635a23b58323c8c2e39d46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Or alternately, you could make a wrapper for &lt;code&gt;doSomethingAsync&lt;/code&gt; that returns a promise, and then do the below...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;또는 또는 약속을 반환하는 &lt;code&gt;doSomethingAsync&lt;/code&gt; 에 대한 래퍼를 만든 다음 아래를 수행 할 수 있습니다 ...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e53fbd340f4f3003e06110183cb83b82789a7984" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Or, again, build a wrapper for &lt;code&gt;doSomethingAsync&lt;/code&gt; that gives you a promise and do the below...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(또 다시 &lt;code&gt;doSomethingAsync&lt;/code&gt; 에 대한 래퍼를 작성하여 약속을하고 아래를 수행하십시오 ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1c2279af365b10752ed22cb3ac6e9f7c78b75a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Since we're doing the work in series, we can just use &lt;code&gt;results.push(result)&lt;/code&gt; since we know we won't get results out of order. In the above we could have used &lt;code&gt;results[index] = result;&lt;/code&gt;, but in some of the following examples we don't have an index to use.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(우리는 일련의 작업을 수행하기 때문에 &lt;code&gt;results.push(result)&lt;/code&gt; 되지 않을 것이므로 results.push (result)를 사용할 수 있습니다. 위의 경우 &lt;code&gt;results[index] = result;&lt;/code&gt; 사용할 수있었습니다 . 다음 예 중 일부에는 사용할 색인이 없습니다.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0dca3ab11483f31910ef1b76a0f2b57827edfed0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(We could do away with &lt;code&gt;expecting&lt;/code&gt; and just use &lt;code&gt;results.length === theArray.length&lt;/code&gt;, but that leaves us open to the possibility that &lt;code&gt;theArray&lt;/code&gt; is changed while the calls are outstanding...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(우리는 &lt;code&gt;expecting&lt;/code&gt; &lt;code&gt;results.length === theArray.length&lt;/code&gt; 사용할 수는 있지만 호출이 눈에 띄는 동안 &lt;code&gt;theArray&lt;/code&gt; 가 변경 될 가능성이 있습니다 ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c79ef9a065b5b6d162c99553810bc34db9b4c98" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A Image from one of the answers here, Correctly explains callback use...&lt;/em&gt;
We give our function(function utilising data returned from server) to function calling server.</source>
          <target state="translated">&lt;em&gt;여기에 대한 답변 중 하나의 이미지가 콜백 사용을 올바르게 설명합니다 ...&lt;/em&gt; 우리는 함수 (서버에서 반환 된 데이터를 사용하는 함수)를 함수 호출 서버에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="575713933b89fb879752fb918e398d207981e848" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Error handler&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;오류 처리기&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb7a5019ca58e906cfe2794d7f8ae19085308f37" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Of course, if &lt;code&gt;doSomethingAsync&lt;/code&gt; passed us errors, we'd use &lt;code&gt;reject&lt;/code&gt; to reject the promise when we got an error.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;물론 &lt;code&gt;doSomethingAsync&lt;/code&gt; 에서 오류를 전달한 경우 오류가 발생했을 때 &lt;code&gt;reject&lt;/code&gt; 를 사용하여 약속을 거부합니다.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29ac499569a5a06c4d82ef94c11d97109d312692" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PS: As the first test I wrote x('x', displayAjax)..., and it totally got a response...??? So I checked the folder where the HTML is located, and there was a file called 'x.xml'. So even if you forget the extension of your file XMLHttpRequest 2 WILL FIND IT&lt;/em&gt;. I LOL'd</source>
          <target state="translated">&lt;em&gt;추신 : 첫 번째 테스트로 x ( 'x', displayAjax) ...를 작성했으며 완전히 응답했습니다 ... ???&lt;/em&gt; &lt;em&gt;그래서 HTML이있는 폴더를 확인했는데 'x.xml'이라는 파일이있었습니다.&lt;/em&gt; &lt;em&gt;따라서 파일의 확장자를 잊어 버린 경우에도 XMLHttpRequest 2 WILL FIND IT&lt;/em&gt; . 나는 LOL했다</target>
        </trans-unit>
        <trans-unit id="a453fdc787181e5194220141468f98edcb49264c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Read a file synchronous&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;동 기적으로 파일 읽기&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f873c1d50c07030d55b6897f696affcc44c234c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 2&lt;/strong&gt; (first of all read the answers from &lt;a href=&quot;https://stackoverflow.com/a/16825593/19068&quot;&gt;Benjamin Gruenbaum&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://stackoverflow.com/a/14220323/19068&quot;&gt;Felix Kling&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 2&lt;/strong&gt; (먼저 &lt;a href=&quot;https://stackoverflow.com/a/16825593/19068&quot;&gt;Benjamin Gruenbaum&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://stackoverflow.com/a/14220323/19068&quot;&gt;Felix Kling&lt;/a&gt; 의 답변을 읽음)</target>
        </trans-unit>
        <trans-unit id="7bb7d03442a106c3a66906d1c9d76fc88badb345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;The Event Loop and Concurrency Model&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;이벤트 루프 및 동시성 모델&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc4c0812139669b4b9302dd36333c2148a9da551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All three are available in current browsers, and node 7+.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;세 가지 모두 현재 브라우저 및 노드 7 이상에서 사용할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="890ea8c5734449e60d41906d358b6206ed712f11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt; (popular in node)</source>
          <target state="translated">&lt;strong&gt;콜백&lt;/strong&gt; (인기 노드)</target>
        </trans-unit>
        <trans-unit id="e2ab2f71e857cb3d2466201010b62a27fd2e5e37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't do that.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그렇게하지 마십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="afaf690b015b9a3ab311cb3b9d55efc3bab713ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 way (async - await)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 방식 (비동기-대기)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d78b4767222f91ac61373691a4d965d332d201f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Embrace the asynchronous nature of JavaScript!&lt;/strong&gt; While certain asynchronous operations provide synchronous counterparts (so does &quot;Ajax&quot;), it's generally discouraged to use them, especially in a browser context.</source>
          <target state="translated">&lt;strong&gt;JavaScript의 비동기 특성을 수용하십시오!&lt;/strong&gt; 특정 비동기 작업은 동기 상대를 제공하지만 ( &quot;Ajax&quot;도 마찬가지) 일반적으로 브라우저 컨텍스트에서 사용하는 것은 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="109d60edc3e638d2bab113fbb027ee1e4e879a32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Have a look at this example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 예를 살펴보십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09004b4c20addc68d6df669ac50a41fb497dea47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heads up!&lt;/strong&gt; It is not possible to make a synchronous &lt;a href=&quot;https://stackoverflow.com/questions/2067472/please-explain-jsonp&quot;&gt;JSONP&lt;/a&gt; request. JSONP by its very nature is always asynchronous (one more reason to not even consider this option).</source>
          <target state="translated">&lt;strong&gt;헤즈 업!&lt;/strong&gt; 동기 &lt;a href=&quot;https://stackoverflow.com/questions/2067472/please-explain-jsonp&quot;&gt;JSONP&lt;/a&gt; 요청은 불가능합니다. JSONP는 본질적으로 항상 비동기 적입니다 (이 옵션을 고려하지 않는 한 가지 이유).</target>
        </trans-unit>
        <trans-unit id="db3e68b8187a2a11a0f5fea968a2add5f24c4dfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; You can only use &lt;code&gt;await&lt;/code&gt; inside an &lt;code&gt;async&lt;/code&gt; function. Right now, top-level &lt;code&gt;await&lt;/code&gt; isn't yet supported, so you might have to make an async IIFE (&lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately_invoked_function_expression&quot;&gt;Immediately Invoked Function Expression&lt;/a&gt;) to start an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="translated">&lt;strong&gt;중요 :&lt;/strong&gt; &lt;code&gt;async&lt;/code&gt; 함수 내에서만 &lt;code&gt;await&lt;/code&gt; 를 사용할 수 있습니다. 현재 최상위 레벨 &lt;code&gt;await&lt;/code&gt; 는 아직 지원되지 않으므로 &lt;code&gt;async&lt;/code&gt; 컨텍스트를 시작하려면 비동기 IIFE ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately_invoked_function_expression&quot;&gt;즉시 호출 된 함수 표현식&lt;/a&gt; )를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1a2d5a4642c349de8193773228017c7500f4e56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;
Recent Spotify &lt;code&gt;search&lt;/code&gt; APIs will require an access token to be specified in the request headers:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 최근 Spotify &lt;code&gt;search&lt;/code&gt; API를 사용하려면 요청 헤더에 액세스 토큰을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b966ba6c20e45f447ff2e8f03f268e29a52a4f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises with &lt;code&gt;async/await&lt;/code&gt;&lt;/strong&gt; (ES2017+, available in older browsers if you use a transpiler or regenerator)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;async/await&lt;/code&gt; 로 약속합니다&lt;/strong&gt; (ES2017 +, 트랜스 파일러 또는 재생기를 사용하는 경우 이전 브라우저에서 사용 가능)</target>
        </trans-unit>
        <trans-unit id="6473a819e62a6a22028f1318142e8cba26e9b5a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises with &lt;code&gt;then()&lt;/code&gt;&lt;/strong&gt; (ES2015+, available in older browsers if you use one of the many promise libraries)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;then()&lt;/code&gt; 약속&lt;/strong&gt; (ES2015 +, 많은 약속 라이브러리 중 하나를 사용하는 경우 이전 브라우저에서 사용 가능)</target>
        </trans-unit>
        <trans-unit id="04c41fa090162049f70a4e607252fab3dd0bb0ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short answer&lt;/strong&gt;: Your &lt;code&gt;foo()&lt;/code&gt; method returns immediately, while the &lt;code&gt;$ajax()&lt;/code&gt; call executes asynchronously &lt;em&gt;after the function returns&lt;/em&gt;. The problem is then how or where to store the results retrieved by the async call once it returns.</source>
          <target state="translated">&lt;strong&gt;짧은 대답&lt;/strong&gt; : &lt;code&gt;foo()&lt;/code&gt; 메소드는 즉시 리턴하지만 &lt;code&gt;$ajax()&lt;/code&gt; 호출은 &lt;em&gt;함수가 리턴 한 후에&lt;/em&gt; 비동기 적으로 실행됩니다. 문제는 비동기 호출에 의해 검색된 결과가 반환되면 결과를 저장하는 방법 또는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="f4645089306c6a1d783c20f54349274a135ed097" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, how do we tackle this issue?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그렇다면이 문제를 어떻게 해결해야합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ab003d485f673dee9ae9f1e5a74cdd4ee60e809" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key thing here is the order of execution. That is&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;여기서 중요한 것은 실행 순서입니다.&lt;/strong&gt; &lt;strong&gt;그건&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fac01d33af22c926036bf26176e2ea876531efc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the plnkr:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이것은 plnkr입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ed0d7ce5e48365488a89a8f5818cd02ab54aa58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WHEN is something going to run&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;언제 달릴 까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8fb2f83aee2cbeff4ac6fcb5ea50cce08e5c218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fulfilled&lt;/strong&gt; meaning that the computation completed successfully.</source>
          <target state="translated">계산이 성공적으로 완료 &lt;strong&gt;되었음을&lt;/strong&gt; 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3030d3b7a04661fbb4185df915ebeef20d9e0313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rejected&lt;/strong&gt; meaning that the computation failed.</source>
          <target state="translated">계산이 실패했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e9da82d285e8df3659dc9d639d7f7999131d7220" translate="yes" xml:space="preserve">
          <source>A Promise is a &lt;em&gt;value over time&lt;/em&gt;. Promises have state, they start as pending with no value and can settle to:</source>
          <target state="translated">약속은 &lt;em&gt;시간이 지남에&lt;/em&gt; 따른 &lt;em&gt;가치&lt;/em&gt; 입니다. 약속에는 상태가 있으며 값없이 보류 중으로 시작하여 다음과 같이 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa2ed570336fff9061c7fed76b7c10d8559bca9" translate="yes" xml:space="preserve">
          <source>A callback is simply a function passed to another function. That other function can call the function passed whenever it is ready. In the context of an asynchronous process, the callback will be called whenever the asynchronous process is done. Usually, the result is passed to the callback.</source>
          <target state="translated">콜백은 단순히 다른 함수로 전달되는 함수입니다. 다른 함수는 준비가 될 때마다 전달 된 함수를 호출 할 수 있습니다. 비동기 프로세스와 관련하여 콜백은 비동기 프로세스가 완료 될 때마다 호출됩니다. 일반적으로 결과는 콜백으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f9e8a04c6605f9a32383dcbf481370c3e715820d" translate="yes" xml:space="preserve">
          <source>A promise can only change states &lt;em&gt;once&lt;/em&gt; after which it will always stay at the same state forever. You can attach &lt;code&gt;then&lt;/code&gt; handlers to promises to extract their value and handle errors. &lt;code&gt;then&lt;/code&gt; handlers allow &lt;a href=&quot;https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks&quot;&gt;chaining&lt;/a&gt; of calls. Promises are created by &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;using APIs that return them&lt;/a&gt;. For example, the more modern AJAX replacement &lt;code&gt;fetch&lt;/code&gt; or jQuery's &lt;code&gt;$.get&lt;/code&gt; return promises.</source>
          <target state="translated">약속은 &lt;em&gt;한 번만&lt;/em&gt; 상태를 변경할 수 있으며 그 후에는 항상 같은 상태를 영원히 유지합니다. &lt;code&gt;then&lt;/code&gt; 처리기를 연결하여 값을 추출하고 오류를 처리 할 수 ​​있습니다. &lt;code&gt;then&lt;/code&gt; 처리기는 호출 &lt;a href=&quot;https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks&quot;&gt;체인&lt;/a&gt; 을 허용합니다. 약속은이 &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;를 반환하는 API를 사용하여&lt;/a&gt; 만들어집니다. 예를 들어, 최신 AJAX 대체 &lt;code&gt;fetch&lt;/code&gt; 또는 jQuery의 &lt;code&gt;$.get&lt;/code&gt; 리턴 약속.</target>
        </trans-unit>
        <trans-unit id="d64b3ccbf97c56e6baf992073261e3d4c261d264" translate="yes" xml:space="preserve">
          <source>A+ Promises.js</source>
          <target state="translated">A + Promises.js</target>
        </trans-unit>
        <trans-unit id="7b2622a1b73a931e6ca38a355f7e3e8ea446ddb8" translate="yes" xml:space="preserve">
          <source>Above, we said, &quot;JS has no way to know that it needs to &lt;strong&gt;wait&lt;/strong&gt; for the first call to finish before it executes the second&quot;. Wouldn't it be nice if there &lt;strong&gt;was&lt;/strong&gt; some way to tell JS that? It turns out that there is--the &lt;code&gt;await&lt;/code&gt; keyword, used inside a special type of function called an &quot;async&quot; function. This feature is part of the upcoming version of ES but is already available in transpilers such as Babel given the right presets. This allows us to simply write</source>
          <target state="translated">위에서 우리는 &quot;JS는 두 번째 호출을 실행하기 전에 첫 번째 호출이 끝날 &lt;strong&gt;때까지 기다려야&lt;/strong&gt; 한다는 것을 알 방법이 없다&quot;고 말했다. JS에게 말할 방법 &lt;strong&gt;이&lt;/strong&gt; 있다면 좋지 않습니까? &quot;비동기&quot;함수라는 특수한 유형의 함수 내에서 사용되는 &lt;code&gt;await&lt;/code&gt; 키워드가 있습니다 . 이 기능은 곧 출시 될 ES 버전의 일부이지만 올바른 사전 설정이 제공되는 Babel과 같은 변환기에서 이미 사용할 수 있습니다. 이것은 단순히 우리가 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e1ca54ffb7b2f8af43c2a3bf761dc7cd1da55e53" translate="yes" xml:space="preserve">
          <source>Actually, all we've done is added a &lt;code&gt;return&lt;/code&gt; to the call to &lt;code&gt;$.ajax&lt;/code&gt;. This works because jQuery's &lt;code&gt;$.ajax&lt;/code&gt; already returns a kind of promise-like thing. (In practice, without getting into details, we would prefer to wrap this call so as for return a real promise, or use some alternative to &lt;code&gt;$.ajax&lt;/code&gt; that does so.) Now, if we want to load the file and wait for it to finish and then do something, we can simply say</source>
          <target state="translated">실제로, 우리가 한 모든 것은 &lt;code&gt;$.ajax&lt;/code&gt; 호출에 대한 &lt;code&gt;return&lt;/code&gt; 을 추가하는 것입니다. jQuery의 &lt;code&gt;$.ajax&lt;/code&gt; 이미 일종의 약속 같은 것을 반환하기 때문에 작동합니다. (실제로 세부 정보를 얻지 않고이 약속을 반환하기 위해이 호출을 래핑하거나 그렇게하는 &lt;code&gt;$.ajax&lt;/code&gt; 대안을 사용하는 것이 좋습니다.) 이제 파일을로드하고 기다릴 경우 마무리하고 무언가를하기 위해 간단히 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8806f1d6f77f315f3c6459851ebdd89a11e28f02" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;'async'&lt;/a&gt; keyword to the parent function</source>
          <target state="translated">부모 함수에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;'비동기'&lt;/a&gt; 키워드 추가</target>
        </trans-unit>
        <trans-unit id="529deb621e57605154d7312ba8f12b3f554d9040" translate="yes" xml:space="preserve">
          <source>Additionally here is the promises &lt;a href=&quot;https://github.com/promises-aplus/promises-spec&quot;&gt;spec&lt;/a&gt; define here.</source>
          <target state="translated">또한 여기에 약속 &lt;a href=&quot;https://github.com/promises-aplus/promises-spec&quot;&gt;사양이&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab38701d1301596d1056dacff49b4a862d011ba3" translate="yes" xml:space="preserve">
          <source>Again ... it's a very short function, but it does get &amp;amp; post.</source>
          <target state="translated">다시 말하지만 ... 매우 짧은 기능이지만 가져오고 게시합니다.</target>
        </trans-unit>
        <trans-unit id="54729d47d0181e621bfce461fcd3befc07e5b989" translate="yes" xml:space="preserve">
          <source>All of this is really bad user experience. The user won't be able to tell whether everything is working fine or not. Furthermore, the effect will be worse for users with a slow connection.</source>
          <target state="translated">이 모든 것은 정말 나쁜 사용자 경험입니다. 사용자는 모든 것이 제대로 작동하는지 알 수 없습니다. 또한 연결 속도가 느린 사용자에게는 효과가 더 나빠질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="644cfe271cac18a474c99dd756307f08b1e0e327" translate="yes" xml:space="preserve">
          <source>And executing it like this.</source>
          <target state="translated">그리고 이렇게 실행합니다.</target>
        </trans-unit>
        <trans-unit id="761067f16b11d2d1e088fb27ee5a3facce3b502f" translate="yes" xml:space="preserve">
          <source>Angular1</source>
          <target state="translated">Angular1</target>
        </trans-unit>
        <trans-unit id="a6f848c2ffe2ed313ae1ff7c87a3e8f4231023f9" translate="yes" xml:space="preserve">
          <source>Angular2 and Later</source>
          <target state="translated">Angular2 이상</target>
        </trans-unit>
        <trans-unit id="700b18f544e30a3391a16d96b67c29e5dd7f4d12" translate="yes" xml:space="preserve">
          <source>Another approach to return a value from an asynchronous function, is to pass in an object that will store the result from the asynchronous function.</source>
          <target state="translated">비동기 함수에서 값을 반환하는 다른 방법은 비동기 함수의 결과를 저장할 개체를 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e0e29ebcd867f1dca1b8c6b1fb3343ba7d8745a" translate="yes" xml:space="preserve">
          <source>Another point is... if you work with APIs or just your own list's files or whatever you always use different functions for each request...</source>
          <target state="translated">또 다른 요점은 ... API 또는 자체 목록 파일 또는 각 요청에 대해 항상 다른 기능을 사용하는 모든 것을 사용하는 경우 ...</target>
        </trans-unit>
        <trans-unit id="64aef2853dbea8a1653b08bcdf147b457091ff7b" translate="yes" xml:space="preserve">
          <source>Another solution is to execute code via sequential executor &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt;.</source>
          <target state="translated">또 다른 해결책은 순차적 실행 프로그램 &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt; 를 통해 코드를 실행하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b2cb720802474bc4792fbb02842d36aeeabbeceb" translate="yes" xml:space="preserve">
          <source>Apart from using &lt;code&gt;then/catch&lt;/code&gt; to work with promises, there exists one more approach. The idea is to &lt;em&gt;recognize an asynchronous function&lt;/em&gt; and then &lt;em&gt;wait for the promises&lt;/em&gt; to resolve, before moving to the next line of code. It's still just the &lt;code&gt;promises&lt;/code&gt; under the hood, but with a different syntactical approach. To make things clearer, you can find a comparison below:</source>
          <target state="translated">약속을 &lt;code&gt;then/catch&lt;/code&gt; 위해 then / catch 를 사용하는 것 외에도 다른 접근 방법이 있습니다. 아이디어는 &lt;em&gt;비동기 함수&lt;/em&gt; 를 &lt;em&gt;인식 한&lt;/em&gt; 후 다음 코드 줄로 이동하기 전에 &lt;em&gt;약속&lt;/em&gt; 이 해결 될 &lt;em&gt;때까지 기다리는 것입니다&lt;/em&gt; . 그것은 여전히 ​​두건의 &lt;code&gt;promises&lt;/code&gt; 이지만 다른 구문 접근법입니다. 더 명확하게하기 위해 아래 비교를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6935922dd9171b57188004a7345d312359feff" translate="yes" xml:space="preserve">
          <source>Applied to our Ajax call we could use promises like this:</source>
          <target state="translated">Ajax 호출에 적용하면 다음과 같은 약속을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef6615c95aa80cbc5318149fff9515811e8e9d4" translate="yes" xml:space="preserve">
          <source>Applying this</source>
          <target state="translated">이것을 적용</target>
        </trans-unit>
        <trans-unit id="f1a34583be1c0d1698743056ac6453867467e99a" translate="yes" xml:space="preserve">
          <source>As I mentioned, some(!) asynchronous operations have synchronous counterparts. I don't advocate their use, but for completeness' sake, here is how you would perform a synchronous call:</source>
          <target state="translated">내가 언급했듯이, 일부 (!) 비동기 작업에는 동기 상대방이 있습니다. 나는 그들의 사용을 옹호하지는 않지만, 완전성을 위해 동기 호출을 수행하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d690325261d4ed328617f51bcb035e4e34411085" translate="yes" xml:space="preserve">
          <source>As for synchronous AJAX, &lt;strong&gt;don't do it!&lt;/strong&gt; Felix's answer raises some compelling arguments about why it's a bad idea. To sum it up, it'll freeze the user's browser until the server returns the response and create a very bad user experience. Here is another short summary taken from MDN on why:</source>
          <target state="translated">동기식 AJAX &lt;strong&gt;는하지 마십시오!&lt;/strong&gt; 펠릭스의 대답은 왜 그것이 나쁜 생각인지에 대한 설득력있는 주장을 제기합니다. 요약하면 서버가 응답을 반환하고 매우 나쁜 사용자 환경을 만들 때까지 사용자 브라우저를 고정시킵니다. 다음은 MDN에서 가져온 또 다른 간단한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="4406a09393c68f9778335e6efa2ba72dfa43398d" translate="yes" xml:space="preserve">
          <source>As mentioned in the comment the use of error &amp;amp;&amp;amp; synchronous does completely break the point of the answer. Which is a nice short way to use Ajax in the proper way?</source>
          <target state="translated">주석에서 언급했듯이 오류 &amp;amp;&amp;amp; 동기식을 사용하면 대답의 요점이 완전히 중단됩니다. Ajax를 올바른 방법으로 사용하는 좋은 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3d039321bb1e1655c4cd32eb77e5d556b9a9d4cc" translate="yes" xml:space="preserve">
          <source>As you can see &lt;code&gt;getJoke&lt;/code&gt; is &lt;strong&gt;returning a&lt;/strong&gt; resolved &lt;strong&gt;promise&lt;/strong&gt; (it is resolved when returning &lt;code&gt;res.data.value&lt;/code&gt;). So you wait until the &lt;strong&gt;$http.get&lt;/strong&gt; request is completed and then &lt;strong&gt;console.log(res.joke)&lt;/strong&gt; is executed (as a normal asynchronous flow).</source>
          <target state="translated">보시다시피 &lt;code&gt;getJoke&lt;/code&gt; 가 해결 된 &lt;strong&gt;약속을&lt;/strong&gt; &lt;strong&gt;반환합니다 (&lt;/strong&gt; res.data.value 를 &lt;strong&gt;반환&lt;/strong&gt; 할 때 &lt;code&gt;res.data.value&lt;/code&gt; ). 따라서 &lt;strong&gt;$ http.get&lt;/strong&gt; 요청이 완료되고 &lt;strong&gt;console.log (res.joke)&lt;/strong&gt; 가 실행될 때까지 기다립니다 (정상 비동기 흐름으로).</target>
        </trans-unit>
        <trans-unit id="6be3c4864e2a35cc4ac8cfd91a74da6e56a1ee18" translate="yes" xml:space="preserve">
          <source>As you can see I didn't implement sync... it's a bad thing.</source>
          <target state="translated">보시다시피 동기화를 구현하지 않았습니다 ... 나쁜 일입니다.</target>
        </trans-unit>
        <trans-unit id="3e214af7884162cf40fb2934293a2a307f51fd46" translate="yes" xml:space="preserve">
          <source>As you can see:</source>
          <target state="translated">보다시피 :</target>
        </trans-unit>
        <trans-unit id="3d7fac7964f752248f02c5aa61c85fd417dcfbcf" translate="yes" xml:space="preserve">
          <source>Asynchronous</source>
          <target state="translated">Asynchronous</target>
        </trans-unit>
        <trans-unit id="9ce552a69176ba76938ef8727847cfb9c28c9943" translate="yes" xml:space="preserve">
          <source>Basically, instead of returning a &lt;em&gt;value&lt;/em&gt; which we can't do because of the concurrency model - we're returning a &lt;em&gt;wrapper&lt;/em&gt; for a value that we can &lt;em&gt;unwrap&lt;/em&gt; with &lt;code&gt;then&lt;/code&gt;. It's like a box you can open with &lt;code&gt;then&lt;/code&gt;.</source>
          <target state="translated">기본적으로 동시성 모델로 인해 수행 할 수없는 &lt;em&gt;값&lt;/em&gt; 을 반환하는 대신 랩핑 할 수없는 값에 대한 &lt;em&gt;래퍼&lt;/em&gt; 를 반환합니다. &lt;code&gt;then&lt;/code&gt; 열 수있는 상자와 같습니다.</target>
        </trans-unit>
        <trans-unit id="eab484a08dfc236925e2ba1434abe3c27155a03c" translate="yes" xml:space="preserve">
          <source>Because JS has no way to know that it needs to &lt;strong&gt;wait&lt;/strong&gt; for &lt;code&gt;order_milk&lt;/code&gt; to finish before it executes &lt;code&gt;put_in_coffee&lt;/code&gt;. In other words, it does not know that &lt;code&gt;order_milk&lt;/code&gt; is &lt;strong&gt;asynchronous&lt;/strong&gt;--is something that is not going to result in milk until some future time. JS, and other declarative languages execute one statement after another without waiting.</source>
          <target state="translated">JS는 &lt;code&gt;order_milk&lt;/code&gt; 를 실행하기 전에 order_milk 가 완료 될 &lt;strong&gt;때까지 기다려야&lt;/strong&gt; 한다는 것을 알 수있는 방법이 없습니다. 다시 말해, &lt;code&gt;order_milk&lt;/code&gt; 가 &lt;strong&gt;비동기&lt;/strong&gt; 라는 것을 알지 못합니다. 이것은 미래까지 우유를 만들지 않을 것입니다. JS 및 기타 선언적 언어는 기다리지 않고 한 명령문을 차례로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4fb46d91439c44dca8be62ad2c6da7e246ac7424" translate="yes" xml:space="preserve">
          <source>Because a callback is not executed immediately but at a later time it's important to pass the reference to the function not it executed. so</source>
          <target state="translated">콜백은 즉시 실행되지 않지만 나중에 실행되지 않은 함수에 대한 참조를 전달하는 것이 중요합니다. 그래서</target>
        </trans-unit>
        <trans-unit id="e949293bb3141d39921183faafd54e8bcb4089c2" translate="yes" xml:space="preserve">
          <source>Becomes:</source>
          <target state="translated">Becomes:</target>
        </trans-unit>
        <trans-unit id="33e41fa8d678aeb4e035f2f254faf9c3f81da31a" translate="yes" xml:space="preserve">
          <source>Browser Promise object</source>
          <target state="translated">브라우저 약속 개체</target>
        </trans-unit>
        <trans-unit id="765bf6bf6d4dba7ff5f829d9d93bb123d301ca4a" translate="yes" xml:space="preserve">
          <source>Browser can be divided into three parts:</source>
          <target state="translated">브라우저는 세 부분으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d450093edec3c9a5aeeeb0beef75d475c35a50cd" translate="yes" xml:space="preserve">
          <source>But how you can do it in pure &lt;strong&gt;javascript&lt;/strong&gt; or &lt;strong&gt;jQuery&lt;/strong&gt; for example as you asked in this question?</source>
          <target state="translated">그러나이 질문에서 요청한 것처럼 순수 &lt;strong&gt;자바 스크립트&lt;/strong&gt; 또는 &lt;strong&gt;jQuery&lt;/strong&gt; 에서 어떻게 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a64b0676afddefea547c307ed3e8295760faffaa" translate="yes" xml:space="preserve">
          <source>But the fix is easy:</source>
          <target state="translated">그러나 수정은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="77d296e55d0766d8200053d7f3cfd7c13d9226be" translate="yes" xml:space="preserve">
          <source>But the question here is how to return an Ajax response... (I added an easy way.)</source>
          <target state="translated">그러나 여기서 질문은 Ajax 응답을 반환하는 방법입니다 ... (나는 쉬운 방법을 추가했습니다.)</target>
        </trans-unit>
        <trans-unit id="871ea55bfadd9c09cdde6b012a015872456c8c66" translate="yes" xml:space="preserve">
          <source>But there's still something vaguely dissatisfying about having to write code one way if synchronous and a quite different way if asynchronous. For synchronous, we write</source>
          <target state="translated">그러나 동 기적 인 경우 코드를 작성하는 방법과 비동기 인 경우 매우 다른 방법으로 코드를 작성해야한다는 것에 대해서는 여전히 모호한 불만이 있습니다. 동기식으로</target>
        </trans-unit>
        <trans-unit id="6662b4c845488fe6c8b6ee72b41f77fa73bca428" translate="yes" xml:space="preserve">
          <source>But to really get out an error the &lt;strong&gt;only&lt;/strong&gt; way is to write a wrong URL in which case every browser throws an error.</source>
          <target state="translated">그러나 실제로 오류를 얻으려면 &lt;strong&gt;유일한&lt;/strong&gt; 방법은 모든 URL에 오류가 발생하는 잘못된 URL을 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6fe1615524c00038c401cf5c333c9dc307f8bd8" translate="yes" xml:space="preserve">
          <source>But wait...!</source>
          <target state="translated">하지만 기다려...!</target>
        </trans-unit>
        <trans-unit id="dfb64faad30b77313e3dfe8cbd9a6f1d588843af" translate="yes" xml:space="preserve">
          <source>But what if you need to &lt;em&gt;return&lt;/em&gt; those results from a function? As the other answers have pointed out, you can't; you have to have your function accept and call a callback (or return a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;). Here's a callback version:</source>
          <target state="translated">그러나 함수에서 결과를 &lt;em&gt;반환&lt;/em&gt; 해야하는 경우 어떻게해야합니까? 다른 답변들이 지적했듯이, 당신은 할 수 없습니다. 함수가 콜백을 수락하고 호출하도록해야합니다 (또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; 반환). 콜백 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53f5926dc5af0fddf203c78ec84b5d65b51a2f52" translate="yes" xml:space="preserve">
          <source>But you can do a lot of stuff with XMLHttpRequest 2:</source>
          <target state="translated">그러나 XMLHttpRequest 2로 많은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0d6941afab03ca7758a76da0c336ec6d021825e" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;http://caniuse.com/xhr2&quot;&gt;XMLHttpRequest advanced features&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://caniuse.com/xhr2&quot;&gt;XMLHttpRequest 고급 기능&lt;/a&gt; 확인</target>
        </trans-unit>
        <trans-unit id="31ebfd440a69ecc3715e49c5b6a6c1dd6d4b0371" translate="yes" xml:space="preserve">
          <source>Consider an example. You call the milkman and order some milk. When it comes, you want to put it in your coffee. You can't put the milk in your coffee right now, because it is not here yet. You have to wait for it to come before putting it in your coffee. In other words, the following won't work:</source>
          <target state="translated">예를 고려하십시오. 우유 배달원에게 전화해서 우유를 주문하십시오. 올 때, 당신은 당신의 커피에 넣어 싶어. 우유가 아직 없기 때문에 커피에 우유를 넣을 수 없습니다. 커피를 넣으려면 커피가 올 때까지 기다려야합니다. 즉, 다음은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84b2d3dacc41e20a8047eac062d786928aeea668" translate="yes" xml:space="preserve">
          <source>Context. The example is querying the &lt;a href=&quot;https://developer.spotify.com/web-api/endpoint-reference/&quot;&gt;Spotify Web API&lt;/a&gt; endpoint in order to search for &lt;code&gt;playlist&lt;/code&gt; objects for a given set of query strings:</source>
          <target state="translated">문맥. 예제는 지정된 쿼리 문자열 세트에 대한 &lt;code&gt;playlist&lt;/code&gt; 객체를 검색하기 위해 &lt;a href=&quot;https://developer.spotify.com/web-api/endpoint-reference/&quot;&gt;Spotify Web API&lt;/a&gt; 엔드 포인트를 쿼리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b985b8de161adfd30380ec1c45ac41353ff18286" translate="yes" xml:space="preserve">
          <source>Current &lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-async_functions&quot;&gt;browser&lt;/a&gt; and &lt;a href=&quot;http://node.green/#ES2017-features-async-functions&quot;&gt;node&lt;/a&gt; versions support &lt;code&gt;async/await&lt;/code&gt;. You can also support older environments by transforming your code to ES5 with the help of &lt;a href=&quot;https://github.com/facebook/regenerator&quot;&gt;regenerator&lt;/a&gt; (or tools that use regenerator, such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;).</source>
          <target state="translated">현재 &lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-async_functions&quot;&gt;브라우저&lt;/a&gt; 및 &lt;a href=&quot;http://node.green/#ES2017-features-async-functions&quot;&gt;노드&lt;/a&gt; 버전은 &lt;code&gt;async/await&lt;/code&gt; 를 지원합니다. 또한 &lt;a href=&quot;https://github.com/facebook/regenerator&quot;&gt;재생기&lt;/a&gt; (또는 &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 과 같은 재생기를 사용하는 도구)를 사용하여 코드를 ES5로 변환하여 이전 환경을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23b9d4749a9f206dd4aecf7d5fe1ab0fe7998221" translate="yes" xml:space="preserve">
          <source>Define a function which returns a &lt;strong&gt;Promise&lt;/strong&gt;, in this case an Ajax call:</source>
          <target state="translated">&lt;strong&gt;Promise&lt;/strong&gt; 를 반환하는 함수 (이 경우 Ajax 호출)를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="3047a156238e05c9e91f44e59216ce4350e7d875" translate="yes" xml:space="preserve">
          <source>Describing all the advantages that promise offer is beyond the scope of this answer, but if you write new code, you should seriously consider them. They provide a great abstraction and separation of your code.</source>
          <target state="translated">약속 한 모든 이점을 설명하는 것은이 답변의 범위를 벗어나지 만 새 코드를 작성하는 경우 신중하게 고려해야합니다. 그것들은 코드의 추상화와 분리를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d24cf059acad77f2348de6ab9a950dcb953d0c1e" translate="yes" xml:space="preserve">
          <source>Difficulties could arise when you have to work with third-party code, but most problems can be solved by just thinking through the application flow.</source>
          <target state="translated">타사 코드로 작업해야 할 경우 문제가 발생할 수 있지만 대부분의 문제는 응용 프로그램 흐름을 생각하면 해결 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="291b4e6259557593d37f6433293f59fe5f76d601" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 has 'generators' which allow you to easily program in an asynchronous style.</source>
          <target state="translated">ECMAScript 6에는 비동기식으로 쉽게 프로그래밍 할 수있는 '제너레이터'가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3af59b16940b2e81235ebbcb74c7f1a75b7e5e5" translate="yes" xml:space="preserve">
          <source>ES2015 (ES6)</source>
          <target state="translated">ES2015 (ES6)</target>
        </trans-unit>
        <trans-unit id="7dbb3904074ff18348bd30e832250b33427cdc38" translate="yes" xml:space="preserve">
          <source>ES2015+: Promises with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;then()&lt;/a&gt;</source>
          <target state="translated">ES2015 + : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;then ()으로&lt;/a&gt; 약속</target>
        </trans-unit>
        <trans-unit id="35bf367fe5ced0d619315d0cc8f147a296348c43" translate="yes" xml:space="preserve">
          <source>ES2016 (ES7)</source>
          <target state="translated">ES2016 (ES7)</target>
        </trans-unit>
        <trans-unit id="1542f3c49056454d75a06101c17c1785c445d891" translate="yes" xml:space="preserve">
          <source>ES2017+: Promises with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async/await&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ES2017 + : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async/await&lt;/code&gt; &lt;/a&gt; 약속</target>
        </trans-unit>
        <trans-unit id="967cf59859743f73ba18a11fe55a168a8034039e" translate="yes" xml:space="preserve">
          <source>ES6 introduces &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generators&lt;/a&gt; which are functions that can return in the middle and then resume the point they were at. This is typically useful for sequences, for example:</source>
          <target state="translated">ES6에는 중간에 돌아와서 원래 있던 지점을 다시 시작할 수있는 함수 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;생성기&lt;/a&gt; 가 도입되었습니다. 이것은 일반적으로 다음과 같은 시퀀스에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4b08c5e49b030b945e2f126cefe3cc1039afa94b" translate="yes" xml:space="preserve">
          <source>Enter promises</source>
          <target state="translated">약속을 입력</target>
        </trans-unit>
        <trans-unit id="80993d0449ad6680943f4a71d58a1facc8010c69" translate="yes" xml:space="preserve">
          <source>Error handlers are maybe useful if you set custom headers, set the responseType to blob array buffer or whatever...</source>
          <target state="translated">오류 처리기는 사용자 지정 헤더를 설정하고 responseType을 blob 배열 버퍼 등으로 설정하는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="52397d788ea7c6b60de8f942da7edb5fd927e6c4" translate="yes" xml:space="preserve">
          <source>Even if you pass 'POSTAPAPAP' as the method it won't throw an error.</source>
          <target state="translated">메소드로 'POSTAPAPAP'을 전달하더라도 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed627f8185515e40e63ef82e28b0e78972fa2fad" translate="yes" xml:space="preserve">
          <source>Even if you pass 'fdggdgilfdghfldj' as formdata it won't throw an error.</source>
          <target state="translated">'fdggdgilfdghfldj'를 formdata로 전달하더라도 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c920a57596f644008ba32598f248afdb53f17307" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;findItem&lt;/code&gt; might take a long time to execute, any code coming after &lt;code&gt;var item = findItem();&lt;/code&gt; has to &lt;em&gt;wait&lt;/em&gt; until the function returns the result.</source>
          <target state="translated">&lt;code&gt;findItem&lt;/code&gt; 을 실행하는 데 시간이 오래 걸릴 수 있지만 모든 코드는 &lt;code&gt;var item = findItem();&lt;/code&gt; 함수가 결과를 반환 할 &lt;em&gt;때&lt;/em&gt; 까지 &lt;em&gt;기다려야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="af30fe5dce2e46682e9e3add89a73ab9d1afd392" translate="yes" xml:space="preserve">
          <source>Event Loop runs for forever i.e kind of infinite loop.Event Queue is where all your function are pushed on some event(example:click) this is one by one carried out of queue and put into Event loop which execute this function and prepares it self for next one after first one is executed.This means Execution of one function doesn't starts till the function before it in queue is executed in event loop.</source>
          <target state="translated">이벤트 루프는 무한 루프의 일종으로 영원히 실행됩니다. 이벤트 큐는 모든 기능이 일부 이벤트 (예 : 클릭)에서 푸시되는 곳입니다. 이것은 큐에서 수행되고 이벤트 루프에 넣어이 기능을 실행하고 자체 준비합니다. 이것은 첫 번째 함수가 실행 된 후 다음에 대한 것입니다. 즉, 큐에있는 함수가 이벤트 루프에서 실행될 때까지 함수 실행이 시작되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ba81b013536dce95c24ccc172a06bd722742bb6a" translate="yes" xml:space="preserve">
          <source>Every Ajax method of jQuery already returns a &quot;deferred object&quot; (actually a promise of a deferred object) which you can just return from your function:</source>
          <target state="translated">jQuery의 모든 Ajax 메소드는 이미 함수에서 리턴 할 수있는 &quot;지연된 오브젝트&quot;(실제로 지연된 오브젝트의 약속)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="197abe1392101850410c061421129e3d1b59f596" translate="yes" xml:space="preserve">
          <source>Example found in &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$q&quot;&gt;docs&lt;/a&gt; mentioned below.</source>
          <target state="translated">아래 언급 된 &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$q&quot;&gt;문서&lt;/a&gt; 에서 예를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="77810a758bab3888ba66659f3df788816aeb992b" translate="yes" xml:space="preserve">
          <source>Example: jQuery deferred implementation to work with multiple requests</source>
          <target state="translated">예 : 여러 요청을 처리하기위한 jQuery 지연 구현</target>
        </trans-unit>
        <trans-unit id="6b5bea21483cbaba11f47e563b491712cd328829" translate="yes" xml:space="preserve">
          <source>Examples of usage:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="2bb87a5dd963da02345343f24198c82aa718d522" translate="yes" xml:space="preserve">
          <source>Felix Kling did a fine job writing an answer for people using jQuery for AJAX, I've decided to provide an alternative for people who aren't.</source>
          <target state="translated">Felix Kling은 AJAX를 위해 jQuery를 사용하는 사람들을 위해 훌륭한 답변을 작성했으며, 그렇지 않은 사람들에게 대안을 제공하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="61b6cad34a7477f709f8134369511744282bf7b8" translate="yes" xml:space="preserve">
          <source>Felix Kling did a fine job writing an answer for people using jQuery with callbacks for AJAX. I have an answer for native XHR. This answer is for generic usage of promises either on the frontend or backend.</source>
          <target state="translated">Felix Kling은 jQuery를 AJAX 콜백과 함께 사용하는 사람들을 위해 훌륭한 답변을 작성했습니다. 네이티브 XHR에 대한 답변이 있습니다. 이 답변은 프론트 엔드 또는 백엔드에서 일반적인 약속 사용에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="635e0097e3c51f900f56e2ff15075d9128740b8b" translate="yes" xml:space="preserve">
          <source>For each item, a new Promise will fire a block - &lt;code&gt;ExecutionBlock&lt;/code&gt;, parse the result, schedule a new set of promises based on the result array, that is a list of Spotify &lt;code&gt;user&lt;/code&gt; objects and execute the new HTTP call within the &lt;code&gt;ExecutionProfileBlock&lt;/code&gt; asynchronously.</source>
          <target state="translated">각 항목에 대해 새 Promise는 블록-ExecutionBlock을 &lt;code&gt;ExecutionBlock&lt;/code&gt; 하고 결과를 구문 분석하고 결과 배열을 기반으로 새 약속을 예약합니다. 즉, Spotify &lt;code&gt;user&lt;/code&gt; 개체 목록이며 &lt;code&gt;ExecutionProfileBlock&lt;/code&gt; 내에서 비동기 적으로 새 HTTP 호출을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="686ea421444c498a952e65a5b7b7b8ef0e77b9a4" translate="yes" xml:space="preserve">
          <source>For example in your case which you are using &lt;strong&gt;jQuery&lt;/strong&gt;, you can do something like this:</source>
          <target state="translated">예를 들어 &lt;strong&gt;jQuery&lt;/strong&gt; 를 사용하는 경우 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e7f2f5c0f405e9a5beea0b22dfdc929a77c6dbf" translate="yes" xml:space="preserve">
          <source>For more details on how this sort of callback design is done, check Felix's answer.</source>
          <target state="translated">이러한 종류의 콜백 디자인이 수행되는 방법에 대한 자세한 내용은 Felix의 답변을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9ae95c96ff6e523f358968e03ed28b68223e6cc4" translate="yes" xml:space="preserve">
          <source>For more information study about &lt;strong&gt;promises&lt;/strong&gt; and &lt;strong&gt;observables&lt;/strong&gt; which are newer ways to do this async stuffs.</source>
          <target state="translated">이 비동기 작업을 수행하는 새로운 방법 인 &lt;strong&gt;약속&lt;/strong&gt; 및 &lt;strong&gt;관찰 가능 항목&lt;/strong&gt; 에 대한 자세한 내용은 연구하십시오.</target>
        </trans-unit>
        <trans-unit id="d2c8933d706e47b9253dd050c3950ebb59a4178f" translate="yes" xml:space="preserve">
          <source>For people who are using &lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;, can handle this situation using &lt;code&gt;Promises&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt; 를 사용하는 사람들의 경우 &lt;code&gt;Promises&lt;/code&gt; 사용하여이 상황을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9244ed786ac52489080bb2ed73727df2582f9b46" translate="yes" xml:space="preserve">
          <source>Handle asynchronous HTTP calls;</source>
          <target state="translated">비동기 HTTP 호출을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="93478a618140fa661d81ab91258f1a651409d131" translate="yes" xml:space="preserve">
          <source>Having said that ... why don't do it the easy way?</source>
          <target state="translated">그 말을 ... 왜 쉬운 방법으로하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="51d1de74537d4867e5318491d300b2040b09329d" translate="yes" xml:space="preserve">
          <source>Here are some approaches to work with asynchronous requests:</source>
          <target state="translated">다음은 비동기 요청을 처리하는 몇 가지 방법입니다.</target>
        </trans-unit>
        <trans-unit id="089375b0e7ad3fd4224f7a969d79cd0949c40a9f" translate="yes" xml:space="preserve">
          <source>Here is a simple analogy</source>
          <target state="translated">여기 간단한 비유가 있습니다</target>
        </trans-unit>
        <trans-unit id="a3e19bd4dc54096f28f69d4061c9289827b6d622" translate="yes" xml:space="preserve">
          <source>Here is a simple analogy for the issue:</source>
          <target state="translated">다음은이 문제에 대한 간단한 비유입니다.</target>
        </trans-unit>
        <trans-unit id="66783b0ea79ce0b229e6872b71ad5253987aee77" translate="yes" xml:space="preserve">
          <source>Here is a simple example of using a promise:</source>
          <target state="translated">다음은 약속을 사용하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="3f98c5fe445eb6aa095ee0b24083a641538f5e28" translate="yes" xml:space="preserve">
          <source>Here is an analogy which hopefully makes the difference between synchronous and asynchronous flow clearer:</source>
          <target state="translated">다음은 동기 흐름과 비동기 흐름의 차이를 더 명확하게 만드는 유추입니다.</target>
        </trans-unit>
        <trans-unit id="e18b9e6f0b7383abbecaa82bf04e6ad414de12c8" translate="yes" xml:space="preserve">
          <source>Here is an example of the same:</source>
          <target state="translated">다음은 동일한 예입니다.</target>
        </trans-unit>
        <trans-unit id="bd9e15afe641187b36f9279675ba8535db066ca8" translate="yes" xml:space="preserve">
          <source>Here is an example that builds on top of delay above:</source>
          <target state="translated">다음은 위의 지연 시간 위에 구축 된 예입니다.</target>
        </trans-unit>
        <trans-unit id="1197d1f4a9d4cf3b8d6f5178c3cec6d0874a533a" translate="yes" xml:space="preserve">
          <source>Here we defined the function &quot;inline&quot; but you can pass any function reference:</source>
          <target state="translated">여기에 함수 &quot;인라인&quot;을 정의했지만 모든 함수 참조를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="164b78f47e3ef1dc3e0cef0b751ea196374fd668" translate="yes" xml:space="preserve">
          <source>Here we passed an anonymous function, but we could just as easily pass a reference to an existing function, making it look like:</source>
          <target state="translated">여기서 익명 함수를 전달했지만 기존 함수에 대한 참조를 쉽게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e64ad5b4497aa10277e2076d4284da48c62d379" translate="yes" xml:space="preserve">
          <source>Here's a working version of your code:</source>
          <target state="translated">작동하는 코드 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e3c8edd9d78bba7e3a4b76a43bc5bd629037a8e" translate="yes" xml:space="preserve">
          <source>Hopefully that will make some sense. When you encounter things like this that seem confusing - i highly recommend reading the documentation fully to at least get an understanding of it. It will make you a much better developer.</source>
          <target state="translated">잘만되면 그것이 의미가있을 것입니다. 혼란스러워 보이는 것과 같은 것들이 생길 때-최소한 문서를 완전히 이해하는 것이 좋습니다. 훨씬 더 나은 개발자가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="156541c40984a4a3ee70fd44f32c4e4796080910" translate="yes" xml:space="preserve">
          <source>How do I return the response from an asynchronous call</source>
          <target state="translated">비동기 호출에서 응답을 반환하는 방법</target>
        </trans-unit>
        <trans-unit id="450c3e475d5ba28aa9f650174becd8bb359d1260" translate="yes" xml:space="preserve">
          <source>How do I return the response from an asynchronous call?</source>
          <target state="translated">비동기 호출에서 응답을 어떻게 반환합니까?</target>
        </trans-unit>
        <trans-unit id="89fed459f83d0d8bc59f73a0c70d136088949d94" translate="yes" xml:space="preserve">
          <source>How to make &lt;strong&gt;asynchronous&lt;/strong&gt; code look &lt;strong&gt;synchronous&lt;/strong&gt;?</source>
          <target state="translated">&lt;strong&gt;비동기&lt;/strong&gt; 코드를 &lt;strong&gt;동 기적으로&lt;/strong&gt; 보이게 만드는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c25df1a995ff1bfc26f40ebfff6e38eed0cf9af3" translate="yes" xml:space="preserve">
          <source>I am using the &lt;code&gt;result&lt;/code&gt; object to store the value during the asynchronous operation. This allows the result be available even after the asynchronous job.</source>
          <target state="translated">비동기 작업 중에 &lt;code&gt;result&lt;/code&gt; 객체를 사용하여 값을 저장하고 있습니다. 이를 통해 비동기 작업 후에도 결과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3082b7f700f005a0779967fd6b3615c7a09694bd" translate="yes" xml:space="preserve">
          <source>I have a function &lt;code&gt;foo&lt;/code&gt; which makes an Ajax request. How can I return the response from &lt;code&gt;foo&lt;/code&gt;?</source>
          <target state="translated">Ajax 요청을하는 함수 &lt;code&gt;foo&lt;/code&gt; 가 있습니다. &lt;code&gt;foo&lt;/code&gt; 에서 응답을 어떻게 반환 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d16b97c7b8f99c277ca18e31f4f0499acffc903b" translate="yes" xml:space="preserve">
          <source>I have extensively discussed this solution &lt;a href=&quot;https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 솔루션에 대해 광범위하게 논의했습니다.</target>
        </trans-unit>
        <trans-unit id="871db57e2d8a1b8bb628280aec3e9abeafe80bbf" translate="yes" xml:space="preserve">
          <source>I made a download manager (using ranges on both sides with resume, filereader, filesystem), various image resizers converters using canvas, populate web SQL databases with base64images and much more... But in these cases you should create a function only for that purpose... sometimes you need a blob, array buffers, you can set headers, override mimetype and there is a lot more...</source>
          <target state="translated">다운로드 관리자 (이력서, 파일 판독기, 파일 시스템으로 양쪽에 범위 사용), 캔버스를 사용하는 다양한 이미지 리사이 저 변환기, base64image 등으로 웹 SQL 데이터베이스 채우기 등 ... 그러나이 경우에만 해당 기능을 만들어야합니다 목적 ... 때로는 BLOB, 배열 버퍼가 필요하며 헤더를 설정하고 mimetype을 재정의 할 수 있으며 훨씬 더 많이 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="aabb558dc219037662405ce169cc7769e808b314" translate="yes" xml:space="preserve">
          <source>I tried returning the value from the &lt;code&gt;success&lt;/code&gt; callback, as well as assigning the response to a local variable inside the function and returning that one, but none of those ways actually return the response.</source>
          <target state="translated">&lt;code&gt;success&lt;/code&gt; 콜백에서 값을 반환하고 함수 내부의 로컬 변수에 응답을 할당하고 해당 변수를 반환하려고 시도했지만 실제로는 응답을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="805d9303f1d1e40a739086bcb503bea0dd8a07cd" translate="yes" xml:space="preserve">
          <source>I use this approach a lot. I would be interested to know how well this approach works where wiring the result back through consecutive modules is involved.</source>
          <target state="translated">나는이 접근법을 많이 사용합니다. 연속 모듈을 통해 결과를 다시 배선하는 경우이 접근법이 얼마나 잘 작동하는지 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="96fd1cbea3405a357b87787e1ea700f496799a2f" translate="yes" xml:space="preserve">
          <source>I was using this solution for a while until I figured out there is an error in old browsers:</source>
          <target state="translated">오래된 브라우저에 오류가 있음을 알 때 까지이 솔루션을 잠시 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="404b02c50355c8c0582c7d04c555e4cc95c4e8cb" translate="yes" xml:space="preserve">
          <source>I will answer with a horrible-looking, hand-drawn comic. The second image is the reason why &lt;code&gt;result&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; in your code example.</source>
          <target state="translated">나는 끔찍한 손으로 그린 ​​만화로 대답 할 것입니다. 두 번째 이미지는 코드 예제에서 &lt;code&gt;result&lt;/code&gt; 가 &lt;code&gt;undefined&lt;/code&gt; 이유입니다.</target>
        </trans-unit>
        <trans-unit id="3967fbf9c99e4d431884df5be7bd68f466e20960" translate="yes" xml:space="preserve">
          <source>I would like to give an example for a Ajax request.</source>
          <target state="translated">Ajax 요청에 대한 예제를 제공하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="e1ef9ad0b4029d883d48f869147c3caa394f24cd" translate="yes" xml:space="preserve">
          <source>I'm using a lot of APIs and one of the first functions I integrate into every HTML page is the first Ajax function in this answer, with GET only...</source>
          <target state="translated">나는 많은 API를 사용하고 있으며 모든 HTML 페이지에 통합 된 첫 번째 기능 중 하나는이 답변의 첫 번째 Ajax 함수이며 GET 만 사용합니다 ...</target>
        </trans-unit>
        <trans-unit id="0a86d08347ddae45aa9f3764c8e9705b92f76fe2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doSomethingAsync&lt;/code&gt; gives you a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;doSomethingAsync&lt;/code&gt; 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise를&lt;/a&gt; 제공하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97dfce1b14fd80ba22d599c23dd5f550c7f63ef9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doSomethingAsync&lt;/code&gt; gives you a Promise, if you can use ES2017+ syntax (perhaps with a transpiler like &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;), you can use an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt; function&lt;/a&gt; with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for-of&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;doSomethingAsync&lt;/code&gt; 가 Promise를 제공하는 경우 ES2017 + 구문 (아마도 &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt; 과 같은 변환기)을 사용할 수있는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for-of&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; 함수&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="163754b0a641fcc79050c0cc9adbe06a5d149a2e" translate="yes" xml:space="preserve">
          <source>If the sequence we're producing is a sequence of actions rather than numbers - we can pause the function whenever an action is yielded and wait for it before we resume the function. So instead of a sequence of numbers, we need a sequence of &lt;em&gt;future&lt;/em&gt; values - that is: promises.</source>
          <target state="translated">우리가 생성하는 시퀀스가 ​​숫자가 아닌 일련의 액션 인 경우-액션이 발생할 때마다 함수를 일시 중지하고 함수를 다시 시작하기 전에 기다릴 수 있습니다. 따라서 일련의 숫자 대신 &lt;em&gt;미래&lt;/em&gt; 가치의 순서, 즉 약속이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="afa00a6b4070ffcc7e4d6431383806ca509e451d" translate="yes" xml:space="preserve">
          <source>If underlying function is not promisified</source>
          <target state="translated">기본 기능이 약속되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="b1be43c2bc654592ef71349407fe409b8835e049" translate="yes" xml:space="preserve">
          <source>If underlying function is promisified</source>
          <target state="translated">기본 기능이 약속 된 경우</target>
        </trans-unit>
        <trans-unit id="a2a2af534201c965a8a5307d8256309bf76d379b" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;have&lt;/em&gt; to do it, you can pass a flag: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request&quot;&gt;Here is how:&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;해야&lt;/em&gt; 할 경우 플래그를 전달할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request&quot;&gt;방법은 다음과 같습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e69ab6f2f9d1e92d40998e6452f1feaaddfbbee5" translate="yes" xml:space="preserve">
          <source>If you can't use ES2017+ syntax (yet), you can use a variation on the &lt;a href=&quot;https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all&quot;&gt;&quot;Promise reduce&quot; pattern&lt;/a&gt; (this is more complex than the usual Promise reduce because we're not passing the result from one into the next, but instead gathering up their results in an array):</source>
          <target state="translated">ES2017 + 구문 (아직)을 사용할 수없는 경우 &lt;a href=&quot;https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all&quot;&gt;&quot;Promise reduce&quot;패턴&lt;/a&gt; 의 변형을 사용할 수 있습니다 (결과를 다음으로 전달하지 않기 때문에 일반적인 Promise Reduce보다 더 복잡합니다. 결과를 배열로 수집) :</target>
        </trans-unit>
        <trans-unit id="9b961004352fb6c26e593f096a006f3382d2c3af" translate="yes" xml:space="preserve">
          <source>If you directly use a &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/&quot;&gt;&lt;code&gt;XMLHTTPRequest&lt;/code&gt;&lt;/a&gt; object, pass &lt;code&gt;false&lt;/code&gt; as third argument to &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/#the-open%28%29-method&quot;&gt;&lt;code&gt;.open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/&quot;&gt; &lt;code&gt;XMLHTTPRequest&lt;/code&gt; &lt;/a&gt; 객체를 직접 사용하는 경우 &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/#the-open%28%29-method&quot;&gt; &lt;code&gt;.open&lt;/code&gt; 의&lt;/a&gt; 세 번째 인수로 &lt;code&gt;false&lt;/code&gt; 를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="458c0f1aba3bbec14d8c4e49ddecf559a0d3074c" translate="yes" xml:space="preserve">
          <source>If you don't use jQuery and want a nice short XMLHttpRequest 2 which works on the modern browsers and also on the mobile browsers I suggest to use it this way:</source>
          <target state="translated">jQuery를 사용하지 않고 최신 브라우저와 모바일 브라우저에서 작동하는 짧은 XMLHttpRequest 2를 원한다면 다음과 같이 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="55afcac8cc3cf8d87fcc46044f624ddede12707e" translate="yes" xml:space="preserve">
          <source>If you know that &lt;code&gt;doSomethingAsync&lt;/code&gt; will ignore a second and third argument, you can just pass it directly to &lt;code&gt;map&lt;/code&gt; (&lt;code&gt;map&lt;/code&gt; calls its callback with three arguments, but most people only use the first most of the time):</source>
          <target state="translated">&lt;code&gt;doSomethingAsync&lt;/code&gt; 가 두 번째 및 세 번째 인수를 무시한다는 것을 알고 있다면, 직접 &lt;code&gt;map&lt;/code&gt; 전달할 수 있습니다 ( &lt;code&gt;map&lt;/code&gt; 은 세 개의 인수로 콜백을 호출하지만 대부분의 사람들은 처음으로 만 사용합니다).</target>
        </trans-unit>
        <trans-unit id="c790a5aebe01811818eef515dc847f0886c8d6c4" translate="yes" xml:space="preserve">
          <source>If you need to target browsers that don't support ES6 you can run the code through Babel or closure-compiler to generate ECMAScript 5.</source>
          <target state="translated">ES6를 지원하지 않는 브라우저를 대상으로해야하는 경우 Babel 또는 클로저-컴파일러를 통해 코드를 실행하여 ECMAScript 5를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3630077cc579c9376d3c4c87878034e415200376" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery&lt;/a&gt;, you can set the &lt;code&gt;async&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;. Note that this option is &lt;em&gt;deprecated&lt;/em&gt; since jQuery 1.8.
You can then either still use a &lt;code&gt;success&lt;/code&gt; callback or access the &lt;code&gt;responseText&lt;/code&gt; property of the &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/#jqXHR&quot;&gt;jqXHR object&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery&lt;/a&gt; 를 사용하는 경우 &lt;code&gt;async&lt;/code&gt; 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정할 수 있습니다. 이 옵션은 jQuery 1.8부터 &lt;em&gt;더 이상 사용되지 않습니다&lt;/em&gt; . 그런 다음 여전히 &lt;code&gt;success&lt;/code&gt; 콜백을 사용하거나 &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/#jqXHR&quot;&gt;jqXHR 객체&lt;/a&gt; 의 &lt;code&gt;responseText&lt;/code&gt; 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15eeba4207bfa4d204303f8eb467ce459a91861c" translate="yes" xml:space="preserve">
          <source>If you use any other jQuery Ajax method, such as &lt;code&gt;$.get&lt;/code&gt;, &lt;code&gt;$.getJSON&lt;/code&gt;, etc., you have to change it to &lt;code&gt;$.ajax&lt;/code&gt; (since you can only pass configuration parameters to &lt;code&gt;$.ajax&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;$.get&lt;/code&gt; , &lt;code&gt;$.getJSON&lt;/code&gt; 등과 같은 다른 jQuery Ajax 메소드를 사용하는 경우 &lt;code&gt;$.ajax&lt;/code&gt; 로 변경해야합니다 (구성 매개 변수 만 &lt;code&gt;$.ajax&lt;/code&gt; 전달할 수 있으므로).</target>
        </trans-unit>
        <trans-unit id="3c715363204b6b0c4a698fa23da4f0f9dc888e78" translate="yes" xml:space="preserve">
          <source>If you want to EXTEND the function...</source>
          <target state="translated">기능을 확장하려면 ...</target>
        </trans-unit>
        <trans-unit id="abe47fc3c57755c3997a845ee0b5aa49beefed3e" translate="yes" xml:space="preserve">
          <source>If you want to block the browser for a while load a nice big &lt;code&gt;.txt&lt;/code&gt; file synchronous.</source>
          <target state="translated">잠시 동안 브라우저를 차단하려면 멋진 큰 &lt;code&gt;.txt&lt;/code&gt; 파일을 동기식으로로드하십시오.</target>
        </trans-unit>
        <trans-unit id="4e422421958cc1f0c9d4abcefec9c5f99bb57a7b" translate="yes" xml:space="preserve">
          <source>If you're &lt;em&gt;not&lt;/em&gt; using jQuery in your code, this answer is for you</source>
          <target state="translated">코드에서 jQuery를 사용 &lt;em&gt;하지 않는&lt;/em&gt; 경우이 답변은 당신을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ab8a1b500c194cbfba3513d7de0dea72d3a034e8" translate="yes" xml:space="preserve">
          <source>If you're still having a hard time understanding this &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&quot;&gt;read the AJAX getting started guide&lt;/a&gt; at MDN.</source>
          <target state="translated">여전히 이해하기 어려운 경우 MDN &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&quot;&gt;의 AJAX 시작 안내서&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="18f9b9e612918f51948f6cc2126155b3c549bdae" translate="yes" xml:space="preserve">
          <source>If you're using promises, this answer is for you.</source>
          <target state="translated">약속을 사용하는 경우이 답변이 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="80fc972e4356d8ced60d608ce0baaf96427cd4b5" translate="yes" xml:space="preserve">
          <source>Imagine you make a phone call to a friend and ask him to look something up for you. Although it might take a while, you wait on the phone and stare into space, until your friend gives you the answer that you needed.</source>
          <target state="translated">친구에게 전화를 걸어 무언가를 찾아 보라고 상상해보십시오. 시간이 걸릴 수 있지만 친구가 필요한 답변을 줄 때까지 전화를 기다리고 우주를 응시합니다.</target>
        </trans-unit>
        <trans-unit id="ca8f184ee30d4a232f354261c37cbb9af43a876b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Angular2&lt;/code&gt; with look at the following example, but its &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html&quot;&gt;recommended&lt;/a&gt; to use &lt;code&gt;Observables&lt;/code&gt; with &lt;code&gt;Angular2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Angular2&lt;/code&gt; 에서는 다음 예제를 &lt;code&gt;Angular2&lt;/code&gt; 와 함께 &lt;code&gt;Observables&lt;/code&gt; 를 사용하는 &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html&quot;&gt;것이 좋습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9164c254eac90254b881079ff36f34d077268d4b" translate="yes" xml:space="preserve">
          <source>In ES7, this is further standardized, there are several proposals right now but in all of them you can &lt;code&gt;await&lt;/code&gt; promise. This is just &quot;sugar&quot; (nicer syntax) for the ES6 proposal above by adding the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; keywords. Making the above example:</source>
          <target state="translated">ES7에서는 이것이 표준화되어 있으며, 현재 몇 가지 제안이 있지만 모든 제안에서 약속을 &lt;code&gt;await&lt;/code&gt; 수 있습니다 . 이것은 &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; 키워드를 추가하여 위의 ES6 제안서에 대한 &quot;설탕&quot;(더 구문)입니다. 위의 예제를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="05677a4350495d3e2b8c6f4b68ebe3c7de4458e1" translate="yes" xml:space="preserve">
          <source>In broad, simplistic terms, the event loop is like the project manager, it is constantly listening for any functions that want to run and communicates between the queue and the stack.</source>
          <target state="translated">광범위하고 단순한 용어로, 이벤트 루프는 프로젝트 관리자와 유사하며, 큐와 스택 사이에서 실행하고 통신하려는 모든 기능을 지속적으로 수신합니다.</target>
        </trans-unit>
        <trans-unit id="cd02d6973d3ea865653a48e911c2e50a8c25776e" translate="yes" xml:space="preserve">
          <source>In my Code it is called as</source>
          <target state="translated">내 코드에서는</target>
        </trans-unit>
        <trans-unit id="5cb5ee146291e3428e4c2fcba91cef4c63579d3d" translate="yes" xml:space="preserve">
          <source>In short, synchronous requests block the execution of code... ...this can cause serious issues...</source>
          <target state="translated">요컨대, 동기 요청은 코드 실행을 차단합니다 ... ... 심각한 문제가 발생할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="c37241c1d0bfe0ae8498665ddda9cb54f035c670" translate="yes" xml:space="preserve">
          <source>In the above script, you have an error handler which is statically defined so it does not compromise the function. The error handler can be used for other functions too.</source>
          <target state="translated">위의 스크립트에는 함수가 손상되지 않도록 정적으로 정의 된 오류 처리기가 있습니다. 오류 처리기는 다른 기능에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fee4a9e013a60a7958cc7ec190286ed94e8f8f3" translate="yes" xml:space="preserve">
          <source>In the case of our milk and coffee, we design &lt;code&gt;order_milk&lt;/code&gt; to return a promise for the milk arriving, then specify &lt;code&gt;put_in_coffee&lt;/code&gt; as a &lt;code&gt;then&lt;/code&gt; action, as follows:</source>
          <target state="translated">우유와 커피의 경우 우유 도착에 대한 약속을 반환하도록 &lt;code&gt;order_milk&lt;/code&gt; 를 디자인 한 후 &lt;code&gt;put_in_coffee&lt;/code&gt; 를 &lt;code&gt;then&lt;/code&gt; 조치로 지정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9724168875ccef827ffb62e3e3dac4f3c469e74" translate="yes" xml:space="preserve">
          <source>In the error response, there are no error codes.</source>
          <target state="translated">오류 응답에는 오류 코드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a6a81cb0fe27a1ef73a694660e522eaf40baa80" translate="yes" xml:space="preserve">
          <source>In the example of the question, you can make &lt;code&gt;foo&lt;/code&gt; accept a callback and use it as &lt;code&gt;success&lt;/code&gt; callback. So this</source>
          <target state="translated">질문의 예에서 &lt;code&gt;foo&lt;/code&gt; 는 콜백을 수락하고 &lt;code&gt;success&lt;/code&gt; 콜백으로 사용할 수 있습니다. 그래서 이건</target>
        </trans-unit>
        <trans-unit id="f64c26e8bf33e53e89ffa065ce2af5f6dae03e32" translate="yes" xml:space="preserve">
          <source>In the first case the error is inside the &lt;code&gt;displayAjax()&lt;/code&gt; under &lt;code&gt;this.statusText&lt;/code&gt; as &lt;code&gt;Method not Allowed&lt;/code&gt;.</source>
          <target state="translated">첫 번째 경우 오류는 &lt;code&gt;this.statusText&lt;/code&gt; 아래의 &lt;code&gt;displayAjax()&lt;/code&gt; 안에 &lt;code&gt;Method not Allowed&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fe42b9b5d9a878fe339729448805008fb45dfb5" translate="yes" xml:space="preserve">
          <source>In the following we will look at three different solutions that are all building on top of each other:</source>
          <target state="translated">다음에서 우리는 서로 위에 세 가지 다른 솔루션을 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="ffdebc5331a7e7297d48ecb0f27d85f259e2d630" translate="yes" xml:space="preserve">
          <source>In the second case, it simply works. You have to check at the server side if you passed the right post data.</source>
          <target state="translated">두 번째 경우에는 간단하게 작동합니다. 올바른 게시물 데이터를 전달했는지 서버 측에서 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f588f48cb190b6ff210dbc0bc1dc76feaba12bc" translate="yes" xml:space="preserve">
          <source>In this case, we could rewrite the code in the question as:</source>
          <target state="translated">이 경우 질문의 코드를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e5bc1f12b6bd30221b97d821033adfc0819696f" translate="yes" xml:space="preserve">
          <source>In your case, you would be able to write something like</source>
          <target state="translated">귀하의 경우에는 다음과 같은 것을 작성할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5ae61ff136e6d353245434234270f433244231c2" translate="yes" xml:space="preserve">
          <source>Instead of waiting for the response, the execution continues immediately and the statement after the Ajax call is executed. To get the response eventually, you provide a function to be called once the response was received, a &lt;em&gt;callback&lt;/em&gt; (notice something? &lt;em&gt;call back&lt;/em&gt; ?). Any statement coming after that call is executed before the callback is called.</source>
          <target state="translated">응답을 기다리는 대신 실행이 즉시 계속되고 Ajax 호출 후 명령문이 실행됩니다. 응답을 받으려면 응답이 수신되면 호출되는 함수 인 &lt;em&gt;콜백&lt;/em&gt; (알림? &lt;em&gt;콜백&lt;/em&gt; ?)을 제공합니다. 콜백이 호출되기 전에 해당 호출 다음에 오는 명령문이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5a176ccd898f71da5498417dd981558178ba5429" translate="yes" xml:space="preserve">
          <source>Is a function that returns an &lt;em&gt;iterator&lt;/em&gt; over the sequence &lt;code&gt;1,2,3,3,3,3,....&lt;/code&gt; which can be iterated. While this is interesting on its own and opens room for a lot of possibility there is one particular interesting case.</source>
          <target state="translated">반복 될 수있는 시퀀스 &lt;code&gt;1,2,3,3,3,3,....&lt;/code&gt; 대해 &lt;em&gt;반복자&lt;/em&gt; 를 리턴하는 함수입니다. 이것은 그 자체로 흥미롭고 많은 가능성을위한 여지를 열어 주지만 특별한 흥미로운 사례가 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bfc5cd8986cc4b5d384c982f8dbec35078eb9aa" translate="yes" xml:space="preserve">
          <source>It still returns a promise just the same :)</source>
          <target state="translated">그것은 여전히 ​​똑같은 약속을 반환합니다 :)</target>
        </trans-unit>
        <trans-unit id="ef1f71df2861c22e656b28c20ac85577923d64df" translate="yes" xml:space="preserve">
          <source>It supported all *modern browsers. And I can confirm as I'm using this approach since XMLHttpRequest 2 exists. I never had any type of problem on all browsers I use.</source>
          <target state="translated">모든 * modern 브라우저를 지원했습니다. XMLHttpRequest 2가 존재하기 때문에이 접근법을 사용하고 있음을 확인할 수 있습니다. 내가 사용하는 모든 브라우저에서 문제가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="72465754e74ca9abdcff6be99e29d6961cffe62f" translate="yes" xml:space="preserve">
          <source>It uses the new onload (so you don't have to check for readystate &amp;amp;&amp;amp; status)</source>
          <target state="translated">새로운 onload를 사용하므로 readystate &amp;amp;&amp;amp; status를 확인할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dc11dae9acba94421bf901ebfd0a99a469f66bba" translate="yes" xml:space="preserve">
          <source>It's a very common issue we face while struggling with the 'mysteries' of JavaScript. Let me try demystifying this mystery today.</source>
          <target state="translated">JavaScript의 '수수께끼'로 어려움을 겪고있는 동안 우리가 직면하는 매우 일반적인 문제입니다. 오늘이 수수께끼를 이해하기 위해 노력하겠습니다.</target>
        </trans-unit>
        <trans-unit id="ad52914796d378e861e608f5f5c6f3f574df3d10" translate="yes" xml:space="preserve">
          <source>It's easier to write code using callbacks than it may seem. After all, JavaScript in the browser is heavily event driven (DOM events). Receiving the Ajax response is nothing else but an event.</source>
          <target state="translated">콜백을 사용하여 코드를 작성하는 것이 생각보다 쉽습니다. 결국, 브라우저의 JavaScript는 많은 이벤트 중심 (DOM 이벤트)입니다. Ajax 응답을받는 것은 이벤트 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="cdbb5508c06d9ebb504456c083faa19b12343a7a" translate="yes" xml:space="preserve">
          <source>It's shorter than all other functions Listed.</source>
          <target state="translated">나열된 다른 모든 기능보다 짧습니다.</target>
        </trans-unit>
        <trans-unit id="dfa79b24d359ed76614774ecdc6d3f1f1fedbc1b" translate="yes" xml:space="preserve">
          <source>JavaScript runs in the UI thread of the browser and any long-running process will lock the UI, making it unresponsive. Additionally, there is an upper limit on the execution time for JavaScript and the browser will ask the user whether to continue the execution or not.</source>
          <target state="translated">JavaScript는 브라우저의 UI 스레드에서 실행되며 장시간 실행되는 프로세스는 UI를 잠그므로 응답하지 않습니다. 또한 JavaScript의 실행 시간에는 상한이 있으며 브라우저는 사용자에게 계속 실행 여부를 묻습니다.</target>
        </trans-unit>
        <trans-unit id="e2b5e177110c45130bd6de8833741d43ceee63e1" translate="yes" xml:space="preserve">
          <source>Javscript.info callback</source>
          <target state="translated">Javscript.info 콜백</target>
        </trans-unit>
        <trans-unit id="bbbd4891d7699a852c6406a296c2fcf52f3c3e57" translate="yes" xml:space="preserve">
          <source>Js is a single threaded.</source>
          <target state="translated">JS는 단일 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="e54a9bcf7595f53be50f3d461e5136cdeac9c123" translate="yes" xml:space="preserve">
          <source>Keep in mind that promises and deferred objects are just &lt;em&gt;containers&lt;/em&gt; for a future value, they are not the value itself. For example, suppose you had the following:</source>
          <target state="translated">약속 및 지연된 개체는 미래 가치를위한 &lt;em&gt;컨테이너 일&lt;/em&gt; 뿐이며 값 자체는 아닙니다. 예를 들어, 다음이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="a450dc9bb252815e0a34be6965a19e24021fbb40" translate="yes" xml:space="preserve">
          <source>Let functions accept &lt;em&gt;callbacks&lt;/em&gt;</source>
          <target state="translated">함수가 &lt;em&gt;콜백을&lt;/em&gt; 받도록 허용</target>
        </trans-unit>
        <trans-unit id="5142ad643e1ca5f1c54df798209cf3a4e972be1a" translate="yes" xml:space="preserve">
          <source>Let suppose our serverRequest() function had a return statement in a code, when we get back data from server Web API will push it in queue at the end of queue.
As it get pushed at end in queue we cannot utilise its data as there is no function left in our queue to utilise this data.&lt;strong&gt;Thus it is not possible to return something from Async Call.&lt;/strong&gt;</source>
          <target state="translated">serverRequest () 함수가 코드에 return 문을 가지고 있다고 가정 해 봅시다. 서버 웹 API에서 데이터를 가져올 때 큐의 끝에서 큐로 푸시합니다. 대기열의 끝에서 푸시되기 때문에 대기열 에이 데이터를 활용하는 기능이 없으므로 데이터를 활용할 수 없습니다. &lt;strong&gt;따라서 비동기 호출에서 무언가를 반환 할 수 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29816c85c3b63dc23d798455274fc320da92a3db" translate="yes" xml:space="preserve">
          <source>Let your function accept a callback. In the example code &lt;code&gt;foo&lt;/code&gt; can be made to accept a callback. We'll be telling our code how to &lt;em&gt;react&lt;/em&gt; when &lt;code&gt;foo&lt;/code&gt; completes.</source>
          <target state="translated">함수가 콜백을 수락하도록합니다. 예제 코드에서 &lt;code&gt;foo&lt;/code&gt; 는 콜백을 수락하도록 만들 수 있습니다. 우리는 &lt;code&gt;foo&lt;/code&gt; 가 완료 될 때 &lt;em&gt;반응&lt;/em&gt; 하는 방법을 코드에 알려줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="2b907de8cd2ea70a0a07b7b3951542f8bc4bf8bc" translate="yes" xml:space="preserve">
          <source>Let's apply promises to your particular problem. We will wrap our request logic inside a function, which returns a promise:</source>
          <target state="translated">특정 문제에 대한 약속을 적용합시다. 우리는 요청 로직을 함수로 감싸서 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d30dd5f759cc5533cfc4d9a5b1b61f8383c8dbb1" translate="yes" xml:space="preserve">
          <source>Let's ask our function for a &lt;strong&gt;PROMISE&lt;/strong&gt;.
Promise is really about what it means : it means that the function guarantees you to provide with any output it gets in future. so let's see it in action for our little problem above :</source>
          <target state="translated">함수에 &lt;strong&gt;PROMISE&lt;/strong&gt; 를 요청합시다. 약속은 실제로 그것이 의미하는 바에 관한 것입니다. 즉,이 기능은 앞으로 얻을 수있는 모든 출력을 제공한다는 것을 의미합니다. 위의 작은 문제에 대해 실제로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f03473dc33a9b7108d06e897d4c147d809acee67" translate="yes" xml:space="preserve">
          <source>Let's see how we can solve the above issue with promises. First, let's demonstrate our understanding of promise states from above by using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise&quot;&gt;Promise constructor&lt;/a&gt; for creating a delay function:</source>
          <target state="translated">약속으로 위의 문제를 어떻게 해결할 수 있는지 봅시다. 먼저 지연 함수를 만들기 위해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise&quot;&gt;Promise 생성자&lt;/a&gt; 를 사용하여 위에서 약속 상태에 대한 이해를 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="097a1fd4f4dd6ae948cf296ebf5e3fed29d827b1" translate="yes" xml:space="preserve">
          <source>Let's start with a simple JavaScript function:</source>
          <target state="translated">간단한 JavaScript 함수로 시작해 봅시다.</target>
        </trans-unit>
        <trans-unit id="012b3ad7e2336b480f233ac7230671a56ff96505" translate="yes" xml:space="preserve">
          <source>Lets first enable JQuery usage, to have &lt;code&gt;$&lt;/code&gt; available as &lt;code&gt;S&lt;/code&gt;:</source>
          <target state="translated">먼저 &lt;code&gt;$&lt;/code&gt; 를 &lt;code&gt;S&lt;/code&gt; 로 사용할 수 있도록 JQuery 사용을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3ac2a3b85bfb179de3d5fd9a6d1778a34a10d96e" translate="yes" xml:space="preserve">
          <source>Make the AJAX call synchronous (lets call it SJAX).</source>
          <target state="translated">AJAX 호출을 동 기적으로 만듭니다 (SJAX라고 함).</target>
        </trans-unit>
        <trans-unit id="4149f095bdea0d897f44292f13870fb2ca675c68" translate="yes" xml:space="preserve">
          <source>More examples here: &lt;a href=&quot;https://github.com/amaksr/nsynjs/tree/master/examples&quot;&gt;https://github.com/amaksr/nsynjs/tree/master/examples&lt;/a&gt;</source>
          <target state="translated">여기에 더 많은 예제가 있습니다 : &lt;a href=&quot;https://github.com/amaksr/nsynjs/tree/master/examples&quot;&gt;https://github.com/amaksr/nsynjs/tree/master/examples&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="416843538915a12d446291b1a92446755e1f2268" translate="yes" xml:space="preserve">
          <source>More information about promises: &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;HTML5 rocks - JavaScript Promises&lt;/a&gt;</source>
          <target state="translated">약속에 대한 추가 정보 : &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;HTML5 Rocks-JavaScript Promises&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25f50452665d503e55acf0b8c965da53f9e2eb1f" translate="yes" xml:space="preserve">
          <source>Most of the answers here give useful suggestions for when you have a single async operation, but sometimes, this comes up when you need to do an asynchronous operation for &lt;em&gt;each&lt;/em&gt; entry in an array or other list-like structure. The temptation is to do this:</source>
          <target state="translated">여기에있는 대부분의 답변은 단일 비동기 작업이있을 때 유용한 제안을 제공하지만 때로는 배열 또는 다른 목록과 같은 구조의 &lt;em&gt;각&lt;/em&gt; 항목에 &lt;em&gt;대해&lt;/em&gt; 비동기 작업을 수행해야 할 때 나타납니다. 유혹은 이것을하는 것입니다 :</target>
        </trans-unit>
        <trans-unit id="7ace0f986a8d32fe40488522b23a55438cb0b782" translate="yes" xml:space="preserve">
          <source>Not recommended: Synchronous &quot;Ajax&quot; calls</source>
          <target state="translated">권장하지 않음 : 동기 &quot;Ajax&quot;호출</target>
        </trans-unit>
        <trans-unit id="a3266b1005a3a1afba35c5209761885a8ad47be3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Promise.all&lt;/code&gt; resolves its promise with an array of the results of all of the promises you give it when they are all resolved, or rejects its promise when the &lt;em&gt;first&lt;/em&gt; of the promises you give it rejects.</source>
          <target state="translated">&lt;code&gt;Promise.all&lt;/code&gt; 은 약속이 모두 해결 될 때 제공 한 모든 약속의 결과 배열을 사용하여 약속을 해결하거나, 약속을 &lt;em&gt;처음&lt;/em&gt; 제공 할 때 약속을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="ce6df39941058908a0b980171b83775c7db609fa" translate="yes" xml:space="preserve">
          <source>Note that the call to &lt;code&gt;foo()&lt;/code&gt; will still return nothing useful. However, the result of the async call will now be stored in &lt;code&gt;result.response&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; 호출은 여전히 ​​유용한 정보를 반환하지 않습니다. 그러나 비동기 호출의 결과는 이제 &lt;code&gt;result.response&lt;/code&gt; 에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d9c2dea7d7e7a3411da1773762e08918f5674124" translate="yes" xml:space="preserve">
          <source>Nothing easier.</source>
          <target state="translated">쉬운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="353e455e2b68dea72cd422384a4b460cd47300c4" translate="yes" xml:space="preserve">
          <source>Notice how we use the &lt;code&gt;index&lt;/code&gt; from &lt;code&gt;forEach&lt;/code&gt; to save the result in &lt;code&gt;results&lt;/code&gt; in the same position as the entry it relates to, even if the results arrive out of order (since async calls don't necessarily complete in the order in which they were started).</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; 의 &lt;code&gt;index&lt;/code&gt; 을 사용하여 결과가 순서에 맞지 않더라도 결과가 관련 항목과 동일한 위치에 &lt;code&gt;results&lt;/code&gt; 를 저장하는 방법에 주목하십시오 (비동기 호출이 반드시 시작된 순서대로 완료되지는 않기 때문). ).</target>
        </trans-unit>
        <trans-unit id="929ed6885fc0b5c2a602a91186d7a6db6f5f8584" translate="yes" xml:space="preserve">
          <source>Now if you want something more complex using post and FormData you can easily extend this function:</source>
          <target state="translated">이제 post 및 FormData를 사용하여 더 복잡한 것을 원하면이 기능을 쉽게 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d974961b0a397dae3ab443eb46237547fe41139f" translate="yes" xml:space="preserve">
          <source>Now let us think we pushed two functions in a queue one is for getting a data from server and another utilises that data.We pushed the serverRequest() function in queue first then utiliseData() function. serverRequest function goes in event loop and makes a call to server as we never know how much time it will take to get data from server
so this process is expected to take time and so we busy our event loop thus hanging our page, that's where Web API come into role it take this function from event loop and deals with server making event loop free so that we can execute next function from queue.The next function in queue is utiliseData() which goes in loop but because of no data available it goes waste and execution of next function continues till end of the queue.(This is called Async calling i.e we can do something else till we get data)</source>
          <target state="translated">이제 하나는 서버에서 데이터를 가져 오기위한 것이고 다른 하나는 해당 데이터를 이용하는 것입니다. 우리는 먼저 queueRequest에서 serverRequest () 함수를 누른 다음 utiliseData () 함수를 푸시합니다. serverRequest 함수는 이벤트 루프로 이동하여 서버에서 데이터를 가져 오는 데 걸리는 시간을 알지 못하므로 서버를 호출 하므로이 프로세스에는 시간이 걸리므로 이벤트 루프가 바빠서 페이지가 중단됩니다. API가 역할을 수행하면 이벤트 루프 에서이 함수를 가져 와서 서버에서 이벤트 루프를 자유롭게 처리하여 큐에서 다음 함수를 실행할 수 있습니다. 큐의 다음 함수는 루프에 들어가는 utiliseData ()이지만 사용할 수있는 데이터가 없기 때문에 대기열이 끝날 때까지 다음 함수의 낭비와 실행이 계속됩니다 (Async 호출이라고합니다. 즉 데이터를 얻을 때까지 다른 작업을 수행 할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="e0a63d4292a004be42ee890cb652815050847bb1" translate="yes" xml:space="preserve">
          <source>Now let's add a bit of twist, by introducing little delay in our function, so that all lines of code are not 'finished' in sequence. Thus, it will emulate the asynchronous behavior of function :</source>
          <target state="translated">이제 모든 코드 줄이 순서대로 '완료'되지 않도록 함수에 약간의 지연을 도입하여 약간의 왜곡을 추가합시다. 따라서 함수의 비동기 동작을 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="42c38f982e0c169feb7e086aabc21246bff1aad8" translate="yes" xml:space="preserve">
          <source>Now some people will probably say that it's better to use onreadystatechange or the even the XMLHttpRequest variable name. That's wrong.</source>
          <target state="translated">이제 일부 사람들은 onreadystatechange 또는 심지어 XMLHttpRequest 변수 이름을 사용하는 것이 더 낫다고 말할 것입니다. 그건 틀렸어요.</target>
        </trans-unit>
        <trans-unit id="a2fab3eea51d1e71a6c436e1f5c97b56ccdd5071" translate="yes" xml:space="preserve">
          <source>Now you can do</source>
          <target state="translated">이제 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="da89b3c0dfa9111f27c794ec1b03edd3bdfde2dd" translate="yes" xml:space="preserve">
          <source>Now, after we converted setTimeout to use promises, we can use &lt;code&gt;then&lt;/code&gt; to make it count:</source>
          <target state="translated">이제 약속을 사용하도록 setTimeout을 변환 &lt;code&gt;then&lt;/code&gt; 이를 사용하여 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8914db3fb9a1d0494f5a0d8fd668ced73c34d069" translate="yes" xml:space="preserve">
          <source>Now, let's define foo itself to act accordingly</source>
          <target state="translated">이제 foo 자체를 적절하게 정의 해 봅시다</target>
        </trans-unit>
        <trans-unit id="99be19d54cf7652a1615ab27cbc8bbf0aed5749c" translate="yes" xml:space="preserve">
          <source>Nsynjs will evaluate all operators and expressions step-by-step, pausing execution in case if result of some slow function is not ready.</source>
          <target state="translated">Nsynjs는 모든 연산자와 표현식을 단계별로 평가하여 일부 느린 기능의 결과가 준비되지 않은 경우 실행을 일시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="5a64163c890c0896f46f25e78ce25b037738ed57" translate="yes" xml:space="preserve">
          <source>Of course there are many approaches like synchronous request, promise, but from my experience I think you should use the callback approach. It's natural to asynchronous behavior of Javascript.
So, your code snippet can be rewrite a little different:</source>
          <target state="translated">물론 동기 요청, 약속과 같은 많은 접근 방식이 있지만 내 경험으로는 콜백 접근 방식을 사용해야한다고 생각합니다. Javascript의 비동기 동작은 자연 스럽습니다. 따라서 코드 스 니펫을 약간 다르게 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e78929c9a21094861197c3ba952c175f274cc77" translate="yes" xml:space="preserve">
          <source>Once it receives a message to run something it adds it to the queue. The queue is the list of things that are waiting to execute (like your AJAX request). imagine it like this:</source>
          <target state="translated">무언가를 실행할 메시지를 받으면 큐에 추가합니다. 대기열은 AJAX 요청과 같이 실행 대기중인 항목의 목록입니다. 다음과 같이 상상하십시오.</target>
        </trans-unit>
        <trans-unit id="9d39748eb9ce2dc97c87c582527e55724204f745" translate="yes" xml:space="preserve">
          <source>One advantage of this is that we can string these together to create sequences of future occurrences (&quot;chaining&quot;):</source>
          <target state="translated">이것의 한 가지 장점은이 문자열들을 함께 묶어 미래에 발생하는 시퀀스 ( &quot;체인&quot;)를 만들 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="54016dfcceb363844e7cc4be09ec8ae272d45106" translate="yes" xml:space="preserve">
          <source>One possible solution to this problem is to code &lt;em&gt;re-actively&lt;/em&gt; , telling your program what to do when the calculation completed.</source>
          <target state="translated">이 문제에 대한 한 가지 가능한 해결책은 &lt;em&gt;재활 성&lt;/em&gt; 코드를 작성하여 계산이 완료되면 프로그램에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="6a68116dc884c578869074c6236313ddd089faa1" translate="yes" xml:space="preserve">
          <source>One possible solution to this problem is to code &lt;em&gt;re-actively&lt;/em&gt; , telling your program what to do when the calculation completed. Promises actively enable this by being temporal (time-sensitive) in nature.</source>
          <target state="translated">이 문제에 대한 한 가지 가능한 해결책은 &lt;em&gt;재활 성&lt;/em&gt; 코드를 작성하여 계산이 완료되면 프로그램에 지시합니다. 약속은 본질적으로 시간적 (시간에 민감 함)이어서 적극적으로 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="e3fe8189fb8e3a9175a9246ff74a29655859c5dc" translate="yes" xml:space="preserve">
          <source>Only if you have a page where you load always the same XML/JSON or whatever you need only one function. In that case, modify a little the Ajax function and replace b with your special function.</source>
          <target state="translated">항상 동일한 XML / JSON을로드하거나 하나의 기능 만 필요한 페이지가있는 경우에만 해당됩니다. 이 경우 Ajax 함수를 약간 수정하고 b를 특수 함수로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="5266da9d163f68f6d914c71fc5ace6c79a2e3aaa" translate="yes" xml:space="preserve">
          <source>Or (the above one is better anonymous functions are always a problem):</source>
          <target state="translated">또는 (위의 익명 함수는 항상 문제가됩니다.)</target>
        </trans-unit>
        <trans-unit id="7574e85e254349a76f9eb280b8d26c2fcd432db0" translate="yes" xml:space="preserve">
          <source>Or here's a version returning a &lt;code&gt;Promise&lt;/code&gt; instead:</source>
          <target state="translated">또는 대신 &lt;code&gt;Promise&lt;/code&gt; 를 반환하는 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="912172dfb14be8eb490ece32e4e426ffa381d626" translate="yes" xml:space="preserve">
          <source>Or if for some reason you &lt;code&gt;bind()&lt;/code&gt; the callback to a class:</source>
          <target state="translated">또는 어떤 이유로 든 콜백을 클래스에 &lt;code&gt;bind()&lt;/code&gt; 하면</target>
        </trans-unit>
        <trans-unit id="97548c9db4d27ac2b95bbc49510f16af46cc2fde" translate="yes" xml:space="preserve">
          <source>Or pass a full form element (&lt;code&gt;document.getElementsByTagName('form')[0]&lt;/code&gt;):</source>
          <target state="translated">또는 전체 양식 요소 ( &lt;code&gt;document.getElementsByTagName('form')[0]&lt;/code&gt; )를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="e22be26c55a52d473b9811210f17414624c87259" translate="yes" xml:space="preserve">
          <source>Or set some custom values:</source>
          <target state="translated">또는 일부 사용자 정의 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="68f819f1f89dc9e0529ac2892b6d2f288badbd02" translate="yes" xml:space="preserve">
          <source>Or the Promise syntax</source>
          <target state="translated">또는 약속 구문</target>
        </trans-unit>
        <trans-unit id="afc129571bf06499cb7e3b0ffe14106bdb906a2f" translate="yes" xml:space="preserve">
          <source>Parallel</source>
          <target state="translated">Parallel</target>
        </trans-unit>
        <trans-unit id="3768a1e6d49da0cac1c978e4121bcf5a453c81eb" translate="yes" xml:space="preserve">
          <source>Possible solutions</source>
          <target state="translated">가능한 해결책</target>
        </trans-unit>
        <trans-unit id="7bb1c6338f84ef633dbff9dc2ca5d6404721463d" translate="yes" xml:space="preserve">
          <source>Promises are containers for &lt;em&gt;future&lt;/em&gt; values. When the promise receives the value (it is &lt;em&gt;resolved&lt;/em&gt;) or when it is canceled (&lt;em&gt;rejected&lt;/em&gt;), it notifies all of its &quot;listeners&quot; who want to access this value.</source>
          <target state="translated">약속은 &lt;em&gt;미래&lt;/em&gt; 가치를위한 컨테이너입니다. 약속이 값을 받거나 ( &lt;em&gt;해결됨&lt;/em&gt; ) 취소 ( &lt;em&gt;거부 됨&lt;/em&gt; )하면이 값에 액세스하려는 모든 &quot;리스너&quot;에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="8350b08167777968ab876b41274f64fe1318e1bf" translate="yes" xml:space="preserve">
          <source>Promises can be used to unnest asynchronous functions and allows one to chain multiple functions together.</source>
          <target state="translated">약속을 사용하여 비동기 함수를 제거하고 여러 함수를 함께 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c32135d34ac0c0221572109c3dfc7f43a9751b94" translate="yes" xml:space="preserve">
          <source>Quick recap on promises</source>
          <target state="translated">약속에 대한 빠른 요약</target>
        </trans-unit>
        <trans-unit id="c235eb24c95a5e9981695eb449944a162b57ebf2" translate="yes" xml:space="preserve">
          <source>Rather than throwing code at you, there are 2 concepts that are key to understanding how JS handles callbacks and asynchronicity. (is that even a word?)</source>
          <target state="translated">코드를 던지기보다는 JS가 콜백 및 비동기 성을 처리하는 방법을 이해하는 데 중요한 두 가지 개념이 있습니다. (그것도 단어입니까?)</target>
        </trans-unit>
        <trans-unit id="29bff7173029217e94f4afcceb94f3ce6f4a8162" translate="yes" xml:space="preserve">
          <source>Restructure your code to work properly with callbacks.</source>
          <target state="translated">콜백에서 제대로 작동하도록 코드를 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="062f9fe8caa07becb814606e66f0cdd8c44eccb5" translate="yes" xml:space="preserve">
          <source>Return a Promise</source>
          <target state="translated">약속을 반환</target>
        </trans-unit>
        <trans-unit id="da07fe527d40396d3dc18ff2bbee2077e9679bf6" translate="yes" xml:space="preserve">
          <source>Returning anything in the submit handler will not do anything. You must instead either hand off the data, or do what you want with it directly inside the success function.</source>
          <target state="translated">제출 핸들러에서 아무것도 리턴하지 않으면 아무 것도 수행되지 않습니다. 대신 데이터를 전달하거나 성공 함수 내에서 직접 원하는 데이터를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="be64c83fb64f3829b56366e909fbacc0081629bd" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html&quot;&gt;original&lt;/a&gt; post here. But Typescript does not support &lt;a href=&quot;http://www.datchley.name/es6-promises/&quot;&gt;native es6 Promises&lt;/a&gt;, if you want to use it, you might need plugin for that.</source>
          <target state="translated">여기에 &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html&quot;&gt;원래&lt;/a&gt; 게시물을 참조하십시오. 그러나 Typescript는 &lt;a href=&quot;http://www.datchley.name/es6-promises/&quot;&gt;기본 es6 Promises를&lt;/a&gt; 지원하지 않습니다. Typescript를 사용하려면 플러그인이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c20d94e78fa142819df8cc9440d30e65329975" translate="yes" xml:space="preserve">
          <source>Series</source>
          <target state="translated">Series</target>
        </trans-unit>
        <trans-unit id="7e56c5c8aa16c1ef6db37ada8a6266e68cceb09e" translate="yes" xml:space="preserve">
          <source>Several solutions have been given in this thread. Perhaps the easiest way is to pass an object to the &lt;code&gt;foo()&lt;/code&gt; method, and to store the results in a member of that object after the async call completes.</source>
          <target state="translated">이 글타래에 여러 가지 해결책이 있습니다. 아마도 가장 쉬운 방법은 객체를 &lt;code&gt;foo()&lt;/code&gt; 메서드에 전달하고 비동기 호출이 완료된 후 결과를 해당 객체의 멤버에 저장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2148a375d3f6b7a16b65d3a1f82733a29815e073" translate="yes" xml:space="preserve">
          <source>Short answer is, &lt;strong&gt;you have to implement a callback like this:&lt;/strong&gt;</source>
          <target state="translated">짧은 대답은 &lt;strong&gt;다음과 같이 콜백을 구현해야한다는 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="ff1c87cac36b81c6f91891fbd54132c4334c4e46" translate="yes" xml:space="preserve">
          <source>Side note: Promise gotchas</source>
          <target state="translated">참고 사항 : Promise gotchas</target>
        </trans-unit>
        <trans-unit id="05506c4ac3acb4d27c65c550acf4b39c197cd038" translate="yes" xml:space="preserve">
          <source>Side note: jQuery's deferred objects</source>
          <target state="translated">참고 사항 : jQuery의 지연된 객체</target>
        </trans-unit>
        <trans-unit id="fa5759978602e0fa347526198e20ed43cc048568" translate="yes" xml:space="preserve">
          <source>Simple usage example:</source>
          <target state="translated">간단한 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="4096759186b4f9723934ec713d75bc04761b5820" translate="yes" xml:space="preserve">
          <source>Since the operation did not happen yet (AJAX, server call, IO, timer) you're returning the value before the request got the chance to tell your code what that value is.</source>
          <target state="translated">작업이 아직 발생하지 않았기 때문에 (AJAX, 서버 호출, IO, 타이머) 요청이 코드에 해당 값이 무엇인지 알려주기 전에 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a7e4ac52f20fc5994d25a70f507d562ec34a41e" translate="yes" xml:space="preserve">
          <source>So anything that foobarFunc needs to execute (in our case &lt;code&gt;anotherFunction&lt;/code&gt;) will get pushed onto the stack. executed, and then forgotten about - the event loop will then move onto the next thing in the queue (or listen for messages)</source>
          <target state="translated">따라서 foobarFunc가 실행해야하는 모든 것 (이 경우 &lt;code&gt;anotherFunction&lt;/code&gt; )이 스택으로 푸시됩니다. 이벤트 루프가 대기열의 다음 항목으로 이동하거나 메시지를 듣습니다.</target>
        </trans-unit>
        <trans-unit id="4130aa961d9f8a1abff39f8f3f11e49af247d9a2" translate="yes" xml:space="preserve">
          <source>So i decided to implement my own Promise class for &lt;strong&gt;ES3 to below&lt;/strong&gt; js compilers if its not defined. Just add this code before your main code and then safely use Promise!</source>
          <target state="translated">그래서 &lt;strong&gt;ES3에&lt;/strong&gt; 대한 내 Promise 클래스를 정의하지 않은 경우 js 컴파일러 &lt;strong&gt;아래&lt;/strong&gt; 로 구현하기로 결정했습니다. 기본 코드 앞에이 코드를 추가 한 다음 Promise를 안전하게 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="519e6b95ba34166e61a9a33a9c6412ef034c0b19" translate="yes" xml:space="preserve">
          <source>So if you are using &lt;strong&gt;Angular, React&lt;/strong&gt; or any other frameworks which do &lt;strong&gt;two ways data binding&lt;/strong&gt; or &lt;strong&gt;store concept&lt;/strong&gt; this issue is simply fixed for you, so in easy word, your result is &lt;code&gt;undefined&lt;/code&gt; at the first stage, so you have got &lt;code&gt;result = undefined&lt;/code&gt; before you receive the data, then as soon as you get the result, it will be updated and get assigned to the new value which response of your Ajax call...</source>
          <target state="translated">따라서 &lt;strong&gt;Angular, React&lt;/strong&gt; 또는 &lt;strong&gt;두 가지 방법으로 데이터 바인딩&lt;/strong&gt; 또는 &lt;strong&gt;저장 개념&lt;/strong&gt; 을 수행하는 다른 프레임 워크를 사용하는 경우이 문제는 간단하게 해결되므로 쉽게 말하면 결과가 첫 번째 단계에서 &lt;code&gt;undefined&lt;/code&gt; 않으므로 &lt;code&gt;result = undefined&lt;/code&gt; 데이터를 수신하기 전에 결과를 얻 자마자 업데이트되어 Ajax 호출의 응답 인 새 값에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="456834897466e279954c59b225ffcd0a611dc23f" translate="yes" xml:space="preserve">
          <source>So there you go, that delay just broke the functionality we expected! But what exactly happened ? Well, it's actually pretty logical if you look at the code. the function &lt;code&gt;foo()&lt;/code&gt;, upon execution, returns nothing (thus returned value is &lt;code&gt;undefined&lt;/code&gt;), but it does start a timer, which executes a function after 1s to return 'wohoo'. But as you can see, the value that's assigned to bar is the immediately returned stuff from foo(), which is nothing i.e. just &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">따라서 지연이 예상 한 기능을 깨뜨 렸습니다. 그러나 정확히 무슨 일이 있었습니까? 글쎄, 코드를 보면 실제로 논리적입니다. &lt;code&gt;foo()&lt;/code&gt; 함수는 실행시 아무것도 반환하지 않으므로 반환 값은 &lt;code&gt;undefined&lt;/code&gt; 이지만 타이머를 시작하여 1 초 후에 함수를 실행하여 'wohoo'를 반환합니다. 그러나 보시다시피 bar에 할당 된 값은 foo ()에서 즉시 반환되는 것입니다. 즉, &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3ebd3c140905d6a71bb22361b04f8129d104582a" translate="yes" xml:space="preserve">
          <source>So this works just as well. We've learned we can't return values from already asynchronous calls but we can use promises and chain them to perform processing. We now know how to return the response from an asynchronous call.</source>
          <target state="translated">그래서 이것은 잘 작동합니다. 이미 비동기 호출에서 값을 반환 할 수는 없지만 약속을 사용하여 연결하여 처리를 수행 할 수 있음을 배웠습니다. 이제 비동기 호출에서 응답을 반환하는 방법을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="16474dcce86aac08469b81e9bbfe841fd4c01c7d" translate="yes" xml:space="preserve">
          <source>So what you need to do is pass a function that is promised to execute at some point with data that is passed to it.</source>
          <target state="translated">그래서 당신이해야 할 일은 전달 된 데이터로 어느 시점에서 실행되도록 약속 된 함수를 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0efce20ff147121d241f07ae7346392a017a7c29" translate="yes" xml:space="preserve">
          <source>So, if you have an array (or list of some kind) and want to do async operations for each entry, you have two options: Do the operations in parallel (overlapping), or in series (one after another in sequence).</source>
          <target state="translated">따라서 배열 (또는 일종의 목록)이 있고 각 항목에 대해 비동기 작업을 수행하려는 경우 두 가지 옵션이 있습니다. 작업을 병렬로 (겹침) 또는 직렬로 (순서대로) 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4549b38f6f564b62d621d5aaa8f137985559a5b5" translate="yes" xml:space="preserve">
          <source>So, you to run the following example you need to put your access token in the request headers:</source>
          <target state="translated">따라서 다음 예제를 실행하려면 요청 헤더에 액세스 토큰을 넣어야합니다.</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="b9a422a9be9b2bc191da989656816034a1f6eee5" translate="yes" xml:space="preserve">
          <source>So: No need for error checks if you're able to copy and paste the URL properly. ;)</source>
          <target state="translated">따라서 URL을 올바르게 복사하여 붙여 넣을 수 있으면 오류를 확인할 필요가 없습니다. ;)</target>
        </trans-unit>
        <trans-unit id="958cd629e68ed77d9824bb75c9b43a7f1cf49e0a" translate="yes" xml:space="preserve">
          <source>Solution(s)</source>
          <target state="translated">Solution(s)</target>
        </trans-unit>
        <trans-unit id="9dbffa1e0ccfddb501d678c507c62423968b4d1e" translate="yes" xml:space="preserve">
          <source>Step 1. Wrap function with callback into nsynjs-aware wrapper (if it has promisified version, you can skip this step):</source>
          <target state="translated">1 단계. 콜백이있는 함수를 nsynjs 인식 래퍼로 래핑합니다 (약식이있는 경우이 단계를 건너 뛸 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="fcdabda0acdbf7ed77f27dcb6841a85fbda15814" translate="yes" xml:space="preserve">
          <source>Step 2. Put synchronous logic into function:</source>
          <target state="translated">2 단계. 동기식 로직을 기능에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="80eb86c9950baf665d77b6ad1ffb913a4fa504e2" translate="yes" xml:space="preserve">
          <source>Step 3. Run function in synchronous manner via nsynjs:</source>
          <target state="translated">단계 3. nsynjs를 통해 동기 방식으로 함수를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e79e3d8d02a013d89691c298f6bd299451c74b8a" translate="yes" xml:space="preserve">
          <source>Suppose you don't want the operations to be in parallel? If you want to run them one after another, you need to wait for each operation to complete before you start the next. Here's an example of a function that does that and calls a callback with the result:</source>
          <target state="translated">작업이 병렬로 수행되고 싶지 않다고 가정 해보십시오. 하나씩 차례로 실행하려면 다음을 시작하기 전에 각 작업이 완료 될 때까지 기다려야합니다. 다음은이를 수행하고 결과와 함께 콜백을 호출하는 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="77c61919f7c0335c38d9155372ee85055a736cc1" translate="yes" xml:space="preserve">
          <source>Synchronous</source>
          <target state="translated">Synchronous</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">그건:</target>
        </trans-unit>
        <trans-unit id="9111ae84fd392e9454be6a96907483945425e257" translate="yes" xml:space="preserve">
          <source>That's a simple synchronous function call (where each line of code is 'finished with its job' before the next one in sequence), and the result is same as expected.</source>
          <target state="translated">그것은 간단한 동기 함수 호출 (각 코드 줄이 다음 작업 순서대로 '작업으로 완료됩니다')이며 결과는 예상과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6dadcf5d4da4a50438dd8a46454bbf9f5c8a3d23" translate="yes" xml:space="preserve">
          <source>That's exactly what's happening when you do an Ajax request.</source>
          <target state="translated">그것이 바로 Ajax 요청을 할 때 일어나는 일입니다.</target>
        </trans-unit>
        <trans-unit id="c7cfbaca7087cb7a7879162ad5a4e04b1f217824" translate="yes" xml:space="preserve">
          <source>That's why with asynchronous functionality we use things called &lt;strong&gt;callbacks&lt;/strong&gt;. It's kinda like a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;promise&lt;/a&gt; quite literally. As in I &lt;em&gt;promise to return something at some point&lt;/em&gt; jQuery uses specific callbacks called &lt;code&gt;deffered.done&lt;/code&gt;&lt;code&gt;deffered.fail&lt;/code&gt; and &lt;code&gt;deffered.always&lt;/code&gt; (amongst others). You can see them all &lt;a href=&quot;https://api.jquery.com/category/deferred-object/&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">이것이 비동기 기능으로 &lt;strong&gt;콜백&lt;/strong&gt; 이라는 것을 사용하는 이유입니다. 문자 그대로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;약속&lt;/a&gt; 같은 것입니다. &lt;em&gt;어느 시점에서 무언가를 반환하겠다고 약속 한&lt;/em&gt; 것처럼 jQuery는 &lt;code&gt;deffered.done&lt;/code&gt; &lt;code&gt;deffered.fail&lt;/code&gt; 및 &lt;code&gt;deffered.always&lt;/code&gt; (다른 것들 중에서)라는 특정 콜백을 사용합니다. &lt;a href=&quot;https://api.jquery.com/category/deferred-object/&quot;&gt;여기에서&lt;/a&gt; 모두 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="15bb754ff5cde7f28dcd0bb70e024c67cb821f55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise API&lt;/a&gt; is a new feature of ECMAScript 6 (ES2015), but it has good &lt;a href=&quot;http://caniuse.com/#feat=promises&quot;&gt;browser support&lt;/a&gt; already. There are also many libraries which implement the standard Promises API and provide additional methods to ease the use and composition of asynchronous functions (e.g. &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;bluebird&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise API&lt;/a&gt; 는 ECMAScript 6 (ES2015)의 새로운 기능이지만 이미 &lt;a href=&quot;http://caniuse.com/#feat=promises&quot;&gt;브라우저&lt;/a&gt; 를 잘 지원 합니다. 표준 Promises API를 구현하고 비동기 함수 (예 : &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;블루 버드&lt;/a&gt; )의 사용 및 구성을 용이하게하는 추가 메소드를 제공하는 많은 라이브러리도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8863ecce1e4cf6263ca3b1bcde858dda65b7c8db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="eb35c6a9a9151152e061add9aab9caeda5223463" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;A&lt;/strong&gt; in &lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;Ajax&lt;/a&gt; stands for &lt;a href=&quot;https://www.merriam-webster.com/dictionary/asynchronous&quot;&gt;&lt;strong&gt;asynchronous&lt;/strong&gt;&lt;/a&gt; . That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, &lt;code&gt;$.ajax&lt;/code&gt; returns immediately and the next statement, &lt;code&gt;return result;&lt;/code&gt;, is executed before the function you passed as &lt;code&gt;success&lt;/code&gt; callback was even called.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;Ajax&lt;/a&gt; 의 &lt;strong&gt;A&lt;/strong&gt; 는 &lt;a href=&quot;https://www.merriam-webster.com/dictionary/asynchronous&quot;&gt;&lt;strong&gt;비동기를&lt;/strong&gt;&lt;/a&gt; 나타냅니다. 즉, 요청 전송 (또는 응답 수신)은 정상적인 실행 흐름에서 제외됩니다. 귀하의 예에서 &lt;code&gt;$.ajax&lt;/code&gt; 는 즉시 리턴하고 다음 명령문은 &lt;code&gt;return result;&lt;/code&gt; &lt;code&gt;success&lt;/code&gt; 콜백이 호출 된 후에 전달한 함수 전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="fd66ac85793821d3ff7fcc5fd0246ae36ee7397a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;A&lt;/strong&gt; in AJAX stands for &lt;strong&gt;asynchronous&lt;/strong&gt;. That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29&quot;&gt;&lt;code&gt;.send&lt;/code&gt;&lt;/a&gt; returns immediately and the next statement, &lt;code&gt;return result;&lt;/code&gt;, is executed before the function you passed as &lt;code&gt;success&lt;/code&gt; callback was even called.</source>
          <target state="translated">AJAX의 &lt;strong&gt;A&lt;/strong&gt; 는 &lt;strong&gt;비동기를&lt;/strong&gt; 나타냅니다. 즉, 요청 전송 (또는 응답 수신)은 정상적인 실행 흐름에서 제외됩니다. 예제에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29&quot;&gt; &lt;code&gt;.send&lt;/code&gt; &lt;/a&gt; 는 즉시 리턴하고 다음 명령문은 &lt;code&gt;return result;&lt;/code&gt; &lt;code&gt;success&lt;/code&gt; 콜백이 호출 된 후에 전달한 함수 전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="16490f52af9e1a9f1fc6768f3e186d1abc950e53" translate="yes" xml:space="preserve">
          <source>The ECMAScript version released in 2017 introduced &lt;em&gt;syntax-level support&lt;/em&gt; for asynchronous functions. With the help of &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;, you can write asynchronous in a &quot;synchronous style&quot;. The code is still asynchronous, but it's easier to read/understand.</source>
          <target state="translated">2017 년에 출시 된 ECMAScript 버전에는 비동기 함수에 대한 &lt;em&gt;구문 수준의 지원이&lt;/em&gt; 도입되었습니다. &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; 을 사용하여 &quot;동기식 스타일&quot;로 비동기식을 작성할 수 있습니다. 코드는 여전히 비동기 적이지만 읽기 / 이해하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="ecce31767a1b5e77be58da7962c0d01b010e4473" translate="yes" xml:space="preserve">
          <source>The JavaScript concurrency model in the browser and on the server with NodeJS/io.js is &lt;em&gt;asynchronous&lt;/em&gt; and &lt;em&gt;reactive&lt;/em&gt;.</source>
          <target state="translated">NodeJS / io.js를 사용하는 브라우저 및 서버의 JavaScript 동시성 모델은 &lt;em&gt;비동기식&lt;/em&gt; 이며 &lt;em&gt;반응성이&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca67c883bbbb71564bf5ac5f9cf7f2adffad99d0" translate="yes" xml:space="preserve">
          <source>The advantage over plain callbacks is that they allow you to decouple your code and they are easier to compose.</source>
          <target state="translated">일반 콜백에 비해 장점은 코드를 분리 할 수 ​​있고 작성이 더 쉽다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="480a14931d5a0da5ce02043bf95ba5bba1ea1b46" translate="yes" xml:space="preserve">
          <source>The big question is when will it get the response? The answer is we don't know - so the event loop is waiting for that message to say &quot;hey run me&quot;. If JS just waited around for that message synchronously your app would freeze and it will suck. So JS carries on executing the next item in the queue whilst waiting for the message to get added back to the queue.</source>
          <target state="translated">가장 큰 질문은 언제 응답을 받습니까? 답은 우리가 모른다는 것입니다. 따라서 이벤트 루프는 그 메시지가 &quot;hey run me&quot;라는 메시지를 기다리고 있습니다. JS가 그 메시지를 동 기적으로 기다리면 앱이 멈추고 빨라집니다. 따라서 JS는 메시지가 큐에 다시 추가되기를 기다리는 동안 큐에서 다음 항목을 계속 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ccbf0ca2fcdd4c3a3e86689a782e66920dbfdb25" translate="yes" xml:space="preserve">
          <source>The callback &lt;code&gt;...args&lt;/code&gt; are wrapped in an array and destructured when you read them so that the pattern can cope with callbacks that have multiple arguments. For example with &lt;a href=&quot;https://nodejs.org/api/fs.html&quot;&gt;node fs&lt;/a&gt;:</source>
          <target state="translated">콜백 &lt;code&gt;...args&lt;/code&gt; 는 배열로 래핑되고 읽을 때 패턴이 구조화되어 패턴이 여러 인수가있는 콜백에 대처할 수 있습니다. 예를 들어, &lt;a href=&quot;https://nodejs.org/api/fs.html&quot;&gt;노드 fs&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="77a6ce0e24e45311bbbc8af933b3454cde1bc3ae" translate="yes" xml:space="preserve">
          <source>The callback is set directly (so no extra unnecessary closures).</source>
          <target state="translated">콜백이 직접 설정되므로 불필요한 추가 클로저가 없습니다.</target>
        </trans-unit>
        <trans-unit id="64f9a89935bc0aec8bd8d2c2f2163e48c2e4e0d3" translate="yes" xml:space="preserve">
          <source>The classic JS approach to this problem, taking advantage of the fact that JS supports functions as first-class objects which can be passed around, is to pass a function as a parameter to the asynchronous request, which it will then invoke when it has completed its task sometime in the future. That is the &quot;callback&quot; approach. It looks like this:</source>
          <target state="translated">JS가 전달할 수있는 일급 객체로 함수를 지원한다는 사실을 이용하여이 문제에 대한 고전적인 JS 접근 방식은 함수를 비동기 요청에 매개 변수로 전달하여 완료되면 호출 할 것입니다. 미래의 언젠가는 이것이 &quot;콜백&quot;접근법입니다. 다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="a4b7cb494bc59feaa54149492dcd2fc6736593a6" translate="yes" xml:space="preserve">
          <source>The computer systems we build--more and more--have time as an important dimension. Certain things are set up to happen in the future. Then other things need to happen after those first things eventually occur. This is the basic notion called &quot;asynchronicity&quot;. In our increasingly networked world, the most common case of asynchronicity is waiting for some remote system to respond to some request.</source>
          <target state="translated">점점 더 많은 컴퓨터 시스템은 시간을 중요한 차원으로 가지고 있습니다. 미래에는 어떤 일들이 일어나도록 마련되었습니다. 그런 다음 첫 번째 일이 발생한 후에 다른 일이 발생해야합니다. 이것이 &quot;비동기 성&quot;이라는 기본 개념입니다. 점점 더 네트워크화되는 세상에서 가장 일반적인 비 동시성 사례는 일부 원격 시스템이 일부 요청에 응답하기를 기다리는 것입니다.</target>
        </trans-unit>
        <trans-unit id="68c3c910b7e388c8ca698170706eac7d163f356e" translate="yes" xml:space="preserve">
          <source>The core issue</source>
          <target state="translated">핵심 이슈</target>
        </trans-unit>
        <trans-unit id="edbb0afa295f70fd7b961434a3ea023d105f1de1" translate="yes" xml:space="preserve">
          <source>The following example I have written shows how to</source>
          <target state="translated">내가 작성한 다음 예는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7e2482274ea8174623353a79961f7e409558a384" translate="yes" xml:space="preserve">
          <source>The functions above are for basic use.</source>
          <target state="translated">위의 기능은 기본 용도입니다.</target>
        </trans-unit>
        <trans-unit id="f0b5d408edc15ee4ab49f75c3a45e0e83fe085b1" translate="yes" xml:space="preserve">
          <source>The most perfect answer to this question is using &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">이 질문에 대한 가장 완벽한 대답은 &lt;code&gt;Promise&lt;/code&gt; 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="bc0f50fb62db74196eb462d4435dbc048d27bedc" translate="yes" xml:space="preserve">
          <source>The problem with this callback approach is that it pollutes the normal semantics of a function reporting its result with &lt;code&gt;return&lt;/code&gt;; instead, functions must not reports their results by calling a callback given as a parameter. Also, this approach can rapidly become unwieldy when dealing with longer sequences of events. For example, let's say that I want to wait for the milk to be put in the coffee, and then and only then perform a third step, namely drinking the coffee. I end up needing to write something like this:</source>
          <target state="translated">이 콜백 접근 방식의 문제점은 함수의 결과를 &lt;code&gt;return&lt;/code&gt; 보고하는 일반적인 의미를 오염 시킨다는 것입니다. 대신 함수는 매개 변수로 제공된 콜백을 호출하여 결과를보고해서는 안됩니다. 또한이 방법은 더 긴 일련의 이벤트를 처리 할 때 신속하게 다루기 어려워 질 수 있습니다. 예를 들어, 우유가 커피에 담길 때까지 기다렸다가 커피를 마시는 세 번째 단계 만 수행한다고 가정 해 봅시다. 결국 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="32dd7ece0413b20c7f6465adba94961d1fd0156b" translate="yes" xml:space="preserve">
          <source>The question was:</source>
          <target state="translated">문제는 :</target>
        </trans-unit>
        <trans-unit id="9865311a25d22afa6e2a491b6a5b84a1c39aeb10" translate="yes" xml:space="preserve">
          <source>The reason that doesn't work is that the callbacks from &lt;code&gt;doSomethingAsync&lt;/code&gt; haven't run yet by the time you're trying to use the results.</source>
          <target state="translated">작동하지 않는 이유는 결과를 사용하려고 할 때까지 &lt;code&gt;doSomethingAsync&lt;/code&gt; 의 콜백이 아직 실행되지 않았기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a2739b5dbb10ebfc12b5d81d5d32fb7cd061a55e" translate="yes" xml:space="preserve">
          <source>The same is happening when you make a function call containing &quot;normal&quot; code:</source>
          <target state="translated">&quot;정상&quot;코드를 포함하는 함수를 호출 할 때도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="98c7c4ba758c9126f0cfa1f1637747d0674ee4fd" translate="yes" xml:space="preserve">
          <source>The simplest solution is create a JavaScript function and call it for the Ajax &lt;code&gt;success&lt;/code&gt; callback.</source>
          <target state="translated">가장 간단한 해결책은 JavaScript 함수를 작성하여 Ajax &lt;code&gt;success&lt;/code&gt; 콜백을 위해 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d2b25517bf2d94a474aa03573586b145df347ce" translate="yes" xml:space="preserve">
          <source>The simplest:</source>
          <target state="translated">가장 간단한 :</target>
        </trans-unit>
        <trans-unit id="6fe5eb2395efd41f10b91e16726041602d6e3143" translate="yes" xml:space="preserve">
          <source>The solution will be to avoid callbacks, and use a combination of &lt;strong&gt;Promises&lt;/strong&gt; and &lt;strong&gt;async/await&lt;/strong&gt;.</source>
          <target state="translated">해결책은 콜백을 피하고 &lt;strong&gt;약속&lt;/strong&gt; 과 &lt;strong&gt;async / await&lt;/strong&gt; 의 조합을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9dec62eb819ee8ace8aad60238eecf9a7f4fb514" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a&lt;/code&gt; returned is &lt;code&gt;undefined&lt;/code&gt; since the &lt;code&gt;a=5&lt;/code&gt; part has not executed yet. AJAX acts like this, you're returning the value before the server got the chance to tell your browser what that value is.</source>
          <target state="translated">&lt;code&gt;a=5&lt;/code&gt; 부분이 아직 실행되지 않았으므로 리턴 된 값은 &lt;code&gt;undefined&lt;/code&gt; 않습니다. AJAX는 이와 같이 작동하므로 서버가 브라우저에 해당 값이 무엇인지 알려주기 전에 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d1a490aef5366b80c665df9adb0416c82e381c5" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; since the &lt;code&gt;data = 5&lt;/code&gt; part has not executed yet. It will likely execute in a second but by that time it is irrelevant to the returned value.</source>
          <target state="translated">&lt;code&gt;data = 5&lt;/code&gt; 부분이 아직 실행되지 않았으므로 &lt;code&gt;data&lt;/code&gt; 값이 &lt;code&gt;undefined&lt;/code&gt; 않았습니다. 아마도 1 초 안에 실행될 것이지만, 그때까지는 반환 값과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="587b206c7db5b969cdb5a40887824aa9c5099e73" translate="yes" xml:space="preserve">
          <source>There are basically two ways how to solve this:</source>
          <target state="translated">이것을 해결하는 방법에는 기본적으로 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf0b130ac11e32c400e435be4fa43654576f982" translate="yes" xml:space="preserve">
          <source>There are some other situations which I don't remember that make the XMLHttpRequest 1 annoying.</source>
          <target state="translated">내가 기억하지 못하는 다른 상황이 있는데 XMLHttpRequest 1을 성가 시게 만든다.</target>
        </trans-unit>
        <trans-unit id="dd643d6829dc9f26a331e2bce21e4a3e98d834bc" translate="yes" xml:space="preserve">
          <source>There are three things you need to be aware of; &lt;strong&gt;The queue; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop&quot;&gt;the event loop&lt;/a&gt; and the stack&lt;/strong&gt;</source>
          <target state="translated">알아야 할 세 가지가 있습니다. &lt;strong&gt;대기열;&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop&quot;&gt;이벤트 루프&lt;/a&gt; 와 스택&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4498030a163e78ec8715dffc1c0ce5911aba4b0c" translate="yes" xml:space="preserve">
          <source>There are two ways to get the response of this Ajax call (three using the XMLHttpRequest var name):</source>
          <target state="translated">이 Ajax 호출에 대한 응답을 얻는 두 가지 방법이 있습니다 (XMLHttpRequest var 이름을 사용하는 세 가지).</target>
        </trans-unit>
        <trans-unit id="37cfc454d35f84e510806797d964ad848a95604e" translate="yes" xml:space="preserve">
          <source>There is a problem with using promises!</source>
          <target state="translated">약속 사용에 문제가 있습니다!</target>
        </trans-unit>
        <trans-unit id="7d46baf54c6d620b802f531b3e92d3841965a2a5" translate="yes" xml:space="preserve">
          <source>There is no other way to do this in a non-asynchronous way. (Yeah, with setTimeout loop... but seriously?)</source>
          <target state="translated">비동기 방식으로이를 수행하는 다른 방법은 없습니다. (예, setTimeout 루프가 있지만 심각합니까?)</target>
        </trans-unit>
        <trans-unit id="8511f0c06778d891bba10da5d78a325fa162981f" translate="yes" xml:space="preserve">
          <source>There is only the &lt;code&gt;this.type&lt;/code&gt; which is set to error.</source>
          <target state="translated">error.로 설정된 &lt;code&gt;this.type&lt;/code&gt; 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="c974cb400663a76c12df4912d445ea3637c72efb" translate="yes" xml:space="preserve">
          <source>This code misunderstands the above asynchrony issues. Specifically, &lt;code&gt;$.ajax()&lt;/code&gt; doesn't freeze the code while it checks the '/password' page on your server - it sends a request to the server and while it waits, it immediately returns a jQuery Ajax Deferred object, not the response from the server. That means the &lt;code&gt;if&lt;/code&gt; statement is going to always get this Deferred object, treat it as &lt;code&gt;true&lt;/code&gt;, and proceed as though the user is logged in. Not good.</source>
          <target state="translated">이 코드는 위의 비동기 문제를 오해합니다. 특히 &lt;code&gt;$.ajax()&lt;/code&gt; 는 서버에서 '/ password'페이지를 확인하는 동안 코드를 고정하지 않습니다. 서버에 요청을 보내고 대기하는 동안 응답이 아닌 jQuery Ajax Deferred 객체를 즉시 반환합니다. 서버에서. 즉, &lt;code&gt;if&lt;/code&gt; 문은 항상이 Deferred 객체를 가져 와서 &lt;code&gt;true&lt;/code&gt; 로 취급하고 사용자가 로그인 한 것처럼 진행합니다. 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="244afc8d38402f6d7c12baa9c3d841505fe06988" translate="yes" xml:space="preserve">
          <source>This is a short summary of &quot;Explanation of the problem&quot; from the other answer, if you're not sure after reading this, read that.</source>
          <target state="translated">이것은 다른 답변의 &quot;문제 설명&quot;에 대한 간략한 요약입니다.이를 읽은 후에 확실하지 않으면 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="bec8301fa7c95d68f2971235b818a4ec00cf9186" translate="yes" xml:space="preserve">
          <source>This is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt;. Basically, we're passing &lt;code&gt;getFive&lt;/code&gt; an action to perform when it completes, we're telling our code how to react when an event completes (like our AJAX call, or in this case the timeout).</source>
          <target state="translated">이것을 &lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt; 라고합니다. 기본적으로 &lt;code&gt;getFive&lt;/code&gt; 가 완료 될 때 수행 할 조치를 전달하고 이벤트가 완료 될 때 (AJAX 호출 또는이 경우 시간 종료와 같은) 응답 하는 방법을 코드에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="e37cc018b8dd7866206ff24c3bd04692ca34d6e0" translate="yes" xml:space="preserve">
          <source>This is one of the places which &lt;strong&gt;two ways data binding&lt;/strong&gt; or &lt;strong&gt;store concept&lt;/strong&gt; that's used in many new JavaScript frameworks will work great for you...</source>
          <target state="translated">이것은 많은 새로운 JavaScript 프레임 워크에서 사용되는 &lt;strong&gt;두 가지 데이터 바인딩&lt;/strong&gt; 또는 &lt;strong&gt;저장소 개념&lt;/strong&gt; 이 당신에게 잘 작동하는 장소 중 하나입니다 ...</target>
        </trans-unit>
        <trans-unit id="87baabf09170470e02be100dac74857e2ebc1619" translate="yes" xml:space="preserve">
          <source>This is quite simple:</source>
          <target state="translated">이것은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="95b540890727eecbe058d586198261782083d7c0" translate="yes" xml:space="preserve">
          <source>This means AngularJS, jQuery (with deferred), native XHR's replacement (fetch), EmberJS, BackboneJS's save or any node library that returns promises.</source>
          <target state="translated">이는 AngularJS, jQuery (지연된), 기본 XHR 대체 (페치), EmberJS, BackboneJS의 저장 또는 약속을 반환하는 모든 노드 라이브러리를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b3d9c5469e4b15f9c162fb643af29c9f5ca05645" translate="yes" xml:space="preserve">
          <source>This means when you're returning &lt;code&gt;data&lt;/code&gt; the &lt;code&gt;then&lt;/code&gt; handler you've defined did not execute yet. This in turn means that the value you're returning has not been set to the correct value in time.</source>
          <target state="translated">이는 &lt;code&gt;data&lt;/code&gt; 반환 할 때 정의한 핸들러가 아직 실행되지 않았 음을 의미합니다. 이는 반환하는 값이 올바른 시간 값으로 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f01778d1944777ab6b8f39abe10e8afdd7a72058" translate="yes" xml:space="preserve">
          <source>This means when you're returning, the listener you've defined did not execute yet, which means the value you're returning has not been defined.</source>
          <target state="translated">이것은 반환 할 때 정의한 리스너가 아직 실행되지 않았 음을 의미합니다. 이는 반환하는 값이 정의되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="61ed4646f32a3a1ac23ad5fb1d6851ea5f3992d0" translate="yes" xml:space="preserve">
          <source>This method returns a promise itself, which we can consume from other coroutines. For example:</source>
          <target state="translated">이 메소드는 다른 코 루틴에서 사용할 수있는 promise 자체를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d9e63f07d1d652a68998572e1a51ce636590916" translate="yes" xml:space="preserve">
          <source>This somewhat tricky but very powerful trick lets us write asynchronous code in a synchronous manner. There are several &quot;runners&quot; that do this for you, writing one is a short few lines of code but is beyond the scope of this answer. I'll be using Bluebird's &lt;code&gt;Promise.coroutine&lt;/code&gt; here, but there are other wrappers like &lt;code&gt;co&lt;/code&gt; or &lt;code&gt;Q.async&lt;/code&gt;.</source>
          <target state="translated">다소 까다 롭지 만 강력한 트릭으로 비동기 코드를 동기 방식으로 작성할 수 있습니다. 이 작업을 수행하는 몇 가지 &quot;실행자&quot;가 있습니다. 하나를 작성하는 것은 몇 줄의 코드이지만이 답변의 범위를 벗어납니다. 여기서는 Bluebird의 &lt;code&gt;Promise.coroutine&lt;/code&gt; 을 사용하지만 &lt;code&gt;co&lt;/code&gt; 또는 &lt;code&gt;Q.async&lt;/code&gt; 와 같은 다른 래퍼가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7419d91a7773bb18e95de8945a17e396a7138932" translate="yes" xml:space="preserve">
          <source>This stands the same for your original API call, you can:</source>
          <target state="translated">이것은 원래 API 호출과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b4c2a28333fa2716b1c47a4f0a2e18a4d80475ff" translate="yes" xml:space="preserve">
          <source>This was the motivation for the notion of a &quot;promise&quot;, which is a particular type of value which represents a &lt;strong&gt;future&lt;/strong&gt; or &lt;strong&gt;asynchronous&lt;/strong&gt; outcome of some sort. It can represent something that already happened, or that is going to happen in the future, or might never happen at all. Promises have a single method, named &lt;code&gt;then&lt;/code&gt;, to which you pass an action to be executed when the outcome the promise represents has been realized.</source>
          <target state="translated">이것은 &quot;약속&quot;이라는 개념에 대한 동기였습니다. 이것은 일종의 &lt;strong&gt;미래&lt;/strong&gt; 또는 &lt;strong&gt;비동기&lt;/strong&gt; 결과를 나타내는 특정 유형의 가치입니다. 이미 일어난 일이나 미래에 일어날 일이거나 전혀 일어날 일이없는 것을 나타낼 수 있습니다. 약속에는 &lt;code&gt;then&lt;/code&gt; 이라는 단일 메소드가 있으며, 약속이 나타내는 결과가 실현 될 때 실행할 조치를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c88099e25e362faf93b5c34442314fc0efbfd023" translate="yes" xml:space="preserve">
          <source>This working example is self-contained. It will define a simple request object that uses the window &lt;code&gt;XMLHttpRequest&lt;/code&gt; object to make calls. It will define a simple function to wait for a bunch of promises to be completed.</source>
          <target state="translated">이 작업 예제는 독립적입니다. 창 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 객체를 사용하여 호출하는 간단한 요청 객체를 정의합니다. 많은 약속이 완료되기를 기다리는 간단한 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="bb4a902028592cca405a4e54f7447a6dd933acce" translate="yes" xml:space="preserve">
          <source>Thus Solution to this is &lt;em&gt;callback&lt;/em&gt; or &lt;em&gt;promise&lt;/em&gt;.</source>
          <target state="translated">따라서 이것에 대한 해결책은 &lt;em&gt;콜백&lt;/em&gt; 또는 &lt;em&gt;약속&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a4ac77e33ad1dc33272e4765092ee238e7b4067" translate="yes" xml:space="preserve">
          <source>Thus, the summary is - to tackle the asynchronous functions like ajax based calls etc., you can use a promise to &lt;code&gt;resolve&lt;/code&gt; the value (which you intend to return). Thus, in short you &lt;strong&gt;resolve&lt;/strong&gt; value instead of &lt;strong&gt;returning&lt;/strong&gt;, in asynchronous functions.</source>
          <target state="translated">따라서 요약은-아약스 기반 호출 등과 같은 비동기 함수를 &lt;code&gt;resolve&lt;/code&gt; 하기 위해 약속을 사용하여 값을 반환 할 수 있습니다 (반환하려는). 따라서 간단히 말하면 비동기 함수 &lt;strong&gt;에서을 반환하는&lt;/strong&gt; 대신 값을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a0a2dcdf916f3c7cf3b91ae00bbe537935bc5316" translate="yes" xml:space="preserve">
          <source>To run the above code you do this:</source>
          <target state="translated">위의 코드를 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2e8f0671297e82a3357b05f76d4c39dd6732c8f7" translate="yes" xml:space="preserve">
          <source>UPDATE (Promises with async/await)</source>
          <target state="translated">업데이트 (비동기 / 대기 약속)</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e3b2c87fbdfa81069562e3801f3b834f583f3068" translate="yes" xml:space="preserve">
          <source>Usage would be:</source>
          <target state="translated">사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ba1f4e931dcc6adc1af6d22a6e4e7abed5a85b2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt; pattern to join multiple HTTP calls;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt; 패턴을 사용하여 여러 HTTP 호출에 참여하십시오.</target>
        </trans-unit>
        <trans-unit id="e698b02ca0c7b2228f7ccbc8c4b111e743e10e2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;Promise&lt;/a&gt; pattern;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;약속&lt;/a&gt; 패턴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0e9a58ba6887bb7e51147aa2da4a49a0486ce969" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;callback()&lt;/code&gt; function inside the &lt;code&gt;foo()&lt;/code&gt; success.
Try in this way. It is simple and easy to understand. &amp;nbsp;</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; 성공 안에서 &lt;code&gt;callback()&lt;/code&gt; 함수를 사용하십시오. 이런 식으로 시도하십시오. 간단하고 이해하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="606944b24d98d72b39627fdefe858efa8d964a89" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;'await'&lt;/a&gt;, which will tell JavaScript to await the promise to be resolved into a value (like the HTTP response)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;'await'을&lt;/a&gt; 사용하면 JavaScript가 HTTP 응답과 같은 값으로 해결 될 약속을 기다리도록 JavaScript에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="a11fcc742eebbcfca3c5bb6597892f401f073e0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;strong&gt;asynchronous&lt;/strong&gt; code as if it were &lt;strong&gt;synchronous&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;비동기&lt;/strong&gt; 코드를 &lt;strong&gt;동기적인&lt;/strong&gt; 것처럼 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50df00102216ee2fa6b8d3f60a71c04beba81fe1" translate="yes" xml:space="preserve">
          <source>Using ES2017 you should have this as the function declaration</source>
          <target state="translated">ES2017을 사용하면 이것을 함수 선언으로해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc12d7b012ca1bfa32bf1aa97b798db2031c84f8" translate="yes" xml:space="preserve">
          <source>Using Promise</source>
          <target state="translated">약속 사용</target>
        </trans-unit>
        <trans-unit id="28685eec146d7abeed631f689f722a157cd3cd31" translate="yes" xml:space="preserve">
          <source>Using callback concept - As implementation in first answer</source>
          <target state="translated">콜백 개념 사용-첫 번째 답변의 구현으로</target>
        </trans-unit>
        <trans-unit id="c787b69b8c1dad213e2bced9dc421d4fbabcda2a" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;XMLHttpRequest&lt;/code&gt; variable name is another big error as you need to execute the callback inside the onload/oreadystatechange closures else you lost it.</source>
          <target state="translated">&lt;code&gt;XMLHttpRequest&lt;/code&gt; 변수 이름을 사용하는 것은 onload / oreadystatechange 클로저 내에서 콜백을 실행해야하므로 손실되는 또 다른 큰 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b7ce43e50f1c7276c7fa06bbf7c04a9872a17966" translate="yes" xml:space="preserve">
          <source>Wait for response from each API call;</source>
          <target state="translated">각 API 호출의 응답을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="35c239d949f8723db6cf2fca7425f52803d0c967" translate="yes" xml:space="preserve">
          <source>We find ourselves in a universe which appears to progress along a dimension we call &quot;time&quot;. We don't really understand what time is, but we have developed abstractions and vocabulary that let us reason and talk about it: &quot;past&quot;, &quot;present&quot;, &quot;future&quot;, &quot;before&quot;, &quot;after&quot;.</source>
          <target state="translated">우리는 우리가 &quot;시간&quot;이라고 부르는 차원을 따라 진보하는 것처럼 보이는 우주에서 자신을 발견합니다. 우리는 시간이 무엇인지 실제로 이해하지 못하지만, 우리는 &quot;과거&quot;, &quot;현재&quot;, &quot;미래&quot;, &quot;전&quot;, &quot;후&quot;와 같이 추론하고 그것에 대해 이야기 할 수있는 추상화와 어휘를 개발했습니다.</target>
        </trans-unit>
        <trans-unit id="cf190ebdec93ca0293df429352a161bff1aed4e0" translate="yes" xml:space="preserve">
          <source>We have now made our foo function accept an action to run when the AJAX completes successfully, we can extend this further by checking if the response status is not 200 and acting accordingly (create a fail handler and such). Effectively solving our issue.</source>
          <target state="translated">이제 우리는 foo 함수가 AJAX가 성공적으로 완료 될 때 실행할 동작을 받아들이도록 만들었습니다. 응답 상태가 200이 아닌지 확인하고 그에 따라 행동하여 (실패 핸들러 등 생성)이를 확장 할 수 있습니다. 효과적으로 우리의 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="ac71c9a45e5e5d552a308fe3128d89db33f20f8b" translate="yes" xml:space="preserve">
          <source>What you're facing</source>
          <target state="translated">당신이 직면하고있는 것</target>
        </trans-unit>
        <trans-unit id="d9e7e738a86ea5326f809837e5b5ea81f305f671" translate="yes" xml:space="preserve">
          <source>When one of these messages is going to execute it pops the message from the queue and creates a stack, the stack is everything JS needs to execute to perform the instruction in the message. So in our example it's being told to call &lt;code&gt;foobarFunc&lt;/code&gt;</source>
          <target state="translated">이러한 메시지 중 하나가 실행될 때 큐에서 메시지를 팝하고 스택을 생성하면 스택은 JS가 메시지에서 명령을 수행하기 위해 실행해야하는 모든 것입니다. 이 예에서는 &lt;code&gt;foobarFunc&lt;/code&gt; 를 호출 하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="46e5db5a04236061d5766214e29fc62f17454cbf" translate="yes" xml:space="preserve">
          <source>When using promises, we end up passing lots of functions into &lt;code&gt;then&lt;/code&gt;, so it's often helpful to use the more compact ES6-style arrow functions:</source>
          <target state="translated">약속을 사용할 때 많은 함수를 &lt;code&gt;then&lt;/code&gt; 에 전달하면 더 컴팩트 한 ES6 스타일 화살표 함수를 사용하는 것이 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b23496e842dceff9fb3a521cbe84a712262e3f34" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;.then&lt;/code&gt; on a promise and &lt;em&gt;return&lt;/em&gt; something from it - we get a promise for &lt;em&gt;the processed value&lt;/em&gt;. If we return another promise we'll get amazing things, but let's hold our horses.</source>
          <target state="translated">우리가 약속을 부르고 약속에서 무언가를 &lt;em&gt;돌려&lt;/em&gt; 주면, 우리 &lt;em&gt;는 가공 된 가치에&lt;/em&gt; 대한 약속을 얻습니다. 우리가 다른 약속을 돌려 주면 놀라운 일을하게되지만 말을 붙잡아 봅시다.</target>
        </trans-unit>
        <trans-unit id="d987b91f60f98a1b758f0e53d90290815d18964e" translate="yes" xml:space="preserve">
          <source>When you make a call using AJAX to an external party or run any asynchronous code (a setTimeout for example), Javascript is dependant upon a response before it can proceed.</source>
          <target state="translated">AJAX를 사용하여 외부 상대방에게 전화를 걸거나 비동기 코드 (예 : setTimeout)를 실행하면 Javascript는 응답에 의존하여 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="380b904db5976f20d5318f6cc1191c770d1da13f" translate="yes" xml:space="preserve">
          <source>Whenever you call a method that returns a promise, the &lt;code&gt;then&lt;/code&gt; handlers are &lt;em&gt;always&lt;/em&gt; executed asynchronously - that is, &lt;strong&gt;after&lt;/strong&gt; the code below them that is not in a &lt;code&gt;.then&lt;/code&gt; handler.</source>
          <target state="translated">약속을 반환하는 메서드를 호출 할 때마다 처리기는 &lt;em&gt;항상&lt;/em&gt; 비동기 적으로 실행됩니다. 즉, &lt;strong&gt;그&lt;/strong&gt; 아래의 코드 다음에 &lt;code&gt;.then&lt;/code&gt; 처리기에 없습니다.</target>
        </trans-unit>
        <trans-unit id="42feb8ea413f33209ece4d328587c570e4d54ebe" translate="yes" xml:space="preserve">
          <source>Which should alert &quot;5&quot; to the screen. &lt;a href=&quot;http://jsfiddle.net/PAjZR/&quot;&gt;(Fiddle)&lt;/a&gt;.</source>
          <target state="translated">화면에 &quot;5&quot;가 표시되어야합니다. &lt;a href=&quot;http://jsfiddle.net/PAjZR/&quot;&gt;(바이올린)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec5557762b5410ae1ddd3eb2b67bfdb2da22a4ce" translate="yes" xml:space="preserve">
          <source>While it is &lt;em&gt;okay&lt;/em&gt; in small examples it gets annoying when you have a lot of similar cases and error handling involved.</source>
          <target state="translated">작은 예제에서는 &lt;em&gt;괜찮지 만&lt;/em&gt; 비슷한 경우와 오류 처리가 많은 경우 짜증이납니다.</target>
        </trans-unit>
        <trans-unit id="1450bd8677cf37b475780df43411df3cca8f006a" translate="yes" xml:space="preserve">
          <source>While promises and callbacks work fine in many situations, it is a pain in the rear to express something like:</source>
          <target state="translated">많은 상황에서 약속과 콜백이 잘 작동하지만 다음과 같은 것을 표현하는 것은 고통 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="448c4cc13812bccdb5367397d714ad86dd6ea552" translate="yes" xml:space="preserve">
          <source>Why add an error handler if you totally have no control over errors?
Most of the errors are returned inside this in the callback function &lt;code&gt;displayAjax()&lt;/code&gt;.</source>
          <target state="translated">오류를 완전히 제어 할 수없는 경우 왜 오류 처리기를 추가합니까? 콜백 함수 &lt;code&gt;displayAjax()&lt;/code&gt; 에서 대부분의 오류가이 안에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5edfc082aa90912642ae681f74a76ece5088c8fa" translate="yes" xml:space="preserve">
          <source>Why is it bad do you ask?</source>
          <target state="translated">왜 나쁜가요?</target>
        </trans-unit>
        <trans-unit id="1229758f7e8ec3a149e87560402cc78e508a43de" translate="yes" xml:space="preserve">
          <source>Why should we use our own custom Promise?</source>
          <target state="translated">우리는 왜 우리 자신의 맞춤형 약속을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="ece375bff4b483047da3749860748c38927e530d" translate="yes" xml:space="preserve">
          <source>With promises</source>
          <target state="translated">약속으로</target>
        </trans-unit>
        <trans-unit id="0c0a59fb074de0fc1fd7cee2f49870f337cc9102" translate="yes" xml:space="preserve">
          <source>Without jQuery</source>
          <target state="translated">jQuery없이</target>
        </trans-unit>
        <trans-unit id="b5fea0abea018388c5315d97c39b4081a7cb703a" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest API</source>
          <target state="translated">XMLHttpRequest API</target>
        </trans-unit>
        <trans-unit id="e73644d1d710900fb613359a5f23e329c06b46fe" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest supports both synchronous and asynchronous communications. In general, however, asynchronous requests should be preferred to synchronous requests for performance reasons.</source>
          <target state="translated">XMLHttpRequest는 동기 및 비동기 통신을 모두 지원합니다. 그러나 일반적으로 성능상의 이유로 비동기 요청이 동기 요청보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="b9b7f311a0fbfaead32e2e31dba1d379c239df35" translate="yes" xml:space="preserve">
          <source>Yes, you can.</source>
          <target state="translated">그래 넌 할수있어.</target>
        </trans-unit>
        <trans-unit id="83fb6a0fad9feb9e391f4aec4d78ee5495226649" translate="yes" xml:space="preserve">
          <source>You are using Ajax incorrectly. The idea is not to have it return anything, but instead hand off the data to something called a callback function, which handles the data.</source>
          <target state="translated">Ajax를 잘못 사용하고 있습니다. 아이디어는 아무것도 반환하지 않고 대신 데이터를 처리하는 콜백 함수라고하는 데이터를 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f394fee622b97599e0a31a6f0f4cd4cc68870f7c" translate="yes" xml:space="preserve">
          <source>You call your friend again for the same reason. But this time you tell him that you are in a hurry and he should &lt;em&gt;call you back&lt;/em&gt; on your mobile phone. You hang up, leave the house and do whatever you planned to do. Once your friend calls you back, you are dealing with the information he gave to you.</source>
          <target state="translated">같은 이유로 친구에게 다시 전화하십시오. 그러나 이번에는 당신이 그에게 당신이 서두르고 있다고 말하면 휴대 전화로 &lt;em&gt;다시 전화&lt;/em&gt; 해야합니다. 당신은 전화를 끊고 집을 떠나고 당신이 계획 한 일을합니다. 친구가 당신에게 전화하면, 당신은 그가 당신에게 준 정보를 다루고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2bd21947364482b0aca338a6b437d78f80037e7" translate="yes" xml:space="preserve">
          <source>You can also process the response before passing it to the callback:</source>
          <target state="translated">콜백에 전달하기 전에 응답을 처리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3beb8e59419ebd09fc9891e40ffa62d7e41da4e2" translate="yes" xml:space="preserve">
          <source>You can checkout the project &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;여기&lt;/a&gt; 에서 프로젝트를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a399a6f3ef2aa4bf612fdbeaabb5190ec6b5790" translate="yes" xml:space="preserve">
          <source>You can consume that in this way,</source>
          <target state="translated">이런 식으로 소비 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0c470949a5de51b9f217c1f0fc0cf12e324c19e0" translate="yes" xml:space="preserve">
          <source>You can find a nice explanation &lt;a href=&quot;http://andyshora.com/promises-angularjs-explained-as-cartoon.html&quot;&gt;here&lt;/a&gt; also.</source>
          <target state="translated">&lt;a href=&quot;http://andyshora.com/promises-angularjs-explained-as-cartoon.html&quot;&gt;여기서도&lt;/a&gt; 좋은 설명을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a480682174de8f801e99da50379e04d8ac8ac06" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; on MDN.</source>
          <target state="translated">MDN에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; 에 대한 자세한 내용을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca259db921dc5475dee1f9c068034b544e83ec7f" translate="yes" xml:space="preserve">
          <source>You can start all of them and keep track of how many callbacks you're expecting, and then use the results when you've gotten that many callbacks:</source>
          <target state="translated">콜백을 모두 시작하고 예상되는 콜백 수를 추적 한 다음 콜백이 많을 때 결과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f65b8b36a713a1b70d47398be1c721ed3fffd5" translate="yes" xml:space="preserve">
          <source>You can then see a nested Promise structure, that lets you spawn multiple and completely asynchronous nested HTTP calls, and join the results from each subset of calls through &lt;code&gt;Promise.all&lt;/code&gt;.</source>
          <target state="translated">그런 다음 중첩 된 Promise 구조를 볼 수 있습니다.이를 통해 여러 개의 완전히 비동기식 중첩 된 HTTP 호출을 생성하고 &lt;code&gt;Promise.all&lt;/code&gt; 을 통해 각 호출의 서브 세트 결과에 참여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5637817dac7360e2bf1c7c2d1626c7be889d259e" translate="yes" xml:space="preserve">
          <source>You can use a &lt;strong&gt;callback&lt;/strong&gt;, &lt;strong&gt;promise&lt;/strong&gt; and recently &lt;strong&gt;observable&lt;/strong&gt; to handle it for you, for example in promises we have some function like &lt;code&gt;success()&lt;/code&gt; or &lt;code&gt;then()&lt;/code&gt; which will be executed when your data is ready for you, same with callback or &lt;strong&gt;subscribe&lt;/strong&gt; function on &lt;strong&gt;observable&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;콜백&lt;/strong&gt; , &lt;strong&gt;promise&lt;/strong&gt; 및 최근에 &lt;strong&gt;관찰 가능한&lt;/strong&gt; 것을 사용하여 처리 할 수 ​​있습니다. 예를 들어 우리는 &lt;code&gt;success()&lt;/code&gt; 또는 &lt;code&gt;then()&lt;/code&gt; 과 같은 함수가 있다고 약속합니다. 콜백 또는 &lt;strong&gt;구독&lt;/strong&gt; 함수와 마찬가지로 데이터가 준비되면 실행됩니다. &lt;strong&gt;관찰 가능&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3aedc25db58a4804737e831c476a6e6a972dbab8" translate="yes" xml:space="preserve">
          <source>You can use this custom library (written using Promise) to make a remote call.</source>
          <target state="translated">이 사용자 지정 라이브러리 (Promise를 사용하여 작성)를 사용하여 원격으로 전화를 걸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd6628c5f45797d9ea0f78c8fc099d6704e851a0" translate="yes" xml:space="preserve">
          <source>You'd end up going through &lt;code&gt;async1&lt;/code&gt;; check if &lt;code&gt;name&lt;/code&gt; is undefined or not and call the callback accordingly.</source>
          <target state="translated">결국 &lt;code&gt;async1&lt;/code&gt; 을 거치게됩니다 . &lt;code&gt;name&lt;/code&gt; 이 정의되어 있지 않은지 확인하고 그에 따라 콜백을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="bd8715a64e94539f3c8b8df1772b0c03d902cf35" translate="yes" xml:space="preserve">
          <source>Your code should be something along the lines of this:</source>
          <target state="translated">코드는 다음과 같이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="79d239c9d4dd6e9398d601a54d23e6f15a901265" translate="yes" xml:space="preserve">
          <source>async/await version:</source>
          <target state="translated">비동기 / 대기 버전 :</target>
        </trans-unit>
        <trans-unit id="5fa5455b316d09922e2556fd3e7db0992016d6bb" translate="yes" xml:space="preserve">
          <source>await is supported in all current browsers and node 8</source>
          <target state="translated">대기는 모든 현재 브라우저 및 노드 8에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="6cdd908e77bf13956316a9dfb985f596f59e72fe" translate="yes" xml:space="preserve">
          <source>but if &lt;code&gt;a&lt;/code&gt; is asynchronous, with promises we have to write</source>
          <target state="translated">그러나 &lt;code&gt;a&lt;/code&gt; 가 비동기 인 경우 약속을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba1108cd1f24e45036a47d4005ece995c5fe8b5d" translate="yes" xml:space="preserve">
          <source>cross-domain not allowed throws error automatically.</source>
          <target state="translated">도메인 간 허용되지 않으면 오류가 자동으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3691b5c9d0eec5124fbea2e6256064c9e642e83e" translate="yes" xml:space="preserve">
          <source>for instance,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="00853d73f19844948fadbc48d500f997c46f7ee4" translate="yes" xml:space="preserve">
          <source>jQuery</source>
          <target state="translated">jQuery</target>
        </trans-unit>
        <trans-unit id="c6ba4cdd11e1a3db37a54109474e9c73534b938a" translate="yes" xml:space="preserve">
          <source>jQuery deferred</source>
          <target state="translated">jQuery 연기</target>
        </trans-unit>
        <trans-unit id="fba0ae53da33f0cd5e54603774b1229ca748fbd7" translate="yes" xml:space="preserve">
          <source>nsynjs will evaluate all promises sequentially, and put promise result into &lt;code&gt;data&lt;/code&gt; property:</source>
          <target state="translated">nsynjs는 모든 약속을 순차적으로 평가하고 약속 결과를 &lt;code&gt;data&lt;/code&gt; 속성에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="e1a5e2d288843cc0d03987443a6fc38bffe1ef80" translate="yes" xml:space="preserve">
          <source>onreadystatechange is only useful if you want to get the headers on state 2.</source>
          <target state="translated">onreadystatechange는 상태 2에서 헤더를 가져 오려는 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0458efd542acc1a7aebda8d34461df3c13d76b38" translate="yes" xml:space="preserve">
          <source>so most of the time (but not always) you'll pass &lt;code&gt;foo&lt;/code&gt; not &lt;code&gt;foo()&lt;/code&gt;</source>
          <target state="translated">그래서 대부분의 경우 (항상 그런 것은 아님) &lt;code&gt;foo&lt;/code&gt; not &lt;code&gt;foo()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88018d8629c033501aa21a3ab6e24d7aebd65b57" translate="yes" xml:space="preserve">
          <source>then/catch version:</source>
          <target state="translated">그런 다음 / 캐치 버전 :</target>
        </trans-unit>
        <trans-unit id="3aee67424c6f45abebfaef894361e9c0e7ddd958" translate="yes" xml:space="preserve">
          <source>where I am passing to &lt;code&gt;put_in_coffee&lt;/code&gt; both the milk to put in it, and also the action (&lt;code&gt;drink_coffee&lt;/code&gt;) to execute once the milk has been put in. Such code becomes hard to write, and read, and debug.</source>
          <target state="translated">여기에 우유를 넣을 때 &lt;code&gt;put_in_coffee&lt;/code&gt; 와 우유를 넣은 후에 실행할 액션 ( &lt;code&gt;drink_coffee&lt;/code&gt; )을 전달합니다. 이러한 코드를 작성하고 읽고 디버깅하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="a861995ce1d879a17b5c91a26cf0e7eb75c29caf" translate="yes" xml:space="preserve">
          <source>which CAN be interpreted as:</source>
          <target state="translated">다음과 같이 해석 될 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
