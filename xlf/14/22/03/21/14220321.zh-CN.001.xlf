<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/14220321">
    <body>
      <group id="14220321">
        <trans-unit id="927d598b66027a146baa1781e637b904c6aa330f" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://stackoverflow.com/a/30180679/1348195&quot;&gt;Note, for those using the new &lt;code&gt;fetch&lt;/code&gt; API, Angular or promises I've added another answer below&lt;/a&gt;)</source>
          <target state="translated">（ &lt;a href=&quot;https://stackoverflow.com/a/30180679/1348195&quot;&gt;请注意，对于那些使用新的 &lt;code&gt;fetch&lt;/code&gt; API，Angular或Promise的人，我在下面添加了另一个答案&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="99f4d532491d1864e1be89ab9b7b1d7432912746" translate="yes" xml:space="preserve">
          <source>(Although it can be written in Javascript, I prefer to write it in Python, and compile it to Javascript using &lt;a href=&quot;https://github.com/QQuick/Transcrypt&quot;&gt;Transcrypt&lt;/a&gt;. It will be clear enough.)</source>
          <target state="translated">（尽管它可以用Javascript编写，但我更喜欢用Python编写，然后使用&lt;a href=&quot;https://github.com/QQuick/Transcrypt&quot;&gt;Transcrypt&lt;/a&gt;将其编译为Javascript。这已经足够清楚了。）</target>
        </trans-unit>
        <trans-unit id="5bdb200d65235570c1b58c9e91da7f158c793d35" translate="yes" xml:space="preserve">
          <source>(Fiddle)</source>
          <target state="translated">(Fiddle)</target>
        </trans-unit>
        <trans-unit id="5db09589cf8459f3d38f5553fbde8bce31d35a4c" translate="yes" xml:space="preserve">
          <source>(fiddle)</source>
          <target state="translated">(fiddle)</target>
        </trans-unit>
        <trans-unit id="7766903fe90c705c4ed71e3573241c83b2c69193" translate="yes" xml:space="preserve">
          <source>...which is less cumbersome with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015+ arrow functions&lt;/a&gt;:</source>
          <target state="translated">...使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015 +箭头功能&lt;/a&gt;不太麻烦：</target>
        </trans-unit>
        <trans-unit id="f927aed5b9c420c5e6e8550a2e4521837fcb377c" translate="yes" xml:space="preserve">
          <source>1)Event Loop</source>
          <target state="translated">1)事件循环</target>
        </trans-unit>
        <trans-unit id="0742a4064775d4cda76aa61598d18d11036418f9" translate="yes" xml:space="preserve">
          <source>1. Synchronous AJAX - Don't do it!!</source>
          <target state="translated">1.同步AJAX----不要做!</target>
        </trans-unit>
        <trans-unit id="f24ae07c22d1eb6bb318aa04f411d2319b454d6c" translate="yes" xml:space="preserve">
          <source>2)Web API</source>
          <target state="translated">2)Web API</target>
        </trans-unit>
        <trans-unit id="f76660e7f2f317741f7b6f9a679f94b6aae6c47e" translate="yes" xml:space="preserve">
          <source>2. Restructure code</source>
          <target state="translated">2.2.改组代码</target>
        </trans-unit>
        <trans-unit id="44d7b3b36c7446cc15b0aafbdc4f232450505779" translate="yes" xml:space="preserve">
          <source>2017 answer: you can now do exactly what you want in every current browser and node</source>
          <target state="translated">2017年答案:你现在可以在当前的每一个浏览器和节点上都能做到你想做的事情了。</target>
        </trans-unit>
        <trans-unit id="0d76585d726fac5212bc15c005d34dc57ae870eb" translate="yes" xml:space="preserve">
          <source>3)Event Queue</source>
          <target state="translated">3)事件队列</target>
        </trans-unit>
        <trans-unit id="68333d073e4f567370e4ebd9e36d796f8c754911" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/&quot;&gt;Here&lt;/a&gt; it says,</source>
          <target state="translated">&lt;a href=&quot;http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/&quot;&gt;在这里&lt;/a&gt;说</target>
        </trans-unit>
        <trans-unit id="d569b34dd010230f2b5736a91066fe31f29056f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; - A promise library for JavaScript</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; -JavaScript的Promise库</target>
        </trans-unit>
        <trans-unit id="8be840693df3eefddf69835e766647c8f3935f38" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/4866721/what-are-deferred-objects&quot;&gt;Deferred objects&lt;/a&gt; are jQuery's custom implementation of promises (before the Promise API was standardized). They behave almost like promises but expose a slightly different API.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4866721/what-are-deferred-objects&quot;&gt;延迟对象&lt;/a&gt;是jQuery的promise的自定义实现（在Promise API标准化之前）。 它们的行为几乎像promise，但是暴露了稍微不同的API。</target>
        </trans-unit>
        <trans-unit id="3c3877fa4d4bea86aa540d1d00c51cba27671903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fibers&lt;/code&gt; helps in solving the issue.</source>
          <target state="translated">&lt;code&gt;Fibers&lt;/code&gt; 有助于解决问题。</target>
        </trans-unit>
        <trans-unit id="d4de38eeff0914f72435ab92aacf70919fd4db58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async/await&lt;/code&gt; builds on top of promises: an &lt;code&gt;async&lt;/code&gt; function always returns a promise. &lt;code&gt;await&lt;/code&gt; &quot;unwraps&quot; a promise and either result in the value the promise was resolved with or throws an error if the promise was rejected.</source>
          <target state="translated">&lt;code&gt;async/await&lt;/code&gt; 建立在promise之上： &lt;code&gt;async&lt;/code&gt; 函数总是返回promise。 &lt;code&gt;await&lt;/code&gt; &amp;ldquo;解开&amp;rdquo;承诺，并导致承诺被解决的价值，或者如果承诺被拒绝，则抛出错误。</target>
        </trans-unit>
        <trans-unit id="472c34ad7218489081303afcad61fe244feeb0fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt; will refer to the function we pass to &lt;code&gt;foo&lt;/code&gt; when we call it and we simply pass it on to &lt;code&gt;success&lt;/code&gt;. I.e. once the Ajax request is successful, &lt;code&gt;$.ajax&lt;/code&gt; will call &lt;code&gt;callback&lt;/code&gt; and pass the response to the callback (which can be referred to with &lt;code&gt;result&lt;/code&gt;, since this is how we defined the callback).</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; 函数将引用当我们调用它时传递给 &lt;code&gt;foo&lt;/code&gt; 的函数，而只是将其传递给 &lt;code&gt;success&lt;/code&gt; 。 即，一旦Ajax请求成功， &lt;code&gt;$.ajax&lt;/code&gt; 将调用 &lt;code&gt;callback&lt;/code&gt; 并将响应传递给回调（可以用 &lt;code&gt;result&lt;/code&gt; 引用，因为这是我们定义回调的方式）。</target>
        </trans-unit>
        <trans-unit id="0cdc633c16019e6c8b41e52704499a8c4fdbc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo&lt;/code&gt; itself is defined as follows:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 本身的定义如下：</target>
        </trans-unit>
        <trans-unit id="5bc50c14ccc34523a427f339d4f6b0d89980a4cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order_milk&lt;/code&gt; kicks off, orders the milk, then, when and only when it arrives, it invokes &lt;code&gt;put_in_coffee&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;order_milk&lt;/code&gt; 开始，订购牛奶，然后仅在牛奶到达时才调用 &lt;code&gt;put_in_coffee&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5486986e826b7ca20e7b32edb333416cf0cafa81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;rarr; For a more general explanation of async behaviour with different examples, please see&lt;/em&gt;&lt;a href=&quot;https://stackoverflow.com/q/23667086/218196&quot;&gt;Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;&amp;rarr;有关使用不同示例的异步行为的更一般说明，请参见&lt;/em&gt; &lt;a href=&quot;https://stackoverflow.com/q/23667086/218196&quot;&gt;在函数内部修改变量后&lt;/a&gt; &lt;em&gt;，&lt;/em&gt; 为什么变量未更改？ -异步代码参考</target>
        </trans-unit>
        <trans-unit id="eb1f5ef8b32f66be0ebf85bab611e6a46d561b3a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;rarr; If you already understand the problem, skip to the possible solutions below.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;rarr;如果您已经理解问题，请跳至下面的可能解决方案。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5326aa0d4ea5b09f0c635a23b58323c8c2e39d46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Or alternately, you could make a wrapper for &lt;code&gt;doSomethingAsync&lt;/code&gt; that returns a promise, and then do the below...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（或者，您可以为 &lt;code&gt;doSomethingAsync&lt;/code&gt; 做一个包装，该包装返回一个promise，然后执行以下操作...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e53fbd340f4f3003e06110183cb83b82789a7984" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Or, again, build a wrapper for &lt;code&gt;doSomethingAsync&lt;/code&gt; that gives you a promise and do the below...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（或者再次为 &lt;code&gt;doSomethingAsync&lt;/code&gt; 构建包装器，该包装器会给您一个承诺，然后执行以下操作...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1c2279af365b10752ed22cb3ac6e9f7c78b75a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Since we're doing the work in series, we can just use &lt;code&gt;results.push(result)&lt;/code&gt; since we know we won't get results out of order. In the above we could have used &lt;code&gt;results[index] = result;&lt;/code&gt;, but in some of the following examples we don't have an index to use.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（由于我们正在进行系列工作，因此我们可以使用 &lt;code&gt;results.push(result)&lt;/code&gt; ,因为我们知道不会使结果乱序。在上面，我们可以使用 &lt;code&gt;results[index] = result;&lt;/code&gt; 但是在以下某些示例中，我们没有要使用的索引。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0dca3ab11483f31910ef1b76a0f2b57827edfed0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(We could do away with &lt;code&gt;expecting&lt;/code&gt; and just use &lt;code&gt;results.length === theArray.length&lt;/code&gt;, but that leaves us open to the possibility that &lt;code&gt;theArray&lt;/code&gt; is changed while the calls are outstanding...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（我们可以消除 &lt;code&gt;expecting&lt;/code&gt; ，只使用 &lt;code&gt;results.length === theArray.length&lt;/code&gt; ，但这使我们对在调用未完成时更改 &lt;code&gt;theArray&lt;/code&gt; 的可能性持开放态度 。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c79ef9a065b5b6d162c99553810bc34db9b4c98" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A Image from one of the answers here, Correctly explains callback use...&lt;/em&gt;
We give our function(function utilising data returned from server) to function calling server.</source>
          <target state="translated">&lt;em&gt;来自此处答案之一的图像，正确解释了回调的用法...&lt;/em&gt;我们将函数（利用从服务器返回的数据的函数）提供给函数调用服务器。</target>
        </trans-unit>
        <trans-unit id="575713933b89fb879752fb918e398d207981e848" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Error handler&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;错误处理程序&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb7a5019ca58e906cfe2794d7f8ae19085308f37" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Of course, if &lt;code&gt;doSomethingAsync&lt;/code&gt; passed us errors, we'd use &lt;code&gt;reject&lt;/code&gt; to reject the promise when we got an error.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;当然，如果 &lt;code&gt;doSomethingAsync&lt;/code&gt; 向我们传递了错误，则当出现错误时，我们将使用 &lt;code&gt;reject&lt;/code&gt; 来拒绝承诺。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29ac499569a5a06c4d82ef94c11d97109d312692" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PS: As the first test I wrote x('x', displayAjax)..., and it totally got a response...??? So I checked the folder where the HTML is located, and there was a file called 'x.xml'. So even if you forget the extension of your file XMLHttpRequest 2 WILL FIND IT&lt;/em&gt;. I LOL'd</source>
          <target state="translated">&lt;em&gt;PS：作为第一个测试，我编写了x（'x'，displayAjax）...，它完全得到了响应... ???&lt;/em&gt; &lt;em&gt;因此，我检查了HTML所在的文件夹，其中有一个名为&amp;ldquo; x.xml&amp;rdquo;的文件。&lt;/em&gt; &lt;em&gt;因此，即使您忘记了XMLHttpRequest 2文件的扩展名，它也将找到它&lt;/em&gt; 。 我哈哈</target>
        </trans-unit>
        <trans-unit id="a453fdc787181e5194220141468f98edcb49264c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Read a file synchronous&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;同步读取文件&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f873c1d50c07030d55b6897f696affcc44c234c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 2&lt;/strong&gt; (first of all read the answers from &lt;a href=&quot;https://stackoverflow.com/a/16825593/19068&quot;&gt;Benjamin Gruenbaum&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://stackoverflow.com/a/14220323/19068&quot;&gt;Felix Kling&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 2&lt;/strong&gt; （首先阅读&lt;a href=&quot;https://stackoverflow.com/a/16825593/19068&quot;&gt;Benjamin Gruenbaum&lt;/a&gt;和&lt;a href=&quot;https://stackoverflow.com/a/14220323/19068&quot;&gt;Felix Kling&lt;/a&gt;的答案）</target>
        </trans-unit>
        <trans-unit id="7bb7d03442a106c3a66906d1c9d76fc88badb345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;The Event Loop and Concurrency Model&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;事件循环和并发模型&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc4c0812139669b4b9302dd36333c2148a9da551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All three are available in current browsers, and node 7+.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在当前浏览器和节点7+中，所有这三个功能均可用。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="890ea8c5734449e60d41906d358b6206ed712f11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt; (popular in node)</source>
          <target state="translated">&lt;strong&gt;回调&lt;/strong&gt; （在节点中受欢迎）</target>
        </trans-unit>
        <trans-unit id="e2ab2f71e857cb3d2466201010b62a27fd2e5e37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't do that.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不要那样做&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="afaf690b015b9a3ab311cb3b9d55efc3bab713ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 way (async - await)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6方式（异步-等待）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d78b4767222f91ac61373691a4d965d332d201f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Embrace the asynchronous nature of JavaScript!&lt;/strong&gt; While certain asynchronous operations provide synchronous counterparts (so does &quot;Ajax&quot;), it's generally discouraged to use them, especially in a browser context.</source>
          <target state="translated">&lt;strong&gt;拥抱JavaScript的异步特性！&lt;/strong&gt; 尽管某些异步操作提供了同步对应项（&amp;ldquo; Ajax&amp;rdquo;也是如此），但通常不鼓励使用它们，尤其是在浏览器上下文中。</target>
        </trans-unit>
        <trans-unit id="109d60edc3e638d2bab113fbb027ee1e4e879a32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Have a look at this example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;看一下这个例子：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09004b4c20addc68d6df669ac50a41fb497dea47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heads up!&lt;/strong&gt; It is not possible to make a synchronous &lt;a href=&quot;https://stackoverflow.com/questions/2067472/please-explain-jsonp&quot;&gt;JSONP&lt;/a&gt; request. JSONP by its very nature is always asynchronous (one more reason to not even consider this option).</source>
          <target state="translated">&lt;strong&gt;小心！&lt;/strong&gt; 不可能发出同步&lt;a href=&quot;https://stackoverflow.com/questions/2067472/please-explain-jsonp&quot;&gt;JSONP&lt;/a&gt;请求。 JSONP本质上始终是异步的（还有一个甚至不考虑此选项的原因）。</target>
        </trans-unit>
        <trans-unit id="db3e68b8187a2a11a0f5fea968a2add5f24c4dfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; You can only use &lt;code&gt;await&lt;/code&gt; inside an &lt;code&gt;async&lt;/code&gt; function. Right now, top-level &lt;code&gt;await&lt;/code&gt; isn't yet supported, so you might have to make an async IIFE (&lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately_invoked_function_expression&quot;&gt;Immediately Invoked Function Expression&lt;/a&gt;) to start an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="translated">&lt;strong&gt;重要提示：&lt;/strong&gt;您只能在 &lt;code&gt;async&lt;/code&gt; 函数内使用 &lt;code&gt;await&lt;/code&gt; 。 目前，尚不支持顶层 &lt;code&gt;await&lt;/code&gt; ，因此您可能必须进行异步IIFE（ &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately_invoked_function_expression&quot;&gt;立即调用函数表达式&lt;/a&gt; ）才能启动 &lt;code&gt;async&lt;/code&gt; 上下文。</target>
        </trans-unit>
        <trans-unit id="d1a2d5a4642c349de8193773228017c7500f4e56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;
Recent Spotify &lt;code&gt;search&lt;/code&gt; APIs will require an access token to be specified in the request headers:</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;最近的Spotify &lt;code&gt;search&lt;/code&gt; API将要求在请求标头中指定访问令牌：</target>
        </trans-unit>
        <trans-unit id="4b966ba6c20e45f447ff2e8f03f268e29a52a4f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises with &lt;code&gt;async/await&lt;/code&gt;&lt;/strong&gt; (ES2017+, available in older browsers if you use a transpiler or regenerator)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;async/await&lt;/code&gt; 承诺&lt;/strong&gt; （ES2017 +，如果使用转译器或再生器，则在较旧的浏览器中可用）</target>
        </trans-unit>
        <trans-unit id="6473a819e62a6a22028f1318142e8cba26e9b5a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises with &lt;code&gt;then()&lt;/code&gt;&lt;/strong&gt; (ES2015+, available in older browsers if you use one of the many promise libraries)</source>
          <target state="translated">&lt;strong&gt;对 &lt;code&gt;then()&lt;/code&gt; 的承诺&lt;/strong&gt; （ES2015 +，如果您使用许多promise库之一，则在较旧的浏览器中可用）</target>
        </trans-unit>
        <trans-unit id="04c41fa090162049f70a4e607252fab3dd0bb0ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short answer&lt;/strong&gt;: Your &lt;code&gt;foo()&lt;/code&gt; method returns immediately, while the &lt;code&gt;$ajax()&lt;/code&gt; call executes asynchronously &lt;em&gt;after the function returns&lt;/em&gt;. The problem is then how or where to store the results retrieved by the async call once it returns.</source>
          <target state="translated">&lt;strong&gt;简短的答案&lt;/strong&gt; ：您的 &lt;code&gt;foo()&lt;/code&gt; 方法立即返回，而 &lt;code&gt;$ajax()&lt;/code&gt; 调用&lt;em&gt;在函数返回之后&lt;/em&gt;异步执行。 问题是一旦异步调用返回，如何或在何处存储结果。</target>
        </trans-unit>
        <trans-unit id="f4645089306c6a1d783c20f54349274a135ed097" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, how do we tackle this issue?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;那么，我们如何解决这个问题呢？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ab003d485f673dee9ae9f1e5a74cdd4ee60e809" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key thing here is the order of execution. That is&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这里的关键是执行顺序。&lt;/strong&gt; &lt;strong&gt;那是&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fac01d33af22c926036bf26176e2ea876531efc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the plnkr:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这是plnkr：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ed0d7ce5e48365488a89a8f5818cd02ab54aa58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WHEN is something going to run&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么时候会运行&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8fb2f83aee2cbeff4ac6fcb5ea50cce08e5c218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fulfilled&lt;/strong&gt; meaning that the computation completed successfully.</source>
          <target state="translated">&lt;strong&gt;完成&lt;/strong&gt;意味着计算成功完成。</target>
        </trans-unit>
        <trans-unit id="3030d3b7a04661fbb4185df915ebeef20d9e0313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rejected&lt;/strong&gt; meaning that the computation failed.</source>
          <target state="translated">&lt;strong&gt;拒绝&lt;/strong&gt;表示计算失败。</target>
        </trans-unit>
        <trans-unit id="e9da82d285e8df3659dc9d639d7f7999131d7220" translate="yes" xml:space="preserve">
          <source>A Promise is a &lt;em&gt;value over time&lt;/em&gt;. Promises have state, they start as pending with no value and can settle to:</source>
          <target state="translated">承诺是一段&lt;em&gt;时间&lt;/em&gt;的&lt;em&gt;价值&lt;/em&gt; 。 承诺具有状态，它们以没有价值的待处理状态开始，可以解决：</target>
        </trans-unit>
        <trans-unit id="0fa2ed570336fff9061c7fed76b7c10d8559bca9" translate="yes" xml:space="preserve">
          <source>A callback is simply a function passed to another function. That other function can call the function passed whenever it is ready. In the context of an asynchronous process, the callback will be called whenever the asynchronous process is done. Usually, the result is passed to the callback.</source>
          <target state="translated">回调只是一个传递给另一个函数的函数。该另一个函数可以随时调用传递的函数。在异步进程的上下文中,每当异步进程完成时,回调就会被调用。通常情况下,结果会被传递给回调。</target>
        </trans-unit>
        <trans-unit id="f9e8a04c6605f9a32383dcbf481370c3e715820d" translate="yes" xml:space="preserve">
          <source>A promise can only change states &lt;em&gt;once&lt;/em&gt; after which it will always stay at the same state forever. You can attach &lt;code&gt;then&lt;/code&gt; handlers to promises to extract their value and handle errors. &lt;code&gt;then&lt;/code&gt; handlers allow &lt;a href=&quot;https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks&quot;&gt;chaining&lt;/a&gt; of calls. Promises are created by &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;using APIs that return them&lt;/a&gt;. For example, the more modern AJAX replacement &lt;code&gt;fetch&lt;/code&gt; or jQuery's &lt;code&gt;$.get&lt;/code&gt; return promises.</source>
          <target state="translated">一个承诺只能更改&lt;em&gt;一次&lt;/em&gt;状态&lt;em&gt;，&lt;/em&gt;此后它将永远永远保持在同一状态。 &lt;code&gt;then&lt;/code&gt; 您可以将处理程序附加到Promise，以提取其值并处理错误。 &lt;code&gt;then&lt;/code&gt; 处理程序允许&lt;a href=&quot;https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks&quot;&gt;链接&lt;/a&gt;调用。 通过&lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;使用返回API的API&lt;/a&gt;来创建Promise。 例如，更现代的AJAX替换 &lt;code&gt;fetch&lt;/code&gt; 或jQuery的 &lt;code&gt;$.get&lt;/code&gt; 返回承诺。</target>
        </trans-unit>
        <trans-unit id="d64b3ccbf97c56e6baf992073261e3d4c261d264" translate="yes" xml:space="preserve">
          <source>A+ Promises.js</source>
          <target state="translated">A+Promises.js</target>
        </trans-unit>
        <trans-unit id="7b2622a1b73a931e6ca38a355f7e3e8ea446ddb8" translate="yes" xml:space="preserve">
          <source>Above, we said, &quot;JS has no way to know that it needs to &lt;strong&gt;wait&lt;/strong&gt; for the first call to finish before it executes the second&quot;. Wouldn't it be nice if there &lt;strong&gt;was&lt;/strong&gt; some way to tell JS that? It turns out that there is--the &lt;code&gt;await&lt;/code&gt; keyword, used inside a special type of function called an &quot;async&quot; function. This feature is part of the upcoming version of ES but is already available in transpilers such as Babel given the right presets. This allows us to simply write</source>
          <target state="translated">上面我们说过：&amp;ldquo; JS无法知道它需要&lt;strong&gt;等待&lt;/strong&gt;第一个调用完成才能执行第二个调用&amp;rdquo;。 如果有某种方法可以告诉JS那不是很好吗？ 事实证明，在一种特殊类型的函数（称为&amp;ldquo;异步&amp;rdquo;函数）中使用了 &lt;code&gt;await&lt;/code&gt; 关键字。 此功能是即将推出的ES版本的一部分，但已提供适当的预设，在诸如Babel之类的编译器中已可用。 这使我们可以简单地编写</target>
        </trans-unit>
        <trans-unit id="e1ca54ffb7b2f8af43c2a3bf761dc7cd1da55e53" translate="yes" xml:space="preserve">
          <source>Actually, all we've done is added a &lt;code&gt;return&lt;/code&gt; to the call to &lt;code&gt;$.ajax&lt;/code&gt;. This works because jQuery's &lt;code&gt;$.ajax&lt;/code&gt; already returns a kind of promise-like thing. (In practice, without getting into details, we would prefer to wrap this call so as for return a real promise, or use some alternative to &lt;code&gt;$.ajax&lt;/code&gt; that does so.) Now, if we want to load the file and wait for it to finish and then do something, we can simply say</source>
          <target state="translated">实际上，我们所做的只是添加了对 &lt;code&gt;$.ajax&lt;/code&gt; 的调用 &lt;code&gt;return&lt;/code&gt; 。 之所以可行，是因为jQuery的 &lt;code&gt;$.ajax&lt;/code&gt; 已经返回了一种类似于promise的东西。 （在实践中，我们无需包装细节，而是希望包装此调用以便返回真实的Promise，或使用 &lt;code&gt;$.ajax&lt;/code&gt; 替代方法进行包装。）现在，如果我们要加载文件并等待它完成然后做某事，我们可以简单地说</target>
        </trans-unit>
        <trans-unit id="8806f1d6f77f315f3c6459851ebdd89a11e28f02" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;'async'&lt;/a&gt; keyword to the parent function</source>
          <target state="translated">将&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;'async'&lt;/a&gt;关键字添加到父函数</target>
        </trans-unit>
        <trans-unit id="529deb621e57605154d7312ba8f12b3f554d9040" translate="yes" xml:space="preserve">
          <source>Additionally here is the promises &lt;a href=&quot;https://github.com/promises-aplus/promises-spec&quot;&gt;spec&lt;/a&gt; define here.</source>
          <target state="translated">另外，这里是在这里定义的Promise &lt;a href=&quot;https://github.com/promises-aplus/promises-spec&quot;&gt;规范&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab38701d1301596d1056dacff49b4a862d011ba3" translate="yes" xml:space="preserve">
          <source>Again ... it's a very short function, but it does get &amp;amp; post.</source>
          <target state="translated">再次...这是一个非常短的函数，但它确实可以获取和发布。</target>
        </trans-unit>
        <trans-unit id="54729d47d0181e621bfce461fcd3befc07e5b989" translate="yes" xml:space="preserve">
          <source>All of this is really bad user experience. The user won't be able to tell whether everything is working fine or not. Furthermore, the effect will be worse for users with a slow connection.</source>
          <target state="translated">这些都是非常糟糕的用户体验。用户将无法辨别出是否一切正常工作。而且,对于连接速度慢的用户来说,效果会更差。</target>
        </trans-unit>
        <trans-unit id="644cfe271cac18a474c99dd756307f08b1e0e327" translate="yes" xml:space="preserve">
          <source>And executing it like this.</source>
          <target state="translated">而执行起来就像这样。</target>
        </trans-unit>
        <trans-unit id="761067f16b11d2d1e088fb27ee5a3facce3b502f" translate="yes" xml:space="preserve">
          <source>Angular1</source>
          <target state="translated">Angular1</target>
        </trans-unit>
        <trans-unit id="a6f848c2ffe2ed313ae1ff7c87a3e8f4231023f9" translate="yes" xml:space="preserve">
          <source>Angular2 and Later</source>
          <target state="translated">Angular2及以后</target>
        </trans-unit>
        <trans-unit id="700b18f544e30a3391a16d96b67c29e5dd7f4d12" translate="yes" xml:space="preserve">
          <source>Another approach to return a value from an asynchronous function, is to pass in an object that will store the result from the asynchronous function.</source>
          <target state="translated">另一种从异步函数返回值的方法是传递一个对象,该对象将存储来自异步函数的结果。</target>
        </trans-unit>
        <trans-unit id="6e0e29ebcd867f1dca1b8c6b1fb3343ba7d8745a" translate="yes" xml:space="preserve">
          <source>Another point is... if you work with APIs or just your own list's files or whatever you always use different functions for each request...</source>
          <target state="translated">还有一点是...........如果你使用API或者只是你自己的列表文件或者其他什么,你总是对每个请求使用不同的函数.....</target>
        </trans-unit>
        <trans-unit id="64aef2853dbea8a1653b08bcdf147b457091ff7b" translate="yes" xml:space="preserve">
          <source>Another solution is to execute code via sequential executor &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt;.</source>
          <target state="translated">另一种解决方案是通过顺序执行程序&lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt;执行代码。</target>
        </trans-unit>
        <trans-unit id="b2cb720802474bc4792fbb02842d36aeeabbeceb" translate="yes" xml:space="preserve">
          <source>Apart from using &lt;code&gt;then/catch&lt;/code&gt; to work with promises, there exists one more approach. The idea is to &lt;em&gt;recognize an asynchronous function&lt;/em&gt; and then &lt;em&gt;wait for the promises&lt;/em&gt; to resolve, before moving to the next line of code. It's still just the &lt;code&gt;promises&lt;/code&gt; under the hood, but with a different syntactical approach. To make things clearer, you can find a comparison below:</source>
          <target state="translated">除了使用 &lt;code&gt;then/catch&lt;/code&gt; 来实现诺言外，还有另一种方法。 这个想法是&lt;em&gt;识别异步函数&lt;/em&gt; ，然后&lt;em&gt;等待承诺&lt;/em&gt;解决，然后再转到下一行代码。 它仍然只是 &lt;code&gt;promises&lt;/code&gt; ，但是采用了不同的句法方法。 为了使事情更清楚，您可以在下面找到一个比较：</target>
        </trans-unit>
        <trans-unit id="4d6935922dd9171b57188004a7345d312359feff" translate="yes" xml:space="preserve">
          <source>Applied to our Ajax call we could use promises like this:</source>
          <target state="translated">应用到我们的Ajax调用中,我们可以使用这样的承诺。</target>
        </trans-unit>
        <trans-unit id="1ef6615c95aa80cbc5318149fff9515811e8e9d4" translate="yes" xml:space="preserve">
          <source>Applying this</source>
          <target state="translated">应用这一点</target>
        </trans-unit>
        <trans-unit id="f1a34583be1c0d1698743056ac6453867467e99a" translate="yes" xml:space="preserve">
          <source>As I mentioned, some(!) asynchronous operations have synchronous counterparts. I don't advocate their use, but for completeness' sake, here is how you would perform a synchronous call:</source>
          <target state="translated">正如我所提到的,有些(!)异步操作有同步的对应对象。我不主张使用它们,但为了完整起见,下面是你将如何执行同步调用。</target>
        </trans-unit>
        <trans-unit id="d690325261d4ed328617f51bcb035e4e34411085" translate="yes" xml:space="preserve">
          <source>As for synchronous AJAX, &lt;strong&gt;don't do it!&lt;/strong&gt; Felix's answer raises some compelling arguments about why it's a bad idea. To sum it up, it'll freeze the user's browser until the server returns the response and create a very bad user experience. Here is another short summary taken from MDN on why:</source>
          <target state="translated">至于同步AJAX， &lt;strong&gt;请不要这样做！&lt;/strong&gt; Felix的回答提出了一些令人信服的论点，说明为什么这是一个坏主意。 总结起来，它将冻结用户的浏览器，直到服务器返回响应并创建非常糟糕的用户体验。 这是MDN提取的另一个简短原因：</target>
        </trans-unit>
        <trans-unit id="4406a09393c68f9778335e6efa2ba72dfa43398d" translate="yes" xml:space="preserve">
          <source>As mentioned in the comment the use of error &amp;amp;&amp;amp; synchronous does completely break the point of the answer. Which is a nice short way to use Ajax in the proper way?</source>
          <target state="translated">如评论中所述，使用错误&amp;amp;&amp;amp;同步确实会完全破坏答案。 哪种是正确使用Ajax的不错的简短方法？</target>
        </trans-unit>
        <trans-unit id="3d039321bb1e1655c4cd32eb77e5d556b9a9d4cc" translate="yes" xml:space="preserve">
          <source>As you can see &lt;code&gt;getJoke&lt;/code&gt; is &lt;strong&gt;returning a&lt;/strong&gt; resolved &lt;strong&gt;promise&lt;/strong&gt; (it is resolved when returning &lt;code&gt;res.data.value&lt;/code&gt;). So you wait until the &lt;strong&gt;$http.get&lt;/strong&gt; request is completed and then &lt;strong&gt;console.log(res.joke)&lt;/strong&gt; is executed (as a normal asynchronous flow).</source>
          <target state="translated">如您所见， &lt;code&gt;getJoke&lt;/code&gt; &lt;strong&gt;返回一个已&lt;/strong&gt;解决的&lt;strong&gt;promise&lt;/strong&gt; （返回 &lt;code&gt;res.data.value&lt;/code&gt; 时已解决）。 因此，您可以等待&lt;strong&gt;$ http.get&lt;/strong&gt;请求完成，然后执行&lt;strong&gt;console.log（res.joke）&lt;/strong&gt; （作为常规的异步流程）。</target>
        </trans-unit>
        <trans-unit id="6be3c4864e2a35cc4ac8cfd91a74da6e56a1ee18" translate="yes" xml:space="preserve">
          <source>As you can see I didn't implement sync... it's a bad thing.</source>
          <target state="translated">如你所见,我没有实现同步......这是个坏事。</target>
        </trans-unit>
        <trans-unit id="3e214af7884162cf40fb2934293a2a307f51fd46" translate="yes" xml:space="preserve">
          <source>As you can see:</source>
          <target state="translated">如你所见。</target>
        </trans-unit>
        <trans-unit id="3d7fac7964f752248f02c5aa61c85fd417dcfbcf" translate="yes" xml:space="preserve">
          <source>Asynchronous</source>
          <target state="translated">Asynchronous</target>
        </trans-unit>
        <trans-unit id="9ce552a69176ba76938ef8727847cfb9c28c9943" translate="yes" xml:space="preserve">
          <source>Basically, instead of returning a &lt;em&gt;value&lt;/em&gt; which we can't do because of the concurrency model - we're returning a &lt;em&gt;wrapper&lt;/em&gt; for a value that we can &lt;em&gt;unwrap&lt;/em&gt; with &lt;code&gt;then&lt;/code&gt;. It's like a box you can open with &lt;code&gt;then&lt;/code&gt;.</source>
          <target state="translated">基本上，不是返回由于并发模型而无法执行的&lt;em&gt;值&lt;/em&gt; ，而是返回一个&lt;em&gt;包装器&lt;/em&gt; ，该&lt;em&gt;包装器&lt;/em&gt;可以使用 &lt;code&gt;then&lt;/code&gt; 进行&lt;em&gt;包装&lt;/em&gt; 。 就像是一个可以用 &lt;code&gt;then&lt;/code&gt; 打开的盒子。</target>
        </trans-unit>
        <trans-unit id="eab484a08dfc236925e2ba1434abe3c27155a03c" translate="yes" xml:space="preserve">
          <source>Because JS has no way to know that it needs to &lt;strong&gt;wait&lt;/strong&gt; for &lt;code&gt;order_milk&lt;/code&gt; to finish before it executes &lt;code&gt;put_in_coffee&lt;/code&gt;. In other words, it does not know that &lt;code&gt;order_milk&lt;/code&gt; is &lt;strong&gt;asynchronous&lt;/strong&gt;--is something that is not going to result in milk until some future time. JS, and other declarative languages execute one statement after another without waiting.</source>
          <target state="translated">因为JS无法知道在执行 &lt;code&gt;put_in_coffee&lt;/code&gt; 之前需要&lt;strong&gt;等待&lt;/strong&gt; &lt;code&gt;order_milk&lt;/code&gt; 完成。 换句话说，它不知道 &lt;code&gt;order_milk&lt;/code&gt; 是&lt;strong&gt;异步的-&lt;/strong&gt;直到将来某个时候才会产生牛奶。 JS和其他声明性语言无需等待即可执行另一个语句。</target>
        </trans-unit>
        <trans-unit id="4fb46d91439c44dca8be62ad2c6da7e246ac7424" translate="yes" xml:space="preserve">
          <source>Because a callback is not executed immediately but at a later time it's important to pass the reference to the function not it executed. so</source>
          <target state="translated">因为回调不是立即执行的,而是在以后的时间,所以传递给函数的引用不是它执行的,这一点很重要。</target>
        </trans-unit>
        <trans-unit id="e949293bb3141d39921183faafd54e8bcb4089c2" translate="yes" xml:space="preserve">
          <source>Becomes:</source>
          <target state="translated">Becomes:</target>
        </trans-unit>
        <trans-unit id="33e41fa8d678aeb4e035f2f254faf9c3f81da31a" translate="yes" xml:space="preserve">
          <source>Browser Promise object</source>
          <target state="translated">浏览器承诺对象</target>
        </trans-unit>
        <trans-unit id="765bf6bf6d4dba7ff5f829d9d93bb123d301ca4a" translate="yes" xml:space="preserve">
          <source>Browser can be divided into three parts:</source>
          <target state="translated">浏览器可以分为三个部分。</target>
        </trans-unit>
        <trans-unit id="d450093edec3c9a5aeeeb0beef75d475c35a50cd" translate="yes" xml:space="preserve">
          <source>But how you can do it in pure &lt;strong&gt;javascript&lt;/strong&gt; or &lt;strong&gt;jQuery&lt;/strong&gt; for example as you asked in this question?</source>
          <target state="translated">但是，如您在此问题中所提出的那样，如何用纯&lt;strong&gt;JavaScript&lt;/strong&gt;或&lt;strong&gt;jQuery&lt;/strong&gt;实现它呢？</target>
        </trans-unit>
        <trans-unit id="a64b0676afddefea547c307ed3e8295760faffaa" translate="yes" xml:space="preserve">
          <source>But the fix is easy:</source>
          <target state="translated">但解决方法很简单。</target>
        </trans-unit>
        <trans-unit id="77d296e55d0766d8200053d7f3cfd7c13d9226be" translate="yes" xml:space="preserve">
          <source>But the question here is how to return an Ajax response... (I added an easy way.)</source>
          <target state="translated">但这里的问题是如何返回Ajax响应.....。我加了一个简单的方法)。</target>
        </trans-unit>
        <trans-unit id="871ea55bfadd9c09cdde6b012a015872456c8c66" translate="yes" xml:space="preserve">
          <source>But there's still something vaguely dissatisfying about having to write code one way if synchronous and a quite different way if asynchronous. For synchronous, we write</source>
          <target state="translated">但是,如果是同步的,就必须用一种方式写代码,而如果是异步的,就必须用另一种方式写代码,这还是让人很不满意。对于synchronous,我们写</target>
        </trans-unit>
        <trans-unit id="6662b4c845488fe6c8b6ee72b41f77fa73bca428" translate="yes" xml:space="preserve">
          <source>But to really get out an error the &lt;strong&gt;only&lt;/strong&gt; way is to write a wrong URL in which case every browser throws an error.</source>
          <target state="translated">但是要真正找出错误， &lt;strong&gt;唯一的&lt;/strong&gt;方法是编写错误的URL，在这种情况下，每个浏览器都会抛出错误。</target>
        </trans-unit>
        <trans-unit id="b6fe1615524c00038c401cf5c333c9dc307f8bd8" translate="yes" xml:space="preserve">
          <source>But wait...!</source>
          <target state="translated">但是等等......</target>
        </trans-unit>
        <trans-unit id="dfb64faad30b77313e3dfe8cbd9a6f1d588843af" translate="yes" xml:space="preserve">
          <source>But what if you need to &lt;em&gt;return&lt;/em&gt; those results from a function? As the other answers have pointed out, you can't; you have to have your function accept and call a callback (or return a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;). Here's a callback version:</source>
          <target state="translated">但是，如果您需要从函数&lt;em&gt;返回&lt;/em&gt;这些结果怎么办？ 正如其他答案所指出的那样，您不能这样做。 您必须让您的函数接受并调用回调（或返回&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; ）。 这是一个回调版本：</target>
        </trans-unit>
        <trans-unit id="53f5926dc5af0fddf203c78ec84b5d65b51a2f52" translate="yes" xml:space="preserve">
          <source>But you can do a lot of stuff with XMLHttpRequest 2:</source>
          <target state="translated">但你可以用XMLHttpRequest 2做很多事情。</target>
        </trans-unit>
        <trans-unit id="b0d6941afab03ca7758a76da0c336ec6d021825e" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;http://caniuse.com/xhr2&quot;&gt;XMLHttpRequest advanced features&lt;/a&gt;</source>
          <target state="translated">查看&lt;a href=&quot;http://caniuse.com/xhr2&quot;&gt;XMLHttpRequest的高级功能&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31ebfd440a69ecc3715e49c5b6a6c1dd6d4b0371" translate="yes" xml:space="preserve">
          <source>Consider an example. You call the milkman and order some milk. When it comes, you want to put it in your coffee. You can't put the milk in your coffee right now, because it is not here yet. You have to wait for it to come before putting it in your coffee. In other words, the following won't work:</source>
          <target state="translated">考虑一个例子。你打电话给送奶员,点了一些牛奶。当它来了,你想把它放在你的咖啡里。但你现在不能把牛奶放进咖啡里,因为牛奶还没到。你必须等它来了之后再放进咖啡里。换句话说,下面的方法是行不通的。</target>
        </trans-unit>
        <trans-unit id="84b2d3dacc41e20a8047eac062d786928aeea668" translate="yes" xml:space="preserve">
          <source>Context. The example is querying the &lt;a href=&quot;https://developer.spotify.com/web-api/endpoint-reference/&quot;&gt;Spotify Web API&lt;/a&gt; endpoint in order to search for &lt;code&gt;playlist&lt;/code&gt; objects for a given set of query strings:</source>
          <target state="translated">上下文。 该示例正在查询&lt;a href=&quot;https://developer.spotify.com/web-api/endpoint-reference/&quot;&gt;Spotify Web API&lt;/a&gt;端点，以便为给定的查询字符串集搜索 &lt;code&gt;playlist&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="b985b8de161adfd30380ec1c45ac41353ff18286" translate="yes" xml:space="preserve">
          <source>Current &lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-async_functions&quot;&gt;browser&lt;/a&gt; and &lt;a href=&quot;http://node.green/#ES2017-features-async-functions&quot;&gt;node&lt;/a&gt; versions support &lt;code&gt;async/await&lt;/code&gt;. You can also support older environments by transforming your code to ES5 with the help of &lt;a href=&quot;https://github.com/facebook/regenerator&quot;&gt;regenerator&lt;/a&gt; (or tools that use regenerator, such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;).</source>
          <target state="translated">当前的&lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-async_functions&quot;&gt;浏览器&lt;/a&gt;和&lt;a href=&quot;http://node.green/#ES2017-features-async-functions&quot;&gt;节点&lt;/a&gt;版本支持 &lt;code&gt;async/await&lt;/code&gt; 。 您还可以通过使用再生&lt;a href=&quot;https://github.com/facebook/regenerator&quot;&gt;器&lt;/a&gt; （或使用再生器的工具，例如&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; ）将代码转换为ES5来支持较旧的环境。</target>
        </trans-unit>
        <trans-unit id="23b9d4749a9f206dd4aecf7d5fe1ab0fe7998221" translate="yes" xml:space="preserve">
          <source>Define a function which returns a &lt;strong&gt;Promise&lt;/strong&gt;, in this case an Ajax call:</source>
          <target state="translated">定义一个返回&lt;strong&gt;Promise&lt;/strong&gt;的函数，在本例中为Ajax调用：</target>
        </trans-unit>
        <trans-unit id="3047a156238e05c9e91f44e59216ce4350e7d875" translate="yes" xml:space="preserve">
          <source>Describing all the advantages that promise offer is beyond the scope of this answer, but if you write new code, you should seriously consider them. They provide a great abstraction and separation of your code.</source>
          <target state="translated">描述承诺提供的所有优势超出了这个答案的范围,但如果你写新代码,你应该认真考虑它们。它们为你的代码提供了很好的抽象和分离。</target>
        </trans-unit>
        <trans-unit id="d24cf059acad77f2348de6ab9a950dcb953d0c1e" translate="yes" xml:space="preserve">
          <source>Difficulties could arise when you have to work with third-party code, but most problems can be solved by just thinking through the application flow.</source>
          <target state="translated">当你不得不与第三方代码合作时,可能会出现困难,但大多数问题只要通过应用流程的思考就可以解决。</target>
        </trans-unit>
        <trans-unit id="291b4e6259557593d37f6433293f59fe5f76d601" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 has 'generators' which allow you to easily program in an asynchronous style.</source>
          <target state="translated">ECMAScript 6有 &quot;生成器&quot;,可以让你轻松地以异步风格编程。</target>
        </trans-unit>
        <trans-unit id="e3af59b16940b2e81235ebbcb74c7f1a75b7e5e5" translate="yes" xml:space="preserve">
          <source>ES2015 (ES6)</source>
          <target state="translated">ES2015(ES6)</target>
        </trans-unit>
        <trans-unit id="7dbb3904074ff18348bd30e832250b33427cdc38" translate="yes" xml:space="preserve">
          <source>ES2015+: Promises with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;then()&lt;/a&gt;</source>
          <target state="translated">ES2015 +：对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;then（）的&lt;/a&gt;承诺</target>
        </trans-unit>
        <trans-unit id="35bf367fe5ced0d619315d0cc8f147a296348c43" translate="yes" xml:space="preserve">
          <source>ES2016 (ES7)</source>
          <target state="translated">ES2016(ES7)</target>
        </trans-unit>
        <trans-unit id="1542f3c49056454d75a06101c17c1785c445d891" translate="yes" xml:space="preserve">
          <source>ES2017+: Promises with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async/await&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ES2017 +：带有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async/await&lt;/code&gt; &lt;/a&gt;承诺</target>
        </trans-unit>
        <trans-unit id="967cf59859743f73ba18a11fe55a168a8034039e" translate="yes" xml:space="preserve">
          <source>ES6 introduces &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generators&lt;/a&gt; which are functions that can return in the middle and then resume the point they were at. This is typically useful for sequences, for example:</source>
          <target state="translated">ES6引入了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;生成器&lt;/a&gt; ，这些生成器可以在中间返回然后再恢复它们所处的位置。 这通常对序列很有用，例如：</target>
        </trans-unit>
        <trans-unit id="4b08c5e49b030b945e2f126cefe3cc1039afa94b" translate="yes" xml:space="preserve">
          <source>Enter promises</source>
          <target state="translated">进入诺言</target>
        </trans-unit>
        <trans-unit id="80993d0449ad6680943f4a71d58a1facc8010c69" translate="yes" xml:space="preserve">
          <source>Error handlers are maybe useful if you set custom headers, set the responseType to blob array buffer or whatever...</source>
          <target state="translated">如果你设置了自定义标题,将响应类型设置为blob数组缓冲区或其他什么的,那么错误处理程序也许会很有用......</target>
        </trans-unit>
        <trans-unit id="52397d788ea7c6b60de8f942da7edb5fd927e6c4" translate="yes" xml:space="preserve">
          <source>Even if you pass 'POSTAPAPAP' as the method it won't throw an error.</source>
          <target state="translated">即使你通过'POSTAPAPAPAP'作为方法,它也不会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="ed627f8185515e40e63ef82e28b0e78972fa2fad" translate="yes" xml:space="preserve">
          <source>Even if you pass 'fdggdgilfdghfldj' as formdata it won't throw an error.</source>
          <target state="translated">即使你把'fdggdgdgilfdghfldj'作为formdata,它也不会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="c920a57596f644008ba32598f248afdb53f17307" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;findItem&lt;/code&gt; might take a long time to execute, any code coming after &lt;code&gt;var item = findItem();&lt;/code&gt; has to &lt;em&gt;wait&lt;/em&gt; until the function returns the result.</source>
          <target state="translated">即使 &lt;code&gt;findItem&lt;/code&gt; 可能需要花费很长时间才能执行，但是 &lt;code&gt;var item = findItem();&lt;/code&gt; 之后的任何代码都将被执行。 必须&lt;em&gt;等到&lt;/em&gt;函数返回结果。</target>
        </trans-unit>
        <trans-unit id="af30fe5dce2e46682e9e3add89a73ab9d1afd392" translate="yes" xml:space="preserve">
          <source>Event Loop runs for forever i.e kind of infinite loop.Event Queue is where all your function are pushed on some event(example:click) this is one by one carried out of queue and put into Event loop which execute this function and prepares it self for next one after first one is executed.This means Execution of one function doesn't starts till the function before it in queue is executed in event loop.</source>
          <target state="translated">Event Loop永远运行,也就是无限循环,Event Queue是指所有的函数都被推送到某个事件上(例如:点击),这个函数一个接一个地从队列中被执行,然后被放到Event循环中,在第一个函数被执行后,这个函数被执行,并为下一个函数做准备。</target>
        </trans-unit>
        <trans-unit id="ba81b013536dce95c24ccc172a06bd722742bb6a" translate="yes" xml:space="preserve">
          <source>Every Ajax method of jQuery already returns a &quot;deferred object&quot; (actually a promise of a deferred object) which you can just return from your function:</source>
          <target state="translated">jQuery的每一个Ajax方法都已经返回一个 &quot;递延对象&quot;(实际上是一个递延对象的承诺),你可以直接从你的函数中返回。</target>
        </trans-unit>
        <trans-unit id="197abe1392101850410c061421129e3d1b59f596" translate="yes" xml:space="preserve">
          <source>Example found in &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$q&quot;&gt;docs&lt;/a&gt; mentioned below.</source>
          <target state="translated">在下面提到的&lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$q&quot;&gt;文档&lt;/a&gt;中找到示例。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="77810a758bab3888ba66659f3df788816aeb992b" translate="yes" xml:space="preserve">
          <source>Example: jQuery deferred implementation to work with multiple requests</source>
          <target state="translated">例子:jQuery延迟实现与多个请求一起工作的延迟实现</target>
        </trans-unit>
        <trans-unit id="6b5bea21483cbaba11f47e563b491712cd328829" translate="yes" xml:space="preserve">
          <source>Examples of usage:</source>
          <target state="translated">用例:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="2bb87a5dd963da02345343f24198c82aa718d522" translate="yes" xml:space="preserve">
          <source>Felix Kling did a fine job writing an answer for people using jQuery for AJAX, I've decided to provide an alternative for people who aren't.</source>
          <target state="translated">Felix Kling为使用jQuery for AJAX的人写了一个很好的答案,我决定为不使用jQuery for AJAX的人提供一个替代方案。</target>
        </trans-unit>
        <trans-unit id="61b6cad34a7477f709f8134369511744282bf7b8" translate="yes" xml:space="preserve">
          <source>Felix Kling did a fine job writing an answer for people using jQuery with callbacks for AJAX. I have an answer for native XHR. This answer is for generic usage of promises either on the frontend or backend.</source>
          <target state="translated">Felix Kling做了一个很好的工作,为使用jQuery的人写了一个关于AJAX回调的答案。我有一个针对本地XHR的答案。这个答案是针对前端或后端的承诺的通用用法。</target>
        </trans-unit>
        <trans-unit id="635e0097e3c51f900f56e2ff15075d9128740b8b" translate="yes" xml:space="preserve">
          <source>For each item, a new Promise will fire a block - &lt;code&gt;ExecutionBlock&lt;/code&gt;, parse the result, schedule a new set of promises based on the result array, that is a list of Spotify &lt;code&gt;user&lt;/code&gt; objects and execute the new HTTP call within the &lt;code&gt;ExecutionProfileBlock&lt;/code&gt; asynchronously.</source>
          <target state="translated">对于每一项，一个新的Promise将触发一个块 &lt;code&gt;ExecutionBlock&lt;/code&gt; ，解析结果，基于结果数组（即Spotify &lt;code&gt;user&lt;/code&gt; 对象的列表）安排一组新的Promise，并在 &lt;code&gt;ExecutionProfileBlock&lt;/code&gt; 中异步执行新的HTTP调用。</target>
        </trans-unit>
        <trans-unit id="686ea421444c498a952e65a5b7b7b8ef0e77b9a4" translate="yes" xml:space="preserve">
          <source>For example in your case which you are using &lt;strong&gt;jQuery&lt;/strong&gt;, you can do something like this:</source>
          <target state="translated">例如，在使用&lt;strong&gt;jQuery的&lt;/strong&gt;情况下，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="5e7f2f5c0f405e9a5beea0b22dfdc929a77c6dbf" translate="yes" xml:space="preserve">
          <source>For more details on how this sort of callback design is done, check Felix's answer.</source>
          <target state="translated">关于这类回调设计的详细情况,请看Felix的回答。</target>
        </trans-unit>
        <trans-unit id="9ae95c96ff6e523f358968e03ed28b68223e6cc4" translate="yes" xml:space="preserve">
          <source>For more information study about &lt;strong&gt;promises&lt;/strong&gt; and &lt;strong&gt;observables&lt;/strong&gt; which are newer ways to do this async stuffs.</source>
          <target state="translated">有关更多信息，请研究有关&lt;strong&gt;promise&lt;/strong&gt;和&lt;strong&gt;observable的&lt;/strong&gt;信息，这是执行异步操作的新方法。</target>
        </trans-unit>
        <trans-unit id="d2c8933d706e47b9253dd050c3950ebb59a4178f" translate="yes" xml:space="preserve">
          <source>For people who are using &lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;, can handle this situation using &lt;code&gt;Promises&lt;/code&gt;.</source>
          <target state="translated">对于使用&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS的人&lt;/a&gt; ，可以使用 &lt;code&gt;Promises&lt;/code&gt; 处理这种情况。</target>
        </trans-unit>
        <trans-unit id="9244ed786ac52489080bb2ed73727df2582f9b46" translate="yes" xml:space="preserve">
          <source>Handle asynchronous HTTP calls;</source>
          <target state="translated">处理异步HTTP调用。</target>
        </trans-unit>
        <trans-unit id="93478a618140fa661d81ab91258f1a651409d131" translate="yes" xml:space="preserve">
          <source>Having said that ... why don't do it the easy way?</source>
          <target state="translated">说了这么多......为什么不从易到难呢?</target>
        </trans-unit>
        <trans-unit id="51d1de74537d4867e5318491d300b2040b09329d" translate="yes" xml:space="preserve">
          <source>Here are some approaches to work with asynchronous requests:</source>
          <target state="translated">下面是一些处理异步请求的方法。</target>
        </trans-unit>
        <trans-unit id="089375b0e7ad3fd4224f7a969d79cd0949c40a9f" translate="yes" xml:space="preserve">
          <source>Here is a simple analogy</source>
          <target state="translated">这里有一个简单的比喻</target>
        </trans-unit>
        <trans-unit id="a3e19bd4dc54096f28f69d4061c9289827b6d622" translate="yes" xml:space="preserve">
          <source>Here is a simple analogy for the issue:</source>
          <target state="translated">下面是一个简单的比喻问题。</target>
        </trans-unit>
        <trans-unit id="66783b0ea79ce0b229e6872b71ad5253987aee77" translate="yes" xml:space="preserve">
          <source>Here is a simple example of using a promise:</source>
          <target state="translated">下面是一个简单的使用承诺的例子。</target>
        </trans-unit>
        <trans-unit id="3f98c5fe445eb6aa095ee0b24083a641538f5e28" translate="yes" xml:space="preserve">
          <source>Here is an analogy which hopefully makes the difference between synchronous and asynchronous flow clearer:</source>
          <target state="translated">这里有一个比喻,希望能让同步流和异步流的区别更加清晰。</target>
        </trans-unit>
        <trans-unit id="e18b9e6f0b7383abbecaa82bf04e6ad414de12c8" translate="yes" xml:space="preserve">
          <source>Here is an example of the same:</source>
          <target state="translated">下面是一个同样的例子。</target>
        </trans-unit>
        <trans-unit id="bd9e15afe641187b36f9279675ba8535db066ca8" translate="yes" xml:space="preserve">
          <source>Here is an example that builds on top of delay above:</source>
          <target state="translated">这里有一个例子,是在上面的延迟基础上建立起来的。</target>
        </trans-unit>
        <trans-unit id="1197d1f4a9d4cf3b8d6f5178c3cec6d0874a533a" translate="yes" xml:space="preserve">
          <source>Here we defined the function &quot;inline&quot; but you can pass any function reference:</source>
          <target state="translated">这里我们定义了函数 &quot;inline&quot;,但你可以传递任何函数引用。</target>
        </trans-unit>
        <trans-unit id="164b78f47e3ef1dc3e0cef0b751ea196374fd668" translate="yes" xml:space="preserve">
          <source>Here we passed an anonymous function, but we could just as easily pass a reference to an existing function, making it look like:</source>
          <target state="translated">这里我们传递了一个匿名函数,但我们可以像传递一个引用到一个现有的函数,使其看起来像。</target>
        </trans-unit>
        <trans-unit id="1e64ad5b4497aa10277e2076d4284da48c62d379" translate="yes" xml:space="preserve">
          <source>Here's a working version of your code:</source>
          <target state="translated">这是你的代码的工作版本。</target>
        </trans-unit>
        <trans-unit id="7e3c8edd9d78bba7e3a4b76a43bc5bd629037a8e" translate="yes" xml:space="preserve">
          <source>Hopefully that will make some sense. When you encounter things like this that seem confusing - i highly recommend reading the documentation fully to at least get an understanding of it. It will make you a much better developer.</source>
          <target state="translated">希望这能让你明白一些道理。当你遇到这样的事情时,我强烈建议你完整地阅读文档,至少对它有一个了解。这将使你成为一个更好的开发者。</target>
        </trans-unit>
        <trans-unit id="156541c40984a4a3ee70fd44f32c4e4796080910" translate="yes" xml:space="preserve">
          <source>How do I return the response from an asynchronous call</source>
          <target state="translated">如何从异步调用中返回响应?</target>
        </trans-unit>
        <trans-unit id="450c3e475d5ba28aa9f650174becd8bb359d1260" translate="yes" xml:space="preserve">
          <source>How do I return the response from an asynchronous call?</source>
          <target state="translated">如何从异步调用中返回响应?</target>
        </trans-unit>
        <trans-unit id="89fed459f83d0d8bc59f73a0c70d136088949d94" translate="yes" xml:space="preserve">
          <source>How to make &lt;strong&gt;asynchronous&lt;/strong&gt; code look &lt;strong&gt;synchronous&lt;/strong&gt;?</source>
          <target state="translated">如何使&lt;strong&gt;异步&lt;/strong&gt;代码看起来&lt;strong&gt;同步&lt;/strong&gt; ？</target>
        </trans-unit>
        <trans-unit id="c25df1a995ff1bfc26f40ebfff6e38eed0cf9af3" translate="yes" xml:space="preserve">
          <source>I am using the &lt;code&gt;result&lt;/code&gt; object to store the value during the asynchronous operation. This allows the result be available even after the asynchronous job.</source>
          <target state="translated">我正在使用 &lt;code&gt;result&lt;/code&gt; 对象在异步操作期间存储值。 这样即使在异步作业之后，结果仍然可用。</target>
        </trans-unit>
        <trans-unit id="3082b7f700f005a0779967fd6b3615c7a09694bd" translate="yes" xml:space="preserve">
          <source>I have a function &lt;code&gt;foo&lt;/code&gt; which makes an Ajax request. How can I return the response from &lt;code&gt;foo&lt;/code&gt;?</source>
          <target state="translated">我有一个函数 &lt;code&gt;foo&lt;/code&gt; ，它发出Ajax请求。 如何返回 &lt;code&gt;foo&lt;/code&gt; 的响应？</target>
        </trans-unit>
        <trans-unit id="d16b97c7b8f99c277ca18e31f4f0499acffc903b" translate="yes" xml:space="preserve">
          <source>I have extensively discussed this solution &lt;a href=&quot;https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">我&lt;a href=&quot;https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774&quot;&gt;在这里&lt;/a&gt;广泛讨论了该解决方案。</target>
        </trans-unit>
        <trans-unit id="871db57e2d8a1b8bb628280aec3e9abeafe80bbf" translate="yes" xml:space="preserve">
          <source>I made a download manager (using ranges on both sides with resume, filereader, filesystem), various image resizers converters using canvas, populate web SQL databases with base64images and much more... But in these cases you should create a function only for that purpose... sometimes you need a blob, array buffers, you can set headers, override mimetype and there is a lot more...</source>
          <target state="translated">我做了一个下载管理器(使用范围两边的简历,文件阅读器,文件系统),使用画布做了各种图像调整器转换器,用base64images填充web SQL数据库等等......但在这些情况下,你应该只为这个目的创建一个函数...........有时你需要一个blob,数组缓冲区,你可以设置头像,覆盖mimetype,还有很多.....</target>
        </trans-unit>
        <trans-unit id="aabb558dc219037662405ce169cc7769e808b314" translate="yes" xml:space="preserve">
          <source>I tried returning the value from the &lt;code&gt;success&lt;/code&gt; callback, as well as assigning the response to a local variable inside the function and returning that one, but none of those ways actually return the response.</source>
          <target state="translated">我尝试从 &lt;code&gt;success&lt;/code&gt; 回调中返回值，以及将响应分配给函数内部的局部变量并返回该局部变量，但这些方法均未真正返回响应。</target>
        </trans-unit>
        <trans-unit id="805d9303f1d1e40a739086bcb503bea0dd8a07cd" translate="yes" xml:space="preserve">
          <source>I use this approach a lot. I would be interested to know how well this approach works where wiring the result back through consecutive modules is involved.</source>
          <target state="translated">我经常使用这种方法。我很想知道,这种方法的效果如何,通过连续的模块,将结果回传到后面的模块中。</target>
        </trans-unit>
        <trans-unit id="96fd1cbea3405a357b87787e1ea700f496799a2f" translate="yes" xml:space="preserve">
          <source>I was using this solution for a while until I figured out there is an error in old browsers:</source>
          <target state="translated">我一直在用这个方案,直到我发现旧的浏览器有一个错误,我才知道是旧的浏览器出了问题。</target>
        </trans-unit>
        <trans-unit id="404b02c50355c8c0582c7d04c555e4cc95c4e8cb" translate="yes" xml:space="preserve">
          <source>I will answer with a horrible-looking, hand-drawn comic. The second image is the reason why &lt;code&gt;result&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; in your code example.</source>
          <target state="translated">我将以恐怖的手绘漫画来回答。 第二张图片是代码示例中 &lt;code&gt;undefined&lt;/code&gt; &lt;code&gt;result&lt;/code&gt; 的原因。</target>
        </trans-unit>
        <trans-unit id="3967fbf9c99e4d431884df5be7bd68f466e20960" translate="yes" xml:space="preserve">
          <source>I would like to give an example for a Ajax request.</source>
          <target state="translated">我想举一个Ajax请求的例子。</target>
        </trans-unit>
        <trans-unit id="e1ef9ad0b4029d883d48f869147c3caa394f24cd" translate="yes" xml:space="preserve">
          <source>I'm using a lot of APIs and one of the first functions I integrate into every HTML page is the first Ajax function in this answer, with GET only...</source>
          <target state="translated">我使用了很多API,我在每个HTML页面中集成的第一个函数就是这个答案中的第一个Ajax函数,只用GET.....</target>
        </trans-unit>
        <trans-unit id="0a86d08347ddae45aa9f3764c8e9705b92f76fe2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doSomethingAsync&lt;/code&gt; gives you a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果 &lt;code&gt;doSomethingAsync&lt;/code&gt; 给您&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; ，则可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="97dfce1b14fd80ba22d599c23dd5f550c7f63ef9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doSomethingAsync&lt;/code&gt; gives you a Promise, if you can use ES2017+ syntax (perhaps with a transpiler like &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;), you can use an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt; function&lt;/a&gt; with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for-of&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果 &lt;code&gt;doSomethingAsync&lt;/code&gt; 给您一个承诺，如果您可以使用ES2017 +语法（也许使用像&lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;这样的编译器），则可以将&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; 函数&lt;/a&gt;与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for-of&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; 一起使用&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="163754b0a641fcc79050c0cc9adbe06a5d149a2e" translate="yes" xml:space="preserve">
          <source>If the sequence we're producing is a sequence of actions rather than numbers - we can pause the function whenever an action is yielded and wait for it before we resume the function. So instead of a sequence of numbers, we need a sequence of &lt;em&gt;future&lt;/em&gt; values - that is: promises.</source>
          <target state="translated">如果我们要产生的序列是一个动作序列而不是数字-我们可以在产生一个动作时暂停该函数，并在恢复该函数之前等待它。 因此，我们不需要一系列数字，而是需要一系列&lt;em&gt;未来&lt;/em&gt;值-即：promise。</target>
        </trans-unit>
        <trans-unit id="afa00a6b4070ffcc7e4d6431383806ca509e451d" translate="yes" xml:space="preserve">
          <source>If underlying function is not promisified</source>
          <target state="translated">如果底层功能不被认可</target>
        </trans-unit>
        <trans-unit id="b1be43c2bc654592ef71349407fe409b8835e049" translate="yes" xml:space="preserve">
          <source>If underlying function is promisified</source>
          <target state="translated">如果基础功能已被认可</target>
        </trans-unit>
        <trans-unit id="a2a2af534201c965a8a5307d8256309bf76d379b" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;have&lt;/em&gt; to do it, you can pass a flag: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request&quot;&gt;Here is how:&lt;/a&gt;</source>
          <target state="translated">如果&lt;em&gt;必须&lt;/em&gt;这样做，可以传递一个标志： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request&quot;&gt;这是如何做的：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e69ab6f2f9d1e92d40998e6452f1feaaddfbbee5" translate="yes" xml:space="preserve">
          <source>If you can't use ES2017+ syntax (yet), you can use a variation on the &lt;a href=&quot;https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all&quot;&gt;&quot;Promise reduce&quot; pattern&lt;/a&gt; (this is more complex than the usual Promise reduce because we're not passing the result from one into the next, but instead gathering up their results in an array):</source>
          <target state="translated">如果还不能使用ES2017 +语法，则可以在&lt;a href=&quot;https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all&quot;&gt;&amp;ldquo; Promise reduce&amp;rdquo;模式&lt;/a&gt;上使用变体（这比通常的Promise reduce更为复杂，因为我们没有将结果从一个传递到下一个将结果收集到一个数组中）：</target>
        </trans-unit>
        <trans-unit id="9b961004352fb6c26e593f096a006f3382d2c3af" translate="yes" xml:space="preserve">
          <source>If you directly use a &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/&quot;&gt;&lt;code&gt;XMLHTTPRequest&lt;/code&gt;&lt;/a&gt; object, pass &lt;code&gt;false&lt;/code&gt; as third argument to &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/#the-open%28%29-method&quot;&gt;&lt;code&gt;.open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果直接使用&lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/&quot;&gt; &lt;code&gt;XMLHTTPRequest&lt;/code&gt; &lt;/a&gt;对象， &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/#the-open%28%29-method&quot;&gt; &lt;code&gt;.open&lt;/code&gt; &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 作为第三个参数传递给.open 。</target>
        </trans-unit>
        <trans-unit id="458c0f1aba3bbec14d8c4e49ddecf559a0d3074c" translate="yes" xml:space="preserve">
          <source>If you don't use jQuery and want a nice short XMLHttpRequest 2 which works on the modern browsers and also on the mobile browsers I suggest to use it this way:</source>
          <target state="translated">如果你不使用jQuery,而想要一个漂亮的XMLHttpRequest 2,在现代浏览器和手机浏览器上都能正常工作,我建议用这个方法。</target>
        </trans-unit>
        <trans-unit id="55afcac8cc3cf8d87fcc46044f624ddede12707e" translate="yes" xml:space="preserve">
          <source>If you know that &lt;code&gt;doSomethingAsync&lt;/code&gt; will ignore a second and third argument, you can just pass it directly to &lt;code&gt;map&lt;/code&gt; (&lt;code&gt;map&lt;/code&gt; calls its callback with three arguments, but most people only use the first most of the time):</source>
          <target state="translated">如果您知道 &lt;code&gt;doSomethingAsync&lt;/code&gt; 将忽略第二个和第三个参数，则可以将其直接传递给 &lt;code&gt;map&lt;/code&gt; （ &lt;code&gt;map&lt;/code&gt; 使用三个参数调用其回调，但是大多数人在大多数时间只使用第一个参数）：</target>
        </trans-unit>
        <trans-unit id="c790a5aebe01811818eef515dc847f0886c8d6c4" translate="yes" xml:space="preserve">
          <source>If you need to target browsers that don't support ES6 you can run the code through Babel or closure-compiler to generate ECMAScript 5.</source>
          <target state="translated">如果你需要针对不支持ES6的浏览器,你可以通过Babel或closing-compiler运行代码,生成ECMAScript 5。</target>
        </trans-unit>
        <trans-unit id="3630077cc579c9376d3c4c87878034e415200376" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery&lt;/a&gt;, you can set the &lt;code&gt;async&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;. Note that this option is &lt;em&gt;deprecated&lt;/em&gt; since jQuery 1.8.
You can then either still use a &lt;code&gt;success&lt;/code&gt; callback or access the &lt;code&gt;responseText&lt;/code&gt; property of the &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/#jqXHR&quot;&gt;jqXHR object&lt;/a&gt;:</source>
          <target state="translated">如果使用&lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery&lt;/a&gt; ，则可以将 &lt;code&gt;async&lt;/code&gt; 选项设置为 &lt;code&gt;false&lt;/code&gt; 。 请注意，自jQuery 1.8起&lt;em&gt;不推荐使用&lt;/em&gt;此选项。 然后，您仍然可以使用 &lt;code&gt;success&lt;/code&gt; 回调或访问&lt;a href=&quot;http://api.jquery.com/jQuery.ajax/#jqXHR&quot;&gt;jqXHR对象&lt;/a&gt;的 &lt;code&gt;responseText&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="15eeba4207bfa4d204303f8eb467ce459a91861c" translate="yes" xml:space="preserve">
          <source>If you use any other jQuery Ajax method, such as &lt;code&gt;$.get&lt;/code&gt;, &lt;code&gt;$.getJSON&lt;/code&gt;, etc., you have to change it to &lt;code&gt;$.ajax&lt;/code&gt; (since you can only pass configuration parameters to &lt;code&gt;$.ajax&lt;/code&gt;).</source>
          <target state="translated">如果使用 &lt;code&gt;$.get&lt;/code&gt; ， &lt;code&gt;$.getJSON&lt;/code&gt; 等其他jQuery Ajax方法，则必须将其更改为 &lt;code&gt;$.ajax&lt;/code&gt; （因为只能将配置参数传递给 &lt;code&gt;$.ajax&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3c715363204b6b0c4a698fa23da4f0f9dc888e78" translate="yes" xml:space="preserve">
          <source>If you want to EXTEND the function...</source>
          <target state="translated">如果你想扩展功能......</target>
        </trans-unit>
        <trans-unit id="abe47fc3c57755c3997a845ee0b5aa49beefed3e" translate="yes" xml:space="preserve">
          <source>If you want to block the browser for a while load a nice big &lt;code&gt;.txt&lt;/code&gt; file synchronous.</source>
          <target state="translated">如果要阻止浏览器一段时间，请同步加载一个不错的大 &lt;code&gt;.txt&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="4e422421958cc1f0c9d4abcefec9c5f99bb57a7b" translate="yes" xml:space="preserve">
          <source>If you're &lt;em&gt;not&lt;/em&gt; using jQuery in your code, this answer is for you</source>
          <target state="translated">如果您&lt;em&gt;未&lt;/em&gt;在代码中使用jQuery，则此答案适合您</target>
        </trans-unit>
        <trans-unit id="ab8a1b500c194cbfba3513d7de0dea72d3a034e8" translate="yes" xml:space="preserve">
          <source>If you're still having a hard time understanding this &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&quot;&gt;read the AJAX getting started guide&lt;/a&gt; at MDN.</source>
          <target state="translated">如果您仍然难以理解，请&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&quot;&gt;阅读&lt;/a&gt; MDN上的AJAX入门指南 。</target>
        </trans-unit>
        <trans-unit id="18f9b9e612918f51948f6cc2126155b3c549bdae" translate="yes" xml:space="preserve">
          <source>If you're using promises, this answer is for you.</source>
          <target state="translated">如果你在使用承诺,这个答案是给你的。</target>
        </trans-unit>
        <trans-unit id="80fc972e4356d8ced60d608ce0baaf96427cd4b5" translate="yes" xml:space="preserve">
          <source>Imagine you make a phone call to a friend and ask him to look something up for you. Although it might take a while, you wait on the phone and stare into space, until your friend gives you the answer that you needed.</source>
          <target state="translated">想象一下,你给朋友打了个电话,让他帮你查点东西。虽然可能要花上一段时间,但你在电话里等着,盯着空间,直到你的朋友给出你需要的答案。</target>
        </trans-unit>
        <trans-unit id="ca8f184ee30d4a232f354261c37cbb9af43a876b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Angular2&lt;/code&gt; with look at the following example, but its &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html&quot;&gt;recommended&lt;/a&gt; to use &lt;code&gt;Observables&lt;/code&gt; with &lt;code&gt;Angular2&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Angular2&lt;/code&gt; 中 ，请看以下示例，但&lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html&quot;&gt;建议&lt;/a&gt;将 &lt;code&gt;Observables&lt;/code&gt; 与 &lt;code&gt;Angular2&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="9164c254eac90254b881079ff36f34d077268d4b" translate="yes" xml:space="preserve">
          <source>In ES7, this is further standardized, there are several proposals right now but in all of them you can &lt;code&gt;await&lt;/code&gt; promise. This is just &quot;sugar&quot; (nicer syntax) for the ES6 proposal above by adding the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; keywords. Making the above example:</source>
          <target state="translated">在ES7中，这是进一步标准化的，现在有几个建议，但是在所有建议中您都可以 &lt;code&gt;await&lt;/code&gt; 。 通过添加 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 关键字，这只是上述ES6提案的&amp;ldquo;糖&amp;rdquo;（更精细的语法）。 上面的例子：</target>
        </trans-unit>
        <trans-unit id="05677a4350495d3e2b8c6f4b68ebe3c7de4458e1" translate="yes" xml:space="preserve">
          <source>In broad, simplistic terms, the event loop is like the project manager, it is constantly listening for any functions that want to run and communicates between the queue and the stack.</source>
          <target state="translated">广义的、简单的说,事件循环就像项目经理一样,它不断地监听任何想要运行的函数,并在队列和堆栈之间进行沟通。</target>
        </trans-unit>
        <trans-unit id="cd02d6973d3ea865653a48e911c2e50a8c25776e" translate="yes" xml:space="preserve">
          <source>In my Code it is called as</source>
          <target state="translated">在我的代码中,它被称为</target>
        </trans-unit>
        <trans-unit id="5cb5ee146291e3428e4c2fcba91cef4c63579d3d" translate="yes" xml:space="preserve">
          <source>In short, synchronous requests block the execution of code... ...this can cause serious issues...</source>
          <target state="translated">简而言之,同步请求会阻止代码的执行...........这可能会导致严重的问题......</target>
        </trans-unit>
        <trans-unit id="c37241c1d0bfe0ae8498665ddda9cb54f035c670" translate="yes" xml:space="preserve">
          <source>In the above script, you have an error handler which is statically defined so it does not compromise the function. The error handler can be used for other functions too.</source>
          <target state="translated">在上面的脚本中,你有一个错误处理程序,这个错误处理程序是静态定义的,所以它不会影响到函数。这个错误处理程序也可以用于其他函数。</target>
        </trans-unit>
        <trans-unit id="1fee4a9e013a60a7958cc7ec190286ed94e8f8f3" translate="yes" xml:space="preserve">
          <source>In the case of our milk and coffee, we design &lt;code&gt;order_milk&lt;/code&gt; to return a promise for the milk arriving, then specify &lt;code&gt;put_in_coffee&lt;/code&gt; as a &lt;code&gt;then&lt;/code&gt; action, as follows:</source>
          <target state="translated">对于我们的牛奶和咖啡，我们设计 &lt;code&gt;order_milk&lt;/code&gt; 以返回牛奶到达的承诺，然后将 &lt;code&gt;put_in_coffee&lt;/code&gt; 指定为 &lt;code&gt;then&lt;/code&gt; 操作，如下所示：</target>
        </trans-unit>
        <trans-unit id="a9724168875ccef827ffb62e3e3dac4f3c469e74" translate="yes" xml:space="preserve">
          <source>In the error response, there are no error codes.</source>
          <target state="translated">在错误回复中,没有错误代码。</target>
        </trans-unit>
        <trans-unit id="1a6a81cb0fe27a1ef73a694660e522eaf40baa80" translate="yes" xml:space="preserve">
          <source>In the example of the question, you can make &lt;code&gt;foo&lt;/code&gt; accept a callback and use it as &lt;code&gt;success&lt;/code&gt; callback. So this</source>
          <target state="translated">在问题的示例中，您可以使 &lt;code&gt;foo&lt;/code&gt; 接受回调并将其用作 &lt;code&gt;success&lt;/code&gt; 回调。 所以这</target>
        </trans-unit>
        <trans-unit id="f64c26e8bf33e53e89ffa065ce2af5f6dae03e32" translate="yes" xml:space="preserve">
          <source>In the first case the error is inside the &lt;code&gt;displayAjax()&lt;/code&gt; under &lt;code&gt;this.statusText&lt;/code&gt; as &lt;code&gt;Method not Allowed&lt;/code&gt;.</source>
          <target state="translated">在第一种情况下，错误是在 &lt;code&gt;this.statusText&lt;/code&gt; 下的 &lt;code&gt;displayAjax()&lt;/code&gt; 内部，因为 &lt;code&gt;Method not Allowed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fe42b9b5d9a878fe339729448805008fb45dfb5" translate="yes" xml:space="preserve">
          <source>In the following we will look at three different solutions that are all building on top of each other:</source>
          <target state="translated">下面我们就来看看这三种不同的解决方案,都是建立在对方的基础上的。</target>
        </trans-unit>
        <trans-unit id="ffdebc5331a7e7297d48ecb0f27d85f259e2d630" translate="yes" xml:space="preserve">
          <source>In the second case, it simply works. You have to check at the server side if you passed the right post data.</source>
          <target state="translated">在第二种情况下,简单的说就是可以。你必须在服务器端检查你是否通过了正确的帖子数据。</target>
        </trans-unit>
        <trans-unit id="0f588f48cb190b6ff210dbc0bc1dc76feaba12bc" translate="yes" xml:space="preserve">
          <source>In this case, we could rewrite the code in the question as:</source>
          <target state="translated">在这种情况下,我们可以将问题中的代码改写为。</target>
        </trans-unit>
        <trans-unit id="8e5bc1f12b6bd30221b97d821033adfc0819696f" translate="yes" xml:space="preserve">
          <source>In your case, you would be able to write something like</source>
          <target state="translated">在你的情况下,你可以写出如下内容</target>
        </trans-unit>
        <trans-unit id="5ae61ff136e6d353245434234270f433244231c2" translate="yes" xml:space="preserve">
          <source>Instead of waiting for the response, the execution continues immediately and the statement after the Ajax call is executed. To get the response eventually, you provide a function to be called once the response was received, a &lt;em&gt;callback&lt;/em&gt; (notice something? &lt;em&gt;call back&lt;/em&gt; ?). Any statement coming after that call is executed before the callback is called.</source>
          <target state="translated">无需等待响应，而是立即继续执行，并执行Ajax调用后的语句。 为了最终获得响应，您提供了一个在收到响应后立即调用的函数，即&lt;em&gt;回调&lt;/em&gt;函数（注意什么？ &lt;em&gt;回叫&lt;/em&gt; ？）。 在调用之后执行的所有语句都将在调用回调之前执行。</target>
        </trans-unit>
        <trans-unit id="5a176ccd898f71da5498417dd981558178ba5429" translate="yes" xml:space="preserve">
          <source>Is a function that returns an &lt;em&gt;iterator&lt;/em&gt; over the sequence &lt;code&gt;1,2,3,3,3,3,....&lt;/code&gt; which can be iterated. While this is interesting on its own and opens room for a lot of possibility there is one particular interesting case.</source>
          <target state="translated">是一个函数，该函数返回可以&lt;em&gt;迭代&lt;/em&gt;的序列 &lt;code&gt;1,2,3,3,3,3,....&lt;/code&gt; 的迭代器。 尽管这本身很有趣，并且为很多可能性打开了空间，但是有一个特别有趣的案例。</target>
        </trans-unit>
        <trans-unit id="3bfc5cd8986cc4b5d384c982f8dbec35078eb9aa" translate="yes" xml:space="preserve">
          <source>It still returns a promise just the same :)</source>
          <target state="translated">它仍然会返回一个承诺,只是同样的承诺:)</target>
        </trans-unit>
        <trans-unit id="ef1f71df2861c22e656b28c20ac85577923d64df" translate="yes" xml:space="preserve">
          <source>It supported all *modern browsers. And I can confirm as I'm using this approach since XMLHttpRequest 2 exists. I never had any type of problem on all browsers I use.</source>
          <target state="translated">它支持所有*现代的浏览器。我可以确认,因为我使用这种方法,因为XMLHttpRequest 2的存在。我在我使用的所有浏览器上都没有遇到过任何问题。</target>
        </trans-unit>
        <trans-unit id="72465754e74ca9abdcff6be99e29d6961cffe62f" translate="yes" xml:space="preserve">
          <source>It uses the new onload (so you don't have to check for readystate &amp;amp;&amp;amp; status)</source>
          <target state="translated">它使用新的onload（因此您不必检查readystate和＆状态）</target>
        </trans-unit>
        <trans-unit id="dc11dae9acba94421bf901ebfd0a99a469f66bba" translate="yes" xml:space="preserve">
          <source>It's a very common issue we face while struggling with the 'mysteries' of JavaScript. Let me try demystifying this mystery today.</source>
          <target state="translated">这是我们在纠结于JavaScript的 &quot;奥秘 &quot;时,面临的一个很常见的问题。今天让我来试着解开这个谜团。</target>
        </trans-unit>
        <trans-unit id="ad52914796d378e861e608f5f5c6f3f574df3d10" translate="yes" xml:space="preserve">
          <source>It's easier to write code using callbacks than it may seem. After all, JavaScript in the browser is heavily event driven (DOM events). Receiving the Ajax response is nothing else but an event.</source>
          <target state="translated">使用回调编写代码比看起来更容易。毕竟,浏览器中的JavaScript在很大程度上是由事件驱动的(DOM事件)。接收Ajax响应,除了事件之外,其他都是无所谓。</target>
        </trans-unit>
        <trans-unit id="cdbb5508c06d9ebb504456c083faa19b12343a7a" translate="yes" xml:space="preserve">
          <source>It's shorter than all other functions Listed.</source>
          <target state="translated">它比所有其他功能都要短。</target>
        </trans-unit>
        <trans-unit id="dfa79b24d359ed76614774ecdc6d3f1f1fedbc1b" translate="yes" xml:space="preserve">
          <source>JavaScript runs in the UI thread of the browser and any long-running process will lock the UI, making it unresponsive. Additionally, there is an upper limit on the execution time for JavaScript and the browser will ask the user whether to continue the execution or not.</source>
          <target state="translated">JavaScript在浏览器的UI线程中运行,任何长时间运行的进程都会锁定UI,使其无响应。另外,JavaScript的执行时间有一个上限,浏览器会询问用户是否继续执行。</target>
        </trans-unit>
        <trans-unit id="e2b5e177110c45130bd6de8833741d43ceee63e1" translate="yes" xml:space="preserve">
          <source>Javscript.info callback</source>
          <target state="translated">Javscript.info回调</target>
        </trans-unit>
        <trans-unit id="bbbd4891d7699a852c6406a296c2fcf52f3c3e57" translate="yes" xml:space="preserve">
          <source>Js is a single threaded.</source>
          <target state="translated">Js是单线程的。</target>
        </trans-unit>
        <trans-unit id="e54a9bcf7595f53be50f3d461e5136cdeac9c123" translate="yes" xml:space="preserve">
          <source>Keep in mind that promises and deferred objects are just &lt;em&gt;containers&lt;/em&gt; for a future value, they are not the value itself. For example, suppose you had the following:</source>
          <target state="translated">请记住，承诺和递延对象只是将来价值的&lt;em&gt;容器&lt;/em&gt; ，它们不是价值本身。 例如，假设您具有以下内容：</target>
        </trans-unit>
        <trans-unit id="a450dc9bb252815e0a34be6965a19e24021fbb40" translate="yes" xml:space="preserve">
          <source>Let functions accept &lt;em&gt;callbacks&lt;/em&gt;</source>
          <target state="translated">让函数接受&lt;em&gt;回调&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5142ad643e1ca5f1c54df798209cf3a4e972be1a" translate="yes" xml:space="preserve">
          <source>Let suppose our serverRequest() function had a return statement in a code, when we get back data from server Web API will push it in queue at the end of queue.
As it get pushed at end in queue we cannot utilise its data as there is no function left in our queue to utilise this data.&lt;strong&gt;Thus it is not possible to return something from Async Call.&lt;/strong&gt;</source>
          <target state="translated">假设我们的serverRequest（）函数在代码中有一个return语句，当我们从服务器Web API取回数据时，它将在队列末尾将其压入队列。 由于它在队列末尾被推送，因此我们无法利用其数据，因为队列中没有剩余功能可以利用此数据。 &lt;strong&gt;因此，不可能从异步调用返回某些内容。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29816c85c3b63dc23d798455274fc320da92a3db" translate="yes" xml:space="preserve">
          <source>Let your function accept a callback. In the example code &lt;code&gt;foo&lt;/code&gt; can be made to accept a callback. We'll be telling our code how to &lt;em&gt;react&lt;/em&gt; when &lt;code&gt;foo&lt;/code&gt; completes.</source>
          <target state="translated">让您的函数接受回调。 在示例代码中，可以使 &lt;code&gt;foo&lt;/code&gt; 接受回调。 我们将告诉我们的代码，当 &lt;code&gt;foo&lt;/code&gt; 完成时如何&lt;em&gt;反应&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b907de8cd2ea70a0a07b7b3951542f8bc4bf8bc" translate="yes" xml:space="preserve">
          <source>Let's apply promises to your particular problem. We will wrap our request logic inside a function, which returns a promise:</source>
          <target state="translated">让我们将承诺应用到你的特定问题上。我们将把我们的请求逻辑封装在一个函数中,返回一个承诺。</target>
        </trans-unit>
        <trans-unit id="d30dd5f759cc5533cfc4d9a5b1b61f8383c8dbb1" translate="yes" xml:space="preserve">
          <source>Let's ask our function for a &lt;strong&gt;PROMISE&lt;/strong&gt;.
Promise is really about what it means : it means that the function guarantees you to provide with any output it gets in future. so let's see it in action for our little problem above :</source>
          <target state="translated">让我们问一下函数&lt;strong&gt;PROMISE&lt;/strong&gt; 。 Promise确实是关于它的含义：它意味着该函数保证您提供将来获得的任何输出。 因此，让我们来看一下上面的小问题：</target>
        </trans-unit>
        <trans-unit id="f03473dc33a9b7108d06e897d4c147d809acee67" translate="yes" xml:space="preserve">
          <source>Let's see how we can solve the above issue with promises. First, let's demonstrate our understanding of promise states from above by using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise&quot;&gt;Promise constructor&lt;/a&gt; for creating a delay function:</source>
          <target state="translated">让我们看看如何用诺言解决上述问题。 首先，让我们通过使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise&quot;&gt;Promise构造函数&lt;/a&gt;创建延迟函数来从上面说明对承诺状态的理解：</target>
        </trans-unit>
        <trans-unit id="097a1fd4f4dd6ae948cf296ebf5e3fed29d827b1" translate="yes" xml:space="preserve">
          <source>Let's start with a simple JavaScript function:</source>
          <target state="translated">让我们从一个简单的JavaScript函数开始。</target>
        </trans-unit>
        <trans-unit id="012b3ad7e2336b480f233ac7230671a56ff96505" translate="yes" xml:space="preserve">
          <source>Lets first enable JQuery usage, to have &lt;code&gt;$&lt;/code&gt; available as &lt;code&gt;S&lt;/code&gt;:</source>
          <target state="translated">首先启用JQuery用法，使 &lt;code&gt;$&lt;/code&gt; 可以用作 &lt;code&gt;S&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3ac2a3b85bfb179de3d5fd9a6d1778a34a10d96e" translate="yes" xml:space="preserve">
          <source>Make the AJAX call synchronous (lets call it SJAX).</source>
          <target state="translated">使AJAX调用同步(让我们称它为SJAX)。</target>
        </trans-unit>
        <trans-unit id="4149f095bdea0d897f44292f13870fb2ca675c68" translate="yes" xml:space="preserve">
          <source>More examples here: &lt;a href=&quot;https://github.com/amaksr/nsynjs/tree/master/examples&quot;&gt;https://github.com/amaksr/nsynjs/tree/master/examples&lt;/a&gt;</source>
          <target state="translated">此处有更多示例： &lt;a href=&quot;https://github.com/amaksr/nsynjs/tree/master/examples&quot;&gt;https&lt;/a&gt; : //github.com/amaksr/nsynjs/tree/master/examples</target>
        </trans-unit>
        <trans-unit id="416843538915a12d446291b1a92446755e1f2268" translate="yes" xml:space="preserve">
          <source>More information about promises: &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;HTML5 rocks - JavaScript Promises&lt;/a&gt;</source>
          <target state="translated">有关诺言的更多信息： &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;HTML5摇滚-JavaScript Promises&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25f50452665d503e55acf0b8c965da53f9e2eb1f" translate="yes" xml:space="preserve">
          <source>Most of the answers here give useful suggestions for when you have a single async operation, but sometimes, this comes up when you need to do an asynchronous operation for &lt;em&gt;each&lt;/em&gt; entry in an array or other list-like structure. The temptation is to do this:</source>
          <target state="translated">此处的大多数答案都会为您提供单个异步操作的有用建议，但是有时，当您需要对数组或其他类似列表的结构中的&lt;em&gt;每个&lt;/em&gt;条目执行异步操作时，就会出现这种建议。 诱惑是这样做的：</target>
        </trans-unit>
        <trans-unit id="7ace0f986a8d32fe40488522b23a55438cb0b782" translate="yes" xml:space="preserve">
          <source>Not recommended: Synchronous &quot;Ajax&quot; calls</source>
          <target state="translated">不建议使用。同步 &quot;Ajax &quot;调用</target>
        </trans-unit>
        <trans-unit id="a3266b1005a3a1afba35c5209761885a8ad47be3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Promise.all&lt;/code&gt; resolves its promise with an array of the results of all of the promises you give it when they are all resolved, or rejects its promise when the &lt;em&gt;first&lt;/em&gt; of the promises you give it rejects.</source>
          <target state="translated">请注意， &lt;code&gt;Promise.all&lt;/code&gt; 会在解决所有诺言时提供给您的所有诺​​言的结果数组来解决其诺言，或者在您给它的&lt;em&gt;第一个&lt;/em&gt;诺言被拒绝时拒绝其诺言。</target>
        </trans-unit>
        <trans-unit id="ce6df39941058908a0b980171b83775c7db609fa" translate="yes" xml:space="preserve">
          <source>Note that the call to &lt;code&gt;foo()&lt;/code&gt; will still return nothing useful. However, the result of the async call will now be stored in &lt;code&gt;result.response&lt;/code&gt;.</source>
          <target state="translated">请注意，对 &lt;code&gt;foo()&lt;/code&gt; 的调用仍然不会返回任何有用的信息。 但是，异步调用的结果现在将存储在 &lt;code&gt;result.response&lt;/code&gt; 中 。</target>
        </trans-unit>
        <trans-unit id="d9c2dea7d7e7a3411da1773762e08918f5674124" translate="yes" xml:space="preserve">
          <source>Nothing easier.</source>
          <target state="translated">没有比这更容易的了。</target>
        </trans-unit>
        <trans-unit id="353e455e2b68dea72cd422384a4b460cd47300c4" translate="yes" xml:space="preserve">
          <source>Notice how we use the &lt;code&gt;index&lt;/code&gt; from &lt;code&gt;forEach&lt;/code&gt; to save the result in &lt;code&gt;results&lt;/code&gt; in the same position as the entry it relates to, even if the results arrive out of order (since async calls don't necessarily complete in the order in which they were started).</source>
          <target state="translated">注意，我们如何使用 &lt;code&gt;forEach&lt;/code&gt; 中的 &lt;code&gt;index&lt;/code&gt; 将结果保存在与它相关的条目相同的位置中，即使结果到达的顺序不正确（因为异步调用不一定按开始的顺序完成） ）。</target>
        </trans-unit>
        <trans-unit id="929ed6885fc0b5c2a602a91186d7a6db6f5f8584" translate="yes" xml:space="preserve">
          <source>Now if you want something more complex using post and FormData you can easily extend this function:</source>
          <target state="translated">现在,如果你想用post和FormData来做更复杂的事情,你可以很容易地扩展这个功能。</target>
        </trans-unit>
        <trans-unit id="d974961b0a397dae3ab443eb46237547fe41139f" translate="yes" xml:space="preserve">
          <source>Now let us think we pushed two functions in a queue one is for getting a data from server and another utilises that data.We pushed the serverRequest() function in queue first then utiliseData() function. serverRequest function goes in event loop and makes a call to server as we never know how much time it will take to get data from server
so this process is expected to take time and so we busy our event loop thus hanging our page, that's where Web API come into role it take this function from event loop and deals with server making event loop free so that we can execute next function from queue.The next function in queue is utiliseData() which goes in loop but because of no data available it goes waste and execution of next function continues till end of the queue.(This is called Async calling i.e we can do something else till we get data)</source>
          <target state="translated">现在让我们想想,我们在队列中推送两个函数,一个是用来从服务器获取数据,另一个是利用数据。serverRequest函数进入事件循环,并对服务器进行调用,因为我们永远不知道从服务器获取数据需要多少时间,所以这个过程预计需要时间,所以我们的事件循环会很忙,这样我们的页面就会被挂起,这就是Web API的作用,它把这个函数从事件循环中拿出来,处理服务器,使事件循环不受影响,这样我们就可以从队列中执行下一个函数。 队列中的下一个函数是utiliseData(),它进入循环,但由于没有数据可用,它就会被浪费掉,下一个函数的执行会一直持续到队列结束。</target>
        </trans-unit>
        <trans-unit id="e0a63d4292a004be42ee890cb652815050847bb1" translate="yes" xml:space="preserve">
          <source>Now let's add a bit of twist, by introducing little delay in our function, so that all lines of code are not 'finished' in sequence. Thus, it will emulate the asynchronous behavior of function :</source>
          <target state="translated">现在,让我们在函数中引入小的延迟,使所有的代码行都不是依次 &quot;完成&quot;。这样,它将模拟函数.NET的异步行为。</target>
        </trans-unit>
        <trans-unit id="42c38f982e0c169feb7e086aabc21246bff1aad8" translate="yes" xml:space="preserve">
          <source>Now some people will probably say that it's better to use onreadystatechange or the even the XMLHttpRequest variable name. That's wrong.</source>
          <target state="translated">现在有的人可能会说,最好是用onreadystatechange或者甚至XMLHttpRequest变量名。这是不对的。</target>
        </trans-unit>
        <trans-unit id="a2fab3eea51d1e71a6c436e1f5c97b56ccdd5071" translate="yes" xml:space="preserve">
          <source>Now you can do</source>
          <target state="translated">现在,你可以做</target>
        </trans-unit>
        <trans-unit id="da89b3c0dfa9111f27c794ec1b03edd3bdfde2dd" translate="yes" xml:space="preserve">
          <source>Now, after we converted setTimeout to use promises, we can use &lt;code&gt;then&lt;/code&gt; to make it count:</source>
          <target state="translated">现在，在将setTimeout转换为使用Promise之后，可以使用 &lt;code&gt;then&lt;/code&gt; 进行计数：</target>
        </trans-unit>
        <trans-unit id="8914db3fb9a1d0494f5a0d8fd668ced73c34d069" translate="yes" xml:space="preserve">
          <source>Now, let's define foo itself to act accordingly</source>
          <target state="translated">现在,让我们来定义一下foo本身,让其相应的行动。</target>
        </trans-unit>
        <trans-unit id="99be19d54cf7652a1615ab27cbc8bbf0aed5749c" translate="yes" xml:space="preserve">
          <source>Nsynjs will evaluate all operators and expressions step-by-step, pausing execution in case if result of some slow function is not ready.</source>
          <target state="translated">Nsynjs将逐步评估所有的运算符和表达式,如果某些慢函数的结果还没有准备好,则暂停执行。</target>
        </trans-unit>
        <trans-unit id="5a64163c890c0896f46f25e78ce25b037738ed57" translate="yes" xml:space="preserve">
          <source>Of course there are many approaches like synchronous request, promise, but from my experience I think you should use the callback approach. It's natural to asynchronous behavior of Javascript.
So, your code snippet can be rewrite a little different:</source>
          <target state="translated">当然有很多方法,比如同步请求、承诺,但根据我的经验,我认为你应该使用回调的方法。这对Javascript的异步行为是很自然的。所以,你的代码片段可以改写得稍微不一样。</target>
        </trans-unit>
        <trans-unit id="2e78929c9a21094861197c3ba952c175f274cc77" translate="yes" xml:space="preserve">
          <source>Once it receives a message to run something it adds it to the queue. The queue is the list of things that are waiting to execute (like your AJAX request). imagine it like this:</source>
          <target state="translated">一旦它收到要运行的消息,就会将其添加到队列中。队列是等待执行的事情的列表(比如你的AJAX请求)。</target>
        </trans-unit>
        <trans-unit id="9d39748eb9ce2dc97c87c582527e55724204f745" translate="yes" xml:space="preserve">
          <source>One advantage of this is that we can string these together to create sequences of future occurrences (&quot;chaining&quot;):</source>
          <target state="translated">这样做的一个好处是,我们可以把这些东西串在一起,创建未来发生的序列(&quot;链式&quot;)。</target>
        </trans-unit>
        <trans-unit id="54016dfcceb363844e7cc4be09ec8ae272d45106" translate="yes" xml:space="preserve">
          <source>One possible solution to this problem is to code &lt;em&gt;re-actively&lt;/em&gt; , telling your program what to do when the calculation completed.</source>
          <target state="translated">解决此问题的一种可能方法是重新编写代码，告诉您的程序在完成计算后要做什么。</target>
        </trans-unit>
        <trans-unit id="6a68116dc884c578869074c6236313ddd089faa1" translate="yes" xml:space="preserve">
          <source>One possible solution to this problem is to code &lt;em&gt;re-actively&lt;/em&gt; , telling your program what to do when the calculation completed. Promises actively enable this by being temporal (time-sensitive) in nature.</source>
          <target state="translated">解决此问题的一种可能方法是重新编写代码，告诉您的程序在完成计算后要做什么。 承诺本质上是时间（时间敏感）的，因此可以积极地实现这一点。</target>
        </trans-unit>
        <trans-unit id="e3fe8189fb8e3a9175a9246ff74a29655859c5dc" translate="yes" xml:space="preserve">
          <source>Only if you have a page where you load always the same XML/JSON or whatever you need only one function. In that case, modify a little the Ajax function and replace b with your special function.</source>
          <target state="translated">只有当你有一个页面总是加载相同的XMLJSON或其他什么你只需要一个函数。在这种情况下,修改一下Ajax函数,把b替换成你的特殊函数。</target>
        </trans-unit>
        <trans-unit id="5266da9d163f68f6d914c71fc5ace6c79a2e3aaa" translate="yes" xml:space="preserve">
          <source>Or (the above one is better anonymous functions are always a problem):</source>
          <target state="translated">或者说(上面一个是比较好的匿名功能总是一个问题)。</target>
        </trans-unit>
        <trans-unit id="7574e85e254349a76f9eb280b8d26c2fcd432db0" translate="yes" xml:space="preserve">
          <source>Or here's a version returning a &lt;code&gt;Promise&lt;/code&gt; instead:</source>
          <target state="translated">或以下是返回 &lt;code&gt;Promise&lt;/code&gt; 的版本：</target>
        </trans-unit>
        <trans-unit id="912172dfb14be8eb490ece32e4e426ffa381d626" translate="yes" xml:space="preserve">
          <source>Or if for some reason you &lt;code&gt;bind()&lt;/code&gt; the callback to a class:</source>
          <target state="translated">或者如果由于某种原因 &lt;code&gt;bind()&lt;/code&gt; 回调到一个类：</target>
        </trans-unit>
        <trans-unit id="97548c9db4d27ac2b95bbc49510f16af46cc2fde" translate="yes" xml:space="preserve">
          <source>Or pass a full form element (&lt;code&gt;document.getElementsByTagName('form')[0]&lt;/code&gt;):</source>
          <target state="translated">或传递一个完整的表单元素（ &lt;code&gt;document.getElementsByTagName('form')[0]&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="e22be26c55a52d473b9811210f17414624c87259" translate="yes" xml:space="preserve">
          <source>Or set some custom values:</source>
          <target state="translated">或者设置一些自定义值。</target>
        </trans-unit>
        <trans-unit id="68f819f1f89dc9e0529ac2892b6d2f288badbd02" translate="yes" xml:space="preserve">
          <source>Or the Promise syntax</source>
          <target state="translated">或者是Promise语法</target>
        </trans-unit>
        <trans-unit id="afc129571bf06499cb7e3b0ffe14106bdb906a2f" translate="yes" xml:space="preserve">
          <source>Parallel</source>
          <target state="translated">Parallel</target>
        </trans-unit>
        <trans-unit id="3768a1e6d49da0cac1c978e4121bcf5a453c81eb" translate="yes" xml:space="preserve">
          <source>Possible solutions</source>
          <target state="translated">可能的解决办法</target>
        </trans-unit>
        <trans-unit id="7bb1c6338f84ef633dbff9dc2ca5d6404721463d" translate="yes" xml:space="preserve">
          <source>Promises are containers for &lt;em&gt;future&lt;/em&gt; values. When the promise receives the value (it is &lt;em&gt;resolved&lt;/em&gt;) or when it is canceled (&lt;em&gt;rejected&lt;/em&gt;), it notifies all of its &quot;listeners&quot; who want to access this value.</source>
          <target state="translated">承诺是&lt;em&gt;未来&lt;/em&gt;价值的容器。 当promise接收到该值（已&lt;em&gt;解决&lt;/em&gt; ）或被取消（ &lt;em&gt;被拒绝&lt;/em&gt; ）时，它会通知要访问此值的所有&amp;ldquo;监听器&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8350b08167777968ab876b41274f64fe1318e1bf" translate="yes" xml:space="preserve">
          <source>Promises can be used to unnest asynchronous functions and allows one to chain multiple functions together.</source>
          <target state="translated">承诺可以用来取消异步函数,并允许一个人将多个函数链在一起。</target>
        </trans-unit>
        <trans-unit id="c32135d34ac0c0221572109c3dfc7f43a9751b94" translate="yes" xml:space="preserve">
          <source>Quick recap on promises</source>
          <target state="translated">关于承诺的快速回顾</target>
        </trans-unit>
        <trans-unit id="c235eb24c95a5e9981695eb449944a162b57ebf2" translate="yes" xml:space="preserve">
          <source>Rather than throwing code at you, there are 2 concepts that are key to understanding how JS handles callbacks and asynchronicity. (is that even a word?)</source>
          <target state="translated">与其把代码扔给你,不如说有2个概念是理解JS如何处理回调和异步的关键。(这甚至是一个词吗?)</target>
        </trans-unit>
        <trans-unit id="29bff7173029217e94f4afcceb94f3ce6f4a8162" translate="yes" xml:space="preserve">
          <source>Restructure your code to work properly with callbacks.</source>
          <target state="translated">重构你的代码,使之与回调正常工作。</target>
        </trans-unit>
        <trans-unit id="062f9fe8caa07becb814606e66f0cdd8c44eccb5" translate="yes" xml:space="preserve">
          <source>Return a Promise</source>
          <target state="translated">归还承诺</target>
        </trans-unit>
        <trans-unit id="da07fe527d40396d3dc18ff2bbee2077e9679bf6" translate="yes" xml:space="preserve">
          <source>Returning anything in the submit handler will not do anything. You must instead either hand off the data, or do what you want with it directly inside the success function.</source>
          <target state="translated">在提交处理程序中返回任何东西都不会起到任何作用。相反,你必须把数据交给别人,或者直接在成功函数中做你想做的事情。</target>
        </trans-unit>
        <trans-unit id="be64c83fb64f3829b56366e909fbacc0081629bd" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html&quot;&gt;original&lt;/a&gt; post here. But Typescript does not support &lt;a href=&quot;http://www.datchley.name/es6-promises/&quot;&gt;native es6 Promises&lt;/a&gt;, if you want to use it, you might need plugin for that.</source>
          <target state="translated">在此处查看&lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html&quot;&gt;原始&lt;/a&gt;帖子。 但是Typescript不支持&lt;a href=&quot;http://www.datchley.name/es6-promises/&quot;&gt;本机es6 Promises&lt;/a&gt; ，如果要使用它，可能需要插件。</target>
        </trans-unit>
        <trans-unit id="40c20d94e78fa142819df8cc9440d30e65329975" translate="yes" xml:space="preserve">
          <source>Series</source>
          <target state="translated">Series</target>
        </trans-unit>
        <trans-unit id="7e56c5c8aa16c1ef6db37ada8a6266e68cceb09e" translate="yes" xml:space="preserve">
          <source>Several solutions have been given in this thread. Perhaps the easiest way is to pass an object to the &lt;code&gt;foo()&lt;/code&gt; method, and to store the results in a member of that object after the async call completes.</source>
          <target state="translated">在该线程中已经给出了几种解决方案。 也许最简单的方法是将一个对象传递给 &lt;code&gt;foo()&lt;/code&gt; 方法，并在异步调用完成后将结果存储在该对象的成员中。</target>
        </trans-unit>
        <trans-unit id="2148a375d3f6b7a16b65d3a1f82733a29815e073" translate="yes" xml:space="preserve">
          <source>Short answer is, &lt;strong&gt;you have to implement a callback like this:&lt;/strong&gt;</source>
          <target state="translated">简短的答案是， &lt;strong&gt;您必须实现这样的回调：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">显示代码片段</target>
        </trans-unit>
        <trans-unit id="ff1c87cac36b81c6f91891fbd54132c4334c4e46" translate="yes" xml:space="preserve">
          <source>Side note: Promise gotchas</source>
          <target state="translated">侧面说明:承诺的问题</target>
        </trans-unit>
        <trans-unit id="05506c4ac3acb4d27c65c550acf4b39c197cd038" translate="yes" xml:space="preserve">
          <source>Side note: jQuery's deferred objects</source>
          <target state="translated">侧面说明:jQuery的递延对象</target>
        </trans-unit>
        <trans-unit id="fa5759978602e0fa347526198e20ed43cc048568" translate="yes" xml:space="preserve">
          <source>Simple usage example:</source>
          <target state="translated">简单的使用实例。</target>
        </trans-unit>
        <trans-unit id="4096759186b4f9723934ec713d75bc04761b5820" translate="yes" xml:space="preserve">
          <source>Since the operation did not happen yet (AJAX, server call, IO, timer) you're returning the value before the request got the chance to tell your code what that value is.</source>
          <target state="translated">由于操作还没有发生(AJAX、服务器调用、IO、定时器),所以在请求还没有机会告诉你的代码这个值是什么之前,你就返回了这个值。</target>
        </trans-unit>
        <trans-unit id="5a7e4ac52f20fc5994d25a70f507d562ec34a41e" translate="yes" xml:space="preserve">
          <source>So anything that foobarFunc needs to execute (in our case &lt;code&gt;anotherFunction&lt;/code&gt;) will get pushed onto the stack. executed, and then forgotten about - the event loop will then move onto the next thing in the queue (or listen for messages)</source>
          <target state="translated">因此，foobarFunc需要执行的所有操作（在我们的示例中为 &lt;code&gt;anotherFunction&lt;/code&gt; ）都将被压入堆栈。 执行，然后被遗忘-事件循环将移至队列中的下一件事（或侦听消息）</target>
        </trans-unit>
        <trans-unit id="4130aa961d9f8a1abff39f8f3f11e49af247d9a2" translate="yes" xml:space="preserve">
          <source>So i decided to implement my own Promise class for &lt;strong&gt;ES3 to below&lt;/strong&gt; js compilers if its not defined. Just add this code before your main code and then safely use Promise!</source>
          <target state="translated">因此，如果未定义&lt;strong&gt;ES3，&lt;/strong&gt;我决定为&lt;strong&gt;下面的&lt;/strong&gt; js编译器实现自己的Promise类。 只需在您的主要代码之前添加此代码，然后安全地使用Promise！</target>
        </trans-unit>
        <trans-unit id="519e6b95ba34166e61a9a33a9c6412ef034c0b19" translate="yes" xml:space="preserve">
          <source>So if you are using &lt;strong&gt;Angular, React&lt;/strong&gt; or any other frameworks which do &lt;strong&gt;two ways data binding&lt;/strong&gt; or &lt;strong&gt;store concept&lt;/strong&gt; this issue is simply fixed for you, so in easy word, your result is &lt;code&gt;undefined&lt;/code&gt; at the first stage, so you have got &lt;code&gt;result = undefined&lt;/code&gt; before you receive the data, then as soon as you get the result, it will be updated and get assigned to the new value which response of your Ajax call...</source>
          <target state="translated">因此，如果您使用的是&lt;strong&gt;Angular，React&lt;/strong&gt;或任何其他通过&lt;strong&gt;两种方式进行数据绑定&lt;/strong&gt;或&lt;strong&gt;存储概念的&lt;/strong&gt;框架，则此问题仅为您解决，因此，简单来说，您的结果在第一阶段是 &lt;code&gt;undefined&lt;/code&gt; 的，因此您得到了 &lt;code&gt;result = undefined&lt;/code&gt; 在您接收数据之前，一旦获得结果，它将被更新并分配给您的Ajax调用响应的新值...</target>
        </trans-unit>
        <trans-unit id="456834897466e279954c59b225ffcd0a611dc23f" translate="yes" xml:space="preserve">
          <source>So there you go, that delay just broke the functionality we expected! But what exactly happened ? Well, it's actually pretty logical if you look at the code. the function &lt;code&gt;foo()&lt;/code&gt;, upon execution, returns nothing (thus returned value is &lt;code&gt;undefined&lt;/code&gt;), but it does start a timer, which executes a function after 1s to return 'wohoo'. But as you can see, the value that's assigned to bar is the immediately returned stuff from foo(), which is nothing i.e. just &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">这样一来，延迟就破坏了我们期望的功能！ 但是到底发生了什么？ 好吧，如果您看一下代码，这实际上是很合逻辑的。 函数 &lt;code&gt;foo()&lt;/code&gt; 在执行时不返回任何内容（因此返回的值是 &lt;code&gt;undefined&lt;/code&gt; ），但是它确实启动了计时器，该计时器在1秒后执行一个函数以返回&amp;ldquo; wohoo&amp;rdquo;。 但是正如您所看到的，分配给bar的值是foo（）立即返回的内容，它什么也没有，就是 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ebd3c140905d6a71bb22361b04f8129d104582a" translate="yes" xml:space="preserve">
          <source>So this works just as well. We've learned we can't return values from already asynchronous calls but we can use promises and chain them to perform processing. We now know how to return the response from an asynchronous call.</source>
          <target state="translated">所以这个也是一样可以的。我们已经知道了我们不能从已经的异步调用中返回值,但我们可以使用承诺并将其链式化来执行处理。现在我们知道了如何从异步调用中返回响应。</target>
        </trans-unit>
        <trans-unit id="16474dcce86aac08469b81e9bbfe841fd4c01c7d" translate="yes" xml:space="preserve">
          <source>So what you need to do is pass a function that is promised to execute at some point with data that is passed to it.</source>
          <target state="translated">所以,你需要做的是传递一个函数,承诺在某个时间点用传递给它的数据来执行。</target>
        </trans-unit>
        <trans-unit id="0efce20ff147121d241f07ae7346392a017a7c29" translate="yes" xml:space="preserve">
          <source>So, if you have an array (or list of some kind) and want to do async operations for each entry, you have two options: Do the operations in parallel (overlapping), or in series (one after another in sequence).</source>
          <target state="translated">所以,如果你有一个数组(或某种类型的列表),并想对每个条目进行异步操作,你有两个选择。并行(重叠)或串联(按顺序一个接一个地进行操作)。</target>
        </trans-unit>
        <trans-unit id="4549b38f6f564b62d621d5aaa8f137985559a5b5" translate="yes" xml:space="preserve">
          <source>So, you to run the following example you need to put your access token in the request headers:</source>
          <target state="translated">所以,要运行下面的例子,你需要把你的访问令牌放在请求头中。</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="b9a422a9be9b2bc191da989656816034a1f6eee5" translate="yes" xml:space="preserve">
          <source>So: No need for error checks if you're able to copy and paste the URL properly. ;)</source>
          <target state="translated">所以。如果你能正确地复制和粘贴URL,就不需要进行错误检查。)</target>
        </trans-unit>
        <trans-unit id="958cd629e68ed77d9824bb75c9b43a7f1cf49e0a" translate="yes" xml:space="preserve">
          <source>Solution(s)</source>
          <target state="translated">Solution(s)</target>
        </trans-unit>
        <trans-unit id="9dbffa1e0ccfddb501d678c507c62423968b4d1e" translate="yes" xml:space="preserve">
          <source>Step 1. Wrap function with callback into nsynjs-aware wrapper (if it has promisified version, you can skip this step):</source>
          <target state="translated">步骤1.将带回调的函数封装到nsynjs-aware wrapper中(如果它有承诺版,可以跳过这一步)。</target>
        </trans-unit>
        <trans-unit id="fcdabda0acdbf7ed77f27dcb6841a85fbda15814" translate="yes" xml:space="preserve">
          <source>Step 2. Put synchronous logic into function:</source>
          <target state="translated">第2步。将同步逻辑放入功能中。</target>
        </trans-unit>
        <trans-unit id="80eb86c9950baf665d77b6ad1ffb913a4fa504e2" translate="yes" xml:space="preserve">
          <source>Step 3. Run function in synchronous manner via nsynjs:</source>
          <target state="translated">第3步:通过nsynjs同步运行函数。通过nsynjs同步运行函数。</target>
        </trans-unit>
        <trans-unit id="e79e3d8d02a013d89691c298f6bd299451c74b8a" translate="yes" xml:space="preserve">
          <source>Suppose you don't want the operations to be in parallel? If you want to run them one after another, you need to wait for each operation to complete before you start the next. Here's an example of a function that does that and calls a callback with the result:</source>
          <target state="translated">假设你不想让这些操作并行运行?如果你想一个接一个地运行,你需要等待每个操作完成后再开始下一个操作。这里有一个函数的例子,它就是这样做的,然后用结果调用回调。</target>
        </trans-unit>
        <trans-unit id="77c61919f7c0335c38d9155372ee85055a736cc1" translate="yes" xml:space="preserve">
          <source>Synchronous</source>
          <target state="translated">Synchronous</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">就是说:</target>
        </trans-unit>
        <trans-unit id="9111ae84fd392e9454be6a96907483945425e257" translate="yes" xml:space="preserve">
          <source>That's a simple synchronous function call (where each line of code is 'finished with its job' before the next one in sequence), and the result is same as expected.</source>
          <target state="translated">那是一个简单的同步函数调用(每一行代码都是在下一行代码之前 &quot;完成任务&quot;),结果和预期的一样。</target>
        </trans-unit>
        <trans-unit id="6dadcf5d4da4a50438dd8a46454bbf9f5c8a3d23" translate="yes" xml:space="preserve">
          <source>That's exactly what's happening when you do an Ajax request.</source>
          <target state="translated">这正是你做Ajax请求时的情况。</target>
        </trans-unit>
        <trans-unit id="c7cfbaca7087cb7a7879162ad5a4e04b1f217824" translate="yes" xml:space="preserve">
          <source>That's why with asynchronous functionality we use things called &lt;strong&gt;callbacks&lt;/strong&gt;. It's kinda like a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;promise&lt;/a&gt; quite literally. As in I &lt;em&gt;promise to return something at some point&lt;/em&gt; jQuery uses specific callbacks called &lt;code&gt;deffered.done&lt;/code&gt;&lt;code&gt;deffered.fail&lt;/code&gt; and &lt;code&gt;deffered.always&lt;/code&gt; (amongst others). You can see them all &lt;a href=&quot;https://api.jquery.com/category/deferred-object/&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">这就是为什么在异步功能中我们使用了称为&lt;strong&gt;callbacks的&lt;/strong&gt;东西。 从字面上看，这有点像一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;承诺&lt;/a&gt; 。 就像我&lt;em&gt;承诺在某个时候返回某些内容一样，&lt;/em&gt; jQuery使用了称为 &lt;code&gt;deffered.done&lt;/code&gt; &lt;code&gt;deffered.fail&lt;/code&gt; 和 &lt;code&gt;deffered.always&lt;/code&gt; 的特定回调（以及其他）。 你可以&lt;a href=&quot;https://api.jquery.com/category/deferred-object/&quot;&gt;在这里&lt;/a&gt;看到他们</target>
        </trans-unit>
        <trans-unit id="15bb754ff5cde7f28dcd0bb70e024c67cb821f55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise API&lt;/a&gt; is a new feature of ECMAScript 6 (ES2015), but it has good &lt;a href=&quot;http://caniuse.com/#feat=promises&quot;&gt;browser support&lt;/a&gt; already. There are also many libraries which implement the standard Promises API and provide additional methods to ease the use and composition of asynchronous functions (e.g. &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;bluebird&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise API&lt;/a&gt;是ECMAScript 6（ES2015）的新功能，但已经具有良好的&lt;a href=&quot;http://caniuse.com/#feat=promises&quot;&gt;浏览器支持&lt;/a&gt; 。 还有许多实现标准Promises API的库，并提供其他方法来简化异步函数（例如&lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;bluebird&lt;/a&gt; ）的使用和组合。</target>
        </trans-unit>
        <trans-unit id="8863ecce1e4cf6263ca3b1bcde858dda65b7c8db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 关键字</target>
        </trans-unit>
        <trans-unit id="eb35c6a9a9151152e061add9aab9caeda5223463" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;A&lt;/strong&gt; in &lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;Ajax&lt;/a&gt; stands for &lt;a href=&quot;https://www.merriam-webster.com/dictionary/asynchronous&quot;&gt;&lt;strong&gt;asynchronous&lt;/strong&gt;&lt;/a&gt; . That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, &lt;code&gt;$.ajax&lt;/code&gt; returns immediately and the next statement, &lt;code&gt;return result;&lt;/code&gt;, is executed before the function you passed as &lt;code&gt;success&lt;/code&gt; callback was even called.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;Ajax中&lt;/a&gt;的&lt;strong&gt;A&lt;/strong&gt;代表&lt;a href=&quot;https://www.merriam-webster.com/dictionary/asynchronous&quot;&gt;&lt;strong&gt;异步&lt;/strong&gt;&lt;/a&gt; 。 这意味着发送请求（或更确切地说接收响应）已从正常执行流程中删除。 在您的示例中， &lt;code&gt;$.ajax&lt;/code&gt; 立即返回，下一条语句 &lt;code&gt;return result;&lt;/code&gt; 会在调用 &lt;code&gt;success&lt;/code&gt; 回调函数之前执行。</target>
        </trans-unit>
        <trans-unit id="fd66ac85793821d3ff7fcc5fd0246ae36ee7397a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;A&lt;/strong&gt; in AJAX stands for &lt;strong&gt;asynchronous&lt;/strong&gt;. That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29&quot;&gt;&lt;code&gt;.send&lt;/code&gt;&lt;/a&gt; returns immediately and the next statement, &lt;code&gt;return result;&lt;/code&gt;, is executed before the function you passed as &lt;code&gt;success&lt;/code&gt; callback was even called.</source>
          <target state="translated">AJAX中的&lt;strong&gt;A&lt;/strong&gt;代表&lt;strong&gt;异步&lt;/strong&gt; 。 这意味着发送请求（或更确切地说接收响应）已从正常执行流程中删除。 在您的示例中， &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29&quot;&gt; &lt;code&gt;.send&lt;/code&gt; &lt;/a&gt;立即返回，下一条语句 &lt;code&gt;return result;&lt;/code&gt; 会在调用 &lt;code&gt;success&lt;/code&gt; 回调函数之前执行。</target>
        </trans-unit>
        <trans-unit id="16490f52af9e1a9f1fc6768f3e186d1abc950e53" translate="yes" xml:space="preserve">
          <source>The ECMAScript version released in 2017 introduced &lt;em&gt;syntax-level support&lt;/em&gt; for asynchronous functions. With the help of &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;, you can write asynchronous in a &quot;synchronous style&quot;. The code is still asynchronous, but it's easier to read/understand.</source>
          <target state="translated">2017年发布的ECMAScript版本引入了对异步功能的&lt;em&gt;语法级支持&lt;/em&gt; 。 借助 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; ，您可以以&amp;ldquo;同步样式&amp;rdquo;编写异步。 该代码仍然是异步的，但更易于阅读/理解。</target>
        </trans-unit>
        <trans-unit id="ecce31767a1b5e77be58da7962c0d01b010e4473" translate="yes" xml:space="preserve">
          <source>The JavaScript concurrency model in the browser and on the server with NodeJS/io.js is &lt;em&gt;asynchronous&lt;/em&gt; and &lt;em&gt;reactive&lt;/em&gt;.</source>
          <target state="translated">浏览器和带有NodeJS / io.js的服务器上的JavaScript并发模型是&lt;em&gt;异步的&lt;/em&gt;和&lt;em&gt;响应式的&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca67c883bbbb71564bf5ac5f9cf7f2adffad99d0" translate="yes" xml:space="preserve">
          <source>The advantage over plain callbacks is that they allow you to decouple your code and they are easier to compose.</source>
          <target state="translated">与普通回调相比,它的优点是允许你解耦你的代码,而且它们更容易编写。</target>
        </trans-unit>
        <trans-unit id="480a14931d5a0da5ce02043bf95ba5bba1ea1b46" translate="yes" xml:space="preserve">
          <source>The big question is when will it get the response? The answer is we don't know - so the event loop is waiting for that message to say &quot;hey run me&quot;. If JS just waited around for that message synchronously your app would freeze and it will suck. So JS carries on executing the next item in the queue whilst waiting for the message to get added back to the queue.</source>
          <target state="translated">最大的问题是,它什么时候能得到响应?答案是我们不知道--所以事件循环是在等待那条消息说 &quot;嘿,运行我&quot;。如果JS只是同步等待那条消息,你的应用程序就会冻结,它就会很烂。所以JS在等待消息被添加到队列中的同时,继续执行队列中的下一个项目。</target>
        </trans-unit>
        <trans-unit id="ccbf0ca2fcdd4c3a3e86689a782e66920dbfdb25" translate="yes" xml:space="preserve">
          <source>The callback &lt;code&gt;...args&lt;/code&gt; are wrapped in an array and destructured when you read them so that the pattern can cope with callbacks that have multiple arguments. For example with &lt;a href=&quot;https://nodejs.org/api/fs.html&quot;&gt;node fs&lt;/a&gt;:</source>
          <target state="translated">回调 &lt;code&gt;...args&lt;/code&gt; 包裹在数组中，在您读取它们时会进行重组，以便该模式可以处理具有多个参数的回调。 例如，使用&lt;a href=&quot;https://nodejs.org/api/fs.html&quot;&gt;节点fs&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="77a6ce0e24e45311bbbc8af933b3454cde1bc3ae" translate="yes" xml:space="preserve">
          <source>The callback is set directly (so no extra unnecessary closures).</source>
          <target state="translated">直接设置了回调(所以没有多余的不必要的关闭)。</target>
        </trans-unit>
        <trans-unit id="64f9a89935bc0aec8bd8d2c2f2163e48c2e4e0d3" translate="yes" xml:space="preserve">
          <source>The classic JS approach to this problem, taking advantage of the fact that JS supports functions as first-class objects which can be passed around, is to pass a function as a parameter to the asynchronous request, which it will then invoke when it has completed its task sometime in the future. That is the &quot;callback&quot; approach. It looks like this:</source>
          <target state="translated">对于这个问题,经典的JS方法是利用JS支持将函数作为第一类对象来传递的事实,将一个函数作为参数传递给异步请求,当它在未来的某个时候完成任务后,再调用这个函数。这就是 &quot;回调 &quot;的方法。它看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="a4b7cb494bc59feaa54149492dcd2fc6736593a6" translate="yes" xml:space="preserve">
          <source>The computer systems we build--more and more--have time as an important dimension. Certain things are set up to happen in the future. Then other things need to happen after those first things eventually occur. This is the basic notion called &quot;asynchronicity&quot;. In our increasingly networked world, the most common case of asynchronicity is waiting for some remote system to respond to some request.</source>
          <target state="translated">我们所建立的计算机系统----越来越多--都把时间作为一个重要的维度。某些事情被设定为在未来发生。然后,在这些最初的事情最终发生之后,其他的事情也需要发生。这就是所谓的 &quot;非同步性 &quot;的基本概念。在我们这个日益网络化的世界里,最常见的非同步性的情况是等待某个远程系统响应某个请求。</target>
        </trans-unit>
        <trans-unit id="68c3c910b7e388c8ca698170706eac7d163f356e" translate="yes" xml:space="preserve">
          <source>The core issue</source>
          <target state="translated">核心问题</target>
        </trans-unit>
        <trans-unit id="edbb0afa295f70fd7b961434a3ea023d105f1de1" translate="yes" xml:space="preserve">
          <source>The following example I have written shows how to</source>
          <target state="translated">以下是我写的例子,说明了如何做到</target>
        </trans-unit>
        <trans-unit id="7e2482274ea8174623353a79961f7e409558a384" translate="yes" xml:space="preserve">
          <source>The functions above are for basic use.</source>
          <target state="translated">以上功能为基本使用。</target>
        </trans-unit>
        <trans-unit id="f0b5d408edc15ee4ab49f75c3a45e0e83fe085b1" translate="yes" xml:space="preserve">
          <source>The most perfect answer to this question is using &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">这个问题的最完美答案是使用 &lt;code&gt;Promise&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">问题是</target>
        </trans-unit>
        <trans-unit id="bc0f50fb62db74196eb462d4435dbc048d27bedc" translate="yes" xml:space="preserve">
          <source>The problem with this callback approach is that it pollutes the normal semantics of a function reporting its result with &lt;code&gt;return&lt;/code&gt;; instead, functions must not reports their results by calling a callback given as a parameter. Also, this approach can rapidly become unwieldy when dealing with longer sequences of events. For example, let's say that I want to wait for the milk to be put in the coffee, and then and only then perform a third step, namely drinking the coffee. I end up needing to write something like this:</source>
          <target state="translated">这种回调方法的问题是它污染了函数的正常语义，并用 &lt;code&gt;return&lt;/code&gt; 来报告结果; 相反，函数不得通过调用作为参数给出的回调来报告其结果。 同样，在处理较长的事件序列时，此方法可能很快变得笨拙。 例如，假设我要等待牛奶放入咖啡中，然后再执行第三步，即喝咖啡。 我最终需要写这样的东西：</target>
        </trans-unit>
        <trans-unit id="32dd7ece0413b20c7f6465adba94961d1fd0156b" translate="yes" xml:space="preserve">
          <source>The question was:</source>
          <target state="translated">这个问题是:</target>
        </trans-unit>
        <trans-unit id="9865311a25d22afa6e2a491b6a5b84a1c39aeb10" translate="yes" xml:space="preserve">
          <source>The reason that doesn't work is that the callbacks from &lt;code&gt;doSomethingAsync&lt;/code&gt; haven't run yet by the time you're trying to use the results.</source>
          <target state="translated">不起作用的原因是，在您尝试使用结果时， &lt;code&gt;doSomethingAsync&lt;/code&gt; 的回调尚未运行。</target>
        </trans-unit>
        <trans-unit id="a2739b5dbb10ebfc12b5d81d5d32fb7cd061a55e" translate="yes" xml:space="preserve">
          <source>The same is happening when you make a function call containing &quot;normal&quot; code:</source>
          <target state="translated">当你进行包含 &quot;正常 &quot;代码的函数调用时也是如此。</target>
        </trans-unit>
        <trans-unit id="98c7c4ba758c9126f0cfa1f1637747d0674ee4fd" translate="yes" xml:space="preserve">
          <source>The simplest solution is create a JavaScript function and call it for the Ajax &lt;code&gt;success&lt;/code&gt; callback.</source>
          <target state="translated">最简单的解决方案是创建一个JavaScript函数，并为Ajax &lt;code&gt;success&lt;/code&gt; 回调调用它。</target>
        </trans-unit>
        <trans-unit id="3d2b25517bf2d94a474aa03573586b145df347ce" translate="yes" xml:space="preserve">
          <source>The simplest:</source>
          <target state="translated">最简单的。</target>
        </trans-unit>
        <trans-unit id="6fe5eb2395efd41f10b91e16726041602d6e3143" translate="yes" xml:space="preserve">
          <source>The solution will be to avoid callbacks, and use a combination of &lt;strong&gt;Promises&lt;/strong&gt; and &lt;strong&gt;async/await&lt;/strong&gt;.</source>
          <target state="translated">解决方案是避免回调，并结合使用&lt;strong&gt;Promises&lt;/strong&gt;和&lt;strong&gt;async / await&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dec62eb819ee8ace8aad60238eecf9a7f4fb514" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a&lt;/code&gt; returned is &lt;code&gt;undefined&lt;/code&gt; since the &lt;code&gt;a=5&lt;/code&gt; part has not executed yet. AJAX acts like this, you're returning the value before the server got the chance to tell your browser what that value is.</source>
          <target state="translated">由于尚未执行 &lt;code&gt;a=5&lt;/code&gt; 部分，因此返回的值 &lt;code&gt;undefined&lt;/code&gt; 。 AJAX就是这样，您要在服务器有机会告诉浏览器该值之前返回值。</target>
        </trans-unit>
        <trans-unit id="8d1a490aef5366b80c665df9adb0416c82e381c5" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; since the &lt;code&gt;data = 5&lt;/code&gt; part has not executed yet. It will likely execute in a second but by that time it is irrelevant to the returned value.</source>
          <target state="translated">由于 &lt;code&gt;data = 5&lt;/code&gt; 部分尚未执行，因此 &lt;code&gt;data&lt;/code&gt; 的值 &lt;code&gt;undefined&lt;/code&gt; 。 它可能会在一秒钟内执行，但到那时它与返回的值无关。</target>
        </trans-unit>
        <trans-unit id="587b206c7db5b969cdb5a40887824aa9c5099e73" translate="yes" xml:space="preserve">
          <source>There are basically two ways how to solve this:</source>
          <target state="translated">基本上有两种方法如何解决。</target>
        </trans-unit>
        <trans-unit id="2cf0b130ac11e32c400e435be4fa43654576f982" translate="yes" xml:space="preserve">
          <source>There are some other situations which I don't remember that make the XMLHttpRequest 1 annoying.</source>
          <target state="translated">还有一些其他的情况,我不记得了,这让XMLHttpRequest 1很烦人。</target>
        </trans-unit>
        <trans-unit id="dd643d6829dc9f26a331e2bce21e4a3e98d834bc" translate="yes" xml:space="preserve">
          <source>There are three things you need to be aware of; &lt;strong&gt;The queue; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop&quot;&gt;the event loop&lt;/a&gt; and the stack&lt;/strong&gt;</source>
          <target state="translated">您需要注意三件事： &lt;strong&gt;队列;&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop&quot;&gt;事件循环&lt;/a&gt;和堆栈&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4498030a163e78ec8715dffc1c0ce5911aba4b0c" translate="yes" xml:space="preserve">
          <source>There are two ways to get the response of this Ajax call (three using the XMLHttpRequest var name):</source>
          <target state="translated">有两种方法可以获得这个Ajax调用的响应(三是使用XMLHttpRequest var名)。</target>
        </trans-unit>
        <trans-unit id="37cfc454d35f84e510806797d964ad848a95604e" translate="yes" xml:space="preserve">
          <source>There is a problem with using promises!</source>
          <target state="translated">使用承诺是有问题的!</target>
        </trans-unit>
        <trans-unit id="7d46baf54c6d620b802f531b3e92d3841965a2a5" translate="yes" xml:space="preserve">
          <source>There is no other way to do this in a non-asynchronous way. (Yeah, with setTimeout loop... but seriously?)</source>
          <target state="translated">没有其他方法可以用非异步的方式来实现。(是的,用setTimeout循环...........但说真的?)</target>
        </trans-unit>
        <trans-unit id="8511f0c06778d891bba10da5d78a325fa162981f" translate="yes" xml:space="preserve">
          <source>There is only the &lt;code&gt;this.type&lt;/code&gt; which is set to error.</source>
          <target state="translated">只有 &lt;code&gt;this.type&lt;/code&gt; 设置为error。</target>
        </trans-unit>
        <trans-unit id="c974cb400663a76c12df4912d445ea3637c72efb" translate="yes" xml:space="preserve">
          <source>This code misunderstands the above asynchrony issues. Specifically, &lt;code&gt;$.ajax()&lt;/code&gt; doesn't freeze the code while it checks the '/password' page on your server - it sends a request to the server and while it waits, it immediately returns a jQuery Ajax Deferred object, not the response from the server. That means the &lt;code&gt;if&lt;/code&gt; statement is going to always get this Deferred object, treat it as &lt;code&gt;true&lt;/code&gt;, and proceed as though the user is logged in. Not good.</source>
          <target state="translated">此代码误解了上述异步问题。 具体来说， &lt;code&gt;$.ajax()&lt;/code&gt; 在检查服务器上的&amp;ldquo; / password&amp;rdquo;页面时不会冻结代码-它向服务器发送请求，等待时立即返回jQuery Ajax Deferred对象，而不是响应从服务器。 这意味着 &lt;code&gt;if&lt;/code&gt; 语句将始终获取此Deferred对象，将其视为 &lt;code&gt;true&lt;/code&gt; ，并像用户已登录一样进行操作。不好。</target>
        </trans-unit>
        <trans-unit id="244afc8d38402f6d7c12baa9c3d841505fe06988" translate="yes" xml:space="preserve">
          <source>This is a short summary of &quot;Explanation of the problem&quot; from the other answer, if you're not sure after reading this, read that.</source>
          <target state="translated">这是另一个答案中的 &quot;问题解析 &quot;的简单总结,如果你看完后不确定,那就看这个。</target>
        </trans-unit>
        <trans-unit id="bec8301fa7c95d68f2971235b818a4ec00cf9186" translate="yes" xml:space="preserve">
          <source>This is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt;. Basically, we're passing &lt;code&gt;getFive&lt;/code&gt; an action to perform when it completes, we're telling our code how to react when an event completes (like our AJAX call, or in this case the timeout).</source>
          <target state="translated">这称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt; 。 基本上，我们给 &lt;code&gt;getFive&lt;/code&gt; 传递了一个在事件完成时执行的动作，我们在告诉代码事件完成后如何做出反应（例如AJAX调用，或者在这种情况下是超时）。</target>
        </trans-unit>
        <trans-unit id="e37cc018b8dd7866206ff24c3bd04692ca34d6e0" translate="yes" xml:space="preserve">
          <source>This is one of the places which &lt;strong&gt;two ways data binding&lt;/strong&gt; or &lt;strong&gt;store concept&lt;/strong&gt; that's used in many new JavaScript frameworks will work great for you...</source>
          <target state="translated">这是在许多新的JavaScript框架中使用的&lt;strong&gt;数据绑定&lt;/strong&gt;或&lt;strong&gt;存储概念&lt;/strong&gt; &lt;strong&gt;两种方式&lt;/strong&gt;对您非常有用的地方之一...</target>
        </trans-unit>
        <trans-unit id="87baabf09170470e02be100dac74857e2ebc1619" translate="yes" xml:space="preserve">
          <source>This is quite simple:</source>
          <target state="translated">这其实很简单。</target>
        </trans-unit>
        <trans-unit id="95b540890727eecbe058d586198261782083d7c0" translate="yes" xml:space="preserve">
          <source>This means AngularJS, jQuery (with deferred), native XHR's replacement (fetch), EmberJS, BackboneJS's save or any node library that returns promises.</source>
          <target state="translated">这意味着AngularJS、jQuery(带递延)、原生XHR的替换(fetch)、EmberJS、BackboneJS的save或任何返回承诺的节点库。</target>
        </trans-unit>
        <trans-unit id="b3d9c5469e4b15f9c162fb643af29c9f5ca05645" translate="yes" xml:space="preserve">
          <source>This means when you're returning &lt;code&gt;data&lt;/code&gt; the &lt;code&gt;then&lt;/code&gt; handler you've defined did not execute yet. This in turn means that the value you're returning has not been set to the correct value in time.</source>
          <target state="translated">这意味着当您返回 &lt;code&gt;data&lt;/code&gt; ，您定义的 &lt;code&gt;then&lt;/code&gt; 处理程序尚未执行。 这又意味着您返回的值没有及时设置为正确的值。</target>
        </trans-unit>
        <trans-unit id="f01778d1944777ab6b8f39abe10e8afdd7a72058" translate="yes" xml:space="preserve">
          <source>This means when you're returning, the listener you've defined did not execute yet, which means the value you're returning has not been defined.</source>
          <target state="translated">这意味着当你返回的时候,你定义的监听器还没有执行,这意味着你要返回的值还没有被定义。</target>
        </trans-unit>
        <trans-unit id="61ed4646f32a3a1ac23ad5fb1d6851ea5f3992d0" translate="yes" xml:space="preserve">
          <source>This method returns a promise itself, which we can consume from other coroutines. For example:</source>
          <target state="translated">这个方法返回一个承诺本身,我们可以从其他的coroutines中消耗掉。比如说。</target>
        </trans-unit>
        <trans-unit id="6d9e63f07d1d652a68998572e1a51ce636590916" translate="yes" xml:space="preserve">
          <source>This somewhat tricky but very powerful trick lets us write asynchronous code in a synchronous manner. There are several &quot;runners&quot; that do this for you, writing one is a short few lines of code but is beyond the scope of this answer. I'll be using Bluebird's &lt;code&gt;Promise.coroutine&lt;/code&gt; here, but there are other wrappers like &lt;code&gt;co&lt;/code&gt; or &lt;code&gt;Q.async&lt;/code&gt;.</source>
          <target state="translated">这个有点棘手但非常强大的技巧使我们可以以同步方式编写异步代码。 有几个&amp;ldquo;运行器&amp;rdquo;可以为您执行此操作，编写一小段代码即可，但超出了此答案的范围。 我将在这里使用Bluebird的 &lt;code&gt;Promise.coroutine&lt;/code&gt; ，但还有其他包装器，例如 &lt;code&gt;co&lt;/code&gt; 或 &lt;code&gt;Q.async&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7419d91a7773bb18e95de8945a17e396a7138932" translate="yes" xml:space="preserve">
          <source>This stands the same for your original API call, you can:</source>
          <target state="translated">这对你原来的API调用是一样的,你可以。</target>
        </trans-unit>
        <trans-unit id="b4c2a28333fa2716b1c47a4f0a2e18a4d80475ff" translate="yes" xml:space="preserve">
          <source>This was the motivation for the notion of a &quot;promise&quot;, which is a particular type of value which represents a &lt;strong&gt;future&lt;/strong&gt; or &lt;strong&gt;asynchronous&lt;/strong&gt; outcome of some sort. It can represent something that already happened, or that is going to happen in the future, or might never happen at all. Promises have a single method, named &lt;code&gt;then&lt;/code&gt;, to which you pass an action to be executed when the outcome the promise represents has been realized.</source>
          <target state="translated">这是&amp;ldquo;承诺&amp;rdquo;概念的动机，&amp;ldquo;承诺&amp;rdquo;是一种特殊的价值类型，代表某种&lt;strong&gt;未来&lt;/strong&gt;或&lt;strong&gt;异步&lt;/strong&gt;结果。 它可以表示已经发生的事情，或者将来会发生的事情，或者可能永远不会发生的事情。 承诺有一个名为 &lt;code&gt;then&lt;/code&gt; 的方法，当实现了promise表示的结果时，您将向该方法传递要执行的动作。</target>
        </trans-unit>
        <trans-unit id="c88099e25e362faf93b5c34442314fc0efbfd023" translate="yes" xml:space="preserve">
          <source>This working example is self-contained. It will define a simple request object that uses the window &lt;code&gt;XMLHttpRequest&lt;/code&gt; object to make calls. It will define a simple function to wait for a bunch of promises to be completed.</source>
          <target state="translated">这个工作示例是独立的。 它将定义一个简单的请求对象，该对象使用窗口 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 对象进行调用。 它将定义一个简单的函数来等待一堆承诺完成。</target>
        </trans-unit>
        <trans-unit id="bb4a902028592cca405a4e54f7447a6dd933acce" translate="yes" xml:space="preserve">
          <source>Thus Solution to this is &lt;em&gt;callback&lt;/em&gt; or &lt;em&gt;promise&lt;/em&gt;.</source>
          <target state="translated">因此，解决方案是&lt;em&gt;回调&lt;/em&gt;或&lt;em&gt;Promise&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a4ac77e33ad1dc33272e4765092ee238e7b4067" translate="yes" xml:space="preserve">
          <source>Thus, the summary is - to tackle the asynchronous functions like ajax based calls etc., you can use a promise to &lt;code&gt;resolve&lt;/code&gt; the value (which you intend to return). Thus, in short you &lt;strong&gt;resolve&lt;/strong&gt; value instead of &lt;strong&gt;returning&lt;/strong&gt;, in asynchronous functions.</source>
          <target state="translated">因此，摘要是-为了处理异步功能，例如基于ajax的调用等，您可以使用promise来 &lt;code&gt;resolve&lt;/code&gt; 值（您打算返回的值）。 因此，简而言之，您可以在异步函数中&lt;strong&gt;解析&lt;/strong&gt;值而不是&lt;strong&gt;返回&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0a2dcdf916f3c7cf3b91ae00bbe537935bc5316" translate="yes" xml:space="preserve">
          <source>To run the above code you do this:</source>
          <target state="translated">要运行上述代码,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="2e8f0671297e82a3357b05f76d4c39dd6732c8f7" translate="yes" xml:space="preserve">
          <source>UPDATE (Promises with async/await)</source>
          <target state="translated">UPDATE (承诺与asyncawait)</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e3b2c87fbdfa81069562e3801f3b834f583f3068" translate="yes" xml:space="preserve">
          <source>Usage would be:</source>
          <target state="translated">用法将是:</target>
        </trans-unit>
        <trans-unit id="4ba1f4e931dcc6adc1af6d22a6e4e7abed5a85b2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt; pattern to join multiple HTTP calls;</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt;模式来加入多个HTTP调用；</target>
        </trans-unit>
        <trans-unit id="e698b02ca0c7b2228f7ccbc8c4b111e743e10e2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;Promise&lt;/a&gt; pattern;</source>
          <target state="translated">使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;承诺&lt;/a&gt;模式；</target>
        </trans-unit>
        <trans-unit id="0e9a58ba6887bb7e51147aa2da4a49a0486ce969" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;callback()&lt;/code&gt; function inside the &lt;code&gt;foo()&lt;/code&gt; success.
Try in this way. It is simple and easy to understand. &amp;nbsp;</source>
          <target state="translated">在 &lt;code&gt;foo()&lt;/code&gt; 成功内使用 &lt;code&gt;callback()&lt;/code&gt; 函数。 以这种方式尝试。 它简单易懂。</target>
        </trans-unit>
        <trans-unit id="606944b24d98d72b39627fdefe858efa8d964a89" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;'await'&lt;/a&gt;, which will tell JavaScript to await the promise to be resolved into a value (like the HTTP response)</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;'await'&lt;/a&gt; ，它将告诉JavaScript等待将承诺解析为一个值（例如HTTP响应）</target>
        </trans-unit>
        <trans-unit id="a11fcc742eebbcfca3c5bb6597892f401f073e0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;strong&gt;asynchronous&lt;/strong&gt; code as if it were &lt;strong&gt;synchronous&lt;/strong&gt;:</source>
          <target state="translated">像&lt;strong&gt;异步&lt;/strong&gt;代码一样使用&lt;strong&gt;异步&lt;/strong&gt;代码：</target>
        </trans-unit>
        <trans-unit id="50df00102216ee2fa6b8d3f60a71c04beba81fe1" translate="yes" xml:space="preserve">
          <source>Using ES2017 you should have this as the function declaration</source>
          <target state="translated">使用ES2017,你应该有这样的函数声明</target>
        </trans-unit>
        <trans-unit id="cc12d7b012ca1bfa32bf1aa97b798db2031c84f8" translate="yes" xml:space="preserve">
          <source>Using Promise</source>
          <target state="translated">使用Promise</target>
        </trans-unit>
        <trans-unit id="28685eec146d7abeed631f689f722a157cd3cd31" translate="yes" xml:space="preserve">
          <source>Using callback concept - As implementation in first answer</source>
          <target state="translated">使用回调概念----如第一个答案中的实现。</target>
        </trans-unit>
        <trans-unit id="c787b69b8c1dad213e2bced9dc421d4fbabcda2a" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;XMLHttpRequest&lt;/code&gt; variable name is another big error as you need to execute the callback inside the onload/oreadystatechange closures else you lost it.</source>
          <target state="translated">使用 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 变量名是另一个大错误，因为您需要在onload / oreadystatechange闭包内执行回调，否则会丢失它。</target>
        </trans-unit>
        <trans-unit id="b7ce43e50f1c7276c7fa06bbf7c04a9872a17966" translate="yes" xml:space="preserve">
          <source>Wait for response from each API call;</source>
          <target state="translated">等待每次API调用的响应。</target>
        </trans-unit>
        <trans-unit id="35c239d949f8723db6cf2fca7425f52803d0c967" translate="yes" xml:space="preserve">
          <source>We find ourselves in a universe which appears to progress along a dimension we call &quot;time&quot;. We don't really understand what time is, but we have developed abstractions and vocabulary that let us reason and talk about it: &quot;past&quot;, &quot;present&quot;, &quot;future&quot;, &quot;before&quot;, &quot;after&quot;.</source>
          <target state="translated">我们发现自己身处一个宇宙中,似乎是沿着我们称之为 &quot;时间 &quot;的维度前进。[...] [...]</target>
        </trans-unit>
        <trans-unit id="cf190ebdec93ca0293df429352a161bff1aed4e0" translate="yes" xml:space="preserve">
          <source>We have now made our foo function accept an action to run when the AJAX completes successfully, we can extend this further by checking if the response status is not 200 and acting accordingly (create a fail handler and such). Effectively solving our issue.</source>
          <target state="translated">我们现在已经让我们的foo函数在AJAX成功完成时接受一个动作来运行,我们可以通过检查响应状态是否不是200并采取相应的行动(创建一个失败处理程序之类的)来进一步扩展。有效的解决了我们的问题。</target>
        </trans-unit>
        <trans-unit id="ac71c9a45e5e5d552a308fe3128d89db33f20f8b" translate="yes" xml:space="preserve">
          <source>What you're facing</source>
          <target state="translated">你要面对的是什么</target>
        </trans-unit>
        <trans-unit id="d9e7e738a86ea5326f809837e5b5ea81f305f671" translate="yes" xml:space="preserve">
          <source>When one of these messages is going to execute it pops the message from the queue and creates a stack, the stack is everything JS needs to execute to perform the instruction in the message. So in our example it's being told to call &lt;code&gt;foobarFunc&lt;/code&gt;</source>
          <target state="translated">当这些消息之一要执行时，它会从队列中弹出消息并创建一个堆栈，而该堆栈就是JS执行该消息中的指令所需的一切。 因此，在我们的示例中，它被告知调用 &lt;code&gt;foobarFunc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46e5db5a04236061d5766214e29fc62f17454cbf" translate="yes" xml:space="preserve">
          <source>When using promises, we end up passing lots of functions into &lt;code&gt;then&lt;/code&gt;, so it's often helpful to use the more compact ES6-style arrow functions:</source>
          <target state="translated">当使用诺言时，我们最终会将大量函数传递给 &lt;code&gt;then&lt;/code&gt; ，因此使用更紧凑的ES6风格的箭头函数通常会有所帮助：</target>
        </trans-unit>
        <trans-unit id="b23496e842dceff9fb3a521cbe84a712262e3f34" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;.then&lt;/code&gt; on a promise and &lt;em&gt;return&lt;/em&gt; something from it - we get a promise for &lt;em&gt;the processed value&lt;/em&gt;. If we return another promise we'll get amazing things, but let's hold our horses.</source>
          <target state="translated">当我们调用 &lt;code&gt;.then&lt;/code&gt; 承诺并从中&lt;em&gt;返回&lt;/em&gt;某些内容时-我们获得了&lt;em&gt;处理后价值&lt;/em&gt;的承诺。 如果我们再次兑现诺言，我们将获得惊人的成就，但让我们坚持不懈。</target>
        </trans-unit>
        <trans-unit id="d987b91f60f98a1b758f0e53d90290815d18964e" translate="yes" xml:space="preserve">
          <source>When you make a call using AJAX to an external party or run any asynchronous code (a setTimeout for example), Javascript is dependant upon a response before it can proceed.</source>
          <target state="translated">当你使用AJAX对外部方进行调用或运行任何异步代码(例如setTimeout)时,Javascript在进行之前需要依赖响应。</target>
        </trans-unit>
        <trans-unit id="380b904db5976f20d5318f6cc1191c770d1da13f" translate="yes" xml:space="preserve">
          <source>Whenever you call a method that returns a promise, the &lt;code&gt;then&lt;/code&gt; handlers are &lt;em&gt;always&lt;/em&gt; executed asynchronously - that is, &lt;strong&gt;after&lt;/strong&gt; the code below them that is not in a &lt;code&gt;.then&lt;/code&gt; handler.</source>
          <target state="translated">每当调用返回承诺的方法时， &lt;code&gt;then&lt;/code&gt; 处理程序&lt;em&gt;始终&lt;/em&gt;异步执行-也就是说， &lt;strong&gt;在&lt;/strong&gt;它们下面的代码&lt;strong&gt;之后，&lt;/strong&gt;该代码不在 &lt;code&gt;.then&lt;/code&gt; 处理程序中。</target>
        </trans-unit>
        <trans-unit id="42feb8ea413f33209ece4d328587c570e4d54ebe" translate="yes" xml:space="preserve">
          <source>Which should alert &quot;5&quot; to the screen. &lt;a href=&quot;http://jsfiddle.net/PAjZR/&quot;&gt;(Fiddle)&lt;/a&gt;.</source>
          <target state="translated">应该在屏幕上提示&amp;ldquo; 5&amp;rdquo;。 &lt;a href=&quot;http://jsfiddle.net/PAjZR/&quot;&gt;（提琴）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec5557762b5410ae1ddd3eb2b67bfdb2da22a4ce" translate="yes" xml:space="preserve">
          <source>While it is &lt;em&gt;okay&lt;/em&gt; in small examples it gets annoying when you have a lot of similar cases and error handling involved.</source>
          <target state="translated">虽然在一些小示例中&lt;em&gt;还可以&lt;/em&gt; ，但是当您遇到很多类似的情况和错误处理时，它会很烦人。</target>
        </trans-unit>
        <trans-unit id="1450bd8677cf37b475780df43411df3cca8f006a" translate="yes" xml:space="preserve">
          <source>While promises and callbacks work fine in many situations, it is a pain in the rear to express something like:</source>
          <target state="translated">虽然承诺和回调在很多情况下都很好用,但要表达类似这样的东西就很麻烦了。</target>
        </trans-unit>
        <trans-unit id="448c4cc13812bccdb5367397d714ad86dd6ea552" translate="yes" xml:space="preserve">
          <source>Why add an error handler if you totally have no control over errors?
Most of the errors are returned inside this in the callback function &lt;code&gt;displayAjax()&lt;/code&gt;.</source>
          <target state="translated">如果您完全无法控制错误，为什么还要添加错误处理程序？ 大多数错误都在回调函数 &lt;code&gt;displayAjax()&lt;/code&gt; 中返回 。</target>
        </trans-unit>
        <trans-unit id="5edfc082aa90912642ae681f74a76ece5088c8fa" translate="yes" xml:space="preserve">
          <source>Why is it bad do you ask?</source>
          <target state="translated">你问为什么不好?</target>
        </trans-unit>
        <trans-unit id="1229758f7e8ec3a149e87560402cc78e508a43de" translate="yes" xml:space="preserve">
          <source>Why should we use our own custom Promise?</source>
          <target state="translated">为什么我们要用自己的定制承诺?</target>
        </trans-unit>
        <trans-unit id="ece375bff4b483047da3749860748c38927e530d" translate="yes" xml:space="preserve">
          <source>With promises</source>
          <target state="translated">有了诺言</target>
        </trans-unit>
        <trans-unit id="0c0a59fb074de0fc1fd7cee2f49870f337cc9102" translate="yes" xml:space="preserve">
          <source>Without jQuery</source>
          <target state="translated">没有jQuery的情况下</target>
        </trans-unit>
        <trans-unit id="b5fea0abea018388c5315d97c39b4081a7cb703a" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest API</source>
          <target state="translated">XMLHttpRequest API</target>
        </trans-unit>
        <trans-unit id="e73644d1d710900fb613359a5f23e329c06b46fe" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest supports both synchronous and asynchronous communications. In general, however, asynchronous requests should be preferred to synchronous requests for performance reasons.</source>
          <target state="translated">XMLHttpRequest同时支持同步和异步通信。但是,一般来说,出于性能的原因,异步请求应优先于同步请求。</target>
        </trans-unit>
        <trans-unit id="b9b7f311a0fbfaead32e2e31dba1d379c239df35" translate="yes" xml:space="preserve">
          <source>Yes, you can.</source>
          <target state="translated">是的,你可以。</target>
        </trans-unit>
        <trans-unit id="83fb6a0fad9feb9e391f4aec4d78ee5495226649" translate="yes" xml:space="preserve">
          <source>You are using Ajax incorrectly. The idea is not to have it return anything, but instead hand off the data to something called a callback function, which handles the data.</source>
          <target state="translated">你使用Ajax不正确。我们的想法是不要让它返回任何东西,而是把数据交给一个叫回调函数的东西来处理数据。</target>
        </trans-unit>
        <trans-unit id="f394fee622b97599e0a31a6f0f4cd4cc68870f7c" translate="yes" xml:space="preserve">
          <source>You call your friend again for the same reason. But this time you tell him that you are in a hurry and he should &lt;em&gt;call you back&lt;/em&gt; on your mobile phone. You hang up, leave the house and do whatever you planned to do. Once your friend calls you back, you are dealing with the information he gave to you.</source>
          <target state="translated">您出于相同的原因再次致电给您的朋友。 但是这次您告诉他您很着急，他应该用您的手机&lt;em&gt;给您回电&lt;/em&gt; 。 您挂断电话，离开房子，然后按计划做。 一旦您的朋友给您回电，您就可以处理他提供给您的信息。</target>
        </trans-unit>
        <trans-unit id="d2bd21947364482b0aca338a6b437d78f80037e7" translate="yes" xml:space="preserve">
          <source>You can also process the response before passing it to the callback:</source>
          <target state="translated">你也可以在将响应传递给回调之前,对其进行处理。</target>
        </trans-unit>
        <trans-unit id="3beb8e59419ebd09fc9891e40ffa62d7e41da4e2" translate="yes" xml:space="preserve">
          <source>You can checkout the project &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;此处&lt;/a&gt;签出项目。</target>
        </trans-unit>
        <trans-unit id="9a399a6f3ef2aa4bf612fdbeaabb5190ec6b5790" translate="yes" xml:space="preserve">
          <source>You can consume that in this way,</source>
          <target state="translated">你可以用这种方式来消费。</target>
        </trans-unit>
        <trans-unit id="0c470949a5de51b9f217c1f0fc0cf12e324c19e0" translate="yes" xml:space="preserve">
          <source>You can find a nice explanation &lt;a href=&quot;http://andyshora.com/promises-angularjs-explained-as-cartoon.html&quot;&gt;here&lt;/a&gt; also.</source>
          <target state="translated">您也可以&lt;a href=&quot;http://andyshora.com/promises-angularjs-explained-as-cartoon.html&quot;&gt;在这里&lt;/a&gt;找到一个很好的解释。</target>
        </trans-unit>
        <trans-unit id="3a480682174de8f801e99da50379e04d8ac8ac06" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; on MDN.</source>
          <target state="translated">您可以阅读有关&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;并在MDN上&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="ca259db921dc5475dee1f9c068034b544e83ec7f" translate="yes" xml:space="preserve">
          <source>You can start all of them and keep track of how many callbacks you're expecting, and then use the results when you've gotten that many callbacks:</source>
          <target state="translated">你可以把所有的都启动,并记录下你期待的回调次数,等你得到这么多的回调后,再使用结果。</target>
        </trans-unit>
        <trans-unit id="00f65b8b36a713a1b70d47398be1c721ed3fffd5" translate="yes" xml:space="preserve">
          <source>You can then see a nested Promise structure, that lets you spawn multiple and completely asynchronous nested HTTP calls, and join the results from each subset of calls through &lt;code&gt;Promise.all&lt;/code&gt;.</source>
          <target state="translated">然后，您可以看到一个嵌套的Promise结构，该结构使您可以生成多个且完全异步的嵌套HTTP调用，并通过 &lt;code&gt;Promise.all&lt;/code&gt; 将每个调用子集的结果合并在一起 。</target>
        </trans-unit>
        <trans-unit id="5637817dac7360e2bf1c7c2d1626c7be889d259e" translate="yes" xml:space="preserve">
          <source>You can use a &lt;strong&gt;callback&lt;/strong&gt;, &lt;strong&gt;promise&lt;/strong&gt; and recently &lt;strong&gt;observable&lt;/strong&gt; to handle it for you, for example in promises we have some function like &lt;code&gt;success()&lt;/code&gt; or &lt;code&gt;then()&lt;/code&gt; which will be executed when your data is ready for you, same with callback or &lt;strong&gt;subscribe&lt;/strong&gt; function on &lt;strong&gt;observable&lt;/strong&gt;.</source>
          <target state="translated">您可以使用&lt;strong&gt;callback&lt;/strong&gt; ， &lt;strong&gt;promise&lt;/strong&gt;和最近&lt;strong&gt;可观察&lt;/strong&gt;到的&lt;strong&gt;回调&lt;/strong&gt;来为您处理它，例如在promise中，我们有一些函数，例如 &lt;code&gt;success()&lt;/code&gt; 或 &lt;code&gt;then()&lt;/code&gt; ，这些函数将在您的数据准备就绪后执行，与callback或&lt;strong&gt;subscription&lt;/strong&gt;函数相同可以&lt;strong&gt;观察&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="3aedc25db58a4804737e831c476a6e6a972dbab8" translate="yes" xml:space="preserve">
          <source>You can use this custom library (written using Promise) to make a remote call.</source>
          <target state="translated">你可以使用这个自定义库(使用Promise编写)进行远程调用。</target>
        </trans-unit>
        <trans-unit id="dd6628c5f45797d9ea0f78c8fc099d6704e851a0" translate="yes" xml:space="preserve">
          <source>You'd end up going through &lt;code&gt;async1&lt;/code&gt;; check if &lt;code&gt;name&lt;/code&gt; is undefined or not and call the callback accordingly.</source>
          <target state="translated">您最终将经历 &lt;code&gt;async1&lt;/code&gt; ; 检查 &lt;code&gt;name&lt;/code&gt; 是否未定义，并相应地调用回调。</target>
        </trans-unit>
        <trans-unit id="bd8715a64e94539f3c8b8df1772b0c03d902cf35" translate="yes" xml:space="preserve">
          <source>Your code should be something along the lines of this:</source>
          <target state="translated">你的代码应该是这样的。</target>
        </trans-unit>
        <trans-unit id="79d239c9d4dd6e9398d601a54d23e6f15a901265" translate="yes" xml:space="preserve">
          <source>async/await version:</source>
          <target state="translated">asyncawait版本。</target>
        </trans-unit>
        <trans-unit id="5fa5455b316d09922e2556fd3e7db0992016d6bb" translate="yes" xml:space="preserve">
          <source>await is supported in all current browsers and node 8</source>
          <target state="translated">await在当前所有浏览器和节点8中都支持。</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="6cdd908e77bf13956316a9dfb985f596f59e72fe" translate="yes" xml:space="preserve">
          <source>but if &lt;code&gt;a&lt;/code&gt; is asynchronous, with promises we have to write</source>
          <target state="translated">但是如果 &lt;code&gt;a&lt;/code&gt; 是异步的，那么必须保证我们必须编写</target>
        </trans-unit>
        <trans-unit id="ba1108cd1f24e45036a47d4005ece995c5fe8b5d" translate="yes" xml:space="preserve">
          <source>cross-domain not allowed throws error automatically.</source>
          <target state="translated">跨域不允许自动抛出错误。</target>
        </trans-unit>
        <trans-unit id="3691b5c9d0eec5124fbea2e6256064c9e642e83e" translate="yes" xml:space="preserve">
          <source>for instance,</source>
          <target state="translated">比如说。</target>
        </trans-unit>
        <trans-unit id="00853d73f19844948fadbc48d500f997c46f7ee4" translate="yes" xml:space="preserve">
          <source>jQuery</source>
          <target state="translated">jQuery</target>
        </trans-unit>
        <trans-unit id="c6ba4cdd11e1a3db37a54109474e9c73534b938a" translate="yes" xml:space="preserve">
          <source>jQuery deferred</source>
          <target state="translated">递延</target>
        </trans-unit>
        <trans-unit id="fba0ae53da33f0cd5e54603774b1229ca748fbd7" translate="yes" xml:space="preserve">
          <source>nsynjs will evaluate all promises sequentially, and put promise result into &lt;code&gt;data&lt;/code&gt; property:</source>
          <target state="translated">nsynjs将顺序评估所有promise，并将promise结果放入 &lt;code&gt;data&lt;/code&gt; 属性中：</target>
        </trans-unit>
        <trans-unit id="e1a5e2d288843cc0d03987443a6fc38bffe1ef80" translate="yes" xml:space="preserve">
          <source>onreadystatechange is only useful if you want to get the headers on state 2.</source>
          <target state="translated">onreadystatechange只有在你想获得状态2的头像时才有用。</target>
        </trans-unit>
        <trans-unit id="0458efd542acc1a7aebda8d34461df3c13d76b38" translate="yes" xml:space="preserve">
          <source>so most of the time (but not always) you'll pass &lt;code&gt;foo&lt;/code&gt; not &lt;code&gt;foo()&lt;/code&gt;</source>
          <target state="translated">因此，大多数情况下（但并非总是如此），您将传递 &lt;code&gt;foo&lt;/code&gt; 而不是 &lt;code&gt;foo()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88018d8629c033501aa21a3ab6e24d7aebd65b57" translate="yes" xml:space="preserve">
          <source>then/catch version:</source>
          <target state="translated">捕捉版。</target>
        </trans-unit>
        <trans-unit id="3aee67424c6f45abebfaef894361e9c0e7ddd958" translate="yes" xml:space="preserve">
          <source>where I am passing to &lt;code&gt;put_in_coffee&lt;/code&gt; both the milk to put in it, and also the action (&lt;code&gt;drink_coffee&lt;/code&gt;) to execute once the milk has been put in. Such code becomes hard to write, and read, and debug.</source>
          <target state="translated">我将传递牛奶的位置传递给 &lt;code&gt;put_in_coffee&lt;/code&gt; ，并将传递牛奶之后执行的动作（ &lt;code&gt;drink_coffee&lt;/code&gt; ）传递给put_in_coffee 。这样的代码变得很难编写，读取和调试。</target>
        </trans-unit>
        <trans-unit id="a861995ce1d879a17b5c91a26cf0e7eb75c29caf" translate="yes" xml:space="preserve">
          <source>which CAN be interpreted as:</source>
          <target state="translated">可被解释为:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
