<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/14220321">
    <body>
      <group id="14220321">
        <trans-unit id="927d598b66027a146baa1781e637b904c6aa330f" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://stackoverflow.com/a/30180679/1348195&quot;&gt;Note, for those using the new &lt;code&gt;fetch&lt;/code&gt; API, Angular or promises I've added another answer below&lt;/a&gt;)</source>
          <target state="translated">( &lt;a href=&quot;https://stackoverflow.com/a/30180679/1348195&quot;&gt;Обратите внимание, что для тех, кто использует новый API &lt;code&gt;fetch&lt;/code&gt; , Angular или обещания, я добавил другой ответ ниже&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="99f4d532491d1864e1be89ab9b7b1d7432912746" translate="yes" xml:space="preserve">
          <source>(Although it can be written in Javascript, I prefer to write it in Python, and compile it to Javascript using &lt;a href=&quot;https://github.com/QQuick/Transcrypt&quot;&gt;Transcrypt&lt;/a&gt;. It will be clear enough.)</source>
          <target state="translated">(Хотя он может быть написан на Javascript, я предпочитаю писать его на Python и компилировать в Javascript с использованием &lt;a href=&quot;https://github.com/QQuick/Transcrypt&quot;&gt;Transcrypt&lt;/a&gt; . Это будет достаточно ясно.)</target>
        </trans-unit>
        <trans-unit id="5bdb200d65235570c1b58c9e91da7f158c793d35" translate="yes" xml:space="preserve">
          <source>(Fiddle)</source>
          <target state="translated">(Fiddle)</target>
        </trans-unit>
        <trans-unit id="5db09589cf8459f3d38f5553fbde8bce31d35a4c" translate="yes" xml:space="preserve">
          <source>(fiddle)</source>
          <target state="translated">(fiddle)</target>
        </trans-unit>
        <trans-unit id="7766903fe90c705c4ed71e3573241c83b2c69193" translate="yes" xml:space="preserve">
          <source>...which is less cumbersome with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015+ arrow functions&lt;/a&gt;:</source>
          <target state="translated">... что менее &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;сложно&lt;/a&gt; с функциями ES2015 + стрелка :</target>
        </trans-unit>
        <trans-unit id="f927aed5b9c420c5e6e8550a2e4521837fcb377c" translate="yes" xml:space="preserve">
          <source>1)Event Loop</source>
          <target state="translated">1)Петля событий</target>
        </trans-unit>
        <trans-unit id="0742a4064775d4cda76aa61598d18d11036418f9" translate="yes" xml:space="preserve">
          <source>1. Synchronous AJAX - Don't do it!!</source>
          <target state="translated">1.Синхронный AJAX-Не делай этого!!!</target>
        </trans-unit>
        <trans-unit id="f24ae07c22d1eb6bb318aa04f411d2319b454d6c" translate="yes" xml:space="preserve">
          <source>2)Web API</source>
          <target state="translated">2)Web API</target>
        </trans-unit>
        <trans-unit id="f76660e7f2f317741f7b6f9a679f94b6aae6c47e" translate="yes" xml:space="preserve">
          <source>2. Restructure code</source>
          <target state="translated">2.Код структуры</target>
        </trans-unit>
        <trans-unit id="44d7b3b36c7446cc15b0aafbdc4f232450505779" translate="yes" xml:space="preserve">
          <source>2017 answer: you can now do exactly what you want in every current browser and node</source>
          <target state="translated">Ответ 2017:теперь в каждом текущем браузере и узле вы можете делать именно то,что хотите.</target>
        </trans-unit>
        <trans-unit id="0d76585d726fac5212bc15c005d34dc57ae870eb" translate="yes" xml:space="preserve">
          <source>3)Event Queue</source>
          <target state="translated">3)Очередь события</target>
        </trans-unit>
        <trans-unit id="68333d073e4f567370e4ebd9e36d796f8c754911" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/&quot;&gt;Here&lt;/a&gt; it says,</source>
          <target state="translated">&lt;a href=&quot;http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/&quot;&gt;Здесь&lt;/a&gt; говорится,</target>
        </trans-unit>
        <trans-unit id="d569b34dd010230f2b5736a91066fe31f29056f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; - A promise library for JavaScript</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; - библиотека обещаний для JavaScript</target>
        </trans-unit>
        <trans-unit id="8be840693df3eefddf69835e766647c8f3935f38" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/4866721/what-are-deferred-objects&quot;&gt;Deferred objects&lt;/a&gt; are jQuery's custom implementation of promises (before the Promise API was standardized). They behave almost like promises but expose a slightly different API.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4866721/what-are-deferred-objects&quot;&gt;Отложенные объекты&lt;/a&gt; - это пользовательская реализация обещаний в jQuery (до стандартизации API Promise). Они ведут себя почти как обещания, но выставляют немного другой API.</target>
        </trans-unit>
        <trans-unit id="3c3877fa4d4bea86aa540d1d00c51cba27671903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fibers&lt;/code&gt; helps in solving the issue.</source>
          <target state="translated">&lt;code&gt;Fibers&lt;/code&gt; помогает в решении проблемы.</target>
        </trans-unit>
        <trans-unit id="d4de38eeff0914f72435ab92aacf70919fd4db58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async/await&lt;/code&gt; builds on top of promises: an &lt;code&gt;async&lt;/code&gt; function always returns a promise. &lt;code&gt;await&lt;/code&gt; &quot;unwraps&quot; a promise and either result in the value the promise was resolved with or throws an error if the promise was rejected.</source>
          <target state="translated">&lt;code&gt;async/await&lt;/code&gt; основывается на обещаниях: &lt;code&gt;async&lt;/code&gt; функция всегда возвращает обещание. подождите, пока &amp;laquo;развернутое&amp;raquo; обещание не приведет к значению, с которым обещание было разрешено, или выдает ошибку, если обещание было отклонено.</target>
        </trans-unit>
        <trans-unit id="472c34ad7218489081303afcad61fe244feeb0fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt; will refer to the function we pass to &lt;code&gt;foo&lt;/code&gt; when we call it and we simply pass it on to &lt;code&gt;success&lt;/code&gt;. I.e. once the Ajax request is successful, &lt;code&gt;$.ajax&lt;/code&gt; will call &lt;code&gt;callback&lt;/code&gt; and pass the response to the callback (which can be referred to with &lt;code&gt;result&lt;/code&gt;, since this is how we defined the callback).</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; будет ссылаться на функцию, которую мы передаем &lt;code&gt;foo&lt;/code&gt; , когда мы ее вызываем, и мы просто передаем ее в &lt;code&gt;success&lt;/code&gt; . Т.е. как только Ajax-запрос будет успешным, &lt;code&gt;$.ajax&lt;/code&gt; вызовет &lt;code&gt;callback&lt;/code&gt; и передаст ответ на обратный вызов (на который можно ссылаться с помощью &lt;code&gt;result&lt;/code&gt; , поскольку именно так мы определили обратный вызов).</target>
        </trans-unit>
        <trans-unit id="0cdc633c16019e6c8b41e52704499a8c4fdbc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo&lt;/code&gt; itself is defined as follows:</source>
          <target state="translated">Сам &lt;code&gt;foo&lt;/code&gt; определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="5bc50c14ccc34523a427f339d4f6b0d89980a4cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order_milk&lt;/code&gt; kicks off, orders the milk, then, when and only when it arrives, it invokes &lt;code&gt;put_in_coffee&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;order_milk&lt;/code&gt; , заказывает молоко, затем, когда и только когда оно прибывает, оно вызывает &lt;code&gt;put_in_coffee&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5486986e826b7ca20e7b32edb333416cf0cafa81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;rarr; For a more general explanation of async behaviour with different examples, please see&lt;/em&gt;&lt;a href=&quot;https://stackoverflow.com/q/23667086/218196&quot;&gt;Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;&amp;rarr; Для более общего объяснения асинхронного поведения на различных примерах см.&lt;/em&gt; &lt;a href=&quot;https://stackoverflow.com/q/23667086/218196&quot;&gt;Почему моя переменная не изменяется после того, как я изменил ее внутри функции?&lt;/a&gt; - асинхронная ссылка на код</target>
        </trans-unit>
        <trans-unit id="eb1f5ef8b32f66be0ebf85bab611e6a46d561b3a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;rarr; If you already understand the problem, skip to the possible solutions below.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;rarr; Если вы уже поняли проблему, перейдите к возможным решениям ниже.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5326aa0d4ea5b09f0c635a23b58323c8c2e39d46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Or alternately, you could make a wrapper for &lt;code&gt;doSomethingAsync&lt;/code&gt; that returns a promise, and then do the below...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Или же вы можете создать оболочку для &lt;code&gt;doSomethingAsync&lt;/code&gt; , которая возвращает обещание, а затем выполнить следующее ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e53fbd340f4f3003e06110183cb83b82789a7984" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Or, again, build a wrapper for &lt;code&gt;doSomethingAsync&lt;/code&gt; that gives you a promise and do the below...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Или, опять же, создайте оболочку для &lt;code&gt;doSomethingAsync&lt;/code&gt; , которая даст вам обещание и выполните следующие действия ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1c2279af365b10752ed22cb3ac6e9f7c78b75a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Since we're doing the work in series, we can just use &lt;code&gt;results.push(result)&lt;/code&gt; since we know we won't get results out of order. In the above we could have used &lt;code&gt;results[index] = result;&lt;/code&gt;, but in some of the following examples we don't have an index to use.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Поскольку мы выполняем эту работу последовательно, мы можем просто использовать &lt;code&gt;results.push(result)&lt;/code&gt; поскольку мы знаем, что не получим результаты не в порядке. В приведенном выше примере мы могли бы использовать &lt;code&gt;results[index] = result;&lt;/code&gt; но в некоторых из следующих примеров у нас нет индекса для использования.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0dca3ab11483f31910ef1b76a0f2b57827edfed0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(We could do away with &lt;code&gt;expecting&lt;/code&gt; and just use &lt;code&gt;results.length === theArray.length&lt;/code&gt;, but that leaves us open to the possibility that &lt;code&gt;theArray&lt;/code&gt; is changed while the calls are outstanding...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Мы могли бы покончить с &lt;code&gt;expecting&lt;/code&gt; и просто использовать &lt;code&gt;results.length === theArray.length&lt;/code&gt; , но это оставляет нас открытым для вероятности того, что &lt;code&gt;theArray&lt;/code&gt; будет изменен, пока вызовы ожидают ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c79ef9a065b5b6d162c99553810bc34db9b4c98" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A Image from one of the answers here, Correctly explains callback use...&lt;/em&gt;
We give our function(function utilising data returned from server) to function calling server.</source>
          <target state="translated">&lt;em&gt;Изображение из одного из ответов здесь, правильно объясняет использование обратного вызова ...&lt;/em&gt; Мы передаем нашу функцию (функцию, использующую данные, возвращенные с сервера) функции, вызывающей сервер.</target>
        </trans-unit>
        <trans-unit id="575713933b89fb879752fb918e398d207981e848" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Error handler&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Обработчик ошибок&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb7a5019ca58e906cfe2794d7f8ae19085308f37" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Of course, if &lt;code&gt;doSomethingAsync&lt;/code&gt; passed us errors, we'd use &lt;code&gt;reject&lt;/code&gt; to reject the promise when we got an error.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Конечно, если &lt;code&gt;doSomethingAsync&lt;/code&gt; передаст нам ошибки, мы будем использовать &lt;code&gt;reject&lt;/code&gt; чтобы отклонить обещание, когда мы получили ошибку.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29ac499569a5a06c4d82ef94c11d97109d312692" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PS: As the first test I wrote x('x', displayAjax)..., and it totally got a response...??? So I checked the folder where the HTML is located, and there was a file called 'x.xml'. So even if you forget the extension of your file XMLHttpRequest 2 WILL FIND IT&lt;/em&gt;. I LOL'd</source>
          <target state="translated">&lt;em&gt;PS: В качестве первого теста я написал x ('x', displayAjax) ..., и он полностью получил ответ ... ???&lt;/em&gt; &lt;em&gt;Поэтому я проверил папку, в которой находится HTML, и там был файл с именем &amp;laquo;x.xml&amp;raquo;.&lt;/em&gt; &lt;em&gt;Так что даже если вы забудете расширение вашего файла, XMLHttpRequest 2 НАЙДЕТ ЕГО&lt;/em&gt; . Я смеюсь</target>
        </trans-unit>
        <trans-unit id="a453fdc787181e5194220141468f98edcb49264c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Read a file synchronous&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Чтение файла синхронно&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f873c1d50c07030d55b6897f696affcc44c234c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 2&lt;/strong&gt; (first of all read the answers from &lt;a href=&quot;https://stackoverflow.com/a/16825593/19068&quot;&gt;Benjamin Gruenbaum&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://stackoverflow.com/a/14220323/19068&quot;&gt;Felix Kling&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 2&lt;/strong&gt; (прежде всего прочитайте ответы &lt;a href=&quot;https://stackoverflow.com/a/16825593/19068&quot;&gt;Бенджамина Грюнбаума&lt;/a&gt; и &lt;a href=&quot;https://stackoverflow.com/a/14220323/19068&quot;&gt;Феликса Клинга&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7bb7d03442a106c3a66906d1c9d76fc88badb345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;The Event Loop and Concurrency Model&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;Цикл событий и модель параллелизма&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc4c0812139669b4b9302dd36333c2148a9da551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All three are available in current browsers, and node 7+.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Все три доступны в текущих браузерах, и узел 7+.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="890ea8c5734449e60d41906d358b6206ed712f11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt; (popular in node)</source>
          <target state="translated">&lt;strong&gt;Обратные вызовы&lt;/strong&gt; (популярные в узле)</target>
        </trans-unit>
        <trans-unit id="e2ab2f71e857cb3d2466201010b62a27fd2e5e37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't do that.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Не делай этого.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="afaf690b015b9a3ab311cb3b9d55efc3bab713ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 way (async - await)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 способ (асинхронно - жду)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d78b4767222f91ac61373691a4d965d332d201f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Embrace the asynchronous nature of JavaScript!&lt;/strong&gt; While certain asynchronous operations provide synchronous counterparts (so does &quot;Ajax&quot;), it's generally discouraged to use them, especially in a browser context.</source>
          <target state="translated">&lt;strong&gt;Примите асинхронную природу JavaScript!&lt;/strong&gt; Хотя некоторые асинхронные операции предоставляют синхронные аналоги (как и &amp;laquo;Ajax&amp;raquo;), обычно их не рекомендуется использовать, особенно в контексте браузера.</target>
        </trans-unit>
        <trans-unit id="109d60edc3e638d2bab113fbb027ee1e4e879a32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Have a look at this example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Посмотрите на этот пример:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09004b4c20addc68d6df669ac50a41fb497dea47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heads up!&lt;/strong&gt; It is not possible to make a synchronous &lt;a href=&quot;https://stackoverflow.com/questions/2067472/please-explain-jsonp&quot;&gt;JSONP&lt;/a&gt; request. JSONP by its very nature is always asynchronous (one more reason to not even consider this option).</source>
          <target state="translated">&lt;strong&gt;Берегись!&lt;/strong&gt; Невозможно сделать синхронный запрос &lt;a href=&quot;https://stackoverflow.com/questions/2067472/please-explain-jsonp&quot;&gt;JSONP&lt;/a&gt; . JSONP по своей природе всегда асинхронен (еще одна причина, чтобы даже не рассматривать эту опцию).</target>
        </trans-unit>
        <trans-unit id="db3e68b8187a2a11a0f5fea968a2add5f24c4dfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; You can only use &lt;code&gt;await&lt;/code&gt; inside an &lt;code&gt;async&lt;/code&gt; function. Right now, top-level &lt;code&gt;await&lt;/code&gt; isn't yet supported, so you might have to make an async IIFE (&lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately_invoked_function_expression&quot;&gt;Immediately Invoked Function Expression&lt;/a&gt;) to start an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="translated">&lt;strong&gt;Важно:&lt;/strong&gt; вы можете использовать &lt;code&gt;await&lt;/code&gt; только внутри &lt;code&gt;async&lt;/code&gt; функции. В настоящее время ожидание верхнего уровня еще не поддерживается, поэтому вам может потребоваться сделать асинхронное выражение IIFE ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately_invoked_function_expression&quot;&gt;выражение немедленно вызванной функции&lt;/a&gt; ) для запуска &lt;code&gt;async&lt;/code&gt; контекста.</target>
        </trans-unit>
        <trans-unit id="d1a2d5a4642c349de8193773228017c7500f4e56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;
Recent Spotify &lt;code&gt;search&lt;/code&gt; APIs will require an access token to be specified in the request headers:</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ. Для&lt;/strong&gt; последних API &lt;code&gt;search&lt;/code&gt; Spotify потребуется указать токен доступа в заголовках запроса:</target>
        </trans-unit>
        <trans-unit id="4b966ba6c20e45f447ff2e8f03f268e29a52a4f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises with &lt;code&gt;async/await&lt;/code&gt;&lt;/strong&gt; (ES2017+, available in older browsers if you use a transpiler or regenerator)</source>
          <target state="translated">&lt;strong&gt;Обещания с &lt;code&gt;async/await&lt;/code&gt; &lt;/strong&gt; (ES2017 +, доступный в старых браузерах, если вы используете транспортер или регенератор)</target>
        </trans-unit>
        <trans-unit id="6473a819e62a6a22028f1318142e8cba26e9b5a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises with &lt;code&gt;then()&lt;/code&gt;&lt;/strong&gt; (ES2015+, available in older browsers if you use one of the many promise libraries)</source>
          <target state="translated">&lt;strong&gt;Обещания с помощью &lt;code&gt;then()&lt;/code&gt; &lt;/strong&gt; (ES2015 +, доступно в старых браузерах, если вы используете одну из множества библиотек обещаний)</target>
        </trans-unit>
        <trans-unit id="04c41fa090162049f70a4e607252fab3dd0bb0ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short answer&lt;/strong&gt;: Your &lt;code&gt;foo()&lt;/code&gt; method returns immediately, while the &lt;code&gt;$ajax()&lt;/code&gt; call executes asynchronously &lt;em&gt;after the function returns&lt;/em&gt;. The problem is then how or where to store the results retrieved by the async call once it returns.</source>
          <target state="translated">&lt;strong&gt;Краткий ответ&lt;/strong&gt; : ваш метод &lt;code&gt;foo()&lt;/code&gt; возвращается немедленно, а вызов &lt;code&gt;$ajax()&lt;/code&gt; выполняется асинхронно &lt;em&gt;после возврата из функции&lt;/em&gt; . Тогда проблема заключается в том, как или где хранить результаты, полученные асинхронным вызовом после его возврата.</target>
        </trans-unit>
        <trans-unit id="f4645089306c6a1d783c20f54349274a135ed097" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, how do we tackle this issue?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Итак, как нам решить эту проблему?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ab003d485f673dee9ae9f1e5a74cdd4ee60e809" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key thing here is the order of execution. That is&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ключевым моментом здесь является порядок исполнения.&lt;/strong&gt; &lt;strong&gt;Это&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fac01d33af22c926036bf26176e2ea876531efc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the plnkr:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Это плнкр:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ed0d7ce5e48365488a89a8f5818cd02ab54aa58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WHEN is something going to run&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;КОГДА-то собирается бежать&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8fb2f83aee2cbeff4ac6fcb5ea50cce08e5c218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fulfilled&lt;/strong&gt; meaning that the computation completed successfully.</source>
          <target state="translated">&lt;strong&gt;выполнив это&lt;/strong&gt; означает, что вычисление завершено успешно.</target>
        </trans-unit>
        <trans-unit id="3030d3b7a04661fbb4185df915ebeef20d9e0313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rejected&lt;/strong&gt; meaning that the computation failed.</source>
          <target state="translated">&lt;strong&gt;отклонено&lt;/strong&gt; означает, что вычисление не удалось.</target>
        </trans-unit>
        <trans-unit id="e9da82d285e8df3659dc9d639d7f7999131d7220" translate="yes" xml:space="preserve">
          <source>A Promise is a &lt;em&gt;value over time&lt;/em&gt;. Promises have state, they start as pending with no value and can settle to:</source>
          <target state="translated">Обещание - это &lt;em&gt;ценность с течением времени&lt;/em&gt; . Обещания имеют состояние, они начинаются как ожидающие без значения и могут рассчитывать на:</target>
        </trans-unit>
        <trans-unit id="0fa2ed570336fff9061c7fed76b7c10d8559bca9" translate="yes" xml:space="preserve">
          <source>A callback is simply a function passed to another function. That other function can call the function passed whenever it is ready. In the context of an asynchronous process, the callback will be called whenever the asynchronous process is done. Usually, the result is passed to the callback.</source>
          <target state="translated">Обратный вызов-это просто функция,переданная другой функции.Эта другая функция может вызывать переданную функцию,когда она готова.В контексте асинхронного процесса,обратный вызов будет вызываться всякий раз,когда асинхронный процесс завершен.Обычно результат передается на обратный вызов.</target>
        </trans-unit>
        <trans-unit id="f9e8a04c6605f9a32383dcbf481370c3e715820d" translate="yes" xml:space="preserve">
          <source>A promise can only change states &lt;em&gt;once&lt;/em&gt; after which it will always stay at the same state forever. You can attach &lt;code&gt;then&lt;/code&gt; handlers to promises to extract their value and handle errors. &lt;code&gt;then&lt;/code&gt; handlers allow &lt;a href=&quot;https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks&quot;&gt;chaining&lt;/a&gt; of calls. Promises are created by &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;using APIs that return them&lt;/a&gt;. For example, the more modern AJAX replacement &lt;code&gt;fetch&lt;/code&gt; or jQuery's &lt;code&gt;$.get&lt;/code&gt; return promises.</source>
          <target state="translated">Обещание может изменить состояние &lt;em&gt;только один раз,&lt;/em&gt; после чего оно всегда будет оставаться в одном и том же состоянии навсегда. &lt;code&gt;then&lt;/code&gt; вы можете прикрепить обработчики к обещаниям, чтобы извлечь их значение и обработать ошибки. &lt;code&gt;then&lt;/code&gt; обработчики разрешают &lt;a href=&quot;https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks&quot;&gt;цепочку&lt;/a&gt; вызовов. Обещания создаются с &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;помощью API, которые их возвращают&lt;/a&gt; . Например, более современное &lt;code&gt;fetch&lt;/code&gt; замены AJAX или &lt;code&gt;$.get&lt;/code&gt; возврата $ .get jQuery.</target>
        </trans-unit>
        <trans-unit id="d64b3ccbf97c56e6baf992073261e3d4c261d264" translate="yes" xml:space="preserve">
          <source>A+ Promises.js</source>
          <target state="translated">A+Promises.js</target>
        </trans-unit>
        <trans-unit id="7b2622a1b73a931e6ca38a355f7e3e8ea446ddb8" translate="yes" xml:space="preserve">
          <source>Above, we said, &quot;JS has no way to know that it needs to &lt;strong&gt;wait&lt;/strong&gt; for the first call to finish before it executes the second&quot;. Wouldn't it be nice if there &lt;strong&gt;was&lt;/strong&gt; some way to tell JS that? It turns out that there is--the &lt;code&gt;await&lt;/code&gt; keyword, used inside a special type of function called an &quot;async&quot; function. This feature is part of the upcoming version of ES but is already available in transpilers such as Babel given the right presets. This allows us to simply write</source>
          <target state="translated">Выше мы говорили: &amp;laquo;JS не может знать, что ему нужно &lt;strong&gt;дождаться&lt;/strong&gt; завершения первого вызова, прежде чем он выполнит второй&amp;raquo;. Разве не было бы хорошо, если бы &lt;strong&gt;был&lt;/strong&gt; какой-то способ сказать JS об этом? Оказывается, есть ключевое слово &lt;code&gt;await&lt;/code&gt; , используемое внутри специального типа функции, называемой &amp;laquo;асинхронной&amp;raquo; функцией. Эта функция является частью будущей версии ES, но она уже доступна в таких транспортерах, как Babel, с правильными настройками. Это позволяет нам просто написать</target>
        </trans-unit>
        <trans-unit id="e1ca54ffb7b2f8af43c2a3bf761dc7cd1da55e53" translate="yes" xml:space="preserve">
          <source>Actually, all we've done is added a &lt;code&gt;return&lt;/code&gt; to the call to &lt;code&gt;$.ajax&lt;/code&gt;. This works because jQuery's &lt;code&gt;$.ajax&lt;/code&gt; already returns a kind of promise-like thing. (In practice, without getting into details, we would prefer to wrap this call so as for return a real promise, or use some alternative to &lt;code&gt;$.ajax&lt;/code&gt; that does so.) Now, if we want to load the file and wait for it to finish and then do something, we can simply say</source>
          <target state="translated">На самом деле все, что мы сделали, это добавили &lt;code&gt;return&lt;/code&gt; к вызову &lt;code&gt;$.ajax&lt;/code&gt; . Это работает, потому что jQuery &lt;code&gt;$.ajax&lt;/code&gt; уже возвращает что-то вроде обещания. (На практике, не вдаваясь в подробности, мы бы предпочли обернуть этот вызов так, чтобы он возвращал реальное обещание, или использовать некоторую альтернативу &lt;code&gt;$.ajax&lt;/code&gt; которая делает это.) Теперь, если мы хотим загрузить файл и дождаться его чтобы закончить, а затем сделать что-то, мы можем просто сказать,</target>
        </trans-unit>
        <trans-unit id="8806f1d6f77f315f3c6459851ebdd89a11e28f02" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;'async'&lt;/a&gt; keyword to the parent function</source>
          <target state="translated">Добавьте ключевое слово &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;async&lt;/a&gt; в родительскую функцию</target>
        </trans-unit>
        <trans-unit id="529deb621e57605154d7312ba8f12b3f554d9040" translate="yes" xml:space="preserve">
          <source>Additionally here is the promises &lt;a href=&quot;https://github.com/promises-aplus/promises-spec&quot;&gt;spec&lt;/a&gt; define here.</source>
          <target state="translated">Дополнительно здесь есть &lt;a href=&quot;https://github.com/promises-aplus/promises-spec&quot;&gt;спецификация&lt;/a&gt; обещаний здесь.</target>
        </trans-unit>
        <trans-unit id="ab38701d1301596d1056dacff49b4a862d011ba3" translate="yes" xml:space="preserve">
          <source>Again ... it's a very short function, but it does get &amp;amp; post.</source>
          <target state="translated">Опять же ... это очень короткая функция, но она получает и публикует.</target>
        </trans-unit>
        <trans-unit id="54729d47d0181e621bfce461fcd3befc07e5b989" translate="yes" xml:space="preserve">
          <source>All of this is really bad user experience. The user won't be able to tell whether everything is working fine or not. Furthermore, the effect will be worse for users with a slow connection.</source>
          <target state="translated">Все это очень плохо для пользователя.Пользователь не сможет сказать,все ли работает нормально или нет.Более того,эффект будет хуже для пользователей с медленным подключением.</target>
        </trans-unit>
        <trans-unit id="644cfe271cac18a474c99dd756307f08b1e0e327" translate="yes" xml:space="preserve">
          <source>And executing it like this.</source>
          <target state="translated">И исполнять его вот так.</target>
        </trans-unit>
        <trans-unit id="761067f16b11d2d1e088fb27ee5a3facce3b502f" translate="yes" xml:space="preserve">
          <source>Angular1</source>
          <target state="translated">Angular1</target>
        </trans-unit>
        <trans-unit id="a6f848c2ffe2ed313ae1ff7c87a3e8f4231023f9" translate="yes" xml:space="preserve">
          <source>Angular2 and Later</source>
          <target state="translated">Угловой2 и позже</target>
        </trans-unit>
        <trans-unit id="700b18f544e30a3391a16d96b67c29e5dd7f4d12" translate="yes" xml:space="preserve">
          <source>Another approach to return a value from an asynchronous function, is to pass in an object that will store the result from the asynchronous function.</source>
          <target state="translated">Другой подход к возвращению значения из асинхронной функции-это передача в объект,в котором будет храниться результат от асинхронной функции.</target>
        </trans-unit>
        <trans-unit id="6e0e29ebcd867f1dca1b8c6b1fb3343ba7d8745a" translate="yes" xml:space="preserve">
          <source>Another point is... if you work with APIs or just your own list's files or whatever you always use different functions for each request...</source>
          <target state="translated">Другой момент...если вы работаете с API или просто с файлами вашего собственного списка,или с тем,что вы всегда используете различные функции для каждого запроса....</target>
        </trans-unit>
        <trans-unit id="64aef2853dbea8a1653b08bcdf147b457091ff7b" translate="yes" xml:space="preserve">
          <source>Another solution is to execute code via sequential executor &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt;.</source>
          <target state="translated">Другое решение - выполнить код через последовательного исполнителя &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2cb720802474bc4792fbb02842d36aeeabbeceb" translate="yes" xml:space="preserve">
          <source>Apart from using &lt;code&gt;then/catch&lt;/code&gt; to work with promises, there exists one more approach. The idea is to &lt;em&gt;recognize an asynchronous function&lt;/em&gt; and then &lt;em&gt;wait for the promises&lt;/em&gt; to resolve, before moving to the next line of code. It's still just the &lt;code&gt;promises&lt;/code&gt; under the hood, but with a different syntactical approach. To make things clearer, you can find a comparison below:</source>
          <target state="translated">Помимо использования &lt;code&gt;then/catch&lt;/code&gt; для работы с обещаниями, существует еще один подход. Идея состоит в том, чтобы &lt;em&gt;распознать асинхронную функцию,&lt;/em&gt; а затем &lt;em&gt;дождаться&lt;/em&gt; разрешения &lt;em&gt;обещаний&lt;/em&gt; , прежде чем перейти к следующей строке кода. Это все еще только &lt;code&gt;promises&lt;/code&gt; под капотом, но с другим синтаксическим подходом. Чтобы прояснить ситуацию, вы можете найти сравнение ниже:</target>
        </trans-unit>
        <trans-unit id="4d6935922dd9171b57188004a7345d312359feff" translate="yes" xml:space="preserve">
          <source>Applied to our Ajax call we could use promises like this:</source>
          <target state="translated">Применительно к нашему звонку по &quot;Аяксу&quot; мы могли бы использовать такие обещания:</target>
        </trans-unit>
        <trans-unit id="1ef6615c95aa80cbc5318149fff9515811e8e9d4" translate="yes" xml:space="preserve">
          <source>Applying this</source>
          <target state="translated">Применяя это</target>
        </trans-unit>
        <trans-unit id="f1a34583be1c0d1698743056ac6453867467e99a" translate="yes" xml:space="preserve">
          <source>As I mentioned, some(!) asynchronous operations have synchronous counterparts. I don't advocate their use, but for completeness' sake, here is how you would perform a synchronous call:</source>
          <target state="translated">Как я уже упоминал,некоторые(!)асинхронные операции имеют синхронные аналоги.Я не выступаю за их использование,но ради полноты,вот как бы вы выполняли синхронный вызов:</target>
        </trans-unit>
        <trans-unit id="d690325261d4ed328617f51bcb035e4e34411085" translate="yes" xml:space="preserve">
          <source>As for synchronous AJAX, &lt;strong&gt;don't do it!&lt;/strong&gt; Felix's answer raises some compelling arguments about why it's a bad idea. To sum it up, it'll freeze the user's browser until the server returns the response and create a very bad user experience. Here is another short summary taken from MDN on why:</source>
          <target state="translated">Что касается синхронного AJAX, &lt;strong&gt;не делайте этого!&lt;/strong&gt; Ответ Феликса вызывает некоторые убедительные аргументы о том, почему это плохая идея. Подводя итог, он замораживает браузер пользователя до тех пор, пока сервер не вернет ответ и не создаст очень плохой пользовательский опыт. Вот еще одно краткое изложение MDN о том, почему:</target>
        </trans-unit>
        <trans-unit id="4406a09393c68f9778335e6efa2ba72dfa43398d" translate="yes" xml:space="preserve">
          <source>As mentioned in the comment the use of error &amp;amp;&amp;amp; synchronous does completely break the point of the answer. Which is a nice short way to use Ajax in the proper way?</source>
          <target state="translated">Как уже упоминалось в комментарии, использование error &amp;amp;&amp;amp; синхронный полностью нарушает смысл ответа. Какой хороший короткий способ правильно использовать Ajax?</target>
        </trans-unit>
        <trans-unit id="3d039321bb1e1655c4cd32eb77e5d556b9a9d4cc" translate="yes" xml:space="preserve">
          <source>As you can see &lt;code&gt;getJoke&lt;/code&gt; is &lt;strong&gt;returning a&lt;/strong&gt; resolved &lt;strong&gt;promise&lt;/strong&gt; (it is resolved when returning &lt;code&gt;res.data.value&lt;/code&gt;). So you wait until the &lt;strong&gt;$http.get&lt;/strong&gt; request is completed and then &lt;strong&gt;console.log(res.joke)&lt;/strong&gt; is executed (as a normal asynchronous flow).</source>
          <target state="translated">Как видите, &lt;code&gt;getJoke&lt;/code&gt; &lt;strong&gt;возвращает&lt;/strong&gt; разрешенное &lt;strong&gt;обещание&lt;/strong&gt; (оно разрешается при возврате &lt;code&gt;res.data.value&lt;/code&gt; ). Поэтому вы ждете, пока запрос &lt;strong&gt;$ http.get не&lt;/strong&gt; будет выполнен, а затем будет выполнен &lt;strong&gt;console.log (res.joke)&lt;/strong&gt; (как обычный асинхронный поток).</target>
        </trans-unit>
        <trans-unit id="6be3c4864e2a35cc4ac8cfd91a74da6e56a1ee18" translate="yes" xml:space="preserve">
          <source>As you can see I didn't implement sync... it's a bad thing.</source>
          <target state="translated">Как видите,я не реализовал синхронизацию...это плохо.</target>
        </trans-unit>
        <trans-unit id="3e214af7884162cf40fb2934293a2a307f51fd46" translate="yes" xml:space="preserve">
          <source>As you can see:</source>
          <target state="translated">Как видите:</target>
        </trans-unit>
        <trans-unit id="3d7fac7964f752248f02c5aa61c85fd417dcfbcf" translate="yes" xml:space="preserve">
          <source>Asynchronous</source>
          <target state="translated">Asynchronous</target>
        </trans-unit>
        <trans-unit id="9ce552a69176ba76938ef8727847cfb9c28c9943" translate="yes" xml:space="preserve">
          <source>Basically, instead of returning a &lt;em&gt;value&lt;/em&gt; which we can't do because of the concurrency model - we're returning a &lt;em&gt;wrapper&lt;/em&gt; for a value that we can &lt;em&gt;unwrap&lt;/em&gt; with &lt;code&gt;then&lt;/code&gt;. It's like a box you can open with &lt;code&gt;then&lt;/code&gt;.</source>
          <target state="translated">По сути, вместо того, чтобы возвращать &lt;em&gt;значение,&lt;/em&gt; которое мы не можем сделать из-за модели параллелизма - мы возвращаем &lt;em&gt;оболочку&lt;/em&gt; для значения, которое мы можем &lt;code&gt;then&lt;/code&gt; &lt;em&gt;развернуть&lt;/em&gt; . Это как коробка, с которой ты можешь открыть.</target>
        </trans-unit>
        <trans-unit id="eab484a08dfc236925e2ba1434abe3c27155a03c" translate="yes" xml:space="preserve">
          <source>Because JS has no way to know that it needs to &lt;strong&gt;wait&lt;/strong&gt; for &lt;code&gt;order_milk&lt;/code&gt; to finish before it executes &lt;code&gt;put_in_coffee&lt;/code&gt;. In other words, it does not know that &lt;code&gt;order_milk&lt;/code&gt; is &lt;strong&gt;asynchronous&lt;/strong&gt;--is something that is not going to result in milk until some future time. JS, and other declarative languages execute one statement after another without waiting.</source>
          <target state="translated">Потому что у JS нет возможности узнать, что ему нужно &lt;strong&gt;дождаться&lt;/strong&gt; &lt;code&gt;order_milk&lt;/code&gt; прежде чем он выполнит &lt;code&gt;put_in_coffee&lt;/code&gt; . Другими словами, он не знает, что &lt;code&gt;order_milk&lt;/code&gt; является &lt;strong&gt;асинхронным -&lt;/strong&gt; это то, что не приведет к появлению молока до некоторого будущего времени. JS и другие декларативные языки выполняют один оператор за другим без ожидания.</target>
        </trans-unit>
        <trans-unit id="4fb46d91439c44dca8be62ad2c6da7e246ac7424" translate="yes" xml:space="preserve">
          <source>Because a callback is not executed immediately but at a later time it's important to pass the reference to the function not it executed. so</source>
          <target state="translated">Поскольку обратный вызов не выполняется сразу,но в последующем важно передать ссылку на функцию,которая не была выполнена,поэтому</target>
        </trans-unit>
        <trans-unit id="e949293bb3141d39921183faafd54e8bcb4089c2" translate="yes" xml:space="preserve">
          <source>Becomes:</source>
          <target state="translated">Becomes:</target>
        </trans-unit>
        <trans-unit id="33e41fa8d678aeb4e035f2f254faf9c3f81da31a" translate="yes" xml:space="preserve">
          <source>Browser Promise object</source>
          <target state="translated">Объект &quot;Браузерное обещание</target>
        </trans-unit>
        <trans-unit id="765bf6bf6d4dba7ff5f829d9d93bb123d301ca4a" translate="yes" xml:space="preserve">
          <source>Browser can be divided into three parts:</source>
          <target state="translated">Браузер можно разделить на три части:</target>
        </trans-unit>
        <trans-unit id="d450093edec3c9a5aeeeb0beef75d475c35a50cd" translate="yes" xml:space="preserve">
          <source>But how you can do it in pure &lt;strong&gt;javascript&lt;/strong&gt; or &lt;strong&gt;jQuery&lt;/strong&gt; for example as you asked in this question?</source>
          <target state="translated">Но как вы можете сделать это в чистом &lt;strong&gt;javascript&lt;/strong&gt; или &lt;strong&gt;jQuery,&lt;/strong&gt; например, как вы задали в этом вопросе?</target>
        </trans-unit>
        <trans-unit id="a64b0676afddefea547c307ed3e8295760faffaa" translate="yes" xml:space="preserve">
          <source>But the fix is easy:</source>
          <target state="translated">Но исправить это легко:</target>
        </trans-unit>
        <trans-unit id="77d296e55d0766d8200053d7f3cfd7c13d9226be" translate="yes" xml:space="preserve">
          <source>But the question here is how to return an Ajax response... (I added an easy way.)</source>
          <target state="translated">Но вопрос в том,как вернуть ответ Аякса...(Я добавил простой способ.)</target>
        </trans-unit>
        <trans-unit id="871ea55bfadd9c09cdde6b012a015872456c8c66" translate="yes" xml:space="preserve">
          <source>But there's still something vaguely dissatisfying about having to write code one way if synchronous and a quite different way if asynchronous. For synchronous, we write</source>
          <target state="translated">Но все равно есть что-то смутно недовольное в том,что приходится писать код одним способом,если он синхронный,и совсем другим,если асинхронный.Для синхронного мы пишем</target>
        </trans-unit>
        <trans-unit id="6662b4c845488fe6c8b6ee72b41f77fa73bca428" translate="yes" xml:space="preserve">
          <source>But to really get out an error the &lt;strong&gt;only&lt;/strong&gt; way is to write a wrong URL in which case every browser throws an error.</source>
          <target state="translated">Но чтобы действительно вывести ошибку, &lt;strong&gt;единственный&lt;/strong&gt; способ - написать неправильный URL, и в этом случае каждый браузер выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="b6fe1615524c00038c401cf5c333c9dc307f8bd8" translate="yes" xml:space="preserve">
          <source>But wait...!</source>
          <target state="translated">Но подожди...!</target>
        </trans-unit>
        <trans-unit id="dfb64faad30b77313e3dfe8cbd9a6f1d588843af" translate="yes" xml:space="preserve">
          <source>But what if you need to &lt;em&gt;return&lt;/em&gt; those results from a function? As the other answers have pointed out, you can't; you have to have your function accept and call a callback (or return a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;). Here's a callback version:</source>
          <target state="translated">Но что, если вам нужно &lt;em&gt;вернуть&lt;/em&gt; эти результаты из функции? Как указали другие ответы, вы не можете; вам нужно, чтобы ваша функция принимала и вызывала обратный вызов (или возвращала &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;обещание&lt;/a&gt; ). Вот версия обратного вызова:</target>
        </trans-unit>
        <trans-unit id="53f5926dc5af0fddf203c78ec84b5d65b51a2f52" translate="yes" xml:space="preserve">
          <source>But you can do a lot of stuff with XMLHttpRequest 2:</source>
          <target state="translated">Но с XMLHttpRequest 2 можно много чего сделать:</target>
        </trans-unit>
        <trans-unit id="b0d6941afab03ca7758a76da0c336ec6d021825e" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;http://caniuse.com/xhr2&quot;&gt;XMLHttpRequest advanced features&lt;/a&gt;</source>
          <target state="translated">Ознакомьтесь с &lt;a href=&quot;http://caniuse.com/xhr2&quot;&gt;расширенными функциями XMLHttpRequest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31ebfd440a69ecc3715e49c5b6a6c1dd6d4b0371" translate="yes" xml:space="preserve">
          <source>Consider an example. You call the milkman and order some milk. When it comes, you want to put it in your coffee. You can't put the milk in your coffee right now, because it is not here yet. You have to wait for it to come before putting it in your coffee. In other words, the following won't work:</source>
          <target state="translated">Рассмотрим пример.Вы звоните молочнику и заказываете молоко.Когда оно придет,ты захочешь положить его в свой кофе.Вы не можете положить молоко в кофе прямо сейчас,потому что его еще нет.Вы должны подождать,пока оно придет,прежде чем положить его в кофе.Другими словами,следующее не сработает:</target>
        </trans-unit>
        <trans-unit id="84b2d3dacc41e20a8047eac062d786928aeea668" translate="yes" xml:space="preserve">
          <source>Context. The example is querying the &lt;a href=&quot;https://developer.spotify.com/web-api/endpoint-reference/&quot;&gt;Spotify Web API&lt;/a&gt; endpoint in order to search for &lt;code&gt;playlist&lt;/code&gt; objects for a given set of query strings:</source>
          <target state="translated">Контекст. Пример запрашивает конечную точку &lt;a href=&quot;https://developer.spotify.com/web-api/endpoint-reference/&quot;&gt;Spotify Web API&lt;/a&gt; для поиска объектов &lt;code&gt;playlist&lt;/code&gt; для заданного набора строк запроса:</target>
        </trans-unit>
        <trans-unit id="b985b8de161adfd30380ec1c45ac41353ff18286" translate="yes" xml:space="preserve">
          <source>Current &lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-async_functions&quot;&gt;browser&lt;/a&gt; and &lt;a href=&quot;http://node.green/#ES2017-features-async-functions&quot;&gt;node&lt;/a&gt; versions support &lt;code&gt;async/await&lt;/code&gt;. You can also support older environments by transforming your code to ES5 with the help of &lt;a href=&quot;https://github.com/facebook/regenerator&quot;&gt;regenerator&lt;/a&gt; (or tools that use regenerator, such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;).</source>
          <target state="translated">Текущие версии &lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-async_functions&quot;&gt;браузера&lt;/a&gt; и &lt;a href=&quot;http://node.green/#ES2017-features-async-functions&quot;&gt;узла&lt;/a&gt; поддерживают &lt;code&gt;async/await&lt;/code&gt; . Вы также можете поддерживать более старые среды, преобразовав свой код в ES5 с помощью &lt;a href=&quot;https://github.com/facebook/regenerator&quot;&gt;регенератора&lt;/a&gt; (или инструментов, использующих регенератор, таких как &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="23b9d4749a9f206dd4aecf7d5fe1ab0fe7998221" translate="yes" xml:space="preserve">
          <source>Define a function which returns a &lt;strong&gt;Promise&lt;/strong&gt;, in this case an Ajax call:</source>
          <target state="translated">Определите функцию, которая возвращает &lt;strong&gt;Promise&lt;/strong&gt; , в данном случае Ajax-вызов:</target>
        </trans-unit>
        <trans-unit id="3047a156238e05c9e91f44e59216ce4350e7d875" translate="yes" xml:space="preserve">
          <source>Describing all the advantages that promise offer is beyond the scope of this answer, but if you write new code, you should seriously consider them. They provide a great abstraction and separation of your code.</source>
          <target state="translated">Описание всех преимуществ,которые дают обещания,выходит за рамки этого ответа,но если вы пишете новый код,вы должны серьезно рассмотреть их.Они обеспечивают отличную абстракцию и разделение вашего кода.</target>
        </trans-unit>
        <trans-unit id="d24cf059acad77f2348de6ab9a950dcb953d0c1e" translate="yes" xml:space="preserve">
          <source>Difficulties could arise when you have to work with third-party code, but most problems can be solved by just thinking through the application flow.</source>
          <target state="translated">Трудности могут возникать,когда приходится работать со сторонним кодом,но большинство проблем можно решить,просто продумывая поток приложений.</target>
        </trans-unit>
        <trans-unit id="291b4e6259557593d37f6433293f59fe5f76d601" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 has 'generators' which allow you to easily program in an asynchronous style.</source>
          <target state="translated">В ECMAScript 6 есть &quot;генераторы&quot;,которые позволяют легко программировать в асинхронном стиле.</target>
        </trans-unit>
        <trans-unit id="e3af59b16940b2e81235ebbcb74c7f1a75b7e5e5" translate="yes" xml:space="preserve">
          <source>ES2015 (ES6)</source>
          <target state="translated">ES2015 (ES6)</target>
        </trans-unit>
        <trans-unit id="7dbb3904074ff18348bd30e832250b33427cdc38" translate="yes" xml:space="preserve">
          <source>ES2015+: Promises with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;then()&lt;/a&gt;</source>
          <target state="translated">ES2015 +: обещания с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;then ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35bf367fe5ced0d619315d0cc8f147a296348c43" translate="yes" xml:space="preserve">
          <source>ES2016 (ES7)</source>
          <target state="translated">ES2016 (ES7)</target>
        </trans-unit>
        <trans-unit id="1542f3c49056454d75a06101c17c1785c445d891" translate="yes" xml:space="preserve">
          <source>ES2017+: Promises with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async/await&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ES2017 +: обещания с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async/await&lt;/code&gt; &lt;/a&gt; ожиданием</target>
        </trans-unit>
        <trans-unit id="967cf59859743f73ba18a11fe55a168a8034039e" translate="yes" xml:space="preserve">
          <source>ES6 introduces &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generators&lt;/a&gt; which are functions that can return in the middle and then resume the point they were at. This is typically useful for sequences, for example:</source>
          <target state="translated">ES6 представляет &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;генераторы,&lt;/a&gt; которые являются функциями, которые могут возвращаться в середине и затем возвращаться к точке, в которой они находились. Это обычно полезно для последовательностей, например:</target>
        </trans-unit>
        <trans-unit id="4b08c5e49b030b945e2f126cefe3cc1039afa94b" translate="yes" xml:space="preserve">
          <source>Enter promises</source>
          <target state="translated">Вводные обещания</target>
        </trans-unit>
        <trans-unit id="80993d0449ad6680943f4a71d58a1facc8010c69" translate="yes" xml:space="preserve">
          <source>Error handlers are maybe useful if you set custom headers, set the responseType to blob array buffer or whatever...</source>
          <target state="translated">Обработчики ошибок могут быть полезны,если вы устанавливаете пользовательские заголовки,устанавливаете тип responseType в буфер блочного массива или что-то в этом роде...</target>
        </trans-unit>
        <trans-unit id="52397d788ea7c6b60de8f942da7edb5fd927e6c4" translate="yes" xml:space="preserve">
          <source>Even if you pass 'POSTAPAPAP' as the method it won't throw an error.</source>
          <target state="translated">Даже если вы передадите 'POSTAPAPAP' в качестве метода,это не приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="ed627f8185515e40e63ef82e28b0e78972fa2fad" translate="yes" xml:space="preserve">
          <source>Even if you pass 'fdggdgilfdghfldj' as formdata it won't throw an error.</source>
          <target state="translated">Даже если вы передадите 'fdggdgilfdghfldj' в качестве формата данных,это не приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="c920a57596f644008ba32598f248afdb53f17307" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;findItem&lt;/code&gt; might take a long time to execute, any code coming after &lt;code&gt;var item = findItem();&lt;/code&gt; has to &lt;em&gt;wait&lt;/em&gt; until the function returns the result.</source>
          <target state="translated">Несмотря на то, что выполнение &lt;code&gt;findItem&lt;/code&gt; может занять много времени, любой код, следующий после &lt;code&gt;var item = findItem();&lt;/code&gt; должен &lt;em&gt;ждать,&lt;/em&gt; пока функция вернет результат.</target>
        </trans-unit>
        <trans-unit id="af30fe5dce2e46682e9e3add89a73ab9d1afd392" translate="yes" xml:space="preserve">
          <source>Event Loop runs for forever i.e kind of infinite loop.Event Queue is where all your function are pushed on some event(example:click) this is one by one carried out of queue and put into Event loop which execute this function and prepares it self for next one after first one is executed.This means Execution of one function doesn't starts till the function before it in queue is executed in event loop.</source>
          <target state="translated">Event Loop работает вечно,т.е.является своего рода бесконечным циклом.Очередь событий-это когда вся Ваша функция толкается по какому-либо событию (пример:клик),оно выполняется один за другим и помещается в цикл событий,который выполняет эту функцию и подготавливает ее самостоятельно к следующему после выполнения первого события.</target>
        </trans-unit>
        <trans-unit id="ba81b013536dce95c24ccc172a06bd722742bb6a" translate="yes" xml:space="preserve">
          <source>Every Ajax method of jQuery already returns a &quot;deferred object&quot; (actually a promise of a deferred object) which you can just return from your function:</source>
          <target state="translated">Каждый Ajax-метод jQuery уже возвращает &quot;отложенный объект&quot; (на самом деле обещание отложенного объекта),который вы можете просто вернуть из своей функции:</target>
        </trans-unit>
        <trans-unit id="197abe1392101850410c061421129e3d1b59f596" translate="yes" xml:space="preserve">
          <source>Example found in &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$q&quot;&gt;docs&lt;/a&gt; mentioned below.</source>
          <target state="translated">Пример найден в &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$q&quot;&gt;документах,&lt;/a&gt; упомянутых ниже.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="77810a758bab3888ba66659f3df788816aeb992b" translate="yes" xml:space="preserve">
          <source>Example: jQuery deferred implementation to work with multiple requests</source>
          <target state="translated">Пример:jQuery отложенная реализация для работы с несколькими запросами</target>
        </trans-unit>
        <trans-unit id="6b5bea21483cbaba11f47e563b491712cd328829" translate="yes" xml:space="preserve">
          <source>Examples of usage:</source>
          <target state="translated">Примеры использования:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="2bb87a5dd963da02345343f24198c82aa718d522" translate="yes" xml:space="preserve">
          <source>Felix Kling did a fine job writing an answer for people using jQuery for AJAX, I've decided to provide an alternative for people who aren't.</source>
          <target state="translated">Феликс Клинг проделал отличную работу,написав ответ для людей,использующих jQuery для AJAX,я решил предоставить альтернативу для людей,которые не являются таковыми.</target>
        </trans-unit>
        <trans-unit id="61b6cad34a7477f709f8134369511744282bf7b8" translate="yes" xml:space="preserve">
          <source>Felix Kling did a fine job writing an answer for people using jQuery with callbacks for AJAX. I have an answer for native XHR. This answer is for generic usage of promises either on the frontend or backend.</source>
          <target state="translated">Феликс Клинг проделал отличную работу,написав ответ для людей,использующих jQuery с обратными вызовами для AJAX.У меня есть ответ для родного XHR.Этот ответ предназначен для общего использования обещаний на переднем или заднем плане.</target>
        </trans-unit>
        <trans-unit id="635e0097e3c51f900f56e2ff15075d9128740b8b" translate="yes" xml:space="preserve">
          <source>For each item, a new Promise will fire a block - &lt;code&gt;ExecutionBlock&lt;/code&gt;, parse the result, schedule a new set of promises based on the result array, that is a list of Spotify &lt;code&gt;user&lt;/code&gt; objects and execute the new HTTP call within the &lt;code&gt;ExecutionProfileBlock&lt;/code&gt; asynchronously.</source>
          <target state="translated">Для каждого элемента новое Promise будет запускать блок - &lt;code&gt;ExecutionBlock&lt;/code&gt; , анализировать результат, планировать новый набор обещаний на основе массива результатов, который представляет собой список &lt;code&gt;user&lt;/code&gt; объектов Spotify, и выполнять новый HTTP-вызов внутри &lt;code&gt;ExecutionProfileBlock&lt;/code&gt; асинхронно.</target>
        </trans-unit>
        <trans-unit id="686ea421444c498a952e65a5b7b7b8ef0e77b9a4" translate="yes" xml:space="preserve">
          <source>For example in your case which you are using &lt;strong&gt;jQuery&lt;/strong&gt;, you can do something like this:</source>
          <target state="translated">Например, в вашем случае, когда вы используете &lt;strong&gt;jQuery&lt;/strong&gt; , вы можете сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="5e7f2f5c0f405e9a5beea0b22dfdc929a77c6dbf" translate="yes" xml:space="preserve">
          <source>For more details on how this sort of callback design is done, check Felix's answer.</source>
          <target state="translated">Для получения более подробной информации о том,как осуществляется такой дизайн обратного вызова,проверьте ответ Феликса.</target>
        </trans-unit>
        <trans-unit id="9ae95c96ff6e523f358968e03ed28b68223e6cc4" translate="yes" xml:space="preserve">
          <source>For more information study about &lt;strong&gt;promises&lt;/strong&gt; and &lt;strong&gt;observables&lt;/strong&gt; which are newer ways to do this async stuffs.</source>
          <target state="translated">Для получения дополнительной информации изучите &lt;strong&gt;обещания&lt;/strong&gt; и &lt;strong&gt;наблюдаемые,&lt;/strong&gt; которые являются более новыми способами сделать это асинхронным материалом.</target>
        </trans-unit>
        <trans-unit id="d2c8933d706e47b9253dd050c3950ebb59a4178f" translate="yes" xml:space="preserve">
          <source>For people who are using &lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;, can handle this situation using &lt;code&gt;Promises&lt;/code&gt;.</source>
          <target state="translated">Для людей, которые используют &lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt; , могут справиться с этой ситуацией с помощью &lt;code&gt;Promises&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9244ed786ac52489080bb2ed73727df2582f9b46" translate="yes" xml:space="preserve">
          <source>Handle asynchronous HTTP calls;</source>
          <target state="translated">Обработка асинхронных HTTP-вызовов;</target>
        </trans-unit>
        <trans-unit id="93478a618140fa661d81ab91258f1a651409d131" translate="yes" xml:space="preserve">
          <source>Having said that ... why don't do it the easy way?</source>
          <target state="translated">Сказав это...почему бы не сделать это легким способом?</target>
        </trans-unit>
        <trans-unit id="51d1de74537d4867e5318491d300b2040b09329d" translate="yes" xml:space="preserve">
          <source>Here are some approaches to work with asynchronous requests:</source>
          <target state="translated">Вот некоторые подходы к работе с асинхронными запросами:</target>
        </trans-unit>
        <trans-unit id="089375b0e7ad3fd4224f7a969d79cd0949c40a9f" translate="yes" xml:space="preserve">
          <source>Here is a simple analogy</source>
          <target state="translated">Вот простая аналогия</target>
        </trans-unit>
        <trans-unit id="a3e19bd4dc54096f28f69d4061c9289827b6d622" translate="yes" xml:space="preserve">
          <source>Here is a simple analogy for the issue:</source>
          <target state="translated">Вот простая аналогия:</target>
        </trans-unit>
        <trans-unit id="66783b0ea79ce0b229e6872b71ad5253987aee77" translate="yes" xml:space="preserve">
          <source>Here is a simple example of using a promise:</source>
          <target state="translated">Вот простой пример использования обещания:</target>
        </trans-unit>
        <trans-unit id="3f98c5fe445eb6aa095ee0b24083a641538f5e28" translate="yes" xml:space="preserve">
          <source>Here is an analogy which hopefully makes the difference between synchronous and asynchronous flow clearer:</source>
          <target state="translated">Вот аналогия,которая,как мы надеемся,сделает различие между синхронным и асинхронным потоками более очевидным:</target>
        </trans-unit>
        <trans-unit id="e18b9e6f0b7383abbecaa82bf04e6ad414de12c8" translate="yes" xml:space="preserve">
          <source>Here is an example of the same:</source>
          <target state="translated">Вот пример того же:</target>
        </trans-unit>
        <trans-unit id="bd9e15afe641187b36f9279675ba8535db066ca8" translate="yes" xml:space="preserve">
          <source>Here is an example that builds on top of delay above:</source>
          <target state="translated">Вот пример,который строится поверх задержки,описанной выше:</target>
        </trans-unit>
        <trans-unit id="1197d1f4a9d4cf3b8d6f5178c3cec6d0874a533a" translate="yes" xml:space="preserve">
          <source>Here we defined the function &quot;inline&quot; but you can pass any function reference:</source>
          <target state="translated">Здесь мы определили функцию &quot;inline&quot;,но можно передать любую ссылку на функцию:</target>
        </trans-unit>
        <trans-unit id="164b78f47e3ef1dc3e0cef0b751ea196374fd668" translate="yes" xml:space="preserve">
          <source>Here we passed an anonymous function, but we could just as easily pass a reference to an existing function, making it look like:</source>
          <target state="translated">Здесь мы передали анонимную функцию,но так же легко могли передать ссылку на существующую функцию,сделав ее похожей:</target>
        </trans-unit>
        <trans-unit id="1e64ad5b4497aa10277e2076d4284da48c62d379" translate="yes" xml:space="preserve">
          <source>Here's a working version of your code:</source>
          <target state="translated">Вот рабочая версия вашего кода:</target>
        </trans-unit>
        <trans-unit id="7e3c8edd9d78bba7e3a4b76a43bc5bd629037a8e" translate="yes" xml:space="preserve">
          <source>Hopefully that will make some sense. When you encounter things like this that seem confusing - i highly recommend reading the documentation fully to at least get an understanding of it. It will make you a much better developer.</source>
          <target state="translated">Надеюсь,в этом будет какой-то смысл.Когда вы сталкиваетесь с подобными вещами,которые кажутся запутанными-я настоятельно рекомендую прочитать документацию полностью,чтобы,по крайней мере,понять ее.Это сделает вас гораздо лучшим разработчиком.</target>
        </trans-unit>
        <trans-unit id="156541c40984a4a3ee70fd44f32c4e4796080910" translate="yes" xml:space="preserve">
          <source>How do I return the response from an asynchronous call</source>
          <target state="translated">Как вернуть ответ с асинхронного вызова.</target>
        </trans-unit>
        <trans-unit id="450c3e475d5ba28aa9f650174becd8bb359d1260" translate="yes" xml:space="preserve">
          <source>How do I return the response from an asynchronous call?</source>
          <target state="translated">Как ответить на асинхронный звонок?</target>
        </trans-unit>
        <trans-unit id="89fed459f83d0d8bc59f73a0c70d136088949d94" translate="yes" xml:space="preserve">
          <source>How to make &lt;strong&gt;asynchronous&lt;/strong&gt; code look &lt;strong&gt;synchronous&lt;/strong&gt;?</source>
          <target state="translated">Как заставить &lt;strong&gt;асинхронный&lt;/strong&gt; код выглядеть &lt;strong&gt;синхронно&lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="c25df1a995ff1bfc26f40ebfff6e38eed0cf9af3" translate="yes" xml:space="preserve">
          <source>I am using the &lt;code&gt;result&lt;/code&gt; object to store the value during the asynchronous operation. This allows the result be available even after the asynchronous job.</source>
          <target state="translated">Я использую объект &lt;code&gt;result&lt;/code&gt; для хранения значения во время асинхронной операции. Это позволяет результату быть доступным даже после асинхронного задания.</target>
        </trans-unit>
        <trans-unit id="3082b7f700f005a0779967fd6b3615c7a09694bd" translate="yes" xml:space="preserve">
          <source>I have a function &lt;code&gt;foo&lt;/code&gt; which makes an Ajax request. How can I return the response from &lt;code&gt;foo&lt;/code&gt;?</source>
          <target state="translated">У меня есть функция &lt;code&gt;foo&lt;/code&gt; которая делает запрос Ajax. Как я могу вернуть ответ от &lt;code&gt;foo&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d16b97c7b8f99c277ca18e31f4f0499acffc903b" translate="yes" xml:space="preserve">
          <source>I have extensively discussed this solution &lt;a href=&quot;https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Я подробно обсудил это решение &lt;a href=&quot;https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="871db57e2d8a1b8bb628280aec3e9abeafe80bbf" translate="yes" xml:space="preserve">
          <source>I made a download manager (using ranges on both sides with resume, filereader, filesystem), various image resizers converters using canvas, populate web SQL databases with base64images and much more... But in these cases you should create a function only for that purpose... sometimes you need a blob, array buffers, you can set headers, override mimetype and there is a lot more...</source>
          <target state="translated">Я сделал менеджер загрузок (используя диапазоны с обеих сторон с resume,filereader,файловая система),различные преобразователи размера изображений с помощью холста,заполнить веб базы данных SQL с base64 изображениями и многое другое...Но в этих случаях нужно создавать функцию только для этого...Иногда нужны капля,массивные буферы,можно задавать заголовки,переопределять миметипы и многое другое...</target>
        </trans-unit>
        <trans-unit id="aabb558dc219037662405ce169cc7769e808b314" translate="yes" xml:space="preserve">
          <source>I tried returning the value from the &lt;code&gt;success&lt;/code&gt; callback, as well as assigning the response to a local variable inside the function and returning that one, but none of those ways actually return the response.</source>
          <target state="translated">Я попытался вернуть значение из обратного вызова &lt;code&gt;success&lt;/code&gt; , а также присвоить ответ локальной переменной внутри функции и вернуть ее, но ни один из этих способов фактически не возвращает ответ.</target>
        </trans-unit>
        <trans-unit id="805d9303f1d1e40a739086bcb503bea0dd8a07cd" translate="yes" xml:space="preserve">
          <source>I use this approach a lot. I would be interested to know how well this approach works where wiring the result back through consecutive modules is involved.</source>
          <target state="translated">Я часто использую этот подход.Мне было бы интересно узнать,насколько хорошо работает этот подход,когда результат подключается через последовательные модули.</target>
        </trans-unit>
        <trans-unit id="96fd1cbea3405a357b87787e1ea700f496799a2f" translate="yes" xml:space="preserve">
          <source>I was using this solution for a while until I figured out there is an error in old browsers:</source>
          <target state="translated">Я использовал это решение некоторое время,пока не обнаружил ошибку в старых браузерах:</target>
        </trans-unit>
        <trans-unit id="404b02c50355c8c0582c7d04c555e4cc95c4e8cb" translate="yes" xml:space="preserve">
          <source>I will answer with a horrible-looking, hand-drawn comic. The second image is the reason why &lt;code&gt;result&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; in your code example.</source>
          <target state="translated">Я отвечу ужасно выглядящим, нарисованным от руки комиксом. Второе изображение - причина, по которой &lt;code&gt;result&lt;/code&gt; не &lt;code&gt;undefined&lt;/code&gt; в вашем примере кода.</target>
        </trans-unit>
        <trans-unit id="3967fbf9c99e4d431884df5be7bd68f466e20960" translate="yes" xml:space="preserve">
          <source>I would like to give an example for a Ajax request.</source>
          <target state="translated">Я хотел бы привести пример для запроса &quot;Аякса&quot;.</target>
        </trans-unit>
        <trans-unit id="e1ef9ad0b4029d883d48f869147c3caa394f24cd" translate="yes" xml:space="preserve">
          <source>I'm using a lot of APIs and one of the first functions I integrate into every HTML page is the first Ajax function in this answer, with GET only...</source>
          <target state="translated">Я использую множество API,и одна из первых функций,которую я интегрирую в каждую HTML-страницу-это первая Ajax-функция в этом ответе,только GET...</target>
        </trans-unit>
        <trans-unit id="0a86d08347ddae45aa9f3764c8e9705b92f76fe2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doSomethingAsync&lt;/code&gt; gives you a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Если &lt;code&gt;doSomethingAsync&lt;/code&gt; дает вам &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; , вы можете использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="97dfce1b14fd80ba22d599c23dd5f550c7f63ef9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doSomethingAsync&lt;/code&gt; gives you a Promise, if you can use ES2017+ syntax (perhaps with a transpiler like &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;), you can use an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt; function&lt;/a&gt; with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for-of&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Если &lt;code&gt;doSomethingAsync&lt;/code&gt; дает вам обещание, если вы можете использовать синтаксис ES2017 + (возможно, с транспортером, таким как &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt; ), вы можете использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; функцию&lt;/a&gt; с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for-of&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="163754b0a641fcc79050c0cc9adbe06a5d149a2e" translate="yes" xml:space="preserve">
          <source>If the sequence we're producing is a sequence of actions rather than numbers - we can pause the function whenever an action is yielded and wait for it before we resume the function. So instead of a sequence of numbers, we need a sequence of &lt;em&gt;future&lt;/em&gt; values - that is: promises.</source>
          <target state="translated">Если последовательность, которую мы создаем, является последовательностью действий, а не чисел - мы можем приостановить функцию всякий раз, когда действие дается, и ждать его, прежде чем мы возобновим функцию. Таким образом, вместо последовательности чисел нам нужна последовательность &lt;em&gt;будущих&lt;/em&gt; значений, то есть обещаний.</target>
        </trans-unit>
        <trans-unit id="afa00a6b4070ffcc7e4d6431383806ca509e451d" translate="yes" xml:space="preserve">
          <source>If underlying function is not promisified</source>
          <target state="translated">Если базовая функция не обещана</target>
        </trans-unit>
        <trans-unit id="b1be43c2bc654592ef71349407fe409b8835e049" translate="yes" xml:space="preserve">
          <source>If underlying function is promisified</source>
          <target state="translated">Если основная функция обещана</target>
        </trans-unit>
        <trans-unit id="a2a2af534201c965a8a5307d8256309bf76d379b" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;have&lt;/em&gt; to do it, you can pass a flag: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request&quot;&gt;Here is how:&lt;/a&gt;</source>
          <target state="translated">Если вам &lt;em&gt;нужно&lt;/em&gt; сделать это, вы можете передать флаг: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request&quot;&gt;Вот как:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e69ab6f2f9d1e92d40998e6452f1feaaddfbbee5" translate="yes" xml:space="preserve">
          <source>If you can't use ES2017+ syntax (yet), you can use a variation on the &lt;a href=&quot;https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all&quot;&gt;&quot;Promise reduce&quot; pattern&lt;/a&gt; (this is more complex than the usual Promise reduce because we're not passing the result from one into the next, but instead gathering up their results in an array):</source>
          <target state="translated">Если вы не можете использовать синтаксис ES2017 + (пока), вы можете использовать вариант с &lt;a href=&quot;https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all&quot;&gt;шаблоном &amp;laquo;Promise Reduce&amp;raquo;&lt;/a&gt; (это более сложно, чем обычное сокращение Promise, потому что мы не передаем результат из одного в другое, а вместо этого собирая их результаты в массив):</target>
        </trans-unit>
        <trans-unit id="9b961004352fb6c26e593f096a006f3382d2c3af" translate="yes" xml:space="preserve">
          <source>If you directly use a &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/&quot;&gt;&lt;code&gt;XMLHTTPRequest&lt;/code&gt;&lt;/a&gt; object, pass &lt;code&gt;false&lt;/code&gt; as third argument to &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/#the-open%28%29-method&quot;&gt;&lt;code&gt;.open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы напрямую используете объект &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/&quot;&gt; &lt;code&gt;XMLHTTPRequest&lt;/code&gt; &lt;/a&gt; , передайте &lt;code&gt;false&lt;/code&gt; в качестве третьего аргумента &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/#the-open%28%29-method&quot;&gt; &lt;code&gt;.open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="458c0f1aba3bbec14d8c4e49ddecf559a0d3074c" translate="yes" xml:space="preserve">
          <source>If you don't use jQuery and want a nice short XMLHttpRequest 2 which works on the modern browsers and also on the mobile browsers I suggest to use it this way:</source>
          <target state="translated">Если вы не используете jQuery и хотите красивый короткий XMLHttpRequest 2,который работает как на современных браузерах,так и на мобильных,я предлагаю использовать его таким образом:</target>
        </trans-unit>
        <trans-unit id="55afcac8cc3cf8d87fcc46044f624ddede12707e" translate="yes" xml:space="preserve">
          <source>If you know that &lt;code&gt;doSomethingAsync&lt;/code&gt; will ignore a second and third argument, you can just pass it directly to &lt;code&gt;map&lt;/code&gt; (&lt;code&gt;map&lt;/code&gt; calls its callback with three arguments, but most people only use the first most of the time):</source>
          <target state="translated">Если вы знаете, что &lt;code&gt;doSomethingAsync&lt;/code&gt; будет игнорировать второй и третий аргумент, вы можете просто передать его непосредственно на &lt;code&gt;map&lt;/code&gt; ( &lt;code&gt;map&lt;/code&gt; вызывает свой обратный вызов с тремя аргументами, но большинство людей используют только первый большую часть времени):</target>
        </trans-unit>
        <trans-unit id="c790a5aebe01811818eef515dc847f0886c8d6c4" translate="yes" xml:space="preserve">
          <source>If you need to target browsers that don't support ES6 you can run the code through Babel or closure-compiler to generate ECMAScript 5.</source>
          <target state="translated">Если вам нужны целевые браузеры,не поддерживающие ES6,вы можете запустить код через Babel или закрывающий компилятор для генерации ECMAScript 5.</target>
        </trans-unit>
        <trans-unit id="3630077cc579c9376d3c4c87878034e415200376" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery&lt;/a&gt;, you can set the &lt;code&gt;async&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;. Note that this option is &lt;em&gt;deprecated&lt;/em&gt; since jQuery 1.8.
You can then either still use a &lt;code&gt;success&lt;/code&gt; callback or access the &lt;code&gt;responseText&lt;/code&gt; property of the &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/#jqXHR&quot;&gt;jqXHR object&lt;/a&gt;:</source>
          <target state="translated">Если вы используете &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery&lt;/a&gt; , вы можете установить для параметра &lt;code&gt;async&lt;/code&gt; значение &lt;code&gt;false&lt;/code&gt; . Обратите внимание, что эта опция &lt;em&gt;устарела&lt;/em&gt; начиная с jQuery 1.8. После этого вы можете по-прежнему использовать &lt;code&gt;success&lt;/code&gt; обратный вызов или получить доступ к свойству &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/#jqXHR&quot;&gt;responseText объекта jqXHR&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="15eeba4207bfa4d204303f8eb467ce459a91861c" translate="yes" xml:space="preserve">
          <source>If you use any other jQuery Ajax method, such as &lt;code&gt;$.get&lt;/code&gt;, &lt;code&gt;$.getJSON&lt;/code&gt;, etc., you have to change it to &lt;code&gt;$.ajax&lt;/code&gt; (since you can only pass configuration parameters to &lt;code&gt;$.ajax&lt;/code&gt;).</source>
          <target state="translated">Если вы используете любой другой метод jQuery Ajax, такой как &lt;code&gt;$.get&lt;/code&gt; , &lt;code&gt;$.getJSON&lt;/code&gt; и т. Д., Вы должны изменить его на &lt;code&gt;$.ajax&lt;/code&gt; (поскольку вы можете передавать только параметры конфигурации в &lt;code&gt;$.ajax&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c715363204b6b0c4a698fa23da4f0f9dc888e78" translate="yes" xml:space="preserve">
          <source>If you want to EXTEND the function...</source>
          <target state="translated">Если вы хотите ВЫДВИЖИТЬ функцию...</target>
        </trans-unit>
        <trans-unit id="abe47fc3c57755c3997a845ee0b5aa49beefed3e" translate="yes" xml:space="preserve">
          <source>If you want to block the browser for a while load a nice big &lt;code&gt;.txt&lt;/code&gt; file synchronous.</source>
          <target state="translated">Если вы хотите на время заблокировать браузер, загрузите красивый большой &lt;code&gt;.txt&lt;/code&gt; файл синхронно.</target>
        </trans-unit>
        <trans-unit id="4e422421958cc1f0c9d4abcefec9c5f99bb57a7b" translate="yes" xml:space="preserve">
          <source>If you're &lt;em&gt;not&lt;/em&gt; using jQuery in your code, this answer is for you</source>
          <target state="translated">Если вы &lt;em&gt;не&lt;/em&gt; используете JQuery в своем коде, этот ответ для вас</target>
        </trans-unit>
        <trans-unit id="ab8a1b500c194cbfba3513d7de0dea72d3a034e8" translate="yes" xml:space="preserve">
          <source>If you're still having a hard time understanding this &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&quot;&gt;read the AJAX getting started guide&lt;/a&gt; at MDN.</source>
          <target state="translated">Если вам все еще трудно понять это, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&quot;&gt;прочтите руководство&lt;/a&gt; по началу работы с AJAX на MDN.</target>
        </trans-unit>
        <trans-unit id="18f9b9e612918f51948f6cc2126155b3c549bdae" translate="yes" xml:space="preserve">
          <source>If you're using promises, this answer is for you.</source>
          <target state="translated">Если ты используешь обещания,то этот ответ для тебя.</target>
        </trans-unit>
        <trans-unit id="80fc972e4356d8ced60d608ce0baaf96427cd4b5" translate="yes" xml:space="preserve">
          <source>Imagine you make a phone call to a friend and ask him to look something up for you. Although it might take a while, you wait on the phone and stare into space, until your friend gives you the answer that you needed.</source>
          <target state="translated">Представь,что ты звонишь другу и просишь его поискать что-нибудь для тебя.Хотя это может занять некоторое время,Вы ждете по телефону и смотрите в пространство,пока Ваш друг не даст Вам ответ,в котором Вы нуждаетесь.</target>
        </trans-unit>
        <trans-unit id="ca8f184ee30d4a232f354261c37cbb9af43a876b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Angular2&lt;/code&gt; with look at the following example, but its &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html&quot;&gt;recommended&lt;/a&gt; to use &lt;code&gt;Observables&lt;/code&gt; with &lt;code&gt;Angular2&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;Angular2&lt;/code&gt; рассмотрим следующий пример, но &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html&quot;&gt;рекомендуется&lt;/a&gt; использовать &lt;code&gt;Observables&lt;/code&gt; с &lt;code&gt;Angular2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9164c254eac90254b881079ff36f34d077268d4b" translate="yes" xml:space="preserve">
          <source>In ES7, this is further standardized, there are several proposals right now but in all of them you can &lt;code&gt;await&lt;/code&gt; promise. This is just &quot;sugar&quot; (nicer syntax) for the ES6 proposal above by adding the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; keywords. Making the above example:</source>
          <target state="translated">В ES7 это еще более стандартизировано, сейчас есть несколько предложений, но во всех из них вы можете &lt;code&gt;await&lt;/code&gt; обещаний. Это просто &amp;laquo;сахар&amp;raquo; (более приятный синтаксис) для предложения ES6, описанного выше, путем добавления ключевых слов &lt;code&gt;async&lt;/code&gt; и &lt;code&gt;await&lt;/code&gt; . Делаем приведенный выше пример:</target>
        </trans-unit>
        <trans-unit id="05677a4350495d3e2b8c6f4b68ebe3c7de4458e1" translate="yes" xml:space="preserve">
          <source>In broad, simplistic terms, the event loop is like the project manager, it is constantly listening for any functions that want to run and communicates between the queue and the stack.</source>
          <target state="translated">В широком,упрощенном смысле,цикл обработки событий похож на менеджер проекта,он постоянно прослушивает любые функции,которые хочет запустить,и общается между очередью и стеком.</target>
        </trans-unit>
        <trans-unit id="cd02d6973d3ea865653a48e911c2e50a8c25776e" translate="yes" xml:space="preserve">
          <source>In my Code it is called as</source>
          <target state="translated">В моем Кодексе это называется</target>
        </trans-unit>
        <trans-unit id="5cb5ee146291e3428e4c2fcba91cef4c63579d3d" translate="yes" xml:space="preserve">
          <source>In short, synchronous requests block the execution of code... ...this can cause serious issues...</source>
          <target state="translated">Короче говоря,синхронные запросы блокируют выполнение кода......это может привести к серьезным проблемам...</target>
        </trans-unit>
        <trans-unit id="c37241c1d0bfe0ae8498665ddda9cb54f035c670" translate="yes" xml:space="preserve">
          <source>In the above script, you have an error handler which is statically defined so it does not compromise the function. The error handler can be used for other functions too.</source>
          <target state="translated">В приведенном выше скрипте,у вас есть обработчик ошибок,который статически определен,чтобы не скомпрометировать функцию.Обработчик ошибок может быть использован и для других функций.</target>
        </trans-unit>
        <trans-unit id="1fee4a9e013a60a7958cc7ec190286ed94e8f8f3" translate="yes" xml:space="preserve">
          <source>In the case of our milk and coffee, we design &lt;code&gt;order_milk&lt;/code&gt; to return a promise for the milk arriving, then specify &lt;code&gt;put_in_coffee&lt;/code&gt; as a &lt;code&gt;then&lt;/code&gt; action, as follows:</source>
          <target state="translated">В случае с нашим молоком и кофе мы проектируем &lt;code&gt;order_milk&lt;/code&gt; , чтобы он возвращал обещание на прибытие молока, затем определяем &lt;code&gt;put_in_coffee&lt;/code&gt; в качестве действия &lt;code&gt;then&lt;/code&gt; , как показано ниже:</target>
        </trans-unit>
        <trans-unit id="a9724168875ccef827ffb62e3e3dac4f3c469e74" translate="yes" xml:space="preserve">
          <source>In the error response, there are no error codes.</source>
          <target state="translated">В ответе на ошибку отсутствуют коды ошибок.</target>
        </trans-unit>
        <trans-unit id="1a6a81cb0fe27a1ef73a694660e522eaf40baa80" translate="yes" xml:space="preserve">
          <source>In the example of the question, you can make &lt;code&gt;foo&lt;/code&gt; accept a callback and use it as &lt;code&gt;success&lt;/code&gt; callback. So this</source>
          <target state="translated">В примере с вопросом вы можете заставить &lt;code&gt;foo&lt;/code&gt; принимать обратный вызов и использовать его в качестве &lt;code&gt;success&lt;/code&gt; обратного вызова. Так это</target>
        </trans-unit>
        <trans-unit id="f64c26e8bf33e53e89ffa065ce2af5f6dae03e32" translate="yes" xml:space="preserve">
          <source>In the first case the error is inside the &lt;code&gt;displayAjax()&lt;/code&gt; under &lt;code&gt;this.statusText&lt;/code&gt; as &lt;code&gt;Method not Allowed&lt;/code&gt;.</source>
          <target state="translated">В первом случае ошибка находится внутри &lt;code&gt;displayAjax()&lt;/code&gt; в &lt;code&gt;this.statusText&lt;/code&gt; ,так как &lt;code&gt;Method not Allowed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe42b9b5d9a878fe339729448805008fb45dfb5" translate="yes" xml:space="preserve">
          <source>In the following we will look at three different solutions that are all building on top of each other:</source>
          <target state="translated">Далее мы рассмотрим три различных решения,которые все строятся друг на друге:</target>
        </trans-unit>
        <trans-unit id="ffdebc5331a7e7297d48ecb0f27d85f259e2d630" translate="yes" xml:space="preserve">
          <source>In the second case, it simply works. You have to check at the server side if you passed the right post data.</source>
          <target state="translated">Во втором случае,это просто работает.Вы должны проверить на стороне сервера,передали ли вы данные нужного поста.</target>
        </trans-unit>
        <trans-unit id="0f588f48cb190b6ff210dbc0bc1dc76feaba12bc" translate="yes" xml:space="preserve">
          <source>In this case, we could rewrite the code in the question as:</source>
          <target state="translated">В этом случае мы могли бы переписать код в вопросе как:</target>
        </trans-unit>
        <trans-unit id="8e5bc1f12b6bd30221b97d821033adfc0819696f" translate="yes" xml:space="preserve">
          <source>In your case, you would be able to write something like</source>
          <target state="translated">В вашем случае,вы могли бы написать что-нибудь вроде</target>
        </trans-unit>
        <trans-unit id="5ae61ff136e6d353245434234270f433244231c2" translate="yes" xml:space="preserve">
          <source>Instead of waiting for the response, the execution continues immediately and the statement after the Ajax call is executed. To get the response eventually, you provide a function to be called once the response was received, a &lt;em&gt;callback&lt;/em&gt; (notice something? &lt;em&gt;call back&lt;/em&gt; ?). Any statement coming after that call is executed before the callback is called.</source>
          <target state="translated">Вместо ожидания ответа выполнение продолжается немедленно и выполняется оператор после вызова Ajax. Чтобы в конечном итоге получить ответ, вы предоставляете функцию, которая будет вызываться после получения ответа, &lt;em&gt;обратный вызов&lt;/em&gt; (заметьте что-нибудь? &lt;em&gt;Перезвонить&lt;/em&gt; ?). Любой оператор, следующий за этим вызовом, выполняется до вызова обратного вызова.</target>
        </trans-unit>
        <trans-unit id="5a176ccd898f71da5498417dd981558178ba5429" translate="yes" xml:space="preserve">
          <source>Is a function that returns an &lt;em&gt;iterator&lt;/em&gt; over the sequence &lt;code&gt;1,2,3,3,3,3,....&lt;/code&gt; which can be iterated. While this is interesting on its own and opens room for a lot of possibility there is one particular interesting case.</source>
          <target state="translated">Это функция, которая возвращает &lt;em&gt;итератор&lt;/em&gt; последовательности &lt;code&gt;1,2,3,3,3,3,....&lt;/code&gt; , который можно повторять. Хотя это само по себе интересно и открывает много возможностей, есть один интересный случай.</target>
        </trans-unit>
        <trans-unit id="3bfc5cd8986cc4b5d384c982f8dbec35078eb9aa" translate="yes" xml:space="preserve">
          <source>It still returns a promise just the same :)</source>
          <target state="translated">Она все равно возвращает обещание точно так же :)</target>
        </trans-unit>
        <trans-unit id="ef1f71df2861c22e656b28c20ac85577923d64df" translate="yes" xml:space="preserve">
          <source>It supported all *modern browsers. And I can confirm as I'm using this approach since XMLHttpRequest 2 exists. I never had any type of problem on all browsers I use.</source>
          <target state="translated">Поддерживаются все *современные браузеры.И я могу подтвердить,что использую этот подход,так как XMLHttpRequest 2 существует.У меня никогда не было проблем со всеми браузерами,которые я использую.</target>
        </trans-unit>
        <trans-unit id="72465754e74ca9abdcff6be99e29d6961cffe62f" translate="yes" xml:space="preserve">
          <source>It uses the new onload (so you don't have to check for readystate &amp;amp;&amp;amp; status)</source>
          <target state="translated">Он использует новую загрузку (так что вам не нужно проверять состояние готовности &amp;amp;&amp;amp;)</target>
        </trans-unit>
        <trans-unit id="dc11dae9acba94421bf901ebfd0a99a469f66bba" translate="yes" xml:space="preserve">
          <source>It's a very common issue we face while struggling with the 'mysteries' of JavaScript. Let me try demystifying this mystery today.</source>
          <target state="translated">Это очень распространенная проблема,с которой мы сталкиваемся,борясь с &quot;тайнами&quot; JavaScript.Позвольте мне попробовать разоблачить эту загадку сегодня.</target>
        </trans-unit>
        <trans-unit id="ad52914796d378e861e608f5f5c6f3f574df3d10" translate="yes" xml:space="preserve">
          <source>It's easier to write code using callbacks than it may seem. After all, JavaScript in the browser is heavily event driven (DOM events). Receiving the Ajax response is nothing else but an event.</source>
          <target state="translated">Легче писать код,используя обратные вызовы,чем может показаться.В конце концов,JavaScript в браузере сильно управляется событиями (DOM-событиями).Получение ответа Ajax-это не что иное,как событие.</target>
        </trans-unit>
        <trans-unit id="cdbb5508c06d9ebb504456c083faa19b12343a7a" translate="yes" xml:space="preserve">
          <source>It's shorter than all other functions Listed.</source>
          <target state="translated">Это короче,чем все остальные функции,перечисленные в списке.</target>
        </trans-unit>
        <trans-unit id="dfa79b24d359ed76614774ecdc6d3f1f1fedbc1b" translate="yes" xml:space="preserve">
          <source>JavaScript runs in the UI thread of the browser and any long-running process will lock the UI, making it unresponsive. Additionally, there is an upper limit on the execution time for JavaScript and the browser will ask the user whether to continue the execution or not.</source>
          <target state="translated">JavaScript запускается в потоке пользовательского интерфейса браузера,и любой длительный процесс блокирует пользовательский интерфейс,делая его невосприимчивым.Кроме того,существует верхний предел времени выполнения JavaScript,и браузер спросит пользователя,следует ли продолжать выполнение или нет.</target>
        </trans-unit>
        <trans-unit id="e2b5e177110c45130bd6de8833741d43ceee63e1" translate="yes" xml:space="preserve">
          <source>Javscript.info callback</source>
          <target state="translated">Javscript.info обратный вызов</target>
        </trans-unit>
        <trans-unit id="bbbd4891d7699a852c6406a296c2fcf52f3c3e57" translate="yes" xml:space="preserve">
          <source>Js is a single threaded.</source>
          <target state="translated">Js-однониточная.</target>
        </trans-unit>
        <trans-unit id="e54a9bcf7595f53be50f3d461e5136cdeac9c123" translate="yes" xml:space="preserve">
          <source>Keep in mind that promises and deferred objects are just &lt;em&gt;containers&lt;/em&gt; for a future value, they are not the value itself. For example, suppose you had the following:</source>
          <target state="translated">Помните, что обещания и отложенные объекты - это просто &lt;em&gt;контейнеры&lt;/em&gt; для будущей стоимости, а не сама стоимость. Например, предположим, у вас было следующее:</target>
        </trans-unit>
        <trans-unit id="a450dc9bb252815e0a34be6965a19e24021fbb40" translate="yes" xml:space="preserve">
          <source>Let functions accept &lt;em&gt;callbacks&lt;/em&gt;</source>
          <target state="translated">Пусть функции принимают &lt;em&gt;обратные вызовы&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5142ad643e1ca5f1c54df798209cf3a4e972be1a" translate="yes" xml:space="preserve">
          <source>Let suppose our serverRequest() function had a return statement in a code, when we get back data from server Web API will push it in queue at the end of queue.
As it get pushed at end in queue we cannot utilise its data as there is no function left in our queue to utilise this data.&lt;strong&gt;Thus it is not possible to return something from Async Call.&lt;/strong&gt;</source>
          <target state="translated">Предположим, что у нашей функции serverRequest () был оператор возврата в коде, когда мы возвращаем данные из серверного веб-API и помещаем их в очередь в конце очереди. Поскольку он помещается в конец очереди, мы не можем использовать его данные, так как в нашей очереди не осталось функции для использования этих данных. &lt;strong&gt;Таким образом, невозможно вернуть что-либо из Async Call.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29816c85c3b63dc23d798455274fc320da92a3db" translate="yes" xml:space="preserve">
          <source>Let your function accept a callback. In the example code &lt;code&gt;foo&lt;/code&gt; can be made to accept a callback. We'll be telling our code how to &lt;em&gt;react&lt;/em&gt; when &lt;code&gt;foo&lt;/code&gt; completes.</source>
          <target state="translated">Позвольте вашей функции принять обратный вызов. В примере кода &lt;code&gt;foo&lt;/code&gt; может быть сделан для принятия обратного вызова. Мы расскажем нашему коду, как &lt;em&gt;реагировать,&lt;/em&gt; когда &lt;code&gt;foo&lt;/code&gt; завершит работу.</target>
        </trans-unit>
        <trans-unit id="2b907de8cd2ea70a0a07b7b3951542f8bc4bf8bc" translate="yes" xml:space="preserve">
          <source>Let's apply promises to your particular problem. We will wrap our request logic inside a function, which returns a promise:</source>
          <target state="translated">Давайте применим обещания к вашей конкретной проблеме.Мы обернем логику запроса в функцию,которая возвращает обещание:</target>
        </trans-unit>
        <trans-unit id="d30dd5f759cc5533cfc4d9a5b1b61f8383c8dbb1" translate="yes" xml:space="preserve">
          <source>Let's ask our function for a &lt;strong&gt;PROMISE&lt;/strong&gt;.
Promise is really about what it means : it means that the function guarantees you to provide with any output it gets in future. so let's see it in action for our little problem above :</source>
          <target state="translated">Давайте попросим нашу функцию для &lt;strong&gt;ОБЕЩАНИЯ&lt;/strong&gt; . Обещание действительно о том, что оно означает: это означает, что функция гарантирует, что вы предоставите любой вывод, который она получит в будущем. Итак, давайте посмотрим на это в действии для нашей маленькой проблемы выше:</target>
        </trans-unit>
        <trans-unit id="f03473dc33a9b7108d06e897d4c147d809acee67" translate="yes" xml:space="preserve">
          <source>Let's see how we can solve the above issue with promises. First, let's demonstrate our understanding of promise states from above by using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise&quot;&gt;Promise constructor&lt;/a&gt; for creating a delay function:</source>
          <target state="translated">Давайте посмотрим, как мы можем решить вышеуказанную проблему с обещаниями. Во-первых, давайте продемонстрируем наше понимание состояний обещаний сверху, используя &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise&quot;&gt;конструктор Promise&lt;/a&gt; для создания функции задержки:</target>
        </trans-unit>
        <trans-unit id="097a1fd4f4dd6ae948cf296ebf5e3fed29d827b1" translate="yes" xml:space="preserve">
          <source>Let's start with a simple JavaScript function:</source>
          <target state="translated">Начнем с простой функции JavaScript:</target>
        </trans-unit>
        <trans-unit id="012b3ad7e2336b480f233ac7230671a56ff96505" translate="yes" xml:space="preserve">
          <source>Lets first enable JQuery usage, to have &lt;code&gt;$&lt;/code&gt; available as &lt;code&gt;S&lt;/code&gt;:</source>
          <target state="translated">Давайте сначала включим использование JQuery, чтобы &lt;code&gt;$&lt;/code&gt; был доступен как &lt;code&gt;S&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3ac2a3b85bfb179de3d5fd9a6d1778a34a10d96e" translate="yes" xml:space="preserve">
          <source>Make the AJAX call synchronous (lets call it SJAX).</source>
          <target state="translated">Сделайте вызов AJAX синхронным (давайте назовем его SJAX).</target>
        </trans-unit>
        <trans-unit id="4149f095bdea0d897f44292f13870fb2ca675c68" translate="yes" xml:space="preserve">
          <source>More examples here: &lt;a href=&quot;https://github.com/amaksr/nsynjs/tree/master/examples&quot;&gt;https://github.com/amaksr/nsynjs/tree/master/examples&lt;/a&gt;</source>
          <target state="translated">Дополнительные примеры здесь: &lt;a href=&quot;https://github.com/amaksr/nsynjs/tree/master/examples&quot;&gt;https://github.com/amaksr/nsynjs/tree/master/examples&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="416843538915a12d446291b1a92446755e1f2268" translate="yes" xml:space="preserve">
          <source>More information about promises: &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;HTML5 rocks - JavaScript Promises&lt;/a&gt;</source>
          <target state="translated">Больше информации об обещаниях: &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;HTML5 - скалы - Обещания JavaScript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25f50452665d503e55acf0b8c965da53f9e2eb1f" translate="yes" xml:space="preserve">
          <source>Most of the answers here give useful suggestions for when you have a single async operation, but sometimes, this comes up when you need to do an asynchronous operation for &lt;em&gt;each&lt;/em&gt; entry in an array or other list-like structure. The temptation is to do this:</source>
          <target state="translated">Большинство ответов здесь дают полезные советы, когда у вас есть одна асинхронная операция, но иногда это происходит, когда вам нужно выполнить асинхронную операцию для &lt;em&gt;каждой&lt;/em&gt; записи в массиве или другой структуре, подобной списку. Соблазн сделать это:</target>
        </trans-unit>
        <trans-unit id="7ace0f986a8d32fe40488522b23a55438cb0b782" translate="yes" xml:space="preserve">
          <source>Not recommended: Synchronous &quot;Ajax&quot; calls</source>
          <target state="translated">Не рекомендуется:Синхронные &quot;Аякс&quot; звонки</target>
        </trans-unit>
        <trans-unit id="a3266b1005a3a1afba35c5209761885a8ad47be3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Promise.all&lt;/code&gt; resolves its promise with an array of the results of all of the promises you give it when they are all resolved, or rejects its promise when the &lt;em&gt;first&lt;/em&gt; of the promises you give it rejects.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Promise.all&lt;/code&gt; разрешает свое обещание с массивом результатов всех обещаний, которые вы даете ему, когда они все разрешены, или отклоняет свое обещание, когда &lt;em&gt;первое&lt;/em&gt; из обещаний, которые вы даете, отклоняет его.</target>
        </trans-unit>
        <trans-unit id="ce6df39941058908a0b980171b83775c7db609fa" translate="yes" xml:space="preserve">
          <source>Note that the call to &lt;code&gt;foo()&lt;/code&gt; will still return nothing useful. However, the result of the async call will now be stored in &lt;code&gt;result.response&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что вызов функции &lt;code&gt;foo()&lt;/code&gt; все равно не даст ничего полезного. Тем не менее, результат асинхронного вызова теперь будет сохранен в &lt;code&gt;result.response&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9c2dea7d7e7a3411da1773762e08918f5674124" translate="yes" xml:space="preserve">
          <source>Nothing easier.</source>
          <target state="translated">Нет ничего проще.</target>
        </trans-unit>
        <trans-unit id="353e455e2b68dea72cd422384a4b460cd47300c4" translate="yes" xml:space="preserve">
          <source>Notice how we use the &lt;code&gt;index&lt;/code&gt; from &lt;code&gt;forEach&lt;/code&gt; to save the result in &lt;code&gt;results&lt;/code&gt; in the same position as the entry it relates to, even if the results arrive out of order (since async calls don't necessarily complete in the order in which they were started).</source>
          <target state="translated">Обратите внимание, как мы используем &lt;code&gt;index&lt;/code&gt; из &lt;code&gt;forEach&lt;/code&gt; для сохранения результата в той же позиции, что и запись, к которой он относится, даже если результаты поступают не по порядку (поскольку асинхронные вызовы не обязательно завершаются в том порядке, в котором они были запущены ).</target>
        </trans-unit>
        <trans-unit id="929ed6885fc0b5c2a602a91186d7a6db6f5f8584" translate="yes" xml:space="preserve">
          <source>Now if you want something more complex using post and FormData you can easily extend this function:</source>
          <target state="translated">Теперь,если вы хотите что-то более сложное,используя post и FormData,вы можете легко расширить эту функцию:</target>
        </trans-unit>
        <trans-unit id="d974961b0a397dae3ab443eb46237547fe41139f" translate="yes" xml:space="preserve">
          <source>Now let us think we pushed two functions in a queue one is for getting a data from server and another utilises that data.We pushed the serverRequest() function in queue first then utiliseData() function. serverRequest function goes in event loop and makes a call to server as we never know how much time it will take to get data from server
so this process is expected to take time and so we busy our event loop thus hanging our page, that's where Web API come into role it take this function from event loop and deals with server making event loop free so that we can execute next function from queue.The next function in queue is utiliseData() which goes in loop but because of no data available it goes waste and execution of next function continues till end of the queue.(This is called Async calling i.e we can do something else till we get data)</source>
          <target state="translated">Теперь давайте подумаем,что мы столкнули две функции в очереди,одна из которых предназначена для получения данных от сервера,а другая использует эти данные,и мы столкнули сначала функцию serverRequest()в очереди,а затем использовали функциюData().Функция serverRequest входит в цикл обработки событий и вызывает сервер,так как мы никогда не знаем,сколько времени займет получение данных от сервера,поэтому ожидается,что этот процесс займет некоторое время,и поэтому мы заняты циклом обработки событий,таким образом,зависая нашу страницу,вот где Web API вступает в роль,он берет эту функцию из цикла обработки событий и работает с сервером,делая цикл обработки событий свободным,так что мы можем выполнить следующую функцию из очереди.Следующей функцией в очереди является функцияData(),которая идет в цикле,но из-за отсутствия данных она уходит впустую,и выполнение следующей функции продолжается до конца очереди (это называется вызовом Async,т.е.мы можем делать что-то еще,пока не получим данные).</target>
        </trans-unit>
        <trans-unit id="e0a63d4292a004be42ee890cb652815050847bb1" translate="yes" xml:space="preserve">
          <source>Now let's add a bit of twist, by introducing little delay in our function, so that all lines of code are not 'finished' in sequence. Thus, it will emulate the asynchronous behavior of function :</source>
          <target state="translated">Теперь добавим немного изюминку,введя небольшую задержку в нашу функцию,чтобы все строки кода не были 'закончены' последовательно.Таким образом,это будет эмулировать асинхронное поведение функции :</target>
        </trans-unit>
        <trans-unit id="42c38f982e0c169feb7e086aabc21246bff1aad8" translate="yes" xml:space="preserve">
          <source>Now some people will probably say that it's better to use onreadystatechange or the even the XMLHttpRequest variable name. That's wrong.</source>
          <target state="translated">Теперь некоторые наверняка скажут,что лучше использовать onreadystatechange или даже имя переменной XMLHttpRequest.Это неправильно.</target>
        </trans-unit>
        <trans-unit id="a2fab3eea51d1e71a6c436e1f5c97b56ccdd5071" translate="yes" xml:space="preserve">
          <source>Now you can do</source>
          <target state="translated">Теперь ты можешь сделать</target>
        </trans-unit>
        <trans-unit id="da89b3c0dfa9111f27c794ec1b03edd3bdfde2dd" translate="yes" xml:space="preserve">
          <source>Now, after we converted setTimeout to use promises, we can use &lt;code&gt;then&lt;/code&gt; to make it count:</source>
          <target state="translated">Теперь, после того как мы конвертировали setTimeout для использования обещаний, мы можем использовать его для подсчета:</target>
        </trans-unit>
        <trans-unit id="8914db3fb9a1d0494f5a0d8fd668ced73c34d069" translate="yes" xml:space="preserve">
          <source>Now, let's define foo itself to act accordingly</source>
          <target state="translated">Теперь,давайте определим,что сам Фу должен действовать соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="99be19d54cf7652a1615ab27cbc8bbf0aed5749c" translate="yes" xml:space="preserve">
          <source>Nsynjs will evaluate all operators and expressions step-by-step, pausing execution in case if result of some slow function is not ready.</source>
          <target state="translated">Nsynjs будет пошагово оценивать все операторы и выражения,останавливая выполнение в случае,если результат какой-то медленной функции не готов.</target>
        </trans-unit>
        <trans-unit id="5a64163c890c0896f46f25e78ce25b037738ed57" translate="yes" xml:space="preserve">
          <source>Of course there are many approaches like synchronous request, promise, but from my experience I think you should use the callback approach. It's natural to asynchronous behavior of Javascript.
So, your code snippet can be rewrite a little different:</source>
          <target state="translated">Конечно,есть много подходов,таких как синхронный запрос,обещание,но по моему опыту я думаю,что вы должны использовать подход обратного вызова.Это естественно для асинхронного поведения Javascript.Итак,ваш фрагмент кода можно переписать немного по-другому:</target>
        </trans-unit>
        <trans-unit id="2e78929c9a21094861197c3ba952c175f274cc77" translate="yes" xml:space="preserve">
          <source>Once it receives a message to run something it adds it to the queue. The queue is the list of things that are waiting to execute (like your AJAX request). imagine it like this:</source>
          <target state="translated">Как только он получает сообщение о запуске чего-то,он добавляет его в очередь.Очередь-это список вещей,которые ожидают выполнения (например,ваш AJAX-запрос).представьте себе это так:</target>
        </trans-unit>
        <trans-unit id="9d39748eb9ce2dc97c87c582527e55724204f745" translate="yes" xml:space="preserve">
          <source>One advantage of this is that we can string these together to create sequences of future occurrences (&quot;chaining&quot;):</source>
          <target state="translated">Одним из преимуществ этого является то,что мы можем связать их вместе для создания последовательностей будущих вхождений (&quot;цепочки&quot;):</target>
        </trans-unit>
        <trans-unit id="54016dfcceb363844e7cc4be09ec8ae272d45106" translate="yes" xml:space="preserve">
          <source>One possible solution to this problem is to code &lt;em&gt;re-actively&lt;/em&gt; , telling your program what to do when the calculation completed.</source>
          <target state="translated">Одним из возможных решений этой проблемы является &lt;em&gt;повторное активное программирование&lt;/em&gt; , сообщающее вашей программе, что делать после завершения расчета.</target>
        </trans-unit>
        <trans-unit id="6a68116dc884c578869074c6236313ddd089faa1" translate="yes" xml:space="preserve">
          <source>One possible solution to this problem is to code &lt;em&gt;re-actively&lt;/em&gt; , telling your program what to do when the calculation completed. Promises actively enable this by being temporal (time-sensitive) in nature.</source>
          <target state="translated">Одним из возможных решений этой проблемы является &lt;em&gt;повторное активное программирование&lt;/em&gt; , сообщающее вашей программе, что делать после завершения расчета. Обещания активно способствуют этому, будучи временными (чувствительными ко времени) по своей природе.</target>
        </trans-unit>
        <trans-unit id="e3fe8189fb8e3a9175a9246ff74a29655859c5dc" translate="yes" xml:space="preserve">
          <source>Only if you have a page where you load always the same XML/JSON or whatever you need only one function. In that case, modify a little the Ajax function and replace b with your special function.</source>
          <target state="translated">Только если у вас есть страница,на которой вы загружаете всегда один и тот же XMLJSON или что-то еще,что вам нужно только одна функция.В этом случае слегка модифицируйте функцию Ajax и замените b на вашу специальную функцию.</target>
        </trans-unit>
        <trans-unit id="5266da9d163f68f6d914c71fc5ace6c79a2e3aaa" translate="yes" xml:space="preserve">
          <source>Or (the above one is better anonymous functions are always a problem):</source>
          <target state="translated">Или (вышеприведенная лучше анонимные функции всегда являются проблемой):</target>
        </trans-unit>
        <trans-unit id="7574e85e254349a76f9eb280b8d26c2fcd432db0" translate="yes" xml:space="preserve">
          <source>Or here's a version returning a &lt;code&gt;Promise&lt;/code&gt; instead:</source>
          <target state="translated">Или вот версия, возвращающая &lt;code&gt;Promise&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="912172dfb14be8eb490ece32e4e426ffa381d626" translate="yes" xml:space="preserve">
          <source>Or if for some reason you &lt;code&gt;bind()&lt;/code&gt; the callback to a class:</source>
          <target state="translated">Или, если по какой-то причине вы &lt;code&gt;bind()&lt;/code&gt; обратный вызов с классом:</target>
        </trans-unit>
        <trans-unit id="97548c9db4d27ac2b95bbc49510f16af46cc2fde" translate="yes" xml:space="preserve">
          <source>Or pass a full form element (&lt;code&gt;document.getElementsByTagName('form')[0]&lt;/code&gt;):</source>
          <target state="translated">Или передайте полный элемент формы ( &lt;code&gt;document.getElementsByTagName('form')[0]&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="e22be26c55a52d473b9811210f17414624c87259" translate="yes" xml:space="preserve">
          <source>Or set some custom values:</source>
          <target state="translated">Или установите некоторые пользовательские значения:</target>
        </trans-unit>
        <trans-unit id="68f819f1f89dc9e0529ac2892b6d2f288badbd02" translate="yes" xml:space="preserve">
          <source>Or the Promise syntax</source>
          <target state="translated">Или синтаксис &quot;Обещания</target>
        </trans-unit>
        <trans-unit id="afc129571bf06499cb7e3b0ffe14106bdb906a2f" translate="yes" xml:space="preserve">
          <source>Parallel</source>
          <target state="translated">Parallel</target>
        </trans-unit>
        <trans-unit id="3768a1e6d49da0cac1c978e4121bcf5a453c81eb" translate="yes" xml:space="preserve">
          <source>Possible solutions</source>
          <target state="translated">Возможные решения</target>
        </trans-unit>
        <trans-unit id="7bb1c6338f84ef633dbff9dc2ca5d6404721463d" translate="yes" xml:space="preserve">
          <source>Promises are containers for &lt;em&gt;future&lt;/em&gt; values. When the promise receives the value (it is &lt;em&gt;resolved&lt;/em&gt;) or when it is canceled (&lt;em&gt;rejected&lt;/em&gt;), it notifies all of its &quot;listeners&quot; who want to access this value.</source>
          <target state="translated">Обещания - это контейнеры для &lt;em&gt;будущих&lt;/em&gt; ценностей. Когда обещание получает значение (оно &lt;em&gt;разрешено&lt;/em&gt; ) или когда оно отменено ( &lt;em&gt;отклонено&lt;/em&gt; ), оно уведомляет всех своих &amp;laquo;слушателей&amp;raquo;, которые хотят получить доступ к этому значению.</target>
        </trans-unit>
        <trans-unit id="8350b08167777968ab876b41274f64fe1318e1bf" translate="yes" xml:space="preserve">
          <source>Promises can be used to unnest asynchronous functions and allows one to chain multiple functions together.</source>
          <target state="translated">Обещания могут быть использованы для того,чтобы избавиться от асинхронных функций,и позволяют связать воедино несколько функций.</target>
        </trans-unit>
        <trans-unit id="c32135d34ac0c0221572109c3dfc7f43a9751b94" translate="yes" xml:space="preserve">
          <source>Quick recap on promises</source>
          <target state="translated">Быстрое подведение итогов по обещаниям</target>
        </trans-unit>
        <trans-unit id="c235eb24c95a5e9981695eb449944a162b57ebf2" translate="yes" xml:space="preserve">
          <source>Rather than throwing code at you, there are 2 concepts that are key to understanding how JS handles callbacks and asynchronicity. (is that even a word?)</source>
          <target state="translated">Вместо того,чтобы бросаться кодом в вас,есть 2 понятия,которые являются ключевыми для понимания того,как JS обрабатывает обратные вызовы и асинхроничность.(это хоть слово?)</target>
        </trans-unit>
        <trans-unit id="29bff7173029217e94f4afcceb94f3ce6f4a8162" translate="yes" xml:space="preserve">
          <source>Restructure your code to work properly with callbacks.</source>
          <target state="translated">Реструктурируйте свой код для корректной работы с обратными вызовами.</target>
        </trans-unit>
        <trans-unit id="062f9fe8caa07becb814606e66f0cdd8c44eccb5" translate="yes" xml:space="preserve">
          <source>Return a Promise</source>
          <target state="translated">Вернуть обещание</target>
        </trans-unit>
        <trans-unit id="da07fe527d40396d3dc18ff2bbee2077e9679bf6" translate="yes" xml:space="preserve">
          <source>Returning anything in the submit handler will not do anything. You must instead either hand off the data, or do what you want with it directly inside the success function.</source>
          <target state="translated">Возвращая что-либо в обработчике заявки,вы ничего не сделаете.Вместо этого вы должны либо передавать данные,либо делать с ними то,что вы хотите,прямо внутри успешной функции.</target>
        </trans-unit>
        <trans-unit id="be64c83fb64f3829b56366e909fbacc0081629bd" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html&quot;&gt;original&lt;/a&gt; post here. But Typescript does not support &lt;a href=&quot;http://www.datchley.name/es6-promises/&quot;&gt;native es6 Promises&lt;/a&gt;, if you want to use it, you might need plugin for that.</source>
          <target state="translated">Смотрите &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html&quot;&gt;оригинальный&lt;/a&gt; пост здесь. Но Typescript не поддерживает &lt;a href=&quot;http://www.datchley.name/es6-promises/&quot;&gt;родные обещания es6&lt;/a&gt; , если вы хотите его использовать, вам может понадобиться плагин для этого.</target>
        </trans-unit>
        <trans-unit id="40c20d94e78fa142819df8cc9440d30e65329975" translate="yes" xml:space="preserve">
          <source>Series</source>
          <target state="translated">Series</target>
        </trans-unit>
        <trans-unit id="7e56c5c8aa16c1ef6db37ada8a6266e68cceb09e" translate="yes" xml:space="preserve">
          <source>Several solutions have been given in this thread. Perhaps the easiest way is to pass an object to the &lt;code&gt;foo()&lt;/code&gt; method, and to store the results in a member of that object after the async call completes.</source>
          <target state="translated">В этой теме было дано несколько решений. Возможно, самый простой способ - передать объект в метод &lt;code&gt;foo()&lt;/code&gt; и сохранить результаты в элементе этого объекта после завершения асинхронного вызова.</target>
        </trans-unit>
        <trans-unit id="2148a375d3f6b7a16b65d3a1f82733a29815e073" translate="yes" xml:space="preserve">
          <source>Short answer is, &lt;strong&gt;you have to implement a callback like this:&lt;/strong&gt;</source>
          <target state="translated">Короткий ответ: &lt;strong&gt;вы должны реализовать обратный вызов, например:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Показать фрагмент кода</target>
        </trans-unit>
        <trans-unit id="ff1c87cac36b81c6f91891fbd54132c4334c4e46" translate="yes" xml:space="preserve">
          <source>Side note: Promise gotchas</source>
          <target state="translated">Боковая заметка:Обещаю получить</target>
        </trans-unit>
        <trans-unit id="05506c4ac3acb4d27c65c550acf4b39c197cd038" translate="yes" xml:space="preserve">
          <source>Side note: jQuery's deferred objects</source>
          <target state="translated">Боковая заметка:отложенные объекты jQuery</target>
        </trans-unit>
        <trans-unit id="fa5759978602e0fa347526198e20ed43cc048568" translate="yes" xml:space="preserve">
          <source>Simple usage example:</source>
          <target state="translated">Простой пример использования:</target>
        </trans-unit>
        <trans-unit id="4096759186b4f9723934ec713d75bc04761b5820" translate="yes" xml:space="preserve">
          <source>Since the operation did not happen yet (AJAX, server call, IO, timer) you're returning the value before the request got the chance to tell your code what that value is.</source>
          <target state="translated">Так как операция еще не произошла (AJAX,вызов сервера,IO,таймер),вы возвращаете значение до того,как запрос получил возможность сказать вашему коду,что это за значение.</target>
        </trans-unit>
        <trans-unit id="5a7e4ac52f20fc5994d25a70f507d562ec34a41e" translate="yes" xml:space="preserve">
          <source>So anything that foobarFunc needs to execute (in our case &lt;code&gt;anotherFunction&lt;/code&gt;) will get pushed onto the stack. executed, and then forgotten about - the event loop will then move onto the next thing in the queue (or listen for messages)</source>
          <target state="translated">Поэтому все, что нужно выполнить foobarFunc (в нашем случае &lt;code&gt;anotherFunction&lt;/code&gt; ), будет помещено в стек. выполнено, а затем забыто - цикл событий переместится на следующую вещь в очереди (или прослушает сообщения)</target>
        </trans-unit>
        <trans-unit id="4130aa961d9f8a1abff39f8f3f11e49af247d9a2" translate="yes" xml:space="preserve">
          <source>So i decided to implement my own Promise class for &lt;strong&gt;ES3 to below&lt;/strong&gt; js compilers if its not defined. Just add this code before your main code and then safely use Promise!</source>
          <target state="translated">Поэтому я решил реализовать свой собственный класс Promise для &lt;strong&gt;ES3 для&lt;/strong&gt; компиляторов &lt;strong&gt;ниже&lt;/strong&gt; js, если он не определен. Просто добавьте этот код перед вашим основным кодом, а затем смело используйте Promise!</target>
        </trans-unit>
        <trans-unit id="519e6b95ba34166e61a9a33a9c6412ef034c0b19" translate="yes" xml:space="preserve">
          <source>So if you are using &lt;strong&gt;Angular, React&lt;/strong&gt; or any other frameworks which do &lt;strong&gt;two ways data binding&lt;/strong&gt; or &lt;strong&gt;store concept&lt;/strong&gt; this issue is simply fixed for you, so in easy word, your result is &lt;code&gt;undefined&lt;/code&gt; at the first stage, so you have got &lt;code&gt;result = undefined&lt;/code&gt; before you receive the data, then as soon as you get the result, it will be updated and get assigned to the new value which response of your Ajax call...</source>
          <target state="translated">Так что, если вы используете &lt;strong&gt;Angular, React&lt;/strong&gt; или любые другие фреймворки, которые выполняют &lt;strong&gt;два способа привязки данных&lt;/strong&gt; или &lt;strong&gt;концепции хранения,&lt;/strong&gt; эта проблема просто решается для вас, так что, проще говоря, ваш результат не &lt;code&gt;undefined&lt;/code&gt; на первом этапе, поэтому вы получите &lt;code&gt;result = undefined&lt;/code&gt; до того, как вы получите данные, затем, как только вы получите результат, он будет обновлен и ему будет присвоено новое значение, которое ответит на ваш вызов Ajax ...</target>
        </trans-unit>
        <trans-unit id="456834897466e279954c59b225ffcd0a611dc23f" translate="yes" xml:space="preserve">
          <source>So there you go, that delay just broke the functionality we expected! But what exactly happened ? Well, it's actually pretty logical if you look at the code. the function &lt;code&gt;foo()&lt;/code&gt;, upon execution, returns nothing (thus returned value is &lt;code&gt;undefined&lt;/code&gt;), but it does start a timer, which executes a function after 1s to return 'wohoo'. But as you can see, the value that's assigned to bar is the immediately returned stuff from foo(), which is nothing i.e. just &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Итак, поехали, эта задержка просто сломала функционал, который мы ожидали Но что именно произошло? Ну, это на самом деле довольно логично, если вы посмотрите на код. функция &lt;code&gt;foo()&lt;/code&gt; после выполнения ничего не возвращает (таким образом, возвращаемое значение не &lt;code&gt;undefined&lt;/code&gt; ), но она запускает таймер, который выполняет функцию через 1 с, чтобы вернуть 'wohoo'. Но, как вы можете видеть, значение, назначенное для bar, является немедленно возвращаемым материалом из foo (), который является ничем, то есть просто &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ebd3c140905d6a71bb22361b04f8129d104582a" translate="yes" xml:space="preserve">
          <source>So this works just as well. We've learned we can't return values from already asynchronous calls but we can use promises and chain them to perform processing. We now know how to return the response from an asynchronous call.</source>
          <target state="translated">Так что это работает так же хорошо.Мы узнали,что не можем возвращать значения из уже асинхронных вызовов,но можем использовать обещания и связывать их цепочками для выполнения обработки.Теперь мы знаем,как вернуть ответ с асинхронного вызова.</target>
        </trans-unit>
        <trans-unit id="16474dcce86aac08469b81e9bbfe841fd4c01c7d" translate="yes" xml:space="preserve">
          <source>So what you need to do is pass a function that is promised to execute at some point with data that is passed to it.</source>
          <target state="translated">Итак,что вам нужно сделать,так это передать функцию,которую обещают выполнить в какой-то момент с передаваемыми ей данными.</target>
        </trans-unit>
        <trans-unit id="0efce20ff147121d241f07ae7346392a017a7c29" translate="yes" xml:space="preserve">
          <source>So, if you have an array (or list of some kind) and want to do async operations for each entry, you have two options: Do the operations in parallel (overlapping), or in series (one after another in sequence).</source>
          <target state="translated">Итак,если у вас есть массив (или какой-то список)и вы хотите выполнять операции асинхронизации для каждого элемента,у вас есть два варианта:Выполнять операции параллельно (наложение)или последовательно (последовательно друг за другом).</target>
        </trans-unit>
        <trans-unit id="4549b38f6f564b62d621d5aaa8f137985559a5b5" translate="yes" xml:space="preserve">
          <source>So, you to run the following example you need to put your access token in the request headers:</source>
          <target state="translated">Итак,чтобы запустить следующий пример,вам нужно поместить ваш маркер доступа в заголовки запросов:</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="b9a422a9be9b2bc191da989656816034a1f6eee5" translate="yes" xml:space="preserve">
          <source>So: No need for error checks if you're able to copy and paste the URL properly. ;)</source>
          <target state="translated">Итак:Нет необходимости в проверке на ошибки,если вы можете правильно скопировать и вставить URL ;).</target>
        </trans-unit>
        <trans-unit id="958cd629e68ed77d9824bb75c9b43a7f1cf49e0a" translate="yes" xml:space="preserve">
          <source>Solution(s)</source>
          <target state="translated">Solution(s)</target>
        </trans-unit>
        <trans-unit id="9dbffa1e0ccfddb501d678c507c62423968b4d1e" translate="yes" xml:space="preserve">
          <source>Step 1. Wrap function with callback into nsynjs-aware wrapper (if it has promisified version, you can skip this step):</source>
          <target state="translated">Шаг 1.Оберните функцию с обратным вызовом в nsynjs-aware обертку (если она имеет обещанную версию,вы можете пропустить этот шаг):</target>
        </trans-unit>
        <trans-unit id="fcdabda0acdbf7ed77f27dcb6841a85fbda15814" translate="yes" xml:space="preserve">
          <source>Step 2. Put synchronous logic into function:</source>
          <target state="translated">Шаг 2.Ввод синхронной логики в действие:</target>
        </trans-unit>
        <trans-unit id="80eb86c9950baf665d77b6ad1ffb913a4fa504e2" translate="yes" xml:space="preserve">
          <source>Step 3. Run function in synchronous manner via nsynjs:</source>
          <target state="translated">Шаг 3.Выполнить функцию синхронно через nsynjs:</target>
        </trans-unit>
        <trans-unit id="e79e3d8d02a013d89691c298f6bd299451c74b8a" translate="yes" xml:space="preserve">
          <source>Suppose you don't want the operations to be in parallel? If you want to run them one after another, you need to wait for each operation to complete before you start the next. Here's an example of a function that does that and calls a callback with the result:</source>
          <target state="translated">Предположим,вы не хотите,чтобы операции были параллельными? Если Вы хотите запускать их одну за другой,Вам необходимо дождаться завершения каждой операции,прежде чем начать следующую.Вот пример функции,которая делает это и вызывает обратный вызов с результатом:</target>
        </trans-unit>
        <trans-unit id="77c61919f7c0335c38d9155372ee85055a736cc1" translate="yes" xml:space="preserve">
          <source>Synchronous</source>
          <target state="translated">Synchronous</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">То есть:</target>
        </trans-unit>
        <trans-unit id="9111ae84fd392e9454be6a96907483945425e257" translate="yes" xml:space="preserve">
          <source>That's a simple synchronous function call (where each line of code is 'finished with its job' before the next one in sequence), and the result is same as expected.</source>
          <target state="translated">Это простой синхронный вызов функции (при котором каждая строка кода &quot;заканчивается своей работой&quot; до следующего по порядку),и результат получается тот же,что и ожидалось.</target>
        </trans-unit>
        <trans-unit id="6dadcf5d4da4a50438dd8a46454bbf9f5c8a3d23" translate="yes" xml:space="preserve">
          <source>That's exactly what's happening when you do an Ajax request.</source>
          <target state="translated">Именно это и происходит,когда ты делаешь запрос на Аякс.</target>
        </trans-unit>
        <trans-unit id="c7cfbaca7087cb7a7879162ad5a4e04b1f217824" translate="yes" xml:space="preserve">
          <source>That's why with asynchronous functionality we use things called &lt;strong&gt;callbacks&lt;/strong&gt;. It's kinda like a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;promise&lt;/a&gt; quite literally. As in I &lt;em&gt;promise to return something at some point&lt;/em&gt; jQuery uses specific callbacks called &lt;code&gt;deffered.done&lt;/code&gt;&lt;code&gt;deffered.fail&lt;/code&gt; and &lt;code&gt;deffered.always&lt;/code&gt; (amongst others). You can see them all &lt;a href=&quot;https://api.jquery.com/category/deferred-object/&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">Вот почему с асинхронной функциональностью мы используем вещи, называемые &lt;strong&gt;обратными вызовами&lt;/strong&gt; . Это как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;обещание в&lt;/a&gt; буквальном смысле. Как и в &lt;em&gt;обещание вернуть что-то в какой-то момент,&lt;/em&gt; jQuery использует специальные обратные вызовы, называемые &lt;code&gt;deffered.done&lt;/code&gt; &lt;code&gt;deffered.fail&lt;/code&gt; и &lt;code&gt;deffered.always&lt;/code&gt; (среди прочих). Вы можете увидеть их все &lt;a href=&quot;https://api.jquery.com/category/deferred-object/&quot;&gt;здесь&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15bb754ff5cde7f28dcd0bb70e024c67cb821f55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise API&lt;/a&gt; is a new feature of ECMAScript 6 (ES2015), but it has good &lt;a href=&quot;http://caniuse.com/#feat=promises&quot;&gt;browser support&lt;/a&gt; already. There are also many libraries which implement the standard Promises API and provide additional methods to ease the use and composition of asynchronous functions (e.g. &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;bluebird&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise API&lt;/a&gt; - это новая функция ECMAScript 6 (ES2015), но он уже имеет хорошую &lt;a href=&quot;http://caniuse.com/#feat=promises&quot;&gt;поддержку браузера&lt;/a&gt; . Есть также много библиотек, которые реализуют стандартный API Promises и предоставляют дополнительные методы для упрощения использования и составления асинхронных функций (например, &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;bluebird&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8863ecce1e4cf6263ca3b1bcde858dda65b7c8db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; keyword</source>
          <target state="translated">Ключевое слово &lt;code&gt;async&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb35c6a9a9151152e061add9aab9caeda5223463" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;A&lt;/strong&gt; in &lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;Ajax&lt;/a&gt; stands for &lt;a href=&quot;https://www.merriam-webster.com/dictionary/asynchronous&quot;&gt;&lt;strong&gt;asynchronous&lt;/strong&gt;&lt;/a&gt; . That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, &lt;code&gt;$.ajax&lt;/code&gt; returns immediately and the next statement, &lt;code&gt;return result;&lt;/code&gt;, is executed before the function you passed as &lt;code&gt;success&lt;/code&gt; callback was even called.</source>
          <target state="translated">&lt;strong&gt;A&lt;/strong&gt; в &lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;Ajax&lt;/a&gt; обозначает &lt;a href=&quot;https://www.merriam-webster.com/dictionary/asynchronous&quot;&gt;&lt;strong&gt;асинхронный&lt;/strong&gt;&lt;/a&gt; . Это означает, что отправка запроса (или, вернее, получение ответа) исключается из обычного потока выполнения. В вашем примере &lt;code&gt;$.ajax&lt;/code&gt; возвращает сразу, а следующий оператор &lt;code&gt;return result;&lt;/code&gt; , выполняется до того, как функция, которую вы передали в качестве &lt;code&gt;success&lt;/code&gt; вызова, даже была вызвана.</target>
        </trans-unit>
        <trans-unit id="fd66ac85793821d3ff7fcc5fd0246ae36ee7397a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;A&lt;/strong&gt; in AJAX stands for &lt;strong&gt;asynchronous&lt;/strong&gt;. That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29&quot;&gt;&lt;code&gt;.send&lt;/code&gt;&lt;/a&gt; returns immediately and the next statement, &lt;code&gt;return result;&lt;/code&gt;, is executed before the function you passed as &lt;code&gt;success&lt;/code&gt; callback was even called.</source>
          <target state="translated">&lt;strong&gt;A&lt;/strong&gt; в AJAX означает &lt;strong&gt;асинхронный&lt;/strong&gt; . Это означает, что отправка запроса (или, вернее, получение ответа) исключается из обычного потока выполнения. В вашем примере &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29&quot;&gt; &lt;code&gt;.send&lt;/code&gt; &lt;/a&gt; возвращает сразу, а следующий оператор &lt;code&gt;return result;&lt;/code&gt; , выполняется до того, как функция, которую вы передали в качестве &lt;code&gt;success&lt;/code&gt; обратного вызова, даже была вызвана.</target>
        </trans-unit>
        <trans-unit id="16490f52af9e1a9f1fc6768f3e186d1abc950e53" translate="yes" xml:space="preserve">
          <source>The ECMAScript version released in 2017 introduced &lt;em&gt;syntax-level support&lt;/em&gt; for asynchronous functions. With the help of &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;, you can write asynchronous in a &quot;synchronous style&quot;. The code is still asynchronous, but it's easier to read/understand.</source>
          <target state="translated">Версия ECMAScript, выпущенная в 2017 году, представила &lt;em&gt;поддержку&lt;/em&gt; асинхронных функций на &lt;em&gt;уровне синтаксиса&lt;/em&gt; . С помощью &lt;code&gt;async&lt;/code&gt; и &lt;code&gt;await&lt;/code&gt; вы можете писать асинхронно в &amp;laquo;синхронном стиле&amp;raquo;. Код все еще асинхронный, но его легче читать / понимать.</target>
        </trans-unit>
        <trans-unit id="ecce31767a1b5e77be58da7962c0d01b010e4473" translate="yes" xml:space="preserve">
          <source>The JavaScript concurrency model in the browser and on the server with NodeJS/io.js is &lt;em&gt;asynchronous&lt;/em&gt; and &lt;em&gt;reactive&lt;/em&gt;.</source>
          <target state="translated">Модель параллелизма JavaScript в браузере и на сервере с NodeJS / io.js является &lt;em&gt;асинхронной&lt;/em&gt; и &lt;em&gt;реактивной&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ca67c883bbbb71564bf5ac5f9cf7f2adffad99d0" translate="yes" xml:space="preserve">
          <source>The advantage over plain callbacks is that they allow you to decouple your code and they are easier to compose.</source>
          <target state="translated">Преимущество по сравнению с обычными обратными вызовами заключается в том,что они позволяют развязывать код,и их легче составлять.</target>
        </trans-unit>
        <trans-unit id="480a14931d5a0da5ce02043bf95ba5bba1ea1b46" translate="yes" xml:space="preserve">
          <source>The big question is when will it get the response? The answer is we don't know - so the event loop is waiting for that message to say &quot;hey run me&quot;. If JS just waited around for that message synchronously your app would freeze and it will suck. So JS carries on executing the next item in the queue whilst waiting for the message to get added back to the queue.</source>
          <target state="translated">Главный вопрос-когда он получит ответ? Ответ заключается в том,что мы не знаем-поэтому цикл обработки событий ждет,когда сообщение скажет:&quot;Привет,беги&quot;.Если JS просто будет ждать этого сообщения синхронно,ваше приложение замерзнет,и это будет отстойно.Таким образом,JS продолжает выполнение следующего элемента в очереди в ожидании,когда сообщение будет добавлено обратно в очередь.</target>
        </trans-unit>
        <trans-unit id="ccbf0ca2fcdd4c3a3e86689a782e66920dbfdb25" translate="yes" xml:space="preserve">
          <source>The callback &lt;code&gt;...args&lt;/code&gt; are wrapped in an array and destructured when you read them so that the pattern can cope with callbacks that have multiple arguments. For example with &lt;a href=&quot;https://nodejs.org/api/fs.html&quot;&gt;node fs&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;...args&lt;/code&gt; обратного вызова ... заключаются в массив и деструктурируются при их чтении, чтобы шаблон мог справиться с обратными вызовами, которые имеют несколько аргументов. Например, с &lt;a href=&quot;https://nodejs.org/api/fs.html&quot;&gt;узлом fs&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="77a6ce0e24e45311bbbc8af933b3454cde1bc3ae" translate="yes" xml:space="preserve">
          <source>The callback is set directly (so no extra unnecessary closures).</source>
          <target state="translated">Обратный вызов устанавливается напрямую (поэтому нет лишних лишних замыканий).</target>
        </trans-unit>
        <trans-unit id="64f9a89935bc0aec8bd8d2c2f2163e48c2e4e0d3" translate="yes" xml:space="preserve">
          <source>The classic JS approach to this problem, taking advantage of the fact that JS supports functions as first-class objects which can be passed around, is to pass a function as a parameter to the asynchronous request, which it will then invoke when it has completed its task sometime in the future. That is the &quot;callback&quot; approach. It looks like this:</source>
          <target state="translated">Классический JS-подход к этой проблеме,использующий тот факт,что JS поддерживает функции как первоклассные объекты,которые могут передаваться по кругу,заключается в передаче функции в качестве параметра асинхронного запроса,который она затем будет вызывать,когда завершит свою задачу когда-нибудь в будущем.Это и есть &quot;обратный вызов&quot;.Похоже на то:</target>
        </trans-unit>
        <trans-unit id="a4b7cb494bc59feaa54149492dcd2fc6736593a6" translate="yes" xml:space="preserve">
          <source>The computer systems we build--more and more--have time as an important dimension. Certain things are set up to happen in the future. Then other things need to happen after those first things eventually occur. This is the basic notion called &quot;asynchronicity&quot;. In our increasingly networked world, the most common case of asynchronicity is waiting for some remote system to respond to some request.</source>
          <target state="translated">Компьютерные системы,которые мы строим-больше и больше-имеют время как важное измерение.Определенные вещи должны произойти в будущем.Тогда другие вещи должны произойти после того,как эти первые вещи,в конце концов,произойдут.Это основное понятие,называемое &quot;асинхроничность&quot;.В нашем все более сетевом мире наиболее распространенным случаем асинхронии является ожидание ответа какой-либо удаленной системы на какой-то запрос.</target>
        </trans-unit>
        <trans-unit id="68c3c910b7e388c8ca698170706eac7d163f356e" translate="yes" xml:space="preserve">
          <source>The core issue</source>
          <target state="translated">Основной вопрос</target>
        </trans-unit>
        <trans-unit id="edbb0afa295f70fd7b961434a3ea023d105f1de1" translate="yes" xml:space="preserve">
          <source>The following example I have written shows how to</source>
          <target state="translated">Следующий пример,который я написал,показывает,как</target>
        </trans-unit>
        <trans-unit id="7e2482274ea8174623353a79961f7e409558a384" translate="yes" xml:space="preserve">
          <source>The functions above are for basic use.</source>
          <target state="translated">Вышеуказанные функции предназначены для базового использования.</target>
        </trans-unit>
        <trans-unit id="f0b5d408edc15ee4ab49f75c3a45e0e83fe085b1" translate="yes" xml:space="preserve">
          <source>The most perfect answer to this question is using &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">Самый совершенный ответ на этот вопрос - использование &lt;code&gt;Promise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">Проблема</target>
        </trans-unit>
        <trans-unit id="bc0f50fb62db74196eb462d4435dbc048d27bedc" translate="yes" xml:space="preserve">
          <source>The problem with this callback approach is that it pollutes the normal semantics of a function reporting its result with &lt;code&gt;return&lt;/code&gt;; instead, functions must not reports their results by calling a callback given as a parameter. Also, this approach can rapidly become unwieldy when dealing with longer sequences of events. For example, let's say that I want to wait for the milk to be put in the coffee, and then and only then perform a third step, namely drinking the coffee. I end up needing to write something like this:</source>
          <target state="translated">Проблема с этим подходом обратного вызова состоит в том, что он загрязняет нормальную семантику функции, сообщающей о своем результате с &lt;code&gt;return&lt;/code&gt; ; вместо этого функции не должны сообщать о своих результатах, вызывая функцию обратного вызова, заданную в качестве параметра. Кроме того, этот подход может быстро стать громоздким при работе с более длинными последовательностями событий. Например, предположим, что я хочу подождать, пока молоко будет добавлено в кофе, а затем и только тогда выполнить третий шаг, а именно выпить кофе. В итоге мне нужно написать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="32dd7ece0413b20c7f6465adba94961d1fd0156b" translate="yes" xml:space="preserve">
          <source>The question was:</source>
          <target state="translated">Вопрос был в том:</target>
        </trans-unit>
        <trans-unit id="9865311a25d22afa6e2a491b6a5b84a1c39aeb10" translate="yes" xml:space="preserve">
          <source>The reason that doesn't work is that the callbacks from &lt;code&gt;doSomethingAsync&lt;/code&gt; haven't run yet by the time you're trying to use the results.</source>
          <target state="translated">Причина, по которой это не работает, заключается в том, что обратные вызовы от &lt;code&gt;doSomethingAsync&lt;/code&gt; еще не выполнялись к тому времени, когда вы пытаетесь использовать результаты.</target>
        </trans-unit>
        <trans-unit id="a2739b5dbb10ebfc12b5d81d5d32fb7cd061a55e" translate="yes" xml:space="preserve">
          <source>The same is happening when you make a function call containing &quot;normal&quot; code:</source>
          <target state="translated">То же самое происходит при вызове функции,содержащей &quot;нормальный&quot; код:</target>
        </trans-unit>
        <trans-unit id="98c7c4ba758c9126f0cfa1f1637747d0674ee4fd" translate="yes" xml:space="preserve">
          <source>The simplest solution is create a JavaScript function and call it for the Ajax &lt;code&gt;success&lt;/code&gt; callback.</source>
          <target state="translated">Самое простое решение - создать функцию JavaScript и вызвать ее для обратного вызова Ajax.</target>
        </trans-unit>
        <trans-unit id="3d2b25517bf2d94a474aa03573586b145df347ce" translate="yes" xml:space="preserve">
          <source>The simplest:</source>
          <target state="translated">Самый простой:</target>
        </trans-unit>
        <trans-unit id="6fe5eb2395efd41f10b91e16726041602d6e3143" translate="yes" xml:space="preserve">
          <source>The solution will be to avoid callbacks, and use a combination of &lt;strong&gt;Promises&lt;/strong&gt; and &lt;strong&gt;async/await&lt;/strong&gt;.</source>
          <target state="translated">Решение будет состоять в том, чтобы избежать обратных вызовов и использовать комбинацию &lt;strong&gt;Promises&lt;/strong&gt; и &lt;strong&gt;async / await&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9dec62eb819ee8ace8aad60238eecf9a7f4fb514" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a&lt;/code&gt; returned is &lt;code&gt;undefined&lt;/code&gt; since the &lt;code&gt;a=5&lt;/code&gt; part has not executed yet. AJAX acts like this, you're returning the value before the server got the chance to tell your browser what that value is.</source>
          <target state="translated">Значение возвращаемого значения не &lt;code&gt;undefined&lt;/code&gt; так как часть &lt;code&gt;a=5&lt;/code&gt; еще не выполнена. AJAX действует следующим образом: вы возвращаете значение до того, как у сервера появится возможность сообщить вашему браузеру, что это за значение.</target>
        </trans-unit>
        <trans-unit id="8d1a490aef5366b80c665df9adb0416c82e381c5" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; since the &lt;code&gt;data = 5&lt;/code&gt; part has not executed yet. It will likely execute in a second but by that time it is irrelevant to the returned value.</source>
          <target state="translated">Значение &lt;code&gt;data&lt;/code&gt; не &lt;code&gt;undefined&lt;/code&gt; поскольку часть &lt;code&gt;data = 5&lt;/code&gt; еще не выполнена. Вероятно, он будет выполнен через секунду, но к тому времени он не будет иметь отношения к возвращаемому значению.</target>
        </trans-unit>
        <trans-unit id="587b206c7db5b969cdb5a40887824aa9c5099e73" translate="yes" xml:space="preserve">
          <source>There are basically two ways how to solve this:</source>
          <target state="translated">Есть два способа решить эту проблему:</target>
        </trans-unit>
        <trans-unit id="2cf0b130ac11e32c400e435be4fa43654576f982" translate="yes" xml:space="preserve">
          <source>There are some other situations which I don't remember that make the XMLHttpRequest 1 annoying.</source>
          <target state="translated">Есть некоторые другие ситуации,которые я не помню,которые делают XMLHttpRequest 1 раздражающим.</target>
        </trans-unit>
        <trans-unit id="dd643d6829dc9f26a331e2bce21e4a3e98d834bc" translate="yes" xml:space="preserve">
          <source>There are three things you need to be aware of; &lt;strong&gt;The queue; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop&quot;&gt;the event loop&lt;/a&gt; and the stack&lt;/strong&gt;</source>
          <target state="translated">Есть три вещи, о которых вам нужно знать; &lt;strong&gt;Очередь;&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop&quot;&gt;цикл событий&lt;/a&gt; и стек&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4498030a163e78ec8715dffc1c0ce5911aba4b0c" translate="yes" xml:space="preserve">
          <source>There are two ways to get the response of this Ajax call (three using the XMLHttpRequest var name):</source>
          <target state="translated">Есть два способа получить ответ на этот вызов Ajax (три с помощью XMLHttpRequest var имя):</target>
        </trans-unit>
        <trans-unit id="37cfc454d35f84e510806797d964ad848a95604e" translate="yes" xml:space="preserve">
          <source>There is a problem with using promises!</source>
          <target state="translated">Есть проблема с использованием обещаний!</target>
        </trans-unit>
        <trans-unit id="7d46baf54c6d620b802f531b3e92d3841965a2a5" translate="yes" xml:space="preserve">
          <source>There is no other way to do this in a non-asynchronous way. (Yeah, with setTimeout loop... but seriously?)</source>
          <target state="translated">Другого способа сделать это несинхронным способом нет.(Да,с петлей SetTimeout...но серьезно?)</target>
        </trans-unit>
        <trans-unit id="8511f0c06778d891bba10da5d78a325fa162981f" translate="yes" xml:space="preserve">
          <source>There is only the &lt;code&gt;this.type&lt;/code&gt; which is set to error.</source>
          <target state="translated">Существует только &lt;code&gt;this.type&lt;/code&gt; , который имеет значение error.</target>
        </trans-unit>
        <trans-unit id="c974cb400663a76c12df4912d445ea3637c72efb" translate="yes" xml:space="preserve">
          <source>This code misunderstands the above asynchrony issues. Specifically, &lt;code&gt;$.ajax()&lt;/code&gt; doesn't freeze the code while it checks the '/password' page on your server - it sends a request to the server and while it waits, it immediately returns a jQuery Ajax Deferred object, not the response from the server. That means the &lt;code&gt;if&lt;/code&gt; statement is going to always get this Deferred object, treat it as &lt;code&gt;true&lt;/code&gt;, and proceed as though the user is logged in. Not good.</source>
          <target state="translated">Этот код неправильно понимает вышеуказанные проблемы асинхронности. В частности, &lt;code&gt;$.ajax()&lt;/code&gt; не замораживает код, пока проверяет страницу &amp;laquo;/ пароль&amp;raquo; на вашем сервере - он отправляет запрос на сервер и, ожидая, немедленно возвращает объект jQuery Ajax Deferred, а не ответ с сервера. Это означает, что оператор &lt;code&gt;if&lt;/code&gt; будет всегда получать этот отложенный объект, обрабатывать его как &lt;code&gt;true&lt;/code&gt; и продолжать, как если бы пользователь вошел в систему. Не хорошо.</target>
        </trans-unit>
        <trans-unit id="244afc8d38402f6d7c12baa9c3d841505fe06988" translate="yes" xml:space="preserve">
          <source>This is a short summary of &quot;Explanation of the problem&quot; from the other answer, if you're not sure after reading this, read that.</source>
          <target state="translated">Это краткое резюме &quot;Объяснение проблемы&quot; из другого ответа,если вы не уверены после прочтения этого,прочтите его.</target>
        </trans-unit>
        <trans-unit id="bec8301fa7c95d68f2971235b818a4ec00cf9186" translate="yes" xml:space="preserve">
          <source>This is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt;. Basically, we're passing &lt;code&gt;getFive&lt;/code&gt; an action to perform when it completes, we're telling our code how to react when an event completes (like our AJAX call, or in this case the timeout).</source>
          <target state="translated">Это называется &lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt; . По сути, мы &lt;code&gt;getFive&lt;/code&gt; действие, которое нужно выполнить после его завершения, мы сообщаем нашему коду, как реагировать на завершение события (например, наш вызов AJAX или в этом случае тайм-аут).</target>
        </trans-unit>
        <trans-unit id="e37cc018b8dd7866206ff24c3bd04692ca34d6e0" translate="yes" xml:space="preserve">
          <source>This is one of the places which &lt;strong&gt;two ways data binding&lt;/strong&gt; or &lt;strong&gt;store concept&lt;/strong&gt; that's used in many new JavaScript frameworks will work great for you...</source>
          <target state="translated">Это одно из мест, где &lt;strong&gt;два способа привязки данных&lt;/strong&gt; или &lt;strong&gt;концепция хранения,&lt;/strong&gt; которые используются во многих новых JavaScript-фреймворках, будут отлично работать для вас ...</target>
        </trans-unit>
        <trans-unit id="87baabf09170470e02be100dac74857e2ebc1619" translate="yes" xml:space="preserve">
          <source>This is quite simple:</source>
          <target state="translated">Это довольно просто:</target>
        </trans-unit>
        <trans-unit id="95b540890727eecbe058d586198261782083d7c0" translate="yes" xml:space="preserve">
          <source>This means AngularJS, jQuery (with deferred), native XHR's replacement (fetch), EmberJS, BackboneJS's save or any node library that returns promises.</source>
          <target state="translated">Это означает AngularJS,jQuery (с отложением),замена XHR (fetch),EmberJS,BackboneJS сохранение или любая библиотека узлов,которая возвращает обещания.</target>
        </trans-unit>
        <trans-unit id="b3d9c5469e4b15f9c162fb643af29c9f5ca05645" translate="yes" xml:space="preserve">
          <source>This means when you're returning &lt;code&gt;data&lt;/code&gt; the &lt;code&gt;then&lt;/code&gt; handler you've defined did not execute yet. This in turn means that the value you're returning has not been set to the correct value in time.</source>
          <target state="translated">Это означает, что когда вы возвращаете &lt;code&gt;data&lt;/code&gt; определенный вами обработчик &lt;code&gt;then&lt;/code&gt; еще не выполнялся. Это, в свою очередь, означает, что возвращаемое вами значение не было правильно установлено во времени.</target>
        </trans-unit>
        <trans-unit id="f01778d1944777ab6b8f39abe10e8afdd7a72058" translate="yes" xml:space="preserve">
          <source>This means when you're returning, the listener you've defined did not execute yet, which means the value you're returning has not been defined.</source>
          <target state="translated">Это означает,что когда вы возвращаетесь,определенный вами слушатель еще не был запущен,что означает,что возвращаемое вами значение не было определено.</target>
        </trans-unit>
        <trans-unit id="61ed4646f32a3a1ac23ad5fb1d6851ea5f3992d0" translate="yes" xml:space="preserve">
          <source>This method returns a promise itself, which we can consume from other coroutines. For example:</source>
          <target state="translated">Этот метод возвращает само обещание,которое мы можем потреблять из других корутинов.Например:</target>
        </trans-unit>
        <trans-unit id="6d9e63f07d1d652a68998572e1a51ce636590916" translate="yes" xml:space="preserve">
          <source>This somewhat tricky but very powerful trick lets us write asynchronous code in a synchronous manner. There are several &quot;runners&quot; that do this for you, writing one is a short few lines of code but is beyond the scope of this answer. I'll be using Bluebird's &lt;code&gt;Promise.coroutine&lt;/code&gt; here, but there are other wrappers like &lt;code&gt;co&lt;/code&gt; or &lt;code&gt;Q.async&lt;/code&gt;.</source>
          <target state="translated">Этот несколько хитрый, но очень мощный трюк позволяет нам писать асинхронный код синхронно. Есть несколько &amp;laquo;бегунов&amp;raquo;, которые делают это для вас, написание одного - несколько строк кода, но выходит за рамки этого ответа. Здесь я буду использовать &lt;code&gt;Promise.coroutine&lt;/code&gt; от Bluebird, но есть и другие оболочки, такие как &lt;code&gt;co&lt;/code&gt; или &lt;code&gt;Q.async&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7419d91a7773bb18e95de8945a17e396a7138932" translate="yes" xml:space="preserve">
          <source>This stands the same for your original API call, you can:</source>
          <target state="translated">Это то же самое,что и ваш оригинальный вызов API,вы можете:</target>
        </trans-unit>
        <trans-unit id="b4c2a28333fa2716b1c47a4f0a2e18a4d80475ff" translate="yes" xml:space="preserve">
          <source>This was the motivation for the notion of a &quot;promise&quot;, which is a particular type of value which represents a &lt;strong&gt;future&lt;/strong&gt; or &lt;strong&gt;asynchronous&lt;/strong&gt; outcome of some sort. It can represent something that already happened, or that is going to happen in the future, or might never happen at all. Promises have a single method, named &lt;code&gt;then&lt;/code&gt;, to which you pass an action to be executed when the outcome the promise represents has been realized.</source>
          <target state="translated">Это послужило мотивацией для понятия &amp;laquo;обещание&amp;raquo;, которое представляет собой особый тип значения, представляющий &lt;strong&gt;будущий&lt;/strong&gt; или какой-то &lt;strong&gt;асинхронный&lt;/strong&gt; результат. Он может представлять собой то, что уже произошло, или произойдет в будущем, или может вообще никогда не произойти. У обещаний есть единственный метод, названный &lt;code&gt;then&lt;/code&gt; , которому вы передаете действие, которое будет выполнено, когда результат, который представляет обещание, был реализован.</target>
        </trans-unit>
        <trans-unit id="c88099e25e362faf93b5c34442314fc0efbfd023" translate="yes" xml:space="preserve">
          <source>This working example is self-contained. It will define a simple request object that uses the window &lt;code&gt;XMLHttpRequest&lt;/code&gt; object to make calls. It will define a simple function to wait for a bunch of promises to be completed.</source>
          <target state="translated">Этот рабочий пример самодостаточен. Он определит простой объект запроса, который использует объект окна &lt;code&gt;XMLHttpRequest&lt;/code&gt; для выполнения вызовов. Он определит простую функцию, которая будет ждать выполнения обещаний.</target>
        </trans-unit>
        <trans-unit id="bb4a902028592cca405a4e54f7447a6dd933acce" translate="yes" xml:space="preserve">
          <source>Thus Solution to this is &lt;em&gt;callback&lt;/em&gt; or &lt;em&gt;promise&lt;/em&gt;.</source>
          <target state="translated">Таким образом, решением является &lt;em&gt;обратный вызов&lt;/em&gt; или &lt;em&gt;обещание&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4ac77e33ad1dc33272e4765092ee238e7b4067" translate="yes" xml:space="preserve">
          <source>Thus, the summary is - to tackle the asynchronous functions like ajax based calls etc., you can use a promise to &lt;code&gt;resolve&lt;/code&gt; the value (which you intend to return). Thus, in short you &lt;strong&gt;resolve&lt;/strong&gt; value instead of &lt;strong&gt;returning&lt;/strong&gt;, in asynchronous functions.</source>
          <target state="translated">Таким образом, краткое изложение - для решения асинхронных функций, таких как вызовы на основе ajax и т. Д., Вы можете использовать обещание для &lt;code&gt;resolve&lt;/code&gt; значения (которое вы намереваетесь вернуть). Таким образом, короче говоря, вы &lt;strong&gt;решаете&lt;/strong&gt; значение вместо &lt;strong&gt;возврата&lt;/strong&gt; в асинхронных функциях.</target>
        </trans-unit>
        <trans-unit id="a0a2dcdf916f3c7cf3b91ae00bbe537935bc5316" translate="yes" xml:space="preserve">
          <source>To run the above code you do this:</source>
          <target state="translated">Чтобы запустить вышеуказанный код,вы делаете это:</target>
        </trans-unit>
        <trans-unit id="2e8f0671297e82a3357b05f76d4c39dd6732c8f7" translate="yes" xml:space="preserve">
          <source>UPDATE (Promises with async/await)</source>
          <target state="translated">UPDATE (Promises with asyncawait)</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e3b2c87fbdfa81069562e3801f3b834f583f3068" translate="yes" xml:space="preserve">
          <source>Usage would be:</source>
          <target state="translated">Это было бы полезно:</target>
        </trans-unit>
        <trans-unit id="4ba1f4e931dcc6adc1af6d22a6e4e7abed5a85b2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt; pattern to join multiple HTTP calls;</source>
          <target state="translated">Используйте шаблон &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt; для объединения нескольких HTTP-вызовов;</target>
        </trans-unit>
        <trans-unit id="e698b02ca0c7b2228f7ccbc8c4b111e743e10e2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;Promise&lt;/a&gt; pattern;</source>
          <target state="translated">Используйте шаблон &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;Promise&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="0e9a58ba6887bb7e51147aa2da4a49a0486ce969" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;callback()&lt;/code&gt; function inside the &lt;code&gt;foo()&lt;/code&gt; success.
Try in this way. It is simple and easy to understand. &amp;nbsp;</source>
          <target state="translated">Используйте функцию &lt;code&gt;callback()&lt;/code&gt; внутри успеха &lt;code&gt;foo()&lt;/code&gt; . Попробуй таким образом. Это просто и легко понять.</target>
        </trans-unit>
        <trans-unit id="606944b24d98d72b39627fdefe858efa8d964a89" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;'await'&lt;/a&gt;, which will tell JavaScript to await the promise to be resolved into a value (like the HTTP response)</source>
          <target state="translated">Используйте &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;'await'&lt;/a&gt; , который сообщит JavaScript, чтобы он ожидал, что обещание будет преобразовано в значение (например, HTTP-ответ)</target>
        </trans-unit>
        <trans-unit id="a11fcc742eebbcfca3c5bb6597892f401f073e0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;strong&gt;asynchronous&lt;/strong&gt; code as if it were &lt;strong&gt;synchronous&lt;/strong&gt;:</source>
          <target state="translated">Используйте &lt;strong&gt;асинхронный&lt;/strong&gt; код, как если бы он был &lt;strong&gt;синхронным&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="50df00102216ee2fa6b8d3f60a71c04beba81fe1" translate="yes" xml:space="preserve">
          <source>Using ES2017 you should have this as the function declaration</source>
          <target state="translated">Используя ES2017,вы должны иметь это в качестве декларации функции</target>
        </trans-unit>
        <trans-unit id="cc12d7b012ca1bfa32bf1aa97b798db2031c84f8" translate="yes" xml:space="preserve">
          <source>Using Promise</source>
          <target state="translated">Используя обещание</target>
        </trans-unit>
        <trans-unit id="28685eec146d7abeed631f689f722a157cd3cd31" translate="yes" xml:space="preserve">
          <source>Using callback concept - As implementation in first answer</source>
          <target state="translated">Использование концепции обратного вызова-как реализация в первом ответе.</target>
        </trans-unit>
        <trans-unit id="c787b69b8c1dad213e2bced9dc421d4fbabcda2a" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;XMLHttpRequest&lt;/code&gt; variable name is another big error as you need to execute the callback inside the onload/oreadystatechange closures else you lost it.</source>
          <target state="translated">Использование имени переменной &lt;code&gt;XMLHttpRequest&lt;/code&gt; является еще одной большой ошибкой, поскольку вам нужно выполнить обратный вызов внутри замыканий onload / oreadystatechange, иначе вы его потеряли.</target>
        </trans-unit>
        <trans-unit id="b7ce43e50f1c7276c7fa06bbf7c04a9872a17966" translate="yes" xml:space="preserve">
          <source>Wait for response from each API call;</source>
          <target state="translated">Ждите ответа от каждого вызова API;</target>
        </trans-unit>
        <trans-unit id="35c239d949f8723db6cf2fca7425f52803d0c967" translate="yes" xml:space="preserve">
          <source>We find ourselves in a universe which appears to progress along a dimension we call &quot;time&quot;. We don't really understand what time is, but we have developed abstractions and vocabulary that let us reason and talk about it: &quot;past&quot;, &quot;present&quot;, &quot;future&quot;, &quot;before&quot;, &quot;after&quot;.</source>
          <target state="translated">Мы оказываемся во вселенной,которая,кажется,развивается в измерении,которое мы называем &quot;временем&quot;.На самом деле мы не понимаем,что такое время,но мы разработали абстракции и лексику,которые позволяют нам рассуждать и говорить об этом:&quot;прошлое&quot;,&quot;настоящее&quot;,&quot;будущее&quot;,&quot;до&quot;,&quot;после&quot;.</target>
        </trans-unit>
        <trans-unit id="cf190ebdec93ca0293df429352a161bff1aed4e0" translate="yes" xml:space="preserve">
          <source>We have now made our foo function accept an action to run when the AJAX completes successfully, we can extend this further by checking if the response status is not 200 and acting accordingly (create a fail handler and such). Effectively solving our issue.</source>
          <target state="translated">Теперь мы заставили нашу функцию foo принять действие,которое будет запущено после успешного завершения AJAX,мы можем расширить это действие,проверив,не 200 ли статус ответа,и действуя соответственно (создать обработчик сбоя и т.п.).Эффективное решение нашей проблемы.</target>
        </trans-unit>
        <trans-unit id="ac71c9a45e5e5d552a308fe3128d89db33f20f8b" translate="yes" xml:space="preserve">
          <source>What you're facing</source>
          <target state="translated">С чем ты сталкиваешься</target>
        </trans-unit>
        <trans-unit id="d9e7e738a86ea5326f809837e5b5ea81f305f671" translate="yes" xml:space="preserve">
          <source>When one of these messages is going to execute it pops the message from the queue and creates a stack, the stack is everything JS needs to execute to perform the instruction in the message. So in our example it's being told to call &lt;code&gt;foobarFunc&lt;/code&gt;</source>
          <target state="translated">Когда одно из этих сообщений будет выполнено, оно извлекает сообщение из очереди и создает стек, а стек - это все, что JS должен выполнить для выполнения инструкции в сообщении. Так что в нашем примере говорят, чтобы вызвать &lt;code&gt;foobarFunc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46e5db5a04236061d5766214e29fc62f17454cbf" translate="yes" xml:space="preserve">
          <source>When using promises, we end up passing lots of functions into &lt;code&gt;then&lt;/code&gt;, so it's often helpful to use the more compact ES6-style arrow functions:</source>
          <target state="translated">При использовании обещаний мы в конечном итоге передаем множество функций, поэтому часто полезно использовать более компактные функции стрелок в стиле ES6:</target>
        </trans-unit>
        <trans-unit id="b23496e842dceff9fb3a521cbe84a712262e3f34" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;.then&lt;/code&gt; on a promise and &lt;em&gt;return&lt;/em&gt; something from it - we get a promise for &lt;em&gt;the processed value&lt;/em&gt;. If we return another promise we'll get amazing things, but let's hold our horses.</source>
          <target state="translated">Когда мы вызываем &lt;code&gt;.then&lt;/code&gt; по обещанию и &lt;em&gt;возвращаем&lt;/em&gt; что-то из него - мы получаем обещание для &lt;em&gt;обработанного значения&lt;/em&gt; . Если мы ответим на другое обещание, мы получим удивительные вещи, но давайте держать наших лошадей.</target>
        </trans-unit>
        <trans-unit id="d987b91f60f98a1b758f0e53d90290815d18964e" translate="yes" xml:space="preserve">
          <source>When you make a call using AJAX to an external party or run any asynchronous code (a setTimeout for example), Javascript is dependant upon a response before it can proceed.</source>
          <target state="translated">Когда вы делаете вызов,используя AJAX,внешней стороне или запускаете любой асинхронный код (например,setTimeout),Javascript зависит от ответа,прежде чем он может быть продолжен.</target>
        </trans-unit>
        <trans-unit id="380b904db5976f20d5318f6cc1191c770d1da13f" translate="yes" xml:space="preserve">
          <source>Whenever you call a method that returns a promise, the &lt;code&gt;then&lt;/code&gt; handlers are &lt;em&gt;always&lt;/em&gt; executed asynchronously - that is, &lt;strong&gt;after&lt;/strong&gt; the code below them that is not in a &lt;code&gt;.then&lt;/code&gt; handler.</source>
          <target state="translated">Всякий раз, когда вы вызываете метод, который возвращает обещание, обработчики &lt;code&gt;then&lt;/code&gt; &lt;em&gt;всегда&lt;/em&gt; выполняются асинхронно, то есть &lt;strong&gt;после&lt;/strong&gt; кода ниже них, который не находится в обработчике &lt;code&gt;.then&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42feb8ea413f33209ece4d328587c570e4d54ebe" translate="yes" xml:space="preserve">
          <source>Which should alert &quot;5&quot; to the screen. &lt;a href=&quot;http://jsfiddle.net/PAjZR/&quot;&gt;(Fiddle)&lt;/a&gt;.</source>
          <target state="translated">Который должен предупредить &amp;laquo;5&amp;raquo; на экране. &lt;a href=&quot;http://jsfiddle.net/PAjZR/&quot;&gt;(Скрипка)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec5557762b5410ae1ddd3eb2b67bfdb2da22a4ce" translate="yes" xml:space="preserve">
          <source>While it is &lt;em&gt;okay&lt;/em&gt; in small examples it gets annoying when you have a lot of similar cases and error handling involved.</source>
          <target state="translated">Хотя в небольших примерах это &lt;em&gt;нормально,&lt;/em&gt; это раздражает, когда у вас много подобных случаев и обработка ошибок.</target>
        </trans-unit>
        <trans-unit id="1450bd8677cf37b475780df43411df3cca8f006a" translate="yes" xml:space="preserve">
          <source>While promises and callbacks work fine in many situations, it is a pain in the rear to express something like:</source>
          <target state="translated">В то время как обещания и обратные вызовы отлично работают во многих ситуациях,это заноза в заднице,чтобы выразить что-то вроде:</target>
        </trans-unit>
        <trans-unit id="448c4cc13812bccdb5367397d714ad86dd6ea552" translate="yes" xml:space="preserve">
          <source>Why add an error handler if you totally have no control over errors?
Most of the errors are returned inside this in the callback function &lt;code&gt;displayAjax()&lt;/code&gt;.</source>
          <target state="translated">Зачем добавлять обработчик ошибок, если вы полностью не можете контролировать ошибки? Большинство ошибок возвращаются внутри этого в функции обратного вызова &lt;code&gt;displayAjax()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5edfc082aa90912642ae681f74a76ece5088c8fa" translate="yes" xml:space="preserve">
          <source>Why is it bad do you ask?</source>
          <target state="translated">Почему ты спрашиваешь?</target>
        </trans-unit>
        <trans-unit id="1229758f7e8ec3a149e87560402cc78e508a43de" translate="yes" xml:space="preserve">
          <source>Why should we use our own custom Promise?</source>
          <target state="translated">Почему мы должны использовать наше собственное пользовательское обещание?</target>
        </trans-unit>
        <trans-unit id="ece375bff4b483047da3749860748c38927e530d" translate="yes" xml:space="preserve">
          <source>With promises</source>
          <target state="translated">С обещаниями</target>
        </trans-unit>
        <trans-unit id="0c0a59fb074de0fc1fd7cee2f49870f337cc9102" translate="yes" xml:space="preserve">
          <source>Without jQuery</source>
          <target state="translated">Без jQuery</target>
        </trans-unit>
        <trans-unit id="b5fea0abea018388c5315d97c39b4081a7cb703a" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest API</source>
          <target state="translated">XMLHttpRequest API</target>
        </trans-unit>
        <trans-unit id="e73644d1d710900fb613359a5f23e329c06b46fe" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest supports both synchronous and asynchronous communications. In general, however, asynchronous requests should be preferred to synchronous requests for performance reasons.</source>
          <target state="translated">XMLHttpRequest поддерживает как синхронную,так и асинхронную связь.В целом,однако,асинхронные запросы должны быть предпочтительнее,чем синхронные запросы по причинам,связанным с производительностью.</target>
        </trans-unit>
        <trans-unit id="b9b7f311a0fbfaead32e2e31dba1d379c239df35" translate="yes" xml:space="preserve">
          <source>Yes, you can.</source>
          <target state="translated">Да,ты можешь.</target>
        </trans-unit>
        <trans-unit id="83fb6a0fad9feb9e391f4aec4d78ee5495226649" translate="yes" xml:space="preserve">
          <source>You are using Ajax incorrectly. The idea is not to have it return anything, but instead hand off the data to something called a callback function, which handles the data.</source>
          <target state="translated">Вы неправильно используете Аякс.Идея заключается в том,чтобы он ничего не возвращал,а вместо этого передавал данные чему-то,что называется функцией обратного вызова,которая обрабатывает данные.</target>
        </trans-unit>
        <trans-unit id="f394fee622b97599e0a31a6f0f4cd4cc68870f7c" translate="yes" xml:space="preserve">
          <source>You call your friend again for the same reason. But this time you tell him that you are in a hurry and he should &lt;em&gt;call you back&lt;/em&gt; on your mobile phone. You hang up, leave the house and do whatever you planned to do. Once your friend calls you back, you are dealing with the information he gave to you.</source>
          <target state="translated">Вы звоните своему другу снова по той же причине. Но на этот раз вы говорите ему, что спешите, и он должен &lt;em&gt;перезвонить вам&lt;/em&gt; на ваш мобильный телефон. Вы вешаете трубку, выходите из дома и делаете все, что планировали. Как только ваш друг перезвонит вам, вы будете иметь дело с информацией, которую он вам дал.</target>
        </trans-unit>
        <trans-unit id="d2bd21947364482b0aca338a6b437d78f80037e7" translate="yes" xml:space="preserve">
          <source>You can also process the response before passing it to the callback:</source>
          <target state="translated">Вы также можете обработать ответ,прежде чем передать его на обратный вызов:</target>
        </trans-unit>
        <trans-unit id="3beb8e59419ebd09fc9891e40ffa62d7e41da4e2" translate="yes" xml:space="preserve">
          <source>You can checkout the project &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Вы можете оформить заказ &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a399a6f3ef2aa4bf612fdbeaabb5190ec6b5790" translate="yes" xml:space="preserve">
          <source>You can consume that in this way,</source>
          <target state="translated">Ты можешь это съесть таким образом,</target>
        </trans-unit>
        <trans-unit id="0c470949a5de51b9f217c1f0fc0cf12e324c19e0" translate="yes" xml:space="preserve">
          <source>You can find a nice explanation &lt;a href=&quot;http://andyshora.com/promises-angularjs-explained-as-cartoon.html&quot;&gt;here&lt;/a&gt; also.</source>
          <target state="translated">Вы также можете найти хорошее объяснение &lt;a href=&quot;http://andyshora.com/promises-angularjs-explained-as-cartoon.html&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a480682174de8f801e99da50379e04d8ac8ac06" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; on MDN.</source>
          <target state="translated">Вы можете прочитать больше об &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; на MDN.</target>
        </trans-unit>
        <trans-unit id="ca259db921dc5475dee1f9c068034b544e83ec7f" translate="yes" xml:space="preserve">
          <source>You can start all of them and keep track of how many callbacks you're expecting, and then use the results when you've gotten that many callbacks:</source>
          <target state="translated">Вы можете запустить их все и отслеживать,сколько вызовов вы ожидаете,а затем использовать результаты,когда вы получили столько вызовов:</target>
        </trans-unit>
        <trans-unit id="00f65b8b36a713a1b70d47398be1c721ed3fffd5" translate="yes" xml:space="preserve">
          <source>You can then see a nested Promise structure, that lets you spawn multiple and completely asynchronous nested HTTP calls, and join the results from each subset of calls through &lt;code&gt;Promise.all&lt;/code&gt;.</source>
          <target state="translated">Затем вы можете увидеть вложенную структуру Promise, которая позволяет создавать множественные и полностью асинхронные вложенные HTTP-вызовы и объединять результаты каждого подмножества вызовов через &lt;code&gt;Promise.all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5637817dac7360e2bf1c7c2d1626c7be889d259e" translate="yes" xml:space="preserve">
          <source>You can use a &lt;strong&gt;callback&lt;/strong&gt;, &lt;strong&gt;promise&lt;/strong&gt; and recently &lt;strong&gt;observable&lt;/strong&gt; to handle it for you, for example in promises we have some function like &lt;code&gt;success()&lt;/code&gt; or &lt;code&gt;then()&lt;/code&gt; which will be executed when your data is ready for you, same with callback or &lt;strong&gt;subscribe&lt;/strong&gt; function on &lt;strong&gt;observable&lt;/strong&gt;.</source>
          <target state="translated">Вы можете использовать &lt;strong&gt;обратный вызов&lt;/strong&gt; , &lt;strong&gt;обещание&lt;/strong&gt; и недавно &lt;strong&gt;наблюдаемый,&lt;/strong&gt; чтобы обработать его для вас, например, в обещаниях у нас есть некоторая функция, такая как &lt;code&gt;success()&lt;/code&gt; или &lt;code&gt;then()&lt;/code&gt; которая будет выполняться, когда ваши данные будут готовы для вас, то же самое с функцией обратного вызова или &lt;strong&gt;подписки&lt;/strong&gt; на &lt;strong&gt;наблюдаемом&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3aedc25db58a4804737e831c476a6e6a972dbab8" translate="yes" xml:space="preserve">
          <source>You can use this custom library (written using Promise) to make a remote call.</source>
          <target state="translated">Вы можете использовать эту пользовательскую библиотеку (написанную с помощью Promise)для удаленного вызова.</target>
        </trans-unit>
        <trans-unit id="dd6628c5f45797d9ea0f78c8fc099d6704e851a0" translate="yes" xml:space="preserve">
          <source>You'd end up going through &lt;code&gt;async1&lt;/code&gt;; check if &lt;code&gt;name&lt;/code&gt; is undefined or not and call the callback accordingly.</source>
          <target state="translated">В конечном итоге вы &lt;code&gt;async1&lt;/code&gt; через async1 ; проверь, если &lt;code&gt;name&lt;/code&gt; не определено или нет, и, соответственно, позвони.</target>
        </trans-unit>
        <trans-unit id="bd8715a64e94539f3c8b8df1772b0c03d902cf35" translate="yes" xml:space="preserve">
          <source>Your code should be something along the lines of this:</source>
          <target state="translated">Твой код должен быть чем-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="79d239c9d4dd6e9398d601a54d23e6f15a901265" translate="yes" xml:space="preserve">
          <source>async/await version:</source>
          <target state="translated">асинкавейтовая версия:</target>
        </trans-unit>
        <trans-unit id="5fa5455b316d09922e2556fd3e7db0992016d6bb" translate="yes" xml:space="preserve">
          <source>await is supported in all current browsers and node 8</source>
          <target state="translated">ожидание поддерживается во всех текущих браузерах и узле 8</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="6cdd908e77bf13956316a9dfb985f596f59e72fe" translate="yes" xml:space="preserve">
          <source>but if &lt;code&gt;a&lt;/code&gt; is asynchronous, with promises we have to write</source>
          <target state="translated">но если &lt;code&gt;a&lt;/code&gt; асинхронный, с обещаниями мы должны написать</target>
        </trans-unit>
        <trans-unit id="ba1108cd1f24e45036a47d4005ece995c5fe8b5d" translate="yes" xml:space="preserve">
          <source>cross-domain not allowed throws error automatically.</source>
          <target state="translated">междоменный не разрешенный бросает ошибку автоматически.</target>
        </trans-unit>
        <trans-unit id="3691b5c9d0eec5124fbea2e6256064c9e642e83e" translate="yes" xml:space="preserve">
          <source>for instance,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="00853d73f19844948fadbc48d500f997c46f7ee4" translate="yes" xml:space="preserve">
          <source>jQuery</source>
          <target state="translated">jQuery</target>
        </trans-unit>
        <trans-unit id="c6ba4cdd11e1a3db37a54109474e9c73534b938a" translate="yes" xml:space="preserve">
          <source>jQuery deferred</source>
          <target state="translated">запрос отложен</target>
        </trans-unit>
        <trans-unit id="fba0ae53da33f0cd5e54603774b1229ca748fbd7" translate="yes" xml:space="preserve">
          <source>nsynjs will evaluate all promises sequentially, and put promise result into &lt;code&gt;data&lt;/code&gt; property:</source>
          <target state="translated">nsynjs будет последовательно оценивать все обещания и помещать результат обещания в свойство &lt;code&gt;data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e1a5e2d288843cc0d03987443a6fc38bffe1ef80" translate="yes" xml:space="preserve">
          <source>onreadystatechange is only useful if you want to get the headers on state 2.</source>
          <target state="translated">onreadystatechange полезен только в том случае,если вы хотите получить заголовки в состоянии 2.</target>
        </trans-unit>
        <trans-unit id="0458efd542acc1a7aebda8d34461df3c13d76b38" translate="yes" xml:space="preserve">
          <source>so most of the time (but not always) you'll pass &lt;code&gt;foo&lt;/code&gt; not &lt;code&gt;foo()&lt;/code&gt;</source>
          <target state="translated">так что большую часть времени (но не всегда) вы будете проходить &lt;code&gt;foo&lt;/code&gt; ,а не &lt;code&gt;foo()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88018d8629c033501aa21a3ab6e24d7aebd65b57" translate="yes" xml:space="preserve">
          <source>then/catch version:</source>
          <target state="translated">версия &quot;дюйма&quot;:</target>
        </trans-unit>
        <trans-unit id="3aee67424c6f45abebfaef894361e9c0e7ddd958" translate="yes" xml:space="preserve">
          <source>where I am passing to &lt;code&gt;put_in_coffee&lt;/code&gt; both the milk to put in it, and also the action (&lt;code&gt;drink_coffee&lt;/code&gt;) to execute once the milk has been put in. Such code becomes hard to write, and read, and debug.</source>
          <target state="translated">где я передаю &lt;code&gt;put_in_coffee&lt;/code&gt; и молоко, которое нужно в него добавить, и действие ( &lt;code&gt;drink_coffee&lt;/code&gt; ), которое нужно выполнить после того, как молоко введено. Такой код становится трудно писать, читать и отлаживать.</target>
        </trans-unit>
        <trans-unit id="a861995ce1d879a17b5c91a26cf0e7eb75c29caf" translate="yes" xml:space="preserve">
          <source>which CAN be interpreted as:</source>
          <target state="translated">что может быть интерпретировано как:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
