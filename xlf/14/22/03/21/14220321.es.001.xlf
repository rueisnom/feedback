<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/14220321">
    <body>
      <group id="14220321">
        <trans-unit id="927d598b66027a146baa1781e637b904c6aa330f" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://stackoverflow.com/a/30180679/1348195&quot;&gt;Note, for those using the new &lt;code&gt;fetch&lt;/code&gt; API, Angular or promises I've added another answer below&lt;/a&gt;)</source>
          <target state="translated">( &lt;a href=&quot;https://stackoverflow.com/a/30180679/1348195&quot;&gt;Nota, para aquellos que usan la nueva API de &lt;code&gt;fetch&lt;/code&gt; , Angular o promesas, he agregado otra respuesta a continuaci&amp;oacute;n&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="99f4d532491d1864e1be89ab9b7b1d7432912746" translate="yes" xml:space="preserve">
          <source>(Although it can be written in Javascript, I prefer to write it in Python, and compile it to Javascript using &lt;a href=&quot;https://github.com/QQuick/Transcrypt&quot;&gt;Transcrypt&lt;/a&gt;. It will be clear enough.)</source>
          <target state="translated">(Aunque puede escribirse en Javascript, prefiero escribirlo en Python y compilarlo en Javascript usando &lt;a href=&quot;https://github.com/QQuick/Transcrypt&quot;&gt;Transcrypt&lt;/a&gt; . Ser&amp;aacute; lo suficientemente claro).</target>
        </trans-unit>
        <trans-unit id="5bdb200d65235570c1b58c9e91da7f158c793d35" translate="yes" xml:space="preserve">
          <source>(Fiddle)</source>
          <target state="translated">(Fiddle)</target>
        </trans-unit>
        <trans-unit id="5db09589cf8459f3d38f5553fbde8bce31d35a4c" translate="yes" xml:space="preserve">
          <source>(fiddle)</source>
          <target state="translated">(fiddle)</target>
        </trans-unit>
        <trans-unit id="7766903fe90c705c4ed71e3573241c83b2c69193" translate="yes" xml:space="preserve">
          <source>...which is less cumbersome with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015+ arrow functions&lt;/a&gt;:</source>
          <target state="translated">... que es menos engorroso con &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;las funciones de flecha ES2015 +&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f927aed5b9c420c5e6e8550a2e4521837fcb377c" translate="yes" xml:space="preserve">
          <source>1)Event Loop</source>
          <target state="translated">1)Bucle de eventos</target>
        </trans-unit>
        <trans-unit id="0742a4064775d4cda76aa61598d18d11036418f9" translate="yes" xml:space="preserve">
          <source>1. Synchronous AJAX - Don't do it!!</source>
          <target state="translated">1.AJAX síncrono-¡¡No lo hagas!!</target>
        </trans-unit>
        <trans-unit id="f24ae07c22d1eb6bb318aa04f411d2319b454d6c" translate="yes" xml:space="preserve">
          <source>2)Web API</source>
          <target state="translated">2)Web API</target>
        </trans-unit>
        <trans-unit id="f76660e7f2f317741f7b6f9a679f94b6aae6c47e" translate="yes" xml:space="preserve">
          <source>2. Restructure code</source>
          <target state="translated">2.Reestructurar el código</target>
        </trans-unit>
        <trans-unit id="44d7b3b36c7446cc15b0aafbdc4f232450505779" translate="yes" xml:space="preserve">
          <source>2017 answer: you can now do exactly what you want in every current browser and node</source>
          <target state="translated">Respuesta 2017:ahora puedes hacer exactamente lo que quieras en cada navegador y nodo actual</target>
        </trans-unit>
        <trans-unit id="0d76585d726fac5212bc15c005d34dc57ae870eb" translate="yes" xml:space="preserve">
          <source>3)Event Queue</source>
          <target state="translated">3)Cola de eventos</target>
        </trans-unit>
        <trans-unit id="68333d073e4f567370e4ebd9e36d796f8c754911" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/&quot;&gt;Here&lt;/a&gt; it says,</source>
          <target state="translated">&lt;a href=&quot;http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/&quot;&gt;Aqu&amp;iacute;&lt;/a&gt; dice</target>
        </trans-unit>
        <trans-unit id="d569b34dd010230f2b5736a91066fe31f29056f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; - A promise library for JavaScript</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; : una biblioteca prometedora para JavaScript</target>
        </trans-unit>
        <trans-unit id="8be840693df3eefddf69835e766647c8f3935f38" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/4866721/what-are-deferred-objects&quot;&gt;Deferred objects&lt;/a&gt; are jQuery's custom implementation of promises (before the Promise API was standardized). They behave almost like promises but expose a slightly different API.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4866721/what-are-deferred-objects&quot;&gt;Los objetos diferidos&lt;/a&gt; son la implementaci&amp;oacute;n personalizada de promesas de jQuery (antes de que la API Promise se estandarizara). Se comportan casi como promesas pero exponen una API ligeramente diferente.</target>
        </trans-unit>
        <trans-unit id="3c3877fa4d4bea86aa540d1d00c51cba27671903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fibers&lt;/code&gt; helps in solving the issue.</source>
          <target state="translated">&lt;code&gt;Fibers&lt;/code&gt; ayuda a resolver el problema.</target>
        </trans-unit>
        <trans-unit id="d4de38eeff0914f72435ab92aacf70919fd4db58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async/await&lt;/code&gt; builds on top of promises: an &lt;code&gt;async&lt;/code&gt; function always returns a promise. &lt;code&gt;await&lt;/code&gt; &quot;unwraps&quot; a promise and either result in the value the promise was resolved with or throws an error if the promise was rejected.</source>
          <target state="translated">&lt;code&gt;async/await&lt;/code&gt; se basa en promesas: una funci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; siempre devuelve una promesa. &lt;code&gt;await&lt;/code&gt; &quot;desenvuelve&quot; una promesa y resulta en el valor con el que se resolvi&amp;oacute; la promesa o arroja un error si la promesa fue rechazada.</target>
        </trans-unit>
        <trans-unit id="472c34ad7218489081303afcad61fe244feeb0fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt; will refer to the function we pass to &lt;code&gt;foo&lt;/code&gt; when we call it and we simply pass it on to &lt;code&gt;success&lt;/code&gt;. I.e. once the Ajax request is successful, &lt;code&gt;$.ajax&lt;/code&gt; will call &lt;code&gt;callback&lt;/code&gt; and pass the response to the callback (which can be referred to with &lt;code&gt;result&lt;/code&gt;, since this is how we defined the callback).</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; se referir&amp;aacute; a la funci&amp;oacute;n que pasamos a &lt;code&gt;foo&lt;/code&gt; cuando la llamamos y simplemente la pasamos al &lt;code&gt;success&lt;/code&gt; . Es decir, una vez que la solicitud de Ajax es exitosa, &lt;code&gt;$.ajax&lt;/code&gt; llamar&amp;aacute; a la &lt;code&gt;callback&lt;/code&gt; y pasar&amp;aacute; la respuesta a la devoluci&amp;oacute;n de llamada (que puede ser referida con el &lt;code&gt;result&lt;/code&gt; ado , ya que as&amp;iacute; es como definimos la devoluci&amp;oacute;n de llamada).</target>
        </trans-unit>
        <trans-unit id="0cdc633c16019e6c8b41e52704499a8c4fdbc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo&lt;/code&gt; itself is defined as follows:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="5bc50c14ccc34523a427f339d4f6b0d89980a4cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order_milk&lt;/code&gt; kicks off, orders the milk, then, when and only when it arrives, it invokes &lt;code&gt;put_in_coffee&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;order_milk&lt;/code&gt; comienza, ordena la leche, luego, cuando y solo cuando llega, invoca &lt;code&gt;put_in_coffee&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5486986e826b7ca20e7b32edb333416cf0cafa81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;rarr; For a more general explanation of async behaviour with different examples, please see&lt;/em&gt;&lt;a href=&quot;https://stackoverflow.com/q/23667086/218196&quot;&gt;Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;&amp;rarr; Para obtener una explicaci&amp;oacute;n m&amp;aacute;s general del comportamiento as&amp;iacute;ncrono con diferentes ejemplos, consulte&lt;/em&gt; &lt;a href=&quot;https://stackoverflow.com/q/23667086/218196&quot;&gt;&amp;iquest;Por qu&amp;eacute; no se altera mi variable despu&amp;eacute;s de modificarla dentro de una funci&amp;oacute;n?&lt;/a&gt; - Referencia de c&amp;oacute;digo as&amp;iacute;ncrono</target>
        </trans-unit>
        <trans-unit id="eb1f5ef8b32f66be0ebf85bab611e6a46d561b3a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;rarr; If you already understand the problem, skip to the possible solutions below.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;rarr; Si ya comprende el problema, pase a las posibles soluciones a continuaci&amp;oacute;n.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5326aa0d4ea5b09f0c635a23b58323c8c2e39d46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Or alternately, you could make a wrapper for &lt;code&gt;doSomethingAsync&lt;/code&gt; that returns a promise, and then do the below...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(O, alternativamente, podr&amp;iacute;a hacer un contenedor para &lt;code&gt;doSomethingAsync&lt;/code&gt; que devuelva una promesa, y luego haga lo siguiente ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e53fbd340f4f3003e06110183cb83b82789a7984" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Or, again, build a wrapper for &lt;code&gt;doSomethingAsync&lt;/code&gt; that gives you a promise and do the below...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(O, de nuevo, cree un contenedor para &lt;code&gt;doSomethingAsync&lt;/code&gt; que le ofrezca una promesa y haga lo siguiente ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1c2279af365b10752ed22cb3ac6e9f7c78b75a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Since we're doing the work in series, we can just use &lt;code&gt;results.push(result)&lt;/code&gt; since we know we won't get results out of order. In the above we could have used &lt;code&gt;results[index] = result;&lt;/code&gt;, but in some of the following examples we don't have an index to use.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Como estamos haciendo el trabajo en serie, podemos usar &lt;code&gt;results.push(result)&lt;/code&gt; ya que sabemos que no obtendremos resultados fuera de orden. En lo anterior podr&amp;iacute;amos haber usado &lt;code&gt;results[index] = result;&lt;/code&gt; pero en algunos de los siguientes ejemplos no tenemos un &amp;iacute;ndice para usar).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0dca3ab11483f31910ef1b76a0f2b57827edfed0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(We could do away with &lt;code&gt;expecting&lt;/code&gt; and just use &lt;code&gt;results.length === theArray.length&lt;/code&gt;, but that leaves us open to the possibility that &lt;code&gt;theArray&lt;/code&gt; is changed while the calls are outstanding...)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Podr&amp;iacute;amos eliminar la &lt;code&gt;expecting&lt;/code&gt; y simplemente usar &lt;code&gt;results.length === theArray.length&lt;/code&gt; , pero eso nos deja abiertos a la posibilidad de que &lt;code&gt;theArray&lt;/code&gt; cambie mientras las llamadas est&amp;aacute;n pendientes ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c79ef9a065b5b6d162c99553810bc34db9b4c98" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A Image from one of the answers here, Correctly explains callback use...&lt;/em&gt;
We give our function(function utilising data returned from server) to function calling server.</source>
          <target state="translated">&lt;em&gt;Una imagen de una de las respuestas aqu&amp;iacute;, explica correctamente el uso de la devoluci&amp;oacute;n de llamada ...&lt;/em&gt; Le damos a nuestra funci&amp;oacute;n (funci&amp;oacute;n que utiliza los datos devueltos por el servidor) a la funci&amp;oacute;n que llama al servidor.</target>
        </trans-unit>
        <trans-unit id="575713933b89fb879752fb918e398d207981e848" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Error handler&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Controlador de errores&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb7a5019ca58e906cfe2794d7f8ae19085308f37" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Of course, if &lt;code&gt;doSomethingAsync&lt;/code&gt; passed us errors, we'd use &lt;code&gt;reject&lt;/code&gt; to reject the promise when we got an error.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Por supuesto, si &lt;code&gt;doSomethingAsync&lt;/code&gt; nos pasa errores, usar&amp;iacute;amos &lt;code&gt;reject&lt;/code&gt; para rechazar la promesa cuando recibimos un error).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29ac499569a5a06c4d82ef94c11d97109d312692" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PS: As the first test I wrote x('x', displayAjax)..., and it totally got a response...??? So I checked the folder where the HTML is located, and there was a file called 'x.xml'. So even if you forget the extension of your file XMLHttpRequest 2 WILL FIND IT&lt;/em&gt;. I LOL'd</source>
          <target state="translated">&lt;em&gt;PD: Como la primera prueba, escrib&amp;iacute; x ('x', displayAjax) ..., y obtuve una respuesta ... &amp;iquest;???&lt;/em&gt; &lt;em&gt;As&amp;iacute; que verifiqu&amp;eacute; la carpeta donde se encuentra el HTML y hab&amp;iacute;a un archivo llamado 'x.xml'.&lt;/em&gt; &lt;em&gt;Entonces, incluso si olvida la extensi&amp;oacute;n de su archivo, XMLHttpRequest 2 LO ENCONTRAR&amp;Aacute;&lt;/em&gt; . Yo jajaja</target>
        </trans-unit>
        <trans-unit id="a453fdc787181e5194220141468f98edcb49264c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Read a file synchronous&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Leer un archivo sincr&amp;oacute;nico&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f873c1d50c07030d55b6897f696affcc44c234c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 2&lt;/strong&gt; (first of all read the answers from &lt;a href=&quot;https://stackoverflow.com/a/16825593/19068&quot;&gt;Benjamin Gruenbaum&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://stackoverflow.com/a/14220323/19068&quot;&gt;Felix Kling&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 2&lt;/strong&gt; (en primer lugar, lea las respuestas de &lt;a href=&quot;https://stackoverflow.com/a/16825593/19068&quot;&gt;Benjamin Gruenbaum&lt;/a&gt; y &lt;a href=&quot;https://stackoverflow.com/a/14220323/19068&quot;&gt;Felix Kling&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7bb7d03442a106c3a66906d1c9d76fc88badb345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;The Event Loop and Concurrency Model&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;El modelo de bucle de eventos y concurrencia&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc4c0812139669b4b9302dd36333c2148a9da551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All three are available in current browsers, and node 7+.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Los tres est&amp;aacute;n disponibles en los navegadores actuales y en el nodo 7+.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="890ea8c5734449e60d41906d358b6206ed712f11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt; (popular in node)</source>
          <target state="translated">&lt;strong&gt;Callbacks&lt;/strong&gt; (popular en nodo)</target>
        </trans-unit>
        <trans-unit id="e2ab2f71e857cb3d2466201010b62a27fd2e5e37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't do that.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;No hagas eso.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="afaf690b015b9a3ab311cb3b9d55efc3bab713ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 way (async - await)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Forma ES6 (as&amp;iacute;ncrono - espera)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d78b4767222f91ac61373691a4d965d332d201f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Embrace the asynchronous nature of JavaScript!&lt;/strong&gt; While certain asynchronous operations provide synchronous counterparts (so does &quot;Ajax&quot;), it's generally discouraged to use them, especially in a browser context.</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;Abrace la naturaleza asincr&amp;oacute;nica de JavaScript!&lt;/strong&gt; Si bien ciertas operaciones asincr&amp;oacute;nicas proporcionan contrapartidas sincr&amp;oacute;nicas (tambi&amp;eacute;n lo hace &quot;Ajax&quot;), generalmente se desaconseja usarlas, especialmente en un contexto de navegador.</target>
        </trans-unit>
        <trans-unit id="109d60edc3e638d2bab113fbb027ee1e4e879a32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Have a look at this example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Echa un vistazo a este ejemplo:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09004b4c20addc68d6df669ac50a41fb497dea47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heads up!&lt;/strong&gt; It is not possible to make a synchronous &lt;a href=&quot;https://stackoverflow.com/questions/2067472/please-explain-jsonp&quot;&gt;JSONP&lt;/a&gt; request. JSONP by its very nature is always asynchronous (one more reason to not even consider this option).</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;Aviso!&lt;/strong&gt; No es posible realizar una solicitud &lt;a href=&quot;https://stackoverflow.com/questions/2067472/please-explain-jsonp&quot;&gt;JSONP&lt;/a&gt; sincr&amp;oacute;nica. JSONP, por su propia naturaleza, siempre es as&amp;iacute;ncrono (una raz&amp;oacute;n m&amp;aacute;s para no considerar esta opci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="db3e68b8187a2a11a0f5fea968a2add5f24c4dfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; You can only use &lt;code&gt;await&lt;/code&gt; inside an &lt;code&gt;async&lt;/code&gt; function. Right now, top-level &lt;code&gt;await&lt;/code&gt; isn't yet supported, so you might have to make an async IIFE (&lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately_invoked_function_expression&quot;&gt;Immediately Invoked Function Expression&lt;/a&gt;) to start an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="translated">&lt;strong&gt;Importante:&lt;/strong&gt; Solo puede usar &lt;code&gt;await&lt;/code&gt; dentro de una funci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; . En este momento, la &lt;code&gt;await&lt;/code&gt; nivel superior a&amp;uacute;n no es compatible, por lo que es posible que deba realizar una IIFE asincr&amp;oacute;nica ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately_invoked_function_expression&quot;&gt;expresi&amp;oacute;n de funci&amp;oacute;n invocada inmediatamente&lt;/a&gt; ) para iniciar un contexto &lt;code&gt;async&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1a2d5a4642c349de8193773228017c7500f4e56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;
Recent Spotify &lt;code&gt;search&lt;/code&gt; APIs will require an access token to be specified in the request headers:</source>
          <target state="translated">&lt;strong&gt;NOTA&lt;/strong&gt; Las API de &lt;code&gt;search&lt;/code&gt; Spotify recientes requerir&amp;aacute;n que se especifique un token de acceso en los encabezados de solicitud:</target>
        </trans-unit>
        <trans-unit id="4b966ba6c20e45f447ff2e8f03f268e29a52a4f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises with &lt;code&gt;async/await&lt;/code&gt;&lt;/strong&gt; (ES2017+, available in older browsers if you use a transpiler or regenerator)</source>
          <target state="translated">&lt;strong&gt;Promesas con &lt;code&gt;async/await&lt;/code&gt; &lt;/strong&gt; await (ES2017 +, disponible en navegadores antiguos si usa un transpilador o regenerador)</target>
        </trans-unit>
        <trans-unit id="6473a819e62a6a22028f1318142e8cba26e9b5a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises with &lt;code&gt;then()&lt;/code&gt;&lt;/strong&gt; (ES2015+, available in older browsers if you use one of the many promise libraries)</source>
          <target state="translated">&lt;strong&gt;Promesas con &lt;code&gt;then()&lt;/code&gt; &lt;/strong&gt; (ES2015 +, disponible en navegadores antiguos si usa una de las muchas bibliotecas de promesas)</target>
        </trans-unit>
        <trans-unit id="04c41fa090162049f70a4e607252fab3dd0bb0ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short answer&lt;/strong&gt;: Your &lt;code&gt;foo()&lt;/code&gt; method returns immediately, while the &lt;code&gt;$ajax()&lt;/code&gt; call executes asynchronously &lt;em&gt;after the function returns&lt;/em&gt;. The problem is then how or where to store the results retrieved by the async call once it returns.</source>
          <target state="translated">&lt;strong&gt;Respuesta corta&lt;/strong&gt; : su m&amp;eacute;todo &lt;code&gt;foo()&lt;/code&gt; regresa inmediatamente, mientras que la llamada &lt;code&gt;$ajax()&lt;/code&gt; ejecuta de forma as&amp;iacute;ncrona &lt;em&gt;despu&amp;eacute;s de que la funci&amp;oacute;n regresa&lt;/em&gt; . El problema es entonces c&amp;oacute;mo o d&amp;oacute;nde almacenar los resultados recuperados por la llamada as&amp;iacute;ncrona una vez que regresa.</target>
        </trans-unit>
        <trans-unit id="f4645089306c6a1d783c20f54349274a135ed097" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, how do we tackle this issue?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Entonces, &amp;iquest;c&amp;oacute;mo abordamos este problema?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ab003d485f673dee9ae9f1e5a74cdd4ee60e809" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key thing here is the order of execution. That is&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La clave aqu&amp;iacute; es el orden de ejecuci&amp;oacute;n.&lt;/strong&gt; &lt;strong&gt;Es decir&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fac01d33af22c926036bf26176e2ea876531efc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the plnkr:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Este es el plnkr:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ed0d7ce5e48365488a89a8f5818cd02ab54aa58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WHEN is something going to run&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CUANDO va a correr algo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8fb2f83aee2cbeff4ac6fcb5ea50cce08e5c218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fulfilled&lt;/strong&gt; meaning that the computation completed successfully.</source>
          <target state="translated">&lt;strong&gt;cumplido,&lt;/strong&gt; lo que significa que el c&amp;aacute;lculo se complet&amp;oacute; con &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="3030d3b7a04661fbb4185df915ebeef20d9e0313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rejected&lt;/strong&gt; meaning that the computation failed.</source>
          <target state="translated">&lt;strong&gt;rechazado,&lt;/strong&gt; lo que significa que el c&amp;aacute;lculo fall&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="e9da82d285e8df3659dc9d639d7f7999131d7220" translate="yes" xml:space="preserve">
          <source>A Promise is a &lt;em&gt;value over time&lt;/em&gt;. Promises have state, they start as pending with no value and can settle to:</source>
          <target state="translated">Una promesa es un &lt;em&gt;valor en el tiempo&lt;/em&gt; . Las promesas tienen estado, comienzan como pendientes sin valor y pueden conformarse con:</target>
        </trans-unit>
        <trans-unit id="0fa2ed570336fff9061c7fed76b7c10d8559bca9" translate="yes" xml:space="preserve">
          <source>A callback is simply a function passed to another function. That other function can call the function passed whenever it is ready. In the context of an asynchronous process, the callback will be called whenever the asynchronous process is done. Usually, the result is passed to the callback.</source>
          <target state="translated">Una llamada es simplemente una función que se pasa a otra función.Esa otra función puede llamar a la función pasada cuando esté lista.En el contexto de un proceso asíncrono,se llamará a la llamada de retorno cuando el proceso asíncrono esté listo.Normalmente,el resultado se pasa a la llamada de retorno.</target>
        </trans-unit>
        <trans-unit id="f9e8a04c6605f9a32383dcbf481370c3e715820d" translate="yes" xml:space="preserve">
          <source>A promise can only change states &lt;em&gt;once&lt;/em&gt; after which it will always stay at the same state forever. You can attach &lt;code&gt;then&lt;/code&gt; handlers to promises to extract their value and handle errors. &lt;code&gt;then&lt;/code&gt; handlers allow &lt;a href=&quot;https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks&quot;&gt;chaining&lt;/a&gt; of calls. Promises are created by &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;using APIs that return them&lt;/a&gt;. For example, the more modern AJAX replacement &lt;code&gt;fetch&lt;/code&gt; or jQuery's &lt;code&gt;$.get&lt;/code&gt; return promises.</source>
          <target state="translated">Una promesa solo puede cambiar de estado &lt;em&gt;una vez,&lt;/em&gt; despu&amp;eacute;s de lo cual siempre permanecer&amp;aacute; en el mismo estado para siempre. &lt;code&gt;then&lt;/code&gt; puede adjuntar controladores a las promesas para extraer su valor y manejar los errores. &lt;code&gt;then&lt;/code&gt; manejadores permiten &lt;a href=&quot;https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks&quot;&gt;encadenar las&lt;/a&gt; llamadas. Las promesas se crean mediante el &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;uso de API que las devuelven&lt;/a&gt; . Por ejemplo, la &lt;code&gt;fetch&lt;/code&gt; reemplazo de AJAX m&amp;aacute;s moderna o las promesas de devoluci&amp;oacute;n de &lt;code&gt;$.get&lt;/code&gt; jQuery.</target>
        </trans-unit>
        <trans-unit id="d64b3ccbf97c56e6baf992073261e3d4c261d264" translate="yes" xml:space="preserve">
          <source>A+ Promises.js</source>
          <target state="translated">A+Promesas.js</target>
        </trans-unit>
        <trans-unit id="7b2622a1b73a931e6ca38a355f7e3e8ea446ddb8" translate="yes" xml:space="preserve">
          <source>Above, we said, &quot;JS has no way to know that it needs to &lt;strong&gt;wait&lt;/strong&gt; for the first call to finish before it executes the second&quot;. Wouldn't it be nice if there &lt;strong&gt;was&lt;/strong&gt; some way to tell JS that? It turns out that there is--the &lt;code&gt;await&lt;/code&gt; keyword, used inside a special type of function called an &quot;async&quot; function. This feature is part of the upcoming version of ES but is already available in transpilers such as Babel given the right presets. This allows us to simply write</source>
          <target state="translated">Arriba, dijimos, &quot;JS no tiene forma de saber que necesita &lt;strong&gt;esperar&lt;/strong&gt; a que termine la primera llamada antes de ejecutar la segunda&quot;. &amp;iquest;No ser&amp;iacute;a bueno si hubiera alguna forma de decirle a JS eso? Resulta que existe la palabra clave &lt;code&gt;await&lt;/code&gt; , utilizada dentro de un tipo especial de funci&amp;oacute;n llamada funci&amp;oacute;n &quot;as&amp;iacute;ncrona&quot;. Esta caracter&amp;iacute;stica es parte de la pr&amp;oacute;xima versi&amp;oacute;n de ES pero ya est&amp;aacute; disponible en transpiladores como Babel con los ajustes preestablecidos correctos. Esto nos permite simplemente escribir</target>
        </trans-unit>
        <trans-unit id="e1ca54ffb7b2f8af43c2a3bf761dc7cd1da55e53" translate="yes" xml:space="preserve">
          <source>Actually, all we've done is added a &lt;code&gt;return&lt;/code&gt; to the call to &lt;code&gt;$.ajax&lt;/code&gt;. This works because jQuery's &lt;code&gt;$.ajax&lt;/code&gt; already returns a kind of promise-like thing. (In practice, without getting into details, we would prefer to wrap this call so as for return a real promise, or use some alternative to &lt;code&gt;$.ajax&lt;/code&gt; that does so.) Now, if we want to load the file and wait for it to finish and then do something, we can simply say</source>
          <target state="translated">En realidad, todo lo que hemos hecho es agregar un &lt;code&gt;return&lt;/code&gt; a la llamada a &lt;code&gt;$.ajax&lt;/code&gt; . Esto funciona porque &lt;code&gt;$.ajax&lt;/code&gt; jQuery ya devuelve una especie de promesa. (En la pr&amp;aacute;ctica, sin entrar en detalles, preferir&amp;iacute;amos finalizar esta llamada para devolver una promesa real, o usar alguna alternativa a &lt;code&gt;$.ajax&lt;/code&gt; que lo haga). Ahora, si queremos cargar el archivo y esperarlo. para terminar y luego hacer algo, simplemente podemos decir</target>
        </trans-unit>
        <trans-unit id="8806f1d6f77f315f3c6459851ebdd89a11e28f02" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;'async'&lt;/a&gt; keyword to the parent function</source>
          <target state="translated">Agregue la palabra clave &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;'async'&lt;/a&gt; a la funci&amp;oacute;n padre</target>
        </trans-unit>
        <trans-unit id="529deb621e57605154d7312ba8f12b3f554d9040" translate="yes" xml:space="preserve">
          <source>Additionally here is the promises &lt;a href=&quot;https://github.com/promises-aplus/promises-spec&quot;&gt;spec&lt;/a&gt; define here.</source>
          <target state="translated">Adem&amp;aacute;s, aqu&amp;iacute; est&amp;aacute;n las promesas que las &lt;a href=&quot;https://github.com/promises-aplus/promises-spec&quot;&gt;especificaciones&lt;/a&gt; definen aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="ab38701d1301596d1056dacff49b4a862d011ba3" translate="yes" xml:space="preserve">
          <source>Again ... it's a very short function, but it does get &amp;amp; post.</source>
          <target state="translated">Una vez m&amp;aacute;s ... es una funci&amp;oacute;n muy corta, pero obtiene y publica.</target>
        </trans-unit>
        <trans-unit id="54729d47d0181e621bfce461fcd3befc07e5b989" translate="yes" xml:space="preserve">
          <source>All of this is really bad user experience. The user won't be able to tell whether everything is working fine or not. Furthermore, the effect will be worse for users with a slow connection.</source>
          <target state="translated">Todo esto es realmente una mala experiencia para el usuario.El usuario no podrá saber si todo funciona bien o no.Además,el efecto será peor para los usuarios con una conexión lenta.</target>
        </trans-unit>
        <trans-unit id="644cfe271cac18a474c99dd756307f08b1e0e327" translate="yes" xml:space="preserve">
          <source>And executing it like this.</source>
          <target state="translated">Y ejecutándolo así.</target>
        </trans-unit>
        <trans-unit id="761067f16b11d2d1e088fb27ee5a3facce3b502f" translate="yes" xml:space="preserve">
          <source>Angular1</source>
          <target state="translated">Angular1</target>
        </trans-unit>
        <trans-unit id="a6f848c2ffe2ed313ae1ff7c87a3e8f4231023f9" translate="yes" xml:space="preserve">
          <source>Angular2 and Later</source>
          <target state="translated">Angular2 y posterior</target>
        </trans-unit>
        <trans-unit id="700b18f544e30a3391a16d96b67c29e5dd7f4d12" translate="yes" xml:space="preserve">
          <source>Another approach to return a value from an asynchronous function, is to pass in an object that will store the result from the asynchronous function.</source>
          <target state="translated">Otro enfoque para devolver un valor de una función asíncrona,es pasar un objeto que almacenará el resultado de la función asíncrona.</target>
        </trans-unit>
        <trans-unit id="6e0e29ebcd867f1dca1b8c6b1fb3343ba7d8745a" translate="yes" xml:space="preserve">
          <source>Another point is... if you work with APIs or just your own list's files or whatever you always use different functions for each request...</source>
          <target state="translated">Otro punto es...si trabajas con APIs o sólo con los archivos de tu propia lista o lo que sea,siempre usas diferentes funciones para cada solicitud...</target>
        </trans-unit>
        <trans-unit id="64aef2853dbea8a1653b08bcdf147b457091ff7b" translate="yes" xml:space="preserve">
          <source>Another solution is to execute code via sequential executor &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt;.</source>
          <target state="translated">Otra soluci&amp;oacute;n es ejecutar c&amp;oacute;digo a trav&amp;eacute;s del ejecutor secuencial &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2cb720802474bc4792fbb02842d36aeeabbeceb" translate="yes" xml:space="preserve">
          <source>Apart from using &lt;code&gt;then/catch&lt;/code&gt; to work with promises, there exists one more approach. The idea is to &lt;em&gt;recognize an asynchronous function&lt;/em&gt; and then &lt;em&gt;wait for the promises&lt;/em&gt; to resolve, before moving to the next line of code. It's still just the &lt;code&gt;promises&lt;/code&gt; under the hood, but with a different syntactical approach. To make things clearer, you can find a comparison below:</source>
          <target state="translated">Adem&amp;aacute;s de usar &lt;code&gt;then/catch&lt;/code&gt; para trabajar con promesas, existe un enfoque m&amp;aacute;s. La idea es &lt;em&gt;reconocer una funci&amp;oacute;n asincr&amp;oacute;nica&lt;/em&gt; y luego &lt;em&gt;esperar&lt;/em&gt; a que se resuelvan &lt;em&gt;las promesas&lt;/em&gt; , antes de pasar a la siguiente l&amp;iacute;nea de c&amp;oacute;digo. Sigue siendo solo las &lt;code&gt;promises&lt;/code&gt; bajo el cap&amp;oacute;, pero con un enfoque sint&amp;aacute;ctico diferente. Para aclarar las cosas, puede encontrar una comparaci&amp;oacute;n a continuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="4d6935922dd9171b57188004a7345d312359feff" translate="yes" xml:space="preserve">
          <source>Applied to our Ajax call we could use promises like this:</source>
          <target state="translated">Aplicado a nuestra llamada de Ajax podríamos usar promesas como esta:</target>
        </trans-unit>
        <trans-unit id="1ef6615c95aa80cbc5318149fff9515811e8e9d4" translate="yes" xml:space="preserve">
          <source>Applying this</source>
          <target state="translated">Aplicando esto</target>
        </trans-unit>
        <trans-unit id="f1a34583be1c0d1698743056ac6453867467e99a" translate="yes" xml:space="preserve">
          <source>As I mentioned, some(!) asynchronous operations have synchronous counterparts. I don't advocate their use, but for completeness' sake, here is how you would perform a synchronous call:</source>
          <target state="translated">Como mencioné,algunas operaciones asíncronas tienen contrapartes síncronas.No abogo por su uso,pero para completar,así es como se realizaría una llamada síncrona:</target>
        </trans-unit>
        <trans-unit id="d690325261d4ed328617f51bcb035e4e34411085" translate="yes" xml:space="preserve">
          <source>As for synchronous AJAX, &lt;strong&gt;don't do it!&lt;/strong&gt; Felix's answer raises some compelling arguments about why it's a bad idea. To sum it up, it'll freeze the user's browser until the server returns the response and create a very bad user experience. Here is another short summary taken from MDN on why:</source>
          <target state="translated">En cuanto a AJAX s&amp;iacute;ncrono, &lt;strong&gt;&amp;iexcl;no lo hagas!&lt;/strong&gt; La respuesta de Felix plantea algunos argumentos convincentes sobre por qu&amp;eacute; es una mala idea. Para resumir, congelar&amp;aacute; el navegador del usuario hasta que el servidor devuelva la respuesta y cree una experiencia de usuario muy mala. Aqu&amp;iacute; hay otro breve resumen tomado de MDN sobre por qu&amp;eacute;:</target>
        </trans-unit>
        <trans-unit id="4406a09393c68f9778335e6efa2ba72dfa43398d" translate="yes" xml:space="preserve">
          <source>As mentioned in the comment the use of error &amp;amp;&amp;amp; synchronous does completely break the point of the answer. Which is a nice short way to use Ajax in the proper way?</source>
          <target state="translated">Como se mencion&amp;oacute; en el comentario, el uso de error &amp;amp;&amp;amp; synchronous rompe completamente el punto de la respuesta. &amp;iquest;Cu&amp;aacute;l es una buena forma de usar Ajax de la manera adecuada?</target>
        </trans-unit>
        <trans-unit id="3d039321bb1e1655c4cd32eb77e5d556b9a9d4cc" translate="yes" xml:space="preserve">
          <source>As you can see &lt;code&gt;getJoke&lt;/code&gt; is &lt;strong&gt;returning a&lt;/strong&gt; resolved &lt;strong&gt;promise&lt;/strong&gt; (it is resolved when returning &lt;code&gt;res.data.value&lt;/code&gt;). So you wait until the &lt;strong&gt;$http.get&lt;/strong&gt; request is completed and then &lt;strong&gt;console.log(res.joke)&lt;/strong&gt; is executed (as a normal asynchronous flow).</source>
          <target state="translated">Como puede ver, &lt;code&gt;getJoke&lt;/code&gt; est&amp;aacute; &lt;strong&gt;devolviendo una&lt;/strong&gt; &lt;strong&gt;promesa&lt;/strong&gt; resuelta (se resuelve al devolver &lt;code&gt;res.data.value&lt;/code&gt; ). Por lo tanto, espere hasta que se &lt;strong&gt;complete la&lt;/strong&gt; solicitud &lt;strong&gt;$ http.get&lt;/strong&gt; y luego se ejecute &lt;strong&gt;console.log (res.joke)&lt;/strong&gt; (como un flujo as&amp;iacute;ncrono normal).</target>
        </trans-unit>
        <trans-unit id="6be3c4864e2a35cc4ac8cfd91a74da6e56a1ee18" translate="yes" xml:space="preserve">
          <source>As you can see I didn't implement sync... it's a bad thing.</source>
          <target state="translated">Como puedes ver,no implementé la sincronización...es algo malo.</target>
        </trans-unit>
        <trans-unit id="3e214af7884162cf40fb2934293a2a307f51fd46" translate="yes" xml:space="preserve">
          <source>As you can see:</source>
          <target state="translated">Como puede ver:</target>
        </trans-unit>
        <trans-unit id="3d7fac7964f752248f02c5aa61c85fd417dcfbcf" translate="yes" xml:space="preserve">
          <source>Asynchronous</source>
          <target state="translated">Asynchronous</target>
        </trans-unit>
        <trans-unit id="9ce552a69176ba76938ef8727847cfb9c28c9943" translate="yes" xml:space="preserve">
          <source>Basically, instead of returning a &lt;em&gt;value&lt;/em&gt; which we can't do because of the concurrency model - we're returning a &lt;em&gt;wrapper&lt;/em&gt; for a value that we can &lt;em&gt;unwrap&lt;/em&gt; with &lt;code&gt;then&lt;/code&gt;. It's like a box you can open with &lt;code&gt;then&lt;/code&gt;.</source>
          <target state="translated">B&amp;aacute;sicamente, en lugar de devolver un &lt;em&gt;valor&lt;/em&gt; que no podemos hacer debido al modelo de concurrencia, estamos devolviendo un &lt;em&gt;contenedor&lt;/em&gt; para un valor con el que podemos &lt;em&gt;desenvolverlo&lt;/em&gt; . Es como una caja con la que puedes abrir &lt;code&gt;then&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eab484a08dfc236925e2ba1434abe3c27155a03c" translate="yes" xml:space="preserve">
          <source>Because JS has no way to know that it needs to &lt;strong&gt;wait&lt;/strong&gt; for &lt;code&gt;order_milk&lt;/code&gt; to finish before it executes &lt;code&gt;put_in_coffee&lt;/code&gt;. In other words, it does not know that &lt;code&gt;order_milk&lt;/code&gt; is &lt;strong&gt;asynchronous&lt;/strong&gt;--is something that is not going to result in milk until some future time. JS, and other declarative languages execute one statement after another without waiting.</source>
          <target state="translated">Debido a que JS no tiene forma de saber que necesita &lt;strong&gt;esperar&lt;/strong&gt; a que termine &lt;code&gt;order_milk&lt;/code&gt; antes de ejecutar &lt;code&gt;put_in_coffee&lt;/code&gt; . En otras palabras, no sabe que &lt;code&gt;order_milk&lt;/code&gt; es &lt;strong&gt;as&amp;iacute;ncrono,&lt;/strong&gt; es algo que no va a producir leche hasta alg&amp;uacute;n momento futuro. JS y otros lenguajes declarativos ejecutan una declaraci&amp;oacute;n tras otra sin esperar.</target>
        </trans-unit>
        <trans-unit id="4fb46d91439c44dca8be62ad2c6da7e246ac7424" translate="yes" xml:space="preserve">
          <source>Because a callback is not executed immediately but at a later time it's important to pass the reference to the function not it executed. so</source>
          <target state="translated">Debido a que una llamada no se ejecuta de inmediato,pero en un momento posterior es importante pasar la referencia a la función que no se ejecutó.así que</target>
        </trans-unit>
        <trans-unit id="e949293bb3141d39921183faafd54e8bcb4089c2" translate="yes" xml:space="preserve">
          <source>Becomes:</source>
          <target state="translated">Becomes:</target>
        </trans-unit>
        <trans-unit id="33e41fa8d678aeb4e035f2f254faf9c3f81da31a" translate="yes" xml:space="preserve">
          <source>Browser Promise object</source>
          <target state="translated">Navegador Objeto de la promesa</target>
        </trans-unit>
        <trans-unit id="765bf6bf6d4dba7ff5f829d9d93bb123d301ca4a" translate="yes" xml:space="preserve">
          <source>Browser can be divided into three parts:</source>
          <target state="translated">El navegador puede dividirse en tres partes:</target>
        </trans-unit>
        <trans-unit id="d450093edec3c9a5aeeeb0beef75d475c35a50cd" translate="yes" xml:space="preserve">
          <source>But how you can do it in pure &lt;strong&gt;javascript&lt;/strong&gt; or &lt;strong&gt;jQuery&lt;/strong&gt; for example as you asked in this question?</source>
          <target state="translated">Pero, &amp;iquest;c&amp;oacute;mo puede hacerlo en &lt;strong&gt;javascript&lt;/strong&gt; puro o &lt;strong&gt;jQuery,&lt;/strong&gt; por ejemplo, como hizo en esta pregunta?</target>
        </trans-unit>
        <trans-unit id="a64b0676afddefea547c307ed3e8295760faffaa" translate="yes" xml:space="preserve">
          <source>But the fix is easy:</source>
          <target state="translated">Pero el arreglo es fácil:</target>
        </trans-unit>
        <trans-unit id="77d296e55d0766d8200053d7f3cfd7c13d9226be" translate="yes" xml:space="preserve">
          <source>But the question here is how to return an Ajax response... (I added an easy way.)</source>
          <target state="translated">Pero la pregunta aquí es cómo devolver una respuesta de Ajax...(Añadí una manera fácil.)</target>
        </trans-unit>
        <trans-unit id="871ea55bfadd9c09cdde6b012a015872456c8c66" translate="yes" xml:space="preserve">
          <source>But there's still something vaguely dissatisfying about having to write code one way if synchronous and a quite different way if asynchronous. For synchronous, we write</source>
          <target state="translated">Pero todavía hay algo vagamente insatisfactorio en tener que escribir código de una manera si es síncrono y de otra muy diferente si es asíncrono.Para el síncrono,escribimos</target>
        </trans-unit>
        <trans-unit id="6662b4c845488fe6c8b6ee72b41f77fa73bca428" translate="yes" xml:space="preserve">
          <source>But to really get out an error the &lt;strong&gt;only&lt;/strong&gt; way is to write a wrong URL in which case every browser throws an error.</source>
          <target state="translated">Pero para sacar realmente un error, la &lt;strong&gt;&amp;uacute;nica&lt;/strong&gt; forma es escribir una URL incorrecta, en cuyo caso cada navegador arroja un error.</target>
        </trans-unit>
        <trans-unit id="b6fe1615524c00038c401cf5c333c9dc307f8bd8" translate="yes" xml:space="preserve">
          <source>But wait...!</source>
          <target state="translated">Pero espera...</target>
        </trans-unit>
        <trans-unit id="dfb64faad30b77313e3dfe8cbd9a6f1d588843af" translate="yes" xml:space="preserve">
          <source>But what if you need to &lt;em&gt;return&lt;/em&gt; those results from a function? As the other answers have pointed out, you can't; you have to have your function accept and call a callback (or return a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;). Here's a callback version:</source>
          <target state="translated">Pero, &amp;iquest;qu&amp;eacute; sucede si necesita &lt;em&gt;devolver&lt;/em&gt; esos resultados de una funci&amp;oacute;n? Como las otras respuestas han se&amp;ntilde;alado, no puedes; debe hacer que su funci&amp;oacute;n acepte y llame una devoluci&amp;oacute;n de llamada (o devuelva una &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promesa&lt;/a&gt; ). Aqu&amp;iacute; hay una versi&amp;oacute;n de devoluci&amp;oacute;n de llamada:</target>
        </trans-unit>
        <trans-unit id="53f5926dc5af0fddf203c78ec84b5d65b51a2f52" translate="yes" xml:space="preserve">
          <source>But you can do a lot of stuff with XMLHttpRequest 2:</source>
          <target state="translated">Pero puedes hacer muchas cosas con XMLHttpRequest 2:</target>
        </trans-unit>
        <trans-unit id="b0d6941afab03ca7758a76da0c336ec6d021825e" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;http://caniuse.com/xhr2&quot;&gt;XMLHttpRequest advanced features&lt;/a&gt;</source>
          <target state="translated">Consulte las &lt;a href=&quot;http://caniuse.com/xhr2&quot;&gt;funciones avanzadas de XMLHttpRequest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31ebfd440a69ecc3715e49c5b6a6c1dd6d4b0371" translate="yes" xml:space="preserve">
          <source>Consider an example. You call the milkman and order some milk. When it comes, you want to put it in your coffee. You can't put the milk in your coffee right now, because it is not here yet. You have to wait for it to come before putting it in your coffee. In other words, the following won't work:</source>
          <target state="translated">Considere un ejemplo.Llama al lechero y pide un poco de leche.Cuando llega,quieres ponerla en tu café.No puedes poner la leche en tu café ahora mismo,porque no está aquí todavía.Tienes que esperar a que llegue antes de ponerla en tu café.En otras palabras,lo siguiente no funcionará:</target>
        </trans-unit>
        <trans-unit id="84b2d3dacc41e20a8047eac062d786928aeea668" translate="yes" xml:space="preserve">
          <source>Context. The example is querying the &lt;a href=&quot;https://developer.spotify.com/web-api/endpoint-reference/&quot;&gt;Spotify Web API&lt;/a&gt; endpoint in order to search for &lt;code&gt;playlist&lt;/code&gt; objects for a given set of query strings:</source>
          <target state="translated">Contexto. El ejemplo es consultar el punto final de la &lt;a href=&quot;https://developer.spotify.com/web-api/endpoint-reference/&quot;&gt;API web de Spotify&lt;/a&gt; para buscar objetos de la &lt;code&gt;playlist&lt;/code&gt; de reproducci&amp;oacute;n para un conjunto dado de cadenas de consulta:</target>
        </trans-unit>
        <trans-unit id="b985b8de161adfd30380ec1c45ac41353ff18286" translate="yes" xml:space="preserve">
          <source>Current &lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-async_functions&quot;&gt;browser&lt;/a&gt; and &lt;a href=&quot;http://node.green/#ES2017-features-async-functions&quot;&gt;node&lt;/a&gt; versions support &lt;code&gt;async/await&lt;/code&gt;. You can also support older environments by transforming your code to ES5 with the help of &lt;a href=&quot;https://github.com/facebook/regenerator&quot;&gt;regenerator&lt;/a&gt; (or tools that use regenerator, such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;).</source>
          <target state="translated">Las versiones actuales de &lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-async_functions&quot;&gt;navegador&lt;/a&gt; y &lt;a href=&quot;http://node.green/#ES2017-features-async-functions&quot;&gt;nodo&lt;/a&gt; admiten &lt;code&gt;async/await&lt;/code&gt; . Tambi&amp;eacute;n puede admitir entornos m&amp;aacute;s antiguos transformando su c&amp;oacute;digo a ES5 con la ayuda de &lt;a href=&quot;https://github.com/facebook/regenerator&quot;&gt;regenerator&lt;/a&gt; (o herramientas que usan regenerator, como &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="23b9d4749a9f206dd4aecf7d5fe1ab0fe7998221" translate="yes" xml:space="preserve">
          <source>Define a function which returns a &lt;strong&gt;Promise&lt;/strong&gt;, in this case an Ajax call:</source>
          <target state="translated">Defina una funci&amp;oacute;n que devuelva una &lt;strong&gt;Promesa&lt;/strong&gt; , en este caso una llamada Ajax:</target>
        </trans-unit>
        <trans-unit id="3047a156238e05c9e91f44e59216ce4350e7d875" translate="yes" xml:space="preserve">
          <source>Describing all the advantages that promise offer is beyond the scope of this answer, but if you write new code, you should seriously consider them. They provide a great abstraction and separation of your code.</source>
          <target state="translated">Describir todas las ventajas que ofrecen las promesas está fuera del alcance de esta respuesta,pero si escribes un nuevo código,deberías considerarlas seriamente.Proporcionan una gran abstracción y separación de tu código.</target>
        </trans-unit>
        <trans-unit id="d24cf059acad77f2348de6ab9a950dcb953d0c1e" translate="yes" xml:space="preserve">
          <source>Difficulties could arise when you have to work with third-party code, but most problems can be solved by just thinking through the application flow.</source>
          <target state="translated">Pueden surgir dificultades cuando se tiene que trabajar con código de terceros,pero la mayoría de los problemas se pueden resolver con sólo pensar en el flujo de la aplicación.</target>
        </trans-unit>
        <trans-unit id="291b4e6259557593d37f6433293f59fe5f76d601" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 has 'generators' which allow you to easily program in an asynchronous style.</source>
          <target state="translated">ECMAScript 6 tiene &quot;generadores&quot; que permiten programar fácilmente en un estilo asíncrono.</target>
        </trans-unit>
        <trans-unit id="e3af59b16940b2e81235ebbcb74c7f1a75b7e5e5" translate="yes" xml:space="preserve">
          <source>ES2015 (ES6)</source>
          <target state="translated">ES2015 (ES6)</target>
        </trans-unit>
        <trans-unit id="7dbb3904074ff18348bd30e832250b33427cdc38" translate="yes" xml:space="preserve">
          <source>ES2015+: Promises with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;then()&lt;/a&gt;</source>
          <target state="translated">ES2015 +: Promesas con &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;then ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35bf367fe5ced0d619315d0cc8f147a296348c43" translate="yes" xml:space="preserve">
          <source>ES2016 (ES7)</source>
          <target state="translated">ES2016 (ES7)</target>
        </trans-unit>
        <trans-unit id="1542f3c49056454d75a06101c17c1785c445d891" translate="yes" xml:space="preserve">
          <source>ES2017+: Promises with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async/await&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ES2017 +: Promesas con &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async/await&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="967cf59859743f73ba18a11fe55a168a8034039e" translate="yes" xml:space="preserve">
          <source>ES6 introduces &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generators&lt;/a&gt; which are functions that can return in the middle and then resume the point they were at. This is typically useful for sequences, for example:</source>
          <target state="translated">ES6 introduce &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generadores&lt;/a&gt; que son funciones que pueden regresar en el medio y luego reanudar el punto en el que estaban. Esto suele ser &amp;uacute;til para secuencias, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4b08c5e49b030b945e2f126cefe3cc1039afa94b" translate="yes" xml:space="preserve">
          <source>Enter promises</source>
          <target state="translated">Ingresa las promesas...</target>
        </trans-unit>
        <trans-unit id="80993d0449ad6680943f4a71d58a1facc8010c69" translate="yes" xml:space="preserve">
          <source>Error handlers are maybe useful if you set custom headers, set the responseType to blob array buffer or whatever...</source>
          <target state="translated">Los manejadores de errores son útiles si se establecen cabeceras personalizadas,si se establece el responseType en el buffer de la matriz de blob o lo que sea...</target>
        </trans-unit>
        <trans-unit id="52397d788ea7c6b60de8f942da7edb5fd927e6c4" translate="yes" xml:space="preserve">
          <source>Even if you pass 'POSTAPAPAP' as the method it won't throw an error.</source>
          <target state="translated">Incluso si pasas &quot;POSTAPAPAP&quot; como el método no arrojará un error.</target>
        </trans-unit>
        <trans-unit id="ed627f8185515e40e63ef82e28b0e78972fa2fad" translate="yes" xml:space="preserve">
          <source>Even if you pass 'fdggdgilfdghfldj' as formdata it won't throw an error.</source>
          <target state="translated">Incluso si pasas 'fdggdgilfdghfldj' como formdata,no te dará un error.</target>
        </trans-unit>
        <trans-unit id="c920a57596f644008ba32598f248afdb53f17307" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;findItem&lt;/code&gt; might take a long time to execute, any code coming after &lt;code&gt;var item = findItem();&lt;/code&gt; has to &lt;em&gt;wait&lt;/em&gt; until the function returns the result.</source>
          <target state="translated">Aunque &lt;code&gt;findItem&lt;/code&gt; puede tardar mucho tiempo en ejecutarse, cualquier c&amp;oacute;digo que venga despu&amp;eacute;s de &lt;code&gt;var item = findItem();&lt;/code&gt; tiene que &lt;em&gt;esperar&lt;/em&gt; hasta que la funci&amp;oacute;n devuelva el resultado.</target>
        </trans-unit>
        <trans-unit id="af30fe5dce2e46682e9e3add89a73ab9d1afd392" translate="yes" xml:space="preserve">
          <source>Event Loop runs for forever i.e kind of infinite loop.Event Queue is where all your function are pushed on some event(example:click) this is one by one carried out of queue and put into Event loop which execute this function and prepares it self for next one after first one is executed.This means Execution of one function doesn't starts till the function before it in queue is executed in event loop.</source>
          <target state="translated">El bucle de eventos funciona para siempre,es decir,una especie de bucle infinito.La cola de eventos es donde todas las funciones se empujan en algún evento (ejemplo:clic),esto se lleva a cabo uno por uno de la cola y se pone en el bucle de eventos,que ejecuta esta función y se prepara para la siguiente después de que se ejecute la primera.</target>
        </trans-unit>
        <trans-unit id="ba81b013536dce95c24ccc172a06bd722742bb6a" translate="yes" xml:space="preserve">
          <source>Every Ajax method of jQuery already returns a &quot;deferred object&quot; (actually a promise of a deferred object) which you can just return from your function:</source>
          <target state="translated">Cada método de Ajax de jQuery ya devuelve un &quot;objeto diferido&quot; (en realidad,una promesa de un objeto diferido)que puedes simplemente devolver de tu función:</target>
        </trans-unit>
        <trans-unit id="197abe1392101850410c061421129e3d1b59f596" translate="yes" xml:space="preserve">
          <source>Example found in &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$q&quot;&gt;docs&lt;/a&gt; mentioned below.</source>
          <target state="translated">Ejemplo encontrado en los &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$q&quot;&gt;documentos&lt;/a&gt; mencionados a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="77810a758bab3888ba66659f3df788816aeb992b" translate="yes" xml:space="preserve">
          <source>Example: jQuery deferred implementation to work with multiple requests</source>
          <target state="translated">Ejemplo:jQuery aplazó la aplicación para trabajar con múltiples solicitudes</target>
        </trans-unit>
        <trans-unit id="6b5bea21483cbaba11f47e563b491712cd328829" translate="yes" xml:space="preserve">
          <source>Examples of usage:</source>
          <target state="translated">Ejemplos de uso:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="2bb87a5dd963da02345343f24198c82aa718d522" translate="yes" xml:space="preserve">
          <source>Felix Kling did a fine job writing an answer for people using jQuery for AJAX, I've decided to provide an alternative for people who aren't.</source>
          <target state="translated">Felix Kling hizo un buen trabajo escribiendo una respuesta para la gente que usa jQuery para AJAX.</target>
        </trans-unit>
        <trans-unit id="61b6cad34a7477f709f8134369511744282bf7b8" translate="yes" xml:space="preserve">
          <source>Felix Kling did a fine job writing an answer for people using jQuery with callbacks for AJAX. I have an answer for native XHR. This answer is for generic usage of promises either on the frontend or backend.</source>
          <target state="translated">Felix Kling hizo un buen trabajo escribiendo una respuesta para la gente que usa jQuery con llamadas para AJAX.Tengo una respuesta para XHR nativo.Esta respuesta es para el uso genérico de promesas ya sea en el frontend o en el backend.</target>
        </trans-unit>
        <trans-unit id="635e0097e3c51f900f56e2ff15075d9128740b8b" translate="yes" xml:space="preserve">
          <source>For each item, a new Promise will fire a block - &lt;code&gt;ExecutionBlock&lt;/code&gt;, parse the result, schedule a new set of promises based on the result array, that is a list of Spotify &lt;code&gt;user&lt;/code&gt; objects and execute the new HTTP call within the &lt;code&gt;ExecutionProfileBlock&lt;/code&gt; asynchronously.</source>
          <target state="translated">Para cada elemento, una nueva Promesa activar&amp;aacute; un bloque: &lt;code&gt;ExecutionBlock&lt;/code&gt; , analizar&amp;aacute; el resultado, programar&amp;aacute; un nuevo conjunto de promesas en funci&amp;oacute;n de la matriz de resultados, que es una lista de objetos de &lt;code&gt;user&lt;/code&gt; de Spotify y ejecutar&amp;aacute; la nueva llamada HTTP dentro del &lt;code&gt;ExecutionProfileBlock&lt;/code&gt; de forma asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="686ea421444c498a952e65a5b7b7b8ef0e77b9a4" translate="yes" xml:space="preserve">
          <source>For example in your case which you are using &lt;strong&gt;jQuery&lt;/strong&gt;, you can do something like this:</source>
          <target state="translated">Por ejemplo, en su caso en el que est&amp;aacute; utilizando &lt;strong&gt;jQuery&lt;/strong&gt; , puede hacer algo como esto:</target>
        </trans-unit>
        <trans-unit id="5e7f2f5c0f405e9a5beea0b22dfdc929a77c6dbf" translate="yes" xml:space="preserve">
          <source>For more details on how this sort of callback design is done, check Felix's answer.</source>
          <target state="translated">Para más detalles sobre cómo se hace este tipo de diseño de devolución de llamada,comprueba la respuesta de Félix.</target>
        </trans-unit>
        <trans-unit id="9ae95c96ff6e523f358968e03ed28b68223e6cc4" translate="yes" xml:space="preserve">
          <source>For more information study about &lt;strong&gt;promises&lt;/strong&gt; and &lt;strong&gt;observables&lt;/strong&gt; which are newer ways to do this async stuffs.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, estudie las &lt;strong&gt;promesas&lt;/strong&gt; y los &lt;strong&gt;observables,&lt;/strong&gt; que son nuevas formas de hacer esto de manera as&amp;iacute;ncrona.</target>
        </trans-unit>
        <trans-unit id="d2c8933d706e47b9253dd050c3950ebb59a4178f" translate="yes" xml:space="preserve">
          <source>For people who are using &lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;, can handle this situation using &lt;code&gt;Promises&lt;/code&gt;.</source>
          <target state="translated">Para las personas que usan &lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt; , pueden manejar esta situaci&amp;oacute;n usando &lt;code&gt;Promises&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9244ed786ac52489080bb2ed73727df2582f9b46" translate="yes" xml:space="preserve">
          <source>Handle asynchronous HTTP calls;</source>
          <target state="translated">Manejar las llamadas HTTP asincrónicas;</target>
        </trans-unit>
        <trans-unit id="93478a618140fa661d81ab91258f1a651409d131" translate="yes" xml:space="preserve">
          <source>Having said that ... why don't do it the easy way?</source>
          <target state="translated">Dicho esto...¿por qué no lo haces de la manera más fácil?</target>
        </trans-unit>
        <trans-unit id="51d1de74537d4867e5318491d300b2040b09329d" translate="yes" xml:space="preserve">
          <source>Here are some approaches to work with asynchronous requests:</source>
          <target state="translated">He aquí algunos enfoques para trabajar con solicitudes asincrónicas:</target>
        </trans-unit>
        <trans-unit id="089375b0e7ad3fd4224f7a969d79cd0949c40a9f" translate="yes" xml:space="preserve">
          <source>Here is a simple analogy</source>
          <target state="translated">Aquí hay una simple analogía</target>
        </trans-unit>
        <trans-unit id="a3e19bd4dc54096f28f69d4061c9289827b6d622" translate="yes" xml:space="preserve">
          <source>Here is a simple analogy for the issue:</source>
          <target state="translated">Aquí hay una simple analogía para el tema:</target>
        </trans-unit>
        <trans-unit id="66783b0ea79ce0b229e6872b71ad5253987aee77" translate="yes" xml:space="preserve">
          <source>Here is a simple example of using a promise:</source>
          <target state="translated">Aquí hay un ejemplo simple de cómo usar una promesa:</target>
        </trans-unit>
        <trans-unit id="3f98c5fe445eb6aa095ee0b24083a641538f5e28" translate="yes" xml:space="preserve">
          <source>Here is an analogy which hopefully makes the difference between synchronous and asynchronous flow clearer:</source>
          <target state="translated">He aquí una analogía que esperamos que haga más clara la diferencia entre el flujo síncrono y el asíncrono:</target>
        </trans-unit>
        <trans-unit id="e18b9e6f0b7383abbecaa82bf04e6ad414de12c8" translate="yes" xml:space="preserve">
          <source>Here is an example of the same:</source>
          <target state="translated">Aquí hay un ejemplo de lo mismo:</target>
        </trans-unit>
        <trans-unit id="bd9e15afe641187b36f9279675ba8535db066ca8" translate="yes" xml:space="preserve">
          <source>Here is an example that builds on top of delay above:</source>
          <target state="translated">He aquí un ejemplo que se suma a la demora anterior:</target>
        </trans-unit>
        <trans-unit id="1197d1f4a9d4cf3b8d6f5178c3cec6d0874a533a" translate="yes" xml:space="preserve">
          <source>Here we defined the function &quot;inline&quot; but you can pass any function reference:</source>
          <target state="translated">Aquí definimos la función &quot;en línea&quot; pero se puede pasar cualquier referencia de función:</target>
        </trans-unit>
        <trans-unit id="164b78f47e3ef1dc3e0cef0b751ea196374fd668" translate="yes" xml:space="preserve">
          <source>Here we passed an anonymous function, but we could just as easily pass a reference to an existing function, making it look like:</source>
          <target state="translated">Aquí pasamos una función anónima,pero también podríamos pasar una referencia a una función existente,haciendo que parezca:</target>
        </trans-unit>
        <trans-unit id="1e64ad5b4497aa10277e2076d4284da48c62d379" translate="yes" xml:space="preserve">
          <source>Here's a working version of your code:</source>
          <target state="translated">Aquí hay una versión de trabajo de su código:</target>
        </trans-unit>
        <trans-unit id="7e3c8edd9d78bba7e3a4b76a43bc5bd629037a8e" translate="yes" xml:space="preserve">
          <source>Hopefully that will make some sense. When you encounter things like this that seem confusing - i highly recommend reading the documentation fully to at least get an understanding of it. It will make you a much better developer.</source>
          <target state="translated">Esperemos que eso tenga algún sentido.Cuando te encuentras con cosas como estas que parecen confusas-recomiendo encarecidamente leer la documentación completamente para al menos entenderla.Te hará un mejor desarrollador.</target>
        </trans-unit>
        <trans-unit id="156541c40984a4a3ee70fd44f32c4e4796080910" translate="yes" xml:space="preserve">
          <source>How do I return the response from an asynchronous call</source>
          <target state="translated">¿Cómo devuelvo la respuesta de una llamada asincrónica</target>
        </trans-unit>
        <trans-unit id="450c3e475d5ba28aa9f650174becd8bb359d1260" translate="yes" xml:space="preserve">
          <source>How do I return the response from an asynchronous call?</source>
          <target state="translated">¿Cómo devuelvo la respuesta de una llamada asincrónica?</target>
        </trans-unit>
        <trans-unit id="89fed459f83d0d8bc59f73a0c70d136088949d94" translate="yes" xml:space="preserve">
          <source>How to make &lt;strong&gt;asynchronous&lt;/strong&gt; code look &lt;strong&gt;synchronous&lt;/strong&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo hacer que el c&amp;oacute;digo &lt;strong&gt;asincr&amp;oacute;nico se&lt;/strong&gt; vea &lt;strong&gt;sincr&amp;oacute;nico&lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="c25df1a995ff1bfc26f40ebfff6e38eed0cf9af3" translate="yes" xml:space="preserve">
          <source>I am using the &lt;code&gt;result&lt;/code&gt; object to store the value during the asynchronous operation. This allows the result be available even after the asynchronous job.</source>
          <target state="translated">Estoy usando el objeto de &lt;code&gt;result&lt;/code&gt; ado para almacenar el valor durante la operaci&amp;oacute;n asincr&amp;oacute;nica. Esto permite que el resultado est&amp;eacute; disponible incluso despu&amp;eacute;s del trabajo asincr&amp;oacute;nico.</target>
        </trans-unit>
        <trans-unit id="3082b7f700f005a0779967fd6b3615c7a09694bd" translate="yes" xml:space="preserve">
          <source>I have a function &lt;code&gt;foo&lt;/code&gt; which makes an Ajax request. How can I return the response from &lt;code&gt;foo&lt;/code&gt;?</source>
          <target state="translated">Tengo una funci&amp;oacute;n &lt;code&gt;foo&lt;/code&gt; que hace una solicitud de Ajax. &amp;iquest;C&amp;oacute;mo puedo devolver la respuesta de &lt;code&gt;foo&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d16b97c7b8f99c277ca18e31f4f0499acffc903b" translate="yes" xml:space="preserve">
          <source>I have extensively discussed this solution &lt;a href=&quot;https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">He discutido ampliamente esta soluci&amp;oacute;n &lt;a href=&quot;https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="871db57e2d8a1b8bb628280aec3e9abeafe80bbf" translate="yes" xml:space="preserve">
          <source>I made a download manager (using ranges on both sides with resume, filereader, filesystem), various image resizers converters using canvas, populate web SQL databases with base64images and much more... But in these cases you should create a function only for that purpose... sometimes you need a blob, array buffers, you can set headers, override mimetype and there is a lot more...</source>
          <target state="translated">Hice un gestor de descargas (usando rangos en ambos lados con curriculum vitae,filereader,sistema de archivos),varios convertidores de redimensionamiento de imágenes usando lienzo,poblar bases de datos web SQL con imágenes base64 y mucho más...Pero en estos casos debes crear una función sólo para ese propósito...a veces necesitas un blob,buffers de matriz,puedes establecer encabezados,anular mimetipos y hay mucho más...</target>
        </trans-unit>
        <trans-unit id="aabb558dc219037662405ce169cc7769e808b314" translate="yes" xml:space="preserve">
          <source>I tried returning the value from the &lt;code&gt;success&lt;/code&gt; callback, as well as assigning the response to a local variable inside the function and returning that one, but none of those ways actually return the response.</source>
          <target state="translated">Intent&amp;eacute; devolver el valor de la devoluci&amp;oacute;n de llamada &lt;code&gt;success&lt;/code&gt; , as&amp;iacute; como asignar la respuesta a una variable local dentro de la funci&amp;oacute;n y devolver esa, pero ninguna de esas formas realmente devuelve la respuesta.</target>
        </trans-unit>
        <trans-unit id="805d9303f1d1e40a739086bcb503bea0dd8a07cd" translate="yes" xml:space="preserve">
          <source>I use this approach a lot. I would be interested to know how well this approach works where wiring the result back through consecutive modules is involved.</source>
          <target state="translated">Uso mucho este enfoque.Me interesaría saber qué tan bien funciona este enfoque cuando se trata de cablear el resultado a través de módulos consecutivos.</target>
        </trans-unit>
        <trans-unit id="96fd1cbea3405a357b87787e1ea700f496799a2f" translate="yes" xml:space="preserve">
          <source>I was using this solution for a while until I figured out there is an error in old browsers:</source>
          <target state="translated">Estuve usando esta solución por un tiempo hasta que descubrí que hay un error en los navegadores antiguos:</target>
        </trans-unit>
        <trans-unit id="404b02c50355c8c0582c7d04c555e4cc95c4e8cb" translate="yes" xml:space="preserve">
          <source>I will answer with a horrible-looking, hand-drawn comic. The second image is the reason why &lt;code&gt;result&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; in your code example.</source>
          <target state="translated">Contestar&amp;eacute; con un c&amp;oacute;mic de aspecto horrible y dibujado a mano. La segunda imagen es la raz&amp;oacute;n por la cual el &lt;code&gt;result&lt;/code&gt; ado &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute; definido en su ejemplo de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="3967fbf9c99e4d431884df5be7bd68f466e20960" translate="yes" xml:space="preserve">
          <source>I would like to give an example for a Ajax request.</source>
          <target state="translated">Me gustaría dar un ejemplo para una petición de Ajax.</target>
        </trans-unit>
        <trans-unit id="e1ef9ad0b4029d883d48f869147c3caa394f24cd" translate="yes" xml:space="preserve">
          <source>I'm using a lot of APIs and one of the first functions I integrate into every HTML page is the first Ajax function in this answer, with GET only...</source>
          <target state="translated">Estoy usando un montón de APIs y una de las primeras funciones que integro en cada página HTML es la primera función Ajax en esta respuesta,con GET solamente...</target>
        </trans-unit>
        <trans-unit id="0a86d08347ddae45aa9f3764c8e9705b92f76fe2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doSomethingAsync&lt;/code&gt; gives you a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Si &lt;code&gt;doSomethingAsync&lt;/code&gt; le da una &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promesa&lt;/a&gt; , puede usar &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="97dfce1b14fd80ba22d599c23dd5f550c7f63ef9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doSomethingAsync&lt;/code&gt; gives you a Promise, if you can use ES2017+ syntax (perhaps with a transpiler like &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;), you can use an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt; function&lt;/a&gt; with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for-of&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Si &lt;code&gt;doSomethingAsync&lt;/code&gt; le da una Promesa, si puede usar la sintaxis ES2017 + (quiz&amp;aacute;s con un transpilador como &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt; ), puede usar una &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;funci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; con &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for-of&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="163754b0a641fcc79050c0cc9adbe06a5d149a2e" translate="yes" xml:space="preserve">
          <source>If the sequence we're producing is a sequence of actions rather than numbers - we can pause the function whenever an action is yielded and wait for it before we resume the function. So instead of a sequence of numbers, we need a sequence of &lt;em&gt;future&lt;/em&gt; values - that is: promises.</source>
          <target state="translated">Si la secuencia que estamos produciendo es una secuencia de acciones en lugar de n&amp;uacute;meros, podemos pausar la funci&amp;oacute;n cada vez que se produce una acci&amp;oacute;n y esperarla antes de reanudar la funci&amp;oacute;n. Entonces, en lugar de una secuencia de n&amp;uacute;meros, necesitamos una secuencia de valores &lt;em&gt;futuros&lt;/em&gt; , es decir, promesas.</target>
        </trans-unit>
        <trans-unit id="afa00a6b4070ffcc7e4d6431383806ca509e451d" translate="yes" xml:space="preserve">
          <source>If underlying function is not promisified</source>
          <target state="translated">Si la función subyacente no se promete</target>
        </trans-unit>
        <trans-unit id="b1be43c2bc654592ef71349407fe409b8835e049" translate="yes" xml:space="preserve">
          <source>If underlying function is promisified</source>
          <target state="translated">Si la función subyacente se promete</target>
        </trans-unit>
        <trans-unit id="a2a2af534201c965a8a5307d8256309bf76d379b" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;have&lt;/em&gt; to do it, you can pass a flag: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request&quot;&gt;Here is how:&lt;/a&gt;</source>
          <target state="translated">Si &lt;em&gt;tiene&lt;/em&gt; que hacerlo, puede pasar una bandera: as&amp;iacute; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request&quot;&gt;es como:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e69ab6f2f9d1e92d40998e6452f1feaaddfbbee5" translate="yes" xml:space="preserve">
          <source>If you can't use ES2017+ syntax (yet), you can use a variation on the &lt;a href=&quot;https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all&quot;&gt;&quot;Promise reduce&quot; pattern&lt;/a&gt; (this is more complex than the usual Promise reduce because we're not passing the result from one into the next, but instead gathering up their results in an array):</source>
          <target state="translated">Si no puede usar la sintaxis ES2017 + (todav&amp;iacute;a), puede usar una variaci&amp;oacute;n en el &lt;a href=&quot;https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all&quot;&gt;patr&amp;oacute;n &quot;&lt;/a&gt; Reducci&amp;oacute;n de promesa&quot; (esto es m&amp;aacute;s complejo que la reducci&amp;oacute;n de Promesa habitual porque no estamos pasando el resultado de uno a otro, sino que en su lugar reuniendo sus resultados en una matriz):</target>
        </trans-unit>
        <trans-unit id="9b961004352fb6c26e593f096a006f3382d2c3af" translate="yes" xml:space="preserve">
          <source>If you directly use a &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/&quot;&gt;&lt;code&gt;XMLHTTPRequest&lt;/code&gt;&lt;/a&gt; object, pass &lt;code&gt;false&lt;/code&gt; as third argument to &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/#the-open%28%29-method&quot;&gt;&lt;code&gt;.open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si usa directamente un objeto &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/&quot;&gt; &lt;code&gt;XMLHTTPRequest&lt;/code&gt; &lt;/a&gt; , pase &lt;code&gt;false&lt;/code&gt; como tercer argumento a &lt;a href=&quot;http://www.w3.org/TR/XMLHttpRequest/#the-open%28%29-method&quot;&gt; &lt;code&gt;.open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="458c0f1aba3bbec14d8c4e49ddecf559a0d3074c" translate="yes" xml:space="preserve">
          <source>If you don't use jQuery and want a nice short XMLHttpRequest 2 which works on the modern browsers and also on the mobile browsers I suggest to use it this way:</source>
          <target state="translated">Si no usas jQuery y quieres un bonito y corto XMLHttpRequest 2 que funciona en los navegadores modernos y también en los navegadores móviles te sugiero que lo uses de esta manera:</target>
        </trans-unit>
        <trans-unit id="55afcac8cc3cf8d87fcc46044f624ddede12707e" translate="yes" xml:space="preserve">
          <source>If you know that &lt;code&gt;doSomethingAsync&lt;/code&gt; will ignore a second and third argument, you can just pass it directly to &lt;code&gt;map&lt;/code&gt; (&lt;code&gt;map&lt;/code&gt; calls its callback with three arguments, but most people only use the first most of the time):</source>
          <target state="translated">Si sabe que &lt;code&gt;doSomethingAsync&lt;/code&gt; ignorar&amp;aacute; un segundo y tercer argumento, puede pasarlo directamente al &lt;code&gt;map&lt;/code&gt; a ( &lt;code&gt;map&lt;/code&gt; llama a su devoluci&amp;oacute;n de llamada con tres argumentos, pero la mayor&amp;iacute;a de las personas solo usan el primero la mayor parte del tiempo):</target>
        </trans-unit>
        <trans-unit id="c790a5aebe01811818eef515dc847f0886c8d6c4" translate="yes" xml:space="preserve">
          <source>If you need to target browsers that don't support ES6 you can run the code through Babel or closure-compiler to generate ECMAScript 5.</source>
          <target state="translated">Si necesitas dirigirte a navegadores que no soportan ES6,puedes ejecutar el código a través de Babel o del compilador de cierre para generar ECMAScript 5.</target>
        </trans-unit>
        <trans-unit id="3630077cc579c9376d3c4c87878034e415200376" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery&lt;/a&gt;, you can set the &lt;code&gt;async&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;. Note that this option is &lt;em&gt;deprecated&lt;/em&gt; since jQuery 1.8.
You can then either still use a &lt;code&gt;success&lt;/code&gt; callback or access the &lt;code&gt;responseText&lt;/code&gt; property of the &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/#jqXHR&quot;&gt;jqXHR object&lt;/a&gt;:</source>
          <target state="translated">Si usa &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery&lt;/a&gt; , puede establecer la opci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; en &lt;code&gt;false&lt;/code&gt; . Tenga en cuenta que esta opci&amp;oacute;n est&amp;aacute; en &lt;em&gt;desuso&lt;/em&gt; desde jQuery 1.8. A continuaci&amp;oacute;n, puede seguir utilizando una devoluci&amp;oacute;n de llamada &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/#jqXHR&quot;&gt;correcta&lt;/a&gt; o acceder a la propiedad &lt;code&gt;responseText&lt;/code&gt; del objeto jqXHR :</target>
        </trans-unit>
        <trans-unit id="15eeba4207bfa4d204303f8eb467ce459a91861c" translate="yes" xml:space="preserve">
          <source>If you use any other jQuery Ajax method, such as &lt;code&gt;$.get&lt;/code&gt;, &lt;code&gt;$.getJSON&lt;/code&gt;, etc., you have to change it to &lt;code&gt;$.ajax&lt;/code&gt; (since you can only pass configuration parameters to &lt;code&gt;$.ajax&lt;/code&gt;).</source>
          <target state="translated">Si usa cualquier otro m&amp;eacute;todo jQuery Ajax, como &lt;code&gt;$.get&lt;/code&gt; , &lt;code&gt;$.getJSON&lt;/code&gt; , etc., debe cambiarlo a &lt;code&gt;$.ajax&lt;/code&gt; (ya que solo puede pasar los par&amp;aacute;metros de configuraci&amp;oacute;n a &lt;code&gt;$.ajax&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c715363204b6b0c4a698fa23da4f0f9dc888e78" translate="yes" xml:space="preserve">
          <source>If you want to EXTEND the function...</source>
          <target state="translated">Si quiere EXTENDER la función...</target>
        </trans-unit>
        <trans-unit id="abe47fc3c57755c3997a845ee0b5aa49beefed3e" translate="yes" xml:space="preserve">
          <source>If you want to block the browser for a while load a nice big &lt;code&gt;.txt&lt;/code&gt; file synchronous.</source>
          <target state="translated">Si desea bloquear el navegador por un tiempo, cargue un gran archivo &lt;code&gt;.txt&lt;/code&gt; sincr&amp;oacute;nico.</target>
        </trans-unit>
        <trans-unit id="4e422421958cc1f0c9d4abcefec9c5f99bb57a7b" translate="yes" xml:space="preserve">
          <source>If you're &lt;em&gt;not&lt;/em&gt; using jQuery in your code, this answer is for you</source>
          <target state="translated">Si no est&amp;aacute; utilizando jQuery en su c&amp;oacute;digo, esta respuesta es para usted</target>
        </trans-unit>
        <trans-unit id="ab8a1b500c194cbfba3513d7de0dea72d3a034e8" translate="yes" xml:space="preserve">
          <source>If you're still having a hard time understanding this &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&quot;&gt;read the AJAX getting started guide&lt;/a&gt; at MDN.</source>
          <target state="translated">Si todav&amp;iacute;a tiene dificultades para entender esto, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&quot;&gt;lea la gu&amp;iacute;a de inicio de AJAX&lt;/a&gt; en MDN.</target>
        </trans-unit>
        <trans-unit id="18f9b9e612918f51948f6cc2126155b3c549bdae" translate="yes" xml:space="preserve">
          <source>If you're using promises, this answer is for you.</source>
          <target state="translated">Si estás usando promesas,esta respuesta es para ti.</target>
        </trans-unit>
        <trans-unit id="80fc972e4356d8ced60d608ce0baaf96427cd4b5" translate="yes" xml:space="preserve">
          <source>Imagine you make a phone call to a friend and ask him to look something up for you. Although it might take a while, you wait on the phone and stare into space, until your friend gives you the answer that you needed.</source>
          <target state="translated">Imagina que llamas a un amigo y le pides que te busque algo.Aunque puede llevar un tiempo,esperas en el teléfono y miras fijamente al espacio,hasta que tu amigo te da la respuesta que necesitabas.</target>
        </trans-unit>
        <trans-unit id="ca8f184ee30d4a232f354261c37cbb9af43a876b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Angular2&lt;/code&gt; with look at the following example, but its &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html&quot;&gt;recommended&lt;/a&gt; to use &lt;code&gt;Observables&lt;/code&gt; with &lt;code&gt;Angular2&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;Angular2&lt;/code&gt; , mire el siguiente ejemplo, pero se &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html&quot;&gt;recomienda&lt;/a&gt; usar &lt;code&gt;Observables&lt;/code&gt; con &lt;code&gt;Angular2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9164c254eac90254b881079ff36f34d077268d4b" translate="yes" xml:space="preserve">
          <source>In ES7, this is further standardized, there are several proposals right now but in all of them you can &lt;code&gt;await&lt;/code&gt; promise. This is just &quot;sugar&quot; (nicer syntax) for the ES6 proposal above by adding the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; keywords. Making the above example:</source>
          <target state="translated">En ES7, esto est&amp;aacute; a&amp;uacute;n m&amp;aacute;s estandarizado, hay varias propuestas en este momento, pero en todas ellas puede &lt;code&gt;await&lt;/code&gt; promesa. Esto es solo &quot;az&amp;uacute;car&quot; (sintaxis m&amp;aacute;s agradable) para la propuesta ES6 anterior al agregar el &lt;code&gt;async&lt;/code&gt; y &lt;code&gt;await&lt;/code&gt; palabras clave. Haciendo el ejemplo anterior:</target>
        </trans-unit>
        <trans-unit id="05677a4350495d3e2b8c6f4b68ebe3c7de4458e1" translate="yes" xml:space="preserve">
          <source>In broad, simplistic terms, the event loop is like the project manager, it is constantly listening for any functions that want to run and communicates between the queue and the stack.</source>
          <target state="translated">En términos amplios y simplistas,el bucle de eventos es como el gestor de proyectos,está constantemente a la escucha de cualquier función que quiera ejecutarse y se comunica entre la cola y la pila.</target>
        </trans-unit>
        <trans-unit id="cd02d6973d3ea865653a48e911c2e50a8c25776e" translate="yes" xml:space="preserve">
          <source>In my Code it is called as</source>
          <target state="translated">En mi Código se llama</target>
        </trans-unit>
        <trans-unit id="5cb5ee146291e3428e4c2fcba91cef4c63579d3d" translate="yes" xml:space="preserve">
          <source>In short, synchronous requests block the execution of code... ...this can cause serious issues...</source>
          <target state="translated">En resumen,las peticiones síncronas bloquean la ejecución del código......esto puede causar serios problemas...</target>
        </trans-unit>
        <trans-unit id="c37241c1d0bfe0ae8498665ddda9cb54f035c670" translate="yes" xml:space="preserve">
          <source>In the above script, you have an error handler which is statically defined so it does not compromise the function. The error handler can be used for other functions too.</source>
          <target state="translated">En el guión anterior,tienes un manejador de errores que está definido estáticamente para que no comprometa la función.El gestor de errores puede utilizarse también para otras funciones.</target>
        </trans-unit>
        <trans-unit id="1fee4a9e013a60a7958cc7ec190286ed94e8f8f3" translate="yes" xml:space="preserve">
          <source>In the case of our milk and coffee, we design &lt;code&gt;order_milk&lt;/code&gt; to return a promise for the milk arriving, then specify &lt;code&gt;put_in_coffee&lt;/code&gt; as a &lt;code&gt;then&lt;/code&gt; action, as follows:</source>
          <target state="translated">En el caso de nuestra leche y caf&amp;eacute;, dise&amp;ntilde;amos &lt;code&gt;order_milk&lt;/code&gt; para devolver una promesa para la llegada de la leche, luego especificamos &lt;code&gt;put_in_coffee&lt;/code&gt; como una acci&amp;oacute;n de &lt;code&gt;then&lt;/code&gt; , de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="a9724168875ccef827ffb62e3e3dac4f3c469e74" translate="yes" xml:space="preserve">
          <source>In the error response, there are no error codes.</source>
          <target state="translated">En la respuesta de error,no hay códigos de error.</target>
        </trans-unit>
        <trans-unit id="1a6a81cb0fe27a1ef73a694660e522eaf40baa80" translate="yes" xml:space="preserve">
          <source>In the example of the question, you can make &lt;code&gt;foo&lt;/code&gt; accept a callback and use it as &lt;code&gt;success&lt;/code&gt; callback. So this</source>
          <target state="translated">En el ejemplo de la pregunta, puede hacer que acepte una devoluci&amp;oacute;n de llamada y usarla como devoluci&amp;oacute;n de llamada &lt;code&gt;success&lt;/code&gt; . As&amp;iacute; que esto</target>
        </trans-unit>
        <trans-unit id="f64c26e8bf33e53e89ffa065ce2af5f6dae03e32" translate="yes" xml:space="preserve">
          <source>In the first case the error is inside the &lt;code&gt;displayAjax()&lt;/code&gt; under &lt;code&gt;this.statusText&lt;/code&gt; as &lt;code&gt;Method not Allowed&lt;/code&gt;.</source>
          <target state="translated">En el primer caso, el error est&amp;aacute; dentro de &lt;code&gt;displayAjax()&lt;/code&gt; en &lt;code&gt;this.statusText&lt;/code&gt; como &lt;code&gt;Method not Allowed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe42b9b5d9a878fe339729448805008fb45dfb5" translate="yes" xml:space="preserve">
          <source>In the following we will look at three different solutions that are all building on top of each other:</source>
          <target state="translated">A continuación veremos tres soluciones diferentes que se construyen una encima de la otra:</target>
        </trans-unit>
        <trans-unit id="ffdebc5331a7e7297d48ecb0f27d85f259e2d630" translate="yes" xml:space="preserve">
          <source>In the second case, it simply works. You have to check at the server side if you passed the right post data.</source>
          <target state="translated">En el segundo caso,simplemente funciona.Tienes que comprobar en el lado del servidor si has pasado los datos del puesto correcto.</target>
        </trans-unit>
        <trans-unit id="0f588f48cb190b6ff210dbc0bc1dc76feaba12bc" translate="yes" xml:space="preserve">
          <source>In this case, we could rewrite the code in the question as:</source>
          <target state="translated">En este caso,podríamos reescribir el código de la pregunta como:</target>
        </trans-unit>
        <trans-unit id="8e5bc1f12b6bd30221b97d821033adfc0819696f" translate="yes" xml:space="preserve">
          <source>In your case, you would be able to write something like</source>
          <target state="translated">En tu caso,serías capaz de escribir algo como</target>
        </trans-unit>
        <trans-unit id="5ae61ff136e6d353245434234270f433244231c2" translate="yes" xml:space="preserve">
          <source>Instead of waiting for the response, the execution continues immediately and the statement after the Ajax call is executed. To get the response eventually, you provide a function to be called once the response was received, a &lt;em&gt;callback&lt;/em&gt; (notice something? &lt;em&gt;call back&lt;/em&gt; ?). Any statement coming after that call is executed before the callback is called.</source>
          <target state="translated">En lugar de esperar la respuesta, la ejecuci&amp;oacute;n contin&amp;uacute;a inmediatamente y la declaraci&amp;oacute;n despu&amp;eacute;s de que se ejecuta la llamada Ajax. Para obtener la respuesta eventualmente, usted proporciona una funci&amp;oacute;n a la que se llamar&amp;aacute; una vez que se recibi&amp;oacute; la respuesta, una &lt;em&gt;devoluci&amp;oacute;n de llamada&lt;/em&gt; (&amp;iquest;nota algo? &amp;iquest; &lt;em&gt;Devolver llamada&lt;/em&gt; ?). Cualquier declaraci&amp;oacute;n posterior a esa llamada se ejecuta antes de que se llame la devoluci&amp;oacute;n de llamada.</target>
        </trans-unit>
        <trans-unit id="5a176ccd898f71da5498417dd981558178ba5429" translate="yes" xml:space="preserve">
          <source>Is a function that returns an &lt;em&gt;iterator&lt;/em&gt; over the sequence &lt;code&gt;1,2,3,3,3,3,....&lt;/code&gt; which can be iterated. While this is interesting on its own and opens room for a lot of possibility there is one particular interesting case.</source>
          <target state="translated">Es una funci&amp;oacute;n que devuelve un &lt;em&gt;iterador&lt;/em&gt; sobre la secuencia &lt;code&gt;1,2,3,3,3,3,....&lt;/code&gt; que se puede iterar. Si bien esto es interesante por s&amp;iacute; solo y abre muchas posibilidades, hay un caso interesante en particular.</target>
        </trans-unit>
        <trans-unit id="3bfc5cd8986cc4b5d384c982f8dbec35078eb9aa" translate="yes" xml:space="preserve">
          <source>It still returns a promise just the same :)</source>
          <target state="translated">De todos modos,sigue siendo una promesa :)</target>
        </trans-unit>
        <trans-unit id="ef1f71df2861c22e656b28c20ac85577923d64df" translate="yes" xml:space="preserve">
          <source>It supported all *modern browsers. And I can confirm as I'm using this approach since XMLHttpRequest 2 exists. I never had any type of problem on all browsers I use.</source>
          <target state="translated">Soportaba todos los *navegadores modernos.Y puedo confirmar que estoy usando este enfoque desde que existe XMLHttpRequest 2.Nunca he tenido ningún tipo de problema en todos los navegadores que uso.</target>
        </trans-unit>
        <trans-unit id="72465754e74ca9abdcff6be99e29d6961cffe62f" translate="yes" xml:space="preserve">
          <source>It uses the new onload (so you don't have to check for readystate &amp;amp;&amp;amp; status)</source>
          <target state="translated">Utiliza la nueva carga (para que no tenga que verificar el estado listo &amp;amp;&amp;amp;)</target>
        </trans-unit>
        <trans-unit id="dc11dae9acba94421bf901ebfd0a99a469f66bba" translate="yes" xml:space="preserve">
          <source>It's a very common issue we face while struggling with the 'mysteries' of JavaScript. Let me try demystifying this mystery today.</source>
          <target state="translated">Es un problema muy común que enfrentamos mientras luchamos con los &quot;misterios&quot; de JavaScript.Déjame intentar desmitificar este misterio hoy.</target>
        </trans-unit>
        <trans-unit id="ad52914796d378e861e608f5f5c6f3f574df3d10" translate="yes" xml:space="preserve">
          <source>It's easier to write code using callbacks than it may seem. After all, JavaScript in the browser is heavily event driven (DOM events). Receiving the Ajax response is nothing else but an event.</source>
          <target state="translated">Es más fácil escribir un código usando devoluciones de llamada de lo que parece.Después de todo,JavaScript en el navegador es fuertemente impulsado por eventos (eventos DOM).Recibir la respuesta de Ajax no es más que un evento.</target>
        </trans-unit>
        <trans-unit id="cdbb5508c06d9ebb504456c083faa19b12343a7a" translate="yes" xml:space="preserve">
          <source>It's shorter than all other functions Listed.</source>
          <target state="translated">Es más corto que todas las demás funciones de la lista.</target>
        </trans-unit>
        <trans-unit id="dfa79b24d359ed76614774ecdc6d3f1f1fedbc1b" translate="yes" xml:space="preserve">
          <source>JavaScript runs in the UI thread of the browser and any long-running process will lock the UI, making it unresponsive. Additionally, there is an upper limit on the execution time for JavaScript and the browser will ask the user whether to continue the execution or not.</source>
          <target state="translated">El JavaScript se ejecuta en el hilo de la UI del navegador y cualquier proceso de larga duración bloqueará la UI,haciéndola insensible.Además,hay un límite superior en el tiempo de ejecución de JavaScript y el navegador preguntará al usuario si debe continuar la ejecución o no.</target>
        </trans-unit>
        <trans-unit id="e2b5e177110c45130bd6de8833741d43ceee63e1" translate="yes" xml:space="preserve">
          <source>Javscript.info callback</source>
          <target state="translated">Javscript.info callback</target>
        </trans-unit>
        <trans-unit id="bbbd4891d7699a852c6406a296c2fcf52f3c3e57" translate="yes" xml:space="preserve">
          <source>Js is a single threaded.</source>
          <target state="translated">La J es un hilo simple.</target>
        </trans-unit>
        <trans-unit id="e54a9bcf7595f53be50f3d461e5136cdeac9c123" translate="yes" xml:space="preserve">
          <source>Keep in mind that promises and deferred objects are just &lt;em&gt;containers&lt;/em&gt; for a future value, they are not the value itself. For example, suppose you had the following:</source>
          <target state="translated">Tenga en cuenta que las promesas y los objetos diferidos son solo &lt;em&gt;contenedores&lt;/em&gt; para un valor futuro, no son el valor en s&amp;iacute;. Por ejemplo, suponga que tiene lo siguiente:</target>
        </trans-unit>
        <trans-unit id="a450dc9bb252815e0a34be6965a19e24021fbb40" translate="yes" xml:space="preserve">
          <source>Let functions accept &lt;em&gt;callbacks&lt;/em&gt;</source>
          <target state="translated">Dejar que las funciones acepten &lt;em&gt;devoluciones de llamada&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5142ad643e1ca5f1c54df798209cf3a4e972be1a" translate="yes" xml:space="preserve">
          <source>Let suppose our serverRequest() function had a return statement in a code, when we get back data from server Web API will push it in queue at the end of queue.
As it get pushed at end in queue we cannot utilise its data as there is no function left in our queue to utilise this data.&lt;strong&gt;Thus it is not possible to return something from Async Call.&lt;/strong&gt;</source>
          <target state="translated">Supongamos que nuestra funci&amp;oacute;n serverRequest () tiene una declaraci&amp;oacute;n de retorno en un c&amp;oacute;digo, cuando recuperamos los datos de la API web del servidor la empujar&amp;aacute; a la cola al final de la cola. A medida que se empuja al final de la cola, no podemos utilizar sus datos, ya que no queda ninguna funci&amp;oacute;n en nuestra cola para utilizar estos datos. &lt;strong&gt;Por lo tanto, no es posible devolver algo de Async Call.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29816c85c3b63dc23d798455274fc320da92a3db" translate="yes" xml:space="preserve">
          <source>Let your function accept a callback. In the example code &lt;code&gt;foo&lt;/code&gt; can be made to accept a callback. We'll be telling our code how to &lt;em&gt;react&lt;/em&gt; when &lt;code&gt;foo&lt;/code&gt; completes.</source>
          <target state="translated">Deje que su funci&amp;oacute;n acepte una devoluci&amp;oacute;n de llamada. En el c&amp;oacute;digo de ejemplo, se puede hacer que &lt;code&gt;foo&lt;/code&gt; acepte una devoluci&amp;oacute;n de llamada. Le diremos a nuestro c&amp;oacute;digo c&amp;oacute;mo &lt;em&gt;reaccionar&lt;/em&gt; cuando se complete &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b907de8cd2ea70a0a07b7b3951542f8bc4bf8bc" translate="yes" xml:space="preserve">
          <source>Let's apply promises to your particular problem. We will wrap our request logic inside a function, which returns a promise:</source>
          <target state="translated">Apliquemos las promesas a su problema particular.Envolveremos nuestra lógica de solicitud dentro de una función,que devuelve una promesa:</target>
        </trans-unit>
        <trans-unit id="d30dd5f759cc5533cfc4d9a5b1b61f8383c8dbb1" translate="yes" xml:space="preserve">
          <source>Let's ask our function for a &lt;strong&gt;PROMISE&lt;/strong&gt;.
Promise is really about what it means : it means that the function guarantees you to provide with any output it gets in future. so let's see it in action for our little problem above :</source>
          <target state="translated">Pidamos a nuestra funci&amp;oacute;n una &lt;strong&gt;PROMESA&lt;/strong&gt; . Promise se trata realmente de lo que significa: significa que la funci&amp;oacute;n le garantiza proporcionar cualquier salida que obtenga en el futuro. as&amp;iacute; que vamos a verlo en acci&amp;oacute;n para nuestro peque&amp;ntilde;o problema anterior:</target>
        </trans-unit>
        <trans-unit id="f03473dc33a9b7108d06e897d4c147d809acee67" translate="yes" xml:space="preserve">
          <source>Let's see how we can solve the above issue with promises. First, let's demonstrate our understanding of promise states from above by using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise&quot;&gt;Promise constructor&lt;/a&gt; for creating a delay function:</source>
          <target state="translated">Veamos c&amp;oacute;mo podemos resolver el problema anterior con promesas. Primero, demostremos nuestra comprensi&amp;oacute;n de los estados de promesa desde arriba usando el &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise&quot;&gt;constructor Promise&lt;/a&gt; para crear una funci&amp;oacute;n de retraso:</target>
        </trans-unit>
        <trans-unit id="097a1fd4f4dd6ae948cf296ebf5e3fed29d827b1" translate="yes" xml:space="preserve">
          <source>Let's start with a simple JavaScript function:</source>
          <target state="translated">Empecemos con una simple función de JavaScript:</target>
        </trans-unit>
        <trans-unit id="012b3ad7e2336b480f233ac7230671a56ff96505" translate="yes" xml:space="preserve">
          <source>Lets first enable JQuery usage, to have &lt;code&gt;$&lt;/code&gt; available as &lt;code&gt;S&lt;/code&gt;:</source>
          <target state="translated">Primero habilitemos el uso de JQuery, para tener &lt;code&gt;$&lt;/code&gt; disponible como &lt;code&gt;S&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3ac2a3b85bfb179de3d5fd9a6d1778a34a10d96e" translate="yes" xml:space="preserve">
          <source>Make the AJAX call synchronous (lets call it SJAX).</source>
          <target state="translated">Haz la llamada AJAX sincronizada (llamémosla SJAX).</target>
        </trans-unit>
        <trans-unit id="4149f095bdea0d897f44292f13870fb2ca675c68" translate="yes" xml:space="preserve">
          <source>More examples here: &lt;a href=&quot;https://github.com/amaksr/nsynjs/tree/master/examples&quot;&gt;https://github.com/amaksr/nsynjs/tree/master/examples&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s ejemplos aqu&amp;iacute;: &lt;a href=&quot;https://github.com/amaksr/nsynjs/tree/master/examples&quot;&gt;https://github.com/amaksr/nsynjs/tree/master/examples&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="416843538915a12d446291b1a92446755e1f2268" translate="yes" xml:space="preserve">
          <source>More information about promises: &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;HTML5 rocks - JavaScript Promises&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s informaci&amp;oacute;n sobre promesas: &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;HTML5 HTML5 - JavaScript Promises&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25f50452665d503e55acf0b8c965da53f9e2eb1f" translate="yes" xml:space="preserve">
          <source>Most of the answers here give useful suggestions for when you have a single async operation, but sometimes, this comes up when you need to do an asynchronous operation for &lt;em&gt;each&lt;/em&gt; entry in an array or other list-like structure. The temptation is to do this:</source>
          <target state="translated">La mayor&amp;iacute;a de las respuestas aqu&amp;iacute; dan sugerencias &amp;uacute;tiles para cuando tiene una sola operaci&amp;oacute;n as&amp;iacute;ncrona, pero a veces, esto surge cuando necesita hacer una operaci&amp;oacute;n asincr&amp;oacute;nica para &lt;em&gt;cada&lt;/em&gt; entrada en una matriz u otra estructura similar a una lista. La tentaci&amp;oacute;n es hacer esto:</target>
        </trans-unit>
        <trans-unit id="7ace0f986a8d32fe40488522b23a55438cb0b782" translate="yes" xml:space="preserve">
          <source>Not recommended: Synchronous &quot;Ajax&quot; calls</source>
          <target state="translated">No se recomienda:Llamadas sincronizadas de &quot;Ajax&quot;.</target>
        </trans-unit>
        <trans-unit id="a3266b1005a3a1afba35c5209761885a8ad47be3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Promise.all&lt;/code&gt; resolves its promise with an array of the results of all of the promises you give it when they are all resolved, or rejects its promise when the &lt;em&gt;first&lt;/em&gt; of the promises you give it rejects.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;Promise.all&lt;/code&gt; resuelve su promesa con una serie de resultados de todas las promesas que le hace cuando se resuelven todas, o rechaza su promesa cuando la &lt;em&gt;primera&lt;/em&gt; de las promesas que le da rechaza.</target>
        </trans-unit>
        <trans-unit id="ce6df39941058908a0b980171b83775c7db609fa" translate="yes" xml:space="preserve">
          <source>Note that the call to &lt;code&gt;foo()&lt;/code&gt; will still return nothing useful. However, the result of the async call will now be stored in &lt;code&gt;result.response&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que la llamada a &lt;code&gt;foo()&lt;/code&gt; a&amp;uacute;n no devolver&amp;aacute; nada &amp;uacute;til. Sin embargo, el resultado de la llamada asincr&amp;oacute;nica ahora se almacenar&amp;aacute; en &lt;code&gt;result.response&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9c2dea7d7e7a3411da1773762e08918f5674124" translate="yes" xml:space="preserve">
          <source>Nothing easier.</source>
          <target state="translated">Nada más fácil.</target>
        </trans-unit>
        <trans-unit id="353e455e2b68dea72cd422384a4b460cd47300c4" translate="yes" xml:space="preserve">
          <source>Notice how we use the &lt;code&gt;index&lt;/code&gt; from &lt;code&gt;forEach&lt;/code&gt; to save the result in &lt;code&gt;results&lt;/code&gt; in the same position as the entry it relates to, even if the results arrive out of order (since async calls don't necessarily complete in the order in which they were started).</source>
          <target state="translated">Observe c&amp;oacute;mo usamos el &lt;code&gt;index&lt;/code&gt; de &lt;code&gt;forEach&lt;/code&gt; para guardar el resultado en &lt;code&gt;results&lt;/code&gt; en la misma posici&amp;oacute;n que la entrada con la que se relaciona, incluso si los resultados llegan fuera de orden (dado que las llamadas as&amp;iacute;ncronas no necesariamente se completan en el orden en que se iniciaron )</target>
        </trans-unit>
        <trans-unit id="929ed6885fc0b5c2a602a91186d7a6db6f5f8584" translate="yes" xml:space="preserve">
          <source>Now if you want something more complex using post and FormData you can easily extend this function:</source>
          <target state="translated">Ahora si quieres algo más complejo usando post y FormData puedes extender fácilmente esta función:</target>
        </trans-unit>
        <trans-unit id="d974961b0a397dae3ab443eb46237547fe41139f" translate="yes" xml:space="preserve">
          <source>Now let us think we pushed two functions in a queue one is for getting a data from server and another utilises that data.We pushed the serverRequest() function in queue first then utiliseData() function. serverRequest function goes in event loop and makes a call to server as we never know how much time it will take to get data from server
so this process is expected to take time and so we busy our event loop thus hanging our page, that's where Web API come into role it take this function from event loop and deals with server making event loop free so that we can execute next function from queue.The next function in queue is utiliseData() which goes in loop but because of no data available it goes waste and execution of next function continues till end of the queue.(This is called Async calling i.e we can do something else till we get data)</source>
          <target state="translated">Ahora pensemos que empujamos dos funciones en una cola,una es para obtener un dato del servidor y otra utiliza ese dato.Empujamos la función serverRequest()en la cola primero y luego utilizamos la funciónData().La función serverRequest va en el bucle de eventos y hace una llamada al servidor,ya que nunca sabemos cuánto tiempo llevará obtener datos del servidor,por lo que se espera que este proceso lleve tiempo,por lo que ocupamos nuestro bucle de eventos,colgando así nuestra página,ahí es donde entra en juego la API Web,que toma esta función del bucle de eventos y se ocupa de que el servidor haga el bucle de eventos libre para que podamos ejecutar la siguiente función de la cola.La siguiente función de la cola es utiliseData()que entra en el bucle pero al no haber datos disponibles se desperdicia y la ejecución de la siguiente función continúa hasta el final de la cola.(Esto se llama llamada Async calling es decir que podemos hacer otra cosa hasta que obtengamos datos)</target>
        </trans-unit>
        <trans-unit id="e0a63d4292a004be42ee890cb652815050847bb1" translate="yes" xml:space="preserve">
          <source>Now let's add a bit of twist, by introducing little delay in our function, so that all lines of code are not 'finished' in sequence. Thus, it will emulate the asynchronous behavior of function :</source>
          <target state="translated">Ahora vamos a añadir un poco de giro,introduciendo un pequeño retraso en nuestra función,para que todas las líneas de código no se &quot;terminen&quot; en secuencia.De esta manera,emulará el comportamiento asíncrono de la función:</target>
        </trans-unit>
        <trans-unit id="42c38f982e0c169feb7e086aabc21246bff1aad8" translate="yes" xml:space="preserve">
          <source>Now some people will probably say that it's better to use onreadystatechange or the even the XMLHttpRequest variable name. That's wrong.</source>
          <target state="translated">Ahora algunas personas probablemente dirán que es mejor usar onreadystatechange o incluso el nombre de la variable XMLHttpRequest.Eso está mal.</target>
        </trans-unit>
        <trans-unit id="a2fab3eea51d1e71a6c436e1f5c97b56ccdd5071" translate="yes" xml:space="preserve">
          <source>Now you can do</source>
          <target state="translated">Ahora puedes hacer</target>
        </trans-unit>
        <trans-unit id="da89b3c0dfa9111f27c794ec1b03edd3bdfde2dd" translate="yes" xml:space="preserve">
          <source>Now, after we converted setTimeout to use promises, we can use &lt;code&gt;then&lt;/code&gt; to make it count:</source>
          <target state="translated">Ahora, despu&amp;eacute;s de convertir setTimeout para usar promesas, podemos usarlo para que cuente:</target>
        </trans-unit>
        <trans-unit id="8914db3fb9a1d0494f5a0d8fd668ced73c34d069" translate="yes" xml:space="preserve">
          <source>Now, let's define foo itself to act accordingly</source>
          <target state="translated">Ahora,vamos a definir el propio Foo para actuar en consecuencia</target>
        </trans-unit>
        <trans-unit id="99be19d54cf7652a1615ab27cbc8bbf0aed5749c" translate="yes" xml:space="preserve">
          <source>Nsynjs will evaluate all operators and expressions step-by-step, pausing execution in case if result of some slow function is not ready.</source>
          <target state="translated">Nsynjs evaluará todos los operadores y expresiones paso a paso,deteniendo la ejecución en caso de que el resultado de alguna función lenta no esté listo.</target>
        </trans-unit>
        <trans-unit id="5a64163c890c0896f46f25e78ce25b037738ed57" translate="yes" xml:space="preserve">
          <source>Of course there are many approaches like synchronous request, promise, but from my experience I think you should use the callback approach. It's natural to asynchronous behavior of Javascript.
So, your code snippet can be rewrite a little different:</source>
          <target state="translated">Por supuesto que hay muchos enfoques como la solicitud sincrónica,promesa,pero desde mi experiencia creo que deberías usar el enfoque de devolución de llamada.Es natural para el comportamiento asincrónico de Javascript.Así que,tu fragmento de código puede ser reescrito un poco diferente:</target>
        </trans-unit>
        <trans-unit id="2e78929c9a21094861197c3ba952c175f274cc77" translate="yes" xml:space="preserve">
          <source>Once it receives a message to run something it adds it to the queue. The queue is the list of things that are waiting to execute (like your AJAX request). imagine it like this:</source>
          <target state="translated">Una vez que recibe un mensaje para ejecutar algo,lo añade a la cola.La cola es la lista de cosas que están esperando ser ejecutadas (como tu petición AJAX).Imagínatelo así:</target>
        </trans-unit>
        <trans-unit id="9d39748eb9ce2dc97c87c582527e55724204f745" translate="yes" xml:space="preserve">
          <source>One advantage of this is that we can string these together to create sequences of future occurrences (&quot;chaining&quot;):</source>
          <target state="translated">Una ventaja de esto es que podemos encadenarlas para crear secuencias de sucesos futuros (&quot;encadenamiento&quot;):</target>
        </trans-unit>
        <trans-unit id="54016dfcceb363844e7cc4be09ec8ae272d45106" translate="yes" xml:space="preserve">
          <source>One possible solution to this problem is to code &lt;em&gt;re-actively&lt;/em&gt; , telling your program what to do when the calculation completed.</source>
          <target state="translated">Una posible soluci&amp;oacute;n a este problema es codificar de forma &lt;em&gt;reactiva&lt;/em&gt; , dici&amp;eacute;ndole a su programa qu&amp;eacute; hacer cuando se complete el c&amp;aacute;lculo.</target>
        </trans-unit>
        <trans-unit id="6a68116dc884c578869074c6236313ddd089faa1" translate="yes" xml:space="preserve">
          <source>One possible solution to this problem is to code &lt;em&gt;re-actively&lt;/em&gt; , telling your program what to do when the calculation completed. Promises actively enable this by being temporal (time-sensitive) in nature.</source>
          <target state="translated">Una posible soluci&amp;oacute;n a este problema es codificar de forma &lt;em&gt;reactiva&lt;/em&gt; , dici&amp;eacute;ndole a su programa qu&amp;eacute; hacer cuando se complete el c&amp;aacute;lculo. Las promesas permiten esto activamente al ser de naturaleza temporal (sensible al tiempo).</target>
        </trans-unit>
        <trans-unit id="e3fe8189fb8e3a9175a9246ff74a29655859c5dc" translate="yes" xml:space="preserve">
          <source>Only if you have a page where you load always the same XML/JSON or whatever you need only one function. In that case, modify a little the Ajax function and replace b with your special function.</source>
          <target state="translated">Sólo si tienes una página en la que cargas siempre el mismo XMLJSON o lo que sea,sólo necesitas una función.En ese caso,modifica un poco la función de Ajax y reemplaza b con tu función especial.</target>
        </trans-unit>
        <trans-unit id="5266da9d163f68f6d914c71fc5ace6c79a2e3aaa" translate="yes" xml:space="preserve">
          <source>Or (the above one is better anonymous functions are always a problem):</source>
          <target state="translated">O (lo anterior es mejor las funciones anónimas son siempre un problema):</target>
        </trans-unit>
        <trans-unit id="7574e85e254349a76f9eb280b8d26c2fcd432db0" translate="yes" xml:space="preserve">
          <source>Or here's a version returning a &lt;code&gt;Promise&lt;/code&gt; instead:</source>
          <target state="translated">O aqu&amp;iacute; hay una versi&amp;oacute;n que devuelve una &lt;code&gt;Promise&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="912172dfb14be8eb490ece32e4e426ffa381d626" translate="yes" xml:space="preserve">
          <source>Or if for some reason you &lt;code&gt;bind()&lt;/code&gt; the callback to a class:</source>
          <target state="translated">O si por alguna raz&amp;oacute;n &lt;code&gt;bind()&lt;/code&gt; la devoluci&amp;oacute;n de llamada a una clase:</target>
        </trans-unit>
        <trans-unit id="97548c9db4d27ac2b95bbc49510f16af46cc2fde" translate="yes" xml:space="preserve">
          <source>Or pass a full form element (&lt;code&gt;document.getElementsByTagName('form')[0]&lt;/code&gt;):</source>
          <target state="translated">O pase un elemento de formulario completo ( &lt;code&gt;document.getElementsByTagName('form')[0]&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="e22be26c55a52d473b9811210f17414624c87259" translate="yes" xml:space="preserve">
          <source>Or set some custom values:</source>
          <target state="translated">O establecer algunos valores personalizados:</target>
        </trans-unit>
        <trans-unit id="68f819f1f89dc9e0529ac2892b6d2f288badbd02" translate="yes" xml:space="preserve">
          <source>Or the Promise syntax</source>
          <target state="translated">O la sintaxis de la Promesa</target>
        </trans-unit>
        <trans-unit id="afc129571bf06499cb7e3b0ffe14106bdb906a2f" translate="yes" xml:space="preserve">
          <source>Parallel</source>
          <target state="translated">Parallel</target>
        </trans-unit>
        <trans-unit id="3768a1e6d49da0cac1c978e4121bcf5a453c81eb" translate="yes" xml:space="preserve">
          <source>Possible solutions</source>
          <target state="translated">Posibles soluciones</target>
        </trans-unit>
        <trans-unit id="7bb1c6338f84ef633dbff9dc2ca5d6404721463d" translate="yes" xml:space="preserve">
          <source>Promises are containers for &lt;em&gt;future&lt;/em&gt; values. When the promise receives the value (it is &lt;em&gt;resolved&lt;/em&gt;) or when it is canceled (&lt;em&gt;rejected&lt;/em&gt;), it notifies all of its &quot;listeners&quot; who want to access this value.</source>
          <target state="translated">Las promesas son contenedores para valores &lt;em&gt;futuros&lt;/em&gt; . Cuando la promesa recibe el valor (se &lt;em&gt;resuelve&lt;/em&gt; ) o cuando se cancela ( &lt;em&gt;rechaza&lt;/em&gt; ), notifica a todos sus &quot;oyentes&quot; que desean acceder a este valor.</target>
        </trans-unit>
        <trans-unit id="8350b08167777968ab876b41274f64fe1318e1bf" translate="yes" xml:space="preserve">
          <source>Promises can be used to unnest asynchronous functions and allows one to chain multiple functions together.</source>
          <target state="translated">Promesas puede utilizarse para anidar funciones asincrónicas y permite encadenar múltiples funciones.</target>
        </trans-unit>
        <trans-unit id="c32135d34ac0c0221572109c3dfc7f43a9751b94" translate="yes" xml:space="preserve">
          <source>Quick recap on promises</source>
          <target state="translated">Recapitulación rápida de las promesas</target>
        </trans-unit>
        <trans-unit id="c235eb24c95a5e9981695eb449944a162b57ebf2" translate="yes" xml:space="preserve">
          <source>Rather than throwing code at you, there are 2 concepts that are key to understanding how JS handles callbacks and asynchronicity. (is that even a word?)</source>
          <target state="translated">En lugar de lanzarte código,hay 2 conceptos que son clave para entender cómo JS maneja las devoluciones de llamada y la asincronicidad.(¿eso es siquiera una palabra?)</target>
        </trans-unit>
        <trans-unit id="29bff7173029217e94f4afcceb94f3ce6f4a8162" translate="yes" xml:space="preserve">
          <source>Restructure your code to work properly with callbacks.</source>
          <target state="translated">Reestructura tu código para que funcione correctamente con las devoluciones de llamada.</target>
        </trans-unit>
        <trans-unit id="062f9fe8caa07becb814606e66f0cdd8c44eccb5" translate="yes" xml:space="preserve">
          <source>Return a Promise</source>
          <target state="translated">Devolver una promesa</target>
        </trans-unit>
        <trans-unit id="da07fe527d40396d3dc18ff2bbee2077e9679bf6" translate="yes" xml:space="preserve">
          <source>Returning anything in the submit handler will not do anything. You must instead either hand off the data, or do what you want with it directly inside the success function.</source>
          <target state="translated">Devolver cualquier cosa en el controlador de envío no hará nada.En su lugar debes entregar los datos,o hacer lo que quieras con ellos directamente dentro de la función de éxito.</target>
        </trans-unit>
        <trans-unit id="be64c83fb64f3829b56366e909fbacc0081629bd" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html&quot;&gt;original&lt;/a&gt; post here. But Typescript does not support &lt;a href=&quot;http://www.datchley.name/es6-promises/&quot;&gt;native es6 Promises&lt;/a&gt;, if you want to use it, you might need plugin for that.</source>
          <target state="translated">Vea la publicaci&amp;oacute;n &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html&quot;&gt;original&lt;/a&gt; aqu&amp;iacute;. Pero Typescript no es compatible con &lt;a href=&quot;http://www.datchley.name/es6-promises/&quot;&gt;las promesas nativas de es6&lt;/a&gt; , si desea usarlo, es posible que necesite un complemento para eso.</target>
        </trans-unit>
        <trans-unit id="40c20d94e78fa142819df8cc9440d30e65329975" translate="yes" xml:space="preserve">
          <source>Series</source>
          <target state="translated">Series</target>
        </trans-unit>
        <trans-unit id="7e56c5c8aa16c1ef6db37ada8a6266e68cceb09e" translate="yes" xml:space="preserve">
          <source>Several solutions have been given in this thread. Perhaps the easiest way is to pass an object to the &lt;code&gt;foo()&lt;/code&gt; method, and to store the results in a member of that object after the async call completes.</source>
          <target state="translated">Se han dado varias soluciones en este hilo. Quiz&amp;aacute;s la forma m&amp;aacute;s f&amp;aacute;cil es pasar un objeto al m&amp;eacute;todo &lt;code&gt;foo()&lt;/code&gt; y almacenar los resultados en un miembro de ese objeto despu&amp;eacute;s de que se complete la llamada asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="2148a375d3f6b7a16b65d3a1f82733a29815e073" translate="yes" xml:space="preserve">
          <source>Short answer is, &lt;strong&gt;you have to implement a callback like this:&lt;/strong&gt;</source>
          <target state="translated">La respuesta corta es &lt;strong&gt;que debe implementar una devoluci&amp;oacute;n de llamada como esta:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Mostrar fragmento de código</target>
        </trans-unit>
        <trans-unit id="ff1c87cac36b81c6f91891fbd54132c4334c4e46" translate="yes" xml:space="preserve">
          <source>Side note: Promise gotchas</source>
          <target state="translated">Nota al margen:La promesa se consiguió</target>
        </trans-unit>
        <trans-unit id="05506c4ac3acb4d27c65c550acf4b39c197cd038" translate="yes" xml:space="preserve">
          <source>Side note: jQuery's deferred objects</source>
          <target state="translated">Nota al margen:los objetos diferidos de jQuery</target>
        </trans-unit>
        <trans-unit id="fa5759978602e0fa347526198e20ed43cc048568" translate="yes" xml:space="preserve">
          <source>Simple usage example:</source>
          <target state="translated">Ejemplo de uso simple:</target>
        </trans-unit>
        <trans-unit id="4096759186b4f9723934ec713d75bc04761b5820" translate="yes" xml:space="preserve">
          <source>Since the operation did not happen yet (AJAX, server call, IO, timer) you're returning the value before the request got the chance to tell your code what that value is.</source>
          <target state="translated">Como la operación aún no se ha realizado (AJAX,llamada a un servidor,IO,temporizador)estás devolviendo el valor antes de que la petición tenga la oportunidad de decir a tu código cuál es ese valor.</target>
        </trans-unit>
        <trans-unit id="5a7e4ac52f20fc5994d25a70f507d562ec34a41e" translate="yes" xml:space="preserve">
          <source>So anything that foobarFunc needs to execute (in our case &lt;code&gt;anotherFunction&lt;/code&gt;) will get pushed onto the stack. executed, and then forgotten about - the event loop will then move onto the next thing in the queue (or listen for messages)</source>
          <target state="translated">Entonces, cualquier cosa que foobarFunc necesite ejecutar (en nuestro caso, otra &lt;code&gt;anotherFunction&lt;/code&gt; ) ser&amp;aacute; empujada a la pila. ejecutado y luego olvidado: el bucle de eventos pasar&amp;aacute; al siguiente elemento de la cola (o escuchar&amp;aacute; mensajes)</target>
        </trans-unit>
        <trans-unit id="4130aa961d9f8a1abff39f8f3f11e49af247d9a2" translate="yes" xml:space="preserve">
          <source>So i decided to implement my own Promise class for &lt;strong&gt;ES3 to below&lt;/strong&gt; js compilers if its not defined. Just add this code before your main code and then safely use Promise!</source>
          <target state="translated">As&amp;iacute; que decid&amp;iacute; implementar mi propia clase Promise para &lt;strong&gt;ES3 a los&lt;/strong&gt; compiladores js &lt;strong&gt;a continuaci&amp;oacute;n&lt;/strong&gt; si no est&amp;aacute; definido. Simplemente agregue este c&amp;oacute;digo antes de su c&amp;oacute;digo principal y luego use Promise de forma segura.</target>
        </trans-unit>
        <trans-unit id="519e6b95ba34166e61a9a33a9c6412ef034c0b19" translate="yes" xml:space="preserve">
          <source>So if you are using &lt;strong&gt;Angular, React&lt;/strong&gt; or any other frameworks which do &lt;strong&gt;two ways data binding&lt;/strong&gt; or &lt;strong&gt;store concept&lt;/strong&gt; this issue is simply fixed for you, so in easy word, your result is &lt;code&gt;undefined&lt;/code&gt; at the first stage, so you have got &lt;code&gt;result = undefined&lt;/code&gt; before you receive the data, then as soon as you get the result, it will be updated and get assigned to the new value which response of your Ajax call...</source>
          <target state="translated">Entonces, si est&amp;aacute; utilizando &lt;strong&gt;Angular, React&lt;/strong&gt; o cualquier otro marco que haga &lt;strong&gt;dos formas de vincular datos&lt;/strong&gt; o &lt;strong&gt;almacenar el concepto,&lt;/strong&gt; este problema simplemente se soluciona para usted, por lo que, en palabras simples, su resultado &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute; definido en la primera etapa, por lo que tiene &lt;code&gt;result = undefined&lt;/code&gt; antes de recibir los datos, tan pronto como obtenga el resultado, se actualizar&amp;aacute; y se asignar&amp;aacute; al nuevo valor que responde a su llamada Ajax ...</target>
        </trans-unit>
        <trans-unit id="456834897466e279954c59b225ffcd0a611dc23f" translate="yes" xml:space="preserve">
          <source>So there you go, that delay just broke the functionality we expected! But what exactly happened ? Well, it's actually pretty logical if you look at the code. the function &lt;code&gt;foo()&lt;/code&gt;, upon execution, returns nothing (thus returned value is &lt;code&gt;undefined&lt;/code&gt;), but it does start a timer, which executes a function after 1s to return 'wohoo'. But as you can see, the value that's assigned to bar is the immediately returned stuff from foo(), which is nothing i.e. just &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&amp;iexcl;Ah&amp;iacute; tienes, ese retraso acaba de romper la funcionalidad que esper&amp;aacute;bamos! &amp;iquest;Pero qu&amp;eacute; pas&amp;oacute; exactamente? Bueno, en realidad es bastante l&amp;oacute;gico si nos fijamos en el c&amp;oacute;digo. la funci&amp;oacute;n &lt;code&gt;foo()&lt;/code&gt; , al ejecutarse, no devuelve nada (por lo tanto, el valor devuelto &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute; definido ), pero s&amp;iacute; inicia un temporizador, que ejecuta una funci&amp;oacute;n despu&amp;eacute;s de 1s para devolver 'wohoo'. Pero como puede ver, el valor que se asigna a la barra es el material devuelto inmediatamente por foo (), que no es nada, es decir, no est&amp;aacute; &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ebd3c140905d6a71bb22361b04f8129d104582a" translate="yes" xml:space="preserve">
          <source>So this works just as well. We've learned we can't return values from already asynchronous calls but we can use promises and chain them to perform processing. We now know how to return the response from an asynchronous call.</source>
          <target state="translated">Así que esto funciona igual de bien.Hemos aprendido que no podemos devolver valores de llamadas ya asincrónicas pero podemos usar promesas y encadenarlas para realizar el procesamiento.Ahora sabemos cómo devolver la respuesta de una llamada asíncrona.</target>
        </trans-unit>
        <trans-unit id="16474dcce86aac08469b81e9bbfe841fd4c01c7d" translate="yes" xml:space="preserve">
          <source>So what you need to do is pass a function that is promised to execute at some point with data that is passed to it.</source>
          <target state="translated">Así que lo que necesitas hacer es pasar una función que se promete ejecutar en algún momento con los datos que se le pasan.</target>
        </trans-unit>
        <trans-unit id="0efce20ff147121d241f07ae7346392a017a7c29" translate="yes" xml:space="preserve">
          <source>So, if you have an array (or list of some kind) and want to do async operations for each entry, you have two options: Do the operations in parallel (overlapping), or in series (one after another in sequence).</source>
          <target state="translated">Por lo tanto,si tienes una matriz (o lista de algún tipo)y quieres hacer operaciones de sincronización para cada entrada,tienes dos opciones:Hacer las operaciones en paralelo (superpuestas),o en serie (una tras otra en secuencia).</target>
        </trans-unit>
        <trans-unit id="4549b38f6f564b62d621d5aaa8f137985559a5b5" translate="yes" xml:space="preserve">
          <source>So, you to run the following example you need to put your access token in the request headers:</source>
          <target state="translated">Así que,para ejecutar el siguiente ejemplo necesitas poner tu token de acceso en los encabezados de las solicitudes:</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="b9a422a9be9b2bc191da989656816034a1f6eee5" translate="yes" xml:space="preserve">
          <source>So: No need for error checks if you're able to copy and paste the URL properly. ;)</source>
          <target state="translated">Así que..:No hay necesidad de comprobar los errores si eres capaz de copiar y pegar la URL correctamente.;)</target>
        </trans-unit>
        <trans-unit id="958cd629e68ed77d9824bb75c9b43a7f1cf49e0a" translate="yes" xml:space="preserve">
          <source>Solution(s)</source>
          <target state="translated">Solution(s)</target>
        </trans-unit>
        <trans-unit id="9dbffa1e0ccfddb501d678c507c62423968b4d1e" translate="yes" xml:space="preserve">
          <source>Step 1. Wrap function with callback into nsynjs-aware wrapper (if it has promisified version, you can skip this step):</source>
          <target state="translated">Paso 1.Envuelva la función con la llamada en el envoltorio de nsynjs-aware (si tiene la versión prometida,puede saltarse este paso):</target>
        </trans-unit>
        <trans-unit id="fcdabda0acdbf7ed77f27dcb6841a85fbda15814" translate="yes" xml:space="preserve">
          <source>Step 2. Put synchronous logic into function:</source>
          <target state="translated">Paso 2.Poner en funcionamiento la lógica sincrónica:</target>
        </trans-unit>
        <trans-unit id="80eb86c9950baf665d77b6ad1ffb913a4fa504e2" translate="yes" xml:space="preserve">
          <source>Step 3. Run function in synchronous manner via nsynjs:</source>
          <target state="translated">Paso 3.Ejecutar la función de forma sincrónica a través de nsynjs:</target>
        </trans-unit>
        <trans-unit id="e79e3d8d02a013d89691c298f6bd299451c74b8a" translate="yes" xml:space="preserve">
          <source>Suppose you don't want the operations to be in parallel? If you want to run them one after another, you need to wait for each operation to complete before you start the next. Here's an example of a function that does that and calls a callback with the result:</source>
          <target state="translated">Suponga que no quiere que las operaciones sean paralelas.Si quieres ejecutarlas una tras otra,debes esperar a que cada operación se complete antes de empezar la siguiente.Aquí hay un ejemplo de una función que hace eso y llama a una llamada con el resultado:</target>
        </trans-unit>
        <trans-unit id="77c61919f7c0335c38d9155372ee85055a736cc1" translate="yes" xml:space="preserve">
          <source>Synchronous</source>
          <target state="translated">Synchronous</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">Eso es:</target>
        </trans-unit>
        <trans-unit id="9111ae84fd392e9454be6a96907483945425e257" translate="yes" xml:space="preserve">
          <source>That's a simple synchronous function call (where each line of code is 'finished with its job' before the next one in sequence), and the result is same as expected.</source>
          <target state="translated">Es una simple llamada de función sincrónica (donde cada línea de código &quot;termina su trabajo&quot; antes de la siguiente en secuencia),y el resultado es el mismo que se esperaba.</target>
        </trans-unit>
        <trans-unit id="6dadcf5d4da4a50438dd8a46454bbf9f5c8a3d23" translate="yes" xml:space="preserve">
          <source>That's exactly what's happening when you do an Ajax request.</source>
          <target state="translated">Eso es exactamente lo que pasa cuando haces una petición de Ajax.</target>
        </trans-unit>
        <trans-unit id="c7cfbaca7087cb7a7879162ad5a4e04b1f217824" translate="yes" xml:space="preserve">
          <source>That's why with asynchronous functionality we use things called &lt;strong&gt;callbacks&lt;/strong&gt;. It's kinda like a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;promise&lt;/a&gt; quite literally. As in I &lt;em&gt;promise to return something at some point&lt;/em&gt; jQuery uses specific callbacks called &lt;code&gt;deffered.done&lt;/code&gt;&lt;code&gt;deffered.fail&lt;/code&gt; and &lt;code&gt;deffered.always&lt;/code&gt; (amongst others). You can see them all &lt;a href=&quot;https://api.jquery.com/category/deferred-object/&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">Es por eso que con la funcionalidad asincr&amp;oacute;nica usamos cosas llamadas &lt;strong&gt;devoluciones de llamada&lt;/strong&gt; . Es como una &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;promesa&lt;/a&gt; literalmente. Como en &lt;em&gt;Prometo devolver algo en alg&amp;uacute;n momento,&lt;/em&gt; jQuery utiliza devoluciones de llamada espec&amp;iacute;ficas llamadas &lt;code&gt;deffered.done&lt;/code&gt; &lt;code&gt;deffered.fail&lt;/code&gt; y &lt;code&gt;deffered.always&lt;/code&gt; (entre otros). Puedes verlos todos &lt;a href=&quot;https://api.jquery.com/category/deferred-object/&quot;&gt;aqu&amp;iacute;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15bb754ff5cde7f28dcd0bb70e024c67cb821f55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise API&lt;/a&gt; is a new feature of ECMAScript 6 (ES2015), but it has good &lt;a href=&quot;http://caniuse.com/#feat=promises&quot;&gt;browser support&lt;/a&gt; already. There are also many libraries which implement the standard Promises API and provide additional methods to ease the use and composition of asynchronous functions (e.g. &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;bluebird&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise API&lt;/a&gt; es una nueva caracter&amp;iacute;stica de ECMAScript 6 (ES2015), pero ya tiene un buen &lt;a href=&quot;http://caniuse.com/#feat=promises&quot;&gt;soporte de navegador&lt;/a&gt; . Tambi&amp;eacute;n hay muchas bibliotecas que implementan la API Promises est&amp;aacute;ndar y proporcionan m&amp;eacute;todos adicionales para facilitar el uso y la composici&amp;oacute;n de funciones asincr&amp;oacute;nicas (por ejemplo, &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;bluebird&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8863ecce1e4cf6263ca3b1bcde858dda65b7c8db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; keyword</source>
          <target state="translated">La palabra clave &lt;code&gt;async&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb35c6a9a9151152e061add9aab9caeda5223463" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;A&lt;/strong&gt; in &lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;Ajax&lt;/a&gt; stands for &lt;a href=&quot;https://www.merriam-webster.com/dictionary/asynchronous&quot;&gt;&lt;strong&gt;asynchronous&lt;/strong&gt;&lt;/a&gt; . That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, &lt;code&gt;$.ajax&lt;/code&gt; returns immediately and the next statement, &lt;code&gt;return result;&lt;/code&gt;, is executed before the function you passed as &lt;code&gt;success&lt;/code&gt; callback was even called.</source>
          <target state="translated">La &lt;strong&gt;A&lt;/strong&gt; en &lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;Ajax&lt;/a&gt; significa &lt;a href=&quot;https://www.merriam-webster.com/dictionary/asynchronous&quot;&gt;&lt;strong&gt;as&amp;iacute;ncrono&lt;/strong&gt;&lt;/a&gt; . Eso significa que enviar la solicitud (o m&amp;aacute;s bien recibir la respuesta) se elimina del flujo de ejecuci&amp;oacute;n normal. En su ejemplo, &lt;code&gt;$.ajax&lt;/code&gt; regresa inmediatamente y la siguiente declaraci&amp;oacute;n, &lt;code&gt;return result;&lt;/code&gt; , se ejecuta antes de que se llamara a la funci&amp;oacute;n que pas&amp;oacute; como devoluci&amp;oacute;n de llamada de &lt;code&gt;success&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd66ac85793821d3ff7fcc5fd0246ae36ee7397a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;A&lt;/strong&gt; in AJAX stands for &lt;strong&gt;asynchronous&lt;/strong&gt;. That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29&quot;&gt;&lt;code&gt;.send&lt;/code&gt;&lt;/a&gt; returns immediately and the next statement, &lt;code&gt;return result;&lt;/code&gt;, is executed before the function you passed as &lt;code&gt;success&lt;/code&gt; callback was even called.</source>
          <target state="translated">La &lt;strong&gt;A&lt;/strong&gt; en AJAX significa &lt;strong&gt;as&amp;iacute;ncrono&lt;/strong&gt; . Eso significa que enviar la solicitud (o m&amp;aacute;s bien recibir la respuesta) se elimina del flujo de ejecuci&amp;oacute;n normal. En su ejemplo, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29&quot;&gt; &lt;code&gt;.send&lt;/code&gt; &lt;/a&gt; devuelve inmediatamente y la siguiente instrucci&amp;oacute;n, &lt;code&gt;return result;&lt;/code&gt; , se ejecuta antes de que se llamara a la funci&amp;oacute;n que pas&amp;oacute; como devoluci&amp;oacute;n de llamada de &lt;code&gt;success&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16490f52af9e1a9f1fc6768f3e186d1abc950e53" translate="yes" xml:space="preserve">
          <source>The ECMAScript version released in 2017 introduced &lt;em&gt;syntax-level support&lt;/em&gt; for asynchronous functions. With the help of &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;, you can write asynchronous in a &quot;synchronous style&quot;. The code is still asynchronous, but it's easier to read/understand.</source>
          <target state="translated">La versi&amp;oacute;n ECMAScript lanzada en 2017 introdujo &lt;em&gt;soporte de nivel de sintaxis&lt;/em&gt; para funciones asincr&amp;oacute;nicas. Con la ayuda de &lt;code&gt;async&lt;/code&gt; y &lt;code&gt;await&lt;/code&gt; , puede escribir asincr&amp;oacute;nico en un &quot;estilo sincr&amp;oacute;nico&quot;. El c&amp;oacute;digo sigue siendo as&amp;iacute;ncrono, pero es m&amp;aacute;s f&amp;aacute;cil de leer / comprender.</target>
        </trans-unit>
        <trans-unit id="ecce31767a1b5e77be58da7962c0d01b010e4473" translate="yes" xml:space="preserve">
          <source>The JavaScript concurrency model in the browser and on the server with NodeJS/io.js is &lt;em&gt;asynchronous&lt;/em&gt; and &lt;em&gt;reactive&lt;/em&gt;.</source>
          <target state="translated">El modelo de concurrencia de JavaScript en el navegador y en el servidor con NodeJS / io.js es &lt;em&gt;as&amp;iacute;ncrono&lt;/em&gt; y &lt;em&gt;reactivo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ca67c883bbbb71564bf5ac5f9cf7f2adffad99d0" translate="yes" xml:space="preserve">
          <source>The advantage over plain callbacks is that they allow you to decouple your code and they are easier to compose.</source>
          <target state="translated">La ventaja sobre las llamadas simples es que permiten desacoplar el código y son más fáciles de componer.</target>
        </trans-unit>
        <trans-unit id="480a14931d5a0da5ce02043bf95ba5bba1ea1b46" translate="yes" xml:space="preserve">
          <source>The big question is when will it get the response? The answer is we don't know - so the event loop is waiting for that message to say &quot;hey run me&quot;. If JS just waited around for that message synchronously your app would freeze and it will suck. So JS carries on executing the next item in the queue whilst waiting for the message to get added back to the queue.</source>
          <target state="translated">La gran pregunta es ¿cuándo tendrá la respuesta? La respuesta es que no lo sabemos,así que el bucle de eventos está esperando que el mensaje diga &quot;hola corran&quot;.Si JS esperara ese mensaje sincrónicamente,tu aplicación se congelaría y apestaría.Así que JS sigue ejecutando el siguiente elemento de la cola mientras espera a que el mensaje se añada de nuevo a la cola.</target>
        </trans-unit>
        <trans-unit id="ccbf0ca2fcdd4c3a3e86689a782e66920dbfdb25" translate="yes" xml:space="preserve">
          <source>The callback &lt;code&gt;...args&lt;/code&gt; are wrapped in an array and destructured when you read them so that the pattern can cope with callbacks that have multiple arguments. For example with &lt;a href=&quot;https://nodejs.org/api/fs.html&quot;&gt;node fs&lt;/a&gt;:</source>
          <target state="translated">La devoluci&amp;oacute;n de llamada &lt;code&gt;...args&lt;/code&gt; se envuelven en una matriz y se desestructuran cuando los lee para que el patr&amp;oacute;n pueda hacer frente a las devoluciones de llamada que tienen m&amp;uacute;ltiples argumentos. Por ejemplo con el &lt;a href=&quot;https://nodejs.org/api/fs.html&quot;&gt;nodo fs&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="77a6ce0e24e45311bbbc8af933b3454cde1bc3ae" translate="yes" xml:space="preserve">
          <source>The callback is set directly (so no extra unnecessary closures).</source>
          <target state="translated">La devolución de llamada se fija directamente (así que no hay cierres adicionales innecesarios).</target>
        </trans-unit>
        <trans-unit id="64f9a89935bc0aec8bd8d2c2f2163e48c2e4e0d3" translate="yes" xml:space="preserve">
          <source>The classic JS approach to this problem, taking advantage of the fact that JS supports functions as first-class objects which can be passed around, is to pass a function as a parameter to the asynchronous request, which it will then invoke when it has completed its task sometime in the future. That is the &quot;callback&quot; approach. It looks like this:</source>
          <target state="translated">El enfoque clásico de JS para este problema,aprovechando el hecho de que JS soporta funciones como objetos de primera clase que se pueden pasar de un lado a otro,es pasar una función como parámetro a la petición asíncrona,que luego invocará cuando haya completado su tarea en algún momento del futuro.Ese es el enfoque de &quot;devolución de llamada&quot;.Se parece a esto:</target>
        </trans-unit>
        <trans-unit id="a4b7cb494bc59feaa54149492dcd2fc6736593a6" translate="yes" xml:space="preserve">
          <source>The computer systems we build--more and more--have time as an important dimension. Certain things are set up to happen in the future. Then other things need to happen after those first things eventually occur. This is the basic notion called &quot;asynchronicity&quot;. In our increasingly networked world, the most common case of asynchronicity is waiting for some remote system to respond to some request.</source>
          <target state="translated">Los sistemas informáticos que construimos...cada vez más...tienen el tiempo como una dimensión importante.Ciertas cosas están preparadas para suceder en el futuro.Luego otras cosas necesitan suceder después de que esas primeras cosas eventualmente ocurran.Esta es la noción básica llamada &quot;asincronicidad&quot;.En nuestro mundo cada vez más interconectado,el caso más común de asincronicidad es esperar que algún sistema remoto responda a alguna petición.</target>
        </trans-unit>
        <trans-unit id="68c3c910b7e388c8ca698170706eac7d163f356e" translate="yes" xml:space="preserve">
          <source>The core issue</source>
          <target state="translated">La cuestión central</target>
        </trans-unit>
        <trans-unit id="edbb0afa295f70fd7b961434a3ea023d105f1de1" translate="yes" xml:space="preserve">
          <source>The following example I have written shows how to</source>
          <target state="translated">El siguiente ejemplo que he escrito muestra cómo</target>
        </trans-unit>
        <trans-unit id="7e2482274ea8174623353a79961f7e409558a384" translate="yes" xml:space="preserve">
          <source>The functions above are for basic use.</source>
          <target state="translated">Las funciones anteriores son de uso básico.</target>
        </trans-unit>
        <trans-unit id="f0b5d408edc15ee4ab49f75c3a45e0e83fe085b1" translate="yes" xml:space="preserve">
          <source>The most perfect answer to this question is using &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">La respuesta m&amp;aacute;s perfecta a esta pregunta es usar &lt;code&gt;Promise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">El problema</target>
        </trans-unit>
        <trans-unit id="bc0f50fb62db74196eb462d4435dbc048d27bedc" translate="yes" xml:space="preserve">
          <source>The problem with this callback approach is that it pollutes the normal semantics of a function reporting its result with &lt;code&gt;return&lt;/code&gt;; instead, functions must not reports their results by calling a callback given as a parameter. Also, this approach can rapidly become unwieldy when dealing with longer sequences of events. For example, let's say that I want to wait for the milk to be put in the coffee, and then and only then perform a third step, namely drinking the coffee. I end up needing to write something like this:</source>
          <target state="translated">El problema con este enfoque de devoluci&amp;oacute;n de llamada es que contamina la sem&amp;aacute;ntica normal de una funci&amp;oacute;n que informa su resultado con &lt;code&gt;return&lt;/code&gt; ; en cambio, las funciones no deben informar sus resultados llamando a una devoluci&amp;oacute;n de llamada dada como un par&amp;aacute;metro. Adem&amp;aacute;s, este enfoque puede volverse r&amp;aacute;pidamente dif&amp;iacute;cil de manejar cuando se trata de secuencias de eventos m&amp;aacute;s largas. Por ejemplo, supongamos que quiero esperar a que se ponga la leche en el caf&amp;eacute; y luego, y solo entonces, realizar un tercer paso, a saber, beber el caf&amp;eacute;. Termino necesitando escribir algo como esto:</target>
        </trans-unit>
        <trans-unit id="32dd7ece0413b20c7f6465adba94961d1fd0156b" translate="yes" xml:space="preserve">
          <source>The question was:</source>
          <target state="translated">La pregunta era:</target>
        </trans-unit>
        <trans-unit id="9865311a25d22afa6e2a491b6a5b84a1c39aeb10" translate="yes" xml:space="preserve">
          <source>The reason that doesn't work is that the callbacks from &lt;code&gt;doSomethingAsync&lt;/code&gt; haven't run yet by the time you're trying to use the results.</source>
          <target state="translated">La raz&amp;oacute;n por la que no funciona es que las devoluciones de llamada de &lt;code&gt;doSomethingAsync&lt;/code&gt; a&amp;uacute;n no se han ejecutado cuando intentas usar los resultados.</target>
        </trans-unit>
        <trans-unit id="a2739b5dbb10ebfc12b5d81d5d32fb7cd061a55e" translate="yes" xml:space="preserve">
          <source>The same is happening when you make a function call containing &quot;normal&quot; code:</source>
          <target state="translated">Lo mismo ocurre cuando se hace una llamada de función que contiene un código &quot;normal&quot;:</target>
        </trans-unit>
        <trans-unit id="98c7c4ba758c9126f0cfa1f1637747d0674ee4fd" translate="yes" xml:space="preserve">
          <source>The simplest solution is create a JavaScript function and call it for the Ajax &lt;code&gt;success&lt;/code&gt; callback.</source>
          <target state="translated">La soluci&amp;oacute;n m&amp;aacute;s simple es crear una funci&amp;oacute;n de JavaScript y llamarla para la devoluci&amp;oacute;n de llamada de &lt;code&gt;success&lt;/code&gt; Ajax.</target>
        </trans-unit>
        <trans-unit id="3d2b25517bf2d94a474aa03573586b145df347ce" translate="yes" xml:space="preserve">
          <source>The simplest:</source>
          <target state="translated">El más simple:</target>
        </trans-unit>
        <trans-unit id="6fe5eb2395efd41f10b91e16726041602d6e3143" translate="yes" xml:space="preserve">
          <source>The solution will be to avoid callbacks, and use a combination of &lt;strong&gt;Promises&lt;/strong&gt; and &lt;strong&gt;async/await&lt;/strong&gt;.</source>
          <target state="translated">La soluci&amp;oacute;n ser&amp;aacute; evitar devoluciones de llamada y usar una combinaci&amp;oacute;n de &lt;strong&gt;Promesas&lt;/strong&gt; y &lt;strong&gt;as&amp;iacute;ncrono / espera&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9dec62eb819ee8ace8aad60238eecf9a7f4fb514" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a&lt;/code&gt; returned is &lt;code&gt;undefined&lt;/code&gt; since the &lt;code&gt;a=5&lt;/code&gt; part has not executed yet. AJAX acts like this, you're returning the value before the server got the chance to tell your browser what that value is.</source>
          <target state="translated">El valor de &lt;code&gt;a&lt;/code&gt; devuelto &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute; definido ya que la parte &lt;code&gt;a=5&lt;/code&gt; a&amp;uacute;n no se ha ejecutado. AJAX act&amp;uacute;a as&amp;iacute;, est&amp;aacute; devolviendo el valor antes de que el servidor tenga la oportunidad de decirle a su navegador cu&amp;aacute;l es ese valor.</target>
        </trans-unit>
        <trans-unit id="8d1a490aef5366b80c665df9adb0416c82e381c5" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; since the &lt;code&gt;data = 5&lt;/code&gt; part has not executed yet. It will likely execute in a second but by that time it is irrelevant to the returned value.</source>
          <target state="translated">El valor de los &lt;code&gt;data&lt;/code&gt; &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute; definido ya que la parte &lt;code&gt;data = 5&lt;/code&gt; a&amp;uacute;n no se ha ejecutado. Probablemente se ejecutar&amp;aacute; en un segundo, pero para ese momento ya no es relevante para el valor devuelto.</target>
        </trans-unit>
        <trans-unit id="587b206c7db5b969cdb5a40887824aa9c5099e73" translate="yes" xml:space="preserve">
          <source>There are basically two ways how to solve this:</source>
          <target state="translated">Hay básicamente dos maneras de resolver esto:</target>
        </trans-unit>
        <trans-unit id="2cf0b130ac11e32c400e435be4fa43654576f982" translate="yes" xml:space="preserve">
          <source>There are some other situations which I don't remember that make the XMLHttpRequest 1 annoying.</source>
          <target state="translated">Hay otras situaciones que no recuerdo que hacen que el XMLHttpRequest 1 sea molesto.</target>
        </trans-unit>
        <trans-unit id="dd643d6829dc9f26a331e2bce21e4a3e98d834bc" translate="yes" xml:space="preserve">
          <source>There are three things you need to be aware of; &lt;strong&gt;The queue; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop&quot;&gt;the event loop&lt;/a&gt; and the stack&lt;/strong&gt;</source>
          <target state="translated">Hay tres cosas que debe tener en cuenta; &lt;strong&gt;La cola;&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop&quot;&gt;el bucle de eventos&lt;/a&gt; y la pila&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4498030a163e78ec8715dffc1c0ce5911aba4b0c" translate="yes" xml:space="preserve">
          <source>There are two ways to get the response of this Ajax call (three using the XMLHttpRequest var name):</source>
          <target state="translated">Hay dos maneras de obtener la respuesta de esta llamada de Ajax (tres usando el nombre de var XMLHttpRequest):</target>
        </trans-unit>
        <trans-unit id="37cfc454d35f84e510806797d964ad848a95604e" translate="yes" xml:space="preserve">
          <source>There is a problem with using promises!</source>
          <target state="translated">¡Hay un problema con el uso de las promesas!</target>
        </trans-unit>
        <trans-unit id="7d46baf54c6d620b802f531b3e92d3841965a2a5" translate="yes" xml:space="preserve">
          <source>There is no other way to do this in a non-asynchronous way. (Yeah, with setTimeout loop... but seriously?)</source>
          <target state="translated">No hay otra forma de hacer esto de forma no asincrónica.(Sí,con el bucle setTimeout...pero ¿en serio?)</target>
        </trans-unit>
        <trans-unit id="8511f0c06778d891bba10da5d78a325fa162981f" translate="yes" xml:space="preserve">
          <source>There is only the &lt;code&gt;this.type&lt;/code&gt; which is set to error.</source>
          <target state="translated">Solo existe &lt;code&gt;this.type&lt;/code&gt; , que est&amp;aacute; configurado como error.</target>
        </trans-unit>
        <trans-unit id="c974cb400663a76c12df4912d445ea3637c72efb" translate="yes" xml:space="preserve">
          <source>This code misunderstands the above asynchrony issues. Specifically, &lt;code&gt;$.ajax()&lt;/code&gt; doesn't freeze the code while it checks the '/password' page on your server - it sends a request to the server and while it waits, it immediately returns a jQuery Ajax Deferred object, not the response from the server. That means the &lt;code&gt;if&lt;/code&gt; statement is going to always get this Deferred object, treat it as &lt;code&gt;true&lt;/code&gt;, and proceed as though the user is logged in. Not good.</source>
          <target state="translated">Este c&amp;oacute;digo no comprende los problemas de asincron&amp;iacute;a anteriores. Espec&amp;iacute;ficamente, &lt;code&gt;$.ajax()&lt;/code&gt; no congela el c&amp;oacute;digo mientras verifica la p&amp;aacute;gina '/ contrase&amp;ntilde;a' en su servidor: env&amp;iacute;a una solicitud al servidor y mientras espera, inmediatamente devuelve un objeto jQuery Ajax diferido, no la respuesta del servidor Eso significa que la instrucci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; siempre obtendr&amp;aacute; este objeto diferido, lo tratar&amp;aacute; como &lt;code&gt;true&lt;/code&gt; y proceder&amp;aacute; como si el usuario hubiera iniciado sesi&amp;oacute;n. No es bueno.</target>
        </trans-unit>
        <trans-unit id="244afc8d38402f6d7c12baa9c3d841505fe06988" translate="yes" xml:space="preserve">
          <source>This is a short summary of &quot;Explanation of the problem&quot; from the other answer, if you're not sure after reading this, read that.</source>
          <target state="translated">Este es un breve resumen de la &quot;Explicación del problema&quot; de la otra respuesta,si no estás seguro después de leer esto,lee eso.</target>
        </trans-unit>
        <trans-unit id="bec8301fa7c95d68f2971235b818a4ec00cf9186" translate="yes" xml:space="preserve">
          <source>This is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt;. Basically, we're passing &lt;code&gt;getFive&lt;/code&gt; an action to perform when it completes, we're telling our code how to react when an event completes (like our AJAX call, or in this case the timeout).</source>
          <target state="translated">Esto se llama &lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt; . B&amp;aacute;sicamente, le estamos pasando a &lt;code&gt;getFive&lt;/code&gt; una acci&amp;oacute;n para que se realice cuando se complete, le estamos diciendo a nuestro c&amp;oacute;digo c&amp;oacute;mo reaccionar cuando se completa un evento (como nuestra llamada AJAX, o en este caso el tiempo de espera).</target>
        </trans-unit>
        <trans-unit id="e37cc018b8dd7866206ff24c3bd04692ca34d6e0" translate="yes" xml:space="preserve">
          <source>This is one of the places which &lt;strong&gt;two ways data binding&lt;/strong&gt; or &lt;strong&gt;store concept&lt;/strong&gt; that's used in many new JavaScript frameworks will work great for you...</source>
          <target state="translated">Este es uno de los lugares en los que &lt;strong&gt;dos formas de vinculaci&amp;oacute;n de datos&lt;/strong&gt; o &lt;strong&gt;concepto de tienda&lt;/strong&gt; que se utilizan en muchos nuevos marcos de JavaScript funcionar&amp;aacute;n muy bien para usted ...</target>
        </trans-unit>
        <trans-unit id="87baabf09170470e02be100dac74857e2ebc1619" translate="yes" xml:space="preserve">
          <source>This is quite simple:</source>
          <target state="translated">Esto es bastante simple:</target>
        </trans-unit>
        <trans-unit id="95b540890727eecbe058d586198261782083d7c0" translate="yes" xml:space="preserve">
          <source>This means AngularJS, jQuery (with deferred), native XHR's replacement (fetch), EmberJS, BackboneJS's save or any node library that returns promises.</source>
          <target state="translated">Esto significa AngularJS,jQuery (con diferido),reemplazo de XHR nativo (fetch),EmberJS,BackboneJS's save o cualquier biblioteca de nodos que devuelva promesas.</target>
        </trans-unit>
        <trans-unit id="b3d9c5469e4b15f9c162fb643af29c9f5ca05645" translate="yes" xml:space="preserve">
          <source>This means when you're returning &lt;code&gt;data&lt;/code&gt; the &lt;code&gt;then&lt;/code&gt; handler you've defined did not execute yet. This in turn means that the value you're returning has not been set to the correct value in time.</source>
          <target state="translated">Esto significa que cuando devuelve &lt;code&gt;data&lt;/code&gt; el controlador que defini&amp;oacute; a&amp;uacute;n no se ejecut&amp;oacute;. Esto a su vez significa que el valor que est&amp;aacute; devolviendo no se ha establecido en el valor correcto a tiempo.</target>
        </trans-unit>
        <trans-unit id="f01778d1944777ab6b8f39abe10e8afdd7a72058" translate="yes" xml:space="preserve">
          <source>This means when you're returning, the listener you've defined did not execute yet, which means the value you're returning has not been defined.</source>
          <target state="translated">Esto significa que cuando estás regresando,el oyente que has definido no se ha ejecutado todavía,lo que significa que el valor que estás regresando no ha sido definido.</target>
        </trans-unit>
        <trans-unit id="61ed4646f32a3a1ac23ad5fb1d6851ea5f3992d0" translate="yes" xml:space="preserve">
          <source>This method returns a promise itself, which we can consume from other coroutines. For example:</source>
          <target state="translated">Este método devuelve una promesa en sí,que podemos consumir de otras cortinas.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6d9e63f07d1d652a68998572e1a51ce636590916" translate="yes" xml:space="preserve">
          <source>This somewhat tricky but very powerful trick lets us write asynchronous code in a synchronous manner. There are several &quot;runners&quot; that do this for you, writing one is a short few lines of code but is beyond the scope of this answer. I'll be using Bluebird's &lt;code&gt;Promise.coroutine&lt;/code&gt; here, but there are other wrappers like &lt;code&gt;co&lt;/code&gt; or &lt;code&gt;Q.async&lt;/code&gt;.</source>
          <target state="translated">Este truco algo complicado pero muy poderoso nos permite escribir c&amp;oacute;digo asincr&amp;oacute;nico de manera sincr&amp;oacute;nica. Hay varios &quot;corredores&quot; que hacen esto por usted, escribir uno es unas pocas l&amp;iacute;neas de c&amp;oacute;digo pero est&amp;aacute; m&amp;aacute;s all&amp;aacute; del alcance de esta respuesta. Voy a usar Bluebird's &lt;code&gt;Promise.coroutine&lt;/code&gt; aqu&amp;iacute;, pero hay otros contenedores como &lt;code&gt;co&lt;/code&gt; o &lt;code&gt;Q.async&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7419d91a7773bb18e95de8945a17e396a7138932" translate="yes" xml:space="preserve">
          <source>This stands the same for your original API call, you can:</source>
          <target state="translated">Esto es lo mismo para tu llamada original a la API,puedes:</target>
        </trans-unit>
        <trans-unit id="b4c2a28333fa2716b1c47a4f0a2e18a4d80475ff" translate="yes" xml:space="preserve">
          <source>This was the motivation for the notion of a &quot;promise&quot;, which is a particular type of value which represents a &lt;strong&gt;future&lt;/strong&gt; or &lt;strong&gt;asynchronous&lt;/strong&gt; outcome of some sort. It can represent something that already happened, or that is going to happen in the future, or might never happen at all. Promises have a single method, named &lt;code&gt;then&lt;/code&gt;, to which you pass an action to be executed when the outcome the promise represents has been realized.</source>
          <target state="translated">Esta fue la motivaci&amp;oacute;n para la noci&amp;oacute;n de una &quot;promesa&quot;, que es un tipo particular de valor que representa un resultado &lt;strong&gt;futuro&lt;/strong&gt; o &lt;strong&gt;as&amp;iacute;ncrono&lt;/strong&gt; de alg&amp;uacute;n tipo. Puede representar algo que ya sucedi&amp;oacute;, o que va a suceder en el futuro, o puede que nunca suceda. Las promesas tienen un &amp;uacute;nico m&amp;eacute;todo, denominado &lt;code&gt;then&lt;/code&gt; , al que pasa una acci&amp;oacute;n para que se ejecute cuando el resultado que representa la promesa se ha cumplido.</target>
        </trans-unit>
        <trans-unit id="c88099e25e362faf93b5c34442314fc0efbfd023" translate="yes" xml:space="preserve">
          <source>This working example is self-contained. It will define a simple request object that uses the window &lt;code&gt;XMLHttpRequest&lt;/code&gt; object to make calls. It will define a simple function to wait for a bunch of promises to be completed.</source>
          <target state="translated">Este ejemplo de trabajo es aut&amp;oacute;nomo. Definir&amp;aacute; un objeto de solicitud simple que utiliza el objeto de ventana &lt;code&gt;XMLHttpRequest&lt;/code&gt; para realizar llamadas. Definir&amp;aacute; una funci&amp;oacute;n simple para esperar a que se completen un mont&amp;oacute;n de promesas.</target>
        </trans-unit>
        <trans-unit id="bb4a902028592cca405a4e54f7447a6dd933acce" translate="yes" xml:space="preserve">
          <source>Thus Solution to this is &lt;em&gt;callback&lt;/em&gt; or &lt;em&gt;promise&lt;/em&gt;.</source>
          <target state="translated">Por lo tanto, la soluci&amp;oacute;n a esto es la &lt;em&gt;devoluci&amp;oacute;n de llamada&lt;/em&gt; o la &lt;em&gt;promesa&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4ac77e33ad1dc33272e4765092ee238e7b4067" translate="yes" xml:space="preserve">
          <source>Thus, the summary is - to tackle the asynchronous functions like ajax based calls etc., you can use a promise to &lt;code&gt;resolve&lt;/code&gt; the value (which you intend to return). Thus, in short you &lt;strong&gt;resolve&lt;/strong&gt; value instead of &lt;strong&gt;returning&lt;/strong&gt;, in asynchronous functions.</source>
          <target state="translated">Por lo tanto, el resumen es: para abordar las funciones asincr&amp;oacute;nicas como llamadas basadas en ajax, etc., puede usar una promesa para &lt;code&gt;resolve&lt;/code&gt; r el valor (que tiene la intenci&amp;oacute;n de devolver). Por lo tanto, en resumen, &lt;strong&gt;resuelve el&lt;/strong&gt; valor en lugar de &lt;strong&gt;devolverlo&lt;/strong&gt; , en funciones asincr&amp;oacute;nicas.</target>
        </trans-unit>
        <trans-unit id="a0a2dcdf916f3c7cf3b91ae00bbe537935bc5316" translate="yes" xml:space="preserve">
          <source>To run the above code you do this:</source>
          <target state="translated">Para ejecutar el código anterior se hace esto:</target>
        </trans-unit>
        <trans-unit id="2e8f0671297e82a3357b05f76d4c39dd6732c8f7" translate="yes" xml:space="preserve">
          <source>UPDATE (Promises with async/await)</source>
          <target state="translated">ACTUALIZACIÓN (Promesas con asyncawait)</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e3b2c87fbdfa81069562e3801f3b834f583f3068" translate="yes" xml:space="preserve">
          <source>Usage would be:</source>
          <target state="translated">El uso sería:</target>
        </trans-unit>
        <trans-unit id="4ba1f4e931dcc6adc1af6d22a6e4e7abed5a85b2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt; pattern to join multiple HTTP calls;</source>
          <target state="translated">Use el patr&amp;oacute;n &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt; para unir m&amp;uacute;ltiples llamadas HTTP;</target>
        </trans-unit>
        <trans-unit id="e698b02ca0c7b2228f7ccbc8c4b111e743e10e2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;Promise&lt;/a&gt; pattern;</source>
          <target state="translated">Usar patr&amp;oacute;n de &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;promesa&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="0e9a58ba6887bb7e51147aa2da4a49a0486ce969" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;callback()&lt;/code&gt; function inside the &lt;code&gt;foo()&lt;/code&gt; success.
Try in this way. It is simple and easy to understand. &amp;nbsp;</source>
          <target state="translated">Use una funci&amp;oacute;n &lt;code&gt;callback()&lt;/code&gt; dentro del &amp;eacute;xito &lt;code&gt;foo()&lt;/code&gt; . Intenta de esta manera. Es simple y f&amp;aacute;cil de entender.</target>
        </trans-unit>
        <trans-unit id="606944b24d98d72b39627fdefe858efa8d964a89" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;'await'&lt;/a&gt;, which will tell JavaScript to await the promise to be resolved into a value (like the HTTP response)</source>
          <target state="translated">Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;'esperar'&lt;/a&gt; , que le indicar&amp;aacute; a JavaScript que espere la promesa de resolverse en un valor (como la respuesta HTTP)</target>
        </trans-unit>
        <trans-unit id="a11fcc742eebbcfca3c5bb6597892f401f073e0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;strong&gt;asynchronous&lt;/strong&gt; code as if it were &lt;strong&gt;synchronous&lt;/strong&gt;:</source>
          <target state="translated">Use el c&amp;oacute;digo &lt;strong&gt;asincr&amp;oacute;nico&lt;/strong&gt; como si fuera &lt;strong&gt;s&amp;iacute;ncrono&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="50df00102216ee2fa6b8d3f60a71c04beba81fe1" translate="yes" xml:space="preserve">
          <source>Using ES2017 you should have this as the function declaration</source>
          <target state="translated">Usando ES2017 deberías tener esto como la declaración de la función</target>
        </trans-unit>
        <trans-unit id="cc12d7b012ca1bfa32bf1aa97b798db2031c84f8" translate="yes" xml:space="preserve">
          <source>Using Promise</source>
          <target state="translated">Usando la promesa</target>
        </trans-unit>
        <trans-unit id="28685eec146d7abeed631f689f722a157cd3cd31" translate="yes" xml:space="preserve">
          <source>Using callback concept - As implementation in first answer</source>
          <target state="translated">Usando el concepto de devolución de llamada-Como implementación en la primera respuesta</target>
        </trans-unit>
        <trans-unit id="c787b69b8c1dad213e2bced9dc421d4fbabcda2a" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;XMLHttpRequest&lt;/code&gt; variable name is another big error as you need to execute the callback inside the onload/oreadystatechange closures else you lost it.</source>
          <target state="translated">El uso del nombre de variable &lt;code&gt;XMLHttpRequest&lt;/code&gt; es otro gran error, ya que debe ejecutar la devoluci&amp;oacute;n de llamada dentro de los cierres onload / oreadystatechange, de lo contrario lo perder&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="b7ce43e50f1c7276c7fa06bbf7c04a9872a17966" translate="yes" xml:space="preserve">
          <source>Wait for response from each API call;</source>
          <target state="translated">Espere la respuesta de cada llamada al API;</target>
        </trans-unit>
        <trans-unit id="35c239d949f8723db6cf2fca7425f52803d0c967" translate="yes" xml:space="preserve">
          <source>We find ourselves in a universe which appears to progress along a dimension we call &quot;time&quot;. We don't really understand what time is, but we have developed abstractions and vocabulary that let us reason and talk about it: &quot;past&quot;, &quot;present&quot;, &quot;future&quot;, &quot;before&quot;, &quot;after&quot;.</source>
          <target state="translated">Nos encontramos en un universo que parece progresar a lo largo de una dimensión que llamamos &quot;tiempo&quot;.No entendemos realmente lo que es el tiempo,pero hemos desarrollado abstracciones y vocabulario que nos permiten razonar y hablar de él:&quot;pasado&quot;,&quot;presente&quot;,&quot;futuro&quot;,&quot;antes&quot;,&quot;después&quot;.</target>
        </trans-unit>
        <trans-unit id="cf190ebdec93ca0293df429352a161bff1aed4e0" translate="yes" xml:space="preserve">
          <source>We have now made our foo function accept an action to run when the AJAX completes successfully, we can extend this further by checking if the response status is not 200 and acting accordingly (create a fail handler and such). Effectively solving our issue.</source>
          <target state="translated">Ahora hemos hecho que nuestra función foo acepte una acción para ejecutar cuando el AJAX se complete con éxito,podemos ampliar esto aún más comprobando si el estado de respuesta no es 200 y actuando en consecuencia (crear un manejador de fallos y tal).Resolviendo efectivamente nuestro problema.</target>
        </trans-unit>
        <trans-unit id="ac71c9a45e5e5d552a308fe3128d89db33f20f8b" translate="yes" xml:space="preserve">
          <source>What you're facing</source>
          <target state="translated">A lo que te enfrentas</target>
        </trans-unit>
        <trans-unit id="d9e7e738a86ea5326f809837e5b5ea81f305f671" translate="yes" xml:space="preserve">
          <source>When one of these messages is going to execute it pops the message from the queue and creates a stack, the stack is everything JS needs to execute to perform the instruction in the message. So in our example it's being told to call &lt;code&gt;foobarFunc&lt;/code&gt;</source>
          <target state="translated">Cuando uno de estos mensajes se va a ejecutar, saca el mensaje de la cola y crea una pila, la pila es todo lo que JS necesita ejecutar para realizar la instrucci&amp;oacute;n en el mensaje. Entonces, en nuestro ejemplo, se le dice que llame a &lt;code&gt;foobarFunc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46e5db5a04236061d5766214e29fc62f17454cbf" translate="yes" xml:space="preserve">
          <source>When using promises, we end up passing lots of functions into &lt;code&gt;then&lt;/code&gt;, so it's often helpful to use the more compact ES6-style arrow functions:</source>
          <target state="translated">Cuando usamos promesas, terminamos pasando muchas funciones en &lt;code&gt;then&lt;/code&gt; , por lo que a menudo es &amp;uacute;til usar las funciones de flecha de estilo ES6 m&amp;aacute;s compactas:</target>
        </trans-unit>
        <trans-unit id="b23496e842dceff9fb3a521cbe84a712262e3f34" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;.then&lt;/code&gt; on a promise and &lt;em&gt;return&lt;/em&gt; something from it - we get a promise for &lt;em&gt;the processed value&lt;/em&gt;. If we return another promise we'll get amazing things, but let's hold our horses.</source>
          <target state="translated">Cuando llamamos a &lt;code&gt;.then&lt;/code&gt; en una promesa y &lt;em&gt;devolvemos&lt;/em&gt; algo de ella, recibimos una promesa por &lt;em&gt;el valor procesado&lt;/em&gt; . Si devolvemos otra promesa, obtendremos cosas incre&amp;iacute;bles, pero sostengamos nuestros caballos.</target>
        </trans-unit>
        <trans-unit id="d987b91f60f98a1b758f0e53d90290815d18964e" translate="yes" xml:space="preserve">
          <source>When you make a call using AJAX to an external party or run any asynchronous code (a setTimeout for example), Javascript is dependant upon a response before it can proceed.</source>
          <target state="translated">Cuando se hace una llamada usando AJAX a una parte externa o se ejecuta cualquier código asíncrono (un setTimeout por ejemplo),Javascript depende de una respuesta antes de poder proceder.</target>
        </trans-unit>
        <trans-unit id="380b904db5976f20d5318f6cc1191c770d1da13f" translate="yes" xml:space="preserve">
          <source>Whenever you call a method that returns a promise, the &lt;code&gt;then&lt;/code&gt; handlers are &lt;em&gt;always&lt;/em&gt; executed asynchronously - that is, &lt;strong&gt;after&lt;/strong&gt; the code below them that is not in a &lt;code&gt;.then&lt;/code&gt; handler.</source>
          <target state="translated">Cada vez que llama a un m&amp;eacute;todo que devuelve una promesa, los controladores de &lt;code&gt;then&lt;/code&gt; &lt;em&gt;siempre se&lt;/em&gt; ejecutan de forma as&amp;iacute;ncrona, es decir, &lt;strong&gt;despu&amp;eacute;s&lt;/strong&gt; del c&amp;oacute;digo debajo de ellos que no est&amp;aacute; en un controlador &lt;code&gt;.then&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42feb8ea413f33209ece4d328587c570e4d54ebe" translate="yes" xml:space="preserve">
          <source>Which should alert &quot;5&quot; to the screen. &lt;a href=&quot;http://jsfiddle.net/PAjZR/&quot;&gt;(Fiddle)&lt;/a&gt;.</source>
          <target state="translated">Que deber&amp;iacute;a alertar &quot;5&quot; a la pantalla. &lt;a href=&quot;http://jsfiddle.net/PAjZR/&quot;&gt;(Viol&amp;iacute;n)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec5557762b5410ae1ddd3eb2b67bfdb2da22a4ce" translate="yes" xml:space="preserve">
          <source>While it is &lt;em&gt;okay&lt;/em&gt; in small examples it gets annoying when you have a lot of similar cases and error handling involved.</source>
          <target state="translated">Si bien est&amp;aacute; &lt;em&gt;bien&lt;/em&gt; en peque&amp;ntilde;os ejemplos, se vuelve molesto cuando tienes muchos casos similares y manejo de errores involucrado.</target>
        </trans-unit>
        <trans-unit id="1450bd8677cf37b475780df43411df3cca8f006a" translate="yes" xml:space="preserve">
          <source>While promises and callbacks work fine in many situations, it is a pain in the rear to express something like:</source>
          <target state="translated">Mientras que las promesas y las devoluciones de llamada funcionan bien en muchas situaciones,es un dolor en la retaguardia expresar algo como:</target>
        </trans-unit>
        <trans-unit id="448c4cc13812bccdb5367397d714ad86dd6ea552" translate="yes" xml:space="preserve">
          <source>Why add an error handler if you totally have no control over errors?
Most of the errors are returned inside this in the callback function &lt;code&gt;displayAjax()&lt;/code&gt;.</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; agregar un controlador de errores si no tiene control sobre los errores? La mayor&amp;iacute;a de los errores se devuelven dentro de esto en la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;displayAjax()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5edfc082aa90912642ae681f74a76ece5088c8fa" translate="yes" xml:space="preserve">
          <source>Why is it bad do you ask?</source>
          <target state="translated">¿Por qué es malo lo que preguntas?</target>
        </trans-unit>
        <trans-unit id="1229758f7e8ec3a149e87560402cc78e508a43de" translate="yes" xml:space="preserve">
          <source>Why should we use our own custom Promise?</source>
          <target state="translated">¿Por qué deberíamos usar nuestra propia Promesa personalizada?</target>
        </trans-unit>
        <trans-unit id="ece375bff4b483047da3749860748c38927e530d" translate="yes" xml:space="preserve">
          <source>With promises</source>
          <target state="translated">Con promesas</target>
        </trans-unit>
        <trans-unit id="0c0a59fb074de0fc1fd7cee2f49870f337cc9102" translate="yes" xml:space="preserve">
          <source>Without jQuery</source>
          <target state="translated">Sin jQuery</target>
        </trans-unit>
        <trans-unit id="b5fea0abea018388c5315d97c39b4081a7cb703a" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest API</source>
          <target state="translated">XMLHttpRequest API</target>
        </trans-unit>
        <trans-unit id="e73644d1d710900fb613359a5f23e329c06b46fe" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest supports both synchronous and asynchronous communications. In general, however, asynchronous requests should be preferred to synchronous requests for performance reasons.</source>
          <target state="translated">XMLHttpRequest soporta tanto comunicaciones sincrónicas como asincrónicas.Sin embargo,en general,las solicitudes asincrónicas deben preferirse a las síncronas por razones de rendimiento.</target>
        </trans-unit>
        <trans-unit id="b9b7f311a0fbfaead32e2e31dba1d379c239df35" translate="yes" xml:space="preserve">
          <source>Yes, you can.</source>
          <target state="translated">Sí,puede.</target>
        </trans-unit>
        <trans-unit id="83fb6a0fad9feb9e391f4aec4d78ee5495226649" translate="yes" xml:space="preserve">
          <source>You are using Ajax incorrectly. The idea is not to have it return anything, but instead hand off the data to something called a callback function, which handles the data.</source>
          <target state="translated">Estás usando Ajax incorrectamente.La idea es que no devuelva nada,sino que pase los datos a algo llamado función de devolución de llamada,que maneja los datos.</target>
        </trans-unit>
        <trans-unit id="f394fee622b97599e0a31a6f0f4cd4cc68870f7c" translate="yes" xml:space="preserve">
          <source>You call your friend again for the same reason. But this time you tell him that you are in a hurry and he should &lt;em&gt;call you back&lt;/em&gt; on your mobile phone. You hang up, leave the house and do whatever you planned to do. Once your friend calls you back, you are dealing with the information he gave to you.</source>
          <target state="translated">Llamas a tu amigo nuevamente por la misma raz&amp;oacute;n. Pero esta vez le dices que tienes prisa y que &amp;eacute;l deber&amp;iacute;a &lt;em&gt;volver&lt;/em&gt; a &lt;em&gt;llamarte&lt;/em&gt; a tu tel&amp;eacute;fono m&amp;oacute;vil. Cuelgas, sales de casa y haces lo que planeaste hacer. Una vez que su amigo le devuelve la llamada, est&amp;aacute; lidiando con la informaci&amp;oacute;n que le dio.</target>
        </trans-unit>
        <trans-unit id="d2bd21947364482b0aca338a6b437d78f80037e7" translate="yes" xml:space="preserve">
          <source>You can also process the response before passing it to the callback:</source>
          <target state="translated">También puedes procesar la respuesta antes de pasarla a la devolución de la llamada:</target>
        </trans-unit>
        <trans-unit id="3beb8e59419ebd09fc9891e40ffa62d7e41da4e2" translate="yes" xml:space="preserve">
          <source>You can checkout the project &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Puedes ver el proyecto &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a399a6f3ef2aa4bf612fdbeaabb5190ec6b5790" translate="yes" xml:space="preserve">
          <source>You can consume that in this way,</source>
          <target state="translated">Puedes consumir eso de esta manera,</target>
        </trans-unit>
        <trans-unit id="0c470949a5de51b9f217c1f0fc0cf12e324c19e0" translate="yes" xml:space="preserve">
          <source>You can find a nice explanation &lt;a href=&quot;http://andyshora.com/promises-angularjs-explained-as-cartoon.html&quot;&gt;here&lt;/a&gt; also.</source>
          <target state="translated">Puedes encontrar una buena explicaci&amp;oacute;n &lt;a href=&quot;http://andyshora.com/promises-angularjs-explained-as-cartoon.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt; tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="3a480682174de8f801e99da50379e04d8ac8ac06" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; on MDN.</source>
          <target state="translated">Puede leer m&amp;aacute;s sobre &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; en MDN.</target>
        </trans-unit>
        <trans-unit id="ca259db921dc5475dee1f9c068034b544e83ec7f" translate="yes" xml:space="preserve">
          <source>You can start all of them and keep track of how many callbacks you're expecting, and then use the results when you've gotten that many callbacks:</source>
          <target state="translated">Puede iniciarlas todas y llevar un registro de cuántas llamadas espera,y luego usar los resultados cuando haya recibido tantas llamadas:</target>
        </trans-unit>
        <trans-unit id="00f65b8b36a713a1b70d47398be1c721ed3fffd5" translate="yes" xml:space="preserve">
          <source>You can then see a nested Promise structure, that lets you spawn multiple and completely asynchronous nested HTTP calls, and join the results from each subset of calls through &lt;code&gt;Promise.all&lt;/code&gt;.</source>
          <target state="translated">Luego puede ver una estructura Promesa anidada, que le permite generar m&amp;uacute;ltiples llamadas HTTP anidadas completamente as&amp;iacute;ncronas, y unir los resultados de cada subconjunto de llamadas a trav&amp;eacute;s de &lt;code&gt;Promise.all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5637817dac7360e2bf1c7c2d1626c7be889d259e" translate="yes" xml:space="preserve">
          <source>You can use a &lt;strong&gt;callback&lt;/strong&gt;, &lt;strong&gt;promise&lt;/strong&gt; and recently &lt;strong&gt;observable&lt;/strong&gt; to handle it for you, for example in promises we have some function like &lt;code&gt;success()&lt;/code&gt; or &lt;code&gt;then()&lt;/code&gt; which will be executed when your data is ready for you, same with callback or &lt;strong&gt;subscribe&lt;/strong&gt; function on &lt;strong&gt;observable&lt;/strong&gt;.</source>
          <target state="translated">Puede usar una &lt;strong&gt;devoluci&amp;oacute;n de llamada&lt;/strong&gt; , &lt;strong&gt;promesa&lt;/strong&gt; y recientemente &lt;strong&gt;observable&lt;/strong&gt; para manejarlo por usted, por ejemplo, en promesas tenemos alguna funci&amp;oacute;n como &lt;code&gt;success()&lt;/code&gt; o &lt;code&gt;then()&lt;/code&gt; que se ejecutar&amp;aacute; cuando sus datos est&amp;eacute;n listos para usted, lo mismo con la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada o &lt;strong&gt;suscripci&amp;oacute;n&lt;/strong&gt; en &lt;strong&gt;observable&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3aedc25db58a4804737e831c476a6e6a972dbab8" translate="yes" xml:space="preserve">
          <source>You can use this custom library (written using Promise) to make a remote call.</source>
          <target state="translated">Puedes usar esta biblioteca personalizada (escrita con Promise)para hacer una llamada remota.</target>
        </trans-unit>
        <trans-unit id="dd6628c5f45797d9ea0f78c8fc099d6704e851a0" translate="yes" xml:space="preserve">
          <source>You'd end up going through &lt;code&gt;async1&lt;/code&gt;; check if &lt;code&gt;name&lt;/code&gt; is undefined or not and call the callback accordingly.</source>
          <target state="translated">Terminar&amp;iacute;as pasando por &lt;code&gt;async1&lt;/code&gt; ; compruebe si el &lt;code&gt;name&lt;/code&gt; no est&amp;aacute; definido o no y llame a la devoluci&amp;oacute;n de llamada en consecuencia.</target>
        </trans-unit>
        <trans-unit id="bd8715a64e94539f3c8b8df1772b0c03d902cf35" translate="yes" xml:space="preserve">
          <source>Your code should be something along the lines of this:</source>
          <target state="translated">Tu código debería ser algo parecido a esto:</target>
        </trans-unit>
        <trans-unit id="79d239c9d4dd6e9398d601a54d23e6f15a901265" translate="yes" xml:space="preserve">
          <source>async/await version:</source>
          <target state="translated">versión asyncawait:</target>
        </trans-unit>
        <trans-unit id="5fa5455b316d09922e2556fd3e7db0992016d6bb" translate="yes" xml:space="preserve">
          <source>await is supported in all current browsers and node 8</source>
          <target state="translated">await está soportado en todos los navegadores actuales y en el nodo 8</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="6cdd908e77bf13956316a9dfb985f596f59e72fe" translate="yes" xml:space="preserve">
          <source>but if &lt;code&gt;a&lt;/code&gt; is asynchronous, with promises we have to write</source>
          <target state="translated">pero si &lt;code&gt;a&lt;/code&gt; es as&amp;iacute;ncrono, con promesas tenemos que escribir</target>
        </trans-unit>
        <trans-unit id="ba1108cd1f24e45036a47d4005ece995c5fe8b5d" translate="yes" xml:space="preserve">
          <source>cross-domain not allowed throws error automatically.</source>
          <target state="translated">El dominio cruzado no permitido arroja un error automáticamente.</target>
        </trans-unit>
        <trans-unit id="3691b5c9d0eec5124fbea2e6256064c9e642e83e" translate="yes" xml:space="preserve">
          <source>for instance,</source>
          <target state="translated">por ejemplo,</target>
        </trans-unit>
        <trans-unit id="00853d73f19844948fadbc48d500f997c46f7ee4" translate="yes" xml:space="preserve">
          <source>jQuery</source>
          <target state="translated">jQuery</target>
        </trans-unit>
        <trans-unit id="c6ba4cdd11e1a3db37a54109474e9c73534b938a" translate="yes" xml:space="preserve">
          <source>jQuery deferred</source>
          <target state="translated">jQuery diferido</target>
        </trans-unit>
        <trans-unit id="fba0ae53da33f0cd5e54603774b1229ca748fbd7" translate="yes" xml:space="preserve">
          <source>nsynjs will evaluate all promises sequentially, and put promise result into &lt;code&gt;data&lt;/code&gt; property:</source>
          <target state="translated">nsynjs evaluar&amp;aacute; todas las promesas secuencialmente y colocar&amp;aacute; el resultado de la promesa en &lt;code&gt;data&lt;/code&gt; propiedad de datos :</target>
        </trans-unit>
        <trans-unit id="e1a5e2d288843cc0d03987443a6fc38bffe1ef80" translate="yes" xml:space="preserve">
          <source>onreadystatechange is only useful if you want to get the headers on state 2.</source>
          <target state="translated">El cambio de estado sólo es útil si quieres obtener los encabezados en el estado 2.</target>
        </trans-unit>
        <trans-unit id="0458efd542acc1a7aebda8d34461df3c13d76b38" translate="yes" xml:space="preserve">
          <source>so most of the time (but not always) you'll pass &lt;code&gt;foo&lt;/code&gt; not &lt;code&gt;foo()&lt;/code&gt;</source>
          <target state="translated">as&amp;iacute; que la mayor&amp;iacute;a de las veces (pero no siempre) pasar&amp;aacute;s &lt;code&gt;foo&lt;/code&gt; no &lt;code&gt;foo()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88018d8629c033501aa21a3ab6e24d7aebd65b57" translate="yes" xml:space="preserve">
          <source>then/catch version:</source>
          <target state="translated">la versión &quot;thencatch&quot;:</target>
        </trans-unit>
        <trans-unit id="3aee67424c6f45abebfaef894361e9c0e7ddd958" translate="yes" xml:space="preserve">
          <source>where I am passing to &lt;code&gt;put_in_coffee&lt;/code&gt; both the milk to put in it, and also the action (&lt;code&gt;drink_coffee&lt;/code&gt;) to execute once the milk has been put in. Such code becomes hard to write, and read, and debug.</source>
          <target state="translated">donde paso a &lt;code&gt;put_in_coffee&lt;/code&gt; tanto la leche para poner en ella, como tambi&amp;eacute;n la acci&amp;oacute;n ( &lt;code&gt;drink_coffee&lt;/code&gt; ) para ejecutar una vez que se ha puesto la leche. Tal c&amp;oacute;digo se vuelve dif&amp;iacute;cil de escribir, leer y depurar.</target>
        </trans-unit>
        <trans-unit id="a861995ce1d879a17b5c91a26cf0e7eb75c29caf" translate="yes" xml:space="preserve">
          <source>which CAN be interpreted as:</source>
          <target state="translated">que puede ser interpretado como:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
