<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1452721">
    <body>
      <group id="1452721">
        <trans-unit id="8e0741bec52099753c6c2a0306787331f3b1bf94" translate="yes" xml:space="preserve">
          <source>&quot;Why is 'using namespace std;' considered a bad practice in C++?&quot;</source>
          <target state="translated">&quot;なぜ「名前空間 std;の使用」は C++で悪い習慣とみなされるのか?&quot;</target>
        </trans-unit>
        <trans-unit id="5575dde3d3d20bdebe5e5002778dd58101ae84ae" translate="yes" xml:space="preserve">
          <source>(Sometimes) source-file-level using-directives</source>
          <target state="translated">(場合によっては)ソースファイルレベルの使用ディレクティブ</target>
        </trans-unit>
        <trans-unit id="6a699133bca549300caca4bbc9e50a4f03f67b9e" translate="yes" xml:space="preserve">
          <source>A concrete example to clarify the concern. Imagine you have a situation where you have two libraries, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, each with their own namespace:</source>
          <target state="translated">懸念を明確にする具体例。 &lt;code&gt;foo&lt;/code&gt; と &lt;code&gt;bar&lt;/code&gt; の 2つのライブラリがあり、それぞれに独自の名前空間がある状況を想像してください。</target>
        </trans-unit>
        <trans-unit id="ba3eac4e25ae1cec81af111cfd596d079e2ef4bd" translate="yes" xml:space="preserve">
          <source>A lot of &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; features are going into the C++0x standard, and Visual&amp;nbsp;Studio&amp;nbsp;2010 has a lot of C++0x features, so suddenly these programs were not compiling.</source>
          <target state="translated">多くの&lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt;機能がC ++ 0x標準に組み込まれ、Visual Studio 2010には多くのC ++ 0x機能があるため、突然これらのプログラムはコンパイルされませんでした。</target>
        </trans-unit>
        <trans-unit id="39f8e6781daf6a934001f51f44614f546e42a1e3" translate="yes" xml:space="preserve">
          <source>A namespace is a named scope. Namespaces are used to group related declarations and to keep separate
items separate. For example, two separately developed libraries may use the same name to refer to different
items, but a user can still use both:</source>
          <target state="translated">名前空間とは、名前付きスコープのことです。名前空間は、関連する宣言をグループ化し、別々の項目を分離しておくために使用されます。例えば、別々に開発された 2 つのライブラリが同じ名前を使用して異なるアイテムを参照することができますが、ユーザーは両方を使用することができます。</target>
        </trans-unit>
        <trans-unit id="8a340e0ae7fed0a2d743f95465081c70d0cb841d" translate="yes" xml:space="preserve">
          <source>A using-declaration:</source>
          <target state="translated">使用宣言。</target>
        </trans-unit>
        <trans-unit id="b82a662dae5884212abc04bb506affe12b0328ae" translate="yes" xml:space="preserve">
          <source>Although the statement saves us from typing std:: whenever
  we wish to access a class or type defined in the std namespace, it
  imports the entirety of the std namespace into the current namespace
  of the program. Let us take a few examples to understand why this
  might not be such a good thing</source>
          <target state="translated">このステートメントを使用することで std::をタイプする手間が省けますが、std 名前空間で定義されているクラスや型にアクセスしたい場合はいつでも、std 名前空間の全体をプログラムの現在の名前空間にインポートします。これが良いことではない理由を理解するために、いくつかの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="2b00151385441b68225fc4658924e46453d8ec93" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;using namespace std&lt;/code&gt; throws a compilation error because of the ambiguity of count, which is also a function in algorithm library.</source>
          <target state="translated">&lt;code&gt;using namespace std&lt;/code&gt; すると、アルゴリズムライブラリの関数でもあるcountのあいまいさが原因でコンパイルエラーがスローされる例。</target>
        </trans-unit>
        <trans-unit id="235c5c438cb46b535c12595279d731d5b7716a5d" translate="yes" xml:space="preserve">
          <source>An idiom for using it locally</source>
          <target state="translated">現地で使うときの熟語</target>
        </trans-unit>
        <trans-unit id="0fbb0cc023270ff0740fd1bead3e7a7d083f3415" translate="yes" xml:space="preserve">
          <source>And as for making Boost's regex part of &lt;code&gt;std&lt;/code&gt;. I do that for future integration and &amp;ndash; again, I admit fully this is bias - I don't think it is as ugly as &lt;code&gt;boost::regex:: ...&lt;/code&gt;. Indeed, that is another thing for me. There are many things in C++ that I still have yet to come to fully accept in looks and methods (another example: variadic templates versus var arguments [though I admit variadic templates are very very useful!]). Even those that I do accept it was difficult, &lt;em&gt;and&lt;/em&gt; I still have issues with them.</source>
          <target state="translated">そしてBoostの正規表現を &lt;code&gt;std&lt;/code&gt; の一部にすることに関しては。 私は将来の統合のためにそれを行います-繰り返しますが、これは完全にバイアスであることを認めます-私はそれが &lt;code&gt;boost::regex:: ...&lt;/code&gt; ほど醜いとは思っていません。 確かに、それは私にとってもう1つのことです。 C ++には、見た目やメソッドでまだ完全に受け入れるには至っていないことがたくさんあります（別の例：可変引数テンプレートとvar引数[可変引数テンプレートは非常に便利だと認めていますが]）。 私が受け入れるものでさえ、それは困難でした、 &lt;em&gt;そして、&lt;/em&gt;私は彼らとまだ問題を抱えています。</target>
        </trans-unit>
        <trans-unit id="3aa9fcea2af1d01ac1dbb4efe366442a34d014fe" translate="yes" xml:space="preserve">
          <source>And see &lt;a href=&quot;https://www.sololearn.com/Discuss/187690/is-using-namespace-std-a-bad-practice/&quot;&gt;this opinion&lt;/a&gt;:</source>
          <target state="translated">そして&lt;a href=&quot;https://www.sololearn.com/Discuss/187690/is-using-namespace-std-a-bad-practice/&quot;&gt;この意見を&lt;/a&gt;見てください：</target>
        </trans-unit>
        <trans-unit id="0fecfa228c906cdbaa2a5ef28640a1b52d83c4df" translate="yes" xml:space="preserve">
          <source>Another reason is surprise.</source>
          <target state="translated">もう一つの理由は驚きです。</target>
        </trans-unit>
        <trans-unit id="9d1dee9a88dd2bd4cb378802f7b802ac8d01b036" translate="yes" xml:space="preserve">
          <source>As is mentioned in this &lt;a href=&quot;https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/&quot;&gt;page&lt;/a&gt;:</source>
          <target state="translated">この&lt;a href=&quot;https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/&quot;&gt;ページで&lt;/a&gt;言及されているように：</target>
        </trans-unit>
        <trans-unit id="e1ea5cc086ad8c105f0de7b7b2d957c6908d8ceb" translate="yes" xml:space="preserve">
          <source>As it is, I am still very biased towards C and biased against C++. Sparing details, much of what I work on fits C more (but it was a good exercise and a good way to make myself a. learn another language and b. try not be less biased against object/classes/etc which is maybe better stated as less closed-minded, less arrogant, and more accepting.). But what &lt;em&gt;is&lt;/em&gt; useful is what some already suggested: I do indeed use list (it is fairly generic, is it not ?), and sort (same thing) to name two that would cause a name clash if I were to do &lt;code&gt;using namespace std;&lt;/code&gt;, and so to that end I prefer being specific, in control and knowing that if I intend it to be the standard use then I will have to specify it. Put simply: no assuming allowed.</source>
          <target state="translated">それでも、私はまだCに非常に偏っていて、C ++に偏っています。 詳細を保存すると、私が取り組む内容の多くがCに適合します（しかし、それは良い練習であり、自分を作るための良い方法でした。a。別の言語を学び、b。オブジェクト/クラス/その他に対して偏見を少なくしないようにしてください。閉鎖的ではなく、傲慢さが少なく、より受け入れやすくなっています。 しかし、有用なのはすでに提案されているものです：私は実際にリストを使用し（かなり一般的ですが、そうではありませんか？）、 &lt;code&gt;using namespace std;&lt;/code&gt; を引き起こす2つの名前をソートします（同じことです）。 ; 、そしてそのために私は具体的に制御することを好み、それを標準的な使用にするつもりなら、それを指定する必要があることを知っています。 簡単に言えば、許可された仮定はありません。</target>
        </trans-unit>
        <trans-unit id="a951ab665371162929ad7cc1021e7f306c09ca5a" translate="yes" xml:space="preserve">
          <source>At this point everything is fine. When you run your program it 'Does something'. But later you update &lt;code&gt;bar&lt;/code&gt; and let's say it has changed to be like:</source>
          <target state="translated">この時点で、すべてが正常です。 プログラムを実行すると、「何かを実行」します。 しかし、後で &lt;code&gt;bar&lt;/code&gt; を更新して、次のように変更したとします。</target>
        </trans-unit>
        <trans-unit id="9cd966c7ceb5c8bf6d8a1e601c36928bf783b349" translate="yes" xml:space="preserve">
          <source>At this point you'll get a compiler error:</source>
          <target state="translated">この時点でコンパイラエラーが出ます。</target>
        </trans-unit>
        <trans-unit id="62f3b54904071c98839a53723f5cac8dbd3c6262" translate="yes" xml:space="preserve">
          <source>At this point your call to &lt;code&gt;a(42)&lt;/code&gt; suddenly binds to &lt;code&gt;bar::a&lt;/code&gt; instead of &lt;code&gt;foo::a&lt;/code&gt; and instead of doing 'something' it does 'something completely different'.  No compiler warning or anything. Your program just silently starts doing something complete different than before.</source>
          <target state="translated">この時点で、 &lt;code&gt;a(42)&lt;/code&gt; への呼び出しは突然 &lt;code&gt;foo::a&lt;/code&gt; ではなく &lt;code&gt;bar::a&lt;/code&gt; にバインドし、 「何か」を実行する代わりに「まったく異なるもの」を実行します。 コンパイラの警告などはありません。 プログラムは、以前とはまったく異なる何かを黙って開始します。</target>
        </trans-unit>
        <trans-unit id="36dab49377a029cf015f76cbd70a8bead781a8f1" translate="yes" xml:space="preserve">
          <source>Besides that, you can have namespace aliases. Here is an example of where it is useful that might not have been referred to. I use the C++11 standard and specifically with libstdc++. Well, it doesn't have complete &lt;code&gt;std::regex&lt;/code&gt; support. Sure, it compiles, but it throws an exception along the lines of it being an error on the programmer's end. But it is lack of implementation.</source>
          <target state="translated">それに加えて、名前空間のエイリアスを持つことができます。 ここでは、言及されていない可能性のある有用な例を示します。 私はC ++ 11標準、特にlibstdc ++を使用しています。 まあ、それは完全な &lt;code&gt;std::regex&lt;/code&gt; サポートを持っていません。 確かに、コンパイルはできますが、プログラマー側のエラーとして、例外をスローします。 しかし、それは実装の欠如です。</target>
        </trans-unit>
        <trans-unit id="8b819cb9c25c847eca882b7f61088fcf30ea9024" translate="yes" xml:space="preserve">
          <source>Beware that some people disagree with my saying &quot;feel free&quot; like this -- because although a &lt;code&gt;using&lt;/code&gt; statement in a cpp file is &lt;em&gt;better&lt;/em&gt; than in a header (because it doesn't affect people who include your header file), they think it's still not &lt;em&gt;good&lt;/em&gt; (because depending on the code it could make the implementation of the class more difficult to maintain). &lt;a href=&quot;https://isocpp.org/wiki/faq/coding-standards#using-namespace-std&quot;&gt;This C++ Super-FAQ entry&lt;/a&gt; says,</source>
          <target state="translated">このように「気軽に」と言うことに同意できない人もいることに注意してください。cppファイルの &lt;code&gt;using&lt;/code&gt; ステートメントはヘッダー&lt;em&gt;より&lt;/em&gt;も&lt;em&gt;優れてい&lt;/em&gt;ますが（ヘッダーファイルをインクルードする人には影響しないため）、それでもまだだと思います。 &lt;em&gt;良く&lt;/em&gt;ない（コードによっては、クラスの実装を維持することがより困難になる可能性があるため）。 &lt;a href=&quot;https://isocpp.org/wiki/faq/coding-standards#using-namespace-std&quot;&gt;このC ++ Super-FAQエントリ&lt;/a&gt;は、</target>
        </trans-unit>
        <trans-unit id="3bd225512cee60fc69de0a0f917ae67552b94c49" translate="yes" xml:space="preserve">
          <source>Bottom line: Explicitly prefixing everything doesn't do any harm, takes very little getting used to, and has objective advantages. In particular, it makes the code easier to interpret by the compiler and by human readers &amp;mdash; and that should probably be the main goal when writing code.</source>
          <target state="translated">結論：すべてに明示的にプレフィックスを付けても害はなく、慣れもほとんどなく、客観的な利点があります。 特に、コンパイラと人間の読者によるコードの解釈を容易にします。これが、コードを記述する際の主な目標になるはずです。</target>
        </trans-unit>
        <trans-unit id="984d1515ce54fb1acb235d14e03bcd7545ccca8f" translate="yes" xml:space="preserve">
          <source>But imagine an alternative scenario where bar changed instead to look like this instead:</source>
          <target state="translated">しかし、代わりにバーがこのように変化した代替シナリオを想像してみてください。</target>
        </trans-unit>
        <trans-unit id="bd243da61bc83e255c691b0eeb1676f5cf315d17" translate="yes" xml:space="preserve">
          <source>Consider</source>
          <target state="translated">Consider</target>
        </trans-unit>
        <trans-unit id="0fde436f316d9e7c2c1244b279c7df1ee1b8459d" translate="yes" xml:space="preserve">
          <source>Consider e.g. writing a piece of numerical software. Why would I even consider polluting my global namespace by cutting general &quot;std::vector&quot; down to &quot;vector&quot; when &quot;vector&quot; is one of the problem domain's most important concepts?</source>
          <target state="translated">例えば、数値計算ソフトウェアを書くことを考えてみましょう。一般的な &quot;std::vector&quot; を &quot;vector&quot; に削ってグローバルな名前空間を汚染することを考えても、&quot;vector&quot; が問題領域の最も重要な概念の一つであるのに、なぜ私はそれを考慮しなければならないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="4f260645290a8d4cc5baf50a62bc1e04d3f4c8a3" translate="yes" xml:space="preserve">
          <source>Corollary: In header files, don&amp;rsquo;t write namespace-level using directives or using declarations; instead, explicitly namespace-qualify all names. (The second rule follows from the first, because headers can never know what other header #includes might appear after them.)</source>
          <target state="translated">当然のこと：ヘッダーファイルでは、ディレクティブや宣言を使用して名前空間レベルを記述しないでください。 代わりに、すべての名前を明示的に名前空間で修飾します。 （2番目のルールは最初のルールに従います。これは、ヘッダーが他のヘッダー#includeの後に表示される可能性があるものを認識できないためです。）</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="b28c908712aa3b3c4f2721161a98d4f73d39f13a" translate="yes" xml:space="preserve">
          <source>Do not use it globally</source>
          <target state="translated">グローバルに使用しない</target>
        </trans-unit>
        <trans-unit id="b10099eb72109a24775417ddca5bf1c65d8e36bc" translate="yes" xml:space="preserve">
          <source>Everything works fine, and you can call &lt;code&gt;Blah()&lt;/code&gt; from Foo and &lt;code&gt;Quux()&lt;/code&gt; from Bar without problems. But one day you upgrade to a new version of Foo 2.0, which now offers a function called &lt;code&gt;Quux()&lt;/code&gt;. Now you've got a conflict: Both Foo 2.0 and Bar import &lt;code&gt;Quux()&lt;/code&gt; into your global namespace. This is going to take some effort to fix, especially if the function parameters happen to match.</source>
          <target state="translated">すべてが正常に機能し、Fooから &lt;code&gt;Blah()&lt;/code&gt; を呼び出し、Barから &lt;code&gt;Quux()&lt;/code&gt; を問題なく呼び出すことができます。 しかし、ある日、Foo 2.0の新しいバージョンにアップグレードすると、 &lt;code&gt;Quux()&lt;/code&gt; と呼ばれる関数が提供されます。 これで競合が発生しました &lt;code&gt;Quux()&lt;/code&gt; とBarの両方が、グローバルネームスペースにQuux（）をインポートします。 これは、特に関数のパラメーターが偶然一致する場合は、修正するためにいくらかの努力が必要です。</target>
        </trans-unit>
        <trans-unit id="7fdc8f5263841efbcae18f9750a704ca266369d1" translate="yes" xml:space="preserve">
          <source>Experienced programmers also try to avoid full qualification of names inside their source files. A minor reason for this is that it's not elegant to write more code when less code is sufficient &lt;em&gt;unless there are good reasons&lt;/em&gt;. A major reason for this is turning off argument-dependent lookup (ADL).</source>
          <target state="translated">また、経験豊富なプログラマーは、ソースファイル内の名前の完全修飾を避けようとします。 これのマイナーな理由は、十分&lt;em&gt;な理由がない限り&lt;/em&gt; 、少ないコードで十分な&lt;em&gt;場合に&lt;/em&gt; 、より多くのコードを書くのはエレガントでは&lt;em&gt;ないということ&lt;/em&gt;です。 これの主な理由は、引数依存検索（ADL）をオフにすることです。</target>
        </trans-unit>
        <trans-unit id="40fc3dd2e604ebb2070a1b8a0000705b0f996fcf" translate="yes" xml:space="preserve">
          <source>Experienced programmers use whatever solves their problems and avoid whatever creates new problems, and they avoid header-file-level using-directives for this exact reason.</source>
          <target state="translated">経験豊富なプログラマは問題を解決するものは何でも使い、新しい問題を生み出すものは何でも避けます。</target>
        </trans-unit>
        <trans-unit id="a7f84ccc694c5225483eb04c03fd8a8b7d981149" translate="yes" xml:space="preserve">
          <source>For example, if I type in, &lt;code&gt;using namespace std;&lt;/code&gt; and &lt;code&gt;using namespace otherlib;&lt;/code&gt; and type just &lt;code&gt;cout&lt;/code&gt; (which happens to be in both), rather than &lt;code&gt;std::cout&lt;/code&gt; (or &lt;code&gt;'otherlib::cout'&lt;/code&gt;), you might use the wrong one, and get errors. It's much more effective and efficient to use &lt;code&gt;std::cout&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;using namespace std;&lt;/code&gt; 入力すると、 &lt;code&gt;using namespace otherlib;&lt;/code&gt; を使用します。 そして、 &lt;code&gt;std::cout&lt;/code&gt; （または &lt;code&gt;'otherlib::cout'&lt;/code&gt; ）ではなく、単に &lt;code&gt;cout&lt;/code&gt; （両方にある）と入力すると、間違ったものを使用してエラーが発生する可能性があります。 &lt;code&gt;std::cout&lt;/code&gt; を使用する方がはるかに効果的で効率的です。</target>
        </trans-unit>
        <trans-unit id="f92e531886e10c1956f1cd4ead46fd24e7ec5ba4" translate="yes" xml:space="preserve">
          <source>From my experiences, if you have multiple libraries that uses say, &lt;code&gt;cout&lt;/code&gt;, but for a different purpose you may use the wrong &lt;code&gt;cout&lt;/code&gt;.</source>
          <target state="translated">私の経験から言うと、たとえば &lt;code&gt;cout&lt;/code&gt; を使用するライブラリが複数ある場合、別の目的で間違った &lt;code&gt;cout&lt;/code&gt; を使用する可能性があります。</target>
        </trans-unit>
        <trans-unit id="dc4a2e1c6384a6c0bca9221545adb77b689f41f1" translate="yes" xml:space="preserve">
          <source>Function-level using-directives and using-declarations inside functions' implementations</source>
          <target state="translated">関数レベルの使用指示子と関数の実装内の使用宣言</target>
        </trans-unit>
        <trans-unit id="e754f634964b71e89733cd919482e9f7c6dc7fd0" translate="yes" xml:space="preserve">
          <source>Go ahead and use it locally (almost) freely. This, of course, prevents you from repetition of &lt;code&gt;std::&lt;/code&gt; -- and repetition is also bad.</source>
          <target state="translated">先に進んで、ローカルで（ほぼ）自由に使用してください。 もちろん、これは &lt;code&gt;std::&lt;/code&gt; -の繰り返しを防ぎます。繰り返しも悪いです。</target>
        </trans-unit>
        <trans-unit id="a13b7ac34e7f5b5ed26674ea84e218245208110c" translate="yes" xml:space="preserve">
          <source>Here's one more data point: Many, many years ago, I also used to find it annoying having to prefix everything from the standard library with &lt;code&gt;std::&lt;/code&gt;. Then I worked in a project where it was decided at the start that both &lt;code&gt;using&lt;/code&gt; directives and declarations are banned except for function scopes. Guess what? It took most of us very few weeks to get used to writing the prefix, and after a few more weeks most of us even agreed that it actually made the code &lt;em&gt;more readable&lt;/em&gt;. There's a reason for that: &lt;strong&gt;&lt;em&gt;Whether you like shorter or longer prose is subjective, but the prefixes objectively add clarity to the code.&lt;/em&gt;&lt;/strong&gt; Not only the compiler, but you, too, find it easier to see which identifier is referred to.</source>
          <target state="translated">ここにもう1つデータポイントがあります。何年も前に、標準ライブラリのすべてのプレフィックスに &lt;code&gt;std::&lt;/code&gt; を付ける必要があることを煩わしく思ったこともありました。 その後、プロジェクトで作業しました。最初は、関数のスコープを除いて、ディレクティブと宣言の両方 &lt;code&gt;using&lt;/code&gt; 禁止することが決定されていました。 何だと思う？ 私たちのほとんどは、接頭辞の記述に慣れるまでに数週間を要し、さらに数週間後、ほとんどの人が実際にコード&lt;em&gt;を読みやすく&lt;/em&gt;することに同意しました。 それには理由があり&lt;strong&gt;&lt;em&gt;ます。文章を短くしたり長くしたりすることは主観的ですが、接頭辞は客観的にコードを明確にします。&lt;/em&gt;&lt;/strong&gt; コンパイラーだけでなく、あなたも、どの識別子が参照されているかを簡単に確認できます。</target>
        </trans-unit>
        <trans-unit id="14cd4a9b5c57786c9dcc406fd5351f54c74541d7" translate="yes" xml:space="preserve">
          <source>Horses for courses - manage your complexity how you best can and feel able.</source>
          <target state="translated">コースのための馬-あなたの複雑さを管理するには、どのように最高のことができ、できると感じることができます。</target>
        </trans-unit>
        <trans-unit id="b6059ce195c06e6a8d7d2780b75b1844645eec62" translate="yes" xml:space="preserve">
          <source>However, if I often use 'cout' and 'cin', I write: &lt;code&gt;using std::cout; using std::cin;&lt;/code&gt; in the .cpp file (never in the header file as it propagates with &lt;code&gt;#include&lt;/code&gt;). I think that no one sane will ever name a stream &lt;code&gt;cout&lt;/code&gt; or &lt;code&gt;cin&lt;/code&gt;. ;)</source>
          <target state="translated">ただし、「cout」と「cin」を頻繁に使用する場合は、次のように記述し &lt;code&gt;using std::cout; using std::cin;&lt;/code&gt; std :: cinを使用します。 .cppファイル内（ &lt;code&gt;#include&lt;/code&gt; を使用して伝播するため、ヘッダーファイル内には絶対にありません）。 私は、誰もストリーム・ &lt;code&gt;cout&lt;/code&gt; や &lt;code&gt;cin&lt;/code&gt; 名前を付けることは決してないと思います。 ;）</target>
        </trans-unit>
        <trans-unit id="2250f701130cc7a3863ada4af431ecaea750adc9" translate="yes" xml:space="preserve">
          <source>However, you may feel free to put a using statement in your (private) *.cpp files.</source>
          <target state="translated">ただし、(プライベートな)*.cpp ファイルの中に using ステートメントを入れても構いません。</target>
        </trans-unit>
        <trans-unit id="b8fafbc70aedce2fc77deabe47f1e309ea3f997a" translate="yes" xml:space="preserve">
          <source>I agree that it should not be used globally, but it's not so evil to use locally, like in a &lt;code&gt;namespace&lt;/code&gt;. Here's an example from &lt;em&gt;&quot;The C++ Programming Language&quot;&lt;/em&gt;:</source>
          <target state="translated">私はそれをグローバルに使用すべきではないことに同意し &lt;code&gt;namespace&lt;/code&gt; が、 名前空間のようにローカルで使用することはそれほど悪いことではありません。 &lt;em&gt;「C ++プログラミング言語」の&lt;/em&gt;例を次に示し&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="b957aa59d52d23ef4bc9ed842310ade7ee82aeff" translate="yes" xml:space="preserve">
          <source>I agree with everything &lt;a href=&quot;https://stackoverflow.com/questions/1452721/1452738#1452738&quot;&gt;Greg wrote&lt;/a&gt;, but I'd like to add: &lt;strong&gt;&lt;em&gt;It can even get worse than Greg said!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/1452721/1452738#1452738&quot;&gt;グレッグが書いた&lt;/a&gt;すべてに同意しますが 、付け加えたいと思い&lt;strong&gt;&lt;em&gt;ます。グレッグが言ったよりもさらに悪化する可能性があります。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3806b9230c26bc35f5387e9568e05e858aa6bb5a" translate="yes" xml:space="preserve">
          <source>I agree with others &amp;ndash; it is asking for name clashes, ambiguities and then the fact is it is less explicit. While I can see the use of &lt;code&gt;using&lt;/code&gt;, my personal preference is to limit it. I would also strongly consider what some others pointed out:</source>
          <target state="translated">私は他の人に同意します。名前の衝突、あいまいさを求めていますが、事実はそれほど明確ではありません。 を使用することはわかりますが、私の個人的な好みは制限することです。 他の人が指摘したことも強く考えます：</target>
        </trans-unit>
        <trans-unit id="de2e7022c8f014a2e70b1ef6b6313df62304adae" translate="yes" xml:space="preserve">
          <source>I agree with the others here, but I would like to address the concerns regarding readability - you can avoid all of that by simply using typedefs at the top of your file, function or class declaration.</source>
          <target state="translated">ここにいる他の人たちと同じ意見ですが、可読性に関する懸念事項にも触れておきたいと思います。</target>
        </trans-unit>
        <trans-unit id="1763537fa947e39d61c79dbb27ae0c8d2955d02f" translate="yes" xml:space="preserve">
          <source>I also consider it a bad practice. Why? Just one day I thought that the function of a namespace is to divide stuff, so I shouldn't spoil it with throwing everything into one global bag.</source>
          <target state="translated">私もそれは悪い習慣だと思っています。なぜでしょうか?名前空間の機能は何かを分割することだと思っていたので、すべてを一つのグローバルバッグに放り込んで、それを台無しにしてはいけないと思いました。</target>
        </trans-unit>
        <trans-unit id="de6cf10d0eaf9e11a0c6a2571f7cee7c4459b91d" translate="yes" xml:space="preserve">
          <source>I do not think it is necessarily bad practice under all conditions, but you need to be careful when you use it.  If you're writing a library, you probably should use the scope resolution operators with the namespace to keep your library from butting heads with other libraries.  For application level code, I don't see anything wrong with it.</source>
          <target state="translated">すべての条件で必ずしも悪いことではないと思いますが、使うときには注意が必要です。ライブラリを書くのであれば、自分のライブラリが他のライブラリとぶつからないように、名前空間を使ってスコープ解決演算子を使うべきでしょう。アプリケーションレベルのコードであれば、何も問題はないと思います。</target>
        </trans-unit>
        <trans-unit id="d5080a2a4a2beb8872491aa265a231ea1ed16674" translate="yes" xml:space="preserve">
          <source>I mean really... saying &quot;don't rely on this being present&quot; is just setting you up to rely on it NOT being present.  You are constantly going to have issues borrowing code snippets and constantly repairing them.  Just keep your user-defined and borrowed stuff in limited scope as they should be and be VERY sparing with globals (honestly globals should almost always be a last resort for purposes of &quot;compile now, sanity later&quot;). Truly I think it is bad advice from your teacher because using std will work for both &quot;cout&quot; and &quot;std::cout&quot; but NOT using std will only work for &quot;std::cout&quot;.  You will not always be fortunate enough to write all your own code.</source>
          <target state="translated">つまり、本当に...&quot;これが存在することに頼るな &quot;と言うことは、それが存在しないことに頼るようにあなたを設定しているだけなのです。あなたは常にコードスニペットを借りてきて、それを修復する問題を抱えていることになります。ユーザー定義や借用したものは、本来あるべきように限定されたスコープにとどめておき、グローバルは非常に控えめにしてください(正直なところ、グローバルは「今すぐコンパイルして、後で正気を保つ」という目的のための最後の手段であることがほとんどです)。std を使うと &quot;cout&quot; と &quot;std::cout&quot; の両方で動作しますが、std を使わないと &quot;std::cout&quot; でしか動作しないので、先生からの悪いアドバイスだと思います。あなたは常に自分でコードを書くことができるほど幸運なわけではありません。</target>
        </trans-unit>
        <trans-unit id="f75a67cd99e9c9fbf6abd8a8f84e205de1d5a8c2" translate="yes" xml:space="preserve">
          <source>I put it the other way around: Why is typing five extra characters considered cumbersome by some?</source>
          <target state="translated">私は逆に言いました。なぜ余分な5文字を入力するのが面倒だと思われる人がいるのか?</target>
        </trans-unit>
        <trans-unit id="315d92e4893f10fb88044d2ccdcfc00fb3e343d7" translate="yes" xml:space="preserve">
          <source>I recently ran into a complaint about &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2010&lt;/a&gt;. It turned out that pretty much all the source files had these two lines:</source>
          <target state="translated">最近、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010&quot;&gt;Visual Studio 2010&lt;/a&gt;について不満を感じました。 ほとんどすべてのソースファイルに次の2行が含まれていることがわかりました。</target>
        </trans-unit>
        <trans-unit id="8441eb391ffa1ac35a213cb285d116689923e4e3" translate="yes" xml:space="preserve">
          <source>I usually use it in my class declaration as methods in a class tend to deal with similar data types (the members) and a typedef is an opportunity to assign a name that is meaningful in the context of the class. This actually aids readability in the definitions of the class methods.</source>
          <target state="translated">私は通常、クラスのメソッドは似たようなデータ型(メンバ)を扱う傾向があるので、クラスのコンテキストで意味のある名前を割り当てる機会として型定義をクラス宣言で使用しています。これは実際にクラスのメソッドの定義の可読性を向上させます。</target>
        </trans-unit>
        <trans-unit id="ae395c81a97e21bacfb9359546bf7289ddc3c88b" translate="yes" xml:space="preserve">
          <source>I won't argue on whether that is a bad idea or not. I will however argue that it keeps it clean for &lt;em&gt;my&lt;/em&gt; project and at the same time makes it specific: True, I have to use Boost, &lt;em&gt;but&lt;/em&gt; I'm using it like the libstdc++ will eventually have it. Yes, starting your own project and starting with a standard (...) at the very beginning goes a very long way with helping maintenance, development and everything involved with the project!</source>
          <target state="translated">それが悪い考えであるかどうかについては議論しません。 しかし、 &lt;em&gt;私&lt;/em&gt;はそれが&lt;em&gt;私の&lt;/em&gt;プロジェクトのためにそれをきれいに保ち、同時にそれを特定にすることを主張します：真、私はブーストを使用しなければなりませんが、libstdc ++が最終的にそれを持っているようにそれを使用しています。 はい、独自のプロジェクトを開始し、最初から標準（...）で開始することは、メンテナンス、開発、およびプロジェクトに関連するすべてを支援するのに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="19e234fd1ffb5551c9bacc76444a0745a8b46a07" translate="yes" xml:space="preserve">
          <source>I've been told by others that writing &lt;code&gt;using namespace std;&lt;/code&gt; in code is wrong, and that I should use &lt;code&gt;std::cout&lt;/code&gt; and &lt;code&gt;std::cin&lt;/code&gt; directly instead.</source>
          <target state="translated">&lt;code&gt;using namespace std;&lt;/code&gt; て書くと他の人から言われました。 コードが間違っているので、代わりに &lt;code&gt;std::cout&lt;/code&gt; と &lt;code&gt;std::cin&lt;/code&gt; 直接使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="091066152480cd6d7ec51ddc1f6d09610b9d55a1" translate="yes" xml:space="preserve">
          <source>If I see &lt;code&gt;cout &amp;lt;&amp;lt; blah&lt;/code&gt;, instead of &lt;code&gt;std::cout &amp;lt;&amp;lt; blah&lt;/code&gt; I think: What is this &lt;code&gt;cout&lt;/code&gt;? Is it the normal &lt;code&gt;cout&lt;/code&gt;? Is it something special?</source>
          <target state="translated">&lt;code&gt;std::cout &amp;lt;&amp;lt; blah&lt;/code&gt; 代わりに &lt;code&gt;cout &amp;lt;&amp;lt; blah&lt;/code&gt; 表示された場合、この &lt;code&gt;cout&lt;/code&gt; とは何ですか？ 普通の &lt;code&gt;cout&lt;/code&gt; ですか？ 何か特別なものですか？</target>
        </trans-unit>
        <trans-unit id="5a9372cdbb50764ea955811dd61572f65ed573bd" translate="yes" xml:space="preserve">
          <source>If all the standard stuff is in its own namespace you don't have to worry about name collisions with your code or other libraries.</source>
          <target state="translated">標準的なものがすべて独自の名前空間にある場合、コードや他のライブラリとの名前の衝突を心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="05bbbb5c87545d8ed21bba66dec5dbe3cf4e541d" translate="yes" xml:space="preserve">
          <source>If you consider this unlikely: There was &lt;a href=&quot;https://stackoverflow.com/a/2712125/140719&quot;&gt;a question asked&lt;/a&gt; here on Stack Overflow where pretty much exactly this happened (wrong function called due to omitted &lt;code&gt;std::&lt;/code&gt; prefix) about half a year after I gave this answer. &lt;a href=&quot;https://stackoverflow.com/questions/13402789/&quot;&gt;Here&lt;/a&gt; is another, more recent example of such a question.
So this is a real problem.</source>
          <target state="translated">あなたがこれをありそうにないと考える場合：Stack Overflowで&lt;a href=&quot;https://stackoverflow.com/a/2712125/140719&quot;&gt;質問&lt;/a&gt;があり、この答えが出てから約半年後に、これがほぼ正確に起こりました（ &lt;code&gt;std::&lt;/code&gt; 接頭辞が省略されているために誤った関数が呼び出されました）。 そのような質問の別の、より最近の例を次に示します。 これは本当の問題です。</target>
        </trans-unit>
        <trans-unit id="883b59bb138a2b98dd2f53050ba718757c60f448" translate="yes" xml:space="preserve">
          <source>If you do &lt;em&gt;not&lt;/em&gt; have that overload the compiler will use &lt;code&gt;void std::swap(Child&amp;amp;,Child&amp;amp;)&lt;/code&gt; and try its best swapping these.</source>
          <target state="translated">そのオーバーロードが&lt;em&gt;ない&lt;/em&gt;場合、コンパイラーは &lt;code&gt;void std::swap(Child&amp;amp;,Child&amp;amp;)&lt;/code&gt; 、これらを最適に交換しようとします。</target>
        </trans-unit>
        <trans-unit id="81009c04e328b3a3b5aadc7fe747aad2c2287d54" translate="yes" xml:space="preserve">
          <source>If you had used &lt;code&gt;foo::Blah()&lt;/code&gt; and &lt;code&gt;bar::Quux()&lt;/code&gt;, then the introduction of &lt;code&gt;foo::Quux()&lt;/code&gt; would have been a non-event.</source>
          <target state="translated">&lt;code&gt;foo::Blah()&lt;/code&gt; と &lt;code&gt;bar::Quux()&lt;/code&gt; 使用した場合、 &lt;code&gt;foo::Quux()&lt;/code&gt; 導入はイベントではありませんでした。</target>
        </trans-unit>
        <trans-unit id="d31c157553e55cd020a04b1f31d6a0bd553ab83f" translate="yes" xml:space="preserve">
          <source>If you have an overload &lt;code&gt;void swap(Child&amp;amp;, Child&amp;amp;)&lt;/code&gt; implemented the compiler will choose it.</source>
          <target state="translated">オーバーロード &lt;code&gt;void swap(Child&amp;amp;, Child&amp;amp;)&lt;/code&gt; 実装されている場合、コンパイラはそれを選択します。</target>
        </trans-unit>
        <trans-unit id="6cfd5241c3ace598230b440bf15ea476ef327fab" translate="yes" xml:space="preserve">
          <source>If you import the right header files you suddenly have names like &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/hex&quot;&gt;&lt;code&gt;hex&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/left&quot;&gt;&lt;code&gt;left&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/functional/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; in your global scope. This might be surprising if you are not aware that &lt;code&gt;std::&lt;/code&gt; contains these names. If you also try to use these names locally it can lead to quite some confusion.</source>
          <target state="translated">正しいヘッダーファイルをインポートすると、突然、 &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/hex&quot;&gt; &lt;code&gt;hex&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/left&quot;&gt; &lt;code&gt;left&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/functional/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;などの名前がグローバルスコープに含まれます。 &lt;code&gt;std::&lt;/code&gt; にこれらの名前が含まれていることに気付いていない場合、これは驚くかもしれません。 これらの名前をローカルで使用しようとすると、かなり混乱する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8d02f14101198ab0a96dc0a62eeaadc30eac403e" translate="yes" xml:space="preserve">
          <source>If you only talk about &lt;code&gt;using namespace std&lt;/code&gt; you might not be aware of all the stuff you grab -- and when you add another &lt;code&gt;#include&lt;/code&gt; or move to a new C++ revision you might get name conflicts you were not aware of.</source>
          <target state="translated">&lt;code&gt;using namespace std&lt;/code&gt; についてのみ話している場合、取得したすべてのものに気付かない可能性があります。別の &lt;code&gt;#include&lt;/code&gt; を追加したり、新しいC ++リビジョンに移動したりすると、気付かなかった名前の競合が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4713f3b8d7aeb939fd9e031cf10de0c3697de5bd" translate="yes" xml:space="preserve">
          <source>If you want to find a function name that might be a fairly common name, but you only want to find it in the &lt;code&gt;std&lt;/code&gt; namespace (or the reverse &amp;ndash; you want to change all calls that are &lt;em&gt;not&lt;/em&gt; in namespace &lt;code&gt;std&lt;/code&gt;, namespace &lt;code&gt;X&lt;/code&gt;, ...), then how do you propose to do this?</source>
          <target state="translated">かなり一般的な名前である可能性がある関数名を検索したいが、 &lt;code&gt;std&lt;/code&gt; 名前空間でのみ検索したい場合（またはその逆-名前空間 &lt;code&gt;std&lt;/code&gt; 、名前空間 &lt;code&gt;X&lt;/code&gt; に&lt;em&gt;ない&lt;/em&gt;すべての呼び出しを変更したい場合） 。）では、これをどのように行うことを提案しますか？</target>
        </trans-unit>
        <trans-unit id="c4a5742abc54fef340d5e42bb52ab3d34501cefb" translate="yes" xml:space="preserve">
          <source>If you're only using &lt;code&gt;cout&lt;/code&gt;, nobody gets confused.  But when you have lots of namespaces flying around and you see this class and you aren't exactly sure what it does, having the namespace explicit acts as a comment of sorts. You can see at first glance, &quot;oh, this is a filesystem operation&quot; or &quot;that's doing network stuff&quot;.</source>
          <target state="translated">&lt;code&gt;cout&lt;/code&gt; のみを使用している場合、混乱する人はいません。 しかし、たくさんの名前空間が飛んでいて、このクラスが表示され、それが何をするのか正確にわからない場合、名前空間を明示的に指定すると、一種のコメントとして機能します。 一見すると、「ああ、これはファイルシステム操作です」または「ネットワーク関連の処理をしている」ことがわかります。</target>
        </trans-unit>
        <trans-unit id="3a0a2f58e94e59b13e5b57410ca215b154e4dd1a" translate="yes" xml:space="preserve">
          <source>In C++03 there was an idiom -- boilerplate code -- for implementing a &lt;code&gt;swap&lt;/code&gt; function for your classes. It was suggested that you actually use a local &lt;code&gt;using namespace std&lt;/code&gt; -- or at least &lt;code&gt;using std::swap&lt;/code&gt;:</source>
          <target state="translated">C ++ 03では、クラスの &lt;code&gt;swap&lt;/code&gt; 関数を実装するためのイディオム（ボイラープレートコード）がありました。 &lt;code&gt;using namespace std&lt;/code&gt; 使用してローカルを実際に使用するか、少なくとも &lt;code&gt;using std::swap&lt;/code&gt; 使用することが推奨されました：</target>
        </trans-unit>
        <trans-unit id="4efd6ea07a2c12ae34510e9920765f13b7b87856" translate="yes" xml:space="preserve">
          <source>In a decade, that project grew to have several million lines of code. Since these discussions come up again and again, I once was curious how often the (allowed) function-scope &lt;code&gt;using&lt;/code&gt; actually was used in the project. I grep'd the sources for it and only found one or two dozen places where it was used. To me this indicates that, once tried, developers don't find &lt;code&gt;std::&lt;/code&gt; painful enough to employ using directives even once every 100 kLoC even where it was allowed to be used.</source>
          <target state="translated">10年の間に、そのプロジェクトは数百万行のコードを持つようになりました。 これらの議論が何度も繰り返されるので、私はかつて、（許可された）関数スコープ &lt;code&gt;using&lt;/code&gt; 実際にプロジェクトで使用する頻度に興味を持っていました。 私はそのソースをgrepしましたが、それが使用された場所は1〜2ダースしか見つかりませんでした。 これは、一度試してみると、開発者が &lt;code&gt;std::&lt;/code&gt; 見つけられないことを示しています。使用が許可されていた場所でも、100 kLoCごとに一度もディレクティブを使用するほど苦痛です。</target>
        </trans-unit>
        <trans-unit id="06435acc952b6ddf3ff59e777675ac2714343da8" translate="yes" xml:space="preserve">
          <source>In short: You can and should use namespace using declarations and directives liberally in your implementation files after #include directives and feel good about it. &lt;strong&gt;Despite repeated assertions to the contrary, namespace using declarations and directives are not evil and they do not defeat the purpose of namespaces. Rather, they are what make namespaces usable&lt;/strong&gt;.</source>
          <target state="translated">簡単に言うと、#includeディレクティブの後に実装ファイルで宣言とディレクティブを自由に使用して名前空間を使用できます。 &lt;strong&gt;反対の主張が繰り返されているにもかかわらず、宣言とディレクティブを使用した名前空間は悪ではなく、名前空間の目的を無効にすることはありません。&lt;/strong&gt; &lt;strong&gt;むしろ、それらは名前空間を使用可能にするもの&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="ec2299e86922f16c12bb89391ea97d486f2d6389" translate="yes" xml:space="preserve">
          <source>In this example, we resolved potential name clashes and ambiguities arising from their composition.</source>
          <target state="translated">この例では、その構成から生じる潜在的な名前の衝突や曖昧さを解決した。</target>
        </trans-unit>
        <trans-unit id="65c4c1dce2db14606c299117092648f5be7eb3d2" translate="yes" xml:space="preserve">
          <source>It depends on where it is located. If it is a common header, then you are diminishing the value of the namespace by merging it into the global namespace. Keep in mind, this could be a neat way of making module globals.</source>
          <target state="translated">それがどこにあるかによります。もしそれが共通のヘッダであれば、名前空間をグローバル名前空間にマージすることで、名前空間の価値を下げていることになります。これは、モジュールのグローバル化を行うための、すっきりとした方法であることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="a9149a57a26a9aeee68e53682d200c4529d40a43" translate="yes" xml:space="preserve">
          <source>It doesn't make your software or project performance worse. The inclusion of the namespace at the beginning of your source code isn't bad. The inclusion of the &lt;code&gt;using namespace std&lt;/code&gt; instruction varies according to your needs and the way you are developing the software or project.</source>
          <target state="translated">ソフトウェアやプロジェクトのパフォーマンスを悪化させることはありません。 ソースコードの最初に名前空間を含めることは悪くありません。 &lt;code&gt;using namespace std&lt;/code&gt; 命令を使用するかどうかは、ニーズとソフトウェアまたはプロジェクトの開発方法によって異なります。</target>
        </trans-unit>
        <trans-unit id="2594ecb269de1ca1ca972a398f9ac08229b7f4f0" translate="yes" xml:space="preserve">
          <source>It is considered &quot;bad&quot; only when &lt;strong&gt;used globally&lt;/strong&gt;. Because:</source>
          <target state="translated">&lt;strong&gt;グローバル&lt;/strong&gt;に&lt;strong&gt;使用された&lt;/strong&gt;場合のみ、「不良」と見なさ&lt;strong&gt;れ&lt;/strong&gt;ます。 なぜなら：</target>
        </trans-unit>
        <trans-unit id="1ebc6c4aab7254b3c847f7a94a880434c0e2f28e" translate="yes" xml:space="preserve">
          <source>It's all about managing complexity. Using the namespace will pull things in that you don't want, and thus possibly make it harder to debug (I say possibly). Using std:: all over the place is harder to read (more text and all that).</source>
          <target state="translated">それは複雑さを管理することです。名前空間を使うと、必要のないものを引き込んでしまい、デバッグが難しくなる可能性があります(私は「可能性がある」と言っています)。std::をあちこちで使うと読みにくくなります (テキストが多くなります)。</target>
        </trans-unit>
        <trans-unit id="38709085bed04576c2d5d32366c7d466d551f5ee" translate="yes" xml:space="preserve">
          <source>It's nice to see code and know what it does. If I see &lt;code&gt;std::cout&lt;/code&gt; I know that's the &lt;code&gt;cout&lt;/code&gt; stream of the &lt;code&gt;std&lt;/code&gt; library. If I see &lt;code&gt;cout&lt;/code&gt; then I don't know. It &lt;em&gt;could&lt;/em&gt; be the &lt;code&gt;cout&lt;/code&gt; stream of the &lt;code&gt;std&lt;/code&gt; library. Or there could be an &lt;code&gt;int cout = 0;&lt;/code&gt; ten lines higher in the same function. Or a &lt;code&gt;static&lt;/code&gt; variable named &lt;code&gt;cout&lt;/code&gt; in that file. It could be anything.</source>
          <target state="translated">コードを見て、それが何をするのかを知るのは素晴らしいことです。 &lt;code&gt;std::cout&lt;/code&gt; 表示された場合、それが &lt;code&gt;std&lt;/code&gt; ライブラリの &lt;code&gt;cout&lt;/code&gt; ストリームであることがわかります。 &lt;code&gt;cout&lt;/code&gt; を見てもわからない。 &lt;code&gt;std&lt;/code&gt; ライブラリの &lt;code&gt;cout&lt;/code&gt; ストリームである&lt;em&gt;可能性&lt;/em&gt;があります。 または、 &lt;code&gt;int cout = 0;&lt;/code&gt; 同じ関数で10行高くなります。 または、そのファイルの &lt;code&gt;cout&lt;/code&gt; という名前の &lt;code&gt;static&lt;/code&gt; 変数。 何でもかまいません。</target>
        </trans-unit>
        <trans-unit id="291d10432ee90ffee7774e1bfd80a03295550276" translate="yes" xml:space="preserve">
          <source>It's not horrible, but you'll save yourself headaches by not using it in header files or the global namespace. It's probably all right to do it in very limited scopes, but I've never had a problem typing the extra five characters to clarify where my functions are coming from.</source>
          <target state="translated">恐ろしいものではありませんが、ヘッダファイルやグローバル名前空間では使用しない方が頭痛の種になりません。非常に限られたスコープではそれでいいのかもしれませんが、私は自分の関数がどこから来ているのかを明確にするために余分な5文字を入力して問題になったことはありません。</target>
        </trans-unit>
        <trans-unit id="9baf97e2ec47fa798dfe06c21b8e750de1bac58f" translate="yes" xml:space="preserve">
          <source>It's one of these things that seem a really good idea if you are a teacher and never had to write and maintain any code for a living. I love seeing code where (1) I know what it does; and, (2) I'm confident that the person writing it knew what it does.</source>
          <target state="translated">これは、あなたが教師であり、生活のためにコードを書いたりメンテナンスしたりする必要がなかった場合には、本当に良いアイデアのように思えるこれらのものの一つです。私は、(1)何をするか分かっていて、(2)書いた人が何をするか分かっていると確信できるコードを見るのが好きです。</target>
        </trans-unit>
        <trans-unit id="91a8c9eace09304424f54dbcea4ab917ef139db7" translate="yes" xml:space="preserve">
          <source>Just to clarify something: I don't actually think it is a good idea to use a name of a class/whatever in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; deliberately and more specifically in place of. The string is the exception (ignore the first, above, or second here, pun if you must) for me as I didn't like the idea of 'String'.</source>
          <target state="translated">何かを明確にするために： &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt;でクラスの名前などを意図的に、より具体的には代わりに使用することは、実際には良い考えではないと思います。 文字列は私にとっては例外です（最初の文字列、上、または2番目の文字列は無視してください。必要な場合は駄洒落です）。私は「文字列」の概念が好きではなかったためです。</target>
        </trans-unit>
        <trans-unit id="29daf4a7594ca589153ad134f21264fe11ca3416" translate="yes" xml:space="preserve">
          <source>Just typing std::</source>
          <target state="translated">std:と入力しただけです。</target>
        </trans-unit>
        <trans-unit id="8507557482216947016f1aeee1629d528f10442b" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;std&lt;/code&gt; namespace has tons of identifiers, many of which are &lt;em&gt;very&lt;/em&gt; common ones (think &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, etc.) which are very likely to appear in other code, too.</source>
          <target state="translated">&lt;code&gt;std&lt;/code&gt; 名前空間には大量の識別子があり、その多くは&lt;em&gt;非常に&lt;/em&gt;一般的な識別子（ &lt;code&gt;list&lt;/code&gt; 、 &lt;code&gt;sort&lt;/code&gt; 、 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;iterator&lt;/code&gt; など）であり、他のコードにも現れる可能性が高いことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6a07da18fbe175d65d1d0865aa1dc4b50b7ab47f" translate="yes" xml:space="preserve">
          <source>Library Foo 2.0 could introduce a function, &lt;code&gt;Quux()&lt;/code&gt;, that is an unambiguously better match for some of your calls to &lt;code&gt;Quux()&lt;/code&gt; than the &lt;code&gt;bar::Quux()&lt;/code&gt; your code called for years. Then your &lt;strong&gt;&lt;em&gt;code still compiles&lt;/em&gt;&lt;/strong&gt;, but &lt;strong&gt;&lt;em&gt;it silently calls the wrong function&lt;/em&gt;&lt;/strong&gt; and does god-knows-what. That's about as bad as things can get.</source>
          <target state="translated">ライブラリFoo 2.0は、 &lt;code&gt;Quux()&lt;/code&gt; 関数を導入する可能性があります。これは、コードが &lt;code&gt;bar::Quux()&lt;/code&gt; &lt;code&gt;Quux()&lt;/code&gt; も前に呼び出したbar :: Quux（）よりも、 Qux（）への呼び出しの一部に明確に一致するものです。 その後、 &lt;strong&gt;&lt;em&gt;コードは引き続きコンパイルされます&lt;/em&gt;&lt;/strong&gt;が、 &lt;strong&gt;&lt;em&gt;それは暗黙のうちに間違った関数&lt;/em&gt;&lt;/strong&gt;を&lt;strong&gt;&lt;em&gt;呼び出して、&lt;/em&gt;&lt;/strong&gt; god-knows-whatを実行します。 それは物事が得ることができるのと同じくらい悪いです。</target>
        </trans-unit>
        <trans-unit id="5124022ffb20c699c10a1cc2488c255b2ffc9a00" translate="yes" xml:space="preserve">
          <source>NOTE: Don't focus too much on efficiency issues until you actually learn a little about how compilers work.  With a little experience coding you don't have to learn that much about them before you realize how much they are able to generalize good code into something something simple.  Every bit as simple as if you wrote the whole thing in C.  Good code is only as complex as it needs to be.</source>
          <target state="translated">NOTE:コンパイラがどのように動作するのかを実際に少し学ぶまでは、効率性の問題にあまり注目しないようにしましょう。コーディングの経験が少しあれば、コンパイラがどれだけ良いコードを簡単なものに一般化できるかを理解するまでは、それほど多くのことを学ぶ必要はありません。良いコードは必要なだけ複雑なものです。</target>
        </trans-unit>
        <trans-unit id="9ce878b56aa89e0fc6464244ab6312410a2325ee" translate="yes" xml:space="preserve">
          <source>Names explicitly declared there (including names declared by using-declarations like &lt;code&gt;His_lib::String&lt;/code&gt;) take priority over names made accessible in another scope by a using-directive (&lt;code&gt;using namespace Her_lib&lt;/code&gt;).</source>
          <target state="translated">そこで明示的に宣言された名前（ &lt;code&gt;His_lib::String&lt;/code&gt; ようなusing宣言によって宣言された名前を含む）は、usingディレクティブ（ &lt;code&gt;using namespace Her_lib&lt;/code&gt; ）によって別のスコープでアクセス可能にされた名前よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="50b2a2e68d91a2fa20faee50e5b1093521bfac70" translate="yes" xml:space="preserve">
          <source>Namespace usings are for your convenience, not for you to inflict on others: Never write a using declaration or a using directive before an #include directive.</source>
          <target state="translated">名前空間の使用はあなたの便宜のためのものであり、あなたが他の人に迷惑をかけるためのものではありません。using宣言やusingディレクティブを#includeディレクティブの前に書いてはいけません。</target>
        </trans-unit>
        <trans-unit id="50b1f6a51d747783cb1dfe6047e35834dd447f4e" translate="yes" xml:space="preserve">
          <source>Namespaces provide a powerful tool for the management of different libraries and of different versions of code. In particular, they offer the programmer alternatives of how explicit to make a reference to a nonlocal name.</source>
          <target state="translated">名前空間は、異なるライブラリや異なるバージョンのコードを管理するための強力なツールです。特に、非ローカル名への参照をどのように明示的に行うかという選択肢をプログラマに提供します。</target>
        </trans-unit>
        <trans-unit id="ddbccb0a8b6506410340a7f532fe40e471a2e05a" translate="yes" xml:space="preserve">
          <source>Note that this is a simple example. If you have files with 20 includes and other imports, you'll have a ton of dependencies to go through to figure out the problem. The worse thing about it is that you can get unrelated errors in other modules depending on the definitions that conflict.</source>
          <target state="translated">これは単純な例であることに注意してください。20個のインクルードや他のインポートがあるファイルを持っている場合、問題を把握するためにはトン単位の依存関係が必要になります。さらに悪いことに、競合する定義によっては、他のモジュールで無関係なエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="36ea41aee46346ce28dcadcb94012cb303748b76" translate="yes" xml:space="preserve">
          <source>Notice how there is an ambiguity, to which library does cout point to?
  The compiler may detect this and not compile the program. In the worst
  case, the program may still compile but call the wrong function, since
  we never specified to which namespace the identifier belonged.</source>
          <target state="translated">cout はどのライブラリを指しているのか、という曖昧さがあることに注意してください。コンパイラはこれを検出してプログラムをコンパイルしないかもしれません。最悪の場合、プログラムはコンパイルされますが、 識別子がどの名前空間に属しているかを指定していないため、 間違った関数を呼び出すことになります。</target>
        </trans-unit>
        <trans-unit id="f735b7708587108249bd04f231f9283a15ed3614" translate="yes" xml:space="preserve">
          <source>Now at a later stage of development, we wish to use another version of
  cout that is custom implemented in some library called &amp;ldquo;foo&amp;rdquo; (for
  example)</source>
          <target state="translated">ここで、開発の後の段階で、「foo」と呼ばれるライブラリにカスタム実装された別のバージョンのcoutを使用したいとします（たとえば）。</target>
        </trans-unit>
        <trans-unit id="a91a9e9922efdb33f03078a0f38ce71a94f60ab3" translate="yes" xml:space="preserve">
          <source>Now let's say you use &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together in your own program as follows:</source>
          <target state="translated">次のように、独自のプログラムで &lt;code&gt;foo&lt;/code&gt; と &lt;code&gt;bar&lt;/code&gt; を一緒に使用するとします。</target>
        </trans-unit>
        <trans-unit id="ce4819e926b1c69f9e959f1bcce61b24bbf7402f" translate="yes" xml:space="preserve">
          <source>Now take a million line code base, which isn't particularly big, and you're searching for a bug, which means you know there is one line in this one million lines that doesn't do what it is supposed to do. &lt;code&gt;cout &amp;lt;&amp;lt; 1;&lt;/code&gt; could read a &lt;code&gt;static int&lt;/code&gt; named &lt;code&gt;cout&lt;/code&gt;, shift it to the left by one bit, and throw away the result. Looking for a bug, I'd have to check that. Can you see how I really really prefer to see &lt;code&gt;std::cout&lt;/code&gt;?</source>
          <target state="translated">今度は100万行のコードベースを取得します。これはそれほど大きくはありませんが、バグを検索しています。つまり、この100万行には、本来の目的を果たさない1行があることを意味します。 &lt;code&gt;cout &amp;lt;&amp;lt; 1;&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; という名前の &lt;code&gt;static int&lt;/code&gt; 読み取り、それを1ビット左にシフトして、結果を破棄できます。 バグを探して、それを確認する必要があります。 私が本当に &lt;code&gt;std::cout&lt;/code&gt; を見る方が本当に好む方法を見ることができますか？</target>
        </trans-unit>
        <trans-unit id="399f9e8eb4c399a3656111274a9c1b117d6d1db3" translate="yes" xml:space="preserve">
          <source>One shouldn't use the &lt;code&gt;using&lt;/code&gt; directive at the global scope, especially in headers. However, there are situations where it is appropriate even in a header file:</source>
          <target state="translated">特にヘッダーでは、グローバルスコープで &lt;code&gt;using&lt;/code&gt; ディレクティブを使用しないでください。 ただし、ヘッダーファイルでも適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="1516c0ad1f8ca81d0226fc547e43c805fde700c0" translate="yes" xml:space="preserve">
          <source>People should stop being so anal about it. Your teacher was right all along. Just use ONE namespace; that is the whole point of using namespaces the first place. You are not supposed to use more than one at the same time. Unless it is your own. So again, redefinition will not happen.</source>
          <target state="translated">人はそれにこだわるのはやめた方がいい あなたの先生は最初から正しかったのです。名前空間は一つだけ使えばいいのです。同時に複数の名前空間を使うことはできません。それがあなた自身のものでない限り。ですから、再定義は起こらないでしょう。</target>
        </trans-unit>
        <trans-unit id="61ba504ad16f53fef83a89ee5e1bf8d3fd48334a" translate="yes" xml:space="preserve">
          <source>Personally, I actually don't mind the &lt;code&gt;std::&lt;/code&gt; prefix. I like the look more than not having it. I don't know if that is because it is explicit and says to me &quot;this isn't my code... I am using the standard library&quot; or if it is something else, but I think it looks nicer. This might be odd given that I only recently got into C++ (used and still do C and other languages for much longer and C is my favourite language of all time, right above assembly).</source>
          <target state="translated">個人的には、私は実際には &lt;code&gt;std::&lt;/code&gt; 接頭辞を気にしません。 私はそれを持たないよりも外観が好きです。 それが明示的で「これは私のコードではない...私は標準ライブラリを使用している」と言っているのか、それ以外の何かであるかはわかりませんが、見た目は良いと思います。 私が最近C ++を始めたばかりであることを考えると、これは奇妙かもしれません（Cと他の言語をずっと長く使用していて、Cは、アセンブリの真上で、いつも私のお気に入りの言語です）。</target>
        </trans-unit>
        <trans-unit id="98a84cb2b057f0497de2c666cab0ffec97887f04" translate="yes" xml:space="preserve">
          <source>Readers will have difficulty seeing where a particular identifier comes from, when you use many &lt;code&gt;using namespace xyz&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;using namespace xyz&lt;/code&gt; を使用して多くを使用する場合、読者は特定の識別子がどこから来たかを理解するのが困難になります。</target>
        </trans-unit>
        <trans-unit id="9140d5235666001f10df811c2360c257238af8d5" translate="yes" xml:space="preserve">
          <source>Repeating a namespace name can be a distraction for both readers and writers. Consequently, it is possible
to state that names from a particular namespace are available without explicit qualification. For example:</source>
          <target state="translated">名前空間の名前を繰り返すことは、読み手と書き手の両方にとって気が散ります。そのため、特定の名前空間からの名前を明示的に修飾しなくても利用可能であることを記述することができます。例えば、以下のように記述します。</target>
        </trans-unit>
        <trans-unit id="a38525257f468902dfed8f814582f493c591c970" translate="yes" xml:space="preserve">
          <source>Short version: don't use global &lt;code&gt;using&lt;/code&gt; declarations or directives in header files. Feel free to use them in implementation files. Here's what &lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrei_Alexandrescu&quot;&gt;Andrei Alexandrescu&lt;/a&gt; have to say about this issue in &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321113586&quot;&gt;C++ Coding Standards&lt;/a&gt; (bolding for emphasis is mine):</source>
          <target state="translated">ショートバージョン：ヘッダーファイルでグローバル &lt;code&gt;using&lt;/code&gt; 宣言またはディレクティブを使用しないでください。 実装ファイルで自由に使用してください。 &lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt;と&lt;a href=&quot;https://en.wikipedia.org/wiki/Andrei_Alexandrescu&quot;&gt;Andrei Alexandrescu&lt;/a&gt;がこの問題について&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321113586&quot;&gt;C ++コーディング標準&lt;/a&gt;で述べていることは次のとおりです（強調のための太字は私のものです）。</target>
        </trans-unit>
        <trans-unit id="eec2d891bc3edd909e8348b90447e5d43222b3e9" translate="yes" xml:space="preserve">
          <source>So here's how I solved it. Install Boost's regex, and link it in. Then, I do the following so that when libstdc++ has it implemented entirely, I need only remove this block and the code remains the same:</source>
          <target state="translated">そこで、私が解決した方法を紹介します。Boostの正規表現をインストールして、それをリンクする。そして、以下のようにして、libstdc++が完全に実装されたときに、このブロックを削除するだけでコードはそのままになるようにしています。</target>
        </trans-unit>
        <trans-unit id="ba958b36fe2684798576e2f9a1a8d021d2835d2a" translate="yes" xml:space="preserve">
          <source>So just consider them functions as reserved names like &quot;int&quot; or &quot;class&quot; and that is it.</source>
          <target state="translated">ですから、関数は「int」や「class」のような予約名と考えればいいだけです。</target>
        </trans-unit>
        <trans-unit id="eeaf7c2ef34ec4418e50a2e403553b2d83998883" translate="yes" xml:space="preserve">
          <source>So the following are OK:</source>
          <target state="translated">ということで、以下はOKです。</target>
        </trans-unit>
        <trans-unit id="f103eac16afc4b9fd2b1e99833b3f809101f91e2" translate="yes" xml:space="preserve">
          <source>So you'll need to do some maintenance to clarify that 'a' meant &lt;code&gt;foo::a&lt;/code&gt;. That's undesirable, but fortunately it is pretty easy (just add &lt;code&gt;foo::&lt;/code&gt; in front of all calls to &lt;code&gt;a&lt;/code&gt; that the compiler marks as ambiguous).</source>
          <target state="translated">したがって、「a」が &lt;code&gt;foo::a&lt;/code&gt; 意味することを明確にするために、いくつかのメンテナンスを行う必要があります。 それは望ましくありませんが、幸いにも非常に簡単です（コンパイラーがあいまいとしてマークする &lt;code&gt;a&lt;/code&gt; へのすべての呼び出しの前に &lt;code&gt;foo::&lt;/code&gt; を追加するだけです）。</target>
        </trans-unit>
        <trans-unit id="ecb267a2211227e4951289cb2c61d96f30e02f89" translate="yes" xml:space="preserve">
          <source>Some people had said that is a bad practice to include the &lt;code&gt;using namespace std&lt;/code&gt; in your source files because you're invoking from that namespace all the functions and variables. When you would like to define a new function with the same name as another function contained in the &lt;code&gt;namespace std&lt;/code&gt; you would overload the function and it could produce problems due to compile or execute. It will not compile or executing as you expect.</source>
          <target state="translated">&lt;code&gt;using namespace std&lt;/code&gt; からすべての関数と変数を呼び出すため、ソースファイルに名前空間stdを使用することは悪い習慣だと言う人もいました。 &lt;code&gt;namespace std&lt;/code&gt; 含まれている別の関数と同じ名前で新しい関数を定義する場合、関数をオーバーロードし、コンパイルまたは実行が原因で問題が発生する可能性があります。 期待どおりにコンパイルまたは実行されません。</target>
        </trans-unit>
        <trans-unit id="2983f4020c6309b44686250810ad2fa1b133cdbd" translate="yes" xml:space="preserve">
          <source>Source-file-level using-declarations inside source files</source>
          <target state="translated">ソースファイルレベルでのソースファイル内での使用宣言</target>
        </trans-unit>
        <trans-unit id="48a09de267300394017fd1240b9ef9afafe06e9a" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;An Overview of the C++ Programming Language&lt;/em&gt;
by Bjarne Stroustrup</source>
          <target state="translated">出典：Bjarne Stroustrupによる&lt;em&gt;C ++プログラミング言語の概要&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="8d362630dbd96c9d94d61a5ba26f68429e881414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;namespace std&lt;/code&gt; contains the C++ standard functions and variables. This namespace is useful when you often would use the C++ standard functions.</source>
          <target state="translated">&lt;code&gt;namespace std&lt;/code&gt; は、C ++標準関数と変数が含まれています。 この名前空間は、C ++標準関数を頻繁に使用する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="a0ecbbc85e8e265d8a3603712049a64cd310766c" translate="yes" xml:space="preserve">
          <source>The FAQ suggests two alternatives:</source>
          <target state="translated">FAQでは、2つの選択肢を提案しています。</target>
        </trans-unit>
        <trans-unit id="64995ed41ecdd7959fd7a75459bcac3c990a145f" translate="yes" xml:space="preserve">
          <source>The compiler will choose the &lt;code&gt;std::swap&lt;/code&gt; for &lt;code&gt;value_&lt;/code&gt;, i.e. &lt;code&gt;void std::swap(int, int)&lt;/code&gt;.</source>
          <target state="translated">コンパイラーは &lt;code&gt;value_&lt;/code&gt; に &lt;code&gt;std::swap&lt;/code&gt; を選択します。つまり、 &lt;code&gt;void std::swap(int, int)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b7f65e416b24edb3d7d7359d825fd5f48ff2bf1b" translate="yes" xml:space="preserve">
          <source>The problem with putting &lt;code&gt;using namespace&lt;/code&gt; in the header files of your classes is that it forces anyone who wants to use your classes (by including your header files) to also be 'using' (i.e. seeing everything in) those other namespaces.</source>
          <target state="translated">クラスのヘッダーファイルに &lt;code&gt;using namespace&lt;/code&gt; を使用することの問題は、（ヘッダーファイルを含めることによって）クラスを使用したいすべての人が、他の名前空間も「使用」する（つまり、すべてを参照する）ことを強制することです。</target>
        </trans-unit>
        <trans-unit id="651d1324e3e3efa0febb293121711a75a4c05298" translate="yes" xml:space="preserve">
          <source>The statement using namespace std is generally considered bad
  practice. The alternative to this statement is to specify the
  namespace to which the identifier belongs using the scope operator(::)
  each time we declare a type.</source>
          <target state="translated">名前空間 std を使用するステートメントは、一般的に悪い習慣と考えられています。このステートメントの代替案は、型を宣言するたびにスコープ演算子(:::)を使用して識別子が属する名前空間を指定することです。</target>
        </trans-unit>
        <trans-unit id="da678d1957a06dc4c79a7d800b78557e33ff5ebf" translate="yes" xml:space="preserve">
          <source>The using-directive exists for legacy C++ code and to ease the transition to namespaces, but you probably shouldn&amp;rsquo;t use it on a regular basis, at least not in your new C++ code.</source>
          <target state="translated">usingディレクティブは、レガシーC ++コードとネームスペースへの移行を容易にするために存在しますが、少なくとも新しいC ++コードでは定期的に使用しないでください。</target>
        </trans-unit>
        <trans-unit id="5b8ee9557da2fd48e95fe83d8c0f287ad5f8df12" translate="yes" xml:space="preserve">
          <source>There is no problem using &quot;using namespace std&quot; in your source file
  when you make heavy use of the namespace and know for sure that
  nothing will collide.</source>
          <target state="translated">名前空間を多用し、何も衝突しないことが確実にわかっている場合は、ソースファイルで &quot;using namespace std &quot;を使用しても問題はありません。</target>
        </trans-unit>
        <trans-unit id="029764c0ea9e395746931f8952df7326aa09ac18" translate="yes" xml:space="preserve">
          <source>There is one other thing although it is somewhat related to the above and what others point out. While this might be bad practise, I sometimes reserve &lt;code&gt;std::name&lt;/code&gt; for the standard library version and name for program-specific implementation. Yes, indeed this could bite you and bite you hard, but it all comes down to that I started this project from scratch, and I'm the only programmer for it. Example: I overload &lt;code&gt;std::string&lt;/code&gt; and call it &lt;code&gt;string&lt;/code&gt;. I have helpful additions. I did it in part because of my C and Unix (+ Linux) tendency towards lower-case names.</source>
          <target state="translated">上記のことや他の人が指摘していることと多少関係がありますが、もう1つあります。 これは悪い習慣かもしれませんが、標準ライブラリのバージョンとプログラム固有の実装の &lt;code&gt;std::name&lt;/code&gt; としてstd :: nameを予約することがあります。 はい、確かにこれはあなたに噛み付き、一生懸命噛む可能性がありますが、結局のところ、私がこのプロジェクトをゼロから始めたこと、そして私はそれだけのプログラマーです。 例： &lt;code&gt;std::string&lt;/code&gt; をオーバーロードし、それを &lt;code&gt;string&lt;/code&gt; と呼びます 。 役立つ追加があります。 CとUnix（+ Linux）で小文字の名前を使用する傾向があったためです。</target>
        </trans-unit>
        <trans-unit id="3f0a653213e88a4d78de823350af0cc28a0f0151" translate="yes" xml:space="preserve">
          <source>Therefore, avoiding &lt;code&gt;using namespace X;&lt;/code&gt; is a form of future-proofing, a way of making sure a change to the libraries and/or header files in use is not going to break a program.</source>
          <target state="translated">したがって、 &lt;code&gt;using namespace X;&lt;/code&gt; は避けてください。 は、将来を見据えた形式の1つであり、使用中のライブラリやヘッダーファイルへの変更がプログラムを破壊しないようにする方法です。</target>
        </trans-unit>
        <trans-unit id="f45f9dde8d1c10defc80ef7f165a362cba2c156e" translate="yes" xml:space="preserve">
          <source>This does the following magic:</source>
          <target state="translated">これは次のような魔法をかけます。</target>
        </trans-unit>
        <trans-unit id="a4545a366e0aad9d34b8acbf9d14874529a60d6a" translate="yes" xml:space="preserve">
          <source>This is a bad practice, often known as global namespace pollution. Problems may occur when more than one namespace has the same function name with signature, then it will be ambiguous for the compiler to decide which one to call and this all can be avoided when you are specifying the namespace with your function call like &lt;code&gt;std::cout&lt;/code&gt; . Hope this helps. :)</source>
          <target state="translated">これは悪い習慣であり、グローバル名前空間汚染としてよく知られています。 複数の名前空間がシグネチャ付きの同じ関数名を持っていると問題が発生する可能性があります。コンパイラがどちらを呼び出すかを決定することは不明確であり、 &lt;code&gt;std::cout&lt;/code&gt; ような関数呼び出しで名前空間を指定しているときにこれをすべて回避できます。 cout 。 お役に立てれば。 :)</target>
        </trans-unit>
        <trans-unit id="99260186b8c3a0ba3c616d9138288919d1f36e7b" translate="yes" xml:space="preserve">
          <source>This is better than explicit qualification (&lt;code&gt;std::sin&lt;/code&gt;, &lt;code&gt;std::cos&lt;/code&gt;...), because it is shorter and has the ability to work with user defined floating point types (via &lt;a href=&quot;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;argument-dependent lookup&lt;/a&gt; (ADL)).</source>
          <target state="translated">これは、明示的修飾（ &lt;code&gt;std::sin&lt;/code&gt; 、 &lt;code&gt;std::cos&lt;/code&gt; ...）よりも優れています。これは、より短く、ユーザー定義の浮動小数点型（ &lt;a href=&quot;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;引数依存ルックアップ&lt;/a&gt; （ADL）を使用）を操作できるためです。</target>
        </trans-unit>
        <trans-unit id="160a0a5c0f76c23ec35ad5487bfae3b08b2536aa" translate="yes" xml:space="preserve">
          <source>This is not related to performance at all. But consider this: you are using two libraries called Foo and Bar:</source>
          <target state="translated">これはパフォーマンスとは全く関係ありません。しかし、次のことを考えてみてください:あなたは Foo と Bar という 2 つのライブラリを使っています。</target>
        </trans-unit>
        <trans-unit id="298ec62c38104583ee0298f42b39da2f5449b342" translate="yes" xml:space="preserve">
          <source>To answer your question I look at it this way practically:  a lot of programmers (not all) invoke namespace std.  Therefore one should be in the habit of NOT using things that impinge or use the same names as what is in the namespace std.  That is a great deal granted, but not so much compared to the number of possible coherent words and pseudonyms that can be come up with strictly speaking.</source>
          <target state="translated">多くのプログラマが(すべてではありませんが)名前空間標準を呼び出しています。そのため、名前空間標準にあるものと同じ名前を使ったり、衝突したりするものは使わないようにしなければなりません。これは非常に重要なことですが、厳密に言えば、首尾一貫した単語や仮名の数に比べれば、それほど多くはありません。</target>
        </trans-unit>
        <trans-unit id="2782259cabfa8ad3d1fe54d85a7f2baf351f10f1" translate="yes" xml:space="preserve">
          <source>Ultimately this is a trade-off between writability vs. reliability/maintainability. Readability may factor in also, but I could see arguments for that going either way. Normally I would say reliability and maintainability are more important, but in this case you'll constantly pay the writability cost for an fairly rare reliability/maintainability impact. The 'best' trade-off will determine on your project and your priorities.</source>
          <target state="translated">最終的には、これは書き込み性と信頼性維持性のトレードオフになります。可読性も考慮されるかもしれませんが、どちらにしても議論の余地はあると思います。通常、私は信頼性と保守性の方が重要だと言いますが、この場合、信頼性と保守性に影響を与えることはほとんどありませんが、書き込み可能性のコストを常に支払うことになります。最良の」トレードオフは、あなたのプロジェクトと優先順位によって決まります。</target>
        </trans-unit>
        <trans-unit id="6ea4fced5fb87a77ecac7ac3fa6aeea3011782f8" translate="yes" xml:space="preserve">
          <source>Using many namespaces at the same time is obviously a recipe for disaster, but using JUST namespace &lt;code&gt;std&lt;/code&gt; and only namespace &lt;code&gt;std&lt;/code&gt; is not that big of a deal in my opinion because redefinition can only occur by your own code...</source>
          <target state="translated">同時に多くの名前空間を使用することは明らかに惨事のレシピですが、再定義は自分のコードによってのみ発生する可能性があるため、JUST名前空間 &lt;code&gt;std&lt;/code&gt; と名前空間 &lt;code&gt;std&lt;/code&gt; だけを使用することはそれほど大きな問題ではありません...</target>
        </trans-unit>
        <trans-unit id="41a6352eaeffb261dfe2d93e2ca63fc49c9ba12a" translate="yes" xml:space="preserve">
          <source>What are these &lt;em&gt;good reasons&lt;/em&gt;? Sometimes programmers explicitly want to turn off ADL, other times they want to disambiguate.</source>
          <target state="translated">これらの&lt;em&gt;良い理由&lt;/em&gt;は何ですか？ プログラマーは明示的にADLをオフにしたい場合もあれば、明確化したい場合もあります。</target>
        </trans-unit>
        <trans-unit id="ab54537830a0232c9f9d54213cf3aa6945c2396b" translate="yes" xml:space="preserve">
          <source>Whatever is true for &lt;em&gt;other&lt;/em&gt; readers of your source code is even more true for the most frequent reader of it: yourself. Come back in a year or two and take a look...</source>
          <target state="translated">ソースコードの&lt;em&gt;他の&lt;/em&gt;読者に当てはまることは何でも、最も頻繁に読む読者、つまり自分自身にさえ当てはまります。 1、2年後に戻って見てください...</target>
        </trans-unit>
        <trans-unit id="cdb77621d85047abd900bf6e655db16ba77b61bb" translate="yes" xml:space="preserve">
          <source>When you use a namespace you're risking a scenario like this, which is why people are uncomfortable using namespaces. The more things in a namespace, the greater the risk of conflict, so people might be even more uncomfortable using namespace &lt;code&gt;std&lt;/code&gt; (due to the number of things in that namespace) than other namespaces.</source>
          <target state="translated">名前空間を使用すると、このようなシナリオが発生する危険性があります。そのため、名前空間の使用は不快です。 名前空間に含まれるものが多ければ多いほど、競合のリスクが高くなるため、（その名前空間にあるものの数が原因で）名前空間 &lt;code&gt;std&lt;/code&gt; を他の名前空間よりも不快に感じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="1654c94350473966024505fd813d40c64664c782" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;using namespace std;&lt;/code&gt; considered a bad practice? Is it inefficient or does it risk declaring ambiguous variables (variables that share the same name as a function in &lt;code&gt;std&lt;/code&gt; namespace)? Does it impact performance?</source>
          <target state="translated">&lt;code&gt;using namespace std;&lt;/code&gt; 理由 悪い習慣と考えていますか？ 非効率的ですか、あいまいな変数（ &lt;code&gt;std&lt;/code&gt; 名前空間の関数と同じ名前を共有する変数）を宣言するリスクがありますか？ パフォーマンスに影響しますか？</target>
        </trans-unit>
        <trans-unit id="b584d12b92d355bff8bb0e1c7230b6bf58ecd519" translate="yes" xml:space="preserve">
          <source>Why is “using namespace std;” considered bad practice</source>
          <target state="translated">なぜ &quot;名前空間 std;を使用する&quot; は悪い習慣とみなされるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="0e30f8945d319ea0f3eeddb281fd252a6c00818b" translate="yes" xml:space="preserve">
          <source>With C++11 there is no reason to use this pattern any more. The implementation of &lt;code&gt;std::swap&lt;/code&gt; was changed to find a potential overload and choose it.</source>
          <target state="translated">C ++ 11では、このパターンを使用する理由はありません。 &lt;code&gt;std::swap&lt;/code&gt; の実装は、潜在的な過負荷を見つけてそれを選択するように変更されました。</target>
        </trans-unit>
        <trans-unit id="634192ce5da22f1caaa7b9299179cbcca7b577b9" translate="yes" xml:space="preserve">
          <source>With unqualified imported identifiers you need external search tools like &lt;em&gt;grep&lt;/em&gt; to find out where identifiers are declared. This makes reasoning about program correctness harder.</source>
          <target state="translated">修飾されていないインポートされた識別子では、識別子が宣言されている場所を見つけるために&lt;em&gt;grep&lt;/em&gt;などの外部検索ツールが必要です。 これはプログラムの正確さについての推論を難しくします。</target>
        </trans-unit>
        <trans-unit id="61b8baeb889064cf813917c7fab3baf262e3a825" translate="yes" xml:space="preserve">
          <source>You clutter the namespace you are programming in.</source>
          <target state="translated">あなたがプログラミングしている名前空間を乱雑にしています。</target>
        </trans-unit>
        <trans-unit id="3bf6425e37e04cd0a68c1fc7844787cb56ab92a8" translate="yes" xml:space="preserve">
          <source>You could write a program to do it, but wouldn't it be better to spend time working on your project itself rather than writing a program to maintain your project?</source>
          <target state="translated">そのためのプログラムを書けばいいのですが、プロジェクトを維持するためのプログラムを書くよりも、プロジェクト自体の作業に時間を割いた方がいいのではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="1a066f3f13ff76e054b645560a1597523d36beac" translate="yes" xml:space="preserve">
          <source>You may use it locally</source>
          <target state="translated">現地で使用することができます。</target>
        </trans-unit>
        <trans-unit id="1a6d9c972154f7b0a7a3e7bc908971e2acb03018" translate="yes" xml:space="preserve">
          <source>You need to be able to read code written by people who have different style and best practices opinions than you.</source>
          <target state="translated">自分とは異なるスタイルやベストプラクティスの意見を持つ人たちが書いたコードを読めるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="9e5ae30173712188975d44da3afd5fd95f0f943a" translate="yes" xml:space="preserve">
          <source>and in the implementation:</source>
          <target state="translated">と実施において。</target>
        </trans-unit>
        <trans-unit id="2b71447c7e589fd9da4e2a449318d54f8e55a2f0" translate="yes" xml:space="preserve">
          <source>as opposed to:</source>
          <target state="translated">対照的に</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
