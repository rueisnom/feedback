<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1452721">
    <body>
      <group id="1452721">
        <trans-unit id="8e0741bec52099753c6c2a0306787331f3b1bf94" translate="yes" xml:space="preserve">
          <source>&quot;Why is 'using namespace std;' considered a bad practice in C++?&quot;</source>
          <target state="translated">&quot;¿Por qué 'usar namespace std;' se considera una mala práctica en C++?&quot;</target>
        </trans-unit>
        <trans-unit id="5575dde3d3d20bdebe5e5002778dd58101ae84ae" translate="yes" xml:space="preserve">
          <source>(Sometimes) source-file-level using-directives</source>
          <target state="translated">(A veces)las directivas de uso a nivel de archivos de origen</target>
        </trans-unit>
        <trans-unit id="6a699133bca549300caca4bbc9e50a4f03f67b9e" translate="yes" xml:space="preserve">
          <source>A concrete example to clarify the concern. Imagine you have a situation where you have two libraries, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, each with their own namespace:</source>
          <target state="translated">Un ejemplo concreto para aclarar la preocupaci&amp;oacute;n. Imagine que tiene una situaci&amp;oacute;n en la que tiene dos bibliotecas, &lt;code&gt;foo&lt;/code&gt; y &lt;code&gt;bar&lt;/code&gt; , cada una con su propio espacio de nombres:</target>
        </trans-unit>
        <trans-unit id="ba3eac4e25ae1cec81af111cfd596d079e2ef4bd" translate="yes" xml:space="preserve">
          <source>A lot of &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; features are going into the C++0x standard, and Visual&amp;nbsp;Studio&amp;nbsp;2010 has a lot of C++0x features, so suddenly these programs were not compiling.</source>
          <target state="translated">Muchas caracter&amp;iacute;sticas de &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; est&amp;aacute;n entrando en el est&amp;aacute;ndar C ++ 0x, y Visual Studio 2010 tiene muchas caracter&amp;iacute;sticas de C ++ 0x, por lo que de repente estos programas no se estaban compilando.</target>
        </trans-unit>
        <trans-unit id="39f8e6781daf6a934001f51f44614f546e42a1e3" translate="yes" xml:space="preserve">
          <source>A namespace is a named scope. Namespaces are used to group related declarations and to keep separate
items separate. For example, two separately developed libraries may use the same name to refer to different
items, but a user can still use both:</source>
          <target state="translated">Un espacio de nombres es un ámbito de nombres.Los espacios de nombres se utilizan para agrupar declaraciones relacionadas y para mantener separados los elementos.Por ejemplo,dos bibliotecas desarrolladas por separado pueden utilizar el mismo nombre para referirse a elementos diferentes,pero un usuario puede seguir utilizando ambos:</target>
        </trans-unit>
        <trans-unit id="8a340e0ae7fed0a2d743f95465081c70d0cb841d" translate="yes" xml:space="preserve">
          <source>A using-declaration:</source>
          <target state="translated">Una declaración de uso:</target>
        </trans-unit>
        <trans-unit id="b82a662dae5884212abc04bb506affe12b0328ae" translate="yes" xml:space="preserve">
          <source>Although the statement saves us from typing std:: whenever
  we wish to access a class or type defined in the std namespace, it
  imports the entirety of the std namespace into the current namespace
  of the program. Let us take a few examples to understand why this
  might not be such a good thing</source>
          <target state="translated">Aunque la declaración nos ahorra tener que teclear std::siempre que queramos acceder a una clase o tipo definido en el espacio de nombres std,importa la totalidad del espacio de nombres std en el espacio de nombres actual del programa.Tomemos algunos ejemplos para entender por qué esto podría no ser tan bueno</target>
        </trans-unit>
        <trans-unit id="2b00151385441b68225fc4658924e46453d8ec93" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;using namespace std&lt;/code&gt; throws a compilation error because of the ambiguity of count, which is also a function in algorithm library.</source>
          <target state="translated">Un ejemplo en el que el &lt;code&gt;using namespace std&lt;/code&gt; arroja un error de compilaci&amp;oacute;n debido a la ambig&amp;uuml;edad del recuento, que tambi&amp;eacute;n es una funci&amp;oacute;n en la biblioteca de algoritmos.</target>
        </trans-unit>
        <trans-unit id="235c5c438cb46b535c12595279d731d5b7716a5d" translate="yes" xml:space="preserve">
          <source>An idiom for using it locally</source>
          <target state="translated">Un modismo para usarlo localmente</target>
        </trans-unit>
        <trans-unit id="0fbb0cc023270ff0740fd1bead3e7a7d083f3415" translate="yes" xml:space="preserve">
          <source>And as for making Boost's regex part of &lt;code&gt;std&lt;/code&gt;. I do that for future integration and &amp;ndash; again, I admit fully this is bias - I don't think it is as ugly as &lt;code&gt;boost::regex:: ...&lt;/code&gt;. Indeed, that is another thing for me. There are many things in C++ that I still have yet to come to fully accept in looks and methods (another example: variadic templates versus var arguments [though I admit variadic templates are very very useful!]). Even those that I do accept it was difficult, &lt;em&gt;and&lt;/em&gt; I still have issues with them.</source>
          <target state="translated">Y en cuanto a hacer que la expresi&amp;oacute;n regular de Boost sea parte de la &lt;code&gt;std&lt;/code&gt; . Hago eso para la integraci&amp;oacute;n futura y, nuevamente, admito que esto es parcial, no creo que sea tan feo como &lt;code&gt;boost::regex:: ...&lt;/code&gt; De hecho, eso es otra cosa para m&amp;iacute;. Hay muchas cosas en C ++ que todav&amp;iacute;a tengo que aceptar completamente en miradas y m&amp;eacute;todos (otro ejemplo: plantillas variadas versus argumentos var [&amp;iexcl;aunque admito que las plantillas variadas son muy, muy &amp;uacute;tiles!]). Incluso aquellos que s&amp;iacute; acepto fueron dif&amp;iacute;ciles, &lt;em&gt;y&lt;/em&gt; todav&amp;iacute;a tengo problemas con ellos.</target>
        </trans-unit>
        <trans-unit id="3aa9fcea2af1d01ac1dbb4efe366442a34d014fe" translate="yes" xml:space="preserve">
          <source>And see &lt;a href=&quot;https://www.sololearn.com/Discuss/187690/is-using-namespace-std-a-bad-practice/&quot;&gt;this opinion&lt;/a&gt;:</source>
          <target state="translated">Y mira &lt;a href=&quot;https://www.sololearn.com/Discuss/187690/is-using-namespace-std-a-bad-practice/&quot;&gt;esta opini&amp;oacute;n&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0fecfa228c906cdbaa2a5ef28640a1b52d83c4df" translate="yes" xml:space="preserve">
          <source>Another reason is surprise.</source>
          <target state="translated">Otra razón es la sorpresa.</target>
        </trans-unit>
        <trans-unit id="9d1dee9a88dd2bd4cb378802f7b802ac8d01b036" translate="yes" xml:space="preserve">
          <source>As is mentioned in this &lt;a href=&quot;https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/&quot;&gt;page&lt;/a&gt;:</source>
          <target state="translated">Como se menciona en esta &lt;a href=&quot;https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/&quot;&gt;p&amp;aacute;gina&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e1ea5cc086ad8c105f0de7b7b2d957c6908d8ceb" translate="yes" xml:space="preserve">
          <source>As it is, I am still very biased towards C and biased against C++. Sparing details, much of what I work on fits C more (but it was a good exercise and a good way to make myself a. learn another language and b. try not be less biased against object/classes/etc which is maybe better stated as less closed-minded, less arrogant, and more accepting.). But what &lt;em&gt;is&lt;/em&gt; useful is what some already suggested: I do indeed use list (it is fairly generic, is it not ?), and sort (same thing) to name two that would cause a name clash if I were to do &lt;code&gt;using namespace std;&lt;/code&gt;, and so to that end I prefer being specific, in control and knowing that if I intend it to be the standard use then I will have to specify it. Put simply: no assuming allowed.</source>
          <target state="translated">Tal como est&amp;aacute;n las cosas, todav&amp;iacute;a estoy muy sesgado hacia C y hacia C ++. Ahorrando detalles, mucho de lo que trabajo encaja m&amp;aacute;s en C (pero fue un buen ejercicio y una buena manera de hacerme a. Aprender otro idioma yb. Tratar de no estar menos predispuesto contra el objeto / clases / etc., lo que tal vez sea mejor dicho como menos cerrado de mente, menos arrogante y m&amp;aacute;s tolerante). Pero lo que &lt;em&gt;es&lt;/em&gt; &amp;uacute;til es lo que algunos ya sugirieron: de hecho uso la lista (es bastante gen&amp;eacute;rica, &amp;iquest;no es as&amp;iacute;?), Y ordeno (lo mismo) para nombrar dos que causar&amp;iacute;an un choque de nombres si lo hiciera &lt;code&gt;using namespace std;&lt;/code&gt; , y por eso prefiero ser espec&amp;iacute;fico, tener el control y saber que si pretendo que sea el uso est&amp;aacute;ndar, tendr&amp;eacute; que especificarlo. En pocas palabras: no se permite suponer.</target>
        </trans-unit>
        <trans-unit id="a951ab665371162929ad7cc1021e7f306c09ca5a" translate="yes" xml:space="preserve">
          <source>At this point everything is fine. When you run your program it 'Does something'. But later you update &lt;code&gt;bar&lt;/code&gt; and let's say it has changed to be like:</source>
          <target state="translated">En este punto todo est&amp;aacute; bien. Cuando ejecuta su programa, &quot;hace algo&quot;. Pero luego actualiza la &lt;code&gt;bar&lt;/code&gt; ra y digamos que ha cambiado para ser as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="9cd966c7ceb5c8bf6d8a1e601c36928bf783b349" translate="yes" xml:space="preserve">
          <source>At this point you'll get a compiler error:</source>
          <target state="translated">En este punto obtendrá un error de compilación:</target>
        </trans-unit>
        <trans-unit id="62f3b54904071c98839a53723f5cac8dbd3c6262" translate="yes" xml:space="preserve">
          <source>At this point your call to &lt;code&gt;a(42)&lt;/code&gt; suddenly binds to &lt;code&gt;bar::a&lt;/code&gt; instead of &lt;code&gt;foo::a&lt;/code&gt; and instead of doing 'something' it does 'something completely different'.  No compiler warning or anything. Your program just silently starts doing something complete different than before.</source>
          <target state="translated">En este punto, su llamada a &lt;code&gt;a(42)&lt;/code&gt; repente se une a &lt;code&gt;bar::a&lt;/code&gt; lugar de &lt;code&gt;foo::a&lt;/code&gt; y en lugar de hacer 'algo' hace 'algo completamente diferente'. No hay advertencia del compilador ni nada. Su programa comienza silenciosamente a hacer algo completamente diferente que antes.</target>
        </trans-unit>
        <trans-unit id="36dab49377a029cf015f76cbd70a8bead781a8f1" translate="yes" xml:space="preserve">
          <source>Besides that, you can have namespace aliases. Here is an example of where it is useful that might not have been referred to. I use the C++11 standard and specifically with libstdc++. Well, it doesn't have complete &lt;code&gt;std::regex&lt;/code&gt; support. Sure, it compiles, but it throws an exception along the lines of it being an error on the programmer's end. But it is lack of implementation.</source>
          <target state="translated">Adem&amp;aacute;s de eso, puede tener alias de espacio de nombres. Aqu&amp;iacute; hay un ejemplo de d&amp;oacute;nde es &amp;uacute;til que podr&amp;iacute;a no haber sido mencionado. Uso el est&amp;aacute;ndar C ++ 11 y espec&amp;iacute;ficamente con libstdc ++. Bueno, no tiene soporte completo para &lt;code&gt;std::regex&lt;/code&gt; . Claro, se compila, pero arroja una excepci&amp;oacute;n en el sentido de que es un error al final del programador. Pero es falta de implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8b819cb9c25c847eca882b7f61088fcf30ea9024" translate="yes" xml:space="preserve">
          <source>Beware that some people disagree with my saying &quot;feel free&quot; like this -- because although a &lt;code&gt;using&lt;/code&gt; statement in a cpp file is &lt;em&gt;better&lt;/em&gt; than in a header (because it doesn't affect people who include your header file), they think it's still not &lt;em&gt;good&lt;/em&gt; (because depending on the code it could make the implementation of the class more difficult to maintain). &lt;a href=&quot;https://isocpp.org/wiki/faq/coding-standards#using-namespace-std&quot;&gt;This C++ Super-FAQ entry&lt;/a&gt; says,</source>
          <target state="translated">Tenga en cuenta que algunas personas no est&amp;aacute;n de acuerdo con mi dicho &quot;si&amp;eacute;ntase libre&quot; de esta manera, porque aunque una declaraci&amp;oacute;n de &lt;code&gt;using&lt;/code&gt; en un archivo cpp es &lt;em&gt;mejor&lt;/em&gt; que en un encabezado (porque no afecta a las personas que incluyen su archivo de encabezado), creen que todav&amp;iacute;a no es &lt;em&gt;bueno&lt;/em&gt; (porque dependiendo del c&amp;oacute;digo podr&amp;iacute;a dificultar el mantenimiento de la implementaci&amp;oacute;n de la clase). &lt;a href=&quot;https://isocpp.org/wiki/faq/coding-standards#using-namespace-std&quot;&gt;Esta entrada de C ++ Super-FAQ&lt;/a&gt; dice:</target>
        </trans-unit>
        <trans-unit id="3bd225512cee60fc69de0a0f917ae67552b94c49" translate="yes" xml:space="preserve">
          <source>Bottom line: Explicitly prefixing everything doesn't do any harm, takes very little getting used to, and has objective advantages. In particular, it makes the code easier to interpret by the compiler and by human readers &amp;mdash; and that should probably be the main goal when writing code.</source>
          <target state="translated">En pocas palabras: el prefijo expl&amp;iacute;cito de todo no hace da&amp;ntilde;o, toma muy poco tiempo acostumbrarse y tiene ventajas objetivas. En particular, hace que el c&amp;oacute;digo sea m&amp;aacute;s f&amp;aacute;cil de interpretar por el compilador y por los lectores humanos, y ese probablemente deber&amp;iacute;a ser el objetivo principal al escribir el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="984d1515ce54fb1acb235d14e03bcd7545ccca8f" translate="yes" xml:space="preserve">
          <source>But imagine an alternative scenario where bar changed instead to look like this instead:</source>
          <target state="translated">Pero imagina un escenario alternativo en el que la barra cambiara en lugar de parecerse a esto:</target>
        </trans-unit>
        <trans-unit id="bd243da61bc83e255c691b0eeb1676f5cf315d17" translate="yes" xml:space="preserve">
          <source>Consider</source>
          <target state="translated">Consider</target>
        </trans-unit>
        <trans-unit id="0fde436f316d9e7c2c1244b279c7df1ee1b8459d" translate="yes" xml:space="preserve">
          <source>Consider e.g. writing a piece of numerical software. Why would I even consider polluting my global namespace by cutting general &quot;std::vector&quot; down to &quot;vector&quot; when &quot;vector&quot; is one of the problem domain's most important concepts?</source>
          <target state="translated">Considere,por ejemplo,la posibilidad de escribir una pieza de software numérico.¿Por qué consideraría siquiera la posibilidad de contaminar mi espacio de nombres mundial cortando el &quot;std::vector&quot; general a &quot;vector&quot; cuando &quot;vector&quot; es uno de los conceptos más importantes del dominio del problema?</target>
        </trans-unit>
        <trans-unit id="4f260645290a8d4cc5baf50a62bc1e04d3f4c8a3" translate="yes" xml:space="preserve">
          <source>Corollary: In header files, don&amp;rsquo;t write namespace-level using directives or using declarations; instead, explicitly namespace-qualify all names. (The second rule follows from the first, because headers can never know what other header #includes might appear after them.)</source>
          <target state="translated">Corolario: en los archivos de encabezado, no escriba el nivel del espacio de nombres usando directivas o declaraciones; en su lugar, expl&amp;iacute;citamente el espacio de nombres califica todos los nombres. (La segunda regla se desprende de la primera, porque los encabezados nunca pueden saber qu&amp;eacute; otro encabezado #incluye podr&amp;iacute;a aparecer despu&amp;eacute;s de ellos).</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="b28c908712aa3b3c4f2721161a98d4f73d39f13a" translate="yes" xml:space="preserve">
          <source>Do not use it globally</source>
          <target state="translated">No lo utilice a nivel mundial</target>
        </trans-unit>
        <trans-unit id="b10099eb72109a24775417ddca5bf1c65d8e36bc" translate="yes" xml:space="preserve">
          <source>Everything works fine, and you can call &lt;code&gt;Blah()&lt;/code&gt; from Foo and &lt;code&gt;Quux()&lt;/code&gt; from Bar without problems. But one day you upgrade to a new version of Foo 2.0, which now offers a function called &lt;code&gt;Quux()&lt;/code&gt;. Now you've got a conflict: Both Foo 2.0 and Bar import &lt;code&gt;Quux()&lt;/code&gt; into your global namespace. This is going to take some effort to fix, especially if the function parameters happen to match.</source>
          <target state="translated">Todo funciona bien, y puedes llamar a &lt;code&gt;Blah()&lt;/code&gt; desde Foo y &lt;code&gt;Quux()&lt;/code&gt; desde Bar sin problemas. Pero un d&amp;iacute;a se actualiza a una nueva versi&amp;oacute;n de Foo 2.0, que ahora ofrece una funci&amp;oacute;n llamada &lt;code&gt;Quux()&lt;/code&gt; . Ahora tiene un conflicto: tanto Foo 2.0 como Bar importan &lt;code&gt;Quux()&lt;/code&gt; en su espacio de nombres global. Esto requerir&amp;aacute; un esfuerzo para solucionarlo, especialmente si los par&amp;aacute;metros de la funci&amp;oacute;n coinciden.</target>
        </trans-unit>
        <trans-unit id="7fdc8f5263841efbcae18f9750a704ca266369d1" translate="yes" xml:space="preserve">
          <source>Experienced programmers also try to avoid full qualification of names inside their source files. A minor reason for this is that it's not elegant to write more code when less code is sufficient &lt;em&gt;unless there are good reasons&lt;/em&gt;. A major reason for this is turning off argument-dependent lookup (ADL).</source>
          <target state="translated">Los programadores experimentados tambi&amp;eacute;n intentan evitar la calificaci&amp;oacute;n completa de los nombres dentro de sus archivos fuente. Una raz&amp;oacute;n menor para esto es que no es elegante escribir m&amp;aacute;s c&amp;oacute;digo cuando menos c&amp;oacute;digo es suficiente a &lt;em&gt;menos que haya buenas razones&lt;/em&gt; . Una raz&amp;oacute;n importante para esto es desactivar la b&amp;uacute;squeda dependiente de argumentos (ADL).</target>
        </trans-unit>
        <trans-unit id="40fc3dd2e604ebb2070a1b8a0000705b0f996fcf" translate="yes" xml:space="preserve">
          <source>Experienced programmers use whatever solves their problems and avoid whatever creates new problems, and they avoid header-file-level using-directives for this exact reason.</source>
          <target state="translated">Los programadores experimentados usan lo que sea que resuelva sus problemas y evitan lo que cree nuevos problemas,y evitan las directivas de uso a nivel de archivos de cabecera por esta misma razón.</target>
        </trans-unit>
        <trans-unit id="a7f84ccc694c5225483eb04c03fd8a8b7d981149" translate="yes" xml:space="preserve">
          <source>For example, if I type in, &lt;code&gt;using namespace std;&lt;/code&gt; and &lt;code&gt;using namespace otherlib;&lt;/code&gt; and type just &lt;code&gt;cout&lt;/code&gt; (which happens to be in both), rather than &lt;code&gt;std::cout&lt;/code&gt; (or &lt;code&gt;'otherlib::cout'&lt;/code&gt;), you might use the wrong one, and get errors. It's much more effective and efficient to use &lt;code&gt;std::cout&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, si escribo, &lt;code&gt;using namespace std;&lt;/code&gt; y &lt;code&gt;using namespace otherlib;&lt;/code&gt; y escriba solo &lt;code&gt;cout&lt;/code&gt; (que est&amp;aacute; en ambos), en lugar de &lt;code&gt;std::cout&lt;/code&gt; (u &lt;code&gt;'otherlib::cout'&lt;/code&gt; ), puede usar el incorrecto y obtener errores. Es mucho m&amp;aacute;s efectivo y eficiente usar &lt;code&gt;std::cout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f92e531886e10c1956f1cd4ead46fd24e7ec5ba4" translate="yes" xml:space="preserve">
          <source>From my experiences, if you have multiple libraries that uses say, &lt;code&gt;cout&lt;/code&gt;, but for a different purpose you may use the wrong &lt;code&gt;cout&lt;/code&gt;.</source>
          <target state="translated">Seg&amp;uacute;n mi experiencia, si tiene varias bibliotecas que usan say, &lt;code&gt;cout&lt;/code&gt; , pero para un prop&amp;oacute;sito diferente, puede usar el &lt;code&gt;cout&lt;/code&gt; incorrecto.</target>
        </trans-unit>
        <trans-unit id="dc4a2e1c6384a6c0bca9221545adb77b689f41f1" translate="yes" xml:space="preserve">
          <source>Function-level using-directives and using-declarations inside functions' implementations</source>
          <target state="translated">Las directivas de uso a nivel de función y las declaraciones de uso dentro de las implementaciones de las funciones</target>
        </trans-unit>
        <trans-unit id="e754f634964b71e89733cd919482e9f7c6dc7fd0" translate="yes" xml:space="preserve">
          <source>Go ahead and use it locally (almost) freely. This, of course, prevents you from repetition of &lt;code&gt;std::&lt;/code&gt; -- and repetition is also bad.</source>
          <target state="translated">Contin&amp;uacute;e y util&amp;iacute;celo localmente (casi) libremente. Esto, por supuesto, le impide repetir &lt;code&gt;std::&lt;/code&gt; - y la repetici&amp;oacute;n tambi&amp;eacute;n es mala.</target>
        </trans-unit>
        <trans-unit id="a13b7ac34e7f5b5ed26674ea84e218245208110c" translate="yes" xml:space="preserve">
          <source>Here's one more data point: Many, many years ago, I also used to find it annoying having to prefix everything from the standard library with &lt;code&gt;std::&lt;/code&gt;. Then I worked in a project where it was decided at the start that both &lt;code&gt;using&lt;/code&gt; directives and declarations are banned except for function scopes. Guess what? It took most of us very few weeks to get used to writing the prefix, and after a few more weeks most of us even agreed that it actually made the code &lt;em&gt;more readable&lt;/em&gt;. There's a reason for that: &lt;strong&gt;&lt;em&gt;Whether you like shorter or longer prose is subjective, but the prefixes objectively add clarity to the code.&lt;/em&gt;&lt;/strong&gt; Not only the compiler, but you, too, find it easier to see which identifier is referred to.</source>
          <target state="translated">Aqu&amp;iacute; hay un punto de datos m&amp;aacute;s: Hace muchos, muchos a&amp;ntilde;os, tambi&amp;eacute;n me resultaba molesto tener que prefijar todo desde la biblioteca est&amp;aacute;ndar con &lt;code&gt;std::&lt;/code&gt; . Luego trabaj&amp;eacute; en un proyecto en el que se decidi&amp;oacute; al principio que tanto el &lt;code&gt;using&lt;/code&gt; directivas como las declaraciones est&amp;aacute;n prohibidas, excepto para los &amp;aacute;mbitos de funciones. &amp;iquest;Adivina qu&amp;eacute;? A la mayor&amp;iacute;a de nosotros nos tom&amp;oacute; muy pocas semanas acostumbrarnos a escribir el prefijo, y despu&amp;eacute;s de algunas semanas m&amp;aacute;s, la mayor&amp;iacute;a de nosotros incluso acordamos que en realidad hizo que el c&amp;oacute;digo fuera &lt;em&gt;m&amp;aacute;s legible&lt;/em&gt; . Hay una raz&amp;oacute;n para eso: &lt;strong&gt;&lt;em&gt;si le gusta la prosa m&amp;aacute;s corta o m&amp;aacute;s larga es subjetiva, pero los prefijos agregan objetivamente claridad al c&amp;oacute;digo.&lt;/em&gt;&lt;/strong&gt; No solo el compilador, sino tambi&amp;eacute;n a usted, le resulta m&amp;aacute;s f&amp;aacute;cil ver a qu&amp;eacute; identificador se hace referencia.</target>
        </trans-unit>
        <trans-unit id="14cd4a9b5c57786c9dcc406fd5351f54c74541d7" translate="yes" xml:space="preserve">
          <source>Horses for courses - manage your complexity how you best can and feel able.</source>
          <target state="translated">Caballos para los cursos-manejar su complejidad de la mejor manera posible y sentirse capaz.</target>
        </trans-unit>
        <trans-unit id="b6059ce195c06e6a8d7d2780b75b1844645eec62" translate="yes" xml:space="preserve">
          <source>However, if I often use 'cout' and 'cin', I write: &lt;code&gt;using std::cout; using std::cin;&lt;/code&gt; in the .cpp file (never in the header file as it propagates with &lt;code&gt;#include&lt;/code&gt;). I think that no one sane will ever name a stream &lt;code&gt;cout&lt;/code&gt; or &lt;code&gt;cin&lt;/code&gt;. ;)</source>
          <target state="translated">Sin embargo, si uso a menudo 'cout' y 'cin', escribo: &lt;code&gt;using std::cout; using std::cin;&lt;/code&gt; usando std :: cin; en el archivo .cpp (nunca en el archivo de encabezado ya que se propaga con &lt;code&gt;#include&lt;/code&gt; ). Creo que nadie cuerdo nunca nombrar&amp;aacute; un &lt;code&gt;cout&lt;/code&gt; de stream o &lt;code&gt;cin&lt;/code&gt; . ;)</target>
        </trans-unit>
        <trans-unit id="2250f701130cc7a3863ada4af431ecaea750adc9" translate="yes" xml:space="preserve">
          <source>However, you may feel free to put a using statement in your (private) *.cpp files.</source>
          <target state="translated">Sin embargo,puede sentirse libre de poner una declaración de uso en sus archivos (privados)*.cpp.</target>
        </trans-unit>
        <trans-unit id="b8fafbc70aedce2fc77deabe47f1e309ea3f997a" translate="yes" xml:space="preserve">
          <source>I agree that it should not be used globally, but it's not so evil to use locally, like in a &lt;code&gt;namespace&lt;/code&gt;. Here's an example from &lt;em&gt;&quot;The C++ Programming Language&quot;&lt;/em&gt;:</source>
          <target state="translated">Estoy de acuerdo en que no debe usarse globalmente, pero no es tan malo usarlo localmente, como en un &lt;code&gt;namespace&lt;/code&gt; . Aqu&amp;iacute; hay un ejemplo de &lt;em&gt;&quot;El lenguaje de programaci&amp;oacute;n C ++&quot;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b957aa59d52d23ef4bc9ed842310ade7ee82aeff" translate="yes" xml:space="preserve">
          <source>I agree with everything &lt;a href=&quot;https://stackoverflow.com/questions/1452721/1452738#1452738&quot;&gt;Greg wrote&lt;/a&gt;, but I'd like to add: &lt;strong&gt;&lt;em&gt;It can even get worse than Greg said!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">Estoy de acuerdo con todo lo que &lt;a href=&quot;https://stackoverflow.com/questions/1452721/1452738#1452738&quot;&gt;Greg escribi&amp;oacute;&lt;/a&gt; , pero me gustar&amp;iacute;a agregar: &lt;strong&gt;&lt;em&gt;&amp;iexcl;Incluso puede empeorar m&amp;aacute;s de lo que Greg dijo!&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3806b9230c26bc35f5387e9568e05e858aa6bb5a" translate="yes" xml:space="preserve">
          <source>I agree with others &amp;ndash; it is asking for name clashes, ambiguities and then the fact is it is less explicit. While I can see the use of &lt;code&gt;using&lt;/code&gt;, my personal preference is to limit it. I would also strongly consider what some others pointed out:</source>
          <target state="translated">Estoy de acuerdo con los dem&amp;aacute;s: est&amp;aacute; pidiendo conflictos de nombres, ambig&amp;uuml;edades y el hecho es que es menos expl&amp;iacute;cito. Si bien puedo ver el uso del &lt;code&gt;using&lt;/code&gt; , mi preferencia personal es limitarlo. Tambi&amp;eacute;n considerar&amp;iacute;a fuertemente lo que otros se&amp;ntilde;alaron:</target>
        </trans-unit>
        <trans-unit id="de2e7022c8f014a2e70b1ef6b6313df62304adae" translate="yes" xml:space="preserve">
          <source>I agree with the others here, but I would like to address the concerns regarding readability - you can avoid all of that by simply using typedefs at the top of your file, function or class declaration.</source>
          <target state="translated">Estoy de acuerdo con los demás,pero me gustaría abordar las preocupaciones relativas a la legibilidad-se puede evitar todo eso con el simple uso de typedefs en la parte superior de su archivo,función o declaración de clase.</target>
        </trans-unit>
        <trans-unit id="1763537fa947e39d61c79dbb27ae0c8d2955d02f" translate="yes" xml:space="preserve">
          <source>I also consider it a bad practice. Why? Just one day I thought that the function of a namespace is to divide stuff, so I shouldn't spoil it with throwing everything into one global bag.</source>
          <target state="translated">También lo considero una mala práctica.¿Por qué? Un día pensé que la función de un espacio de nombres es dividir las cosas,así que no debería estropearlo tirándolo todo en una bolsa global.</target>
        </trans-unit>
        <trans-unit id="de6cf10d0eaf9e11a0c6a2571f7cee7c4459b91d" translate="yes" xml:space="preserve">
          <source>I do not think it is necessarily bad practice under all conditions, but you need to be careful when you use it.  If you're writing a library, you probably should use the scope resolution operators with the namespace to keep your library from butting heads with other libraries.  For application level code, I don't see anything wrong with it.</source>
          <target state="translated">No creo que sea necesariamente una mala práctica en todas las condiciones,pero hay que tener cuidado cuando se usa.Si estás escribiendo una biblioteca,probablemente deberías usar los operadores de resolución de alcance con el espacio de nombres para evitar que tu biblioteca se meta con otras bibliotecas.Para el código de nivel de aplicación,no veo nada malo en ello.</target>
        </trans-unit>
        <trans-unit id="d5080a2a4a2beb8872491aa265a231ea1ed16674" translate="yes" xml:space="preserve">
          <source>I mean really... saying &quot;don't rely on this being present&quot; is just setting you up to rely on it NOT being present.  You are constantly going to have issues borrowing code snippets and constantly repairing them.  Just keep your user-defined and borrowed stuff in limited scope as they should be and be VERY sparing with globals (honestly globals should almost always be a last resort for purposes of &quot;compile now, sanity later&quot;). Truly I think it is bad advice from your teacher because using std will work for both &quot;cout&quot; and &quot;std::cout&quot; but NOT using std will only work for &quot;std::cout&quot;.  You will not always be fortunate enough to write all your own code.</source>
          <target state="translated">Quiero decir realmente...decir &quot;no confíes en que esto esté presente&quot; es sólo configurarte para que confíes en que NO esté presente.Constantemente vas a tener problemas pidiendo prestados fragmentos de código y reparándolos constantemente.Sólo mantén tus cosas definidas por el usuario y prestadas en un ámbito limitado como debe ser y sé MUY parco con los globales (honestamente,los globales casi siempre deberían ser el último recurso para propósitos de &quot;compilar ahora,cordura después&quot;).En verdad creo que es un mal consejo de tu profesor porque usar std funcionará tanto para &quot;cout&quot; como para &quot;std::cout&quot; pero NO usar std sólo funcionará para &quot;std::cout&quot;.No siempre tendrás la suerte de escribir tu propio código.</target>
        </trans-unit>
        <trans-unit id="f75a67cd99e9c9fbf6abd8a8f84e205de1d5a8c2" translate="yes" xml:space="preserve">
          <source>I put it the other way around: Why is typing five extra characters considered cumbersome by some?</source>
          <target state="translated">Lo puse al revés:¿Por qué escribir cinco caracteres extra es considerado incómodo por algunos?</target>
        </trans-unit>
        <trans-unit id="315d92e4893f10fb88044d2ccdcfc00fb3e343d7" translate="yes" xml:space="preserve">
          <source>I recently ran into a complaint about &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2010&lt;/a&gt;. It turned out that pretty much all the source files had these two lines:</source>
          <target state="translated">Recientemente me encontr&amp;eacute; con una queja sobre &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010&quot;&gt;Visual Studio 2010&lt;/a&gt; . Result&amp;oacute; que casi todos los archivos fuente ten&amp;iacute;an estas dos l&amp;iacute;neas:</target>
        </trans-unit>
        <trans-unit id="8441eb391ffa1ac35a213cb285d116689923e4e3" translate="yes" xml:space="preserve">
          <source>I usually use it in my class declaration as methods in a class tend to deal with similar data types (the members) and a typedef is an opportunity to assign a name that is meaningful in the context of the class. This actually aids readability in the definitions of the class methods.</source>
          <target state="translated">Normalmente lo utilizo en mi declaración de clase,ya que los métodos de una clase tienden a tratar tipos de datos similares (los miembros)y un tipedef es una oportunidad para asignar un nombre que sea significativo en el contexto de la clase.Esto realmente ayuda a la legibilidad en las definiciones de los métodos de la clase.</target>
        </trans-unit>
        <trans-unit id="ae395c81a97e21bacfb9359546bf7289ddc3c88b" translate="yes" xml:space="preserve">
          <source>I won't argue on whether that is a bad idea or not. I will however argue that it keeps it clean for &lt;em&gt;my&lt;/em&gt; project and at the same time makes it specific: True, I have to use Boost, &lt;em&gt;but&lt;/em&gt; I'm using it like the libstdc++ will eventually have it. Yes, starting your own project and starting with a standard (...) at the very beginning goes a very long way with helping maintenance, development and everything involved with the project!</source>
          <target state="translated">No discutir&amp;eacute; si es una mala idea o no. Sin embargo, argumentar&amp;eacute; que lo mantiene limpio para &lt;em&gt;mi&lt;/em&gt; proyecto y al mismo tiempo lo hace espec&amp;iacute;fico: es cierto, tengo que usar Boost, &lt;em&gt;pero&lt;/em&gt; lo estoy utilizando como libstdc ++ eventualmente lo tendr&amp;aacute;. S&amp;iacute;, comenzar su propio proyecto y comenzar con un est&amp;aacute;ndar (...) desde el principio ayuda mucho al mantenimiento, el desarrollo y todo lo relacionado con el proyecto.</target>
        </trans-unit>
        <trans-unit id="19e234fd1ffb5551c9bacc76444a0745a8b46a07" translate="yes" xml:space="preserve">
          <source>I've been told by others that writing &lt;code&gt;using namespace std;&lt;/code&gt; in code is wrong, and that I should use &lt;code&gt;std::cout&lt;/code&gt; and &lt;code&gt;std::cin&lt;/code&gt; directly instead.</source>
          <target state="translated">Otros me han dicho que escribir &lt;code&gt;using namespace std;&lt;/code&gt; en el c&amp;oacute;digo est&amp;aacute; mal, y que deber&amp;iacute;a usar &lt;code&gt;std::cout&lt;/code&gt; y &lt;code&gt;std::cin&lt;/code&gt; directamente en su lugar.</target>
        </trans-unit>
        <trans-unit id="091066152480cd6d7ec51ddc1f6d09610b9d55a1" translate="yes" xml:space="preserve">
          <source>If I see &lt;code&gt;cout &amp;lt;&amp;lt; blah&lt;/code&gt;, instead of &lt;code&gt;std::cout &amp;lt;&amp;lt; blah&lt;/code&gt; I think: What is this &lt;code&gt;cout&lt;/code&gt;? Is it the normal &lt;code&gt;cout&lt;/code&gt;? Is it something special?</source>
          <target state="translated">Si veo &lt;code&gt;cout &amp;lt;&amp;lt; blah&lt;/code&gt; , en lugar de &lt;code&gt;std::cout &amp;lt;&amp;lt; blah&lt;/code&gt; , pienso: &amp;iquest;Qu&amp;eacute; es este &lt;code&gt;cout&lt;/code&gt; ? &amp;iquest;Es la &lt;code&gt;cout&lt;/code&gt; normal? &amp;iquest;Es algo especial?</target>
        </trans-unit>
        <trans-unit id="5a9372cdbb50764ea955811dd61572f65ed573bd" translate="yes" xml:space="preserve">
          <source>If all the standard stuff is in its own namespace you don't have to worry about name collisions with your code or other libraries.</source>
          <target state="translated">Si todo el material estándar está en su propio espacio de nombres,no tienes que preocuparte por las colisiones de nombres con tu código u otras bibliotecas.</target>
        </trans-unit>
        <trans-unit id="05bbbb5c87545d8ed21bba66dec5dbe3cf4e541d" translate="yes" xml:space="preserve">
          <source>If you consider this unlikely: There was &lt;a href=&quot;https://stackoverflow.com/a/2712125/140719&quot;&gt;a question asked&lt;/a&gt; here on Stack Overflow where pretty much exactly this happened (wrong function called due to omitted &lt;code&gt;std::&lt;/code&gt; prefix) about half a year after I gave this answer. &lt;a href=&quot;https://stackoverflow.com/questions/13402789/&quot;&gt;Here&lt;/a&gt; is another, more recent example of such a question.
So this is a real problem.</source>
          <target state="translated">Si considera que esto es improbable: se hizo &lt;a href=&quot;https://stackoverflow.com/a/2712125/140719&quot;&gt;una pregunta&lt;/a&gt; aqu&amp;iacute; en Stack Overflow donde sucedi&amp;oacute; m&amp;aacute;s o menos exactamente (funci&amp;oacute;n incorrecta llamada debido a la &lt;code&gt;std::&lt;/code&gt; prefijo std : :) aproximadamente medio a&amp;ntilde;o despu&amp;eacute;s de que di esta respuesta. &lt;a href=&quot;https://stackoverflow.com/questions/13402789/&quot;&gt;Aqu&amp;iacute;&lt;/a&gt; hay otro ejemplo m&amp;aacute;s reciente de tal pregunta. Entonces este es un problema real.</target>
        </trans-unit>
        <trans-unit id="883b59bb138a2b98dd2f53050ba718757c60f448" translate="yes" xml:space="preserve">
          <source>If you do &lt;em&gt;not&lt;/em&gt; have that overload the compiler will use &lt;code&gt;void std::swap(Child&amp;amp;,Child&amp;amp;)&lt;/code&gt; and try its best swapping these.</source>
          <target state="translated">Si &lt;em&gt;no&lt;/em&gt; tiene esa sobrecarga, el compilador usar&amp;aacute; &lt;code&gt;void std::swap(Child&amp;amp;,Child&amp;amp;)&lt;/code&gt; e intentar&amp;aacute; intercambiarlos.</target>
        </trans-unit>
        <trans-unit id="81009c04e328b3a3b5aadc7fe747aad2c2287d54" translate="yes" xml:space="preserve">
          <source>If you had used &lt;code&gt;foo::Blah()&lt;/code&gt; and &lt;code&gt;bar::Quux()&lt;/code&gt;, then the introduction of &lt;code&gt;foo::Quux()&lt;/code&gt; would have been a non-event.</source>
          <target state="translated">Si hubiera utilizado &lt;code&gt;foo::Blah()&lt;/code&gt; y &lt;code&gt;bar::Quux()&lt;/code&gt; , entonces la introducci&amp;oacute;n de &lt;code&gt;foo::Quux()&lt;/code&gt; no habr&amp;iacute;a sido un evento.</target>
        </trans-unit>
        <trans-unit id="d31c157553e55cd020a04b1f31d6a0bd553ab83f" translate="yes" xml:space="preserve">
          <source>If you have an overload &lt;code&gt;void swap(Child&amp;amp;, Child&amp;amp;)&lt;/code&gt; implemented the compiler will choose it.</source>
          <target state="translated">Si tiene una sobrecarga &lt;code&gt;void swap(Child&amp;amp;, Child&amp;amp;)&lt;/code&gt; implementada, el compilador la elegir&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="6cfd5241c3ace598230b440bf15ea476ef327fab" translate="yes" xml:space="preserve">
          <source>If you import the right header files you suddenly have names like &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/hex&quot;&gt;&lt;code&gt;hex&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/left&quot;&gt;&lt;code&gt;left&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/functional/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; in your global scope. This might be surprising if you are not aware that &lt;code&gt;std::&lt;/code&gt; contains these names. If you also try to use these names locally it can lead to quite some confusion.</source>
          <target state="translated">Si importa los archivos de encabezado derecho, de repente tiene nombres como &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/hex&quot;&gt; &lt;code&gt;hex&lt;/code&gt; adecimal&lt;/a&gt; , &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/left&quot;&gt; &lt;code&gt;left&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/functional/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; en su alcance global. Esto puede ser sorprendente si no sabe que &lt;code&gt;std::&lt;/code&gt; contiene estos nombres. Si tambi&amp;eacute;n intenta usar estos nombres localmente, puede generar bastante confusi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8d02f14101198ab0a96dc0a62eeaadc30eac403e" translate="yes" xml:space="preserve">
          <source>If you only talk about &lt;code&gt;using namespace std&lt;/code&gt; you might not be aware of all the stuff you grab -- and when you add another &lt;code&gt;#include&lt;/code&gt; or move to a new C++ revision you might get name conflicts you were not aware of.</source>
          <target state="translated">Si solo habla sobre el &lt;code&gt;using namespace std&lt;/code&gt; es posible que no est&amp;eacute; al tanto de todas las cosas que toma, y ​​cuando agrega otro &lt;code&gt;#include&lt;/code&gt; o pasa a una nueva revisi&amp;oacute;n de C ++, puede obtener conflictos de nombres que no conoc&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="4713f3b8d7aeb939fd9e031cf10de0c3697de5bd" translate="yes" xml:space="preserve">
          <source>If you want to find a function name that might be a fairly common name, but you only want to find it in the &lt;code&gt;std&lt;/code&gt; namespace (or the reverse &amp;ndash; you want to change all calls that are &lt;em&gt;not&lt;/em&gt; in namespace &lt;code&gt;std&lt;/code&gt;, namespace &lt;code&gt;X&lt;/code&gt;, ...), then how do you propose to do this?</source>
          <target state="translated">Si desea encontrar un nombre de funci&amp;oacute;n que podr&amp;iacute;a ser un nombre bastante com&amp;uacute;n, pero solo desea encontrarlo en el &lt;code&gt;std&lt;/code&gt; nombres est&amp;aacute;ndar (o al rev&amp;eacute;s, desea cambiar todas las llamadas que &lt;em&gt;no&lt;/em&gt; est&amp;aacute;n en el espacio de nombres &lt;code&gt;std&lt;/code&gt; , espacio de nombres &lt;code&gt;X&lt;/code&gt; , etc. .), entonces, &amp;iquest;c&amp;oacute;mo propones hacer esto?</target>
        </trans-unit>
        <trans-unit id="c4a5742abc54fef340d5e42bb52ab3d34501cefb" translate="yes" xml:space="preserve">
          <source>If you're only using &lt;code&gt;cout&lt;/code&gt;, nobody gets confused.  But when you have lots of namespaces flying around and you see this class and you aren't exactly sure what it does, having the namespace explicit acts as a comment of sorts. You can see at first glance, &quot;oh, this is a filesystem operation&quot; or &quot;that's doing network stuff&quot;.</source>
          <target state="translated">Si solo usas &lt;code&gt;cout&lt;/code&gt; , nadie se confunde. Pero cuando tiene muchos espacios de nombres volando y ve esta clase y no est&amp;aacute; exactamente seguro de lo que hace, tener el espacio de nombres expl&amp;iacute;cito act&amp;uacute;a como una especie de comentario. Puede ver a primera vista, &quot;oh, esta es una operaci&amp;oacute;n del sistema de archivos&quot; o &quot;eso est&amp;aacute; haciendo cosas de red&quot;.</target>
        </trans-unit>
        <trans-unit id="3a0a2f58e94e59b13e5b57410ca215b154e4dd1a" translate="yes" xml:space="preserve">
          <source>In C++03 there was an idiom -- boilerplate code -- for implementing a &lt;code&gt;swap&lt;/code&gt; function for your classes. It was suggested that you actually use a local &lt;code&gt;using namespace std&lt;/code&gt; -- or at least &lt;code&gt;using std::swap&lt;/code&gt;:</source>
          <target state="translated">En C ++ 03 hab&amp;iacute;a un modismo - c&amp;oacute;digo repetitivo - para implementar una funci&amp;oacute;n de &lt;code&gt;swap&lt;/code&gt; para sus clases. Se sugiri&amp;oacute; que realmente use un local &lt;code&gt;using namespace std&lt;/code&gt; , o al menos &lt;code&gt;using std::swap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4efd6ea07a2c12ae34510e9920765f13b7b87856" translate="yes" xml:space="preserve">
          <source>In a decade, that project grew to have several million lines of code. Since these discussions come up again and again, I once was curious how often the (allowed) function-scope &lt;code&gt;using&lt;/code&gt; actually was used in the project. I grep'd the sources for it and only found one or two dozen places where it was used. To me this indicates that, once tried, developers don't find &lt;code&gt;std::&lt;/code&gt; painful enough to employ using directives even once every 100 kLoC even where it was allowed to be used.</source>
          <target state="translated">En una d&amp;eacute;cada, ese proyecto creci&amp;oacute; hasta tener varios millones de l&amp;iacute;neas de c&amp;oacute;digo. Dado que estas discusiones surgen una y otra vez, una vez tuve curiosidad por saber con qu&amp;eacute; frecuencia se usaba el alcance de funci&amp;oacute;n (permitido) en el proyecto. Busqu&amp;eacute; las fuentes y solo encontr&amp;eacute; una o dos docenas de lugares donde se usaba. Para m&amp;iacute;, esto indica que, una vez probado, los desarrolladores no encuentran &lt;code&gt;std::&lt;/code&gt; suficientemente doloroso como para emplear el uso de directivas, incluso una vez cada 100 kLoC, incluso donde se permiti&amp;oacute; su uso.</target>
        </trans-unit>
        <trans-unit id="06435acc952b6ddf3ff59e777675ac2714343da8" translate="yes" xml:space="preserve">
          <source>In short: You can and should use namespace using declarations and directives liberally in your implementation files after #include directives and feel good about it. &lt;strong&gt;Despite repeated assertions to the contrary, namespace using declarations and directives are not evil and they do not defeat the purpose of namespaces. Rather, they are what make namespaces usable&lt;/strong&gt;.</source>
          <target state="translated">En resumen: puede y debe usar el espacio de nombres usando declaraciones y directivas generosamente en sus archivos de implementaci&amp;oacute;n despu&amp;eacute;s de #incluir directivas y sentirse bien al respecto. &lt;strong&gt;A pesar de las reiteradas afirmaciones en sentido contrario, el espacio de nombres que utiliza declaraciones y directivas no es malo y no vencen el prop&amp;oacute;sito de los espacios de nombres.&lt;/strong&gt; &lt;strong&gt;M&amp;aacute;s bien, son los que hacen que los espacios de nombres sean utilizables&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ec2299e86922f16c12bb89391ea97d486f2d6389" translate="yes" xml:space="preserve">
          <source>In this example, we resolved potential name clashes and ambiguities arising from their composition.</source>
          <target state="translated">En este ejemplo,resolvimos los posibles conflictos de nombres y las ambigüedades derivadas de su composición.</target>
        </trans-unit>
        <trans-unit id="65c4c1dce2db14606c299117092648f5be7eb3d2" translate="yes" xml:space="preserve">
          <source>It depends on where it is located. If it is a common header, then you are diminishing the value of the namespace by merging it into the global namespace. Keep in mind, this could be a neat way of making module globals.</source>
          <target state="translated">Depende de dónde se encuentre.Si es un encabezado común,entonces estás disminuyendo el valor del espacio de nombres al fusionarlo con el espacio de nombres global.Ten en cuenta que esta podría ser una forma limpia de hacer globales los módulos.</target>
        </trans-unit>
        <trans-unit id="a9149a57a26a9aeee68e53682d200c4529d40a43" translate="yes" xml:space="preserve">
          <source>It doesn't make your software or project performance worse. The inclusion of the namespace at the beginning of your source code isn't bad. The inclusion of the &lt;code&gt;using namespace std&lt;/code&gt; instruction varies according to your needs and the way you are developing the software or project.</source>
          <target state="translated">No empeora el rendimiento de su software o proyecto. La inclusi&amp;oacute;n del espacio de nombres al comienzo de su c&amp;oacute;digo fuente no est&amp;aacute; mal. La inclusi&amp;oacute;n del &lt;code&gt;using namespace std&lt;/code&gt; instrucci&amp;oacute;n est&amp;aacute;ndar de espacio de nombres var&amp;iacute;a seg&amp;uacute;n sus necesidades y la forma en que est&amp;aacute; desarrollando el software o proyecto.</target>
        </trans-unit>
        <trans-unit id="2594ecb269de1ca1ca972a398f9ac08229b7f4f0" translate="yes" xml:space="preserve">
          <source>It is considered &quot;bad&quot; only when &lt;strong&gt;used globally&lt;/strong&gt;. Because:</source>
          <target state="translated">Se considera &quot;malo&quot; solo cuando se &lt;strong&gt;usa globalmente&lt;/strong&gt; . Porque:</target>
        </trans-unit>
        <trans-unit id="1ebc6c4aab7254b3c847f7a94a880434c0e2f28e" translate="yes" xml:space="preserve">
          <source>It's all about managing complexity. Using the namespace will pull things in that you don't want, and thus possibly make it harder to debug (I say possibly). Using std:: all over the place is harder to read (more text and all that).</source>
          <target state="translated">Se trata de manejar la complejidad.Usar el espacio de nombres traerá cosas que no quieres,y así posiblemente hará más difícil la depuración (digo posiblemente).Usar std::por todas partes es más difícil de leer (más texto y todo eso).</target>
        </trans-unit>
        <trans-unit id="38709085bed04576c2d5d32366c7d466d551f5ee" translate="yes" xml:space="preserve">
          <source>It's nice to see code and know what it does. If I see &lt;code&gt;std::cout&lt;/code&gt; I know that's the &lt;code&gt;cout&lt;/code&gt; stream of the &lt;code&gt;std&lt;/code&gt; library. If I see &lt;code&gt;cout&lt;/code&gt; then I don't know. It &lt;em&gt;could&lt;/em&gt; be the &lt;code&gt;cout&lt;/code&gt; stream of the &lt;code&gt;std&lt;/code&gt; library. Or there could be an &lt;code&gt;int cout = 0;&lt;/code&gt; ten lines higher in the same function. Or a &lt;code&gt;static&lt;/code&gt; variable named &lt;code&gt;cout&lt;/code&gt; in that file. It could be anything.</source>
          <target state="translated">Es bueno ver el c&amp;oacute;digo y saber lo que hace. Si veo &lt;code&gt;std::cout&lt;/code&gt; , s&amp;eacute; que esa es la secuencia de &lt;code&gt;cout&lt;/code&gt; de la biblioteca &lt;code&gt;std&lt;/code&gt; . Si veo &lt;code&gt;cout&lt;/code&gt; entonces no lo s&amp;eacute;. &lt;em&gt;Podr&amp;iacute;a&lt;/em&gt; ser la secuencia de la biblioteca &lt;code&gt;std&lt;/code&gt; . O podr&amp;iacute;a haber un &lt;code&gt;int cout = 0;&lt;/code&gt; diez l&amp;iacute;neas m&amp;aacute;s arriba en la misma funci&amp;oacute;n. O una variable &lt;code&gt;static&lt;/code&gt; llamada &lt;code&gt;cout&lt;/code&gt; en ese archivo. Podr&amp;iacute;a ser cualquier cosa.</target>
        </trans-unit>
        <trans-unit id="291d10432ee90ffee7774e1bfd80a03295550276" translate="yes" xml:space="preserve">
          <source>It's not horrible, but you'll save yourself headaches by not using it in header files or the global namespace. It's probably all right to do it in very limited scopes, but I've never had a problem typing the extra five characters to clarify where my functions are coming from.</source>
          <target state="translated">No es horrible,pero te ahorrarás dolores de cabeza si no lo usas en los archivos de cabecera o en el espacio de nombres global.Probablemente esté bien hacerlo en ámbitos muy limitados,pero nunca he tenido problemas para escribir los cinco caracteres extra para aclarar de dónde vienen mis funciones.</target>
        </trans-unit>
        <trans-unit id="9baf97e2ec47fa798dfe06c21b8e750de1bac58f" translate="yes" xml:space="preserve">
          <source>It's one of these things that seem a really good idea if you are a teacher and never had to write and maintain any code for a living. I love seeing code where (1) I know what it does; and, (2) I'm confident that the person writing it knew what it does.</source>
          <target state="translated">Es una de esas cosas que parecen una buena idea si eres un profesor y nunca has tenido que escribir y mantener un código para vivir.Me encanta ver el código donde (1)sé lo que hace;y,(2)estoy seguro de que la persona que lo escribe sabe lo que hace.</target>
        </trans-unit>
        <trans-unit id="91a8c9eace09304424f54dbcea4ab917ef139db7" translate="yes" xml:space="preserve">
          <source>Just to clarify something: I don't actually think it is a good idea to use a name of a class/whatever in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; deliberately and more specifically in place of. The string is the exception (ignore the first, above, or second here, pun if you must) for me as I didn't like the idea of 'String'.</source>
          <target state="translated">Solo para aclarar algo: en realidad no creo que sea una buena idea usar el nombre de una clase / lo que sea en el &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; deliberadamente y m&amp;aacute;s espec&amp;iacute;ficamente en lugar de. La cadena es la excepci&amp;oacute;n (ignore el primero, el anterior o el segundo aqu&amp;iacute;, haga un juego de palabras si es necesario) para m&amp;iacute;, ya que no me gust&amp;oacute; la idea de 'String'.</target>
        </trans-unit>
        <trans-unit id="29daf4a7594ca589153ad134f21264fe11ca3416" translate="yes" xml:space="preserve">
          <source>Just typing std::</source>
          <target state="translated">Sólo escribiendo std::</target>
        </trans-unit>
        <trans-unit id="8507557482216947016f1aeee1629d528f10442b" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;std&lt;/code&gt; namespace has tons of identifiers, many of which are &lt;em&gt;very&lt;/em&gt; common ones (think &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, etc.) which are very likely to appear in other code, too.</source>
          <target state="translated">Tenga en cuenta que el &lt;code&gt;std&lt;/code&gt; nombres est&amp;aacute;ndar tiene toneladas de identificadores, muchos de los cuales son &lt;em&gt;muy&lt;/em&gt; comunes ( &lt;code&gt;list&lt;/code&gt; a de pensamiento, &lt;code&gt;sort&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; , etc.) que tambi&amp;eacute;n es muy probable que aparezcan en otro c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="6a07da18fbe175d65d1d0865aa1dc4b50b7ab47f" translate="yes" xml:space="preserve">
          <source>Library Foo 2.0 could introduce a function, &lt;code&gt;Quux()&lt;/code&gt;, that is an unambiguously better match for some of your calls to &lt;code&gt;Quux()&lt;/code&gt; than the &lt;code&gt;bar::Quux()&lt;/code&gt; your code called for years. Then your &lt;strong&gt;&lt;em&gt;code still compiles&lt;/em&gt;&lt;/strong&gt;, but &lt;strong&gt;&lt;em&gt;it silently calls the wrong function&lt;/em&gt;&lt;/strong&gt; and does god-knows-what. That's about as bad as things can get.</source>
          <target state="translated">Library Foo 2.0 podr&amp;iacute;a introducir una funci&amp;oacute;n, &lt;code&gt;Quux()&lt;/code&gt; , que es una coincidencia inequ&amp;iacute;vocamente mejor para algunas de sus llamadas a &lt;code&gt;Quux()&lt;/code&gt; que la &lt;code&gt;bar::Quux()&lt;/code&gt; su c&amp;oacute;digo llam&amp;oacute; durante a&amp;ntilde;os. Entonces su &lt;strong&gt;&lt;em&gt;c&amp;oacute;digo a&amp;uacute;n se compila&lt;/em&gt;&lt;/strong&gt; , pero &lt;strong&gt;&lt;em&gt;silenciosamente llama a la funci&amp;oacute;n incorrecta&lt;/em&gt;&lt;/strong&gt; y hace dios sabe qu&amp;eacute;. Eso es tan malo como las cosas pueden ponerse.</target>
        </trans-unit>
        <trans-unit id="5124022ffb20c699c10a1cc2488c255b2ffc9a00" translate="yes" xml:space="preserve">
          <source>NOTE: Don't focus too much on efficiency issues until you actually learn a little about how compilers work.  With a little experience coding you don't have to learn that much about them before you realize how much they are able to generalize good code into something something simple.  Every bit as simple as if you wrote the whole thing in C.  Good code is only as complex as it needs to be.</source>
          <target state="translated">NOTA:No te centres demasiado en los temas de eficiencia hasta que aprendas un poco sobre el funcionamiento de los compiladores.Con un poco de experiencia en codificación no tienes que aprender tanto sobre ellos antes de darte cuenta de lo mucho que son capaces de generalizar un buen código en algo simple.Tan simple como si lo hubieras escrito todo en C.El buen código es tan complejo como debe ser.</target>
        </trans-unit>
        <trans-unit id="9ce878b56aa89e0fc6464244ab6312410a2325ee" translate="yes" xml:space="preserve">
          <source>Names explicitly declared there (including names declared by using-declarations like &lt;code&gt;His_lib::String&lt;/code&gt;) take priority over names made accessible in another scope by a using-directive (&lt;code&gt;using namespace Her_lib&lt;/code&gt;).</source>
          <target state="translated">Los nombres declarados expl&amp;iacute;citamente all&amp;iacute; (incluidos los nombres declarados mediante declaraciones de uso como &lt;code&gt;His_lib::String&lt;/code&gt; ) tienen prioridad sobre los nombres accesibles en otro &amp;aacute;mbito mediante una directiva de &lt;code&gt;using namespace Her_lib&lt;/code&gt; ( usando namespace Her_lib ).</target>
        </trans-unit>
        <trans-unit id="50b2a2e68d91a2fa20faee50e5b1093521bfac70" translate="yes" xml:space="preserve">
          <source>Namespace usings are for your convenience, not for you to inflict on others: Never write a using declaration or a using directive before an #include directive.</source>
          <target state="translated">El uso del espacio de nombres es para tu conveniencia,no para que lo infligas a otros:Nunca escriba una declaración de uso o una directiva de uso antes de una directiva #include.</target>
        </trans-unit>
        <trans-unit id="50b1f6a51d747783cb1dfe6047e35834dd447f4e" translate="yes" xml:space="preserve">
          <source>Namespaces provide a powerful tool for the management of different libraries and of different versions of code. In particular, they offer the programmer alternatives of how explicit to make a reference to a nonlocal name.</source>
          <target state="translated">Namespaces proporciona una poderosa herramienta para la gestión de diferentes bibliotecas y de diferentes versiones de código.En particular,ofrecen al programador alternativas de cómo hacer una referencia explícita a un nombre no local.</target>
        </trans-unit>
        <trans-unit id="ddbccb0a8b6506410340a7f532fe40e471a2e05a" translate="yes" xml:space="preserve">
          <source>Note that this is a simple example. If you have files with 20 includes and other imports, you'll have a ton of dependencies to go through to figure out the problem. The worse thing about it is that you can get unrelated errors in other modules depending on the definitions that conflict.</source>
          <target state="translated">Obsérvese que este es un ejemplo simple.Si tienes archivos con 20 includes y otras importaciones,tendrás una tonelada de dependencias que recorrer para resolver el problema.Lo peor de todo es que puedes obtener errores no relacionados en otros módulos dependiendo de las definiciones que entren en conflicto.</target>
        </trans-unit>
        <trans-unit id="36ea41aee46346ce28dcadcb94012cb303748b76" translate="yes" xml:space="preserve">
          <source>Notice how there is an ambiguity, to which library does cout point to?
  The compiler may detect this and not compile the program. In the worst
  case, the program may still compile but call the wrong function, since
  we never specified to which namespace the identifier belonged.</source>
          <target state="translated">Fíjate en la ambigüedad,¿a qué biblioteca apunta la palabra &quot;cout&quot;? El compilador puede detectar esto y no compilar el programa.En el peor de los casos,el programa puede seguir compilando pero llamar a la función equivocada,ya que nunca especificamos a qué espacio de nombres pertenecía el identificador.</target>
        </trans-unit>
        <trans-unit id="f735b7708587108249bd04f231f9283a15ed3614" translate="yes" xml:space="preserve">
          <source>Now at a later stage of development, we wish to use another version of
  cout that is custom implemented in some library called &amp;ldquo;foo&amp;rdquo; (for
  example)</source>
          <target state="translated">Ahora, en una etapa posterior de desarrollo, deseamos usar otra versi&amp;oacute;n de cout que se implemente de manera personalizada en alguna biblioteca llamada &quot;foo&quot; (por ejemplo)</target>
        </trans-unit>
        <trans-unit id="a91a9e9922efdb33f03078a0f38ce71a94f60ab3" translate="yes" xml:space="preserve">
          <source>Now let's say you use &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together in your own program as follows:</source>
          <target state="translated">Ahora supongamos que usa &lt;code&gt;foo&lt;/code&gt; y &lt;code&gt;bar&lt;/code&gt; juntos en su propio programa de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ce4819e926b1c69f9e959f1bcce61b24bbf7402f" translate="yes" xml:space="preserve">
          <source>Now take a million line code base, which isn't particularly big, and you're searching for a bug, which means you know there is one line in this one million lines that doesn't do what it is supposed to do. &lt;code&gt;cout &amp;lt;&amp;lt; 1;&lt;/code&gt; could read a &lt;code&gt;static int&lt;/code&gt; named &lt;code&gt;cout&lt;/code&gt;, shift it to the left by one bit, and throw away the result. Looking for a bug, I'd have to check that. Can you see how I really really prefer to see &lt;code&gt;std::cout&lt;/code&gt;?</source>
          <target state="translated">Ahora tome una base de c&amp;oacute;digo de un mill&amp;oacute;n de l&amp;iacute;neas, que no es particularmente grande, y est&amp;aacute; buscando un error, lo que significa que sabe que hay una l&amp;iacute;nea en este mill&amp;oacute;n de l&amp;iacute;neas que no hace lo que se supone que debe hacer. &lt;code&gt;cout &amp;lt;&amp;lt; 1;&lt;/code&gt; podr&amp;iacute;a leer un &lt;code&gt;static int&lt;/code&gt; llamado &lt;code&gt;cout&lt;/code&gt; , desplazarlo a la izquierda un bit y tirar el resultado. Buscando un error, tendr&amp;iacute;a que comprobarlo. &amp;iquest;Puedes ver c&amp;oacute;mo realmente prefiero ver &lt;code&gt;std::cout&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="399f9e8eb4c399a3656111274a9c1b117d6d1db3" translate="yes" xml:space="preserve">
          <source>One shouldn't use the &lt;code&gt;using&lt;/code&gt; directive at the global scope, especially in headers. However, there are situations where it is appropriate even in a header file:</source>
          <target state="translated">No se debe usar la directiva &lt;code&gt;using&lt;/code&gt; en el &amp;aacute;mbito global, especialmente en los encabezados. Sin embargo, hay situaciones en las que es apropiado incluso en un archivo de encabezado:</target>
        </trans-unit>
        <trans-unit id="1516c0ad1f8ca81d0226fc547e43c805fde700c0" translate="yes" xml:space="preserve">
          <source>People should stop being so anal about it. Your teacher was right all along. Just use ONE namespace; that is the whole point of using namespaces the first place. You are not supposed to use more than one at the same time. Unless it is your own. So again, redefinition will not happen.</source>
          <target state="translated">La gente debería dejar de ser tan analítica al respecto.Tu profesor tenía razón todo el tiempo.Sólo usa UN espacio de nombres;ese es el objetivo de usar los espacios de nombres en primer lugar.Se supone que no debes usar más de uno al mismo tiempo.A menos que sea el tuyo propio.Así que de nuevo,la redefinición no ocurrirá.</target>
        </trans-unit>
        <trans-unit id="61ba504ad16f53fef83a89ee5e1bf8d3fd48334a" translate="yes" xml:space="preserve">
          <source>Personally, I actually don't mind the &lt;code&gt;std::&lt;/code&gt; prefix. I like the look more than not having it. I don't know if that is because it is explicit and says to me &quot;this isn't my code... I am using the standard library&quot; or if it is something else, but I think it looks nicer. This might be odd given that I only recently got into C++ (used and still do C and other languages for much longer and C is my favourite language of all time, right above assembly).</source>
          <target state="translated">Personalmente, en realidad no me importa el prefijo &lt;code&gt;std::&lt;/code&gt; . Me gusta m&amp;aacute;s el aspecto que no tenerlo. No s&amp;eacute; si eso es porque es expl&amp;iacute;cito y me dice &quot;este no es mi c&amp;oacute;digo ... estoy usando la biblioteca est&amp;aacute;ndar&quot; o si es otra cosa, pero creo que se ve mejor. Esto podr&amp;iacute;a ser extra&amp;ntilde;o dado que recientemente ingres&amp;eacute; a C ++ (utilic&amp;eacute; y sigo haciendo C y otros lenguajes durante mucho m&amp;aacute;s tiempo y C es mi lenguaje favorito de todos los tiempos, justo encima del ensamblaje).</target>
        </trans-unit>
        <trans-unit id="98a84cb2b057f0497de2c666cab0ffec97887f04" translate="yes" xml:space="preserve">
          <source>Readers will have difficulty seeing where a particular identifier comes from, when you use many &lt;code&gt;using namespace xyz&lt;/code&gt;.</source>
          <target state="translated">Los lectores tendr&amp;aacute;n dificultades para ver de d&amp;oacute;nde proviene un identificador particular, cuando usas muchos &lt;code&gt;using namespace xyz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9140d5235666001f10df811c2360c257238af8d5" translate="yes" xml:space="preserve">
          <source>Repeating a namespace name can be a distraction for both readers and writers. Consequently, it is possible
to state that names from a particular namespace are available without explicit qualification. For example:</source>
          <target state="translated">Repetir el nombre de un espacio de nombres puede ser una distracción tanto para los lectores como para los escritores.Por consiguiente,es posible afirmar que los nombres de un determinado espacio de nombres están disponibles sin una calificación explícita.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a38525257f468902dfed8f814582f493c591c970" translate="yes" xml:space="preserve">
          <source>Short version: don't use global &lt;code&gt;using&lt;/code&gt; declarations or directives in header files. Feel free to use them in implementation files. Here's what &lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrei_Alexandrescu&quot;&gt;Andrei Alexandrescu&lt;/a&gt; have to say about this issue in &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321113586&quot;&gt;C++ Coding Standards&lt;/a&gt; (bolding for emphasis is mine):</source>
          <target state="translated">Versi&amp;oacute;n corta: no use global &lt;code&gt;using&lt;/code&gt; declaraciones o directivas en archivos de encabezado. Si&amp;eacute;ntase libre de usarlos en los archivos de implementaci&amp;oacute;n. Esto es lo que &lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt; y &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrei_Alexandrescu&quot;&gt;Andrei Alexandrescu&lt;/a&gt; tienen que decir sobre este tema en los &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321113586&quot;&gt;est&amp;aacute;ndares de codificaci&amp;oacute;n C ++&lt;/a&gt; (la negrita es el m&amp;iacute;o):</target>
        </trans-unit>
        <trans-unit id="eec2d891bc3edd909e8348b90447e5d43222b3e9" translate="yes" xml:space="preserve">
          <source>So here's how I solved it. Install Boost's regex, and link it in. Then, I do the following so that when libstdc++ has it implemented entirely, I need only remove this block and the code remains the same:</source>
          <target state="translated">Así que así es como lo resolví.Instala el regex de Boost,y enlázalo.Luego,hago lo siguiente para que cuando libstdc++lo tenga implementado por completo,sólo tenga que quitar este bloque y el código permanezca igual:</target>
        </trans-unit>
        <trans-unit id="ba958b36fe2684798576e2f9a1a8d021d2835d2a" translate="yes" xml:space="preserve">
          <source>So just consider them functions as reserved names like &quot;int&quot; or &quot;class&quot; and that is it.</source>
          <target state="translated">Así que considera las funciones como nombres reservados como &quot;int&quot; o &quot;class&quot; y eso es todo.</target>
        </trans-unit>
        <trans-unit id="eeaf7c2ef34ec4418e50a2e403553b2d83998883" translate="yes" xml:space="preserve">
          <source>So the following are OK:</source>
          <target state="translated">Así que lo siguiente está bien:</target>
        </trans-unit>
        <trans-unit id="f103eac16afc4b9fd2b1e99833b3f809101f91e2" translate="yes" xml:space="preserve">
          <source>So you'll need to do some maintenance to clarify that 'a' meant &lt;code&gt;foo::a&lt;/code&gt;. That's undesirable, but fortunately it is pretty easy (just add &lt;code&gt;foo::&lt;/code&gt; in front of all calls to &lt;code&gt;a&lt;/code&gt; that the compiler marks as ambiguous).</source>
          <target state="translated">Por lo tanto, deber&amp;aacute; realizar algunas tareas de mantenimiento para aclarar que 'a' significaba &lt;code&gt;foo::a&lt;/code&gt; . Eso no es deseable, pero afortunadamente es bastante f&amp;aacute;cil (solo agregue &lt;code&gt;foo::&lt;/code&gt; en frente de todas las llamadas a que el compilador marca como ambiguas).</target>
        </trans-unit>
        <trans-unit id="ecb267a2211227e4951289cb2c61d96f30e02f89" translate="yes" xml:space="preserve">
          <source>Some people had said that is a bad practice to include the &lt;code&gt;using namespace std&lt;/code&gt; in your source files because you're invoking from that namespace all the functions and variables. When you would like to define a new function with the same name as another function contained in the &lt;code&gt;namespace std&lt;/code&gt; you would overload the function and it could produce problems due to compile or execute. It will not compile or executing as you expect.</source>
          <target state="translated">Algunas personas han dicho que es una mala pr&amp;aacute;ctica incluir el &lt;code&gt;using namespace std&lt;/code&gt; en sus archivos fuente porque est&amp;aacute; invocando desde ese espacio de nombres todas las funciones y variables. Cuando desee definir una nueva funci&amp;oacute;n con el mismo nombre que otra funci&amp;oacute;n contenida en el &lt;code&gt;namespace std&lt;/code&gt; , sobrecargar&amp;iacute;a la funci&amp;oacute;n y podr&amp;iacute;a producir problemas debido a la compilaci&amp;oacute;n o ejecuci&amp;oacute;n. No se compilar&amp;aacute; ni ejecutar&amp;aacute; como espera.</target>
        </trans-unit>
        <trans-unit id="2983f4020c6309b44686250810ad2fa1b133cdbd" translate="yes" xml:space="preserve">
          <source>Source-file-level using-declarations inside source files</source>
          <target state="translated">Nivel de archivos de origen usando declaraciones dentro de los archivos de origen</target>
        </trans-unit>
        <trans-unit id="48a09de267300394017fd1240b9ef9afafe06e9a" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;An Overview of the C++ Programming Language&lt;/em&gt;
by Bjarne Stroustrup</source>
          <target state="translated">Fuente: &lt;em&gt;Una descripci&amp;oacute;n general del lenguaje de programaci&amp;oacute;n C ++&lt;/em&gt; por Bjarne Stroustrup</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="8d362630dbd96c9d94d61a5ba26f68429e881414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;namespace std&lt;/code&gt; contains the C++ standard functions and variables. This namespace is useful when you often would use the C++ standard functions.</source>
          <target state="translated">El &lt;code&gt;namespace std&lt;/code&gt; est&amp;aacute;ndar contiene las funciones y variables est&amp;aacute;ndar de C ++. Este espacio de nombres es &amp;uacute;til cuando a menudo usar&amp;iacute;a las funciones est&amp;aacute;ndar de C ++.</target>
        </trans-unit>
        <trans-unit id="a0ecbbc85e8e265d8a3603712049a64cd310766c" translate="yes" xml:space="preserve">
          <source>The FAQ suggests two alternatives:</source>
          <target state="translated">La FAQ sugiere dos alternativas:</target>
        </trans-unit>
        <trans-unit id="64995ed41ecdd7959fd7a75459bcac3c990a145f" translate="yes" xml:space="preserve">
          <source>The compiler will choose the &lt;code&gt;std::swap&lt;/code&gt; for &lt;code&gt;value_&lt;/code&gt;, i.e. &lt;code&gt;void std::swap(int, int)&lt;/code&gt;.</source>
          <target state="translated">El compilador elegir&amp;aacute; &lt;code&gt;std::swap&lt;/code&gt; para &lt;code&gt;value_&lt;/code&gt; , es decir, &lt;code&gt;void std::swap(int, int)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7f65e416b24edb3d7d7359d825fd5f48ff2bf1b" translate="yes" xml:space="preserve">
          <source>The problem with putting &lt;code&gt;using namespace&lt;/code&gt; in the header files of your classes is that it forces anyone who wants to use your classes (by including your header files) to also be 'using' (i.e. seeing everything in) those other namespaces.</source>
          <target state="translated">El problema con el &lt;code&gt;using namespace&lt;/code&gt; de nombres en los archivos de encabezado de sus clases es que obliga a cualquiera que quiera usar sus clases (al incluir sus archivos de encabezado) a 'usar' (es decir, ver todo) esos otros espacios de nombres.</target>
        </trans-unit>
        <trans-unit id="651d1324e3e3efa0febb293121711a75a4c05298" translate="yes" xml:space="preserve">
          <source>The statement using namespace std is generally considered bad
  practice. The alternative to this statement is to specify the
  namespace to which the identifier belongs using the scope operator(::)
  each time we declare a type.</source>
          <target state="translated">La declaración que utiliza namespace std se considera generalmente como una mala práctica.La alternativa a esta declaración es especificar el espacio de nombres al que pertenece el identificador utilizando el operador de ámbito(::)cada vez que declaramos un tipo.</target>
        </trans-unit>
        <trans-unit id="da678d1957a06dc4c79a7d800b78557e33ff5ebf" translate="yes" xml:space="preserve">
          <source>The using-directive exists for legacy C++ code and to ease the transition to namespaces, but you probably shouldn&amp;rsquo;t use it on a regular basis, at least not in your new C++ code.</source>
          <target state="translated">La directiva de uso existe para el c&amp;oacute;digo C ++ heredado y para facilitar la transici&amp;oacute;n a los espacios de nombres, pero probablemente no deber&amp;iacute;a usarlo de forma regular, al menos no en su nuevo c&amp;oacute;digo C ++.</target>
        </trans-unit>
        <trans-unit id="5b8ee9557da2fd48e95fe83d8c0f287ad5f8df12" translate="yes" xml:space="preserve">
          <source>There is no problem using &quot;using namespace std&quot; in your source file
  when you make heavy use of the namespace and know for sure that
  nothing will collide.</source>
          <target state="translated">No hay problema en usar &quot;using namespace std&quot; en su archivo fuente cuando se hace un uso intensivo del espacio de nombres y se sabe con seguridad que nada va a colisionar.</target>
        </trans-unit>
        <trans-unit id="029764c0ea9e395746931f8952df7326aa09ac18" translate="yes" xml:space="preserve">
          <source>There is one other thing although it is somewhat related to the above and what others point out. While this might be bad practise, I sometimes reserve &lt;code&gt;std::name&lt;/code&gt; for the standard library version and name for program-specific implementation. Yes, indeed this could bite you and bite you hard, but it all comes down to that I started this project from scratch, and I'm the only programmer for it. Example: I overload &lt;code&gt;std::string&lt;/code&gt; and call it &lt;code&gt;string&lt;/code&gt;. I have helpful additions. I did it in part because of my C and Unix (+ Linux) tendency towards lower-case names.</source>
          <target state="translated">Hay otra cosa, aunque est&amp;aacute; algo relacionada con lo anterior y lo que otros se&amp;ntilde;alan. Si bien esto podr&amp;iacute;a ser una mala pr&amp;aacute;ctica, a veces reservo &lt;code&gt;std::name&lt;/code&gt; para la versi&amp;oacute;n est&amp;aacute;ndar de la biblioteca y el nombre para la implementaci&amp;oacute;n espec&amp;iacute;fica del programa. S&amp;iacute;, de hecho, esto podr&amp;iacute;a morderte y morderte duro, pero todo se reduce a que comenc&amp;eacute; este proyecto desde cero, y soy el &amp;uacute;nico programador para ello. Ejemplo: sobrecargo &lt;code&gt;std::string&lt;/code&gt; y lo llamo &lt;code&gt;string&lt;/code&gt; . Tengo adiciones &amp;uacute;tiles. Lo hice en parte debido a mi tendencia de C y Unix (+ Linux) hacia los nombres en min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="3f0a653213e88a4d78de823350af0cc28a0f0151" translate="yes" xml:space="preserve">
          <source>Therefore, avoiding &lt;code&gt;using namespace X;&lt;/code&gt; is a form of future-proofing, a way of making sure a change to the libraries and/or header files in use is not going to break a program.</source>
          <target state="translated">Por lo tanto, evite &lt;code&gt;using namespace X;&lt;/code&gt; es una forma de preparaci&amp;oacute;n para el futuro, una forma de asegurarse de que un cambio en las bibliotecas y / o los archivos de encabezado en uso no va a romper un programa.</target>
        </trans-unit>
        <trans-unit id="f45f9dde8d1c10defc80ef7f165a362cba2c156e" translate="yes" xml:space="preserve">
          <source>This does the following magic:</source>
          <target state="translated">Esto hace la siguiente magia:</target>
        </trans-unit>
        <trans-unit id="a4545a366e0aad9d34b8acbf9d14874529a60d6a" translate="yes" xml:space="preserve">
          <source>This is a bad practice, often known as global namespace pollution. Problems may occur when more than one namespace has the same function name with signature, then it will be ambiguous for the compiler to decide which one to call and this all can be avoided when you are specifying the namespace with your function call like &lt;code&gt;std::cout&lt;/code&gt; . Hope this helps. :)</source>
          <target state="translated">Esta es una mala pr&amp;aacute;ctica, a menudo conocida como contaminaci&amp;oacute;n global del espacio de nombres. Pueden surgir problemas cuando m&amp;aacute;s de un espacio de nombres tiene el mismo nombre de funci&amp;oacute;n con firma, entonces ser&amp;aacute; ambiguo que el compilador decida a cu&amp;aacute;l llamar y todo esto se puede evitar cuando se especifica el espacio de nombres con su funci&amp;oacute;n llamada como &lt;code&gt;std::cout&lt;/code&gt; . Espero que esto ayude. :)</target>
        </trans-unit>
        <trans-unit id="99260186b8c3a0ba3c616d9138288919d1f36e7b" translate="yes" xml:space="preserve">
          <source>This is better than explicit qualification (&lt;code&gt;std::sin&lt;/code&gt;, &lt;code&gt;std::cos&lt;/code&gt;...), because it is shorter and has the ability to work with user defined floating point types (via &lt;a href=&quot;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;argument-dependent lookup&lt;/a&gt; (ADL)).</source>
          <target state="translated">Esto es mejor que la calificaci&amp;oacute;n expl&amp;iacute;cita ( &lt;code&gt;std::sin&lt;/code&gt; , &lt;code&gt;std::cos&lt;/code&gt; ...), porque es m&amp;aacute;s corto y tiene la capacidad de trabajar con tipos de punto flotante definidos por el usuario (a trav&amp;eacute;s &lt;a href=&quot;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;de b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; (ADL)).</target>
        </trans-unit>
        <trans-unit id="160a0a5c0f76c23ec35ad5487bfae3b08b2536aa" translate="yes" xml:space="preserve">
          <source>This is not related to performance at all. But consider this: you are using two libraries called Foo and Bar:</source>
          <target state="translated">Esto no tiene nada que ver con el rendimiento.Pero considera esto:estás usando dos bibliotecas llamadas Foo y Bar:</target>
        </trans-unit>
        <trans-unit id="298ec62c38104583ee0298f42b39da2f5449b342" translate="yes" xml:space="preserve">
          <source>To answer your question I look at it this way practically:  a lot of programmers (not all) invoke namespace std.  Therefore one should be in the habit of NOT using things that impinge or use the same names as what is in the namespace std.  That is a great deal granted, but not so much compared to the number of possible coherent words and pseudonyms that can be come up with strictly speaking.</source>
          <target state="translated">Para responder a su pregunta lo veo de esta manera prácticamente:muchos programadores (no todos)invocan namespace std.Por lo tanto,uno debería tener el hábito de NO usar cosas que afecten o utilicen los mismos nombres que lo que está en el namespace std.Eso es mucho concedido,pero no tanto en comparación con el número de posibles palabras coherentes y seudónimos que se pueden inventar en sentido estricto.</target>
        </trans-unit>
        <trans-unit id="2782259cabfa8ad3d1fe54d85a7f2baf351f10f1" translate="yes" xml:space="preserve">
          <source>Ultimately this is a trade-off between writability vs. reliability/maintainability. Readability may factor in also, but I could see arguments for that going either way. Normally I would say reliability and maintainability are more important, but in this case you'll constantly pay the writability cost for an fairly rare reliability/maintainability impact. The 'best' trade-off will determine on your project and your priorities.</source>
          <target state="translated">En última instancia,esto es un compromiso entre la escritura y la fiabilidad-mantenimiento.La legibilidad también puede ser un factor,pero puedo ver que los argumentos para eso van en cualquier dirección.Normalmente diría que la fiabilidad y la mantenibilidad son más importantes,pero en este caso usted pagará constantemente el costo de la escritura por un impacto bastante raro de fiabilidad y mantenibilidad.El &quot;mejor&quot; compromiso determinará su proyecto y sus prioridades.</target>
        </trans-unit>
        <trans-unit id="6ea4fced5fb87a77ecac7ac3fa6aeea3011782f8" translate="yes" xml:space="preserve">
          <source>Using many namespaces at the same time is obviously a recipe for disaster, but using JUST namespace &lt;code&gt;std&lt;/code&gt; and only namespace &lt;code&gt;std&lt;/code&gt; is not that big of a deal in my opinion because redefinition can only occur by your own code...</source>
          <target state="translated">Obviamente, usar muchos espacios de nombres al mismo tiempo es una receta para el desastre, pero usar JUST namespace &lt;code&gt;std&lt;/code&gt; y solo namespace &lt;code&gt;std&lt;/code&gt; no es tan importante en mi opini&amp;oacute;n porque la redefinici&amp;oacute;n solo puede ocurrir por su propio c&amp;oacute;digo ...</target>
        </trans-unit>
        <trans-unit id="41a6352eaeffb261dfe2d93e2ca63fc49c9ba12a" translate="yes" xml:space="preserve">
          <source>What are these &lt;em&gt;good reasons&lt;/em&gt;? Sometimes programmers explicitly want to turn off ADL, other times they want to disambiguate.</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;les son estas &lt;em&gt;buenas razones&lt;/em&gt; ? Algunas veces los programadores quieren desactivar ADL expl&amp;iacute;citamente, otras veces quieren desambiguar.</target>
        </trans-unit>
        <trans-unit id="ab54537830a0232c9f9d54213cf3aa6945c2396b" translate="yes" xml:space="preserve">
          <source>Whatever is true for &lt;em&gt;other&lt;/em&gt; readers of your source code is even more true for the most frequent reader of it: yourself. Come back in a year or two and take a look...</source>
          <target state="translated">Lo que sea cierto para &lt;em&gt;otros&lt;/em&gt; lectores de su c&amp;oacute;digo fuente es a&amp;uacute;n m&amp;aacute;s cierto para el lector m&amp;aacute;s frecuente: usted mismo. Regrese en un a&amp;ntilde;o o dos y eche un vistazo ...</target>
        </trans-unit>
        <trans-unit id="cdb77621d85047abd900bf6e655db16ba77b61bb" translate="yes" xml:space="preserve">
          <source>When you use a namespace you're risking a scenario like this, which is why people are uncomfortable using namespaces. The more things in a namespace, the greater the risk of conflict, so people might be even more uncomfortable using namespace &lt;code&gt;std&lt;/code&gt; (due to the number of things in that namespace) than other namespaces.</source>
          <target state="translated">Cuando usa un espacio de nombres, est&amp;aacute; arriesgando un escenario como este, por lo que las personas se sienten inc&amp;oacute;modas al usar espacios de nombres. Cuantas m&amp;aacute;s cosas haya en un espacio de nombres, mayor ser&amp;aacute; el riesgo de conflicto, por lo que las personas podr&amp;iacute;an sentirse a&amp;uacute;n m&amp;aacute;s inc&amp;oacute;modas usando &lt;code&gt;std&lt;/code&gt; de espacio de nombres (debido a la cantidad de cosas en ese espacio de nombres) que otros espacios de nombres.</target>
        </trans-unit>
        <trans-unit id="1654c94350473966024505fd813d40c64664c782" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;using namespace std;&lt;/code&gt; considered a bad practice? Is it inefficient or does it risk declaring ambiguous variables (variables that share the same name as a function in &lt;code&gt;std&lt;/code&gt; namespace)? Does it impact performance?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; est&amp;aacute; &lt;code&gt;using namespace std;&lt;/code&gt; considerado una mala pr&amp;aacute;ctica? &amp;iquest;Es ineficiente o se arriesga a declarar variables ambiguas (variables que comparten el mismo nombre que una funci&amp;oacute;n en el &lt;code&gt;std&lt;/code&gt; nombres est&amp;aacute;ndar )? &amp;iquest;Afecta el rendimiento?</target>
        </trans-unit>
        <trans-unit id="b584d12b92d355bff8bb0e1c7230b6bf58ecd519" translate="yes" xml:space="preserve">
          <source>Why is “using namespace std;” considered bad practice</source>
          <target state="translated">¿Por qué &quot;usar namespace std;&quot; se considera una mala práctica</target>
        </trans-unit>
        <trans-unit id="0e30f8945d319ea0f3eeddb281fd252a6c00818b" translate="yes" xml:space="preserve">
          <source>With C++11 there is no reason to use this pattern any more. The implementation of &lt;code&gt;std::swap&lt;/code&gt; was changed to find a potential overload and choose it.</source>
          <target state="translated">Con C ++ 11 ya no hay raz&amp;oacute;n para usar este patr&amp;oacute;n. La implementaci&amp;oacute;n de &lt;code&gt;std::swap&lt;/code&gt; se cambi&amp;oacute; para encontrar una posible sobrecarga y elegirla.</target>
        </trans-unit>
        <trans-unit id="634192ce5da22f1caaa7b9299179cbcca7b577b9" translate="yes" xml:space="preserve">
          <source>With unqualified imported identifiers you need external search tools like &lt;em&gt;grep&lt;/em&gt; to find out where identifiers are declared. This makes reasoning about program correctness harder.</source>
          <target state="translated">Con los identificadores importados no calificados, necesita herramientas de b&amp;uacute;squeda externas como &lt;em&gt;grep&lt;/em&gt; para averiguar d&amp;oacute;nde se declaran los identificadores. Esto dificulta el razonamiento sobre la correcci&amp;oacute;n del programa.</target>
        </trans-unit>
        <trans-unit id="61b8baeb889064cf813917c7fab3baf262e3a825" translate="yes" xml:space="preserve">
          <source>You clutter the namespace you are programming in.</source>
          <target state="translated">Desordenas el espacio de nombres en el que estás programando.</target>
        </trans-unit>
        <trans-unit id="3bf6425e37e04cd0a68c1fc7844787cb56ab92a8" translate="yes" xml:space="preserve">
          <source>You could write a program to do it, but wouldn't it be better to spend time working on your project itself rather than writing a program to maintain your project?</source>
          <target state="translated">Podrías escribir un programa para hacerlo,pero ¿no sería mejor pasar el tiempo trabajando en tu proyecto en sí mismo en lugar de escribir un programa para mantener tu proyecto?</target>
        </trans-unit>
        <trans-unit id="1a066f3f13ff76e054b645560a1597523d36beac" translate="yes" xml:space="preserve">
          <source>You may use it locally</source>
          <target state="translated">Puede utilizarlo localmente</target>
        </trans-unit>
        <trans-unit id="1a6d9c972154f7b0a7a3e7bc908971e2acb03018" translate="yes" xml:space="preserve">
          <source>You need to be able to read code written by people who have different style and best practices opinions than you.</source>
          <target state="translated">Tienes que ser capaz de leer el código escrito por personas que tienen opiniones de estilo y mejores prácticas diferentes a las tuyas.</target>
        </trans-unit>
        <trans-unit id="9e5ae30173712188975d44da3afd5fd95f0f943a" translate="yes" xml:space="preserve">
          <source>and in the implementation:</source>
          <target state="translated">y en la aplicación:</target>
        </trans-unit>
        <trans-unit id="2b71447c7e589fd9da4e2a449318d54f8e55a2f0" translate="yes" xml:space="preserve">
          <source>as opposed to:</source>
          <target state="translated">en lugar de:</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
