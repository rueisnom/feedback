<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1452721">
    <body>
      <group id="1452721">
        <trans-unit id="8e0741bec52099753c6c2a0306787331f3b1bf94" translate="yes" xml:space="preserve">
          <source>&quot;Why is 'using namespace std;' considered a bad practice in C++?&quot;</source>
          <target state="translated">&quot;왜 네임 스페이스 std를 사용하고 있습니까?&quot; &quot;C ++에서 나쁜 습관으로 간주 되었습니까?&quot;</target>
        </trans-unit>
        <trans-unit id="5575dde3d3d20bdebe5e5002778dd58101ae84ae" translate="yes" xml:space="preserve">
          <source>(Sometimes) source-file-level using-directives</source>
          <target state="translated">(때로는) 소스 파일 수준 사용 지시문</target>
        </trans-unit>
        <trans-unit id="6a699133bca549300caca4bbc9e50a4f03f67b9e" translate="yes" xml:space="preserve">
          <source>A concrete example to clarify the concern. Imagine you have a situation where you have two libraries, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, each with their own namespace:</source>
          <target state="translated">우려를 명확히하는 구체적인 예. 각각 자체 네임 스페이스가있는 두 개의 라이브러리 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 가있는 상황이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="ba3eac4e25ae1cec81af111cfd596d079e2ef4bd" translate="yes" xml:space="preserve">
          <source>A lot of &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; features are going into the C++0x standard, and Visual&amp;nbsp;Studio&amp;nbsp;2010 has a lot of C++0x features, so suddenly these programs were not compiling.</source>
          <target state="translated">많은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; 기능이 C ++ 0x 표준으로 들어가고 Visual Studio 2010에는 많은 C ++ 0x 기능이 있으므로 갑자기 이러한 프로그램이 컴파일되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="39f8e6781daf6a934001f51f44614f546e42a1e3" translate="yes" xml:space="preserve">
          <source>A namespace is a named scope. Namespaces are used to group related declarations and to keep separate
items separate. For example, two separately developed libraries may use the same name to refer to different
items, but a user can still use both:</source>
          <target state="translated">네임 스페이스는 명명 된 범위입니다. 네임 스페이스는 관련 선언을 그룹화하고 별도의 항목을 개별적으로 유지하는 데 사용됩니다. 예를 들어, 별도로 개발 된 두 개의 라이브러리는 동일한 이름을 사용하여 다른 항목을 참조 할 수 있지만 사용자는 여전히 두 가지를 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a340e0ae7fed0a2d743f95465081c70d0cb841d" translate="yes" xml:space="preserve">
          <source>A using-declaration:</source>
          <target state="translated">사용 선언 :</target>
        </trans-unit>
        <trans-unit id="b82a662dae5884212abc04bb506affe12b0328ae" translate="yes" xml:space="preserve">
          <source>Although the statement saves us from typing std:: whenever
  we wish to access a class or type defined in the std namespace, it
  imports the entirety of the std namespace into the current namespace
  of the program. Let us take a few examples to understand why this
  might not be such a good thing</source>
          <target state="translated">이 명령문은 std ::를 입력하지 않아도되지만 std 네임 스페이스에 정의 된 클래스 나 유형에 액세스 할 때마다 std 네임 스페이스 전체를 프로그램의 현재 네임 스페이스로 가져옵니다. 왜 이것이 좋지 않은지 이해하기 위해 몇 가지 예를 들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="2b00151385441b68225fc4658924e46453d8ec93" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;using namespace std&lt;/code&gt; throws a compilation error because of the ambiguity of count, which is also a function in algorithm library.</source>
          <target state="translated">&lt;code&gt;using namespace std&lt;/code&gt; 하는 경우 모호함 때문에 알고리즘 오류가 발생하며 이는 알고리즘 라이브러리의 함수이기도합니다.</target>
        </trans-unit>
        <trans-unit id="235c5c438cb46b535c12595279d731d5b7716a5d" translate="yes" xml:space="preserve">
          <source>An idiom for using it locally</source>
          <target state="translated">로컬로 사용하는 관용구</target>
        </trans-unit>
        <trans-unit id="0fbb0cc023270ff0740fd1bead3e7a7d083f3415" translate="yes" xml:space="preserve">
          <source>And as for making Boost's regex part of &lt;code&gt;std&lt;/code&gt;. I do that for future integration and &amp;ndash; again, I admit fully this is bias - I don't think it is as ugly as &lt;code&gt;boost::regex:: ...&lt;/code&gt;. Indeed, that is another thing for me. There are many things in C++ that I still have yet to come to fully accept in looks and methods (another example: variadic templates versus var arguments [though I admit variadic templates are very very useful!]). Even those that I do accept it was difficult, &lt;em&gt;and&lt;/em&gt; I still have issues with them.</source>
          <target state="translated">그리고 Boost의 정규 표현식을 &lt;code&gt;std&lt;/code&gt; 의 일부로 만드는 것과 관련하여. 나는 미래의 통합을 위해 그것을하고 다시 한번, 이것이 완전히 편견임을 인정한다-그것이 &lt;code&gt;boost::regex:: ...&lt;/code&gt; 만큼 못생긴 것으로 생각하지 않는다. 사실, 그것은 저에게 또 다른 것입니다. C ++에는 아직 외모와 방법으로 완전히 받아들이지 않은 많은 것들이 있습니다 (또 다른 예 : 가변 템플릿과 var 인수 [변형 템플릿은 매우 유용합니다!). 내가 받아들이는 사람들조차도 어려웠으며 여전히 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa9fcea2af1d01ac1dbb4efe366442a34d014fe" translate="yes" xml:space="preserve">
          <source>And see &lt;a href=&quot;https://www.sololearn.com/Discuss/187690/is-using-namespace-std-a-bad-practice/&quot;&gt;this opinion&lt;/a&gt;:</source>
          <target state="translated">그리고이 &lt;a href=&quot;https://www.sololearn.com/Discuss/187690/is-using-namespace-std-a-bad-practice/&quot;&gt;의견을보십시오&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0fecfa228c906cdbaa2a5ef28640a1b52d83c4df" translate="yes" xml:space="preserve">
          <source>Another reason is surprise.</source>
          <target state="translated">또 다른 이유는 놀라움입니다.</target>
        </trans-unit>
        <trans-unit id="9d1dee9a88dd2bd4cb378802f7b802ac8d01b036" translate="yes" xml:space="preserve">
          <source>As is mentioned in this &lt;a href=&quot;https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/&quot;&gt;page&lt;/a&gt;:</source>
          <target state="translated">이 &lt;a href=&quot;https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/&quot;&gt;페이지&lt;/a&gt; 에서 언급했듯이 :</target>
        </trans-unit>
        <trans-unit id="e1ea5cc086ad8c105f0de7b7b2d957c6908d8ceb" translate="yes" xml:space="preserve">
          <source>As it is, I am still very biased towards C and biased against C++. Sparing details, much of what I work on fits C more (but it was a good exercise and a good way to make myself a. learn another language and b. try not be less biased against object/classes/etc which is maybe better stated as less closed-minded, less arrogant, and more accepting.). But what &lt;em&gt;is&lt;/em&gt; useful is what some already suggested: I do indeed use list (it is fairly generic, is it not ?), and sort (same thing) to name two that would cause a name clash if I were to do &lt;code&gt;using namespace std;&lt;/code&gt;, and so to that end I prefer being specific, in control and knowing that if I intend it to be the standard use then I will have to specify it. Put simply: no assuming allowed.</source>
          <target state="translated">그대로, 나는 여전히 C에 대해 매우 편견이 있으며 C ++에 대해 편견이 있습니다. 세부 사항을 절약하고, 내가 작업하는 많은 부분이 C에 더 적합합니다 (그러나 그것은 좋은 운동이었고 나 자신을 만드는 좋은 방법이었습니다. 덜 닫힌 마음, 덜 거만하고 더 수용 적.). 그러나 유용한 것은 이미 제안 된 것입니다. 실제로 목록을 사용하고 있습니다 (꽤 일반적이지 않습니까?). &lt;code&gt;using namespace std;&lt;/code&gt; 하면 이름 충돌을 일으킬 수있는 이름을 2로 정렬합니다 (같은 것). ; , 그래서 나는 그것을 구체적으로 사용하는 것을 선호하고 통제하고 표준 사용을 원한다면 그것을 명시해야한다는 것을 알고 있습니다. 간단히 말해서 허용되지 않는다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="a951ab665371162929ad7cc1021e7f306c09ca5a" translate="yes" xml:space="preserve">
          <source>At this point everything is fine. When you run your program it 'Does something'. But later you update &lt;code&gt;bar&lt;/code&gt; and let's say it has changed to be like:</source>
          <target state="translated">이 시점에서 모든 것이 정상입니다. 프로그램을 실행할 때 '무언가를한다'. 그러나 나중에 &lt;code&gt;bar&lt;/code&gt; 업데이트하고 다음과 같이 변경되었다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="9cd966c7ceb5c8bf6d8a1e601c36928bf783b349" translate="yes" xml:space="preserve">
          <source>At this point you'll get a compiler error:</source>
          <target state="translated">이 시점에서 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62f3b54904071c98839a53723f5cac8dbd3c6262" translate="yes" xml:space="preserve">
          <source>At this point your call to &lt;code&gt;a(42)&lt;/code&gt; suddenly binds to &lt;code&gt;bar::a&lt;/code&gt; instead of &lt;code&gt;foo::a&lt;/code&gt; and instead of doing 'something' it does 'something completely different'.  No compiler warning or anything. Your program just silently starts doing something complete different than before.</source>
          <target state="translated">이 시점에서 &lt;code&gt;a(42)&lt;/code&gt; 대한 호출은 갑자기 &lt;code&gt;foo::a&lt;/code&gt; 대신 &lt;code&gt;bar::a&lt;/code&gt; 바인딩되고 '무언가'를 수행하는 대신 '완전히 다른 것'을 수행합니다. 컴파일러 경고 또는 아무것도 없습니다. 당신의 프로그램은 이전과는 완전히 다른 일을 조용히 시작합니다.</target>
        </trans-unit>
        <trans-unit id="36dab49377a029cf015f76cbd70a8bead781a8f1" translate="yes" xml:space="preserve">
          <source>Besides that, you can have namespace aliases. Here is an example of where it is useful that might not have been referred to. I use the C++11 standard and specifically with libstdc++. Well, it doesn't have complete &lt;code&gt;std::regex&lt;/code&gt; support. Sure, it compiles, but it throws an exception along the lines of it being an error on the programmer's end. But it is lack of implementation.</source>
          <target state="translated">그 외에도 네임 스페이스 별칭이있을 수 있습니다. 다음은 참조되지 않은 유용한 위치의 예입니다. 나는 C ++ 11 표준을 사용하며 특히 libstdc ++와 함께 사용합니다. 글쎄, 완전한 &lt;code&gt;std::regex&lt;/code&gt; 지원이 없습니다. 물론 컴파일되지만 프로그래머의 말에 오류가있는 줄을 따라 예외가 발생합니다. 그러나 구현이 부족합니다.</target>
        </trans-unit>
        <trans-unit id="8b819cb9c25c847eca882b7f61088fcf30ea9024" translate="yes" xml:space="preserve">
          <source>Beware that some people disagree with my saying &quot;feel free&quot; like this -- because although a &lt;code&gt;using&lt;/code&gt; statement in a cpp file is &lt;em&gt;better&lt;/em&gt; than in a header (because it doesn't affect people who include your header file), they think it's still not &lt;em&gt;good&lt;/em&gt; (because depending on the code it could make the implementation of the class more difficult to maintain). &lt;a href=&quot;https://isocpp.org/wiki/faq/coding-standards#using-namespace-std&quot;&gt;This C++ Super-FAQ entry&lt;/a&gt; says,</source>
          <target state="translated">일부 사람들은 cpp 파일의 &lt;code&gt;using&lt;/code&gt; 문이 헤더보다 &lt;em&gt;낫지&lt;/em&gt; 만 (헤더 파일을 포함하는 사람들에게 영향을 미치지 않기 때문에) 여전히 내 생각에 동의하지 않는다는 점에 유의하십시오. 좋지 않습니다 (코드에 따라 클래스 구현을 유지하기가 어려울 수 있기 때문에). &lt;a href=&quot;https://isocpp.org/wiki/faq/coding-standards#using-namespace-std&quot;&gt;이 C ++ Super-FAQ 항목&lt;/a&gt; 은 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="3bd225512cee60fc69de0a0f917ae67552b94c49" translate="yes" xml:space="preserve">
          <source>Bottom line: Explicitly prefixing everything doesn't do any harm, takes very little getting used to, and has objective advantages. In particular, it makes the code easier to interpret by the compiler and by human readers &amp;mdash; and that should probably be the main goal when writing code.</source>
          <target state="translated">결론 : 모든 접두사를 명시 적으로 사용하면 아무런 해를 끼치 지 않으며 익숙해지지 않으며 객관적인 이점이 있습니다. 특히 컴파일러와 독자가 코드를 쉽게 해석 할 수있게 해주므로 코드 작성시 주요 목표가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="984d1515ce54fb1acb235d14e03bcd7545ccca8f" translate="yes" xml:space="preserve">
          <source>But imagine an alternative scenario where bar changed instead to look like this instead:</source>
          <target state="translated">그러나 대신 bar가 다음과 같이 바뀌는 대체 시나리오를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="bd243da61bc83e255c691b0eeb1676f5cf315d17" translate="yes" xml:space="preserve">
          <source>Consider</source>
          <target state="translated">Consider</target>
        </trans-unit>
        <trans-unit id="0fde436f316d9e7c2c1244b279c7df1ee1b8459d" translate="yes" xml:space="preserve">
          <source>Consider e.g. writing a piece of numerical software. Why would I even consider polluting my global namespace by cutting general &quot;std::vector&quot; down to &quot;vector&quot; when &quot;vector&quot; is one of the problem domain's most important concepts?</source>
          <target state="translated">예를 들어 수치 소프트웨어를 작성하는 것을 고려하십시오. &quot;vector&quot;가 문제 도메인의 가장 중요한 개념 중 하나 일 때 일반 &quot;std :: vector&quot;를 &quot;vector&quot;로 줄임으로써 글로벌 네임 스페이스를 오염시키는 것을 고려할 필요가있는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4f260645290a8d4cc5baf50a62bc1e04d3f4c8a3" translate="yes" xml:space="preserve">
          <source>Corollary: In header files, don&amp;rsquo;t write namespace-level using directives or using declarations; instead, explicitly namespace-qualify all names. (The second rule follows from the first, because headers can never know what other header #includes might appear after them.)</source>
          <target state="translated">Corollary : 헤더 파일에서 지시문이나 선언을 사용하여 네임 스페이스 수준을 쓰지 마십시오. 대신 모든 이름을 명시 적으로 네임 스페이스로 한정하십시오. (두 번째 규칙은 첫 번째 규칙을 따릅니다. 헤더는 다른 헤더 #include가 그 뒤에 나타날 수있는 것을 알 수 없기 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="b28c908712aa3b3c4f2721161a98d4f73d39f13a" translate="yes" xml:space="preserve">
          <source>Do not use it globally</source>
          <target state="translated">전 세계적으로 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="b10099eb72109a24775417ddca5bf1c65d8e36bc" translate="yes" xml:space="preserve">
          <source>Everything works fine, and you can call &lt;code&gt;Blah()&lt;/code&gt; from Foo and &lt;code&gt;Quux()&lt;/code&gt; from Bar without problems. But one day you upgrade to a new version of Foo 2.0, which now offers a function called &lt;code&gt;Quux()&lt;/code&gt;. Now you've got a conflict: Both Foo 2.0 and Bar import &lt;code&gt;Quux()&lt;/code&gt; into your global namespace. This is going to take some effort to fix, especially if the function parameters happen to match.</source>
          <target state="translated">모든 것이 잘 작동하며 문제없이 Foo의 &lt;code&gt;Blah()&lt;/code&gt; 및 Bar의 &lt;code&gt;Quux()&lt;/code&gt; 를 호출 할 수 있습니다. 그러나 언젠가 새로운 버전의 Foo 2.0으로 업그레이드하여 &lt;code&gt;Quux()&lt;/code&gt; 라는 함수를 제공합니다. 이제 Foo 2.0과 Bar 모두 &lt;code&gt;Quux()&lt;/code&gt; 를 전역 네임 스페이스로 가져옵니다. 특히 함수 매개 변수가 일치하는 경우 수정하기 위해 약간의 노력이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7fdc8f5263841efbcae18f9750a704ca266369d1" translate="yes" xml:space="preserve">
          <source>Experienced programmers also try to avoid full qualification of names inside their source files. A minor reason for this is that it's not elegant to write more code when less code is sufficient &lt;em&gt;unless there are good reasons&lt;/em&gt;. A major reason for this is turning off argument-dependent lookup (ADL).</source>
          <target state="translated">숙련 된 프로그래머는 또한 소스 파일 내에서 이름의 완전한 자격을 피하려고합니다. 이것에 대한 사소한 이유 &lt;em&gt;는 좋은 이유가 없다면&lt;/em&gt; 코드가 충분 &lt;em&gt;하지 않을&lt;/em&gt; 때 더 많은 코드를 작성하는 것이 우아하지 않기 &lt;em&gt;때문&lt;/em&gt; 입니다. 이에 대한 주된 이유는 인수 종속 조회 (ADL)를 끄는 것입니다.</target>
        </trans-unit>
        <trans-unit id="40fc3dd2e604ebb2070a1b8a0000705b0f996fcf" translate="yes" xml:space="preserve">
          <source>Experienced programmers use whatever solves their problems and avoid whatever creates new problems, and they avoid header-file-level using-directives for this exact reason.</source>
          <target state="translated">숙련 된 프로그래머는 문제를 해결하기 위해 무엇이든 사용하고 새로운 문제를 일으키는 것은 피하고 정확한 이유로 헤더 파일 수준의 지시문을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7f84ccc694c5225483eb04c03fd8a8b7d981149" translate="yes" xml:space="preserve">
          <source>For example, if I type in, &lt;code&gt;using namespace std;&lt;/code&gt; and &lt;code&gt;using namespace otherlib;&lt;/code&gt; and type just &lt;code&gt;cout&lt;/code&gt; (which happens to be in both), rather than &lt;code&gt;std::cout&lt;/code&gt; (or &lt;code&gt;'otherlib::cout'&lt;/code&gt;), you might use the wrong one, and get errors. It's much more effective and efficient to use &lt;code&gt;std::cout&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 입력 &lt;code&gt;using namespace std;&lt;/code&gt; 그리고 &lt;code&gt;using namespace otherlib;&lt;/code&gt; &lt;code&gt;std::cout&lt;/code&gt; (또는 &lt;code&gt;'otherlib::cout'&lt;/code&gt; ) 대신 cout (둘 다 발생)을 입력하면 잘못된 것을 사용하고 오류가 발생할 수 있습니다. &lt;code&gt;std::cout&lt;/code&gt; 을 사용하는 것이 훨씬 효과적이고 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="f92e531886e10c1956f1cd4ead46fd24e7ec5ba4" translate="yes" xml:space="preserve">
          <source>From my experiences, if you have multiple libraries that uses say, &lt;code&gt;cout&lt;/code&gt;, but for a different purpose you may use the wrong &lt;code&gt;cout&lt;/code&gt;.</source>
          <target state="translated">내 경험에 따르면 say, &lt;code&gt;cout&lt;/code&gt; 을 사용하는 여러 라이브러리가 있지만 다른 목적으로 잘못된 &lt;code&gt;cout&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc4a2e1c6384a6c0bca9221545adb77b689f41f1" translate="yes" xml:space="preserve">
          <source>Function-level using-directives and using-declarations inside functions' implementations</source>
          <target state="translated">함수 구현 내에서 함수 레벨 사용 지시문 및 사용 선언</target>
        </trans-unit>
        <trans-unit id="e754f634964b71e89733cd919482e9f7c6dc7fd0" translate="yes" xml:space="preserve">
          <source>Go ahead and use it locally (almost) freely. This, of course, prevents you from repetition of &lt;code&gt;std::&lt;/code&gt; -- and repetition is also bad.</source>
          <target state="translated">계속해서 로컬로 (거의) 자유롭게 사용하십시오. 물론 이것은 &lt;code&gt;std::&lt;/code&gt; -의 반복을 막을 수 있으며 반복도 나쁘다.</target>
        </trans-unit>
        <trans-unit id="a13b7ac34e7f5b5ed26674ea84e218245208110c" translate="yes" xml:space="preserve">
          <source>Here's one more data point: Many, many years ago, I also used to find it annoying having to prefix everything from the standard library with &lt;code&gt;std::&lt;/code&gt;. Then I worked in a project where it was decided at the start that both &lt;code&gt;using&lt;/code&gt; directives and declarations are banned except for function scopes. Guess what? It took most of us very few weeks to get used to writing the prefix, and after a few more weeks most of us even agreed that it actually made the code &lt;em&gt;more readable&lt;/em&gt;. There's a reason for that: &lt;strong&gt;&lt;em&gt;Whether you like shorter or longer prose is subjective, but the prefixes objectively add clarity to the code.&lt;/em&gt;&lt;/strong&gt; Not only the compiler, but you, too, find it easier to see which identifier is referred to.</source>
          <target state="translated">여기에 또 하나의 데이터 포인트가 있습니다. 수년 전, 표준 라이브러리의 모든 것을 &lt;code&gt;std::&lt;/code&gt; 로 접두사로 사용하는 것이 귀찮았습니다 . 그런 다음 시작시 함수 범위를 제외하고 지시문과 선언을 모두 &lt;code&gt;using&lt;/code&gt; 하지 못하도록 결정한 프로젝트에서 작업했습니다. 뭔지 맞춰봐? 접두사를 작성하는 데 익숙해지기까지는 대부분 몇 주가 걸렸으며, 몇 주 후에 대부분의 사람들은 실제로 코드를 &lt;em&gt;더 읽기 쉽게&lt;/em&gt; 만들었다는 데 동의했습니다. 그 이유는 &lt;strong&gt;&lt;em&gt;다음과 같습니다. 짧거나 긴 산문을 좋아하든간에 주관적이지만 접두사가 코드에 명확성을 추가합니다.&lt;/em&gt;&lt;/strong&gt; 컴파일러뿐만 아니라 어떤 식별자가 참조되는지 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14cd4a9b5c57786c9dcc406fd5351f54c74541d7" translate="yes" xml:space="preserve">
          <source>Horses for courses - manage your complexity how you best can and feel able.</source>
          <target state="translated">코스를위한 말-최선을 다하고 능력을 발휘하는 방법으로 복잡성을 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="b6059ce195c06e6a8d7d2780b75b1844645eec62" translate="yes" xml:space="preserve">
          <source>However, if I often use 'cout' and 'cin', I write: &lt;code&gt;using std::cout; using std::cin;&lt;/code&gt; in the .cpp file (never in the header file as it propagates with &lt;code&gt;#include&lt;/code&gt;). I think that no one sane will ever name a stream &lt;code&gt;cout&lt;/code&gt; or &lt;code&gt;cin&lt;/code&gt;. ;)</source>
          <target state="translated">그러나 종종 'cout'과 'cin'을 &lt;code&gt;using std::cout; using std::cin;&lt;/code&gt; 다음과 같이 씁니다. using std :: cout; std :: cin 사용; .cpp 파일에서 ( &lt;code&gt;#include&lt;/code&gt; 로 전파 될 때 헤더 파일에는 절대 포함되지 않음) 나는 제정신이 스트림 스트림이나 &lt;code&gt;cin&lt;/code&gt; 이라고 이름을 짓지 않을 것이라고 생각합니다. ;)</target>
        </trans-unit>
        <trans-unit id="2250f701130cc7a3863ada4af431ecaea750adc9" translate="yes" xml:space="preserve">
          <source>However, you may feel free to put a using statement in your (private) *.cpp files.</source>
          <target state="translated">그러나 (개인) * .cpp 파일에 using 문을 자유롭게 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8fafbc70aedce2fc77deabe47f1e309ea3f997a" translate="yes" xml:space="preserve">
          <source>I agree that it should not be used globally, but it's not so evil to use locally, like in a &lt;code&gt;namespace&lt;/code&gt;. Here's an example from &lt;em&gt;&quot;The C++ Programming Language&quot;&lt;/em&gt;:</source>
          <target state="translated">전 세계적으로 사용해서는 안되지만 &lt;code&gt;namespace&lt;/code&gt; 와 같이 로컬에서 사용하는 것은 그렇게 나쁘지 않습니다. 다음은 &lt;em&gt;&quot;C ++ 프로그래밍 언어&quot;의 예입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b957aa59d52d23ef4bc9ed842310ade7ee82aeff" translate="yes" xml:space="preserve">
          <source>I agree with everything &lt;a href=&quot;https://stackoverflow.com/questions/1452721/1452738#1452738&quot;&gt;Greg wrote&lt;/a&gt;, but I'd like to add: &lt;strong&gt;&lt;em&gt;It can even get worse than Greg said!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">나는 &lt;a href=&quot;https://stackoverflow.com/questions/1452721/1452738#1452738&quot;&gt;Greg가 쓴&lt;/a&gt; 모든 것에 동의하지만 추가하고 싶습니다 : &lt;strong&gt;&lt;em&gt;Greg가 말한 것보다 더 나빠질 수 있습니다!&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3806b9230c26bc35f5387e9568e05e858aa6bb5a" translate="yes" xml:space="preserve">
          <source>I agree with others &amp;ndash; it is asking for name clashes, ambiguities and then the fact is it is less explicit. While I can see the use of &lt;code&gt;using&lt;/code&gt;, my personal preference is to limit it. I would also strongly consider what some others pointed out:</source>
          <target state="translated">나는 다른 사람들에 동의한다 &amp;ndash; 그것은 이름 충돌, 모호성을 요구하고있다. 그리고 사실은 덜 명백하다. 의 사용을 볼 수는 있지만 개인적 선호는 사용을 제한하는 것입니다. 또한 다른 사람들이 지적한 것을 강력하게 고려할 것입니다.</target>
        </trans-unit>
        <trans-unit id="de2e7022c8f014a2e70b1ef6b6313df62304adae" translate="yes" xml:space="preserve">
          <source>I agree with the others here, but I would like to address the concerns regarding readability - you can avoid all of that by simply using typedefs at the top of your file, function or class declaration.</source>
          <target state="translated">나는 다른 사람들과 동의하지만 가독성과 관련된 문제를 해결하고 싶습니다. 파일, 함수 또는 클래스 선언 맨 위에 typedef를 사용하면 모든 것을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1763537fa947e39d61c79dbb27ae0c8d2955d02f" translate="yes" xml:space="preserve">
          <source>I also consider it a bad practice. Why? Just one day I thought that the function of a namespace is to divide stuff, so I shouldn't spoil it with throwing everything into one global bag.</source>
          <target state="translated">또한 나쁜 습관이라고 생각합니다. 왜? 언젠가는 네임 스페이스의 기능이 물건을 나누는 것이라고 생각했기 때문에 모든 것을 하나의 글로벌 백에 던지는 것을 망쳐서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="de6cf10d0eaf9e11a0c6a2571f7cee7c4459b91d" translate="yes" xml:space="preserve">
          <source>I do not think it is necessarily bad practice under all conditions, but you need to be careful when you use it.  If you're writing a library, you probably should use the scope resolution operators with the namespace to keep your library from butting heads with other libraries.  For application level code, I don't see anything wrong with it.</source>
          <target state="translated">모든 조건에서 반드시 나쁜 습관이라고 생각하지는 않지만 사용할 때는주의해야합니다. 라이브러리를 작성하는 경우 네임 스페이스와 함께 범위 확인 연산자를 사용하여 라이브러리가 다른 라이브러리와 헤드를 충돌하지 않도록해야합니다. 응용 프로그램 수준 코드의 경우 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5080a2a4a2beb8872491aa265a231ea1ed16674" translate="yes" xml:space="preserve">
          <source>I mean really... saying &quot;don't rely on this being present&quot; is just setting you up to rely on it NOT being present.  You are constantly going to have issues borrowing code snippets and constantly repairing them.  Just keep your user-defined and borrowed stuff in limited scope as they should be and be VERY sparing with globals (honestly globals should almost always be a last resort for purposes of &quot;compile now, sanity later&quot;). Truly I think it is bad advice from your teacher because using std will work for both &quot;cout&quot; and &quot;std::cout&quot; but NOT using std will only work for &quot;std::cout&quot;.  You will not always be fortunate enough to write all your own code.</source>
          <target state="translated">내 말은 ... &quot;현재 존재하는 것에 의존하지 말라&quot;는 말은 당신이 존재하지 않는 것에 의존하도록 설정하는 것입니다. 코드 스 니펫을 차용하고 지속적으로 수리하는 데 문제가 계속 발생합니다. 사용자 정의 및 빌린 물건을 제한된 범위로 유지하고 전역과 매우 아껴서 사용하십시오 (정직한 세계는 &quot;지금 컴파일하고 나중에는 정신을 바꾼다&quot;의 목적으로 거의 항상 최후의 수단이어야합니다). std를 사용하면 &quot;cout&quot;과 &quot;std :: cout&quot;모두에 대해 작동하지만 std를 사용하지 않으면 &quot;std :: cout&quot;에 대해서만 작동하기 때문에 교사의 조언이 잘못된 것 같습니다. 자신의 코드를 모두 작성하기에 항상 운이 좋은 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f75a67cd99e9c9fbf6abd8a8f84e205de1d5a8c2" translate="yes" xml:space="preserve">
          <source>I put it the other way around: Why is typing five extra characters considered cumbersome by some?</source>
          <target state="translated">나는 그것을 다른 방식으로 넣었습니다. 왜 5 명의 추가 문자를 입력하면 일부는 번거로운 것으로 간주됩니까?</target>
        </trans-unit>
        <trans-unit id="315d92e4893f10fb88044d2ccdcfc00fb3e343d7" translate="yes" xml:space="preserve">
          <source>I recently ran into a complaint about &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2010&lt;/a&gt;. It turned out that pretty much all the source files had these two lines:</source>
          <target state="translated">최근에 &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010&quot;&gt;Visual Studio 2010&lt;/a&gt; 에 대한 불만이있었습니다. 거의 모든 소스 파일에 다음 두 줄이 있다는 것이 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="8441eb391ffa1ac35a213cb285d116689923e4e3" translate="yes" xml:space="preserve">
          <source>I usually use it in my class declaration as methods in a class tend to deal with similar data types (the members) and a typedef is an opportunity to assign a name that is meaningful in the context of the class. This actually aids readability in the definitions of the class methods.</source>
          <target state="translated">클래스의 메소드는 비슷한 데이터 유형 (멤버)을 처리하는 경향이 있으므로 typedef는 클래스의 컨텍스트에서 의미있는 이름을 지정할 수있는 기회이므로 일반적으로 클래스 선언에서 사용합니다. 이것은 실제로 클래스 메소드의 정의에서 가독성을 돕습니다.</target>
        </trans-unit>
        <trans-unit id="ae395c81a97e21bacfb9359546bf7289ddc3c88b" translate="yes" xml:space="preserve">
          <source>I won't argue on whether that is a bad idea or not. I will however argue that it keeps it clean for &lt;em&gt;my&lt;/em&gt; project and at the same time makes it specific: True, I have to use Boost, &lt;em&gt;but&lt;/em&gt; I'm using it like the libstdc++ will eventually have it. Yes, starting your own project and starting with a standard (...) at the very beginning goes a very long way with helping maintenance, development and everything involved with the project!</source>
          <target state="translated">나는 그것이 나쁜 생각인지 아닌지에 대해서는 논쟁하지 않을 것이다. 그러나 나는 그것이 &lt;em&gt;내&lt;/em&gt; 프로젝트를 깨끗하게 유지하고 동시에 그것을 특정하게 만든다고 주장 할 것입니다 : True, Boost를 사용해야 &lt;em&gt;하지만&lt;/em&gt; libstdc ++가 결국 그것을 가지고있는 것처럼 사용하고 있습니다. 예, 자신의 프로젝트를 시작하고 처음에 표준 (...)으로 시작하면 유지 관리, 개발 및 프로젝트와 관련된 모든 것을 돕는 데 매우 먼 길을갑니다!</target>
        </trans-unit>
        <trans-unit id="19e234fd1ffb5551c9bacc76444a0745a8b46a07" translate="yes" xml:space="preserve">
          <source>I've been told by others that writing &lt;code&gt;using namespace std;&lt;/code&gt; in code is wrong, and that I should use &lt;code&gt;std::cout&lt;/code&gt; and &lt;code&gt;std::cin&lt;/code&gt; directly instead.</source>
          <target state="translated">나는 다른 사람들에게 &lt;code&gt;using namespace std;&lt;/code&gt; 쓰는 것을 들었습니다 . 코드에서 잘못되었으며 대신 &lt;code&gt;std::cout&lt;/code&gt; 및 &lt;code&gt;std::cin&lt;/code&gt; 직접 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="091066152480cd6d7ec51ddc1f6d09610b9d55a1" translate="yes" xml:space="preserve">
          <source>If I see &lt;code&gt;cout &amp;lt;&amp;lt; blah&lt;/code&gt;, instead of &lt;code&gt;std::cout &amp;lt;&amp;lt; blah&lt;/code&gt; I think: What is this &lt;code&gt;cout&lt;/code&gt;? Is it the normal &lt;code&gt;cout&lt;/code&gt;? Is it something special?</source>
          <target state="translated">&lt;code&gt;std::cout &amp;lt;&amp;lt; blah&lt;/code&gt; 대신 &lt;code&gt;cout &amp;lt;&amp;lt; blah&lt;/code&gt; 되면이 &lt;code&gt;cout&lt;/code&gt; 은 무엇입니까? 그것은 정상적인 &lt;code&gt;cout&lt;/code&gt; 입니까? 뭔가 특별한가요?</target>
        </trans-unit>
        <trans-unit id="5a9372cdbb50764ea955811dd61572f65ed573bd" translate="yes" xml:space="preserve">
          <source>If all the standard stuff is in its own namespace you don't have to worry about name collisions with your code or other libraries.</source>
          <target state="translated">모든 표준 항목이 자체 네임 스페이스에 있으면 코드 또는 다른 라이브러리와의 이름 충돌에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="05bbbb5c87545d8ed21bba66dec5dbe3cf4e541d" translate="yes" xml:space="preserve">
          <source>If you consider this unlikely: There was &lt;a href=&quot;https://stackoverflow.com/a/2712125/140719&quot;&gt;a question asked&lt;/a&gt; here on Stack Overflow where pretty much exactly this happened (wrong function called due to omitted &lt;code&gt;std::&lt;/code&gt; prefix) about half a year after I gave this answer. &lt;a href=&quot;https://stackoverflow.com/questions/13402789/&quot;&gt;Here&lt;/a&gt; is another, more recent example of such a question.
So this is a real problem.</source>
          <target state="translated">당신이 이것을 가능성이 거의 없다고 생각하면 :이 답변을 준 후 반 &lt;code&gt;std::&lt;/code&gt; 정확히 정확히 이런 일이 발생하는 스택 오버플로 (여기서 std :: 접두사로 잘못 호출 된 함수)에 대한 질문이있었습니다. 이러한 질문에 대한 또 다른 더 최근의 예가 있습니다. 따라서 이것은 실제 문제입니다.</target>
        </trans-unit>
        <trans-unit id="883b59bb138a2b98dd2f53050ba718757c60f448" translate="yes" xml:space="preserve">
          <source>If you do &lt;em&gt;not&lt;/em&gt; have that overload the compiler will use &lt;code&gt;void std::swap(Child&amp;amp;,Child&amp;amp;)&lt;/code&gt; and try its best swapping these.</source>
          <target state="translated">과부하가 &lt;em&gt;없으면&lt;/em&gt; 컴파일러는 &lt;code&gt;void std::swap(Child&amp;amp;,Child&amp;amp;)&lt;/code&gt; 하고 최선의 스왑을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="81009c04e328b3a3b5aadc7fe747aad2c2287d54" translate="yes" xml:space="preserve">
          <source>If you had used &lt;code&gt;foo::Blah()&lt;/code&gt; and &lt;code&gt;bar::Quux()&lt;/code&gt;, then the introduction of &lt;code&gt;foo::Quux()&lt;/code&gt; would have been a non-event.</source>
          <target state="translated">&lt;code&gt;foo::Blah()&lt;/code&gt; 및 &lt;code&gt;bar::Quux()&lt;/code&gt; 를 사용했다면 &lt;code&gt;foo::Quux()&lt;/code&gt; 소개는 이벤트가 아니었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d31c157553e55cd020a04b1f31d6a0bd553ab83f" translate="yes" xml:space="preserve">
          <source>If you have an overload &lt;code&gt;void swap(Child&amp;amp;, Child&amp;amp;)&lt;/code&gt; implemented the compiler will choose it.</source>
          <target state="translated">과부하 &lt;code&gt;void swap(Child&amp;amp;, Child&amp;amp;)&lt;/code&gt; 구현되어 있으면 컴파일러가이를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6cfd5241c3ace598230b440bf15ea476ef327fab" translate="yes" xml:space="preserve">
          <source>If you import the right header files you suddenly have names like &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/hex&quot;&gt;&lt;code&gt;hex&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/left&quot;&gt;&lt;code&gt;left&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/functional/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; in your global scope. This might be surprising if you are not aware that &lt;code&gt;std::&lt;/code&gt; contains these names. If you also try to use these names locally it can lead to quite some confusion.</source>
          <target state="translated">올바른 헤더 파일을 가져 오면 갑자기 전역 범위에 &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/hex&quot;&gt; &lt;code&gt;hex&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/left&quot;&gt; &lt;code&gt;left&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/functional/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 와 같은 이름이 있습니다. &lt;code&gt;std::&lt;/code&gt; 에 이러한 이름이 포함되어 있음을 모르는 경우 놀라운 결과 일 수 있습니다. 이 이름을 로컬로 사용하려고하면 혼란이 생길 ​​수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d02f14101198ab0a96dc0a62eeaadc30eac403e" translate="yes" xml:space="preserve">
          <source>If you only talk about &lt;code&gt;using namespace std&lt;/code&gt; you might not be aware of all the stuff you grab -- and when you add another &lt;code&gt;#include&lt;/code&gt; or move to a new C++ revision you might get name conflicts you were not aware of.</source>
          <target state="translated">&lt;code&gt;using namespace std&lt;/code&gt; 대해서만 이야기하면 잡은 모든 것을 알지 못할 수 있습니다. 다른 &lt;code&gt;#include&lt;/code&gt; 를 추가하거나 새 C ++ 개정으로 이동할 때 알지 못하는 이름 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4713f3b8d7aeb939fd9e031cf10de0c3697de5bd" translate="yes" xml:space="preserve">
          <source>If you want to find a function name that might be a fairly common name, but you only want to find it in the &lt;code&gt;std&lt;/code&gt; namespace (or the reverse &amp;ndash; you want to change all calls that are &lt;em&gt;not&lt;/em&gt; in namespace &lt;code&gt;std&lt;/code&gt;, namespace &lt;code&gt;X&lt;/code&gt;, ...), then how do you propose to do this?</source>
          <target state="translated">상당히 일반적인 이름 일 수있는 함수 이름을 찾고 싶지만 &lt;code&gt;std&lt;/code&gt; 네임 스페이스 (또는 그 반대)에서만 찾고자하는 경우 네임 스페이스 &lt;code&gt;std&lt;/code&gt; , namespace &lt;code&gt;X&lt;/code&gt; ..에 &lt;em&gt;없는&lt;/em&gt; 모든 호출을 변경하려고합니다. )) 그렇다면 어떻게이 작업을 제안합니까?</target>
        </trans-unit>
        <trans-unit id="c4a5742abc54fef340d5e42bb52ab3d34501cefb" translate="yes" xml:space="preserve">
          <source>If you're only using &lt;code&gt;cout&lt;/code&gt;, nobody gets confused.  But when you have lots of namespaces flying around and you see this class and you aren't exactly sure what it does, having the namespace explicit acts as a comment of sorts. You can see at first glance, &quot;oh, this is a filesystem operation&quot; or &quot;that's doing network stuff&quot;.</source>
          <target state="translated">&lt;code&gt;cout&lt;/code&gt; 만 사용하고 있다면 아무도 혼란스럽지 않습니다. 그러나 많은 네임 스페이스가 날고 있고이 클래스를 볼 때 클래스가 무엇인지 정확히 알지 못하면 명시 적 네임 스페이스가 일종의 주석으로 작동합니다. 언뜻보기에 &quot;오, 이것은 파일 시스템 작업입니다&quot;또는 &quot;네트워크 작업을 수행하고 있습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="3a0a2f58e94e59b13e5b57410ca215b154e4dd1a" translate="yes" xml:space="preserve">
          <source>In C++03 there was an idiom -- boilerplate code -- for implementing a &lt;code&gt;swap&lt;/code&gt; function for your classes. It was suggested that you actually use a local &lt;code&gt;using namespace std&lt;/code&gt; -- or at least &lt;code&gt;using std::swap&lt;/code&gt;:</source>
          <target state="translated">C ++ 03에는 클래스 &lt;code&gt;swap&lt;/code&gt; 함수를 구현하기위한 관용구 (보일러 플레이트 코드)가있었습니다. 실제로 &lt;code&gt;using namespace std&lt;/code&gt; 하거나 적어도 &lt;code&gt;using std::swap&lt;/code&gt; 사용하여 로컬 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4efd6ea07a2c12ae34510e9920765f13b7b87856" translate="yes" xml:space="preserve">
          <source>In a decade, that project grew to have several million lines of code. Since these discussions come up again and again, I once was curious how often the (allowed) function-scope &lt;code&gt;using&lt;/code&gt; actually was used in the project. I grep'd the sources for it and only found one or two dozen places where it was used. To me this indicates that, once tried, developers don't find &lt;code&gt;std::&lt;/code&gt; painful enough to employ using directives even once every 100 kLoC even where it was allowed to be used.</source>
          <target state="translated">10 년 동안이 프로젝트는 수백만 줄의 코드로 성장했습니다. 이러한 논의가 계속 반복되어 왔기 때문에 프로젝트에서 실제로 &lt;code&gt;using&lt;/code&gt; 하는 (허용 된) 함수 범위가 얼마나 자주 사용되는지 궁금했습니다. 나는 그 소스를 grep하고 그것이 사용 된 한두 곳에서만 발견했다. 나에게 이것은 일단 시도하면 개발자가 &lt;code&gt;std::&lt;/code&gt; 를 사용하지 않아도 100 kLoC마다 한 번이라도 지시문을 사용할 정도로 고통 스럽다는 것을 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="06435acc952b6ddf3ff59e777675ac2714343da8" translate="yes" xml:space="preserve">
          <source>In short: You can and should use namespace using declarations and directives liberally in your implementation files after #include directives and feel good about it. &lt;strong&gt;Despite repeated assertions to the contrary, namespace using declarations and directives are not evil and they do not defeat the purpose of namespaces. Rather, they are what make namespaces usable&lt;/strong&gt;.</source>
          <target state="translated">간단히 말해 : #include 지시문 다음에 구현 파일에서 선언과 지시문을 자유롭게 사용하여 네임 스페이스를 사용할 수 있고 사용해야합니다. &lt;strong&gt;반대로 반복되는 주장에도 불구하고 선언과 지시문을 사용하는 네임 스페이스는 악의적이지 않으며 네임 스페이스의 목적을 무시하지 않습니다.&lt;/strong&gt; &lt;strong&gt;오히려 네임 스페이스를 사용할 수있게 만드는 요소&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ec2299e86922f16c12bb89391ea97d486f2d6389" translate="yes" xml:space="preserve">
          <source>In this example, we resolved potential name clashes and ambiguities arising from their composition.</source>
          <target state="translated">이 예에서는 잠재적 인 이름 충돌과 그 구성으로 인해 발생하는 모호성을 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="65c4c1dce2db14606c299117092648f5be7eb3d2" translate="yes" xml:space="preserve">
          <source>It depends on where it is located. If it is a common header, then you are diminishing the value of the namespace by merging it into the global namespace. Keep in mind, this could be a neat way of making module globals.</source>
          <target state="translated">위치에 따라 다릅니다. 공통 헤더 인 경우 네임 스페이스의 값을 전역 네임 스페이스에 병합하여 네임 스페이스의 값을 줄입니다. 모듈 전역을 만드는 깔끔한 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9149a57a26a9aeee68e53682d200c4529d40a43" translate="yes" xml:space="preserve">
          <source>It doesn't make your software or project performance worse. The inclusion of the namespace at the beginning of your source code isn't bad. The inclusion of the &lt;code&gt;using namespace std&lt;/code&gt; instruction varies according to your needs and the way you are developing the software or project.</source>
          <target state="translated">소프트웨어 나 프로젝트 성능을 악화 시키지는 않습니다. 소스 코드 시작 부분에 네임 스페이스를 포함시키는 것은 나쁘지 않습니다. &lt;code&gt;using namespace std&lt;/code&gt; 명령어의 포함은 사용자의 요구와 소프트웨어 또는 프로젝트 개발 방식에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2594ecb269de1ca1ca972a398f9ac08229b7f4f0" translate="yes" xml:space="preserve">
          <source>It is considered &quot;bad&quot; only when &lt;strong&gt;used globally&lt;/strong&gt;. Because:</source>
          <target state="translated">&lt;strong&gt;전 세계적으로 사용될&lt;/strong&gt; 때만 &quot;나쁜&quot;것으로 간주 &lt;strong&gt;됩니다&lt;/strong&gt; . 때문에:</target>
        </trans-unit>
        <trans-unit id="1ebc6c4aab7254b3c847f7a94a880434c0e2f28e" translate="yes" xml:space="preserve">
          <source>It's all about managing complexity. Using the namespace will pull things in that you don't want, and thus possibly make it harder to debug (I say possibly). Using std:: all over the place is harder to read (more text and all that).</source>
          <target state="translated">복잡성을 관리하는 것이 전부입니다. 네임 스페이스를 사용하면 원하지 않는 것들을 끌어 들일 수 있으므로 디버그하기가 더 어려워집니다 (가능하다고 말합니다). std :: 사용 : 모든 곳에서 읽기가 더 어렵습니다 (텍스트와 그 이상).</target>
        </trans-unit>
        <trans-unit id="38709085bed04576c2d5d32366c7d466d551f5ee" translate="yes" xml:space="preserve">
          <source>It's nice to see code and know what it does. If I see &lt;code&gt;std::cout&lt;/code&gt; I know that's the &lt;code&gt;cout&lt;/code&gt; stream of the &lt;code&gt;std&lt;/code&gt; library. If I see &lt;code&gt;cout&lt;/code&gt; then I don't know. It &lt;em&gt;could&lt;/em&gt; be the &lt;code&gt;cout&lt;/code&gt; stream of the &lt;code&gt;std&lt;/code&gt; library. Or there could be an &lt;code&gt;int cout = 0;&lt;/code&gt; ten lines higher in the same function. Or a &lt;code&gt;static&lt;/code&gt; variable named &lt;code&gt;cout&lt;/code&gt; in that file. It could be anything.</source>
          <target state="translated">코드를보고 코드의 기능을 아는 것이 좋습니다. &lt;code&gt;std::cout&lt;/code&gt; 표시되면 이것이 &lt;code&gt;std&lt;/code&gt; 라이브러리의 &lt;code&gt;cout&lt;/code&gt; 스트림이라는 것을 알고 있습니다. 내가 &lt;code&gt;cout&lt;/code&gt; 을 본다면 나는 모른다. &lt;code&gt;std&lt;/code&gt; 라이브러리의 &lt;code&gt;cout&lt;/code&gt; 스트림 일 &lt;em&gt;수&lt;/em&gt; 있습니다. 또는 &lt;code&gt;int cout = 0;&lt;/code&gt; 일 수 있습니다 . 같은 기능에서 10 줄이 더 높습니다. 또는 해당 파일에 &lt;code&gt;cout&lt;/code&gt; 이라는 &lt;code&gt;static&lt;/code&gt; 변수가 있습니다. 무엇이든 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="291d10432ee90ffee7774e1bfd80a03295550276" translate="yes" xml:space="preserve">
          <source>It's not horrible, but you'll save yourself headaches by not using it in header files or the global namespace. It's probably all right to do it in very limited scopes, but I've never had a problem typing the extra five characters to clarify where my functions are coming from.</source>
          <target state="translated">끔찍한 것은 아니지만 헤더 파일이나 전역 네임 스페이스에서 두통을 사용하지 않으면 두통을 피할 수 있습니다. 매우 제한된 범위 에서이 작업을 수행하는 것이 좋을 수도 있지만 함수의 출처를 명확히하기 위해 추가로 5자를 입력하는 데 아무런 문제가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="9baf97e2ec47fa798dfe06c21b8e750de1bac58f" translate="yes" xml:space="preserve">
          <source>It's one of these things that seem a really good idea if you are a teacher and never had to write and maintain any code for a living. I love seeing code where (1) I know what it does; and, (2) I'm confident that the person writing it knew what it does.</source>
          <target state="translated">당신이 교사이고 생계를 위해 코드를 작성하고 유지할 필요가 없다면 정말 좋은 생각처럼 보이는 것 중 하나입니다. 나는 코드를 보는 것을 좋아한다. (1) 내가하는 일을 알고있다. 그리고, (2) 나는 그것을 쓰는 사람이 그것이 무엇을하는지 알고 있다고 확신한다.</target>
        </trans-unit>
        <trans-unit id="91a8c9eace09304424f54dbcea4ab917ef139db7" translate="yes" xml:space="preserve">
          <source>Just to clarify something: I don't actually think it is a good idea to use a name of a class/whatever in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; deliberately and more specifically in place of. The string is the exception (ignore the first, above, or second here, pun if you must) for me as I didn't like the idea of 'String'.</source>
          <target state="translated">무언가를 분명히하기 위해 : 실제로 &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; 의 클래스 / 이름을 고의적으로 더 구체적으로 사용하는 것이 좋은 생각은 아닙니다. 'String'이라는 아이디어가 마음에 들지 않았으므로 문자열은 예외입니다 (필요한 경우 말장난, 첫 번째, 위 또는 두 번째 무시).</target>
        </trans-unit>
        <trans-unit id="29daf4a7594ca589153ad134f21264fe11ca3416" translate="yes" xml:space="preserve">
          <source>Just typing std::</source>
          <target state="translated">std :: 만 입력하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8507557482216947016f1aeee1629d528f10442b" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;std&lt;/code&gt; namespace has tons of identifiers, many of which are &lt;em&gt;very&lt;/em&gt; common ones (think &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, etc.) which are very likely to appear in other code, too.</source>
          <target state="translated">&lt;code&gt;std&lt;/code&gt; 네임 스페이스에는 수많은 식별자가 있으며 그중 많은 식별자가 다른 코드에도 나타날 가능성이 &lt;em&gt;매우&lt;/em&gt; 일반적인 식별자 (think &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;sort&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; 등)입니다.</target>
        </trans-unit>
        <trans-unit id="6a07da18fbe175d65d1d0865aa1dc4b50b7ab47f" translate="yes" xml:space="preserve">
          <source>Library Foo 2.0 could introduce a function, &lt;code&gt;Quux()&lt;/code&gt;, that is an unambiguously better match for some of your calls to &lt;code&gt;Quux()&lt;/code&gt; than the &lt;code&gt;bar::Quux()&lt;/code&gt; your code called for years. Then your &lt;strong&gt;&lt;em&gt;code still compiles&lt;/em&gt;&lt;/strong&gt;, but &lt;strong&gt;&lt;em&gt;it silently calls the wrong function&lt;/em&gt;&lt;/strong&gt; and does god-knows-what. That's about as bad as things can get.</source>
          <target state="translated">Library Foo 2.0은 &lt;code&gt;Quux()&lt;/code&gt; 함수를 도입 할 수 있는데, 이것은 코드가 몇 년 동안 호출 한 &lt;code&gt;bar::Quux()&lt;/code&gt; 보다 &lt;code&gt;Quux()&lt;/code&gt; 대한 일부 호출에 대해 분명하게 더 잘 맞는 함수입니다. 그런 다음 &lt;strong&gt;&lt;em&gt;코드는 여전히 컴파일&lt;/em&gt;&lt;/strong&gt; 되지만 &lt;strong&gt;&lt;em&gt;자동으로 잘못된 함수를 호출하고&lt;/em&gt;&lt;/strong&gt; 신을 알 수 있습니다. 그것은 물건이 얻을 수있는만큼 나쁘다.</target>
        </trans-unit>
        <trans-unit id="5124022ffb20c699c10a1cc2488c255b2ffc9a00" translate="yes" xml:space="preserve">
          <source>NOTE: Don't focus too much on efficiency issues until you actually learn a little about how compilers work.  With a little experience coding you don't have to learn that much about them before you realize how much they are able to generalize good code into something something simple.  Every bit as simple as if you wrote the whole thing in C.  Good code is only as complex as it needs to be.</source>
          <target state="translated">참고 : 실제로 컴파일러의 작동 방식에 대해 조금 배울 때까지 효율성 문제에 너무 집중하지 마십시오. 코딩 경험이 적 으면 좋은 코드를 간단한 것으로 일반화 할 수있는 양을 깨닫기 전에 그에 대해 많이 배울 필요가 없습니다. C로 전체 내용을 작성하는 것처럼 간단합니다. 좋은 코드는 필요한만큼 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="9ce878b56aa89e0fc6464244ab6312410a2325ee" translate="yes" xml:space="preserve">
          <source>Names explicitly declared there (including names declared by using-declarations like &lt;code&gt;His_lib::String&lt;/code&gt;) take priority over names made accessible in another scope by a using-directive (&lt;code&gt;using namespace Her_lib&lt;/code&gt;).</source>
          <target state="translated">거기에 명시 적으로 선언 된 이름 ( &lt;code&gt;His_lib::String&lt;/code&gt; 과 같은 using-declaration에 의해 선언 된 이름 포함)은 using-directive ( &lt;code&gt;using namespace Her_lib&lt;/code&gt; )에 의해 다른 범위에서 액세스 가능한 이름보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="50b2a2e68d91a2fa20faee50e5b1093521bfac70" translate="yes" xml:space="preserve">
          <source>Namespace usings are for your convenience, not for you to inflict on others: Never write a using declaration or a using directive before an #include directive.</source>
          <target state="translated">네임 스페이스 사용은 다른 사람에게 영향을주지 않는 편의를위한 것입니다. #include 지시문 앞에 using 선언 또는 using 지시문을 작성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="50b1f6a51d747783cb1dfe6047e35834dd447f4e" translate="yes" xml:space="preserve">
          <source>Namespaces provide a powerful tool for the management of different libraries and of different versions of code. In particular, they offer the programmer alternatives of how explicit to make a reference to a nonlocal name.</source>
          <target state="translated">네임 스페이스는 다른 라이브러리와 다른 버전의 코드를 관리 할 수있는 강력한 도구를 제공합니다. 특히, 비 로컬 이름을 참조하는 방법에 대한 프로그래머 대안을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ddbccb0a8b6506410340a7f532fe40e471a2e05a" translate="yes" xml:space="preserve">
          <source>Note that this is a simple example. If you have files with 20 includes and other imports, you'll have a ton of dependencies to go through to figure out the problem. The worse thing about it is that you can get unrelated errors in other modules depending on the definitions that conflict.</source>
          <target state="translated">이것은 간단한 예입니다. 포함 및 기타 가져 오기가 20 개인 파일이있는 경우 문제점을 파악하기 위해 많은 종속성이 필요합니다. 더 나쁜 점은 충돌하는 정의에 따라 다른 모듈에서 관련이없는 오류가 발생할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="36ea41aee46346ce28dcadcb94012cb303748b76" translate="yes" xml:space="preserve">
          <source>Notice how there is an ambiguity, to which library does cout point to?
  The compiler may detect this and not compile the program. In the worst
  case, the program may still compile but call the wrong function, since
  we never specified to which namespace the identifier belonged.</source>
          <target state="translated">어떤 라이브러리가 cout을 가리키고 있는지 모호한 점에 주목하십시오. 컴파일러는이를 감지하고 프로그램을 컴파일하지 않을 수 있습니다. 최악의 경우 식별자가 속한 네임 스페이스를 지정하지 않았기 때문에 프로그램은 여전히 ​​컴파일되지만 잘못된 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f735b7708587108249bd04f231f9283a15ed3614" translate="yes" xml:space="preserve">
          <source>Now at a later stage of development, we wish to use another version of
  cout that is custom implemented in some library called &amp;ldquo;foo&amp;rdquo; (for
  example)</source>
          <target state="translated">이제 개발의 나중 단계에서 &quot;foo&quot;라는 라이브러리에서 사용자 정의 구현 된 다른 버전의 cout을 사용하려고합니다 (예 :)</target>
        </trans-unit>
        <trans-unit id="a91a9e9922efdb33f03078a0f38ce71a94f60ab3" translate="yes" xml:space="preserve">
          <source>Now let's say you use &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together in your own program as follows:</source>
          <target state="translated">이제 다음과 같이 자신의 프로그램에서 &lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;bar&lt;/code&gt; 를 함께 사용한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="ce4819e926b1c69f9e959f1bcce61b24bbf7402f" translate="yes" xml:space="preserve">
          <source>Now take a million line code base, which isn't particularly big, and you're searching for a bug, which means you know there is one line in this one million lines that doesn't do what it is supposed to do. &lt;code&gt;cout &amp;lt;&amp;lt; 1;&lt;/code&gt; could read a &lt;code&gt;static int&lt;/code&gt; named &lt;code&gt;cout&lt;/code&gt;, shift it to the left by one bit, and throw away the result. Looking for a bug, I'd have to check that. Can you see how I really really prefer to see &lt;code&gt;std::cout&lt;/code&gt;?</source>
          <target state="translated">이제 백만 줄 코드베이스를 취하십시오. 특히 크지 않은 버그를 찾고 있습니다.이 백만 줄에 한 줄이 있다는 것을 알고 있음을 의미합니다. &lt;code&gt;cout &amp;lt;&amp;lt; 1;&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; 이라는 &lt;code&gt;static int&lt;/code&gt; 읽고 1 비트 왼쪽으로 시프트 한 다음 결과를 버릴 수 있습니다. 버그를 찾으려면 확인해야합니다. 내가 정말로 &lt;code&gt;std::cout&lt;/code&gt; 선호하는 것을 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="399f9e8eb4c399a3656111274a9c1b117d6d1db3" translate="yes" xml:space="preserve">
          <source>One shouldn't use the &lt;code&gt;using&lt;/code&gt; directive at the global scope, especially in headers. However, there are situations where it is appropriate even in a header file:</source>
          <target state="translated">전역 범위, 특히 헤더에서 &lt;code&gt;using&lt;/code&gt; 지시문을 사용해서는 안됩니다. 그러나 헤더 파일에서도 적절한 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1516c0ad1f8ca81d0226fc547e43c805fde700c0" translate="yes" xml:space="preserve">
          <source>People should stop being so anal about it. Your teacher was right all along. Just use ONE namespace; that is the whole point of using namespaces the first place. You are not supposed to use more than one at the same time. Unless it is your own. So again, redefinition will not happen.</source>
          <target state="translated">사람들은 그것에 대해 너무 항문 적이 지 않아야합니다. 선생님이 잘 지내셨습니다. 하나의 네임 스페이스 만 사용하십시오. 그것이 네임 스페이스를 처음 사용하는 요점입니다. 동시에 둘 이상을 사용해서는 안됩니다. 그것이 당신의 것이 아닌 한. 다시 정의하면 다시 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61ba504ad16f53fef83a89ee5e1bf8d3fd48334a" translate="yes" xml:space="preserve">
          <source>Personally, I actually don't mind the &lt;code&gt;std::&lt;/code&gt; prefix. I like the look more than not having it. I don't know if that is because it is explicit and says to me &quot;this isn't my code... I am using the standard library&quot; or if it is something else, but I think it looks nicer. This might be odd given that I only recently got into C++ (used and still do C and other languages for much longer and C is my favourite language of all time, right above assembly).</source>
          <target state="translated">개인적으로, 나는 실제로 &lt;code&gt;std::&lt;/code&gt; 접두사를 신경 쓰지 않습니다. 나는 그것을하지 않는 것보다 더 좋아 보인다. 나는 그것이 명시적이고 나에게 &quot;이것은 내 코드가 아닙니다 ... 표준 라이브러리를 사용하고 있습니다&quot;라고 말했는지 또는 다른 것이 있는지는 모르겠지만 더 멋지다고 생각합니다. 최근에 C ++ 만 사용하고 (C와 다른 언어를 훨씬 더 오랫동안 사용하고 C는 어셈블리 바로 위에있는 가장 좋아하는 언어입니다) 이상한 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a84cb2b057f0497de2c666cab0ffec97887f04" translate="yes" xml:space="preserve">
          <source>Readers will have difficulty seeing where a particular identifier comes from, when you use many &lt;code&gt;using namespace xyz&lt;/code&gt;.</source>
          <target state="translated">많은 &lt;code&gt;using namespace xyz&lt;/code&gt; 를 사용하면 독자가 특정 식별자의 출처를 알기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="9140d5235666001f10df811c2360c257238af8d5" translate="yes" xml:space="preserve">
          <source>Repeating a namespace name can be a distraction for both readers and writers. Consequently, it is possible
to state that names from a particular namespace are available without explicit qualification. For example:</source>
          <target state="translated">네임 스페이스 이름을 반복하는 것은 독자와 작가 모두에게 방해가 될 수 있습니다. 따라서 특정 네임 스페이스의 이름을 명시적인 자격없이 사용할 수 있다고 진술 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a38525257f468902dfed8f814582f493c591c970" translate="yes" xml:space="preserve">
          <source>Short version: don't use global &lt;code&gt;using&lt;/code&gt; declarations or directives in header files. Feel free to use them in implementation files. Here's what &lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrei_Alexandrescu&quot;&gt;Andrei Alexandrescu&lt;/a&gt; have to say about this issue in &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321113586&quot;&gt;C++ Coding Standards&lt;/a&gt; (bolding for emphasis is mine):</source>
          <target state="translated">짧은 버전 : 헤더 파일에서 선언이나 지시문을 &lt;code&gt;using&lt;/code&gt; 전역을 사용 하지 마십시오. 구현 파일에서 자유롭게 사용하십시오. &lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt; 와 &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrei_Alexandrescu&quot;&gt;Andrei Alexandrescu&lt;/a&gt; 가 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321113586&quot;&gt;C ++ 코딩 표준&lt;/a&gt; 에서이 문제에 대해 말한 내용은 다음과 같습니다 (강조를위한 대담은 내 것입니다).</target>
        </trans-unit>
        <trans-unit id="eec2d891bc3edd909e8348b90447e5d43222b3e9" translate="yes" xml:space="preserve">
          <source>So here's how I solved it. Install Boost's regex, and link it in. Then, I do the following so that when libstdc++ has it implemented entirely, I need only remove this block and the code remains the same:</source>
          <target state="translated">여기에 내가 해결 한 방법이 있습니다. Boost의 정규 표현식을 설치하고 링크하십시오. 그런 다음 libstdc ++가 완전히 구현되었을 때이 블록 만 제거하면되고 코드는 동일하게 유지되도록 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ba958b36fe2684798576e2f9a1a8d021d2835d2a" translate="yes" xml:space="preserve">
          <source>So just consider them functions as reserved names like &quot;int&quot; or &quot;class&quot; and that is it.</source>
          <target state="translated">&quot;int&quot;또는 &quot;class&quot;와 같은 예약 된 이름으로 기능을 고려하면됩니다.</target>
        </trans-unit>
        <trans-unit id="eeaf7c2ef34ec4418e50a2e403553b2d83998883" translate="yes" xml:space="preserve">
          <source>So the following are OK:</source>
          <target state="translated">따라서 다음은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="f103eac16afc4b9fd2b1e99833b3f809101f91e2" translate="yes" xml:space="preserve">
          <source>So you'll need to do some maintenance to clarify that 'a' meant &lt;code&gt;foo::a&lt;/code&gt;. That's undesirable, but fortunately it is pretty easy (just add &lt;code&gt;foo::&lt;/code&gt; in front of all calls to &lt;code&gt;a&lt;/code&gt; that the compiler marks as ambiguous).</source>
          <target state="translated">따라서 'a'가 &lt;code&gt;foo::a&lt;/code&gt; 의미한다는 것을 명확히하기 위해 약간의 유지 관리를 수행해야 합니다 . 바람직하지는 않지만 다행히도 매우 쉽습니다 (컴파일러가 모호한 것으로 표시되는 모든 호출 앞에 &lt;code&gt;foo::&lt;/code&gt; 를 추가하십시오).</target>
        </trans-unit>
        <trans-unit id="ecb267a2211227e4951289cb2c61d96f30e02f89" translate="yes" xml:space="preserve">
          <source>Some people had said that is a bad practice to include the &lt;code&gt;using namespace std&lt;/code&gt; in your source files because you're invoking from that namespace all the functions and variables. When you would like to define a new function with the same name as another function contained in the &lt;code&gt;namespace std&lt;/code&gt; you would overload the function and it could produce problems due to compile or execute. It will not compile or executing as you expect.</source>
          <target state="translated">어떤 사람들은 그 네임 스페이스에서 모든 함수와 변수를 호출하기 때문에 소스 파일에 &lt;code&gt;using namespace std&lt;/code&gt; 를 포함시키는 것은 나쁜 습관이라고 말했습니다. &lt;code&gt;namespace std&lt;/code&gt; 포함 된 다른 함수와 동일한 이름으로 새 함수를 정의하려는 경우 함수를 오버로드하면 컴파일 또는 실행으로 인해 문제가 발생할 수 있습니다. 예상대로 컴파일하거나 실행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2983f4020c6309b44686250810ad2fa1b133cdbd" translate="yes" xml:space="preserve">
          <source>Source-file-level using-declarations inside source files</source>
          <target state="translated">소스 파일 내 소스 파일 레벨 사용 선언</target>
        </trans-unit>
        <trans-unit id="48a09de267300394017fd1240b9ef9afafe06e9a" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;An Overview of the C++ Programming Language&lt;/em&gt;
by Bjarne Stroustrup</source>
          <target state="translated">출처 : Bjarne Stroustrup &lt;em&gt;의 C ++ 프로그래밍 언어 개요&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="8d362630dbd96c9d94d61a5ba26f68429e881414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;namespace std&lt;/code&gt; contains the C++ standard functions and variables. This namespace is useful when you often would use the C++ standard functions.</source>
          <target state="translated">&lt;code&gt;namespace std&lt;/code&gt; 는 C ++ 표준 함수 및 변수를 포함합니다. 이 네임 스페이스는 C ++ 표준 함수를 자주 사용할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a0ecbbc85e8e265d8a3603712049a64cd310766c" translate="yes" xml:space="preserve">
          <source>The FAQ suggests two alternatives:</source>
          <target state="translated">FAQ는 두 가지 대안을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="64995ed41ecdd7959fd7a75459bcac3c990a145f" translate="yes" xml:space="preserve">
          <source>The compiler will choose the &lt;code&gt;std::swap&lt;/code&gt; for &lt;code&gt;value_&lt;/code&gt;, i.e. &lt;code&gt;void std::swap(int, int)&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 &lt;code&gt;value_&lt;/code&gt; 에 대해 &lt;code&gt;std::swap&lt;/code&gt; 을 선택합니다 (예 : &lt;code&gt;void std::swap(int, int)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7f65e416b24edb3d7d7359d825fd5f48ff2bf1b" translate="yes" xml:space="preserve">
          <source>The problem with putting &lt;code&gt;using namespace&lt;/code&gt; in the header files of your classes is that it forces anyone who wants to use your classes (by including your header files) to also be 'using' (i.e. seeing everything in) those other namespaces.</source>
          <target state="translated">클래스의 헤더 파일에 &lt;code&gt;using namespace&lt;/code&gt; 를 사용 하는 문제는 클래스를 사용하려는 모든 사람 (헤더 파일을 포함하여)을 사용하여 다른 네임 스페이스를 '사용'(즉 모든 것을 보도록)해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="651d1324e3e3efa0febb293121711a75a4c05298" translate="yes" xml:space="preserve">
          <source>The statement using namespace std is generally considered bad
  practice. The alternative to this statement is to specify the
  namespace to which the identifier belongs using the scope operator(::)
  each time we declare a type.</source>
          <target state="translated">네임 스페이스 std를 사용하는 문장은 일반적으로 나쁜 습관으로 간주됩니다. 이 문장의 대안은 타입을 선언 할 때마다 scope 연산자 (: :)를 사용하여 식별자가 속하는 네임 스페이스를 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="da678d1957a06dc4c79a7d800b78557e33ff5ebf" translate="yes" xml:space="preserve">
          <source>The using-directive exists for legacy C++ code and to ease the transition to namespaces, but you probably shouldn&amp;rsquo;t use it on a regular basis, at least not in your new C++ code.</source>
          <target state="translated">using-directive는 레거시 C ++ 코드에 존재하며 네임 스페이스로 쉽게 전환 할 수 있지만 적어도 새로운 C ++ 코드에서는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5b8ee9557da2fd48e95fe83d8c0f287ad5f8df12" translate="yes" xml:space="preserve">
          <source>There is no problem using &quot;using namespace std&quot; in your source file
  when you make heavy use of the namespace and know for sure that
  nothing will collide.</source>
          <target state="translated">네임 스페이스를 많이 사용하고 아무 것도 충돌하지 않음을 알고있을 때 소스 파일에서 &quot;네임 스페이스 std 사용&quot;을 사용하는 데 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="029764c0ea9e395746931f8952df7326aa09ac18" translate="yes" xml:space="preserve">
          <source>There is one other thing although it is somewhat related to the above and what others point out. While this might be bad practise, I sometimes reserve &lt;code&gt;std::name&lt;/code&gt; for the standard library version and name for program-specific implementation. Yes, indeed this could bite you and bite you hard, but it all comes down to that I started this project from scratch, and I'm the only programmer for it. Example: I overload &lt;code&gt;std::string&lt;/code&gt; and call it &lt;code&gt;string&lt;/code&gt;. I have helpful additions. I did it in part because of my C and Unix (+ Linux) tendency towards lower-case names.</source>
          <target state="translated">위와 다소 관련이 있지만 다른 사람들이 지적하는 내용이 있지만 다른 것이 있습니다. 이것이 나쁜 연습 일 수는 있지만 표준 라이브러리 버전의 경우 &lt;code&gt;std::name&lt;/code&gt; 을 예약하고 프로그램 별 구현의 이름 을 예약하는 경우가 있습니다. 그렇습니다. 실제로 이것은 당신을 물고 열심히 물릴 수는 있지만,이 프로젝트를 처음부터 시작한 것이 전부입니다. 그리고 나는 그것을위한 유일한 프로그래머입니다. 예 : &lt;code&gt;std::string&lt;/code&gt; 오버로드하고 그것을 &lt;code&gt;string&lt;/code&gt; 이라고 부릅니다. 도움이되는 추가 사항이 있습니다. 나는 C와 Unix (+ Linux)가 소문자로 경향이 있기 때문에 부분적으로 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="3f0a653213e88a4d78de823350af0cc28a0f0151" translate="yes" xml:space="preserve">
          <source>Therefore, avoiding &lt;code&gt;using namespace X;&lt;/code&gt; is a form of future-proofing, a way of making sure a change to the libraries and/or header files in use is not going to break a program.</source>
          <target state="translated">따라서 &lt;code&gt;using namespace X;&lt;/code&gt; 하지 마십시오 . 은 미래 보장의 한 형태로, 사용중인 라이브러리 및 / 또는 헤더 파일을 변경해도 프로그램이 중단되지 않도록하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f45f9dde8d1c10defc80ef7f165a362cba2c156e" translate="yes" xml:space="preserve">
          <source>This does the following magic:</source>
          <target state="translated">이것은 다음과 같은 마법을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a4545a366e0aad9d34b8acbf9d14874529a60d6a" translate="yes" xml:space="preserve">
          <source>This is a bad practice, often known as global namespace pollution. Problems may occur when more than one namespace has the same function name with signature, then it will be ambiguous for the compiler to decide which one to call and this all can be avoided when you are specifying the namespace with your function call like &lt;code&gt;std::cout&lt;/code&gt; . Hope this helps. :)</source>
          <target state="translated">이것은 종종 글로벌 네임 스페이스 오염으로 알려진 나쁜 습관입니다. 둘 이상의 네임 스페이스에 서명이있는 동일한 함수 이름이있는 경우 문제가 발생할 수 있으며, 컴파일러가 호출 할 네임 스페이스를 결정하는 것은 모호하며 &lt;code&gt;std::cout&lt;/code&gt; 와 같은 함수 호출로 네임 스페이스를 지정할 때이 모든 것을 피할 수 있습니다. cout . 도움이 되었기를 바랍니다. :)</target>
        </trans-unit>
        <trans-unit id="99260186b8c3a0ba3c616d9138288919d1f36e7b" translate="yes" xml:space="preserve">
          <source>This is better than explicit qualification (&lt;code&gt;std::sin&lt;/code&gt;, &lt;code&gt;std::cos&lt;/code&gt;...), because it is shorter and has the ability to work with user defined floating point types (via &lt;a href=&quot;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;argument-dependent lookup&lt;/a&gt; (ADL)).</source>
          <target state="translated">이는 명시 적 규정 ( &lt;code&gt;std::sin&lt;/code&gt; , &lt;code&gt;std::cos&lt;/code&gt; ...)보다 낫습니다 (ADL ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;인수 종속 조회&lt;/a&gt; )를 통해). 사용자 정의 부동 소수점 유형에 대해 작업 할 수 있기 때문에 더 짧습니다.</target>
        </trans-unit>
        <trans-unit id="160a0a5c0f76c23ec35ad5487bfae3b08b2536aa" translate="yes" xml:space="preserve">
          <source>This is not related to performance at all. But consider this: you are using two libraries called Foo and Bar:</source>
          <target state="translated">이것은 성능과 전혀 관련이 없습니다. 그러나 이것을 고려하십시오 : Foo와 Bar라는 두 개의 라이브러리를 사용하고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="298ec62c38104583ee0298f42b39da2f5449b342" translate="yes" xml:space="preserve">
          <source>To answer your question I look at it this way practically:  a lot of programmers (not all) invoke namespace std.  Therefore one should be in the habit of NOT using things that impinge or use the same names as what is in the namespace std.  That is a great deal granted, but not so much compared to the number of possible coherent words and pseudonyms that can be come up with strictly speaking.</source>
          <target state="translated">귀하의 질문에 대답하기 위해 실제로 이런 방식으로 봅니다. 많은 프로그래머 (모두는 아님)가 네임 스페이스 std를 호출합니다. 따라서 네임 스페이스 std에있는 것과 동일한 이름을 충돌 시키거나 사용하는 것을 사용하지 않는 습관이 있어야합니다. 그것은 엄청나게 부여되었지만 엄격하게 말해서 얻을 수있는 일관된 단어와 가명 수와 비교할 때 그리 많지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="2782259cabfa8ad3d1fe54d85a7f2baf351f10f1" translate="yes" xml:space="preserve">
          <source>Ultimately this is a trade-off between writability vs. reliability/maintainability. Readability may factor in also, but I could see arguments for that going either way. Normally I would say reliability and maintainability are more important, but in this case you'll constantly pay the writability cost for an fairly rare reliability/maintainability impact. The 'best' trade-off will determine on your project and your priorities.</source>
          <target state="translated">궁극적으로 이것은 쓰기 가능성과 안정성 / 유지 보수 가능성 사이의 균형입니다. 가독성도 고려할 수 있지만, 그에 대한 논쟁은 어느 쪽이든 진행될 수 있습니다. 일반적으로 안정성과 유지 관리 성이 더 중요하다고 말하지만이 경우 상당히 드문 안정성 / 유지 관리 가능성에 대한 쓰기 비용을 지속적으로 지불합니다. '최상의'트레이드 오프는 프로젝트와 우선 순위를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6ea4fced5fb87a77ecac7ac3fa6aeea3011782f8" translate="yes" xml:space="preserve">
          <source>Using many namespaces at the same time is obviously a recipe for disaster, but using JUST namespace &lt;code&gt;std&lt;/code&gt; and only namespace &lt;code&gt;std&lt;/code&gt; is not that big of a deal in my opinion because redefinition can only occur by your own code...</source>
          <target state="translated">동시에 많은 네임 스페이스를 사용하는 것은 분명히 재난의 요리법이지만 JUST 네임 스페이스 &lt;code&gt;std&lt;/code&gt; 및 네임 스페이스 std 만 사용하는 것은 재정의가 자신의 코드에 의해서만 발생할 수 있기 때문에 내 의견으로는 그다지 중요하지 않습니다 ...</target>
        </trans-unit>
        <trans-unit id="41a6352eaeffb261dfe2d93e2ca63fc49c9ba12a" translate="yes" xml:space="preserve">
          <source>What are these &lt;em&gt;good reasons&lt;/em&gt;? Sometimes programmers explicitly want to turn off ADL, other times they want to disambiguate.</source>
          <target state="translated">이 &lt;em&gt;좋은 이유&lt;/em&gt; 는 무엇입니까? 때로는 프로그래머가 ADL을 명시 적으로 끄고 싶을 수도 있고, 그렇지 않은 경우 명확하게하기를 원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab54537830a0232c9f9d54213cf3aa6945c2396b" translate="yes" xml:space="preserve">
          <source>Whatever is true for &lt;em&gt;other&lt;/em&gt; readers of your source code is even more true for the most frequent reader of it: yourself. Come back in a year or two and take a look...</source>
          <target state="translated">소스 코드의 &lt;em&gt;다른&lt;/em&gt; 독자에게는 무엇이든지, 가장 빈번한 독자에게는 더 사실입니다. 1 ~ 2 년 후에 다시 와서 살펴보세요 ...</target>
        </trans-unit>
        <trans-unit id="cdb77621d85047abd900bf6e655db16ba77b61bb" translate="yes" xml:space="preserve">
          <source>When you use a namespace you're risking a scenario like this, which is why people are uncomfortable using namespaces. The more things in a namespace, the greater the risk of conflict, so people might be even more uncomfortable using namespace &lt;code&gt;std&lt;/code&gt; (due to the number of things in that namespace) than other namespaces.</source>
          <target state="translated">네임 스페이스를 사용하면 이와 같은 시나리오가 발생할 위험이 있으므로 네임 스페이스를 사용하는 것이 불편합니다. 네임 스페이스에있는 항목이 많을수록 충돌의 위험이 커지므로 다른 네임 스페이스보다 네임 스페이스 &lt;code&gt;std&lt;/code&gt; (해당 네임 스페이스의 항목 수로 인해)를 사용하는 것이 더 불편할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1654c94350473966024505fd813d40c64664c782" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;using namespace std;&lt;/code&gt; considered a bad practice? Is it inefficient or does it risk declaring ambiguous variables (variables that share the same name as a function in &lt;code&gt;std&lt;/code&gt; namespace)? Does it impact performance?</source>
          <target state="translated">&lt;code&gt;using namespace std;&lt;/code&gt; 이유는 무엇입니까? 나쁜 습관으로 간주? 비효율적이거나 모호한 변수 ( &lt;code&gt;std&lt;/code&gt; 네임 스페이스의 함수와 동일한 이름을 공유하는 변수)를 선언 할 위험이 있습니까? 성능에 영향을 줍니까?</target>
        </trans-unit>
        <trans-unit id="b584d12b92d355bff8bb0e1c7230b6bf58ecd519" translate="yes" xml:space="preserve">
          <source>Why is “using namespace std;” considered bad practice</source>
          <target state="translated">&amp;ldquo;네임 스페이스 std를 사용하는 이유&amp;rdquo;; 나쁜 습관으로 간주</target>
        </trans-unit>
        <trans-unit id="0e30f8945d319ea0f3eeddb281fd252a6c00818b" translate="yes" xml:space="preserve">
          <source>With C++11 there is no reason to use this pattern any more. The implementation of &lt;code&gt;std::swap&lt;/code&gt; was changed to find a potential overload and choose it.</source>
          <target state="translated">C ++ 11에서는이 패턴을 더 이상 사용할 이유가 없습니다. &lt;code&gt;std::swap&lt;/code&gt; 의 구현이 잠재적 과부하를 찾아서 선택하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="634192ce5da22f1caaa7b9299179cbcca7b577b9" translate="yes" xml:space="preserve">
          <source>With unqualified imported identifiers you need external search tools like &lt;em&gt;grep&lt;/em&gt; to find out where identifiers are declared. This makes reasoning about program correctness harder.</source>
          <target state="translated">자격이없는 가져온 식별자를 사용하면 식별자가 선언 된 위치를 찾으려면 &lt;em&gt;grep&lt;/em&gt; 과 같은 외부 검색 도구가 필요합니다. 이것은 프로그램 정확성에 대한 추론을 어렵게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="61b8baeb889064cf813917c7fab3baf262e3a825" translate="yes" xml:space="preserve">
          <source>You clutter the namespace you are programming in.</source>
          <target state="translated">프로그래밍하고있는 네임 스페이스를 복잡하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3bf6425e37e04cd0a68c1fc7844787cb56ab92a8" translate="yes" xml:space="preserve">
          <source>You could write a program to do it, but wouldn't it be better to spend time working on your project itself rather than writing a program to maintain your project?</source>
          <target state="translated">당신은 그것을 할 수있는 프로그램을 작성할 수 있지만, 프로젝트를 유지하기위한 프로그램을 작성하는 것보다는 프로젝트 자체에서 작업하는데 시간을 보내는 것이 낫지 않습니까?</target>
        </trans-unit>
        <trans-unit id="1a066f3f13ff76e054b645560a1597523d36beac" translate="yes" xml:space="preserve">
          <source>You may use it locally</source>
          <target state="translated">로컬로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1a6d9c972154f7b0a7a3e7bc908971e2acb03018" translate="yes" xml:space="preserve">
          <source>You need to be able to read code written by people who have different style and best practices opinions than you.</source>
          <target state="translated">스타일과 모범 사례 의견이 다른 사람들이 작성한 코드를 읽을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9e5ae30173712188975d44da3afd5fd95f0f943a" translate="yes" xml:space="preserve">
          <source>and in the implementation:</source>
          <target state="translated">그리고 구현에서 :</target>
        </trans-unit>
        <trans-unit id="2b71447c7e589fd9da4e2a449318d54f8e55a2f0" translate="yes" xml:space="preserve">
          <source>as opposed to:</source>
          <target state="translated">반대로 :</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
