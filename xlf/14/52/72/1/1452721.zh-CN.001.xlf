<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1452721">
    <body>
      <group id="1452721">
        <trans-unit id="8e0741bec52099753c6c2a0306787331f3b1bf94" translate="yes" xml:space="preserve">
          <source>&quot;Why is 'using namespace std;' considered a bad practice in C++?&quot;</source>
          <target state="translated">&quot;为什么'使用命名空间 std;'被认为是C++中不好的做法?&quot;</target>
        </trans-unit>
        <trans-unit id="5575dde3d3d20bdebe5e5002778dd58101ae84ae" translate="yes" xml:space="preserve">
          <source>(Sometimes) source-file-level using-directives</source>
          <target state="translated">有时)源文件级的使用指令</target>
        </trans-unit>
        <trans-unit id="6a699133bca549300caca4bbc9e50a4f03f67b9e" translate="yes" xml:space="preserve">
          <source>A concrete example to clarify the concern. Imagine you have a situation where you have two libraries, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, each with their own namespace:</source>
          <target state="translated">一个具体的例子来澄清这个问题。 假设您遇到这样一个情况，您有两个库 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; ，每个库都有自己的名称空间：</target>
        </trans-unit>
        <trans-unit id="ba3eac4e25ae1cec81af111cfd596d079e2ef4bd" translate="yes" xml:space="preserve">
          <source>A lot of &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; features are going into the C++0x standard, and Visual&amp;nbsp;Studio&amp;nbsp;2010 has a lot of C++0x features, so suddenly these programs were not compiling.</source>
          <target state="translated">许多&lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt;功能进入C ++ 0x标准，而Visual Studio 2010具有很多C ++ 0x功能，因此突然这些程序没有被编译。</target>
        </trans-unit>
        <trans-unit id="39f8e6781daf6a934001f51f44614f546e42a1e3" translate="yes" xml:space="preserve">
          <source>A namespace is a named scope. Namespaces are used to group related declarations and to keep separate
items separate. For example, two separately developed libraries may use the same name to refer to different
items, but a user can still use both:</source>
          <target state="translated">命名空间是一个命名的作用域。命名空间用于将相关的声明进行分组,并将单独的项目分开。例如,两个单独开发的库可以使用相同的名称来指代不同的项,但用户仍然可以同时使用两个库。</target>
        </trans-unit>
        <trans-unit id="8a340e0ae7fed0a2d743f95465081c70d0cb841d" translate="yes" xml:space="preserve">
          <source>A using-declaration:</source>
          <target state="translated">使用声明;</target>
        </trans-unit>
        <trans-unit id="b82a662dae5884212abc04bb506affe12b0328ae" translate="yes" xml:space="preserve">
          <source>Although the statement saves us from typing std:: whenever
  we wish to access a class or type defined in the std namespace, it
  imports the entirety of the std namespace into the current namespace
  of the program. Let us take a few examples to understand why this
  might not be such a good thing</source>
          <target state="translated">虽然这条语句省去了我们键入 std:::,但每当我们想访问一个在 std 命名空间中定义的类或类型时,它就会将 std 命名空间的全部内容导入到程序的当前命名空间中。让我们举几个例子来理解为什么这可能不是一件好事情</target>
        </trans-unit>
        <trans-unit id="2b00151385441b68225fc4658924e46453d8ec93" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;using namespace std&lt;/code&gt; throws a compilation error because of the ambiguity of count, which is also a function in algorithm library.</source>
          <target state="translated">一个示例，其中 &lt;code&gt;using namespace std&lt;/code&gt; 会由于count的歧义性而引发编译错误，这也是算法库中的函数。</target>
        </trans-unit>
        <trans-unit id="235c5c438cb46b535c12595279d731d5b7716a5d" translate="yes" xml:space="preserve">
          <source>An idiom for using it locally</source>
          <target state="translated">成语:就地取材</target>
        </trans-unit>
        <trans-unit id="0fbb0cc023270ff0740fd1bead3e7a7d083f3415" translate="yes" xml:space="preserve">
          <source>And as for making Boost's regex part of &lt;code&gt;std&lt;/code&gt;. I do that for future integration and &amp;ndash; again, I admit fully this is bias - I don't think it is as ugly as &lt;code&gt;boost::regex:: ...&lt;/code&gt;. Indeed, that is another thing for me. There are many things in C++ that I still have yet to come to fully accept in looks and methods (another example: variadic templates versus var arguments [though I admit variadic templates are very very useful!]). Even those that I do accept it was difficult, &lt;em&gt;and&lt;/em&gt; I still have issues with them.</source>
          <target state="translated">至于使Boost的regex成为 &lt;code&gt;std&lt;/code&gt; 的一部分。 我这样做是为了将来的集成，并且-再次，我完全承认这是偏见-我认为它不像 &lt;code&gt;boost::regex:: ...&lt;/code&gt; 那样丑陋。 确实，那对我来说是另一回事。 在C ++中，在外观和方法上我还有很多事情要完全接受（另一个示例：可变参数模板与var参数[尽管我承认可变参数模板非常有用！]）。 即使是那些我确实接受的人也很难， &lt;em&gt;而且&lt;/em&gt;我仍然对他们有疑问。</target>
        </trans-unit>
        <trans-unit id="3aa9fcea2af1d01ac1dbb4efe366442a34d014fe" translate="yes" xml:space="preserve">
          <source>And see &lt;a href=&quot;https://www.sololearn.com/Discuss/187690/is-using-namespace-std-a-bad-practice/&quot;&gt;this opinion&lt;/a&gt;:</source>
          <target state="translated">并查看&lt;a href=&quot;https://www.sololearn.com/Discuss/187690/is-using-namespace-std-a-bad-practice/&quot;&gt;此意见&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="0fecfa228c906cdbaa2a5ef28640a1b52d83c4df" translate="yes" xml:space="preserve">
          <source>Another reason is surprise.</source>
          <target state="translated">另一个原因是惊喜。</target>
        </trans-unit>
        <trans-unit id="9d1dee9a88dd2bd4cb378802f7b802ac8d01b036" translate="yes" xml:space="preserve">
          <source>As is mentioned in this &lt;a href=&quot;https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/&quot;&gt;page&lt;/a&gt;:</source>
          <target state="translated">如&lt;a href=&quot;https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/&quot;&gt;本页所述&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="e1ea5cc086ad8c105f0de7b7b2d957c6908d8ceb" translate="yes" xml:space="preserve">
          <source>As it is, I am still very biased towards C and biased against C++. Sparing details, much of what I work on fits C more (but it was a good exercise and a good way to make myself a. learn another language and b. try not be less biased against object/classes/etc which is maybe better stated as less closed-minded, less arrogant, and more accepting.). But what &lt;em&gt;is&lt;/em&gt; useful is what some already suggested: I do indeed use list (it is fairly generic, is it not ?), and sort (same thing) to name two that would cause a name clash if I were to do &lt;code&gt;using namespace std;&lt;/code&gt;, and so to that end I prefer being specific, in control and knowing that if I intend it to be the standard use then I will have to specify it. Put simply: no assuming allowed.</source>
          <target state="translated">实际上，我仍然非常偏向于C和偏向于C ++。 保留细节，我所做的大部分工作都更适合C（但这是一个很好的练习，也是使自己成为一个好方法的一种方法。a。学习另一种语言，并且b。尽量不要偏向于对象/类/等，这也许更好地表述了更少的胸襟，更少的自大和更多的接受。） 但是有用的是一些已经提出的建议：我确实使用列表（它是相当通用的，不是吗？），并排序（同一件事）命名两个，如果我 &lt;code&gt;using namespace std;&lt;/code&gt; 会引起名称冲突。 ; ，因此，为此，我更希望在控制方面具有特定性，并且知道如果我打算将其作为标准用法，则必须指定它。 简单地说：不允许假设。</target>
        </trans-unit>
        <trans-unit id="a951ab665371162929ad7cc1021e7f306c09ca5a" translate="yes" xml:space="preserve">
          <source>At this point everything is fine. When you run your program it 'Does something'. But later you update &lt;code&gt;bar&lt;/code&gt; and let's say it has changed to be like:</source>
          <target state="translated">此时一切都很好。 当您运行程序时，它&amp;ldquo;做某事&amp;rdquo;。 但是后来您更新了 &lt;code&gt;bar&lt;/code&gt; ，可以说它变成了：</target>
        </trans-unit>
        <trans-unit id="9cd966c7ceb5c8bf6d8a1e601c36928bf783b349" translate="yes" xml:space="preserve">
          <source>At this point you'll get a compiler error:</source>
          <target state="translated">这时,你会得到一个编译器错误。</target>
        </trans-unit>
        <trans-unit id="62f3b54904071c98839a53723f5cac8dbd3c6262" translate="yes" xml:space="preserve">
          <source>At this point your call to &lt;code&gt;a(42)&lt;/code&gt; suddenly binds to &lt;code&gt;bar::a&lt;/code&gt; instead of &lt;code&gt;foo::a&lt;/code&gt; and instead of doing 'something' it does 'something completely different'.  No compiler warning or anything. Your program just silently starts doing something complete different than before.</source>
          <target state="translated">此时，您对 &lt;code&gt;a(42)&lt;/code&gt; 的调用突然绑定到 &lt;code&gt;bar::a&lt;/code&gt; 而不是 &lt;code&gt;foo::a&lt;/code&gt; ，而不是执行&amp;ldquo;某些操作&amp;rdquo;，而是执行了&amp;ldquo;完全不同的操作&amp;rdquo;。 没有编译器警告或任何东西。 您的程序只是默默地开始做一些与以前完全不同的事情。</target>
        </trans-unit>
        <trans-unit id="36dab49377a029cf015f76cbd70a8bead781a8f1" translate="yes" xml:space="preserve">
          <source>Besides that, you can have namespace aliases. Here is an example of where it is useful that might not have been referred to. I use the C++11 standard and specifically with libstdc++. Well, it doesn't have complete &lt;code&gt;std::regex&lt;/code&gt; support. Sure, it compiles, but it throws an exception along the lines of it being an error on the programmer's end. But it is lack of implementation.</source>
          <target state="translated">除此之外，您还可以使用名称空间别名。 这是一个可能未提及的有用示例。 我使用C ++ 11标准，尤其是libstdc ++。 好吧，它没有完整的 &lt;code&gt;std::regex&lt;/code&gt; 支持。 当然，它可以编译，但是会引发异常，因为它是程序员的错误。 但这是缺乏执行力的。</target>
        </trans-unit>
        <trans-unit id="8b819cb9c25c847eca882b7f61088fcf30ea9024" translate="yes" xml:space="preserve">
          <source>Beware that some people disagree with my saying &quot;feel free&quot; like this -- because although a &lt;code&gt;using&lt;/code&gt; statement in a cpp file is &lt;em&gt;better&lt;/em&gt; than in a header (because it doesn't affect people who include your header file), they think it's still not &lt;em&gt;good&lt;/em&gt; (because depending on the code it could make the implementation of the class more difficult to maintain). &lt;a href=&quot;https://isocpp.org/wiki/faq/coding-standards#using-namespace-std&quot;&gt;This C++ Super-FAQ entry&lt;/a&gt; says,</source>
          <target state="translated">请注意，有些人不同意我这样说的&amp;ldquo;随意&amp;rdquo;-因为尽管在cpp文件中 &lt;code&gt;using&lt;/code&gt; 语句要比在头文件中使用&lt;em&gt;更好&lt;/em&gt; （因为它不会影响包含您的头文件的人），但他们认为它仍然&lt;em&gt;不好&lt;/em&gt; （因为取决于代码，这可能会使类的实现更加难以维护）。 &lt;a href=&quot;https://isocpp.org/wiki/faq/coding-standards#using-namespace-std&quot;&gt;这个C ++ Super-FAQ条目&lt;/a&gt;说，</target>
        </trans-unit>
        <trans-unit id="3bd225512cee60fc69de0a0f917ae67552b94c49" translate="yes" xml:space="preserve">
          <source>Bottom line: Explicitly prefixing everything doesn't do any harm, takes very little getting used to, and has objective advantages. In particular, it makes the code easier to interpret by the compiler and by human readers &amp;mdash; and that should probably be the main goal when writing code.</source>
          <target state="translated">底线：明确地为所有内容加上前缀不会造成任何损害，几乎不需要花什么时间就拥有客观的优势。 尤其是，它使代码更易于由编译器和人类读者解释，而这可能是编写代码时的主要目标。</target>
        </trans-unit>
        <trans-unit id="984d1515ce54fb1acb235d14e03bcd7545ccca8f" translate="yes" xml:space="preserve">
          <source>But imagine an alternative scenario where bar changed instead to look like this instead:</source>
          <target state="translated">但试想一下,在另一种情况下,酒吧的外观是这样的,而不是这样的。</target>
        </trans-unit>
        <trans-unit id="bd243da61bc83e255c691b0eeb1676f5cf315d17" translate="yes" xml:space="preserve">
          <source>Consider</source>
          <target state="translated">Consider</target>
        </trans-unit>
        <trans-unit id="0fde436f316d9e7c2c1244b279c7df1ee1b8459d" translate="yes" xml:space="preserve">
          <source>Consider e.g. writing a piece of numerical software. Why would I even consider polluting my global namespace by cutting general &quot;std::vector&quot; down to &quot;vector&quot; when &quot;vector&quot; is one of the problem domain's most important concepts?</source>
          <target state="translated">考虑一下,比如说写一个数值软件。当 &quot;向量 &quot;是问题域最重要的概念之一时,我为什么要考虑将一般的 &quot;std:::vector &quot;削减为 &quot;向量 &quot;而污染我的全局命名空间呢?</target>
        </trans-unit>
        <trans-unit id="4f260645290a8d4cc5baf50a62bc1e04d3f4c8a3" translate="yes" xml:space="preserve">
          <source>Corollary: In header files, don&amp;rsquo;t write namespace-level using directives or using declarations; instead, explicitly namespace-qualify all names. (The second rule follows from the first, because headers can never know what other header #includes might appear after them.)</source>
          <target state="translated">结论：在头文件中，请勿使用指令或声明来编写名称空间级别； 相反，显式命名空间限定所有名称。 （第二条规则是从第一条开始的，因为标头永远不知道其他标头#includes可能会出现在它们之后。）</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="b28c908712aa3b3c4f2721161a98d4f73d39f13a" translate="yes" xml:space="preserve">
          <source>Do not use it globally</source>
          <target state="translated">请勿在全球范围内使用</target>
        </trans-unit>
        <trans-unit id="b10099eb72109a24775417ddca5bf1c65d8e36bc" translate="yes" xml:space="preserve">
          <source>Everything works fine, and you can call &lt;code&gt;Blah()&lt;/code&gt; from Foo and &lt;code&gt;Quux()&lt;/code&gt; from Bar without problems. But one day you upgrade to a new version of Foo 2.0, which now offers a function called &lt;code&gt;Quux()&lt;/code&gt;. Now you've got a conflict: Both Foo 2.0 and Bar import &lt;code&gt;Quux()&lt;/code&gt; into your global namespace. This is going to take some effort to fix, especially if the function parameters happen to match.</source>
          <target state="translated">一切正常，您可以从Foo调用 &lt;code&gt;Blah()&lt;/code&gt; 并从Bar调用 &lt;code&gt;Quux()&lt;/code&gt; 而不会出现问题。 但是有一天，您将升级到Foo 2.0的新版本，该版本现在提供了称为 &lt;code&gt;Quux()&lt;/code&gt; 的功能。 现在您有一个冲突：Foo 2.0和Bar都将 &lt;code&gt;Quux()&lt;/code&gt; 导入到全局名称空间中。 这将需要花费一些时间来修复，尤其是在功能参数碰巧匹配的情况下。</target>
        </trans-unit>
        <trans-unit id="7fdc8f5263841efbcae18f9750a704ca266369d1" translate="yes" xml:space="preserve">
          <source>Experienced programmers also try to avoid full qualification of names inside their source files. A minor reason for this is that it's not elegant to write more code when less code is sufficient &lt;em&gt;unless there are good reasons&lt;/em&gt;. A major reason for this is turning off argument-dependent lookup (ADL).</source>
          <target state="translated">经验丰富的程序员还尝试避免在源文件中使用完全限定的名称。 造成这种情况的一个次要原因是， &lt;em&gt;除非有充分的理由，否则在&lt;/em&gt;编写较少的代码时就不能编写更多的代码，这不是很优雅。 这样做的主要原因是要关闭基于参数的查找（ADL）。</target>
        </trans-unit>
        <trans-unit id="40fc3dd2e604ebb2070a1b8a0000705b0f996fcf" translate="yes" xml:space="preserve">
          <source>Experienced programmers use whatever solves their problems and avoid whatever creates new problems, and they avoid header-file-level using-directives for this exact reason.</source>
          <target state="translated">有经验的程序员会使用任何能解决他们的问题的东西,而避免使用任何能产生新问题的东西,他们避免头文件级的使用方向正是出于这个原因。</target>
        </trans-unit>
        <trans-unit id="a7f84ccc694c5225483eb04c03fd8a8b7d981149" translate="yes" xml:space="preserve">
          <source>For example, if I type in, &lt;code&gt;using namespace std;&lt;/code&gt; and &lt;code&gt;using namespace otherlib;&lt;/code&gt; and type just &lt;code&gt;cout&lt;/code&gt; (which happens to be in both), rather than &lt;code&gt;std::cout&lt;/code&gt; (or &lt;code&gt;'otherlib::cout'&lt;/code&gt;), you might use the wrong one, and get errors. It's much more effective and efficient to use &lt;code&gt;std::cout&lt;/code&gt;.</source>
          <target state="translated">例如，如果我 &lt;code&gt;using namespace std;&lt;/code&gt; 并 &lt;code&gt;using namespace otherlib;&lt;/code&gt; 并仅键入 &lt;code&gt;cout&lt;/code&gt; （恰好在两者中），而不是 &lt;code&gt;std::cout&lt;/code&gt; （或 &lt;code&gt;'otherlib::cout'&lt;/code&gt; ），则可能使用了错误的代码并出错。 使用 &lt;code&gt;std::cout&lt;/code&gt; 更加有效。</target>
        </trans-unit>
        <trans-unit id="f92e531886e10c1956f1cd4ead46fd24e7ec5ba4" translate="yes" xml:space="preserve">
          <source>From my experiences, if you have multiple libraries that uses say, &lt;code&gt;cout&lt;/code&gt;, but for a different purpose you may use the wrong &lt;code&gt;cout&lt;/code&gt;.</source>
          <target state="translated">根据我的经验，如果您有多个使用 &lt;code&gt;cout&lt;/code&gt; 库，但出于不同的目的，则可能使用了错误的 &lt;code&gt;cout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc4a2e1c6384a6c0bca9221545adb77b689f41f1" translate="yes" xml:space="preserve">
          <source>Function-level using-directives and using-declarations inside functions' implementations</source>
          <target state="translated">函数级的使用指令和函数实现内部的使用声明</target>
        </trans-unit>
        <trans-unit id="e754f634964b71e89733cd919482e9f7c6dc7fd0" translate="yes" xml:space="preserve">
          <source>Go ahead and use it locally (almost) freely. This, of course, prevents you from repetition of &lt;code&gt;std::&lt;/code&gt; -- and repetition is also bad.</source>
          <target state="translated">继续免费在本地（几乎）使用它。 当然，这可以防止您重复 &lt;code&gt;std::&lt;/code&gt; -重复也是不好的。</target>
        </trans-unit>
        <trans-unit id="a13b7ac34e7f5b5ed26674ea84e218245208110c" translate="yes" xml:space="preserve">
          <source>Here's one more data point: Many, many years ago, I also used to find it annoying having to prefix everything from the standard library with &lt;code&gt;std::&lt;/code&gt;. Then I worked in a project where it was decided at the start that both &lt;code&gt;using&lt;/code&gt; directives and declarations are banned except for function scopes. Guess what? It took most of us very few weeks to get used to writing the prefix, and after a few more weeks most of us even agreed that it actually made the code &lt;em&gt;more readable&lt;/em&gt;. There's a reason for that: &lt;strong&gt;&lt;em&gt;Whether you like shorter or longer prose is subjective, but the prefixes objectively add clarity to the code.&lt;/em&gt;&lt;/strong&gt; Not only the compiler, but you, too, find it easier to see which identifier is referred to.</source>
          <target state="translated">这是另一个数据点：许多年前，我还发现必须在标准库中的所有内容前加上 &lt;code&gt;std::&lt;/code&gt; 作为前缀，这很烦人。 然后，我在一个项目中工作，该项目一开始就决定禁止 &lt;code&gt;using&lt;/code&gt; 指令和声明（函数范围除外）。 你猜怎么着？ 我们大多数人只花了几周的时间就习惯了编写前缀，而又过了几周，我们大多数人甚至同意它实际上使代码&lt;em&gt;更具可读性&lt;/em&gt; 。 这是有原因的： &lt;strong&gt;&lt;em&gt;您喜欢散文是短还是长是主观的，但是前缀客观地增加了代码的清晰度。&lt;/em&gt;&lt;/strong&gt; 不仅是编译器，而且您也发现查找引用的标识符更加容易。</target>
        </trans-unit>
        <trans-unit id="14cd4a9b5c57786c9dcc406fd5351f54c74541d7" translate="yes" xml:space="preserve">
          <source>Horses for courses - manage your complexity how you best can and feel able.</source>
          <target state="translated">马的课程-管理你的复杂性,你最好能和感觉到自己的能力。</target>
        </trans-unit>
        <trans-unit id="b6059ce195c06e6a8d7d2780b75b1844645eec62" translate="yes" xml:space="preserve">
          <source>However, if I often use 'cout' and 'cin', I write: &lt;code&gt;using std::cout; using std::cin;&lt;/code&gt; in the .cpp file (never in the header file as it propagates with &lt;code&gt;#include&lt;/code&gt;). I think that no one sane will ever name a stream &lt;code&gt;cout&lt;/code&gt; or &lt;code&gt;cin&lt;/code&gt;. ;)</source>
          <target state="translated">但是，如果我经常使用'cout'和'cin'，我会写： &lt;code&gt;using std::cout; using std::cin;&lt;/code&gt; 使用std :: cin; 在.cpp文件中（在头文件中永远不会与 &lt;code&gt;#include&lt;/code&gt; 一起传播）。 我认为没有人能说出流媒体或 &lt;code&gt;cin&lt;/code&gt; 的名字。 ;）</target>
        </trans-unit>
        <trans-unit id="2250f701130cc7a3863ada4af431ecaea750adc9" translate="yes" xml:space="preserve">
          <source>However, you may feel free to put a using statement in your (private) *.cpp files.</source>
          <target state="translated">但是,你可以在你的(私有的)*.cpp文件中添加一个使用语句。</target>
        </trans-unit>
        <trans-unit id="b8fafbc70aedce2fc77deabe47f1e309ea3f997a" translate="yes" xml:space="preserve">
          <source>I agree that it should not be used globally, but it's not so evil to use locally, like in a &lt;code&gt;namespace&lt;/code&gt;. Here's an example from &lt;em&gt;&quot;The C++ Programming Language&quot;&lt;/em&gt;:</source>
          <target state="translated">我同意不应在全球范围内使用它，但在本地使用它（如在 &lt;code&gt;namespace&lt;/code&gt; 并没有那么邪恶。 这是&lt;em&gt;&amp;ldquo; C ++编程语言&amp;rdquo;中&lt;/em&gt;的示例：</target>
        </trans-unit>
        <trans-unit id="b957aa59d52d23ef4bc9ed842310ade7ee82aeff" translate="yes" xml:space="preserve">
          <source>I agree with everything &lt;a href=&quot;https://stackoverflow.com/questions/1452721/1452738#1452738&quot;&gt;Greg wrote&lt;/a&gt;, but I'd like to add: &lt;strong&gt;&lt;em&gt;It can even get worse than Greg said!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">我同意&lt;a href=&quot;https://stackoverflow.com/questions/1452721/1452738#1452738&quot;&gt;Greg撰写的&lt;/a&gt;所有内容，但我想补充一点： &lt;strong&gt;&lt;em&gt;甚至比Greg所说的还要糟糕！&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3806b9230c26bc35f5387e9568e05e858aa6bb5a" translate="yes" xml:space="preserve">
          <source>I agree with others &amp;ndash; it is asking for name clashes, ambiguities and then the fact is it is less explicit. While I can see the use of &lt;code&gt;using&lt;/code&gt;, my personal preference is to limit it. I would also strongly consider what some others pointed out:</source>
          <target state="translated">我同意其他人的观点-它要求名称冲突，含糊不清，然后事实是它不够明确。 虽然可以看到 &lt;code&gt;using&lt;/code&gt; 的使用 ，但我个人的偏好是限制它。 我还将强烈考虑其他人指出的内容：</target>
        </trans-unit>
        <trans-unit id="de2e7022c8f014a2e70b1ef6b6313df62304adae" translate="yes" xml:space="preserve">
          <source>I agree with the others here, but I would like to address the concerns regarding readability - you can avoid all of that by simply using typedefs at the top of your file, function or class declaration.</source>
          <target state="translated">我同意这里的其他人的观点,但我想解决一下关于可读性的问题--你可以通过在文件、函数或类声明的顶部使用 typedefs 来避免所有这些问题。</target>
        </trans-unit>
        <trans-unit id="1763537fa947e39d61c79dbb27ae0c8d2955d02f" translate="yes" xml:space="preserve">
          <source>I also consider it a bad practice. Why? Just one day I thought that the function of a namespace is to divide stuff, so I shouldn't spoil it with throwing everything into one global bag.</source>
          <target state="translated">我也认为这是一种不好的做法。为什么要这样做呢?就在某一天,我想,命名空间的功能是划分东西,所以我不应该把所有的东西都扔到一个全局包里去破坏它。</target>
        </trans-unit>
        <trans-unit id="de6cf10d0eaf9e11a0c6a2571f7cee7c4459b91d" translate="yes" xml:space="preserve">
          <source>I do not think it is necessarily bad practice under all conditions, but you need to be careful when you use it.  If you're writing a library, you probably should use the scope resolution operators with the namespace to keep your library from butting heads with other libraries.  For application level code, I don't see anything wrong with it.</source>
          <target state="translated">我不认为在所有条件下,这种做法不一定是不好的,但你在使用的时候需要谨慎。如果你写的是一个库,你可能应该使用命名空间的作用域解析操作符,以防止你的库与其他库发生冲突。对于应用级的代码,我觉得没有什么问题。</target>
        </trans-unit>
        <trans-unit id="d5080a2a4a2beb8872491aa265a231ea1ed16674" translate="yes" xml:space="preserve">
          <source>I mean really... saying &quot;don't rely on this being present&quot; is just setting you up to rely on it NOT being present.  You are constantly going to have issues borrowing code snippets and constantly repairing them.  Just keep your user-defined and borrowed stuff in limited scope as they should be and be VERY sparing with globals (honestly globals should almost always be a last resort for purposes of &quot;compile now, sanity later&quot;). Truly I think it is bad advice from your teacher because using std will work for both &quot;cout&quot; and &quot;std::cout&quot; but NOT using std will only work for &quot;std::cout&quot;.  You will not always be fortunate enough to write all your own code.</source>
          <target state="translated">我的意思是...........说 &quot;不要依赖这个存在 &quot;只是给你设置了一个依赖它不存在的条件。你会不断地借用代码片段并不断地修复它们。只要把你的用户定义的和借用的东西保持在有限的范围内就好了,并且对globals的使用要非常谨慎(老实说,globals几乎都应该是最后的手段,为了 &quot;现在编译,以后再理智&quot;)。真的,我认为你的老师给你的建议是错误的,因为使用 std 对 &quot;cout &quot;和 &quot;std:::cout &quot;都有效,但不使用 std 只对 &quot;std:::cout &quot;有效。你不会总是幸运的写出你自己的所有代码。</target>
        </trans-unit>
        <trans-unit id="f75a67cd99e9c9fbf6abd8a8f84e205de1d5a8c2" translate="yes" xml:space="preserve">
          <source>I put it the other way around: Why is typing five extra characters considered cumbersome by some?</source>
          <target state="translated">我是反过来说的。为什么有人认为多打五个字很麻烦?</target>
        </trans-unit>
        <trans-unit id="315d92e4893f10fb88044d2ccdcfc00fb3e343d7" translate="yes" xml:space="preserve">
          <source>I recently ran into a complaint about &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2010&lt;/a&gt;. It turned out that pretty much all the source files had these two lines:</source>
          <target state="translated">我最近遇到了有关&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010&quot;&gt;Visual Studio 2010&lt;/a&gt;的投诉。 事实证明，几乎所有源文件都具有以下两行：</target>
        </trans-unit>
        <trans-unit id="8441eb391ffa1ac35a213cb285d116689923e4e3" translate="yes" xml:space="preserve">
          <source>I usually use it in my class declaration as methods in a class tend to deal with similar data types (the members) and a typedef is an opportunity to assign a name that is meaningful in the context of the class. This actually aids readability in the definitions of the class methods.</source>
          <target state="translated">我通常在类的声明中使用它,因为类中的方法往往会处理类似的数据类型(成员),而typedef是一个在类的上下文中指定一个有意义的名称的机会。这实际上有助于类方法定义中的可读性。</target>
        </trans-unit>
        <trans-unit id="ae395c81a97e21bacfb9359546bf7289ddc3c88b" translate="yes" xml:space="preserve">
          <source>I won't argue on whether that is a bad idea or not. I will however argue that it keeps it clean for &lt;em&gt;my&lt;/em&gt; project and at the same time makes it specific: True, I have to use Boost, &lt;em&gt;but&lt;/em&gt; I'm using it like the libstdc++ will eventually have it. Yes, starting your own project and starting with a standard (...) at the very beginning goes a very long way with helping maintenance, development and everything involved with the project!</source>
          <target state="translated">我不会争论那是一个坏主意。 但是，我会争辩说它可以使&lt;em&gt;我的&lt;/em&gt;项目保持整洁，同时又要使其具体化：确实，我必须使用Boost， &lt;em&gt;但是&lt;/em&gt;我正在使用它，就像libstdc ++最终会使用它一样。 是的，从一开始就开始自己的项目并从一个标准（...）开始，在帮助维护，开发以及该项目涉及的所有方面都走了很长的路！</target>
        </trans-unit>
        <trans-unit id="19e234fd1ffb5551c9bacc76444a0745a8b46a07" translate="yes" xml:space="preserve">
          <source>I've been told by others that writing &lt;code&gt;using namespace std;&lt;/code&gt; in code is wrong, and that I should use &lt;code&gt;std::cout&lt;/code&gt; and &lt;code&gt;std::cin&lt;/code&gt; directly instead.</source>
          <target state="translated">其他人告诉我， &lt;code&gt;using namespace std;&lt;/code&gt; 编写； 在代码中是错误的，我应该直接使用 &lt;code&gt;std::cout&lt;/code&gt; 和 &lt;code&gt;std::cin&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="091066152480cd6d7ec51ddc1f6d09610b9d55a1" translate="yes" xml:space="preserve">
          <source>If I see &lt;code&gt;cout &amp;lt;&amp;lt; blah&lt;/code&gt;, instead of &lt;code&gt;std::cout &amp;lt;&amp;lt; blah&lt;/code&gt; I think: What is this &lt;code&gt;cout&lt;/code&gt;? Is it the normal &lt;code&gt;cout&lt;/code&gt;? Is it something special?</source>
          <target state="translated">如果我看到 &lt;code&gt;cout &amp;lt;&amp;lt; blah&lt;/code&gt; ，而不是 &lt;code&gt;std::cout &amp;lt;&amp;lt; blah&lt;/code&gt; 我想：这是 &lt;code&gt;cout&lt;/code&gt; 吗？ 这是正常的情况吗？ 有什么特别的吗？</target>
        </trans-unit>
        <trans-unit id="5a9372cdbb50764ea955811dd61572f65ed573bd" translate="yes" xml:space="preserve">
          <source>If all the standard stuff is in its own namespace you don't have to worry about name collisions with your code or other libraries.</source>
          <target state="translated">如果所有标准的东西都在自己的命名空间中,你就不用担心与你的代码或其他库的名称碰撞。</target>
        </trans-unit>
        <trans-unit id="05bbbb5c87545d8ed21bba66dec5dbe3cf4e541d" translate="yes" xml:space="preserve">
          <source>If you consider this unlikely: There was &lt;a href=&quot;https://stackoverflow.com/a/2712125/140719&quot;&gt;a question asked&lt;/a&gt; here on Stack Overflow where pretty much exactly this happened (wrong function called due to omitted &lt;code&gt;std::&lt;/code&gt; prefix) about half a year after I gave this answer. &lt;a href=&quot;https://stackoverflow.com/questions/13402789/&quot;&gt;Here&lt;/a&gt; is another, more recent example of such a question.
So this is a real problem.</source>
          <target state="translated">如果您认为这不太可能，请执行以下操作：在我给出答案的半年后，Stack Overflow上有&lt;a href=&quot;https://stackoverflow.com/a/2712125/140719&quot;&gt;一个问题&lt;/a&gt;几乎完全在此发生（由于省略了 &lt;code&gt;std::&lt;/code&gt; 前缀而调用了错误的函数）。 &lt;a href=&quot;https://stackoverflow.com/questions/13402789/&quot;&gt;这&lt;/a&gt;是此类问题的另一个最新示例。 所以这是一个真正的问题。</target>
        </trans-unit>
        <trans-unit id="883b59bb138a2b98dd2f53050ba718757c60f448" translate="yes" xml:space="preserve">
          <source>If you do &lt;em&gt;not&lt;/em&gt; have that overload the compiler will use &lt;code&gt;void std::swap(Child&amp;amp;,Child&amp;amp;)&lt;/code&gt; and try its best swapping these.</source>
          <target state="translated">如果&lt;em&gt;没有&lt;/em&gt;这种重载，编译器将使用 &lt;code&gt;void std::swap(Child&amp;amp;,Child&amp;amp;)&lt;/code&gt; 并尝试最好地交换它们。</target>
        </trans-unit>
        <trans-unit id="81009c04e328b3a3b5aadc7fe747aad2c2287d54" translate="yes" xml:space="preserve">
          <source>If you had used &lt;code&gt;foo::Blah()&lt;/code&gt; and &lt;code&gt;bar::Quux()&lt;/code&gt;, then the introduction of &lt;code&gt;foo::Quux()&lt;/code&gt; would have been a non-event.</source>
          <target state="translated">如果您使用过 &lt;code&gt;foo::Blah()&lt;/code&gt; 和 &lt;code&gt;bar::Quux()&lt;/code&gt; ，那么 &lt;code&gt;foo::Quux()&lt;/code&gt; 的引入将是非事件。</target>
        </trans-unit>
        <trans-unit id="d31c157553e55cd020a04b1f31d6a0bd553ab83f" translate="yes" xml:space="preserve">
          <source>If you have an overload &lt;code&gt;void swap(Child&amp;amp;, Child&amp;amp;)&lt;/code&gt; implemented the compiler will choose it.</source>
          <target state="translated">如果实现了重载 &lt;code&gt;void swap(Child&amp;amp;, Child&amp;amp;)&lt;/code&gt; 则编译器将选择它。</target>
        </trans-unit>
        <trans-unit id="6cfd5241c3ace598230b440bf15ea476ef327fab" translate="yes" xml:space="preserve">
          <source>If you import the right header files you suddenly have names like &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/hex&quot;&gt;&lt;code&gt;hex&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/left&quot;&gt;&lt;code&gt;left&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/functional/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; in your global scope. This might be surprising if you are not aware that &lt;code&gt;std::&lt;/code&gt; contains these names. If you also try to use these names locally it can lead to quite some confusion.</source>
          <target state="translated">如果导入正确的头文件，则突然在全局范围内具有诸如&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/hex&quot;&gt; &lt;code&gt;hex&lt;/code&gt; &lt;/a&gt; ， &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/left&quot;&gt; &lt;code&gt;left&lt;/code&gt; &lt;/a&gt; ， &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/functional/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/count&quot;&gt; &lt;code&gt;count&lt;/code&gt; 之&lt;/a&gt;类的名称。 如果您不知道 &lt;code&gt;std::&lt;/code&gt; 包含这些名称，这可能会令人惊讶。 如果您还尝试在本地使用这些名称，则可能导致相当混乱。</target>
        </trans-unit>
        <trans-unit id="8d02f14101198ab0a96dc0a62eeaadc30eac403e" translate="yes" xml:space="preserve">
          <source>If you only talk about &lt;code&gt;using namespace std&lt;/code&gt; you might not be aware of all the stuff you grab -- and when you add another &lt;code&gt;#include&lt;/code&gt; or move to a new C++ revision you might get name conflicts you were not aware of.</source>
          <target state="translated">如果仅谈论 &lt;code&gt;using namespace std&lt;/code&gt; 那么您可能并不了解所抓取的所有内容，并且当您添加另一个 &lt;code&gt;#include&lt;/code&gt; 或移动到新的C ++修订版时，可能会遇到您不认识的名称冲突。</target>
        </trans-unit>
        <trans-unit id="4713f3b8d7aeb939fd9e031cf10de0c3697de5bd" translate="yes" xml:space="preserve">
          <source>If you want to find a function name that might be a fairly common name, but you only want to find it in the &lt;code&gt;std&lt;/code&gt; namespace (or the reverse &amp;ndash; you want to change all calls that are &lt;em&gt;not&lt;/em&gt; in namespace &lt;code&gt;std&lt;/code&gt;, namespace &lt;code&gt;X&lt;/code&gt;, ...), then how do you propose to do this?</source>
          <target state="translated">如果要查找可能是一个相当普通的名称的函数名，而只想在 &lt;code&gt;std&lt;/code&gt; 命名空间中找到它（或者相反）&amp;ndash;您想更改&lt;em&gt;不在&lt;/em&gt;命名空间 &lt;code&gt;std&lt;/code&gt; ，命名空间 &lt;code&gt;X&lt;/code&gt; ，..中的所有调用。 。），那么您打算怎么做呢？</target>
        </trans-unit>
        <trans-unit id="c4a5742abc54fef340d5e42bb52ab3d34501cefb" translate="yes" xml:space="preserve">
          <source>If you're only using &lt;code&gt;cout&lt;/code&gt;, nobody gets confused.  But when you have lots of namespaces flying around and you see this class and you aren't exactly sure what it does, having the namespace explicit acts as a comment of sorts. You can see at first glance, &quot;oh, this is a filesystem operation&quot; or &quot;that's doing network stuff&quot;.</source>
          <target state="translated">如果您只使用 &lt;code&gt;cout&lt;/code&gt; ，那么没人会感到困惑。 但是，当您有很多命名空间在四处徘徊，并且看到此类时，您不确定它的作用是什么，将命名空间显式用作某种注释。 乍看之下，&amp;ldquo;哦，这是文件系统操作&amp;rdquo;或&amp;ldquo;正在做网络工作&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3a0a2f58e94e59b13e5b57410ca215b154e4dd1a" translate="yes" xml:space="preserve">
          <source>In C++03 there was an idiom -- boilerplate code -- for implementing a &lt;code&gt;swap&lt;/code&gt; function for your classes. It was suggested that you actually use a local &lt;code&gt;using namespace std&lt;/code&gt; -- or at least &lt;code&gt;using std::swap&lt;/code&gt;:</source>
          <target state="translated">在C ++ 03中，有一个习惯用法-样板代码-用于为您的类实现 &lt;code&gt;swap&lt;/code&gt; 功能。 建议您实际上使用带有 &lt;code&gt;using namespace std&lt;/code&gt; 的本地-或至少 &lt;code&gt;using std::swap&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4efd6ea07a2c12ae34510e9920765f13b7b87856" translate="yes" xml:space="preserve">
          <source>In a decade, that project grew to have several million lines of code. Since these discussions come up again and again, I once was curious how often the (allowed) function-scope &lt;code&gt;using&lt;/code&gt; actually was used in the project. I grep'd the sources for it and only found one or two dozen places where it was used. To me this indicates that, once tried, developers don't find &lt;code&gt;std::&lt;/code&gt; painful enough to employ using directives even once every 100 kLoC even where it was allowed to be used.</source>
          <target state="translated">在十年中，该项目增长到拥有几百万行代码。 由于这些讨论一次又一次地出现，我曾经很好奇项目中实际使用（允许的）功能范围的频率。 我找到了它的来源，只发现了使用它的一两个地方。 对我来说，这表明，一旦尝试，开发人员就不会感到 &lt;code&gt;std::&lt;/code&gt; 痛苦到即使使用每100 kLoC一次就可以使用using指令，即使允许使用它也是如此。</target>
        </trans-unit>
        <trans-unit id="06435acc952b6ddf3ff59e777675ac2714343da8" translate="yes" xml:space="preserve">
          <source>In short: You can and should use namespace using declarations and directives liberally in your implementation files after #include directives and feel good about it. &lt;strong&gt;Despite repeated assertions to the contrary, namespace using declarations and directives are not evil and they do not defeat the purpose of namespaces. Rather, they are what make namespaces usable&lt;/strong&gt;.</source>
          <target state="translated">简而言之：您可以并且应该在#include指令之后在实现文件中自由使用使用声明和指令的名称空间，并对此感到满意。 &lt;strong&gt;尽管反复声明相反，使用声明和指令的名称空间并不是邪恶的，它们不会破坏名称空间的目的。&lt;/strong&gt; &lt;strong&gt;相反，它们是使命名空间可用的原因&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec2299e86922f16c12bb89391ea97d486f2d6389" translate="yes" xml:space="preserve">
          <source>In this example, we resolved potential name clashes and ambiguities arising from their composition.</source>
          <target state="translated">在这个例子中,我们解决了可能出现的名称冲突和构成上的歧义。</target>
        </trans-unit>
        <trans-unit id="65c4c1dce2db14606c299117092648f5be7eb3d2" translate="yes" xml:space="preserve">
          <source>It depends on where it is located. If it is a common header, then you are diminishing the value of the namespace by merging it into the global namespace. Keep in mind, this could be a neat way of making module globals.</source>
          <target state="translated">这取决于它的位置。如果它是一个普通的头,那么你通过将其合并到全局命名空间中来减少命名空间的价值。请记住,这可能是制作模块globals的整齐方法。</target>
        </trans-unit>
        <trans-unit id="a9149a57a26a9aeee68e53682d200c4529d40a43" translate="yes" xml:space="preserve">
          <source>It doesn't make your software or project performance worse. The inclusion of the namespace at the beginning of your source code isn't bad. The inclusion of the &lt;code&gt;using namespace std&lt;/code&gt; instruction varies according to your needs and the way you are developing the software or project.</source>
          <target state="translated">它不会使您的软件或项目性能变差。 在源代码的开头包含名称空间也不错。 &lt;code&gt;using namespace std&lt;/code&gt; 指令的内容根据您的需要以及开发软件或项目的方式而有所不同。</target>
        </trans-unit>
        <trans-unit id="2594ecb269de1ca1ca972a398f9ac08229b7f4f0" translate="yes" xml:space="preserve">
          <source>It is considered &quot;bad&quot; only when &lt;strong&gt;used globally&lt;/strong&gt;. Because:</source>
          <target state="translated">仅在&lt;strong&gt;全局使用&lt;/strong&gt;时才被视为&amp;ldquo;不良&amp;rdquo;。 因为：</target>
        </trans-unit>
        <trans-unit id="1ebc6c4aab7254b3c847f7a94a880434c0e2f28e" translate="yes" xml:space="preserve">
          <source>It's all about managing complexity. Using the namespace will pull things in that you don't want, and thus possibly make it harder to debug (I say possibly). Using std:: all over the place is harder to read (more text and all that).</source>
          <target state="translated">这就是管理复杂性的问题。使用命名空间会把你不想要的东西拉进来,因此可能会使调试变得更难(我说可能)。使用 std:::遍地都是的命名空间会让你更难读(更多的文字和其他的东西)。</target>
        </trans-unit>
        <trans-unit id="38709085bed04576c2d5d32366c7d466d551f5ee" translate="yes" xml:space="preserve">
          <source>It's nice to see code and know what it does. If I see &lt;code&gt;std::cout&lt;/code&gt; I know that's the &lt;code&gt;cout&lt;/code&gt; stream of the &lt;code&gt;std&lt;/code&gt; library. If I see &lt;code&gt;cout&lt;/code&gt; then I don't know. It &lt;em&gt;could&lt;/em&gt; be the &lt;code&gt;cout&lt;/code&gt; stream of the &lt;code&gt;std&lt;/code&gt; library. Or there could be an &lt;code&gt;int cout = 0;&lt;/code&gt; ten lines higher in the same function. Or a &lt;code&gt;static&lt;/code&gt; variable named &lt;code&gt;cout&lt;/code&gt; in that file. It could be anything.</source>
          <target state="translated">很高兴看到代码并知道它的作用。 如果我看到 &lt;code&gt;std::cout&lt;/code&gt; 我知道这就是 &lt;code&gt;std&lt;/code&gt; 库的 &lt;code&gt;cout&lt;/code&gt; 流。 如果我看到提示，那我就不知道了。 它&lt;em&gt;可能&lt;/em&gt;是 &lt;code&gt;std&lt;/code&gt; 库的 &lt;code&gt;cout&lt;/code&gt; 流。 否则可能是 &lt;code&gt;int cout = 0;&lt;/code&gt; 同一功能高十行。 或该文件中名为 &lt;code&gt;cout&lt;/code&gt; 的 &lt;code&gt;static&lt;/code&gt; 变量。 可能是任何东西。</target>
        </trans-unit>
        <trans-unit id="291d10432ee90ffee7774e1bfd80a03295550276" translate="yes" xml:space="preserve">
          <source>It's not horrible, but you'll save yourself headaches by not using it in header files or the global namespace. It's probably all right to do it in very limited scopes, but I've never had a problem typing the extra five characters to clarify where my functions are coming from.</source>
          <target state="translated">这并不可怕,但你可以通过不在头文件或全局命名空间中使用它来省去自己的头痛。可能在非常有限的范围内使用它是没有问题的,但我从来没有遇到过打出额外的五个字符来澄清我的函数来自哪里的问题。</target>
        </trans-unit>
        <trans-unit id="9baf97e2ec47fa798dfe06c21b8e750de1bac58f" translate="yes" xml:space="preserve">
          <source>It's one of these things that seem a really good idea if you are a teacher and never had to write and maintain any code for a living. I love seeing code where (1) I know what it does; and, (2) I'm confident that the person writing it knew what it does.</source>
          <target state="translated">如果你是个老师,而且从来没有以写代码和维护代码为生的人,那么这似乎是一个非常好的想法。我喜欢看到这样的代码:(1)我知道它是做什么的;(2)我确信写它的人知道它是做什么的。</target>
        </trans-unit>
        <trans-unit id="91a8c9eace09304424f54dbcea4ab917ef139db7" translate="yes" xml:space="preserve">
          <source>Just to clarify something: I don't actually think it is a good idea to use a name of a class/whatever in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; deliberately and more specifically in place of. The string is the exception (ignore the first, above, or second here, pun if you must) for me as I didn't like the idea of 'String'.</source>
          <target state="translated">只是为了澄清一些事情：我实际上不认为在&lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL中&lt;/a&gt;故意使用类/任何名称（而是更具体地代替它）是个好主意。 对于我来说，字符串是个例外（忽略第一个，上面或第二个，如果需要，请忽略双关），因为我不喜欢&amp;ldquo; String&amp;rdquo;的概念。</target>
        </trans-unit>
        <trans-unit id="29daf4a7594ca589153ad134f21264fe11ca3416" translate="yes" xml:space="preserve">
          <source>Just typing std::</source>
          <target state="translated">只是打出了std:。</target>
        </trans-unit>
        <trans-unit id="8507557482216947016f1aeee1629d528f10442b" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;std&lt;/code&gt; namespace has tons of identifiers, many of which are &lt;em&gt;very&lt;/em&gt; common ones (think &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, etc.) which are very likely to appear in other code, too.</source>
          <target state="translated">请记住， &lt;code&gt;std&lt;/code&gt; 名称空间有很多标识符，其中许多是&lt;em&gt;非常&lt;/em&gt;常见的标识符（例如 &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;sort&lt;/code&gt; ， &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;iterator&lt;/code&gt; 等），它们也很可能出现在其他代码中。</target>
        </trans-unit>
        <trans-unit id="6a07da18fbe175d65d1d0865aa1dc4b50b7ab47f" translate="yes" xml:space="preserve">
          <source>Library Foo 2.0 could introduce a function, &lt;code&gt;Quux()&lt;/code&gt;, that is an unambiguously better match for some of your calls to &lt;code&gt;Quux()&lt;/code&gt; than the &lt;code&gt;bar::Quux()&lt;/code&gt; your code called for years. Then your &lt;strong&gt;&lt;em&gt;code still compiles&lt;/em&gt;&lt;/strong&gt;, but &lt;strong&gt;&lt;em&gt;it silently calls the wrong function&lt;/em&gt;&lt;/strong&gt; and does god-knows-what. That's about as bad as things can get.</source>
          <target state="translated">库Foo 2.0可以引入一个函数 &lt;code&gt;Quux()&lt;/code&gt; ， 它对您对 &lt;code&gt;Quux()&lt;/code&gt; 的某些调用比对您多年调用的 &lt;code&gt;bar::Quux()&lt;/code&gt; 的匹配更好。 然后，您的&lt;strong&gt;&lt;em&gt;代码仍然可以编译&lt;/em&gt;&lt;/strong&gt; ，但是&lt;strong&gt;&lt;em&gt;它会静默地调用错误的函数，&lt;/em&gt;&lt;/strong&gt;并且可以执行任何操作。 事情会变得糟透了。</target>
        </trans-unit>
        <trans-unit id="5124022ffb20c699c10a1cc2488c255b2ffc9a00" translate="yes" xml:space="preserve">
          <source>NOTE: Don't focus too much on efficiency issues until you actually learn a little about how compilers work.  With a little experience coding you don't have to learn that much about them before you realize how much they are able to generalize good code into something something simple.  Every bit as simple as if you wrote the whole thing in C.  Good code is only as complex as it needs to be.</source>
          <target state="translated">注意:在你真正了解一点关于编译器的工作原理之前,不要太关注效率问题。只要你有一点编码经验,你不需要学习那么多关于它们的知识,你就会发现它们能把好的代码概括成简单的东西。好的代码只需要复杂到一定程度就可以了。</target>
        </trans-unit>
        <trans-unit id="9ce878b56aa89e0fc6464244ab6312410a2325ee" translate="yes" xml:space="preserve">
          <source>Names explicitly declared there (including names declared by using-declarations like &lt;code&gt;His_lib::String&lt;/code&gt;) take priority over names made accessible in another scope by a using-directive (&lt;code&gt;using namespace Her_lib&lt;/code&gt;).</source>
          <target state="translated">在此显式声明的名称（包括通过使用声明声明的名称，例如 &lt;code&gt;His_lib::String&lt;/code&gt; ）比使用using伪指令（ &lt;code&gt;using namespace Her_lib&lt;/code&gt; ）在另一个作用域中可访问的名称具有更高的优先级。</target>
        </trans-unit>
        <trans-unit id="50b2a2e68d91a2fa20faee50e5b1093521bfac70" translate="yes" xml:space="preserve">
          <source>Namespace usings are for your convenience, not for you to inflict on others: Never write a using declaration or a using directive before an #include directive.</source>
          <target state="translated">命名空间的使用是为了方便你的使用,而不是让你去强加给别人。不要在#include指令之前写一个使用声明或使用指令。</target>
        </trans-unit>
        <trans-unit id="50b1f6a51d747783cb1dfe6047e35834dd447f4e" translate="yes" xml:space="preserve">
          <source>Namespaces provide a powerful tool for the management of different libraries and of different versions of code. In particular, they offer the programmer alternatives of how explicit to make a reference to a nonlocal name.</source>
          <target state="translated">命名空间为管理不同库和不同版本的代码提供了一个强大的工具。特别是,它们为程序员提供了如何显式引用非本地名称的选择。</target>
        </trans-unit>
        <trans-unit id="ddbccb0a8b6506410340a7f532fe40e471a2e05a" translate="yes" xml:space="preserve">
          <source>Note that this is a simple example. If you have files with 20 includes and other imports, you'll have a ton of dependencies to go through to figure out the problem. The worse thing about it is that you can get unrelated errors in other modules depending on the definitions that conflict.</source>
          <target state="translated">注意,这只是一个简单的例子。如果你有20个include和其他导入的文件,你会有一吨的依赖关系来解决这个问题。更糟糕的是,根据定义冲突的定义,你会在其他模块中得到不相关的错误。</target>
        </trans-unit>
        <trans-unit id="36ea41aee46346ce28dcadcb94012cb303748b76" translate="yes" xml:space="preserve">
          <source>Notice how there is an ambiguity, to which library does cout point to?
  The compiler may detect this and not compile the program. In the worst
  case, the program may still compile but call the wrong function, since
  we never specified to which namespace the identifier belonged.</source>
          <target state="translated">注意到这里有一个歧义,cout指向哪个库?编译器可能会检测到这一点而不编译程序。在最坏的情况下,程序可能仍然会被编译,但调用了错误的函数,因为我们从未指定标识符属于哪个命名空间。</target>
        </trans-unit>
        <trans-unit id="f735b7708587108249bd04f231f9283a15ed3614" translate="yes" xml:space="preserve">
          <source>Now at a later stage of development, we wish to use another version of
  cout that is custom implemented in some library called &amp;ldquo;foo&amp;rdquo; (for
  example)</source>
          <target state="translated">现在，在开发的稍后阶段，我们希望使用在某个名为&amp;ldquo; foo&amp;rdquo;的库中自定义实现的cout的另一个版本（例如）</target>
        </trans-unit>
        <trans-unit id="a91a9e9922efdb33f03078a0f38ce71a94f60ab3" translate="yes" xml:space="preserve">
          <source>Now let's say you use &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together in your own program as follows:</source>
          <target state="translated">现在，假设您在自己的程序中一起使用 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="ce4819e926b1c69f9e959f1bcce61b24bbf7402f" translate="yes" xml:space="preserve">
          <source>Now take a million line code base, which isn't particularly big, and you're searching for a bug, which means you know there is one line in this one million lines that doesn't do what it is supposed to do. &lt;code&gt;cout &amp;lt;&amp;lt; 1;&lt;/code&gt; could read a &lt;code&gt;static int&lt;/code&gt; named &lt;code&gt;cout&lt;/code&gt;, shift it to the left by one bit, and throw away the result. Looking for a bug, I'd have to check that. Can you see how I really really prefer to see &lt;code&gt;std::cout&lt;/code&gt;?</source>
          <target state="translated">现在以一百万行代码库为基础，这不是特别大，并且您正在寻找一个错误，这意味着您知道一百万行中有一行没有执行应做的工作。 &lt;code&gt;cout &amp;lt;&amp;lt; 1;&lt;/code&gt; 可以读取一个名为 &lt;code&gt;cout&lt;/code&gt; 的 &lt;code&gt;static int&lt;/code&gt; ，将其向左移动一位，然后丢弃结果。 寻找错误，我必须检查一下。 您能看到我真的更喜欢看 &lt;code&gt;std::cout&lt;/code&gt; 吗？</target>
        </trans-unit>
        <trans-unit id="399f9e8eb4c399a3656111274a9c1b117d6d1db3" translate="yes" xml:space="preserve">
          <source>One shouldn't use the &lt;code&gt;using&lt;/code&gt; directive at the global scope, especially in headers. However, there are situations where it is appropriate even in a header file:</source>
          <target state="translated">不应在全局范围内使用 &lt;code&gt;using&lt;/code&gt; 指令，尤其是在标头中。 但是，在某些情况下，即使在头文件中也适用：</target>
        </trans-unit>
        <trans-unit id="1516c0ad1f8ca81d0226fc547e43c805fde700c0" translate="yes" xml:space="preserve">
          <source>People should stop being so anal about it. Your teacher was right all along. Just use ONE namespace; that is the whole point of using namespaces the first place. You are not supposed to use more than one at the same time. Unless it is your own. So again, redefinition will not happen.</source>
          <target state="translated">大家不要再这么针锋相对了。你的老师一直都是对的。只需使用一个命名空间就可以了;这就是使用命名空间的意义所在。你不应该同时使用一个以上的命名空间。除非是你自己的名字空间。所以再一次,重新定义是不会发生的。</target>
        </trans-unit>
        <trans-unit id="61ba504ad16f53fef83a89ee5e1bf8d3fd48334a" translate="yes" xml:space="preserve">
          <source>Personally, I actually don't mind the &lt;code&gt;std::&lt;/code&gt; prefix. I like the look more than not having it. I don't know if that is because it is explicit and says to me &quot;this isn't my code... I am using the standard library&quot; or if it is something else, but I think it looks nicer. This might be odd given that I only recently got into C++ (used and still do C and other languages for much longer and C is my favourite language of all time, right above assembly).</source>
          <target state="translated">就我个人而言，我实际上并不介意 &lt;code&gt;std::&lt;/code&gt; 前缀。 我不喜欢它，而不是喜欢它。 我不知道这是否是因为它是显式的，并对我说：&amp;ldquo;这不是我的代码&amp;hellip;&amp;hellip;我正在使用标准库&amp;rdquo;，或者是否还有其他用途，但我认为它看起来更好。 考虑到我最近才刚接触C ++（这可能很奇怪）（使用和仍然使用C和其他语言的时间更长，而C是我一直以来最喜欢的语言，就在汇编之上）。</target>
        </trans-unit>
        <trans-unit id="98a84cb2b057f0497de2c666cab0ffec97887f04" translate="yes" xml:space="preserve">
          <source>Readers will have difficulty seeing where a particular identifier comes from, when you use many &lt;code&gt;using namespace xyz&lt;/code&gt;.</source>
          <target state="translated">当您使用 &lt;code&gt;using namespace xyz&lt;/code&gt; 使用许多标识符时，读者将很难看到特定标识符的来源。</target>
        </trans-unit>
        <trans-unit id="9140d5235666001f10df811c2360c257238af8d5" translate="yes" xml:space="preserve">
          <source>Repeating a namespace name can be a distraction for both readers and writers. Consequently, it is possible
to state that names from a particular namespace are available without explicit qualification. For example:</source>
          <target state="translated">对读者和作者来说,重复一个命名空间的名称会分散读者和作者的注意力。因此,可以在没有明确限定的情况下,说明某一个特定命名空间的名称是可以使用的。比如说:</target>
        </trans-unit>
        <trans-unit id="a38525257f468902dfed8f814582f493c591c970" translate="yes" xml:space="preserve">
          <source>Short version: don't use global &lt;code&gt;using&lt;/code&gt; declarations or directives in header files. Feel free to use them in implementation files. Here's what &lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrei_Alexandrescu&quot;&gt;Andrei Alexandrescu&lt;/a&gt; have to say about this issue in &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321113586&quot;&gt;C++ Coding Standards&lt;/a&gt; (bolding for emphasis is mine):</source>
          <target state="translated">简短版本：不要在头文件中使用global &lt;code&gt;using&lt;/code&gt; 声明或指令。 随时在实现文件中使用它们。 这是&lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;赫伯&amp;middot;萨特&lt;/a&gt; （ Herb Sutter）和&lt;a href=&quot;https://en.wikipedia.org/wiki/Andrei_Alexandrescu&quot;&gt;安德烈&amp;middot;亚历山大&lt;/a&gt; （ Andrei Alexandrescu）在&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321113586&quot;&gt;C ++编码标准中&lt;/a&gt;对这个问题的评价（强调点是我的）</target>
        </trans-unit>
        <trans-unit id="eec2d891bc3edd909e8348b90447e5d43222b3e9" translate="yes" xml:space="preserve">
          <source>So here's how I solved it. Install Boost's regex, and link it in. Then, I do the following so that when libstdc++ has it implemented entirely, I need only remove this block and the code remains the same:</source>
          <target state="translated">所以我是这样解决的。安装Boost的regex,并将其链接进去。然后,我做了下面的操作,这样当libstdc++完全实现后,我只需要把这个块去掉,代码不变。</target>
        </trans-unit>
        <trans-unit id="ba958b36fe2684798576e2f9a1a8d021d2835d2a" translate="yes" xml:space="preserve">
          <source>So just consider them functions as reserved names like &quot;int&quot; or &quot;class&quot; and that is it.</source>
          <target state="translated">所以只要把它们看作是保留的函数名称,比如 &quot;int &quot;或 &quot;class&quot;,就可以了。</target>
        </trans-unit>
        <trans-unit id="eeaf7c2ef34ec4418e50a2e403553b2d83998883" translate="yes" xml:space="preserve">
          <source>So the following are OK:</source>
          <target state="translated">所以,以下这些都是可以的。</target>
        </trans-unit>
        <trans-unit id="f103eac16afc4b9fd2b1e99833b3f809101f91e2" translate="yes" xml:space="preserve">
          <source>So you'll need to do some maintenance to clarify that 'a' meant &lt;code&gt;foo::a&lt;/code&gt;. That's undesirable, but fortunately it is pretty easy (just add &lt;code&gt;foo::&lt;/code&gt; in front of all calls to &lt;code&gt;a&lt;/code&gt; that the compiler marks as ambiguous).</source>
          <target state="translated">因此，您需要进行一些维护以阐明'a'意味着 &lt;code&gt;foo::a&lt;/code&gt; 。 这是不希望有的，但幸运的是，这很容易（只需在编译器标记为模糊的所有对 &lt;code&gt;a&lt;/code&gt; 的调用之前添加 &lt;code&gt;foo::&lt;/code&gt; :）。</target>
        </trans-unit>
        <trans-unit id="ecb267a2211227e4951289cb2c61d96f30e02f89" translate="yes" xml:space="preserve">
          <source>Some people had said that is a bad practice to include the &lt;code&gt;using namespace std&lt;/code&gt; in your source files because you're invoking from that namespace all the functions and variables. When you would like to define a new function with the same name as another function contained in the &lt;code&gt;namespace std&lt;/code&gt; you would overload the function and it could produce problems due to compile or execute. It will not compile or executing as you expect.</source>
          <target state="translated">有人曾说过，在源文件中包含 &lt;code&gt;using namespace std&lt;/code&gt; 是一种不好的做法，因为您要从该命名空间调用所有函数和变量。 当您想要定义一个与名称 &lt;code&gt;namespace std&lt;/code&gt; 包含的另一个函数同名的新函数时，您将使该函数过载，并且由于编译或执行而可能产生问题。 它不会像您期望的那样编译或执行。</target>
        </trans-unit>
        <trans-unit id="2983f4020c6309b44686250810ad2fa1b133cdbd" translate="yes" xml:space="preserve">
          <source>Source-file-level using-declarations inside source files</source>
          <target state="translated">源文件内的源文件级使用声明</target>
        </trans-unit>
        <trans-unit id="48a09de267300394017fd1240b9ef9afafe06e9a" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;An Overview of the C++ Programming Language&lt;/em&gt;
by Bjarne Stroustrup</source>
          <target state="translated">资料来源：Bjarne Stroustrup撰写&lt;em&gt;的C ++编程语言概述&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="8d362630dbd96c9d94d61a5ba26f68429e881414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;namespace std&lt;/code&gt; contains the C++ standard functions and variables. This namespace is useful when you often would use the C++ standard functions.</source>
          <target state="translated">&lt;code&gt;namespace std&lt;/code&gt; 包含C ++标准函数和变量。 当您经常使用C ++标准函数时，此命名空间很有用。</target>
        </trans-unit>
        <trans-unit id="a0ecbbc85e8e265d8a3603712049a64cd310766c" translate="yes" xml:space="preserve">
          <source>The FAQ suggests two alternatives:</source>
          <target state="translated">常见问题建议有两种选择。</target>
        </trans-unit>
        <trans-unit id="64995ed41ecdd7959fd7a75459bcac3c990a145f" translate="yes" xml:space="preserve">
          <source>The compiler will choose the &lt;code&gt;std::swap&lt;/code&gt; for &lt;code&gt;value_&lt;/code&gt;, i.e. &lt;code&gt;void std::swap(int, int)&lt;/code&gt;.</source>
          <target state="translated">编译器将为 &lt;code&gt;value_&lt;/code&gt; 选择 &lt;code&gt;std::swap&lt;/code&gt; ，即 &lt;code&gt;void std::swap(int, int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7f65e416b24edb3d7d7359d825fd5f48ff2bf1b" translate="yes" xml:space="preserve">
          <source>The problem with putting &lt;code&gt;using namespace&lt;/code&gt; in the header files of your classes is that it forces anyone who wants to use your classes (by including your header files) to also be 'using' (i.e. seeing everything in) those other namespaces.</source>
          <target state="translated">在类的头文件中 &lt;code&gt;using namespace&lt;/code&gt; 的问题在于，它会迫使想要使用您的类的任何人（通过包含头文件）也&amp;ldquo;使用&amp;rdquo;（即查看所有其他名称空间）。</target>
        </trans-unit>
        <trans-unit id="651d1324e3e3efa0febb293121711a75a4c05298" translate="yes" xml:space="preserve">
          <source>The statement using namespace std is generally considered bad
  practice. The alternative to this statement is to specify the
  namespace to which the identifier belongs using the scope operator(::)
  each time we declare a type.</source>
          <target state="translated">使用命名空间 std 的语句一般被认为是不好的做法。这个语句的替代方法是在每次声明一个类型时,使用 scope 操作符(::)指定标识符所属的命名空间。</target>
        </trans-unit>
        <trans-unit id="da678d1957a06dc4c79a7d800b78557e33ff5ebf" translate="yes" xml:space="preserve">
          <source>The using-directive exists for legacy C++ code and to ease the transition to namespaces, but you probably shouldn&amp;rsquo;t use it on a regular basis, at least not in your new C++ code.</source>
          <target state="translated">using指令适用于旧版C ++代码，并可以简化向名称空间的过渡，但是您可能不应该定期使用它，至少在新的C ++代码中不应该使用。</target>
        </trans-unit>
        <trans-unit id="5b8ee9557da2fd48e95fe83d8c0f287ad5f8df12" translate="yes" xml:space="preserve">
          <source>There is no problem using &quot;using namespace std&quot; in your source file
  when you make heavy use of the namespace and know for sure that
  nothing will collide.</source>
          <target state="translated">在你的源文件中使用 &quot;使用命名空间 std &quot;是没有问题的,当你大量使用命名空间,并且知道肯定不会有什么碰撞。</target>
        </trans-unit>
        <trans-unit id="029764c0ea9e395746931f8952df7326aa09ac18" translate="yes" xml:space="preserve">
          <source>There is one other thing although it is somewhat related to the above and what others point out. While this might be bad practise, I sometimes reserve &lt;code&gt;std::name&lt;/code&gt; for the standard library version and name for program-specific implementation. Yes, indeed this could bite you and bite you hard, but it all comes down to that I started this project from scratch, and I'm the only programmer for it. Example: I overload &lt;code&gt;std::string&lt;/code&gt; and call it &lt;code&gt;string&lt;/code&gt;. I have helpful additions. I did it in part because of my C and Unix (+ Linux) tendency towards lower-case names.</source>
          <target state="translated">还有另一件事，尽管它与上述内容以及其他指出的内容有些相关。 尽管这可能是不好的做法，但有时我会为标准库版本保留 &lt;code&gt;std::name&lt;/code&gt; ，并为程序特定的实现保留名称 。 是的，确实这可能会咬你，再咬你，但是一切都取决于我从头开始这个项目，而且我是唯一的程序员。 示例：我重载 &lt;code&gt;std::string&lt;/code&gt; 并将其称为 &lt;code&gt;string&lt;/code&gt; 。 我有一些有益的补充。 我这样做的部分原因是我的C和Unix（+ Linux）倾向于使用小写字母。</target>
        </trans-unit>
        <trans-unit id="3f0a653213e88a4d78de823350af0cc28a0f0151" translate="yes" xml:space="preserve">
          <source>Therefore, avoiding &lt;code&gt;using namespace X;&lt;/code&gt; is a form of future-proofing, a way of making sure a change to the libraries and/or header files in use is not going to break a program.</source>
          <target state="translated">因此，避免 &lt;code&gt;using namespace X;&lt;/code&gt; 是一种面向未来的形式，一种确保对正在使用的库和/或头文件进行更改不会破坏程序的方法。</target>
        </trans-unit>
        <trans-unit id="f45f9dde8d1c10defc80ef7f165a362cba2c156e" translate="yes" xml:space="preserve">
          <source>This does the following magic:</source>
          <target state="translated">这样做有如下魔力:</target>
        </trans-unit>
        <trans-unit id="a4545a366e0aad9d34b8acbf9d14874529a60d6a" translate="yes" xml:space="preserve">
          <source>This is a bad practice, often known as global namespace pollution. Problems may occur when more than one namespace has the same function name with signature, then it will be ambiguous for the compiler to decide which one to call and this all can be avoided when you are specifying the namespace with your function call like &lt;code&gt;std::cout&lt;/code&gt; . Hope this helps. :)</source>
          <target state="translated">这是一种不良做法，通常称为全局名称空间污染。 当多个名称空间具有相同的带有签名的函数名称时，可能会出现问题，然后编译器决定要调用哪个名称将是模棱两可的，而当您使用函数调用（例如 &lt;code&gt;std::cout&lt;/code&gt; 指定名称空间时，可以避免所有这些情况：侦察兵 。 希望这可以帮助。 :)</target>
        </trans-unit>
        <trans-unit id="99260186b8c3a0ba3c616d9138288919d1f36e7b" translate="yes" xml:space="preserve">
          <source>This is better than explicit qualification (&lt;code&gt;std::sin&lt;/code&gt;, &lt;code&gt;std::cos&lt;/code&gt;...), because it is shorter and has the ability to work with user defined floating point types (via &lt;a href=&quot;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;argument-dependent lookup&lt;/a&gt; (ADL)).</source>
          <target state="translated">这比显式限定（ &lt;code&gt;std::sin&lt;/code&gt; ， &lt;code&gt;std::cos&lt;/code&gt; ...）更好，因为它更短并且具有使用用户定义的浮点类型的能力（通过&lt;a href=&quot;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;依赖于参数的查找&lt;/a&gt; （ADL））。</target>
        </trans-unit>
        <trans-unit id="160a0a5c0f76c23ec35ad5487bfae3b08b2536aa" translate="yes" xml:space="preserve">
          <source>This is not related to performance at all. But consider this: you are using two libraries called Foo and Bar:</source>
          <target state="translated">这和性能完全没有关系。但考虑到这一点:你使用的是两个叫Foo和Bar的库。</target>
        </trans-unit>
        <trans-unit id="298ec62c38104583ee0298f42b39da2f5449b342" translate="yes" xml:space="preserve">
          <source>To answer your question I look at it this way practically:  a lot of programmers (not all) invoke namespace std.  Therefore one should be in the habit of NOT using things that impinge or use the same names as what is in the namespace std.  That is a great deal granted, but not so much compared to the number of possible coherent words and pseudonyms that can be come up with strictly speaking.</source>
          <target state="translated">要回答你的问题,我实际上是这样看的:很多程序员(不是所有程序员)都会调用命名空间 std.com。因此,我们应该养成不使用与命名空间 std 中的东西相冲突或使用相同名称的习惯。这是很有道理的,但相对于严格意义上来说,可以想出的连贯的词和假名的数量来说,就不那么多了。</target>
        </trans-unit>
        <trans-unit id="2782259cabfa8ad3d1fe54d85a7f2baf351f10f1" translate="yes" xml:space="preserve">
          <source>Ultimately this is a trade-off between writability vs. reliability/maintainability. Readability may factor in also, but I could see arguments for that going either way. Normally I would say reliability and maintainability are more important, but in this case you'll constantly pay the writability cost for an fairly rare reliability/maintainability impact. The 'best' trade-off will determine on your project and your priorities.</source>
          <target state="translated">归根结底,这是一个可写性与可靠性维护性之间的权衡。可读性可能也是一个因素,但我可以看到任何一种方式都有理由。通常情况下,我会说可靠性和可维护性更重要,但在这种情况下,你会不断地付出可写性的代价来换取相当少见的可靠性可维护性的影响。最佳 &quot;的权衡将取决于你的项目和你的优先级。</target>
        </trans-unit>
        <trans-unit id="6ea4fced5fb87a77ecac7ac3fa6aeea3011782f8" translate="yes" xml:space="preserve">
          <source>Using many namespaces at the same time is obviously a recipe for disaster, but using JUST namespace &lt;code&gt;std&lt;/code&gt; and only namespace &lt;code&gt;std&lt;/code&gt; is not that big of a deal in my opinion because redefinition can only occur by your own code...</source>
          <target state="translated">同时使用多个名称空间显然是灾难的根源，但在我看来，仅使用名称空间 &lt;code&gt;std&lt;/code&gt; 和仅使用名称空间 &lt;code&gt;std&lt;/code&gt; 就没什么大不了的，因为重新定义只能由您自己的代码进行...</target>
        </trans-unit>
        <trans-unit id="41a6352eaeffb261dfe2d93e2ca63fc49c9ba12a" translate="yes" xml:space="preserve">
          <source>What are these &lt;em&gt;good reasons&lt;/em&gt;? Sometimes programmers explicitly want to turn off ADL, other times they want to disambiguate.</source>
          <target state="translated">这些&lt;em&gt;好的理由是&lt;/em&gt;什么？ 有时，程序员明确希望关闭ADL，而有时他们又想消除歧义。</target>
        </trans-unit>
        <trans-unit id="ab54537830a0232c9f9d54213cf3aa6945c2396b" translate="yes" xml:space="preserve">
          <source>Whatever is true for &lt;em&gt;other&lt;/em&gt; readers of your source code is even more true for the most frequent reader of it: yourself. Come back in a year or two and take a look...</source>
          <target state="translated">对于您的源代码的&lt;em&gt;其他&lt;/em&gt;阅读者而言，正确的是对最常使用它的读者：您自己。 一两年后再来看看...</target>
        </trans-unit>
        <trans-unit id="cdb77621d85047abd900bf6e655db16ba77b61bb" translate="yes" xml:space="preserve">
          <source>When you use a namespace you're risking a scenario like this, which is why people are uncomfortable using namespaces. The more things in a namespace, the greater the risk of conflict, so people might be even more uncomfortable using namespace &lt;code&gt;std&lt;/code&gt; (due to the number of things in that namespace) than other namespaces.</source>
          <target state="translated">使用命名空间时，您会冒这样的风险，这就是为什么人们对使用命名空间感到不舒服的原因。 名称空间中的事物越多，发生冲突的风险就越大，因此使用名称空间 &lt;code&gt;std&lt;/code&gt; （由于该名称空间中的事物数量）而导致的人们可能比其他名称空间更加不舒服。</target>
        </trans-unit>
        <trans-unit id="1654c94350473966024505fd813d40c64664c782" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;using namespace std;&lt;/code&gt; considered a bad practice? Is it inefficient or does it risk declaring ambiguous variables (variables that share the same name as a function in &lt;code&gt;std&lt;/code&gt; namespace)? Does it impact performance?</source>
          <target state="translated">为什么 &lt;code&gt;using namespace std;&lt;/code&gt; 被认为是不良做法？ 是效率低下还是冒着声明模棱两可的变量（与 &lt;code&gt;std&lt;/code&gt; 名称空间中的函数具有相同名称的变量）的风险？ 它会影响性能吗？</target>
        </trans-unit>
        <trans-unit id="b584d12b92d355bff8bb0e1c7230b6bf58ecd519" translate="yes" xml:space="preserve">
          <source>Why is “using namespace std;” considered bad practice</source>
          <target state="translated">为什么 &quot;使用命名空间 std;&quot;被认为是不好的做法?</target>
        </trans-unit>
        <trans-unit id="0e30f8945d319ea0f3eeddb281fd252a6c00818b" translate="yes" xml:space="preserve">
          <source>With C++11 there is no reason to use this pattern any more. The implementation of &lt;code&gt;std::swap&lt;/code&gt; was changed to find a potential overload and choose it.</source>
          <target state="translated">使用C ++ 11，就没有理由再使用此模式了。 已更改 &lt;code&gt;std::swap&lt;/code&gt; 的实现，以找到潜在的过载并选择它。</target>
        </trans-unit>
        <trans-unit id="634192ce5da22f1caaa7b9299179cbcca7b577b9" translate="yes" xml:space="preserve">
          <source>With unqualified imported identifiers you need external search tools like &lt;em&gt;grep&lt;/em&gt; to find out where identifiers are declared. This makes reasoning about program correctness harder.</source>
          <target state="translated">对于不合格的导入标识符，您需要外部搜索工具（例如&lt;em&gt;grep）&lt;/em&gt;来查找声明标识符的位置。 这使得关于程序正确性的推理更加困难。</target>
        </trans-unit>
        <trans-unit id="61b8baeb889064cf813917c7fab3baf262e3a825" translate="yes" xml:space="preserve">
          <source>You clutter the namespace you are programming in.</source>
          <target state="translated">你在编程时,你的命名空间就会变得杂乱无章。</target>
        </trans-unit>
        <trans-unit id="3bf6425e37e04cd0a68c1fc7844787cb56ab92a8" translate="yes" xml:space="preserve">
          <source>You could write a program to do it, but wouldn't it be better to spend time working on your project itself rather than writing a program to maintain your project?</source>
          <target state="translated">你可以写一个程序来做,但与其写一个程序来维护你的项目,不如把时间花在项目本身上,不是更好吗?</target>
        </trans-unit>
        <trans-unit id="1a066f3f13ff76e054b645560a1597523d36beac" translate="yes" xml:space="preserve">
          <source>You may use it locally</source>
          <target state="translated">你可以在本地使用</target>
        </trans-unit>
        <trans-unit id="1a6d9c972154f7b0a7a3e7bc908971e2acb03018" translate="yes" xml:space="preserve">
          <source>You need to be able to read code written by people who have different style and best practices opinions than you.</source>
          <target state="translated">你需要能够阅读那些与你有不同风格和最佳实践意见的人写的代码。</target>
        </trans-unit>
        <trans-unit id="9e5ae30173712188975d44da3afd5fd95f0f943a" translate="yes" xml:space="preserve">
          <source>and in the implementation:</source>
          <target state="translated">并在执行中。</target>
        </trans-unit>
        <trans-unit id="2b71447c7e589fd9da4e2a449318d54f8e55a2f0" translate="yes" xml:space="preserve">
          <source>as opposed to:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
