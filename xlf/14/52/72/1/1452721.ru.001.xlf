<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1452721">
    <body>
      <group id="1452721">
        <trans-unit id="8e0741bec52099753c6c2a0306787331f3b1bf94" translate="yes" xml:space="preserve">
          <source>&quot;Why is 'using namespace std;' considered a bad practice in C++?&quot;</source>
          <target state="translated">&quot;Почему &quot;использование пространства имён std;&quot; считается плохой практикой в Си++?&quot;</target>
        </trans-unit>
        <trans-unit id="5575dde3d3d20bdebe5e5002778dd58101ae84ae" translate="yes" xml:space="preserve">
          <source>(Sometimes) source-file-level using-directives</source>
          <target state="translated">(Иногда)директивы об использовании на уровне источников информации-директивы</target>
        </trans-unit>
        <trans-unit id="6a699133bca549300caca4bbc9e50a4f03f67b9e" translate="yes" xml:space="preserve">
          <source>A concrete example to clarify the concern. Imagine you have a situation where you have two libraries, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, each with their own namespace:</source>
          <target state="translated">Конкретный пример, чтобы прояснить проблему. Представьте, что у вас есть ситуация, когда у вас есть две библиотеки, &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; , каждая со своим собственным пространством имен:</target>
        </trans-unit>
        <trans-unit id="ba3eac4e25ae1cec81af111cfd596d079e2ef4bd" translate="yes" xml:space="preserve">
          <source>A lot of &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; features are going into the C++0x standard, and Visual&amp;nbsp;Studio&amp;nbsp;2010 has a lot of C++0x features, so suddenly these programs were not compiling.</source>
          <target state="translated">Многие функции &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; входят в стандарт C ++ 0x, а Visual Studio 2010 имеет много функций C ++ 0x, поэтому неожиданно эти программы не компилировались.</target>
        </trans-unit>
        <trans-unit id="39f8e6781daf6a934001f51f44614f546e42a1e3" translate="yes" xml:space="preserve">
          <source>A namespace is a named scope. Namespaces are used to group related declarations and to keep separate
items separate. For example, two separately developed libraries may use the same name to refer to different
items, but a user can still use both:</source>
          <target state="translated">Пространство имён-это именованная область.Пространства имен используются для группировки связанных с ними объявлений и для разделения отдельных элементов.Например,две отдельно разработанные библиотеки могут использовать одно и то же имя для обозначения различных элементов,но пользователь может использовать и то,и другое:</target>
        </trans-unit>
        <trans-unit id="8a340e0ae7fed0a2d743f95465081c70d0cb841d" translate="yes" xml:space="preserve">
          <source>A using-declaration:</source>
          <target state="translated">Заявление об использовании:</target>
        </trans-unit>
        <trans-unit id="b82a662dae5884212abc04bb506affe12b0328ae" translate="yes" xml:space="preserve">
          <source>Although the statement saves us from typing std:: whenever
  we wish to access a class or type defined in the std namespace, it
  imports the entirety of the std namespace into the current namespace
  of the program. Let us take a few examples to understand why this
  might not be such a good thing</source>
          <target state="translated">Хотя это утверждение спасает нас от ввода std:::всякий раз,когда мы хотим получить доступ к классу или типу,определённому в пространстве имён std,оно импортирует всё пространство имён std в текущее пространство имён программы.Давайте возьмем несколько примеров,чтобы понять,почему это может быть не так хорошо.</target>
        </trans-unit>
        <trans-unit id="2b00151385441b68225fc4658924e46453d8ec93" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;using namespace std&lt;/code&gt; throws a compilation error because of the ambiguity of count, which is also a function in algorithm library.</source>
          <target state="translated">Пример, в котором &lt;code&gt;using namespace std&lt;/code&gt; вызывает ошибку компиляции из-за неоднозначности count, которая также является функцией в библиотеке алгоритмов.</target>
        </trans-unit>
        <trans-unit id="235c5c438cb46b535c12595279d731d5b7716a5d" translate="yes" xml:space="preserve">
          <source>An idiom for using it locally</source>
          <target state="translated">Идиома для локального использования</target>
        </trans-unit>
        <trans-unit id="0fbb0cc023270ff0740fd1bead3e7a7d083f3415" translate="yes" xml:space="preserve">
          <source>And as for making Boost's regex part of &lt;code&gt;std&lt;/code&gt;. I do that for future integration and &amp;ndash; again, I admit fully this is bias - I don't think it is as ugly as &lt;code&gt;boost::regex:: ...&lt;/code&gt;. Indeed, that is another thing for me. There are many things in C++ that I still have yet to come to fully accept in looks and methods (another example: variadic templates versus var arguments [though I admit variadic templates are very very useful!]). Even those that I do accept it was difficult, &lt;em&gt;and&lt;/em&gt; I still have issues with them.</source>
          <target state="translated">А что касается того, чтобы сделать регулярное выражение Boost частью &lt;code&gt;std&lt;/code&gt; . Я делаю это для будущей интеграции и - опять же, я полностью признаю, что это предвзятость - я не думаю, что это так ужасно, как &lt;code&gt;boost::regex:: ...&lt;/code&gt; На самом деле, это другое для меня. В C ++ есть много вещей, которые мне еще предстоит полностью принять во взглядах и методах (другой пример: шаблоны с переменным числом аргументов против аргументов var [хотя я допускаю, что шаблоны с переменным числом аргументов очень и очень полезны!]). Даже те, кого я принимаю, были трудными, &lt;em&gt;и у&lt;/em&gt; меня все еще есть проблемы с ними.</target>
        </trans-unit>
        <trans-unit id="3aa9fcea2af1d01ac1dbb4efe366442a34d014fe" translate="yes" xml:space="preserve">
          <source>And see &lt;a href=&quot;https://www.sololearn.com/Discuss/187690/is-using-namespace-std-a-bad-practice/&quot;&gt;this opinion&lt;/a&gt;:</source>
          <target state="translated">И увидеть &lt;a href=&quot;https://www.sololearn.com/Discuss/187690/is-using-namespace-std-a-bad-practice/&quot;&gt;это мнение&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0fecfa228c906cdbaa2a5ef28640a1b52d83c4df" translate="yes" xml:space="preserve">
          <source>Another reason is surprise.</source>
          <target state="translated">Другая причина-сюрприз.</target>
        </trans-unit>
        <trans-unit id="9d1dee9a88dd2bd4cb378802f7b802ac8d01b036" translate="yes" xml:space="preserve">
          <source>As is mentioned in this &lt;a href=&quot;https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/&quot;&gt;page&lt;/a&gt;:</source>
          <target state="translated">Как упоминается на этой &lt;a href=&quot;https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/&quot;&gt;странице&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e1ea5cc086ad8c105f0de7b7b2d957c6908d8ceb" translate="yes" xml:space="preserve">
          <source>As it is, I am still very biased towards C and biased against C++. Sparing details, much of what I work on fits C more (but it was a good exercise and a good way to make myself a. learn another language and b. try not be less biased against object/classes/etc which is maybe better stated as less closed-minded, less arrogant, and more accepting.). But what &lt;em&gt;is&lt;/em&gt; useful is what some already suggested: I do indeed use list (it is fairly generic, is it not ?), and sort (same thing) to name two that would cause a name clash if I were to do &lt;code&gt;using namespace std;&lt;/code&gt;, and so to that end I prefer being specific, in control and knowing that if I intend it to be the standard use then I will have to specify it. Put simply: no assuming allowed.</source>
          <target state="translated">На самом деле, я все еще очень склонен к C и склонен к C ++. Щадящие детали, большая часть того, над чем я работаю, больше подходит для C (но это было хорошее упражнение и хороший способ заставить себя а. Выучить другой язык и б) стараться не быть менее предвзятым по отношению к объекту / классам / и т. Д., Что, возможно, лучше сформулировано как менее закрытый, менее высокомерный и более принимающий.) Но то, что полезно, это то, что некоторые уже предложили: я действительно использую список (это довольно универсально, не так ли?) И сортирую (то же самое), чтобы назвать два, что вызвало бы конфликт имен, если бы я делал это &lt;code&gt;using namespace std;&lt;/code&gt; и поэтому для этого я предпочитаю быть конкретным, контролировать и знать, что, если я намерен использовать его как стандартное использование, мне придется его указать. Проще говоря, не предполагая, допускается.</target>
        </trans-unit>
        <trans-unit id="a951ab665371162929ad7cc1021e7f306c09ca5a" translate="yes" xml:space="preserve">
          <source>At this point everything is fine. When you run your program it 'Does something'. But later you update &lt;code&gt;bar&lt;/code&gt; and let's say it has changed to be like:</source>
          <target state="translated">На данный момент все хорошо. Когда вы запускаете свою программу, она &amp;laquo;что-то делает&amp;raquo;. Но позже вы обновляете &lt;code&gt;bar&lt;/code&gt; и, скажем, она изменилась, чтобы быть такой:</target>
        </trans-unit>
        <trans-unit id="9cd966c7ceb5c8bf6d8a1e601c36928bf783b349" translate="yes" xml:space="preserve">
          <source>At this point you'll get a compiler error:</source>
          <target state="translated">В этот момент вы получите ошибку компилятора:</target>
        </trans-unit>
        <trans-unit id="62f3b54904071c98839a53723f5cac8dbd3c6262" translate="yes" xml:space="preserve">
          <source>At this point your call to &lt;code&gt;a(42)&lt;/code&gt; suddenly binds to &lt;code&gt;bar::a&lt;/code&gt; instead of &lt;code&gt;foo::a&lt;/code&gt; and instead of doing 'something' it does 'something completely different'.  No compiler warning or anything. Your program just silently starts doing something complete different than before.</source>
          <target state="translated">В этот момент ваш вызов &lt;code&gt;a(42)&lt;/code&gt; неожиданно связывается с &lt;code&gt;bar::a&lt;/code&gt; вместо &lt;code&gt;foo::a&lt;/code&gt; и вместо того, чтобы делать &amp;laquo;что-то&amp;raquo;, он делает &amp;laquo;что-то совершенно другое&amp;raquo;. Нет предупреждения компилятора или что-нибудь. Ваша программа просто молча начинает делать что-то совершенно другое, чем раньше.</target>
        </trans-unit>
        <trans-unit id="36dab49377a029cf015f76cbd70a8bead781a8f1" translate="yes" xml:space="preserve">
          <source>Besides that, you can have namespace aliases. Here is an example of where it is useful that might not have been referred to. I use the C++11 standard and specifically with libstdc++. Well, it doesn't have complete &lt;code&gt;std::regex&lt;/code&gt; support. Sure, it compiles, but it throws an exception along the lines of it being an error on the programmer's end. But it is lack of implementation.</source>
          <target state="translated">Кроме того, вы можете иметь псевдонимы пространства имен. Вот пример того, где это полезно, на которое, возможно, не ссылались. Я использую стандарт C ++ 11 и специально с libstdc ++. Ну, у него нет полной поддержки &lt;code&gt;std::regex&lt;/code&gt; . Конечно, он компилируется, но выдает исключение, так как это ошибка программиста. Но это недостаток реализации.</target>
        </trans-unit>
        <trans-unit id="8b819cb9c25c847eca882b7f61088fcf30ea9024" translate="yes" xml:space="preserve">
          <source>Beware that some people disagree with my saying &quot;feel free&quot; like this -- because although a &lt;code&gt;using&lt;/code&gt; statement in a cpp file is &lt;em&gt;better&lt;/em&gt; than in a header (because it doesn't affect people who include your header file), they think it's still not &lt;em&gt;good&lt;/em&gt; (because depending on the code it could make the implementation of the class more difficult to maintain). &lt;a href=&quot;https://isocpp.org/wiki/faq/coding-standards#using-namespace-std&quot;&gt;This C++ Super-FAQ entry&lt;/a&gt; says,</source>
          <target state="translated">Имейте в виду, что некоторые люди не согласны с моим высказыванием &amp;laquo;не стесняйтесь&amp;raquo;, как это - потому что, хотя оператор &lt;code&gt;using&lt;/code&gt; в файле cpp &lt;em&gt;лучше,&lt;/em&gt; чем в заголовке (потому что он не влияет на людей, которые включают ваш файл заголовка), они думают, что это все еще не &lt;em&gt;хорошо&lt;/em&gt; (потому что в зависимости от кода это может усложнить реализацию класса). &lt;a href=&quot;https://isocpp.org/wiki/faq/coding-standards#using-namespace-std&quot;&gt;Эта запись C ++ Super-FAQ&lt;/a&gt; гласит:</target>
        </trans-unit>
        <trans-unit id="3bd225512cee60fc69de0a0f917ae67552b94c49" translate="yes" xml:space="preserve">
          <source>Bottom line: Explicitly prefixing everything doesn't do any harm, takes very little getting used to, and has objective advantages. In particular, it makes the code easier to interpret by the compiler and by human readers &amp;mdash; and that should probably be the main goal when writing code.</source>
          <target state="translated">Итог: явный префикс всего не приносит никакого вреда, требует очень мало привыкания и имеет объективные преимущества. В частности, это облегчает интерпретацию кода компилятором и читателями - и это, вероятно, должно быть главной целью при написании кода.</target>
        </trans-unit>
        <trans-unit id="984d1515ce54fb1acb235d14e03bcd7545ccca8f" translate="yes" xml:space="preserve">
          <source>But imagine an alternative scenario where bar changed instead to look like this instead:</source>
          <target state="translated">Но представьте себе альтернативный сценарий,в котором вместо этого панель изменилась,чтобы выглядеть вот так:</target>
        </trans-unit>
        <trans-unit id="bd243da61bc83e255c691b0eeb1676f5cf315d17" translate="yes" xml:space="preserve">
          <source>Consider</source>
          <target state="translated">Consider</target>
        </trans-unit>
        <trans-unit id="0fde436f316d9e7c2c1244b279c7df1ee1b8459d" translate="yes" xml:space="preserve">
          <source>Consider e.g. writing a piece of numerical software. Why would I even consider polluting my global namespace by cutting general &quot;std::vector&quot; down to &quot;vector&quot; when &quot;vector&quot; is one of the problem domain's most important concepts?</source>
          <target state="translated">Рассмотрим,например,возможность написания числового программного обеспечения.Зачем мне вообще думать о загрязнении своего глобального пространства имён,обрезая общее &quot;std::vector&quot; до &quot;vector&quot;,когда &quot;вектор&quot; является одним из самых важных понятий в проблемной области?</target>
        </trans-unit>
        <trans-unit id="4f260645290a8d4cc5baf50a62bc1e04d3f4c8a3" translate="yes" xml:space="preserve">
          <source>Corollary: In header files, don&amp;rsquo;t write namespace-level using directives or using declarations; instead, explicitly namespace-qualify all names. (The second rule follows from the first, because headers can never know what other header #includes might appear after them.)</source>
          <target state="translated">Следствие: в заголовочных файлах не пишите на уровне пространства имен, используя директивы или объявления; вместо этого явно определите пространство имен для всех имен. (Второе правило следует из первого, потому что заголовки никогда не могут знать, какие другие заголовки #include могут появиться после них.)</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="b28c908712aa3b3c4f2721161a98d4f73d39f13a" translate="yes" xml:space="preserve">
          <source>Do not use it globally</source>
          <target state="translated">Не используйте его глобально</target>
        </trans-unit>
        <trans-unit id="b10099eb72109a24775417ddca5bf1c65d8e36bc" translate="yes" xml:space="preserve">
          <source>Everything works fine, and you can call &lt;code&gt;Blah()&lt;/code&gt; from Foo and &lt;code&gt;Quux()&lt;/code&gt; from Bar without problems. But one day you upgrade to a new version of Foo 2.0, which now offers a function called &lt;code&gt;Quux()&lt;/code&gt;. Now you've got a conflict: Both Foo 2.0 and Bar import &lt;code&gt;Quux()&lt;/code&gt; into your global namespace. This is going to take some effort to fix, especially if the function parameters happen to match.</source>
          <target state="translated">Все работает нормально, и вы можете без проблем вызывать &lt;code&gt;Blah()&lt;/code&gt; из Foo и &lt;code&gt;Quux()&lt;/code&gt; из Bar. Но однажды вы обновляетесь до новой версии Foo 2.0, которая теперь предлагает функцию &lt;code&gt;Quux()&lt;/code&gt; . Теперь у вас есть конфликт: и Foo 2.0, и Bar импортируют &lt;code&gt;Quux()&lt;/code&gt; в ваше глобальное пространство имен. Это займет некоторое усилие, чтобы исправить, особенно если параметры функции совпадают.</target>
        </trans-unit>
        <trans-unit id="7fdc8f5263841efbcae18f9750a704ca266369d1" translate="yes" xml:space="preserve">
          <source>Experienced programmers also try to avoid full qualification of names inside their source files. A minor reason for this is that it's not elegant to write more code when less code is sufficient &lt;em&gt;unless there are good reasons&lt;/em&gt;. A major reason for this is turning off argument-dependent lookup (ADL).</source>
          <target state="translated">Опытные программисты также стараются избегать полной квалификации имен внутри своих исходных файлов. Небольшая причина этого заключается в том, что не элегантно писать больше кода, когда недостаточно кода, &lt;em&gt;если нет веских причин&lt;/em&gt; . Основной причиной этого является отключение аргумент-зависимого поиска (ADL).</target>
        </trans-unit>
        <trans-unit id="40fc3dd2e604ebb2070a1b8a0000705b0f996fcf" translate="yes" xml:space="preserve">
          <source>Experienced programmers use whatever solves their problems and avoid whatever creates new problems, and they avoid header-file-level using-directives for this exact reason.</source>
          <target state="translated">Опытные программисты используют то,что решает их проблемы и избегают того,что создает новые проблемы,и именно по этой причине они избегают использования директив на уровне заголовков.</target>
        </trans-unit>
        <trans-unit id="a7f84ccc694c5225483eb04c03fd8a8b7d981149" translate="yes" xml:space="preserve">
          <source>For example, if I type in, &lt;code&gt;using namespace std;&lt;/code&gt; and &lt;code&gt;using namespace otherlib;&lt;/code&gt; and type just &lt;code&gt;cout&lt;/code&gt; (which happens to be in both), rather than &lt;code&gt;std::cout&lt;/code&gt; (or &lt;code&gt;'otherlib::cout'&lt;/code&gt;), you might use the wrong one, and get errors. It's much more effective and efficient to use &lt;code&gt;std::cout&lt;/code&gt;.</source>
          <target state="translated">Например, если я наберу, &lt;code&gt;using namespace std;&lt;/code&gt; и &lt;code&gt;using namespace otherlib;&lt;/code&gt; и введите просто &lt;code&gt;cout&lt;/code&gt; (что происходит в обоих), а не &lt;code&gt;std::cout&lt;/code&gt; (или &lt;code&gt;'otherlib::cout'&lt;/code&gt; ), вы можете использовать неправильный и получать ошибки. Гораздо эффективнее и эффективнее использовать &lt;code&gt;std::cout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f92e531886e10c1956f1cd4ead46fd24e7ec5ba4" translate="yes" xml:space="preserve">
          <source>From my experiences, if you have multiple libraries that uses say, &lt;code&gt;cout&lt;/code&gt;, but for a different purpose you may use the wrong &lt;code&gt;cout&lt;/code&gt;.</source>
          <target state="translated">Из моего опыта, если у вас есть несколько библиотек, которые используют скажем, &lt;code&gt;cout&lt;/code&gt; , но для другой цели вы можете использовать неправильный &lt;code&gt;cout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc4a2e1c6384a6c0bca9221545adb77b689f41f1" translate="yes" xml:space="preserve">
          <source>Function-level using-directives and using-declarations inside functions' implementations</source>
          <target state="translated">Использования на уровне функций-директивы и описания использования внутри реализации функций</target>
        </trans-unit>
        <trans-unit id="e754f634964b71e89733cd919482e9f7c6dc7fd0" translate="yes" xml:space="preserve">
          <source>Go ahead and use it locally (almost) freely. This, of course, prevents you from repetition of &lt;code&gt;std::&lt;/code&gt; -- and repetition is also bad.</source>
          <target state="translated">Идите вперед и используйте его локально (почти) свободно. Это, конечно, предотвращает повторение &lt;code&gt;std::&lt;/code&gt; - и повторение тоже плохо.</target>
        </trans-unit>
        <trans-unit id="a13b7ac34e7f5b5ed26674ea84e218245208110c" translate="yes" xml:space="preserve">
          <source>Here's one more data point: Many, many years ago, I also used to find it annoying having to prefix everything from the standard library with &lt;code&gt;std::&lt;/code&gt;. Then I worked in a project where it was decided at the start that both &lt;code&gt;using&lt;/code&gt; directives and declarations are banned except for function scopes. Guess what? It took most of us very few weeks to get used to writing the prefix, and after a few more weeks most of us even agreed that it actually made the code &lt;em&gt;more readable&lt;/em&gt;. There's a reason for that: &lt;strong&gt;&lt;em&gt;Whether you like shorter or longer prose is subjective, but the prefixes objectively add clarity to the code.&lt;/em&gt;&lt;/strong&gt; Not only the compiler, but you, too, find it easier to see which identifier is referred to.</source>
          <target state="translated">Вот еще один момент данных: много-много лет назад я также находил, что это раздражает необходимость префиксировать все из стандартной библиотеки с помощью &lt;code&gt;std::&lt;/code&gt; . Затем я работал в проекте, где с самого начала было решено, что &lt;code&gt;using&lt;/code&gt; директив и объявлений запрещено, за исключением областей действия функций. Угадай, что? Большинству из нас потребовалось несколько недель, чтобы привыкнуть к написанию префикса, и спустя еще несколько недель большинство из нас даже согласилось с тем, что это фактически делает код &lt;em&gt;более читабельным&lt;/em&gt; . Для этого есть причина: &lt;strong&gt;&lt;em&gt;нравится ли вам короткая или длинная проза, субъективно, но префиксы объективно добавляют ясности в код.&lt;/em&gt;&lt;/strong&gt; Не только компилятору, но и вам легче понять, на какой идентификатор ссылаются.</target>
        </trans-unit>
        <trans-unit id="14cd4a9b5c57786c9dcc406fd5351f54c74541d7" translate="yes" xml:space="preserve">
          <source>Horses for courses - manage your complexity how you best can and feel able.</source>
          <target state="translated">Лошади для курсов-управляйте своей сложностью так,как вы можете и чувствуете себя наилучшим образом.</target>
        </trans-unit>
        <trans-unit id="b6059ce195c06e6a8d7d2780b75b1844645eec62" translate="yes" xml:space="preserve">
          <source>However, if I often use 'cout' and 'cin', I write: &lt;code&gt;using std::cout; using std::cin;&lt;/code&gt; in the .cpp file (never in the header file as it propagates with &lt;code&gt;#include&lt;/code&gt;). I think that no one sane will ever name a stream &lt;code&gt;cout&lt;/code&gt; or &lt;code&gt;cin&lt;/code&gt;. ;)</source>
          <target state="translated">Однако, если я часто использую 'cout' и 'cin', я пишу: &lt;code&gt;using std::cout; using std::cin;&lt;/code&gt; используя std :: cin; в файле .cpp (никогда в заголовочном файле, так как он распространяется с помощью &lt;code&gt;#include&lt;/code&gt; ). Я думаю, что ни один здравомыслящий человек никогда не &lt;code&gt;cout&lt;/code&gt; ручей или &lt;code&gt;cin&lt;/code&gt; . ;)</target>
        </trans-unit>
        <trans-unit id="2250f701130cc7a3863ada4af431ecaea750adc9" translate="yes" xml:space="preserve">
          <source>However, you may feel free to put a using statement in your (private) *.cpp files.</source>
          <target state="translated">Тем не менее,вы можете поместить заявление об использовании в свои (личные)*.cpp файлы.</target>
        </trans-unit>
        <trans-unit id="b8fafbc70aedce2fc77deabe47f1e309ea3f997a" translate="yes" xml:space="preserve">
          <source>I agree that it should not be used globally, but it's not so evil to use locally, like in a &lt;code&gt;namespace&lt;/code&gt;. Here's an example from &lt;em&gt;&quot;The C++ Programming Language&quot;&lt;/em&gt;:</source>
          <target state="translated">Я согласен с тем, что его не следует использовать глобально, но локально использовать его не так страшно, как в &lt;code&gt;namespace&lt;/code&gt; . Вот пример из &lt;em&gt;&quot;языка программирования C ++&quot;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b957aa59d52d23ef4bc9ed842310ade7ee82aeff" translate="yes" xml:space="preserve">
          <source>I agree with everything &lt;a href=&quot;https://stackoverflow.com/questions/1452721/1452738#1452738&quot;&gt;Greg wrote&lt;/a&gt;, but I'd like to add: &lt;strong&gt;&lt;em&gt;It can even get worse than Greg said!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">Я согласен со всем, что &lt;a href=&quot;https://stackoverflow.com/questions/1452721/1452738#1452738&quot;&gt;написал Грег&lt;/a&gt; , но я хотел бы добавить: &lt;strong&gt;&lt;em&gt;это может быть даже хуже, чем сказал Грег!&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3806b9230c26bc35f5387e9568e05e858aa6bb5a" translate="yes" xml:space="preserve">
          <source>I agree with others &amp;ndash; it is asking for name clashes, ambiguities and then the fact is it is less explicit. While I can see the use of &lt;code&gt;using&lt;/code&gt;, my personal preference is to limit it. I would also strongly consider what some others pointed out:</source>
          <target state="translated">Я согласен с другими - это требует столкновения имен, двусмысленности, а затем факт менее явный. Хотя я могу видеть использование &lt;code&gt;using&lt;/code&gt; , мое личное предпочтение - ограничить его. Я также настоятельно рассмотрел бы то, на что указали некоторые другие:</target>
        </trans-unit>
        <trans-unit id="de2e7022c8f014a2e70b1ef6b6313df62304adae" translate="yes" xml:space="preserve">
          <source>I agree with the others here, but I would like to address the concerns regarding readability - you can avoid all of that by simply using typedefs at the top of your file, function or class declaration.</source>
          <target state="translated">Здесь я согласен с остальными,но я хотел бы остановиться на проблемах,связанных с удобочитаемостью-вы можете избежать всего этого,просто используя typedefs в верхней части вашего файла,функции или объявления класса.</target>
        </trans-unit>
        <trans-unit id="1763537fa947e39d61c79dbb27ae0c8d2955d02f" translate="yes" xml:space="preserve">
          <source>I also consider it a bad practice. Why? Just one day I thought that the function of a namespace is to divide stuff, so I shouldn't spoil it with throwing everything into one global bag.</source>
          <target state="translated">Я также считаю это плохой практикой.Почему? Всего лишь однажды я подумал,что функция пространства имён состоит в том,чтобы делить вещи,поэтому я не должен портить его,бросая всё в одну глобальную сумку.</target>
        </trans-unit>
        <trans-unit id="de6cf10d0eaf9e11a0c6a2571f7cee7c4459b91d" translate="yes" xml:space="preserve">
          <source>I do not think it is necessarily bad practice under all conditions, but you need to be careful when you use it.  If you're writing a library, you probably should use the scope resolution operators with the namespace to keep your library from butting heads with other libraries.  For application level code, I don't see anything wrong with it.</source>
          <target state="translated">Я не думаю,что это обязательно плохая практика при любых условиях,но вы должны быть осторожны,когда вы используете его.Если вы пишете библиотеку,то вам,вероятно,следует использовать операторы разрешения границ с пространством имён,чтобы не дать вашей библиотеке зазоры с другими библиотеками.Для кода уровня приложений я не вижу в нем ничего плохого.</target>
        </trans-unit>
        <trans-unit id="d5080a2a4a2beb8872491aa265a231ea1ed16674" translate="yes" xml:space="preserve">
          <source>I mean really... saying &quot;don't rely on this being present&quot; is just setting you up to rely on it NOT being present.  You are constantly going to have issues borrowing code snippets and constantly repairing them.  Just keep your user-defined and borrowed stuff in limited scope as they should be and be VERY sparing with globals (honestly globals should almost always be a last resort for purposes of &quot;compile now, sanity later&quot;). Truly I think it is bad advice from your teacher because using std will work for both &quot;cout&quot; and &quot;std::cout&quot; but NOT using std will only work for &quot;std::cout&quot;.  You will not always be fortunate enough to write all your own code.</source>
          <target state="translated">Я имею в виду,на самом деле...сказать &quot;не полагайся на это присутствие&quot;-это просто настроить тебя на то,что ты полагаешься на то,что это НЕ присутствие.У вас постоянно будут проблемы с заимствованием фрагментов кода и их постоянным исправлением.Просто держите свои пользовательские и заимствованные вещи в ограниченном объеме,как и должно быть,и ОЧЕНЬ берегите их от шаров (честно говоря,шаровидные вещи почти всегда должны быть последним средством для целей &quot;компиляции сейчас,вменяемости позже&quot;).Правда,я думаю,что это плохой совет от вашего учителя,потому что использование std будет работать и для &quot;cout&quot;,и для &quot;std::cout&quot;,но НЕ использование std будет работать только для &quot;std::cout&quot;.Вам не всегда повезет,если вы напишете свой собственный код.</target>
        </trans-unit>
        <trans-unit id="f75a67cd99e9c9fbf6abd8a8f84e205de1d5a8c2" translate="yes" xml:space="preserve">
          <source>I put it the other way around: Why is typing five extra characters considered cumbersome by some?</source>
          <target state="translated">Я поставил наоборот:Почему некоторые печатают пять лишних символов,считая их громоздкими?</target>
        </trans-unit>
        <trans-unit id="315d92e4893f10fb88044d2ccdcfc00fb3e343d7" translate="yes" xml:space="preserve">
          <source>I recently ran into a complaint about &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2010&lt;/a&gt;. It turned out that pretty much all the source files had these two lines:</source>
          <target state="translated">Недавно я столкнулся с жалобой на &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010&quot;&gt;Visual Studio 2010&lt;/a&gt; . Оказалось, что почти все исходные файлы имеют следующие две строки:</target>
        </trans-unit>
        <trans-unit id="8441eb391ffa1ac35a213cb285d116689923e4e3" translate="yes" xml:space="preserve">
          <source>I usually use it in my class declaration as methods in a class tend to deal with similar data types (the members) and a typedef is an opportunity to assign a name that is meaningful in the context of the class. This actually aids readability in the definitions of the class methods.</source>
          <target state="translated">Обычно я использую его в объявлении класса,так как методы в классе имеют тенденцию работать с похожими типами данных (членами),а typedef-это возможность присвоить имя,которое имеет смысл в контексте класса.Это на самом деле облегчает чтение определений методов класса.</target>
        </trans-unit>
        <trans-unit id="ae395c81a97e21bacfb9359546bf7289ddc3c88b" translate="yes" xml:space="preserve">
          <source>I won't argue on whether that is a bad idea or not. I will however argue that it keeps it clean for &lt;em&gt;my&lt;/em&gt; project and at the same time makes it specific: True, I have to use Boost, &lt;em&gt;but&lt;/em&gt; I'm using it like the libstdc++ will eventually have it. Yes, starting your own project and starting with a standard (...) at the very beginning goes a very long way with helping maintenance, development and everything involved with the project!</source>
          <target state="translated">Я не буду спорить о том, что это плохая идея или нет. Однако я буду утверждать, что он поддерживает его в чистоте для &lt;em&gt;моего&lt;/em&gt; проекта и в то же время делает его конкретным: правда, я должен использовать Boost, &lt;em&gt;но&lt;/em&gt; я использую его так, как в итоге у libstdc ++. Да, начинать собственный проект и начинать со стандартного (...) в самом начале очень долгий путь, помогая сопровождению, развитию и всему, что связано с проектом!</target>
        </trans-unit>
        <trans-unit id="19e234fd1ffb5551c9bacc76444a0745a8b46a07" translate="yes" xml:space="preserve">
          <source>I've been told by others that writing &lt;code&gt;using namespace std;&lt;/code&gt; in code is wrong, and that I should use &lt;code&gt;std::cout&lt;/code&gt; and &lt;code&gt;std::cin&lt;/code&gt; directly instead.</source>
          <target state="translated">Другие говорили мне, что написание &lt;code&gt;using namespace std;&lt;/code&gt; в коде неправильно, и что я должен использовать &lt;code&gt;std::cout&lt;/code&gt; и &lt;code&gt;std::cin&lt;/code&gt; напрямую вместо этого.</target>
        </trans-unit>
        <trans-unit id="091066152480cd6d7ec51ddc1f6d09610b9d55a1" translate="yes" xml:space="preserve">
          <source>If I see &lt;code&gt;cout &amp;lt;&amp;lt; blah&lt;/code&gt;, instead of &lt;code&gt;std::cout &amp;lt;&amp;lt; blah&lt;/code&gt; I think: What is this &lt;code&gt;cout&lt;/code&gt;? Is it the normal &lt;code&gt;cout&lt;/code&gt;? Is it something special?</source>
          <target state="translated">Если я вижу &lt;code&gt;cout &amp;lt;&amp;lt; blah&lt;/code&gt; , вместо &lt;code&gt;std::cout &amp;lt;&amp;lt; blah&lt;/code&gt; я думаю: что это за &lt;code&gt;cout&lt;/code&gt; ? Это нормальный &lt;code&gt;cout&lt;/code&gt; ? Это что-то особенное?</target>
        </trans-unit>
        <trans-unit id="5a9372cdbb50764ea955811dd61572f65ed573bd" translate="yes" xml:space="preserve">
          <source>If all the standard stuff is in its own namespace you don't have to worry about name collisions with your code or other libraries.</source>
          <target state="translated">Если все стандартные вещи находятся в собственном пространстве имен,вам не нужно беспокоиться о коллизиях имен с вашим кодом или другими библиотеками.</target>
        </trans-unit>
        <trans-unit id="05bbbb5c87545d8ed21bba66dec5dbe3cf4e541d" translate="yes" xml:space="preserve">
          <source>If you consider this unlikely: There was &lt;a href=&quot;https://stackoverflow.com/a/2712125/140719&quot;&gt;a question asked&lt;/a&gt; here on Stack Overflow where pretty much exactly this happened (wrong function called due to omitted &lt;code&gt;std::&lt;/code&gt; prefix) about half a year after I gave this answer. &lt;a href=&quot;https://stackoverflow.com/questions/13402789/&quot;&gt;Here&lt;/a&gt; is another, more recent example of such a question.
So this is a real problem.</source>
          <target state="translated">Если вы считаете это маловероятным: здесь был &lt;a href=&quot;https://stackoverflow.com/a/2712125/140719&quot;&gt;задан вопрос&lt;/a&gt; о переполнении стека, где в значительной степени именно это и произошло (неправильная функция вызвана из-за пропущенного префикса &lt;code&gt;std::&lt;/code&gt; :) примерно через полгода после того, как я дал этот ответ. &lt;a href=&quot;https://stackoverflow.com/questions/13402789/&quot;&gt;Вот&lt;/a&gt; еще один, более свежий пример такого вопроса. Так что это настоящая проблема.</target>
        </trans-unit>
        <trans-unit id="883b59bb138a2b98dd2f53050ba718757c60f448" translate="yes" xml:space="preserve">
          <source>If you do &lt;em&gt;not&lt;/em&gt; have that overload the compiler will use &lt;code&gt;void std::swap(Child&amp;amp;,Child&amp;amp;)&lt;/code&gt; and try its best swapping these.</source>
          <target state="translated">Если у вас нет такой перегрузки, компилятор будет использовать &lt;code&gt;void std::swap(Child&amp;amp;,Child&amp;amp;)&lt;/code&gt; и попытаться заменить их.</target>
        </trans-unit>
        <trans-unit id="81009c04e328b3a3b5aadc7fe747aad2c2287d54" translate="yes" xml:space="preserve">
          <source>If you had used &lt;code&gt;foo::Blah()&lt;/code&gt; and &lt;code&gt;bar::Quux()&lt;/code&gt;, then the introduction of &lt;code&gt;foo::Quux()&lt;/code&gt; would have been a non-event.</source>
          <target state="translated">Если бы вы использовали &lt;code&gt;foo::Blah()&lt;/code&gt; и &lt;code&gt;bar::Quux()&lt;/code&gt; , то введение &lt;code&gt;foo::Quux()&lt;/code&gt; не было бы событием.</target>
        </trans-unit>
        <trans-unit id="d31c157553e55cd020a04b1f31d6a0bd553ab83f" translate="yes" xml:space="preserve">
          <source>If you have an overload &lt;code&gt;void swap(Child&amp;amp;, Child&amp;amp;)&lt;/code&gt; implemented the compiler will choose it.</source>
          <target state="translated">Если у вас реализована перегрузка &lt;code&gt;void swap(Child&amp;amp;, Child&amp;amp;)&lt;/code&gt; компилятор выберет ее.</target>
        </trans-unit>
        <trans-unit id="6cfd5241c3ace598230b440bf15ea476ef327fab" translate="yes" xml:space="preserve">
          <source>If you import the right header files you suddenly have names like &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/hex&quot;&gt;&lt;code&gt;hex&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/left&quot;&gt;&lt;code&gt;left&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/functional/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; in your global scope. This might be surprising if you are not aware that &lt;code&gt;std::&lt;/code&gt; contains these names. If you also try to use these names locally it can lead to quite some confusion.</source>
          <target state="translated">Если вы импортируете правильные заголовочные файлы, у вас внезапно появятся имена, такие как &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/hex&quot;&gt; &lt;code&gt;hex&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/manip/left&quot;&gt; &lt;code&gt;left&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/functional/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; в вашей глобальной области видимости. Это может быть удивительно, если вы не знаете, что &lt;code&gt;std::&lt;/code&gt; содержит эти имена. Если вы также попытаетесь использовать эти имена локально, это может привести к некоторой путанице.</target>
        </trans-unit>
        <trans-unit id="8d02f14101198ab0a96dc0a62eeaadc30eac403e" translate="yes" xml:space="preserve">
          <source>If you only talk about &lt;code&gt;using namespace std&lt;/code&gt; you might not be aware of all the stuff you grab -- and when you add another &lt;code&gt;#include&lt;/code&gt; or move to a new C++ revision you might get name conflicts you were not aware of.</source>
          <target state="translated">Если вы говорите только об &lt;code&gt;using namespace std&lt;/code&gt; вы можете не знать обо всех вещах, которые вы захватываете - и когда вы добавляете еще один &lt;code&gt;#include&lt;/code&gt; или переходите на новую версию C ++, вы можете получить конфликты имен, о которых вы не знали.</target>
        </trans-unit>
        <trans-unit id="4713f3b8d7aeb939fd9e031cf10de0c3697de5bd" translate="yes" xml:space="preserve">
          <source>If you want to find a function name that might be a fairly common name, but you only want to find it in the &lt;code&gt;std&lt;/code&gt; namespace (or the reverse &amp;ndash; you want to change all calls that are &lt;em&gt;not&lt;/em&gt; in namespace &lt;code&gt;std&lt;/code&gt;, namespace &lt;code&gt;X&lt;/code&gt;, ...), then how do you propose to do this?</source>
          <target state="translated">Если вы хотите найти имя функции, которое может быть довольно распространенным именем, но вы хотите найти его только в пространстве имен &lt;code&gt;std&lt;/code&gt; (или наоборот - вы хотите изменить все вызовы, которые &lt;em&gt;не&lt;/em&gt; находятся в пространстве имен &lt;code&gt;std&lt;/code&gt; , пространстве имен &lt;code&gt;X&lt;/code&gt; , .. .) тогда как вы предлагаете это сделать?</target>
        </trans-unit>
        <trans-unit id="c4a5742abc54fef340d5e42bb52ab3d34501cefb" translate="yes" xml:space="preserve">
          <source>If you're only using &lt;code&gt;cout&lt;/code&gt;, nobody gets confused.  But when you have lots of namespaces flying around and you see this class and you aren't exactly sure what it does, having the namespace explicit acts as a comment of sorts. You can see at first glance, &quot;oh, this is a filesystem operation&quot; or &quot;that's doing network stuff&quot;.</source>
          <target state="translated">Если вы используете только &lt;code&gt;cout&lt;/code&gt; , никто не запутается. Но когда у вас много летающих пространств имен, и вы видите этот класс, и вы не совсем уверены, что он делает, явное использование пространства имен действует как своего рода комментарий. На первый взгляд вы можете видеть: &amp;laquo;О, это операция с файловой системой&amp;raquo; или &amp;laquo;Это делает сетевые вещи&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3a0a2f58e94e59b13e5b57410ca215b154e4dd1a" translate="yes" xml:space="preserve">
          <source>In C++03 there was an idiom -- boilerplate code -- for implementing a &lt;code&gt;swap&lt;/code&gt; function for your classes. It was suggested that you actually use a local &lt;code&gt;using namespace std&lt;/code&gt; -- or at least &lt;code&gt;using std::swap&lt;/code&gt;:</source>
          <target state="translated">В C ++ 03 была идиома - шаблонный код - для реализации функции &lt;code&gt;swap&lt;/code&gt; для ваших классов. Было предложено использовать локальное &lt;code&gt;using namespace std&lt;/code&gt; или, по крайней мере, &lt;code&gt;using std::swap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4efd6ea07a2c12ae34510e9920765f13b7b87856" translate="yes" xml:space="preserve">
          <source>In a decade, that project grew to have several million lines of code. Since these discussions come up again and again, I once was curious how often the (allowed) function-scope &lt;code&gt;using&lt;/code&gt; actually was used in the project. I grep'd the sources for it and only found one or two dozen places where it was used. To me this indicates that, once tried, developers don't find &lt;code&gt;std::&lt;/code&gt; painful enough to employ using directives even once every 100 kLoC even where it was allowed to be used.</source>
          <target state="translated">За десятилетие этот проект вырос до нескольких миллионов строк кода. Поскольку эти обсуждения возникают снова и снова, мне однажды было любопытно, как часто (разрешенная) область &lt;code&gt;using&lt;/code&gt; фактически использовалась в проекте. Я нашел источники для него и нашел только одно или два десятка мест, где он использовался. Для меня это указывает на то, что после попытки разработчики не находят, что &lt;code&gt;std::&lt;/code&gt; painful достаточно использовать директивы, даже один раз каждые 100 кОл, даже там, где это разрешено использовать.</target>
        </trans-unit>
        <trans-unit id="06435acc952b6ddf3ff59e777675ac2714343da8" translate="yes" xml:space="preserve">
          <source>In short: You can and should use namespace using declarations and directives liberally in your implementation files after #include directives and feel good about it. &lt;strong&gt;Despite repeated assertions to the contrary, namespace using declarations and directives are not evil and they do not defeat the purpose of namespaces. Rather, they are what make namespaces usable&lt;/strong&gt;.</source>
          <target state="translated">Вкратце: вы можете и должны использовать пространство имен, свободно используя объявления и директивы в ваших файлах реализации после директив #include, и вам это нравится. &lt;strong&gt;Несмотря на неоднократные утверждения об обратном, пространства имен, использующие декларации и директивы, не являются злом и не наносят ущерба цели пространств имен.&lt;/strong&gt; &lt;strong&gt;Скорее, именно они делают пространства имен пригодными для использования&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ec2299e86922f16c12bb89391ea97d486f2d6389" translate="yes" xml:space="preserve">
          <source>In this example, we resolved potential name clashes and ambiguities arising from their composition.</source>
          <target state="translated">В данном примере мы разрешили потенциальные противоречия между именами и двусмысленности,связанные с их составом.</target>
        </trans-unit>
        <trans-unit id="65c4c1dce2db14606c299117092648f5be7eb3d2" translate="yes" xml:space="preserve">
          <source>It depends on where it is located. If it is a common header, then you are diminishing the value of the namespace by merging it into the global namespace. Keep in mind, this could be a neat way of making module globals.</source>
          <target state="translated">Это зависит от того,где он находится.Если это общий заголовок,то вы уменьшаете значение пространства имен,объединяя его в глобальное пространство имен.Имейте в виду,что это может быть аккуратный способ создания модульных глобусов.</target>
        </trans-unit>
        <trans-unit id="a9149a57a26a9aeee68e53682d200c4529d40a43" translate="yes" xml:space="preserve">
          <source>It doesn't make your software or project performance worse. The inclusion of the namespace at the beginning of your source code isn't bad. The inclusion of the &lt;code&gt;using namespace std&lt;/code&gt; instruction varies according to your needs and the way you are developing the software or project.</source>
          <target state="translated">Это не ухудшит производительность вашего программного обеспечения или проекта. Включение пространства имен в начале вашего исходного кода неплохо. Включение инструкции &lt;code&gt;using namespace std&lt;/code&gt; варьируется в зависимости от ваших потребностей и способа разработки программного обеспечения или проекта.</target>
        </trans-unit>
        <trans-unit id="2594ecb269de1ca1ca972a398f9ac08229b7f4f0" translate="yes" xml:space="preserve">
          <source>It is considered &quot;bad&quot; only when &lt;strong&gt;used globally&lt;/strong&gt;. Because:</source>
          <target state="translated">Считается &amp;laquo;плохим&amp;raquo; только при &lt;strong&gt;глобальном использовании&lt;/strong&gt; . Потому что:</target>
        </trans-unit>
        <trans-unit id="1ebc6c4aab7254b3c847f7a94a880434c0e2f28e" translate="yes" xml:space="preserve">
          <source>It's all about managing complexity. Using the namespace will pull things in that you don't want, and thus possibly make it harder to debug (I say possibly). Using std:: all over the place is harder to read (more text and all that).</source>
          <target state="translated">Все дело в управлении сложностями.Использование пространства имён втянет вещи,которые вам не нужны,и таким образом,возможно,усложнит отладку (я говорю &quot;возможно&quot;).Использование std::везде сложнее читать (больше текста и все такое).</target>
        </trans-unit>
        <trans-unit id="38709085bed04576c2d5d32366c7d466d551f5ee" translate="yes" xml:space="preserve">
          <source>It's nice to see code and know what it does. If I see &lt;code&gt;std::cout&lt;/code&gt; I know that's the &lt;code&gt;cout&lt;/code&gt; stream of the &lt;code&gt;std&lt;/code&gt; library. If I see &lt;code&gt;cout&lt;/code&gt; then I don't know. It &lt;em&gt;could&lt;/em&gt; be the &lt;code&gt;cout&lt;/code&gt; stream of the &lt;code&gt;std&lt;/code&gt; library. Or there could be an &lt;code&gt;int cout = 0;&lt;/code&gt; ten lines higher in the same function. Or a &lt;code&gt;static&lt;/code&gt; variable named &lt;code&gt;cout&lt;/code&gt; in that file. It could be anything.</source>
          <target state="translated">Приятно видеть код и знать, что он делает. Если я вижу &lt;code&gt;std::cout&lt;/code&gt; я знаю, что это поток &lt;code&gt;cout&lt;/code&gt; библиотеки &lt;code&gt;std&lt;/code&gt; . Если я вижу &lt;code&gt;cout&lt;/code&gt; то я не знаю. Это &lt;em&gt;может&lt;/em&gt; быть поток &lt;code&gt;cout&lt;/code&gt; библиотеки &lt;code&gt;std&lt;/code&gt; . Или может быть &lt;code&gt;int cout = 0;&lt;/code&gt; на десять строк выше в той же функции. Или &lt;code&gt;static&lt;/code&gt; переменная с именем &lt;code&gt;cout&lt;/code&gt; в этом файле. Это может быть что угодно.</target>
        </trans-unit>
        <trans-unit id="291d10432ee90ffee7774e1bfd80a03295550276" translate="yes" xml:space="preserve">
          <source>It's not horrible, but you'll save yourself headaches by not using it in header files or the global namespace. It's probably all right to do it in very limited scopes, but I've never had a problem typing the extra five characters to clarify where my functions are coming from.</source>
          <target state="translated">Это не ужасно,но вы избавите себя от головной боли,не используя ее в заголовочных файлах или глобальном пространстве имён.Наверное,это нормально делать в очень ограниченном пространстве,но у меня никогда не возникало проблем с вводом дополнительных пяти символов,чтобы уточнить,откуда берутся мои функции.</target>
        </trans-unit>
        <trans-unit id="9baf97e2ec47fa798dfe06c21b8e750de1bac58f" translate="yes" xml:space="preserve">
          <source>It's one of these things that seem a really good idea if you are a teacher and never had to write and maintain any code for a living. I love seeing code where (1) I know what it does; and, (2) I'm confident that the person writing it knew what it does.</source>
          <target state="translated">Это одна из тех вещей,которые кажутся действительно хорошей идеей,если вы учитель,и вам никогда не приходилось писать и поддерживать какой-нибудь код,чтобы заработать на жизнь.Мне нравится видеть код там,где (1)я знаю,что он делает;и (2)я уверен,что человек,который его пишет,знал,что он делает.</target>
        </trans-unit>
        <trans-unit id="91a8c9eace09304424f54dbcea4ab917ef139db7" translate="yes" xml:space="preserve">
          <source>Just to clarify something: I don't actually think it is a good idea to use a name of a class/whatever in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; deliberately and more specifically in place of. The string is the exception (ignore the first, above, or second here, pun if you must) for me as I didn't like the idea of 'String'.</source>
          <target state="translated">Просто чтобы прояснить кое-что: на самом деле я не думаю, что было бы хорошей идеей использовать имя класса / что-либо в &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; намеренно и более конкретно вместо. Строка является исключением (игнорируйте первое, выше или второе здесь, каламбур, если нужно) для меня, поскольку мне не понравилась идея &amp;laquo;String&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="29daf4a7594ca589153ad134f21264fe11ca3416" translate="yes" xml:space="preserve">
          <source>Just typing std::</source>
          <target state="translated">Просто печатаю Стд::</target>
        </trans-unit>
        <trans-unit id="8507557482216947016f1aeee1629d528f10442b" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;std&lt;/code&gt; namespace has tons of identifiers, many of which are &lt;em&gt;very&lt;/em&gt; common ones (think &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, etc.) which are very likely to appear in other code, too.</source>
          <target state="translated">Имейте в виду, что пространство имен &lt;code&gt;std&lt;/code&gt; имеет множество идентификаторов, многие из которых &lt;em&gt;очень&lt;/em&gt; распространены (например, &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;sort&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; и т. Д.), Которые , скорее всего, появятся и в другом коде.</target>
        </trans-unit>
        <trans-unit id="6a07da18fbe175d65d1d0865aa1dc4b50b7ab47f" translate="yes" xml:space="preserve">
          <source>Library Foo 2.0 could introduce a function, &lt;code&gt;Quux()&lt;/code&gt;, that is an unambiguously better match for some of your calls to &lt;code&gt;Quux()&lt;/code&gt; than the &lt;code&gt;bar::Quux()&lt;/code&gt; your code called for years. Then your &lt;strong&gt;&lt;em&gt;code still compiles&lt;/em&gt;&lt;/strong&gt;, but &lt;strong&gt;&lt;em&gt;it silently calls the wrong function&lt;/em&gt;&lt;/strong&gt; and does god-knows-what. That's about as bad as things can get.</source>
          <target state="translated">Библиотека Foo 2.0 может представить функцию &lt;code&gt;Quux()&lt;/code&gt; , которая однозначно лучше подходит для некоторых ваших вызовов &lt;code&gt;Quux()&lt;/code&gt; чем &lt;code&gt;bar::Quux()&lt;/code&gt; ваш код вызывал годами. Тогда ваш &lt;strong&gt;&lt;em&gt;код все еще компилируется&lt;/em&gt;&lt;/strong&gt; , но &lt;strong&gt;&lt;em&gt;он молча вызывает неправильную функцию&lt;/em&gt;&lt;/strong&gt; и выполняет бог-знает-что. Это настолько плохо, насколько это возможно.</target>
        </trans-unit>
        <trans-unit id="5124022ffb20c699c10a1cc2488c255b2ffc9a00" translate="yes" xml:space="preserve">
          <source>NOTE: Don't focus too much on efficiency issues until you actually learn a little about how compilers work.  With a little experience coding you don't have to learn that much about them before you realize how much they are able to generalize good code into something something simple.  Every bit as simple as if you wrote the whole thing in C.  Good code is only as complex as it needs to be.</source>
          <target state="translated">ПРИМЕЧАНИЕ:Не фокусируйтесь слишком много на вопросах эффективности,пока не узнаете немного о том,как работают компиляторы.Имея небольшой опыт в программировании,тебе не нужно так много о них узнавать,прежде чем ты поймешь,насколько они способны обобщить хороший код во что-то простое.Каждый бит так же прост,как если бы Вы написали все это на Си.Хороший код только настолько сложен,насколько он должен быть.</target>
        </trans-unit>
        <trans-unit id="9ce878b56aa89e0fc6464244ab6312410a2325ee" translate="yes" xml:space="preserve">
          <source>Names explicitly declared there (including names declared by using-declarations like &lt;code&gt;His_lib::String&lt;/code&gt;) take priority over names made accessible in another scope by a using-directive (&lt;code&gt;using namespace Her_lib&lt;/code&gt;).</source>
          <target state="translated">Имена, явно объявленные там (включая имена, объявленные с помощью объявлений &lt;code&gt;His_lib::String&lt;/code&gt; таких как His_lib :: String ), имеют приоритет над именами, доступными в другой области действия с помощью директивы &lt;code&gt;using namespace Her_lib&lt;/code&gt; ( используя пространство имен Her_lib ).</target>
        </trans-unit>
        <trans-unit id="50b2a2e68d91a2fa20faee50e5b1093521bfac70" translate="yes" xml:space="preserve">
          <source>Namespace usings are for your convenience, not for you to inflict on others: Never write a using declaration or a using directive before an #include directive.</source>
          <target state="translated">Использование пространства имён для вашего удобства,а не для того,чтобы навязывать другим:Никогда не записывайте декларацию use или директиву use перед директивой #include.</target>
        </trans-unit>
        <trans-unit id="50b1f6a51d747783cb1dfe6047e35834dd447f4e" translate="yes" xml:space="preserve">
          <source>Namespaces provide a powerful tool for the management of different libraries and of different versions of code. In particular, they offer the programmer alternatives of how explicit to make a reference to a nonlocal name.</source>
          <target state="translated">Пространства имен предоставляют мощный инструмент для управления различными библиотеками и версиями кода.В частности,они предлагают программисту альтернативы того,как явно делать ссылку на нелокальное имя.</target>
        </trans-unit>
        <trans-unit id="ddbccb0a8b6506410340a7f532fe40e471a2e05a" translate="yes" xml:space="preserve">
          <source>Note that this is a simple example. If you have files with 20 includes and other imports, you'll have a ton of dependencies to go through to figure out the problem. The worse thing about it is that you can get unrelated errors in other modules depending on the definitions that conflict.</source>
          <target state="translated">Обратите внимание,что это простой пример.Если у вас есть файлы с 20 включёнными и другими импортами,вам придётся пройти через тонну зависимостей,чтобы разобраться с проблемой.Хуже всего то,что вы можете получить несвязанные ошибки в других модулях в зависимости от конфликтующих определений.</target>
        </trans-unit>
        <trans-unit id="36ea41aee46346ce28dcadcb94012cb303748b76" translate="yes" xml:space="preserve">
          <source>Notice how there is an ambiguity, to which library does cout point to?
  The compiler may detect this and not compile the program. In the worst
  case, the program may still compile but call the wrong function, since
  we never specified to which namespace the identifier belonged.</source>
          <target state="translated">Заметьте,как существует двусмысленность,на которую указывает библиотека? Компилятор может это обнаружить и не компилировать программу.В худшем случае программа все равно может скомпилировать,но вызвать не ту функцию,так как мы никогда не указывали,к какому пространству имён принадлежит идентификатор.</target>
        </trans-unit>
        <trans-unit id="f735b7708587108249bd04f231f9283a15ed3614" translate="yes" xml:space="preserve">
          <source>Now at a later stage of development, we wish to use another version of
  cout that is custom implemented in some library called &amp;ldquo;foo&amp;rdquo; (for
  example)</source>
          <target state="translated">Теперь, на более поздней стадии разработки, мы хотим использовать другую версию cout, которая реализована в некоторой библиотеке под названием &amp;laquo;foo&amp;raquo; (например).</target>
        </trans-unit>
        <trans-unit id="a91a9e9922efdb33f03078a0f38ce71a94f60ab3" translate="yes" xml:space="preserve">
          <source>Now let's say you use &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together in your own program as follows:</source>
          <target state="translated">Теперь предположим, что вы используете &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; вместе в своей собственной программе следующим образом:</target>
        </trans-unit>
        <trans-unit id="ce4819e926b1c69f9e959f1bcce61b24bbf7402f" translate="yes" xml:space="preserve">
          <source>Now take a million line code base, which isn't particularly big, and you're searching for a bug, which means you know there is one line in this one million lines that doesn't do what it is supposed to do. &lt;code&gt;cout &amp;lt;&amp;lt; 1;&lt;/code&gt; could read a &lt;code&gt;static int&lt;/code&gt; named &lt;code&gt;cout&lt;/code&gt;, shift it to the left by one bit, and throw away the result. Looking for a bug, I'd have to check that. Can you see how I really really prefer to see &lt;code&gt;std::cout&lt;/code&gt;?</source>
          <target state="translated">Теперь возьмем базу кода в миллион строк, которая не особенно велика, и вы ищете ошибку, что означает, что вы знаете, что в этом миллионе строк есть одна строка, которая не выполняет то, что должна делать. &lt;code&gt;cout &amp;lt;&amp;lt; 1;&lt;/code&gt; мог прочитать &lt;code&gt;static int&lt;/code&gt; именем &lt;code&gt;cout&lt;/code&gt; , сдвинуть его влево на один бит и выбросить результат. В поисках ошибки, я должен это проверить. Вы видите, как я действительно предпочитаю видеть &lt;code&gt;std::cout&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="399f9e8eb4c399a3656111274a9c1b117d6d1db3" translate="yes" xml:space="preserve">
          <source>One shouldn't use the &lt;code&gt;using&lt;/code&gt; directive at the global scope, especially in headers. However, there are situations where it is appropriate even in a header file:</source>
          <target state="translated">Не следует использовать директиву &lt;code&gt;using&lt;/code&gt; в глобальном масштабе, особенно в заголовках. Однако существуют ситуации, когда это уместно даже в заголовочном файле:</target>
        </trans-unit>
        <trans-unit id="1516c0ad1f8ca81d0226fc547e43c805fde700c0" translate="yes" xml:space="preserve">
          <source>People should stop being so anal about it. Your teacher was right all along. Just use ONE namespace; that is the whole point of using namespaces the first place. You are not supposed to use more than one at the same time. Unless it is your own. So again, redefinition will not happen.</source>
          <target state="translated">Люди должны перестать быть настолько анальными по этому поводу.Твой учитель был прав с самого начала.Просто используйте ОДНОЕ пространство имён;в этом весь смысл использования пространств имён в первую очередь.Вы не должны использовать более одного одновременно.Если только это не твое собственное.Так что,опять же,переопределения не будет.</target>
        </trans-unit>
        <trans-unit id="61ba504ad16f53fef83a89ee5e1bf8d3fd48334a" translate="yes" xml:space="preserve">
          <source>Personally, I actually don't mind the &lt;code&gt;std::&lt;/code&gt; prefix. I like the look more than not having it. I don't know if that is because it is explicit and says to me &quot;this isn't my code... I am using the standard library&quot; or if it is something else, but I think it looks nicer. This might be odd given that I only recently got into C++ (used and still do C and other languages for much longer and C is my favourite language of all time, right above assembly).</source>
          <target state="translated">Лично я на самом деле не против префикса &lt;code&gt;std::&lt;/code&gt; . Мне больше нравится внешний вид, чем отсутствие его. Я не знаю, так ли это, потому что это явно и говорит мне: &amp;laquo;Это не мой код ... Я использую стандартную библиотеку&amp;raquo; или это что-то еще, но я думаю, что это выглядит лучше. Это может быть странно, учитывая, что я только недавно вошел в C ++ (использовал и все еще использую C и другие языки гораздо дольше, и C - мой любимый язык всех времен, прямо над сборкой).</target>
        </trans-unit>
        <trans-unit id="98a84cb2b057f0497de2c666cab0ffec97887f04" translate="yes" xml:space="preserve">
          <source>Readers will have difficulty seeing where a particular identifier comes from, when you use many &lt;code&gt;using namespace xyz&lt;/code&gt;.</source>
          <target state="translated">Читателям будет трудно увидеть, откуда исходит конкретный идентификатор, когда вы используете многие из них, &lt;code&gt;using namespace xyz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9140d5235666001f10df811c2360c257238af8d5" translate="yes" xml:space="preserve">
          <source>Repeating a namespace name can be a distraction for both readers and writers. Consequently, it is possible
to state that names from a particular namespace are available without explicit qualification. For example:</source>
          <target state="translated">Повторение имени пространства имен может быть отвлекающим маневром как для читателей,так и для писателей.Следовательно,можно утверждать,что имена из конкретного пространства имен доступны без явной квалификации.Например:</target>
        </trans-unit>
        <trans-unit id="a38525257f468902dfed8f814582f493c591c970" translate="yes" xml:space="preserve">
          <source>Short version: don't use global &lt;code&gt;using&lt;/code&gt; declarations or directives in header files. Feel free to use them in implementation files. Here's what &lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Herb Sutter&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrei_Alexandrescu&quot;&gt;Andrei Alexandrescu&lt;/a&gt; have to say about this issue in &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321113586&quot;&gt;C++ Coding Standards&lt;/a&gt; (bolding for emphasis is mine):</source>
          <target state="translated">Короткая версия: не используйте глобальные объявления или директивы с использованием заголовочных файлов. Не стесняйтесь использовать их в файлах реализации. Вот что &lt;a href=&quot;https://en.wikipedia.org/wiki/Herb_Sutter&quot;&gt;Херб Саттер&lt;/a&gt; и &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrei_Alexandrescu&quot;&gt;Андрей Александреску&lt;/a&gt; должны сказать об этой проблеме в &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321113586&quot;&gt;стандартах кодирования C ++&lt;/a&gt; (выделение для акцента - мое):</target>
        </trans-unit>
        <trans-unit id="eec2d891bc3edd909e8348b90447e5d43222b3e9" translate="yes" xml:space="preserve">
          <source>So here's how I solved it. Install Boost's regex, and link it in. Then, I do the following so that when libstdc++ has it implemented entirely, I need only remove this block and the code remains the same:</source>
          <target state="translated">Итак,вот как я решил эту проблему.Установите регекс Буста и соедините его.Затем я делаю следующее,чтобы когда libstdc++будет полностью реализован,мне нужно было только удалить этот блок и код остался прежним:</target>
        </trans-unit>
        <trans-unit id="ba958b36fe2684798576e2f9a1a8d021d2835d2a" translate="yes" xml:space="preserve">
          <source>So just consider them functions as reserved names like &quot;int&quot; or &quot;class&quot; and that is it.</source>
          <target state="translated">Поэтому просто считайте их функции зарезервированными именами типа &quot;int&quot; или &quot;class&quot; и все.</target>
        </trans-unit>
        <trans-unit id="eeaf7c2ef34ec4418e50a2e403553b2d83998883" translate="yes" xml:space="preserve">
          <source>So the following are OK:</source>
          <target state="translated">Значит,все в порядке:</target>
        </trans-unit>
        <trans-unit id="f103eac16afc4b9fd2b1e99833b3f809101f91e2" translate="yes" xml:space="preserve">
          <source>So you'll need to do some maintenance to clarify that 'a' meant &lt;code&gt;foo::a&lt;/code&gt;. That's undesirable, but fortunately it is pretty easy (just add &lt;code&gt;foo::&lt;/code&gt; in front of all calls to &lt;code&gt;a&lt;/code&gt; that the compiler marks as ambiguous).</source>
          <target state="translated">Таким образом, вам необходимо выполнить некоторые действия, чтобы уточнить, что &amp;laquo;a&amp;raquo; означает &lt;code&gt;foo::a&lt;/code&gt; . Это нежелательно, но, к счастью, это довольно просто (просто добавьте &lt;code&gt;foo::&lt;/code&gt; перед всеми вызовами, которые компилятор помечает как неоднозначные).</target>
        </trans-unit>
        <trans-unit id="ecb267a2211227e4951289cb2c61d96f30e02f89" translate="yes" xml:space="preserve">
          <source>Some people had said that is a bad practice to include the &lt;code&gt;using namespace std&lt;/code&gt; in your source files because you're invoking from that namespace all the functions and variables. When you would like to define a new function with the same name as another function contained in the &lt;code&gt;namespace std&lt;/code&gt; you would overload the function and it could produce problems due to compile or execute. It will not compile or executing as you expect.</source>
          <target state="translated">Некоторые люди говорили, что плохая практика включать &lt;code&gt;using namespace std&lt;/code&gt; в ваши исходные файлы, потому что вы вызываете из этого пространства имен все функции и переменные. Когда вы хотите определить новую функцию с тем же именем, что и другая функция, содержащаяся в &lt;code&gt;namespace std&lt;/code&gt; вы перегружаете функцию, и это может вызвать проблемы из-за компиляции или выполнения. Он не будет компилироваться или выполняться так, как вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="2983f4020c6309b44686250810ad2fa1b133cdbd" translate="yes" xml:space="preserve">
          <source>Source-file-level using-declarations inside source files</source>
          <target state="translated">Использование-объявления на уровне исходных файлов в исходных файлах</target>
        </trans-unit>
        <trans-unit id="48a09de267300394017fd1240b9ef9afafe06e9a" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;An Overview of the C++ Programming Language&lt;/em&gt;
by Bjarne Stroustrup</source>
          <target state="translated">Источник: &lt;em&gt;Обзор языка программирования C ++&lt;/em&gt; , Бьярн Страуструп</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="8d362630dbd96c9d94d61a5ba26f68429e881414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;namespace std&lt;/code&gt; contains the C++ standard functions and variables. This namespace is useful when you often would use the C++ standard functions.</source>
          <target state="translated">Пространство &lt;code&gt;namespace std&lt;/code&gt; содержит стандартные функции и переменные C ++. Это пространство имен полезно, когда вы часто используете стандартные функции C ++.</target>
        </trans-unit>
        <trans-unit id="a0ecbbc85e8e265d8a3603712049a64cd310766c" translate="yes" xml:space="preserve">
          <source>The FAQ suggests two alternatives:</source>
          <target state="translated">В FAQ предлагаются две альтернативы:</target>
        </trans-unit>
        <trans-unit id="64995ed41ecdd7959fd7a75459bcac3c990a145f" translate="yes" xml:space="preserve">
          <source>The compiler will choose the &lt;code&gt;std::swap&lt;/code&gt; for &lt;code&gt;value_&lt;/code&gt;, i.e. &lt;code&gt;void std::swap(int, int)&lt;/code&gt;.</source>
          <target state="translated">Компилятор выберет &lt;code&gt;std::swap&lt;/code&gt; для &lt;code&gt;value_&lt;/code&gt; , то есть &lt;code&gt;void std::swap(int, int)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7f65e416b24edb3d7d7359d825fd5f48ff2bf1b" translate="yes" xml:space="preserve">
          <source>The problem with putting &lt;code&gt;using namespace&lt;/code&gt; in the header files of your classes is that it forces anyone who wants to use your classes (by including your header files) to also be 'using' (i.e. seeing everything in) those other namespaces.</source>
          <target state="translated">Проблема с &lt;code&gt;using namespace&lt;/code&gt; в файлах заголовков ваших классов заключается в том, что это заставляет любого, кто хочет использовать ваши классы (включая файлы заголовков), также &amp;laquo;использовать&amp;raquo; (то есть видеть все в) эти другие пространства имен.</target>
        </trans-unit>
        <trans-unit id="651d1324e3e3efa0febb293121711a75a4c05298" translate="yes" xml:space="preserve">
          <source>The statement using namespace std is generally considered bad
  practice. The alternative to this statement is to specify the
  namespace to which the identifier belongs using the scope operator(::)
  each time we declare a type.</source>
          <target state="translated">Утверждение с использованием пространства имён std,как правило,считается плохой практикой.Альтернативой этому оператору является указание пространства имён,к которому принадлежит идентификатор,с помощью оператора scope(::)каждый раз,когда мы объявляем тип.</target>
        </trans-unit>
        <trans-unit id="da678d1957a06dc4c79a7d800b78557e33ff5ebf" translate="yes" xml:space="preserve">
          <source>The using-directive exists for legacy C++ code and to ease the transition to namespaces, but you probably shouldn&amp;rsquo;t use it on a regular basis, at least not in your new C++ code.</source>
          <target state="translated">Директива using существует для унаследованного кода C ++ и для облегчения перехода к пространствам имен, но вам, вероятно, не следует использовать его на регулярной основе, по крайней мере, в новом коде C ++.</target>
        </trans-unit>
        <trans-unit id="5b8ee9557da2fd48e95fe83d8c0f287ad5f8df12" translate="yes" xml:space="preserve">
          <source>There is no problem using &quot;using namespace std&quot; in your source file
  when you make heavy use of the namespace and know for sure that
  nothing will collide.</source>
          <target state="translated">Нет проблем с использованием &quot;use namespace std&quot; в вашем исходном файле,когда вы сильно используете пространство имён и знаете наверняка,что ничто не столкнётся.</target>
        </trans-unit>
        <trans-unit id="029764c0ea9e395746931f8952df7326aa09ac18" translate="yes" xml:space="preserve">
          <source>There is one other thing although it is somewhat related to the above and what others point out. While this might be bad practise, I sometimes reserve &lt;code&gt;std::name&lt;/code&gt; for the standard library version and name for program-specific implementation. Yes, indeed this could bite you and bite you hard, but it all comes down to that I started this project from scratch, and I'm the only programmer for it. Example: I overload &lt;code&gt;std::string&lt;/code&gt; and call it &lt;code&gt;string&lt;/code&gt;. I have helpful additions. I did it in part because of my C and Unix (+ Linux) tendency towards lower-case names.</source>
          <target state="translated">Есть еще одна вещь, хотя она в некоторой степени связана с вышеизложенным и тем, на что указывают другие. Хотя это может быть плохой практикой, я иногда резервирую &lt;code&gt;std::name&lt;/code&gt; для стандартной версии библиотеки и name для специфичной для программы реализации. Да, действительно, это может укусить вас и укусить вас сильно, но все сводится к тому, что я начал этот проект с нуля, и я единственный программист для него. Пример: я перегружаю &lt;code&gt;std::string&lt;/code&gt; и называю это &lt;code&gt;string&lt;/code&gt; . У меня есть полезные дополнения. Я сделал это частично из-за моей склонности C и Unix (+ Linux) к строчным именам.</target>
        </trans-unit>
        <trans-unit id="3f0a653213e88a4d78de823350af0cc28a0f0151" translate="yes" xml:space="preserve">
          <source>Therefore, avoiding &lt;code&gt;using namespace X;&lt;/code&gt; is a form of future-proofing, a way of making sure a change to the libraries and/or header files in use is not going to break a program.</source>
          <target state="translated">Следовательно, избегая &lt;code&gt;using namespace X;&lt;/code&gt; это форма будущего, способ убедиться, что изменение используемых библиотек и / или заголовочных файлов не приведет к поломке программы.</target>
        </trans-unit>
        <trans-unit id="f45f9dde8d1c10defc80ef7f165a362cba2c156e" translate="yes" xml:space="preserve">
          <source>This does the following magic:</source>
          <target state="translated">Это делает следующее волшебство:</target>
        </trans-unit>
        <trans-unit id="a4545a366e0aad9d34b8acbf9d14874529a60d6a" translate="yes" xml:space="preserve">
          <source>This is a bad practice, often known as global namespace pollution. Problems may occur when more than one namespace has the same function name with signature, then it will be ambiguous for the compiler to decide which one to call and this all can be avoided when you are specifying the namespace with your function call like &lt;code&gt;std::cout&lt;/code&gt; . Hope this helps. :)</source>
          <target state="translated">Это плохая практика, часто называемая глобальным загрязнением пространства имен. Проблемы могут возникать, когда более чем одно пространство имен имеет одно и то же имя функции с сигнатурой, тогда компилятору будет неоднозначно решать, какой из них вызывать, и всего этого можно избежать, когда вы задаете пространство имен с помощью вызова функции, такого как &lt;code&gt;std::cout&lt;/code&gt; Надеюсь это поможет. :)</target>
        </trans-unit>
        <trans-unit id="99260186b8c3a0ba3c616d9138288919d1f36e7b" translate="yes" xml:space="preserve">
          <source>This is better than explicit qualification (&lt;code&gt;std::sin&lt;/code&gt;, &lt;code&gt;std::cos&lt;/code&gt;...), because it is shorter and has the ability to work with user defined floating point types (via &lt;a href=&quot;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;argument-dependent lookup&lt;/a&gt; (ADL)).</source>
          <target state="translated">Это лучше, чем явная квалификация ( &lt;code&gt;std::sin&lt;/code&gt; , &lt;code&gt;std::cos&lt;/code&gt; ...), потому что она короче и способна работать с определенными пользователем типами с плавающей запятой (с помощью &lt;a href=&quot;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&quot;&gt;зависимого от аргумента поиска&lt;/a&gt; (ADL)).</target>
        </trans-unit>
        <trans-unit id="160a0a5c0f76c23ec35ad5487bfae3b08b2536aa" translate="yes" xml:space="preserve">
          <source>This is not related to performance at all. But consider this: you are using two libraries called Foo and Bar:</source>
          <target state="translated">Это вовсе не связано с производительностью.Но учтите это:вы используете две библиотеки Foo и Bar:</target>
        </trans-unit>
        <trans-unit id="298ec62c38104583ee0298f42b39da2f5449b342" translate="yes" xml:space="preserve">
          <source>To answer your question I look at it this way practically:  a lot of programmers (not all) invoke namespace std.  Therefore one should be in the habit of NOT using things that impinge or use the same names as what is in the namespace std.  That is a great deal granted, but not so much compared to the number of possible coherent words and pseudonyms that can be come up with strictly speaking.</source>
          <target state="translated">Чтобы ответить на ваш вопрос,я смотрю на это практически так:многие программисты (не все)вызывают пространство имён std.Поэтому надо иметь привычку НЕ использовать вещи,которые ущемляют или используют те же имена,что и в пространстве имён std.Это очень много,но не так много по сравнению с количеством возможных связных слов и псевдонимов,которые можно придумать строго говоря.</target>
        </trans-unit>
        <trans-unit id="2782259cabfa8ad3d1fe54d85a7f2baf351f10f1" translate="yes" xml:space="preserve">
          <source>Ultimately this is a trade-off between writability vs. reliability/maintainability. Readability may factor in also, but I could see arguments for that going either way. Normally I would say reliability and maintainability are more important, but in this case you'll constantly pay the writability cost for an fairly rare reliability/maintainability impact. The 'best' trade-off will determine on your project and your priorities.</source>
          <target state="translated">В конечном счете,это компромисс между возможностью списания и надежностью.Читабельность тоже может быть фактором,но я вижу аргументы в пользу этого в любом случае.Обычно я бы сказал,что надежность и ремонтопригодность более важны,но в этом случае вы будете постоянно платить стоимость записи за довольно редкое влияние надежности и ремонтопригодности.Лучший&quot; компромисс определит ваш проект и ваши приоритеты.</target>
        </trans-unit>
        <trans-unit id="6ea4fced5fb87a77ecac7ac3fa6aeea3011782f8" translate="yes" xml:space="preserve">
          <source>Using many namespaces at the same time is obviously a recipe for disaster, but using JUST namespace &lt;code&gt;std&lt;/code&gt; and only namespace &lt;code&gt;std&lt;/code&gt; is not that big of a deal in my opinion because redefinition can only occur by your own code...</source>
          <target state="translated">Использование множества пространств имен в одно и то же время, очевидно, является причиной катастрофы, но использование JUST пространства имен &lt;code&gt;std&lt;/code&gt; и только пространства имен &lt;code&gt;std&lt;/code&gt; , на мой взгляд, не так уж важно, потому что переопределение может происходить только с помощью вашего собственного кода ...</target>
        </trans-unit>
        <trans-unit id="41a6352eaeffb261dfe2d93e2ca63fc49c9ba12a" translate="yes" xml:space="preserve">
          <source>What are these &lt;em&gt;good reasons&lt;/em&gt;? Sometimes programmers explicitly want to turn off ADL, other times they want to disambiguate.</source>
          <target state="translated">Каковы эти &lt;em&gt;веские причины&lt;/em&gt; ? Иногда программисты явно хотят отключить ADL, иногда они хотят устранить неоднозначность.</target>
        </trans-unit>
        <trans-unit id="ab54537830a0232c9f9d54213cf3aa6945c2396b" translate="yes" xml:space="preserve">
          <source>Whatever is true for &lt;em&gt;other&lt;/em&gt; readers of your source code is even more true for the most frequent reader of it: yourself. Come back in a year or two and take a look...</source>
          <target state="translated">То, что верно для &lt;em&gt;других&lt;/em&gt; читателей вашего исходного кода, еще более верно для самого частого читателя: вас самих. Вернитесь через год или два и посмотрите ...</target>
        </trans-unit>
        <trans-unit id="cdb77621d85047abd900bf6e655db16ba77b61bb" translate="yes" xml:space="preserve">
          <source>When you use a namespace you're risking a scenario like this, which is why people are uncomfortable using namespaces. The more things in a namespace, the greater the risk of conflict, so people might be even more uncomfortable using namespace &lt;code&gt;std&lt;/code&gt; (due to the number of things in that namespace) than other namespaces.</source>
          <target state="translated">Когда вы используете пространство имен, вы рискуете подобным сценарием, поэтому людям неудобно использовать пространства имен. Чем больше вещей в пространстве имен, тем больше риск конфликта, поэтому людям может быть еще более неудобно использовать пространство имен &lt;code&gt;std&lt;/code&gt; (из-за количества вещей в этом пространстве имен), чем другие пространства имен.</target>
        </trans-unit>
        <trans-unit id="1654c94350473966024505fd813d40c64664c782" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;using namespace std;&lt;/code&gt; considered a bad practice? Is it inefficient or does it risk declaring ambiguous variables (variables that share the same name as a function in &lt;code&gt;std&lt;/code&gt; namespace)? Does it impact performance?</source>
          <target state="translated">Почему &lt;code&gt;using namespace std;&lt;/code&gt; считается плохой практикой? Это неэффективно или существует риск объявления неоднозначных переменных (переменных, которые имеют то же имя, что и функция в пространстве имен &lt;code&gt;std&lt;/code&gt; )? Влияет ли это на производительность?</target>
        </trans-unit>
        <trans-unit id="b584d12b92d355bff8bb0e1c7230b6bf58ecd519" translate="yes" xml:space="preserve">
          <source>Why is “using namespace std;” considered bad practice</source>
          <target state="translated">Почему &quot;использование пространства имён std&quot; считается плохой практикой.</target>
        </trans-unit>
        <trans-unit id="0e30f8945d319ea0f3eeddb281fd252a6c00818b" translate="yes" xml:space="preserve">
          <source>With C++11 there is no reason to use this pattern any more. The implementation of &lt;code&gt;std::swap&lt;/code&gt; was changed to find a potential overload and choose it.</source>
          <target state="translated">В C ++ 11 больше нет причин использовать этот шаблон. Реализация &lt;code&gt;std::swap&lt;/code&gt; была изменена, чтобы найти потенциальную перегрузку и выбрать ее.</target>
        </trans-unit>
        <trans-unit id="634192ce5da22f1caaa7b9299179cbcca7b577b9" translate="yes" xml:space="preserve">
          <source>With unqualified imported identifiers you need external search tools like &lt;em&gt;grep&lt;/em&gt; to find out where identifiers are declared. This makes reasoning about program correctness harder.</source>
          <target state="translated">С неквалифицированными импортированными идентификаторами вам нужны внешние инструменты поиска, такие как &lt;em&gt;grep,&lt;/em&gt; чтобы узнать, где идентификаторы объявлены. Это усложняет рассуждения о правильности программы.</target>
        </trans-unit>
        <trans-unit id="61b8baeb889064cf813917c7fab3baf262e3a825" translate="yes" xml:space="preserve">
          <source>You clutter the namespace you are programming in.</source>
          <target state="translated">Ты загромождаешь пространство имён,в котором программируешь.</target>
        </trans-unit>
        <trans-unit id="3bf6425e37e04cd0a68c1fc7844787cb56ab92a8" translate="yes" xml:space="preserve">
          <source>You could write a program to do it, but wouldn't it be better to spend time working on your project itself rather than writing a program to maintain your project?</source>
          <target state="translated">Вы могли бы написать программу для этого,но не лучше ли было бы потратить время на работу над самим проектом,вместо того,чтобы писать программу для поддержки своего проекта?</target>
        </trans-unit>
        <trans-unit id="1a066f3f13ff76e054b645560a1597523d36beac" translate="yes" xml:space="preserve">
          <source>You may use it locally</source>
          <target state="translated">Вы можете использовать его локально</target>
        </trans-unit>
        <trans-unit id="1a6d9c972154f7b0a7a3e7bc908971e2acb03018" translate="yes" xml:space="preserve">
          <source>You need to be able to read code written by people who have different style and best practices opinions than you.</source>
          <target state="translated">Вы должны уметь читать код,написанный людьми,которые имеют другой стиль и мнения о лучшей практике,чем вы.</target>
        </trans-unit>
        <trans-unit id="9e5ae30173712188975d44da3afd5fd95f0f943a" translate="yes" xml:space="preserve">
          <source>and in the implementation:</source>
          <target state="translated">и в реализации:</target>
        </trans-unit>
        <trans-unit id="2b71447c7e589fd9da4e2a449318d54f8e55a2f0" translate="yes" xml:space="preserve">
          <source>as opposed to:</source>
          <target state="translated">в отличие от..:</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
