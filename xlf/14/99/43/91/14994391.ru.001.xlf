<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/14994391">
    <body>
      <group id="14994391">
        <trans-unit id="2e892d84a456775f25c00e4f845837dd39c07406" translate="yes" xml:space="preserve">
          <source>--&amp;gt;For any developer coming from jQuery background, my first advice would be to &quot;learn JavaScript as a first class language before jumping onto a rich framework like AngularJS!&quot;
I learned the above fact the hard way.</source>
          <target state="translated">-&amp;gt; Для любого разработчика, начинающего с jQuery, мой первый совет - &amp;laquo;изучить JavaScript как язык первого класса, прежде чем переходить к богатой среде, такой как AngularJS!&amp;raquo; Я узнал вышеупомянутый факт трудным путем.</target>
        </trans-unit>
        <trans-unit id="396fc50aacb3d9fb04c78bba466f7908a2e8385d" translate="yes" xml:space="preserve">
          <source>1. Don't design your page, and then change it with &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; manipulations</source>
          <target state="translated">1. Не оформляйте свою страницу, а затем изменяйте ее с помощью манипуляций с &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3828151a3b203e32a8d4b22c6fdb84d2f290a8bc" translate="yes" xml:space="preserve">
          <source>2. Don't augment jQuery with AngularJS</source>
          <target state="translated">2.Не увеличивайте JQuery с AngularJS.</target>
        </trans-unit>
        <trans-unit id="cbedaed8896e96dbbaa762bfb0a519199fab646b" translate="yes" xml:space="preserve">
          <source>3. Always think in terms of architecture</source>
          <target state="translated">3.Всегда думать с точки зрения архитектуры</target>
        </trans-unit>
        <trans-unit id="9bb57b273b075b57706f730ef766b8139c69ca9e" translate="yes" xml:space="preserve">
          <source>4. Test-driven development - &lt;em&gt;always&lt;/em&gt;</source>
          <target state="translated">4. Разработка через тестирование - &lt;em&gt;всегда&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5df0490b33144a83a19e27b67ca325463559d8dd" translate="yes" xml:space="preserve">
          <source>5. Conceptually, directives are &lt;em&gt;not&lt;/em&gt; packaged jQuery</source>
          <target state="translated">5. Концептуально директивы &lt;em&gt;не&lt;/em&gt; упакованы в jQuery</target>
        </trans-unit>
        <trans-unit id="9d37a0363a38e4535d4fbf679c38b69053d2845a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Dependency injection&lt;/a&gt; (DI) vs. Instatiation - aka de-spaghettification</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Инъекция зависимостей&lt;/a&gt; (DI) в сравнении с инстализацией - она ​​же де-спагеттификация</target>
        </trans-unit>
        <trans-unit id="5b2bf38bee1c00dcbf6a933d82ad04998661ee32" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;Separation of concerns&lt;/a&gt; (SOC) is a pattern that grew up over many years of web development for a variety of reasons including SEO, accessibility and browser incompatibility. It looks like this:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;Разделение интересов&lt;/a&gt; (SOC) - это модель, которая выросла за многие годы веб-разработки по ряду причин, включая SEO, доступность и несовместимость браузера. Это выглядит так:</target>
        </trans-unit>
        <trans-unit id="50b9bf0923a4b128bb297b2cf829a6c75cccc91e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;/ &lt;a href=&quot;http://underscorejs.org&quot;&gt;Underscore&lt;/a&gt; for the &lt;strong&gt;facade pattern&lt;/strong&gt; (like WYSIWYG's for manipulating the DOM)</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com&quot;&gt;JQuery&lt;/a&gt; / &lt;a href=&quot;http://underscorejs.org&quot;&gt;Underscore&lt;/a&gt; для &lt;strong&gt;шаблона фасада&lt;/strong&gt; (как WYSIWYG для управления DOM)</target>
        </trans-unit>
        <trans-unit id="69042625919dd0e27703e71445b2b7bd23b39703" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://knockoutjs.com&quot;&gt;KnockoutJS&lt;/a&gt; for the &lt;strong&gt;observable, publish/subscribe pattern&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;http://knockoutjs.com&quot;&gt;KnockoutJS&lt;/a&gt; для &lt;strong&gt;наблюдаемого шаблона публикации / подписки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d7a0982ee2f9c3c522d1ee89cd375e2cb7609417" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://prototypejs.org&quot;&gt;Prototype.js&lt;/a&gt; for the &lt;strong&gt;prototype/ constructor/ mixin pattern&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;http://prototypejs.org&quot;&gt;Prototype.js&lt;/a&gt; для &lt;strong&gt;шаблона прототип / конструктор / миксин&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92b3217c5ba1cc0f9135ed9705adca8c3f975b4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://requirejs.org&quot;&gt;RequireJS&lt;/a&gt;/ &lt;a href=&quot;https://github.com/cujojs/curl&quot;&gt;Curl.js&lt;/a&gt; for the &lt;strong&gt;module pattern/ AMD&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;http://requirejs.org&quot;&gt;RequireJS&lt;/a&gt; / &lt;a href=&quot;https://github.com/cujojs/curl&quot;&gt;Curl.js&lt;/a&gt; для &lt;strong&gt;шаблона модуля / AMD&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9b870b99d1adcc3ce0b3833fc3f86074e9524de" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.google.be/search?q=js+oop&quot;&gt;JavaScript Object-oriented Programming&lt;/a&gt; (this is a Google search link). It is not a library, but certainly a prerequisite to any application programming. It taught me the native implementations of the &lt;strong&gt;prototype, constructor, singleton &amp;amp; decorator patterns&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.google.be/search?q=js+oop&quot;&gt;JavaScript Объектно-ориентированное программирование&lt;/a&gt; (это поисковая ссылка Google). Это не библиотека, но, безусловно, обязательное условие для любого прикладного программирования. Он научил меня нативным реализациям &lt;strong&gt;прототипа, конструктора, шаблонов синглтона и декоратора&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="abd6dd62d85dac964abb4fc9b6d39f70c1511d55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The AngularJS way is to extend the capabilities of native looking HTML.&lt;/em&gt; You should write HTML that looks like HTML, extended with custom attributes and elements.</source>
          <target state="translated">&lt;em&gt;Способ AngularJS - расширить возможности нативно выглядящего HTML.&lt;/em&gt; Вы должны написать HTML, который выглядит как HTML, расширенный с помощью пользовательских атрибутов и элементов.</target>
        </trans-unit>
        <trans-unit id="42d5cb01532a1eb833bc5dc3442165730fc715f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS and jQuery:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;AngularJS и JQuery:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2cb0e6123d036e1454b06c3e92f6619c31e7b8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS&lt;/strong&gt; is a beautiful client-side framework, highly testable, that combines tons of cool stuff such as MVC, &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, data binding and much more.</source>
          <target state="translated">&lt;strong&gt;AngularJS&lt;/strong&gt; - это красивый клиентский фреймворк, хорошо тестируемый, который сочетает в себе множество интересных вещей, таких как MVC, &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;внедрение зависимостей&lt;/a&gt; , привязка данных и многое другое.</target>
        </trans-unit>
        <trans-unit id="0f7938672e21aa28fcfa2974e178640ad994aae7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controllers are great:&lt;/strong&gt;
Controllers take care of their own HTML, but this separation works well for common functionality well as. If you want to call the same function on the click of a button on master HTML, just write the same function name in each controller and write individual code.</source>
          <target state="translated">&lt;strong&gt;Контроллеры великолепны:&lt;/strong&gt; контроллеры заботятся о своем собственном HTML, но это разделение хорошо работает и для обычной функциональности. Если вы хотите вызывать одну и ту же функцию одним нажатием кнопки в главном HTML, просто напишите одно и то же имя функции на каждом контроллере и напишите отдельный код.</target>
        </trans-unit>
        <trans-unit id="c11e6c999d67e30b4dd08344b653ee2887d7eeb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensibility&lt;/strong&gt;: Angular has extended the HTML directives using angular directives. Write expressions inside html and evaluate them on runtime. Create your own directives and services and use them in another project without any extra effort.</source>
          <target state="translated">&lt;strong&gt;Расширяемость&lt;/strong&gt; : Angular расширил директивы HTML с помощью угловых директив. Напишите выражения внутри html и оцените их во время выполнения. Создайте свои собственные директивы и сервисы и используйте их в другом проекте без каких-либо дополнительных усилий.</target>
        </trans-unit>
        <trans-unit id="0a5df869fa8dc89f42caf2f14c8a4d5438689936" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IGOR&lt;/strong&gt;: So think of directive as the instruction to the compiler that tells it whenever you come across this certain element or this CSS in the template, and you keep this kind of code and that code is in charge of the element and everything below that element in the DOM tree.</source>
          <target state="translated">&lt;strong&gt;ИГОРЬ&lt;/strong&gt; : Так что воспринимайте директиву как инструкцию для компилятора, которая сообщает ее всякий раз, когда вы сталкиваетесь с этим определенным элементом или этим CSS в шаблоне, и вы сохраняете этот вид кода, и этот код отвечает за элемент и все, что находится под этим элементом в дереве DOM.</target>
        </trans-unit>
        <trans-unit id="fb847df57ef2048ada827543b7b83275102b35c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ideal for &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; architecture:&lt;/strong&gt;
Being a complete frameworks makes AngularJS great to work with a RESTful architecture. To call REST CRUD APIs is very easier and</source>
          <target state="translated">&lt;strong&gt;Идеально подходит для архитектуры &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; :&lt;/strong&gt; будучи полным фреймворком, AngularJS отлично &lt;strong&gt;подходит для&lt;/strong&gt; работы с архитектурой RESTful. Вызвать API REST CRUD очень просто и</target>
        </trans-unit>
        <trans-unit id="6db3ad18a3fcffc3e35affc669f632a630d17906" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you have some data and are now trying to update HTML... STOP! update the model, and make sure your HTML is bound to the model.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Если у вас есть данные и вы пытаетесь обновить HTML ... STOP!&lt;/strong&gt; &lt;strong&gt;обновите модель и убедитесь, что ваш HTML привязан к модели.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a19b1a68f851522bd0cf824036f977b0867ca9fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Imperative vs Declarative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Императив против декларативного&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f010845158f0f95b6de7c77468721d2aacc26955" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MISKO&lt;/strong&gt;: [...] one of the things we thought about very hardly in Angular is, how do we provide lots of escape hatches so that you can get out and basically figure out a way out of this. So to us, the answer is this thing called &amp;ldquo;Directives&amp;rdquo;. &lt;strong&gt;And with directives, you essentially become a regular little jQuery JavaScript, you can do whatever you want.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MISKO&lt;/strong&gt; : [...] одна из вещей, о которых мы очень &lt;strong&gt;редко&lt;/strong&gt; думали в Angular, это то, как мы предоставляем много аварийных люков, чтобы вы могли выбраться и найти выход из этого. Поэтому для нас ответом является то, что называется &amp;laquo;Директивы&amp;raquo;. &lt;strong&gt;А с помощью директив вы по сути становитесь обычным маленьким jQuery JavaScript, вы можете делать все, что захотите.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb2c2d380076a74aa03ad025fcf7629b16d2b1de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins extend jQuery. AngularJS Directives extend the capabilities of your browser.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Плагины расширяют jQuery.&lt;/strong&gt; &lt;strong&gt;Директивы AngularJS расширяют возможности вашего браузера.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c47fced225128e4a144ce379fa468a4309c6e8e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins:&lt;/strong&gt;
There are many other similar features like showing an overlay in your app. You don't need to write code for it, just use an overlay plugin available as wc-overlay, and this will automatically take care of all &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; (XHR) requests.</source>
          <target state="translated">&lt;strong&gt;Плагины:&lt;/strong&gt; есть много других похожих функций, таких как отображение наложения в вашем приложении. Вам не нужно писать код для него, просто используйте плагин наложения, доступный как wc-overlay, и он автоматически позаботится обо всех запросах &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; (XHR).</target>
        </trans-unit>
        <trans-unit id="887a0d220804750ef67bb7862fb203a7bd2bcb18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reusable directives are super:&lt;/strong&gt;
Write directives in one place and use it throughout the application. OMG!!! I used these directive for paging, regex, validations, etc. It is really cool!</source>
          <target state="translated">&lt;strong&gt;Директивы многократного использования - это супер:&lt;/strong&gt; пишите директивы в одном месте и используйте их во всем приложении. О, МОЙ БОГ!!! Я использовал эти директивы для подкачки страниц, регулярных выражений, проверок и т. Д. Это действительно круто!</target>
        </trans-unit>
        <trans-unit id="f69a19e5ccd84c1031161d37ece994aed62fe59d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Routing is strong:&lt;/strong&gt;
It's up to your implementation how you want to use it, but it requires very few lines of code to route the request to specify HTML and controller (JavaScript)</source>
          <target state="translated">&lt;strong&gt;Маршрутизация сильна:&lt;/strong&gt; ваша реализация зависит от того, как вы хотите ее использовать, но для маршрутизации запроса на указание HTML и контроллера требуется очень мало строк кода (JavaScript)</target>
        </trans-unit>
        <trans-unit id="797f295648a2a0dbe2273589c1be293d5bfe525f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Services&lt;/strong&gt;: Write common codes using services and less code in controllers. Sevices can be used to share common functionalities among the controllers.</source>
          <target state="translated">&lt;strong&gt;Сервисы&lt;/strong&gt; : пишите общие коды, используя сервисы и меньше кода в контроллерах. Устройства могут использоваться для совместного использования общих функций контроллеров.</target>
        </trans-unit>
        <trans-unit id="138e836a952df3aa65cdcd5ed6d0228190442e07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stop trying to drive your application from your JavaScript. Let the template drive the application, and let AngularJS take care of wiring the components together. This also is the Angular way.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Прекратите пытаться вытеснить ваше приложение из вашего JavaScript.&lt;/strong&gt; &lt;strong&gt;Пусть шаблон управляет приложением, а AngularJS позаботится о соединении компонентов.&lt;/strong&gt; &lt;strong&gt;Это и есть угловой путь.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fdb21836db9637198f74d2b8f19405107dec8dbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This means that Angular is Template Driven&lt;/strong&gt;. Your template drives the JavaScript, not the other way around. This is a radical reversal of roles, and the complete opposite of the unobtrusive JavaScript we have been writing for the last 10 years or so. This can take some getting used to.</source>
          <target state="translated">&lt;strong&gt;Это означает, что Angular управляется на основе шаблонов&lt;/strong&gt; . Ваш шаблон управляет JavaScript, а не наоборот. Это радикальное изменение ролей и полная противоположность ненавязчивому JavaScript, который мы пишем последние 10 лет или около того. Это может занять некоторое привыкание.</target>
        </trans-unit>
        <trans-unit id="20ab0f6802a5394aa105383981477201dead0b2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two-way data binding is amazing:&lt;/strong&gt; 
I had a grid with all functionality UPDATE, DELTE, INSERT. I have a data object that binds the grid's model using ng-repeat. You only need to write a single line of simple JavaScript code for delete and insert and that's it. grid automatically updates as the grid model changes instantly. Update functionality is real time, no code for it.
You feel amazing!!!</source>
          <target state="translated">&lt;strong&gt;Двухстороннее связывание данных удивительно: у&lt;/strong&gt; меня была сетка со всеми функциями UPDATE, DELTE, INSERT. У меня есть объект данных, который связывает модель сетки с помощью ng-repeat. Вам нужно всего лишь написать одну строку простого кода JavaScript для удаления и вставки, и все. Сетка автоматически обновляется при мгновенном изменении модели сетки. Обновление функционирует в режиме реального времени, для него нет кода. Вы чувствуете себя потрясающе !!!</target>
        </trans-unit>
        <trans-unit id="36ae55072d91b6ded3403dc2b4cad372aaa77444" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your HTML source is no longer semantic, instead, your API and compiled DOM are semantic.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ваш HTML-источник больше не является семантическим, вместо этого ваш API и скомпилированный DOM являются семантическими.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0ed9f7320d225087a2cabdd3049cfd766fead2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery&lt;/strong&gt; is a library</source>
          <target state="translated">&lt;strong&gt;JQuery&lt;/strong&gt; это библиотека</target>
        </trans-unit>
        <trans-unit id="6c335564959dc2af53604b8909e474e66420b796" translate="yes" xml:space="preserve">
          <source>A nice thing about AngularJs is that it allows you to separate/isolate the DOM manipulation in the directives.  There are built-in directives ready for you to use such as ng-click. You can create your own custom directives that will contain all your view logic or DOM manipulation so you don't end up mingle DOM manipulation code in the controllers or services that should take care of the business logic.</source>
          <target state="translated">Приятной особенностью AngularJs является то,что она позволяет отделить DOM манипуляцию в директивах.Есть встроенные директивы,которые вы можете использовать,такие как ng-клик.Вы можете создать свои собственные пользовательские директивы,которые будут содержать всю вашу логику просмотра или манипуляции с DOM,чтобы вы не в конечном итоге смешивали код манипуляции с DOM в контроллерах или службах,которые должны заботиться о бизнес-логике.</target>
        </trans-unit>
        <trans-unit id="7ceb5d7ed6945141f56ba005625ff024d9d7eb17" translate="yes" xml:space="preserve">
          <source>A transcript of the entire episode is available at the link provided above.</source>
          <target state="translated">Транскрипт всего эпизода доступен по ссылке,приведенной выше.</target>
        </trans-unit>
        <trans-unit id="b8f9a78d78001336ae3c83f2d488f8880d463909" translate="yes" xml:space="preserve">
          <source>Actually, if you're using AngularJS, you don't need jQuery anymore. AngularJS itself has the binding and directive, which is a very good &quot;replacement&quot; for most things you can do with jQuery.</source>
          <target state="translated">Вообще-то,если ты используешь AngularJS,тебе больше не нужен jQuery.Сама по себе AngularJS имеет привязку и директиву,которая является очень хорошей &quot;заменой&quot; для большинства вещей,которые вы можете делать с jQuery.</target>
        </trans-unit>
        <trans-unit id="a982e94ed93b338e6087c54069f224404ee9152d" translate="yes" xml:space="preserve">
          <source>Again, AngularJS does not play by their rules. In a stroke, &lt;strong&gt;AngularJS does away with a decade of received wisdom&lt;/strong&gt; and instead implements an MVC pattern in which the template is no longer semantic, not even a little bit.</source>
          <target state="translated">Опять же AngularJS не играет по своим правилам. &lt;strong&gt;Одним словом&lt;/strong&gt; , &lt;strong&gt;AngularJS избавляется от десятилетия полученной мудрости&lt;/strong&gt; и вместо этого реализует шаблон MVC, в котором шаблон больше не является семантическим, даже немного.</target>
        </trans-unit>
        <trans-unit id="dd4ee4af98c6fe65fb4b3c2b533d9c832398158d" translate="yes" xml:space="preserve">
          <source>Again, the template stuff is in the template, so you (or your users) can easily swap it out for one that meets any style necessary, and the &lt;strong&gt;logic&lt;/strong&gt; never had to be touched. Reusability - boom!</source>
          <target state="translated">Опять же, содержимое шаблона находится в шаблоне, так что вы (или ваши пользователи) можете легко поменять его на тот, который соответствует любому необходимому стилю, и &lt;strong&gt;логику&lt;/strong&gt; никогда не приходилось трогать. Повторное использование - бум!</target>
        </trans-unit>
        <trans-unit id="1480b134e7c98fe4782ceaa71c1becda85bf1d42" translate="yes" xml:space="preserve">
          <source>Ajax all of the time</source>
          <target state="translated">Аякс все время</target>
        </trans-unit>
        <trans-unit id="7088908d0701fd67fecee7fd934804b9635f1eac" translate="yes" xml:space="preserve">
          <source>And I decided to make a tiny code snippet that help me quickly start a website using AngularJS with the power of jQuery Selector (using Sizzle).</source>
          <target state="translated">И я решил сделать крошечный фрагмент кода,который поможет мне быстро запустить сайт с помощью AngularJS с помощью jQuery Selector (используя Sizzle).</target>
        </trans-unit>
        <trans-unit id="b3c9932d142f6e1ee02747f1578184f1f2f6fc13" translate="yes" xml:space="preserve">
          <source>And all of the above tie into this over-arching theme: keep your concerns separate. Your view acts as the official record of what is supposed to happen (for the most part); your model represents your data; you have a service layer to perform reusable tasks; you do DOM manipulation and augment your view with directives; and you glue it all together with controllers. This was also mentioned in other answers, and the only thing I would add pertains to testability, which I discuss in another section below.</source>
          <target state="translated">И все вышесказанное связано с этой всеобъемлющей темой:держите свои проблемы отдельно.Ваше представление действует как официальная запись того,что должно произойти (по большей части);ваша модель представляет ваши данные;у вас есть сервисный уровень для выполнения многоразовых задач;вы выполняете манипуляции с DOM и дополняете ваше представление директивами;и вы склеиваете все это вместе с контроллерами.Об этом также упоминалось в других ответах,и единственное,что я бы добавил,относится к тестируемости,о которой я расскажу в другом разделе ниже.</target>
        </trans-unit>
        <trans-unit id="717ce7322f7d359fabb874116d82f9a23af3a1cf" translate="yes" xml:space="preserve">
          <source>And fifth, which we've mentioned in previous sections, why are we mixing template stuff into our logic?</source>
          <target state="translated">И в-пятых,о чем мы упоминали в предыдущих разделах,почему мы смешиваем шаблонные вещи с нашей логикой?</target>
        </trans-unit>
        <trans-unit id="31b7375227eaf487f50dd9c4d2a4be13432b0992" translate="yes" xml:space="preserve">
          <source>And now instead of using an unordered list, we're using Bootstrap alert boxes. And we never had to change the controller code! But more importantly, no matter &lt;em&gt;where&lt;/em&gt; or &lt;em&gt;how&lt;/em&gt; the log gets updated, the view will change too. Automatically. Neat!</source>
          <target state="translated">И теперь вместо неупорядоченного списка мы используем окна предупреждений Bootstrap. И нам никогда не приходилось менять код контроллера! Но что более важно, независимо от того, &lt;em&gt;где&lt;/em&gt; и &lt;em&gt;как&lt;/em&gt; журнал обновляется, представление также изменится. Автоматически. Ухоженная!</target>
        </trans-unit>
        <trans-unit id="ded1b56b02466779ad820433f366b36a1ad7629b" translate="yes" xml:space="preserve">
          <source>And our view can look like this:</source>
          <target state="translated">И наш взгляд может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="e0dec1075f573c8803a10203b7685e0ba502d0e0" translate="yes" xml:space="preserve">
          <source>And there are still all those other benefits, like testing - it's easy! No matter what's in the template, the directive's internal API is never touched, so refactoring is easy. You can change the template as much as you want without touching the directive. And no matter what you change, your tests still pass.</source>
          <target state="translated">И еще есть все те преимущества,например,тестирование-это легко! Что бы ни было в шаблоне,внутренний API директивы никогда не трогается,поэтому рефакторинг прост.Вы можете менять шаблон сколько угодно,не касаясь директивы.И что бы вы ни изменили,ваши тесты все равно пройдут.</target>
        </trans-unit>
        <trans-unit id="5bee056b415ffd9808306a38b2d56440081c0e20" translate="yes" xml:space="preserve">
          <source>And when we run our test, we can confirm that it fails. Only now should we create our directive:</source>
          <target state="translated">И когда мы проведем тест,мы сможем подтвердить,что он провалился.Только сейчас мы должны создать нашу директиву:</target>
        </trans-unit>
        <trans-unit id="180abb5e88521e466bf2e4475cd2b687c06483d9" translate="yes" xml:space="preserve">
          <source>And with DOM manipulation in AngularJS, you find yourself adding directives and filters, which you can think of as valid HTML extensions.</source>
          <target state="translated">А с помощью манипуляций с DOM в AngularJS вы получаете возможность добавлять директивы и фильтры,которые можно считать действительными расширениями HTML.</target>
        </trans-unit>
        <trans-unit id="24580187a4254fa76812f2d649f1e29d6069e0b9" translate="yes" xml:space="preserve">
          <source>Angular and jQuery do different things. AngularJS gives you a set of tools to produce web applications. jQuery mainly gives you tools for modifying the DOM. If jQuery is present on your page, AngularJS will use it automatically. If it isn't, AngularJS ships with jQuery Lite, which is a cut down, but still perfectly usable version of jQuery.</source>
          <target state="translated">Угловые и jQuery делают разные вещи.AngularJS дает вам набор инструментов для создания веб-приложений.jQuery в основном дает вам инструменты для модификации DOM.Если jQuery присутствует на вашей странице,AngularJS будет использовать его автоматически.Если нет,то AngularJS поставляется с jQuery Lite,которая является урезанной,но все же прекрасно используемой версией jQuery.</target>
        </trans-unit>
        <trans-unit id="743831e45593d1d3b1984a6b44f8c8b5aff24099" translate="yes" xml:space="preserve">
          <source>Angular breaks down your app into 
- Controllers
- Services
- Views
- etc.</source>
          <target state="translated">Угловой разбивает ваше приложение на-Контроллеры-Службы-Виды-и т.д.</target>
        </trans-unit>
        <trans-unit id="2a3de4a9dc7c9f3bd23b0b53226033777b1c013b" translate="yes" xml:space="preserve">
          <source>AngularJS</source>
          <target state="translated">AngularJS</target>
        </trans-unit>
        <trans-unit id="f39ebda33fdd6cea30fb3e03a8a2d79fcda3487a" translate="yes" xml:space="preserve">
          <source>AngularJS allows you to make your own HTML tags/attributes that do things which work well with dynamic web applications (since HTML was designed for static pages).</source>
          <target state="translated">AngularJS позволяет создавать собственные HTML-теги-аттрибуты,которые хорошо работают с динамическими веб-приложениями (поскольку HTML был разработан для статических страниц).</target>
        </trans-unit>
        <trans-unit id="83ef7970ea8e67c4542f275b5fdabad15e691725" translate="yes" xml:space="preserve">
          <source>AngularJS and jQuery adopt very different ideologies. If you're coming from jQuery you may find some of the differences surprising. Angular may make you angry.</source>
          <target state="translated">AngularJS и jQuery принимают очень разные идеологии.Если вы пришли из jQuery,некоторые различия могут показаться вам удивительными.Угловой может вас разозлить.</target>
        </trans-unit>
        <trans-unit id="fc13641dffc4ac29f5a7e6fba2f371197f917be0" translate="yes" xml:space="preserve">
          <source>AngularJS and jQuery are not enemies. It's possible to use jQuery within AngularJS very nicely. If you're using AngularJS well (templates, data-binding, $scope, directives, etc.) you will find you need a &lt;strong&gt;lot&lt;/strong&gt; less jQuery than you might otherwise require.</source>
          <target state="translated">AngularJS и jQuery не являются врагами. В AngularJS можно очень хорошо использовать jQuery. Если вы хорошо используете AngularJS (шаблоны, привязка данных, $ scope, директивы и т. Д.), Вы обнаружите, что вам нужно &lt;strong&gt;намного&lt;/strong&gt; меньше jQuery, чем в противном случае.</target>
        </trans-unit>
        <trans-unit id="222ef2db3e23de37ca20387e96e35891b58e48cd" translate="yes" xml:space="preserve">
          <source>AngularJS changes the way you &lt;em&gt;find&lt;/em&gt; elements</source>
          <target state="translated">AngularJS меняет способ &lt;em&gt;поиска&lt;/em&gt; элементов</target>
        </trans-unit>
        <trans-unit id="e1c2157022eaa4f2a0716583841f5203e08b070a" translate="yes" xml:space="preserve">
          <source>AngularJS comes with an entire set of tools to make this very easy; with &lt;code&gt;ngClass&lt;/code&gt; we can dynamically update the class; &lt;code&gt;ngModel&lt;/code&gt; allows two-way data binding; &lt;code&gt;ngShow&lt;/code&gt; and &lt;code&gt;ngHide&lt;/code&gt; programmatically show or hide an element; and many more - including the ones we write ourselves. In other words, we can do all kinds of awesomeness &lt;em&gt;without&lt;/em&gt; DOM manipulation. The less DOM manipulation, the easier directives are to test, the easier they are to style, the easier they are to change in the future, and the more re-usable and distributable they are.</source>
          <target state="translated">AngularJS поставляется с полным набором инструментов, чтобы сделать это очень легко; с помощью &lt;code&gt;ngClass&lt;/code&gt; мы можем динамически обновлять класс; &lt;code&gt;ngModel&lt;/code&gt; позволяет двустороннее связывание данных; &lt;code&gt;ngShow&lt;/code&gt; и &lt;code&gt;ngHide&lt;/code&gt; программно показывают или скрывают элемент; и многое другое, включая те, которые мы пишем сами. Другими словами, мы можем делать все виды удивительных вещей &lt;em&gt;без&lt;/em&gt; манипуляций с DOM. Чем меньше манипуляций с DOM, тем легче директивы тестировать, чем легче их стилизовать, тем легче их менять в будущем, и тем более они пригодны для повторного использования и распространения.</target>
        </trans-unit>
        <trans-unit id="8a1f9a965073fef341c41540c540b536642219de" translate="yes" xml:space="preserve">
          <source>AngularJS doesn't need (or want) you to find elements using selectors - the primary difference between AngularJS's &lt;strong&gt;jqLite&lt;/strong&gt; versus full-blown &lt;strong&gt;jQuery&lt;/strong&gt; is that &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.element&quot;&gt;jqLite does not support selectors&lt;/a&gt;.</source>
          <target state="translated">AngularJS не нуждается (или не хочет), чтобы вы находили элементы с помощью селекторов - главное отличие &lt;strong&gt;jQLite&lt;/strong&gt; от AngularJS от полноценного &lt;strong&gt;jQuery&lt;/strong&gt; заключается в том, что &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.element&quot;&gt;jqLite не поддерживает селекторы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d472a45e93868af2bd80d2ee2bab7981ad1a855e" translate="yes" xml:space="preserve">
          <source>AngularJS extends HTML, so you don't have to put &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; all over the place just to make an application. It makes HTML actually work for applications rather than what it was designed for, which is static, educational web pages. It accomplishes this in a roundabout way using JavaScript, but fundamentally it is an extension of HTML, not JavaScript.</source>
          <target state="translated">AngularJS расширяет HTML, так что вам не нужно помещать &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; повсюду, чтобы создать приложение. Это заставляет HTML фактически работать для приложений, а не для чего он был разработан, то есть для статических образовательных веб-страниц. Это делается окольным путем с использованием JavaScript, но по сути это расширение HTML, а не JavaScript.</target>
        </trans-unit>
        <trans-unit id="a790802605b2871a0ef2e9ba795618736b158088" translate="yes" xml:space="preserve">
          <source>AngularJS gives us service objects.</source>
          <target state="translated">AngularJS предоставляет нам сервисные объекты.</target>
        </trans-unit>
        <trans-unit id="580b72b69de2dbaa91260842ab501683adc90363" translate="yes" xml:space="preserve">
          <source>AngularJS gives you modules into which you can place your code. If you're writing a script that talks to Flickr for example, you might want to create a Flickr module to wrap all your Flickr related functions in. Modules can include other modules (DI). Your main application is usually a module, and this should include all the other modules your application will depend on.</source>
          <target state="translated">AngularJS дает вам модули,в которые вы можете поместить свой код.Если Вы пишете сценарий,который говорит,например,с Flickr,то,возможно,Вы захотите создать модуль Flickr,в который будут заворачиваться все Ваши функции,связанные с Flickr.Модули могут включать другие модули (DI).Обычно ваше основное приложение является модулем,и в него должны входить все остальные модули,от которых зависит ваше приложение.</target>
        </trans-unit>
        <trans-unit id="f5dbd7fd768f26aa68cfb19bda9fe60441f2e19f" translate="yes" xml:space="preserve">
          <source>AngularJS has $scope objects. These are special objects created and maintained by AngularJS in which you store your model. Certain directives will spawn a new $scope, which by default inherits from its wrapping $scope using JavaScript prototypical inheritance. The $scope object is accessible in the controller and the view.</source>
          <target state="translated">В AngularJS есть объекты в $scope.Это специальные объекты,созданные и поддерживаемые AngularJS,в которых вы храните свою модель.Определенные директивы порождают новый $scope,который по умолчанию наследуется от его обертки $scope с использованием JavaScript прототипного наследования.Объект $scope доступен в контроллере и представлении.</target>
        </trans-unit>
        <trans-unit id="3347e5a5c11ca76b8bae02225f867635154e1d18" translate="yes" xml:space="preserve">
          <source>AngularJS has the concept of &quot;Directives&quot; for DOM manipulation and designing reusable UI components, so you should use it whenever you feel the need of doing DOM manipulation related stuff (directives are only place where you should write jQuery code while using AngularJS).</source>
          <target state="translated">AngularJS имеет концепцию &quot;Директивы&quot; для манипуляций с DOM и проектирования многоразовых компонентов пользовательского интерфейса,поэтому вы должны использовать его всякий раз,когда вы чувствуете необходимость делать что-то,связанное с манипуляциями с DOM (директивы-это только то место,где вы должны писать jQuery код при использовании AngularJS).</target>
        </trans-unit>
        <trans-unit id="abb7d137ad0c0d41f229faf7978453fac70efa79" translate="yes" xml:space="preserve">
          <source>AngularJS instead gives you a &lt;strong&gt;compiler&lt;/strong&gt;.</source>
          <target state="translated">AngularJS вместо этого дает вам &lt;strong&gt;компилятор&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f454c455626fe5cac16b1e78b3064e9efba3a1f4" translate="yes" xml:space="preserve">
          <source>AngularJS involves some learning curve (more than jQuery :-).</source>
          <target state="translated">AngularJS включает в себя некоторую кривую обучения (больше чем jQuery :-).</target>
        </trans-unit>
        <trans-unit id="0f33f894c7aeb275ff7e26043faaaba6c9273c31" translate="yes" xml:space="preserve">
          <source>AngularJS is an MV* framework.</source>
          <target state="translated">AngularJS-это каркас MV*.</target>
        </trans-unit>
        <trans-unit id="496acda8671b0ee67088cb637f1c89eb97cd852d" translate="yes" xml:space="preserve">
          <source>AngularJS is an entire client-side framework that uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; pattern (check out their &lt;a href=&quot;http://docs.angularjs.org/guide/concepts&quot;&gt;graphical representation&lt;/a&gt;). It greatly focuses on separation of concerns.</source>
          <target state="translated">AngularJS - это целая клиентская среда, которая использует шаблон &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; (посмотрите их &lt;a href=&quot;http://docs.angularjs.org/guide/concepts&quot;&gt;графическое представление&lt;/a&gt; ). Это сильно фокусируется на разделении интересов.</target>
        </trans-unit>
        <trans-unit id="ccc498700b07180690b810f63f70291230b83439" translate="yes" xml:space="preserve">
          <source>AngularJS itself includes a jQuery-lite edition within it. So for some basic DOM selection/manipulation, you really don't have to include the jQuery library (it saves many bytes to run on the network.)</source>
          <target state="translated">Сама AngularJS включает в себя издание jQuery-lite.Так что для некоторых базовых DOM манипуляций с выбором,вам действительно не нужно включать библиотеку jQuery (она сохраняет много байт для запуска по сети).</target>
        </trans-unit>
        <trans-unit id="f8eb1469e26f56c8a74bfdb88d4142545826f06f" translate="yes" xml:space="preserve">
          <source>AngularJS manages your dependencies for you. If you want an object, simply refer to it and AngularJS will get it for you.</source>
          <target state="translated">AngularJS управляет вашими зависимостями за вас.Если вы хотите получить объект,просто обратитесь к нему,и AngularJS получит его за вас.</target>
        </trans-unit>
        <trans-unit id="38dffc5e5dca986ffefa44052bb0ef43d021e403" translate="yes" xml:space="preserve">
          <source>AngularJS uses &lt;strong&gt;controllers&lt;/strong&gt; and directives (each of which can have their own controller, and/or compile and linking functions) to remove behavior from the view/structure (HTML).  Angular also has &lt;strong&gt;services&lt;/strong&gt; and &lt;strong&gt;filters&lt;/strong&gt; to help separate/organize your application.</source>
          <target state="translated">AngularJS использует &lt;strong&gt;контроллеры&lt;/strong&gt; и директивы (каждая из которых может иметь свой собственный контроллер и / или функции компиляции и связывания) для удаления поведения из представления / структуры (HTML). Angular также имеет &lt;strong&gt;сервисы&lt;/strong&gt; и &lt;strong&gt;фильтры,&lt;/strong&gt; помогающие отделить / организовать ваше приложение.</target>
        </trans-unit>
        <trans-unit id="427ca6be55cbd36d29b597716cd026cabed3d117" translate="yes" xml:space="preserve">
          <source>AngularJS vs. jQuery</source>
          <target state="translated">AngularJS vs.jQuery</target>
        </trans-unit>
        <trans-unit id="209303f007b14469938fa3242370f0eed9fe6b7f" translate="yes" xml:space="preserve">
          <source>AngularJS will recognise that a FlickrService object is needed to instantiate the controller, and will provide one for us.</source>
          <target state="translated">AngularJS распознает,что объект FlickrService необходим для инстанцирования контроллера,и предоставит его нам.</target>
        </trans-unit>
        <trans-unit id="89fd96e13c335779cf18929ce0e49db544e7b95a" translate="yes" xml:space="preserve">
          <source>AngularJS: THE model is the truth, and you always think from that ANGLE.</source>
          <target state="translated">Модель-это правда,и ты всегда думаешь от этого АНГЛЯ.</target>
        </trans-unit>
        <trans-unit id="3bef657357e40dc720fc2a1d5a9a5e5e4d968b2d" translate="yes" xml:space="preserve">
          <source>AngularJs Cool Principle - If you want some changes on your UI think from model data change perspective. Change your data and UI will re-render itself. You need not to play around DOM each time unless and until it is hardly required and that should also be handled through Angular Directives.</source>
          <target state="translated">AngularJs Cool Principle-Если вы хотите,чтобы некоторые изменения в вашем пользовательском интерфейсе происходили с точки зрения перспективы изменения данных модели.Измените свои данные,и пользовательский интерфейс пересканирует сам себя.Вам не нужно каждый раз играть с DOM до тех пор,пока это вряд ли потребуется,и это также должно выполняться с помощью Angular Directives.</target>
        </trans-unit>
        <trans-unit id="4c7fa873dad04f6b1ea51f0bb4c021ea8dae7e48" translate="yes" xml:space="preserve">
          <source>AngularJs and JQuery are completely different at every level except the JQLite functionality and you will see it once you start learning the AngularJs core features (I explained it below).</source>
          <target state="translated">AngularJs и JQuery совершенно разные на всех уровнях,за исключением функциональности JQLite,и вы увидите это,как только начнете изучать основные функции AngularJs (я объясню это ниже).</target>
        </trans-unit>
        <trans-unit id="3edbcd2b0fe8f2eeb3060452cd16d0c33d77cc16" translate="yes" xml:space="preserve">
          <source>AngularJs is a client side framework that offers to build the independent client side application. JQuery is a client side library that play around the DOM.</source>
          <target state="translated">AngularJs-это фреймворк на стороне клиента,который предлагает построить независимое приложение на стороне клиента.JQuery-это библиотека на стороне клиента,которая играет с DOM.</target>
        </trans-unit>
        <trans-unit id="5239585f0407322b9de9420fc353533aa0b142a9" translate="yes" xml:space="preserve">
          <source>Apart from mixing concerns, we also have the same problems of signifying intent that I mentioned before. But more importantly, we had to manually reference and update a DOM node. And if we want to delete a log entry, we have to code against the DOM for that too. How do we test the logic apart from the DOM? And what if we want to change the presentation?</source>
          <target state="translated">Помимо смешивания озабоченностей,у нас также есть те же проблемы с обозначением намерений,о которых я упоминал ранее.Но что более важно,нам пришлось вручную обращаться к DOM-узлу и обновлять его.И если мы хотим удалить запись в журнале,нам тоже приходится кодировать против DOM для этого.Как мы можем проверить логику кроме DOM? И что,если мы хотим изменить представление?</target>
        </trans-unit>
        <trans-unit id="4887e453b680689b4f5edbe3a009b399e0a9cd5f" translate="yes" xml:space="preserve">
          <source>Application design</source>
          <target state="translated">Дизайн приложения</target>
        </trans-unit>
        <trans-unit id="390be301a8114b068b77d68bc38caf2bb1d0d455" translate="yes" xml:space="preserve">
          <source>Are there any server-side considerations/restrictions?</source>
          <target state="translated">Существуют ли какие-нибудь ограничения со стороны сервера?</target>
        </trans-unit>
        <trans-unit id="664c60d57cb407ffa5cf65a1d3cbd40930f03f80" translate="yes" xml:space="preserve">
          <source>As a JavaScript MV* beginner and purely focusing on the application architecture (not the server/client-side matters), I would certainly recommend the following resource (which I am surprised wasn't mentioned yet): &lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;JavaScript Design Patterns&lt;/a&gt;, by Addy Osmani, as an introduction to different &lt;strong&gt;JavaScript Design Patterns&lt;/strong&gt;. The terms used in this answer are taken from the linked document above. I'm not going to repeat what was worded really well in the accepted answer. Instead, this answer links back to the &lt;strong&gt;theoretical backgrounds&lt;/strong&gt; which power AngularJS (and other libraries).</source>
          <target state="translated">Будучи новичком в JavaScript MV * и сосредоточенным исключительно на архитектуре приложения (не на стороне сервера / клиента), я бы определенно порекомендовал следующий ресурс (который, как я удивляюсь, пока не упоминался): &lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;шаблоны проектирования JavaScript&lt;/a&gt; , автор Addy Osmani , как введение в различные &lt;strong&gt;шаблоны проектирования JavaScript&lt;/strong&gt; . Термины, используемые в этом ответе, взяты из связанного документа выше. Я не собираюсь повторять то, что было действительно хорошо сформулировано в принятом ответе. Вместо этого этот ответ связан с &lt;strong&gt;теоретическими основами, на&lt;/strong&gt; которых основан AngularJS (и другие библиотеки).</target>
        </trans-unit>
        <trans-unit id="23a7327c34c86abe93b30fb5462eaf583c740d8f" translate="yes" xml:space="preserve">
          <source>At this point you likely have all sorts of questions concerning &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt; and accessibility, and rightly so. There are open issues here. Most screen readers will now parse JavaScript. Search engines can also index &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;AJAXed&lt;/a&gt; content. Nevertheless, you will want to make sure you are using pushstate URLs and you have a decent sitemap. See here for a discussion of the issue: &lt;a href=&quot;https://stackoverflow.com/a/23245379/687677&quot;&gt;https://stackoverflow.com/a/23245379/687677&lt;/a&gt;</source>
          <target state="translated">На данный момент у вас, вероятно, есть все виды вопросов, касающихся &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt; и доступности, и это правильно. Здесь есть открытые вопросы. Большинство программ чтения с экрана теперь анализируют JavaScript. Поисковые системы также могут индексировать контент &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;AJAX&lt;/a&gt; . Тем не менее, вы захотите убедиться, что вы используете pushstate URL, и у вас есть приличная карта сайта. Смотрите здесь для обсуждения проблемы: &lt;a href=&quot;https://stackoverflow.com/a/23245379/687677&quot;&gt;https://stackoverflow.com/a/23245379/687677&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e64cce4dacf87903542cb264297ae0a879e80ca7" translate="yes" xml:space="preserve">
          <source>Attach a controller to each view (using ng-view and routing, or ng-controller). Have the controller find/get only whatever model data the view needs to do its job. Make controllers as thin as possible.</source>
          <target state="translated">Прикрепите контроллер к каждому виду (используя ng-вид и маршрутизацию,или ng-контроллер).Пусть контроллер findget только для тех данных модели,которые нужны представлению для выполнения своей работы.Сделать контроллеры как можно более тонкими.</target>
        </trans-unit>
        <trans-unit id="4988689ec96d69654ac1b4d26595c58327121e0c" translate="yes" xml:space="preserve">
          <source>Because AngularJS treats your HTML page as a template. The template is not supposed to be semantic as your content is typically stored in your model which ultimately comes from your API. AngularJS compiles your DOM with the model to produce a semantic web page.</source>
          <target state="translated">Потому что AngularJS рассматривает вашу HTML страницу как шаблон.Шаблон не должен быть семантическим,так как ваше содержимое обычно хранится в вашей модели,которая,в конечном счете,поступает из вашего API.AngularJS компилирует ваш DOM с моделью для создания семантической веб-страницы.</target>
        </trans-unit>
        <trans-unit id="52ff735af719db7308ce1da781ad856d29790080" translate="yes" xml:space="preserve">
          <source>Because data binding is done from the template, using either an attribute or the curly brace syntax, it's super easy to do. There's little cognitive overhead associated with it so you'll find yourself doing it all the time.</source>
          <target state="translated">Так как привязка данных производится из шаблона,используя либо атрибут,либо синтаксис фигурных скобок,это очень просто сделать.С этим связано мало когнитивных накладных расходов,так что вы будете делать это постоянно.</target>
        </trans-unit>
        <trans-unit id="da1f91ccd2cdc9e39f69ad5bd7c07fde87791168" translate="yes" xml:space="preserve">
          <source>Being a framework, it hosts your code and takes ownership of decisions about what to call and when!</source>
          <target state="translated">Будучи фреймворком,он содержит ваш код и принимает на себя ответственность за принятие решений о том,как и когда звонить!</target>
        </trans-unit>
        <trans-unit id="1ede8f40530371ca2072fafa529a4af2b37e9ba1" translate="yes" xml:space="preserve">
          <source>Binds the input element to &lt;code&gt;$scope.user.name&lt;/code&gt;. Updating the input will update the value in your current scope, and vice-versa.</source>
          <target state="translated">&lt;code&gt;$scope.user.name&lt;/code&gt; элемент ввода к $ scope.user.name . Обновление ввода приведет к обновлению значения в вашей текущей области, и наоборот.</target>
        </trans-unit>
        <trans-unit id="723820bab62fc4cc602aaa7c4690e3b306e0a88e" translate="yes" xml:space="preserve">
          <source>But because we have separation of concerns, we can do test-driven development iteratively in AngularJS! For example, let's say we want a super-simple directive to indicate in our menu what our current route is. We can declare what we want in the view of our application:</source>
          <target state="translated">Но поскольку у нас есть разделение опасений,мы можем делать итеративную разработку,основанную на тестировании,в AngularJS! Например,допустим,нам нужна суперпростая директива,которая будет указывать в нашем меню,какой наш текущий маршрут.Мы можем объявить то,что хотим,в представлении нашего приложения:</target>
        </trans-unit>
        <trans-unit id="ce753a2c6da077456572ab747e44d38ca49b9bd8" translate="yes" xml:space="preserve">
          <source>But for that matter, our view could look like this:</source>
          <target state="translated">Но,если на то пошло,наш взгляд может выглядеть вот так:</target>
        </trans-unit>
        <trans-unit id="05e4f17ec22790979e0e74231b4a9712ba108795" translate="yes" xml:space="preserve">
          <source>But in AngularJS, you must start from the ground up with your architecture in mind. Instead of starting by thinking &quot;I have this piece of the DOM and I want to make it do X&quot;, you have to start with what you want to accomplish, then go about designing your application, and then finally go about designing your view.</source>
          <target state="translated">Но в AngularJS вы должны начать с нуля,учитывая вашу архитектуру.Вместо того,чтобы начинать с мысли &quot;У меня есть этот кусок DOM,и я хочу,чтобы он сделал X&quot;,вы должны начать с того,что вы хотите сделать,затем перейти к проектированию вашего приложения,а затем,наконец,перейти к проектированию вашего вида.</target>
        </trans-unit>
        <trans-unit id="706cdc463699e1ed474fcbc74dc48ab1f144a5d9" translate="yes" xml:space="preserve">
          <source>But let's dive a little deeper...</source>
          <target state="translated">Но давайте погрузимся чуть глубже...</target>
        </trans-unit>
        <trans-unit id="d00b45211d6f5e02dbf9930e954ca044f2728901" translate="yes" xml:space="preserve">
          <source>By googling, I see that there is a standalone jQuery selector module out there. It's Sizzle.</source>
          <target state="translated">Погуглив,я вижу,что там есть автономный модуль JQuery.Это Sizzle.</target>
        </trans-unit>
        <trans-unit id="75ed687c979f0bd97e2a3c3bf1ba2c8068f3c723" translate="yes" xml:space="preserve">
          <source>CSS - Styling, without the CSS the page is still readable.</source>
          <target state="translated">CSS-Styling,без CSS страница остается читаемой.</target>
        </trans-unit>
        <trans-unit id="5fbb684c9310c39e4a515fe80a2bcaad03a97701" translate="yes" xml:space="preserve">
          <source>Can you describe the paradigm shift that is necessary?</source>
          <target state="translated">Можете ли вы описать необходимый сдвиг парадигмы?</target>
        </trans-unit>
        <trans-unit id="fc22be49056528fdaa6e3e976f7e5c0875c0ea23" translate="yes" xml:space="preserve">
          <source>Closure vs. $scope</source>
          <target state="translated">Closure vs.$scope</target>
        </trans-unit>
        <trans-unit id="35313dc9f2a46f49b61938e95da8ca20b23eaa38" translate="yes" xml:space="preserve">
          <source>Controller - Your controller is a JavaScript function which hooks the view to the model. Its function is to initialise $scope. Depending on your application, you may or may not need to create a controller. You can have many controllers on a page.</source>
          <target state="translated">Контроллер-Ваш контроллер представляет собой функцию JavaScript,которая привязывает вид к модели.Его функция заключается в инициализации $scope.В зависимости от вашего приложения,вам может понадобиться или не понадобиться создавать контроллер.На странице может быть много контроллеров.</target>
        </trans-unit>
        <trans-unit id="38e5b6c1d5bdd30cd076016ffcf63fb6a6fe8ba7" translate="yes" xml:space="preserve">
          <source>Controllers and providers (services, factories, etc.) are for modifying the data model, NOT HTML.</source>
          <target state="translated">Контроллеры и провайдеры (услуги,фабрики и т.д.)предназначены для модификации модели данных,а не HTML.</target>
        </trans-unit>
        <trans-unit id="8190947945a5d101ce34179f8d52d23951e48521" translate="yes" xml:space="preserve">
          <source>DI means that instead of writing your application and wiring it together, you instead define a library of components, each identified by a string.</source>
          <target state="translated">DI означает,что вместо того,чтобы писать свое приложение и соединять его вместе,вы определяете библиотеку компонентов,каждый из которых идентифицируется строкой.</target>
        </trans-unit>
        <trans-unit id="d38cca5da9c7df446a12182ab09218cd420e4017" translate="yes" xml:space="preserve">
          <source>Data binding</source>
          <target state="translated">Привязка данных</target>
        </trans-unit>
        <trans-unit id="abe361ec5ac92ab2b51436412eccfc4c617ee10a" translate="yes" xml:space="preserve">
          <source>Dependency injection</source>
          <target state="translated">Инъекция зависимостей</target>
        </trans-unit>
        <trans-unit id="b4834f95740149caa4ab7c7998c3085a73d25833" translate="yes" xml:space="preserve">
          <source>Developers new to AngularJS often ask a question like: how do I find all links of a specific kind and add a directive onto them. The developer is always flabbergasted when we reply: you don't. But the reason you don't do that is that this is like half-jQuery, half-AngularJS, and no good. The problem here is that the developer is trying to &quot;do jQuery&quot; in the context of AngularJS. That's never going to work well. The view &lt;em&gt;is&lt;/em&gt; the official record. Outside of a directive (more on this below), you never, ever, &lt;em&gt;never&lt;/em&gt; change the DOM. And directives are applied &lt;em&gt;in the view&lt;/em&gt;, so intent is clear.</source>
          <target state="translated">Разработчики, плохо знакомые с AngularJS, часто задают такой вопрос, как: как найти все ссылки определенного вида и добавить к ним директиву. Разработчик всегда ошеломлен, когда мы отвечаем: нет. Но причина, по которой вы этого не делаете, состоит в том, что это похоже на half-jQuery, half-AngularJS и ничего хорошего. Проблема в том, что разработчик пытается &amp;laquo;сделать jQuery&amp;raquo; в контексте AngularJS. Это никогда не сработает. Представление &lt;em&gt;является&lt;/em&gt; официальным отчетом. Вне директивы (подробнее об этом ниже) вы никогда и никогда &lt;em&gt;не&lt;/em&gt; меняете DOM. И директивы применяются &lt;em&gt;в представлении&lt;/em&gt; , поэтому намерение ясно.</target>
        </trans-unit>
        <trans-unit id="53d7a9d92573e089ff93413770ae30c25ee69d14" translate="yes" xml:space="preserve">
          <source>Directives can then in turn pull in additional Angular components such as controllers, services, etc. What comes out the bottom of the compiler is a fully formed web application, wired up and ready to go.</source>
          <target state="translated">Директивы могут,в свою очередь,втягивать дополнительные угловые компоненты,такие как контроллеры,службы и т.д.То,что выходит внизу компилятора-это полностью сформированное веб-приложение,проводное и готовое к работе.</target>
        </trans-unit>
        <trans-unit id="6e07f7c559632d31618e542f4fc425e25f0611c0" translate="yes" xml:space="preserve">
          <source>Distinct model layer</source>
          <target state="translated">Отличительный слой модели</target>
        </trans-unit>
        <trans-unit id="7d3e17491190e7a5dea94490347df028a3f9aa5e" translate="yes" xml:space="preserve">
          <source>Doing so will allow you to leverage their &lt;a href=&quot;http://docs.angularjs.org/api/ngResource.$resource&quot;&gt;resource factory&lt;/a&gt;, which creates an abstraction of your server side RESTful &lt;a href=&quot;http://en.wikipedia.org/wiki/Application_programming_interface&quot;&gt;API&lt;/a&gt; and makes server-side calls (get, save, delete, etc.) incredibly easy.</source>
          <target state="translated">Это позволит вам использовать их &lt;a href=&quot;http://docs.angularjs.org/api/ngResource.$resource&quot;&gt;фабрику ресурсов&lt;/a&gt; , которая создает абстракцию вашего RESTful &lt;a href=&quot;http://en.wikipedia.org/wiki/Application_programming_interface&quot;&gt;API на&lt;/a&gt; стороне сервера и делает невероятно простыми вызовы на стороне сервера (получение, сохранение, удаление и т. Д.).</target>
        </trans-unit>
        <trans-unit id="9fac905701ef3b0097c8764804ad3e59dbd915f9" translate="yes" xml:space="preserve">
          <source>Don't even use jQuery. Don't even include it. It will hold you back. And when you come to a problem that you think you know how to solve in jQuery already, before you reach for the &lt;code&gt;$&lt;/code&gt;, try to think about how to do it within the confines the AngularJS. If you don't know, ask! 19 times out of 20, the best way to do it doesn't need jQuery and to try to solve it with jQuery results in more work for you.</source>
          <target state="translated">Даже не используйте JQuery. Даже не включайте это. Это будет сдерживать вас. И когда вы столкнетесь с проблемой, которую, как вам кажется, вы уже знаете, как решить ее в jQuery, прежде чем вы достигнете &lt;code&gt;$&lt;/code&gt; , попытайтесь подумать, как это сделать в пределах AngularJS. Если не знаешь, спроси! 19 раз из 20, лучший способ сделать это не нуждается в jQuery, и попытка решить его с помощью jQuery приводит к большей работе для вас.</target>
        </trans-unit>
        <trans-unit id="2c79c2f8fe6cef139b77391f6699a0512a187188" translate="yes" xml:space="preserve">
          <source>Edit:</source>
          <target state="translated">Edit:</target>
        </trans-unit>
        <trans-unit id="22b7ff6e8b6f6df26b8528e8d5a05b683dda1ec4" translate="yes" xml:space="preserve">
          <source>First know that &lt;a href=&quot;http://en.wikipedia.org/wiki/Single-page_application&quot;&gt;single-page applications&lt;/a&gt; are &lt;em&gt;applications&lt;/em&gt;. They're &lt;em&gt;not&lt;/em&gt; webpages. So we need to think like a server-side developer &lt;em&gt;in addition&lt;/em&gt; to thinking like a client-side developer. We have to think about how to divide our application into individual, extensible, testable components.</source>
          <target state="translated">Сначала знайте, что &lt;a href=&quot;http://en.wikipedia.org/wiki/Single-page_application&quot;&gt;одностраничные приложения&lt;/a&gt; - это &lt;em&gt;приложения&lt;/em&gt; . Они &lt;em&gt;не&lt;/em&gt; веб-страницы. Таким образом, мы должны думать как разработчик &lt;em&gt;на&lt;/em&gt; стороне сервера &lt;em&gt;в дополнение&lt;/em&gt; к мышлению как разработчик на стороне клиента. Мы должны подумать о том, как разделить наше приложение на отдельные, расширяемые, тестируемые компоненты.</target>
        </trans-unit>
        <trans-unit id="395a4b3bfca26bc0f15e623275df885c5164cd6a" translate="yes" xml:space="preserve">
          <source>First up, Angular doesn't replace jQuery</source>
          <target state="translated">Во-первых,&quot;Угловой&quot; не заменит &quot;Джей Кьюри&quot;.</target>
        </trans-unit>
        <trans-unit id="2bd966a54c73aaa3f249cccf1a9fc029ccf3efc7" translate="yes" xml:space="preserve">
          <source>First, jQuery was never necessary. There's nothing we did here that needed jQuery at all!</source>
          <target state="translated">Во-первых,в Джей Кьюри никогда не было необходимости.Нет ничего,что мы делали здесь,что вообще было бы необходимо Джей Кьюри!</target>
        </trans-unit>
        <trans-unit id="900191e8f993958a06b036ac65d730e1bdaa6073" translate="yes" xml:space="preserve">
          <source>For a view that looks like this:</source>
          <target state="translated">Для вида,который выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="2e2c9d3bdb321bac05780afd95a48bfce104b09e" translate="yes" xml:space="preserve">
          <source>For example, here I define a service:</source>
          <target state="translated">Например,здесь я определяю услугу:</target>
        </trans-unit>
        <trans-unit id="de3e20808c116384b0a4b03719bffd49cb190884" translate="yes" xml:space="preserve">
          <source>For example, if you want a carousel on your page, you might define an unordered list of figures, perhaps wrapped in a nav element. You might then write some jQuery to select the list on the page and restyle it as a gallery with timeouts to do the sliding animation.</source>
          <target state="translated">Например,если вы хотите,чтобы на вашей странице была карусель,вы можете определить неупорядоченный список фигур,возможно,завернутых в элемент навигации.Затем вы можете написать jQuery,чтобы выбрать список на странице и переделать его в галерею с таймаутами,чтобы сделать скользящую анимацию.</target>
        </trans-unit>
        <trans-unit id="991573402c0940207e9bacdb158be6295096e397" translate="yes" xml:space="preserve">
          <source>For example, when you get data from THE server which you intend to display in some format in the DOM, in jQuery, you need to '1. FIND' where in the DOM you want to place this data, the '2. UPDATE/APPEND' it there by creating a new node or just setting its &lt;a href=&quot;http://www.tizag.com/javascriptT/javascript-innerHTML.php&quot;&gt;innerHTML&lt;/a&gt;. Then when you want to update this view, you then '3. FIND' the location and '4. UPDATE'. This cycle of find and update all done within the same context of getting and formatting data from server is gone in AngularJS.</source>
          <target state="translated">Например, когда вы получаете данные с сервера THE, которые вы намереваетесь отобразить в каком-либо формате в DOM, в jQuery, вам нужно '1. НАЙТИ 'где в DOM вы хотите разместить эти данные' 2. UPDATE / APPEND 'это там, создав новый узел или просто установив его &lt;a href=&quot;http://www.tizag.com/javascriptT/javascript-innerHTML.php&quot;&gt;innerHTML&lt;/a&gt; . Затем, когда вы хотите обновить это представление, вы затем '3. НАЙТИ 'местоположение и' 4. ОБНОВИТЬ'. Этот цикл поиска и обновления, выполненный в одном контексте получения и форматирования данных с сервера, пропал в AngularJS.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="850a95bbb6dd76741f2f32607f4ef86792316738" translate="yes" xml:space="preserve">
          <source>Fourth, closely related to the third, is that jqLite elements needn't be wrapped in &lt;code&gt;$&lt;/code&gt; - the &lt;code&gt;element&lt;/code&gt; that is passed to the &lt;code&gt;link&lt;/code&gt; function would &lt;em&gt;already be&lt;/em&gt; a jQuery element!</source>
          <target state="translated">Четвертое, тесно связанное с третьим, заключается в том, что элементы jqLite не нужно заключать в &lt;code&gt;$&lt;/code&gt; - &lt;code&gt;element&lt;/code&gt; который передается в функцию &lt;code&gt;link&lt;/code&gt; , &lt;em&gt;уже будет&lt;/em&gt; элементом jQuery!</target>
        </trans-unit>
        <trans-unit id="e937a7317ee9e666605382e9345fe01e5e87523e" translate="yes" xml:space="preserve">
          <source>From a broad perspective, DI means that you can declare components very freely and then from any other component, just ask for an instance of it and it will be granted. You don't have to know about loading order, or file locations, or anything like that. The power may not immediately be visible, but I'll provide just one (common) example: testing.</source>
          <target state="translated">В широком смысле,DI означает,что вы можете объявлять компоненты очень свободно,а затем из любого другого компонента,просто попросите экземпляр,и он будет предоставлен.Вам не нужно знать о порядке загрузки,или местоположении файлов,или о чем-то подобном.Питание может быть не сразу видно,но я приведу только один (общий)пример:тестирование.</target>
        </trans-unit>
        <trans-unit id="70376458c7e1d59978b45b6a33d1a41e52fb91db" translate="yes" xml:space="preserve">
          <source>Good luck.</source>
          <target state="translated">Удачи.</target>
        </trans-unit>
        <trans-unit id="a27f0fe6a21c158932ddc9c6ab32b680263c7a6e" translate="yes" xml:space="preserve">
          <source>HTML - Semantic meaning. The HTML should stand alone.</source>
          <target state="translated">HTML-семантическое значение.HTML должен быть самостоятельным.</target>
        </trans-unit>
        <trans-unit id="c5340e7474927e0f273d76b88c2f86f9341fb5de" translate="yes" xml:space="preserve">
          <source>HTML and directives define the layout and binding to the model.</source>
          <target state="translated">HTML и директивы определяют макет и привязку к модели.</target>
        </trans-unit>
        <trans-unit id="7602bdeaf94c8c4d20e603fafd1c75516db6e8a6" translate="yes" xml:space="preserve">
          <source>Here's a quick example that shows the pattern I see most frequently. We want a toggleable button. (Note: this example is a little contrived and a skosh verbose to represent more complicated cases that are solved in exactly the same way.)</source>
          <target state="translated">Вот краткий пример,который показывает шаблон,который я вижу чаще всего.Нам нужна переключаемая кнопка.(Обратите внимание:этот пример немного наворочен и многословен,чтобы представить более сложные случаи,которые решаются точно таким же образом).</target>
        </trans-unit>
        <trans-unit id="1b872c0b8b5cb91fbb546831e6921db7d5087ecd" translate="yes" xml:space="preserve">
          <source>How do I architect and design client-side web applications differently? What is the biggest difference?</source>
          <target state="translated">Как по-разному проектировать веб-приложения на стороне клиента? В чем разница?</target>
        </trans-unit>
        <trans-unit id="9ff77b581f89f632f34713ccc81664a4f91cf1b8" translate="yes" xml:space="preserve">
          <source>How do I architect and design client-side web apps differently?</source>
          <target state="translated">Как по-разному проектировать веб-приложения на стороне клиента и архитектора?</target>
        </trans-unit>
        <trans-unit id="8456215573486aa4c8df48dde90555787930b6c5" translate="yes" xml:space="preserve">
          <source>I find this question interesting, because my first serious exposure to JavaScript programming was &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; and AngularJS. I never learned jQuery, and I guess that's a good thing, because I don't have to unlearn anything. In fact, I actively avoid jQuery solutions to my problems, and instead, solely look for an &quot;AngularJS way&quot; to solve them. So, I guess my answer to this question would essentially boil down to, &quot;think like someone who never learned jQuery&quot; and avoid any temptation to incorporate jQuery directly (obviously AngularJS uses it to some extent behind the scenes).</source>
          <target state="translated">Я нахожу этот вопрос интересным, потому что мое первое серьезное знакомство с программированием на JavaScript было &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; и AngularJS. Я никогда не изучал jQuery, и я думаю, что это хорошо, потому что мне не нужно ничего учить. На самом деле, я активно избегаю решения своих проблем с помощью jQuery и вместо этого ищу исключительно &amp;laquo;AngularJS-способ&amp;raquo; для их решения. Итак, я думаю, что мой ответ на этот вопрос по сути сводится к тому, чтобы &amp;laquo;думать как кто-то, кто никогда не изучал jQuery&amp;raquo;, и избегать любого соблазна включить jQuery напрямую (очевидно, AngularJS использует его в некоторой степени за кулисами).</target>
        </trans-unit>
        <trans-unit id="efb9e3de8580d4d388e6d1d2c1128365fcee76cb" translate="yes" xml:space="preserve">
          <source>I found it easier also, to test &lt;strong&gt;(1)&lt;/strong&gt; native JavaScript code and &lt;strong&gt;(2)&lt;/strong&gt; smaller libraries for each one of these patterns &lt;strong&gt;separately&lt;/strong&gt; before diving into one global framework. This allowed me to better understand which crucial issues a framework adresses (because you are personally faced with the problem).</source>
          <target state="translated">Мне также было легче тестировать &lt;strong&gt;(1)&lt;/strong&gt; собственный код JavaScript и &lt;strong&gt;(2)&lt;/strong&gt; меньшие библиотеки для каждого из этих шаблонов &lt;strong&gt;отдельно,&lt;/strong&gt; прежде чем погрузиться в одну глобальную среду. Это позволило мне лучше понять, какие критические вопросы решает основа (потому что вы лично столкнулись с проблемой).</target>
        </trans-unit>
        <trans-unit id="0f5fdb791dc830db0312c3e805b978f9fee42e94" translate="yes" xml:space="preserve">
          <source>I got so excited about AngularJS, I wrote a short book on it which you're very welcome to read online &lt;a href=&quot;http://nicholasjohnson.com/angular-book/&quot;&gt;http://nicholasjohnson.com/angular-book/&lt;/a&gt;. I hope it's helpful.</source>
          <target state="translated">Я так взволнован AngularJS, я написал небольшую книгу, которую вы можете прочитать онлайн &lt;a href=&quot;http://nicholasjohnson.com/angular-book/&quot;&gt;http://nicholasjohnson.com/angular-book/&lt;/a&gt; . Я надеюсь, что это полезно.</target>
        </trans-unit>
        <trans-unit id="cff209bb9bc1c566d085c39c77af21c5738cf6e4" translate="yes" xml:space="preserve">
          <source>I heard from a meetup I attended, one of the founders of Angular said they worked really hard to separate out the DOM manipulation so do not try to include them back in.</source>
          <target state="translated">Я слышал от встречи,на которой присутствовал,один из основателей Angular сказал,что они очень много работали,чтобы отделить манипуляцию DOM,так что не пытайтесь включить их обратно.</target>
        </trans-unit>
        <trans-unit id="b1cc19c6fa446f86e199536080332bbd9a86f525" translate="yes" xml:space="preserve">
          <source>I see lots of developers new to AngularJS using directives as the place to throw a bunch of jQuery. In other words, they think &quot;since I can't do DOM manipulation in the controller, I'll take that code put it in a directive&quot;. While that certainly is much better, it's often &lt;em&gt;still wrong&lt;/em&gt;.</source>
          <target state="translated">Я вижу, что многие разработчики, плохо знакомые с AngularJS, используют директивы в качестве места для создания множества jQuery. Другими словами, они думают, что &amp;laquo;поскольку я не могу манипулировать DOM в контроллере, я возьму этот код и поместу его в директиву&amp;raquo;. Хотя это, конечно, намного лучше, но часто &lt;em&gt;все же неправильно&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cc523ff786c336f7206f714e0c729f9f96a4ee5f" translate="yes" xml:space="preserve">
          <source>I shared my code here: &lt;a href=&quot;https://github.com/huytd/Sizzular&quot;&gt;https://github.com/huytd/Sizzular&lt;/a&gt;</source>
          <target state="translated">Я поделился своим кодом здесь: &lt;a href=&quot;https://github.com/huytd/Sizzular&quot;&gt;https://github.com/huytd/Sizzular&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59b381689432e88b63f12501377e65b7661e38f1" translate="yes" xml:space="preserve">
          <source>I usually develop mobile applications using AngularJS and &lt;a href=&quot;http://en.wikipedia.org/wiki/PhoneGap&quot;&gt;Cordova&lt;/a&gt;. The ONLY thing from jQuery I needed is the Selector.</source>
          <target state="translated">Я обычно разрабатываю мобильные приложения, используя AngularJS и &lt;a href=&quot;http://en.wikipedia.org/wiki/PhoneGap&quot;&gt;Cordova&lt;/a&gt; . ЕДИНСТВЕННАЯ вещь от jQuery, в которой я нуждался, является Селектором.</target>
        </trans-unit>
        <trans-unit id="68cf991557c35bd050972b963c214ad303e38353" translate="yes" xml:space="preserve">
          <source>I'm not looking for a detailed comparison between &lt;code&gt;jQuery&lt;/code&gt; and &lt;code&gt;AngularJS&lt;/code&gt;.</source>
          <target state="translated">Я не ищу подробного сравнения между &lt;code&gt;jQuery&lt;/code&gt; и &lt;code&gt;AngularJS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f656d296b8b07178ef6945737f0889477b62c8e3" translate="yes" xml:space="preserve">
          <source>I've seen many developers here and on the mailing list create these elaborate solutions with jQuery plugins of 150 or 200 lines of code that they then glue into AngularJS with a collection of callbacks and &lt;code&gt;$apply&lt;/code&gt;s that are confusing and convoluted; but they eventually get it working! The problem is that in &lt;strong&gt;most&lt;/strong&gt; cases that jQuery plugin could be rewritten in AngularJS in a fraction of the code, where suddenly everything becomes comprehensible and straightforward.</source>
          <target state="translated">Я видел много разработчиков здесь и в списке рассылки, которые создавали эти сложные решения с помощью плагинов jQuery из 150 или 200 строк кода, которые они затем склеивали в AngularJS с помощью коллекции обратных вызовов и &lt;code&gt;$apply&lt;/code&gt; , которые сбивают с толку и запутывают; но они в конечном итоге заставить его работать! Проблема в том, что в &lt;strong&gt;большинстве&lt;/strong&gt; случаев этот плагин jQuery может быть переписан в AngularJS за небольшую часть кода, где вдруг все становится понятным и понятным.</target>
        </trans-unit>
        <trans-unit id="9faefb35c2c81504d51573a6b0bb40a2af1787a2" translate="yes" xml:space="preserve">
          <source>If this sounds like it might be over-prescriptive and limiting, nothing could be farther from the truth. Because AngularJS treats your HTML as code, you get &lt;strong&gt;HTML level granularity in your web application&lt;/strong&gt;. Everything is possible, and most things are surprisingly easy once you make a few conceptual leaps.</source>
          <target state="translated">Если это звучит так, как будто это слишком предписывает и ограничивает, ничто не может быть дальше от истины. Поскольку AngularJS рассматривает ваш HTML как код, вы получаете &lt;strong&gt;гранулярность уровня HTML в своем веб-приложении&lt;/strong&gt; . Все возможно, и большинство вещей на удивление легко, когда вы делаете несколько концептуальных скачков.</target>
        </trans-unit>
        <trans-unit id="79f7744c5244c5d82136a0b399bcf24b88bb5af1" translate="yes" xml:space="preserve">
          <source>If you do use jQuery, you shouldn't be sprinkling it all over the place. The correct place for DOM manipulation in AngularJS is in a directive. More on these later.</source>
          <target state="translated">Если вы все-таки используете jQuery,вы не должны разбрызгивать его повсюду.Правильное место для манипуляции DOM в AngularJS-в директиве.Подробнее об этом позже.</target>
        </trans-unit>
        <trans-unit id="b60077ec18c37edabed1d4367bf017ee53c9fbcf" translate="yes" xml:space="preserve">
          <source>If you need an HTML widget, create a directive.</source>
          <target state="translated">Если вам нужен HTML-виджет,создайте директиву.</target>
        </trans-unit>
        <trans-unit id="c0db6dddb3c36feeee526c677dfbbae3c8383c59" translate="yes" xml:space="preserve">
          <source>If you need to share data between controllers, create a service or factory - they are singletons that are shared across the application.</source>
          <target state="translated">Если требуется обмен данными между контроллерами,создание службы или фабрики-это синглоны,которые совместно используются всеми приложениями.</target>
        </trans-unit>
        <trans-unit id="4428aad89d5c0c9e8fe7de6ea30b96f7e38235d8" translate="yes" xml:space="preserve">
          <source>If you want a carousel, just use a &lt;code&gt;&amp;lt;carousel /&amp;gt;&lt;/code&gt; element, then define a directive to pull in a template, and make that sucker work.</source>
          <target state="translated">Если вы хотите использовать карусель, просто используйте элемент &lt;code&gt;&amp;lt;carousel /&amp;gt;&lt;/code&gt; , затем определите директиву для добавления шаблона и заставьте эту присоску работать.</target>
        </trans-unit>
        <trans-unit id="276ce11b5a508e459e0e3120bcd6327d2afadd20" translate="yes" xml:space="preserve">
          <source>If, like me, you lived through the browser wars, you might find this idea quite offensive. Get over it, it'll be worth it, I promise.</source>
          <target state="translated">Если,как и я,вы пережили браузерные войны,эта идея может показаться вам оскорбительной.Смирись с этим,оно того стоит,обещаю.</target>
        </trans-unit>
        <trans-unit id="5813cd91b1b8004097b86b34053bfec044d09858" translate="yes" xml:space="preserve">
          <source>Imperative &amp;rarr; declarative</source>
          <target state="translated">Императив &amp;rarr; декларативный</target>
        </trans-unit>
        <trans-unit id="07968492b4fc9b61f75164fde04e026e2f9fa45e" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;AngularJS&lt;/strong&gt;, you use &lt;strong&gt;directives&lt;/strong&gt; to mark the elements directly, to wire them up:</source>
          <target state="translated">В &lt;strong&gt;AngularJS&lt;/strong&gt; вы используете &lt;strong&gt;директивы&lt;/strong&gt; для прямой маркировки элементов и их соединения:</target>
        </trans-unit>
        <trans-unit id="f72af3c482bf1229ea3ff7aa97ad07e3cddd38f9" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;jQuery&lt;/strong&gt;, you typically  use &lt;strong&gt;selectors&lt;/strong&gt; to find elements, and then wire them up:</source>
          <target state="translated">В &lt;strong&gt;jQuery&lt;/strong&gt; вы обычно используете &lt;strong&gt;селекторы&lt;/strong&gt; для поиска элементов, а затем подключаете их:</target>
        </trans-unit>
        <trans-unit id="f023543783f6ea1287434a1d4ab86cd65d3608d2" translate="yes" xml:space="preserve">
          <source>In AngularJS we write smaller directives. Our dropdown directive would be ridiculously small. It might maintain the folded state, and provide methods to fold(), unfold() or toggle(). These methods would simply update $scope.menu.visible which is a boolean holding the state.</source>
          <target state="translated">В AngularJS мы пишем меньшие директивы.Наша выпадающая директива была бы смешно мала.Она может поддерживать сложенное состояние и предоставлять методы для fold(),unfold()или toggle().Эти методы будут просто обновлять $scope.menu.visible,который является булевым,удерживающим состояние.</target>
        </trans-unit>
        <trans-unit id="d8e03995fe1bd0fda78591a1efe81ead5f9d2dc8" translate="yes" xml:space="preserve">
          <source>In AngularJS you can do this too, but you are encouraged to make use of data binding. Change your model, and because the DOM is bound to it via a template your DOM will automatically update, no intervention required.</source>
          <target state="translated">В AngularJS это тоже можно сделать,но рекомендуется использовать привязку данных.Измените вашу модель,и так как DOM привязан к ней через шаблон,ваш DOM будет автоматически обновляться,никакого вмешательства не требуется.</target>
        </trans-unit>
        <trans-unit id="1ac2131eed6961b3bcec8b6db93b268ad621db10" translate="yes" xml:space="preserve">
          <source>In AngularJS, Ajax is your default go-to solution and it happens all the time, almost without you noticing. You can include templates with ng-include. You can apply a template with the simplest custom directive. You can wrap an Ajax call in a service and create yourself a &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt; service, or a &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt; service, which you can access with astonishing ease.</source>
          <target state="translated">В AngularJS Ajax - это стандартное решение по умолчанию, и это происходит постоянно, почти без вашего ведома. Вы можете включать шаблоны с помощью ng-include. Вы можете применить шаблон с простейшей пользовательской директивой. Вы можете заключить вызов Ajax в службу и создать себе службу &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt; или службу &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt; , к которой вы можете обращаться с удивительной легкостью.</target>
        </trans-unit>
        <trans-unit id="e2b05f35093dd1f890c262faf35c9be008a7512c" translate="yes" xml:space="preserve">
          <source>In AngularJS, meaning lives in the model, the HTML is just a template, for display only.</source>
          <target state="translated">В AngularJS,смысл которого живет в модели,HTML является просто шаблоном,только для отображения.</target>
        </trans-unit>
        <trans-unit id="d68e1fa23f0a8a69226a8fe0de84d40b5cf7424f" translate="yes" xml:space="preserve">
          <source>In AngularJS, think about models, rather than jQuery-selected DOM elements that hold your data. Think about views as projections of those models, rather than registering callbacks to manipulate what the user sees.</source>
          <target state="translated">В AngularJS подумайте о моделях,а не о DOM-элементах,выбранных с помощью jQuery,которые хранят ваши данные.Думайте о представлениях как о проекциях этих моделей,а не о регистрации обратных вызовов для манипулирования тем,что видит пользователь.</target>
        </trans-unit>
        <trans-unit id="89cbb8617b950a42475e39e8432df7a8116707a2" translate="yes" xml:space="preserve">
          <source>In AngularJS, though, the view is the official record of view-based functionality. Our &lt;code&gt;ul&lt;/code&gt; declaration would look like this instead:</source>
          <target state="translated">В AngularJS, однако, представление является официальной записью функциональности на основе представления. Наша декларация &lt;code&gt;ul&lt;/code&gt; будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="0162908cf1e7269bf496e946a61a8ada95cd6936" translate="yes" xml:space="preserve">
          <source>In AngularJS, we define directives. A directive is a function which returns a JSON object. This object tells AngularJS what DOM elements to look for, and what changes to make to them. Directives are hooked in to the template using either attributes or elements, which you invent. The idea is to extend the capabilities of HTML with new attributes and elements.</source>
          <target state="translated">В AngularJS мы определяем директивы.Директива-это функция,которая возвращает JSON-объект.Этот объект сообщает AngularJS,какие элементы DOM нужно искать и какие изменения в них вносить.Директивы привязываются к шаблону,используя либо атрибуты,либо элементы,которые вы изобретаете.Идея заключается в расширении возможностей HTML с помощью новых атрибутов и элементов.</target>
        </trans-unit>
        <trans-unit id="9ead8b9954017937b7508b690030cf694823a516" translate="yes" xml:space="preserve">
          <source>In AngularJS, you want to think about &lt;strong&gt;views&lt;/strong&gt; rather than DOM elements. Views are (declarative) HTML that contain AngularJS &lt;strong&gt;directives&lt;/strong&gt;. Directives set up the event handlers behind the scenes for us and give us dynamic databinding. Selectors are rarely used, so the need for IDs (and some types of classes) is greatly diminished. Views are tied to &lt;strong&gt;models&lt;/strong&gt; (via scopes). Views are a projection of the model. Events change models (that is, data, scope properties), and the views that project those models update &quot;automatically.&quot;</source>
          <target state="translated">В AngularJS вы хотите думать о &lt;strong&gt;представлениях,&lt;/strong&gt; а не об элементах DOM. Представления (декларативные) HTML, которые содержат &lt;strong&gt;директивы&lt;/strong&gt; AngularJS. Директивы устанавливают для нас закулисные обработчики событий и дают нам динамическое связывание данных. Селекторы используются редко, поэтому потребность в идентификаторах (и некоторых типах классов) значительно уменьшается. Представления привязаны к &lt;strong&gt;моделям&lt;/strong&gt; (через области видимости). Представления являются проекцией модели. События изменяют модели (то есть данные, свойства области), а представления, проецирующие эти модели, обновляются &amp;laquo;автоматически&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0978a7538d2e9b597f501e430a1fc5188f95a6ac" translate="yes" xml:space="preserve">
          <source>In fact, AngularJS is one of the few JavaScript MV* frameworks (many JavaScript MVC tools still fall under the category library).</source>
          <target state="translated">Фактически,AngularJS является одной из немногих фреймворков JavaScript MV*(многие инструменты JavaScript MVC все еще попадают в библиотеку категорий).</target>
        </trans-unit>
        <trans-unit id="90ff4de51967b0e32cde73bafc0522d33f597359" translate="yes" xml:space="preserve">
          <source>In jQuery making an Ajax call is fairly simple, but it's still something you might think twice about. There's the added complexity to think about, and a fair chunk of script to maintain.</source>
          <target state="translated">В jQuery сделать звонок на Ajax довольно просто,но это все равно что-то,о чем вы можете подумать дважды.Есть дополнительная сложность,о которой стоит подумать,и достаточный кусок сценария,который нужно поддерживать.</target>
        </trans-unit>
        <trans-unit id="4d193d7aba2968b4d212b2af011f3a04f803d0cc" translate="yes" xml:space="preserve">
          <source>In jQuery we define plugins by adding functions to the jQuery.prototype. We then hook these into the DOM by selecting elements and calling the plugin on the result. The idea is to extend the capabilities of jQuery.</source>
          <target state="translated">В jQuery мы определяем плагины,добавляя функции в jQuery.prototype.Затем мы подключаем их к DOM,выбирая элементы и вызывая плагин по результату.Идея заключается в расширении возможностей jQuery.</target>
        </trans-unit>
        <trans-unit id="91a51e946cb4f1b8c319d268bb1e04bc99f9428c" translate="yes" xml:space="preserve">
          <source>In jQuery you make all your DOM changes by hand. You construct new DOM elements programatically. If you have a JSON array and you want to put it to the DOM, you must write a function to generate the HTML and insert it.</source>
          <target state="translated">В jQuery вы вносите все изменения в DOM вручную.Вы создаете новые элементы DOM программно.Если у вас есть массив JSON и вы хотите поместить его в DOM,вы должны написать функцию для генерации HTML и вставить его.</target>
        </trans-unit>
        <trans-unit id="a18bb6e728d8ea68da1050a05d8c1caca3f92ba2" translate="yes" xml:space="preserve">
          <source>In jQuery, &lt;em&gt;selectors&lt;/em&gt; are used to find &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; elements and then bind/register event handlers to them. When an event triggers, that (imperative) code executes to update/change the DOM.</source>
          <target state="translated">В jQuery &lt;em&gt;селекторы&lt;/em&gt; используются для поиска элементов &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM,&lt;/a&gt; а затем связывают / регистрируют обработчики событий с ними. Когда происходит событие, этот (обязательный) код выполняется для обновления / изменения DOM.</target>
        </trans-unit>
        <trans-unit id="8a90029611394ef928be3afb0243d4a481afa763" translate="yes" xml:space="preserve">
          <source>In jQuery, if we want to accomplish a small non-dom related task such as pulling a feed from an API, we might write a little function to do that in our closure. That's a valid solution, but what if we  want to access that feed often? What if we want to reuse that code in another application?</source>
          <target state="translated">В jQuery,если мы хотим выполнить небольшую,не связанную с домом,задачу,например,вытащить поток из API,мы можем написать небольшую функцию,чтобы сделать это в нашем закрытии.Это правильное решение,но что,если мы захотим часто получать доступ к этому каналу? Что если мы захотим повторно использовать этот код в другом приложении?</target>
        </trans-unit>
        <trans-unit id="578dbc27e0bbb209f2594106996aa6a42a880c64" translate="yes" xml:space="preserve">
          <source>In jQuery, in our application logic, we would activate it with something like:</source>
          <target state="translated">В jQuery,в логике нашего приложения,мы бы активировали его с чем-то вроде:</target>
        </trans-unit>
        <trans-unit id="e592dbbf682e0219ae9b707b9547f8d0c26db26e" translate="yes" xml:space="preserve">
          <source>In jQuery, the DOM is kind of like the model. But in AngularJS, we have a separate model layer that we can manage in any way we want, completely independently from the view. This helps for the above data binding, maintains &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separation of concerns&lt;/a&gt;, and introduces far greater testability. Other answers mentioned this point, so I'll just leave it at that.</source>
          <target state="translated">В jQuery DOM вроде как модель. Но в AngularJS у нас есть отдельный уровень модели, которым мы можем управлять любым способом, абсолютно независимо от вида. Это помогает для вышеупомянутой привязки данных, поддерживает &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;разделение проблем&lt;/a&gt; и обеспечивает гораздо большую тестируемость. Другие ответы упоминали этот момент, поэтому я просто оставлю это на этом.</target>
        </trans-unit>
        <trans-unit id="9df8eb4ba7e6248a7fa36700e17beb0b22254122" translate="yes" xml:space="preserve">
          <source>In jQuery, the only way to test is often to create the component independently with a sample/demo page against which our tests can perform DOM manipulation. So then we have to develop a component separately and &lt;em&gt;then&lt;/em&gt; integrate it into our application. How inconvenient! So much of the time, when developing with jQuery, we opt for iterative instead of test-driven development. And who could blame us?</source>
          <target state="translated">В jQuery единственным способом тестирования часто является независимое создание компонента с примером / демонстрационной страницей, с помощью которой наши тесты могут выполнять манипуляции с DOM. Итак, мы должны разработать компонент отдельно, а &lt;em&gt;затем&lt;/em&gt; интегрировать его в наше приложение. Как неудобно! Большую часть времени при разработке с использованием jQuery мы выбираем итеративную, а не управляемую тестами разработку. И кто мог обвинить нас?</target>
        </trans-unit>
        <trans-unit id="3d416179f5af40e5d18f244c9ec21f4ff3ba4392" translate="yes" xml:space="preserve">
          <source>In jQuery, we programmatically change the view. We could have a dropdown menu defined as a &lt;code&gt;ul&lt;/code&gt; like so:</source>
          <target state="translated">В jQuery мы программно меняем представление. У нас может быть выпадающее меню, определенное как &lt;code&gt;ul&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="8cc873c923938462e55d7110881a14087792dc45" translate="yes" xml:space="preserve">
          <source>In jQuery, you design a page, and then you make it dynamic. This is because jQuery was designed for augmentation and has grown incredibly from that simple premise.</source>
          <target state="translated">В jQuery вы создаете страницу,а затем делаете ее динамичной.Это происходит потому,что jQuery был разработан для аугментации и невероятно вырос из этого простого помещения.</target>
        </trans-unit>
        <trans-unit id="7090926b8952ded00ad0da61eb6e721bc8a14052" translate="yes" xml:space="preserve">
          <source>It focuses on &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separation of concerns&lt;/a&gt; and testing (&lt;a href=&quot;http://en.wikipedia.org/wiki/Unit_testing&quot;&gt;unit testing&lt;/a&gt; and end-to-end testing), which facilitates test-driven development.</source>
          <target state="translated">Основное внимание уделяется &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;разделению задач&lt;/a&gt; и тестированию ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Unit_testing&quot;&gt;модульное тестирование&lt;/a&gt; и сквозное тестирование), что облегчает разработку через тестирование.</target>
        </trans-unit>
        <trans-unit id="68f6b3301831188f15035c61039b24d8f4da1058" translate="yes" xml:space="preserve">
          <source>It looks like this:</source>
          <target state="translated">Похоже на то:</target>
        </trans-unit>
        <trans-unit id="1bf8b46db45a60c96dc64642b65b408cb0586b2c" translate="yes" xml:space="preserve">
          <source>It's more similar to &lt;a href=&quot;http://en.wikipedia.org/wiki/XSLT&quot;&gt;XSLT&lt;/a&gt; than &lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt; for example.</source>
          <target state="translated">Например, он больше похож на &lt;a href=&quot;http://en.wikipedia.org/wiki/XSLT&quot;&gt;XSLT,&lt;/a&gt; чем на &lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa9f7423100ee20741ac52a057ba63a8dfdb5f92" translate="yes" xml:space="preserve">
          <source>It's really two very different states of mind.</source>
          <target state="translated">Это действительно два очень разных состояния души.</target>
        </trans-unit>
        <trans-unit id="94d4826a0666242ba1ec0266cc07db08e55ebb65" translate="yes" xml:space="preserve">
          <source>JQuery plugins are created in a closure. Privacy is maintained within that closure. It's up to you to maintain your scope chain within that closure. You only really have access to the set of DOM nodes passed in to the plugin by jQuery, plus any local variables defined in the closure and any globals you have defined. This means that plugins are quite self contained. This is a good thing, but can get restrictive when creating a whole application. Trying to pass data between sections of a dynamic page becomes a chore.</source>
          <target state="translated">Плагины JQuery создаются в закрытом виде.Конфиденциальность сохраняется в этом закрытии.Это зависит от вас,чтобы сохранить вашу цепочку область применения в этом закрытии.Вы действительно имеете доступ только к набору DOM-узлов,переданных плагину jQuery,плюс любые локальные переменные,определенные в закрытии,и любые глобусы,которые вы определили.Это означает,что плагины вполне автономны.Это хорошо,но может стать ограничительным при создании целого приложения.Попытка передать данные между разделами динамической страницы становится рутиной.</target>
        </trans-unit>
        <trans-unit id="4f2edb980b5874e73b214306540044ccfc45d51f" translate="yes" xml:space="preserve">
          <source>JavaScript - Behaviour, without the script the content remains.</source>
          <target state="translated">JavaScript-Поведение,без скрипта содержимое остается.</target>
        </trans-unit>
        <trans-unit id="0270aec9323c9370103673494bbf224ea44393df" translate="yes" xml:space="preserve">
          <source>Let's get down to the nitty gritty.</source>
          <target state="translated">Давайте перейдем к &quot;Нитти Гритти&quot;.</target>
        </trans-unit>
        <trans-unit id="b836477afc268d4e57ddfe2bd54c811505cff526" translate="yes" xml:space="preserve">
          <source>Let's say in our application, we require a service that implements server-side storage through a &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;REST&lt;/a&gt; API and, depending on application state, local storage as well. When running tests on our controllers, we don't want to have to communicate with the server - we're testing the &lt;em&gt;controller&lt;/em&gt;, after all. We can just add a mock service of the same name as our original component, and the injector will ensure that our controller gets the fake one automatically - our controller doesn't and needn't know the difference.</source>
          <target state="translated">Скажем, в нашем приложении нам нужен сервис, который реализует серверное хранилище через &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;REST&lt;/a&gt; API и, в зависимости от состояния приложения, локальное хранилище. При выполнении тестов на наших контроллерах нам не нужно связываться с сервером - в конце концов, мы тестируем &lt;em&gt;контроллер&lt;/em&gt; . Мы можем просто добавить фиктивную службу с тем же именем, что и у нашего исходного компонента, и инжектор будет гарантировать, что наш контроллер автоматически получит поддельный - наш контроллер не знает и не должен знать разницу.</target>
        </trans-unit>
        <trans-unit id="019d0f43d35ebf4308b922e715c1e5edd09fa4ad" translate="yes" xml:space="preserve">
          <source>Let's say we have a shopping cart. We might define a ShoppingCartService which maintains our cart and contains methods for adding and removing items. Because the service is a singleton, and is shared by all other components, any object that needs to can write to the shopping cart and pull data from it. It's always the same cart.</source>
          <target state="translated">Допустим,у нас есть корзина для покупок.Мы можем определить ShoppingCartService,который обслуживает нашу корзину и содержит методы добавления и удаления элементов.Так как сервис является одноэлементным и разделяется всеми остальными компонентами,любой объект,который необходимо записать в корзину и вытащить из нее данные.Это всегда одна и та же корзина.</target>
        </trans-unit>
        <trans-unit id="727106c324e0d326b53eb51a45c4de3427303c78" translate="yes" xml:space="preserve">
          <source>Like me, you will quickly realize that AngularJS (or &lt;a href=&quot;http://en.wikipedia.org/wiki/Ember.js&quot;&gt;Ember.js&lt;/a&gt;, Durandal, &amp;amp; other MV* frameworks for that matter) is one complex framework assembling many of the different JavaScript design patterns.</source>
          <target state="translated">Как и я, вы быстро поймете, что AngularJS (или &lt;a href=&quot;http://en.wikipedia.org/wiki/Ember.js&quot;&gt;Ember.js&lt;/a&gt; , Durandal и другие MV * фреймворки в этом отношении) - это одна сложная фреймворк, объединяющая множество различных шаблонов проектирования JavaScript.</target>
        </trans-unit>
        <trans-unit id="1cfac11915904016eed201cd17895ef142e7298c" translate="yes" xml:space="preserve">
          <source>Likewise:</source>
          <target state="translated">Likewise:</target>
        </trans-unit>
        <trans-unit id="480a72e21e4eecb130022ee539c13f82e6fb2dfc" translate="yes" xml:space="preserve">
          <source>Listen to the podcast &lt;em&gt;&lt;a href=&quot;http://javascriptjabber.com/032-jsj-angular-js/&quot;&gt;JavaScript Jabber: Episode #32&lt;/a&gt;&lt;/em&gt; that features the original creators of AngularJS: Misko Hevery &amp;amp; Igor Minar. They talk a lot about what it's like to come to AngularJS from other JavaScript backgrounds, especially jQuery.</source>
          <target state="translated">Послушайте подкаст &lt;em&gt;&lt;a href=&quot;http://javascriptjabber.com/032-jsj-angular-js/&quot;&gt;JavaScript Jabber: Episode # 32, в&lt;/a&gt;&lt;/em&gt; котором представлены оригинальные создатели AngularJS: Misko Hevery и Igor Minar. Они много говорят о том, каково это приходить в AngularJS из других фонов JavaScript, особенно из jQuery.</target>
        </trans-unit>
        <trans-unit id="b67d9fb1be3c48bab4357a222d15c0c1c6b2a6cb" translate="yes" xml:space="preserve">
          <source>Lots of small directives vs. big plugins with configuration switches</source>
          <target state="translated">Множество маленьких директив против больших плагинов с переключателями конфигурации</target>
        </trans-unit>
        <trans-unit id="d35f5ddc9a42a97abe31468fffd327ecf232b76a" translate="yes" xml:space="preserve">
          <source>MVC and SOC are not on opposite ends of the same scale, they are on completely different axes. SOC makes no sense in an AngularJS context. You have to forget it and move on.</source>
          <target state="translated">MVC и SOC не находятся на противоположных концах одной шкалы,они находятся на совершенно разных осях.SOC не имеет смысла в контексте AngularJS.Вы должны забыть об этом и двигаться дальше.</target>
        </trans-unit>
        <trans-unit id="c45a37dd264d950f6729ef56ff2a3c5abcd3a05d" translate="yes" xml:space="preserve">
          <source>Manual DOM changes vs. Data Binding</source>
          <target state="translated">Изменения ручного флэш-накопителя по сравнению с привязкой данных</target>
        </trans-unit>
        <trans-unit id="40e632bf9794198f4934d498879371d6d20bbd8f" translate="yes" xml:space="preserve">
          <source>Misko likes jQuery and doesn't object to you using it. However you will find as you advance that you can get a pretty much all of your work done using a combination of scope, templates and directives, and you should prefer this workflow where possible because your code will be more discrete, more configurable, and more Angular.</source>
          <target state="translated">Misko нравится jQuery и не возражает против того,чтобы вы его использовали.Однако по мере продвижения вперед вы обнаружите,что вы можете получить практически всю работу,используя комбинацию scope,templates и директив,и вы должны предпочесть этот рабочий процесс там,где это возможно,потому что ваш код будет более дискретным,более настраиваемым и более угловатым.</target>
        </trans-unit>
        <trans-unit id="aec4fedd98ecef7252e688fd312c8e23a1997547" translate="yes" xml:space="preserve">
          <source>Model - your models contains your semantic data. Models are usually &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; objects. Models exist as attributes of an object called $scope. You can also store handy utility functions on $scope which your templates can then access.</source>
          <target state="translated">Модель - ваши модели содержат ваши семантические данные. Модели обычно являются объектами &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; . Модели существуют как атрибуты объекта с именем $ scope. Вы также можете хранить полезные служебные функции в $ scope, к которым ваши шаблоны смогут получить доступ.</target>
        </trans-unit>
        <trans-unit id="19445a7cb4f59d8113ef809076f488b19366f851" translate="yes" xml:space="preserve">
          <source>Modular service architecture</source>
          <target state="translated">Модульная архитектура обслуживания</target>
        </trans-unit>
        <trans-unit id="9f995a1445edebed9a0edf58ca86dd65ac082151" translate="yes" xml:space="preserve">
          <source>Modules contain AngularJS components. &lt;strong&gt;When we include a module, all the components in that module become available to us as a simple list identified by their unique strings&lt;/strong&gt;. We can then inject those components into each other using AngularJS's dependency injection mechanism.</source>
          <target state="translated">Модули содержат компоненты AngularJS. &lt;strong&gt;Когда мы включаем модуль, все компоненты в этом модуле становятся доступны нам в виде простого списка, идентифицируемого их уникальными строками&lt;/strong&gt; . Затем мы можем внедрить эти компоненты друг в друга, используя механизм внедрения зависимостей AngularJS.</target>
        </trans-unit>
        <trans-unit id="70589733204c633c8000b33bb5a831052090d3fd" translate="yes" xml:space="preserve">
          <source>My little book</source>
          <target state="translated">Моя маленькая книжка</target>
        </trans-unit>
        <trans-unit id="07bfe1f4feee155120fcc275ea68f1bb17d3143b" translate="yes" xml:space="preserve">
          <source>NB: This list is not complete, nor 'the best libraries'; they just happen to be the libraries I used. These libraries also include more patterns, the ones mentioned are just their main focuses or original intents. If you feel something is missing from this list, please do mention it in the comments, and I will be glad to add it.</source>
          <target state="translated">NB:Этот список не полный и не &quot;лучшие библиотеки&quot;;они просто случайно оказались библиотеками,которые я использовал.Эти библиотеки также включают в себя больше шаблонов,те,которые упоминаются,являются лишь их основной целью или оригинальным намерением.Если вы чувствуете,что чего-то не хватает в этом списке,пожалуйста,упомяните об этом в комментариях,и я буду рад это добавить.</target>
        </trans-unit>
        <trans-unit id="9c8b27c78d13ab71411ac0fb47cbd272d9d671dd" translate="yes" xml:space="preserve">
          <source>Need to update on mouseover?</source>
          <target state="translated">Нужно обновить курсор мыши?</target>
        </trans-unit>
        <trans-unit id="aa01a327749e49bb46fbfc492f1fd3a49c1971bc" translate="yes" xml:space="preserve">
          <source>Now &lt;strong&gt;in our template&lt;/strong&gt; we can wire this up:</source>
          <target state="translated">Теперь &lt;strong&gt;в нашем шаблоне&lt;/strong&gt; мы можем подключить это:</target>
        </trans-unit>
        <trans-unit id="153e1db9288018367b69014d7e273ac9321adee5" translate="yes" xml:space="preserve">
          <source>Now when I want to use that service I just refer to it by name like this:</source>
          <target state="translated">Теперь,когда я хочу воспользоваться этим сервисом,я просто называю его так:</target>
        </trans-unit>
        <trans-unit id="0442ca4f2eae67ddd54b40deb8356ab4b3234010" translate="yes" xml:space="preserve">
          <source>Okay, now we can write a test for the non-existent &lt;code&gt;when-active&lt;/code&gt; directive:</source>
          <target state="translated">Хорошо, теперь мы можем написать тест для несуществующей директивы &lt;code&gt;when-active&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7837f88043d6848be1c4e543d7bab6fecef2576e" translate="yes" xml:space="preserve">
          <source>One approach to designing an AngularJS application:</source>
          <target state="translated">Один подход к проектированию приложения AngularJS:</target>
        </trans-unit>
        <trans-unit id="2bf914d56359268ce76537cc99ef400aea8ea885" translate="yes" xml:space="preserve">
          <source>One more thing you will experience in AngularJS: in jQuery you call the jQuery functions a lot, in AngularJS, AngularJS will call your functions, so AngularJS will 'tell you how to do things', but the benefits are worth it, so learning AngularJS usually means learning what AngularJS wants or the way AngularJS requires that you present your functions and it will call it accordingly. This is one of the things that makes AngularJS a framework rather than a library.</source>
          <target state="translated">Еще одна вещь,которую вы почувствуете в AngularJS:в jQuery вы часто называете функции jQuery,в AngularJS,AngularJS будет называть ваши функции,поэтому AngularJS будет &quot;указывать вам,как делать вещи&quot;,но преимущества того стоят,поэтому изучение AngularJS обычно означает изучение того,что хочет AngularJS или то,как AngularJS требует,чтобы вы представили свои функции,и он будет называть их соответствующим образом.Это одна из тех вещей,которые делают AngularJS не библиотекой,а каркасом.</target>
        </trans-unit>
        <trans-unit id="03d3b7c13e891111d419508c0bfcfcb11f3df270" translate="yes" xml:space="preserve">
          <source>One of the first questions I asked myself when starting AngularJS and running through the tutorials is &lt;strong&gt;&quot;Where is my code?&quot;&lt;/strong&gt;. I've written no JavaScript, and yet I have all this behaviour. The answer is obvious. Because AngularJS compiles the DOM, AngularJS is treating your HTML as code. For many simple cases it's often sufficient to just write a template and let AngularJS compile it into an application for you.</source>
          <target state="translated">Один из первых вопросов, которые я задавал себе при запуске AngularJS и прохождении руководств, - &lt;strong&gt;&amp;laquo;Где мой код?&amp;raquo;&lt;/strong&gt; , Я не написал JavaScript, и все же у меня есть все это поведение. Ответ очевиден. Поскольку AngularJS компилирует DOM, AngularJS рассматривает ваш HTML как код. Для многих простых случаев часто достаточно просто написать шаблон и позволить AngularJS скомпилировать его в приложение для вас.</target>
        </trans-unit>
        <trans-unit id="5560b0b478cb184acb6dd255b743f68939c76bfb" translate="yes" xml:space="preserve">
          <source>One of the first things your will notice about AngularJS is that &lt;strong&gt;custom attributes are everywhere&lt;/strong&gt;. Your HTML will be littered with ng attributes, which are essentially onClick attributes on steroids. These are directives (compiler directives), and are one of the main ways in which the template is hooked to the model.</source>
          <target state="translated">Первое, что вы заметите в AngularJS, это то, что &lt;strong&gt;пользовательские атрибуты есть везде&lt;/strong&gt; . Ваш HTML будет завален атрибутами ng, которые по сути являются атрибутами onClick на стероидах. Это директивы (директивы компилятора), и они являются одним из основных способов привязки шаблона к модели.</target>
        </trans-unit>
        <trans-unit id="57ecf8a54298e4269c92c7bcc0dbba1ce9d013e8" translate="yes" xml:space="preserve">
          <source>One of the points made in the podcast made a lot of things click for me with respects to your question:</source>
          <target state="translated">Один из пунктов,сделанных в подкасте сделал много вещей нажмите для меня с уважением к вашему вопросу:</target>
        </trans-unit>
        <trans-unit id="d2d60cb91258951e85b2c255d25b7443475f73c6" translate="yes" xml:space="preserve">
          <source>Our test now passes &lt;em&gt;and&lt;/em&gt; our menu performs as requested. Our development is &lt;em&gt;both&lt;/em&gt; iterative &lt;em&gt;and&lt;/em&gt; test-driven. Wicked-cool.</source>
          <target state="translated">Наш тест теперь проходит, &lt;em&gt;и&lt;/em&gt; наше меню работает в соответствии с запросом. Наша разработка является итеративной &lt;em&gt;и&lt;/em&gt; управляемой тестами. Злая-круто.</target>
        </trans-unit>
        <trans-unit id="b1cda9d2edb4291daae963095ddaa44650f5868e" translate="yes" xml:space="preserve">
          <source>Out of all of the many jQuery plugins you've seen, used, or written, how many of them had an accompanying test suite? Not very many because jQuery isn't very amenable to that. But AngularJS is.</source>
          <target state="translated">Из множества плагинов jQuery,которые вы видели,использовали или написали,сколько из них имели сопровождающий набор тестов? Не очень многие,потому что jQuery не очень подходит для этого.Но AngularJS-да.</target>
        </trans-unit>
        <trans-unit id="f9292427c33228bbb89cf354be2c739835887f3c" translate="yes" xml:space="preserve">
          <source>Plugins vs. Directives</source>
          <target state="translated">Плагины против руководящих принципов</target>
        </trans-unit>
        <trans-unit id="607f6c8afc68a939603967e0db86561e2011d68e" translate="yes" xml:space="preserve">
          <source>Prototypal inheritance</source>
          <target state="translated">Прототипное наследование</target>
        </trans-unit>
        <trans-unit id="1125bad105ddcf506c8be1fdc620fda300253963" translate="yes" xml:space="preserve">
          <source>Put another way, if AngularJS doesn't do something out of the box, think how the team would accomplish it to fit right in with &lt;code&gt;ngClick&lt;/code&gt;, &lt;code&gt;ngClass&lt;/code&gt;, et al.</source>
          <target state="translated">Иными словами, если AngularJS не делает что-то &amp;laquo;из коробки&amp;raquo;, подумайте, как команда &lt;code&gt;ngClick&lt;/code&gt; с этим , чтобы соответствовать требованиям ngClick , &lt;code&gt;ngClass&lt;/code&gt; и др.</target>
        </trans-unit>
        <trans-unit id="114cadb60225b9cfb70015e3d69c1e89f1ac48ce" translate="yes" xml:space="preserve">
          <source>Remember: don't design, and then mark up. You must architect, and then design.</source>
          <target state="translated">Помни:не проектируй,а потом делай пометки.Ты должен архитектор,а потом проектировать.</target>
        </trans-unit>
        <trans-unit id="f161adf528d29607ada8937ad2e9d5fb2b6eb816" translate="yes" xml:space="preserve">
          <source>Say I have a component called 'FlickrService' which defines methods for pulling JSON feeds from Flickr. Now, if I want to write a controller that can access Flickr, I just need to refer to the 'FlickrService' by name when I declare the controller. AngularJS will take care of instantiating the component and making it available to my controller.</source>
          <target state="translated">Допустим,у меня есть компонент под названием 'FlickrService',который определяет методы для вытягивания JSON-каналов из Flickr.Теперь,если я хочу записать контроллер,который может получить доступ к Flickr,мне просто нужно обратиться к 'FlickrService' по имени,когда я объявляю контроллер.AngularJS позаботится о инстанцировании компонента и о том,чтобы сделать его доступным для моего контроллера.</target>
        </trans-unit>
        <trans-unit id="19ccf6b268bdaab6e39621189c0b09a8c462daa5" translate="yes" xml:space="preserve">
          <source>Say you have a menu that you want to unfold on hover. Well now we have a problem. Our plugin has wired in our click handler for us, we're going to need to add a configuration option to make it behave differently in this specific case.</source>
          <target state="translated">Скажем,у тебя есть меню,которое ты хочешь развернуть на виселице.Ну,теперь у нас проблема.Наш плагин подключен к обработчику кликов для нас,нам нужно добавить опцию конфигурации,чтобы он вел себя по-другому в данном конкретном случае.</target>
        </trans-unit>
        <trans-unit id="7d90dd71a242dda24991720aaeaa5f7a73787c5c" translate="yes" xml:space="preserve">
          <source>Saying &quot;I have a jQuery background how do I think in AngularJS?&quot; is like saying &quot;I have an HTML background how do I think in JavaScript?&quot; The fact that you're asking the question shows you most likely don't understand the fundamental purposes of these two resources. This is why I chose to answer the question by simply pointing out the fundamental difference rather than going through the list saying &quot;AngularJS makes use of directives whereas jQuery uses CSS selectors to make a jQuery object which does this and that etc....&quot;. This question does not require a lengthy answer.</source>
          <target state="translated">Сказать &quot;У меня есть фона jQuery,как я думаю в AngularJS?&quot;-это все равно,что сказать &quot;У меня есть фона HTML,как я думаю в JavaScript?&quot; Тот факт,что вы задаете этот вопрос,показывает,что вы,скорее всего,не понимаете фундаментальных целей этих двух ресурсов.Вот почему я решил ответить на вопрос,просто указав на фундаментальную разницу,вместо того,чтобы пройтись по списку и сказать:&quot;AngularJS использует директивы,в то время как jQuery использует CSS селекторы для создания объекта jQuery,который делает то,что делает и т.д.....&quot;.Этот вопрос не требует длительного ответа.</target>
        </trans-unit>
        <trans-unit id="b15d2624d8c5f4177ef0a3ab7aff382714a73357" translate="yes" xml:space="preserve">
          <source>Second, even if we already have jQuery on our page, there's no reason to use it here; we can simply use &lt;code&gt;angular.element&lt;/code&gt; and our component will still work when dropped into a project that doesn't have jQuery.</source>
          <target state="translated">Во-вторых, даже если у нас уже есть jQuery на нашей странице, нет причин использовать его здесь; мы можем просто использовать &lt;code&gt;angular.element&lt;/code&gt; , и наш компонент все равно будет работать при переносе в проект, в котором нет jQuery.</target>
        </trans-unit>
        <trans-unit id="f1027ea73a1ce39cead4439ded7f29e2042983a5" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/a/14346528/215945&quot;&gt;https://stackoverflow.com/a/14346528/215945&lt;/a&gt;</source>
          <target state="translated">Смотрите также &lt;a href=&quot;https://stackoverflow.com/a/14346528/215945&quot;&gt;https://stackoverflow.com/a/14346528/215945&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f1430a8f5652e40680c3ddd0c683243bf517e61" translate="yes" xml:space="preserve">
          <source>Semantic HTML vs. Semantic Models</source>
          <target state="translated">Сематический HTML против семантических моделей</target>
        </trans-unit>
        <trans-unit id="53858a8768ea9c3d5fda9320b9574562086e2f5d" translate="yes" xml:space="preserve">
          <source>Separation of concerns</source>
          <target state="translated">Разделение проблем</target>
        </trans-unit>
        <trans-unit id="6db963975c4efe88a2a596e7aed57f9bfc1a010d" translate="yes" xml:space="preserve">
          <source>Separation of concerns (SOC) vs. MVC</source>
          <target state="translated">Разделение опасений (SOC)против MVC</target>
        </trans-unit>
        <trans-unit id="5bc1e903eb4c935f3459b8bfa4ee30d83efd9017" translate="yes" xml:space="preserve">
          <source>Service Objects vs Helper Functions</source>
          <target state="translated">Сервисные объекты против функций помощника</target>
        </trans-unit>
        <trans-unit id="4c836a91846e8f4077393af2f95820c64acdb8ff" translate="yes" xml:space="preserve">
          <source>Service objects are self-contained AngularJS components which we can use and reuse as we see fit. They are simple JSON objects containing functions and Data. They are always singletons, so if you store data on a service in one place, you can get that data out somewhere else just by requesting the same service.</source>
          <target state="translated">Сервисные объекты являются автономными компонентами AngularJS,которые мы можем использовать и повторно использовать по своему усмотрению.Это простые JSON-объекты,содержащие функции и данные.Они всегда являются синглонами,так что если вы храните данные о сервисе в одном месте,вы можете получить эти данные где-нибудь в другом месте,просто запросив тот же самый сервис.</target>
        </trans-unit>
        <trans-unit id="108da03ec5d5f76f957cbf432008dbadf4a072c6" translate="yes" xml:space="preserve">
          <source>Services are simple objects that contain functions and data. They are always singletons, meaning there can never be more than one of them. Say we want to access the Stack Overflow API, we might write a &lt;code&gt;StackOverflowService&lt;/code&gt; which defines methods for doing so.</source>
          <target state="translated">Сервисы - это простые объекты, которые содержат функции и данные. Они всегда одиночные, то есть никогда не может быть больше одного из них. Скажем, мы хотим получить доступ к API переполнения стека, мы могли бы написать &lt;code&gt;StackOverflowService&lt;/code&gt; , который определяет методы для этого.</target>
        </trans-unit>
        <trans-unit id="bcd9e97fc87fb6d10f4491826f78c5d81839dcbf" translate="yes" xml:space="preserve">
          <source>Similarly, don't start with the idea that jQuery does X, Y, and Z, so I'll just add AngularJS on top of that for models and controllers. This is &lt;em&gt;really&lt;/em&gt; tempting when you're just starting out, which is why I always recommend that new AngularJS developers don't use jQuery at all, at least until they get used to doing things the &quot;Angular Way&quot;.</source>
          <target state="translated">Точно так же не начинайте с идеи, что jQuery выполняет X, Y и Z, поэтому я просто добавлю AngularJS в дополнение к этому для моделей и контроллеров. Это &lt;em&gt;действительно&lt;/em&gt; заманчиво, когда вы только начинаете, поэтому я всегда рекомендую, чтобы новые разработчики AngularJS вообще не использовали jQuery, по крайней мере до тех пор, пока они не привыкнут делать что-то &amp;laquo;Angular Way&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="bcedf6e82233838f46efd8ce2fadad3c46a471c6" translate="yes" xml:space="preserve">
          <source>So if directives aren't just collections of jQuery-like functions, what are they? Directives are actually &lt;strong&gt;extensions of HTML&lt;/strong&gt;. If HTML doesn't do something you need it to do, you write a directive to do it for you, and then use it just as if it was part of HTML.</source>
          <target state="translated">Так что, если директивы - это не просто коллекции jQuery-подобных функций, что это? Директивы на самом деле являются &lt;strong&gt;расширениями HTML&lt;/strong&gt; . Если HTML не делает то, что вам нужно, вы пишете директиву, чтобы сделать это для вас, а затем используете это так, как если бы это было частью HTML.</target>
        </trans-unit>
        <trans-unit id="6120b7aac76e709ec6a4b057e3e50cdedce773bf" translate="yes" xml:space="preserve">
          <source>So then &lt;em&gt;how&lt;/em&gt; do you do that? How do you &quot;think in AngularJS&quot;? Here are some general principles, contrasted with jQuery.</source>
          <target state="translated">Итак, &lt;em&gt;как&lt;/em&gt; ты это делаешь? Как вы &amp;laquo;думаете в AngularJS&amp;raquo;? Вот некоторые общие принципы, противопоставленные jQuery.</target>
        </trans-unit>
        <trans-unit id="c8363d4dd045c968829900ac07d31222d3fe3f8c" translate="yes" xml:space="preserve">
          <source>So when people say &quot;don't include jQuery at all&quot;, it's mainly because they don't want you to use selectors; they want you to learn to use directives instead. Direct, not select!</source>
          <target state="translated">Поэтому,когда люди говорят &quot;вообще не включать jQuery&quot;,это в основном потому,что они не хотят,чтобы вы использовали селекторы;они хотят,чтобы вы научились использовать директивы вместо этого.Прямой,а не селектор!</target>
        </trans-unit>
        <trans-unit id="353a803b7edb418ffb01abfd037657963de833b9" translate="yes" xml:space="preserve">
          <source>So, to directly answer your question: AngularJS is -very- opinionated and is a true MV* framework. However, you can still do all of the really cool stuff you know and love with jQuery inside of directives. It's not a matter of &quot;How do I do what I used to in jQuery?&quot; as much as it's a matter of &quot;How do I supplement AngularJS with all of the stuff I used to do in jQuery?&quot;</source>
          <target state="translated">Итак,чтобы напрямую ответить на ваш вопрос:AngularJS-это-все-таки мнение и является истинным MV*фреймворком.Тем не менее,вы все еще можете делать все действительно крутые вещи,которые вы знаете и любите с jQuery внутри директив.Это не вопрос &quot;Как мне сделать то,что я делал раньше в jQuery?&quot;,а вопрос &quot;Как мне дополнить AngularJS всем тем,что я делал раньше в jQuery?&quot;.</target>
        </trans-unit>
        <trans-unit id="615e1f97ec6c97206dc36b15588437a9d429a60e" translate="yes" xml:space="preserve">
          <source>Some directives just decorate what's already in the view (think &lt;code&gt;ngClass&lt;/code&gt;) and therefore sometimes do DOM manipulation straight away and then are basically done. But if a directive is like a &quot;widget&quot; and has a template, it should &lt;em&gt;also&lt;/em&gt; respect separation of concerns. That is, the template &lt;em&gt;too&lt;/em&gt; should remain largely independent from its implementation in the link and controller functions.</source>
          <target state="translated">Некоторые директивы просто украшают то, что уже находится в представлении (например, &lt;code&gt;ngClass&lt;/code&gt; ), и поэтому иногда выполняют манипуляции с DOM, а затем в основном выполняются. Но если директива похожа на &amp;laquo;виджет&amp;raquo; и имеет шаблон, она &lt;em&gt;также&lt;/em&gt; должна учитывать разделение интересов. То есть шаблон &lt;em&gt;также&lt;/em&gt; должен оставаться в значительной степени независимым от его реализации в функциях связи и контроллера.</target>
        </trans-unit>
        <trans-unit id="0b7f180f770b68b78d30a4012dd96f23b513a81e" translate="yes" xml:space="preserve">
          <source>Speaking of testing...</source>
          <target state="translated">Кстати,о тестировании...</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="2c1b6c2453539d082bde5c9bc024f6fe7db931a1" translate="yes" xml:space="preserve">
          <source>Suppose I'm familiar with developing client-side applications in &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, but now I'd like to start using &lt;a href=&quot;http://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;. Can you describe the paradigm shift that is necessary? Here are a few questions that might help you frame an answer:</source>
          <target state="translated">Предположим, я знаком с разработкой клиентских приложений в &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; , но теперь я хотел бы начать использовать &lt;a href=&quot;http://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt; . Можете ли вы описать смену парадигмы, которая необходима? Вот несколько вопросов, которые могут помочь вам сформулировать ответ:</target>
        </trans-unit>
        <trans-unit id="fd6f41a20d68ad3b1c1fbfcea42f10e9427c9beb" translate="yes" xml:space="preserve">
          <source>Take the example of a dropdown. When writing a dropdown plugin you might be tempted to code in click handlers, perhaps a function to add in a chevron which is either up or down, perhaps change the class of the unfolded element, show hide the menu, all helpful stuff.</source>
          <target state="translated">Возьмите пример с выпаданием.При написании выпадающего плагина у вас может возникнуть соблазн кодировать в обработчиках кликов,возможно,функцию для добавления в шеврон,которая находится либо вверх,либо вниз,возможно,изменить класс разворачиваемого элемента,показать скрыть меню,все полезные вещи.</target>
        </trans-unit>
        <trans-unit id="5f73c389448f9c45c912813ff91624715c6cc34b" translate="yes" xml:space="preserve">
          <source>The JavaScript is in control. The HTML has a completely independent existence. Your HTML remains semantic even without JavaScript. Onclick attributes are very bad practice.</source>
          <target state="translated">JavaScript под контролем.HTML имеет полностью самостоятельное существование.Ваш HTML остается семантическим даже без JavaScript.Атрибуты клика-очень плохая практика.</target>
        </trans-unit>
        <trans-unit id="130af66cb629f5431d0392abeadf163c2a137efa" translate="yes" xml:space="preserve">
          <source>The best way to start is going through &lt;a href=&quot;http://docs.angularjs.org/tutorial/&quot;&gt;their awesome tutorial&lt;/a&gt;. You can go through the steps in a couple of hours; however, in case you want to master the concepts behind the scenes, they include a myriad of reference for further reading.</source>
          <target state="translated">Лучший способ начать - пройти &lt;a href=&quot;http://docs.angularjs.org/tutorial/&quot;&gt;их удивительный урок&lt;/a&gt; . Вы можете пройти через шаги в течение нескольких часов; однако, если вы хотите овладеть концепциями за кулисами, они включают множество ссылок для дальнейшего чтения.</target>
        </trans-unit>
        <trans-unit id="2e204a233be1d37e6b8cbf5eb65012ecf70edcf5" translate="yes" xml:space="preserve">
          <source>The big difference (TLDR)</source>
          <target state="translated">Большая разница (TLDR)</target>
        </trans-unit>
        <trans-unit id="907f9bbd858732c7716065c039f6505a1e2910ac" translate="yes" xml:space="preserve">
          <source>The bottom line is this: when solutioning, first &quot;think in AngularJS&quot;; if you can't think of a solution, ask the community; if after all of that there is no easy solution, &lt;em&gt;then&lt;/em&gt; feel free to reach for the jQuery. But don't let jQuery become a crutch or you'll never master AngularJS.</source>
          <target state="translated">Суть заключается в следующем: при решении, сначала &amp;laquo;думать в AngularJS&amp;raquo;; если вы не можете придумать решение, спросите сообщество; если после всего этого нет простого решения, &lt;em&gt;тогда не&lt;/em&gt; стесняйтесь обращаться к jQuery. Но не позволяйте jQuery стать опорой, иначе вы никогда не овладеете AngularJS.</target>
        </trans-unit>
        <trans-unit id="e57a136d72c8717caeadf129317ca6ab40af1abf" translate="yes" xml:space="preserve">
          <source>The main thing to realise is that your template drives your application. Stop trying to write big plugins that do everything. Instead write little directives that do one thing, then write a simple template to wire them together.</source>
          <target state="translated">Главное,чтобы понять,что ваш шаблон управляет вашим приложением.Прекратите пытаться писать большие плагины,которые все делают.Вместо этого пишите маленькие директивы,которые делают одну вещь,а затем пишите простой шаблон,чтобы соединить их вместе.</target>
        </trans-unit>
        <trans-unit id="962f4b9dcab1b0d6684a689d197c000723b390d9" translate="yes" xml:space="preserve">
          <source>The template drives the application so we get HTML level granularity. If we want to make case by case exceptions, the template makes this easy.</source>
          <target state="translated">Шаблон управляет приложением,поэтому мы получаем гранулярность уровня HTML.Если мы хотим сделать случай за случаем исключения,шаблон делает это легко.</target>
        </trans-unit>
        <trans-unit id="ab3b37bfaba497ececec74f637723357bb8a14df" translate="yes" xml:space="preserve">
          <source>The template is in the driving seat.</source>
          <target state="translated">Шаблон находится на сиденье водителя.</target>
        </trans-unit>
        <trans-unit id="dbd42a737715dc284713f8149c27aef45340aa3e" translate="yes" xml:space="preserve">
          <source>The tendency with jQuery is to write great big plugins like lightbox which we then configure by passing in numerous values and options.</source>
          <target state="translated">Тенденция с jQuery заключается в написании больших плагинов,таких как лайтбокс,который мы затем настраиваем,передавая многочисленные значения и опции.</target>
        </trans-unit>
        <trans-unit id="a78f488c2b28762effe665517b5bb3bf368fa282" translate="yes" xml:space="preserve">
          <source>The view is the &quot;official record&quot;</source>
          <target state="translated">Вид-&quot;официальная запись&quot;</target>
        </trans-unit>
        <trans-unit id="1c2ed441fd1cd976f573b36eb08871514ae231f0" translate="yes" xml:space="preserve">
          <source>There are a few things wrong with this:</source>
          <target state="translated">В этом есть несколько неправильных вещей:</target>
        </trans-unit>
        <trans-unit id="a60b215ea4b528f70a3f3f95afa944b9858d76db" translate="yes" xml:space="preserve">
          <source>These two do the same thing, but in the AngularJS version anyone looking at the template knows what's supposed to happen. Whenever a new member of the development team comes on board, she can look at this and then &lt;em&gt;know&lt;/em&gt; that there is a directive called &lt;code&gt;dropdownMenu&lt;/code&gt; operating on it; she doesn't need to intuit the right answer or sift through any code. The view told us what was supposed to happen. Much cleaner.</source>
          <target state="translated">Эти два делают одно и то же, но в версии AngularJS любой, кто смотрит на шаблон, знает, что должно произойти. Всякий раз, когда в команду входит новый член команды разработчиков, она может посмотреть на это, а затем &lt;em&gt;узнать,&lt;/em&gt; что над ним действует директива &lt;code&gt;dropdownMenu&lt;/code&gt; ; ей не нужно интуитивно понимать правильный ответ или просеивать какой-либо код. Вид сказал нам, что должно было случиться. Гораздо чище.</target>
        </trans-unit>
        <trans-unit id="5b12bc82675fe1d062a24637098e0b0d6f018bd6" translate="yes" xml:space="preserve">
          <source>They're apples and oranges. You don't want to compare them. They're two different things. AngularJs has already jQuery lite built in which allows you to perform basic DOM manipulation without even including the full blown jQuery version.</source>
          <target state="translated">Это яблоки и апельсины.Ты не хочешь их сравнивать.Это две разные вещи.В AngularJs уже встроена jQuery lite,которая позволяет выполнять базовые манипуляции с DOM,даже не включая полнофункциональную версию jQuery.</target>
        </trans-unit>
        <trans-unit id="56611a6e765ec02b14bdc41b9a14cd86614e07d8" translate="yes" xml:space="preserve">
          <source>Think about how you want to present your models -- your views. Create HTML templates for each view, using the necessary directives to get dynamic databinding.</source>
          <target state="translated">Подумайте о том,как вы хотите представить свои модели-ваши взгляды.Создавайте HTML шаблоны для каждого представления,используя необходимые директивы для получения динамической базы данных.</target>
        </trans-unit>
        <trans-unit id="27d048b935d814179e7c6a8517808bc5033c1c1e" translate="yes" xml:space="preserve">
          <source>Think about your models. Create services or your own JavaScript objects for those models.</source>
          <target state="translated">Подумай о своих моделях.Создавайте сервисы или собственные JavaScript-объекты для этих моделей.</target>
        </trans-unit>
        <trans-unit id="c7f6bac1d5607c8628add234dae8dfe943f7ebea" translate="yes" xml:space="preserve">
          <source>Think less about unobtrusive JavaScript, and instead think in terms of HTML extensions.</source>
          <target state="translated">Меньше думайте о ненавязчивом JavaScript,а вместо этого думайте о расширениях HTML.</target>
        </trans-unit>
        <trans-unit id="d9ef4e6d01c706c53e91d508343c6fe29cbd9c16" translate="yes" xml:space="preserve">
          <source>Think of the logger we programmed in section 3. Even if we put that in a directive, we &lt;em&gt;still&lt;/em&gt; want to do it the &quot;Angular Way&quot;. It &lt;em&gt;still&lt;/em&gt; doesn't take any DOM manipulation! There are lots of times when DOM manipulation is necessary, but it's a &lt;em&gt;lot&lt;/em&gt; rarer than you think! Before doing DOM manipulation &lt;em&gt;anywhere&lt;/em&gt; in your application, ask yourself if you really need to. There might be a better way.</source>
          <target state="translated">Подумайте о логгере, который мы запрограммировали в разделе 3. Даже если мы поместим это в директиву, мы &lt;em&gt;все равно&lt;/em&gt; хотим сделать это &amp;laquo;Угловым путем&amp;raquo;. Это &lt;em&gt;все&lt;/em&gt; еще не требует никаких манипуляций с DOM! Много раз, когда манипулирование DOM необходимо, но это &lt;em&gt;намного&lt;/em&gt; реже, чем вы думаете! Прежде чем выполнять манипуляции с DOM в &lt;em&gt;любом месте&lt;/em&gt; приложения, спросите себя, действительно ли вам это нужно. Там может быть лучший способ.</target>
        </trans-unit>
        <trans-unit id="59fba0d2a6be76b95e9437f56c0b3eb3aeefa64f" translate="yes" xml:space="preserve">
          <source>Third, even assuming jQuery &lt;em&gt;was&lt;/em&gt; required for this directive to work, jqLite (&lt;code&gt;angular.element&lt;/code&gt;) will &lt;em&gt;always&lt;/em&gt; use jQuery if it was loaded! So we needn't use the &lt;code&gt;$&lt;/code&gt; - we can just use &lt;code&gt;angular.element&lt;/code&gt;.</source>
          <target state="translated">В-третьих, даже если предположить, что для работы этой директивы требуется jQuery, jqLite ( &lt;code&gt;angular.element&lt;/code&gt; ) &lt;em&gt;всегда&lt;/em&gt; будет использовать jQuery, если он был загружен! Поэтому нам не нужно использовать &lt;code&gt;$&lt;/code&gt; - мы можем просто использовать &lt;code&gt;angular.element&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3dd8e8537bb1ca3481ce114c90c34fedaf33ea7" translate="yes" xml:space="preserve">
          <source>This a little messy and a trifle frail. But in AngularJS, we can do this:</source>
          <target state="translated">Немного грязновато и ничтожно хрупко.Но в AngularJS мы можем сделать это:</target>
        </trans-unit>
        <trans-unit id="751b9456fbde65691801d5e0cfad8c4a181a1230" translate="yes" xml:space="preserve">
          <source>This directive can be rewritten (even for very complicated cases!) much more simply like so:</source>
          <target state="translated">Эта директива может быть переписана (даже для очень сложных случаев!)гораздо проще:</target>
        </trans-unit>
        <trans-unit id="020626cca70fec4fadcd4c85e19094b67d89900d" translate="yes" xml:space="preserve">
          <source>This is a mistake in AngularJS.</source>
          <target state="translated">Это ошибка в AngularJS.</target>
        </trans-unit>
        <trans-unit id="3ee80553c6d3b6490cc47a8c1b3fc30604995853" translate="yes" xml:space="preserve">
          <source>This is a radical inversion of control that takes some getting used to.</source>
          <target state="translated">Это радикальная инверсия управления,к которой нужно привыкнуть.</target>
        </trans-unit>
        <trans-unit id="468caea94a05f6a1199b09552c745bdaee04f2e1" translate="yes" xml:space="preserve">
          <source>This is by far one of the most awesome features of AngularJS and cuts out a lot of the need to do the kinds of DOM manipulations I mentioned in the previous section. AngularJS will automatically update your view so you don't have to! In jQuery, we respond to events and then update content. Something like:</source>
          <target state="translated">Это,безусловно,одна из самых удивительных особенностей AngularJS и вырезает много необходимости делать виды манипуляций с DOM,о которых я упоминал в предыдущем разделе.AngularJS автоматически обновит ваше представление,так что вам не придется! В jQuery мы отвечаем на события,а затем обновляем контент.Что-то вроде:</target>
        </trans-unit>
        <trans-unit id="303ce135543d65882737386396b17832595260ae" translate="yes" xml:space="preserve">
          <source>This is normal, you should push through. Angular is worth it.</source>
          <target state="translated">Это нормально,ты должен протолкнуть.Угловой стоит того.</target>
        </trans-unit>
        <trans-unit id="7b1905aad1d40bfa2426382e15205e07ca50c045" translate="yes" xml:space="preserve">
          <source>This is really part of section 3 on architecture, but it's so important that I'm putting it as its own top-level section.</source>
          <target state="translated">Это действительно часть раздела 3 об архитектуре,но это настолько важно,что я ставлю его в качестве собственного раздела верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="383c8572d2b60f8594b548e872ffb17f8b10ed55" translate="yes" xml:space="preserve">
          <source>This is the clever part. Because the structure of $scope inheritance roughly follows the structure of the DOM, elements have access to their own scope, and any containing scopes seamlessly, all the way up to the global $scope (which is not the same as the global scope).</source>
          <target state="translated">Это умная часть.Поскольку структура наследования $scope примерно повторяет структуру DOM,элементы имеют доступ к своему собственному scope,а любые содержащие scopes бесшовно,вплоть до глобального $scope (что не то же самое,что и глобальный scope).</target>
        </trans-unit>
        <trans-unit id="f3085b36e84f35d5704fcffc8d2903ab4191c80b" translate="yes" xml:space="preserve">
          <source>This is the first big difference. To jQuery, your web page is a DOM to be manipulated. To AngularJS, your HTML is code to be compiled. AngularJS reads in your whole web page and literally compiles it into a new web page using its built in compiler.</source>
          <target state="translated">Это первая большая разница.Для jQuery,ваша веб-страница является DOM для манипулирования.Для AngularJS ваш HTML-это код,который должен быть скомпилирован.AngularJS читает всю вашу веб-страницу и буквально компилирует ее в новую веб-страницу,используя встроенный компилятор.</target>
        </trans-unit>
        <trans-unit id="1ad2248d3589183cfe2efd76e3ed9a33f9b96543" translate="yes" xml:space="preserve">
          <source>This makes it much easier to pass data around, and to store data at an appropriate level. If a dropdown is unfolded, only the dropdown $scope needs to know about it. If the user updates their preferences, you might want to update the global $scope, and any nested scopes listening to the user preferences would automatically be alerted.</source>
          <target state="translated">Это значительно облегчает передачу данных и их хранение на соответствующем уровне.Если разворачивается выпадающее окно,то об этом должен знать только выпадающий $scope.Если пользователь обновляет свои предпочтения,вы можете захотеть обновить глобальный $scope,и любые вложенные диапазоны,прослушивающие предпочтения пользователя,будут автоматически предупреждены.</target>
        </trans-unit>
        <trans-unit id="a8a3cb7a0749fede326fb94b0ea02af49e57374b" translate="yes" xml:space="preserve">
          <source>This makes wiring things together very easy, and pretty much eliminates any tendency towards spagettification. We have a flat list of components, and AngularJS hands them to us one by one as and when we need them.</source>
          <target state="translated">Это делает монтаж проводки очень простым,и практически исключает любую склонность к образованию спагетти.У нас есть плоский список компонентов,и AngularJS передает их нам по одному,когда и когда они нам нужны.</target>
        </trans-unit>
        <trans-unit id="01c6c85a35ab8aa0b42467c4fd5ea8262061e009" translate="yes" xml:space="preserve">
          <source>This might sound complicated, in fact, once you relax into it, it's like flying. You don't need to create the $scope object, AngularJS instantiates and configures it for you, correctly and appropriately based on your template hierarchy. AngularJS then makes it available to your component using the magic of dependency injection (more on this later).</source>
          <target state="translated">Это может показаться сложным,на самом деле,как только ты расслабляешься,это как полет.Вам не нужно создавать объект $scope,AngularJS инстанцирует и настраивает его для вас,правильно и правильно основываясь на вашей шаблонной иерархии.Затем AngularJS делает его доступным для вашего компонента,используя магию инъекции зависимостей (подробнее об этом позже).</target>
        </trans-unit>
        <trans-unit id="026686ca92306b82d1e8c15693deeebfe16be490" translate="yes" xml:space="preserve">
          <source>Those are some very nice, but lengthy answers.</source>
          <target state="translated">Это очень хорошие,но длинные ответы.</target>
        </trans-unit>
        <trans-unit id="b3d3c648ebb51538f239af45aaff5bf2a9ed2172" translate="yes" xml:space="preserve">
          <source>Though I didn't show it here, the data binding is two-way. So those log messages could also be editable in the view just by doing this: &lt;code&gt;&amp;lt;input ng-model=&quot;entry.msg&quot; /&amp;gt;&lt;/code&gt;. And there was much rejoicing.</source>
          <target state="translated">Хотя я не показывал это здесь, привязка данных является двусторонней. Таким образом, эти сообщения журнала также можно редактировать в представлении, просто выполнив следующее: &lt;code&gt;&amp;lt;input ng-model=&quot;entry.msg&quot; /&amp;gt;&lt;/code&gt; . И было много радости.</target>
        </trans-unit>
        <trans-unit id="ea44fd1157e8b164de6f12bfc47356be4ca15c22" translate="yes" xml:space="preserve">
          <source>To answer this question, I want to share my experience on the first enterprise application with AngularJS. These are the most awesome features that Angular provide where we start changing our jQuery mindset and we get the Angular like a framework and not the library.</source>
          <target state="translated">Чтобы ответить на этот вопрос,я хочу поделиться с AngularJS своим опытом работы с первым корпоративным приложением.Это самые удивительные возможности,которые предоставляет Angular,когда мы начинаем менять наше мышление jQuery,и мы получаем Angular как фреймворк,а не библиотеку.</target>
        </trans-unit>
        <trans-unit id="d960bde17bc0fc487713623ef832bfbb6216643e" translate="yes" xml:space="preserve">
          <source>To describe the &quot;paradigm shift&quot;, I think a short answer can suffice.</source>
          <target state="translated">Чтобы описать &quot;смещение парадигмы&quot;,думаю,достаточно короткого ответа.</target>
        </trans-unit>
        <trans-unit id="74c492c9268c2ba44b4ae9400fc50533ad33c007" translate="yes" xml:space="preserve">
          <source>To help us out with separation of concerns is &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt; (DI). If you come from a server-side language (from &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; to &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;) you're probably familiar with this concept already, but if you're a client-side guy coming from jQuery, this concept can seem anything from silly to superfluous to hipster. But it's not. :-)</source>
          <target state="translated">Чтобы помочь нам с разделением интересов является &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;внедрение зависимости&lt;/a&gt; (DI). Если вы работаете с серверным языком (от &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; до &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt; ), вы, вероятно, уже знакомы с этой концепцией, но если вы парень на стороне клиента, пришедший из jQuery, эта концепция может показаться чем-то глупым, излишним и хипстерским. , Но это не так. :-)</target>
        </trans-unit>
        <trans-unit id="57c4a51d2a57fb7332a311ca65fbda307945a043" translate="yes" xml:space="preserve">
          <source>To put in another way, in jQuery, you need to think about CSS selectors, that is, where is the &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;td&lt;/code&gt; that has a class or attribute, etc., so that I can get their HTML or color or value, but in AngularJS, you will find yourself thinking like this: what model am I dealing with, I will set the model's value to true. You are not bothering yourself of whether the view reflecting this value is a checked box or resides in a &lt;code&gt;td&lt;/code&gt; element (details you would have often needed to think about in jQuery).</source>
          <target state="translated">Иными словами, в jQuery вам нужно подумать о CSS-селекторах, то есть где находится &lt;code&gt;div&lt;/code&gt; или &lt;code&gt;td&lt;/code&gt; , имеющий класс или атрибут и т. Д., Чтобы я мог получить их HTML, цвет или значение, но в AngularJS, вы обнаружите, что думаете так: с какой моделью я имею дело, я установлю значение модели на true. Вы не беспокоитесь о том, является ли представление, отражающее это значение, установленным флажком или находится в элементе &lt;code&gt;td&lt;/code&gt; (подробности, о которых вам часто приходилось бы думать в jQuery).</target>
        </trans-unit>
        <trans-unit id="f4709eee581374c200f042fc55313a1c370597e0" translate="yes" xml:space="preserve">
          <source>To sum up</source>
          <target state="translated">Подводя итог</target>
        </trans-unit>
        <trans-unit id="836dd86d4b838ebe7598bd4b4cf3a469296eba00" translate="yes" xml:space="preserve">
          <source>To sum up my experiences:</source>
          <target state="translated">Подводя итог моему опыту:</target>
        </trans-unit>
        <trans-unit id="ce1ba8a1eb8df452a4296dfeb3f52aabce22bb11" translate="yes" xml:space="preserve">
          <source>Unobtrusive JavaScript with Selectors vs. Declarative Templates</source>
          <target state="translated">Ненавязчивый JavaScript с селекторами против декоративных шаблонов</target>
        </trans-unit>
        <trans-unit id="7dbc3550a5fc4912024fa7d8d15ebd8dac9e9fc3" translate="yes" xml:space="preserve">
          <source>Until you start to use this, it's hard to explain just what a massive time boon this is. Nothing like AngularJS DI exists inside jQuery.</source>
          <target state="translated">Пока ты не начнешь использовать это,трудно объяснить,что это за огромная временная выгода.Внутри JQuery нет ничего лучше,чем AngularJS DI.</target>
        </trans-unit>
        <trans-unit id="955f8bb419dd7b30b67b29f047877ec5da2bfed5" translate="yes" xml:space="preserve">
          <source>Until you want to make a small change.</source>
          <target state="translated">Пока ты не захочешь внести небольшие изменения.</target>
        </trans-unit>
        <trans-unit id="03fc4791bb56c36c6c9fce6cb595b363618e13c3" translate="yes" xml:space="preserve">
          <source>View - Your views are written in HTML. The view is usually not semantic because your data lives in the model.</source>
          <target state="translated">Просмотр-Ваши просмотры записываются в HTML.Вид обычно не семантический,потому что ваши данные живут в модели.</target>
        </trans-unit>
        <trans-unit id="5a862f238c06fc71828a9a25732468b79fbb1861" translate="yes" xml:space="preserve">
          <source>What is the biggest difference? What should I stop doing/using; what should I start doing/using instead?</source>
          <target state="translated">В чём самая большая разница? Что мне следует прекратить употребление;что мне следует начать употреблять вместо этого?</target>
        </trans-unit>
        <trans-unit id="0170226ebb8fd23c58004be3a692707980e1d490" translate="yes" xml:space="preserve">
          <source>What should I stop doing/using; What should I start doing/using instead?</source>
          <target state="translated">Что я должен перестать делать,что я должен начать делать вместо этого?</target>
        </trans-unit>
        <trans-unit id="6e7344707e452d84d6745b34070d9c7734587cd4" translate="yes" xml:space="preserve">
          <source>What this means is that AngularJS reads your entire DOM from top to bottom and treats it as code, literally as instructions to the compiler. As it traverses the DOM, It looks for specific &lt;strong&gt;directives&lt;/strong&gt; (compiler directives) that tell the AngularJS compiler how to behave and what to do. Directives are little objects full of JavaScript which can match against attributes, tags, classes or even comments.</source>
          <target state="translated">Это означает, что AngularJS читает весь ваш DOM сверху вниз и обрабатывает его как код, буквально как инструкции для компилятора. Обходя DOM, он ищет конкретные &lt;strong&gt;директивы&lt;/strong&gt; ( &lt;strong&gt;директивы&lt;/strong&gt; компилятора), которые сообщают компилятору AngularJS, как себя вести и что делать. Директивы - это маленькие объекты, полные JavaScript, которые могут сопоставляться с атрибутами, тегами, классами или даже комментариями.</target>
        </trans-unit>
        <trans-unit id="065885e8affa9b9b626e5ee7819e4774e1e660cf" translate="yes" xml:space="preserve">
          <source>When the Angular compiler determines that a piece of the DOM matches a particular directive, it calls the directive function, passing it the DOM element, any attributes, the current $scope (which is a local variable store), and some other useful bits. These attributes may contain expressions which can be interpreted by the Directive, and which tell it how to render, and when it should redraw itself.</source>
          <target state="translated">Когда компилятор Angular определяет,что часть DOM соответствует определенной директиве,он вызывает функцию директивы,передавая ей элемент DOM,любые атрибуты,текущий $scope (который является локальным хранилищем переменных)и некоторые другие полезные биты.Эти атрибуты могут содержать выражения,которые могут быть интерпретированы директивой,и которые говорят ей,как рендерить,и когда она должна перерисовать себя.</target>
        </trans-unit>
        <trans-unit id="b1f85922f7e91e37e11942af0d06bbc55d4f2b85" translate="yes" xml:space="preserve">
          <source>When we just look at the view, it's not immediately obvious that there is any functionality here. For small applications, that's fine. But for non-trivial applications, things quickly get confusing and hard to maintain.</source>
          <target state="translated">Когда мы просто смотрим на вид,не сразу видно,что здесь есть какая-то функциональность.Для небольших приложений это нормально.Но для нетривиальных приложений вещи быстро запутываются и их сложно поддерживать.</target>
        </trans-unit>
        <trans-unit id="f1562ae865a8c76b7015478b8cdbdfe3f9de7697" translate="yes" xml:space="preserve">
          <source>When you first see this you might be tempted to write AngularJS off as old school intrusive JavaScript (like I did at first). In fact, AngularJS does not play by those rules. In AngularJS, your HTML5 is a template. It is compiled by AngularJS to produce your web page.</source>
          <target state="translated">Когда вы впервые видите это,у вас может возникнуть соблазн списать AngularJS как старый школьный навязчивый JavaScript (как я сделал это вначале).На самом деле,AngularJS не играет по этим правилам.В AngularJS ваш HTML5 является шаблоном.Он компилируется AngularJS для создания вашей веб-страницы.</target>
        </trans-unit>
        <trans-unit id="7f3d35681fa2c63c5104c34b879516df9d536a1b" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;jQuery&lt;/strong&gt; you tell the DOM what needs to happen, step by step. With &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;&lt;/strong&gt; you describe what results you want but not how to do it. More on this &lt;a href=&quot;https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming&quot;&gt;here&lt;/a&gt;. Also, check out Mark Rajcok's answer.</source>
          <target state="translated">С &lt;strong&gt;jQuery&lt;/strong&gt; вы сообщаете DOM, что должно произойти, шаг за шагом. С &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;&lt;/strong&gt; вы описываете, какие результаты вы хотите, но не как это сделать. Подробнее об этом &lt;a href=&quot;https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming&quot;&gt;здесь&lt;/a&gt; . Также ознакомьтесь с ответом Марка Райкока.</target>
        </trans-unit>
        <trans-unit id="fc839325c446b08cf5a65d8819d89d6bb3164e33" translate="yes" xml:space="preserve">
          <source>With AngularJS you have your model (JavaScript objects you are already used to) and the value of the model tells you about the model (obviously) and about the view, and an operation on the model automatically propagates to the view, so you don't have to think about it. You will find yourself in AngularJS no longer finding things in the DOM.</source>
          <target state="translated">С AngularJS у вас есть ваша модель (объекты JavaScript,к которым вы уже привыкли),и значение модели говорит вам о модели (очевидно)и о представлении,и операция над моделью автоматически распространяется на представление,так что вам не нужно думать об этом.Вы обнаружите,что в AngularJS больше нет вещей,которые можно найти в DOM.</target>
        </trans-unit>
        <trans-unit id="4652c10e282176714fe41ae1e85eb5402efa7939" translate="yes" xml:space="preserve">
          <source>With jQuery your HTML page should contain semantic meaningful content. If the JavaScript is turned off (by a user or search engine) your content remains accessible.</source>
          <target state="translated">С помощью jQuery ваша HTML-страница должна содержать семантически значимое содержимое.Если JavaScript отключен (пользователем или поисковой системой),ваш контент остается доступным.</target>
        </trans-unit>
        <trans-unit id="ca1706ec5fb5ac78f5fde18c0d8566fbe135cc3c" translate="yes" xml:space="preserve">
          <source>You can do a lot with jQuery without knowing about how JavaScript prototypal inheritance works. When developing AngularJS applications, you will avoid some common pitfalls if you have a good understanding of JavaScript inheritance. Recommended reading: &lt;a href=&quot;https://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs&quot;&gt;What are the nuances of scope prototypal / prototypical inheritance in AngularJS?&lt;/a&gt;</source>
          <target state="translated">Вы можете многое сделать с помощью jQuery, не зная, как работает наследование прототипов JavaScript. При разработке приложений AngularJS вы избежите некоторых распространенных ошибок, если хорошо разбираетесь в наследовании JavaScript. Рекомендуемое чтение: &lt;a href=&quot;https://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs&quot;&gt;каковы нюансы области действия прототипа / прототипического наследования в AngularJS?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3bccb18f2df39489cf9c94bdc521ad8c56f6483" translate="yes" xml:space="preserve">
          <source>You get simple code reuse, if you want to write another application based on Flickr, you can just include the Flickr module and voila, you have access to all your Flickr related functions in your new application.</source>
          <target state="translated">Вы получаете простой повторный код,если вы хотите написать другое приложение на основе Flickr,вы можете просто включить модуль Flickr и вуаля,у вас есть доступ ко всем вашим функциям,связанным с Flickr,в вашем новом приложении.</target>
        </trans-unit>
        <trans-unit id="07a633bd9c67d80494b78137069dcf9bff6f8d9c" translate="yes" xml:space="preserve">
          <source>You may use it on existing applications where you are already using pure jQuery. However, if you want to fully take advantage of the AngularJS features you may consider coding the server side using a &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; approach.</source>
          <target state="translated">Вы можете использовать его в существующих приложениях, где вы уже используете чистый jQuery. Однако, если вы хотите в полной мере воспользоваться возможностями AngularJS, вы можете рассмотреть кодирование на стороне сервера с использованием подхода &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93e48c750ccd396d3473070f7e54269ec34e6751" translate="yes" xml:space="preserve">
          <source>You'll often hear &quot;only do DOM manipulation in a directive&quot;. &lt;strong&gt;This is a necessity.&lt;/strong&gt; Treat it with due deference!</source>
          <target state="translated">Вы часто будете слышать &quot;только манипулируйте DOM в директиве&quot;. &lt;strong&gt;Это необходимость.&lt;/strong&gt; Относись к этому с должным почтением!</target>
        </trans-unit>
        <trans-unit id="e9d5a9c89b6ee27e430aeadc83c97fafeb311b2e" translate="yes" xml:space="preserve">
          <source>Your template drives your application. It's treated as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL&lt;/a&gt;. You write AngularJS components, and AngularJS will take care of pulling them in and making them available at the right time based on the structure of your template. This is very different to a standard &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; pattern, where the template is just for output.</source>
          <target state="translated">Ваш шаблон управляет вашим приложением. Это рассматривается как &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL&lt;/a&gt; . Вы пишете компоненты AngularJS, а AngularJS позаботится о том, чтобы вытянуть их и сделать их доступными в нужное время в зависимости от структуры вашего шаблона. Это сильно отличается от стандартного шаблона &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; , где шаблон предназначен только для вывода.</target>
        </trans-unit>
        <trans-unit id="f63336c8b68dbd54d77ba260a5e6c9141be9ff84" translate="yes" xml:space="preserve">
          <source>Your template should be declarative; its meaning should be clear simply by reading it. We use custom attributes with meaningful names. We make up new HTML elements, again with meaningful names. A designer with minimal HTML knowledge and no coding skill can read your AngularJS template and understand what it is doing. He or she can make modifications. &lt;em&gt;This is the Angular way.&lt;/em&gt;</source>
          <target state="translated">Ваш шаблон должен быть декларативным; его значение должно быть ясно, просто прочитав его. Мы используем пользовательские атрибуты со значимыми именами. Мы создаем новые элементы HTML, опять же со значимыми именами. Дизайнер с минимальными знаниями HTML и навыками программирования не может прочитать ваш шаблон AngularJS и понять, что он делает. Он или она может вносить изменения. &lt;em&gt;Это угловой путь.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bdf7e60e32dde216fb6e902f1792e6d04b0b4e9" translate="yes" xml:space="preserve">
          <source>and there is one more thing, that's the directive. It's an attribute  you can attach to any DOM element and you can go nuts with jQuery within it without worrying about your jQuery ever conflicts with AngularJs components or messes up with its architecture.</source>
          <target state="translated">и есть еще одна вещь,это директива.Это атрибут,который вы можете прикрепить к любому DOM-элементу,и вы можете сойти с ума с jQuery внутри него,не беспокоясь о том,что ваш jQuery когда-нибудь конфликтует с компонентами AngularJs или испортит его архитектуру.</target>
        </trans-unit>
        <trans-unit id="00853d73f19844948fadbc48d500f997c46f7ee4" translate="yes" xml:space="preserve">
          <source>jQuery</source>
          <target state="translated">jQuery</target>
        </trans-unit>
        <trans-unit id="be925b4f423bcada24aaecc3aafd5c04280ae11d" translate="yes" xml:space="preserve">
          <source>jQuery employs &lt;a href=&quot;http://en.wikipedia.org/wiki/Unobtrusive_JavaScript&quot;&gt;unobtrusive JavaScript&lt;/a&gt; - behavior (JavaScript) is separated from the structure (HTML).</source>
          <target state="translated">В jQuery используется &lt;a href=&quot;http://en.wikipedia.org/wiki/Unobtrusive_JavaScript&quot;&gt;ненавязчивый JavaScript&lt;/a&gt; - поведение (JavaScript) отделено от структуры (HTML).</target>
        </trans-unit>
        <trans-unit id="c320142ede798313f44c3d11d76a83ae93eda792" translate="yes" xml:space="preserve">
          <source>jQuery gives you a toolkit for selecting arbitrary bits of the DOM and making ad-hoc changes to them. You can do pretty much anything you like piece by piece.</source>
          <target state="translated">jQuery предоставляет набор инструментов для выбора произвольных битов DOM и внесения в них специальных изменений.Вы можете делать практически все,что угодно по частям.</target>
        </trans-unit>
        <trans-unit id="a9491d0d475183db24d559659151458a8832e918" translate="yes" xml:space="preserve">
          <source>jQuery is a DOM manipulation library.</source>
          <target state="translated">jQuery-это DOM-библиотека манипуляций.</target>
        </trans-unit>
        <trans-unit id="dc5ccb5632110fdd3b6daae0577b2656f4f69591" translate="yes" xml:space="preserve">
          <source>jQuery is a way to make programming JavaScript in the browser easier. Shorter, cross-browser commands, etc.</source>
          <target state="translated">jQuery-это способ облегчить программирование JavaScript в браузере.Более короткие,кросс-браузерные команды и т.д.</target>
        </trans-unit>
        <trans-unit id="18f057b6ceb40d6c2c4a68a9d1752b11d2e478bc" translate="yes" xml:space="preserve">
          <source>jQuery is all about DOM manipulation. It solves all the cross browser pain otherwise you will have to deal with but it's not a framework that allows you to divide your app into components like AngularJS.</source>
          <target state="translated">jQuery-это все манипуляции с DOM.Она решает все проблемы кросс-браузера,иначе вам придется иметь дело с ней,но это не фреймворк,который позволяет вам разделить ваше приложение на компоненты,такие как AngularJS.</target>
        </trans-unit>
        <trans-unit id="b8a1fbe4c24f3cd32559fc40d013cf05b48575a8" translate="yes" xml:space="preserve">
          <source>jQuery is typically applied unobtrusively. Your JavaScript code is linked in the header (or the footer), and this is the only place it is mentioned. We use selectors to pick out bits of the page and write plugins to modify those parts.</source>
          <target state="translated">jQuery обычно применяется ненавязчиво.Ваш код JavaScript связан в заголовке (или нижнем колонтитуле),и это единственное место,где он упоминается.Мы используем селекторы для выбора битов страницы и пишем плагины для изменения этих частей.</target>
        </trans-unit>
        <trans-unit id="970e2a9590ad405940e9e253b4e0d66959d31936" translate="yes" xml:space="preserve">
          <source>jQuery makes ridiculously long JavaScript commands like &lt;code&gt;getElementByHerpDerp&lt;/code&gt; shorter and cross-browser.</source>
          <target state="translated">jQuery делает смешные длинные команды JavaScript, такие как &lt;code&gt;getElementByHerpDerp&lt;/code&gt; , более короткими и кросс-браузерными.</target>
        </trans-unit>
        <trans-unit id="c7b8d7c0d6361934bbf52868690dfdb5012d95ae" translate="yes" xml:space="preserve">
          <source>jQuery says very little about how you should organise your code. AngularJS has opinions.</source>
          <target state="translated">jQuery очень мало говорит о том,как вы должны организовать свой код.У AngularJS есть мнения.</target>
        </trans-unit>
        <trans-unit id="34f8968c02f9b2effb99adc9f1eadb7ef80c5c90" translate="yes" xml:space="preserve">
          <source>jQuery: you think a lot about 'QUERYing the &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;' for DOM elements and doing something.</source>
          <target state="translated">jQuery: вы много думаете о том, чтобы &amp;laquo;ЗАПРОСИТЬ &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; &amp;raquo; для элементов DOM и что-то делать.</target>
        </trans-unit>
        <trans-unit id="5ba0c567dacd0527890e40d7b7790df6aec5ca39" translate="yes" xml:space="preserve">
          <source>w00t!</source>
          <target state="translated">w00t!</target>
        </trans-unit>
        <trans-unit id="c546eb5a1fdcd9672da789e9684f30280d159a04" translate="yes" xml:space="preserve">
          <source>will output the user name in a paragraph. It's a live binding, so if the &lt;code&gt;$scope.user.name&lt;/code&gt; value is updated, the template will update too.</source>
          <target state="translated">выведет имя пользователя в абзаце. Это живая привязка, поэтому, если значение &lt;code&gt;$scope.user.name&lt;/code&gt; будет обновлено, шаблон также обновится.</target>
        </trans-unit>
        <trans-unit id="cbda61a42cf4628d5b234a95997da65ed8079da7" translate="yes" xml:space="preserve">
          <source>“Thinking in AngularJS” if I have a jQuery background</source>
          <target state="translated">&quot;Мыслить в угловом JS&quot;,если у меня есть JQuery задний план.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
