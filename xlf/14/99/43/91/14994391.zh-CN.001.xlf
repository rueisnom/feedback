<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/14994391">
    <body>
      <group id="14994391">
        <trans-unit id="2e892d84a456775f25c00e4f845837dd39c07406" translate="yes" xml:space="preserve">
          <source>--&amp;gt;For any developer coming from jQuery background, my first advice would be to &quot;learn JavaScript as a first class language before jumping onto a rich framework like AngularJS!&quot;
I learned the above fact the hard way.</source>
          <target state="translated">-&amp;gt;对于所有来自jQuery背景的开发人员，我的第一条建议是&amp;ldquo;在跳入AngularJS之类的丰富框架之前，将JavaScript作为一流的语言学习！&amp;rdquo; 我很难学到上述事实。</target>
        </trans-unit>
        <trans-unit id="396fc50aacb3d9fb04c78bba466f7908a2e8385d" translate="yes" xml:space="preserve">
          <source>1. Don't design your page, and then change it with &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; manipulations</source>
          <target state="translated">1.不要设计您的页面，然后通过&lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;操作对其进行更改</target>
        </trans-unit>
        <trans-unit id="3828151a3b203e32a8d4b22c6fdb84d2f290a8bc" translate="yes" xml:space="preserve">
          <source>2. Don't augment jQuery with AngularJS</source>
          <target state="translated">2.不要用AngularJS来增强jQuery。</target>
        </trans-unit>
        <trans-unit id="cbedaed8896e96dbbaa762bfb0a519199fab646b" translate="yes" xml:space="preserve">
          <source>3. Always think in terms of architecture</source>
          <target state="translated">3.始终从建筑学的角度思考</target>
        </trans-unit>
        <trans-unit id="9bb57b273b075b57706f730ef766b8139c69ca9e" translate="yes" xml:space="preserve">
          <source>4. Test-driven development - &lt;em&gt;always&lt;/em&gt;</source>
          <target state="translated">4.测试驱动的开发- &lt;em&gt;始终&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5df0490b33144a83a19e27b67ca325463559d8dd" translate="yes" xml:space="preserve">
          <source>5. Conceptually, directives are &lt;em&gt;not&lt;/em&gt; packaged jQuery</source>
          <target state="translated">5.从概念上讲，指令&lt;em&gt;不是&lt;/em&gt;打包的jQuery</target>
        </trans-unit>
        <trans-unit id="9d37a0363a38e4535d4fbf679c38b69053d2845a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Dependency injection&lt;/a&gt; (DI) vs. Instatiation - aka de-spaghettification</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;依赖注入&lt;/a&gt; （DI）与状态化-又名去意大利化</target>
        </trans-unit>
        <trans-unit id="5b2bf38bee1c00dcbf6a933d82ad04998661ee32" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;Separation of concerns&lt;/a&gt; (SOC) is a pattern that grew up over many years of web development for a variety of reasons including SEO, accessibility and browser incompatibility. It looks like this:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;关注分离&lt;/a&gt; （SOC）是Web开发多年来发展起来的一种模式，其原因包括SEO，可访问性和浏览器不兼容等多种原因。 看起来像这样：</target>
        </trans-unit>
        <trans-unit id="50b9bf0923a4b128bb297b2cf829a6c75cccc91e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;/ &lt;a href=&quot;http://underscorejs.org&quot;&gt;Underscore&lt;/a&gt; for the &lt;strong&gt;facade pattern&lt;/strong&gt; (like WYSIWYG's for manipulating the DOM)</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt; / &lt;a href=&quot;http://underscorejs.org&quot;&gt;Underscore&lt;/a&gt;用于&lt;strong&gt;外观模式&lt;/strong&gt; （例如用于操纵DOM的WYSIWYG）</target>
        </trans-unit>
        <trans-unit id="69042625919dd0e27703e71445b2b7bd23b39703" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://knockoutjs.com&quot;&gt;KnockoutJS&lt;/a&gt; for the &lt;strong&gt;observable, publish/subscribe pattern&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;http://knockoutjs.com&quot;&gt;KnockoutJS&lt;/a&gt;用于&lt;strong&gt;可观察的发布/订阅模式&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d7a0982ee2f9c3c522d1ee89cd375e2cb7609417" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://prototypejs.org&quot;&gt;Prototype.js&lt;/a&gt; for the &lt;strong&gt;prototype/ constructor/ mixin pattern&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;http://prototypejs.org&quot;&gt;Prototype.js&lt;/a&gt;用于&lt;strong&gt;原型/构造器/混合模式&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92b3217c5ba1cc0f9135ed9705adca8c3f975b4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://requirejs.org&quot;&gt;RequireJS&lt;/a&gt;/ &lt;a href=&quot;https://github.com/cujojs/curl&quot;&gt;Curl.js&lt;/a&gt; for the &lt;strong&gt;module pattern/ AMD&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;http://requirejs.org&quot;&gt;RequireJS&lt;/a&gt; / &lt;a href=&quot;https://github.com/cujojs/curl&quot;&gt;Curl.js&lt;/a&gt;用于&lt;strong&gt;模块模式/ AMD&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9b870b99d1adcc3ce0b3833fc3f86074e9524de" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.google.be/search?q=js+oop&quot;&gt;JavaScript Object-oriented Programming&lt;/a&gt; (this is a Google search link). It is not a library, but certainly a prerequisite to any application programming. It taught me the native implementations of the &lt;strong&gt;prototype, constructor, singleton &amp;amp; decorator patterns&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.google.be/search?q=js+oop&quot;&gt;JavaScript面向对象程序设计&lt;/a&gt; （这是Google搜索链接）。 它不是库，但肯定是任何应用程序编程的先决条件。 它教会了我&lt;strong&gt;原型，构造函数，单例和装饰器模式&lt;/strong&gt;的本地实现</target>
        </trans-unit>
        <trans-unit id="abd6dd62d85dac964abb4fc9b6d39f70c1511d55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The AngularJS way is to extend the capabilities of native looking HTML.&lt;/em&gt; You should write HTML that looks like HTML, extended with custom attributes and elements.</source>
          <target state="translated">&lt;em&gt;AngularJS的方法是扩展原生HTML的功能。&lt;/em&gt; 您应该编写类似于HTML的HTML，并使用自定义属性和元素进行扩展。</target>
        </trans-unit>
        <trans-unit id="42d5cb01532a1eb833bc5dc3442165730fc715f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS and jQuery:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;AngularJS和jQuery：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2cb0e6123d036e1454b06c3e92f6619c31e7b8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS&lt;/strong&gt; is a beautiful client-side framework, highly testable, that combines tons of cool stuff such as MVC, &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, data binding and much more.</source>
          <target state="translated">&lt;strong&gt;AngularJS&lt;/strong&gt;是一个漂亮的客户端框架，可测试性强，它结合了许多很酷的东西，例如MVC， &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;依赖项注入&lt;/a&gt; ，数据绑定等等。</target>
        </trans-unit>
        <trans-unit id="0f7938672e21aa28fcfa2974e178640ad994aae7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controllers are great:&lt;/strong&gt;
Controllers take care of their own HTML, but this separation works well for common functionality well as. If you want to call the same function on the click of a button on master HTML, just write the same function name in each controller and write individual code.</source>
          <target state="translated">&lt;strong&gt;控制器很棒：&lt;/strong&gt;控制器会照顾好自己的HTML，但是这种分离对于通用功能也很有效。 如果要通过单击主HTML上的按钮来调用相同的函数，只需在每个控制器中写入相同的函数名称并编写单独的代码即可。</target>
        </trans-unit>
        <trans-unit id="c11e6c999d67e30b4dd08344b653ee2887d7eeb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensibility&lt;/strong&gt;: Angular has extended the HTML directives using angular directives. Write expressions inside html and evaluate them on runtime. Create your own directives and services and use them in another project without any extra effort.</source>
          <target state="translated">&lt;strong&gt;可扩展性&lt;/strong&gt; ：Angular已使用angular指令扩展了HTML指令。 在html内编写表达式，并在运行时对其求值。 创建您自己的指令和服务，并在其他项目中使用它们，而无需进行任何额外的工作。</target>
        </trans-unit>
        <trans-unit id="0a5df869fa8dc89f42caf2f14c8a4d5438689936" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IGOR&lt;/strong&gt;: So think of directive as the instruction to the compiler that tells it whenever you come across this certain element or this CSS in the template, and you keep this kind of code and that code is in charge of the element and everything below that element in the DOM tree.</source>
          <target state="translated">&lt;strong&gt;IGOR&lt;/strong&gt; ：因此，可以将指令视为编译器的指令，当您在模板中遇到此特定元素或此CSS时便会告诉它，并保留此类代码，并且该代码负责该元素以及该元素下的所有内容在DOM树中。</target>
        </trans-unit>
        <trans-unit id="fb847df57ef2048ada827543b7b83275102b35c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ideal for &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; architecture:&lt;/strong&gt;
Being a complete frameworks makes AngularJS great to work with a RESTful architecture. To call REST CRUD APIs is very easier and</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt;体系结构的理想选择：&lt;/strong&gt;完整的框架使AngularJS非常适合与RESTful体系结构一起使用。 调用REST CRUD API非常容易，而且</target>
        </trans-unit>
        <trans-unit id="6db3ad18a3fcffc3e35affc669f632a630d17906" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you have some data and are now trying to update HTML... STOP! update the model, and make sure your HTML is bound to the model.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果您有一些数据，现在正尝试更新HTML，请停止！&lt;/strong&gt; &lt;strong&gt;更新模型，并确保您的HTML已绑定到模型。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a19b1a68f851522bd0cf824036f977b0867ca9fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Imperative vs Declarative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;命令式与声明式&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f010845158f0f95b6de7c77468721d2aacc26955" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MISKO&lt;/strong&gt;: [...] one of the things we thought about very hardly in Angular is, how do we provide lots of escape hatches so that you can get out and basically figure out a way out of this. So to us, the answer is this thing called &amp;ldquo;Directives&amp;rdquo;. &lt;strong&gt;And with directives, you essentially become a regular little jQuery JavaScript, you can do whatever you want.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MISKO&lt;/strong&gt; ：[...]我们在Angular中很少想到的一件事是，我们如何提供大量逃生舱口，以便您可以走出来并从根本上找出解决办法。 所以对我们来说，答案就是这个叫做&amp;ldquo;指令&amp;rdquo;的东西。 &lt;strong&gt;有了指令，您实际上就变成了普通的小型jQuery JavaScript，您可以做任何您想做的事情。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb2c2d380076a74aa03ad025fcf7629b16d2b1de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins extend jQuery. AngularJS Directives extend the capabilities of your browser.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;插件扩展了jQuery。&lt;/strong&gt; &lt;strong&gt;AngularJS指令扩展了浏览器的功能。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c47fced225128e4a144ce379fa468a4309c6e8e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins:&lt;/strong&gt;
There are many other similar features like showing an overlay in your app. You don't need to write code for it, just use an overlay plugin available as wc-overlay, and this will automatically take care of all &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; (XHR) requests.</source>
          <target state="translated">&lt;strong&gt;插件：&lt;/strong&gt;还有许多其他类似功能，例如在您的应用程序中显示覆盖图。 您无需为此编写代码，只需使用可作为wc-overlay使用的overlay插件，它将自动处理所有&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; （XHR）请求。</target>
        </trans-unit>
        <trans-unit id="887a0d220804750ef67bb7862fb203a7bd2bcb18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reusable directives are super:&lt;/strong&gt;
Write directives in one place and use it throughout the application. OMG!!! I used these directive for paging, regex, validations, etc. It is really cool!</source>
          <target state="translated">&lt;strong&gt;可重用指令是超级的：&lt;/strong&gt;在一个地方编写指令，并在整个应用程序中使用它。 我的天啊！！！ 我将这些指令用于分页，正则​​表达式，验证等。这真的很棒！</target>
        </trans-unit>
        <trans-unit id="f69a19e5ccd84c1031161d37ece994aed62fe59d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Routing is strong:&lt;/strong&gt;
It's up to your implementation how you want to use it, but it requires very few lines of code to route the request to specify HTML and controller (JavaScript)</source>
          <target state="translated">&lt;strong&gt;路由功能很强大：&lt;/strong&gt;取决于您的实现方式，但要用很少的代码行来路由请求以指定HTML和控制器（JavaScript）</target>
        </trans-unit>
        <trans-unit id="797f295648a2a0dbe2273589c1be293d5bfe525f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Services&lt;/strong&gt;: Write common codes using services and less code in controllers. Sevices can be used to share common functionalities among the controllers.</source>
          <target state="translated">&lt;strong&gt;服务&lt;/strong&gt; ：使用服务编写通用代码，而在控制器中编写更少的代码。 服务可用于在控制器之间共享通用功能。</target>
        </trans-unit>
        <trans-unit id="138e836a952df3aa65cdcd5ed6d0228190442e07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stop trying to drive your application from your JavaScript. Let the template drive the application, and let AngularJS take care of wiring the components together. This also is the Angular way.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;停止尝试从JavaScript驱动应用程序。&lt;/strong&gt; &lt;strong&gt;让模板驱动应用程序，让AngularJS负责将组件连接在一起。&lt;/strong&gt; &lt;strong&gt;这也是Angular方式。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fdb21836db9637198f74d2b8f19405107dec8dbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This means that Angular is Template Driven&lt;/strong&gt;. Your template drives the JavaScript, not the other way around. This is a radical reversal of roles, and the complete opposite of the unobtrusive JavaScript we have been writing for the last 10 years or so. This can take some getting used to.</source>
          <target state="translated">&lt;strong&gt;这意味着Angular是模板驱动的&lt;/strong&gt; 。 您的模板将驱动JavaScript，而不是相反。 这是角色的根本颠倒，这与我们近十年来一直在编写的不引人注目的JavaScript完全相反。 这可能需要一些时间来适应。</target>
        </trans-unit>
        <trans-unit id="20ab0f6802a5394aa105383981477201dead0b2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two-way data binding is amazing:&lt;/strong&gt; 
I had a grid with all functionality UPDATE, DELTE, INSERT. I have a data object that binds the grid's model using ng-repeat. You only need to write a single line of simple JavaScript code for delete and insert and that's it. grid automatically updates as the grid model changes instantly. Update functionality is real time, no code for it.
You feel amazing!!!</source>
          <target state="translated">&lt;strong&gt;双向数据绑定是惊人的：&lt;/strong&gt;我拥有一个具有所有功能UPDATE，DELTE，INSERT的网格。 我有一个使用ng-repeat绑定网格模型的数据对象。 您只需要编写一行简单的JavaScript代码即可进行删除和插入，仅此而已。 网格模型立即更改时，网格会自动更新。 更新功能是实时的，没有代码。 你感觉很棒！！！</target>
        </trans-unit>
        <trans-unit id="36ae55072d91b6ded3403dc2b4cad372aaa77444" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your HTML source is no longer semantic, instead, your API and compiled DOM are semantic.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTML源不再是语义的，而是API和已编译的DOM是语义的。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0ed9f7320d225087a2cabdd3049cfd766fead2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery&lt;/strong&gt; is a library</source>
          <target state="translated">&lt;strong&gt;jQuery&lt;/strong&gt;是一个库</target>
        </trans-unit>
        <trans-unit id="6c335564959dc2af53604b8909e474e66420b796" translate="yes" xml:space="preserve">
          <source>A nice thing about AngularJs is that it allows you to separate/isolate the DOM manipulation in the directives.  There are built-in directives ready for you to use such as ng-click. You can create your own custom directives that will contain all your view logic or DOM manipulation so you don't end up mingle DOM manipulation code in the controllers or services that should take care of the business logic.</source>
          <target state="translated">AngularJs的一个很好的地方是,它允许你在指令中分离DOM操作。有一些内置的指令可以供你使用,比如ng-click。你可以创建你自己的自定义指令,这些指令将包含你所有的视图逻辑或DOM操作,这样你就不会在控制器或服务中混杂着DOM操作代码,而这些代码应该是业务逻辑的一部分。</target>
        </trans-unit>
        <trans-unit id="7ceb5d7ed6945141f56ba005625ff024d9d7eb17" translate="yes" xml:space="preserve">
          <source>A transcript of the entire episode is available at the link provided above.</source>
          <target state="translated">全集的实录可在上面提供的链接中找到。</target>
        </trans-unit>
        <trans-unit id="b8f9a78d78001336ae3c83f2d488f8880d463909" translate="yes" xml:space="preserve">
          <source>Actually, if you're using AngularJS, you don't need jQuery anymore. AngularJS itself has the binding and directive, which is a very good &quot;replacement&quot; for most things you can do with jQuery.</source>
          <target state="translated">其实,如果你用的是AngularJS,你就不需要jQuery了。AngularJS本身就有绑定和指令,这对于你用jQuery可以做的大部分事情来说,是一个很好的 &quot;替代&quot;。</target>
        </trans-unit>
        <trans-unit id="a982e94ed93b338e6087c54069f224404ee9152d" translate="yes" xml:space="preserve">
          <source>Again, AngularJS does not play by their rules. In a stroke, &lt;strong&gt;AngularJS does away with a decade of received wisdom&lt;/strong&gt; and instead implements an MVC pattern in which the template is no longer semantic, not even a little bit.</source>
          <target state="translated">同样，AngularJS并不遵守他们的规则。 &lt;strong&gt;很快&lt;/strong&gt; ， &lt;strong&gt;AngularJS放弃了十年的智慧&lt;/strong&gt; ，而是实现了一种MVC模式，在该模式下，模板不再是语义，甚至不再是语义。</target>
        </trans-unit>
        <trans-unit id="dd4ee4af98c6fe65fb4b3c2b533d9c832398158d" translate="yes" xml:space="preserve">
          <source>Again, the template stuff is in the template, so you (or your users) can easily swap it out for one that meets any style necessary, and the &lt;strong&gt;logic&lt;/strong&gt; never had to be touched. Reusability - boom!</source>
          <target state="translated">同样，模板内容在模板中，因此您（或您的用户）可以轻松地将其替换为符合任何必要样式的样式，而无需触及&lt;strong&gt;逻辑&lt;/strong&gt; 。 可重用性-繁荣！</target>
        </trans-unit>
        <trans-unit id="1480b134e7c98fe4782ceaa71c1becda85bf1d42" translate="yes" xml:space="preserve">
          <source>Ajax all of the time</source>
          <target state="translated">Ajax一直以来都是这样</target>
        </trans-unit>
        <trans-unit id="7088908d0701fd67fecee7fd934804b9635f1eac" translate="yes" xml:space="preserve">
          <source>And I decided to make a tiny code snippet that help me quickly start a website using AngularJS with the power of jQuery Selector (using Sizzle).</source>
          <target state="translated">我决定做一个小小的代码片段,利用jQuery Selector(使用Sizzle)的强大功能,帮助我快速启动一个使用AngularJS的网站。</target>
        </trans-unit>
        <trans-unit id="b3c9932d142f6e1ee02747f1578184f1f2f6fc13" translate="yes" xml:space="preserve">
          <source>And all of the above tie into this over-arching theme: keep your concerns separate. Your view acts as the official record of what is supposed to happen (for the most part); your model represents your data; you have a service layer to perform reusable tasks; you do DOM manipulation and augment your view with directives; and you glue it all together with controllers. This was also mentioned in other answers, and the only thing I would add pertains to testability, which I discuss in another section below.</source>
          <target state="translated">而以上所有这些都与这个总的主题联系在一起:将你所关心的事情分开。你的视图作为应该发生的事情的官方记录(大部分情况下);你的模型代表你的数据;你有一个服务层来执行可重用的任务;你做DOM操作,用指令来增强你的视图;你用控制器将这一切粘合在一起。这一点在其他答案中也提到了,我唯一要补充的是关于可测试性,我在下面的另一节中讨论。</target>
        </trans-unit>
        <trans-unit id="717ce7322f7d359fabb874116d82f9a23af3a1cf" translate="yes" xml:space="preserve">
          <source>And fifth, which we've mentioned in previous sections, why are we mixing template stuff into our logic?</source>
          <target state="translated">第五,也就是我们在前面的章节中提到的,为什么我们要把模板的东西混入我们的逻辑中?</target>
        </trans-unit>
        <trans-unit id="31b7375227eaf487f50dd9c4d2a4be13432b0992" translate="yes" xml:space="preserve">
          <source>And now instead of using an unordered list, we're using Bootstrap alert boxes. And we never had to change the controller code! But more importantly, no matter &lt;em&gt;where&lt;/em&gt; or &lt;em&gt;how&lt;/em&gt; the log gets updated, the view will change too. Automatically. Neat!</source>
          <target state="translated">现在，我们使用了Bootstrap警报框，而不是使用无序列表。 而且，我们无需更改控制器代码！ 但更重要的是，无论&lt;em&gt;在何处&lt;/em&gt;或&lt;em&gt;如何&lt;/em&gt;更新日志，视图也会改变。 自动地。 整齐！</target>
        </trans-unit>
        <trans-unit id="ded1b56b02466779ad820433f366b36a1ad7629b" translate="yes" xml:space="preserve">
          <source>And our view can look like this:</source>
          <target state="translated">而我们的观点可以这样看。</target>
        </trans-unit>
        <trans-unit id="e0dec1075f573c8803a10203b7685e0ba502d0e0" translate="yes" xml:space="preserve">
          <source>And there are still all those other benefits, like testing - it's easy! No matter what's in the template, the directive's internal API is never touched, so refactoring is easy. You can change the template as much as you want without touching the directive. And no matter what you change, your tests still pass.</source>
          <target state="translated">而且还有其他所有这些好处,比如测试----很简单! 无论模板里有什么,指令的内部API永远不会被触动,所以重构很容易。你可以在不触及指令的情况下随意更改模板。而且无论你改变了什么,你的测试仍然可以通过。</target>
        </trans-unit>
        <trans-unit id="5bee056b415ffd9808306a38b2d56440081c0e20" translate="yes" xml:space="preserve">
          <source>And when we run our test, we can confirm that it fails. Only now should we create our directive:</source>
          <target state="translated">而当我们运行我们的测试时,我们可以确认它失败了。现在我们才应该创建我们的指令。</target>
        </trans-unit>
        <trans-unit id="180abb5e88521e466bf2e4475cd2b687c06483d9" translate="yes" xml:space="preserve">
          <source>And with DOM manipulation in AngularJS, you find yourself adding directives and filters, which you can think of as valid HTML extensions.</source>
          <target state="translated">而使用AngularJS中的DOM操作,你会发现自己添加了指令和过滤器,你可以把它们看作是有效的HTML扩展。</target>
        </trans-unit>
        <trans-unit id="24580187a4254fa76812f2d649f1e29d6069e0b9" translate="yes" xml:space="preserve">
          <source>Angular and jQuery do different things. AngularJS gives you a set of tools to produce web applications. jQuery mainly gives you tools for modifying the DOM. If jQuery is present on your page, AngularJS will use it automatically. If it isn't, AngularJS ships with jQuery Lite, which is a cut down, but still perfectly usable version of jQuery.</source>
          <target state="translated">Angular和jQuery的作用是不同的。AngularJS给你一套工具来制作Web应用程序,jQuery主要给你修改DOM的工具。如果你的页面上有jQuery,AngularJS会自动使用它。如果没有的话,AngularJS会提供jQuery Lite,这是jQuery的一个缩减版,但仍然完全可用。</target>
        </trans-unit>
        <trans-unit id="743831e45593d1d3b1984a6b44f8c8b5aff24099" translate="yes" xml:space="preserve">
          <source>Angular breaks down your app into 
- Controllers
- Services
- Views
- etc.</source>
          <target state="translated">Angular将你的应用分解成--控制器--服务--视图--等等。</target>
        </trans-unit>
        <trans-unit id="2a3de4a9dc7c9f3bd23b0b53226033777b1c013b" translate="yes" xml:space="preserve">
          <source>AngularJS</source>
          <target state="translated">AngularJS</target>
        </trans-unit>
        <trans-unit id="f39ebda33fdd6cea30fb3e03a8a2d79fcda3487a" translate="yes" xml:space="preserve">
          <source>AngularJS allows you to make your own HTML tags/attributes that do things which work well with dynamic web applications (since HTML was designed for static pages).</source>
          <target state="translated">AngularJS允许你制作你自己的HTML标签属性,这些属性可以很好地完成动态Web应用的工作(因为HTML是为静态页面设计的)。</target>
        </trans-unit>
        <trans-unit id="83ef7970ea8e67c4542f275b5fdabad15e691725" translate="yes" xml:space="preserve">
          <source>AngularJS and jQuery adopt very different ideologies. If you're coming from jQuery you may find some of the differences surprising. Angular may make you angry.</source>
          <target state="translated">AngularJS和jQuery采用了非常不同的理念。如果你是jQuery出身,你可能会发现其中的一些差异让人惊讶。Angular可能会让你感到愤怒。</target>
        </trans-unit>
        <trans-unit id="fc13641dffc4ac29f5a7e6fba2f371197f917be0" translate="yes" xml:space="preserve">
          <source>AngularJS and jQuery are not enemies. It's possible to use jQuery within AngularJS very nicely. If you're using AngularJS well (templates, data-binding, $scope, directives, etc.) you will find you need a &lt;strong&gt;lot&lt;/strong&gt; less jQuery than you might otherwise require.</source>
          <target state="translated">AngularJS和jQuery不是敌人。 可以在AngularJS中很好地使用jQuery。 如果您很好地使用了AngularJS（模板，数据绑定，$ scope，指令等），您会发现所需的jQuery比您可能需要的&lt;strong&gt;要&lt;/strong&gt;少得多。</target>
        </trans-unit>
        <trans-unit id="222ef2db3e23de37ca20387e96e35891b58e48cd" translate="yes" xml:space="preserve">
          <source>AngularJS changes the way you &lt;em&gt;find&lt;/em&gt; elements</source>
          <target state="translated">AngularJS改变了&lt;em&gt;查找&lt;/em&gt;元素的方式</target>
        </trans-unit>
        <trans-unit id="e1c2157022eaa4f2a0716583841f5203e08b070a" translate="yes" xml:space="preserve">
          <source>AngularJS comes with an entire set of tools to make this very easy; with &lt;code&gt;ngClass&lt;/code&gt; we can dynamically update the class; &lt;code&gt;ngModel&lt;/code&gt; allows two-way data binding; &lt;code&gt;ngShow&lt;/code&gt; and &lt;code&gt;ngHide&lt;/code&gt; programmatically show or hide an element; and many more - including the ones we write ourselves. In other words, we can do all kinds of awesomeness &lt;em&gt;without&lt;/em&gt; DOM manipulation. The less DOM manipulation, the easier directives are to test, the easier they are to style, the easier they are to change in the future, and the more re-usable and distributable they are.</source>
          <target state="translated">AngularJS附带了一整套工具，使这一过程变得非常容易。 使用 &lt;code&gt;ngClass&lt;/code&gt; ,我们可以动态更新类； &lt;code&gt;ngModel&lt;/code&gt; 允许双向数据绑定； &lt;code&gt;ngShow&lt;/code&gt; 和 &lt;code&gt;ngHide&lt;/code&gt; 以编程方式显示或隐藏元素； 还有更多-包括我们自己编写的内容。 换句话说，我们可以在&lt;em&gt;没有&lt;/em&gt; DOM操作的&lt;em&gt;情况下进行&lt;/em&gt;各种出色的工作。 DOM操作越少，指令的测试就越容易，指令的样式就越容易，将来更改就越容易，它们的重用性和可分发性就越高。</target>
        </trans-unit>
        <trans-unit id="8a1f9a965073fef341c41540c540b536642219de" translate="yes" xml:space="preserve">
          <source>AngularJS doesn't need (or want) you to find elements using selectors - the primary difference between AngularJS's &lt;strong&gt;jqLite&lt;/strong&gt; versus full-blown &lt;strong&gt;jQuery&lt;/strong&gt; is that &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.element&quot;&gt;jqLite does not support selectors&lt;/a&gt;.</source>
          <target state="translated">AngularJS不需要（也不希望）使用选择器来查找元素&lt;strong&gt;-AngularJS&lt;/strong&gt;的&lt;strong&gt;jqLit​​e&lt;/strong&gt;与成熟的&lt;strong&gt;jQuery&lt;/strong&gt;之间的主要区别是&lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.element&quot;&gt;jqLit​​e不支持选择器&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="d472a45e93868af2bd80d2ee2bab7981ad1a855e" translate="yes" xml:space="preserve">
          <source>AngularJS extends HTML, so you don't have to put &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; all over the place just to make an application. It makes HTML actually work for applications rather than what it was designed for, which is static, educational web pages. It accomplishes this in a roundabout way using JavaScript, but fundamentally it is an extension of HTML, not JavaScript.</source>
          <target state="translated">AngularJS扩展了HTML，因此您不必为了整个应用程序而在所有地方放置 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 。 它使HTML实际上可用于应用程序，而不是为静态的教育性网页设计的。 它使用JavaScript以一种about回的方式来完成此任务，但从根本上讲，它是HTML的扩展，而不是JavaScript。</target>
        </trans-unit>
        <trans-unit id="a790802605b2871a0ef2e9ba795618736b158088" translate="yes" xml:space="preserve">
          <source>AngularJS gives us service objects.</source>
          <target state="translated">AngularJS给了我们服务对象。</target>
        </trans-unit>
        <trans-unit id="580b72b69de2dbaa91260842ab501683adc90363" translate="yes" xml:space="preserve">
          <source>AngularJS gives you modules into which you can place your code. If you're writing a script that talks to Flickr for example, you might want to create a Flickr module to wrap all your Flickr related functions in. Modules can include other modules (DI). Your main application is usually a module, and this should include all the other modules your application will depend on.</source>
          <target state="translated">AngularJS为你提供了一些模块,你可以将代码放入其中。例如,如果你正在编写一个与Flickr对话的脚本,你可能会想创建一个Flickr模块来封装所有与Flickr相关的功能。模块可以包括其他模块(DI)。你的主应用程序通常是一个模块,这应该包括你的应用程序所依赖的所有其他模块。</target>
        </trans-unit>
        <trans-unit id="f5dbd7fd768f26aa68cfb19bda9fe60441f2e19f" translate="yes" xml:space="preserve">
          <source>AngularJS has $scope objects. These are special objects created and maintained by AngularJS in which you store your model. Certain directives will spawn a new $scope, which by default inherits from its wrapping $scope using JavaScript prototypical inheritance. The $scope object is accessible in the controller and the view.</source>
          <target state="translated">AngularJS有$scope对象。这些是由AngularJS创建和维护的特殊对象,你可以在其中存储你的模型。某些指令会产生一个新的$scope,默认情况下,该对象会使用JavaScript原型继承从其封装的$scope继承。$scope对象可以在控制器和视图中访问。</target>
        </trans-unit>
        <trans-unit id="3347e5a5c11ca76b8bae02225f867635154e1d18" translate="yes" xml:space="preserve">
          <source>AngularJS has the concept of &quot;Directives&quot; for DOM manipulation and designing reusable UI components, so you should use it whenever you feel the need of doing DOM manipulation related stuff (directives are only place where you should write jQuery code while using AngularJS).</source>
          <target state="translated">AngularJS有一个 &quot;Directives &quot;的概念,用于DOM操作和设计可重用的UI组件,所以当你觉得需要做DOM操作相关的事情时,就应该使用它(Directives是你在使用AngularJS时,只需要写jQuery代码的地方)。</target>
        </trans-unit>
        <trans-unit id="abb7d137ad0c0d41f229faf7978453fac70efa79" translate="yes" xml:space="preserve">
          <source>AngularJS instead gives you a &lt;strong&gt;compiler&lt;/strong&gt;.</source>
          <target state="translated">AngularJS却为您提供了一个&lt;strong&gt;编译器&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f454c455626fe5cac16b1e78b3064e9efba3a1f4" translate="yes" xml:space="preserve">
          <source>AngularJS involves some learning curve (more than jQuery :-).</source>
          <target state="translated">AngularJS涉及到一些学习曲线(比jQuery更多)。</target>
        </trans-unit>
        <trans-unit id="0f33f894c7aeb275ff7e26043faaaba6c9273c31" translate="yes" xml:space="preserve">
          <source>AngularJS is an MV* framework.</source>
          <target state="translated">AngularJS是一个MV*框架。</target>
        </trans-unit>
        <trans-unit id="496acda8671b0ee67088cb637f1c89eb97cd852d" translate="yes" xml:space="preserve">
          <source>AngularJS is an entire client-side framework that uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; pattern (check out their &lt;a href=&quot;http://docs.angularjs.org/guide/concepts&quot;&gt;graphical representation&lt;/a&gt;). It greatly focuses on separation of concerns.</source>
          <target state="translated">AngularJS是使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt;模式的完整客户端框架（请查看其&lt;a href=&quot;http://docs.angularjs.org/guide/concepts&quot;&gt;图形表示&lt;/a&gt; ）。 它极大地侧重于关注点分离。</target>
        </trans-unit>
        <trans-unit id="ccc498700b07180690b810f63f70291230b83439" translate="yes" xml:space="preserve">
          <source>AngularJS itself includes a jQuery-lite edition within it. So for some basic DOM selection/manipulation, you really don't have to include the jQuery library (it saves many bytes to run on the network.)</source>
          <target state="translated">AngularJS本身就包含了一个jQuery-lite版。所以对于一些基本的DOM选择操纵,你真的不需要包含jQuery库(在网络上运行可以节省很多字节)。</target>
        </trans-unit>
        <trans-unit id="f8eb1469e26f56c8a74bfdb88d4142545826f06f" translate="yes" xml:space="preserve">
          <source>AngularJS manages your dependencies for you. If you want an object, simply refer to it and AngularJS will get it for you.</source>
          <target state="translated">AngularJS为你管理你的依赖关系。如果你想要一个对象,只需引用它,AngularJS就会帮你得到它。</target>
        </trans-unit>
        <trans-unit id="38dffc5e5dca986ffefa44052bb0ef43d021e403" translate="yes" xml:space="preserve">
          <source>AngularJS uses &lt;strong&gt;controllers&lt;/strong&gt; and directives (each of which can have their own controller, and/or compile and linking functions) to remove behavior from the view/structure (HTML).  Angular also has &lt;strong&gt;services&lt;/strong&gt; and &lt;strong&gt;filters&lt;/strong&gt; to help separate/organize your application.</source>
          <target state="translated">AngularJS使用&lt;strong&gt;控制器&lt;/strong&gt;和指令（每个&lt;strong&gt;控制器&lt;/strong&gt;和指令都可以具有自己的控制器和/或编译和链接功能）从视图/结构（HTML）中删除行为。 Angular还提供&lt;strong&gt;服务&lt;/strong&gt;和&lt;strong&gt;过滤器，&lt;/strong&gt;以帮助分离/组织您的应用程序。</target>
        </trans-unit>
        <trans-unit id="427ca6be55cbd36d29b597716cd026cabed3d117" translate="yes" xml:space="preserve">
          <source>AngularJS vs. jQuery</source>
          <target state="translated">AngularJS vs.jQuery</target>
        </trans-unit>
        <trans-unit id="209303f007b14469938fa3242370f0eed9fe6b7f" translate="yes" xml:space="preserve">
          <source>AngularJS will recognise that a FlickrService object is needed to instantiate the controller, and will provide one for us.</source>
          <target state="translated">AngularJS会识别出需要一个FlickrService对象来实例化控制器,并为我们提供一个。</target>
        </trans-unit>
        <trans-unit id="89fd96e13c335779cf18929ce0e49db544e7b95a" translate="yes" xml:space="preserve">
          <source>AngularJS: THE model is the truth, and you always think from that ANGLE.</source>
          <target state="translated">AngularJS:模型就是真理,你总是从这个角度去思考。</target>
        </trans-unit>
        <trans-unit id="3bef657357e40dc720fc2a1d5a9a5e5e4d968b2d" translate="yes" xml:space="preserve">
          <source>AngularJs Cool Principle - If you want some changes on your UI think from model data change perspective. Change your data and UI will re-render itself. You need not to play around DOM each time unless and until it is hardly required and that should also be handled through Angular Directives.</source>
          <target state="translated">AngularJs 酷炫原理----如果你想在UI上做一些改变,可以从改变模型数据的角度来思考。改变你的数据,UI会自己重新渲染。你不需要每次都玩弄DOM,除非直到几乎不需要,这也应该通过Angular指令来处理。</target>
        </trans-unit>
        <trans-unit id="4c7fa873dad04f6b1ea51f0bb4c021ea8dae7e48" translate="yes" xml:space="preserve">
          <source>AngularJs and JQuery are completely different at every level except the JQLite functionality and you will see it once you start learning the AngularJs core features (I explained it below).</source>
          <target state="translated">AngularJs和JQuery除了JQLite的功能外,其他每个层面都完全不同,一旦你开始学习AngularJs的核心功能,你就会发现它(我在下面解释过)。</target>
        </trans-unit>
        <trans-unit id="3edbcd2b0fe8f2eeb3060452cd16d0c33d77cc16" translate="yes" xml:space="preserve">
          <source>AngularJs is a client side framework that offers to build the independent client side application. JQuery is a client side library that play around the DOM.</source>
          <target state="translated">AngularJs是一个客户端框架,它提供了构建独立的客户端应用程序。JQuery是一个玩转DOM的客户端库。</target>
        </trans-unit>
        <trans-unit id="5239585f0407322b9de9420fc353533aa0b142a9" translate="yes" xml:space="preserve">
          <source>Apart from mixing concerns, we also have the same problems of signifying intent that I mentioned before. But more importantly, we had to manually reference and update a DOM node. And if we want to delete a log entry, we have to code against the DOM for that too. How do we test the logic apart from the DOM? And what if we want to change the presentation?</source>
          <target state="translated">除了混合的问题外,我们还遇到了我之前提到的表示意图的问题。但更重要的是,我们不得不手动引用和更新一个DOM节点。而如果我们想删除一个日志条目,我们也必须针对DOM进行编码。除了DOM之外,我们该如何测试逻辑呢?如果我们想改变呈现方式,又该怎么办?</target>
        </trans-unit>
        <trans-unit id="4887e453b680689b4f5edbe3a009b399e0a9cd5f" translate="yes" xml:space="preserve">
          <source>Application design</source>
          <target state="translated">应用设计</target>
        </trans-unit>
        <trans-unit id="390be301a8114b068b77d68bc38caf2bb1d0d455" translate="yes" xml:space="preserve">
          <source>Are there any server-side considerations/restrictions?</source>
          <target state="translated">是否有服务器端的考虑限制?</target>
        </trans-unit>
        <trans-unit id="664c60d57cb407ffa5cf65a1d3cbd40930f03f80" translate="yes" xml:space="preserve">
          <source>As a JavaScript MV* beginner and purely focusing on the application architecture (not the server/client-side matters), I would certainly recommend the following resource (which I am surprised wasn't mentioned yet): &lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;JavaScript Design Patterns&lt;/a&gt;, by Addy Osmani, as an introduction to different &lt;strong&gt;JavaScript Design Patterns&lt;/strong&gt;. The terms used in this answer are taken from the linked document above. I'm not going to repeat what was worded really well in the accepted answer. Instead, this answer links back to the &lt;strong&gt;theoretical backgrounds&lt;/strong&gt; which power AngularJS (and other libraries).</source>
          <target state="translated">作为JavaScript MV *的初学者，并且只专注于应用程序体系结构（而不​​是服务器/客户端问题），我当然会推荐以下资源（我还没有提到它很惊讶）： &lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;JavaScript设计模式&lt;/a&gt; ，作者：Addy Osmani ，介绍不同的&lt;strong&gt;JavaScript设计模式&lt;/strong&gt; 。 该答案中使用的术语取自上面的链接文档。 我不会在已接受的答案中重复非常好的措词。 相反，此答案可以链接到为AngularJS（和其他库）提供支持的&lt;strong&gt;理论背景&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="23a7327c34c86abe93b30fb5462eaf583c740d8f" translate="yes" xml:space="preserve">
          <source>At this point you likely have all sorts of questions concerning &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt; and accessibility, and rightly so. There are open issues here. Most screen readers will now parse JavaScript. Search engines can also index &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;AJAXed&lt;/a&gt; content. Nevertheless, you will want to make sure you are using pushstate URLs and you have a decent sitemap. See here for a discussion of the issue: &lt;a href=&quot;https://stackoverflow.com/a/23245379/687677&quot;&gt;https://stackoverflow.com/a/23245379/687677&lt;/a&gt;</source>
          <target state="translated">在这一点上，您可能会遇到有关&lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt;和可访问性的各种问题，这是正确的。 这里有未解决的问题。 现在，大多数屏幕阅读器都会解析JavaScript。 搜索引擎还可以索引&lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;AJAX&lt;/a&gt;内容。 不过，您将需要确保使用的是pushstate URL，并且您拥有一个不错的站点地图。 请参阅此处以获取有关该问题的讨论： &lt;a href=&quot;https://stackoverflow.com/a/23245379/687677&quot;&gt;https&lt;/a&gt; : //stackoverflow.com/a/23245379/687677</target>
        </trans-unit>
        <trans-unit id="e64cce4dacf87903542cb264297ae0a879e80ca7" translate="yes" xml:space="preserve">
          <source>Attach a controller to each view (using ng-view and routing, or ng-controller). Have the controller find/get only whatever model data the view needs to do its job. Make controllers as thin as possible.</source>
          <target state="translated">给每个视图附加一个控制器(使用ng-view和路由,或者ng-controller)。让控制器只找到视图所需要的模型数据来完成它的工作。让控制器尽可能的薄一些。</target>
        </trans-unit>
        <trans-unit id="4988689ec96d69654ac1b4d26595c58327121e0c" translate="yes" xml:space="preserve">
          <source>Because AngularJS treats your HTML page as a template. The template is not supposed to be semantic as your content is typically stored in your model which ultimately comes from your API. AngularJS compiles your DOM with the model to produce a semantic web page.</source>
          <target state="translated">因为AngularJS把你的HTML页面当作一个模板来处理。模板不应该是语义的,因为你的内容通常存储在你的模型中,而模型最终来自于你的API。AngularJS将你的DOM与模型编译成语义网页。</target>
        </trans-unit>
        <trans-unit id="52ff735af719db7308ce1da781ad856d29790080" translate="yes" xml:space="preserve">
          <source>Because data binding is done from the template, using either an attribute or the curly brace syntax, it's super easy to do. There's little cognitive overhead associated with it so you'll find yourself doing it all the time.</source>
          <target state="translated">因为数据绑定是在模板中完成的,使用属性或大括号语法,所以超级容易做。几乎没有什么认知上的开销,所以你会发现自己一直都在做。</target>
        </trans-unit>
        <trans-unit id="da1f91ccd2cdc9e39f69ad5bd7c07fde87791168" translate="yes" xml:space="preserve">
          <source>Being a framework, it hosts your code and takes ownership of decisions about what to call and when!</source>
          <target state="translated">作为一个框架,它承载着你的代码,并掌握着关于调用什么和何时调用的决定权!</target>
        </trans-unit>
        <trans-unit id="1ede8f40530371ca2072fafa529a4af2b37e9ba1" translate="yes" xml:space="preserve">
          <source>Binds the input element to &lt;code&gt;$scope.user.name&lt;/code&gt;. Updating the input will update the value in your current scope, and vice-versa.</source>
          <target state="translated">将输入元素绑定到 &lt;code&gt;$scope.user.name&lt;/code&gt; 。 更新输入将更新当前作用域中的值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="723820bab62fc4cc602aaa7c4690e3b306e0a88e" translate="yes" xml:space="preserve">
          <source>But because we have separation of concerns, we can do test-driven development iteratively in AngularJS! For example, let's say we want a super-simple directive to indicate in our menu what our current route is. We can declare what we want in the view of our application:</source>
          <target state="translated">但是因为我们有了分离关注点,所以我们可以在AngularJS中进行测试驱动的开发迭代! 举个例子,假设我们想要一个超级简单的指令,在我们的菜单中指出我们当前的路径是什么。我们可以在我们的应用程序的视图中声明我们想要什么。</target>
        </trans-unit>
        <trans-unit id="ce753a2c6da077456572ab747e44d38ca49b9bd8" translate="yes" xml:space="preserve">
          <source>But for that matter, our view could look like this:</source>
          <target state="translated">但就这一点来说,我们的观点可能是这样的。</target>
        </trans-unit>
        <trans-unit id="05e4f17ec22790979e0e74231b4a9712ba108795" translate="yes" xml:space="preserve">
          <source>But in AngularJS, you must start from the ground up with your architecture in mind. Instead of starting by thinking &quot;I have this piece of the DOM and I want to make it do X&quot;, you have to start with what you want to accomplish, then go about designing your application, and then finally go about designing your view.</source>
          <target state="translated">但在AngularJS中,你必须从头开始,从你的架构出发,考虑到你的架构。不要一开始就想着 &quot;我有这块DOM,我要让它做X&quot;,而是要从你想完成的事情开始,然后去设计你的应用,最后去设计你的视图。</target>
        </trans-unit>
        <trans-unit id="706cdc463699e1ed474fcbc74dc48ab1f144a5d9" translate="yes" xml:space="preserve">
          <source>But let's dive a little deeper...</source>
          <target state="translated">但让我们再深入一点......</target>
        </trans-unit>
        <trans-unit id="d00b45211d6f5e02dbf9930e954ca044f2728901" translate="yes" xml:space="preserve">
          <source>By googling, I see that there is a standalone jQuery selector module out there. It's Sizzle.</source>
          <target state="translated">通过googling,我看到外面有一个独立的jQuery selector模块。它就是Sizzle。</target>
        </trans-unit>
        <trans-unit id="75ed687c979f0bd97e2a3c3bf1ba2c8068f3c723" translate="yes" xml:space="preserve">
          <source>CSS - Styling, without the CSS the page is still readable.</source>
          <target state="translated">CSS-Styling,如果没有CSS,页面仍然可以阅读。</target>
        </trans-unit>
        <trans-unit id="5fbb684c9310c39e4a515fe80a2bcaad03a97701" translate="yes" xml:space="preserve">
          <source>Can you describe the paradigm shift that is necessary?</source>
          <target state="translated">你能描述一下范式的转变是必要的吗?</target>
        </trans-unit>
        <trans-unit id="fc22be49056528fdaa6e3e976f7e5c0875c0ea23" translate="yes" xml:space="preserve">
          <source>Closure vs. $scope</source>
          <target state="translated">封闭与$scope</target>
        </trans-unit>
        <trans-unit id="35313dc9f2a46f49b61938e95da8ca20b23eaa38" translate="yes" xml:space="preserve">
          <source>Controller - Your controller is a JavaScript function which hooks the view to the model. Its function is to initialise $scope. Depending on your application, you may or may not need to create a controller. You can have many controllers on a page.</source>
          <target state="translated">Controller-你的控制器是一个JavaScript函数,它将视图与模型挂钩。它的功能是初始化$scope。根据你的应用,你可能需要或不需要创建一个控制器。你可以在一个页面上有很多控制器。</target>
        </trans-unit>
        <trans-unit id="38e5b6c1d5bdd30cd076016ffcf63fb6a6fe8ba7" translate="yes" xml:space="preserve">
          <source>Controllers and providers (services, factories, etc.) are for modifying the data model, NOT HTML.</source>
          <target state="translated">控制器和提供者(服务、工厂等)是用来修改数据模型的,而不是HTML。</target>
        </trans-unit>
        <trans-unit id="8190947945a5d101ce34179f8d52d23951e48521" translate="yes" xml:space="preserve">
          <source>DI means that instead of writing your application and wiring it together, you instead define a library of components, each identified by a string.</source>
          <target state="translated">DI的意思是,你不需要编写你的应用程序并把它连在一起,而是定义一个组件库,每个组件由一个字符串标识。</target>
        </trans-unit>
        <trans-unit id="d38cca5da9c7df446a12182ab09218cd420e4017" translate="yes" xml:space="preserve">
          <source>Data binding</source>
          <target state="translated">数据绑定</target>
        </trans-unit>
        <trans-unit id="abe361ec5ac92ab2b51436412eccfc4c617ee10a" translate="yes" xml:space="preserve">
          <source>Dependency injection</source>
          <target state="translated">依赖性注入</target>
        </trans-unit>
        <trans-unit id="b4834f95740149caa4ab7c7998c3085a73d25833" translate="yes" xml:space="preserve">
          <source>Developers new to AngularJS often ask a question like: how do I find all links of a specific kind and add a directive onto them. The developer is always flabbergasted when we reply: you don't. But the reason you don't do that is that this is like half-jQuery, half-AngularJS, and no good. The problem here is that the developer is trying to &quot;do jQuery&quot; in the context of AngularJS. That's never going to work well. The view &lt;em&gt;is&lt;/em&gt; the official record. Outside of a directive (more on this below), you never, ever, &lt;em&gt;never&lt;/em&gt; change the DOM. And directives are applied &lt;em&gt;in the view&lt;/em&gt;, so intent is clear.</source>
          <target state="translated">刚接触AngularJS的开发人员经常会提出这样的问题：如何找到特定种类的所有链接并向它们添加指令。 当我们回复时，开发人员总是为之震惊：您没有。 但是，您不这样做的原因是，这就像一半的jQuery，一半的AngularJS，并且没有好处。 这里的问题是开发人员试图在AngularJS上下文中&amp;ldquo;执行jQuery&amp;rdquo;。 那永远行不通。 该视图&lt;em&gt;是&lt;/em&gt;官方记录。 在指令之外（请参见下文），您永远&lt;em&gt;不会&lt;/em&gt;更改DOM。 并且&lt;em&gt;在视图&lt;/em&gt;中应用&lt;em&gt;了&lt;/em&gt;指令，因此意图很明确。</target>
        </trans-unit>
        <trans-unit id="53d7a9d92573e089ff93413770ae30c25ee69d14" translate="yes" xml:space="preserve">
          <source>Directives can then in turn pull in additional Angular components such as controllers, services, etc. What comes out the bottom of the compiler is a fully formed web application, wired up and ready to go.</source>
          <target state="translated">然后指令可以反过来拉入额外的Angular组件,如控制器、服务等。从编译器底部出来的是一个完整的Web应用程序,它是一个完整的Web应用程序,已经安装好了,可以使用了。</target>
        </trans-unit>
        <trans-unit id="6e07f7c559632d31618e542f4fc425e25f0611c0" translate="yes" xml:space="preserve">
          <source>Distinct model layer</source>
          <target state="translated">区分模型层</target>
        </trans-unit>
        <trans-unit id="7d3e17491190e7a5dea94490347df028a3f9aa5e" translate="yes" xml:space="preserve">
          <source>Doing so will allow you to leverage their &lt;a href=&quot;http://docs.angularjs.org/api/ngResource.$resource&quot;&gt;resource factory&lt;/a&gt;, which creates an abstraction of your server side RESTful &lt;a href=&quot;http://en.wikipedia.org/wiki/Application_programming_interface&quot;&gt;API&lt;/a&gt; and makes server-side calls (get, save, delete, etc.) incredibly easy.</source>
          <target state="translated">这样做将允许您利用他们的&lt;a href=&quot;http://docs.angularjs.org/api/ngResource.$resource&quot;&gt;资源工厂&lt;/a&gt; ，这将创建服务器端RESTful &lt;a href=&quot;http://en.wikipedia.org/wiki/Application_programming_interface&quot;&gt;API&lt;/a&gt;的抽象，并使服务器端调用（获取，保存，删除等）变得异常简单。</target>
        </trans-unit>
        <trans-unit id="9fac905701ef3b0097c8764804ad3e59dbd915f9" translate="yes" xml:space="preserve">
          <source>Don't even use jQuery. Don't even include it. It will hold you back. And when you come to a problem that you think you know how to solve in jQuery already, before you reach for the &lt;code&gt;$&lt;/code&gt;, try to think about how to do it within the confines the AngularJS. If you don't know, ask! 19 times out of 20, the best way to do it doesn't need jQuery and to try to solve it with jQuery results in more work for you.</source>
          <target state="translated">甚至不使用jQuery。 甚至不包含它。 它会让你退缩。 当您遇到问题时，您认为自己已经知道如何在jQuery中解决，在达到 &lt;code&gt;$&lt;/code&gt; 之前 ，请尝试考虑如何在AngularJS范围内解决该问题。 如果您不知道，请询问！ 20的19倍中，最好的方法不需要jQuery，并尝试使用jQuery解决它会为您带来更多工作。</target>
        </trans-unit>
        <trans-unit id="2c79c2f8fe6cef139b77391f6699a0512a187188" translate="yes" xml:space="preserve">
          <source>Edit:</source>
          <target state="translated">Edit:</target>
        </trans-unit>
        <trans-unit id="22b7ff6e8b6f6df26b8528e8d5a05b683dda1ec4" translate="yes" xml:space="preserve">
          <source>First know that &lt;a href=&quot;http://en.wikipedia.org/wiki/Single-page_application&quot;&gt;single-page applications&lt;/a&gt; are &lt;em&gt;applications&lt;/em&gt;. They're &lt;em&gt;not&lt;/em&gt; webpages. So we need to think like a server-side developer &lt;em&gt;in addition&lt;/em&gt; to thinking like a client-side developer. We have to think about how to divide our application into individual, extensible, testable components.</source>
          <target state="translated">首先知道&lt;a href=&quot;http://en.wikipedia.org/wiki/Single-page_application&quot;&gt;单页应用程序&lt;/a&gt;是&lt;em&gt;application&lt;/em&gt; 。 它们&lt;em&gt;不是&lt;/em&gt;网页。 因此&lt;em&gt;，除了&lt;/em&gt;像客户端开发人员那样思考&lt;em&gt;之外&lt;/em&gt; ，我们还需要像服务器端开发人员&lt;em&gt;那样&lt;/em&gt;思考。 我们必须考虑如何将应用程序划分为各个可扩展的可测试组件。</target>
        </trans-unit>
        <trans-unit id="395a4b3bfca26bc0f15e623275df885c5164cd6a" translate="yes" xml:space="preserve">
          <source>First up, Angular doesn't replace jQuery</source>
          <target state="translated">首先,Angular并不能取代jQuery。</target>
        </trans-unit>
        <trans-unit id="2bd966a54c73aaa3f249cccf1a9fc029ccf3efc7" translate="yes" xml:space="preserve">
          <source>First, jQuery was never necessary. There's nothing we did here that needed jQuery at all!</source>
          <target state="translated">首先,jQuery从来没有必要。我们在这里做的事情根本就不需要jQuery!</target>
        </trans-unit>
        <trans-unit id="900191e8f993958a06b036ac65d730e1bdaa6073" translate="yes" xml:space="preserve">
          <source>For a view that looks like this:</source>
          <target state="translated">对于像这样的景色。</target>
        </trans-unit>
        <trans-unit id="2e2c9d3bdb321bac05780afd95a48bfce104b09e" translate="yes" xml:space="preserve">
          <source>For example, here I define a service:</source>
          <target state="translated">比如说,这里我定义了一个服务。</target>
        </trans-unit>
        <trans-unit id="de3e20808c116384b0a4b03719bffd49cb190884" translate="yes" xml:space="preserve">
          <source>For example, if you want a carousel on your page, you might define an unordered list of figures, perhaps wrapped in a nav element. You might then write some jQuery to select the list on the page and restyle it as a gallery with timeouts to do the sliding animation.</source>
          <target state="translated">例如,如果你想在你的页面上有一个旋转木马,你可以定义一个无序的数字列表,或许可以用导航元素包裹起来。然后你可以写一些jQuery来选择页面上的列表,并将其重塑为一个带超时的图库来做滑动动画。</target>
        </trans-unit>
        <trans-unit id="991573402c0940207e9bacdb158be6295096e397" translate="yes" xml:space="preserve">
          <source>For example, when you get data from THE server which you intend to display in some format in the DOM, in jQuery, you need to '1. FIND' where in the DOM you want to place this data, the '2. UPDATE/APPEND' it there by creating a new node or just setting its &lt;a href=&quot;http://www.tizag.com/javascriptT/javascript-innerHTML.php&quot;&gt;innerHTML&lt;/a&gt;. Then when you want to update this view, you then '3. FIND' the location and '4. UPDATE'. This cycle of find and update all done within the same context of getting and formatting data from server is gone in AngularJS.</source>
          <target state="translated">例如，当您从THE Server获取要以某种格式在DOM中显示的数据时，在jQuery中，您需要将其设置为'1。 在DOM中要放置此数据的位置找到&amp;ldquo; 2&amp;rdquo;。 通过创建一个新节点或仅设置其&lt;a href=&quot;http://www.tizag.com/javascriptT/javascript-innerHTML.php&quot;&gt;innerHTML来进行&lt;/a&gt; &amp;ldquo;更新/添加&amp;rdquo;。 然后，当您要更新此视图时，请输入'3。 查找位置，然后单击&amp;ldquo; 4&amp;rdquo;。 更新&amp;rdquo;。 AngularJS中没有在从服务器获取和格式化数据的同一上下文中完成所有查找和更新的循环。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="850a95bbb6dd76741f2f32607f4ef86792316738" translate="yes" xml:space="preserve">
          <source>Fourth, closely related to the third, is that jqLite elements needn't be wrapped in &lt;code&gt;$&lt;/code&gt; - the &lt;code&gt;element&lt;/code&gt; that is passed to the &lt;code&gt;link&lt;/code&gt; function would &lt;em&gt;already be&lt;/em&gt; a jQuery element!</source>
          <target state="translated">第四，与第三个紧密相关，是jqLit​​e元素不需要用 &lt;code&gt;$&lt;/code&gt; 包裹-传递给 &lt;code&gt;link&lt;/code&gt; 函数的元素&lt;em&gt;已经是&lt;/em&gt; jQuery元素！</target>
        </trans-unit>
        <trans-unit id="e937a7317ee9e666605382e9345fe01e5e87523e" translate="yes" xml:space="preserve">
          <source>From a broad perspective, DI means that you can declare components very freely and then from any other component, just ask for an instance of it and it will be granted. You don't have to know about loading order, or file locations, or anything like that. The power may not immediately be visible, but I'll provide just one (common) example: testing.</source>
          <target state="translated">从广义上讲,DI意味着你可以非常自由地声明组件,然后从任何其他组件中,只要要求它的实例就会被授予。你不需要知道加载顺序,或者文件位置之类的东西。这个能力可能不会立刻显现出来,但我只提供一个(常见的)例子:测试。</target>
        </trans-unit>
        <trans-unit id="70376458c7e1d59978b45b6a33d1a41e52fb91db" translate="yes" xml:space="preserve">
          <source>Good luck.</source>
          <target state="translated">祝你们好运。</target>
        </trans-unit>
        <trans-unit id="a27f0fe6a21c158932ddc9c6ab32b680263c7a6e" translate="yes" xml:space="preserve">
          <source>HTML - Semantic meaning. The HTML should stand alone.</source>
          <target state="translated">HTML-语义。HTML应该是独立的。</target>
        </trans-unit>
        <trans-unit id="c5340e7474927e0f273d76b88c2f86f9341fb5de" translate="yes" xml:space="preserve">
          <source>HTML and directives define the layout and binding to the model.</source>
          <target state="translated">HTML和指令定义了模型的布局和绑定。</target>
        </trans-unit>
        <trans-unit id="7602bdeaf94c8c4d20e603fafd1c75516db6e8a6" translate="yes" xml:space="preserve">
          <source>Here's a quick example that shows the pattern I see most frequently. We want a toggleable button. (Note: this example is a little contrived and a skosh verbose to represent more complicated cases that are solved in exactly the same way.)</source>
          <target state="translated">下面是一个快速的例子,展示了我最常看到的模式。我们希望有一个可切换的按钮。(注意:这个例子有点夸张,而且有点夸张,是为了表示更复杂的情况,而这些情况的解决方式完全相同。)</target>
        </trans-unit>
        <trans-unit id="1b872c0b8b5cb91fbb546831e6921db7d5087ecd" translate="yes" xml:space="preserve">
          <source>How do I architect and design client-side web applications differently? What is the biggest difference?</source>
          <target state="translated">如何架构和设计客户端Web应用的不同?最大的区别是什么?</target>
        </trans-unit>
        <trans-unit id="9ff77b581f89f632f34713ccc81664a4f91cf1b8" translate="yes" xml:space="preserve">
          <source>How do I architect and design client-side web apps differently?</source>
          <target state="translated">如何架构和设计客户端的web应用,如何区别对待?</target>
        </trans-unit>
        <trans-unit id="8456215573486aa4c8df48dde90555787930b6c5" translate="yes" xml:space="preserve">
          <source>I find this question interesting, because my first serious exposure to JavaScript programming was &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; and AngularJS. I never learned jQuery, and I guess that's a good thing, because I don't have to unlearn anything. In fact, I actively avoid jQuery solutions to my problems, and instead, solely look for an &quot;AngularJS way&quot; to solve them. So, I guess my answer to this question would essentially boil down to, &quot;think like someone who never learned jQuery&quot; and avoid any temptation to incorporate jQuery directly (obviously AngularJS uses it to some extent behind the scenes).</source>
          <target state="translated">我发现这个问题很有趣，因为我最先接触JavaScript编程的是&lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt;和AngularJS。 我从来没有学过jQuery，我想那是一件好事，因为我不必学习任何东西。 实际上，我积极地避免了针对我的问题的jQuery解决方案，而是仅寻找&amp;ldquo; AngularJS方式&amp;rdquo;来解决它们。 因此，我想我对这个问题的回答本质上可以归结为&amp;ldquo;像从未学习过jQuery的人一样思考&amp;rdquo;，并避免了直接集成jQuery的任何诱惑（显然AngularJS在后台使用了它）。</target>
        </trans-unit>
        <trans-unit id="efb9e3de8580d4d388e6d1d2c1128365fcee76cb" translate="yes" xml:space="preserve">
          <source>I found it easier also, to test &lt;strong&gt;(1)&lt;/strong&gt; native JavaScript code and &lt;strong&gt;(2)&lt;/strong&gt; smaller libraries for each one of these patterns &lt;strong&gt;separately&lt;/strong&gt; before diving into one global framework. This allowed me to better understand which crucial issues a framework adresses (because you are personally faced with the problem).</source>
          <target state="translated">我发现，在进入一个全局框架之前，分别测试&lt;strong&gt;（1）&lt;/strong&gt;本机JavaScript代码和&lt;strong&gt;（2）&lt;/strong&gt;这些模式中的每个模式的较小库也更加容易。 这使我可以更好地了解框架解决了哪些关键问题（因为您亲自面对该问题）。</target>
        </trans-unit>
        <trans-unit id="0f5fdb791dc830db0312c3e805b978f9fee42e94" translate="yes" xml:space="preserve">
          <source>I got so excited about AngularJS, I wrote a short book on it which you're very welcome to read online &lt;a href=&quot;http://nicholasjohnson.com/angular-book/&quot;&gt;http://nicholasjohnson.com/angular-book/&lt;/a&gt;. I hope it's helpful.</source>
          <target state="translated">我对AngularJS感到非常兴奋，我为此写了一本简短的书，非常欢迎您在线阅读&lt;a href=&quot;http://nicholasjohnson.com/angular-book/&quot;&gt;http://nicholasjohnson.com/angular-book/&lt;/a&gt; 。 希望对您有所帮助。</target>
        </trans-unit>
        <trans-unit id="cff209bb9bc1c566d085c39c77af21c5738cf6e4" translate="yes" xml:space="preserve">
          <source>I heard from a meetup I attended, one of the founders of Angular said they worked really hard to separate out the DOM manipulation so do not try to include them back in.</source>
          <target state="translated">我从我参加的一次聚会上听到,Angular的创始人之一说,他们真的很努力地把DOM操作分开来,所以不要试图把他们重新纳入进来。</target>
        </trans-unit>
        <trans-unit id="b1cc19c6fa446f86e199536080332bbd9a86f525" translate="yes" xml:space="preserve">
          <source>I see lots of developers new to AngularJS using directives as the place to throw a bunch of jQuery. In other words, they think &quot;since I can't do DOM manipulation in the controller, I'll take that code put it in a directive&quot;. While that certainly is much better, it's often &lt;em&gt;still wrong&lt;/em&gt;.</source>
          <target state="translated">我看到很多使用指令作为投掷jQuery的地方的AngularJS新手。 换句话说，他们认为&amp;ldquo;由于我无法在控制器中进行DOM操作，因此我会将代码放入指令中&amp;rdquo;。 虽然这肯定好得多，但通常&lt;em&gt;仍然是错误的&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc523ff786c336f7206f714e0c729f9f96a4ee5f" translate="yes" xml:space="preserve">
          <source>I shared my code here: &lt;a href=&quot;https://github.com/huytd/Sizzular&quot;&gt;https://github.com/huytd/Sizzular&lt;/a&gt;</source>
          <target state="translated">我在这里分享了我的代码： &lt;a href=&quot;https://github.com/huytd/Sizzular&quot;&gt;https&lt;/a&gt; : //github.com/huytd/Sizzular</target>
        </trans-unit>
        <trans-unit id="59b381689432e88b63f12501377e65b7661e38f1" translate="yes" xml:space="preserve">
          <source>I usually develop mobile applications using AngularJS and &lt;a href=&quot;http://en.wikipedia.org/wiki/PhoneGap&quot;&gt;Cordova&lt;/a&gt;. The ONLY thing from jQuery I needed is the Selector.</source>
          <target state="translated">我通常使用AngularJS和&lt;a href=&quot;http://en.wikipedia.org/wiki/PhoneGap&quot;&gt;Cordova&lt;/a&gt;开发移动应用程序。 我唯一需要的jQuery是Selector。</target>
        </trans-unit>
        <trans-unit id="68cf991557c35bd050972b963c214ad303e38353" translate="yes" xml:space="preserve">
          <source>I'm not looking for a detailed comparison between &lt;code&gt;jQuery&lt;/code&gt; and &lt;code&gt;AngularJS&lt;/code&gt;.</source>
          <target state="translated">我不是要在 &lt;code&gt;jQuery&lt;/code&gt; 和 &lt;code&gt;AngularJS&lt;/code&gt; 之间进行详细的比较。</target>
        </trans-unit>
        <trans-unit id="f656d296b8b07178ef6945737f0889477b62c8e3" translate="yes" xml:space="preserve">
          <source>I've seen many developers here and on the mailing list create these elaborate solutions with jQuery plugins of 150 or 200 lines of code that they then glue into AngularJS with a collection of callbacks and &lt;code&gt;$apply&lt;/code&gt;s that are confusing and convoluted; but they eventually get it working! The problem is that in &lt;strong&gt;most&lt;/strong&gt; cases that jQuery plugin could be rewritten in AngularJS in a fraction of the code, where suddenly everything becomes comprehensible and straightforward.</source>
          <target state="translated">我在这里和邮件列表上已经看到很多开发人员使用150或200行代码的jQuery插件创建这些精心设计的解决方案，然后将它们粘贴到AngularJS中，并包含一系列令人困惑和费解的回调和 &lt;code&gt;$apply&lt;/code&gt; ； 但是他们最终使它起作用了！ 问题在于，在&lt;strong&gt;大多数&lt;/strong&gt;情况下，可以用少量代码在AngularJS中重写jQuery插件，突然之间所有事情都变得容易理解和直接了。</target>
        </trans-unit>
        <trans-unit id="9faefb35c2c81504d51573a6b0bb40a2af1787a2" translate="yes" xml:space="preserve">
          <source>If this sounds like it might be over-prescriptive and limiting, nothing could be farther from the truth. Because AngularJS treats your HTML as code, you get &lt;strong&gt;HTML level granularity in your web application&lt;/strong&gt;. Everything is possible, and most things are surprisingly easy once you make a few conceptual leaps.</source>
          <target state="translated">如果这听起来像是过于规范和限制的话，那就没有比事实更遥远了。 由于AngularJS将HTML视为代码，因此您可以&lt;strong&gt;在Web应用程序中&lt;/strong&gt;获得&lt;strong&gt;HTML级别的粒度&lt;/strong&gt; 。 一切皆有可能，一旦您实现了一些概念上的飞跃，大多数事情都将变得异常容易。</target>
        </trans-unit>
        <trans-unit id="79f7744c5244c5d82136a0b399bcf24b88bb5af1" translate="yes" xml:space="preserve">
          <source>If you do use jQuery, you shouldn't be sprinkling it all over the place. The correct place for DOM manipulation in AngularJS is in a directive. More on these later.</source>
          <target state="translated">如果你真的使用jQuery,你不应该把它洒得满地都是。AngularJS中DOM操作的正确位置是在一个指令中。稍后会有更多关于这些的内容。</target>
        </trans-unit>
        <trans-unit id="b60077ec18c37edabed1d4367bf017ee53c9fbcf" translate="yes" xml:space="preserve">
          <source>If you need an HTML widget, create a directive.</source>
          <target state="translated">如果你需要一个HTML小部件,创建一个指令。</target>
        </trans-unit>
        <trans-unit id="c0db6dddb3c36feeee526c677dfbbae3c8383c59" translate="yes" xml:space="preserve">
          <source>If you need to share data between controllers, create a service or factory - they are singletons that are shared across the application.</source>
          <target state="translated">如果您需要在控制器之间共享数据,请创建一个服务或工厂--它们是在整个应用程序中共享的单子。</target>
        </trans-unit>
        <trans-unit id="4428aad89d5c0c9e8fe7de6ea30b96f7e38235d8" translate="yes" xml:space="preserve">
          <source>If you want a carousel, just use a &lt;code&gt;&amp;lt;carousel /&amp;gt;&lt;/code&gt; element, then define a directive to pull in a template, and make that sucker work.</source>
          <target state="translated">如果您想要轮播，只需使用 &lt;code&gt;&amp;lt;carousel /&amp;gt;&lt;/code&gt; 元素，然后定义指令以引入模板，并使该吸盘工作。</target>
        </trans-unit>
        <trans-unit id="276ce11b5a508e459e0e3120bcd6327d2afadd20" translate="yes" xml:space="preserve">
          <source>If, like me, you lived through the browser wars, you might find this idea quite offensive. Get over it, it'll be worth it, I promise.</source>
          <target state="translated">如果你和我一样经历过浏览器大战,你可能会觉得这个想法很反感。别再想了,我保证,这是很值得的。</target>
        </trans-unit>
        <trans-unit id="5813cd91b1b8004097b86b34053bfec044d09858" translate="yes" xml:space="preserve">
          <source>Imperative &amp;rarr; declarative</source>
          <target state="translated">命令式&amp;rarr;声明式</target>
        </trans-unit>
        <trans-unit id="07968492b4fc9b61f75164fde04e026e2f9fa45e" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;AngularJS&lt;/strong&gt;, you use &lt;strong&gt;directives&lt;/strong&gt; to mark the elements directly, to wire them up:</source>
          <target state="translated">在&lt;strong&gt;AngularJS中&lt;/strong&gt; ，您使用&lt;strong&gt;指令&lt;/strong&gt;直接标记元素，以将它们连接起来：</target>
        </trans-unit>
        <trans-unit id="f72af3c482bf1229ea3ff7aa97ad07e3cddd38f9" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;jQuery&lt;/strong&gt;, you typically  use &lt;strong&gt;selectors&lt;/strong&gt; to find elements, and then wire them up:</source>
          <target state="translated">在&lt;strong&gt;jQuery中&lt;/strong&gt; ，通常使用&lt;strong&gt;选择器&lt;/strong&gt;查找元素，然后将它们连接起来：</target>
        </trans-unit>
        <trans-unit id="f023543783f6ea1287434a1d4ab86cd65d3608d2" translate="yes" xml:space="preserve">
          <source>In AngularJS we write smaller directives. Our dropdown directive would be ridiculously small. It might maintain the folded state, and provide methods to fold(), unfold() or toggle(). These methods would simply update $scope.menu.visible which is a boolean holding the state.</source>
          <target state="translated">在AngularJS中,我们写的指令要小一些。我们的下拉指令将是非常小的。它可能会保持折叠状态,并提供折叠()、展开()或切换()的方法。这些方法只需更新$scope.menuine.visible,这是一个保持状态的布尔值。</target>
        </trans-unit>
        <trans-unit id="d8e03995fe1bd0fda78591a1efe81ead5f9d2dc8" translate="yes" xml:space="preserve">
          <source>In AngularJS you can do this too, but you are encouraged to make use of data binding. Change your model, and because the DOM is bound to it via a template your DOM will automatically update, no intervention required.</source>
          <target state="translated">在AngularJS中,你也可以这样做,但鼓励你使用数据绑定。改变你的模型,因为DOM是通过模板绑定的,所以你的DOM会自动更新,不需要干预。</target>
        </trans-unit>
        <trans-unit id="1ac2131eed6961b3bcec8b6db93b268ad621db10" translate="yes" xml:space="preserve">
          <source>In AngularJS, Ajax is your default go-to solution and it happens all the time, almost without you noticing. You can include templates with ng-include. You can apply a template with the simplest custom directive. You can wrap an Ajax call in a service and create yourself a &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt; service, or a &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt; service, which you can access with astonishing ease.</source>
          <target state="translated">在AngularJS中，Ajax是您的默认入门解决方案，并且它一直在发生，几乎没有引起您的注意。 您可以将模板包含在ng-include中。 您可以使用最简单的自定义指令来应用模板。 您可以将Ajax调用包装在服务中，并创建自己的&lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt;服务或&lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt;服务，您可以轻松地访问它们。</target>
        </trans-unit>
        <trans-unit id="e2b05f35093dd1f890c262faf35c9be008a7512c" translate="yes" xml:space="preserve">
          <source>In AngularJS, meaning lives in the model, the HTML is just a template, for display only.</source>
          <target state="translated">在AngularJS中,意思是住在模型中,HTML只是一个模板,仅用于显示。</target>
        </trans-unit>
        <trans-unit id="d68e1fa23f0a8a69226a8fe0de84d40b5cf7424f" translate="yes" xml:space="preserve">
          <source>In AngularJS, think about models, rather than jQuery-selected DOM elements that hold your data. Think about views as projections of those models, rather than registering callbacks to manipulate what the user sees.</source>
          <target state="translated">在AngularJS中,思考的是模型,而不是jQuery选择的DOM元素。将视图视为这些模型的投影,而不是注册回调来操纵用户看到的东西。</target>
        </trans-unit>
        <trans-unit id="89cbb8617b950a42475e39e8432df7a8116707a2" translate="yes" xml:space="preserve">
          <source>In AngularJS, though, the view is the official record of view-based functionality. Our &lt;code&gt;ul&lt;/code&gt; declaration would look like this instead:</source>
          <target state="translated">但是，在AngularJS中，视图是基于视图的功能的正式记录。 我们的 &lt;code&gt;ul&lt;/code&gt; 声明看起来像这样：</target>
        </trans-unit>
        <trans-unit id="0162908cf1e7269bf496e946a61a8ada95cd6936" translate="yes" xml:space="preserve">
          <source>In AngularJS, we define directives. A directive is a function which returns a JSON object. This object tells AngularJS what DOM elements to look for, and what changes to make to them. Directives are hooked in to the template using either attributes or elements, which you invent. The idea is to extend the capabilities of HTML with new attributes and elements.</source>
          <target state="translated">在AngularJS中,我们定义了指令。指令是一个函数,它返回一个JSON对象。这个对象告诉AngularJS要寻找哪些DOM元素,以及要对它们做什么修改。指令使用你发明的属性或元素来钩住模板。这个想法是用新的属性和元素来扩展HTML的功能。</target>
        </trans-unit>
        <trans-unit id="9ead8b9954017937b7508b690030cf694823a516" translate="yes" xml:space="preserve">
          <source>In AngularJS, you want to think about &lt;strong&gt;views&lt;/strong&gt; rather than DOM elements. Views are (declarative) HTML that contain AngularJS &lt;strong&gt;directives&lt;/strong&gt;. Directives set up the event handlers behind the scenes for us and give us dynamic databinding. Selectors are rarely used, so the need for IDs (and some types of classes) is greatly diminished. Views are tied to &lt;strong&gt;models&lt;/strong&gt; (via scopes). Views are a projection of the model. Events change models (that is, data, scope properties), and the views that project those models update &quot;automatically.&quot;</source>
          <target state="translated">在AngularJS中，您要考虑&lt;strong&gt;视图&lt;/strong&gt;而不是DOM元素。 视图是包含AngularJS &lt;strong&gt;指令的&lt;/strong&gt; （声明性）HTML。 指令为我们在后台设置了事件处理程序，并为我们提供了动态数据绑定。 选择器很少使用，因此对ID（和某些类型的类）的需求大大减少了。 视图与&lt;strong&gt;模型&lt;/strong&gt;绑定（通过作用域）。 视图是模型的投影。 事件会更改模型（即数据，范围属性），并且投影这些模型的视图会&amp;ldquo;自动&amp;rdquo;更新。</target>
        </trans-unit>
        <trans-unit id="0978a7538d2e9b597f501e430a1fc5188f95a6ac" translate="yes" xml:space="preserve">
          <source>In fact, AngularJS is one of the few JavaScript MV* frameworks (many JavaScript MVC tools still fall under the category library).</source>
          <target state="translated">事实上,AngularJS是为数不多的JavaScript MV*框架之一(很多JavaScript MVC工具仍然属于类库)。</target>
        </trans-unit>
        <trans-unit id="90ff4de51967b0e32cde73bafc0522d33f597359" translate="yes" xml:space="preserve">
          <source>In jQuery making an Ajax call is fairly simple, but it's still something you might think twice about. There's the added complexity to think about, and a fair chunk of script to maintain.</source>
          <target state="translated">在jQuery中,做一个Ajax调用是相当简单的,但它仍然是你可能会三思而后行的事情。这就需要考虑到额外的复杂性,以及需要维护大量的脚本。</target>
        </trans-unit>
        <trans-unit id="4d193d7aba2968b4d212b2af011f3a04f803d0cc" translate="yes" xml:space="preserve">
          <source>In jQuery we define plugins by adding functions to the jQuery.prototype. We then hook these into the DOM by selecting elements and calling the plugin on the result. The idea is to extend the capabilities of jQuery.</source>
          <target state="translated">在jQuery中,我们通过向jQuery.prototype添加函数来定义插件。然后,我们通过选择元素并在结果上调用插件,将这些函数挂到DOM中。这样做的目的是为了扩展jQuery的功能。</target>
        </trans-unit>
        <trans-unit id="91a51e946cb4f1b8c319d268bb1e04bc99f9428c" translate="yes" xml:space="preserve">
          <source>In jQuery you make all your DOM changes by hand. You construct new DOM elements programatically. If you have a JSON array and you want to put it to the DOM, you must write a function to generate the HTML and insert it.</source>
          <target state="translated">在jQuery中,你可以手动修改所有的DOM元素。你可以通过程序化的方式构造新的DOM元素。如果你有一个JSON数组,你想把它放到DOM中,你必须写一个函数来生成HTML并插入它。</target>
        </trans-unit>
        <trans-unit id="a18bb6e728d8ea68da1050a05d8c1caca3f92ba2" translate="yes" xml:space="preserve">
          <source>In jQuery, &lt;em&gt;selectors&lt;/em&gt; are used to find &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; elements and then bind/register event handlers to them. When an event triggers, that (imperative) code executes to update/change the DOM.</source>
          <target state="translated">在jQuery中， &lt;em&gt;选择器&lt;/em&gt;用于查找&lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;元素，然后将事件处理程序绑定/注册到它们。 当事件触发时，该（命令）代码将执行以更新/更改DOM。</target>
        </trans-unit>
        <trans-unit id="8a90029611394ef928be3afb0243d4a481afa763" translate="yes" xml:space="preserve">
          <source>In jQuery, if we want to accomplish a small non-dom related task such as pulling a feed from an API, we might write a little function to do that in our closure. That's a valid solution, but what if we  want to access that feed often? What if we want to reuse that code in another application?</source>
          <target state="translated">在jQuery中,如果我们想完成一个非DOM相关的小任务,比如从API中拉出一个feed,我们可能会写一个小函数来完成这个任务。这是一个有效的解决方案,但如果我们想经常访问那个feed怎么办?如果我们想在另一个应用中重用这些代码呢?</target>
        </trans-unit>
        <trans-unit id="578dbc27e0bbb209f2594106996aa6a42a880c64" translate="yes" xml:space="preserve">
          <source>In jQuery, in our application logic, we would activate it with something like:</source>
          <target state="translated">在jQuery中,在我们的应用逻辑中,我们会用这样的方式激活它。</target>
        </trans-unit>
        <trans-unit id="e592dbbf682e0219ae9b707b9547f8d0c26db26e" translate="yes" xml:space="preserve">
          <source>In jQuery, the DOM is kind of like the model. But in AngularJS, we have a separate model layer that we can manage in any way we want, completely independently from the view. This helps for the above data binding, maintains &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separation of concerns&lt;/a&gt;, and introduces far greater testability. Other answers mentioned this point, so I'll just leave it at that.</source>
          <target state="translated">在jQuery中，DOM有点像模型。 但是在AngularJS中，我们有一个单独的模型层，我们可以用它想要的任何方式进行管理，完全独立于视图。 这有助于实现上述数据绑定，保持&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;关注点分离&lt;/a&gt; ，并引入更大的可测试性。 其他答案都提到了这一点，因此我将其保留。</target>
        </trans-unit>
        <trans-unit id="9df8eb4ba7e6248a7fa36700e17beb0b22254122" translate="yes" xml:space="preserve">
          <source>In jQuery, the only way to test is often to create the component independently with a sample/demo page against which our tests can perform DOM manipulation. So then we have to develop a component separately and &lt;em&gt;then&lt;/em&gt; integrate it into our application. How inconvenient! So much of the time, when developing with jQuery, we opt for iterative instead of test-driven development. And who could blame us?</source>
          <target state="translated">在jQuery中，测试的唯一方法通常是使用示例/演示页面独立创建组件，我们的测试可以针对该示例/演示页面执行DOM操作。 因此，我们必须分别开发一个组件， &lt;em&gt;然后&lt;/em&gt;将其集成到我们的应用程序中。 多么不便！ 很多时候，当使用jQuery开发时，我们选择迭代而不是测试驱动的开发。 谁能责怪我们？</target>
        </trans-unit>
        <trans-unit id="3d416179f5af40e5d18f244c9ec21f4ff3ba4392" translate="yes" xml:space="preserve">
          <source>In jQuery, we programmatically change the view. We could have a dropdown menu defined as a &lt;code&gt;ul&lt;/code&gt; like so:</source>
          <target state="translated">在jQuery中，我们以编程方式更改视图。 我们可以将下拉菜单定义为 &lt;code&gt;ul&lt;/code&gt; ,如下所示：</target>
        </trans-unit>
        <trans-unit id="8cc873c923938462e55d7110881a14087792dc45" translate="yes" xml:space="preserve">
          <source>In jQuery, you design a page, and then you make it dynamic. This is because jQuery was designed for augmentation and has grown incredibly from that simple premise.</source>
          <target state="translated">在jQuery中,你设计一个页面,然后让它成为动态的。这是因为jQuery是为增强型而设计的,并且从这个简单的前提下发展得非常好。</target>
        </trans-unit>
        <trans-unit id="7090926b8952ded00ad0da61eb6e721bc8a14052" translate="yes" xml:space="preserve">
          <source>It focuses on &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separation of concerns&lt;/a&gt; and testing (&lt;a href=&quot;http://en.wikipedia.org/wiki/Unit_testing&quot;&gt;unit testing&lt;/a&gt; and end-to-end testing), which facilitates test-driven development.</source>
          <target state="translated">它着重于&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;关注点&lt;/a&gt;和测试（ &lt;a href=&quot;http://en.wikipedia.org/wiki/Unit_testing&quot;&gt;单元测试&lt;/a&gt;和端到端测试）的分离，这有助于测试驱动的开发。</target>
        </trans-unit>
        <trans-unit id="68f6b3301831188f15035c61039b24d8f4da1058" translate="yes" xml:space="preserve">
          <source>It looks like this:</source>
          <target state="translated">它看起来是这样的</target>
        </trans-unit>
        <trans-unit id="1bf8b46db45a60c96dc64642b65b408cb0586b2c" translate="yes" xml:space="preserve">
          <source>It's more similar to &lt;a href=&quot;http://en.wikipedia.org/wiki/XSLT&quot;&gt;XSLT&lt;/a&gt; than &lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt; for example.</source>
          <target state="translated">例如，它比&lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt;更类似于&lt;a href=&quot;http://en.wikipedia.org/wiki/XSLT&quot;&gt;XSLT&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa9f7423100ee20741ac52a057ba63a8dfdb5f92" translate="yes" xml:space="preserve">
          <source>It's really two very different states of mind.</source>
          <target state="translated">这真的是两种截然不同的心态。</target>
        </trans-unit>
        <trans-unit id="94d4826a0666242ba1ec0266cc07db08e55ebb65" translate="yes" xml:space="preserve">
          <source>JQuery plugins are created in a closure. Privacy is maintained within that closure. It's up to you to maintain your scope chain within that closure. You only really have access to the set of DOM nodes passed in to the plugin by jQuery, plus any local variables defined in the closure and any globals you have defined. This means that plugins are quite self contained. This is a good thing, but can get restrictive when creating a whole application. Trying to pass data between sections of a dynamic page becomes a chore.</source>
          <target state="translated">JQuery插件是在一个封闭中创建的。隐私是在那个封包中维护的。在这个闭包中维护你的作用域链是由你来决定的。你只能访问jQuery传递给插件的DOM节点的集合,再加上在闭包中定义的任何本地变量和你定义的任何globals。这意味着插件是相当自含的。这是一件好事,但在创建整个应用程序的时候,可能会受到限制。试图在一个动态页面的各个部分之间传递数据会变得很麻烦。</target>
        </trans-unit>
        <trans-unit id="4f2edb980b5874e73b214306540044ccfc45d51f" translate="yes" xml:space="preserve">
          <source>JavaScript - Behaviour, without the script the content remains.</source>
          <target state="translated">JavaScript-行为,没有脚本,内容依然存在。</target>
        </trans-unit>
        <trans-unit id="0270aec9323c9370103673494bbf224ea44393df" translate="yes" xml:space="preserve">
          <source>Let's get down to the nitty gritty.</source>
          <target state="translated">让我们来说说细节上的问题。</target>
        </trans-unit>
        <trans-unit id="b836477afc268d4e57ddfe2bd54c811505cff526" translate="yes" xml:space="preserve">
          <source>Let's say in our application, we require a service that implements server-side storage through a &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;REST&lt;/a&gt; API and, depending on application state, local storage as well. When running tests on our controllers, we don't want to have to communicate with the server - we're testing the &lt;em&gt;controller&lt;/em&gt;, after all. We can just add a mock service of the same name as our original component, and the injector will ensure that our controller gets the fake one automatically - our controller doesn't and needn't know the difference.</source>
          <target state="translated">假设在我们的应用程序中，我们需要一个服务，该服务通过&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;REST&lt;/a&gt; API以及本地存储（取决于应用程序状态）来实现服务器端存储。 在我们的控制器上运行测试时，我们不需要与服务器通信-毕竟，我们正在测试&lt;em&gt;控制器&lt;/em&gt; 。 我们可以添加一个与原始组件同名的模拟服务，并且注入器将确保我们的控制器自动获得伪造的服务-我们的控制器不需要也不需要知道两者之间的区别。</target>
        </trans-unit>
        <trans-unit id="019d0f43d35ebf4308b922e715c1e5edd09fa4ad" translate="yes" xml:space="preserve">
          <source>Let's say we have a shopping cart. We might define a ShoppingCartService which maintains our cart and contains methods for adding and removing items. Because the service is a singleton, and is shared by all other components, any object that needs to can write to the shopping cart and pull data from it. It's always the same cart.</source>
          <target state="translated">假设我们有一个购物车。我们可以定义一个ShoppingCartService,它维护我们的购物车,并包含添加和删除项目的方法。因为这个服务是一个单子,并且被所有其他组件共享,任何需要的对象都可以写到购物车并从购物车中提取数据。它始终是同一个购物车。</target>
        </trans-unit>
        <trans-unit id="727106c324e0d326b53eb51a45c4de3427303c78" translate="yes" xml:space="preserve">
          <source>Like me, you will quickly realize that AngularJS (or &lt;a href=&quot;http://en.wikipedia.org/wiki/Ember.js&quot;&gt;Ember.js&lt;/a&gt;, Durandal, &amp;amp; other MV* frameworks for that matter) is one complex framework assembling many of the different JavaScript design patterns.</source>
          <target state="translated">像我一样，您会很快意识到AngularJS（或&lt;a href=&quot;http://en.wikipedia.org/wiki/Ember.js&quot;&gt;Ember.js&lt;/a&gt; ，Durandal以及其他MV *框架）是一个复杂的框架，它集合了许多不同的JavaScript设计模式。</target>
        </trans-unit>
        <trans-unit id="1cfac11915904016eed201cd17895ef142e7298c" translate="yes" xml:space="preserve">
          <source>Likewise:</source>
          <target state="translated">Likewise:</target>
        </trans-unit>
        <trans-unit id="480a72e21e4eecb130022ee539c13f82e6fb2dfc" translate="yes" xml:space="preserve">
          <source>Listen to the podcast &lt;em&gt;&lt;a href=&quot;http://javascriptjabber.com/032-jsj-angular-js/&quot;&gt;JavaScript Jabber: Episode #32&lt;/a&gt;&lt;/em&gt; that features the original creators of AngularJS: Misko Hevery &amp;amp; Igor Minar. They talk a lot about what it's like to come to AngularJS from other JavaScript backgrounds, especially jQuery.</source>
          <target state="translated">收听播客&lt;em&gt;&lt;a href=&quot;http://javascriptjabber.com/032-jsj-angular-js/&quot;&gt;JavaScript Jabber：第32集&lt;/a&gt;&lt;/em&gt; ，其中介绍了AngularJS的原始创建者：Misko Hevery和Igor Minar。 他们谈论了来自其他JavaScript背景（尤其是jQuery）的AngularJS的感受。</target>
        </trans-unit>
        <trans-unit id="b67d9fb1be3c48bab4357a222d15c0c1c6b2a6cb" translate="yes" xml:space="preserve">
          <source>Lots of small directives vs. big plugins with configuration switches</source>
          <target state="translated">大量的小指令相对于大插件的配置开关的小指令</target>
        </trans-unit>
        <trans-unit id="d35f5ddc9a42a97abe31468fffd327ecf232b76a" translate="yes" xml:space="preserve">
          <source>MVC and SOC are not on opposite ends of the same scale, they are on completely different axes. SOC makes no sense in an AngularJS context. You have to forget it and move on.</source>
          <target state="translated">MVC和SOC并不在同一个尺度的两端,它们是在完全不同的轴上。SOC在AngularJS的上下文中没有任何意义。你必须忘记它,继续前进。</target>
        </trans-unit>
        <trans-unit id="c45a37dd264d950f6729ef56ff2a3c5abcd3a05d" translate="yes" xml:space="preserve">
          <source>Manual DOM changes vs. Data Binding</source>
          <target state="translated">手动更改DOM与数据绑定</target>
        </trans-unit>
        <trans-unit id="40e632bf9794198f4934d498879371d6d20bbd8f" translate="yes" xml:space="preserve">
          <source>Misko likes jQuery and doesn't object to you using it. However you will find as you advance that you can get a pretty much all of your work done using a combination of scope, templates and directives, and you should prefer this workflow where possible because your code will be more discrete, more configurable, and more Angular.</source>
          <target state="translated">Misko喜欢jQuery,不反对你使用它。然而,随着你的进步,你会发现你可以使用范围、模板和指令的组合来完成几乎所有的工作,而且你应该尽可能地喜欢这种工作流程,因为你的代码会更离散,更可配置,也更有Angular。</target>
        </trans-unit>
        <trans-unit id="aec4fedd98ecef7252e688fd312c8e23a1997547" translate="yes" xml:space="preserve">
          <source>Model - your models contains your semantic data. Models are usually &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; objects. Models exist as attributes of an object called $scope. You can also store handy utility functions on $scope which your templates can then access.</source>
          <target state="translated">模型-您的模型包含您的语义数据。 模型通常是&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;对象。 模型作为称为$ scope的对象的属性存在。 您也可以将方便的实用程序功能存储在$ scope上，然后可以使用它们访问模板。</target>
        </trans-unit>
        <trans-unit id="19445a7cb4f59d8113ef809076f488b19366f851" translate="yes" xml:space="preserve">
          <source>Modular service architecture</source>
          <target state="translated">模块化服务架构</target>
        </trans-unit>
        <trans-unit id="9f995a1445edebed9a0edf58ca86dd65ac082151" translate="yes" xml:space="preserve">
          <source>Modules contain AngularJS components. &lt;strong&gt;When we include a module, all the components in that module become available to us as a simple list identified by their unique strings&lt;/strong&gt;. We can then inject those components into each other using AngularJS's dependency injection mechanism.</source>
          <target state="translated">模块包含AngularJS组件。 &lt;strong&gt;当我们包含一个模块时，该模块中的所有组件都可以作为由其唯一字符串标识的简单列表来使用&lt;/strong&gt; 。 然后，我们可以使用AngularJS的依赖项注入机制将这些组件相互注入。</target>
        </trans-unit>
        <trans-unit id="70589733204c633c8000b33bb5a831052090d3fd" translate="yes" xml:space="preserve">
          <source>My little book</source>
          <target state="translated">我的小书</target>
        </trans-unit>
        <trans-unit id="07bfe1f4feee155120fcc275ea68f1bb17d3143b" translate="yes" xml:space="preserve">
          <source>NB: This list is not complete, nor 'the best libraries'; they just happen to be the libraries I used. These libraries also include more patterns, the ones mentioned are just their main focuses or original intents. If you feel something is missing from this list, please do mention it in the comments, and I will be glad to add it.</source>
          <target state="translated">注:这个列表不是完整的,也不是 &quot;最好的库&quot;,它们只是刚好是我用过的库。这些库还包括了更多的模式,提到的只是它们的重点或原意。如果你觉得这个列表中缺少了什么,请在评论中提到,我会很乐意补充。</target>
        </trans-unit>
        <trans-unit id="9c8b27c78d13ab71411ac0fb47cbd272d9d671dd" translate="yes" xml:space="preserve">
          <source>Need to update on mouseover?</source>
          <target state="translated">需要更新鼠标切换吗?</target>
        </trans-unit>
        <trans-unit id="aa01a327749e49bb46fbfc492f1fd3a49c1971bc" translate="yes" xml:space="preserve">
          <source>Now &lt;strong&gt;in our template&lt;/strong&gt; we can wire this up:</source>
          <target state="translated">现在， &lt;strong&gt;在我们的模板中，&lt;/strong&gt;我们可以将其连接起来：</target>
        </trans-unit>
        <trans-unit id="153e1db9288018367b69014d7e273ac9321adee5" translate="yes" xml:space="preserve">
          <source>Now when I want to use that service I just refer to it by name like this:</source>
          <target state="translated">现在,当我想使用这项服务时,我只需要用它的名字来称呼它。</target>
        </trans-unit>
        <trans-unit id="0442ca4f2eae67ddd54b40deb8356ab4b3234010" translate="yes" xml:space="preserve">
          <source>Okay, now we can write a test for the non-existent &lt;code&gt;when-active&lt;/code&gt; directive:</source>
          <target state="translated">好的，现在我们可以为不存在的 &lt;code&gt;when-active&lt;/code&gt; 指令编写测试：</target>
        </trans-unit>
        <trans-unit id="7837f88043d6848be1c4e543d7bab6fecef2576e" translate="yes" xml:space="preserve">
          <source>One approach to designing an AngularJS application:</source>
          <target state="translated">设计AngularJS应用的一种方法。</target>
        </trans-unit>
        <trans-unit id="2bf914d56359268ce76537cc99ef400aea8ea885" translate="yes" xml:space="preserve">
          <source>One more thing you will experience in AngularJS: in jQuery you call the jQuery functions a lot, in AngularJS, AngularJS will call your functions, so AngularJS will 'tell you how to do things', but the benefits are worth it, so learning AngularJS usually means learning what AngularJS wants or the way AngularJS requires that you present your functions and it will call it accordingly. This is one of the things that makes AngularJS a framework rather than a library.</source>
          <target state="translated">在AngularJS中,你还会体验到一件事:在jQuery中,你会调用很多jQuery函数,在AngularJS中,AngularJS会调用你的函数,所以AngularJS会 &quot;告诉你怎么做事情&quot;,但好处是值得的,所以学习AngularJS通常意味着学习AngularJS想要什么,或者说AngularJS要求你展示你的函数的方式,它就会相应地调用。这也是AngularJS成为框架而不是库的原因之一。</target>
        </trans-unit>
        <trans-unit id="03d3b7c13e891111d419508c0bfcfcb11f3df270" translate="yes" xml:space="preserve">
          <source>One of the first questions I asked myself when starting AngularJS and running through the tutorials is &lt;strong&gt;&quot;Where is my code?&quot;&lt;/strong&gt;. I've written no JavaScript, and yet I have all this behaviour. The answer is obvious. Because AngularJS compiles the DOM, AngularJS is treating your HTML as code. For many simple cases it's often sufficient to just write a template and let AngularJS compile it into an application for you.</source>
          <target state="translated">在启动AngularJS并运行教程时，我问自己的第一个问题是&lt;strong&gt;&amp;ldquo;我的代码在哪里？&amp;rdquo;&lt;/strong&gt; 。 我没有编写JavaScript，但是我有所有这些行为。 答案很明显。 由于AngularJS会编译DOM，因此AngularJS会将您的HTML视为代码。 在许多简单情况下，只需编写一个模板并让AngularJS为您编译成应用程序通常就足够了。</target>
        </trans-unit>
        <trans-unit id="5560b0b478cb184acb6dd255b743f68939c76bfb" translate="yes" xml:space="preserve">
          <source>One of the first things your will notice about AngularJS is that &lt;strong&gt;custom attributes are everywhere&lt;/strong&gt;. Your HTML will be littered with ng attributes, which are essentially onClick attributes on steroids. These are directives (compiler directives), and are one of the main ways in which the template is hooked to the model.</source>
          <target state="translated">关于AngularJS的第一件事就是&lt;strong&gt;自定义属性无处不在&lt;/strong&gt; 。 您的HTML会充满ng属性，该属性本质上是类固醇上的onClick属性。 这些是指令（编译器指令），并且是模板与模型挂钩的主要方式之一。</target>
        </trans-unit>
        <trans-unit id="57ecf8a54298e4269c92c7bcc0dbba1ce9d013e8" translate="yes" xml:space="preserve">
          <source>One of the points made in the podcast made a lot of things click for me with respects to your question:</source>
          <target state="translated">在播客中提出的一个观点让我对你的问题有了很大的启发。</target>
        </trans-unit>
        <trans-unit id="d2d60cb91258951e85b2c255d25b7443475f73c6" translate="yes" xml:space="preserve">
          <source>Our test now passes &lt;em&gt;and&lt;/em&gt; our menu performs as requested. Our development is &lt;em&gt;both&lt;/em&gt; iterative &lt;em&gt;and&lt;/em&gt; test-driven. Wicked-cool.</source>
          <target state="translated">现在&lt;em&gt;，&lt;/em&gt;我们的测试通过了&lt;em&gt;，&lt;/em&gt;并且菜单按要求执行。 我们的开发&lt;em&gt;既是&lt;/em&gt;迭代的&lt;em&gt;又是&lt;/em&gt;测试驱动的。 邪恶的酷。</target>
        </trans-unit>
        <trans-unit id="b1cda9d2edb4291daae963095ddaa44650f5868e" translate="yes" xml:space="preserve">
          <source>Out of all of the many jQuery plugins you've seen, used, or written, how many of them had an accompanying test suite? Not very many because jQuery isn't very amenable to that. But AngularJS is.</source>
          <target state="translated">在你见过、用过或写过的那么多jQuery插件中,有几个有附带的测试套件?不多,因为jQuery并不是很适合做这个。但AngularJS是。</target>
        </trans-unit>
        <trans-unit id="f9292427c33228bbb89cf354be2c739835887f3c" translate="yes" xml:space="preserve">
          <source>Plugins vs. Directives</source>
          <target state="translated">插件与指南</target>
        </trans-unit>
        <trans-unit id="607f6c8afc68a939603967e0db86561e2011d68e" translate="yes" xml:space="preserve">
          <source>Prototypal inheritance</source>
          <target state="translated">原型继承</target>
        </trans-unit>
        <trans-unit id="1125bad105ddcf506c8be1fdc620fda300253963" translate="yes" xml:space="preserve">
          <source>Put another way, if AngularJS doesn't do something out of the box, think how the team would accomplish it to fit right in with &lt;code&gt;ngClick&lt;/code&gt;, &lt;code&gt;ngClass&lt;/code&gt;, et al.</source>
          <target state="translated">换句话说，如果AngularJS没有做一些开箱即用的事情，请考虑一下团队将如何实现它以使其与 &lt;code&gt;ngClick&lt;/code&gt; ， &lt;code&gt;ngClass&lt;/code&gt; 等完美配合。</target>
        </trans-unit>
        <trans-unit id="114cadb60225b9cfb70015e3d69c1e89f1ac48ce" translate="yes" xml:space="preserve">
          <source>Remember: don't design, and then mark up. You must architect, and then design.</source>
          <target state="translated">记住:不要先设计,再做标记。一定要先做建筑师,再做设计。</target>
        </trans-unit>
        <trans-unit id="f161adf528d29607ada8937ad2e9d5fb2b6eb816" translate="yes" xml:space="preserve">
          <source>Say I have a component called 'FlickrService' which defines methods for pulling JSON feeds from Flickr. Now, if I want to write a controller that can access Flickr, I just need to refer to the 'FlickrService' by name when I declare the controller. AngularJS will take care of instantiating the component and making it available to my controller.</source>
          <target state="translated">假设我有一个叫'FlickrService'的组件,它定义了从Flickr中提取JSON feeds的方法。现在,如果我想写一个可以访问Flickr的控制器,我只需要在声明控制器时引用'FlickrService'的名字就可以了。AngularJS将负责实例化这个组件,并将其提供给我的控制器。</target>
        </trans-unit>
        <trans-unit id="19ccf6b268bdaab6e39621189c0b09a8c462daa5" translate="yes" xml:space="preserve">
          <source>Say you have a menu that you want to unfold on hover. Well now we have a problem. Our plugin has wired in our click handler for us, we're going to need to add a configuration option to make it behave differently in this specific case.</source>
          <target state="translated">说你有一个菜单,你想在悬停时展开。那么现在我们有一个问题。我们的插件已经在我们的点击处理程序中加入了线,我们需要添加一个配置选项,让它在这种特殊情况下有不同的表现。</target>
        </trans-unit>
        <trans-unit id="7d90dd71a242dda24991720aaeaa5f7a73787c5c" translate="yes" xml:space="preserve">
          <source>Saying &quot;I have a jQuery background how do I think in AngularJS?&quot; is like saying &quot;I have an HTML background how do I think in JavaScript?&quot; The fact that you're asking the question shows you most likely don't understand the fundamental purposes of these two resources. This is why I chose to answer the question by simply pointing out the fundamental difference rather than going through the list saying &quot;AngularJS makes use of directives whereas jQuery uses CSS selectors to make a jQuery object which does this and that etc....&quot;. This question does not require a lengthy answer.</source>
          <target state="translated">说 &quot;我有jQuery背景,怎么用AngularJS思考?&quot;就像说 &quot;我有HTML背景,怎么用JavaScript思考?&quot; 你问这个问题,说明你很可能不了解这两种资源的基本用途。这就是为什么我选择回答这个问题的原因,我只是简单地指出了根本的区别,而不是罗列了一下,说 &quot;AngularJS使用指令,而jQuery使用CSS选择器来做一个jQuery对象,做这个做那个..........&quot;。这个问题不需要冗长的回答。</target>
        </trans-unit>
        <trans-unit id="b15d2624d8c5f4177ef0a3ab7aff382714a73357" translate="yes" xml:space="preserve">
          <source>Second, even if we already have jQuery on our page, there's no reason to use it here; we can simply use &lt;code&gt;angular.element&lt;/code&gt; and our component will still work when dropped into a project that doesn't have jQuery.</source>
          <target state="translated">其次，即使我们的页面上已经有了jQuery，也没有理由在这里使用它。 我们可以简单地使用 &lt;code&gt;angular.element&lt;/code&gt; ，当我们的组件放到没有jQuery的项目中时，它仍然可以工作。</target>
        </trans-unit>
        <trans-unit id="f1027ea73a1ce39cead4439ded7f29e2042983a5" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/a/14346528/215945&quot;&gt;https://stackoverflow.com/a/14346528/215945&lt;/a&gt;</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://stackoverflow.com/a/14346528/215945&quot;&gt;https://stackoverflow.com/a/14346528/215945&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f1430a8f5652e40680c3ddd0c683243bf517e61" translate="yes" xml:space="preserve">
          <source>Semantic HTML vs. Semantic Models</source>
          <target state="translated">语义HTML与语义模型</target>
        </trans-unit>
        <trans-unit id="53858a8768ea9c3d5fda9320b9574562086e2f5d" translate="yes" xml:space="preserve">
          <source>Separation of concerns</source>
          <target state="translated">分开关注的问题</target>
        </trans-unit>
        <trans-unit id="6db963975c4efe88a2a596e7aed57f9bfc1a010d" translate="yes" xml:space="preserve">
          <source>Separation of concerns (SOC) vs. MVC</source>
          <target state="translated">分开关注(SOC)和MVC</target>
        </trans-unit>
        <trans-unit id="5bc1e903eb4c935f3459b8bfa4ee30d83efd9017" translate="yes" xml:space="preserve">
          <source>Service Objects vs Helper Functions</source>
          <target state="translated">服务对象与帮助函数</target>
        </trans-unit>
        <trans-unit id="4c836a91846e8f4077393af2f95820c64acdb8ff" translate="yes" xml:space="preserve">
          <source>Service objects are self-contained AngularJS components which we can use and reuse as we see fit. They are simple JSON objects containing functions and Data. They are always singletons, so if you store data on a service in one place, you can get that data out somewhere else just by requesting the same service.</source>
          <target state="translated">服务对象是独立的AngularJS组件,我们可以根据自己的需要使用和重用。它们是简单的JSON对象,包含函数和数据。它们总是单子,所以如果你把数据存储在一个服务上,你可以通过请求相同的服务来获取其他地方的数据。</target>
        </trans-unit>
        <trans-unit id="108da03ec5d5f76f957cbf432008dbadf4a072c6" translate="yes" xml:space="preserve">
          <source>Services are simple objects that contain functions and data. They are always singletons, meaning there can never be more than one of them. Say we want to access the Stack Overflow API, we might write a &lt;code&gt;StackOverflowService&lt;/code&gt; which defines methods for doing so.</source>
          <target state="translated">服务是包含功能和数据的简单对象。 它们始终是单例，这意味着不能超过一个。 假设我们要访问Stack Overflow API，我们可以编写一个 &lt;code&gt;StackOverflowService&lt;/code&gt; 来定义用于执行此操作的方法。</target>
        </trans-unit>
        <trans-unit id="bcd9e97fc87fb6d10f4491826f78c5d81839dcbf" translate="yes" xml:space="preserve">
          <source>Similarly, don't start with the idea that jQuery does X, Y, and Z, so I'll just add AngularJS on top of that for models and controllers. This is &lt;em&gt;really&lt;/em&gt; tempting when you're just starting out, which is why I always recommend that new AngularJS developers don't use jQuery at all, at least until they get used to doing things the &quot;Angular Way&quot;.</source>
          <target state="translated">同样，不要以jQuery做X，Y和Z的想法开始，所以我只在模型和控制器的基础上添加AngularJS。 当您刚开始时，这&lt;em&gt;确实&lt;/em&gt;很诱人，这就是为什么我总是建议新的AngularJS开发人员根本不使用jQuery，至少直到他们习惯于&amp;ldquo; Angular Way&amp;rdquo;为止。</target>
        </trans-unit>
        <trans-unit id="bcedf6e82233838f46efd8ce2fadad3c46a471c6" translate="yes" xml:space="preserve">
          <source>So if directives aren't just collections of jQuery-like functions, what are they? Directives are actually &lt;strong&gt;extensions of HTML&lt;/strong&gt;. If HTML doesn't do something you need it to do, you write a directive to do it for you, and then use it just as if it was part of HTML.</source>
          <target state="translated">因此，如果指令不仅仅是类似jQuery的函数的集合，它们是什么？ 指令实际上&lt;strong&gt;是HTML的扩展&lt;/strong&gt; 。 如果HTML不能做您需要做的事情，您可以编写一条指令来为您做，然后像使用HTML一样使用它。</target>
        </trans-unit>
        <trans-unit id="6120b7aac76e709ec6a4b057e3e50cdedce773bf" translate="yes" xml:space="preserve">
          <source>So then &lt;em&gt;how&lt;/em&gt; do you do that? How do you &quot;think in AngularJS&quot;? Here are some general principles, contrasted with jQuery.</source>
          <target state="translated">那你该&lt;em&gt;怎么&lt;/em&gt;做呢？ 您如何&amp;ldquo;在AngularJS中思考&amp;rdquo;？ 以下是一些与jQuery相反的一般原则。</target>
        </trans-unit>
        <trans-unit id="c8363d4dd045c968829900ac07d31222d3fe3f8c" translate="yes" xml:space="preserve">
          <source>So when people say &quot;don't include jQuery at all&quot;, it's mainly because they don't want you to use selectors; they want you to learn to use directives instead. Direct, not select!</source>
          <target state="translated">所以,当人们说 &quot;完全不要包含jQuery &quot;时,主要是因为他们不想让你使用选择器,而是希望你学会使用指令。直接的,而不是选择器!</target>
        </trans-unit>
        <trans-unit id="353a803b7edb418ffb01abfd037657963de833b9" translate="yes" xml:space="preserve">
          <source>So, to directly answer your question: AngularJS is -very- opinionated and is a true MV* framework. However, you can still do all of the really cool stuff you know and love with jQuery inside of directives. It's not a matter of &quot;How do I do what I used to in jQuery?&quot; as much as it's a matter of &quot;How do I supplement AngularJS with all of the stuff I used to do in jQuery?&quot;</source>
          <target state="translated">所以,直接回答你的问题。AngularJS是一个真正的MV*框架。但是,你仍然可以在jQuery里面用jQuery做所有你知道的、喜欢的东西。這並不是 &quot;我該如何做我以前在jQuery中所做的事情? &quot;的問題,而是 &quot;我該如何將AngularJS與我以前在jQuery中所做的所有事情補充到AngularJS中?&quot;</target>
        </trans-unit>
        <trans-unit id="615e1f97ec6c97206dc36b15588437a9d429a60e" translate="yes" xml:space="preserve">
          <source>Some directives just decorate what's already in the view (think &lt;code&gt;ngClass&lt;/code&gt;) and therefore sometimes do DOM manipulation straight away and then are basically done. But if a directive is like a &quot;widget&quot; and has a template, it should &lt;em&gt;also&lt;/em&gt; respect separation of concerns. That is, the template &lt;em&gt;too&lt;/em&gt; should remain largely independent from its implementation in the link and controller functions.</source>
          <target state="translated">有些指令只是修饰视图中已经存在的内容（认为 &lt;code&gt;ngClass&lt;/code&gt; ），因此有时会立即进行DOM操作，然后基本完成。 但是，如果一条指令就像一个&amp;ldquo;小部件&amp;rdquo;并具有一个模板，则它&lt;em&gt;也&lt;/em&gt;应该尊重关注点的分离。 也就是说，模板在链接和控制器功能中&lt;em&gt;也&lt;/em&gt;应在很大程度上与其实现无关。</target>
        </trans-unit>
        <trans-unit id="0b7f180f770b68b78d30a4012dd96f23b513a81e" translate="yes" xml:space="preserve">
          <source>Speaking of testing...</source>
          <target state="translated">说到测试.....</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="2c1b6c2453539d082bde5c9bc024f6fe7db931a1" translate="yes" xml:space="preserve">
          <source>Suppose I'm familiar with developing client-side applications in &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, but now I'd like to start using &lt;a href=&quot;http://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;. Can you describe the paradigm shift that is necessary? Here are a few questions that might help you frame an answer:</source>
          <target state="translated">假设我熟悉使用&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;开发客户端应用程序，但是现在我想开始使用&lt;a href=&quot;http://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt; 。 您能否描述必要的范式转换？ 以下是一些可以帮助您确定答案的问题：</target>
        </trans-unit>
        <trans-unit id="fd6f41a20d68ad3b1c1fbfcea42f10e9427c9beb" translate="yes" xml:space="preserve">
          <source>Take the example of a dropdown. When writing a dropdown plugin you might be tempted to code in click handlers, perhaps a function to add in a chevron which is either up or down, perhaps change the class of the unfolded element, show hide the menu, all helpful stuff.</source>
          <target state="translated">以下拉式插件为例。在写下拉插件的时候,你可能会在点击处理程序中编写代码,也许是一个函数来添加一个向上或向下的Chevron,也许是改变展开的元素的类,显示隐藏菜单,这些都是有用的东西。</target>
        </trans-unit>
        <trans-unit id="5f73c389448f9c45c912813ff91624715c6cc34b" translate="yes" xml:space="preserve">
          <source>The JavaScript is in control. The HTML has a completely independent existence. Your HTML remains semantic even without JavaScript. Onclick attributes are very bad practice.</source>
          <target state="translated">JavaScript在控制中。HTML有一个完全独立的存在。即使没有JavaScript,你的HTML仍然是语义的。Onclick属性是非常不好的做法。</target>
        </trans-unit>
        <trans-unit id="130af66cb629f5431d0392abeadf163c2a137efa" translate="yes" xml:space="preserve">
          <source>The best way to start is going through &lt;a href=&quot;http://docs.angularjs.org/tutorial/&quot;&gt;their awesome tutorial&lt;/a&gt;. You can go through the steps in a couple of hours; however, in case you want to master the concepts behind the scenes, they include a myriad of reference for further reading.</source>
          <target state="translated">最好的开始方法是阅读&lt;a href=&quot;http://docs.angularjs.org/tutorial/&quot;&gt;他们很棒的教程&lt;/a&gt; 。 您可以在几个小时内完成所有步骤； 但是，如果您想掌握幕后的概念，则其中包含许多参考资料供进一步阅读。</target>
        </trans-unit>
        <trans-unit id="2e204a233be1d37e6b8cbf5eb65012ecf70edcf5" translate="yes" xml:space="preserve">
          <source>The big difference (TLDR)</source>
          <target state="translated">最大的区别(TLDR)</target>
        </trans-unit>
        <trans-unit id="907f9bbd858732c7716065c039f6505a1e2910ac" translate="yes" xml:space="preserve">
          <source>The bottom line is this: when solutioning, first &quot;think in AngularJS&quot;; if you can't think of a solution, ask the community; if after all of that there is no easy solution, &lt;em&gt;then&lt;/em&gt; feel free to reach for the jQuery. But don't let jQuery become a crutch or you'll never master AngularJS.</source>
          <target state="translated">底线是：解决时，首先&amp;ldquo;在AngularJS中思考&amp;rdquo;； 如果您想不出解决方案，请询问社区； 如果毕竟没有简单的解决方案，请随时使用jQuery。 但是不要让jQuery成为拐杖，否则您将永远无法掌握AngularJS。</target>
        </trans-unit>
        <trans-unit id="e57a136d72c8717caeadf129317ca6ab40af1abf" translate="yes" xml:space="preserve">
          <source>The main thing to realise is that your template drives your application. Stop trying to write big plugins that do everything. Instead write little directives that do one thing, then write a simple template to wire them together.</source>
          <target state="translated">最主要的是要意识到,你的模板驱动着你的应用程序。不要再试图写大的插件来做所有的事情了。相反,写一些小指令,做一件事,然后写一个简单的模板把它们连接起来。</target>
        </trans-unit>
        <trans-unit id="962f4b9dcab1b0d6684a689d197c000723b390d9" translate="yes" xml:space="preserve">
          <source>The template drives the application so we get HTML level granularity. If we want to make case by case exceptions, the template makes this easy.</source>
          <target state="translated">模板驱动应用程序,所以我们得到了HTML级别的粒度。如果我们想要逐案异常,模板可以让这一切变得简单。</target>
        </trans-unit>
        <trans-unit id="ab3b37bfaba497ececec74f637723357bb8a14df" translate="yes" xml:space="preserve">
          <source>The template is in the driving seat.</source>
          <target state="translated">模板在驾驶座上。</target>
        </trans-unit>
        <trans-unit id="dbd42a737715dc284713f8149c27aef45340aa3e" translate="yes" xml:space="preserve">
          <source>The tendency with jQuery is to write great big plugins like lightbox which we then configure by passing in numerous values and options.</source>
          <target state="translated">jQuery的趋势是写出像lightbox这样的大插件,然后我们通过传递大量的值和选项来配置。</target>
        </trans-unit>
        <trans-unit id="a78f488c2b28762effe665517b5bb3bf368fa282" translate="yes" xml:space="preserve">
          <source>The view is the &quot;official record&quot;</source>
          <target state="translated">该观点是 &quot;官方记录&quot;</target>
        </trans-unit>
        <trans-unit id="1c2ed441fd1cd976f573b36eb08871514ae231f0" translate="yes" xml:space="preserve">
          <source>There are a few things wrong with this:</source>
          <target state="translated">这里面有几个问题。</target>
        </trans-unit>
        <trans-unit id="a60b215ea4b528f70a3f3f95afa944b9858d76db" translate="yes" xml:space="preserve">
          <source>These two do the same thing, but in the AngularJS version anyone looking at the template knows what's supposed to happen. Whenever a new member of the development team comes on board, she can look at this and then &lt;em&gt;know&lt;/em&gt; that there is a directive called &lt;code&gt;dropdownMenu&lt;/code&gt; operating on it; she doesn't need to intuit the right answer or sift through any code. The view told us what was supposed to happen. Much cleaner.</source>
          <target state="translated">两者的作用相同，但是在AngularJS版本中，任何查看模板的人都知道会发生什么。 每当开发团队的新成员加入时，她都可以查看一下，然后&lt;em&gt;知道&lt;/em&gt;有一个名为 &lt;code&gt;dropdownMenu&lt;/code&gt; 的指令正在运行； 她不需要输入正确的答案或筛选任何代码。 该视图告诉我们应该发生什么。 干净得多。</target>
        </trans-unit>
        <trans-unit id="5b12bc82675fe1d062a24637098e0b0d6f018bd6" translate="yes" xml:space="preserve">
          <source>They're apples and oranges. You don't want to compare them. They're two different things. AngularJs has already jQuery lite built in which allows you to perform basic DOM manipulation without even including the full blown jQuery version.</source>
          <target state="translated">他们是苹果和橘子。你不要拿它们做比较。它们是两种不同的东西。AngularJs已经内置了jQuery lite,它允许你执行基本的DOM操作,甚至不需要完整的jQuery版本。</target>
        </trans-unit>
        <trans-unit id="56611a6e765ec02b14bdc41b9a14cd86614e07d8" translate="yes" xml:space="preserve">
          <source>Think about how you want to present your models -- your views. Create HTML templates for each view, using the necessary directives to get dynamic databinding.</source>
          <target state="translated">想一想你要如何展示你的模型--你的视图。为每个视图创建HTML模板,使用必要的指令来获得动态数据绑定。</target>
        </trans-unit>
        <trans-unit id="27d048b935d814179e7c6a8517808bc5033c1c1e" translate="yes" xml:space="preserve">
          <source>Think about your models. Create services or your own JavaScript objects for those models.</source>
          <target state="translated">思考一下你的模型。为这些模型创建服务或你自己的JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="c7f6bac1d5607c8628add234dae8dfe943f7ebea" translate="yes" xml:space="preserve">
          <source>Think less about unobtrusive JavaScript, and instead think in terms of HTML extensions.</source>
          <target state="translated">少考虑一些不显眼的JavaScript,而是从HTML扩展的角度考虑。</target>
        </trans-unit>
        <trans-unit id="d9ef4e6d01c706c53e91d508343c6fe29cbd9c16" translate="yes" xml:space="preserve">
          <source>Think of the logger we programmed in section 3. Even if we put that in a directive, we &lt;em&gt;still&lt;/em&gt; want to do it the &quot;Angular Way&quot;. It &lt;em&gt;still&lt;/em&gt; doesn't take any DOM manipulation! There are lots of times when DOM manipulation is necessary, but it's a &lt;em&gt;lot&lt;/em&gt; rarer than you think! Before doing DOM manipulation &lt;em&gt;anywhere&lt;/em&gt; in your application, ask yourself if you really need to. There might be a better way.</source>
          <target state="translated">想想我们在第3节中编写的记录器。即使将其放入指令中，我们&lt;em&gt;仍然&lt;/em&gt;希望以&amp;ldquo; Angular Way&amp;rdquo;方式进行操作。 它&lt;em&gt;仍然&lt;/em&gt;不需要任何DOM操作！ 很多时候需要进行DOM操作，但是它比您想像的&lt;em&gt;要&lt;/em&gt;稀少得多！ 在对应用程序中的&lt;em&gt;任何位置&lt;/em&gt;进行DOM操作之前，请问自己是否确实需要这样做。 可能有更好的方法。</target>
        </trans-unit>
        <trans-unit id="59fba0d2a6be76b95e9437f56c0b3eb3aeefa64f" translate="yes" xml:space="preserve">
          <source>Third, even assuming jQuery &lt;em&gt;was&lt;/em&gt; required for this directive to work, jqLite (&lt;code&gt;angular.element&lt;/code&gt;) will &lt;em&gt;always&lt;/em&gt; use jQuery if it was loaded! So we needn't use the &lt;code&gt;$&lt;/code&gt; - we can just use &lt;code&gt;angular.element&lt;/code&gt;.</source>
          <target state="translated">第三，即使假设该指令需要使用jQuery，jqLit​​e（ &lt;code&gt;angular.element&lt;/code&gt; ）如果已加载，也将&lt;em&gt;始终&lt;/em&gt;使用jQuery！ 所以我们不需要使用 &lt;code&gt;$&lt;/code&gt; -我们可以只使用 &lt;code&gt;angular.element&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3dd8e8537bb1ca3481ce114c90c34fedaf33ea7" translate="yes" xml:space="preserve">
          <source>This a little messy and a trifle frail. But in AngularJS, we can do this:</source>
          <target state="translated">这个有点乱,而且有点弱。但在AngularJS中,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="751b9456fbde65691801d5e0cfad8c4a181a1230" translate="yes" xml:space="preserve">
          <source>This directive can be rewritten (even for very complicated cases!) much more simply like so:</source>
          <target state="translated">这个指令可以这样改写(即使对于非常复杂的情况也可以这样写!)。</target>
        </trans-unit>
        <trans-unit id="020626cca70fec4fadcd4c85e19094b67d89900d" translate="yes" xml:space="preserve">
          <source>This is a mistake in AngularJS.</source>
          <target state="translated">这是AngularJS中的一个错误。</target>
        </trans-unit>
        <trans-unit id="3ee80553c6d3b6490cc47a8c1b3fc30604995853" translate="yes" xml:space="preserve">
          <source>This is a radical inversion of control that takes some getting used to.</source>
          <target state="translated">这是对控制权的彻底颠覆,需要一段时间的适应。</target>
        </trans-unit>
        <trans-unit id="468caea94a05f6a1199b09552c745bdaee04f2e1" translate="yes" xml:space="preserve">
          <source>This is by far one of the most awesome features of AngularJS and cuts out a lot of the need to do the kinds of DOM manipulations I mentioned in the previous section. AngularJS will automatically update your view so you don't have to! In jQuery, we respond to events and then update content. Something like:</source>
          <target state="translated">这是到目前为止AngularJS最棒的功能之一,可以省去很多我在上一节中提到的DOM操作。AngularJS会自动更新你的视图,所以你不需要这样做。在jQuery中,我们响应事件,然后更新内容。类似这样的事情。</target>
        </trans-unit>
        <trans-unit id="303ce135543d65882737386396b17832595260ae" translate="yes" xml:space="preserve">
          <source>This is normal, you should push through. Angular is worth it.</source>
          <target state="translated">这很正常,你应该推送过去。Angular是值得的。</target>
        </trans-unit>
        <trans-unit id="7b1905aad1d40bfa2426382e15205e07ca50c045" translate="yes" xml:space="preserve">
          <source>This is really part of section 3 on architecture, but it's so important that I'm putting it as its own top-level section.</source>
          <target state="translated">这确实是关于架构的第3节的一部分,但它太重要了,所以我把它作为自己的顶层章节。</target>
        </trans-unit>
        <trans-unit id="383c8572d2b60f8594b548e872ffb17f8b10ed55" translate="yes" xml:space="preserve">
          <source>This is the clever part. Because the structure of $scope inheritance roughly follows the structure of the DOM, elements have access to their own scope, and any containing scopes seamlessly, all the way up to the global $scope (which is not the same as the global scope).</source>
          <target state="translated">这就是聪明的地方了。因为$scope继承的结构大致遵循DOM的结构,所以元素可以无缝地访问自己的作用域和任何包含的作用域,一直到全局的$scope(这和全局的作用域不一样)。</target>
        </trans-unit>
        <trans-unit id="f3085b36e84f35d5704fcffc8d2903ab4191c80b" translate="yes" xml:space="preserve">
          <source>This is the first big difference. To jQuery, your web page is a DOM to be manipulated. To AngularJS, your HTML is code to be compiled. AngularJS reads in your whole web page and literally compiles it into a new web page using its built in compiler.</source>
          <target state="translated">这是第一个大的区别。对jQuery来说,你的网页是一个待处理的DOM。對於AngularJS來說,你的HTML是要被編譯的代碼。AngularJS会读取你的整个网页,然后用它的内置编译器将其编译成一个新的网页。</target>
        </trans-unit>
        <trans-unit id="1ad2248d3589183cfe2efd76e3ed9a33f9b96543" translate="yes" xml:space="preserve">
          <source>This makes it much easier to pass data around, and to store data at an appropriate level. If a dropdown is unfolded, only the dropdown $scope needs to know about it. If the user updates their preferences, you might want to update the global $scope, and any nested scopes listening to the user preferences would automatically be alerted.</source>
          <target state="translated">这使得数据的传递更容易,在适当的层次上存储数据。如果一个下拉菜单被展开,只有下拉菜单$scope需要知道它。如果用户更新了他们的偏好,你可能会想更新全局$scope,而任何嵌套的作用域监听用户的偏好都会自动被提醒。</target>
        </trans-unit>
        <trans-unit id="a8a3cb7a0749fede326fb94b0ea02af49e57374b" translate="yes" xml:space="preserve">
          <source>This makes wiring things together very easy, and pretty much eliminates any tendency towards spagettification. We have a flat list of components, and AngularJS hands them to us one by one as and when we need them.</source>
          <target state="translated">这让我们可以很容易地把东西连接在一起,而且基本上消除了任何的spagettification倾向。我们有一个扁平化的组件列表,当我们需要的时候,AngularJS会把它们一个一个地交给我们。</target>
        </trans-unit>
        <trans-unit id="01c6c85a35ab8aa0b42467c4fd5ea8262061e009" translate="yes" xml:space="preserve">
          <source>This might sound complicated, in fact, once you relax into it, it's like flying. You don't need to create the $scope object, AngularJS instantiates and configures it for you, correctly and appropriately based on your template hierarchy. AngularJS then makes it available to your component using the magic of dependency injection (more on this later).</source>
          <target state="translated">这听起来可能很复杂,事实上,一旦你放松到其中,就像飞一样。你不需要创建$scope对象,AngularJS会根据你的模板层次结构正确、适当地为你实例化并配置它。然后,AngularJS通过依赖注入的魔力将其提供给你的组件(后面会有更多介绍)。</target>
        </trans-unit>
        <trans-unit id="026686ca92306b82d1e8c15693deeebfe16be490" translate="yes" xml:space="preserve">
          <source>Those are some very nice, but lengthy answers.</source>
          <target state="translated">这些都是一些很好的答案,但是很冗长。</target>
        </trans-unit>
        <trans-unit id="b3d3c648ebb51538f239af45aaff5bf2a9ed2172" translate="yes" xml:space="preserve">
          <source>Though I didn't show it here, the data binding is two-way. So those log messages could also be editable in the view just by doing this: &lt;code&gt;&amp;lt;input ng-model=&quot;entry.msg&quot; /&amp;gt;&lt;/code&gt;. And there was much rejoicing.</source>
          <target state="translated">尽管这里没有显示，但数据绑定是双向的。 因此，只需执行以下操作，即可在视图中编辑那些日志消息： &lt;code&gt;&amp;lt;input ng-model=&quot;entry.msg&quot; /&amp;gt;&lt;/code&gt; 。 有很多的欣喜。</target>
        </trans-unit>
        <trans-unit id="ea44fd1157e8b164de6f12bfc47356be4ca15c22" translate="yes" xml:space="preserve">
          <source>To answer this question, I want to share my experience on the first enterprise application with AngularJS. These are the most awesome features that Angular provide where we start changing our jQuery mindset and we get the Angular like a framework and not the library.</source>
          <target state="translated">为了回答这个问题,我想分享一下我在第一个企业级应用AngularJS上的经验。这些都是Angular提供的最牛逼的功能,在这里我们开始改变jQuery的思维方式,我们得到的Angular就像一个框架而不是库一样。</target>
        </trans-unit>
        <trans-unit id="d960bde17bc0fc487713623ef832bfbb6216643e" translate="yes" xml:space="preserve">
          <source>To describe the &quot;paradigm shift&quot;, I think a short answer can suffice.</source>
          <target state="translated">要说到 &quot;范式的转变&quot;,我想简单的回答一下就够了。</target>
        </trans-unit>
        <trans-unit id="74c492c9268c2ba44b4ae9400fc50533ad33c007" translate="yes" xml:space="preserve">
          <source>To help us out with separation of concerns is &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt; (DI). If you come from a server-side language (from &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; to &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;) you're probably familiar with this concept already, but if you're a client-side guy coming from jQuery, this concept can seem anything from silly to superfluous to hipster. But it's not. :-)</source>
          <target state="translated">帮助我们分离关注点的是&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;依赖注入&lt;/a&gt; （DI）。 如果您来自服务器端语言（从&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt;到&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt; ），您可能已经熟悉此概念，但是如果您是来自jQuery的客户端人员，那么这个概念似乎从愚蠢到多余到时髦都不是。 。 但事实并非如此。 :-)</target>
        </trans-unit>
        <trans-unit id="57c4a51d2a57fb7332a311ca65fbda307945a043" translate="yes" xml:space="preserve">
          <source>To put in another way, in jQuery, you need to think about CSS selectors, that is, where is the &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;td&lt;/code&gt; that has a class or attribute, etc., so that I can get their HTML or color or value, but in AngularJS, you will find yourself thinking like this: what model am I dealing with, I will set the model's value to true. You are not bothering yourself of whether the view reflecting this value is a checked box or resides in a &lt;code&gt;td&lt;/code&gt; element (details you would have often needed to think about in jQuery).</source>
          <target state="translated">换句话说，在jQuery中，您需要考虑CSS选择器，即具有类或属性等的 &lt;code&gt;div&lt;/code&gt; 或 &lt;code&gt;td&lt;/code&gt; 在哪里，以便可以获取它们的HTML或颜色或值，但是在AngularJS，您会发现自己是这样想的：我要处理的模型是什么，我将模型的值设置为true。 您不必担心反映此值的视图是复选框还是驻留在 &lt;code&gt;td&lt;/code&gt; 元素中（详细信息，您通常需要在jQuery中进行思考）。</target>
        </trans-unit>
        <trans-unit id="f4709eee581374c200f042fc55313a1c370597e0" translate="yes" xml:space="preserve">
          <source>To sum up</source>
          <target state="translated">总结一下</target>
        </trans-unit>
        <trans-unit id="836dd86d4b838ebe7598bd4b4cf3a469296eba00" translate="yes" xml:space="preserve">
          <source>To sum up my experiences:</source>
          <target state="translated">总结一下我的经验。</target>
        </trans-unit>
        <trans-unit id="ce1ba8a1eb8df452a4296dfeb3f52aabce22bb11" translate="yes" xml:space="preserve">
          <source>Unobtrusive JavaScript with Selectors vs. Declarative Templates</source>
          <target state="translated">使用选择器与声明式模板的不明显的JavaScript与声明式模板对比</target>
        </trans-unit>
        <trans-unit id="7dbc3550a5fc4912024fa7d8d15ebd8dac9e9fc3" translate="yes" xml:space="preserve">
          <source>Until you start to use this, it's hard to explain just what a massive time boon this is. Nothing like AngularJS DI exists inside jQuery.</source>
          <target state="translated">在你开始使用这个东西之前,很难解释这是一个多么巨大的时间福音。在jQuery内部,没有任何东西能像AngularJS DI这样的存在。</target>
        </trans-unit>
        <trans-unit id="955f8bb419dd7b30b67b29f047877ec5da2bfed5" translate="yes" xml:space="preserve">
          <source>Until you want to make a small change.</source>
          <target state="translated">直到你想做一个小小的改变。</target>
        </trans-unit>
        <trans-unit id="03fc4791bb56c36c6c9fce6cb595b363618e13c3" translate="yes" xml:space="preserve">
          <source>View - Your views are written in HTML. The view is usually not semantic because your data lives in the model.</source>
          <target state="translated">视图-你的视图是用HTML编写的。视图通常不是语义的,因为你的数据住在模型中。</target>
        </trans-unit>
        <trans-unit id="5a862f238c06fc71828a9a25732468b79fbb1861" translate="yes" xml:space="preserve">
          <source>What is the biggest difference? What should I stop doing/using; what should I start doing/using instead?</source>
          <target state="translated">最大的区别是什么?我应该停止使用什么;我应该开始使用什么来代替?</target>
        </trans-unit>
        <trans-unit id="0170226ebb8fd23c58004be3a692707980e1d490" translate="yes" xml:space="preserve">
          <source>What should I stop doing/using; What should I start doing/using instead?</source>
          <target state="translated">我应该停止使用什么;我应该开始使用什么来代替?</target>
        </trans-unit>
        <trans-unit id="6e7344707e452d84d6745b34070d9c7734587cd4" translate="yes" xml:space="preserve">
          <source>What this means is that AngularJS reads your entire DOM from top to bottom and treats it as code, literally as instructions to the compiler. As it traverses the DOM, It looks for specific &lt;strong&gt;directives&lt;/strong&gt; (compiler directives) that tell the AngularJS compiler how to behave and what to do. Directives are little objects full of JavaScript which can match against attributes, tags, classes or even comments.</source>
          <target state="translated">这意味着AngularJS从头到尾读取您的整个DOM，并将其视为代码，从字面上看是对编译器的指令。 在遍历DOM时，它会寻找特定的&lt;strong&gt;指令&lt;/strong&gt; （编译器指令），这些指令告诉AngularJS编译器如何运行以及如何执行。 指令是充满JavaScript的小对象，可以与属性，标签，类甚至注释进行匹配。</target>
        </trans-unit>
        <trans-unit id="065885e8affa9b9b626e5ee7819e4774e1e660cf" translate="yes" xml:space="preserve">
          <source>When the Angular compiler determines that a piece of the DOM matches a particular directive, it calls the directive function, passing it the DOM element, any attributes, the current $scope (which is a local variable store), and some other useful bits. These attributes may contain expressions which can be interpreted by the Directive, and which tell it how to render, and when it should redraw itself.</source>
          <target state="translated">当Angular编译器确定DOM中的某个部分与某个特定的指令相匹配时,它就会调用指令函数,将DOM元素、任何属性、当前的$scope(这是一个本地变量存储)以及其他一些有用的位子传递给它。这些属性可能包含可以被Directive解释的表达式,并告诉它如何渲染,以及何时应该重新绘制。</target>
        </trans-unit>
        <trans-unit id="b1f85922f7e91e37e11942af0d06bbc55d4f2b85" translate="yes" xml:space="preserve">
          <source>When we just look at the view, it's not immediately obvious that there is any functionality here. For small applications, that's fine. But for non-trivial applications, things quickly get confusing and hard to maintain.</source>
          <target state="translated">当我们只看视图的时候,并不能马上看出这里有什么功能。对于小型应用,这很好。但对于非琐碎的应用,事情很快就会变得混乱,难以维护。</target>
        </trans-unit>
        <trans-unit id="f1562ae865a8c76b7015478b8cdbdfe3f9de7697" translate="yes" xml:space="preserve">
          <source>When you first see this you might be tempted to write AngularJS off as old school intrusive JavaScript (like I did at first). In fact, AngularJS does not play by those rules. In AngularJS, your HTML5 is a template. It is compiled by AngularJS to produce your web page.</source>
          <target state="translated">当你第一次看到这句话的时候,你可能会想把AngularJS写成老派的侵入式JavaScript(就像我一开始那样)。事实上,AngularJS并不遵循这些规则。在AngularJS中,你的HTML5是一个模板。它是由AngularJS编译来制作你的网页的。</target>
        </trans-unit>
        <trans-unit id="7f3d35681fa2c63c5104c34b879516df9d536a1b" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;jQuery&lt;/strong&gt; you tell the DOM what needs to happen, step by step. With &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;&lt;/strong&gt; you describe what results you want but not how to do it. More on this &lt;a href=&quot;https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming&quot;&gt;here&lt;/a&gt;. Also, check out Mark Rajcok's answer.</source>
          <target state="translated">使用&lt;strong&gt;jQuery，&lt;/strong&gt;您可以逐步告诉DOM需要做什么。 使用&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS，&lt;/a&gt;&lt;/strong&gt;您可以描述所需的结果，而不是所需的结果。 在这更多。 另外，请查看Mark Rajcok的答案。</target>
        </trans-unit>
        <trans-unit id="fc839325c446b08cf5a65d8819d89d6bb3164e33" translate="yes" xml:space="preserve">
          <source>With AngularJS you have your model (JavaScript objects you are already used to) and the value of the model tells you about the model (obviously) and about the view, and an operation on the model automatically propagates to the view, so you don't have to think about it. You will find yourself in AngularJS no longer finding things in the DOM.</source>
          <target state="translated">使用AngularJS,你有了你的模型(你已经习惯了的JavaScript对象),模型的值会告诉你关于模型(很明显)和视图,对模型的一个操作会自动传播到视图中,所以你不需要考虑。你会发现自己在AngularJS中不再是在DOM中找东西了。</target>
        </trans-unit>
        <trans-unit id="4652c10e282176714fe41ae1e85eb5402efa7939" translate="yes" xml:space="preserve">
          <source>With jQuery your HTML page should contain semantic meaningful content. If the JavaScript is turned off (by a user or search engine) your content remains accessible.</source>
          <target state="translated">使用jQuery,你的HTML页面应该包含有意义的语义内容。如果JavaScript被关闭(用户或搜索引擎),你的内容仍然可以访问。</target>
        </trans-unit>
        <trans-unit id="ca1706ec5fb5ac78f5fde18c0d8566fbe135cc3c" translate="yes" xml:space="preserve">
          <source>You can do a lot with jQuery without knowing about how JavaScript prototypal inheritance works. When developing AngularJS applications, you will avoid some common pitfalls if you have a good understanding of JavaScript inheritance. Recommended reading: &lt;a href=&quot;https://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs&quot;&gt;What are the nuances of scope prototypal / prototypical inheritance in AngularJS?&lt;/a&gt;</source>
          <target state="translated">您可以在不了解JavaScript原型继承如何工作的情况下使用jQuery做很多事情。 在开发AngularJS应用程序时，如果您对JavaScript继承有很好的了解，将避免一些常见的陷阱。 推荐阅读： &lt;a href=&quot;https://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs&quot;&gt;AngularJS中范围原型/原型继承的细微差别是什么？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3bccb18f2df39489cf9c94bdc521ad8c56f6483" translate="yes" xml:space="preserve">
          <source>You get simple code reuse, if you want to write another application based on Flickr, you can just include the Flickr module and voila, you have access to all your Flickr related functions in your new application.</source>
          <target state="translated">你可以获得简单的代码重用,如果你想在Flickr的基础上编写另一个应用程序,你只需将Flickr模块包含在内,就可以在你的新应用程序中访问所有与Flickr相关的功能。</target>
        </trans-unit>
        <trans-unit id="07a633bd9c67d80494b78137069dcf9bff6f8d9c" translate="yes" xml:space="preserve">
          <source>You may use it on existing applications where you are already using pure jQuery. However, if you want to fully take advantage of the AngularJS features you may consider coding the server side using a &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; approach.</source>
          <target state="translated">您可以在已经使用纯jQuery的现有应用程序上使用它。 但是，如果您想充分利用AngularJS功能，则可以考虑使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt;方法对服务器端进行编码。</target>
        </trans-unit>
        <trans-unit id="93e48c750ccd396d3473070f7e54269ec34e6751" translate="yes" xml:space="preserve">
          <source>You'll often hear &quot;only do DOM manipulation in a directive&quot;. &lt;strong&gt;This is a necessity.&lt;/strong&gt; Treat it with due deference!</source>
          <target state="translated">您会经常听到&amp;ldquo;仅在指令中进行DOM操作&amp;rdquo;。 &lt;strong&gt;这是必须的。&lt;/strong&gt; 谨慎对待它！</target>
        </trans-unit>
        <trans-unit id="e9d5a9c89b6ee27e430aeadc83c97fafeb311b2e" translate="yes" xml:space="preserve">
          <source>Your template drives your application. It's treated as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL&lt;/a&gt;. You write AngularJS components, and AngularJS will take care of pulling them in and making them available at the right time based on the structure of your template. This is very different to a standard &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; pattern, where the template is just for output.</source>
          <target state="translated">您的模板将驱动您的应用程序。 它被视为&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL&lt;/a&gt; 。 您编写了AngularJS组件，AngularJS将根据模板的结构将它们拉入并在适当的时间使其可用。 这与标准&lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt;模式非常不同，在标准MVC模式中，模板仅用于输出。</target>
        </trans-unit>
        <trans-unit id="f63336c8b68dbd54d77ba260a5e6c9141be9ff84" translate="yes" xml:space="preserve">
          <source>Your template should be declarative; its meaning should be clear simply by reading it. We use custom attributes with meaningful names. We make up new HTML elements, again with meaningful names. A designer with minimal HTML knowledge and no coding skill can read your AngularJS template and understand what it is doing. He or she can make modifications. &lt;em&gt;This is the Angular way.&lt;/em&gt;</source>
          <target state="translated">您的模板应该是声明性的； 只需阅读即可清楚了解其含义。 我们使用具有有意义名称的自定义属性。 我们用有意义的名称组成新的HTML元素。 仅有很少的HTML知识并且没有编码技能的设计人员可以阅读您的AngularJS模板并了解其功能。 他或她可以进行修改。 &lt;em&gt;这是角度的方式。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bdf7e60e32dde216fb6e902f1792e6d04b0b4e9" translate="yes" xml:space="preserve">
          <source>and there is one more thing, that's the directive. It's an attribute  you can attach to any DOM element and you can go nuts with jQuery within it without worrying about your jQuery ever conflicts with AngularJs components or messes up with its architecture.</source>
          <target state="translated">还有一件事,那就是指令。它是一个属性,你可以附加到任何DOM元素上,你可以在其中疯狂地使用jQuery,而不用担心你的jQuery会与AngularJs组件冲突,也不用担心会破坏它的架构。</target>
        </trans-unit>
        <trans-unit id="00853d73f19844948fadbc48d500f997c46f7ee4" translate="yes" xml:space="preserve">
          <source>jQuery</source>
          <target state="translated">jQuery</target>
        </trans-unit>
        <trans-unit id="be925b4f423bcada24aaecc3aafd5c04280ae11d" translate="yes" xml:space="preserve">
          <source>jQuery employs &lt;a href=&quot;http://en.wikipedia.org/wiki/Unobtrusive_JavaScript&quot;&gt;unobtrusive JavaScript&lt;/a&gt; - behavior (JavaScript) is separated from the structure (HTML).</source>
          <target state="translated">jQuery使用了&lt;a href=&quot;http://en.wikipedia.org/wiki/Unobtrusive_JavaScript&quot;&gt;不引人注目的JavaScript-&lt;/a&gt;行为（JavaScript）与结构（HTML）是分开的。</target>
        </trans-unit>
        <trans-unit id="c320142ede798313f44c3d11d76a83ae93eda792" translate="yes" xml:space="preserve">
          <source>jQuery gives you a toolkit for selecting arbitrary bits of the DOM and making ad-hoc changes to them. You can do pretty much anything you like piece by piece.</source>
          <target state="translated">jQuery给了你一个工具包,可以选择DOM的任意位并对其进行临时性的修改。你可以做几乎任何你喜欢的事情。</target>
        </trans-unit>
        <trans-unit id="a9491d0d475183db24d559659151458a8832e918" translate="yes" xml:space="preserve">
          <source>jQuery is a DOM manipulation library.</source>
          <target state="translated">jQuery是一个DOM操作库。</target>
        </trans-unit>
        <trans-unit id="dc5ccb5632110fdd3b6daae0577b2656f4f69591" translate="yes" xml:space="preserve">
          <source>jQuery is a way to make programming JavaScript in the browser easier. Shorter, cross-browser commands, etc.</source>
          <target state="translated">jQuery是一种让浏览器中的JavaScript编程更容易的方法。更短,跨浏览器的命令等。</target>
        </trans-unit>
        <trans-unit id="18f057b6ceb40d6c2c4a68a9d1752b11d2e478bc" translate="yes" xml:space="preserve">
          <source>jQuery is all about DOM manipulation. It solves all the cross browser pain otherwise you will have to deal with but it's not a framework that allows you to divide your app into components like AngularJS.</source>
          <target state="translated">jQuery是关于DOM操作的全部内容。它解决了所有的跨浏览器的痛点,否则你将不得不处理,但它不是一个框架,可以让你的应用程序像AngularJS一样,分成组件。</target>
        </trans-unit>
        <trans-unit id="b8a1fbe4c24f3cd32559fc40d013cf05b48575a8" translate="yes" xml:space="preserve">
          <source>jQuery is typically applied unobtrusively. Your JavaScript code is linked in the header (or the footer), and this is the only place it is mentioned. We use selectors to pick out bits of the page and write plugins to modify those parts.</source>
          <target state="translated">jQuery的应用通常是不引人注意的。你的JavaScript代码被链接在页眉(或页脚),这是唯一被提及的地方。我们使用选择器来挑出页面中的位,然后编写插件来修改这些部分。</target>
        </trans-unit>
        <trans-unit id="970e2a9590ad405940e9e253b4e0d66959d31936" translate="yes" xml:space="preserve">
          <source>jQuery makes ridiculously long JavaScript commands like &lt;code&gt;getElementByHerpDerp&lt;/code&gt; shorter and cross-browser.</source>
          <target state="translated">jQuery使 &lt;code&gt;getElementByHerpDerp&lt;/code&gt; 等可笑的长JavaScript命令变得更短且跨浏览器。</target>
        </trans-unit>
        <trans-unit id="c7b8d7c0d6361934bbf52868690dfdb5012d95ae" translate="yes" xml:space="preserve">
          <source>jQuery says very little about how you should organise your code. AngularJS has opinions.</source>
          <target state="translated">jQuery很少说你应该如何组织你的代码。AngularJS是有意见的。</target>
        </trans-unit>
        <trans-unit id="34f8968c02f9b2effb99adc9f1eadb7ef80c5c90" translate="yes" xml:space="preserve">
          <source>jQuery: you think a lot about 'QUERYing the &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;' for DOM elements and doing something.</source>
          <target state="translated">jQuery：关于DOM元素&amp;ldquo;查询&lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; &amp;rdquo;并做一些事情，您考虑了很多。</target>
        </trans-unit>
        <trans-unit id="5ba0c567dacd0527890e40d7b7790df6aec5ca39" translate="yes" xml:space="preserve">
          <source>w00t!</source>
          <target state="translated">w00t!</target>
        </trans-unit>
        <trans-unit id="c546eb5a1fdcd9672da789e9684f30280d159a04" translate="yes" xml:space="preserve">
          <source>will output the user name in a paragraph. It's a live binding, so if the &lt;code&gt;$scope.user.name&lt;/code&gt; value is updated, the template will update too.</source>
          <target state="translated">将在一个段落中输出用户名。 这是实时绑定，因此如果 &lt;code&gt;$scope.user.name&lt;/code&gt; 值被更新，则模板也将更新。</target>
        </trans-unit>
        <trans-unit id="cbda61a42cf4628d5b234a95997da65ed8079da7" translate="yes" xml:space="preserve">
          <source>“Thinking in AngularJS” if I have a jQuery background</source>
          <target state="translated">&quot;用AngularJS思考&quot;,如果我有jQuery的背景</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
