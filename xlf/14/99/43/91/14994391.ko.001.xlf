<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/14994391">
    <body>
      <group id="14994391">
        <trans-unit id="2e892d84a456775f25c00e4f845837dd39c07406" translate="yes" xml:space="preserve">
          <source>--&amp;gt;For any developer coming from jQuery background, my first advice would be to &quot;learn JavaScript as a first class language before jumping onto a rich framework like AngularJS!&quot;
I learned the above fact the hard way.</source>
          <target state="translated">-&amp;gt; jQuery 배경에서 온 개발자의 경우, 첫 번째 조언은 &quot;AngularJS와 같은 풍부한 프레임 워크로 넘어 가기 전에 JavaScript를 일급 언어로 배우는 것&quot;입니다. 위의 사실을 어려운 방법으로 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="396fc50aacb3d9fb04c78bba466f7908a2e8385d" translate="yes" xml:space="preserve">
          <source>1. Don't design your page, and then change it with &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; manipulations</source>
          <target state="translated">1. 페이지를 디자인하지 말고 &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; 조작으로 변경하십시오</target>
        </trans-unit>
        <trans-unit id="3828151a3b203e32a8d4b22c6fdb84d2f290a8bc" translate="yes" xml:space="preserve">
          <source>2. Don't augment jQuery with AngularJS</source>
          <target state="translated">2. AngularJS로 jQuery를 보강하지 마십시오</target>
        </trans-unit>
        <trans-unit id="cbedaed8896e96dbbaa762bfb0a519199fab646b" translate="yes" xml:space="preserve">
          <source>3. Always think in terms of architecture</source>
          <target state="translated">3. 항상 건축의 관점에서 생각</target>
        </trans-unit>
        <trans-unit id="9bb57b273b075b57706f730ef766b8139c69ca9e" translate="yes" xml:space="preserve">
          <source>4. Test-driven development - &lt;em&gt;always&lt;/em&gt;</source>
          <target state="translated">4. 테스트 중심 개발- &lt;em&gt;항상&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5df0490b33144a83a19e27b67ca325463559d8dd" translate="yes" xml:space="preserve">
          <source>5. Conceptually, directives are &lt;em&gt;not&lt;/em&gt; packaged jQuery</source>
          <target state="translated">5. 개념적으로 지시어는 jQuery로 패키지 &lt;em&gt;되지 않습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d37a0363a38e4535d4fbf679c38b69053d2845a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Dependency injection&lt;/a&gt; (DI) vs. Instatiation - aka de-spaghettification</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;의존성 주입&lt;/a&gt; (DI) vs. 인스톨레이션-일명 De-spaghettification</target>
        </trans-unit>
        <trans-unit id="5b2bf38bee1c00dcbf6a933d82ad04998661ee32" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;Separation of concerns&lt;/a&gt; (SOC) is a pattern that grew up over many years of web development for a variety of reasons including SEO, accessibility and browser incompatibility. It looks like this:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;우려 분리&lt;/a&gt; (SOC)는 SEO, 접근성 및 브라우저 비 호환성을 포함하여 다양한 이유로 수년간 웹 개발을 통해 자란 패턴입니다. 다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="50b9bf0923a4b128bb297b2cf829a6c75cccc91e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;/ &lt;a href=&quot;http://underscorejs.org&quot;&gt;Underscore&lt;/a&gt; for the &lt;strong&gt;facade pattern&lt;/strong&gt; (like WYSIWYG's for manipulating the DOM)</source>
          <target state="translated">&lt;strong&gt;파사드 패턴&lt;/strong&gt; 의 &lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt; / &lt;a href=&quot;http://underscorejs.org&quot;&gt;밑줄&lt;/a&gt; (예 : WYSIWYG와 같은 DOM 조작)</target>
        </trans-unit>
        <trans-unit id="69042625919dd0e27703e71445b2b7bd23b39703" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://knockoutjs.com&quot;&gt;KnockoutJS&lt;/a&gt; for the &lt;strong&gt;observable, publish/subscribe pattern&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;관찰 가능, 발행 / 구독 패턴을&lt;/strong&gt; 위한 &lt;a href=&quot;http://knockoutjs.com&quot;&gt;KnockoutJS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7a0982ee2f9c3c522d1ee89cd375e2cb7609417" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://prototypejs.org&quot;&gt;Prototype.js&lt;/a&gt; for the &lt;strong&gt;prototype/ constructor/ mixin pattern&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;http://prototypejs.org&quot;&gt;프로토&lt;/a&gt; &lt;strong&gt;타입 / 생성자 / 믹스 인 패턴을&lt;/strong&gt; 위한 Prototype.js</target>
        </trans-unit>
        <trans-unit id="92b3217c5ba1cc0f9135ed9705adca8c3f975b4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://requirejs.org&quot;&gt;RequireJS&lt;/a&gt;/ &lt;a href=&quot;https://github.com/cujojs/curl&quot;&gt;Curl.js&lt;/a&gt; for the &lt;strong&gt;module pattern/ AMD&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;모듈 패턴을&lt;/strong&gt; 위한 &lt;a href=&quot;http://requirejs.org&quot;&gt;RequireJS&lt;/a&gt; / &lt;a href=&quot;https://github.com/cujojs/curl&quot;&gt;Curl.js&lt;/a&gt; &lt;strong&gt;/ AMD&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9b870b99d1adcc3ce0b3833fc3f86074e9524de" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.google.be/search?q=js+oop&quot;&gt;JavaScript Object-oriented Programming&lt;/a&gt; (this is a Google search link). It is not a library, but certainly a prerequisite to any application programming. It taught me the native implementations of the &lt;strong&gt;prototype, constructor, singleton &amp;amp; decorator patterns&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.google.be/search?q=js+oop&quot;&gt;자바 스크립트 객체 지향 프로그래밍&lt;/a&gt; (Google 검색 링크) 라이브러리는 아니지만 모든 응용 프로그램 프로그래밍의 전제 조건입니다. &lt;strong&gt;프로토 타입, 생성자, 싱글 톤 및 데코레이터 패턴&lt;/strong&gt; 의 기본 구현을 가르쳐주었습니다.</target>
        </trans-unit>
        <trans-unit id="abd6dd62d85dac964abb4fc9b6d39f70c1511d55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The AngularJS way is to extend the capabilities of native looking HTML.&lt;/em&gt; You should write HTML that looks like HTML, extended with custom attributes and elements.</source>
          <target state="translated">&lt;em&gt;AngularJS 방식은 네이티브 HTML의 기능을 확장하는 것입니다.&lt;/em&gt; 사용자 정의 속성 및 요소로 확장 된 HTML처럼 보이는 HTML을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="42d5cb01532a1eb833bc5dc3442165730fc715f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS and jQuery:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;AngularJS와 jQuery :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2cb0e6123d036e1454b06c3e92f6619c31e7b8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS&lt;/strong&gt; is a beautiful client-side framework, highly testable, that combines tons of cool stuff such as MVC, &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, data binding and much more.</source>
          <target state="translated">&lt;strong&gt;AngularJS&lt;/strong&gt; 는 MVC, &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;의존성 주입&lt;/a&gt; , 데이터 바인딩 등과 같은 멋진 것들을 결합한 테스트 가능한 아름다운 클라이언트 측 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="0f7938672e21aa28fcfa2974e178640ad994aae7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controllers are great:&lt;/strong&gt;
Controllers take care of their own HTML, but this separation works well for common functionality well as. If you want to call the same function on the click of a button on master HTML, just write the same function name in each controller and write individual code.</source>
          <target state="translated">&lt;strong&gt;컨트롤러는 훌륭합니다.&lt;/strong&gt; 컨트롤러는 자체 HTML을 관리하지만 이러한 구분은 일반적인 기능에 효과적입니다. 마스터 HTML에서 버튼을 클릭하여 동일한 함수를 호출하려면 각 컨트롤러에 동일한 함수 이름을 작성하고 개별 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c11e6c999d67e30b4dd08344b653ee2887d7eeb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensibility&lt;/strong&gt;: Angular has extended the HTML directives using angular directives. Write expressions inside html and evaluate them on runtime. Create your own directives and services and use them in another project without any extra effort.</source>
          <target state="translated">&lt;strong&gt;확장 성&lt;/strong&gt; : Angular는 각도 지시문을 사용하여 HTML 지시문을 확장했습니다. html 안에 표현식을 작성하고 런타임에 평가하십시오. 직접 지시문과 서비스를 작성하고 별도의 노력없이 다른 프로젝트에서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0a5df869fa8dc89f42caf2f14c8a4d5438689936" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IGOR&lt;/strong&gt;: So think of directive as the instruction to the compiler that tells it whenever you come across this certain element or this CSS in the template, and you keep this kind of code and that code is in charge of the element and everything below that element in the DOM tree.</source>
          <target state="translated">&lt;strong&gt;IGOR&lt;/strong&gt; : 지시어는 템플릿 에서이 특정 요소 또는 CSS를 발견 할 때마다 지시하는 컴파일러의 명령으로 생각하십시오. 이러한 종류의 코드를 유지하면 해당 코드는 해당 요소와 해당 요소 아래의 모든 것을 담당합니다 DOM 트리에서.</target>
        </trans-unit>
        <trans-unit id="fb847df57ef2048ada827543b7b83275102b35c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ideal for &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; architecture:&lt;/strong&gt;
Being a complete frameworks makes AngularJS great to work with a RESTful architecture. To call REST CRUD APIs is very easier and</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; 아키텍처에 이상적 :&lt;/strong&gt; AngularJS는 완전한 프레임 워크이기 때문에 RESTful 아키텍처와 함께 사용할 수 있습니다. REST CRUD API를 호출하는 것은 매우 쉽고</target>
        </trans-unit>
        <trans-unit id="6db3ad18a3fcffc3e35affc669f632a630d17906" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you have some data and are now trying to update HTML... STOP! update the model, and make sure your HTML is bound to the model.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;데이터가 있고 HTML을 업데이트하려는 경우 ... 중지!&lt;/strong&gt; &lt;strong&gt;모델을 업데이트하고 HTML이 모델에 바인딩되어 있는지 확인하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a19b1a68f851522bd0cf824036f977b0867ca9fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Imperative vs Declarative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;명령형 대 선언 형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f010845158f0f95b6de7c77468721d2aacc26955" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MISKO&lt;/strong&gt;: [...] one of the things we thought about very hardly in Angular is, how do we provide lots of escape hatches so that you can get out and basically figure out a way out of this. So to us, the answer is this thing called &amp;ldquo;Directives&amp;rdquo;. &lt;strong&gt;And with directives, you essentially become a regular little jQuery JavaScript, you can do whatever you want.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MISKO&lt;/strong&gt; : [...] 우리가 Angular에서 거의 생각하지 &lt;strong&gt;못한&lt;/strong&gt; 것 중 하나는 탈출구를 어떻게 제공하고 기본적으로 이것으로부터 벗어날 수있는 방법을 알아낼 수 있는가입니다. 우리에게 답은&amp;ldquo;지시문&amp;rdquo;이라고하는 것입니다. &lt;strong&gt;지시문을 사용하면 본질적으로 규칙적인 작은 jQuery JavaScript가되어 원하는대로 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb2c2d380076a74aa03ad025fcf7629b16d2b1de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins extend jQuery. AngularJS Directives extend the capabilities of your browser.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;플러그인은 jQuery를 확장합니다.&lt;/strong&gt; &lt;strong&gt;AngularJS 지시문은 브라우저의 기능을 확장합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c47fced225128e4a144ce379fa468a4309c6e8e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins:&lt;/strong&gt;
There are many other similar features like showing an overlay in your app. You don't need to write code for it, just use an overlay plugin available as wc-overlay, and this will automatically take care of all &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; (XHR) requests.</source>
          <target state="translated">&lt;strong&gt;플러그인 :&lt;/strong&gt; 앱에 오버레이 표시와 같은 다른 유사한 기능이 많이 있습니다. 코드를 작성할 필요가 없으며 wc-overlay로 제공되는 오버레이 플러그인 만 사용하면 모든 XHR ( &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; ) 요청이 자동으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="887a0d220804750ef67bb7862fb203a7bd2bcb18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reusable directives are super:&lt;/strong&gt;
Write directives in one place and use it throughout the application. OMG!!! I used these directive for paging, regex, validations, etc. It is really cool!</source>
          <target state="translated">&lt;strong&gt;재사용 가능한 지시문은 슈퍼입니다.&lt;/strong&gt; 지시문을 한 곳에 작성하여 응용 프로그램 전체에서 사용하십시오. 세상에! 페이징, 정규식, 유효성 검사 등에 이러한 지시문을 사용했습니다. 정말 멋집니다!</target>
        </trans-unit>
        <trans-unit id="f69a19e5ccd84c1031161d37ece994aed62fe59d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Routing is strong:&lt;/strong&gt;
It's up to your implementation how you want to use it, but it requires very few lines of code to route the request to specify HTML and controller (JavaScript)</source>
          <target state="translated">&lt;strong&gt;라우팅은 강력합니다.&lt;/strong&gt; 사용 방법에 따라 구현 방법이 다르지만 HTML 및 컨트롤러 (JavaScript)를 지정하기 위해 요청을 라우팅하는 데 코드 줄이 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="797f295648a2a0dbe2273589c1be293d5bfe525f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Services&lt;/strong&gt;: Write common codes using services and less code in controllers. Sevices can be used to share common functionalities among the controllers.</source>
          <target state="translated">&lt;strong&gt;서비스&lt;/strong&gt; : 컨트롤러에서 서비스와 적은 코드를 사용하여 공통 코드를 작성하십시오. 컨트롤러간에 공통 기능을 공유하기 위해 서비스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="138e836a952df3aa65cdcd5ed6d0228190442e07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stop trying to drive your application from your JavaScript. Let the template drive the application, and let AngularJS take care of wiring the components together. This also is the Angular way.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JavaScript에서 애플리케이션을 구동하려고하지 마십시오.&lt;/strong&gt; &lt;strong&gt;템플릿이 응용 프로그램을 구동하게하고 AngularJS가 구성 요소를 함께 배선하도록합니다.&lt;/strong&gt; &lt;strong&gt;이것은 또한 각도 방식입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fdb21836db9637198f74d2b8f19405107dec8dbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This means that Angular is Template Driven&lt;/strong&gt;. Your template drives the JavaScript, not the other way around. This is a radical reversal of roles, and the complete opposite of the unobtrusive JavaScript we have been writing for the last 10 years or so. This can take some getting used to.</source>
          <target state="translated">&lt;strong&gt;이것은 Angular가 Template Driven이라는 것을 의미합니다&lt;/strong&gt; . 템플릿은 다른 방식이 아닌 JavaScript를 구동합니다. 이것은 역할의 급진적 인 반전이며 지난 10 년 동안 우리가 작성해 온 명백한 JavaScript와 완전히 반대입니다. 익숙해지는 데 시간이 좀 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20ab0f6802a5394aa105383981477201dead0b2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two-way data binding is amazing:&lt;/strong&gt; 
I had a grid with all functionality UPDATE, DELTE, INSERT. I have a data object that binds the grid's model using ng-repeat. You only need to write a single line of simple JavaScript code for delete and insert and that's it. grid automatically updates as the grid model changes instantly. Update functionality is real time, no code for it.
You feel amazing!!!</source>
          <target state="translated">&lt;strong&gt;양방향 데이터 바인딩은 놀랍습니다.&lt;/strong&gt; 모든 기능 UPDATE, DELTE, INSERT가있는 그리드가 있습니다. ng-repeat를 사용하여 그리드의 모델을 바인딩하는 데이터 객체가 있습니다. 삭제 및 삽입을 위해 한 줄의 간단한 JavaScript 코드 만 작성하면됩니다. 그리드 모델이 즉시 변경되면 그리드가 자동으로 업데이트됩니다. 업데이트 기능은 실시간이며 코드는 없습니다. 당신은 놀라운 느낌!</target>
        </trans-unit>
        <trans-unit id="36ae55072d91b6ded3403dc2b4cad372aaa77444" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your HTML source is no longer semantic, instead, your API and compiled DOM are semantic.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTML 소스는 더 이상 의미가 없으며 대신 API와 컴파일 된 DOM은 의미가 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0ed9f7320d225087a2cabdd3049cfd766fead2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery&lt;/strong&gt; is a library</source>
          <target state="translated">&lt;strong&gt;jQuery&lt;/strong&gt; 는 라이브러리입니다</target>
        </trans-unit>
        <trans-unit id="6c335564959dc2af53604b8909e474e66420b796" translate="yes" xml:space="preserve">
          <source>A nice thing about AngularJs is that it allows you to separate/isolate the DOM manipulation in the directives.  There are built-in directives ready for you to use such as ng-click. You can create your own custom directives that will contain all your view logic or DOM manipulation so you don't end up mingle DOM manipulation code in the controllers or services that should take care of the business logic.</source>
          <target state="translated">AngularJ의 좋은 점은 지시문에서 DOM 조작을 분리 / 분리 할 수 ​​있다는 것입니다. ng-click과 같이 사용할 수있는 내장 지시문이 있습니다. 모든 뷰 로직 또는 DOM 조작을 포함하는 사용자 정의 지시문을 작성할 수 있으므로 비즈니스 로직을 처리해야하는 컨트롤러 또는 서비스에서 DOM 조작 코드를 혼동하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="7ceb5d7ed6945141f56ba005625ff024d9d7eb17" translate="yes" xml:space="preserve">
          <source>A transcript of the entire episode is available at the link provided above.</source>
          <target state="translated">전체 에피소드의 성적 증명서는 위에 제공된 링크에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b8f9a78d78001336ae3c83f2d488f8880d463909" translate="yes" xml:space="preserve">
          <source>Actually, if you're using AngularJS, you don't need jQuery anymore. AngularJS itself has the binding and directive, which is a very good &quot;replacement&quot; for most things you can do with jQuery.</source>
          <target state="translated">실제로 AngularJS를 사용하는 경우 더 이상 jQuery가 필요하지 않습니다. AngularJS 자체에는 바인딩 및 지시문이 있으며 이는 jQuery로 수행 할 수있는 대부분의 작업에 매우 적합한 &quot;대체&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a982e94ed93b338e6087c54069f224404ee9152d" translate="yes" xml:space="preserve">
          <source>Again, AngularJS does not play by their rules. In a stroke, &lt;strong&gt;AngularJS does away with a decade of received wisdom&lt;/strong&gt; and instead implements an MVC pattern in which the template is no longer semantic, not even a little bit.</source>
          <target state="translated">다시 한 번 AngularJS는 규칙에 따라 재생되지 않습니다. 뇌졸중에서 &lt;strong&gt;AngularJS는 수십 년의 지혜를 버리고&lt;/strong&gt; 대신 템플릿이 더 이상 의미가없고 조금도 의미가없는 MVC 패턴을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="dd4ee4af98c6fe65fb4b3c2b533d9c832398158d" translate="yes" xml:space="preserve">
          <source>Again, the template stuff is in the template, so you (or your users) can easily swap it out for one that meets any style necessary, and the &lt;strong&gt;logic&lt;/strong&gt; never had to be touched. Reusability - boom!</source>
          <target state="translated">다시 말하지만 템플릿 항목은 템플릿에 있으므로 사용자 (또는 사용자)가 필요한 스타일에 맞는 템플릿으로 쉽게 교체 할 수 있으며 &lt;strong&gt;로직&lt;/strong&gt; 을 건드리지 않아도됩니다. 재사용 성-붐!</target>
        </trans-unit>
        <trans-unit id="1480b134e7c98fe4782ceaa71c1becda85bf1d42" translate="yes" xml:space="preserve">
          <source>Ajax all of the time</source>
          <target state="translated">항상 아약스</target>
        </trans-unit>
        <trans-unit id="7088908d0701fd67fecee7fd934804b9635f1eac" translate="yes" xml:space="preserve">
          <source>And I decided to make a tiny code snippet that help me quickly start a website using AngularJS with the power of jQuery Selector (using Sizzle).</source>
          <target state="translated">그리고 jQuery Selector (Sizzle 사용)로 AngularJS를 사용하여 웹 사이트를 빠르게 시작할 수 있도록 작은 코드 스 니펫을 만들기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="b3c9932d142f6e1ee02747f1578184f1f2f6fc13" translate="yes" xml:space="preserve">
          <source>And all of the above tie into this over-arching theme: keep your concerns separate. Your view acts as the official record of what is supposed to happen (for the most part); your model represents your data; you have a service layer to perform reusable tasks; you do DOM manipulation and augment your view with directives; and you glue it all together with controllers. This was also mentioned in other answers, and the only thing I would add pertains to testability, which I discuss in another section below.</source>
          <target state="translated">위의 모든 내용은이 중요한 주제와 관련이 있습니다. 당신의 견해는 (대부분) 일어날 일에 대한 공식 기록으로 작용합니다. 모델은 데이터를 나타냅니다. 재사용 가능한 작업을 수행 할 서비스 계층이 있습니다. DOM 조작을 수행하고 지시문으로 뷰를 보강하십시오. 컨트롤러와 함께 모두 붙입니다. 이것은 다른 답변에서도 언급되었으며, 내가 추가 할 수있는 유일한 것은 테스트 가능성과 관련이 있으며, 아래의 다른 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="717ce7322f7d359fabb874116d82f9a23af3a1cf" translate="yes" xml:space="preserve">
          <source>And fifth, which we've mentioned in previous sections, why are we mixing template stuff into our logic?</source>
          <target state="translated">그리고 이전 섹션에서 언급 한 다섯 번째, 왜 템플릿을 로직에 믹싱합니까?</target>
        </trans-unit>
        <trans-unit id="31b7375227eaf487f50dd9c4d2a4be13432b0992" translate="yes" xml:space="preserve">
          <source>And now instead of using an unordered list, we're using Bootstrap alert boxes. And we never had to change the controller code! But more importantly, no matter &lt;em&gt;where&lt;/em&gt; or &lt;em&gt;how&lt;/em&gt; the log gets updated, the view will change too. Automatically. Neat!</source>
          <target state="translated">이제 순서가없는 목록을 사용하는 대신 부트 스트랩 경고 상자를 사용하고 있습니다. 그리고 컨트롤러 코드를 변경하지 않아도됩니다! 그러나 더 중요한 것은 로그가 업데이트 &lt;em&gt;되는 위치&lt;/em&gt; 나 &lt;em&gt;방법에&lt;/em&gt; 관계없이보기도 변경됩니다. 자동으로. 산뜻한!</target>
        </trans-unit>
        <trans-unit id="ded1b56b02466779ad820433f366b36a1ad7629b" translate="yes" xml:space="preserve">
          <source>And our view can look like this:</source>
          <target state="translated">그리고 우리의 관점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0dec1075f573c8803a10203b7685e0ba502d0e0" translate="yes" xml:space="preserve">
          <source>And there are still all those other benefits, like testing - it's easy! No matter what's in the template, the directive's internal API is never touched, so refactoring is easy. You can change the template as much as you want without touching the directive. And no matter what you change, your tests still pass.</source>
          <target state="translated">그리고 테스트와 같은 다른 모든 이점이 여전히 있습니다. 쉬워요! 템플릿의 내용에 관계없이 지시문의 내부 API는 절대로 손대지 않으므로 리팩토링이 쉽습니다. 지시문을 건드리지 않고 원하는만큼 템플릿을 변경할 수 있습니다. 그리고 무엇을 변경하더라도 테스트는 여전히 통과합니다.</target>
        </trans-unit>
        <trans-unit id="5bee056b415ffd9808306a38b2d56440081c0e20" translate="yes" xml:space="preserve">
          <source>And when we run our test, we can confirm that it fails. Only now should we create our directive:</source>
          <target state="translated">테스트를 실행할 때 실패한 것을 확인할 수 있습니다. 이제 만 지시문을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="180abb5e88521e466bf2e4475cd2b687c06483d9" translate="yes" xml:space="preserve">
          <source>And with DOM manipulation in AngularJS, you find yourself adding directives and filters, which you can think of as valid HTML extensions.</source>
          <target state="translated">AngularJS에서 DOM 조작을하면 지시문과 필터를 추가 할 수 있습니다.이 지시문은 유효한 HTML 확장으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24580187a4254fa76812f2d649f1e29d6069e0b9" translate="yes" xml:space="preserve">
          <source>Angular and jQuery do different things. AngularJS gives you a set of tools to produce web applications. jQuery mainly gives you tools for modifying the DOM. If jQuery is present on your page, AngularJS will use it automatically. If it isn't, AngularJS ships with jQuery Lite, which is a cut down, but still perfectly usable version of jQuery.</source>
          <target state="translated">Angular와 jQuery는 다른 작업을 수행합니다. AngularJS는 웹 애플리케이션을 생성하는 도구 세트를 제공합니다. jQuery는 주로 DOM 수정 도구를 제공합니다. 페이지에 jQuery가 있으면 AngularJS가 자동으로 사용합니다. 그렇지 않은 경우 AngularJS는 jQuery Lite를 제공합니다. 이는 jQuery Lite이지만, 여전히 완벽하게 사용 가능한 jQuery 버전입니다.</target>
        </trans-unit>
        <trans-unit id="743831e45593d1d3b1984a6b44f8c8b5aff24099" translate="yes" xml:space="preserve">
          <source>Angular breaks down your app into 
- Controllers
- Services
- Views
- etc.</source>
          <target state="translated">Angular는 앱을 컨트롤러-서비스-뷰 등으로 분류합니다.</target>
        </trans-unit>
        <trans-unit id="2a3de4a9dc7c9f3bd23b0b53226033777b1c013b" translate="yes" xml:space="preserve">
          <source>AngularJS</source>
          <target state="translated">AngularJS</target>
        </trans-unit>
        <trans-unit id="f39ebda33fdd6cea30fb3e03a8a2d79fcda3487a" translate="yes" xml:space="preserve">
          <source>AngularJS allows you to make your own HTML tags/attributes that do things which work well with dynamic web applications (since HTML was designed for static pages).</source>
          <target state="translated">AngularJS를 사용하면 HTML이 정적 페이지 용으로 설계되었으므로 동적 웹 응용 프로그램과 잘 작동하는 고유 한 HTML 태그 / 속성을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ef7970ea8e67c4542f275b5fdabad15e691725" translate="yes" xml:space="preserve">
          <source>AngularJS and jQuery adopt very different ideologies. If you're coming from jQuery you may find some of the differences surprising. Angular may make you angry.</source>
          <target state="translated">AngularJS와 jQuery는 매우 다른 이데올로기를 채택합니다. jQuery에서 오는 경우 놀라운 차이점을 발견 할 수 있습니다. 각도가 화나게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc13641dffc4ac29f5a7e6fba2f371197f917be0" translate="yes" xml:space="preserve">
          <source>AngularJS and jQuery are not enemies. It's possible to use jQuery within AngularJS very nicely. If you're using AngularJS well (templates, data-binding, $scope, directives, etc.) you will find you need a &lt;strong&gt;lot&lt;/strong&gt; less jQuery than you might otherwise require.</source>
          <target state="translated">AngularJS와 jQuery는 적이 아닙니다. AngularJS 내에서 jQuery를 매우 잘 사용할 수 있습니다. AngularJS를 잘 사용하고 있다면 (템플릿, 데이터 바인딩, $ scope, 지시문 등) 필요한 경우보다 &lt;strong&gt;훨씬&lt;/strong&gt; 적은 jQuery가 필요하다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="222ef2db3e23de37ca20387e96e35891b58e48cd" translate="yes" xml:space="preserve">
          <source>AngularJS changes the way you &lt;em&gt;find&lt;/em&gt; elements</source>
          <target state="translated">AngularJS &lt;em&gt;는&lt;/em&gt; 요소를 &lt;em&gt;찾는&lt;/em&gt; 방식을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="e1c2157022eaa4f2a0716583841f5203e08b070a" translate="yes" xml:space="preserve">
          <source>AngularJS comes with an entire set of tools to make this very easy; with &lt;code&gt;ngClass&lt;/code&gt; we can dynamically update the class; &lt;code&gt;ngModel&lt;/code&gt; allows two-way data binding; &lt;code&gt;ngShow&lt;/code&gt; and &lt;code&gt;ngHide&lt;/code&gt; programmatically show or hide an element; and many more - including the ones we write ourselves. In other words, we can do all kinds of awesomeness &lt;em&gt;without&lt;/em&gt; DOM manipulation. The less DOM manipulation, the easier directives are to test, the easier they are to style, the easier they are to change in the future, and the more re-usable and distributable they are.</source>
          <target state="translated">AngularJS는이를 매우 쉽게하기 위해 전체 도구 세트와 함께 제공됩니다. &lt;code&gt;ngClass&lt;/code&gt; 를 사용하면 클래스를 동적으로 업데이트 할 수 있습니다. &lt;code&gt;ngModel&lt;/code&gt; 은 양방향 데이터 바인딩을 허용합니다. &lt;code&gt;ngShow&lt;/code&gt; 및 &lt;code&gt;ngHide&lt;/code&gt; 는 프로그래밍 방식으로 요소를 표시하거나 숨 깁니다. 그리고 우리가 직접 작성한 것을 포함하여 더 많은. 다시 말해, DOM 조작 &lt;em&gt;없이&lt;/em&gt; 모든 종류의 경이로움 &lt;em&gt;을&lt;/em&gt; 수행 할 수 있습니다. DOM 조작이 적을수록 지시문을 쉽게 테스트하고 스타일을 쉽게 지정할 수 있으며 향후 더 쉽게 변경할 수 있으며 재사용 및 배포가 더 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="8a1f9a965073fef341c41540c540b536642219de" translate="yes" xml:space="preserve">
          <source>AngularJS doesn't need (or want) you to find elements using selectors - the primary difference between AngularJS's &lt;strong&gt;jqLite&lt;/strong&gt; versus full-blown &lt;strong&gt;jQuery&lt;/strong&gt; is that &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.element&quot;&gt;jqLite does not support selectors&lt;/a&gt;.</source>
          <target state="translated">AngularJS는 선택기를 사용하여 요소를 찾을 필요가 없습니다 (또는 원합니다) &lt;strong&gt;-AngularJS&lt;/strong&gt; 의 &lt;strong&gt;jqLite&lt;/strong&gt; 와 완전한 &lt;strong&gt;jQuery&lt;/strong&gt; 의 주요 차이점은 &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.element&quot;&gt;jqLite가 선택기를 지원하지 않는다는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d472a45e93868af2bd80d2ee2bab7981ad1a855e" translate="yes" xml:space="preserve">
          <source>AngularJS extends HTML, so you don't have to put &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; all over the place just to make an application. It makes HTML actually work for applications rather than what it was designed for, which is static, educational web pages. It accomplishes this in a roundabout way using JavaScript, but fundamentally it is an extension of HTML, not JavaScript.</source>
          <target state="translated">AngularJS는 HTML을 확장하므로 응용 프로그램을 만들기 위해 모든 곳에 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 를 넣을 필요가 없습니다. 정적이며 교육적인 웹 페이지 인 HTML이 실제로 설계된 것이 아니라 응용 프로그램에서 HTML을 실제로 작동시킵니다. JavaScript를 사용하여이 방법을 사용하지만 기본적으로 JavaScript가 아닌 HTML의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="a790802605b2871a0ef2e9ba795618736b158088" translate="yes" xml:space="preserve">
          <source>AngularJS gives us service objects.</source>
          <target state="translated">AngularJS는 서비스 객체를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="580b72b69de2dbaa91260842ab501683adc90363" translate="yes" xml:space="preserve">
          <source>AngularJS gives you modules into which you can place your code. If you're writing a script that talks to Flickr for example, you might want to create a Flickr module to wrap all your Flickr related functions in. Modules can include other modules (DI). Your main application is usually a module, and this should include all the other modules your application will depend on.</source>
          <target state="translated">AngularJS는 코드를 넣을 수있는 모듈을 제공합니다. 예를 들어 Flickr와 대화하는 스크립트를 작성하는 경우 Flickr 모듈을 작성하여 모든 Flickr 관련 기능을 래핑 할 수 있습니다. 모듈에는 다른 모듈 (DI)이 포함될 수 있습니다. 기본 응용 프로그램은 일반적으로 모듈이며 여기에는 응용 프로그램이 의존 할 다른 모든 모듈이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f5dbd7fd768f26aa68cfb19bda9fe60441f2e19f" translate="yes" xml:space="preserve">
          <source>AngularJS has $scope objects. These are special objects created and maintained by AngularJS in which you store your model. Certain directives will spawn a new $scope, which by default inherits from its wrapping $scope using JavaScript prototypical inheritance. The $scope object is accessible in the controller and the view.</source>
          <target state="translated">AngularJS에는 $ scope 객체가 있습니다. 이들은 모델을 저장하는 AngularJS에 의해 생성 및 유지 관리되는 특수 객체입니다. 특정 지시문은 기본적으로 JavaScript 프로토 타입 상속을 사용하여 $ scope를 래핑하여 상속하는 새로운 $ scope를 생성합니다. $ scope 객체는 컨트롤러와보기에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3347e5a5c11ca76b8bae02225f867635154e1d18" translate="yes" xml:space="preserve">
          <source>AngularJS has the concept of &quot;Directives&quot; for DOM manipulation and designing reusable UI components, so you should use it whenever you feel the need of doing DOM manipulation related stuff (directives are only place where you should write jQuery code while using AngularJS).</source>
          <target state="translated">AngularJS는 DOM 조작 및 재사용 가능한 UI 구성 요소 설계를위한 &quot;지시문&quot;이라는 개념을 가지고 있으므로 DOM 조작 관련 작업을 수행 할 필요가있을 때마다이를 사용해야합니다 (지시문은 AngularJS를 사용하는 동안 jQuery 코드를 작성해야하는 위치에만 해당)</target>
        </trans-unit>
        <trans-unit id="abb7d137ad0c0d41f229faf7978453fac70efa79" translate="yes" xml:space="preserve">
          <source>AngularJS instead gives you a &lt;strong&gt;compiler&lt;/strong&gt;.</source>
          <target state="translated">AngularJS는 대신 &lt;strong&gt;컴파일러&lt;/strong&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f454c455626fe5cac16b1e78b3064e9efba3a1f4" translate="yes" xml:space="preserve">
          <source>AngularJS involves some learning curve (more than jQuery :-).</source>
          <target state="translated">AngularJS는 학습 곡선을 포함합니다 (jQuery :-이상).</target>
        </trans-unit>
        <trans-unit id="0f33f894c7aeb275ff7e26043faaaba6c9273c31" translate="yes" xml:space="preserve">
          <source>AngularJS is an MV* framework.</source>
          <target state="translated">AngularJS는 MV * 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="496acda8671b0ee67088cb637f1c89eb97cd852d" translate="yes" xml:space="preserve">
          <source>AngularJS is an entire client-side framework that uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; pattern (check out their &lt;a href=&quot;http://docs.angularjs.org/guide/concepts&quot;&gt;graphical representation&lt;/a&gt;). It greatly focuses on separation of concerns.</source>
          <target state="translated">AngularJS는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; 패턴을 사용하는 전체 클라이언트 측 프레임 워크입니다 ( &lt;a href=&quot;http://docs.angularjs.org/guide/concepts&quot;&gt;그래픽 표현 확인&lt;/a&gt; ). 관심사 분리에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="ccc498700b07180690b810f63f70291230b83439" translate="yes" xml:space="preserve">
          <source>AngularJS itself includes a jQuery-lite edition within it. So for some basic DOM selection/manipulation, you really don't have to include the jQuery library (it saves many bytes to run on the network.)</source>
          <target state="translated">AngularJS 자체에는 jQuery-lite 에디션이 포함되어 있습니다. 따라서 기본 DOM 선택 / 조작의 경우 실제로 jQuery 라이브러리를 포함 할 필요가 없습니다 (네트워크에서 실행하기 위해 많은 바이트를 절약합니다).</target>
        </trans-unit>
        <trans-unit id="f8eb1469e26f56c8a74bfdb88d4142545826f06f" translate="yes" xml:space="preserve">
          <source>AngularJS manages your dependencies for you. If you want an object, simply refer to it and AngularJS will get it for you.</source>
          <target state="translated">AngularJS는 당신을 위해 당신의 의존성을 관리합니다. 객체를 원하면 간단히 참조하면 AngularJS가 객체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="38dffc5e5dca986ffefa44052bb0ef43d021e403" translate="yes" xml:space="preserve">
          <source>AngularJS uses &lt;strong&gt;controllers&lt;/strong&gt; and directives (each of which can have their own controller, and/or compile and linking functions) to remove behavior from the view/structure (HTML).  Angular also has &lt;strong&gt;services&lt;/strong&gt; and &lt;strong&gt;filters&lt;/strong&gt; to help separate/organize your application.</source>
          <target state="translated">AngularJS는 &lt;strong&gt;컨트롤러&lt;/strong&gt; 와 지시문 (각각 고유의 컨트롤러가 있거나 컴파일 및 링크 기능을 가질 수 있음)을 사용하여 뷰 / 구조 (HTML)에서 동작을 제거합니다. Angular에는 응용 프로그램을 분리 / 구성하는 데 도움이되는 &lt;strong&gt;서비스&lt;/strong&gt; 및 &lt;strong&gt;필터&lt;/strong&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="427ca6be55cbd36d29b597716cd026cabed3d117" translate="yes" xml:space="preserve">
          <source>AngularJS vs. jQuery</source>
          <target state="translated">AngularJS와 jQuery</target>
        </trans-unit>
        <trans-unit id="209303f007b14469938fa3242370f0eed9fe6b7f" translate="yes" xml:space="preserve">
          <source>AngularJS will recognise that a FlickrService object is needed to instantiate the controller, and will provide one for us.</source>
          <target state="translated">AngularJS는 컨트롤러를 인스턴스화하기 위해 FlickrService 객체가 필요하다는 것을 인식하고 우리에게 제공 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="89fd96e13c335779cf18929ce0e49db544e7b95a" translate="yes" xml:space="preserve">
          <source>AngularJS: THE model is the truth, and you always think from that ANGLE.</source>
          <target state="translated">AngularJS : 모델은 진실이며 항상 그 각도에서 생각합니다.</target>
        </trans-unit>
        <trans-unit id="3bef657357e40dc720fc2a1d5a9a5e5e4d968b2d" translate="yes" xml:space="preserve">
          <source>AngularJs Cool Principle - If you want some changes on your UI think from model data change perspective. Change your data and UI will re-render itself. You need not to play around DOM each time unless and until it is hardly required and that should also be handled through Angular Directives.</source>
          <target state="translated">AngularJs Cool Principle-UI의 일부 변경을 원한다면 모델 데이터 변경 관점에서 생각하십시오. 데이터를 변경하면 UI가 다시 렌더링됩니다. 거의 필요하지 않을 때까지 그리고 각도 지시어를 통해 처리해야 할 때까지 DOM을 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c7fa873dad04f6b1ea51f0bb4c021ea8dae7e48" translate="yes" xml:space="preserve">
          <source>AngularJs and JQuery are completely different at every level except the JQLite functionality and you will see it once you start learning the AngularJs core features (I explained it below).</source>
          <target state="translated">AngularJ와 JQuery는 JQLite 기능을 제외한 모든 수준에서 완전히 다르며 AngularJs 핵심 기능을 배우기 시작하면 볼 수 있습니다 (아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="3edbcd2b0fe8f2eeb3060452cd16d0c33d77cc16" translate="yes" xml:space="preserve">
          <source>AngularJs is a client side framework that offers to build the independent client side application. JQuery is a client side library that play around the DOM.</source>
          <target state="translated">AngularJ는 독립적 인 클라이언트 측 애플리케이션을 구축 할 수있는 클라이언트 측 프레임 워크입니다. JQuery는 DOM을 다루는 클라이언트 측 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="5239585f0407322b9de9420fc353533aa0b142a9" translate="yes" xml:space="preserve">
          <source>Apart from mixing concerns, we also have the same problems of signifying intent that I mentioned before. But more importantly, we had to manually reference and update a DOM node. And if we want to delete a log entry, we have to code against the DOM for that too. How do we test the logic apart from the DOM? And what if we want to change the presentation?</source>
          <target state="translated">혼합 문제 외에도, 앞에서 언급 한 의도를 나타내는 것과 동일한 문제가 있습니다. 그러나 더 중요한 것은 DOM 노드를 수동으로 참조하고 업데이트해야한다는 것입니다. 로그 항목을 삭제하려면 DOM에 대해서도 코딩해야합니다. DOM 이외의 로직을 어떻게 테스트합니까? 프레젠테이션을 변경하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="4887e453b680689b4f5edbe3a009b399e0a9cd5f" translate="yes" xml:space="preserve">
          <source>Application design</source>
          <target state="translated">응용 프로그램 설계</target>
        </trans-unit>
        <trans-unit id="390be301a8114b068b77d68bc38caf2bb1d0d455" translate="yes" xml:space="preserve">
          <source>Are there any server-side considerations/restrictions?</source>
          <target state="translated">서버 측 고려 사항 / 제한 사항이 있습니까?</target>
        </trans-unit>
        <trans-unit id="664c60d57cb407ffa5cf65a1d3cbd40930f03f80" translate="yes" xml:space="preserve">
          <source>As a JavaScript MV* beginner and purely focusing on the application architecture (not the server/client-side matters), I would certainly recommend the following resource (which I am surprised wasn't mentioned yet): &lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;JavaScript Design Patterns&lt;/a&gt;, by Addy Osmani, as an introduction to different &lt;strong&gt;JavaScript Design Patterns&lt;/strong&gt;. The terms used in this answer are taken from the linked document above. I'm not going to repeat what was worded really well in the accepted answer. Instead, this answer links back to the &lt;strong&gt;theoretical backgrounds&lt;/strong&gt; which power AngularJS (and other libraries).</source>
          <target state="translated">JavaScript MV * 초보자로서 순수하게 응용 프로그램 아키텍처 (서버 / 클라이언트 측 문제는 아님)에 초점을 맞추면서 다음 리소스를 추천 할 것입니다 (아직 언급하지 않은 놀랍게도) : &lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;JavaScript Design Patterns&lt;/a&gt; , Addy Osmani , 다른 &lt;strong&gt;JavaScript 디자인 패턴에&lt;/strong&gt; 대한 소개. 이 답변에 사용 된 용어는 위의 링크 된 문서에서 가져옵니다. 나는 받아 들여진 대답에서 실제로 잘 표현 된 것을 반복하지 않을 것입니다. 대신이 답변은 AngularJS (및 기타 라이브러리)를 강화하는 &lt;strong&gt;이론적 배경으로&lt;/strong&gt; 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="23a7327c34c86abe93b30fb5462eaf583c740d8f" translate="yes" xml:space="preserve">
          <source>At this point you likely have all sorts of questions concerning &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt; and accessibility, and rightly so. There are open issues here. Most screen readers will now parse JavaScript. Search engines can also index &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;AJAXed&lt;/a&gt; content. Nevertheless, you will want to make sure you are using pushstate URLs and you have a decent sitemap. See here for a discussion of the issue: &lt;a href=&quot;https://stackoverflow.com/a/23245379/687677&quot;&gt;https://stackoverflow.com/a/23245379/687677&lt;/a&gt;</source>
          <target state="translated">이 시점에서 &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt; 및 접근성에 관한 모든 종류의 질문이있을 것입니다. 여기에 공개 된 문제가 있습니다. 대부분의 스크린 리더는 이제 JavaScript를 구문 분석합니다. 검색 엔진은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;AJAXed&lt;/a&gt; 컨텐츠를 색인 할 수도 있습니다. 그럼에도 불구하고, 푸시 스테이트 URL을 사용하고 적절한 사이트 맵이 있는지 확인하고 싶을 것입니다. 문제에 대한 토론은 여기를 참조하십시오 : &lt;a href=&quot;https://stackoverflow.com/a/23245379/687677&quot;&gt;https&lt;/a&gt; : //.com/a/23245379/687677</target>
        </trans-unit>
        <trans-unit id="e64cce4dacf87903542cb264297ae0a879e80ca7" translate="yes" xml:space="preserve">
          <source>Attach a controller to each view (using ng-view and routing, or ng-controller). Have the controller find/get only whatever model data the view needs to do its job. Make controllers as thin as possible.</source>
          <target state="translated">ng-view 및 routing 또는 ng-controller를 사용하여 각보기에 컨트롤러를 연결하십시오. 컨트롤러가 뷰가 작업을 수행하는 데 필요한 모델 데이터 만 찾거나 가져 오도록합니다. 컨트롤러를 최대한 얇게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="4988689ec96d69654ac1b4d26595c58327121e0c" translate="yes" xml:space="preserve">
          <source>Because AngularJS treats your HTML page as a template. The template is not supposed to be semantic as your content is typically stored in your model which ultimately comes from your API. AngularJS compiles your DOM with the model to produce a semantic web page.</source>
          <target state="translated">AngularJS는 HTML 페이지를 템플릿으로 취급하기 때문입니다. 콘텐츠는 일반적으로 API에서 제공되는 모델에 저장되므로 템플릿은 의미가 없어야합니다. AngularJS는 DOM을 모델로 컴파일하여 시맨틱 웹 페이지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="52ff735af719db7308ce1da781ad856d29790080" translate="yes" xml:space="preserve">
          <source>Because data binding is done from the template, using either an attribute or the curly brace syntax, it's super easy to do. There's little cognitive overhead associated with it so you'll find yourself doing it all the time.</source>
          <target state="translated">데이터 바인딩은 속성 또는 중괄호 구문을 사용하여 템플릿에서 수행되므로 매우 쉽습니다. 인지적인 오버 헤드가 적기 때문에 항상 자신이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1f91ccd2cdc9e39f69ad5bd7c07fde87791168" translate="yes" xml:space="preserve">
          <source>Being a framework, it hosts your code and takes ownership of decisions about what to call and when!</source>
          <target state="translated">프레임 워크이기 때문에 코드를 호스팅하고 무엇을 언제 호출해야하는지에 대한 결정권을 갖습니다!</target>
        </trans-unit>
        <trans-unit id="1ede8f40530371ca2072fafa529a4af2b37e9ba1" translate="yes" xml:space="preserve">
          <source>Binds the input element to &lt;code&gt;$scope.user.name&lt;/code&gt;. Updating the input will update the value in your current scope, and vice-versa.</source>
          <target state="translated">입력 요소를 &lt;code&gt;$scope.user.name&lt;/code&gt; 합니다. 입력을 업데이트하면 현재 범위의 값이 업데이트되고 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="723820bab62fc4cc602aaa7c4690e3b306e0a88e" translate="yes" xml:space="preserve">
          <source>But because we have separation of concerns, we can do test-driven development iteratively in AngularJS! For example, let's say we want a super-simple directive to indicate in our menu what our current route is. We can declare what we want in the view of our application:</source>
          <target state="translated">그러나 우려가 분리되어 있으므로 AngularJS에서 테스트 중심 개발을 반복적으로 수행 할 수 있습니다! 예를 들어 메뉴에 현재 경로가 무엇인지 나타내는 매우 간단한 지시문을 원한다고 가정 해 봅시다. 애플리케이션 관점에서 원하는 것을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce753a2c6da077456572ab747e44d38ca49b9bd8" translate="yes" xml:space="preserve">
          <source>But for that matter, our view could look like this:</source>
          <target state="translated">그러나 그 문제에 대해서는 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05e4f17ec22790979e0e74231b4a9712ba108795" translate="yes" xml:space="preserve">
          <source>But in AngularJS, you must start from the ground up with your architecture in mind. Instead of starting by thinking &quot;I have this piece of the DOM and I want to make it do X&quot;, you have to start with what you want to accomplish, then go about designing your application, and then finally go about designing your view.</source>
          <target state="translated">그러나 AngularJS에서는 아키텍처를 염두에두고 처음부터 시작해야합니다. &quot;이 DOM을 가지고 X를 만들고 싶다&quot;고 생각하는 것부터 시작하는 대신, 달성하고자하는 것부터 시작한 다음 응용 프로그램을 디자인하고 마지막으로 뷰를 디자인해야합니다.</target>
        </trans-unit>
        <trans-unit id="706cdc463699e1ed474fcbc74dc48ab1f144a5d9" translate="yes" xml:space="preserve">
          <source>But let's dive a little deeper...</source>
          <target state="translated">그러나 조금 더 깊이 잠수합시다 ...</target>
        </trans-unit>
        <trans-unit id="d00b45211d6f5e02dbf9930e954ca044f2728901" translate="yes" xml:space="preserve">
          <source>By googling, I see that there is a standalone jQuery selector module out there. It's Sizzle.</source>
          <target state="translated">인터넷 검색을 통해 독립형 jQuery 선택기 모듈이 있음을 알 수 있습니다. 지글 지글입니다.</target>
        </trans-unit>
        <trans-unit id="75ed687c979f0bd97e2a3c3bf1ba2c8068f3c723" translate="yes" xml:space="preserve">
          <source>CSS - Styling, without the CSS the page is still readable.</source>
          <target state="translated">CSS-스타일링, CSS가 없으면 페이지를 여전히 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fbb684c9310c39e4a515fe80a2bcaad03a97701" translate="yes" xml:space="preserve">
          <source>Can you describe the paradigm shift that is necessary?</source>
          <target state="translated">필요한 패러다임 전환을 설명 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="fc22be49056528fdaa6e3e976f7e5c0875c0ea23" translate="yes" xml:space="preserve">
          <source>Closure vs. $scope</source>
          <target state="translated">마감 대 $ scope</target>
        </trans-unit>
        <trans-unit id="35313dc9f2a46f49b61938e95da8ca20b23eaa38" translate="yes" xml:space="preserve">
          <source>Controller - Your controller is a JavaScript function which hooks the view to the model. Its function is to initialise $scope. Depending on your application, you may or may not need to create a controller. You can have many controllers on a page.</source>
          <target state="translated">컨트롤러-컨트롤러는 뷰를 모델에 연결하는 JavaScript 함수입니다. 그 기능은 $ scope를 초기화하는 것입니다. 응용 프로그램에 따라 컨트롤러를 생성하거나 생성하지 않아도됩니다. 한 페이지에 많은 컨트롤러가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38e5b6c1d5bdd30cd076016ffcf63fb6a6fe8ba7" translate="yes" xml:space="preserve">
          <source>Controllers and providers (services, factories, etc.) are for modifying the data model, NOT HTML.</source>
          <target state="translated">컨트롤러 및 공급자 (서비스, 팩토리 등)는 HTML이 아닌 데이터 모델을 수정하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8190947945a5d101ce34179f8d52d23951e48521" translate="yes" xml:space="preserve">
          <source>DI means that instead of writing your application and wiring it together, you instead define a library of components, each identified by a string.</source>
          <target state="translated">DI는 애플리케이션을 작성하고 함께 배선하는 대신 각각 문자열로 식별되는 구성 요소 라이브러리를 정의 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d38cca5da9c7df446a12182ab09218cd420e4017" translate="yes" xml:space="preserve">
          <source>Data binding</source>
          <target state="translated">데이터 바인딩</target>
        </trans-unit>
        <trans-unit id="abe361ec5ac92ab2b51436412eccfc4c617ee10a" translate="yes" xml:space="preserve">
          <source>Dependency injection</source>
          <target state="translated">의존성 주입</target>
        </trans-unit>
        <trans-unit id="b4834f95740149caa4ab7c7998c3085a73d25833" translate="yes" xml:space="preserve">
          <source>Developers new to AngularJS often ask a question like: how do I find all links of a specific kind and add a directive onto them. The developer is always flabbergasted when we reply: you don't. But the reason you don't do that is that this is like half-jQuery, half-AngularJS, and no good. The problem here is that the developer is trying to &quot;do jQuery&quot; in the context of AngularJS. That's never going to work well. The view &lt;em&gt;is&lt;/em&gt; the official record. Outside of a directive (more on this below), you never, ever, &lt;em&gt;never&lt;/em&gt; change the DOM. And directives are applied &lt;em&gt;in the view&lt;/em&gt;, so intent is clear.</source>
          <target state="translated">AngularJS를 처음 사용하는 개발자는 종종 다음과 같은 질문을합니다. 특정 종류의 모든 링크를 찾고 지시문을 추가하는 방법. 우리가 대답 할 때 개발자는 항상 화를 내고 있습니다. 그러나 그렇게하지 않는 이유는 half-jQuery, half-AngularJS와 같고 좋지 않기 때문입니다. 여기서 문제는 개발자가 AngularJS의 맥락에서 &quot;jQuery&quot;를 수행하려고한다는 것입니다. 그것은 결코 잘 작동하지 않을 것입니다. 보기 &lt;em&gt;는&lt;/em&gt; 공식 기록입니다. 지시문 밖에서 (아래에 더 자세히 설명되어 있음) DOM을 변경 &lt;em&gt;하지 마십시오&lt;/em&gt; . 지시어는 &lt;em&gt;뷰에&lt;/em&gt; 적용되므로 의도가 분명합니다.</target>
        </trans-unit>
        <trans-unit id="53d7a9d92573e089ff93413770ae30c25ee69d14" translate="yes" xml:space="preserve">
          <source>Directives can then in turn pull in additional Angular components such as controllers, services, etc. What comes out the bottom of the compiler is a fully formed web application, wired up and ready to go.</source>
          <target state="translated">지시문은 컨트롤러, 서비스 등과 같은 추가 Angular 구성 요소를 차례로 끌어 올 수 있습니다. 컴파일러의 맨 아래에 나오는 것은 완전히 구성된 웹 응용 프로그램으로, 유선으로 연결되어 바로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e07f7c559632d31618e542f4fc425e25f0611c0" translate="yes" xml:space="preserve">
          <source>Distinct model layer</source>
          <target state="translated">고유 한 모델 레이어</target>
        </trans-unit>
        <trans-unit id="7d3e17491190e7a5dea94490347df028a3f9aa5e" translate="yes" xml:space="preserve">
          <source>Doing so will allow you to leverage their &lt;a href=&quot;http://docs.angularjs.org/api/ngResource.$resource&quot;&gt;resource factory&lt;/a&gt;, which creates an abstraction of your server side RESTful &lt;a href=&quot;http://en.wikipedia.org/wiki/Application_programming_interface&quot;&gt;API&lt;/a&gt; and makes server-side calls (get, save, delete, etc.) incredibly easy.</source>
          <target state="translated">그렇게하면 &lt;a href=&quot;http://docs.angularjs.org/api/ngResource.$resource&quot;&gt;리소스 팩토리&lt;/a&gt; 를 활용할 수있게되어 서버 측 RESTful &lt;a href=&quot;http://en.wikipedia.org/wiki/Application_programming_interface&quot;&gt;API를&lt;/a&gt; 추상화하고 서버 측 호출 (get, save, delete 등)을 매우 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9fac905701ef3b0097c8764804ad3e59dbd915f9" translate="yes" xml:space="preserve">
          <source>Don't even use jQuery. Don't even include it. It will hold you back. And when you come to a problem that you think you know how to solve in jQuery already, before you reach for the &lt;code&gt;$&lt;/code&gt;, try to think about how to do it within the confines the AngularJS. If you don't know, ask! 19 times out of 20, the best way to do it doesn't need jQuery and to try to solve it with jQuery results in more work for you.</source>
          <target state="translated">jQuery를 사용하지 마십시오. 포함하지 마십시오. 그것은 당신을 다시 잡아 것입니다. 그리고 jQuery에서 이미 해결하는 방법을 알고 있다고 생각하는 문제가 발생하면 &lt;code&gt;$&lt;/code&gt; 에 도달하기 전에 AngularJS를 제한하는 방법을 생각해보십시오. 모른다면 물어보십시오! 20 중 19 번, jQuery가 필요하지 않고 jQuery 결과로 해결하려고 시도하는 가장 좋은 방법은 더 많은 작업을 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c79c2f8fe6cef139b77391f6699a0512a187188" translate="yes" xml:space="preserve">
          <source>Edit:</source>
          <target state="translated">Edit:</target>
        </trans-unit>
        <trans-unit id="22b7ff6e8b6f6df26b8528e8d5a05b683dda1ec4" translate="yes" xml:space="preserve">
          <source>First know that &lt;a href=&quot;http://en.wikipedia.org/wiki/Single-page_application&quot;&gt;single-page applications&lt;/a&gt; are &lt;em&gt;applications&lt;/em&gt;. They're &lt;em&gt;not&lt;/em&gt; webpages. So we need to think like a server-side developer &lt;em&gt;in addition&lt;/em&gt; to thinking like a client-side developer. We have to think about how to divide our application into individual, extensible, testable components.</source>
          <target state="translated">먼저 &lt;a href=&quot;http://en.wikipedia.org/wiki/Single-page_application&quot;&gt;단일 페이지 응용 프로그램&lt;/a&gt; 이 &lt;em&gt;응용&lt;/em&gt; 프로그램 임을 알고 있어야합니다. 그들은 웹 페이지가 &lt;em&gt;아닙니다&lt;/em&gt; . 따라서 클라이언트 측 개발자처럼 생각하는 것 &lt;em&gt;외에도&lt;/em&gt; 서버 측 개발자로 생각해야합니다. 애플리케이션을 확장 가능하고 테스트 가능한 개별 구성 요소로 나누는 방법에 대해 생각해야합니다.</target>
        </trans-unit>
        <trans-unit id="395a4b3bfca26bc0f15e623275df885c5164cd6a" translate="yes" xml:space="preserve">
          <source>First up, Angular doesn't replace jQuery</source>
          <target state="translated">먼저 Angular는 jQuery를 대체하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bd966a54c73aaa3f249cccf1a9fc029ccf3efc7" translate="yes" xml:space="preserve">
          <source>First, jQuery was never necessary. There's nothing we did here that needed jQuery at all!</source>
          <target state="translated">첫째, jQuery는 필요하지 않았습니다. 여기에 jQuery가 필요한 것은 없습니다!</target>
        </trans-unit>
        <trans-unit id="900191e8f993958a06b036ac65d730e1bdaa6073" translate="yes" xml:space="preserve">
          <source>For a view that looks like this:</source>
          <target state="translated">다음과 같은보기 :</target>
        </trans-unit>
        <trans-unit id="2e2c9d3bdb321bac05780afd95a48bfce104b09e" translate="yes" xml:space="preserve">
          <source>For example, here I define a service:</source>
          <target state="translated">예를 들어 여기에 서비스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="de3e20808c116384b0a4b03719bffd49cb190884" translate="yes" xml:space="preserve">
          <source>For example, if you want a carousel on your page, you might define an unordered list of figures, perhaps wrapped in a nav element. You might then write some jQuery to select the list on the page and restyle it as a gallery with timeouts to do the sliding animation.</source>
          <target state="translated">예를 들어, 페이지에 캐 러셀을 원하는 경우 정렬되지 않은 그림 목록 (예 : nav 요소로 묶여 있음)을 정의 할 수 있습니다. 그런 다음 jQuery를 작성하여 페이지에서 목록을 선택하고 슬라이딩 애니메이션을 수행하기 위해 시간 초과가있는 갤러리로 다시 스타일을 다시 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="991573402c0940207e9bacdb158be6295096e397" translate="yes" xml:space="preserve">
          <source>For example, when you get data from THE server which you intend to display in some format in the DOM, in jQuery, you need to '1. FIND' where in the DOM you want to place this data, the '2. UPDATE/APPEND' it there by creating a new node or just setting its &lt;a href=&quot;http://www.tizag.com/javascriptT/javascript-innerHTML.php&quot;&gt;innerHTML&lt;/a&gt;. Then when you want to update this view, you then '3. FIND' the location and '4. UPDATE'. This cycle of find and update all done within the same context of getting and formatting data from server is gone in AngularJS.</source>
          <target state="translated">예를 들어, DOM에서 일부 형식으로 표시하려는 서버에서 데이터를 가져 오면 jQuery에서 '1이어야합니다. DOM에서이 데이터를 배치하려는 위치를 찾으십시오. '2. 새 노드를 만들거나 &lt;a href=&quot;http://www.tizag.com/javascriptT/javascript-innerHTML.php&quot;&gt;innerHTML을&lt;/a&gt; 설정하여 업데이트하십시오. 그런 다음이보기를 업데이트하려면 '3. 위치를 찾고 '4. 최신 정보'. 서버에서 데이터를 가져오고 형식을 지정하는 것과 동일한 컨텍스트에서 수행되는 찾기 및 업데이트주기는 AngularJS에서 사라졌습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="850a95bbb6dd76741f2f32607f4ef86792316738" translate="yes" xml:space="preserve">
          <source>Fourth, closely related to the third, is that jqLite elements needn't be wrapped in &lt;code&gt;$&lt;/code&gt; - the &lt;code&gt;element&lt;/code&gt; that is passed to the &lt;code&gt;link&lt;/code&gt; function would &lt;em&gt;already be&lt;/em&gt; a jQuery element!</source>
          <target state="translated">넷째, 세 번째와 밀접하게 관련된 jqLite 요소는 &lt;code&gt;$&lt;/code&gt; 로 래핑 할 필요가 없습니다. &lt;code&gt;link&lt;/code&gt; 함수에 전달 된 &lt;code&gt;element&lt;/code&gt; 는 &lt;em&gt;이미&lt;/em&gt; jQuery 요소입니다!</target>
        </trans-unit>
        <trans-unit id="e937a7317ee9e666605382e9345fe01e5e87523e" translate="yes" xml:space="preserve">
          <source>From a broad perspective, DI means that you can declare components very freely and then from any other component, just ask for an instance of it and it will be granted. You don't have to know about loading order, or file locations, or anything like that. The power may not immediately be visible, but I'll provide just one (common) example: testing.</source>
          <target state="translated">넓은 관점에서 DI는 구성 요소를 매우 자유롭게 선언 한 다음 다른 구성 요소에서 인스턴스를 요청하면 해당 구성 요소를 요청할 수 있음을 의미합니다. 로딩 순서, 파일 위치 등을 알 필요가 없습니다. 힘은 즉시 보이지 않을 수도 있지만 테스트 중 하나 (일반)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="70376458c7e1d59978b45b6a33d1a41e52fb91db" translate="yes" xml:space="preserve">
          <source>Good luck.</source>
          <target state="translated">행운을 빕니다.</target>
        </trans-unit>
        <trans-unit id="a27f0fe6a21c158932ddc9c6ab32b680263c7a6e" translate="yes" xml:space="preserve">
          <source>HTML - Semantic meaning. The HTML should stand alone.</source>
          <target state="translated">HTML-의미 적 의미. HTML은 독립적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c5340e7474927e0f273d76b88c2f86f9341fb5de" translate="yes" xml:space="preserve">
          <source>HTML and directives define the layout and binding to the model.</source>
          <target state="translated">HTML 및 지시문은 모델에 대한 레이아웃 및 바인딩을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7602bdeaf94c8c4d20e603fafd1c75516db6e8a6" translate="yes" xml:space="preserve">
          <source>Here's a quick example that shows the pattern I see most frequently. We want a toggleable button. (Note: this example is a little contrived and a skosh verbose to represent more complicated cases that are solved in exactly the same way.)</source>
          <target state="translated">가장 자주 본 패턴을 보여주는 간단한 예입니다. 전환 가능한 버튼이 필요합니다. (참고 :이 예제는 약간 똑같은 방법으로 해결되는 더 복잡한 경우를 나타 내기 위해 약간 고안되었습니다.)</target>
        </trans-unit>
        <trans-unit id="1b872c0b8b5cb91fbb546831e6921db7d5087ecd" translate="yes" xml:space="preserve">
          <source>How do I architect and design client-side web applications differently? What is the biggest difference?</source>
          <target state="translated">클라이언트 측 웹 응용 프로그램을 어떻게 다르게 설계하고 설계합니까? 가장 큰 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9ff77b581f89f632f34713ccc81664a4f91cf1b8" translate="yes" xml:space="preserve">
          <source>How do I architect and design client-side web apps differently?</source>
          <target state="translated">클라이언트 측 웹 앱을 어떻게 다르게 설계하고 설계합니까?</target>
        </trans-unit>
        <trans-unit id="8456215573486aa4c8df48dde90555787930b6c5" translate="yes" xml:space="preserve">
          <source>I find this question interesting, because my first serious exposure to JavaScript programming was &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; and AngularJS. I never learned jQuery, and I guess that's a good thing, because I don't have to unlearn anything. In fact, I actively avoid jQuery solutions to my problems, and instead, solely look for an &quot;AngularJS way&quot; to solve them. So, I guess my answer to this question would essentially boil down to, &quot;think like someone who never learned jQuery&quot; and avoid any temptation to incorporate jQuery directly (obviously AngularJS uses it to some extent behind the scenes).</source>
          <target state="translated">JavaScript 프로그래밍에 대한 첫 번째 심각한 노출은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; 와 AngularJS이기 때문에이 질문이 흥미 롭습니다. 나는 jQuery를 배운 적이 없으며 아무것도 배울 필요가 없기 때문에 좋은 일이라고 생각합니다. 사실, 나는 내 문제에 대한 jQuery 솔루션을 적극적으로 피하고 대신 &quot;AngularJS 방식&quot;만 찾으십시오. 따라서이 질문에 대한 대답은 본질적으로 &quot;jQuery를 배운 적이없는 사람처럼 생각하십시오.&quot;라고 말하고 jQuery를 직접 통합하려는 유혹을 피하십시오 (분명히 AngularJS는 어느 정도 뒤에서 사용합니다).</target>
        </trans-unit>
        <trans-unit id="efb9e3de8580d4d388e6d1d2c1128365fcee76cb" translate="yes" xml:space="preserve">
          <source>I found it easier also, to test &lt;strong&gt;(1)&lt;/strong&gt; native JavaScript code and &lt;strong&gt;(2)&lt;/strong&gt; smaller libraries for each one of these patterns &lt;strong&gt;separately&lt;/strong&gt; before diving into one global framework. This allowed me to better understand which crucial issues a framework adresses (because you are personally faced with the problem).</source>
          <target state="translated">하나의 전역 프레임 워크로 뛰어 들기 전에 &lt;strong&gt;(1)&lt;/strong&gt; 기본 JavaScript 코드와 &lt;strong&gt;(2)&lt;/strong&gt; 이러한 패턴 각각에 대해 더 작은 라이브러리를 개별적으로 테스트하는 것이 더 쉽다는 것을 알았습니다. 이것은 개인적으로 문제에 직면했기 때문에 프레임 워크가 해결하는 중요한 문제를 더 잘 이해할 수있게했습니다.</target>
        </trans-unit>
        <trans-unit id="0f5fdb791dc830db0312c3e805b978f9fee42e94" translate="yes" xml:space="preserve">
          <source>I got so excited about AngularJS, I wrote a short book on it which you're very welcome to read online &lt;a href=&quot;http://nicholasjohnson.com/angular-book/&quot;&gt;http://nicholasjohnson.com/angular-book/&lt;/a&gt;. I hope it's helpful.</source>
          <target state="translated">나는 AngularJS에 대해 너무 흥분해서, 당신이 온라인 &lt;a href=&quot;http://nicholasjohnson.com/angular-book/&quot;&gt;http://nicholasjohnson.com/angular-book/&lt;/a&gt; 을 읽을 수있는 짧은 책을 썼습니다. 도움이 되길 바랍니다.</target>
        </trans-unit>
        <trans-unit id="cff209bb9bc1c566d085c39c77af21c5738cf6e4" translate="yes" xml:space="preserve">
          <source>I heard from a meetup I attended, one of the founders of Angular said they worked really hard to separate out the DOM manipulation so do not try to include them back in.</source>
          <target state="translated">내가 참석 한 모임에서 Angular의 창립자 중 한 명이 DOM 조작을 분리하기 위해 열심히 노력했기 때문에 다시 포함시키지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b1cc19c6fa446f86e199536080332bbd9a86f525" translate="yes" xml:space="preserve">
          <source>I see lots of developers new to AngularJS using directives as the place to throw a bunch of jQuery. In other words, they think &quot;since I can't do DOM manipulation in the controller, I'll take that code put it in a directive&quot;. While that certainly is much better, it's often &lt;em&gt;still wrong&lt;/em&gt;.</source>
          <target state="translated">많은 jQuery를 던질 장소로 지시문을 사용하는 AngularJS를 처음 접하는 많은 개발자가 있습니다. 다시 말해, 그들은 &quot;컨트롤러에서 DOM 조작을 할 수 없기 때문에 지시어에 코드를 넣을 것&quot;이라고 생각합니다. 확실히 훨씬 낫지 만 &lt;em&gt;여전히 여전히 잘못&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc523ff786c336f7206f714e0c729f9f96a4ee5f" translate="yes" xml:space="preserve">
          <source>I shared my code here: &lt;a href=&quot;https://github.com/huytd/Sizzular&quot;&gt;https://github.com/huytd/Sizzular&lt;/a&gt;</source>
          <target state="translated">내 코드를 여기에서 공유했습니다 : &lt;a href=&quot;https://github.com/huytd/Sizzular&quot;&gt;https://github.com/huytd/Sizzular&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59b381689432e88b63f12501377e65b7661e38f1" translate="yes" xml:space="preserve">
          <source>I usually develop mobile applications using AngularJS and &lt;a href=&quot;http://en.wikipedia.org/wiki/PhoneGap&quot;&gt;Cordova&lt;/a&gt;. The ONLY thing from jQuery I needed is the Selector.</source>
          <target state="translated">나는 보통 AngularJS와 &lt;a href=&quot;http://en.wikipedia.org/wiki/PhoneGap&quot;&gt;Cordova를&lt;/a&gt; 사용하여 모바일 애플리케이션을 개발합니다. 내가 필요한 jQuery의 유일한 것은 선택기입니다.</target>
        </trans-unit>
        <trans-unit id="68cf991557c35bd050972b963c214ad303e38353" translate="yes" xml:space="preserve">
          <source>I'm not looking for a detailed comparison between &lt;code&gt;jQuery&lt;/code&gt; and &lt;code&gt;AngularJS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jQuery&lt;/code&gt; 와 &lt;code&gt;AngularJS&lt;/code&gt; 간의 자세한 비교를 찾고 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f656d296b8b07178ef6945737f0889477b62c8e3" translate="yes" xml:space="preserve">
          <source>I've seen many developers here and on the mailing list create these elaborate solutions with jQuery plugins of 150 or 200 lines of code that they then glue into AngularJS with a collection of callbacks and &lt;code&gt;$apply&lt;/code&gt;s that are confusing and convoluted; but they eventually get it working! The problem is that in &lt;strong&gt;most&lt;/strong&gt; cases that jQuery plugin could be rewritten in AngularJS in a fraction of the code, where suddenly everything becomes comprehensible and straightforward.</source>
          <target state="translated">필자는 여기와 메일 링리스트에서 150 또는 200 줄의 코드로 구성된 jQuery 플러그인을 사용하여 이러한 정교한 솔루션을 생성 한 후 AngularJS에 콜백과 &lt;code&gt;$apply&lt;/code&gt; 하여 혼란스럽고 복잡하게 만들었습니다. 그러나 그들은 결국 그것을 작동시킵니다! 문제는 &lt;strong&gt;대부분의&lt;/strong&gt; 경우 jQuery 플러그인이 코드의 일부로 AngularJS에서 다시 작성 될 수 있다는 점입니다. 갑자기 모든 것이 이해되고 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="9faefb35c2c81504d51573a6b0bb40a2af1787a2" translate="yes" xml:space="preserve">
          <source>If this sounds like it might be over-prescriptive and limiting, nothing could be farther from the truth. Because AngularJS treats your HTML as code, you get &lt;strong&gt;HTML level granularity in your web application&lt;/strong&gt;. Everything is possible, and most things are surprisingly easy once you make a few conceptual leaps.</source>
          <target state="translated">이것이 지나치게 규범적이고 제한적인 것처럼 들리면 진실에서 멀어지는 것은 없습니다. AngularJS는 HTML을 코드로 취급하므로 &lt;strong&gt;웹 애플리케이션에서 HTML 레벨의 세분성&lt;/strong&gt; 을 얻습니다. 모든 것이 가능하며, 개념적으로 도약하면 대부분의 일이 놀라 울 정도로 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="79f7744c5244c5d82136a0b399bcf24b88bb5af1" translate="yes" xml:space="preserve">
          <source>If you do use jQuery, you shouldn't be sprinkling it all over the place. The correct place for DOM manipulation in AngularJS is in a directive. More on these later.</source>
          <target state="translated">jQuery를 사용한다면 어디서나 jQuery를 뿌려서는 안됩니다. AngularJS에서 DOM 조작의 올바른 위치는 지시문에 있습니다. 이것들에 대해서는 나중에 더 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="b60077ec18c37edabed1d4367bf017ee53c9fbcf" translate="yes" xml:space="preserve">
          <source>If you need an HTML widget, create a directive.</source>
          <target state="translated">HTML 위젯이 필요한 경우 지시문을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c0db6dddb3c36feeee526c677dfbbae3c8383c59" translate="yes" xml:space="preserve">
          <source>If you need to share data between controllers, create a service or factory - they are singletons that are shared across the application.</source>
          <target state="translated">컨트롤러간에 데이터를 공유해야하는 경우 서비스 또는 팩토리를 작성하십시오. 애플리케이션 또는 애플리케이션간에 공유되는 싱글 톤입니다.</target>
        </trans-unit>
        <trans-unit id="4428aad89d5c0c9e8fe7de6ea30b96f7e38235d8" translate="yes" xml:space="preserve">
          <source>If you want a carousel, just use a &lt;code&gt;&amp;lt;carousel /&amp;gt;&lt;/code&gt; element, then define a directive to pull in a template, and make that sucker work.</source>
          <target state="translated">회전 목마를 원한다면 &lt;code&gt;&amp;lt;carousel /&amp;gt;&lt;/code&gt; 요소를 사용하고 지시문을 정의하여 템플릿을 가져 와서 빨라지게하십시오.</target>
        </trans-unit>
        <trans-unit id="276ce11b5a508e459e0e3120bcd6327d2afadd20" translate="yes" xml:space="preserve">
          <source>If, like me, you lived through the browser wars, you might find this idea quite offensive. Get over it, it'll be worth it, I promise.</source>
          <target state="translated">나처럼, 당신이 브라우저 전쟁을 겪었다면, 당신은이 아이디어가 매우 공격적이라고 생각할 것입니다. 그만해, 그만한 가치가 있다고 약속 해</target>
        </trans-unit>
        <trans-unit id="5813cd91b1b8004097b86b34053bfec044d09858" translate="yes" xml:space="preserve">
          <source>Imperative &amp;rarr; declarative</source>
          <target state="translated">명령 적 &amp;rarr; 선언적</target>
        </trans-unit>
        <trans-unit id="07968492b4fc9b61f75164fde04e026e2f9fa45e" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;AngularJS&lt;/strong&gt;, you use &lt;strong&gt;directives&lt;/strong&gt; to mark the elements directly, to wire them up:</source>
          <target state="translated">&lt;strong&gt;AngularJS&lt;/strong&gt; 에서는 &lt;strong&gt;지시문&lt;/strong&gt; 을 사용하여 요소를 직접 표시하고 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f72af3c482bf1229ea3ff7aa97ad07e3cddd38f9" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;jQuery&lt;/strong&gt;, you typically  use &lt;strong&gt;selectors&lt;/strong&gt; to find elements, and then wire them up:</source>
          <target state="translated">&lt;strong&gt;jQuery&lt;/strong&gt; 에서는 일반적으로 &lt;strong&gt;선택기&lt;/strong&gt; 를 사용하여 요소를 찾은 다음 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f023543783f6ea1287434a1d4ab86cd65d3608d2" translate="yes" xml:space="preserve">
          <source>In AngularJS we write smaller directives. Our dropdown directive would be ridiculously small. It might maintain the folded state, and provide methods to fold(), unfold() or toggle(). These methods would simply update $scope.menu.visible which is a boolean holding the state.</source>
          <target state="translated">AngularJS에서는 더 작은 지시문을 작성합니다. 드롭 다운 지시문은 엄청나게 작습니다. 접힌 상태를 유지하고 fold (), unfold () 또는 toggle ()에 메소드를 제공 할 수 있습니다. 이 메소드는 단순히 상태를 유지하는 부울 인 $ scope.menu.visible을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="d8e03995fe1bd0fda78591a1efe81ead5f9d2dc8" translate="yes" xml:space="preserve">
          <source>In AngularJS you can do this too, but you are encouraged to make use of data binding. Change your model, and because the DOM is bound to it via a template your DOM will automatically update, no intervention required.</source>
          <target state="translated">AngularJS 에서도이 작업을 수행 할 수 있지만 데이터 바인딩을 사용하는 것이 좋습니다. 모델을 변경하십시오. DOM은 템플릿을 통해 모델에 바인딩되므로 DOM이 자동으로 업데이트되며 개입 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ac2131eed6961b3bcec8b6db93b268ad621db10" translate="yes" xml:space="preserve">
          <source>In AngularJS, Ajax is your default go-to solution and it happens all the time, almost without you noticing. You can include templates with ng-include. You can apply a template with the simplest custom directive. You can wrap an Ajax call in a service and create yourself a &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt; service, or a &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt; service, which you can access with astonishing ease.</source>
          <target state="translated">AngularJS에서 Ajax는 기본 이동 솔루션이며 거의 눈치 채지 않고 항상 발생합니다. ng-include와 함께 템플릿을 포함 할 수 있습니다. 가장 간단한 사용자 지정 지시문을 사용하여 템플릿을 적용 할 수 있습니다. 서비스에서 Ajax 호출을 래핑하고 &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt; 서비스 또는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt; 서비스를 직접 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b05f35093dd1f890c262faf35c9be008a7512c" translate="yes" xml:space="preserve">
          <source>In AngularJS, meaning lives in the model, the HTML is just a template, for display only.</source>
          <target state="translated">AngularJS에서 모델에 존재한다는 의미는 HTML이 표시 용 템플릿 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="d68e1fa23f0a8a69226a8fe0de84d40b5cf7424f" translate="yes" xml:space="preserve">
          <source>In AngularJS, think about models, rather than jQuery-selected DOM elements that hold your data. Think about views as projections of those models, rather than registering callbacks to manipulate what the user sees.</source>
          <target state="translated">AngularJS에서는 데이터를 보유하는 jQuery로 선택한 DOM 요소보다는 모델을 생각해보십시오. 콜백을 등록하여 사용자가 보는 것을 조작하는 대신 뷰를 해당 모델의 투영으로 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="89cbb8617b950a42475e39e8432df7a8116707a2" translate="yes" xml:space="preserve">
          <source>In AngularJS, though, the view is the official record of view-based functionality. Our &lt;code&gt;ul&lt;/code&gt; declaration would look like this instead:</source>
          <target state="translated">그러나 AngularJS에서 뷰는 뷰 기반 기능의 공식 레코드입니다. &lt;code&gt;ul&lt;/code&gt; 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0162908cf1e7269bf496e946a61a8ada95cd6936" translate="yes" xml:space="preserve">
          <source>In AngularJS, we define directives. A directive is a function which returns a JSON object. This object tells AngularJS what DOM elements to look for, and what changes to make to them. Directives are hooked in to the template using either attributes or elements, which you invent. The idea is to extend the capabilities of HTML with new attributes and elements.</source>
          <target state="translated">AngularJS에서 지시어를 정의합니다. 지시문은 JSON 객체를 반환하는 함수입니다. 이 객체는 AngularJS에게 어떤 DOM 요소를 찾고 어떤 요소를 변경해야하는지 알려줍니다. 지시문은 사용자가 발명 한 속성 또는 요소를 사용하여 템플리트에 연결됩니다. 아이디어는 새로운 속성과 요소로 HTML의 기능을 확장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ead8b9954017937b7508b690030cf694823a516" translate="yes" xml:space="preserve">
          <source>In AngularJS, you want to think about &lt;strong&gt;views&lt;/strong&gt; rather than DOM elements. Views are (declarative) HTML that contain AngularJS &lt;strong&gt;directives&lt;/strong&gt;. Directives set up the event handlers behind the scenes for us and give us dynamic databinding. Selectors are rarely used, so the need for IDs (and some types of classes) is greatly diminished. Views are tied to &lt;strong&gt;models&lt;/strong&gt; (via scopes). Views are a projection of the model. Events change models (that is, data, scope properties), and the views that project those models update &quot;automatically.&quot;</source>
          <target state="translated">AngularJS에서는 DOM 요소가 아닌 &lt;strong&gt;뷰&lt;/strong&gt; 에 대해 생각하고 싶습니다. 뷰는 AngularJS &lt;strong&gt;지시문&lt;/strong&gt; 을 포함하는 (선언적) HTML입니다. 지시문은 우리를 위해 무대 뒤에서 이벤트 핸들러를 설정하고 동적 데이터 바인딩을 제공합니다. 선택기는 거의 사용되지 않으므로 ID (및 일부 유형의 클래스)에 대한 필요성이 크게 줄어 듭니다. 뷰는 범위를 통해 &lt;strong&gt;모델&lt;/strong&gt; 에 연결됩니다. 뷰는 모델의 투영입니다. 이벤트는 모델 (즉, 데이터, 범위 속성) 및 해당 모델을 투영하는 뷰가 &quot;자동으로&quot;변경됩니다.</target>
        </trans-unit>
        <trans-unit id="0978a7538d2e9b597f501e430a1fc5188f95a6ac" translate="yes" xml:space="preserve">
          <source>In fact, AngularJS is one of the few JavaScript MV* frameworks (many JavaScript MVC tools still fall under the category library).</source>
          <target state="translated">실제로 AngularJS는 몇 가지 JavaScript MV * 프레임 워크 중 하나입니다 (많은 JavaScript MVC 도구는 여전히 카테고리 라이브러리에 속함).</target>
        </trans-unit>
        <trans-unit id="90ff4de51967b0e32cde73bafc0522d33f597359" translate="yes" xml:space="preserve">
          <source>In jQuery making an Ajax call is fairly simple, but it's still something you might think twice about. There's the added complexity to think about, and a fair chunk of script to maintain.</source>
          <target state="translated">jQuery에서 Ajax 호출은 매우 간단하지만 여전히 두 번 생각할 수도 있습니다. 추가로 고려해야 할 복잡성과 유지해야 할 스크립트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d193d7aba2968b4d212b2af011f3a04f803d0cc" translate="yes" xml:space="preserve">
          <source>In jQuery we define plugins by adding functions to the jQuery.prototype. We then hook these into the DOM by selecting elements and calling the plugin on the result. The idea is to extend the capabilities of jQuery.</source>
          <target state="translated">jQuery에서는 jQuery.prototype에 함수를 추가하여 플러그인을 정의합니다. 그런 다음 요소를 선택하고 결과에서 플러그인을 호출하여이를 DOM에 연결합니다. 아이디어는 jQuery의 기능을 확장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="91a51e946cb4f1b8c319d268bb1e04bc99f9428c" translate="yes" xml:space="preserve">
          <source>In jQuery you make all your DOM changes by hand. You construct new DOM elements programatically. If you have a JSON array and you want to put it to the DOM, you must write a function to generate the HTML and insert it.</source>
          <target state="translated">jQuery에서는 모든 DOM을 수동으로 변경합니다. 프로그래밍 방식으로 새 DOM 요소를 구성합니다. JSON 배열이 있고이를 DOM에 넣으려면 HTML을 생성하고 삽입하는 함수를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="a18bb6e728d8ea68da1050a05d8c1caca3f92ba2" translate="yes" xml:space="preserve">
          <source>In jQuery, &lt;em&gt;selectors&lt;/em&gt; are used to find &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; elements and then bind/register event handlers to them. When an event triggers, that (imperative) code executes to update/change the DOM.</source>
          <target state="translated">jQuery에서 &lt;em&gt;선택기&lt;/em&gt; 는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; 요소를 찾은 다음 이벤트 핸들러를 바인딩 / 등록하는 데 사용됩니다. 이벤트가 트리거되면 DOM을 업데이트 / 변경하기 위해 해당 (제국) 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="8a90029611394ef928be3afb0243d4a481afa763" translate="yes" xml:space="preserve">
          <source>In jQuery, if we want to accomplish a small non-dom related task such as pulling a feed from an API, we might write a little function to do that in our closure. That's a valid solution, but what if we  want to access that feed often? What if we want to reuse that code in another application?</source>
          <target state="translated">jQuery에서 API에서 피드를 가져 오는 것과 같은 소규모의 비 DOM 관련 작업을 수행하려는 경우 클로저에서이를 수행하는 작은 함수를 작성할 수 있습니다. 유효한 솔루션이지만 해당 피드에 자주 액세스하려면 어떻게해야합니까? 다른 응용 프로그램에서 해당 코드를 재사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="578dbc27e0bbb209f2594106996aa6a42a880c64" translate="yes" xml:space="preserve">
          <source>In jQuery, in our application logic, we would activate it with something like:</source>
          <target state="translated">jQuery의 애플리케이션 로직에서 다음과 같이 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e592dbbf682e0219ae9b707b9547f8d0c26db26e" translate="yes" xml:space="preserve">
          <source>In jQuery, the DOM is kind of like the model. But in AngularJS, we have a separate model layer that we can manage in any way we want, completely independently from the view. This helps for the above data binding, maintains &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separation of concerns&lt;/a&gt;, and introduces far greater testability. Other answers mentioned this point, so I'll just leave it at that.</source>
          <target state="translated">jQuery에서 DOM은 모델과 비슷합니다. 그러나 AngularJS에는 뷰와 완전히 독립적으로 원하는 방식으로 관리 할 수있는 별도의 모델 계층이 있습니다. 이는 위의 데이터 바인딩에 도움을주고 &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;우려 사항의 분리를&lt;/a&gt; 유지하며 훨씬 큰 테스트 가능성을 제공합니다. 다른 답변은이 시점에서 언급 했으므로 그냥 그대로 두겠습니다.</target>
        </trans-unit>
        <trans-unit id="9df8eb4ba7e6248a7fa36700e17beb0b22254122" translate="yes" xml:space="preserve">
          <source>In jQuery, the only way to test is often to create the component independently with a sample/demo page against which our tests can perform DOM manipulation. So then we have to develop a component separately and &lt;em&gt;then&lt;/em&gt; integrate it into our application. How inconvenient! So much of the time, when developing with jQuery, we opt for iterative instead of test-driven development. And who could blame us?</source>
          <target state="translated">jQuery에서 테스트하는 유일한 방법은 종종 테스트에서 DOM 조작을 수행 할 수있는 샘플 / 데모 페이지를 사용하여 구성 요소를 독립적으로 작성하는 것입니다. 따라서 구성 요소를 별도로 개발 한 &lt;em&gt;다음&lt;/em&gt; 응용 프로그램에 통합해야합니다. 불편하다! jQuery로 개발할 때 많은 시간을 테스트 중심 개발 대신 반복을 선택합니다. 누가 우리를 비난 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="3d416179f5af40e5d18f244c9ec21f4ff3ba4392" translate="yes" xml:space="preserve">
          <source>In jQuery, we programmatically change the view. We could have a dropdown menu defined as a &lt;code&gt;ul&lt;/code&gt; like so:</source>
          <target state="translated">jQuery에서는 프로그래밍 방식으로 뷰를 변경합니다. 드롭 다운 메뉴를 &lt;code&gt;ul&lt;/code&gt; 로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cc873c923938462e55d7110881a14087792dc45" translate="yes" xml:space="preserve">
          <source>In jQuery, you design a page, and then you make it dynamic. This is because jQuery was designed for augmentation and has grown incredibly from that simple premise.</source>
          <target state="translated">jQuery에서는 페이지를 디자인 한 다음 동적으로 만듭니다. 이는 jQuery가 기능 보강을 위해 설계되었으며 단순한 전제에서 크게 성장했기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7090926b8952ded00ad0da61eb6e721bc8a14052" translate="yes" xml:space="preserve">
          <source>It focuses on &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separation of concerns&lt;/a&gt; and testing (&lt;a href=&quot;http://en.wikipedia.org/wiki/Unit_testing&quot;&gt;unit testing&lt;/a&gt; and end-to-end testing), which facilitates test-driven development.</source>
          <target state="translated">테스트 중심 개발을 용이하게하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;우려&lt;/a&gt; 및 테스트 분리 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Unit_testing&quot;&gt;단위 테스트&lt;/a&gt; 및 엔드 투 엔드 테스트)에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="68f6b3301831188f15035c61039b24d8f4da1058" translate="yes" xml:space="preserve">
          <source>It looks like this:</source>
          <target state="translated">다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="1bf8b46db45a60c96dc64642b65b408cb0586b2c" translate="yes" xml:space="preserve">
          <source>It's more similar to &lt;a href=&quot;http://en.wikipedia.org/wiki/XSLT&quot;&gt;XSLT&lt;/a&gt; than &lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt; for example.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt; 보다 &lt;a href=&quot;http://en.wikipedia.org/wiki/XSLT&quot;&gt;XSLT&lt;/a&gt; 와 더 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="fa9f7423100ee20741ac52a057ba63a8dfdb5f92" translate="yes" xml:space="preserve">
          <source>It's really two very different states of mind.</source>
          <target state="translated">정말 두 가지 다른 상태입니다.</target>
        </trans-unit>
        <trans-unit id="94d4826a0666242ba1ec0266cc07db08e55ebb65" translate="yes" xml:space="preserve">
          <source>JQuery plugins are created in a closure. Privacy is maintained within that closure. It's up to you to maintain your scope chain within that closure. You only really have access to the set of DOM nodes passed in to the plugin by jQuery, plus any local variables defined in the closure and any globals you have defined. This means that plugins are quite self contained. This is a good thing, but can get restrictive when creating a whole application. Trying to pass data between sections of a dynamic page becomes a chore.</source>
          <target state="translated">JQuery 플러그인은 클로저에서 생성됩니다. 프라이버시는 그 폐쇄 내에서 유지됩니다. 해당 폐쇄 내에서 스코프 체인을 유지 관리하는 것은 귀하의 책임입니다. jQuery에 의해 플러그인으로 전달 된 DOM 노드 세트와 클로저에 정의 된 모든 로컬 변수 및 정의한 전역 변수에만 액세스 할 수 있습니다. 이것은 플러그인이 자체 포함되어 있음을 의미합니다. 이것은 좋은 일이지만 전체 응용 프로그램을 만들 때 제한을받을 수 있습니다. 동적 페이지의 섹션간에 데이터를 전달하려고하면 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="4f2edb980b5874e73b214306540044ccfc45d51f" translate="yes" xml:space="preserve">
          <source>JavaScript - Behaviour, without the script the content remains.</source>
          <target state="translated">JavaScript-동작은 스크립트없이 내용이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0270aec9323c9370103673494bbf224ea44393df" translate="yes" xml:space="preserve">
          <source>Let's get down to the nitty gritty.</source>
          <target state="translated">멍청한 녀석에게로 갑시다.</target>
        </trans-unit>
        <trans-unit id="b836477afc268d4e57ddfe2bd54c811505cff526" translate="yes" xml:space="preserve">
          <source>Let's say in our application, we require a service that implements server-side storage through a &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;REST&lt;/a&gt; API and, depending on application state, local storage as well. When running tests on our controllers, we don't want to have to communicate with the server - we're testing the &lt;em&gt;controller&lt;/em&gt;, after all. We can just add a mock service of the same name as our original component, and the injector will ensure that our controller gets the fake one automatically - our controller doesn't and needn't know the difference.</source>
          <target state="translated">애플리케이션에서 &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;REST&lt;/a&gt; API를 통해 서버 측 스토리지를 구현하고 애플리케이션 상태에 따라 로컬 스토리지도 구현하는 서비스가 필요하다고 가정 해 보겠습니다. 컨트롤러에서 테스트를 실행할 때 서버와 통신 할 필요가 없습니다. 결국 &lt;em&gt;컨트롤러를&lt;/em&gt; 테스트하고 있습니다. 우리는 원래 구성 요소와 동일한 이름의 모의 서비스를 추가 할 수 있으며 인젝터는 컨트롤러가 가짜 컨트롤러를 자동으로 얻도록합니다. 컨트롤러는 차이점을 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="019d0f43d35ebf4308b922e715c1e5edd09fa4ad" translate="yes" xml:space="preserve">
          <source>Let's say we have a shopping cart. We might define a ShoppingCartService which maintains our cart and contains methods for adding and removing items. Because the service is a singleton, and is shared by all other components, any object that needs to can write to the shopping cart and pull data from it. It's always the same cart.</source>
          <target state="translated">장바구니가 있다고 가정 해 봅시다. 장바구니를 유지하고 품목을 추가 및 제거하기위한 메소드를 포함하는 ShoppingCartService를 정의 할 수 있습니다. 서비스는 싱글 톤이며 다른 모든 구성 요소와 공유되므로 쇼핑 카트에 쓰고 데이터를 가져올 수있는 모든 개체입니다. 항상 같은 카트입니다.</target>
        </trans-unit>
        <trans-unit id="727106c324e0d326b53eb51a45c4de3427303c78" translate="yes" xml:space="preserve">
          <source>Like me, you will quickly realize that AngularJS (or &lt;a href=&quot;http://en.wikipedia.org/wiki/Ember.js&quot;&gt;Ember.js&lt;/a&gt;, Durandal, &amp;amp; other MV* frameworks for that matter) is one complex framework assembling many of the different JavaScript design patterns.</source>
          <target state="translated">나와 마찬가지로 AngularJS (또는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Ember.js&quot;&gt;Ember.js&lt;/a&gt; , Durandal 및 기타 MV * 프레임 워크)는 여러 가지 JavaScript 디자인 패턴을 조립하는 복잡한 프레임 워크라는 것을 금방 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cfac11915904016eed201cd17895ef142e7298c" translate="yes" xml:space="preserve">
          <source>Likewise:</source>
          <target state="translated">Likewise:</target>
        </trans-unit>
        <trans-unit id="480a72e21e4eecb130022ee539c13f82e6fb2dfc" translate="yes" xml:space="preserve">
          <source>Listen to the podcast &lt;em&gt;&lt;a href=&quot;http://javascriptjabber.com/032-jsj-angular-js/&quot;&gt;JavaScript Jabber: Episode #32&lt;/a&gt;&lt;/em&gt; that features the original creators of AngularJS: Misko Hevery &amp;amp; Igor Minar. They talk a lot about what it's like to come to AngularJS from other JavaScript backgrounds, especially jQuery.</source>
          <target state="translated">AngularJS : Misko Hevery &amp;amp; Igor Minar의 최초 제작자가 &lt;em&gt;&lt;a href=&quot;http://javascriptjabber.com/032-jsj-angular-js/&quot;&gt;등장&lt;/a&gt;&lt;/em&gt; 하는 Podcast &lt;em&gt;JavaScript Jabber : Episode # 32&lt;/em&gt; 를 들어보십시오. 그들은 다른 JavaScript 배경, 특히 jQuery에서 AngularJS에 오는 것이 무엇인지에 대해 많이 이야기합니다.</target>
        </trans-unit>
        <trans-unit id="b67d9fb1be3c48bab4357a222d15c0c1c6b2a6cb" translate="yes" xml:space="preserve">
          <source>Lots of small directives vs. big plugins with configuration switches</source>
          <target state="translated">구성 스위치가있는 많은 작은 지시문 대 큰 플러그인</target>
        </trans-unit>
        <trans-unit id="d35f5ddc9a42a97abe31468fffd327ecf232b76a" translate="yes" xml:space="preserve">
          <source>MVC and SOC are not on opposite ends of the same scale, they are on completely different axes. SOC makes no sense in an AngularJS context. You have to forget it and move on.</source>
          <target state="translated">MVC와 SOC는 같은 축척의 반대쪽 끝에 있지 않으며 완전히 다른 축에 있습니다. SOC는 AngularJS 컨텍스트에서 의미가 없습니다. 당신은 그것을 잊고 계속해야합니다.</target>
        </trans-unit>
        <trans-unit id="c45a37dd264d950f6729ef56ff2a3c5abcd3a05d" translate="yes" xml:space="preserve">
          <source>Manual DOM changes vs. Data Binding</source>
          <target state="translated">수동 DOM 변경과 데이터 바인딩</target>
        </trans-unit>
        <trans-unit id="40e632bf9794198f4934d498879371d6d20bbd8f" translate="yes" xml:space="preserve">
          <source>Misko likes jQuery and doesn't object to you using it. However you will find as you advance that you can get a pretty much all of your work done using a combination of scope, templates and directives, and you should prefer this workflow where possible because your code will be more discrete, more configurable, and more Angular.</source>
          <target state="translated">Misko는 jQuery를 좋아하며이를 사용하는 것에 반대하지 않습니다. 그러나 범위, 템플릿 및 지시문의 조합을 사용하여 거의 모든 작업을 수행 할 수 있다는 것을 알게 될 것이므로 코드가 더 개별적이며 구성 가능하며 더 많기 때문에 가능한 경우이 워크 플로를 선호해야합니다. 모난.</target>
        </trans-unit>
        <trans-unit id="aec4fedd98ecef7252e688fd312c8e23a1997547" translate="yes" xml:space="preserve">
          <source>Model - your models contains your semantic data. Models are usually &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; objects. Models exist as attributes of an object called $scope. You can also store handy utility functions on $scope which your templates can then access.</source>
          <target state="translated">모델-모델에 의미 데이터가 포함되어 있습니다. 모델은 일반적으로 &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; 객체입니다. 모델은 $ scope라는 객체의 속성으로 존재합니다. 템플릿에 액세스 할 수있는 편리한 유틸리티 기능을 $ scope에 저장할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="19445a7cb4f59d8113ef809076f488b19366f851" translate="yes" xml:space="preserve">
          <source>Modular service architecture</source>
          <target state="translated">모듈 식 서비스 아키텍처</target>
        </trans-unit>
        <trans-unit id="9f995a1445edebed9a0edf58ca86dd65ac082151" translate="yes" xml:space="preserve">
          <source>Modules contain AngularJS components. &lt;strong&gt;When we include a module, all the components in that module become available to us as a simple list identified by their unique strings&lt;/strong&gt;. We can then inject those components into each other using AngularJS's dependency injection mechanism.</source>
          <target state="translated">모듈에는 AngularJS 구성 요소가 포함되어 있습니다. &lt;strong&gt;모듈을 포함 시키면 해당 모듈의 모든 구성 요소가 고유 한 문자열로 식별되는 간단한 목록으로 제공됩니다&lt;/strong&gt; . 그런 다음 AngularJS의 의존성 주입 메커니즘을 사용하여 이러한 구성 요소를 서로 주입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70589733204c633c8000b33bb5a831052090d3fd" translate="yes" xml:space="preserve">
          <source>My little book</source>
          <target state="translated">내 작은 책</target>
        </trans-unit>
        <trans-unit id="07bfe1f4feee155120fcc275ea68f1bb17d3143b" translate="yes" xml:space="preserve">
          <source>NB: This list is not complete, nor 'the best libraries'; they just happen to be the libraries I used. These libraries also include more patterns, the ones mentioned are just their main focuses or original intents. If you feel something is missing from this list, please do mention it in the comments, and I will be glad to add it.</source>
          <target state="translated">주의 :이 목록은 완전하지도 않고 '최고의 도서관'도 아닙니다. 그들은 내가 사용한 라이브러리 일뿐입니다. 이 라이브러리에는 더 많은 패턴이 포함되어 있으며 언급 된 패턴은 주요 초점 또는 원래 의도입니다. 이 목록에서 빠진 것이 있다고 생각되면 의견에 언급 해 주시면 기꺼이 추가하겠습니다.</target>
        </trans-unit>
        <trans-unit id="9c8b27c78d13ab71411ac0fb47cbd272d9d671dd" translate="yes" xml:space="preserve">
          <source>Need to update on mouseover?</source>
          <target state="translated">마우스 오버시 업데이트가 필요하십니까?</target>
        </trans-unit>
        <trans-unit id="aa01a327749e49bb46fbfc492f1fd3a49c1971bc" translate="yes" xml:space="preserve">
          <source>Now &lt;strong&gt;in our template&lt;/strong&gt; we can wire this up:</source>
          <target state="translated">이제 &lt;strong&gt;템플릿에서&lt;/strong&gt; 이를 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="153e1db9288018367b69014d7e273ac9321adee5" translate="yes" xml:space="preserve">
          <source>Now when I want to use that service I just refer to it by name like this:</source>
          <target state="translated">이제 해당 서비스를 사용하려면 다음과 같이 이름으로 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0442ca4f2eae67ddd54b40deb8356ab4b3234010" translate="yes" xml:space="preserve">
          <source>Okay, now we can write a test for the non-existent &lt;code&gt;when-active&lt;/code&gt; directive:</source>
          <target state="translated">이제 존재하지 않는 &lt;code&gt;when-active&lt;/code&gt; 지시어에 대한 테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7837f88043d6848be1c4e543d7bab6fecef2576e" translate="yes" xml:space="preserve">
          <source>One approach to designing an AngularJS application:</source>
          <target state="translated">AngularJS 애플리케이션을 설계하는 한 가지 방법 :</target>
        </trans-unit>
        <trans-unit id="2bf914d56359268ce76537cc99ef400aea8ea885" translate="yes" xml:space="preserve">
          <source>One more thing you will experience in AngularJS: in jQuery you call the jQuery functions a lot, in AngularJS, AngularJS will call your functions, so AngularJS will 'tell you how to do things', but the benefits are worth it, so learning AngularJS usually means learning what AngularJS wants or the way AngularJS requires that you present your functions and it will call it accordingly. This is one of the things that makes AngularJS a framework rather than a library.</source>
          <target state="translated">AngularJS에서 경험할 수있는 또 하나의 기능 : jQuery에서는 jQuery 함수를 많이 호출합니다. AngularJS에서는 AngularJS가 함수를 호출하므로 AngularJS는 '일을 수행하는 방법을 알려줄 것입니다. 일반적으로 AngularJS가 원하는 것을 배우거나 AngularJS가 함수를 제시 해야하는 방식을 배우면 그에 따라 호출합니다. 이것은 AngularJS를 라이브러리가 아닌 프레임 워크로 만드는 것 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="03d3b7c13e891111d419508c0bfcfcb11f3df270" translate="yes" xml:space="preserve">
          <source>One of the first questions I asked myself when starting AngularJS and running through the tutorials is &lt;strong&gt;&quot;Where is my code?&quot;&lt;/strong&gt;. I've written no JavaScript, and yet I have all this behaviour. The answer is obvious. Because AngularJS compiles the DOM, AngularJS is treating your HTML as code. For many simple cases it's often sufficient to just write a template and let AngularJS compile it into an application for you.</source>
          <target state="translated">AngularJS를 시작하고 튜토리얼을 실행할 때 가장 먼저 제기 한 질문 중 하나는 &lt;strong&gt;&quot;내 코드는 어디에 있습니까?&quot;입니다.&lt;/strong&gt; . JavaScript를 작성하지 않았지만이 모든 동작이 있습니다. 답은 분명하다. AngularJS는 DOM을 컴파일하기 때문에 AngularJS는 HTML을 코드로 취급합니다. 간단한 경우에는 템플릿을 작성하고 AngularJS가 응용 프로그램으로 컴파일하도록하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="5560b0b478cb184acb6dd255b743f68939c76bfb" translate="yes" xml:space="preserve">
          <source>One of the first things your will notice about AngularJS is that &lt;strong&gt;custom attributes are everywhere&lt;/strong&gt;. Your HTML will be littered with ng attributes, which are essentially onClick attributes on steroids. These are directives (compiler directives), and are one of the main ways in which the template is hooked to the model.</source>
          <target state="translated">AngularJS에 대해 가장 먼저 알게 될 것은 &lt;strong&gt;사용자 정의 속성이 어디에나 있다는 것&lt;/strong&gt; 입니다. HTML의 속성은 ng 속성으로 흩어지며 이는 스테로이드의 onClick 속성입니다. 이들은 지시문 (컴파일러 지시문)이며 템플릿이 모델에 연결되는 주요 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="57ecf8a54298e4269c92c7bcc0dbba1ce9d013e8" translate="yes" xml:space="preserve">
          <source>One of the points made in the podcast made a lot of things click for me with respects to your question:</source>
          <target state="translated">Podcast에서 만든 요점 중 하나는 귀하의 질문과 관련하여 많은 것들을 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="d2d60cb91258951e85b2c255d25b7443475f73c6" translate="yes" xml:space="preserve">
          <source>Our test now passes &lt;em&gt;and&lt;/em&gt; our menu performs as requested. Our development is &lt;em&gt;both&lt;/em&gt; iterative &lt;em&gt;and&lt;/em&gt; test-driven. Wicked-cool.</source>
          <target state="translated">우리의 테스트는 이제 통과 &lt;em&gt;하고&lt;/em&gt; 우리의 메뉴는 요청에 따라 수행됩니다. 우리의 개발은 반복 &lt;em&gt;적이고&lt;/em&gt; 테스트 중심입니다. 사악한.</target>
        </trans-unit>
        <trans-unit id="b1cda9d2edb4291daae963095ddaa44650f5868e" translate="yes" xml:space="preserve">
          <source>Out of all of the many jQuery plugins you've seen, used, or written, how many of them had an accompanying test suite? Not very many because jQuery isn't very amenable to that. But AngularJS is.</source>
          <target state="translated">여러분이 보거나 사용하거나 작성한 많은 jQuery 플러그인 중 몇 개가 테스트 스위트를 수 반했습니까? jQuery가 그다지 적합하지 않기 때문에 그리 많지 않습니다. 그러나 AngularJS는 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9292427c33228bbb89cf354be2c739835887f3c" translate="yes" xml:space="preserve">
          <source>Plugins vs. Directives</source>
          <target state="translated">플러그인과 지시어</target>
        </trans-unit>
        <trans-unit id="607f6c8afc68a939603967e0db86561e2011d68e" translate="yes" xml:space="preserve">
          <source>Prototypal inheritance</source>
          <target state="translated">프로토 타입 상속</target>
        </trans-unit>
        <trans-unit id="1125bad105ddcf506c8be1fdc620fda300253963" translate="yes" xml:space="preserve">
          <source>Put another way, if AngularJS doesn't do something out of the box, think how the team would accomplish it to fit right in with &lt;code&gt;ngClick&lt;/code&gt;, &lt;code&gt;ngClass&lt;/code&gt;, et al.</source>
          <target state="translated">달리 말하면 AngularJS가 즉시 무언가를하지 않으면 팀이 어떻게 &lt;code&gt;ngClick&lt;/code&gt; , &lt;code&gt;ngClass&lt;/code&gt; , 등에 적합하게 그것을 달성 할 수 있을지 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="114cadb60225b9cfb70015e3d69c1e89f1ac48ce" translate="yes" xml:space="preserve">
          <source>Remember: don't design, and then mark up. You must architect, and then design.</source>
          <target state="translated">기억하십시오 : 디자인하지 말고 마크 업하십시오. 설계하고 디자인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f161adf528d29607ada8937ad2e9d5fb2b6eb816" translate="yes" xml:space="preserve">
          <source>Say I have a component called 'FlickrService' which defines methods for pulling JSON feeds from Flickr. Now, if I want to write a controller that can access Flickr, I just need to refer to the 'FlickrService' by name when I declare the controller. AngularJS will take care of instantiating the component and making it available to my controller.</source>
          <target state="translated">Flickr에서 JSON 피드를 가져 오는 메소드를 정의하는 'FlickrService'라는 구성 요소가 있다고 가정하겠습니다. 이제 Flickr에 액세스 할 수있는 컨트롤러를 작성하려면 컨트롤러를 선언 할 때 이름으로 'FlickrService'를 참조하면됩니다. AngularJS는 구성 요소를 인스턴스화하고 내 컨트롤러에서 사용할 수 있도록 관리합니다.</target>
        </trans-unit>
        <trans-unit id="19ccf6b268bdaab6e39621189c0b09a8c462daa5" translate="yes" xml:space="preserve">
          <source>Say you have a menu that you want to unfold on hover. Well now we have a problem. Our plugin has wired in our click handler for us, we're going to need to add a configuration option to make it behave differently in this specific case.</source>
          <target state="translated">호버링 할 때 펼치려는 메뉴가 있다고 가정하십시오. 이제 문제가 생겼습니다. 플러그인은 클릭 핸들러에 연결되어 있으며,이 특정 상황에서 다르게 작동하도록 구성 옵션을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d90dd71a242dda24991720aaeaa5f7a73787c5c" translate="yes" xml:space="preserve">
          <source>Saying &quot;I have a jQuery background how do I think in AngularJS?&quot; is like saying &quot;I have an HTML background how do I think in JavaScript?&quot; The fact that you're asking the question shows you most likely don't understand the fundamental purposes of these two resources. This is why I chose to answer the question by simply pointing out the fundamental difference rather than going through the list saying &quot;AngularJS makes use of directives whereas jQuery uses CSS selectors to make a jQuery object which does this and that etc....&quot;. This question does not require a lengthy answer.</source>
          <target state="translated">&quot;AngularJS에서 어떻게 생각할 수있는 jQuery 배경이 있습니까?&quot; &quot;자바 스크립트에서 HTML을 어떻게 생각하나요?&quot;라고 말하는 것과 같습니다. 질문을하고 있다는 사실은이 두 자원의 기본 목적을 이해하지 못했을 가능성이 높습니다. 이것이 바로 &quot;AngularJS는 지시문을 사용하는 반면 jQuery는 CSS 선택기를 사용하여 이와 같은 작업을 수행하는 jQuery 객체를 만드는 것&quot;이라는 목록을 살펴 보지 않고 근본적인 차이점을 지적함으로써 질문에 대답하기로 선택한 이유입니다. . 이 질문에는 긴 답변이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b15d2624d8c5f4177ef0a3ab7aff382714a73357" translate="yes" xml:space="preserve">
          <source>Second, even if we already have jQuery on our page, there's no reason to use it here; we can simply use &lt;code&gt;angular.element&lt;/code&gt; and our component will still work when dropped into a project that doesn't have jQuery.</source>
          <target state="translated">둘째, 페이지에 jQuery가 이미 있어도 여기서 사용할 이유가 없습니다. 우리는 단순히 &lt;code&gt;angular.element&lt;/code&gt; 를 사용할 수 있으며 jQuery가없는 프로젝트에 드롭 될 때 컴포넌트는 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f1027ea73a1ce39cead4439ded7f29e2042983a5" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/a/14346528/215945&quot;&gt;https://stackoverflow.com/a/14346528/215945&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14346528/215945&quot;&gt;https://stackoverflow.com/a/14346528/215945 참조&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f1430a8f5652e40680c3ddd0c683243bf517e61" translate="yes" xml:space="preserve">
          <source>Semantic HTML vs. Semantic Models</source>
          <target state="translated">시맨틱 HTML과 시맨틱 모델</target>
        </trans-unit>
        <trans-unit id="53858a8768ea9c3d5fda9320b9574562086e2f5d" translate="yes" xml:space="preserve">
          <source>Separation of concerns</source>
          <target state="translated">우려의 분리</target>
        </trans-unit>
        <trans-unit id="6db963975c4efe88a2a596e7aed57f9bfc1a010d" translate="yes" xml:space="preserve">
          <source>Separation of concerns (SOC) vs. MVC</source>
          <target state="translated">우려 분리 (SOC) 및 MVC</target>
        </trans-unit>
        <trans-unit id="5bc1e903eb4c935f3459b8bfa4ee30d83efd9017" translate="yes" xml:space="preserve">
          <source>Service Objects vs Helper Functions</source>
          <target state="translated">서비스 객체와 도우미 함수</target>
        </trans-unit>
        <trans-unit id="4c836a91846e8f4077393af2f95820c64acdb8ff" translate="yes" xml:space="preserve">
          <source>Service objects are self-contained AngularJS components which we can use and reuse as we see fit. They are simple JSON objects containing functions and Data. They are always singletons, so if you store data on a service in one place, you can get that data out somewhere else just by requesting the same service.</source>
          <target state="translated">서비스 객체는 자체 포함 된 AngularJS 구성 요소로, 적합하다고 생각하는대로 사용하고 재사용 할 수 있습니다. 함수와 데이터를 포함하는 간단한 JSON 객체입니다. 이들은 항상 싱글 톤이므로 서비스에 데이터를 한 곳에 저장하면 동일한 서비스를 요청하여 해당 데이터를 다른 곳으로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="108da03ec5d5f76f957cbf432008dbadf4a072c6" translate="yes" xml:space="preserve">
          <source>Services are simple objects that contain functions and data. They are always singletons, meaning there can never be more than one of them. Say we want to access the Stack Overflow API, we might write a &lt;code&gt;StackOverflowService&lt;/code&gt; which defines methods for doing so.</source>
          <target state="translated">서비스는 함수와 데이터를 포함하는 간단한 개체입니다. 그것들은 항상 싱글 톤이므로 둘 이상이 될 수 없습니다. Stack Overflow API에 액세스하고 싶다고 가정하면 &lt;code&gt;StackOverflowService&lt;/code&gt; 를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcd9e97fc87fb6d10f4491826f78c5d81839dcbf" translate="yes" xml:space="preserve">
          <source>Similarly, don't start with the idea that jQuery does X, Y, and Z, so I'll just add AngularJS on top of that for models and controllers. This is &lt;em&gt;really&lt;/em&gt; tempting when you're just starting out, which is why I always recommend that new AngularJS developers don't use jQuery at all, at least until they get used to doing things the &quot;Angular Way&quot;.</source>
          <target state="translated">마찬가지로 jQuery가 X, Y 및 Z를 수행한다는 아이디어로 시작하지 마십시오. 따라서 모델 및 컨트롤러에 AngularJS를 추가합니다. 이것은 처음 시작할 때 &lt;em&gt;정말&lt;/em&gt; 유혹적입니다. 따라서 새로운 AngularJS 개발자는 적어도 &quot;Angular Way&quot;작업에 익숙해 질 때까지 jQuery를 전혀 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bcedf6e82233838f46efd8ce2fadad3c46a471c6" translate="yes" xml:space="preserve">
          <source>So if directives aren't just collections of jQuery-like functions, what are they? Directives are actually &lt;strong&gt;extensions of HTML&lt;/strong&gt;. If HTML doesn't do something you need it to do, you write a directive to do it for you, and then use it just as if it was part of HTML.</source>
          <target state="translated">지시어가 jQuery와 유사한 함수의 컬렉션이 아니라면 무엇입니까? 지시문은 실제로 &lt;strong&gt;HTML의 확장입니다&lt;/strong&gt; . HTML이 필요한 작업을 수행하지 않으면 HTML을위한 지시문을 작성한 다음 HTML의 일부인 것처럼 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6120b7aac76e709ec6a4b057e3e50cdedce773bf" translate="yes" xml:space="preserve">
          <source>So then &lt;em&gt;how&lt;/em&gt; do you do that? How do you &quot;think in AngularJS&quot;? Here are some general principles, contrasted with jQuery.</source>
          <target state="translated">그럼 &lt;em&gt;어떻게&lt;/em&gt; 합니까? &quot;AngularJS를 어떻게 생각하십니까?&quot; 다음은 jQuery와 대조되는 몇 가지 일반적인 원칙입니다.</target>
        </trans-unit>
        <trans-unit id="c8363d4dd045c968829900ac07d31222d3fe3f8c" translate="yes" xml:space="preserve">
          <source>So when people say &quot;don't include jQuery at all&quot;, it's mainly because they don't want you to use selectors; they want you to learn to use directives instead. Direct, not select!</source>
          <target state="translated">따라서 사람들이 &quot;jQuery를 전혀 포함하지 않는다&quot;고 말하면 주로 선택기를 사용하지 않기 때문입니다. 그들은 대신 지시문을 사용하는 법을 배우기를 원합니다. 직접 선택하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="353a803b7edb418ffb01abfd037657963de833b9" translate="yes" xml:space="preserve">
          <source>So, to directly answer your question: AngularJS is -very- opinionated and is a true MV* framework. However, you can still do all of the really cool stuff you know and love with jQuery inside of directives. It's not a matter of &quot;How do I do what I used to in jQuery?&quot; as much as it's a matter of &quot;How do I supplement AngularJS with all of the stuff I used to do in jQuery?&quot;</source>
          <target state="translated">따라서 귀하의 질문에 직접 대답하기 위해 : AngularJS는 매우 의견이 많으며 진정한 MV * 프레임 워크입니다. 그러나 지시문 내에서 jQuery로 알고 사랑하는 모든 멋진 작업을 계속 수행 할 수 있습니다. &quot;jQuery에서 익숙했던 것을 어떻게해야합니까?&quot;는 중요하지 않습니다. &quot;JQuery에서 사용했던 모든 것들로 AngularJS를 어떻게 보완합니까?&quot;의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="615e1f97ec6c97206dc36b15588437a9d429a60e" translate="yes" xml:space="preserve">
          <source>Some directives just decorate what's already in the view (think &lt;code&gt;ngClass&lt;/code&gt;) and therefore sometimes do DOM manipulation straight away and then are basically done. But if a directive is like a &quot;widget&quot; and has a template, it should &lt;em&gt;also&lt;/em&gt; respect separation of concerns. That is, the template &lt;em&gt;too&lt;/em&gt; should remain largely independent from its implementation in the link and controller functions.</source>
          <target state="translated">일부 지시문은보기에 이미있는 것을 장식하고 ( &lt;code&gt;ngClass&lt;/code&gt; 생각) 때로는 DOM 조작을 즉시 수행 한 다음 기본적으로 수행됩니다. 그러나 지시어가 &quot;위젯&quot;과 같고 템플릿이있는 경우, 우려의 분리 &lt;em&gt;도&lt;/em&gt; 존중해야합니다. 즉, 템플릿 &lt;em&gt;도&lt;/em&gt; 링크 및 컨트롤러 기능에서의 구현과는 독립적으로 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0b7f180f770b68b78d30a4012dd96f23b513a81e" translate="yes" xml:space="preserve">
          <source>Speaking of testing...</source>
          <target state="translated">테스트에 대해 ...</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="2c1b6c2453539d082bde5c9bc024f6fe7db931a1" translate="yes" xml:space="preserve">
          <source>Suppose I'm familiar with developing client-side applications in &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, but now I'd like to start using &lt;a href=&quot;http://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;. Can you describe the paradigm shift that is necessary? Here are a few questions that might help you frame an answer:</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 에서 클라이언트 측 애플리케이션을 개발하는 데 익숙하지만 이제 &lt;a href=&quot;http://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt; 사용을 시작하려고합니다. 필요한 패러다임 전환을 설명 할 수 있습니까? 다음은 답변을 구성하는 데 도움이되는 몇 가지 질문입니다.</target>
        </trans-unit>
        <trans-unit id="fd6f41a20d68ad3b1c1fbfcea42f10e9427c9beb" translate="yes" xml:space="preserve">
          <source>Take the example of a dropdown. When writing a dropdown plugin you might be tempted to code in click handlers, perhaps a function to add in a chevron which is either up or down, perhaps change the class of the unfolded element, show hide the menu, all helpful stuff.</source>
          <target state="translated">드롭 다운의 예를 보자. 드롭 다운 플러그인을 작성할 때 클릭 처리기에서 코드를 작성하려고 할 수 있습니다. 어쩌면 위 또는 아래에있는 갈매기 형에 추가하는 기능, 펼친 요소의 클래스를 변경하고 메뉴를 숨기거나 모든 유용한 물건을 표시하는 기능 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f73c389448f9c45c912813ff91624715c6cc34b" translate="yes" xml:space="preserve">
          <source>The JavaScript is in control. The HTML has a completely independent existence. Your HTML remains semantic even without JavaScript. Onclick attributes are very bad practice.</source>
          <target state="translated">JavaScript가 제어됩니다. HTML은 완전히 독립적으로 존재합니다. JavaScript 없이도 HTML은 의미 론적으로 유지됩니다. Onclick 속성은 매우 나쁜 습관입니다.</target>
        </trans-unit>
        <trans-unit id="130af66cb629f5431d0392abeadf163c2a137efa" translate="yes" xml:space="preserve">
          <source>The best way to start is going through &lt;a href=&quot;http://docs.angularjs.org/tutorial/&quot;&gt;their awesome tutorial&lt;/a&gt;. You can go through the steps in a couple of hours; however, in case you want to master the concepts behind the scenes, they include a myriad of reference for further reading.</source>
          <target state="translated">시작하는 가장 좋은 방법은 &lt;a href=&quot;http://docs.angularjs.org/tutorial/&quot;&gt;멋진 튜토리얼을&lt;/a&gt; 진행하는 것입니다. 몇 시간 안에 단계를 진행할 수 있습니다. 그러나 배후의 개념을 마스터하려는 경우 추가로 읽을 수있는 수많은 참조가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2e204a233be1d37e6b8cbf5eb65012ecf70edcf5" translate="yes" xml:space="preserve">
          <source>The big difference (TLDR)</source>
          <target state="translated">큰 차이 (TLDR)</target>
        </trans-unit>
        <trans-unit id="907f9bbd858732c7716065c039f6505a1e2910ac" translate="yes" xml:space="preserve">
          <source>The bottom line is this: when solutioning, first &quot;think in AngularJS&quot;; if you can't think of a solution, ask the community; if after all of that there is no easy solution, &lt;em&gt;then&lt;/em&gt; feel free to reach for the jQuery. But don't let jQuery become a crutch or you'll never master AngularJS.</source>
          <target state="translated">결론은 다음과 같습니다. 해결시 먼저 &quot;AngularJS에서 생각&quot;; 해결책을 생각할 수 없다면 커뮤니티에 문의하십시오. 이 모든 것이 쉬운 해결책이 없다면 jQuery에 자유롭게 접근하십시오. 그러나 jQuery를 버팀목으로 만들지 마십시오. 그렇지 않으면 절대 AngularJS를 마스터하지 못할 것입니다.</target>
        </trans-unit>
        <trans-unit id="e57a136d72c8717caeadf129317ca6ab40af1abf" translate="yes" xml:space="preserve">
          <source>The main thing to realise is that your template drives your application. Stop trying to write big plugins that do everything. Instead write little directives that do one thing, then write a simple template to wire them together.</source>
          <target state="translated">가장 중요한 사실은 템플릿이 응용 프로그램을 구동한다는 것입니다. 모든 것을하는 큰 플러그인을 작성하려고하지 마십시오. 대신 한 가지 작업을 수행하는 작은 지시문을 작성한 다음 간단한 템플릿을 작성하여 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="962f4b9dcab1b0d6684a689d197c000723b390d9" translate="yes" xml:space="preserve">
          <source>The template drives the application so we get HTML level granularity. If we want to make case by case exceptions, the template makes this easy.</source>
          <target state="translated">템플릿은 응용 프로그램을 구동하여 HTML 수준의 세분성을 얻습니다. 사례별로 예외를 적용하려는 경우 템플릿을 사용하면이를 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3b37bfaba497ececec74f637723357bb8a14df" translate="yes" xml:space="preserve">
          <source>The template is in the driving seat.</source>
          <target state="translated">템플릿이 운전석에 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbd42a737715dc284713f8149c27aef45340aa3e" translate="yes" xml:space="preserve">
          <source>The tendency with jQuery is to write great big plugins like lightbox which we then configure by passing in numerous values and options.</source>
          <target state="translated">jQuery의 경향은 라이트 박스와 같은 큰 플러그인을 작성하여 수많은 값과 옵션을 전달하여 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a78f488c2b28762effe665517b5bb3bf368fa282" translate="yes" xml:space="preserve">
          <source>The view is the &quot;official record&quot;</source>
          <target state="translated">보기는 &quot;공식 기록&quot;입니다</target>
        </trans-unit>
        <trans-unit id="1c2ed441fd1cd976f573b36eb08871514ae231f0" translate="yes" xml:space="preserve">
          <source>There are a few things wrong with this:</source>
          <target state="translated">이것에 몇 가지 잘못된 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a60b215ea4b528f70a3f3f95afa944b9858d76db" translate="yes" xml:space="preserve">
          <source>These two do the same thing, but in the AngularJS version anyone looking at the template knows what's supposed to happen. Whenever a new member of the development team comes on board, she can look at this and then &lt;em&gt;know&lt;/em&gt; that there is a directive called &lt;code&gt;dropdownMenu&lt;/code&gt; operating on it; she doesn't need to intuit the right answer or sift through any code. The view told us what was supposed to happen. Much cleaner.</source>
          <target state="translated">이 두 가지는 같은 일을하지만 AngularJS 버전에서는 템플릿을보고있는 사람은 무엇이 일어날 지 알고 있습니다. 개발 팀의 새로운 멤버가 탑승 할 때마다이를보고 &lt;code&gt;dropdownMenu&lt;/code&gt; 라는 지시문이 &lt;em&gt;있다는&lt;/em&gt; 것을 &lt;em&gt;알&lt;/em&gt; 수 있습니다. 그녀는 정답을 직관하거나 어떤 코드를 거칠 필요가 없습니다. 그 견해는 우리에게 무슨 일이 있었는지 말해주었습니다. 훨씬 더 깨끗합니다.</target>
        </trans-unit>
        <trans-unit id="5b12bc82675fe1d062a24637098e0b0d6f018bd6" translate="yes" xml:space="preserve">
          <source>They're apples and oranges. You don't want to compare them. They're two different things. AngularJs has already jQuery lite built in which allows you to perform basic DOM manipulation without even including the full blown jQuery version.</source>
          <target state="translated">그들은 사과와 오렌지입니다. 당신은 그들을 비교하고 싶지 않습니다. 그들은 서로 다른 두 가지입니다. AngularJs에는 이미 jQuery 라이트가 내장되어있어 완전한 jQuery 버전을 포함하지 않고도 기본 DOM 조작을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56611a6e765ec02b14bdc41b9a14cd86614e07d8" translate="yes" xml:space="preserve">
          <source>Think about how you want to present your models -- your views. Create HTML templates for each view, using the necessary directives to get dynamic databinding.</source>
          <target state="translated">모델을 어떻게 표현하고 싶은지 생각하십시오. 동적 지시문을 가져 오는 데 필요한 지시문을 사용하여 각보기에 대한 HTML 템플리트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="27d048b935d814179e7c6a8517808bc5033c1c1e" translate="yes" xml:space="preserve">
          <source>Think about your models. Create services or your own JavaScript objects for those models.</source>
          <target state="translated">모델에 대해 생각하십시오. 해당 모델에 대한 서비스 또는 고유 한 JavaScript 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c7f6bac1d5607c8628add234dae8dfe943f7ebea" translate="yes" xml:space="preserve">
          <source>Think less about unobtrusive JavaScript, and instead think in terms of HTML extensions.</source>
          <target state="translated">눈에 잘 띄지 않는 JavaScript에 대해서는 생각하지 말고 HTML 확장에 대해서는 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="d9ef4e6d01c706c53e91d508343c6fe29cbd9c16" translate="yes" xml:space="preserve">
          <source>Think of the logger we programmed in section 3. Even if we put that in a directive, we &lt;em&gt;still&lt;/em&gt; want to do it the &quot;Angular Way&quot;. It &lt;em&gt;still&lt;/em&gt; doesn't take any DOM manipulation! There are lots of times when DOM manipulation is necessary, but it's a &lt;em&gt;lot&lt;/em&gt; rarer than you think! Before doing DOM manipulation &lt;em&gt;anywhere&lt;/em&gt; in your application, ask yourself if you really need to. There might be a better way.</source>
          <target state="translated">섹션 3에서 프로그래밍 한 로거를 생각해보십시오. 지시어에 넣었더라도 &lt;em&gt;여전히&lt;/em&gt; &quot;Angular Way&quot;를 원합니다. &lt;em&gt;여전히&lt;/em&gt; DOM 조작이 필요하지 않습니다! DOM 조작이 필요한 경우가 많이 있지만 생각보다 &lt;em&gt;훨씬 드&lt;/em&gt; !니다! 애플리케이션의 &lt;em&gt;어느 곳에서나&lt;/em&gt; DOM 조작을하기 전에 실제로 필요한지 스스로에게 물어보십시오. 더 좋은 방법이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59fba0d2a6be76b95e9437f56c0b3eb3aeefa64f" translate="yes" xml:space="preserve">
          <source>Third, even assuming jQuery &lt;em&gt;was&lt;/em&gt; required for this directive to work, jqLite (&lt;code&gt;angular.element&lt;/code&gt;) will &lt;em&gt;always&lt;/em&gt; use jQuery if it was loaded! So we needn't use the &lt;code&gt;$&lt;/code&gt; - we can just use &lt;code&gt;angular.element&lt;/code&gt;.</source>
          <target state="translated">셋째,이 지시문이 작동하기 위해 jQuery &lt;em&gt;가&lt;/em&gt; 필요하다고 가정하더라도 jqLite ( &lt;code&gt;angular.element&lt;/code&gt; )는로드 된 경우 &lt;em&gt;항상&lt;/em&gt; jQuery를 사용합니다! 따라서 &lt;code&gt;$&lt;/code&gt; 를 사용할 필요가 없습니다 &amp;ndash; &lt;code&gt;angular.element&lt;/code&gt; 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3dd8e8537bb1ca3481ce114c90c34fedaf33ea7" translate="yes" xml:space="preserve">
          <source>This a little messy and a trifle frail. But in AngularJS, we can do this:</source>
          <target state="translated">이것은 약간 지저분하고 사소한 연약한 것입니다. 그러나 AngularJS에서는 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="751b9456fbde65691801d5e0cfad8c4a181a1230" translate="yes" xml:space="preserve">
          <source>This directive can be rewritten (even for very complicated cases!) much more simply like so:</source>
          <target state="translated">이 지시어는 (매우 복잡한 경우에도) 매우 간단하게 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="020626cca70fec4fadcd4c85e19094b67d89900d" translate="yes" xml:space="preserve">
          <source>This is a mistake in AngularJS.</source>
          <target state="translated">이것은 AngularJS의 실수입니다.</target>
        </trans-unit>
        <trans-unit id="3ee80553c6d3b6490cc47a8c1b3fc30604995853" translate="yes" xml:space="preserve">
          <source>This is a radical inversion of control that takes some getting used to.</source>
          <target state="translated">이것은 약간의 익숙해지는 제어의 근본적인 반전입니다.</target>
        </trans-unit>
        <trans-unit id="468caea94a05f6a1199b09552c745bdaee04f2e1" translate="yes" xml:space="preserve">
          <source>This is by far one of the most awesome features of AngularJS and cuts out a lot of the need to do the kinds of DOM manipulations I mentioned in the previous section. AngularJS will automatically update your view so you don't have to! In jQuery, we respond to events and then update content. Something like:</source>
          <target state="translated">이것은 AngularJS의 가장 멋진 기능 중 하나이며 이전 섹션에서 언급 한 종류의 DOM 조작을 수행해야 할 필요성을 많이 제거했습니다. AngularJS는 자동으로보기를 업데이트하므로 필요하지 않습니다! jQuery에서는 이벤트에 응답 한 다음 컨텐츠를 업데이트합니다. 다음과 같은 것 :</target>
        </trans-unit>
        <trans-unit id="303ce135543d65882737386396b17832595260ae" translate="yes" xml:space="preserve">
          <source>This is normal, you should push through. Angular is worth it.</source>
          <target state="translated">이것은 정상적인 현상입니다. Angular는 그만한 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1905aad1d40bfa2426382e15205e07ca50c045" translate="yes" xml:space="preserve">
          <source>This is really part of section 3 on architecture, but it's so important that I'm putting it as its own top-level section.</source>
          <target state="translated">이것은 실제로 아키텍처 섹션 3의 일부이지만, 자체 최상위 섹션으로 사용하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="383c8572d2b60f8594b548e872ffb17f8b10ed55" translate="yes" xml:space="preserve">
          <source>This is the clever part. Because the structure of $scope inheritance roughly follows the structure of the DOM, elements have access to their own scope, and any containing scopes seamlessly, all the way up to the global $scope (which is not the same as the global scope).</source>
          <target state="translated">이것은 영리한 부분입니다. $ scope 상속의 구조는 대략 DOM의 구조를 따르기 때문에 요소는 전역 $ scope (전역 범위와 동일하지 않음)까지 자체 범위 및 포함 범위에 완벽하게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3085b36e84f35d5704fcffc8d2903ab4191c80b" translate="yes" xml:space="preserve">
          <source>This is the first big difference. To jQuery, your web page is a DOM to be manipulated. To AngularJS, your HTML is code to be compiled. AngularJS reads in your whole web page and literally compiles it into a new web page using its built in compiler.</source>
          <target state="translated">이것이 첫 번째 큰 차이입니다. jQuery에서 웹 페이지는 조작 할 DOM입니다. AngularJS에게 HTML은 컴파일 할 코드입니다. AngularJS는 전체 웹 페이지를 읽고 내장 컴파일러를 사용하여 문자 그대로 새 웹 페이지로 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="1ad2248d3589183cfe2efd76e3ed9a33f9b96543" translate="yes" xml:space="preserve">
          <source>This makes it much easier to pass data around, and to store data at an appropriate level. If a dropdown is unfolded, only the dropdown $scope needs to know about it. If the user updates their preferences, you might want to update the global $scope, and any nested scopes listening to the user preferences would automatically be alerted.</source>
          <target state="translated">이를 통해 데이터를보다 쉽게 ​​전달하고 적절한 수준으로 데이터를 저장할 수 있습니다. 드롭 다운이 펼쳐지면 $ scope 만 알면됩니다. 사용자가 기본 설정을 업데이트하면 전역 $ scope를 업데이트 할 수 있으며 사용자 기본 설정을 수신하는 중첩 된 범위에 자동으로 경고됩니다.</target>
        </trans-unit>
        <trans-unit id="a8a3cb7a0749fede326fb94b0ea02af49e57374b" translate="yes" xml:space="preserve">
          <source>This makes wiring things together very easy, and pretty much eliminates any tendency towards spagettification. We have a flat list of components, and AngularJS hands them to us one by one as and when we need them.</source>
          <target state="translated">따라서 배선을 매우 쉽게 수행 할 수 있으며, 파쇄 경향을 거의 제거 할 수 있습니다. 우리는 간단한 컴포넌트 목록을 가지고 있으며, AngularJS는 필요할 때마다 하나씩 제공합니다.</target>
        </trans-unit>
        <trans-unit id="01c6c85a35ab8aa0b42467c4fd5ea8262061e009" translate="yes" xml:space="preserve">
          <source>This might sound complicated, in fact, once you relax into it, it's like flying. You don't need to create the $scope object, AngularJS instantiates and configures it for you, correctly and appropriately based on your template hierarchy. AngularJS then makes it available to your component using the magic of dependency injection (more on this later).</source>
          <target state="translated">실제로 복잡한 것처럼 들리면 일단 긴장을 풀면 마치 비행하는 것과 같습니다. $ scope 객체를 만들 필요는 없습니다. AngularJS는 템플릿 계층 구조에 따라 적절하고 적절하게 인스턴스화하고 구성합니다. 그런 다음 AngularJS는 의존성 주입의 마법을 사용하여 구성 요소에서 사용할 수있게합니다 (나중에 자세히 설명).</target>
        </trans-unit>
        <trans-unit id="026686ca92306b82d1e8c15693deeebfe16be490" translate="yes" xml:space="preserve">
          <source>Those are some very nice, but lengthy answers.</source>
          <target state="translated">그것들은 매우 훌륭하지만 긴 대답입니다.</target>
        </trans-unit>
        <trans-unit id="b3d3c648ebb51538f239af45aaff5bf2a9ed2172" translate="yes" xml:space="preserve">
          <source>Though I didn't show it here, the data binding is two-way. So those log messages could also be editable in the view just by doing this: &lt;code&gt;&amp;lt;input ng-model=&quot;entry.msg&quot; /&amp;gt;&lt;/code&gt;. And there was much rejoicing.</source>
          <target state="translated">여기에 표시하지 않았지만 데이터 바인딩은 양방향입니다. 따라서 &lt;code&gt;&amp;lt;input ng-model=&quot;entry.msg&quot; /&amp;gt;&lt;/code&gt; 를 수행하여 해당 로그 메시지를보기에서 편집 할 수도 있습니다. 그리고 기뻐했습니다.</target>
        </trans-unit>
        <trans-unit id="ea44fd1157e8b164de6f12bfc47356be4ca15c22" translate="yes" xml:space="preserve">
          <source>To answer this question, I want to share my experience on the first enterprise application with AngularJS. These are the most awesome features that Angular provide where we start changing our jQuery mindset and we get the Angular like a framework and not the library.</source>
          <target state="translated">이 질문에 대답하기 위해 AngularJS와 첫 번째 엔터프라이즈 응용 프로그램에 대한 경험을 공유하고 싶습니다. 이것들은 jQuery 마인드 변경을 시작할 때 Angular가 제공하는 가장 멋진 기능이며 라이브러리가 아닌 프레임 워크처럼 Angular를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d960bde17bc0fc487713623ef832bfbb6216643e" translate="yes" xml:space="preserve">
          <source>To describe the &quot;paradigm shift&quot;, I think a short answer can suffice.</source>
          <target state="translated">&quot;패러다임 전환&quot;을 설명하기 위해 짧은 대답만으로 충분하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="74c492c9268c2ba44b4ae9400fc50533ad33c007" translate="yes" xml:space="preserve">
          <source>To help us out with separation of concerns is &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt; (DI). If you come from a server-side language (from &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; to &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;) you're probably familiar with this concept already, but if you're a client-side guy coming from jQuery, this concept can seem anything from silly to superfluous to hipster. But it's not. :-)</source>
          <target state="translated">우려를 분리하는 데 도움이되는 것은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;의존성 주입&lt;/a&gt; (DI)입니다. 서버 측 언어 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; 에서 &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP로&lt;/a&gt; )에서 온 경우 이미이 개념에 익숙 할 것입니다. 그러나 jQuery에서 온 클라이언트 측 사람이라면이 개념은 어리석은 것에서 불필요한 것으로 힙 스터까지 보일 수 있습니다. . 그러나 그렇지 않습니다. :-)</target>
        </trans-unit>
        <trans-unit id="57c4a51d2a57fb7332a311ca65fbda307945a043" translate="yes" xml:space="preserve">
          <source>To put in another way, in jQuery, you need to think about CSS selectors, that is, where is the &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;td&lt;/code&gt; that has a class or attribute, etc., so that I can get their HTML or color or value, but in AngularJS, you will find yourself thinking like this: what model am I dealing with, I will set the model's value to true. You are not bothering yourself of whether the view reflecting this value is a checked box or resides in a &lt;code&gt;td&lt;/code&gt; element (details you would have often needed to think about in jQuery).</source>
          <target state="translated">다른 방법으로, jQuery에서 CSS 선택자, 즉 클래스 또는 속성 등이있는 &lt;code&gt;div&lt;/code&gt; 또는 &lt;code&gt;td&lt;/code&gt; 등을 생각해야합니다 .HTML 또는 색상 또는 값을 얻을 수는 있지만 AngularJS, 당신은 다음과 같이 생각할 것입니다 : 내가 다루는 모델은 모델의 가치를 true로 설정합니다. 이 값을 반영하는 뷰가 체크 박스인지 또는 &lt;code&gt;td&lt;/code&gt; 요소에 있는지 여부를 귀찮게하지 않습니다 (jQuery에서 자주 생각해야 할 세부 사항).</target>
        </trans-unit>
        <trans-unit id="f4709eee581374c200f042fc55313a1c370597e0" translate="yes" xml:space="preserve">
          <source>To sum up</source>
          <target state="translated">요약하자면</target>
        </trans-unit>
        <trans-unit id="836dd86d4b838ebe7598bd4b4cf3a469296eba00" translate="yes" xml:space="preserve">
          <source>To sum up my experiences:</source>
          <target state="translated">내 경험을 요약하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce1ba8a1eb8df452a4296dfeb3f52aabce22bb11" translate="yes" xml:space="preserve">
          <source>Unobtrusive JavaScript with Selectors vs. Declarative Templates</source>
          <target state="translated">선택기 vs 선언적 템플릿을 사용하여 눈에 잘 띄지 않는 JavaScript</target>
        </trans-unit>
        <trans-unit id="7dbc3550a5fc4912024fa7d8d15ebd8dac9e9fc3" translate="yes" xml:space="preserve">
          <source>Until you start to use this, it's hard to explain just what a massive time boon this is. Nothing like AngularJS DI exists inside jQuery.</source>
          <target state="translated">이것을 사용하기 시작할 때까지 이것이 얼마나 큰 시간인지 설명하기는 어렵습니다. AngularJS DI와 같은 것은 jQuery 안에 없습니다.</target>
        </trans-unit>
        <trans-unit id="955f8bb419dd7b30b67b29f047877ec5da2bfed5" translate="yes" xml:space="preserve">
          <source>Until you want to make a small change.</source>
          <target state="translated">약간 변경하고 싶을 때까지</target>
        </trans-unit>
        <trans-unit id="03fc4791bb56c36c6c9fce6cb595b363618e13c3" translate="yes" xml:space="preserve">
          <source>View - Your views are written in HTML. The view is usually not semantic because your data lives in the model.</source>
          <target state="translated">보기-보기가 HTML로 작성되었습니다. 데이터가 모델에 존재하므로보기는 일반적으로 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a862f238c06fc71828a9a25732468b79fbb1861" translate="yes" xml:space="preserve">
          <source>What is the biggest difference? What should I stop doing/using; what should I start doing/using instead?</source>
          <target state="translated">가장 큰 차이점은 무엇입니까? 무엇을 멈춰야합니까 / 사용; 대신 무엇을하고 / 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="0170226ebb8fd23c58004be3a692707980e1d490" translate="yes" xml:space="preserve">
          <source>What should I stop doing/using; What should I start doing/using instead?</source>
          <target state="translated">무엇을 멈춰야합니까 / 사용; 대신 무엇을하고 / 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="6e7344707e452d84d6745b34070d9c7734587cd4" translate="yes" xml:space="preserve">
          <source>What this means is that AngularJS reads your entire DOM from top to bottom and treats it as code, literally as instructions to the compiler. As it traverses the DOM, It looks for specific &lt;strong&gt;directives&lt;/strong&gt; (compiler directives) that tell the AngularJS compiler how to behave and what to do. Directives are little objects full of JavaScript which can match against attributes, tags, classes or even comments.</source>
          <target state="translated">이것이 의미하는 바는 AngularJS가 전체 DOM을 위에서 아래로 읽은 다음 문자 그대로 컴파일러의 명령으로 코드로 취급한다는 것입니다. DOM을 통과 할 때 AngularJS 컴파일러에게 동작 방식과 수행 방식을 알려주는 특정 &lt;strong&gt;지시문&lt;/strong&gt; (컴파일러 지시문)을 찾습니다. 지시문은 속성, 태그, 클래스 또는 주석과 일치 할 수있는 JavaScript로 가득 찬 작은 객체입니다.</target>
        </trans-unit>
        <trans-unit id="065885e8affa9b9b626e5ee7819e4774e1e660cf" translate="yes" xml:space="preserve">
          <source>When the Angular compiler determines that a piece of the DOM matches a particular directive, it calls the directive function, passing it the DOM element, any attributes, the current $scope (which is a local variable store), and some other useful bits. These attributes may contain expressions which can be interpreted by the Directive, and which tell it how to render, and when it should redraw itself.</source>
          <target state="translated">Angular 컴파일러는 DOM 조각이 특정 지시문과 일치한다고 판단하면 지시문 함수를 호출하여 DOM 요소, 속성, 현재 $ scope (로컬 변수 저장소) 및 기타 유용한 비트를 전달합니다. 이러한 속성에는 지시문에 의해 해석 될 수있는 표현과 렌더링 방법 및 언제 다시 그려야하는 표현이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1f85922f7e91e37e11942af0d06bbc55d4f2b85" translate="yes" xml:space="preserve">
          <source>When we just look at the view, it's not immediately obvious that there is any functionality here. For small applications, that's fine. But for non-trivial applications, things quickly get confusing and hard to maintain.</source>
          <target state="translated">뷰를 살펴보면 여기에 기능이 있다는 것이 분명하지 않습니다. 작은 응용 프로그램의 경우 문제가 없습니다. 그러나 사소한 응용 프로그램의 경우 상황이 빠르게 혼란스럽고 유지 관리하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="f1562ae865a8c76b7015478b8cdbdfe3f9de7697" translate="yes" xml:space="preserve">
          <source>When you first see this you might be tempted to write AngularJS off as old school intrusive JavaScript (like I did at first). In fact, AngularJS does not play by those rules. In AngularJS, your HTML5 is a template. It is compiled by AngularJS to produce your web page.</source>
          <target state="translated">처음에 이것을 보았을 때 AngularJS를 구식 침입 JavaScript로 작성하고 싶을 수도 있습니다 (처음에했던 것처럼). 실제로 AngularJS는 이러한 규칙을 따르지 않습니다. AngularJS에서 HTML5는 템플릿입니다. AngularJS에 의해 컴파일되어 웹 페이지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7f3d35681fa2c63c5104c34b879516df9d536a1b" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;jQuery&lt;/strong&gt; you tell the DOM what needs to happen, step by step. With &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;&lt;/strong&gt; you describe what results you want but not how to do it. More on this &lt;a href=&quot;https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming&quot;&gt;here&lt;/a&gt;. Also, check out Mark Rajcok's answer.</source>
          <target state="translated">&lt;strong&gt;jQuery&lt;/strong&gt; 를 사용하면 DOM에 필요한 단계를 단계별로 알려줍니다. &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;&lt;/strong&gt; 를 사용하면 원하는 결과는 있지만 수행 방법은 설명하지 않습니다. &lt;a href=&quot;https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming&quot;&gt;여기&lt;/a&gt; 에 더 많은 것 . 또한 Mark Rajcok의 답변을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fc839325c446b08cf5a65d8819d89d6bb3164e33" translate="yes" xml:space="preserve">
          <source>With AngularJS you have your model (JavaScript objects you are already used to) and the value of the model tells you about the model (obviously) and about the view, and an operation on the model automatically propagates to the view, so you don't have to think about it. You will find yourself in AngularJS no longer finding things in the DOM.</source>
          <target state="translated">AngularJS를 사용하면 모델 (이미 익숙한 JavaScript 객체)이 있으며 모델 값은 모델에 대해 (분명히) 뷰에 대해 알려주고 모델의 작업은 자동으로 뷰에 전파되므로 그것에 대해 생각할 필요가 없습니다. AngularJS에서 더 이상 DOM에서 물건을 찾지 못할 것입니다.</target>
        </trans-unit>
        <trans-unit id="4652c10e282176714fe41ae1e85eb5402efa7939" translate="yes" xml:space="preserve">
          <source>With jQuery your HTML page should contain semantic meaningful content. If the JavaScript is turned off (by a user or search engine) your content remains accessible.</source>
          <target state="translated">jQuery를 사용하면 HTML 페이지에 의미있는 의미있는 내용이 포함되어야합니다. 사용자 또는 검색 엔진이 JavaScript를 끄면 컨텐츠에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1706ec5fb5ac78f5fde18c0d8566fbe135cc3c" translate="yes" xml:space="preserve">
          <source>You can do a lot with jQuery without knowing about how JavaScript prototypal inheritance works. When developing AngularJS applications, you will avoid some common pitfalls if you have a good understanding of JavaScript inheritance. Recommended reading: &lt;a href=&quot;https://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs&quot;&gt;What are the nuances of scope prototypal / prototypical inheritance in AngularJS?&lt;/a&gt;</source>
          <target state="translated">JavaScript 프로토 타입 상속이 어떻게 작동하는지 알지 않고도 jQuery로 많은 작업을 수행 할 수 있습니다. AngularJS 애플리케이션을 개발할 때 JavaScript 상속에 대해 잘 알고 있다면 일반적인 함정을 피할 수 있습니다. 권장 독서 : &lt;a href=&quot;https://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs&quot;&gt;AngularJS에서 스코프 프로토 타입 / 프로토 타입 상속의 뉘앙스는 무엇입니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3bccb18f2df39489cf9c94bdc521ad8c56f6483" translate="yes" xml:space="preserve">
          <source>You get simple code reuse, if you want to write another application based on Flickr, you can just include the Flickr module and voila, you have access to all your Flickr related functions in your new application.</source>
          <target state="translated">Flickr 기반의 다른 응용 프로그램을 작성하려면 간단한 코드 재사용이 가능합니다. Flickr 모듈과 voila 만 포함하면 새 응용 프로그램의 모든 Flickr 관련 기능에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07a633bd9c67d80494b78137069dcf9bff6f8d9c" translate="yes" xml:space="preserve">
          <source>You may use it on existing applications where you are already using pure jQuery. However, if you want to fully take advantage of the AngularJS features you may consider coding the server side using a &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; approach.</source>
          <target state="translated">이미 순수 jQuery를 사용중인 기존 애플리케이션에서 사용할 수 있습니다. 그러나 AngularJS 기능을 완전히 활용하려면 &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; 접근 방식을 사용하여 서버 측 코딩을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e48c750ccd396d3473070f7e54269ec34e6751" translate="yes" xml:space="preserve">
          <source>You'll often hear &quot;only do DOM manipulation in a directive&quot;. &lt;strong&gt;This is a necessity.&lt;/strong&gt; Treat it with due deference!</source>
          <target state="translated">종종 &quot;지시문에서 DOM 조작 만한다&quot;는 소리가납니다. &lt;strong&gt;이것은 필수입니다.&lt;/strong&gt; 정당한 지연으로 처리하십시오!</target>
        </trans-unit>
        <trans-unit id="e9d5a9c89b6ee27e430aeadc83c97fafeb311b2e" translate="yes" xml:space="preserve">
          <source>Your template drives your application. It's treated as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL&lt;/a&gt;. You write AngularJS components, and AngularJS will take care of pulling them in and making them available at the right time based on the structure of your template. This is very different to a standard &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; pattern, where the template is just for output.</source>
          <target state="translated">템플릿이 애플리케이션을 주도합니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL&lt;/a&gt; 로 취급됩니다. AngularJS 구성 요소를 작성하면 AngularJS가 템플릿 구조를 기반으로 올바른 구성 요소를 가져와 적절한 시간에 사용할 수 있도록합니다. 이것은 템플릿이 출력용 인 표준 &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; 패턴과는 매우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f63336c8b68dbd54d77ba260a5e6c9141be9ff84" translate="yes" xml:space="preserve">
          <source>Your template should be declarative; its meaning should be clear simply by reading it. We use custom attributes with meaningful names. We make up new HTML elements, again with meaningful names. A designer with minimal HTML knowledge and no coding skill can read your AngularJS template and understand what it is doing. He or she can make modifications. &lt;em&gt;This is the Angular way.&lt;/em&gt;</source>
          <target state="translated">템플릿은 선언적이어야합니다. 그것의 의미는 단순히 그것을 읽음으로써 분명해야합니다. 의미있는 이름을 가진 사용자 지정 특성을 사용합니다. 의미있는 이름으로 새로운 HTML 요소를 다시 구성합니다. HTML 지식이 거의없고 코딩 기술이없는 디자이너는 AngularJS 템플릿을 읽고 그것이 무엇을하고 있는지 이해할 수 있습니다. 그 또는 그녀는 수정할 수 있습니다. &lt;em&gt;이것은 각도 방식입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bdf7e60e32dde216fb6e902f1792e6d04b0b4e9" translate="yes" xml:space="preserve">
          <source>and there is one more thing, that's the directive. It's an attribute  you can attach to any DOM element and you can go nuts with jQuery within it without worrying about your jQuery ever conflicts with AngularJs components or messes up with its architecture.</source>
          <target state="translated">지시어가 하나 더 있습니다. 이는 모든 DOM 요소에 연결할 수있는 속성이며, jQuery가 AngularJs 구성 요소와 충돌하거나 아키텍처와 엉망이 될 걱정없이 jQuery를 사용하여 견딜 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00853d73f19844948fadbc48d500f997c46f7ee4" translate="yes" xml:space="preserve">
          <source>jQuery</source>
          <target state="translated">jQuery</target>
        </trans-unit>
        <trans-unit id="be925b4f423bcada24aaecc3aafd5c04280ae11d" translate="yes" xml:space="preserve">
          <source>jQuery employs &lt;a href=&quot;http://en.wikipedia.org/wiki/Unobtrusive_JavaScript&quot;&gt;unobtrusive JavaScript&lt;/a&gt; - behavior (JavaScript) is separated from the structure (HTML).</source>
          <target state="translated">jQuery는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Unobtrusive_JavaScript&quot;&gt;눈에 거슬리지 않는 JavaScript를&lt;/a&gt; 사용합니다. 동작 (JavaScript)은 구조 (HTML)와 분리되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c320142ede798313f44c3d11d76a83ae93eda792" translate="yes" xml:space="preserve">
          <source>jQuery gives you a toolkit for selecting arbitrary bits of the DOM and making ad-hoc changes to them. You can do pretty much anything you like piece by piece.</source>
          <target state="translated">jQuery는 DOM의 임의 비트를 선택하고 임시로 변경하기위한 툴킷을 제공합니다. 당신은 한 조각 씩 좋아하는 거의 모든 것을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9491d0d475183db24d559659151458a8832e918" translate="yes" xml:space="preserve">
          <source>jQuery is a DOM manipulation library.</source>
          <target state="translated">jQuery는 DOM 조작 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="dc5ccb5632110fdd3b6daae0577b2656f4f69591" translate="yes" xml:space="preserve">
          <source>jQuery is a way to make programming JavaScript in the browser easier. Shorter, cross-browser commands, etc.</source>
          <target state="translated">jQuery는 브라우저에서 JavaScript를 쉽게 프로그래밍 할 수있는 방법입니다. 더 짧은 브라우저 간 명령 등</target>
        </trans-unit>
        <trans-unit id="18f057b6ceb40d6c2c4a68a9d1752b11d2e478bc" translate="yes" xml:space="preserve">
          <source>jQuery is all about DOM manipulation. It solves all the cross browser pain otherwise you will have to deal with but it's not a framework that allows you to divide your app into components like AngularJS.</source>
          <target state="translated">jQuery는 DOM 조작에 관한 것입니다. 그렇지 않으면 처리해야 할 모든 크로스 브라우저 문제를 해결하지만 AngularJS와 같은 구성 요소로 앱을 나눌 수있는 프레임 워크는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b8a1fbe4c24f3cd32559fc40d013cf05b48575a8" translate="yes" xml:space="preserve">
          <source>jQuery is typically applied unobtrusively. Your JavaScript code is linked in the header (or the footer), and this is the only place it is mentioned. We use selectors to pick out bits of the page and write plugins to modify those parts.</source>
          <target state="translated">jQuery는 일반적으로 눈에 거슬리지 않게 적용됩니다. JavaScript 코드는 머리글 (또는 바닥 글)에 연결되어 있으며 이것이 유일하게 언급 된 곳입니다. 우리는 선택기를 사용하여 페이지의 비트를 선택하고 플러그인을 작성하여 해당 부분을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="970e2a9590ad405940e9e253b4e0d66959d31936" translate="yes" xml:space="preserve">
          <source>jQuery makes ridiculously long JavaScript commands like &lt;code&gt;getElementByHerpDerp&lt;/code&gt; shorter and cross-browser.</source>
          <target state="translated">jQuery는 &lt;code&gt;getElementByHerpDerp&lt;/code&gt; 와 같은 엄청나게 긴 JavaScript 명령을 더 짧고 크로스 브라우저로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c7b8d7c0d6361934bbf52868690dfdb5012d95ae" translate="yes" xml:space="preserve">
          <source>jQuery says very little about how you should organise your code. AngularJS has opinions.</source>
          <target state="translated">jQuery는 코드를 구성하는 방법에 대해 거의 말하지 않습니다. AngularJS는 의견이 있습니다.</target>
        </trans-unit>
        <trans-unit id="34f8968c02f9b2effb99adc9f1eadb7ef80c5c90" translate="yes" xml:space="preserve">
          <source>jQuery: you think a lot about 'QUERYing the &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;' for DOM elements and doing something.</source>
          <target state="translated">jQuery : DOM 요소에 대한 ' &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; 쿼리'에 대해 많이 생각하고 무언가를합니다.</target>
        </trans-unit>
        <trans-unit id="5ba0c567dacd0527890e40d7b7790df6aec5ca39" translate="yes" xml:space="preserve">
          <source>w00t!</source>
          <target state="translated">w00t!</target>
        </trans-unit>
        <trans-unit id="c546eb5a1fdcd9672da789e9684f30280d159a04" translate="yes" xml:space="preserve">
          <source>will output the user name in a paragraph. It's a live binding, so if the &lt;code&gt;$scope.user.name&lt;/code&gt; value is updated, the template will update too.</source>
          <target state="translated">단락에서 사용자 이름을 출력합니다. 라이브 바인딩이므로 &lt;code&gt;$scope.user.name&lt;/code&gt; 값이 업데이트되면 템플릿도 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="cbda61a42cf4628d5b234a95997da65ed8079da7" translate="yes" xml:space="preserve">
          <source>“Thinking in AngularJS” if I have a jQuery background</source>
          <target state="translated">jQuery 배경이있는 경우&amp;ldquo;AngularJS에서 생각하기&amp;rdquo;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
