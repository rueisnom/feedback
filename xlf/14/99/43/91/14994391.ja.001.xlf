<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/14994391">
    <body>
      <group id="14994391">
        <trans-unit id="2e892d84a456775f25c00e4f845837dd39c07406" translate="yes" xml:space="preserve">
          <source>--&amp;gt;For any developer coming from jQuery background, my first advice would be to &quot;learn JavaScript as a first class language before jumping onto a rich framework like AngularJS!&quot;
I learned the above fact the hard way.</source>
          <target state="translated">-&amp;gt; jQueryのバックグラウンドを持つ開発者の場合、私の最初のアドバイスは、「AngularJSのようなリッチなフレームワークにジャンプする前に、JavaScriptをファーストクラス言語として学習すること」です。 上記の事実を一生懸命学びました。</target>
        </trans-unit>
        <trans-unit id="396fc50aacb3d9fb04c78bba466f7908a2e8385d" translate="yes" xml:space="preserve">
          <source>1. Don't design your page, and then change it with &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; manipulations</source>
          <target state="translated">1.ページを設計せず、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;操作で変更する</target>
        </trans-unit>
        <trans-unit id="3828151a3b203e32a8d4b22c6fdb84d2f290a8bc" translate="yes" xml:space="preserve">
          <source>2. Don't augment jQuery with AngularJS</source>
          <target state="translated">2.jQueryをAngularJSで拡張しない</target>
        </trans-unit>
        <trans-unit id="cbedaed8896e96dbbaa762bfb0a519199fab646b" translate="yes" xml:space="preserve">
          <source>3. Always think in terms of architecture</source>
          <target state="translated">3.常に建築の観点から考える</target>
        </trans-unit>
        <trans-unit id="9bb57b273b075b57706f730ef766b8139c69ca9e" translate="yes" xml:space="preserve">
          <source>4. Test-driven development - &lt;em&gt;always&lt;/em&gt;</source>
          <target state="translated">4.テスト駆動開発- &lt;em&gt;常に&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5df0490b33144a83a19e27b67ca325463559d8dd" translate="yes" xml:space="preserve">
          <source>5. Conceptually, directives are &lt;em&gt;not&lt;/em&gt; packaged jQuery</source>
          <target state="translated">5.概念的には、ディレクティブはjQueryにパッケージ化されて&lt;em&gt;いません&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d37a0363a38e4535d4fbf679c38b69053d2845a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Dependency injection&lt;/a&gt; (DI) vs. Instatiation - aka de-spaghettification</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;依存性注入&lt;/a&gt; （DI）とインスタシエーション-別名スパゲティフィケーション</target>
        </trans-unit>
        <trans-unit id="5b2bf38bee1c00dcbf6a933d82ad04998661ee32" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;Separation of concerns&lt;/a&gt; (SOC) is a pattern that grew up over many years of web development for a variety of reasons including SEO, accessibility and browser incompatibility. It looks like this:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;懸念の分離&lt;/a&gt; （SOC）は、SEO、アクセシビリティ、ブラウザの非互換性などのさまざまな理由により、長年のWeb開発で育ったパターンです。 次のようになります。</target>
        </trans-unit>
        <trans-unit id="50b9bf0923a4b128bb297b2cf829a6c75cccc91e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;/ &lt;a href=&quot;http://underscorejs.org&quot;&gt;Underscore&lt;/a&gt; for the &lt;strong&gt;facade pattern&lt;/strong&gt; (like WYSIWYG's for manipulating the DOM)</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt; / &lt;strong&gt;ファサードパターンの&lt;/strong&gt; &lt;a href=&quot;http://underscorejs.org&quot;&gt;アンダースコア&lt;/a&gt; （DOMを操作するWYSIWYGのような）</target>
        </trans-unit>
        <trans-unit id="69042625919dd0e27703e71445b2b7bd23b39703" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://knockoutjs.com&quot;&gt;KnockoutJS&lt;/a&gt; for the &lt;strong&gt;observable, publish/subscribe pattern&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;観察可能なパブリッシュ/サブスクライブパターンの&lt;/strong&gt; &lt;a href=&quot;http://knockoutjs.com&quot;&gt;KnockoutJS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7a0982ee2f9c3c522d1ee89cd375e2cb7609417" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://prototypejs.org&quot;&gt;Prototype.js&lt;/a&gt; for the &lt;strong&gt;prototype/ constructor/ mixin pattern&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;http://prototypejs.org&quot;&gt;プロトタイプ&lt;/a&gt; &lt;strong&gt;/コンストラクター/ミックスインパターンの&lt;/strong&gt; Prototype.js</target>
        </trans-unit>
        <trans-unit id="92b3217c5ba1cc0f9135ed9705adca8c3f975b4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://requirejs.org&quot;&gt;RequireJS&lt;/a&gt;/ &lt;a href=&quot;https://github.com/cujojs/curl&quot;&gt;Curl.js&lt;/a&gt; for the &lt;strong&gt;module pattern/ AMD&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;モジュールパターン/ AMDの&lt;/strong&gt; &lt;a href=&quot;http://requirejs.org&quot;&gt;RequireJS&lt;/a&gt; / &lt;a href=&quot;https://github.com/cujojs/curl&quot;&gt;Curl.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d9b870b99d1adcc3ce0b3833fc3f86074e9524de" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.google.be/search?q=js+oop&quot;&gt;JavaScript Object-oriented Programming&lt;/a&gt; (this is a Google search link). It is not a library, but certainly a prerequisite to any application programming. It taught me the native implementations of the &lt;strong&gt;prototype, constructor, singleton &amp;amp; decorator patterns&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.google.be/search?q=js+oop&quot;&gt;JavaScriptオブジェクト指向プログラミング&lt;/a&gt; （これはGoogle検索リンクです）。 ライブラリではありませんが、アプリケーションプログラミングの前提条件です。 &lt;strong&gt;プロトタイプ、コンストラクター、シングルトン＆デコレーターパターン&lt;/strong&gt;のネイティブ実装を教えてくれました</target>
        </trans-unit>
        <trans-unit id="abd6dd62d85dac964abb4fc9b6d39f70c1511d55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The AngularJS way is to extend the capabilities of native looking HTML.&lt;/em&gt; You should write HTML that looks like HTML, extended with custom attributes and elements.</source>
          <target state="translated">&lt;em&gt;AngularJSの方法は、ネイティブに見えるHTMLの機能を拡張することです。&lt;/em&gt; HTMLのように見え、カスタム属性と要素で拡張されたHTMLを記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="42d5cb01532a1eb833bc5dc3442165730fc715f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS and jQuery:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;AngularJSとjQuery：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2cb0e6123d036e1454b06c3e92f6619c31e7b8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS&lt;/strong&gt; is a beautiful client-side framework, highly testable, that combines tons of cool stuff such as MVC, &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, data binding and much more.</source>
          <target state="translated">&lt;strong&gt;AngularJS&lt;/strong&gt;は、MVC、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;依存関係の注入&lt;/a&gt; 、データバインディングなどの多くの優れた機能を組み合わせた、高度なテストが可能な美しいクライアント側フレームワークです。</target>
        </trans-unit>
        <trans-unit id="0f7938672e21aa28fcfa2974e178640ad994aae7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controllers are great:&lt;/strong&gt;
Controllers take care of their own HTML, but this separation works well for common functionality well as. If you want to call the same function on the click of a button on master HTML, just write the same function name in each controller and write individual code.</source>
          <target state="translated">&lt;strong&gt;コントローラーは素晴らしいです：&lt;/strong&gt;コントローラーは独自のHTMLを処理しますが、この分離は一般的な機能でもうまく機能します。 マスターHTMLのボタンをクリックして同じ関数を呼び出したい場合は、各コントローラーに同じ関数名を記述し、個別のコードを記述します。</target>
        </trans-unit>
        <trans-unit id="c11e6c999d67e30b4dd08344b653ee2887d7eeb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensibility&lt;/strong&gt;: Angular has extended the HTML directives using angular directives. Write expressions inside html and evaluate them on runtime. Create your own directives and services and use them in another project without any extra effort.</source>
          <target state="translated">&lt;strong&gt;拡張性&lt;/strong&gt; ：Angularは、角度ディレクティブを使用してHTMLディレクティブを拡張しました。 HTML内に式を記述し、実行時に評価します。 独自のディレクティブとサービスを作成し、余計な手間をかけずにそれらを別のプロジェクトで使用します。</target>
        </trans-unit>
        <trans-unit id="0a5df869fa8dc89f42caf2f14c8a4d5438689936" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IGOR&lt;/strong&gt;: So think of directive as the instruction to the compiler that tells it whenever you come across this certain element or this CSS in the template, and you keep this kind of code and that code is in charge of the element and everything below that element in the DOM tree.</source>
          <target state="translated">&lt;strong&gt;IGOR&lt;/strong&gt; ：ディレクティブは、テンプレート内のこの特定の要素またはこのCSSに遭遇したときに必ず指示するコンパイラーへの指示と考えてください。この種のコードを保持し、そのコードが要素とその要素の下にあるすべてを担当しますDOMツリー内。</target>
        </trans-unit>
        <trans-unit id="fb847df57ef2048ada827543b7b83275102b35c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ideal for &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; architecture:&lt;/strong&gt;
Being a complete frameworks makes AngularJS great to work with a RESTful architecture. To call REST CRUD APIs is very easier and</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt;アーキテクチャに最適：&lt;/strong&gt;完全なフレームワークであるため、AngularJSはRESTfulアーキテクチャでの作業に最適です。 REST CRUD APIを呼び出すのは非常に簡単で、</target>
        </trans-unit>
        <trans-unit id="6db3ad18a3fcffc3e35affc669f632a630d17906" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you have some data and are now trying to update HTML... STOP! update the model, and make sure your HTML is bound to the model.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;データがあり、HTMLを更新しようとしている場合は、停止してください。&lt;/strong&gt; &lt;strong&gt;モデルを更新し、HTMLがモデルにバインドされていることを確認します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a19b1a68f851522bd0cf824036f977b0867ca9fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Imperative vs Declarative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;命令型と宣言型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f010845158f0f95b6de7c77468721d2aacc26955" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MISKO&lt;/strong&gt;: [...] one of the things we thought about very hardly in Angular is, how do we provide lots of escape hatches so that you can get out and basically figure out a way out of this. So to us, the answer is this thing called &amp;ldquo;Directives&amp;rdquo;. &lt;strong&gt;And with directives, you essentially become a regular little jQuery JavaScript, you can do whatever you want.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MISKO&lt;/strong&gt; ：[...]私たちがAngularでほとんど考えていなかったことの1つは、脱出して基本的にこれからの方法を理解できるように、たくさんのエスケープハッチを提供する方法です。 私たちにとって、答えは「ディレクティブ」と呼ばれるものです。 &lt;strong&gt;ディレクティブを使用すると、基本的には通常の小さなjQuery JavaScriptになり、好きなことを何でも実行できます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb2c2d380076a74aa03ad025fcf7629b16d2b1de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins extend jQuery. AngularJS Directives extend the capabilities of your browser.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プラグインはjQueryを拡張します。&lt;/strong&gt; &lt;strong&gt;AngularJSディレクティブは、ブラウザーの機能を拡張します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c47fced225128e4a144ce379fa468a4309c6e8e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins:&lt;/strong&gt;
There are many other similar features like showing an overlay in your app. You don't need to write code for it, just use an overlay plugin available as wc-overlay, and this will automatically take care of all &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; (XHR) requests.</source>
          <target state="translated">&lt;strong&gt;プラグイン：&lt;/strong&gt;アプリにオーバーレイを表示するなど、他にも多くの同様の機能があります。 そのためのコードを記述する必要はありません。wc-overlayとして利用可能なオーバーレイプラグインを使用するだけで、すべての&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; （XHR）リクエストが自動的に処理されます。</target>
        </trans-unit>
        <trans-unit id="887a0d220804750ef67bb7862fb203a7bd2bcb18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reusable directives are super:&lt;/strong&gt;
Write directives in one place and use it throughout the application. OMG!!! I used these directive for paging, regex, validations, etc. It is really cool!</source>
          <target state="translated">&lt;strong&gt;再利用可能なディレクティブは非常に優れ&lt;/strong&gt;ています。ディレクティブを1か所に記述し、アプリケーション全体で使用できます。 ああ、神様！！！ これらのディレクティブをページング、正規表現、検証などに使用しました。</target>
        </trans-unit>
        <trans-unit id="f69a19e5ccd84c1031161d37ece994aed62fe59d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Routing is strong:&lt;/strong&gt;
It's up to your implementation how you want to use it, but it requires very few lines of code to route the request to specify HTML and controller (JavaScript)</source>
          <target state="translated">&lt;strong&gt;ルーティングは強力です。&lt;/strong&gt;どのように使用するかは実装次第ですが、リクエストをルーティングしてHTMLとコントローラー（JavaScript）を指定するために必要なコード行はごくわずかです</target>
        </trans-unit>
        <trans-unit id="797f295648a2a0dbe2273589c1be293d5bfe525f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Services&lt;/strong&gt;: Write common codes using services and less code in controllers. Sevices can be used to share common functionalities among the controllers.</source>
          <target state="translated">&lt;strong&gt;サービス&lt;/strong&gt; ：サービスを使用して一般的なコードを記述し、コントローラーのコードを少なくします。 サービスを使用して、コントローラー間で共通の機能を共有できます。</target>
        </trans-unit>
        <trans-unit id="138e836a952df3aa65cdcd5ed6d0228190442e07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stop trying to drive your application from your JavaScript. Let the template drive the application, and let AngularJS take care of wiring the components together. This also is the Angular way.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JavaScriptからアプリケーションを駆動しようとするのをやめます。&lt;/strong&gt; &lt;strong&gt;テンプレートでアプリケーションを駆動し、AngularJSでコンポーネントの相互接続を処理します。&lt;/strong&gt; &lt;strong&gt;これもまた角度的な方法です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fdb21836db9637198f74d2b8f19405107dec8dbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This means that Angular is Template Driven&lt;/strong&gt;. Your template drives the JavaScript, not the other way around. This is a radical reversal of roles, and the complete opposite of the unobtrusive JavaScript we have been writing for the last 10 years or so. This can take some getting used to.</source>
          <target state="translated">&lt;strong&gt;これは、Angularがテンプレート駆動型であることを意味します&lt;/strong&gt; 。 テンプレートはJavaScriptを駆動しますが、その逆ではありません。 これは、役割が根本的に逆転したものであり、過去10年間ほど私たちが書いてきた控えめなJavaScriptとは正反対です。 これには慣れるまでに時間がかかる場合があります。</target>
        </trans-unit>
        <trans-unit id="20ab0f6802a5394aa105383981477201dead0b2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two-way data binding is amazing:&lt;/strong&gt; 
I had a grid with all functionality UPDATE, DELTE, INSERT. I have a data object that binds the grid's model using ng-repeat. You only need to write a single line of simple JavaScript code for delete and insert and that's it. grid automatically updates as the grid model changes instantly. Update functionality is real time, no code for it.
You feel amazing!!!</source>
          <target state="translated">&lt;strong&gt;双方向のデータバインディングはすばらしいです。&lt;/strong&gt;グリッドには、すべての機能UPDATE、DELTE、INSERTがありました。 ng-repeatを使用してグリッドのモデルをバインドするデータオブジェクトがあります。 削除と挿入のための単純なJavaScriptコードを1行書くだけでよいのです。 グリッドモデルが瞬時に変更されると、グリッドは自動的に更新されます。 更新機能はリアルタイムであり、コードはありません。 あなたは素晴らしい気分です!!!</target>
        </trans-unit>
        <trans-unit id="36ae55072d91b6ded3403dc2b4cad372aaa77444" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your HTML source is no longer semantic, instead, your API and compiled DOM are semantic.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTMLソースはセマンティックではなくなり、代わりにAPIとコンパイルされたDOMがセマンティックになります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0ed9f7320d225087a2cabdd3049cfd766fead2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery&lt;/strong&gt; is a library</source>
          <target state="translated">&lt;strong&gt;jQuery&lt;/strong&gt;はライブラリです</target>
        </trans-unit>
        <trans-unit id="6c335564959dc2af53604b8909e474e66420b796" translate="yes" xml:space="preserve">
          <source>A nice thing about AngularJs is that it allows you to separate/isolate the DOM manipulation in the directives.  There are built-in directives ready for you to use such as ng-click. You can create your own custom directives that will contain all your view logic or DOM manipulation so you don't end up mingle DOM manipulation code in the controllers or services that should take care of the business logic.</source>
          <target state="translated">AngularJsの良いところは、DOMの操作をディレクティブで分離できることです。ng-clickのようなビルトインのディレクティブが用意されています。独自のカスタムディレクティブを作成して、すべてのビューロジックやDOM操作を含むようにすることができ、ビジネスロジックを処理するはずのコントローラやサービスにDOM操作のコードが混ざってしまうことがありません。</target>
        </trans-unit>
        <trans-unit id="7ceb5d7ed6945141f56ba005625ff024d9d7eb17" translate="yes" xml:space="preserve">
          <source>A transcript of the entire episode is available at the link provided above.</source>
          <target state="translated">エピソード全体のトランスクリプトは、上記のリンクからご覧いただけます。</target>
        </trans-unit>
        <trans-unit id="b8f9a78d78001336ae3c83f2d488f8880d463909" translate="yes" xml:space="preserve">
          <source>Actually, if you're using AngularJS, you don't need jQuery anymore. AngularJS itself has the binding and directive, which is a very good &quot;replacement&quot; for most things you can do with jQuery.</source>
          <target state="translated">実はAngularJSを使っているのであれば、もうjQueryは必要ありません。AngularJS自体がバインディングとディレクティブを持っているので、jQueryでできることのほとんどを「代用」することができます。</target>
        </trans-unit>
        <trans-unit id="a982e94ed93b338e6087c54069f224404ee9152d" translate="yes" xml:space="preserve">
          <source>Again, AngularJS does not play by their rules. In a stroke, &lt;strong&gt;AngularJS does away with a decade of received wisdom&lt;/strong&gt; and instead implements an MVC pattern in which the template is no longer semantic, not even a little bit.</source>
          <target state="translated">繰り返しになりますが、AngularJSは彼らのルールに従っていません。 &lt;strong&gt;AngularJSは&lt;/strong&gt;一気に&lt;strong&gt;10年の知恵&lt;/strong&gt;を&lt;strong&gt;捨て&lt;/strong&gt; 、代わりにテンプレートがセマンティックではなく、少しでもないMVCパターンを実装します。</target>
        </trans-unit>
        <trans-unit id="dd4ee4af98c6fe65fb4b3c2b533d9c832398158d" translate="yes" xml:space="preserve">
          <source>Again, the template stuff is in the template, so you (or your users) can easily swap it out for one that meets any style necessary, and the &lt;strong&gt;logic&lt;/strong&gt; never had to be touched. Reusability - boom!</source>
          <target state="translated">繰り返しになりますが、テンプレートの要素はテンプレートに含まれているので、あなた（またはユーザー）は、必要なスタイルを満たす&lt;strong&gt;ロジックに&lt;/strong&gt;簡単に入れ替えることができ、 &lt;strong&gt;ロジックに手を加える&lt;/strong&gt;必要がありませんでした。 再利用性-ブーム！</target>
        </trans-unit>
        <trans-unit id="1480b134e7c98fe4782ceaa71c1becda85bf1d42" translate="yes" xml:space="preserve">
          <source>Ajax all of the time</source>
          <target state="translated">いつものAjax</target>
        </trans-unit>
        <trans-unit id="7088908d0701fd67fecee7fd934804b9635f1eac" translate="yes" xml:space="preserve">
          <source>And I decided to make a tiny code snippet that help me quickly start a website using AngularJS with the power of jQuery Selector (using Sizzle).</source>
          <target state="translated">そして、私はjQuery Selector(Sizzleを使用)の力でAngularJSを使用したウェブサイトをすぐに立ち上げるのに役立つ小さなコードスニペットを作ることにしました。</target>
        </trans-unit>
        <trans-unit id="b3c9932d142f6e1ee02747f1578184f1f2f6fc13" translate="yes" xml:space="preserve">
          <source>And all of the above tie into this over-arching theme: keep your concerns separate. Your view acts as the official record of what is supposed to happen (for the most part); your model represents your data; you have a service layer to perform reusable tasks; you do DOM manipulation and augment your view with directives; and you glue it all together with controllers. This was also mentioned in other answers, and the only thing I would add pertains to testability, which I discuss in another section below.</source>
          <target state="translated">そして、上記のすべてのことは、この包括的なテーマに結びついています。ビューは(ほとんどの場合)何が起こるかの公式な記録として機能し、モデルはデータを表現し、再利用可能なタスクを実行するためのサービスレイヤーがあり、DOM 操作を行い、ディレクティブでビューを拡張し、コントローラですべてを接着します。これは他の回答でも言及されていますが、私が追加する唯一のことはテスト可能性に関するもので、以下の別のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="717ce7322f7d359fabb874116d82f9a23af3a1cf" translate="yes" xml:space="preserve">
          <source>And fifth, which we've mentioned in previous sections, why are we mixing template stuff into our logic?</source>
          <target state="translated">そして5つ目は、前のセクションでも触れましたが、なぜロジックにテンプレートを混ぜるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="31b7375227eaf487f50dd9c4d2a4be13432b0992" translate="yes" xml:space="preserve">
          <source>And now instead of using an unordered list, we're using Bootstrap alert boxes. And we never had to change the controller code! But more importantly, no matter &lt;em&gt;where&lt;/em&gt; or &lt;em&gt;how&lt;/em&gt; the log gets updated, the view will change too. Automatically. Neat!</source>
          <target state="translated">そして今、順序付けられていないリストを使用する代わりに、Bootstrapアラートボックスを使用しています。 そして、コントローラーのコードを変更する必要はありませんでした！ しかし、より重要なのは、ログが&lt;em&gt;どこでどのよう&lt;/em&gt;に更新される&lt;em&gt;かに&lt;/em&gt;関係なく、ビューも変更されることです。 自動的に。 きちんと！</target>
        </trans-unit>
        <trans-unit id="ded1b56b02466779ad820433f366b36a1ad7629b" translate="yes" xml:space="preserve">
          <source>And our view can look like this:</source>
          <target state="translated">そして、私たちの景色はこんな感じになります。</target>
        </trans-unit>
        <trans-unit id="e0dec1075f573c8803a10203b7685e0ba502d0e0" translate="yes" xml:space="preserve">
          <source>And there are still all those other benefits, like testing - it's easy! No matter what's in the template, the directive's internal API is never touched, so refactoring is easy. You can change the template as much as you want without touching the directive. And no matter what you change, your tests still pass.</source>
          <target state="translated">他にもテストのような利点があります-簡単です! テンプレートに何が入っていても、ディレクティブの内部 API には一切触れないので、リファクタリングも簡単です。ディレクティブには触れずにテンプレートを好きなだけ変更できます。そして、何を変更してもテストは通過します。</target>
        </trans-unit>
        <trans-unit id="5bee056b415ffd9808306a38b2d56440081c0e20" translate="yes" xml:space="preserve">
          <source>And when we run our test, we can confirm that it fails. Only now should we create our directive:</source>
          <target state="translated">そして、テストを実行すると失敗することが確認できます。あとはディレクティブを作成するだけです。</target>
        </trans-unit>
        <trans-unit id="180abb5e88521e466bf2e4475cd2b687c06483d9" translate="yes" xml:space="preserve">
          <source>And with DOM manipulation in AngularJS, you find yourself adding directives and filters, which you can think of as valid HTML extensions.</source>
          <target state="translated">AngularJSでDOMを操作すると、ディレクティブやフィルターを追加していることに気づくでしょう。</target>
        </trans-unit>
        <trans-unit id="24580187a4254fa76812f2d649f1e29d6069e0b9" translate="yes" xml:space="preserve">
          <source>Angular and jQuery do different things. AngularJS gives you a set of tools to produce web applications. jQuery mainly gives you tools for modifying the DOM. If jQuery is present on your page, AngularJS will use it automatically. If it isn't, AngularJS ships with jQuery Lite, which is a cut down, but still perfectly usable version of jQuery.</source>
          <target state="translated">AngularとjQueryは異なることをしています。AngularJSはWebアプリケーションを制作するためのツール群を提供してくれますが、jQueryは主にDOMを修正するためのツールを提供してくれます。jQueryがページ上に存在する場合、AngularJSは自動的にそれを使用します。jQueryが存在しない場合、AngularJSにはjQuery Liteが同梱されています。これはjQueryの縮小版ですが、完全に使えるバージョンです。</target>
        </trans-unit>
        <trans-unit id="743831e45593d1d3b1984a6b44f8c8b5aff24099" translate="yes" xml:space="preserve">
          <source>Angular breaks down your app into 
- Controllers
- Services
- Views
- etc.</source>
          <target state="translated">Angularはアプリを次のように分解します-コントローラ-サービス-ビュー-など。</target>
        </trans-unit>
        <trans-unit id="2a3de4a9dc7c9f3bd23b0b53226033777b1c013b" translate="yes" xml:space="preserve">
          <source>AngularJS</source>
          <target state="translated">AngularJS</target>
        </trans-unit>
        <trans-unit id="f39ebda33fdd6cea30fb3e03a8a2d79fcda3487a" translate="yes" xml:space="preserve">
          <source>AngularJS allows you to make your own HTML tags/attributes that do things which work well with dynamic web applications (since HTML was designed for static pages).</source>
          <target state="translated">AngularJSを使うと、動的なWebアプリケーションに適した機能を持つ独自のHTMLタグ属性を作ることができます(HTMLは静的なページのために設計されているので)。</target>
        </trans-unit>
        <trans-unit id="83ef7970ea8e67c4542f275b5fdabad15e691725" translate="yes" xml:space="preserve">
          <source>AngularJS and jQuery adopt very different ideologies. If you're coming from jQuery you may find some of the differences surprising. Angular may make you angry.</source>
          <target state="translated">AngularJSとjQueryは全く異なるイデオロギーを採用しています。jQueryから来た人は、いくつかの違いに驚くかもしれません。Angularはあなたを怒らせるかもしれません。</target>
        </trans-unit>
        <trans-unit id="fc13641dffc4ac29f5a7e6fba2f371197f917be0" translate="yes" xml:space="preserve">
          <source>AngularJS and jQuery are not enemies. It's possible to use jQuery within AngularJS very nicely. If you're using AngularJS well (templates, data-binding, $scope, directives, etc.) you will find you need a &lt;strong&gt;lot&lt;/strong&gt; less jQuery than you might otherwise require.</source>
          <target state="translated">AngularJSとjQueryは敵ではありません。 AngularJS内でjQueryを非常にうまく使用できます。 AngularJSを上手に使用している場合（テンプレート、データバインディング、$ scope、ディレクティブなど）、必要なjQueryよりも&lt;strong&gt;はるかに&lt;/strong&gt;少ないjQueryで済みます。</target>
        </trans-unit>
        <trans-unit id="222ef2db3e23de37ca20387e96e35891b58e48cd" translate="yes" xml:space="preserve">
          <source>AngularJS changes the way you &lt;em&gt;find&lt;/em&gt; elements</source>
          <target state="translated">AngularJS &lt;em&gt;は&lt;/em&gt;要素の&lt;em&gt;検索&lt;/em&gt;方法を変更します</target>
        </trans-unit>
        <trans-unit id="e1c2157022eaa4f2a0716583841f5203e08b070a" translate="yes" xml:space="preserve">
          <source>AngularJS comes with an entire set of tools to make this very easy; with &lt;code&gt;ngClass&lt;/code&gt; we can dynamically update the class; &lt;code&gt;ngModel&lt;/code&gt; allows two-way data binding; &lt;code&gt;ngShow&lt;/code&gt; and &lt;code&gt;ngHide&lt;/code&gt; programmatically show or hide an element; and many more - including the ones we write ourselves. In other words, we can do all kinds of awesomeness &lt;em&gt;without&lt;/em&gt; DOM manipulation. The less DOM manipulation, the easier directives are to test, the easier they are to style, the easier they are to change in the future, and the more re-usable and distributable they are.</source>
          <target state="translated">AngularJSには、これを非常に簡単にするためのツールセット全体が付属しています。 &lt;code&gt;ngClass&lt;/code&gt; を使用すると、クラスを動的に更新できます。 &lt;code&gt;ngModel&lt;/code&gt; は双方向のデータバインディングを可能にします。 &lt;code&gt;ngShow&lt;/code&gt; および &lt;code&gt;ngHide&lt;/code&gt; は、プログラムで要素を表示または非表示にします。 その他多数-自分で書いたものを含みます。 つまり、DOMを操作し&lt;em&gt;なくて&lt;/em&gt;も、あらゆる種類の素晴らしいことができるのです。 DOM操作が少ないほど、ディレクティブのテストが容易になり、スタイルの設定が容易になり、将来の変更が容易になり、再利用と配布が容易になります。</target>
        </trans-unit>
        <trans-unit id="8a1f9a965073fef341c41540c540b536642219de" translate="yes" xml:space="preserve">
          <source>AngularJS doesn't need (or want) you to find elements using selectors - the primary difference between AngularJS's &lt;strong&gt;jqLite&lt;/strong&gt; versus full-blown &lt;strong&gt;jQuery&lt;/strong&gt; is that &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.element&quot;&gt;jqLite does not support selectors&lt;/a&gt;.</source>
          <target state="translated">AngularJSでは、セレクターを使用して要素を検索する必要はありません（または必要ありません） &lt;strong&gt;。AngularJS&lt;/strong&gt;の&lt;strong&gt;jqLit​​e&lt;/strong&gt;と本格的な&lt;strong&gt;jQuery&lt;/strong&gt;の主な違いは、 &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.element&quot;&gt;jqLit​​eがセレクターをサポートしていないこと&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d472a45e93868af2bd80d2ee2bab7981ad1a855e" translate="yes" xml:space="preserve">
          <source>AngularJS extends HTML, so you don't have to put &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; all over the place just to make an application. It makes HTML actually work for applications rather than what it was designed for, which is static, educational web pages. It accomplishes this in a roundabout way using JavaScript, but fundamentally it is an extension of HTML, not JavaScript.</source>
          <target state="translated">AngularJSはHTMLを拡張するため、アプリケーションを作成するためだけに &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; をすべて配置する必要はありません。 HTMLは、静的で教育的なWebページである目的のために設計されたものではなく、実際にアプリケーションで機能します。 JavaScriptを使用してこれを遠回りで実現しますが、基本的にはJavaScriptではなくHTMLの拡張です。</target>
        </trans-unit>
        <trans-unit id="a790802605b2871a0ef2e9ba795618736b158088" translate="yes" xml:space="preserve">
          <source>AngularJS gives us service objects.</source>
          <target state="translated">AngularJSはサービスオブジェクトを提供してくれます。</target>
        </trans-unit>
        <trans-unit id="580b72b69de2dbaa91260842ab501683adc90363" translate="yes" xml:space="preserve">
          <source>AngularJS gives you modules into which you can place your code. If you're writing a script that talks to Flickr for example, you might want to create a Flickr module to wrap all your Flickr related functions in. Modules can include other modules (DI). Your main application is usually a module, and this should include all the other modules your application will depend on.</source>
          <target state="translated">AngularJSはコードを配置できるモジュールを提供してくれます。例えばFlickrと対話するスクリプトを書いているのであれば、Flickr関連の関数をすべてラップするFlickrモジュールを作成したいと思うかもしれません。モジュールには、他のモジュール(DI)を含めることができます。あなたのメインアプリケーションは通常モジュールであり、これはあなたのアプリケーションが依存する他のすべてのモジュールを含むべきです。</target>
        </trans-unit>
        <trans-unit id="f5dbd7fd768f26aa68cfb19bda9fe60441f2e19f" translate="yes" xml:space="preserve">
          <source>AngularJS has $scope objects. These are special objects created and maintained by AngularJS in which you store your model. Certain directives will spawn a new $scope, which by default inherits from its wrapping $scope using JavaScript prototypical inheritance. The $scope object is accessible in the controller and the view.</source>
          <target state="translated">AngularJSには$scopeオブジェクトがあります。これらはAngularJSによって作成され、維持される特別なオブジェクトで、モデルを保存します。特定のディレクティブによって新しい$scopeが生成され、デフォルトではJavaScriptのプロトタイピング継承を使ってラッピングされた$scopeを継承します。この$scopeオブジェクトはコントローラとビューでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="3347e5a5c11ca76b8bae02225f867635154e1d18" translate="yes" xml:space="preserve">
          <source>AngularJS has the concept of &quot;Directives&quot; for DOM manipulation and designing reusable UI components, so you should use it whenever you feel the need of doing DOM manipulation related stuff (directives are only place where you should write jQuery code while using AngularJS).</source>
          <target state="translated">AngularJSにはDOM操作や再利用可能なUIコンポーネントの設計のための「ディレクティブ」という概念があるので、DOM操作関連のことをしたいと思ったときにはこれを使うといいでしょう(ディレクティブはAngularJSを使いながらjQueryのコードを書くべき場所にしかなりません)。</target>
        </trans-unit>
        <trans-unit id="abb7d137ad0c0d41f229faf7978453fac70efa79" translate="yes" xml:space="preserve">
          <source>AngularJS instead gives you a &lt;strong&gt;compiler&lt;/strong&gt;.</source>
          <target state="translated">AngularJSは代わりに&lt;strong&gt;コンパイラ&lt;/strong&gt;を提供します。</target>
        </trans-unit>
        <trans-unit id="f454c455626fe5cac16b1e78b3064e9efba3a1f4" translate="yes" xml:space="preserve">
          <source>AngularJS involves some learning curve (more than jQuery :-).</source>
          <target state="translated">AngularJSは多少の学習曲線を伴います(jQuery以上に)。</target>
        </trans-unit>
        <trans-unit id="0f33f894c7aeb275ff7e26043faaaba6c9273c31" translate="yes" xml:space="preserve">
          <source>AngularJS is an MV* framework.</source>
          <target state="translated">AngularJSはMV*フレームワークです。</target>
        </trans-unit>
        <trans-unit id="496acda8671b0ee67088cb637f1c89eb97cd852d" translate="yes" xml:space="preserve">
          <source>AngularJS is an entire client-side framework that uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; pattern (check out their &lt;a href=&quot;http://docs.angularjs.org/guide/concepts&quot;&gt;graphical representation&lt;/a&gt;). It greatly focuses on separation of concerns.</source>
          <target state="translated">AngularJSは、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt;パターンを使用する完全なクライアント側フレームワークです（ &lt;a href=&quot;http://docs.angularjs.org/guide/concepts&quot;&gt;グラフィック表現を&lt;/a&gt;確認してください）。 関心事の分離に大きく焦点を当てています。</target>
        </trans-unit>
        <trans-unit id="ccc498700b07180690b810f63f70291230b83439" translate="yes" xml:space="preserve">
          <source>AngularJS itself includes a jQuery-lite edition within it. So for some basic DOM selection/manipulation, you really don't have to include the jQuery library (it saves many bytes to run on the network.)</source>
          <target state="translated">AngularJS自体にはjQuery-lite版が含まれています。そのため、いくつかの基本的なDOMの選択操作のためには、本当にjQueryライブラリをインクルードする必要はありません(ネットワーク上で実行するために多くのバイトを節約することができます)。</target>
        </trans-unit>
        <trans-unit id="f8eb1469e26f56c8a74bfdb88d4142545826f06f" translate="yes" xml:space="preserve">
          <source>AngularJS manages your dependencies for you. If you want an object, simply refer to it and AngularJS will get it for you.</source>
          <target state="translated">AngularJSは依存関係を管理してくれます。オブジェクトが欲しい場合は、それを参照するだけでAngularJSが取得してくれます。</target>
        </trans-unit>
        <trans-unit id="38dffc5e5dca986ffefa44052bb0ef43d021e403" translate="yes" xml:space="preserve">
          <source>AngularJS uses &lt;strong&gt;controllers&lt;/strong&gt; and directives (each of which can have their own controller, and/or compile and linking functions) to remove behavior from the view/structure (HTML).  Angular also has &lt;strong&gt;services&lt;/strong&gt; and &lt;strong&gt;filters&lt;/strong&gt; to help separate/organize your application.</source>
          <target state="translated">AngularJSは、 &lt;strong&gt;コントローラー&lt;/strong&gt;とディレクティブ（それぞれに独自のコントローラー、および/またはコンパイルとリンク関数を含めることができます）を使用して、ビュー/構造（HTML）から動作を削除します。 Angularには、アプリケーションの分離/整理に役立つ&lt;strong&gt;サービス&lt;/strong&gt;と&lt;strong&gt;フィルター&lt;/strong&gt;もあり&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="427ca6be55cbd36d29b597716cd026cabed3d117" translate="yes" xml:space="preserve">
          <source>AngularJS vs. jQuery</source>
          <target state="translated">AngularJS vs.jQuery</target>
        </trans-unit>
        <trans-unit id="209303f007b14469938fa3242370f0eed9fe6b7f" translate="yes" xml:space="preserve">
          <source>AngularJS will recognise that a FlickrService object is needed to instantiate the controller, and will provide one for us.</source>
          <target state="translated">AngularJSはコントローラをインスタンス化するためにFlickrServiceオブジェクトが必要であることを認識し、それを提供してくれます。</target>
        </trans-unit>
        <trans-unit id="89fd96e13c335779cf18929ce0e49db544e7b95a" translate="yes" xml:space="preserve">
          <source>AngularJS: THE model is the truth, and you always think from that ANGLE.</source>
          <target state="translated">AngularJS:THEモデルが真実であり、常にそのANGLEから考える。</target>
        </trans-unit>
        <trans-unit id="3bef657357e40dc720fc2a1d5a9a5e5e4d968b2d" translate="yes" xml:space="preserve">
          <source>AngularJs Cool Principle - If you want some changes on your UI think from model data change perspective. Change your data and UI will re-render itself. You need not to play around DOM each time unless and until it is hardly required and that should also be handled through Angular Directives.</source>
          <target state="translated">AngularJsのクールな原則-UIを変更したい場合は、モデルデータの変更の観点から考えよう。データを変更すれば、UIは再レンダリングされる。余程のことがない限り、毎回DOMを弄る必要はないし、それもAngular Directivesで処理すべきだ。</target>
        </trans-unit>
        <trans-unit id="4c7fa873dad04f6b1ea51f0bb4c021ea8dae7e48" translate="yes" xml:space="preserve">
          <source>AngularJs and JQuery are completely different at every level except the JQLite functionality and you will see it once you start learning the AngularJs core features (I explained it below).</source>
          <target state="translated">AngularJsとJQueryはJQLiteの機能以外は全てのレベルで全く違うもので、AngularJsのコア機能を学び始めるとわかると思います(以下で説明しました)。</target>
        </trans-unit>
        <trans-unit id="3edbcd2b0fe8f2eeb3060452cd16d0c33d77cc16" translate="yes" xml:space="preserve">
          <source>AngularJs is a client side framework that offers to build the independent client side application. JQuery is a client side library that play around the DOM.</source>
          <target state="translated">AngularJsは独立したクライアントサイドアプリケーションを構築するためのクライアントサイドフレームワークです。JQueryはDOMを利用したクライアントサイドのライブラリです。</target>
        </trans-unit>
        <trans-unit id="5239585f0407322b9de9420fc353533aa0b142a9" translate="yes" xml:space="preserve">
          <source>Apart from mixing concerns, we also have the same problems of signifying intent that I mentioned before. But more importantly, we had to manually reference and update a DOM node. And if we want to delete a log entry, we have to code against the DOM for that too. How do we test the logic apart from the DOM? And what if we want to change the presentation?</source>
          <target state="translated">混合の懸念とは別に、先に述べたインテントのシグニフィケーションの問題もあります。しかし、もっと重要なのは、DOM ノードを手動で参照して更新しなければならないということです。また、ログエントリを削除したい場合は、そのために DOM に対してコードを記述しなければなりません。DOM とは別にロジックをテストするにはどうすればいいのでしょうか?また、プレゼンテーションを変更したい場合はどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="4887e453b680689b4f5edbe3a009b399e0a9cd5f" translate="yes" xml:space="preserve">
          <source>Application design</source>
          <target state="translated">アプリケーション設計</target>
        </trans-unit>
        <trans-unit id="390be301a8114b068b77d68bc38caf2bb1d0d455" translate="yes" xml:space="preserve">
          <source>Are there any server-side considerations/restrictions?</source>
          <target state="translated">サーバー側の配慮で制限はありますか?</target>
        </trans-unit>
        <trans-unit id="664c60d57cb407ffa5cf65a1d3cbd40930f03f80" translate="yes" xml:space="preserve">
          <source>As a JavaScript MV* beginner and purely focusing on the application architecture (not the server/client-side matters), I would certainly recommend the following resource (which I am surprised wasn't mentioned yet): &lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;JavaScript Design Patterns&lt;/a&gt;, by Addy Osmani, as an introduction to different &lt;strong&gt;JavaScript Design Patterns&lt;/strong&gt;. The terms used in this answer are taken from the linked document above. I'm not going to repeat what was worded really well in the accepted answer. Instead, this answer links back to the &lt;strong&gt;theoretical backgrounds&lt;/strong&gt; which power AngularJS (and other libraries).</source>
          <target state="translated">JavaScript MV *の初心者であり、純粋にアプリケーションアーキテクチャ（サーバー/クライアント側の問題ではない）に焦点を当てているので、次のリソースをお勧めします（まだ驚かされていませんが）。JavaScript &lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;デザインパターン&lt;/a&gt; 、Addy Osmani著、さまざまな&lt;strong&gt;JavaScriptデザインパターンの&lt;/strong&gt;紹介として。 この回答で使用される用語は、上記のリンクされたドキュメントから取得されます。 私は、受け入れられた答えで本当によく言われたことを繰り返すつもりはありません。 代わりに、この回答は、AngularJS（およびその他のライブラリ）を強化する&lt;strong&gt;理論的な背景に&lt;/strong&gt;リンクしています。</target>
        </trans-unit>
        <trans-unit id="23a7327c34c86abe93b30fb5462eaf583c740d8f" translate="yes" xml:space="preserve">
          <source>At this point you likely have all sorts of questions concerning &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt; and accessibility, and rightly so. There are open issues here. Most screen readers will now parse JavaScript. Search engines can also index &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;AJAXed&lt;/a&gt; content. Nevertheless, you will want to make sure you are using pushstate URLs and you have a decent sitemap. See here for a discussion of the issue: &lt;a href=&quot;https://stackoverflow.com/a/23245379/687677&quot;&gt;https://stackoverflow.com/a/23245379/687677&lt;/a&gt;</source>
          <target state="translated">この時点で、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt;とアクセシビリティに関してあらゆる種類の質問がありそうです。 ここには未解決の問題があります。 ほとんどのスクリーンリーダーがJavaScriptを解析するようになります。 検索エンジンは、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;AJAX処理された&lt;/a&gt;コンテンツをインデックスに登録することもできます。 それでも、pushstate URLを使用していて、適切なサイトマップがあることを確認する必要があります。 この問題の説明については、こちらを&lt;a href=&quot;https://stackoverflow.com/a/23245379/687677&quot;&gt;ご覧ください&lt;/a&gt; ： https : //stackoverflow.com/a/23245379/687677</target>
        </trans-unit>
        <trans-unit id="e64cce4dacf87903542cb264297ae0a879e80ca7" translate="yes" xml:space="preserve">
          <source>Attach a controller to each view (using ng-view and routing, or ng-controller). Have the controller find/get only whatever model data the view needs to do its job. Make controllers as thin as possible.</source>
          <target state="translated">各ビューにコントローラをアタッチします(ng-view and routing、またはng-controllerを使用)。コントローラには、ビューが仕事をするのに必要なモデルデータのみをfindgetさせます。コントローラはできるだけ薄くします。</target>
        </trans-unit>
        <trans-unit id="4988689ec96d69654ac1b4d26595c58327121e0c" translate="yes" xml:space="preserve">
          <source>Because AngularJS treats your HTML page as a template. The template is not supposed to be semantic as your content is typically stored in your model which ultimately comes from your API. AngularJS compiles your DOM with the model to produce a semantic web page.</source>
          <target state="translated">AngularJSはHTMLページをテンプレートとして扱うからです。コンテンツは通常、最終的にはAPIから来るモデルに格納されるので、テンプレートはセマンティックなものではないはずです。AngularJSはDOMをモデルとコンパイルしてセマンティックなウェブページを生成します。</target>
        </trans-unit>
        <trans-unit id="52ff735af719db7308ce1da781ad856d29790080" translate="yes" xml:space="preserve">
          <source>Because data binding is done from the template, using either an attribute or the curly brace syntax, it's super easy to do. There's little cognitive overhead associated with it so you'll find yourself doing it all the time.</source>
          <target state="translated">データバインディングはテンプレートから属性または中括弧構文のいずれかを使用して行われるため、非常に簡単に行うことができます。これに関連した認知的なオーバーヘッドはほとんどないので、いつもやっていることに気づくでしょう。</target>
        </trans-unit>
        <trans-unit id="da1f91ccd2cdc9e39f69ad5bd7c07fde87791168" translate="yes" xml:space="preserve">
          <source>Being a framework, it hosts your code and takes ownership of decisions about what to call and when!</source>
          <target state="translated">フレームワークであるため、コードをホストし、何をいつ、何を呼び出すかを決定するオーナーシップを取ります!</target>
        </trans-unit>
        <trans-unit id="1ede8f40530371ca2072fafa529a4af2b37e9ba1" translate="yes" xml:space="preserve">
          <source>Binds the input element to &lt;code&gt;$scope.user.name&lt;/code&gt;. Updating the input will update the value in your current scope, and vice-versa.</source>
          <target state="translated">入力要素を &lt;code&gt;$scope.user.name&lt;/code&gt; バインドします。 入力を更新すると現在のスコープの値が更新され、逆も同様です。</target>
        </trans-unit>
        <trans-unit id="723820bab62fc4cc602aaa7c4690e3b306e0a88e" translate="yes" xml:space="preserve">
          <source>But because we have separation of concerns, we can do test-driven development iteratively in AngularJS! For example, let's say we want a super-simple directive to indicate in our menu what our current route is. We can declare what we want in the view of our application:</source>
          <target state="translated">しかし、懸念事項が分離されているので、AngularJSでテスト駆動開発を反復的に行うことができます。例えば、現在のルートをメニューに表示するための超シンプルなディレクティブが欲しいとしましょう。アプリケーションのビューで欲しいものを宣言することができます。</target>
        </trans-unit>
        <trans-unit id="ce753a2c6da077456572ab747e44d38ca49b9bd8" translate="yes" xml:space="preserve">
          <source>But for that matter, our view could look like this:</source>
          <target state="translated">しかし、そのためには、私たちの見解は次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="05e4f17ec22790979e0e74231b4a9712ba108795" translate="yes" xml:space="preserve">
          <source>But in AngularJS, you must start from the ground up with your architecture in mind. Instead of starting by thinking &quot;I have this piece of the DOM and I want to make it do X&quot;, you have to start with what you want to accomplish, then go about designing your application, and then finally go about designing your view.</source>
          <target state="translated">しかしAngularJSでは、アーキテクチャを念頭に置いて一から始めなければなりません。DOMのこの部分を持っていて、それをXにしたい」と考えることから始めるのではなく、何を達成したいのかから始め、アプリケーションを設計し、最後にビューを設計しなければなりません。</target>
        </trans-unit>
        <trans-unit id="706cdc463699e1ed474fcbc74dc48ab1f144a5d9" translate="yes" xml:space="preserve">
          <source>But let's dive a little deeper...</source>
          <target state="translated">でも、もう少し深く潜ってみましょう...。</target>
        </trans-unit>
        <trans-unit id="d00b45211d6f5e02dbf9930e954ca044f2728901" translate="yes" xml:space="preserve">
          <source>By googling, I see that there is a standalone jQuery selector module out there. It's Sizzle.</source>
          <target state="translated">ググってみると、スタンドアロンのjQueryセレクターモジュールが出ている。それはSizzle。</target>
        </trans-unit>
        <trans-unit id="75ed687c979f0bd97e2a3c3bf1ba2c8068f3c723" translate="yes" xml:space="preserve">
          <source>CSS - Styling, without the CSS the page is still readable.</source>
          <target state="translated">CSS-スタイリング、CSSなしでもページは読みやすくなっています。</target>
        </trans-unit>
        <trans-unit id="5fbb684c9310c39e4a515fe80a2bcaad03a97701" translate="yes" xml:space="preserve">
          <source>Can you describe the paradigm shift that is necessary?</source>
          <target state="translated">必要なパラダイムシフトを説明できますか?</target>
        </trans-unit>
        <trans-unit id="fc22be49056528fdaa6e3e976f7e5c0875c0ea23" translate="yes" xml:space="preserve">
          <source>Closure vs. $scope</source>
          <target state="translated">クロージャー対$スコープ</target>
        </trans-unit>
        <trans-unit id="35313dc9f2a46f49b61938e95da8ca20b23eaa38" translate="yes" xml:space="preserve">
          <source>Controller - Your controller is a JavaScript function which hooks the view to the model. Its function is to initialise $scope. Depending on your application, you may or may not need to create a controller. You can have many controllers on a page.</source>
          <target state="translated">コントローラ-コントローラは、ビューをモデルにフックするJavaScriptの関数です。その関数は $scope を初期化します。アプリケーションによっては、コントローラを作成する必要がある場合とそうでない場合があります。ページ上にたくさんのコントローラを作成することができます。</target>
        </trans-unit>
        <trans-unit id="38e5b6c1d5bdd30cd076016ffcf63fb6a6fe8ba7" translate="yes" xml:space="preserve">
          <source>Controllers and providers (services, factories, etc.) are for modifying the data model, NOT HTML.</source>
          <target state="translated">コントローラやプロバイダ(サービスや工場など)は、データモデルを修正するためのものであり、HTMLではありません。</target>
        </trans-unit>
        <trans-unit id="8190947945a5d101ce34179f8d52d23951e48521" translate="yes" xml:space="preserve">
          <source>DI means that instead of writing your application and wiring it together, you instead define a library of components, each identified by a string.</source>
          <target state="translated">DIとは、アプリケーションを書いて配線するのではなく、文字列で識別されるコンポーネントのライブラリを定義することを意味します。</target>
        </trans-unit>
        <trans-unit id="d38cca5da9c7df446a12182ab09218cd420e4017" translate="yes" xml:space="preserve">
          <source>Data binding</source>
          <target state="translated">データバインディング</target>
        </trans-unit>
        <trans-unit id="abe361ec5ac92ab2b51436412eccfc4c617ee10a" translate="yes" xml:space="preserve">
          <source>Dependency injection</source>
          <target state="translated">依存性の注入</target>
        </trans-unit>
        <trans-unit id="b4834f95740149caa4ab7c7998c3085a73d25833" translate="yes" xml:space="preserve">
          <source>Developers new to AngularJS often ask a question like: how do I find all links of a specific kind and add a directive onto them. The developer is always flabbergasted when we reply: you don't. But the reason you don't do that is that this is like half-jQuery, half-AngularJS, and no good. The problem here is that the developer is trying to &quot;do jQuery&quot; in the context of AngularJS. That's never going to work well. The view &lt;em&gt;is&lt;/em&gt; the official record. Outside of a directive (more on this below), you never, ever, &lt;em&gt;never&lt;/em&gt; change the DOM. And directives are applied &lt;em&gt;in the view&lt;/em&gt;, so intent is clear.</source>
          <target state="translated">AngularJSを初めて使用する開発者は、次のような質問をよくします。特定の種類のすべてのリンクを見つけて、そこにディレクティブを追加するにはどうすればよいですか。 私たちが返信するとき、開発者は常に驚かされます。あなたはそうではありません。 しかし、これを行わない理由は、これがjQueryの半分、AngularJSの半分のようなものであり、効果がないためです。 ここでの問題は、開発者がAngularJSのコンテキストで「jQueryを実行」しようとしていることです。 それはうまくいきません。 ビュー&lt;em&gt;は&lt;/em&gt;公式記録です。 ディレクティブの外では（以下で詳しく説明します）、DOMを変更する&lt;em&gt;ことは決してありません&lt;/em&gt; 。 また、ディレクティブは&lt;em&gt;ビュー&lt;/em&gt;に適用されるため、意図は明確です。</target>
        </trans-unit>
        <trans-unit id="53d7a9d92573e089ff93413770ae30c25ee69d14" translate="yes" xml:space="preserve">
          <source>Directives can then in turn pull in additional Angular components such as controllers, services, etc. What comes out the bottom of the compiler is a fully formed web application, wired up and ready to go.</source>
          <target state="translated">ディレクティブはコントローラやサービスなどの追加のAngularコンポーネントを引き込むことができます。コンパイラの底から出てくるのは、完全に形成されたウェブアプリケーションで、配線が完了してすぐに使えるようになっています。</target>
        </trans-unit>
        <trans-unit id="6e07f7c559632d31618e542f4fc425e25f0611c0" translate="yes" xml:space="preserve">
          <source>Distinct model layer</source>
          <target state="translated">識別モデル層</target>
        </trans-unit>
        <trans-unit id="7d3e17491190e7a5dea94490347df028a3f9aa5e" translate="yes" xml:space="preserve">
          <source>Doing so will allow you to leverage their &lt;a href=&quot;http://docs.angularjs.org/api/ngResource.$resource&quot;&gt;resource factory&lt;/a&gt;, which creates an abstraction of your server side RESTful &lt;a href=&quot;http://en.wikipedia.org/wiki/Application_programming_interface&quot;&gt;API&lt;/a&gt; and makes server-side calls (get, save, delete, etc.) incredibly easy.</source>
          <target state="translated">そうすることで、 &lt;a href=&quot;http://docs.angularjs.org/api/ngResource.$resource&quot;&gt;リソースファクトリ&lt;/a&gt;を活用できるようになります。これにより、サーバー側のRESTful &lt;a href=&quot;http://en.wikipedia.org/wiki/Application_programming_interface&quot;&gt;APIの&lt;/a&gt;抽象化が作成され、サーバー側の呼び出し（取得、保存、削除など）が非常に簡単になります。</target>
        </trans-unit>
        <trans-unit id="9fac905701ef3b0097c8764804ad3e59dbd915f9" translate="yes" xml:space="preserve">
          <source>Don't even use jQuery. Don't even include it. It will hold you back. And when you come to a problem that you think you know how to solve in jQuery already, before you reach for the &lt;code&gt;$&lt;/code&gt;, try to think about how to do it within the confines the AngularJS. If you don't know, ask! 19 times out of 20, the best way to do it doesn't need jQuery and to try to solve it with jQuery results in more work for you.</source>
          <target state="translated">jQueryを使用しないでください。 それも含めないでください。 それはあなたを引き留めます。 そして、jQueryで解決する方法をすでに知っていると思う問題に遭遇したときは、 &lt;code&gt;$&lt;/code&gt; に到達する前に、AngularJSの範囲内でそれを行う方法について考えてみてください。 わからない場合は質問してください。 20回のうち19回は、jQueryを必要とせず、jQueryの結果で解決するための最善の方法は、より多くの作業を必要とします。</target>
        </trans-unit>
        <trans-unit id="2c79c2f8fe6cef139b77391f6699a0512a187188" translate="yes" xml:space="preserve">
          <source>Edit:</source>
          <target state="translated">Edit:</target>
        </trans-unit>
        <trans-unit id="22b7ff6e8b6f6df26b8528e8d5a05b683dda1ec4" translate="yes" xml:space="preserve">
          <source>First know that &lt;a href=&quot;http://en.wikipedia.org/wiki/Single-page_application&quot;&gt;single-page applications&lt;/a&gt; are &lt;em&gt;applications&lt;/em&gt;. They're &lt;em&gt;not&lt;/em&gt; webpages. So we need to think like a server-side developer &lt;em&gt;in addition&lt;/em&gt; to thinking like a client-side developer. We have to think about how to divide our application into individual, extensible, testable components.</source>
          <target state="translated">最初に、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Single-page_application&quot;&gt;単一ページのアプリケーション&lt;/a&gt;が&lt;em&gt;アプリケーションである&lt;/em&gt;ことを知ってください 。 それらはウェブページではあり&lt;em&gt;ません&lt;/em&gt; 。 したがって、クライアント側の開発者のように考えること&lt;em&gt;に加え&lt;/em&gt;て、サーバー側の開発者のように考える必要があります。 アプリケーションを個別の拡張可能なテスト可能なコンポーネントに分割する方法について考える必要があります。</target>
        </trans-unit>
        <trans-unit id="395a4b3bfca26bc0f15e623275df885c5164cd6a" translate="yes" xml:space="preserve">
          <source>First up, Angular doesn't replace jQuery</source>
          <target state="translated">まず第一に、AngularはjQueryを置き換えるものではありません。</target>
        </trans-unit>
        <trans-unit id="2bd966a54c73aaa3f249cccf1a9fc029ccf3efc7" translate="yes" xml:space="preserve">
          <source>First, jQuery was never necessary. There's nothing we did here that needed jQuery at all!</source>
          <target state="translated">まず、jQueryが必要だったことはありません。ここでやったことの中でjQueryが必要なものは全くありませんでした。</target>
        </trans-unit>
        <trans-unit id="900191e8f993958a06b036ac65d730e1bdaa6073" translate="yes" xml:space="preserve">
          <source>For a view that looks like this:</source>
          <target state="translated">こんな感じの景色の場合</target>
        </trans-unit>
        <trans-unit id="2e2c9d3bdb321bac05780afd95a48bfce104b09e" translate="yes" xml:space="preserve">
          <source>For example, here I define a service:</source>
          <target state="translated">例えば、ここではサービスを定義します。</target>
        </trans-unit>
        <trans-unit id="de3e20808c116384b0a4b03719bffd49cb190884" translate="yes" xml:space="preserve">
          <source>For example, if you want a carousel on your page, you might define an unordered list of figures, perhaps wrapped in a nav element. You might then write some jQuery to select the list on the page and restyle it as a gallery with timeouts to do the sliding animation.</source>
          <target state="translated">例えば、ページにカルーセルを表示させたい場合は、nav要素でラップされた順序のない図形のリストを定義するとします。そして、ページ上のリストを選択して、スライド アニメーションを行うためのタイムアウト付きのギャラリーとしてスタイルを変更するために jQuery を書くことができます。</target>
        </trans-unit>
        <trans-unit id="991573402c0940207e9bacdb158be6295096e397" translate="yes" xml:space="preserve">
          <source>For example, when you get data from THE server which you intend to display in some format in the DOM, in jQuery, you need to '1. FIND' where in the DOM you want to place this data, the '2. UPDATE/APPEND' it there by creating a new node or just setting its &lt;a href=&quot;http://www.tizag.com/javascriptT/javascript-innerHTML.php&quot;&gt;innerHTML&lt;/a&gt;. Then when you want to update this view, you then '3. FIND' the location and '4. UPDATE'. This cycle of find and update all done within the same context of getting and formatting data from server is gone in AngularJS.</source>
          <target state="translated">たとえば、DOMで何らかの形式で表示する予定のサーバーからデータを取得する場合、jQueryでは '1。 DOMでこのデータを配置する場所を検索します。 新しいノードを作成するか、その&lt;a href=&quot;http://www.tizag.com/javascriptT/javascript-innerHTML.php&quot;&gt;innerHTMLを&lt;/a&gt;設定するだけで、そこに更新/追加します。 次に、このビューを更新する場合は、 '3。 場所を見つける」と「4。 更新'。 この検索と更新のサイクルはすべて、サーバーからデータを取得してフォーマットするという同じコンテキスト内で行われ、AngularJSではなくなりました。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="850a95bbb6dd76741f2f32607f4ef86792316738" translate="yes" xml:space="preserve">
          <source>Fourth, closely related to the third, is that jqLite elements needn't be wrapped in &lt;code&gt;$&lt;/code&gt; - the &lt;code&gt;element&lt;/code&gt; that is passed to the &lt;code&gt;link&lt;/code&gt; function would &lt;em&gt;already be&lt;/em&gt; a jQuery element!</source>
          <target state="translated">4つ目は、3つ目と密接に関連しており、jqLit​​e要素を &lt;code&gt;$&lt;/code&gt; でラップする必要がないことです。 &lt;code&gt;link&lt;/code&gt; 関数に渡される &lt;code&gt;element&lt;/code&gt; は、 &lt;em&gt;すでに&lt;/em&gt; jQuery要素です。</target>
        </trans-unit>
        <trans-unit id="e937a7317ee9e666605382e9345fe01e5e87523e" translate="yes" xml:space="preserve">
          <source>From a broad perspective, DI means that you can declare components very freely and then from any other component, just ask for an instance of it and it will be granted. You don't have to know about loading order, or file locations, or anything like that. The power may not immediately be visible, but I'll provide just one (common) example: testing.</source>
          <target state="translated">広い意味では、DIとは、コンポーネントを非常に自由に宣言して、他のコンポーネントから、そのインスタンスを要求するだけで、それが許可されるということです。読み込み順とか、ファイルの位置とか、そんなことを知る必要はありません。その威力はすぐにはわからないかもしれませんが、一つだけ(一般的な)例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="70376458c7e1d59978b45b6a33d1a41e52fb91db" translate="yes" xml:space="preserve">
          <source>Good luck.</source>
          <target state="translated">頑張れよ</target>
        </trans-unit>
        <trans-unit id="a27f0fe6a21c158932ddc9c6ab32b680263c7a6e" translate="yes" xml:space="preserve">
          <source>HTML - Semantic meaning. The HTML should stand alone.</source>
          <target state="translated">HTML-意味的な意味。HTMLは独立している必要があります。</target>
        </trans-unit>
        <trans-unit id="c5340e7474927e0f273d76b88c2f86f9341fb5de" translate="yes" xml:space="preserve">
          <source>HTML and directives define the layout and binding to the model.</source>
          <target state="translated">HTMLとディレクティブは、レイアウトとモデルへのバインディングを定義します。</target>
        </trans-unit>
        <trans-unit id="7602bdeaf94c8c4d20e603fafd1c75516db6e8a6" translate="yes" xml:space="preserve">
          <source>Here's a quick example that shows the pattern I see most frequently. We want a toggleable button. (Note: this example is a little contrived and a skosh verbose to represent more complicated cases that are solved in exactly the same way.)</source>
          <target state="translated">ここでは、私がよく目にするパターンを示す簡単な例を紹介します。トグル可能なボタンが欲しい。(注意:この例は、全く同じ方法で解決されるより複雑なケースを表現するために、少し工夫しています。)</target>
        </trans-unit>
        <trans-unit id="1b872c0b8b5cb91fbb546831e6921db7d5087ecd" translate="yes" xml:space="preserve">
          <source>How do I architect and design client-side web applications differently? What is the biggest difference?</source>
          <target state="translated">クライアントサイドのWebアプリケーションのアーキテクチャーと設計はどう違うのか?最大の違いは何ですか?</target>
        </trans-unit>
        <trans-unit id="9ff77b581f89f632f34713ccc81664a4f91cf1b8" translate="yes" xml:space="preserve">
          <source>How do I architect and design client-side web apps differently?</source>
          <target state="translated">クライアントサイドのWebアプリのアーキテクトとデザインの違いは?</target>
        </trans-unit>
        <trans-unit id="8456215573486aa4c8df48dde90555787930b6c5" translate="yes" xml:space="preserve">
          <source>I find this question interesting, because my first serious exposure to JavaScript programming was &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; and AngularJS. I never learned jQuery, and I guess that's a good thing, because I don't have to unlearn anything. In fact, I actively avoid jQuery solutions to my problems, and instead, solely look for an &quot;AngularJS way&quot; to solve them. So, I guess my answer to this question would essentially boil down to, &quot;think like someone who never learned jQuery&quot; and avoid any temptation to incorporate jQuery directly (obviously AngularJS uses it to some extent behind the scenes).</source>
          <target state="translated">JavaScriptプログラミングへの私の最初の真剣な暴露が&lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt;とAngularJSだったので、この質問は興味深いと思います。 私はjQueryを学習したことがありません。何も学習する必要がないので、それは良いことだと思います。 実際、私は問題に対するjQueryソリューションを積極的に避けて、代わりに単に「AngularJSの方法」で問題を解決しようとしています。 したがって、この質問に対する私の答えは基本的に「jQueryを学習したことがない人のように考える」に要約され、jQueryを直接組み込む誘惑を避けます（明らかに、AngularJSはある程度それを舞台裏で使用しています）。</target>
        </trans-unit>
        <trans-unit id="efb9e3de8580d4d388e6d1d2c1128365fcee76cb" translate="yes" xml:space="preserve">
          <source>I found it easier also, to test &lt;strong&gt;(1)&lt;/strong&gt; native JavaScript code and &lt;strong&gt;(2)&lt;/strong&gt; smaller libraries for each one of these patterns &lt;strong&gt;separately&lt;/strong&gt; before diving into one global framework. This allowed me to better understand which crucial issues a framework adresses (because you are personally faced with the problem).</source>
          <target state="translated">また、1つのグローバルフレームワークに飛び込む前に、 &lt;strong&gt;（1）&lt;/strong&gt;ネイティブJavaScriptコードと&lt;strong&gt;（2）&lt;/strong&gt;これらのパターンの&lt;strong&gt;それぞれについて個別&lt;/strong&gt;に小さなライブラリをテストする方が簡単だとわかりました。 これにより、フレームワークが対応する重要な問題をよりよく理解できました（個人的に問題に直面しているため）。</target>
        </trans-unit>
        <trans-unit id="0f5fdb791dc830db0312c3e805b978f9fee42e94" translate="yes" xml:space="preserve">
          <source>I got so excited about AngularJS, I wrote a short book on it which you're very welcome to read online &lt;a href=&quot;http://nicholasjohnson.com/angular-book/&quot;&gt;http://nicholasjohnson.com/angular-book/&lt;/a&gt;. I hope it's helpful.</source>
          <target state="translated">私はAngularJSにとても興奮しました。オンラインで&lt;a href=&quot;http://nicholasjohnson.com/angular-book/&quot;&gt;http://nicholasjohnson.com/angular-book/&lt;/a&gt;を読んでいただける、短い本を書きました。 お役に立てば幸いです。</target>
        </trans-unit>
        <trans-unit id="cff209bb9bc1c566d085c39c77af21c5738cf6e4" translate="yes" xml:space="preserve">
          <source>I heard from a meetup I attended, one of the founders of Angular said they worked really hard to separate out the DOM manipulation so do not try to include them back in.</source>
          <target state="translated">私が参加したミートアップで聞いたのですが、Angularの創設者の一人は、DOMの操作を分離するのに本当に苦労したと言っていたので、DOMの操作を元に戻そうとしないでください。</target>
        </trans-unit>
        <trans-unit id="b1cc19c6fa446f86e199536080332bbd9a86f525" translate="yes" xml:space="preserve">
          <source>I see lots of developers new to AngularJS using directives as the place to throw a bunch of jQuery. In other words, they think &quot;since I can't do DOM manipulation in the controller, I'll take that code put it in a directive&quot;. While that certainly is much better, it's often &lt;em&gt;still wrong&lt;/em&gt;.</source>
          <target state="translated">一連のjQueryをスローする場所としてディレクティブを使用するAngularJSを初めて使用する多くの開発者がいます。 言い換えれば、彼らは「コントローラーではDOM操作を実行できないので、そのコードをディレクティブに挿入する」と考えています。 それは確かにはるかに良いですが、 &lt;em&gt;それでも&lt;/em&gt;しばしば&lt;em&gt;間違ってい&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="cc523ff786c336f7206f714e0c729f9f96a4ee5f" translate="yes" xml:space="preserve">
          <source>I shared my code here: &lt;a href=&quot;https://github.com/huytd/Sizzular&quot;&gt;https://github.com/huytd/Sizzular&lt;/a&gt;</source>
          <target state="translated">私はここでコードを共有しました： &lt;a href=&quot;https://github.com/huytd/Sizzular&quot;&gt;https&lt;/a&gt; ： //github.com/huytd/Sizzular</target>
        </trans-unit>
        <trans-unit id="59b381689432e88b63f12501377e65b7661e38f1" translate="yes" xml:space="preserve">
          <source>I usually develop mobile applications using AngularJS and &lt;a href=&quot;http://en.wikipedia.org/wiki/PhoneGap&quot;&gt;Cordova&lt;/a&gt;. The ONLY thing from jQuery I needed is the Selector.</source>
          <target state="translated">私は通常、AngularJSと&lt;a href=&quot;http://en.wikipedia.org/wiki/PhoneGap&quot;&gt;Cordova&lt;/a&gt;を使用してモバイルアプリケーションを開発しています。 私が必要としたjQueryの唯一のものはセレクターです。</target>
        </trans-unit>
        <trans-unit id="68cf991557c35bd050972b963c214ad303e38353" translate="yes" xml:space="preserve">
          <source>I'm not looking for a detailed comparison between &lt;code&gt;jQuery&lt;/code&gt; and &lt;code&gt;AngularJS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jQuery&lt;/code&gt; と &lt;code&gt;AngularJS&lt;/code&gt; の詳細な比較を探しているのではありません。</target>
        </trans-unit>
        <trans-unit id="f656d296b8b07178ef6945737f0889477b62c8e3" translate="yes" xml:space="preserve">
          <source>I've seen many developers here and on the mailing list create these elaborate solutions with jQuery plugins of 150 or 200 lines of code that they then glue into AngularJS with a collection of callbacks and &lt;code&gt;$apply&lt;/code&gt;s that are confusing and convoluted; but they eventually get it working! The problem is that in &lt;strong&gt;most&lt;/strong&gt; cases that jQuery plugin could be rewritten in AngularJS in a fraction of the code, where suddenly everything becomes comprehensible and straightforward.</source>
          <target state="translated">私はここで多くの開発者を見てきました。メーリングリストでは、150行または200行のコードのjQueryプラグインを使用してこれらの精巧なソリューションを作成し、それらを混乱と複雑なコールバックと &lt;code&gt;$apply&lt;/code&gt; のコレクションでAngularJSに接着しています。 しかし、最終的には機能します！ 問題は、 &lt;strong&gt;ほとんどの&lt;/strong&gt;場合、jQueryプラグインがコードの一部でAngularJSで書き換えられる可能性があり、突然すべてが理解可能で簡単になるということです。</target>
        </trans-unit>
        <trans-unit id="9faefb35c2c81504d51573a6b0bb40a2af1787a2" translate="yes" xml:space="preserve">
          <source>If this sounds like it might be over-prescriptive and limiting, nothing could be farther from the truth. Because AngularJS treats your HTML as code, you get &lt;strong&gt;HTML level granularity in your web application&lt;/strong&gt;. Everything is possible, and most things are surprisingly easy once you make a few conceptual leaps.</source>
          <target state="translated">これが過度に規範的で制限的であるように聞こえる場合は、真実から遠く離れているものはありません。 AngularJSはHTMLをコードとして扱うため&lt;strong&gt;、WebアプリケーションでHTMLレベルの細分性&lt;/strong&gt;が得られ&lt;strong&gt;ます&lt;/strong&gt; 。 すべてが可能であり、いくつかの概念的な飛躍をすれば、ほとんどのことは驚くほど簡単です。</target>
        </trans-unit>
        <trans-unit id="79f7744c5244c5d82136a0b399bcf24b88bb5af1" translate="yes" xml:space="preserve">
          <source>If you do use jQuery, you shouldn't be sprinkling it all over the place. The correct place for DOM manipulation in AngularJS is in a directive. More on these later.</source>
          <target state="translated">jQueryを使うのであれば、あちこちに散りばめてはいけません。AngularJSにおけるDOM操作の正しい場所はディレクティブの中です。これについては後述します。</target>
        </trans-unit>
        <trans-unit id="b60077ec18c37edabed1d4367bf017ee53c9fbcf" translate="yes" xml:space="preserve">
          <source>If you need an HTML widget, create a directive.</source>
          <target state="translated">HTML ウィジェットが必要な場合は、ディレクティブを作成します。</target>
        </trans-unit>
        <trans-unit id="c0db6dddb3c36feeee526c677dfbbae3c8383c59" translate="yes" xml:space="preserve">
          <source>If you need to share data between controllers, create a service or factory - they are singletons that are shared across the application.</source>
          <target state="translated">コントローラ間でデータを共有する必要がある場合は、サービスやファクトリーを作成します。</target>
        </trans-unit>
        <trans-unit id="4428aad89d5c0c9e8fe7de6ea30b96f7e38235d8" translate="yes" xml:space="preserve">
          <source>If you want a carousel, just use a &lt;code&gt;&amp;lt;carousel /&amp;gt;&lt;/code&gt; element, then define a directive to pull in a template, and make that sucker work.</source>
          <target state="translated">カルーセルが必要な場合は、 &lt;code&gt;&amp;lt;carousel /&amp;gt;&lt;/code&gt; 要素を使用して、テンプレートを取り込むディレクティブを定義し、その吸盤を機能させます。</target>
        </trans-unit>
        <trans-unit id="276ce11b5a508e459e0e3120bcd6327d2afadd20" translate="yes" xml:space="preserve">
          <source>If, like me, you lived through the browser wars, you might find this idea quite offensive. Get over it, it'll be worth it, I promise.</source>
          <target state="translated">私のようにブラウザ戦争を生き抜いてきた人は、このアイデアを不快に感じるかもしれません。乗り越えてください、その価値はあります、約束します。</target>
        </trans-unit>
        <trans-unit id="5813cd91b1b8004097b86b34053bfec044d09858" translate="yes" xml:space="preserve">
          <source>Imperative &amp;rarr; declarative</source>
          <target state="translated">命令型&amp;rarr;宣言型</target>
        </trans-unit>
        <trans-unit id="07968492b4fc9b61f75164fde04e026e2f9fa45e" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;AngularJS&lt;/strong&gt;, you use &lt;strong&gt;directives&lt;/strong&gt; to mark the elements directly, to wire them up:</source>
          <target state="translated">&lt;strong&gt;AngularJS&lt;/strong&gt;では、 &lt;strong&gt;ディレクティブ&lt;/strong&gt;を使用して要素を直接マークし、要素を&lt;strong&gt;結び付け&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="f72af3c482bf1229ea3ff7aa97ad07e3cddd38f9" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;jQuery&lt;/strong&gt;, you typically  use &lt;strong&gt;selectors&lt;/strong&gt; to find elements, and then wire them up:</source>
          <target state="translated">&lt;strong&gt;jQuery&lt;/strong&gt;では、通常、 &lt;strong&gt;セレクター&lt;/strong&gt;を使用して要素を検索し、それらを関連付けます。</target>
        </trans-unit>
        <trans-unit id="f023543783f6ea1287434a1d4ab86cd65d3608d2" translate="yes" xml:space="preserve">
          <source>In AngularJS we write smaller directives. Our dropdown directive would be ridiculously small. It might maintain the folded state, and provide methods to fold(), unfold() or toggle(). These methods would simply update $scope.menu.visible which is a boolean holding the state.</source>
          <target state="translated">AngularJSでは、より小さなディレクティブを書きます。私たちのドロップダウンディレクティブはとんでもなく小さいです。折りたたまれた状態を維持し、fold()、unfold()、toggle()のメソッドを提供します。これらのメソッドは単に状態を保持するブール値である$scope.menu.visibleを更新するだけです。</target>
        </trans-unit>
        <trans-unit id="d8e03995fe1bd0fda78591a1efe81ead5f9d2dc8" translate="yes" xml:space="preserve">
          <source>In AngularJS you can do this too, but you are encouraged to make use of data binding. Change your model, and because the DOM is bound to it via a template your DOM will automatically update, no intervention required.</source>
          <target state="translated">AngularJSでもこれができますが、データバインディングを利用することをお勧めします。モデルを変更すれば、テンプレートを介してDOMがバインドされているので、DOMは自動的に更新され、何も介入する必要はありません。</target>
        </trans-unit>
        <trans-unit id="1ac2131eed6961b3bcec8b6db93b268ad621db10" translate="yes" xml:space="preserve">
          <source>In AngularJS, Ajax is your default go-to solution and it happens all the time, almost without you noticing. You can include templates with ng-include. You can apply a template with the simplest custom directive. You can wrap an Ajax call in a service and create yourself a &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt; service, or a &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt; service, which you can access with astonishing ease.</source>
          <target state="translated">AngularJSでは、Ajaxがデフォルトの主要ソリューションであり、ほとんど気付かれることなく、常に発生します。 ng-includeを使用してテンプレートを含めることができます。 最も単純なカスタムディレクティブを使用してテンプレートを適用できます。 Ajax呼び出しをサービスにラップして、驚くほど簡単にアクセスできる&lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt;サービスまたは&lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt;サービスを自分で作成できます。</target>
        </trans-unit>
        <trans-unit id="e2b05f35093dd1f890c262faf35c9be008a7512c" translate="yes" xml:space="preserve">
          <source>In AngularJS, meaning lives in the model, the HTML is just a template, for display only.</source>
          <target state="translated">AngularJSでは、意味はモデルの中に住んでいるので、HTMLは表示用のテンプレートに過ぎません。</target>
        </trans-unit>
        <trans-unit id="d68e1fa23f0a8a69226a8fe0de84d40b5cf7424f" translate="yes" xml:space="preserve">
          <source>In AngularJS, think about models, rather than jQuery-selected DOM elements that hold your data. Think about views as projections of those models, rather than registering callbacks to manipulate what the user sees.</source>
          <target state="translated">AngularJSでは、データを保持するjQueryで選択されたDOM要素ではなく、モデルについて考えてみましょう。ユーザーが見るものを操作するためにコールバックを登録するのではなく、モデルの投影としてビューを考えてください。</target>
        </trans-unit>
        <trans-unit id="89cbb8617b950a42475e39e8432df7a8116707a2" translate="yes" xml:space="preserve">
          <source>In AngularJS, though, the view is the official record of view-based functionality. Our &lt;code&gt;ul&lt;/code&gt; declaration would look like this instead:</source>
          <target state="translated">ただし、AngularJSでは、ビューはビューベースの機能の公式記録です。 代わりに、 &lt;code&gt;ul&lt;/code&gt; 宣言は次のようになります。</target>
        </trans-unit>
        <trans-unit id="0162908cf1e7269bf496e946a61a8ada95cd6936" translate="yes" xml:space="preserve">
          <source>In AngularJS, we define directives. A directive is a function which returns a JSON object. This object tells AngularJS what DOM elements to look for, and what changes to make to them. Directives are hooked in to the template using either attributes or elements, which you invent. The idea is to extend the capabilities of HTML with new attributes and elements.</source>
          <target state="translated">AngularJSではディレクティブを定義します。ディレクティブはJSONオブジェクトを返す関数です。このオブジェクトはAngularJSにどのDOM要素を探し、それにどのような変更を加えるべきかを伝えます。ディレクティブは属性や要素を使ってテンプレートにフックされます。新しい属性や要素を使ってHTMLの機能を拡張しようという考えです。</target>
        </trans-unit>
        <trans-unit id="9ead8b9954017937b7508b690030cf694823a516" translate="yes" xml:space="preserve">
          <source>In AngularJS, you want to think about &lt;strong&gt;views&lt;/strong&gt; rather than DOM elements. Views are (declarative) HTML that contain AngularJS &lt;strong&gt;directives&lt;/strong&gt;. Directives set up the event handlers behind the scenes for us and give us dynamic databinding. Selectors are rarely used, so the need for IDs (and some types of classes) is greatly diminished. Views are tied to &lt;strong&gt;models&lt;/strong&gt; (via scopes). Views are a projection of the model. Events change models (that is, data, scope properties), and the views that project those models update &quot;automatically.&quot;</source>
          <target state="translated">AngularJSでは、DOM要素ではなく&lt;strong&gt;ビュー&lt;/strong&gt;について考えたいと思い&lt;strong&gt;ます&lt;/strong&gt; 。 ビューは、AngularJS &lt;strong&gt;ディレクティブ&lt;/strong&gt;を含む（宣言的な）HTMLです。 ディレクティブは、バックグラウンドでイベントハンドラーをセットアップし、動的なデータバインディングを提供します。 セレクタはめったに使用されないため、ID（および一部のタイプのクラス）の必要性は大幅に減少します。 ビューは、（スコープを介して） &lt;strong&gt;モデルに&lt;/strong&gt;関連付けられてい&lt;strong&gt;ます&lt;/strong&gt; 。 ビューはモデルの投影です。 イベントはモデル（つまり、データ、スコーププロパティ）を変更し、それらのモデルを投影するビューは「自動的に」更新されます。</target>
        </trans-unit>
        <trans-unit id="0978a7538d2e9b597f501e430a1fc5188f95a6ac" translate="yes" xml:space="preserve">
          <source>In fact, AngularJS is one of the few JavaScript MV* frameworks (many JavaScript MVC tools still fall under the category library).</source>
          <target state="translated">実際、AngularJSは数少ないJavaScript MV*フレームワークの一つです(多くのJavaScript MVCツールは今でもカテゴリライブラリに該当します)。</target>
        </trans-unit>
        <trans-unit id="90ff4de51967b0e32cde73bafc0522d33f597359" translate="yes" xml:space="preserve">
          <source>In jQuery making an Ajax call is fairly simple, but it's still something you might think twice about. There's the added complexity to think about, and a fair chunk of script to maintain.</source>
          <target state="translated">jQueryでAjaxコールを行うのは非常にシンプルだが、まだ考え直す必要があるかもしれない。考えなければならない複雑さと、維持するためのスクリプトのかなりの塊があります。</target>
        </trans-unit>
        <trans-unit id="4d193d7aba2968b4d212b2af011f3a04f803d0cc" translate="yes" xml:space="preserve">
          <source>In jQuery we define plugins by adding functions to the jQuery.prototype. We then hook these into the DOM by selecting elements and calling the plugin on the result. The idea is to extend the capabilities of jQuery.</source>
          <target state="translated">jQuery では、jQuery.prototype に関数を追加してプラグインを定義します。そして、要素を選択し、その結果に対してプラグインを呼び出すことで、これらを DOM にフックします。これは、jQuery の機能を拡張するためのアイデアです。</target>
        </trans-unit>
        <trans-unit id="91a51e946cb4f1b8c319d268bb1e04bc99f9428c" translate="yes" xml:space="preserve">
          <source>In jQuery you make all your DOM changes by hand. You construct new DOM elements programatically. If you have a JSON array and you want to put it to the DOM, you must write a function to generate the HTML and insert it.</source>
          <target state="translated">jQuery では、DOM の変更はすべて手作業で行います。新しい DOM 要素はプログラムで構築します。JSON 配列を持っていて、それを DOM に配置したい場合は、HTML を生成して挿入する関数を書かなければなりません。</target>
        </trans-unit>
        <trans-unit id="a18bb6e728d8ea68da1050a05d8c1caca3f92ba2" translate="yes" xml:space="preserve">
          <source>In jQuery, &lt;em&gt;selectors&lt;/em&gt; are used to find &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; elements and then bind/register event handlers to them. When an event triggers, that (imperative) code executes to update/change the DOM.</source>
          <target state="translated">jQueryでは、 &lt;em&gt;セレクター&lt;/em&gt;を使用して&lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;要素を検索し、それらにイベントハンドラーをバインド/登録します。 イベントがトリガーされると、その（命令型）コードが実行され、DOMを更新/変更します。</target>
        </trans-unit>
        <trans-unit id="8a90029611394ef928be3afb0243d4a481afa763" translate="yes" xml:space="preserve">
          <source>In jQuery, if we want to accomplish a small non-dom related task such as pulling a feed from an API, we might write a little function to do that in our closure. That's a valid solution, but what if we  want to access that feed often? What if we want to reuse that code in another application?</source>
          <target state="translated">jQueryでは、APIからフィードを引っ張ってくるなど、ドムに関連しない小さなタスクを達成したい場合、クロージャの中にそれを行うための小さな関数を書くことがあります。これは有効な解決策ですが、フィードに頻繁にアクセスしたい場合はどうでしょうか?そのコードを別のアプリケーションで再利用したい場合はどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="578dbc27e0bbb209f2594106996aa6a42a880c64" translate="yes" xml:space="preserve">
          <source>In jQuery, in our application logic, we would activate it with something like:</source>
          <target state="translated">jQueryのアプリケーションロジックでは、次のようにしてアクティブにします。</target>
        </trans-unit>
        <trans-unit id="e592dbbf682e0219ae9b707b9547f8d0c26db26e" translate="yes" xml:space="preserve">
          <source>In jQuery, the DOM is kind of like the model. But in AngularJS, we have a separate model layer that we can manage in any way we want, completely independently from the view. This helps for the above data binding, maintains &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separation of concerns&lt;/a&gt;, and introduces far greater testability. Other answers mentioned this point, so I'll just leave it at that.</source>
          <target state="translated">jQueryでは、DOMはモデルのようなものです。 しかし、AngularJSでは、ビューから完全に独立して、任意の方法で管理できる独立したモデルレイヤーがあります。 これは、上記のデータバインディングに役立ち&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;、懸念事項の分離を&lt;/a&gt;維持し、はるかに優れたテスト容易性をもたらします。 この点については他の回答でも触れたので、そのままにしておきます。</target>
        </trans-unit>
        <trans-unit id="9df8eb4ba7e6248a7fa36700e17beb0b22254122" translate="yes" xml:space="preserve">
          <source>In jQuery, the only way to test is often to create the component independently with a sample/demo page against which our tests can perform DOM manipulation. So then we have to develop a component separately and &lt;em&gt;then&lt;/em&gt; integrate it into our application. How inconvenient! So much of the time, when developing with jQuery, we opt for iterative instead of test-driven development. And who could blame us?</source>
          <target state="translated">jQueryでテストする唯一の方法は、多くの場合、テストでDOM操作を実行できるサンプル/デモページを使用してコンポーネントを個別に作成することです。 したがって、コンポーネントを個別に開発し、それをアプリケーションに統合する必要があります。 なんて不便なことでしょう。 ほとんどの場合、jQueryで開発するときは、テスト駆動型開発ではなく反復型を選択します。 そして、誰が私たちを責めることができますか？</target>
        </trans-unit>
        <trans-unit id="3d416179f5af40e5d18f244c9ec21f4ff3ba4392" translate="yes" xml:space="preserve">
          <source>In jQuery, we programmatically change the view. We could have a dropdown menu defined as a &lt;code&gt;ul&lt;/code&gt; like so:</source>
          <target state="translated">jQueryでは、プログラムによってビューを変更します。 次のように、ドロップダウンメニューを &lt;code&gt;ul&lt;/code&gt; として定義できます。</target>
        </trans-unit>
        <trans-unit id="8cc873c923938462e55d7110881a14087792dc45" translate="yes" xml:space="preserve">
          <source>In jQuery, you design a page, and then you make it dynamic. This is because jQuery was designed for augmentation and has grown incredibly from that simple premise.</source>
          <target state="translated">jQueryでは、ページをデザインして、それを動的なものにします。これは、jQueryが拡張のために設計されたもので、そのシンプルな前提から驚くほど成長したからです。</target>
        </trans-unit>
        <trans-unit id="7090926b8952ded00ad0da61eb6e721bc8a14052" translate="yes" xml:space="preserve">
          <source>It focuses on &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separation of concerns&lt;/a&gt; and testing (&lt;a href=&quot;http://en.wikipedia.org/wiki/Unit_testing&quot;&gt;unit testing&lt;/a&gt; and end-to-end testing), which facilitates test-driven development.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;関心事&lt;/a&gt;とテスト（ &lt;a href=&quot;http://en.wikipedia.org/wiki/Unit_testing&quot;&gt;単体テスト&lt;/a&gt;とエンドツーエンドテスト）の分離に焦点を当てているため、テスト駆動型の開発が容易になります。</target>
        </trans-unit>
        <trans-unit id="68f6b3301831188f15035c61039b24d8f4da1058" translate="yes" xml:space="preserve">
          <source>It looks like this:</source>
          <target state="translated">こんな感じです。</target>
        </trans-unit>
        <trans-unit id="1bf8b46db45a60c96dc64642b65b408cb0586b2c" translate="yes" xml:space="preserve">
          <source>It's more similar to &lt;a href=&quot;http://en.wikipedia.org/wiki/XSLT&quot;&gt;XSLT&lt;/a&gt; than &lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt; for example.</source>
          <target state="translated">たとえば&lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt;よりも&lt;a href=&quot;http://en.wikipedia.org/wiki/XSLT&quot;&gt;XSLTに&lt;/a&gt;似ています 。</target>
        </trans-unit>
        <trans-unit id="fa9f7423100ee20741ac52a057ba63a8dfdb5f92" translate="yes" xml:space="preserve">
          <source>It's really two very different states of mind.</source>
          <target state="translated">本当に2つの異なる心の状態です。</target>
        </trans-unit>
        <trans-unit id="94d4826a0666242ba1ec0266cc07db08e55ebb65" translate="yes" xml:space="preserve">
          <source>JQuery plugins are created in a closure. Privacy is maintained within that closure. It's up to you to maintain your scope chain within that closure. You only really have access to the set of DOM nodes passed in to the plugin by jQuery, plus any local variables defined in the closure and any globals you have defined. This means that plugins are quite self contained. This is a good thing, but can get restrictive when creating a whole application. Trying to pass data between sections of a dynamic page becomes a chore.</source>
          <target state="translated">JQuery プラグインはクロージャ内に作成されます。プライバシーはそのクロージャ内で維持されます。そのクロージャ内でスコープ チェーンを維持するのはユーザー次第です。実際にアクセスできるのは、jQuery によってプラグインに渡された DOM ノードのセットに加えて、クロージャ内で定義されたローカル変数と定義したグローバルのみです。これは、プラグインが非常に自己完結していることを意味します。これは良いことですが、アプリケーション全体を作成する場合には制限がかかります。動的ページのセクション間でデータを受け渡そうとするのが面倒になります。</target>
        </trans-unit>
        <trans-unit id="4f2edb980b5874e73b214306540044ccfc45d51f" translate="yes" xml:space="preserve">
          <source>JavaScript - Behaviour, without the script the content remains.</source>
          <target state="translated">JavaScript-動作、スクリプトがなくてもコンテンツは残ります。</target>
        </trans-unit>
        <trans-unit id="0270aec9323c9370103673494bbf224ea44393df" translate="yes" xml:space="preserve">
          <source>Let's get down to the nitty gritty.</source>
          <target state="translated">本題に入りましょう。</target>
        </trans-unit>
        <trans-unit id="b836477afc268d4e57ddfe2bd54c811505cff526" translate="yes" xml:space="preserve">
          <source>Let's say in our application, we require a service that implements server-side storage through a &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;REST&lt;/a&gt; API and, depending on application state, local storage as well. When running tests on our controllers, we don't want to have to communicate with the server - we're testing the &lt;em&gt;controller&lt;/em&gt;, after all. We can just add a mock service of the same name as our original component, and the injector will ensure that our controller gets the fake one automatically - our controller doesn't and needn't know the difference.</source>
          <target state="translated">アプリケーションで、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;REST&lt;/a&gt; APIを介してサーバー側のストレージを実装し、アプリケーションの状態に応じてローカルストレージも実装するサービスが必要だとします。 コントローラーでテストを実行するとき、サーバーと通信する必要はありません。コントローラーをテストしているからです。 元のコンポーネントと同じ名前のモックサービスを追加するだけで、インジェクターによってコントローラーが偽のサービスを自動的に取得するようになります。コントローラーは違いを認識していないため、認識する必要はありません。</target>
        </trans-unit>
        <trans-unit id="019d0f43d35ebf4308b922e715c1e5edd09fa4ad" translate="yes" xml:space="preserve">
          <source>Let's say we have a shopping cart. We might define a ShoppingCartService which maintains our cart and contains methods for adding and removing items. Because the service is a singleton, and is shared by all other components, any object that needs to can write to the shopping cart and pull data from it. It's always the same cart.</source>
          <target state="translated">ショッピングカートがあるとしましょう。ショッピングカートを管理し、アイテムを追加したり削除したりするためのメソッドを含む ShoppingCartService を定義するとします。このサービスはシングルトンで、他のすべてのコンポーネントで共有されているため、必要なオブジェクトはすべてショッピングカートに書き込み、そこからデータを引き出すことができます。それは常に同じカートです。</target>
        </trans-unit>
        <trans-unit id="727106c324e0d326b53eb51a45c4de3427303c78" translate="yes" xml:space="preserve">
          <source>Like me, you will quickly realize that AngularJS (or &lt;a href=&quot;http://en.wikipedia.org/wiki/Ember.js&quot;&gt;Ember.js&lt;/a&gt;, Durandal, &amp;amp; other MV* frameworks for that matter) is one complex framework assembling many of the different JavaScript design patterns.</source>
          <target state="translated">私と同じように、AngularJS（または&lt;a href=&quot;http://en.wikipedia.org/wiki/Ember.js&quot;&gt;Ember.js&lt;/a&gt; 、Durandal、およびその他のMV *フレームワーク）は、さまざまなJavaScriptデザインパターンの多くを組み合わせた1つの複雑なフレームワークであることをすぐに理解できます。</target>
        </trans-unit>
        <trans-unit id="1cfac11915904016eed201cd17895ef142e7298c" translate="yes" xml:space="preserve">
          <source>Likewise:</source>
          <target state="translated">Likewise:</target>
        </trans-unit>
        <trans-unit id="480a72e21e4eecb130022ee539c13f82e6fb2dfc" translate="yes" xml:space="preserve">
          <source>Listen to the podcast &lt;em&gt;&lt;a href=&quot;http://javascriptjabber.com/032-jsj-angular-js/&quot;&gt;JavaScript Jabber: Episode #32&lt;/a&gt;&lt;/em&gt; that features the original creators of AngularJS: Misko Hevery &amp;amp; Igor Minar. They talk a lot about what it's like to come to AngularJS from other JavaScript backgrounds, especially jQuery.</source>
          <target state="translated">ポッドキャストの&lt;em&gt;&lt;a href=&quot;http://javascriptjabber.com/032-jsj-angular-js/&quot;&gt;JavaScript Jabber：Episode＃32&lt;/a&gt;&lt;/em&gt;を聞いて、AngularJSのオリジナルクリエイターであるMisko HeveryとIgor Minarを紹介します。 他のJavaScriptのバックグラウンド、特にjQueryからAngularJSに来るのはどのようなものかについて多くのことを話します。</target>
        </trans-unit>
        <trans-unit id="b67d9fb1be3c48bab4357a222d15c0c1c6b2a6cb" translate="yes" xml:space="preserve">
          <source>Lots of small directives vs. big plugins with configuration switches</source>
          <target state="translated">多くの小さなディレクティブと、設定スイッチを持つ大きなプラグインとの比較</target>
        </trans-unit>
        <trans-unit id="d35f5ddc9a42a97abe31468fffd327ecf232b76a" translate="yes" xml:space="preserve">
          <source>MVC and SOC are not on opposite ends of the same scale, they are on completely different axes. SOC makes no sense in an AngularJS context. You have to forget it and move on.</source>
          <target state="translated">MVCとSOCは同じスケールの反対側にあるのではなく、全く別の軸にある。SOCはAngularJSのコンテキストでは意味がありません。それを忘れて前に進むべきです。</target>
        </trans-unit>
        <trans-unit id="c45a37dd264d950f6729ef56ff2a3c5abcd3a05d" translate="yes" xml:space="preserve">
          <source>Manual DOM changes vs. Data Binding</source>
          <target state="translated">手動での DOM の変更とデータバインディング</target>
        </trans-unit>
        <trans-unit id="40e632bf9794198f4934d498879371d6d20bbd8f" translate="yes" xml:space="preserve">
          <source>Misko likes jQuery and doesn't object to you using it. However you will find as you advance that you can get a pretty much all of your work done using a combination of scope, templates and directives, and you should prefer this workflow where possible because your code will be more discrete, more configurable, and more Angular.</source>
          <target state="translated">MiskoはjQueryが好きで、あなたがjQueryを使うことに反対することはありません。しかし、あなたが進むにつれて、スコープ、テンプレート、ディレクティブの組み合わせを使用して、あなたの作業のほとんどすべてを行うことができることに気づくでしょう。</target>
        </trans-unit>
        <trans-unit id="aec4fedd98ecef7252e688fd312c8e23a1997547" translate="yes" xml:space="preserve">
          <source>Model - your models contains your semantic data. Models are usually &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; objects. Models exist as attributes of an object called $scope. You can also store handy utility functions on $scope which your templates can then access.</source>
          <target state="translated">モデル-モデルにはセマンティックデータが含まれています。 モデルは通常&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;オブジェクトです。 モデルは$ scopeと呼ばれるオブジェクトの属性として存在します。 テンプレートがアクセスできる$ scopeに便利なユーティリティ関数を保存することもできます。</target>
        </trans-unit>
        <trans-unit id="19445a7cb4f59d8113ef809076f488b19366f851" translate="yes" xml:space="preserve">
          <source>Modular service architecture</source>
          <target state="translated">モジュラーサービスアーキテクチャ</target>
        </trans-unit>
        <trans-unit id="9f995a1445edebed9a0edf58ca86dd65ac082151" translate="yes" xml:space="preserve">
          <source>Modules contain AngularJS components. &lt;strong&gt;When we include a module, all the components in that module become available to us as a simple list identified by their unique strings&lt;/strong&gt;. We can then inject those components into each other using AngularJS's dependency injection mechanism.</source>
          <target state="translated">モジュールにはAngularJSコンポーネントが含まれています。 &lt;strong&gt;モジュールを含めると、そのモジュール内のすべてのコンポーネントが、一意の文字列で識別される単純なリストとして使用できるようになります&lt;/strong&gt; 。 次に、AngularJSの依存性注入メカニズムを使用して、これらのコンポーネントを相互に注入できます。</target>
        </trans-unit>
        <trans-unit id="70589733204c633c8000b33bb5a831052090d3fd" translate="yes" xml:space="preserve">
          <source>My little book</source>
          <target state="translated">私の小さな本</target>
        </trans-unit>
        <trans-unit id="07bfe1f4feee155120fcc275ea68f1bb17d3143b" translate="yes" xml:space="preserve">
          <source>NB: This list is not complete, nor 'the best libraries'; they just happen to be the libraries I used. These libraries also include more patterns, the ones mentioned are just their main focuses or original intents. If you feel something is missing from this list, please do mention it in the comments, and I will be glad to add it.</source>
          <target state="translated">注:このリストは完全なものではありませんし、「最高のライブラリ」でもありません。これらのライブラリには他のパターンも含まれています。もしこのリストに何かが欠けていると感じたら、コメントでそれを述べてください。</target>
        </trans-unit>
        <trans-unit id="9c8b27c78d13ab71411ac0fb47cbd272d9d671dd" translate="yes" xml:space="preserve">
          <source>Need to update on mouseover?</source>
          <target state="translated">マウスオーバーの更新が必要ですか?</target>
        </trans-unit>
        <trans-unit id="aa01a327749e49bb46fbfc492f1fd3a49c1971bc" translate="yes" xml:space="preserve">
          <source>Now &lt;strong&gt;in our template&lt;/strong&gt; we can wire this up:</source>
          <target state="translated">これ&lt;strong&gt;で、テンプレートで&lt;/strong&gt;これを接続でき&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="153e1db9288018367b69014d7e273ac9321adee5" translate="yes" xml:space="preserve">
          <source>Now when I want to use that service I just refer to it by name like this:</source>
          <target state="translated">今では、そのサービスを使いたいときには、このように名前を付けて参照しています。</target>
        </trans-unit>
        <trans-unit id="0442ca4f2eae67ddd54b40deb8356ab4b3234010" translate="yes" xml:space="preserve">
          <source>Okay, now we can write a test for the non-existent &lt;code&gt;when-active&lt;/code&gt; directive:</source>
          <target state="translated">さて、存在しない &lt;code&gt;when-active&lt;/code&gt; ディレクティブのテストを書くことができます：</target>
        </trans-unit>
        <trans-unit id="7837f88043d6848be1c4e543d7bab6fecef2576e" translate="yes" xml:space="preserve">
          <source>One approach to designing an AngularJS application:</source>
          <target state="translated">AngularJSアプリケーションを設計するための1つのアプローチ。</target>
        </trans-unit>
        <trans-unit id="2bf914d56359268ce76537cc99ef400aea8ea885" translate="yes" xml:space="preserve">
          <source>One more thing you will experience in AngularJS: in jQuery you call the jQuery functions a lot, in AngularJS, AngularJS will call your functions, so AngularJS will 'tell you how to do things', but the benefits are worth it, so learning AngularJS usually means learning what AngularJS wants or the way AngularJS requires that you present your functions and it will call it accordingly. This is one of the things that makes AngularJS a framework rather than a library.</source>
          <target state="translated">もう一つ、AngularJSで経験することがあります:jQueryではjQueryの関数をたくさん呼びますが、AngularJSではAngularJSがあなたの関数を呼びますので、AngularJSは「やり方を教えてくれる」のですが、そのメリットはそれだけの価値があるので、AngularJSを学ぶということは、通常、AngularJSが何を望んでいるのか、またはAngularJSが要求する方法を学ぶということです。これがAngularJSをライブラリではなくフレームワークにしている理由の一つです。</target>
        </trans-unit>
        <trans-unit id="03d3b7c13e891111d419508c0bfcfcb11f3df270" translate="yes" xml:space="preserve">
          <source>One of the first questions I asked myself when starting AngularJS and running through the tutorials is &lt;strong&gt;&quot;Where is my code?&quot;&lt;/strong&gt;. I've written no JavaScript, and yet I have all this behaviour. The answer is obvious. Because AngularJS compiles the DOM, AngularJS is treating your HTML as code. For many simple cases it's often sufficient to just write a template and let AngularJS compile it into an application for you.</source>
          <target state="translated">AngularJSを起動してチュートリアルを実行するときに私が最初に尋ねた質問の1つは、 &lt;strong&gt;「コードはどこですか？」&lt;/strong&gt; 。 私はJavaScriptを作成していませんが、それでもこのような振る舞いをしています。 答えは明白です。 AngularJSはDOMをコンパイルするため、AngularJSはHTMLをコードとして扱います。 多くの単純なケースでは、多くの場合、テンプレートを作成して、AngularJSにそれをアプリケーションにコンパイルさせるだけで十分です。</target>
        </trans-unit>
        <trans-unit id="5560b0b478cb184acb6dd255b743f68939c76bfb" translate="yes" xml:space="preserve">
          <source>One of the first things your will notice about AngularJS is that &lt;strong&gt;custom attributes are everywhere&lt;/strong&gt;. Your HTML will be littered with ng attributes, which are essentially onClick attributes on steroids. These are directives (compiler directives), and are one of the main ways in which the template is hooked to the model.</source>
          <target state="translated">AngularJSについて最初に気付くのは、 &lt;strong&gt;カスタム属性がどこにでも&lt;/strong&gt;ある&lt;strong&gt;ということです&lt;/strong&gt; 。 HTMLはng属性で散らかされます。これらは本質的にステロイドのonClick属性です。 これらはディレクティブ（コンパイラディレクティブ）であり、テンプレートがモデルにフックされる主な方法の1つです。</target>
        </trans-unit>
        <trans-unit id="57ecf8a54298e4269c92c7bcc0dbba1ce9d013e8" translate="yes" xml:space="preserve">
          <source>One of the points made in the podcast made a lot of things click for me with respects to your question:</source>
          <target state="translated">ポッドキャストの中で行われたポイントの一つは、あなたの質問に関連して、私にとって多くのことがクリックされました。</target>
        </trans-unit>
        <trans-unit id="d2d60cb91258951e85b2c255d25b7443475f73c6" translate="yes" xml:space="preserve">
          <source>Our test now passes &lt;em&gt;and&lt;/em&gt; our menu performs as requested. Our development is &lt;em&gt;both&lt;/em&gt; iterative &lt;em&gt;and&lt;/em&gt; test-driven. Wicked-cool.</source>
          <target state="translated">これでテストに合格&lt;em&gt;し&lt;/em&gt; 、メニューは要求どおりに実行されます。 私たちの開発は&lt;em&gt;、&lt;/em&gt;反復的&lt;em&gt;で&lt;/em&gt;テスト主導型です。 邪悪なクール。</target>
        </trans-unit>
        <trans-unit id="b1cda9d2edb4291daae963095ddaa44650f5868e" translate="yes" xml:space="preserve">
          <source>Out of all of the many jQuery plugins you've seen, used, or written, how many of them had an accompanying test suite? Not very many because jQuery isn't very amenable to that. But AngularJS is.</source>
          <target state="translated">これまでに見たことがある、使ったことがある、書いたことがある数多くのjQueryプラグインの中で、テストスイートが付属していたものはどれくらいあったでしょうか?jQueryはそれに対応していないので、あまり多くはありません。しかし、AngularJSはそうです。</target>
        </trans-unit>
        <trans-unit id="f9292427c33228bbb89cf354be2c739835887f3c" translate="yes" xml:space="preserve">
          <source>Plugins vs. Directives</source>
          <target state="translated">プラグインとガイドライン</target>
        </trans-unit>
        <trans-unit id="607f6c8afc68a939603967e0db86561e2011d68e" translate="yes" xml:space="preserve">
          <source>Prototypal inheritance</source>
          <target state="translated">プロトタイプ継承</target>
        </trans-unit>
        <trans-unit id="1125bad105ddcf506c8be1fdc620fda300253963" translate="yes" xml:space="preserve">
          <source>Put another way, if AngularJS doesn't do something out of the box, think how the team would accomplish it to fit right in with &lt;code&gt;ngClick&lt;/code&gt;, &lt;code&gt;ngClass&lt;/code&gt;, et al.</source>
          <target state="translated">別の言い方をすれば、AngularJSがそのままでは何もしない場合は、 &lt;code&gt;ngClick&lt;/code&gt; や &lt;code&gt;ngClass&lt;/code&gt; などを使用してチームがどのようにそれを実現できるかを考えてください。</target>
        </trans-unit>
        <trans-unit id="114cadb60225b9cfb70015e3d69c1e89f1ac48ce" translate="yes" xml:space="preserve">
          <source>Remember: don't design, and then mark up. You must architect, and then design.</source>
          <target state="translated">覚えておいてください:設計してからマークアップするのではなく、設計してからマークアップするのです。設計してから設計するのです。</target>
        </trans-unit>
        <trans-unit id="f161adf528d29607ada8937ad2e9d5fb2b6eb816" translate="yes" xml:space="preserve">
          <source>Say I have a component called 'FlickrService' which defines methods for pulling JSON feeds from Flickr. Now, if I want to write a controller that can access Flickr, I just need to refer to the 'FlickrService' by name when I declare the controller. AngularJS will take care of instantiating the component and making it available to my controller.</source>
          <target state="translated">FlickrからJSONフィードを引っ張ってくるためのメソッドを定義している'FlickrService'というコンポーネントがあるとします。さて、Flickrにアクセスできるコントローラを書きたい場合、コントローラを宣言する際に'FlickrService'を名前で参照する必要があります。AngularJSはコンポーネントのインスタンスを作成し、それをコントローラで利用できるようにしてくれます。</target>
        </trans-unit>
        <trans-unit id="19ccf6b268bdaab6e39621189c0b09a8c462daa5" translate="yes" xml:space="preserve">
          <source>Say you have a menu that you want to unfold on hover. Well now we have a problem. Our plugin has wired in our click handler for us, we're going to need to add a configuration option to make it behave differently in this specific case.</source>
          <target state="translated">ホバー上で展開したいメニューがあるとします。さて、ここで問題が発生しました。このプラグインはクリックハンドラを配線しているので、この特定のケースでは異なる動作をするように設定オプションを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="7d90dd71a242dda24991720aaeaa5f7a73787c5c" translate="yes" xml:space="preserve">
          <source>Saying &quot;I have a jQuery background how do I think in AngularJS?&quot; is like saying &quot;I have an HTML background how do I think in JavaScript?&quot; The fact that you're asking the question shows you most likely don't understand the fundamental purposes of these two resources. This is why I chose to answer the question by simply pointing out the fundamental difference rather than going through the list saying &quot;AngularJS makes use of directives whereas jQuery uses CSS selectors to make a jQuery object which does this and that etc....&quot;. This question does not require a lengthy answer.</source>
          <target state="translated">&quot;I have a jQuery background how do I think in AngularJS? &quot;と言うのは、&quot;I have an HTML background how do I think in JavaScript? &quot;と言っているようなものです。この質問をしているということは、この2つのリソースの根本的な目的を理解していない可能性が高いことを示しています。だからこそ、「AngularJSはディレクティブを利用しているのに対し、jQueryはCSSのセレクタを使ってjQueryオブジェクトを作成し、これを実行したり、これを実行したりする......」とリストアップするのではなく、単純に根本的な違いを指摘することで質問に答えようとしたのです。この質問に長々と答える必要はありません。</target>
        </trans-unit>
        <trans-unit id="b15d2624d8c5f4177ef0a3ab7aff382714a73357" translate="yes" xml:space="preserve">
          <source>Second, even if we already have jQuery on our page, there's no reason to use it here; we can simply use &lt;code&gt;angular.element&lt;/code&gt; and our component will still work when dropped into a project that doesn't have jQuery.</source>
          <target state="translated">2番目に、ページにjQueryが既にある場合でも、ここでそれを使用する理由はありません。 &lt;code&gt;angular.element&lt;/code&gt; を使用するだけで、jQueryを持たないプロジェクトにドロップしてもコンポーネントは機能します。</target>
        </trans-unit>
        <trans-unit id="f1027ea73a1ce39cead4439ded7f29e2042983a5" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/a/14346528/215945&quot;&gt;https://stackoverflow.com/a/14346528/215945&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14346528/215945&quot;&gt;https://stackoverflow.com/a/14346528/215945&lt;/a&gt;も参照してください</target>
        </trans-unit>
        <trans-unit id="5f1430a8f5652e40680c3ddd0c683243bf517e61" translate="yes" xml:space="preserve">
          <source>Semantic HTML vs. Semantic Models</source>
          <target state="translated">セマンティックHTMLとセマンティックモデル</target>
        </trans-unit>
        <trans-unit id="53858a8768ea9c3d5fda9320b9574562086e2f5d" translate="yes" xml:space="preserve">
          <source>Separation of concerns</source>
          <target state="translated">懸念事項の分離</target>
        </trans-unit>
        <trans-unit id="6db963975c4efe88a2a596e7aed57f9bfc1a010d" translate="yes" xml:space="preserve">
          <source>Separation of concerns (SOC) vs. MVC</source>
          <target state="translated">懸念事項の分離(SOC)対MVC</target>
        </trans-unit>
        <trans-unit id="5bc1e903eb4c935f3459b8bfa4ee30d83efd9017" translate="yes" xml:space="preserve">
          <source>Service Objects vs Helper Functions</source>
          <target state="translated">サービスオブジェクトとヘルパー関数</target>
        </trans-unit>
        <trans-unit id="4c836a91846e8f4077393af2f95820c64acdb8ff" translate="yes" xml:space="preserve">
          <source>Service objects are self-contained AngularJS components which we can use and reuse as we see fit. They are simple JSON objects containing functions and Data. They are always singletons, so if you store data on a service in one place, you can get that data out somewhere else just by requesting the same service.</source>
          <target state="translated">サービスオブジェクトは自己完結型のAngularJSコンポーネントで、必要に応じて使用したり再利用したりすることができます。サービスオブジェクトは関数とデータを含むシンプルなJSONオブジェクトです。サービスオブジェクトは常にシングルトンで、ある場所にデータを保存しておけば、同じサービスをリクエストするだけで別の場所からデータを取り出すことができます。</target>
        </trans-unit>
        <trans-unit id="108da03ec5d5f76f957cbf432008dbadf4a072c6" translate="yes" xml:space="preserve">
          <source>Services are simple objects that contain functions and data. They are always singletons, meaning there can never be more than one of them. Say we want to access the Stack Overflow API, we might write a &lt;code&gt;StackOverflowService&lt;/code&gt; which defines methods for doing so.</source>
          <target state="translated">サービスは、関数とデータを含む単純なオブジェクトです。 それらは常にシングルトンです。つまり、それらが複数になることはありません。 Stack Overflow APIにアクセスしたいとします。そのためのメソッドを定義する &lt;code&gt;StackOverflowService&lt;/code&gt; を作成する場合があります。</target>
        </trans-unit>
        <trans-unit id="bcd9e97fc87fb6d10f4491826f78c5d81839dcbf" translate="yes" xml:space="preserve">
          <source>Similarly, don't start with the idea that jQuery does X, Y, and Z, so I'll just add AngularJS on top of that for models and controllers. This is &lt;em&gt;really&lt;/em&gt; tempting when you're just starting out, which is why I always recommend that new AngularJS developers don't use jQuery at all, at least until they get used to doing things the &quot;Angular Way&quot;.</source>
          <target state="translated">同様に、jQueryがX、Y、およびZを実行するという考えから始めないでください。そのため、モデルとコントローラー用にAngularJSを追加するだけです。 これは、始めたばかりの場合は&lt;em&gt;本当に&lt;/em&gt;魅力的です。そのため、少なくとも「Angular Way」に慣れるまで、新しいAngularJS開発者はjQueryをまったく使用しないことを常にお勧めします。</target>
        </trans-unit>
        <trans-unit id="bcedf6e82233838f46efd8ce2fadad3c46a471c6" translate="yes" xml:space="preserve">
          <source>So if directives aren't just collections of jQuery-like functions, what are they? Directives are actually &lt;strong&gt;extensions of HTML&lt;/strong&gt;. If HTML doesn't do something you need it to do, you write a directive to do it for you, and then use it just as if it was part of HTML.</source>
          <target state="translated">では、ディレクティブがjQueryのような関数のコレクションだけではない場合、それらは何ですか？ ディレクティブは実際に&lt;strong&gt;はHTMLの拡張です&lt;/strong&gt; 。 HTMLが必要な処理を行わない場合は、それを行うためのディレクティブを記述し、HTMLの一部であるかのように使用します。</target>
        </trans-unit>
        <trans-unit id="6120b7aac76e709ec6a4b057e3e50cdedce773bf" translate="yes" xml:space="preserve">
          <source>So then &lt;em&gt;how&lt;/em&gt; do you do that? How do you &quot;think in AngularJS&quot;? Here are some general principles, contrasted with jQuery.</source>
          <target state="translated">それでは、 &lt;em&gt;どう&lt;/em&gt;やってそれを行うのですか？ どのように「AngularJSで考える」のですか？ jQueryと対照的ないくつかの一般的な原則を次に示します。</target>
        </trans-unit>
        <trans-unit id="c8363d4dd045c968829900ac07d31222d3fe3f8c" translate="yes" xml:space="preserve">
          <source>So when people say &quot;don't include jQuery at all&quot;, it's mainly because they don't want you to use selectors; they want you to learn to use directives instead. Direct, not select!</source>
          <target state="translated">そのため、「jQueryを全く入れるな」と言われたとき、それは主にセレクタを使って欲しくないからで、代わりにディレクティブを使うことを学んで欲しいからです。セレクタではなくダイレクトに</target>
        </trans-unit>
        <trans-unit id="353a803b7edb418ffb01abfd037657963de833b9" translate="yes" xml:space="preserve">
          <source>So, to directly answer your question: AngularJS is -very- opinionated and is a true MV* framework. However, you can still do all of the really cool stuff you know and love with jQuery inside of directives. It's not a matter of &quot;How do I do what I used to in jQuery?&quot; as much as it's a matter of &quot;How do I supplement AngularJS with all of the stuff I used to do in jQuery?&quot;</source>
          <target state="translated">そこで、あなたの質問に直接お答えします。AngularJSは非常に意見が多く、真のMV*フレームワークです。しかし、あなたが知っていて大好きな本当にクールなものはすべて、ディレクティブの中のjQueryで行うことができます。これは、&quot;jQueryで使っていたことをどうやってやるか?&quot;という問題ではなく、&quot;jQueryで使っていたことをどうやってAngularJSを補完するか?&quot;という問題です。</target>
        </trans-unit>
        <trans-unit id="615e1f97ec6c97206dc36b15588437a9d429a60e" translate="yes" xml:space="preserve">
          <source>Some directives just decorate what's already in the view (think &lt;code&gt;ngClass&lt;/code&gt;) and therefore sometimes do DOM manipulation straight away and then are basically done. But if a directive is like a &quot;widget&quot; and has a template, it should &lt;em&gt;also&lt;/em&gt; respect separation of concerns. That is, the template &lt;em&gt;too&lt;/em&gt; should remain largely independent from its implementation in the link and controller functions.</source>
          <target state="translated">一部のディレクティブは、すでにビューにあるものを装飾するだけです（ &lt;code&gt;ngClass&lt;/code&gt; と考えてください ）。したがって、すぐにDOM操作を行ってから、基本的に行われることがあります。 ただし、ディレクティブが「ウィジェット」のようなものであり、テンプレートがある場合は、懸念の分離&lt;em&gt;も&lt;/em&gt;尊重する必要が&lt;em&gt;あり&lt;/em&gt;ます。 つまり、テンプレート&lt;em&gt;も&lt;/em&gt; 、リンクおよびコントローラー関数での実装から大部分は独立している必要があります。</target>
        </trans-unit>
        <trans-unit id="0b7f180f770b68b78d30a4012dd96f23b513a81e" translate="yes" xml:space="preserve">
          <source>Speaking of testing...</source>
          <target state="translated">テストといえば</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="2c1b6c2453539d082bde5c9bc024f6fe7db931a1" translate="yes" xml:space="preserve">
          <source>Suppose I'm familiar with developing client-side applications in &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, but now I'd like to start using &lt;a href=&quot;http://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;. Can you describe the paradigm shift that is necessary? Here are a few questions that might help you frame an answer:</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;でのクライアント側アプリケーションの開発に精通しているとしましょう。ここで、 &lt;a href=&quot;http://angularjs.org/&quot;&gt;AngularJSの&lt;/a&gt;使用を開始したいと思います。 必要なパラダイムシフトについて説明できますか？ 回答の組み立てに役立つと思われるいくつかの質問を次に示します。</target>
        </trans-unit>
        <trans-unit id="fd6f41a20d68ad3b1c1fbfcea42f10e9427c9beb" translate="yes" xml:space="preserve">
          <source>Take the example of a dropdown. When writing a dropdown plugin you might be tempted to code in click handlers, perhaps a function to add in a chevron which is either up or down, perhaps change the class of the unfolded element, show hide the menu, all helpful stuff.</source>
          <target state="translated">ドロップダウンの例を見てみましょう。ドロップダウンプラグインを書くとき、クリックハンドラでコーディングしたくなるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5f73c389448f9c45c912813ff91624715c6cc34b" translate="yes" xml:space="preserve">
          <source>The JavaScript is in control. The HTML has a completely independent existence. Your HTML remains semantic even without JavaScript. Onclick attributes are very bad practice.</source>
          <target state="translated">JavaScriptが支配している。HTMLは完全に独立した存在です。あなたのHTMLはJavaScriptがなくてもセマンティックなままです。Onclick属性は非常に悪い習慣です。</target>
        </trans-unit>
        <trans-unit id="130af66cb629f5431d0392abeadf163c2a137efa" translate="yes" xml:space="preserve">
          <source>The best way to start is going through &lt;a href=&quot;http://docs.angularjs.org/tutorial/&quot;&gt;their awesome tutorial&lt;/a&gt;. You can go through the steps in a couple of hours; however, in case you want to master the concepts behind the scenes, they include a myriad of reference for further reading.</source>
          <target state="translated">開始するための最良の方法は&lt;a href=&quot;http://docs.angularjs.org/tutorial/&quot;&gt;、素晴らしいチュートリアルを実行すること&lt;/a&gt;です。 数時間で手順を実行できます。 ただし、舞台裏のコンセプトをマスターしたい場合は、さらに読むための無数のリファレンスが含まれています。</target>
        </trans-unit>
        <trans-unit id="2e204a233be1d37e6b8cbf5eb65012ecf70edcf5" translate="yes" xml:space="preserve">
          <source>The big difference (TLDR)</source>
          <target state="translated">大きな違い(TLDR</target>
        </trans-unit>
        <trans-unit id="907f9bbd858732c7716065c039f6505a1e2910ac" translate="yes" xml:space="preserve">
          <source>The bottom line is this: when solutioning, first &quot;think in AngularJS&quot;; if you can't think of a solution, ask the community; if after all of that there is no easy solution, &lt;em&gt;then&lt;/em&gt; feel free to reach for the jQuery. But don't let jQuery become a crutch or you'll never master AngularJS.</source>
          <target state="translated">肝心なのはこれです：解決するとき、最初に「AngularJSで考える」; 解決策が思いつかない場合は、コミュニティに質問してください。 それでも簡単な解決策がない場合は、jQueryに気軽にアクセスしてください。 ただし、jQueryが松葉杖にならないようにしてください。そうしないと、AngularJSをマスターすることはできません。</target>
        </trans-unit>
        <trans-unit id="e57a136d72c8717caeadf129317ca6ab40af1abf" translate="yes" xml:space="preserve">
          <source>The main thing to realise is that your template drives your application. Stop trying to write big plugins that do everything. Instead write little directives that do one thing, then write a simple template to wire them together.</source>
          <target state="translated">主なことは、あなたのテンプレートがあなたのアプリケーションを動かすということです。すべてを行う大きなプラグインを書こうとするのはやめましょう。その代わりに、一つのことを行う小さなディレクティブを書き、それらをつなぐシンプルなテンプレートを書きましょう。</target>
        </trans-unit>
        <trans-unit id="962f4b9dcab1b0d6684a689d197c000723b390d9" translate="yes" xml:space="preserve">
          <source>The template drives the application so we get HTML level granularity. If we want to make case by case exceptions, the template makes this easy.</source>
          <target state="translated">テンプレートがアプリケーションを駆動するので、HTMLレベルの粒度を得ることができます。ケースバイケースの例外を作りたい場合は、テンプレートがこれを簡単にしてくれます。</target>
        </trans-unit>
        <trans-unit id="ab3b37bfaba497ececec74f637723357bb8a14df" translate="yes" xml:space="preserve">
          <source>The template is in the driving seat.</source>
          <target state="translated">テンプレートは運転席にあります。</target>
        </trans-unit>
        <trans-unit id="dbd42a737715dc284713f8149c27aef45340aa3e" translate="yes" xml:space="preserve">
          <source>The tendency with jQuery is to write great big plugins like lightbox which we then configure by passing in numerous values and options.</source>
          <target state="translated">jQueryの傾向としては、lightboxのような大きなプラグインを書くことがありますが、これは多数の値やオプションを渡して設定します。</target>
        </trans-unit>
        <trans-unit id="a78f488c2b28762effe665517b5bb3bf368fa282" translate="yes" xml:space="preserve">
          <source>The view is the &quot;official record&quot;</source>
          <target state="translated">眺望は「公式記録」である</target>
        </trans-unit>
        <trans-unit id="1c2ed441fd1cd976f573b36eb08871514ae231f0" translate="yes" xml:space="preserve">
          <source>There are a few things wrong with this:</source>
          <target state="translated">これにはいくつか問題があります。</target>
        </trans-unit>
        <trans-unit id="a60b215ea4b528f70a3f3f95afa944b9858d76db" translate="yes" xml:space="preserve">
          <source>These two do the same thing, but in the AngularJS version anyone looking at the template knows what's supposed to happen. Whenever a new member of the development team comes on board, she can look at this and then &lt;em&gt;know&lt;/em&gt; that there is a directive called &lt;code&gt;dropdownMenu&lt;/code&gt; operating on it; she doesn't need to intuit the right answer or sift through any code. The view told us what was supposed to happen. Much cleaner.</source>
          <target state="translated">これら2つは同じことを行いますが、AngularJSバージョンでは、テンプレートを見ている人は何が起こるかを知っています。 開発チームの新しいメンバーが参加すると、彼女はこれを見て、dropdownMenuと呼ばれるディレクティブが動作していることを&lt;em&gt;知る&lt;/em&gt;ことができます。 彼女は正しい答えを直感したり、コードをふるいにかけたりする必要はありません。 見解は私たちに何が起こるはずだったかを教えてくれました。 ずっときれい。</target>
        </trans-unit>
        <trans-unit id="5b12bc82675fe1d062a24637098e0b0d6f018bd6" translate="yes" xml:space="preserve">
          <source>They're apples and oranges. You don't want to compare them. They're two different things. AngularJs has already jQuery lite built in which allows you to perform basic DOM manipulation without even including the full blown jQuery version.</source>
          <target state="translated">リンゴとオレンジだ 比べない方がいい 2つは違うものなのです。AngularJsにはすでにjQuery liteが組み込まれていて、本格的なjQueryバージョンを含まなくても基本的なDOM操作を行うことができます。</target>
        </trans-unit>
        <trans-unit id="56611a6e765ec02b14bdc41b9a14cd86614e07d8" translate="yes" xml:space="preserve">
          <source>Think about how you want to present your models -- your views. Create HTML templates for each view, using the necessary directives to get dynamic databinding.</source>
          <target state="translated">モデルをどのように表示したいかを考えてください。動的データバインディングを取得するために必要なディレクティブを使用して、各ビュー用のHTMLテンプレートを作成します。</target>
        </trans-unit>
        <trans-unit id="27d048b935d814179e7c6a8517808bc5033c1c1e" translate="yes" xml:space="preserve">
          <source>Think about your models. Create services or your own JavaScript objects for those models.</source>
          <target state="translated">モデルについて考えてみましょう。それらのモデルのためにサービスや独自の JavaScript オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="c7f6bac1d5607c8628add234dae8dfe943f7ebea" translate="yes" xml:space="preserve">
          <source>Think less about unobtrusive JavaScript, and instead think in terms of HTML extensions.</source>
          <target state="translated">邪魔にならないJavaScriptのことは考えず、代わりにHTMLの拡張機能のことを考えましょう。</target>
        </trans-unit>
        <trans-unit id="d9ef4e6d01c706c53e91d508343c6fe29cbd9c16" translate="yes" xml:space="preserve">
          <source>Think of the logger we programmed in section 3. Even if we put that in a directive, we &lt;em&gt;still&lt;/em&gt; want to do it the &quot;Angular Way&quot;. It &lt;em&gt;still&lt;/em&gt; doesn't take any DOM manipulation! There are lots of times when DOM manipulation is necessary, but it's a &lt;em&gt;lot&lt;/em&gt; rarer than you think! Before doing DOM manipulation &lt;em&gt;anywhere&lt;/em&gt; in your application, ask yourself if you really need to. There might be a better way.</source>
          <target state="translated">セクション3でプログラムしたロガーについて考えてみましょう。たとえそれをディレクティブに入れても、それを「角度のある方法」で実行したいのです。 &lt;em&gt;それでも&lt;/em&gt; 、DOM操作は一切必要ありません。 DOMの操作が必要な場合はたくさんありますが、思ったよりも&lt;em&gt;ずっと&lt;/em&gt;まれです！ アプリケーションの&lt;em&gt;どこか&lt;/em&gt;でDOM操作を行う前に、本当に必要かどうかを自問してください。 もっと良い方法があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="59fba0d2a6be76b95e9437f56c0b3eb3aeefa64f" translate="yes" xml:space="preserve">
          <source>Third, even assuming jQuery &lt;em&gt;was&lt;/em&gt; required for this directive to work, jqLite (&lt;code&gt;angular.element&lt;/code&gt;) will &lt;em&gt;always&lt;/em&gt; use jQuery if it was loaded! So we needn't use the &lt;code&gt;$&lt;/code&gt; - we can just use &lt;code&gt;angular.element&lt;/code&gt;.</source>
          <target state="translated">3番目に、このディレクティブ&lt;em&gt;が機能&lt;/em&gt;するためにjQuery &lt;em&gt;が&lt;/em&gt;必要であると仮定しても、jqLit​​e（ &lt;code&gt;angular.element&lt;/code&gt; ）は、ロードされている場合は&lt;em&gt;常に&lt;/em&gt; jQuery &lt;em&gt;を&lt;/em&gt;使用します。 したがって、 &lt;code&gt;$&lt;/code&gt; を使用する必要はありません &lt;code&gt;angular.element&lt;/code&gt; のみを使用できます。</target>
        </trans-unit>
        <trans-unit id="e3dd8e8537bb1ca3481ce114c90c34fedaf33ea7" translate="yes" xml:space="preserve">
          <source>This a little messy and a trifle frail. But in AngularJS, we can do this:</source>
          <target state="translated">これは少し乱雑で、少し弱いです。でもAngularJSではこんなことができます。</target>
        </trans-unit>
        <trans-unit id="751b9456fbde65691801d5e0cfad8c4a181a1230" translate="yes" xml:space="preserve">
          <source>This directive can be rewritten (even for very complicated cases!) much more simply like so:</source>
          <target state="translated">このディレクティブは(非常に複雑な場合でも!)もっと簡単にこのように書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="020626cca70fec4fadcd4c85e19094b67d89900d" translate="yes" xml:space="preserve">
          <source>This is a mistake in AngularJS.</source>
          <target state="translated">これはAngularJSの間違いです。</target>
        </trans-unit>
        <trans-unit id="3ee80553c6d3b6490cc47a8c1b3fc30604995853" translate="yes" xml:space="preserve">
          <source>This is a radical inversion of control that takes some getting used to.</source>
          <target state="translated">これは制御の根本的な逆転であり、慣れるまでにはいくつかのことが必要です。</target>
        </trans-unit>
        <trans-unit id="468caea94a05f6a1199b09552c745bdaee04f2e1" translate="yes" xml:space="preserve">
          <source>This is by far one of the most awesome features of AngularJS and cuts out a lot of the need to do the kinds of DOM manipulations I mentioned in the previous section. AngularJS will automatically update your view so you don't have to! In jQuery, we respond to events and then update content. Something like:</source>
          <target state="translated">これはAngularJSの最も素晴らしい機能の一つであり、前のセクションで述べたようなDOM操作を行う必要性の多くをカットしてくれます。AngularJSは自動的にビューを更新してくれるので、その必要はありません。jQueryでは、イベントに反応してコンテンツを更新します。みたいなことをします。</target>
        </trans-unit>
        <trans-unit id="303ce135543d65882737386396b17832595260ae" translate="yes" xml:space="preserve">
          <source>This is normal, you should push through. Angular is worth it.</source>
          <target state="translated">これは普通のことです、押し通すべきです。Angularはそれだけの価値があります。</target>
        </trans-unit>
        <trans-unit id="7b1905aad1d40bfa2426382e15205e07ca50c045" translate="yes" xml:space="preserve">
          <source>This is really part of section 3 on architecture, but it's so important that I'm putting it as its own top-level section.</source>
          <target state="translated">これは本当に建築の第3章の一部なのですが、とても重要なことなので、トップレベルのセクションにしています。</target>
        </trans-unit>
        <trans-unit id="383c8572d2b60f8594b548e872ffb17f8b10ed55" translate="yes" xml:space="preserve">
          <source>This is the clever part. Because the structure of $scope inheritance roughly follows the structure of the DOM, elements have access to their own scope, and any containing scopes seamlessly, all the way up to the global $scope (which is not the same as the global scope).</source>
          <target state="translated">ここが賢いところです。スコープ継承の構造は DOM の構造にほぼ沿っているので、要素は自分のスコープと、それを含むすべてのスコープにシームレスにアクセスでき、グローバルな $scope (グローバルスコープとは同じではありません)に至るまで、すべてのスコープにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="f3085b36e84f35d5704fcffc8d2903ab4191c80b" translate="yes" xml:space="preserve">
          <source>This is the first big difference. To jQuery, your web page is a DOM to be manipulated. To AngularJS, your HTML is code to be compiled. AngularJS reads in your whole web page and literally compiles it into a new web page using its built in compiler.</source>
          <target state="translated">これが最初の大きな違いです。jQueryでは、ウェブページは操作されるDOMです。AngularJSにとって、HTMLはコンパイルされるコードです。AngularJSはウェブページ全体を読み込み、内蔵のコンパイラを使って文字通り新しいウェブページにコンパイルします。</target>
        </trans-unit>
        <trans-unit id="1ad2248d3589183cfe2efd76e3ed9a33f9b96543" translate="yes" xml:space="preserve">
          <source>This makes it much easier to pass data around, and to store data at an appropriate level. If a dropdown is unfolded, only the dropdown $scope needs to know about it. If the user updates their preferences, you might want to update the global $scope, and any nested scopes listening to the user preferences would automatically be alerted.</source>
          <target state="translated">これにより、データの受け渡しが格段に楽になり、適切なレベルでデータを保存することができるようになります。ドロップダウンが展開された場合、ドロップダウンの $scope だけがそれについて知る必要があります。ユーザーが設定を更新した場合、グローバルな $scope を更新したいと思うかもしれませんが、ユーザーの設定を聞いているネストされたスコープは自動的にアラートされます。</target>
        </trans-unit>
        <trans-unit id="a8a3cb7a0749fede326fb94b0ea02af49e57374b" translate="yes" xml:space="preserve">
          <source>This makes wiring things together very easy, and pretty much eliminates any tendency towards spagettification. We have a flat list of components, and AngularJS hands them to us one by one as and when we need them.</source>
          <target state="translated">これにより、物事の配線が非常に簡単になり、スパゲッ ト化の傾向がほとんどなくなります。コンポーネントのフラットなリストがあり、必要に応じてAngularJSがそれを一つずつ渡してくれます。</target>
        </trans-unit>
        <trans-unit id="01c6c85a35ab8aa0b42467c4fd5ea8262061e009" translate="yes" xml:space="preserve">
          <source>This might sound complicated, in fact, once you relax into it, it's like flying. You don't need to create the $scope object, AngularJS instantiates and configures it for you, correctly and appropriately based on your template hierarchy. AngularJS then makes it available to your component using the magic of dependency injection (more on this later).</source>
          <target state="translated">これは複雑に聞こえるかもしれませんが、一度リラックスしてしまえば、まるで空を飛ぶようなものです。AngularJSがテンプレート階層に基づいて正しく適切にインスタンス化して設定してくれます。AngularJSは依存性注入の魔法を使って、それをコンポーネントで利用できるようにします(これについては後で詳しく説明します)。</target>
        </trans-unit>
        <trans-unit id="026686ca92306b82d1e8c15693deeebfe16be490" translate="yes" xml:space="preserve">
          <source>Those are some very nice, but lengthy answers.</source>
          <target state="translated">とても素敵な回答ですが、長くなりました。</target>
        </trans-unit>
        <trans-unit id="b3d3c648ebb51538f239af45aaff5bf2a9ed2172" translate="yes" xml:space="preserve">
          <source>Though I didn't show it here, the data binding is two-way. So those log messages could also be editable in the view just by doing this: &lt;code&gt;&amp;lt;input ng-model=&quot;entry.msg&quot; /&amp;gt;&lt;/code&gt;. And there was much rejoicing.</source>
          <target state="translated">ここでは示していませんが、データバインディングは双方向です。 したがって、これらのログメッセージは、 &lt;code&gt;&amp;lt;input ng-model=&quot;entry.msg&quot; /&amp;gt;&lt;/code&gt; を実行するだけで、ビューで編集することもできます。 そして、多くの喜びがありました。</target>
        </trans-unit>
        <trans-unit id="ea44fd1157e8b164de6f12bfc47356be4ca15c22" translate="yes" xml:space="preserve">
          <source>To answer this question, I want to share my experience on the first enterprise application with AngularJS. These are the most awesome features that Angular provide where we start changing our jQuery mindset and we get the Angular like a framework and not the library.</source>
          <target state="translated">この質問に答えるために、AngularJSを使った最初のエンタープライズアプリケーションでの私の経験を共有したいと思います。これらは、我々はjQueryの考え方を変更して開始し、我々はフレームワークのようなAngularを取得し、ライブラリではなく、Angularが提供する最も素晴らしい機能です。</target>
        </trans-unit>
        <trans-unit id="d960bde17bc0fc487713623ef832bfbb6216643e" translate="yes" xml:space="preserve">
          <source>To describe the &quot;paradigm shift&quot;, I think a short answer can suffice.</source>
          <target state="translated">パラダイムシフト」を説明するには、短い答えで十分だと思います。</target>
        </trans-unit>
        <trans-unit id="74c492c9268c2ba44b4ae9400fc50533ad33c007" translate="yes" xml:space="preserve">
          <source>To help us out with separation of concerns is &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt; (DI). If you come from a server-side language (from &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; to &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;) you're probably familiar with this concept already, but if you're a client-side guy coming from jQuery, this concept can seem anything from silly to superfluous to hipster. But it's not. :-)</source>
          <target state="translated">懸念の分離を支援するのが&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;依存性注入&lt;/a&gt; （DI）です。 サーバー側の言語（ &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt;から&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHPまで&lt;/a&gt; ）を使用している場合は、おそらくこの概念に精通しているでしょうが、jQueryを使用しているクライアント側の人であれば、この概念は愚かなものから不必要なもの、流行に敏感なものまでさまざまです。 。 しかし、そうではありません。 :-)</target>
        </trans-unit>
        <trans-unit id="57c4a51d2a57fb7332a311ca65fbda307945a043" translate="yes" xml:space="preserve">
          <source>To put in another way, in jQuery, you need to think about CSS selectors, that is, where is the &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;td&lt;/code&gt; that has a class or attribute, etc., so that I can get their HTML or color or value, but in AngularJS, you will find yourself thinking like this: what model am I dealing with, I will set the model's value to true. You are not bothering yourself of whether the view reflecting this value is a checked box or resides in a &lt;code&gt;td&lt;/code&gt; element (details you would have often needed to think about in jQuery).</source>
          <target state="translated">別の言い方をすれば、jQueryでは、CSSセレクターについて考える必要があります。つまり、クラスまたは属性などを持つ &lt;code&gt;div&lt;/code&gt; または &lt;code&gt;td&lt;/code&gt; がどこにあるかを考えて、HTMLまたは色または値を取得できるようにします。 AngularJS、このように考えていることに気づくでしょう。どのモデルを扱っているのか、モデルの値をtrueに設定します。 この値を反映するビューがチェックボックスであるか、 &lt;code&gt;td&lt;/code&gt; 要素に存在するか（jQueryでよく考える必要がある詳細）を気にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="f4709eee581374c200f042fc55313a1c370597e0" translate="yes" xml:space="preserve">
          <source>To sum up</source>
          <target state="translated">要約すると</target>
        </trans-unit>
        <trans-unit id="836dd86d4b838ebe7598bd4b4cf3a469296eba00" translate="yes" xml:space="preserve">
          <source>To sum up my experiences:</source>
          <target state="translated">自分の経験をまとめると</target>
        </trans-unit>
        <trans-unit id="ce1ba8a1eb8df452a4296dfeb3f52aabce22bb11" translate="yes" xml:space="preserve">
          <source>Unobtrusive JavaScript with Selectors vs. Declarative Templates</source>
          <target state="translated">セレクタと宣言的テンプレートを使った控えめな JavaScript</target>
        </trans-unit>
        <trans-unit id="7dbc3550a5fc4912024fa7d8d15ebd8dac9e9fc3" translate="yes" xml:space="preserve">
          <source>Until you start to use this, it's hard to explain just what a massive time boon this is. Nothing like AngularJS DI exists inside jQuery.</source>
          <target state="translated">これを使い始めるまでは、これがどれほどの時間の節約になるのかを説明するのは難しい。AngularJS DIのようなものはjQueryの中には存在しません。</target>
        </trans-unit>
        <trans-unit id="955f8bb419dd7b30b67b29f047877ec5da2bfed5" translate="yes" xml:space="preserve">
          <source>Until you want to make a small change.</source>
          <target state="translated">ちょっとした変化をしたいと思うようになるまで</target>
        </trans-unit>
        <trans-unit id="03fc4791bb56c36c6c9fce6cb595b363618e13c3" translate="yes" xml:space="preserve">
          <source>View - Your views are written in HTML. The view is usually not semantic because your data lives in the model.</source>
          <target state="translated">ビュー-ビューはHTMLで書かれています。データはモデル内に存在するため、ビューは通常セマンティックではありません。</target>
        </trans-unit>
        <trans-unit id="5a862f238c06fc71828a9a25732468b79fbb1861" translate="yes" xml:space="preserve">
          <source>What is the biggest difference? What should I stop doing/using; what should I start doing/using instead?</source>
          <target state="translated">最大の違いは何ですか?何を使っているのか、何を使っているのか、何を使っているのか。</target>
        </trans-unit>
        <trans-unit id="0170226ebb8fd23c58004be3a692707980e1d490" translate="yes" xml:space="preserve">
          <source>What should I stop doing/using; What should I start doing/using instead?</source>
          <target state="translated">私は何を使用することを停止する必要があります;私は代わりに何を使用することを開始する必要がありますか?</target>
        </trans-unit>
        <trans-unit id="6e7344707e452d84d6745b34070d9c7734587cd4" translate="yes" xml:space="preserve">
          <source>What this means is that AngularJS reads your entire DOM from top to bottom and treats it as code, literally as instructions to the compiler. As it traverses the DOM, It looks for specific &lt;strong&gt;directives&lt;/strong&gt; (compiler directives) that tell the AngularJS compiler how to behave and what to do. Directives are little objects full of JavaScript which can match against attributes, tags, classes or even comments.</source>
          <target state="translated">これが意味することは、AngularJSがDOM全体を上から下に読み取り、それを文字どおりコンパイラーへの命令としてコードとして扱うということです。 DOMを通過するときに、AngularJSコンパイラーに動作方法と実行方法を指示する特定の&lt;strong&gt;ディレクティブ&lt;/strong&gt; （コンパイラーディレクティブ）を探します。 ディレクティブはJavaScriptでいっぱいの小さなオブジェクトであり、属性、タグ、クラス、さらにはコメントと照合できます。</target>
        </trans-unit>
        <trans-unit id="065885e8affa9b9b626e5ee7819e4774e1e660cf" translate="yes" xml:space="preserve">
          <source>When the Angular compiler determines that a piece of the DOM matches a particular directive, it calls the directive function, passing it the DOM element, any attributes, the current $scope (which is a local variable store), and some other useful bits. These attributes may contain expressions which can be interpreted by the Directive, and which tell it how to render, and when it should redraw itself.</source>
          <target state="translated">AngularコンパイラはDOMの一部が特定のディレクティブにマッチすると判断すると、ディレクティブ関数を呼び出し、DOM要素、属性、現在の$scope(ローカル変数の保存場所)、その他の便利な情報を渡します。これらの属性には、ディレクティブが解釈できる式が含まれていて、どのようにレンダリングするか、いつ再描画すべきかを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="b1f85922f7e91e37e11942af0d06bbc55d4f2b85" translate="yes" xml:space="preserve">
          <source>When we just look at the view, it's not immediately obvious that there is any functionality here. For small applications, that's fine. But for non-trivial applications, things quickly get confusing and hard to maintain.</source>
          <target state="translated">ビューだけ見ても、ここに機能があることはすぐにはわかりません。小規模なアプリケーションでは、それでいいのです。しかし、些細なアプリケーションでは、すぐに混乱してメンテナンスが困難になります。</target>
        </trans-unit>
        <trans-unit id="f1562ae865a8c76b7015478b8cdbdfe3f9de7697" translate="yes" xml:space="preserve">
          <source>When you first see this you might be tempted to write AngularJS off as old school intrusive JavaScript (like I did at first). In fact, AngularJS does not play by those rules. In AngularJS, your HTML5 is a template. It is compiled by AngularJS to produce your web page.</source>
          <target state="translated">最初にこれを見たときは、AngularJSを昔ながらの押し付けがましいJavaScriptだと書きたくなるかもしれません(私も最初はそうでした)。実際には、AngularJSはそのようなルールに従っていません。AngularJSでは、HTML5はテンプレートです。HTML5はAngularJSによってコンパイルされ、ウェブページを作成します。</target>
        </trans-unit>
        <trans-unit id="7f3d35681fa2c63c5104c34b879516df9d536a1b" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;jQuery&lt;/strong&gt; you tell the DOM what needs to happen, step by step. With &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;&lt;/strong&gt; you describe what results you want but not how to do it. More on this &lt;a href=&quot;https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming&quot;&gt;here&lt;/a&gt;. Also, check out Mark Rajcok's answer.</source>
          <target state="translated">&lt;strong&gt;jQueryを使用&lt;/strong&gt;すると、何が必要かを段階的にDOMに伝えます。 &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJSを使用&lt;/a&gt;&lt;/strong&gt;すると、どのような結果が必要かを記述できますが、その方法は記述できません。 詳細は&lt;a href=&quot;https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming&quot;&gt;こちら&lt;/a&gt; 。 また、Mark Rajcokの回答もご覧ください。</target>
        </trans-unit>
        <trans-unit id="fc839325c446b08cf5a65d8819d89d6bb3164e33" translate="yes" xml:space="preserve">
          <source>With AngularJS you have your model (JavaScript objects you are already used to) and the value of the model tells you about the model (obviously) and about the view, and an operation on the model automatically propagates to the view, so you don't have to think about it. You will find yourself in AngularJS no longer finding things in the DOM.</source>
          <target state="translated">AngularJSではモデル(すでに慣れ親しんだJavaScriptオブジェクト)があり、モデルの値がモデルとビューについて教えてくれます(当然ですが)。AngularJSではもはやDOMの中にあるものを見つけることができなくなっていることに気づくでしょう。</target>
        </trans-unit>
        <trans-unit id="4652c10e282176714fe41ae1e85eb5402efa7939" translate="yes" xml:space="preserve">
          <source>With jQuery your HTML page should contain semantic meaningful content. If the JavaScript is turned off (by a user or search engine) your content remains accessible.</source>
          <target state="translated">jQuery を使用すると、HTML ページに意味のあるコンテンツが含まれている必要があります。JavaScript が(ユーザーや検索エンジンによって)オフになっている場合、コンテンツはアクセス可能なままです。</target>
        </trans-unit>
        <trans-unit id="ca1706ec5fb5ac78f5fde18c0d8566fbe135cc3c" translate="yes" xml:space="preserve">
          <source>You can do a lot with jQuery without knowing about how JavaScript prototypal inheritance works. When developing AngularJS applications, you will avoid some common pitfalls if you have a good understanding of JavaScript inheritance. Recommended reading: &lt;a href=&quot;https://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs&quot;&gt;What are the nuances of scope prototypal / prototypical inheritance in AngularJS?&lt;/a&gt;</source>
          <target state="translated">JavaScriptプロトタイプの継承がどのように機能するかを知らなくても、jQueryで多くのことができます。 AngularJSアプリケーションを開発する場合、JavaScriptの継承を十分に理解していれば、いくつかの一般的な落とし穴を回避できます。 推奨読書： &lt;a href=&quot;https://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs&quot;&gt;AngularJSのスコーププロトタイプ/プロトタイプ継承のニュアンスは何ですか？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3bccb18f2df39489cf9c94bdc521ad8c56f6483" translate="yes" xml:space="preserve">
          <source>You get simple code reuse, if you want to write another application based on Flickr, you can just include the Flickr module and voila, you have access to all your Flickr related functions in your new application.</source>
          <target state="translated">Flickrをベースにした別のアプリケーションを書きたい場合は、Flickrモジュールをインクルードするだけで、新しいアプリケーション内のすべてのFlickr関連の関数にアクセスできるようになります。</target>
        </trans-unit>
        <trans-unit id="07a633bd9c67d80494b78137069dcf9bff6f8d9c" translate="yes" xml:space="preserve">
          <source>You may use it on existing applications where you are already using pure jQuery. However, if you want to fully take advantage of the AngularJS features you may consider coding the server side using a &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; approach.</source>
          <target state="translated">純粋なjQueryをすでに使用している既存のアプリケーションで使用できます。 ただし、AngularJSの機能を十分に活用したい場合は、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt;アプローチを使用してサーバー側をコーディングすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="93e48c750ccd396d3473070f7e54269ec34e6751" translate="yes" xml:space="preserve">
          <source>You'll often hear &quot;only do DOM manipulation in a directive&quot;. &lt;strong&gt;This is a necessity.&lt;/strong&gt; Treat it with due deference!</source>
          <target state="translated">「ディレクティブではDOM操作のみを行う」とよく耳にします。 &lt;strong&gt;これは必需品です。&lt;/strong&gt; 敬意をもって扱いましょう！</target>
        </trans-unit>
        <trans-unit id="e9d5a9c89b6ee27e430aeadc83c97fafeb311b2e" translate="yes" xml:space="preserve">
          <source>Your template drives your application. It's treated as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL&lt;/a&gt;. You write AngularJS components, and AngularJS will take care of pulling them in and making them available at the right time based on the structure of your template. This is very different to a standard &lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt; pattern, where the template is just for output.</source>
          <target state="translated">テンプレートがアプリケーションを動かします。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL&lt;/a&gt;として扱われます。 AngularJSコンポーネントを作成すると、AngularJSがコンポーネントを取り込み、テンプレートの構造に基づいて適切なタイミングで利用できるようにします。 これは、テンプレートが出力専用である標準の&lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt;パターンとは大きく異なります。</target>
        </trans-unit>
        <trans-unit id="f63336c8b68dbd54d77ba260a5e6c9141be9ff84" translate="yes" xml:space="preserve">
          <source>Your template should be declarative; its meaning should be clear simply by reading it. We use custom attributes with meaningful names. We make up new HTML elements, again with meaningful names. A designer with minimal HTML knowledge and no coding skill can read your AngularJS template and understand what it is doing. He or she can make modifications. &lt;em&gt;This is the Angular way.&lt;/em&gt;</source>
          <target state="translated">テンプレートは宣言型である必要があります。 それを読むだけでその意味が明確になるはずです。 わかりやすい名前のカスタム属性を使用します。 ここでも、意味のある名前で新しいHTML要素を作成します。 HTMLの知識が最小限で、コーディングスキルのないデザイナーは、AngularJSテンプレートを読んで、それが何をしているかを理解できます。 彼または彼女は変更を加えることができます。 &lt;em&gt;これがAngularの方法です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bdf7e60e32dde216fb6e902f1792e6d04b0b4e9" translate="yes" xml:space="preserve">
          <source>and there is one more thing, that's the directive. It's an attribute  you can attach to any DOM element and you can go nuts with jQuery within it without worrying about your jQuery ever conflicts with AngularJs components or messes up with its architecture.</source>
          <target state="translated">そしてもう一つ、ディレクティブがあります。これはどんなDOM要素にもアタッチできる属性で、jQueryがAngularJsのコンポーネントと衝突したりアーキテクチャが混乱したりすることを気にせずに、その中でjQueryを使って暴れまわることができます。</target>
        </trans-unit>
        <trans-unit id="00853d73f19844948fadbc48d500f997c46f7ee4" translate="yes" xml:space="preserve">
          <source>jQuery</source>
          <target state="translated">jQuery</target>
        </trans-unit>
        <trans-unit id="be925b4f423bcada24aaecc3aafd5c04280ae11d" translate="yes" xml:space="preserve">
          <source>jQuery employs &lt;a href=&quot;http://en.wikipedia.org/wiki/Unobtrusive_JavaScript&quot;&gt;unobtrusive JavaScript&lt;/a&gt; - behavior (JavaScript) is separated from the structure (HTML).</source>
          <target state="translated">jQueryは&lt;a href=&quot;http://en.wikipedia.org/wiki/Unobtrusive_JavaScript&quot;&gt;控えめなJavaScriptを&lt;/a&gt;採用-動作（JavaScript）は構造（HTML）から分離されています。</target>
        </trans-unit>
        <trans-unit id="c320142ede798313f44c3d11d76a83ae93eda792" translate="yes" xml:space="preserve">
          <source>jQuery gives you a toolkit for selecting arbitrary bits of the DOM and making ad-hoc changes to them. You can do pretty much anything you like piece by piece.</source>
          <target state="translated">jQuery は、DOM の任意のビットを選択して、その場しのぎの変更を行うためのツールキットです。好きなことを1つ1つやっていくことができます。</target>
        </trans-unit>
        <trans-unit id="a9491d0d475183db24d559659151458a8832e918" translate="yes" xml:space="preserve">
          <source>jQuery is a DOM manipulation library.</source>
          <target state="translated">jQueryはDOM操作ライブラリです。</target>
        </trans-unit>
        <trans-unit id="dc5ccb5632110fdd3b6daae0577b2656f4f69591" translate="yes" xml:space="preserve">
          <source>jQuery is a way to make programming JavaScript in the browser easier. Shorter, cross-browser commands, etc.</source>
          <target state="translated">jQueryは、ブラウザでJavaScriptを簡単にプログラミングできるようにするためのものです。より短い、クロスブラウザコマンドなど。</target>
        </trans-unit>
        <trans-unit id="18f057b6ceb40d6c2c4a68a9d1752b11d2e478bc" translate="yes" xml:space="preserve">
          <source>jQuery is all about DOM manipulation. It solves all the cross browser pain otherwise you will have to deal with but it's not a framework that allows you to divide your app into components like AngularJS.</source>
          <target state="translated">jQueryはDOMの操作に特化しています。そうでなければ対処しなければならないクロスブラウザの苦痛をすべて解決してくれますが、AngularJSのようにアプリをコンポーネントに分割することができるフレームワークではありません。</target>
        </trans-unit>
        <trans-unit id="b8a1fbe4c24f3cd32559fc40d013cf05b48575a8" translate="yes" xml:space="preserve">
          <source>jQuery is typically applied unobtrusively. Your JavaScript code is linked in the header (or the footer), and this is the only place it is mentioned. We use selectors to pick out bits of the page and write plugins to modify those parts.</source>
          <target state="translated">jQuery は通常、目立たないように適用されます。JavaScript コードはヘッダー(またはフッター)でリンクされており、ここでしか言及されていません。私たちはセレクタを使用してページの一部を選択し、それらの部分を修正するためのプラグインを書きます。</target>
        </trans-unit>
        <trans-unit id="970e2a9590ad405940e9e253b4e0d66959d31936" translate="yes" xml:space="preserve">
          <source>jQuery makes ridiculously long JavaScript commands like &lt;code&gt;getElementByHerpDerp&lt;/code&gt; shorter and cross-browser.</source>
          <target state="translated">jQueryは、 &lt;code&gt;getElementByHerpDerp&lt;/code&gt; のような途方もなく長いJavaScriptコマンドをより短くしてクロスブラウザにします。</target>
        </trans-unit>
        <trans-unit id="c7b8d7c0d6361934bbf52868690dfdb5012d95ae" translate="yes" xml:space="preserve">
          <source>jQuery says very little about how you should organise your code. AngularJS has opinions.</source>
          <target state="translated">jQueryはコードをどのように整理すべきかについてはほとんど書いていません。AngularJSには意見があります。</target>
        </trans-unit>
        <trans-unit id="34f8968c02f9b2effb99adc9f1eadb7ef80c5c90" translate="yes" xml:space="preserve">
          <source>jQuery: you think a lot about 'QUERYing the &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;' for DOM elements and doing something.</source>
          <target state="translated">jQuery：DOM要素の「 &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;のクエリ」と、何かを行うことについて多くのことを考えています。</target>
        </trans-unit>
        <trans-unit id="5ba0c567dacd0527890e40d7b7790df6aec5ca39" translate="yes" xml:space="preserve">
          <source>w00t!</source>
          <target state="translated">w00t!</target>
        </trans-unit>
        <trans-unit id="c546eb5a1fdcd9672da789e9684f30280d159a04" translate="yes" xml:space="preserve">
          <source>will output the user name in a paragraph. It's a live binding, so if the &lt;code&gt;$scope.user.name&lt;/code&gt; value is updated, the template will update too.</source>
          <target state="translated">ユーザー名を段落に出力します。 これはライブバインディングなので、 &lt;code&gt;$scope.user.name&lt;/code&gt; 値が更新されると、テンプレートも更新されます。</target>
        </trans-unit>
        <trans-unit id="cbda61a42cf4628d5b234a95997da65ed8079da7" translate="yes" xml:space="preserve">
          <source>“Thinking in AngularJS” if I have a jQuery background</source>
          <target state="translated">&quot;AngularJSで考える&quot; jQueryの背景があれば</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
