<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1458633">
    <body>
      <group id="1458633">
        <trans-unit id="a58ae6e028aa9f56e0b393f9b27512d036863b7f" translate="yes" xml:space="preserve">
          <source>--- as in ---</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;---에서와 같이 ---&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a61acece68b9a4523517acd4c2932a44347a36f6" translate="yes" xml:space="preserve">
          <source>---also---</source>
          <target state="translated">---also---</target>
        </trans-unit>
        <trans-unit id="04039dd8c765ea73c439eaf667216b755095fcbb" translate="yes" xml:space="preserve">
          <source>---or---</source>
          <target state="translated">---or---</target>
        </trans-unit>
        <trans-unit id="e239b2f0cb4457085cc5a0a4c2e32b9d1078ef93" translate="yes" xml:space="preserve">
          <source>0.1 in binary floating points is like 1/3 in decimal (i.e. 0.3333333333333... forever), there's just no accurate way to handle it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 부동 소수점의 0.1은 소수점의 1/3과 같습니다 (즉, 0.3333333333333 ... 영원히), 그것을 처리하는 정확한 방법은 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc9246ffda94554579941bcde9c4edc49c446d01" translate="yes" xml:space="preserve">
          <source>0.6 * 3 it's awesome!))
For me this works fine:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;0.6 * 3 대단합니다!)) 나에게 이것은 잘 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3cc69294c19b6465378465752174c2fdb6cba03d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://mikemcl.github.io/decimal.js/&quot;&gt;decimal.js&lt;/a&gt;, &lt;a href=&quot;http://mikemcl.github.io/big.js/&quot;&gt;big.js&lt;/a&gt; or &lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt; can be used to avoid floating-point manipulation problems in Javascript:</source>
          <target state="translated">&lt;a href=&quot;http://mikemcl.github.io/decimal.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;decimal.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://mikemcl.github.io/big.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;big.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bignumber.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 사용하여 Javascript에서 부동 소수점 조작 문제를 피할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8da0f03b27353c36e89a7f463f0f26edc030610" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/MikeMcl/bignumber.js&quot;&gt;BigNumbers&lt;/a&gt; solved the problem, but introduced another, somewhat ironic, problem. When trying to load 8.5 into BigNumbers I was informed that it was really 8.4999&amp;hellip; and had more than 15 significant digits. This meant BigNumbers could not accept it (I believe I mentioned this problem was somewhat ironic).</source>
          <target state="translated">&lt;a href=&quot;https://github.com/MikeMcl/bignumber.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigNumbers&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는이 문제를 해결했지만 다소 아이러니 한 또 다른 문제를 소개했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigNumbers에 8.5를로드하려고 할 때 실제로는 8.4999이고 15 자리 이상의 유효 숫자가 있다는 알림을 받았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 BigNumbers가 그것을 받아 들일 수 없다는 것을 의미했습니다 (나는이 문제가 다소 역설적이라고 언급했습니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ce0db9bea2fbfefa7b87bc4a1388e1cc35b89b2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Better avoid having the problem&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 나은 문제를 피하십시오&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92f696b23971dfa0a68250122f4ece948aba6e57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discrete functions or operators (like modula)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이산 함수 또는 연산자 (모듈라와 같은)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4abe6058e1666fa25cd7562739ff8d998c39bfd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input and output for floating point values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부동 소수점 값의 입력 및 출력&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a09079fe3f3cae3b532870bda64e5af716b17478" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Problem&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="241fda0675cef6227b22533c7fc0f61068a79a12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What can I do to avoid this problem?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 문제를 피하려면 어떻게해야합니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce9300b41e15ad2d19e7ece35b5fc60757beb39e" translate="yes" xml:space="preserve">
          <source>A (very quick) solution looks something like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(매우 빠른) 솔루션은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="33a2b5e174fcca7358ea0f736487477bfc1ffec7" translate="yes" xml:space="preserve">
          <source>A JavaScript library for arbitrary-precision decimal and non-decimal arithmetic.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;임의 정밀도 10 진수 및 비소수 산술을위한 JavaScript 라이브러리.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdc228a5887707e65f81fcb3dccdf34e8acdcbf5" translate="yes" xml:space="preserve">
          <source>A small, fast JavaScript library for arbitrary-precision decimal arithmetic. The little sister to bignumber.js.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;임의 정밀도 10 진수 산술을위한 작고 빠른 JavaScript 라이브러리입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bignumber.js의 여동생.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="24ab8c562d1e296af3223a66eb9647aaf3256c06" translate="yes" xml:space="preserve">
          <source>A special check/correction on intermediate calculation results, immediately after applying the discrete function or operator might be required.
For a specific case (modula operator), see my answer on question: &lt;a href=&quot;https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/45346570#45346570&quot;&gt;Why does modulus operator return fractional number in javascript?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이산 함수 또는 연산자를 적용한 직후에 중간 계산 결과에 대한 특별한 점검 / 수정이 필요할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특정 경우 ( &lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/45346570#45346570&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모듈러스 연산자)&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 대한 질문에 대한 대답 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 모듈러스 연산자가 Javascript에서 소수를 반환하는 이유는 무엇입니까?를 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e147f80845946fb26fa310a4077a3d65e96df84" translate="yes" xml:space="preserve">
          <source>Add a small value to the outputs before rounding/formatting them which is smaller than or equal to 1/4 of the desired precision and bigger than the maximum expected error caused by rounding errors on input and during calculation. If that is not possible the combination of the precision of the used data type isn't enough to deliver the desired output precision for your calculation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반올림 / 포맷하기 전에 원하는 정밀도의 1/4보다 작고 입력 및 반올림 오차로 인한 최대 예상 오차보다 큰 출력에 작은 값을 추가하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 가능하지 않은 경우 사용 된 데이터 유형의 정밀도 조합은 계산에 원하는 출력 정밀도를 제공하기에 충분하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ec5991d0491a50ed072932cfd75f49e54ea8673" translate="yes" xml:space="preserve">
          <source>An arbitrary-precision Decimal type for JavaScript.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaScript에 대한 임의 정밀도 10 진수 유형입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="22b59d0bd4142a0ac4d0949aed1e7a4055828148" translate="yes" xml:space="preserve">
          <source>Are you only performing multiplication?  If so then you can use to your advantage a neat secret about decimal arithmetic.  That is that &lt;code&gt;NumberOfDecimals(X) + NumberOfDecimals(Y) = ExpectedNumberOfDecimals&lt;/code&gt;. That is to say that if we have &lt;code&gt;0.123 * 0.12&lt;/code&gt; then we know that there will be 5 decimal places because &lt;code&gt;0.123&lt;/code&gt; has 3 decimal places and &lt;code&gt;0.12&lt;/code&gt; has two. Thus if JavaScript gave us a number like &lt;code&gt;0.014760000002&lt;/code&gt; we can safely round to the 5th decimal place without fear of losing precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;곱셈 만 수행하고 있습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇다면 십진 산술에 대한 깔끔한 비밀을 유리하게 사용할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;NumberOfDecimals(X) + NumberOfDecimals(Y) = ExpectedNumberOfDecimals&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 우리가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.123 * 0.12&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.123&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 3 개의 소수점 자리를, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.12&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 2를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가지고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있기 때문에 소수점 5 자리가 있다는 것을 알 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 JavaScript가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.014760000002&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같은 숫자를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주면&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 정밀도를 잃을 염려없이 소수점 5 자리로 안전하게 반올림 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c873412f7d33e43d993fd7170b2548732ae1976" translate="yes" xml:space="preserve">
          <source>Because the rounding adds an error which can cause the total error to be more then half of the desired precision, the output should be corrected based on expected precision of inputs and desired precision of output. You should</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반올림으로 인해 전체 오차가 원하는 정밀도의 절반 이상이 될 수있는 오차가 발생하므로 예상되는 입력 정밀도와 원하는 출력 정밀도를 기반으로 출력을 수정해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은해야&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5292ab4ae2ac6f1f1671909362adce21a8d03efb" translate="yes" xml:space="preserve">
          <source>Big.js</source>
          <target state="translated">Big.js</target>
        </trans-unit>
        <trans-unit id="d66c7d4989fa88e8c1967fe5c794a60a171e4bb4" translate="yes" xml:space="preserve">
          <source>Does anyone have a good solution so that in such case I get the correct result &lt;code&gt;0.02&lt;/code&gt;? I know there are functions like &lt;code&gt;toFixed&lt;/code&gt; or rounding would be another possibility, but I'd like to really have the whole number printed without any cutting and rounding. Just wanted to know if one of you has some nice, elegant solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 경우에 올바른 결과 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.02&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 얻을 수있는 좋은 해결책이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니까? &lt;/font&gt;&lt;/font&gt; &lt;code&gt;toFixed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 rounding &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;과 같은 기능 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 또 다른 가능성이 있다는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;것을 알고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있지만 실제로 절단 및 반올림없이 정수를 인쇄하고 싶습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신 중 하나가 멋지고 우아한 해결책을 가지고 있는지 알고 싶었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="c341e94c1b98a43dae4389df37cf0aada6e3fee0" translate="yes" xml:space="preserve">
          <source>Fix:</source>
          <target state="translated">Fix:</target>
        </trans-unit>
        <trans-unit id="4056e753845c8a8fd4a301c49e68620745f4fc19" translate="yes" xml:space="preserve">
          <source>Floating point can't store all decimal values exactly. So when using floating point formats there will always be rounding errors on the input values.
The errors on the inputs of course results on errors on the output.
In case of a discrete function or operator there can be big differences on the output around the point where the function or operator is discrete.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부동 소수점은 모든 소수 값을 정확하게 저장할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 부동 소수점 형식을 사용하면 입력 값에 항상 반올림 오류가 발생합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 입력의 오류는 출력의 오류를 초래합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;불연속 기능 또는 작동 자의 경우 기능 또는 작동자가 불연속 인 지점 주변에서 출력에 큰 차이가있을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aeb92746f89ae3b376318f5f1b422a3f62e2d554" translate="yes" xml:space="preserve">
          <source>For the mathematically inclined: &lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수학적으로 기울어 진 경우 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd67f72c65d9c61d8d2450191828d1627d8d5146" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://floating-point-gui.de/&quot;&gt;Floating-Point Guide&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로부터 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://floating-point-gui.de/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부동 소수점 가이드&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3aade10752679fef5dd7ea1f4d15d9b02c98c3e" translate="yes" xml:space="preserve">
          <source>Have a look at &lt;a href=&quot;http://en.wikipedia.org/wiki/Fixed-point_arithmetic&quot;&gt;Fixed-point arithmetic&lt;/a&gt;. It will probably solve your problem, if the range of numbers you want to operate on is small (eg, currency). I would round it off to a few decimal values, which is the simplest solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Fixed-point_arithmetic&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;고정 소수점 산술을&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 살펴보십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;조작하려는 숫자 범위가 작은 경우 (예 : 통화) 문제를 해결할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소수로 소수를 반올림하여 가장 간단한 해결책입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b83cbd138fff23024c94f3b4bad484eafc94fff3" translate="yes" xml:space="preserve">
          <source>Here's some code using BigNumber:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigNumber를 사용하는 코드는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee81411664de7bb4caaa5929799806ccb568b7b0" translate="yes" xml:space="preserve">
          <source>How to deal with floating point number precision in JavaScript</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaScript에서 부동 소수점 숫자 정밀도를 처리하는 방법&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c8df9c129f17bfcc385ced7492e4b82ccec5e93a" translate="yes" xml:space="preserve">
          <source>I definitely recommend using a tested library like &lt;a href=&quot;https://github.com/guipn/sinful.js/blob/master/sinful.js&quot;&gt;SinfulJS&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;https://github.com/guipn/sinful.js/blob/master/sinful.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SinfulJS&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같은 테스트 라이브러리를 사용하는 것이 좋습니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a853ef4121663b373e78e17939e2d11ca4c83986" translate="yes" xml:space="preserve">
          <source>I had a nasty rounding error problem with mod 3. Sometimes when I should get 0 I would get .000...01. That's easy enough to handle, just test for &amp;lt;= .01. But then sometimes I would get 2.99999999999998. OUCH!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mod 3에서 불쾌한 반올림 오류 문제가 발생했습니다. 때로는 0을 받아야 할 때 .000 ... 01을 얻습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;lt;= .01을 테스트하기 만하면됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 때로는 2.99999999999998을 얻습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아야!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9f9d35c2b34cb9f3475700d017c4d1185419e3c" translate="yes" xml:space="preserve">
          <source>I have the following dummy test script:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같은 더미 테스트 스크립트가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ba55b9d67e3d6448720f1cc36080a3e415841b6d" translate="yes" xml:space="preserve">
          <source>I like Pedro Ladaria's solution and use something similar.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 Pedro Ladaria의 솔루션을 좋아하고 비슷한 것을 사용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="11e4c0a4884796e3eaf68f789faed2b433d2248f" translate="yes" xml:space="preserve">
          <source>I'm finding &lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;BigNumber.js&lt;/a&gt; meets my needs.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigNumber.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 내 요구를 충족시키는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;것으로 나타 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;났습니다&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="970fc9047311aa9e995057a784ac862b33e2831e" translate="yes" xml:space="preserve">
          <source>If the first point really applies to you, use &lt;a href=&quot;https://web.archive.org/web/20150511085914/https://github.com/dtrebbien/BigDecimal.js&quot;&gt;BigDecimal for JavaScript&lt;/a&gt;, which is not elegant at all, but actually solves the problem rather than providing an imperfect workaround.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫 번째 요점이 실제로 적용되는 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전혀 우아하지는 않지만 불완전한 해결 방법을 제공하는 대신 문제를 해결하는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://web.archive.org/web/20150511085914/https://github.com/dtrebbien/BigDecimal.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaScript에 BigDecimal for JavaScript를&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f6e317ec81ade40f1e9e97cedccdc40678ac775d" translate="yes" xml:space="preserve">
          <source>If you are doing if-s/comparisons and don't want to cut of then you also need a small constant, usually called eps, which is one decimal place higher than max expected error. Say that your cut-off is last two decimals - then your eps has 1 at the 3rd place from the last (3rd least significant) and you can use it to compare whether the result is within eps range of expected (0.02 -eps &amp;lt; 0.1*0.2 &amp;lt; 0.02 +eps).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;if-s / comparisons를하고 있고 잘라 내고 싶지 않으면 보통 eps라고 불리는 작은 상수가 필요합니다.이 상수는 최대 예상 오차보다 소수점 이하 1 자리입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컷오프가 소수점 이하 두 자릿수라고 가정하면 eps는 마지막 3 번째 자리 (1 번째 중요도)에서 1을 가지며 결과를 예상 eps 범위 (0.02 -eps &amp;lt;0.1) 내에 있는지 비교하는 데 사용할 수 있습니다. * 0.2 &amp;lt;0.02 + eps).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3fb645f140e6b7fba5cf80b199367d878602c09e" translate="yes" xml:space="preserve">
          <source>If you have no decimal datatype available, an alternative is to work
  with integers, e.g. do money
  calculations entirely in cents. But
  this is more work and has some
  drawbacks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용 가능한 10 진수 데이터 유형이없는 경우 다른 방법은 정수를 사용하는 것입니다 (예 : 돈 계산을 센트 단위로 수행). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 이것은 더 많은 작업이며 몇 가지 단점이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f9a231822977eedb774b63cec0c1a0376b172063" translate="yes" xml:space="preserve">
          <source>If you just don&amp;rsquo;t want to see all those extra decimal places: simply
  format your result rounded to a fixed
  number of decimal places when
  displaying it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;추가 소수 자릿수를 모두 표시하지 않으려면 결과를 표시 할 때 고정 소수점 이하 자릿수로 반올림하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42fc965d2e7933faeb52ad0042fa265db75c529f" translate="yes" xml:space="preserve">
          <source>If you really need your results to add up exactly, especially when you
  work with money: use a special decimal
  datatype.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히 돈을 다룰 때 결과를 정확하게 합치려면 특별한 10 진수 데이터 유형을 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d5f63b24009028d7cd1e82a2dcdac457c43a8f72" translate="yes" xml:space="preserve">
          <source>If you're dealing with floats &lt;em&gt;always&lt;/em&gt; expect small rounding errors, so you'll also always have to round the displayed result to something sensible. In return you get very very fast and powerful arithmetic because all the computations are in the native binary of the processor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;플로트를 처리하는 경우 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;항상&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 작은 반올림 오류가 예상되므로 항상 표시된 결과를 적절한 것으로 반올림해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 계산이 프로세서의 기본 바이너리에 있기 때문에 매우 빠르고 강력한 산술을 얻을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76df916b62840bf387c4d5f679f0bb56b6c112cd" translate="yes" xml:space="preserve">
          <source>In this case:</source>
          <target state="translated">이 경우 :</target>
        </trans-unit>
        <trans-unit id="dc35e05387823f39d75255f34cb157621bf93da5" translate="yes" xml:space="preserve">
          <source>It has good &lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;documentation&lt;/a&gt; and the author is very diligent responding to feedback.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문서&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 훌륭하고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;저자는 피드백에 부지런히 응답합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c0dbedb40544f549861aab974817b42583eb09a3" translate="yes" xml:space="preserve">
          <source>It is often more efficient to avoid these problems by using data types (integer or fixed point formats) for calculations like this which can store the expected input without rounding errors.
An example of that is that you should never use floating point values for financial calculations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반올림 오류없이 예상 입력을 저장할 수있는 이와 같은 계산에 데이터 유형 (정수 또는 고정 소수점 형식)을 사용하여 이러한 문제를 피하는 것이 종종 더 효율적입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 예로 금융 계산에 부동 소수점 값을 사용해서는 안됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="448607d7ba223d62964e7cd11aa31257cd4a3f9c" translate="yes" xml:space="preserve">
          <source>Many systems omit working with decimals this way. That is the reason why many systems work with cents (as integer) instead of dollars/euro's (as floating point).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 시스템에서 이런 식으로 소수 자릿수를 생략합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 많은 시스템이 달러 / 유로 대신에 부동 소수점으로 센트 (정수)로 작동하는 이유입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d6f9a91ba210d6d0d8e1736e610c0911b4b3dfe" translate="yes" xml:space="preserve">
          <source>Most of the time the solution is not to switch to fixed-point arithmetic, mainly because it's much slower and 99% of the time you just don't need the accuracy. If you're dealing with stuff that does need that level of accuracy (for instance financial transactions) Javascript probably isn't the best tool to use anyway (as you've want to enforce the fixed-point types a static language is probably better).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 경우 솔루션은 고정 소수점 산술로 전환하지 않습니다. 주로 정확도가 필요하지 않은 시간의 99 %가 훨씬 느리기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;금융 거래와 같이 그 정도의 정확성이 필요한 것을 다루는 경우 Javascript는 어쨌든 사용하기에 가장 좋은 도구가 아닙니다 (고정 소수점 유형을 적용하려는 경우 정적 언어가 더 낫습니다) ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9bf7090b248473b9077c1c5f6937631d47c5fe07" translate="yes" xml:space="preserve">
          <source>Note that the first point only applies if you really need specific precise &lt;em&gt;decimal&lt;/em&gt; behaviour. Most people don't need that, they're just irritated that their programs don't work correctly with numbers like 1/10 without realizing that they wouldn't even blink at the same error if it occurred with 1/3.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫 번째 요점은 특정한 정확한 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;십진수&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 동작 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 실제로 필요한 경우에만 적용됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 사람들은 그것을 필요로하지 않으며 단지 1/3에서 발생하면 동일한 오류로 깜박이지 않을 것이라는 사실을 깨닫지 않고 1/10과 같은 숫자로 프로그램이 올바르게 작동하지 않는다는 것에 자극을 받았습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb097215ec09eb0024375e4ae22d1c146c281243" translate="yes" xml:space="preserve">
          <source>Note: When dealing with 32 or 64 bit floats, you should use toPrecision(7) and toPrecision(15) for best results.  See &lt;a href=&quot;https://stackoverflow.com/questions/28045787/how-many-decimal-places-does-the-primitive-float-and-double-support&quot;&gt;this question&lt;/a&gt; for info as to why.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참고 : 32 비트 또는 64 비트 부동 소수점을 처리 할 때 최상의 결과를 얻으려면 toPrecision (7) 및 toPrecision (15)을 사용해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이유에 대한 정보는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/28045787/how-many-decimal-places-does-the-primitive-float-and-double-support&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 질문&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="11195d73ee275b234990d7d7cb1e88d873fcca46" translate="yes" xml:space="preserve">
          <source>Notice that for the general purpose use, this behavior is likely to be acceptable.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적인 용도로는이 동작이 허용 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3290637a00912e04380d8c64be613af76228d4bf" translate="yes" xml:space="preserve">
          <source>Numerical errors accumulate with every further operation and if you don't cut it off early it's just going to grow. Numerical libraries which present results that look clean simply cut off the last 2 digits at every step, numerical co-processors also have a &quot;normal&quot; and &quot;full&quot; lenght for the same reason. Cuf-offs are cheap for a processor but very expensive for you in a script (multiplying and dividing and using pov(...)). Good math lib would provide floor(x,n) to do the cut-off for you.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;추가 오류가 발생할 때마다 수치 오류가 누적되며 일찍 중단하지 않으면 점점 커질 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;깨끗하게 보이는 결과를 제공하는 숫자 라이브러리는 모든 단계에서 마지막 2 자리를 간단히 잘라냅니다. 숫자 보조 프로세서도 같은 이유로 &quot;일반&quot;및 &quot;전체&quot;길이를 갖습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuf-off는 프로세서에서는 저렴하지만 스크립트에서 pov (...)를 곱하고 나누고 사용하는 것은 매우 비쌉니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;좋은 수학 라이브러리는 floor (x, n)을 제공하여 컷오프를 수행합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2839401e766a935656ba07eb6b9d6b7c03f3cac8" translate="yes" xml:space="preserve">
          <source>Of course that won't help much with irrational numbers. But you may want to optimize your computations in the way they will cause the least problem (e.g. detecting situations like &lt;code&gt;sqrt(3)^2)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 그것은 비이성적 인 숫자에는별로 도움이되지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 가장 문제가 적은 방식으로 계산을 최적화 할 수 있습니다 (예 : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sqrt(3)^2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같은 상황 감지 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63652065953c408e91fa63939df078c88343bbe4" translate="yes" xml:space="preserve">
          <source>Of course, otherwise I'll round to some 10 digits or so.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 그렇지 않으면 약 10 자리 정도로 반올림합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="56ceded875df16b30aabedd0be6143d73e5f2da8" translate="yes" xml:space="preserve">
          <source>Output using the following function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 기능을 사용한 출력 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a87200547de52dcba232ee8140c48ce625448de" translate="yes" xml:space="preserve">
          <source>Pay attention to the output &lt;code&gt;toFixedCurrency(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;toFixedCurrency(x)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 출력에주의하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7ccc77c464d68ec4d4d9bc39d5016a33fe1860ca" translate="yes" xml:space="preserve">
          <source>Round inputs to the expected precision or make sure no values can be entered with higher precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입력을 예상 정밀도로 반올림하거나 더 높은 정밀도로 값을 입력 할 수 없도록합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fea441daf71749c24a14635d2315d7865e68e5f8" translate="yes" xml:space="preserve">
          <source>Simple solution to ironic problem:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아이러니 한 문제에 대한 간단한 해결책 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5fa04705106510002b87a6a2c96b7082fb446b6c" translate="yes" xml:space="preserve">
          <source>So at the very least you should make global var/constant with pov(10,n) - meaning that you decided on the precision you need :-) Then do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 최소한 pov (10, n)을 사용하여 전역 var / constant를 만들어야합니다. 즉, 필요한 정밀도를 결정했음을 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="87f4cc4a8551195a42d1a9c700149f90f3ab76a5" translate="yes" xml:space="preserve">
          <source>So instead of performing the comparison like this</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 이와 같은 비교를 수행하는 대신&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04289cf569c9ea315b899e01e3ff8127ebce2c75" translate="yes" xml:space="preserve">
          <source>So, when using floating point variables, you should always be aware of this. And whatever output you want from a calculation with floating points should always be formatted/conditioned before displaying with this in mind.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 부동 소수점 변수를 사용할 때는 항상이를 알고 있어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부동 소수점을 사용한 계산에서 원하는 출력은 항상이를 염두에두고 표시하기 전에 형식화 / 조건화되어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a55f20d8ecae19b33f63d58dc9371e763bf4f2d9" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;http://2ality.com/2015/04/numbers-math-es6.html#numberepsilon&quot;&gt;http://2ality.com/2015/04/numbers-math-es6.html#numberepsilon&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;출처 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://2ality.com/2015/04/numbers-math-es6.html#numberepsilon&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://2ality.com/2015/04/numbers-math-es6.html#numberepsilon&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d25e632121467e8635330d7167a552d2e9181c60" translate="yes" xml:space="preserve">
          <source>Surprisingly, this function has not been posted yet although others have similar variations of it. It is from the MDN web docs for Math.round().
It's concise and allows for varying precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;놀랍게도,이 기능은 다른 기능과 유사하지만 아직 게시되지 않았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Math.round ()에 대한 MDN 웹 문서에서 가져온 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간결하고 다양한 정밀도를 허용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="87dbc587972268868e6cbe059d1ed329fd1a5fc4" translate="yes" xml:space="preserve">
          <source>That depends on what kind of
  calculations you&amp;rsquo;re doing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 당신이하고있는 계산의 종류에 달려 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c927531832108bc06279d31503b601200af52f43" translate="yes" xml:space="preserve">
          <source>The problem arises when comparing those floating points values to determine an appropriate action.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 부동 소수점 값을 비교하여 적절한 조치를 결정할 때 문제가 발생합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="55b1d2cc4477268763bd5500964d5b184e3991ae" translate="yes" xml:space="preserve">
          <source>The recommended approach is to use correction factors (multiply by a suitable power of 10 so that the arithmetic happens between integers).  For example, in the case of &lt;code&gt;0.1 * 0.2&lt;/code&gt;, the correction factor is &lt;code&gt;10&lt;/code&gt;, and you are performing the calculation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;권장되는 방법은 보정 계수를 사용하는 것입니다 (적수 사이에 산술이 발생하도록 10의 적절한 거듭 제곱을 곱함). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.1 * 0.2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보정 계수는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;10&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이며 계산을 수행하고 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b6daa3471e97c035d55063d4c0b0d8e3d0cf9a7" translate="yes" xml:space="preserve">
          <source>The result you've got is correct and fairly consistent across floating point implementations in different languages, processors and operating systems - the only thing that changes is the level of the inaccuracy when the float is actually a double (or higher).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;얻은 결과는 다른 언어, 프로세서 및 운영 체제의 부동 소수점 구현에서 정확하고 일관됩니다. 부동 소수점이 실제로 두 배 이상인 경우 부정확성 수준 만 변경됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="578414fc1ccf375f1c3022393ae84492ed9b86d6" translate="yes" xml:space="preserve">
          <source>The round() function at phpjs.org works nicely: &lt;a href=&quot;http://phpjs.org/functions/round&quot;&gt;http://phpjs.org/functions/round&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;phpjs.org의 round () 함수는 잘 작동합니다 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://phpjs.org/functions/round&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://phpjs.org/functions/round&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7aa22287f011062f40011982b9b1e4267305ec01" translate="yes" xml:space="preserve">
          <source>The same author has 2 other similar libraries:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동일한 저자는 2 개의 다른 유사한 라이브러리를 가지고 있습니다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="45b18900669ce60100b2a8139e01034f4d63e1c4" translate="yes" xml:space="preserve">
          <source>These 2 things are usually not done and in most cases the differences caused by not doing them are too small to be important for most users, but I already had a project where output wasn't accepted by the users without those corrections.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 두 가지 작업은 일반적으로 수행되지 않으며 대부분의 경우 이러한 작업을 수행하지 않아 발생하는 차이가 너무 작아 대부분의 사용자에게 중요하지는 않지만 이미 해당 수정없이 사용자가 출력을 수락하지 않은 프로젝트가있었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="995e6adcd7dd4e903f9034755d0f02e5f32e42e5" translate="yes" xml:space="preserve">
          <source>These conditions work correctly:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 조건은 올바르게 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30a1e69eaf576087f4adc95f66859b6980b7efbd" translate="yes" xml:space="preserve">
          <source>This function will determine the needed precision from the multiplication of two floating point numbers and return a result with the appropriate precision. Elegant though it is not.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 함수는 두 부동 소수점 숫자의 곱으로부터 필요한 정밀도를 결정하고 적절한 정밀도로 결과를 반환합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇지 않지만 우아합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c60c8cf88cdadc5ddf53a3cf7f9de9f9bf4f000" translate="yes" xml:space="preserve">
          <source>This just adds a digit to the right when rounding decimals.
MDN has updated the Math.round page so maybe someone could provide a 
better solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소수 자릿수를 올릴 때 오른쪽에 숫자가 추가됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MDN은 Math.round 페이지를 업데이트하여 더 나은 솔루션을 제공 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="22f1374e80bb9c8ef8c66feafcef8948c3f17d13" translate="yes" xml:space="preserve">
          <source>This will print the result &lt;code&gt;0.020000000000000004&lt;/code&gt; while it should just print &lt;code&gt;0.02&lt;/code&gt; (if you use your calculator). As far as I understood this is due to errors in the floating point multiplication precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;0.020000000000000004&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 결과가 인쇄 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되지만 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.02&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 만 인쇄 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면됩니다 (계산기를 사용하는 경우). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 이해하는 한 이것은 부동 소수점 곱셈 정밀도의 오류 때문입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b4e4dd5dedd60c21b1e2d40ef5986a69c044c8f" translate="yes" xml:space="preserve">
          <source>This works for me:</source>
          <target state="translated">이것은 나를 위해 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="41a41835f3c82af8647a7b77cb179b50a5405429" translate="yes" xml:space="preserve">
          <source>To avoid this you should work with integer values instead of floating points. So when you want to have 2 positions precision work with the values * 100, for 3 positions use 1000. When displaying you use a formatter to put in the separator.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 피하려면 부동 소수점 대신 정수 값을 사용해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 * 100의 값으로 2 개의 위치에서 정밀하게 작업하려면 3 개의 위치에 1000을 사용하십시오. 표시 할 때는 포맷터를 사용하여 구분 기호를 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f4481943972d21f141fcea329ac4f83c9332934" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;http://www.diveintojavascript.com/projects/javascript-sprintf&quot;&gt;javascript-sprintf&lt;/a&gt;, you would call it like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://www.diveintojavascript.com/projects/javascript-sprintf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;javascript-sprintf를&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 시도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면 다음과 같이 호출됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7818ea1fdff45e1ca14750be6d4169bfaee57e85" translate="yes" xml:space="preserve">
          <source>Try my chiliadic arithmetic library, which you can see &lt;a href=&quot;http://www.daniweb.com/forums/thread222006.html&quot;&gt;here&lt;/a&gt;.
If you want a later version, I can get you one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 칠레 식 산술 라이브러리를 사용해보십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.daniweb.com/forums/thread222006.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에서&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 볼 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나중 버전을 원하면 얻을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="069816246ed77462eefa613586edbd76e4fd87a2" translate="yes" xml:space="preserve">
          <source>UPDATE: Aug/20/2019
Just noticed this error. I believe it's due to a floating point precision error with Math.round().</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;업데이트 : 2019 년 8 월 20 일이 오류가 나타났습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Math.round ()의 부동 소수점 정밀도 오류 때문이라고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16e517b2e990ed3cf70be817c23709bd8d7accfa" translate="yes" xml:space="preserve">
          <source>Unlike Pedros solution this will round up 0.999...repeating and is accurate to plus/minus one on the least significant digit.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pedros 솔루션과 달리 이것은 0.999를 반올림합니다 ... 반복하며 가장 작은 자리에서 1을 더하기 / 빼기 정확합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">Use</target>
        </trans-unit>
        <trans-unit id="c9fa3b375e9e156eb9d66c9445e57dd3139fe0c4" translate="yes" xml:space="preserve">
          <source>Use Number(1.234443).toFixed(2); it will print 1.23</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용 번호 (1.234443) .toFixed (2); &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1.23을 인쇄합니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8dbb2394fd5cea4a5a0bceabe5ea9e242ad8b66c" translate="yes" xml:space="preserve">
          <source>Very very simple))</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;매우 간단합니다))&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a6dda06638f436253a8d23045c0f9134a35f024c" translate="yes" xml:space="preserve">
          <source>When discrete operators or functions are involved, extra corrections might be required to make sure the output is as expected. Rounding and adding small corrections before rounding can't solve the problem.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개별 연산자 또는 기능이 관련된 경우 출력이 예상대로 이루어 지도록 추가 수정이 필요할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반올림 전에 반올림 및 작은 수정을 추가해도 문제를 해결할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="99becbd0dffc744e204763d33ed726f31f4a99ac" translate="yes" xml:space="preserve">
          <source>When only continuous functions and operators are used, rounding to the desired precision often will do (don't truncate).  Standard formatting features used to convert floats to string will usually do this for you.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;연속 함수와 연산자 만 사용하는 경우 원하는 정밀도로 반올림하는 경우가 많습니다 (잘리지 않음). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;float를 문자열로 변환하는 데 사용되는 표준 형식 지정 기능이 일반적으로이 작업을 수행합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c6d73c873914a39afca0e4eb9a2e40a4035e5e08" translate="yes" xml:space="preserve">
          <source>With the advent of ES6, a new constant &lt;code&gt;Number.EPSILON&lt;/code&gt; is defined to determine the acceptable error margin :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES6의 출현으로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;허용 가능한 오류 마진을 결정하기 위해 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새로운 상수 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 정의됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14be6040fc36980e04bebea70f3f947216b405d0" translate="yes" xml:space="preserve">
          <source>You are looking for an &lt;code&gt;sprintf&lt;/code&gt; implementation for JavaScript, so that you can write out floats with small errors in them (since they are stored in binary format) in a format that you expect.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaScript &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에 대한 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sprintf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 구현을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;찾고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있으므로 작은 오류가있는 부동 소수점 (이진 형식으로 저장되어 있기 때문에)을 원하는 형식으로 작성할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec9ba5ceb02278a88d554e12764f6b29484e13fb" translate="yes" xml:space="preserve">
          <source>You are right, the reason for that is limited precision of floating point numbers. Store your rational numbers as a division of two integer numbers and in most situations you'll be able to store numbers without any precision loss. When it comes to printing, you may want to display the result as fraction. With representation I proposed, it becomes trivial.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 맞습니다. 그 이유는 부동 소수점 숫자의 정밀도가 제한되어 있기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;유리수를 두 정수로 나눈 값을 저장하면 대부분의 경우 정밀한 손실없이 숫자를 저장할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인쇄 할 때 결과를 분수로 표시 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 제안한 표현으로 그것은 사소한 것이된다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ffd7bd84840ca50d76440ccf8ca0c3594bc487e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;parseFloat()&lt;/code&gt; and &lt;code&gt;toFixed()&lt;/code&gt; if you want to bypass this issue for a small operation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작은 작업으로이 문제를 무시 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하려면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parseFloat()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;toFixed()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="40157fe7c1bc40e6a5655614855b704359d6e483" translate="yes" xml:space="preserve">
          <source>You can't represent most decimal fractions exactly with binary floating point types (which is what ECMAScript uses to represent floating point values). So there isn't an elegant solution unless you use arbitrary precision arithmetic types or a decimal based floating point type. For example, &lt;a href=&quot;http://blogs.msdn.com/b/oldnewthing/archive/2004/05/25/141253.aspx&quot;&gt;the Calculator app that ships with Windows now uses arbitrary precision arithmetic to solve this problem&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 부동 소수점 유형 (ECMAScript에서 부동 소수점 값을 나타내는 데 사용)을 사용하여 대부분의 소수를 정확하게 표현할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 임의의 정밀 산술 유형 또는 10 진수 기반 부동 소수점 유형을 사용하지 않으면 우아한 솔루션이 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msdn.com/b/oldnewthing/archive/2004/05/25/141253.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Windows와 함께 제공되는 계산기 앱은 이제이 문제를 해결하기 위해 임의의 정밀 산술을 사용합니다&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1cfea31bd9e2d6a6462a80aa994ae5ee23456ce" translate="yes" xml:space="preserve">
          <source>You could also keep doing math and only cut-off at the end - assuming that you are only displaying and not doing if-s with results. If you can do that, then .toFixed(...) might be more efficient.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결과를 표시하고 if-s를 수행하지 않는다고 가정하면 마지막에 수학을 계속하고 끝낼 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇게 할 수 있다면 .toFixed (...)가 더 효율적일 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="efdde9427ae67b144eb864b034a322d41713c6fa" translate="yes" xml:space="preserve">
          <source>You just have to make up your mind on how many decimal digits you actually want - can't have the cake and eat it too :-)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은 당신이 실제로 원하는 소수 자릿수에 대해 생각해야합니다-케이크를 먹을 수 없으며 너무 먹습니다 :-)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b92e6abf5f2b79acdec60ef0de73fe34f00ef252" translate="yes" xml:space="preserve">
          <source>You may also use  &lt;a href=&quot;http://www.w3schools.com/jsref/jsref_tofixed.asp&quot;&gt;Number.toFixed()&lt;/a&gt;  for display purposes, if you'd rather not include  more files merely for floating point rounding to a given precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 부동 소수점 반올림을 위해 주어진 정밀도로 더 많은 파일을 포함하지 않으려는 경우 표시 목적으로 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.w3schools.com/jsref/jsref_tofixed.asp&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Number.toFixed ()&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용할 수도 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edfa60213bd8f2d844928a429d60cb63e965db84" translate="yes" xml:space="preserve">
          <source>You're looking for the elegant solution then I'm afraid this is it: floats are quick but have small rounding errors - always round to something sensible when displaying their results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우아한 솔루션을 찾고 있다면 이것이 두렵습니다. 수레는 빠르지 만 작은 반올림 오류가 있습니다-결과를 표시 할 때 항상 합리적인 것으로 반올림하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4eab28434b44398092c734e075943f499d2e137c" translate="yes" xml:space="preserve">
          <source>and &lt;a href=&quot;https://github.com/MikeMcl/decimal.js/&quot;&gt;Decimal.js&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;및 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/MikeMcl/decimal.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Decimal.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31fbdc945417c8ee525f933924cfe13a7f2424af" translate="yes" xml:space="preserve">
          <source>big.js: minimalist; easy-to-use; precision specified in decimal places; precision applied to division only.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;big.js : 미니멀리스트; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하기 쉬운; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소수점 이하 자릿수로 지정된 정밀도; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;분할에만 적용되는 정밀도.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b09fe83f641a1a95cde4fd67164f2ee057e13d0a" translate="yes" xml:space="preserve">
          <source>bignumber.js: bases 2-64; configuration options; NaN; Infinity; precision specified in decimal places; precision applied to division only; base prefixes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bignumber.js : 염기 2-64; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성 옵션; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;NaN; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무한대; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소수점 이하 자릿수로 지정된 정밀도; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;분할에만 적용되는 정밀도; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 접두사.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ca0fb1811849befef678634dcad67c0b4854e51b" translate="yes" xml:space="preserve">
          <source>console.log((parseFloat(0.1) + parseFloat(0.2)).toFixed(1) == parseFloat(0.3).toFixed(1));</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;console.log ((parseFloat (0.1) + parseFloat (0.2)). toFixed (1) == parseFloat (0.3) .toFixed (1));&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a72717b86f4f1d0fa2a38b2fab25f2b271a2264a" translate="yes" xml:space="preserve">
          <source>console.log(precisionRound(1234.5678, -1));
   // expected output: 1230</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;console.log (precisionRound (1234.5678, -1)); &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;// 예상 출력 : 1230&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d0fef98d2af7d1d1a6c13739c51a505822c3b782" translate="yes" xml:space="preserve">
          <source>console.log(precisionRound(1234.5678, 1));
   // expected output: 1234.6</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;console.log (precisionRound (1234.5678, 1)); &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;// 예상 출력 : 1234.6&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="057764ffca879ed98c1fe3d95161aa733b9b4ef2" translate="yes" xml:space="preserve">
          <source>decimal.js: bases 2-64; configuration options; NaN; Infinity; non-integer powers, exp, ln, log; precision specified in significant digits; precision always applied; random numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;decimal.js :베이스 2-64; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성 옵션; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;NaN; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무한대; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정수가 아닌 제곱, exp, ln, log; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;유효 숫자로 지정된 정밀도; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;항상 적용되는 정밀도; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;난수.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da3f5b4eb74efe48286815d68ffd305b61e0751e" translate="yes" xml:space="preserve">
          <source>link to detailed comparisons</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자세한 비교 링크&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cbee38ce3307e66953c2a713e6ab5747f3d951e" translate="yes" xml:space="preserve">
          <source>not elegant but does the job (removes trailing zeros)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우아하지는 않지만 작업을 수행합니다 (후행 0 제거)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4fcdee7cbb8d16776e4fba9f1cd17e31d1427924" translate="yes" xml:space="preserve">
          <source>to print out your number as a float with two decimal places.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소수점 이하 두 자리의 부동 소수점으로 숫자를 인쇄합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="428fd5c08f7f539b3d5e5c5b24c3f54e50e227a7" translate="yes" xml:space="preserve">
          <source>while adding two  float value its never give the precise values so we need to fixed this to certain number that will help us to compare.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 개의 float 값을 추가하는 동안 정확한 값을 제공하지 않으므로 비교하기 위해 특정 숫자로 고정해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e8f984f0c891a245d25e57c3d16b020e0d0d3e8d" translate="yes" xml:space="preserve">
          <source>you can define a custom compare function, like this :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같이 사용자 정의 비교 기능을 정의 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
