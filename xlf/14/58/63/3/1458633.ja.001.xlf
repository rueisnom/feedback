<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1458633">
    <body>
      <group id="1458633">
        <trans-unit id="a58ae6e028aa9f56e0b393f9b27512d036863b7f" translate="yes" xml:space="preserve">
          <source>--- as in ---</source>
          <target state="translated">---に於いて</target>
        </trans-unit>
        <trans-unit id="a61acece68b9a4523517acd4c2932a44347a36f6" translate="yes" xml:space="preserve">
          <source>---also---</source>
          <target state="translated">---also---</target>
        </trans-unit>
        <trans-unit id="04039dd8c765ea73c439eaf667216b755095fcbb" translate="yes" xml:space="preserve">
          <source>---or---</source>
          <target state="translated">---or---</target>
        </trans-unit>
        <trans-unit id="e239b2f0cb4457085cc5a0a4c2e32b9d1078ef93" translate="yes" xml:space="preserve">
          <source>0.1 in binary floating points is like 1/3 in decimal (i.e. 0.3333333333333... forever), there's just no accurate way to handle it.</source>
          <target state="translated">2進数の浮動小数点の0.1は10進数の13のようなもので(つまり0.3333333333...永遠に)、正確な処理方法がないだけです。</target>
        </trans-unit>
        <trans-unit id="bc9246ffda94554579941bcde9c4edc49c446d01" translate="yes" xml:space="preserve">
          <source>0.6 * 3 it's awesome!))
For me this works fine:</source>
          <target state="translated">0.6*3 それは素晴らしいです!))私の場合はこれで大丈夫です。</target>
        </trans-unit>
        <trans-unit id="3cc69294c19b6465378465752174c2fdb6cba03d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://mikemcl.github.io/decimal.js/&quot;&gt;decimal.js&lt;/a&gt;, &lt;a href=&quot;http://mikemcl.github.io/big.js/&quot;&gt;big.js&lt;/a&gt; or &lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt; can be used to avoid floating-point manipulation problems in Javascript:</source>
          <target state="translated">&lt;a href=&quot;http://mikemcl.github.io/decimal.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;decimal.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://mikemcl.github.io/big.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;big.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bignumber.jsは、&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; JavaScriptでの浮動小数点操作の問題を回避するために使用することができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8da0f03b27353c36e89a7f463f0f26edc030610" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/MikeMcl/bignumber.js&quot;&gt;BigNumbers&lt;/a&gt; solved the problem, but introduced another, somewhat ironic, problem. When trying to load 8.5 into BigNumbers I was informed that it was really 8.4999&amp;hellip; and had more than 15 significant digits. This meant BigNumbers could not accept it (I believe I mentioned this problem was somewhat ironic).</source>
          <target state="translated">&lt;a href=&quot;https://github.com/MikeMcl/bignumber.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigNumbers&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が問題を解決しましたが、別のやや皮肉な問題が発生しました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigNumbersに8.5をロードしようとしたときに、それが実際には8.4999であり、有効桁数が15桁以上であることが通知されました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、BigNumbersがそれを受け入れることができなかったことを意味しました（この問題は皮肉なことだと私は言ったと思います）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ce0db9bea2fbfefa7b87bc4a1388e1cc35b89b2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Better avoid having the problem&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;問題を回避する方が良い&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92f696b23971dfa0a68250122f4ece948aba6e57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discrete functions or operators (like modula)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;離散関数または演算子（モジュラなど）&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4abe6058e1666fa25cd7562739ff8d998c39bfd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input and output for floating point values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮動小数点値の入力と出力&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a09079fe3f3cae3b532870bda64e5af716b17478" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Problem&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="241fda0675cef6227b22533c7fc0f61068a79a12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What can I do to avoid this problem?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この問題を回避するにはどうすればよいですか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce9300b41e15ad2d19e7ece35b5fc60757beb39e" translate="yes" xml:space="preserve">
          <source>A (very quick) solution looks something like:</source>
          <target state="translated">(非常に迅速な)解決策は、次のようなものになります。</target>
        </trans-unit>
        <trans-unit id="33a2b5e174fcca7358ea0f736487477bfc1ffec7" translate="yes" xml:space="preserve">
          <source>A JavaScript library for arbitrary-precision decimal and non-decimal arithmetic.</source>
          <target state="translated">任意精度の10進法・10進法以外の算術のためのJavaScriptライブラリ。</target>
        </trans-unit>
        <trans-unit id="cdc228a5887707e65f81fcb3dccdf34e8acdcbf5" translate="yes" xml:space="preserve">
          <source>A small, fast JavaScript library for arbitrary-precision decimal arithmetic. The little sister to bignumber.js.</source>
          <target state="translated">任意精度の10進数演算のための小さくて高速な JavaScript ライブラリ。bignumber.js の妹分。</target>
        </trans-unit>
        <trans-unit id="24ab8c562d1e296af3223a66eb9647aaf3256c06" translate="yes" xml:space="preserve">
          <source>A special check/correction on intermediate calculation results, immediately after applying the discrete function or operator might be required.
For a specific case (modula operator), see my answer on question: &lt;a href=&quot;https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/45346570#45346570&quot;&gt;Why does modulus operator return fractional number in javascript?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;離散関数または演算子を適用した直後に、中間計算結果の特別なチェック/修正が必要になる場合があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特定のケース（モジュラ演算子）については、質問の私の回答を参照してください：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/45346570#45346570&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;モジュラス演算子がJavaScriptで小数を返すのはなぜですか？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e147f80845946fb26fa310a4077a3d65e96df84" translate="yes" xml:space="preserve">
          <source>Add a small value to the outputs before rounding/formatting them which is smaller than or equal to 1/4 of the desired precision and bigger than the maximum expected error caused by rounding errors on input and during calculation. If that is not possible the combination of the precision of the used data type isn't enough to deliver the desired output precision for your calculation.</source>
          <target state="translated">丸め込み前に、出力に小さな値を追加します。これは、所望の精度の14以下で、入力時および計算中の丸め込み誤差によって生じる最大の期待誤差よりも大きい値です。それが不可能な場合は、使用されるデータ型の精度の組み合わせでは、計算に必要な出力精度を提供するのに十分ではありません。</target>
        </trans-unit>
        <trans-unit id="9ec5991d0491a50ed072932cfd75f49e54ea8673" translate="yes" xml:space="preserve">
          <source>An arbitrary-precision Decimal type for JavaScript.</source>
          <target state="translated">JavaScript用の任意精度の10進数型。</target>
        </trans-unit>
        <trans-unit id="22b59d0bd4142a0ac4d0949aed1e7a4055828148" translate="yes" xml:space="preserve">
          <source>Are you only performing multiplication?  If so then you can use to your advantage a neat secret about decimal arithmetic.  That is that &lt;code&gt;NumberOfDecimals(X) + NumberOfDecimals(Y) = ExpectedNumberOfDecimals&lt;/code&gt;. That is to say that if we have &lt;code&gt;0.123 * 0.12&lt;/code&gt; then we know that there will be 5 decimal places because &lt;code&gt;0.123&lt;/code&gt; has 3 decimal places and &lt;code&gt;0.12&lt;/code&gt; has two. Thus if JavaScript gave us a number like &lt;code&gt;0.014760000002&lt;/code&gt; we can safely round to the 5th decimal place without fear of losing precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;乗算のみを実行していますか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もしそうなら、あなたはあなたの利点に小数算術についてのきちんとした秘密を使うことができます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;NumberOfDecimals(X) + NumberOfDecimals(Y) = ExpectedNumberOfDecimals&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.123 * 0.12&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.123&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;小数点以下の桁数は3で、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.12&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;桁数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は2 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なので、小数点以下5桁になることがわかり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、JavaScriptによって&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.014760000002&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ような&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数値&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が得られた場合、精度を失うことを恐れずに、小数点第5位まで安全に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;丸める&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c873412f7d33e43d993fd7170b2548732ae1976" translate="yes" xml:space="preserve">
          <source>Because the rounding adds an error which can cause the total error to be more then half of the desired precision, the output should be corrected based on expected precision of inputs and desired precision of output. You should</source>
          <target state="translated">丸めにより、合計誤差が所望の精度の半分以上になる可能性があるため、入力の期待精度と出力の期待精度に基づいて出力を補正する必要があります。以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="5292ab4ae2ac6f1f1671909362adce21a8d03efb" translate="yes" xml:space="preserve">
          <source>Big.js</source>
          <target state="translated">Big.js</target>
        </trans-unit>
        <trans-unit id="d66c7d4989fa88e8c1967fe5c794a60a171e4bb4" translate="yes" xml:space="preserve">
          <source>Does anyone have a good solution so that in such case I get the correct result &lt;code&gt;0.02&lt;/code&gt;? I know there are functions like &lt;code&gt;toFixed&lt;/code&gt; or rounding would be another possibility, but I'd like to really have the whole number printed without any cutting and rounding. Just wanted to know if one of you has some nice, elegant solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのような場合に正しい結果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.02&lt;/code&gt; が&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;得られるように誰かが良い解決策を持ってい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ますか？&lt;/font&gt;&lt;/font&gt; &lt;code&gt;toFixed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;や四捨五入の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ような機能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がある可能性&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;があることはわかっ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ていますが、本当に丸めたり丸めたりせずに整数を印刷したいのですが。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あなたの一人が素晴らしいエレガントな解決策を持っているかどうか知りたいだけでした。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="c341e94c1b98a43dae4389df37cf0aada6e3fee0" translate="yes" xml:space="preserve">
          <source>Fix:</source>
          <target state="translated">Fix:</target>
        </trans-unit>
        <trans-unit id="4056e753845c8a8fd4a301c49e68620745f4fc19" translate="yes" xml:space="preserve">
          <source>Floating point can't store all decimal values exactly. So when using floating point formats there will always be rounding errors on the input values.
The errors on the inputs of course results on errors on the output.
In case of a discrete function or operator there can be big differences on the output around the point where the function or operator is discrete.</source>
          <target state="translated">浮動小数点はすべての10進数を正確に格納することはできません。そのため、浮動小数点フォーマットを使用する場合、入力値には常に丸め誤差が発生します。もちろん、入力値の誤差は出力値の誤差にも影響します。離散関数や演算子の場合、関数や演算子が離散的である点の周辺で出力に大きな違いが生じることがあります。</target>
        </trans-unit>
        <trans-unit id="aeb92746f89ae3b376318f5f1b422a3f62e2d554" translate="yes" xml:space="preserve">
          <source>For the mathematically inclined: &lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数学的に傾斜した場合：&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd67f72c65d9c61d8d2450191828d1627d8d5146" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://floating-point-gui.de/&quot;&gt;Floating-Point Guide&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://floating-point-gui.de/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮動小数点ガイド&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3aade10752679fef5dd7ea1f4d15d9b02c98c3e" translate="yes" xml:space="preserve">
          <source>Have a look at &lt;a href=&quot;http://en.wikipedia.org/wiki/Fixed-point_arithmetic&quot;&gt;Fixed-point arithmetic&lt;/a&gt;. It will probably solve your problem, if the range of numbers you want to operate on is small (eg, currency). I would round it off to a few decimal values, which is the simplest solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;見てい&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Fixed-point_arithmetic&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;固定小数点演算を&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;操作したい数値の範囲が狭い場合（通貨など）、問題はおそらく解決します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私はそれをいくつかの10進数値に四捨五入します。これが最も簡単な解決策です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b83cbd138fff23024c94f3b4bad484eafc94fff3" translate="yes" xml:space="preserve">
          <source>Here's some code using BigNumber:</source>
          <target state="translated">ここにBigNumberを使ったコードがあります。</target>
        </trans-unit>
        <trans-unit id="ee81411664de7bb4caaa5929799806ccb568b7b0" translate="yes" xml:space="preserve">
          <source>How to deal with floating point number precision in JavaScript</source>
          <target state="translated">JavaScriptで浮動小数点数の精度を扱う方法</target>
        </trans-unit>
        <trans-unit id="c8df9c129f17bfcc385ced7492e4b82ccec5e93a" translate="yes" xml:space="preserve">
          <source>I definitely recommend using a tested library like &lt;a href=&quot;https://github.com/guipn/sinful.js/blob/master/sinful.js&quot;&gt;SinfulJS&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;https://github.com/guipn/sinful.js/blob/master/sinful.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SinfulJS&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などのテスト済みライブラリを使用することをお勧めし&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a853ef4121663b373e78e17939e2d11ca4c83986" translate="yes" xml:space="preserve">
          <source>I had a nasty rounding error problem with mod 3. Sometimes when I should get 0 I would get .000...01. That's easy enough to handle, just test for &amp;lt;= .01. But then sometimes I would get 2.99999999999998. OUCH!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mod 3で厄介な丸めエラーの問題が発生しました。0を取得する必要があるときに、.000 ... 01が返されることがあります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは処理が簡単で、&amp;lt;= .01をテストするだけです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、時々2.99999999999998を取得します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;痛い！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9f9d35c2b34cb9f3475700d017c4d1185419e3c" translate="yes" xml:space="preserve">
          <source>I have the following dummy test script:</source>
          <target state="translated">私は以下のようなダミーのテストスクリプトを持っています。</target>
        </trans-unit>
        <trans-unit id="ba55b9d67e3d6448720f1cc36080a3e415841b6d" translate="yes" xml:space="preserve">
          <source>I like Pedro Ladaria's solution and use something similar.</source>
          <target state="translated">私はペドロ・ラダリアの解決策が好きで、似たようなものを使っています。</target>
        </trans-unit>
        <trans-unit id="11e4c0a4884796e3eaf68f789faed2b433d2248f" translate="yes" xml:space="preserve">
          <source>I'm finding &lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;BigNumber.js&lt;/a&gt; meets my needs.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigNumber.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が私のニーズを満たして&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いることが&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;わかりました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="970fc9047311aa9e995057a784ac862b33e2831e" translate="yes" xml:space="preserve">
          <source>If the first point really applies to you, use &lt;a href=&quot;https://web.archive.org/web/20150511085914/https://github.com/dtrebbien/BigDecimal.js&quot;&gt;BigDecimal for JavaScript&lt;/a&gt;, which is not elegant at all, but actually solves the problem rather than providing an imperfect workaround.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最初の点が本当に当てはまる場合は、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://web.archive.org/web/20150511085914/https://github.com/dtrebbien/BigDecimal.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigDecimal for JavaScriptを&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用してください。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これはエレガントではありませんが、不完全な回避策を提供するのではなく、実際に問題を解決します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f6e317ec81ade40f1e9e97cedccdc40678ac775d" translate="yes" xml:space="preserve">
          <source>If you are doing if-s/comparisons and don't want to cut of then you also need a small constant, usually called eps, which is one decimal place higher than max expected error. Say that your cut-off is last two decimals - then your eps has 1 at the 3rd place from the last (3rd least significant) and you can use it to compare whether the result is within eps range of expected (0.02 -eps &amp;lt; 0.1*0.2 &amp;lt; 0.02 +eps).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;if-s / comparisonsを実行していて、切り捨てたくない場合は、通常epsと呼ばれる小さな定数も必要です。これは、予想される最大エラーよりも小数点第1位高い値です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;カットオフが最後の2つの小数点であるとすると、epsは最後から3番目に1（最下位3番目）であり、それを使用して結果が期待されるepsの範囲内にあるかどうかを比較できます（0.02 -eps &amp;lt;0.1 * 0.2 &amp;lt;0.02 + eps）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3fb645f140e6b7fba5cf80b199367d878602c09e" translate="yes" xml:space="preserve">
          <source>If you have no decimal datatype available, an alternative is to work
  with integers, e.g. do money
  calculations entirely in cents. But
  this is more work and has some
  drawbacks.</source>
          <target state="translated">10進数のデータ型が利用できない場合は、整数を使って計算する方法もあります。しかし、これは手間がかかりますし、いくつかの欠点があります。</target>
        </trans-unit>
        <trans-unit id="f9a231822977eedb774b63cec0c1a0376b172063" translate="yes" xml:space="preserve">
          <source>If you just don&amp;rsquo;t want to see all those extra decimal places: simply
  format your result rounded to a fixed
  number of decimal places when
  displaying it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これらの余分な小数点以下の桁をすべて表示したくない場合は、結果を表示するときに、結果を固定小数点以下の桁数に丸めるだけです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42fc965d2e7933faeb52ad0042fa265db75c529f" translate="yes" xml:space="preserve">
          <source>If you really need your results to add up exactly, especially when you
  work with money: use a special decimal
  datatype.</source>
          <target state="translated">特にお金を使って仕事をするときに、結果を正確に加算する必要がある場合は、特別な10進数のデータ型を使用してください。</target>
        </trans-unit>
        <trans-unit id="d5f63b24009028d7cd1e82a2dcdac457c43a8f72" translate="yes" xml:space="preserve">
          <source>If you're dealing with floats &lt;em&gt;always&lt;/em&gt; expect small rounding errors, so you'll also always have to round the displayed result to something sensible. In return you get very very fast and powerful arithmetic because all the computations are in the native binary of the processor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フロート&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;処理している場合は、&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;常に&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;小さな丸め誤差が予想されるため、表示された結果を&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;常に&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;適切な値に丸める必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代わりに、すべての計算がプロセッサのネイティブバイナリで行われるため、非常に高速で強力な演算が得られます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76df916b62840bf387c4d5f679f0bb56b6c112cd" translate="yes" xml:space="preserve">
          <source>In this case:</source>
          <target state="translated">この場合は</target>
        </trans-unit>
        <trans-unit id="dc35e05387823f39d75255f34cb157621bf93da5" translate="yes" xml:space="preserve">
          <source>It has good &lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;documentation&lt;/a&gt; and the author is very diligent responding to feedback.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;良い&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ドキュメントが&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あり、著者はフィードバックに非常に注意深く対応しています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c0dbedb40544f549861aab974817b42583eb09a3" translate="yes" xml:space="preserve">
          <source>It is often more efficient to avoid these problems by using data types (integer or fixed point formats) for calculations like this which can store the expected input without rounding errors.
An example of that is that you should never use floating point values for financial calculations.</source>
          <target state="translated">このような計算には、丸め誤差なしに期待される入力を保存できるデータ型(整数または固定小数点形式)を使用した方が、これらの問題を回避できることが多いです。その例として、財務計算に浮動小数点値を使用してはいけないということがあります。</target>
        </trans-unit>
        <trans-unit id="448607d7ba223d62964e7cd11aa31257cd4a3f9c" translate="yes" xml:space="preserve">
          <source>Many systems omit working with decimals this way. That is the reason why many systems work with cents (as integer) instead of dollars/euro's (as floating point).</source>
          <target state="translated">多くのシステムでは、このように小数の操作を省略しています。これが、多くのシステムがドルセウロ(浮動小数点)の代わりにセント(整数)を使う理由です。</target>
        </trans-unit>
        <trans-unit id="6d6f9a91ba210d6d0d8e1736e610c0911b4b3dfe" translate="yes" xml:space="preserve">
          <source>Most of the time the solution is not to switch to fixed-point arithmetic, mainly because it's much slower and 99% of the time you just don't need the accuracy. If you're dealing with stuff that does need that level of accuracy (for instance financial transactions) Javascript probably isn't the best tool to use anyway (as you've want to enforce the fixed-point types a static language is probably better).</source>
          <target state="translated">ほとんどの場合、解決策は固定小数点演算に切り替えることではありません。もしあなたがそのレベルの精度を必要とするものを扱っているのであれば(例えば金融取引など)、Javascriptはおそらく使用するのに最適なツールではないでしょう(固定小数点型を強制したいのであれば、静的言語の方が良いでしょう)。</target>
        </trans-unit>
        <trans-unit id="9bf7090b248473b9077c1c5f6937631d47c5fe07" translate="yes" xml:space="preserve">
          <source>Note that the first point only applies if you really need specific precise &lt;em&gt;decimal&lt;/em&gt; behaviour. Most people don't need that, they're just irritated that their programs don't work correctly with numbers like 1/10 without realizing that they wouldn't even blink at the same error if it occurred with 1/3.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最初の点は、特定の正確な&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10進数の&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;動作&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が本当に必要な場合にのみ適用されることに注意してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ほとんどの人はそれを必要としません、彼らは彼らのプログラムが1/3で発生した場合に同じエラーで点滅しないことさえ知らずに1/10のような数値で正しく動作しないことにただイライラします。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb097215ec09eb0024375e4ae22d1c146c281243" translate="yes" xml:space="preserve">
          <source>Note: When dealing with 32 or 64 bit floats, you should use toPrecision(7) and toPrecision(15) for best results.  See &lt;a href=&quot;https://stackoverflow.com/questions/28045787/how-many-decimal-places-does-the-primitive-float-and-double-support&quot;&gt;this question&lt;/a&gt; for info as to why.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注：32ビットまたは64ビットの浮動小数点数を処理する場合、最良の結果を得るにはtoPrecision（7）およびtoPrecision（15）を使用する必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;理由&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;については、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/28045787/how-many-decimal-places-does-the-primitive-float-and-double-support&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この質問&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="11195d73ee275b234990d7d7cb1e88d873fcca46" translate="yes" xml:space="preserve">
          <source>Notice that for the general purpose use, this behavior is likely to be acceptable.</source>
          <target state="translated">一般的な用途では、このような行動が許容される可能性が高いことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3290637a00912e04380d8c64be613af76228d4bf" translate="yes" xml:space="preserve">
          <source>Numerical errors accumulate with every further operation and if you don't cut it off early it's just going to grow. Numerical libraries which present results that look clean simply cut off the last 2 digits at every step, numerical co-processors also have a &quot;normal&quot; and &quot;full&quot; lenght for the same reason. Cuf-offs are cheap for a processor but very expensive for you in a script (multiplying and dividing and using pov(...)). Good math lib would provide floor(x,n) to do the cut-off for you.</source>
          <target state="translated">数値的なエラーは操作を続けるごとに蓄積されていくので、早めに切り離さないとどんどん増えていきます。きれいに見える結果を表示する数値ライブラリは、ステップごとに下2桁の数字をカットしています。Cuf-off はプロセッサとしては安価ですが、スクリプトとしては非常に高価です (乗算と除算、そして pov(...)の使用)。良い数学ライブラリは、カットオフを行うために floor(x,n)を提供してくれます。</target>
        </trans-unit>
        <trans-unit id="2839401e766a935656ba07eb6b9d6b7c03f3cac8" translate="yes" xml:space="preserve">
          <source>Of course that won't help much with irrational numbers. But you may want to optimize your computations in the way they will cause the least problem (e.g. detecting situations like &lt;code&gt;sqrt(3)^2)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、それは無理な数ではあまり役に立ちません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、問題が最小限になるように計算を最適化することもできます（たとえば、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sqrt(3)^2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ような状況の検出&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63652065953c408e91fa63939df078c88343bbe4" translate="yes" xml:space="preserve">
          <source>Of course, otherwise I'll round to some 10 digits or so.</source>
          <target state="translated">もちろん、そうでなければ10桁くらいに四捨五入します。</target>
        </trans-unit>
        <trans-unit id="56ceded875df16b30aabedd0be6143d73e5f2da8" translate="yes" xml:space="preserve">
          <source>Output using the following function:</source>
          <target state="translated">以下の機能を使って出力します。</target>
        </trans-unit>
        <trans-unit id="1a87200547de52dcba232ee8140c48ce625448de" translate="yes" xml:space="preserve">
          <source>Pay attention to the output &lt;code&gt;toFixedCurrency(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出力&lt;/font&gt;&lt;/font&gt; &lt;code&gt;toFixedCurrency(x)&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意して&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7ccc77c464d68ec4d4d9bc39d5016a33fe1860ca" translate="yes" xml:space="preserve">
          <source>Round inputs to the expected precision or make sure no values can be entered with higher precision.</source>
          <target state="translated">入力を予想される精度に丸めたり、より高い精度で値を入力できないようにしたりします。</target>
        </trans-unit>
        <trans-unit id="fea441daf71749c24a14635d2315d7865e68e5f8" translate="yes" xml:space="preserve">
          <source>Simple solution to ironic problem:</source>
          <target state="translated">皮肉な問題をシンプルに解決</target>
        </trans-unit>
        <trans-unit id="5fa04705106510002b87a6a2c96b7082fb446b6c" translate="yes" xml:space="preserve">
          <source>So at the very least you should make global var/constant with pov(10,n) - meaning that you decided on the precision you need :-) Then do:</source>
          <target state="translated">ですから、少なくともあなたは pov(10,n)でグローバル varconstant を作るべきです-つまり、あなたが必要とする精度を決定したということです :-)それから実行してください。</target>
        </trans-unit>
        <trans-unit id="87f4cc4a8551195a42d1a9c700149f90f3ab76a5" translate="yes" xml:space="preserve">
          <source>So instead of performing the comparison like this</source>
          <target state="translated">そのため、次のように比較を実行する代わりに</target>
        </trans-unit>
        <trans-unit id="04289cf569c9ea315b899e01e3ff8127ebce2c75" translate="yes" xml:space="preserve">
          <source>So, when using floating point variables, you should always be aware of this. And whatever output you want from a calculation with floating points should always be formatted/conditioned before displaying with this in mind.</source>
          <target state="translated">ですから、浮動小数点変数を使用するときは、常にこれを意識する必要があります。そして、浮動小数点を使用した計算から出力したいものは何であれ、これを念頭に置いて表示する前に必ずformatattedconditionedされていなければなりません。</target>
        </trans-unit>
        <trans-unit id="a55f20d8ecae19b33f63d58dc9371e763bf4f2d9" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;http://2ality.com/2015/04/numbers-math-es6.html#numberepsilon&quot;&gt;http://2ality.com/2015/04/numbers-math-es6.html#numberepsilon&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出典：&lt;/font&gt;&lt;a href=&quot;http://2ality.com/2015/04/numbers-math-es6.html#numberepsilon&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//2ality.com/2015/04/numbers-math-es6.html#numberepsilon&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d25e632121467e8635330d7167a552d2e9181c60" translate="yes" xml:space="preserve">
          <source>Surprisingly, this function has not been posted yet although others have similar variations of it. It is from the MDN web docs for Math.round().
It's concise and allows for varying precision.</source>
          <target state="translated">意外なことに、この関数は他にも似たようなバリエーションがあるにもかかわらず、まだ投稿されていません。これは、Math.round()の MDN ウェブドキュメントにあります。簡潔で、精度を変えることができます。</target>
        </trans-unit>
        <trans-unit id="87dbc587972268868e6cbe059d1ed329fd1a5fc4" translate="yes" xml:space="preserve">
          <source>That depends on what kind of
  calculations you&amp;rsquo;re doing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それはあなたがどのような計算をしているのかに依存します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c927531832108bc06279d31503b601200af52f43" translate="yes" xml:space="preserve">
          <source>The problem arises when comparing those floating points values to determine an appropriate action.</source>
          <target state="translated">これらの浮動小数点の値を比較して適切なアクションを決定する際に問題が発生します。</target>
        </trans-unit>
        <trans-unit id="55b1d2cc4477268763bd5500964d5b184e3991ae" translate="yes" xml:space="preserve">
          <source>The recommended approach is to use correction factors (multiply by a suitable power of 10 so that the arithmetic happens between integers).  For example, in the case of &lt;code&gt;0.1 * 0.2&lt;/code&gt;, the correction factor is &lt;code&gt;10&lt;/code&gt;, and you are performing the calculation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;推奨されるアプローチは、補正係数を使用することです（整数間で計算が行われるように、適切な10の累乗を掛けます）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.1 * 0.2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合、補正係数は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;10&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;であり、計算を実行しています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b6daa3471e97c035d55063d4c0b0d8e3d0cf9a7" translate="yes" xml:space="preserve">
          <source>The result you've got is correct and fairly consistent across floating point implementations in different languages, processors and operating systems - the only thing that changes is the level of the inaccuracy when the float is actually a double (or higher).</source>
          <target state="translated">あなたが得た結果は、異なる言語、プロセッサ、オペレーティングシステムにおける浮動小数点の実装の間で正しく、かなり一貫しています。</target>
        </trans-unit>
        <trans-unit id="578414fc1ccf375f1c3022393ae84492ed9b86d6" translate="yes" xml:space="preserve">
          <source>The round() function at phpjs.org works nicely: &lt;a href=&quot;http://phpjs.org/functions/round&quot;&gt;http://phpjs.org/functions/round&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;phpjs.orgのround（）関数はうまく動作します：&lt;/font&gt;&lt;a href=&quot;http://phpjs.org/functions/round&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ://phpjs.org/functions/round&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7aa22287f011062f40011982b9b1e4267305ec01" translate="yes" xml:space="preserve">
          <source>The same author has 2 other similar libraries:</source>
          <target state="translated">同じ作者には、他にも2つの似たようなライブラリがあります。</target>
        </trans-unit>
        <trans-unit id="45b18900669ce60100b2a8139e01034f4d63e1c4" translate="yes" xml:space="preserve">
          <source>These 2 things are usually not done and in most cases the differences caused by not doing them are too small to be important for most users, but I already had a project where output wasn't accepted by the users without those corrections.</source>
          <target state="translated">これら2つのことは通常は行われていないし、ほとんどの場合、これらを行わなかったことによる違いは、ほとんどのユーザーにとっては重要ではないほど小さいのですが、私はすでにこれらの修正を行わずに出力がユーザーに受け入れられなかったプロジェクトを持っていました。</target>
        </trans-unit>
        <trans-unit id="995e6adcd7dd4e903f9034755d0f02e5f32e42e5" translate="yes" xml:space="preserve">
          <source>These conditions work correctly:</source>
          <target state="translated">これらの条件は正しく機能します。</target>
        </trans-unit>
        <trans-unit id="30a1e69eaf576087f4adc95f66859b6980b7efbd" translate="yes" xml:space="preserve">
          <source>This function will determine the needed precision from the multiplication of two floating point numbers and return a result with the appropriate precision. Elegant though it is not.</source>
          <target state="translated">この関数は、2つの浮動小数点数の乗算から必要な精度を求め、適切な精度で結果を返します。エレガントではありませんが。</target>
        </trans-unit>
        <trans-unit id="1c60c8cf88cdadc5ddf53a3cf7f9de9f9bf4f000" translate="yes" xml:space="preserve">
          <source>This just adds a digit to the right when rounding decimals.
MDN has updated the Math.round page so maybe someone could provide a 
better solution.</source>
          <target state="translated">これは小数を丸めるときに右に一桁追加するだけです。MDNがMath.roundのページを更新したので、誰かがもっと良い解決策を提供してくれるかもしれません。</target>
        </trans-unit>
        <trans-unit id="22f1374e80bb9c8ef8c66feafcef8948c3f17d13" translate="yes" xml:space="preserve">
          <source>This will print the result &lt;code&gt;0.020000000000000004&lt;/code&gt; while it should just print &lt;code&gt;0.02&lt;/code&gt; (if you use your calculator). As far as I understood this is due to errors in the floating point multiplication precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.020000000000000004&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の結果を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出力&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ますが、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.02&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を出力するはず&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です（計算機を使用している場合）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私が理解している限り、これは浮動小数点乗算精度のエラーが原因です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b4e4dd5dedd60c21b1e2d40ef5986a69c044c8f" translate="yes" xml:space="preserve">
          <source>This works for me:</source>
          <target state="translated">これは私には効き目があります。</target>
        </trans-unit>
        <trans-unit id="41a41835f3c82af8647a7b77cb179b50a5405429" translate="yes" xml:space="preserve">
          <source>To avoid this you should work with integer values instead of floating points. So when you want to have 2 positions precision work with the values * 100, for 3 positions use 1000. When displaying you use a formatter to put in the separator.</source>
          <target state="translated">これを避けるためには、浮動小数点の代わりに整数値を使用する必要があります。つまり、2つの位置の精度が必要な場合は、値*100を使用し、3つの位置には1000を使用します。表示するときにはフォーマッタを使って区切り文字を入れます。</target>
        </trans-unit>
        <trans-unit id="9f4481943972d21f141fcea329ac4f83c9332934" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;http://www.diveintojavascript.com/projects/javascript-sprintf&quot;&gt;javascript-sprintf&lt;/a&gt;, you would call it like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://www.diveintojavascript.com/projects/javascript-sprintf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;javascript-sprintfを&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;試してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。次のように呼び出します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7818ea1fdff45e1ca14750be6d4169bfaee57e85" translate="yes" xml:space="preserve">
          <source>Try my chiliadic arithmetic library, which you can see &lt;a href=&quot;http://www.daniweb.com/forums/thread222006.html&quot;&gt;here&lt;/a&gt;.
If you want a later version, I can get you one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://www.daniweb.com/forums/thread222006.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここに&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ある私のキリアス算術ライブラリを試してみてください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;より新しいバージョンが必要な場合は、入手できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="069816246ed77462eefa613586edbd76e4fd87a2" translate="yes" xml:space="preserve">
          <source>UPDATE: Aug/20/2019
Just noticed this error. I believe it's due to a floating point precision error with Math.round().</source>
          <target state="translated">UPDATE:Aug202019 ちょうどこのエラーに気づきました。Math.round()での浮動小数点精度のエラーが原因だと思います。</target>
        </trans-unit>
        <trans-unit id="16e517b2e990ed3cf70be817c23709bd8d7accfa" translate="yes" xml:space="preserve">
          <source>Unlike Pedros solution this will round up 0.999...repeating and is accurate to plus/minus one on the least significant digit.</source>
          <target state="translated">ペドロスのソリューションとは異なり、これは0.999...リピートを切り上げ、最も重要な桁のプラスマイナス1に正確です。</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">Use</target>
        </trans-unit>
        <trans-unit id="c9fa3b375e9e156eb9d66c9445e57dd3139fe0c4" translate="yes" xml:space="preserve">
          <source>Use Number(1.234443).toFixed(2); it will print 1.23</source>
          <target state="translated">Number(1.234443).toFixed(2)を使用します。</target>
        </trans-unit>
        <trans-unit id="8dbb2394fd5cea4a5a0bceabe5ea9e242ad8b66c" translate="yes" xml:space="preserve">
          <source>Very very simple))</source>
          <target state="translated">非常にシンプルです))</target>
        </trans-unit>
        <trans-unit id="a6dda06638f436253a8d23045c0f9134a35f024c" translate="yes" xml:space="preserve">
          <source>When discrete operators or functions are involved, extra corrections might be required to make sure the output is as expected. Rounding and adding small corrections before rounding can't solve the problem.</source>
          <target state="translated">離散演算子や関数が関与している場合、出力が期待通りであることを確認するために余分な補正が必要になることがあります。丸めや、丸めの前に小さな補正を追加しても問題は解決しません。</target>
        </trans-unit>
        <trans-unit id="99becbd0dffc744e204763d33ed726f31f4a99ac" translate="yes" xml:space="preserve">
          <source>When only continuous functions and operators are used, rounding to the desired precision often will do (don't truncate).  Standard formatting features used to convert floats to string will usually do this for you.</source>
          <target state="translated">連続関数や演算子だけを使用している場合は、必要な精度に丸めればよいことが多いです(切り捨てはしないでください)。浮動小数点数を文字列に変換するために使用される標準的な書式設定機能は、通常、これを代行してくれます。</target>
        </trans-unit>
        <trans-unit id="c6d73c873914a39afca0e4eb9a2e40a4035e5e08" translate="yes" xml:space="preserve">
          <source>With the advent of ES6, a new constant &lt;code&gt;Number.EPSILON&lt;/code&gt; is defined to determine the acceptable error margin :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES6の登場により&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、許容可能なエラーマージンを決定するために、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新しい定数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が定義されています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14be6040fc36980e04bebea70f3f947216b405d0" translate="yes" xml:space="preserve">
          <source>You are looking for an &lt;code&gt;sprintf&lt;/code&gt; implementation for JavaScript, so that you can write out floats with small errors in them (since they are stored in binary format) in a format that you expect.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaScriptの&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sprintf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;探しているため、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（バイナリ形式で格納されているため）小さなエラーのある浮動小数点数を期待どおりの形式で書き出すことができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec9ba5ceb02278a88d554e12764f6b29484e13fb" translate="yes" xml:space="preserve">
          <source>You are right, the reason for that is limited precision of floating point numbers. Store your rational numbers as a division of two integer numbers and in most situations you'll be able to store numbers without any precision loss. When it comes to printing, you may want to display the result as fraction. With representation I proposed, it becomes trivial.</source>
          <target state="translated">あなたの言う通り、その理由は浮動小数点数の限られた精度にあります。有理数を2つの整数の除算として格納すれば、ほとんどの状況で精度を落とさずに数値を格納することができます。印刷するときには、結果を分数で表示したい場合もあるでしょう。私が提案した表現では、それは些細なことになります。</target>
        </trans-unit>
        <trans-unit id="4ffd7bd84840ca50d76440ccf8ca0c3594bc487e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;parseFloat()&lt;/code&gt; and &lt;code&gt;toFixed()&lt;/code&gt; if you want to bypass this issue for a small operation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;小さな操作でこの問題を回避したい場合は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parseFloat()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;toFixed()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="40157fe7c1bc40e6a5655614855b704359d6e483" translate="yes" xml:space="preserve">
          <source>You can't represent most decimal fractions exactly with binary floating point types (which is what ECMAScript uses to represent floating point values). So there isn't an elegant solution unless you use arbitrary precision arithmetic types or a decimal based floating point type. For example, &lt;a href=&quot;http://blogs.msdn.com/b/oldnewthing/archive/2004/05/25/141253.aspx&quot;&gt;the Calculator app that ships with Windows now uses arbitrary precision arithmetic to solve this problem&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ほとんどの小数は、2進浮動小数点型では正確に表すことができません（これはECMAScriptが浮動小数点値を表すために使用するものです）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、任意の精度の算術型または10進数ベースの浮動小数点型を使用しない限り、洗練されたソリューションはありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msdn.com/b/oldnewthing/archive/2004/05/25/141253.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Windowsに同梱されている電卓アプリ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、この問題を解決するために任意精度演算が使用されるようになりました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1cfea31bd9e2d6a6462a80aa994ae5ee23456ce" translate="yes" xml:space="preserve">
          <source>You could also keep doing math and only cut-off at the end - assuming that you are only displaying and not doing if-s with results. If you can do that, then .toFixed(...) might be more efficient.</source>
          <target state="translated">また、計算を続けて、最後にカットオフだけを行うこともできます-結果を表示するだけで、結果のif-sを行わないことを想定しています。もしそれができるのであれば、.toFixed(....)の方が効率的かもしれません。</target>
        </trans-unit>
        <trans-unit id="efdde9427ae67b144eb864b034a322d41713c6fa" translate="yes" xml:space="preserve">
          <source>You just have to make up your mind on how many decimal digits you actually want - can't have the cake and eat it too :-)</source>
          <target state="translated">あなたは、実際に必要な小数点以下の桁数を自分で決める必要があります-ケーキを持っているとそれを食べることもできません :-)</target>
        </trans-unit>
        <trans-unit id="b92e6abf5f2b79acdec60ef0de73fe34f00ef252" translate="yes" xml:space="preserve">
          <source>You may also use  &lt;a href=&quot;http://www.w3schools.com/jsref/jsref_tofixed.asp&quot;&gt;Number.toFixed()&lt;/a&gt;  for display purposes, if you'd rather not include  more files merely for floating point rounding to a given precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 浮動小数点の特定の精度への丸めのためだけにファイルを追加しない場合は、表示目的で&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.w3schools.com/jsref/jsref_tofixed.asp&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Number.toFixed（）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用することも &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edfa60213bd8f2d844928a429d60cb63e965db84" translate="yes" xml:space="preserve">
          <source>You're looking for the elegant solution then I'm afraid this is it: floats are quick but have small rounding errors - always round to something sensible when displaying their results.</source>
          <target state="translated">浮動小数点数は速いが、丸め誤差が小さい-結果を表示する際には、常に何か分別のあるものに丸めます。</target>
        </trans-unit>
        <trans-unit id="4eab28434b44398092c734e075943f499d2e137c" translate="yes" xml:space="preserve">
          <source>and &lt;a href=&quot;https://github.com/MikeMcl/decimal.js/&quot;&gt;Decimal.js&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;および&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/MikeMcl/decimal.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Decimal.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31fbdc945417c8ee525f933924cfe13a7f2424af" translate="yes" xml:space="preserve">
          <source>big.js: minimalist; easy-to-use; precision specified in decimal places; precision applied to division only.</source>
          <target state="translated">big.js:ミニマリスト;使いやすい;精度は小数点以下で指定;精度は除算のみに適用される</target>
        </trans-unit>
        <trans-unit id="b09fe83f641a1a95cde4fd67164f2ee057e13d0a" translate="yes" xml:space="preserve">
          <source>bignumber.js: bases 2-64; configuration options; NaN; Infinity; precision specified in decimal places; precision applied to division only; base prefixes.</source>
          <target state="translated">bignumber.js:base 2-64;configuration options;NaN;Infinity;precision specified in decimal places;precision applied to division only;base prefix.</target>
        </trans-unit>
        <trans-unit id="ca0fb1811849befef678634dcad67c0b4854e51b" translate="yes" xml:space="preserve">
          <source>console.log((parseFloat(0.1) + parseFloat(0.2)).toFixed(1) == parseFloat(0.3).toFixed(1));</source>
          <target state="translated">console.log((parseFloat(0.1)+parseFloat(0.2)).toFixed(1)==parseFloat(0.3).toFixed(1))。</target>
        </trans-unit>
        <trans-unit id="a72717b86f4f1d0fa2a38b2fab25f2b271a2264a" translate="yes" xml:space="preserve">
          <source>console.log(precisionRound(1234.5678, -1));
   // expected output: 1230</source>
          <target state="translated">console.log(precisionRound(1234.5678,-1));/期待される出力。1230</target>
        </trans-unit>
        <trans-unit id="d0fef98d2af7d1d1a6c13739c51a505822c3b782" translate="yes" xml:space="preserve">
          <source>console.log(precisionRound(1234.5678, 1));
   // expected output: 1234.6</source>
          <target state="translated">console.log(precisionRound(1234.5678,1));/期待される出力。1234.6</target>
        </trans-unit>
        <trans-unit id="057764ffca879ed98c1fe3d95161aa733b9b4ef2" translate="yes" xml:space="preserve">
          <source>decimal.js: bases 2-64; configuration options; NaN; Infinity; non-integer powers, exp, ln, log; precision specified in significant digits; precision always applied; random numbers.</source>
          <target state="translated">decimal.js:base 2-64;設定オプション;NaN;Infinity;非整数の累乗、exp、ln、log;有効数字で指定された精度;常に適用される精度;乱数。</target>
        </trans-unit>
        <trans-unit id="da3f5b4eb74efe48286815d68ffd305b61e0751e" translate="yes" xml:space="preserve">
          <source>link to detailed comparisons</source>
          <target state="translated">詳細比較へのリンク</target>
        </trans-unit>
        <trans-unit id="9cbee38ce3307e66953c2a713e6ab5747f3d951e" translate="yes" xml:space="preserve">
          <source>not elegant but does the job (removes trailing zeros)</source>
          <target state="translated">エレガントではありませんが、仕事はできます (末尾のゼロを削除します)</target>
        </trans-unit>
        <trans-unit id="4fcdee7cbb8d16776e4fba9f1cd17e31d1427924" translate="yes" xml:space="preserve">
          <source>to print out your number as a float with two decimal places.</source>
          <target state="translated">を使用して、小数点以下2桁の浮動小数点数で数値を印刷します。</target>
        </trans-unit>
        <trans-unit id="428fd5c08f7f539b3d5e5c5b24c3f54e50e227a7" translate="yes" xml:space="preserve">
          <source>while adding two  float value its never give the precise values so we need to fixed this to certain number that will help us to compare.</source>
          <target state="translated">2つの浮動小数点演算子の値を加算している間、それは決して正確な値を与えることはありませんので、私たちは私たちが比較するのに役立つ特定の数に固定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e8f984f0c891a245d25e57c3d16b020e0d0d3e8d" translate="yes" xml:space="preserve">
          <source>you can define a custom compare function, like this :</source>
          <target state="translated">のようなカスタム比較関数を定義することができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
