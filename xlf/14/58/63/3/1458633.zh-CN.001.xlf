<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1458633">
    <body>
      <group id="1458633">
        <trans-unit id="a58ae6e028aa9f56e0b393f9b27512d036863b7f" translate="yes" xml:space="preserve">
          <source>--- as in ---</source>
          <target state="translated">------如------</target>
        </trans-unit>
        <trans-unit id="a61acece68b9a4523517acd4c2932a44347a36f6" translate="yes" xml:space="preserve">
          <source>---also---</source>
          <target state="translated">---also---</target>
        </trans-unit>
        <trans-unit id="04039dd8c765ea73c439eaf667216b755095fcbb" translate="yes" xml:space="preserve">
          <source>---or---</source>
          <target state="translated">---or---</target>
        </trans-unit>
        <trans-unit id="e239b2f0cb4457085cc5a0a4c2e32b9d1078ef93" translate="yes" xml:space="preserve">
          <source>0.1 in binary floating points is like 1/3 in decimal (i.e. 0.3333333333333... forever), there's just no accurate way to handle it.</source>
          <target state="translated">二进制浮点数中的0.1就像十进制中的13(即0.33333333333333333...........永远),只是没有准确的处理方法。</target>
        </trans-unit>
        <trans-unit id="bc9246ffda94554579941bcde9c4edc49c446d01" translate="yes" xml:space="preserve">
          <source>0.6 * 3 it's awesome!))
For me this works fine:</source>
          <target state="translated">0.6*3,太赞了!)对我来说,这个很好用。</target>
        </trans-unit>
        <trans-unit id="3cc69294c19b6465378465752174c2fdb6cba03d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://mikemcl.github.io/decimal.js/&quot;&gt;decimal.js&lt;/a&gt;, &lt;a href=&quot;http://mikemcl.github.io/big.js/&quot;&gt;big.js&lt;/a&gt; or &lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt; can be used to avoid floating-point manipulation problems in Javascript:</source>
          <target state="translated">&lt;a href=&quot;http://mikemcl.github.io/decimal.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;decimal.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://mikemcl.github.io/big.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;big.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bignumber.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可用于避免Javascript中的浮点操作问题：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8da0f03b27353c36e89a7f463f0f26edc030610" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/MikeMcl/bignumber.js&quot;&gt;BigNumbers&lt;/a&gt; solved the problem, but introduced another, somewhat ironic, problem. When trying to load 8.5 into BigNumbers I was informed that it was really 8.4999&amp;hellip; and had more than 15 significant digits. This meant BigNumbers could not accept it (I believe I mentioned this problem was somewhat ironic).</source>
          <target state="translated">&lt;a href=&quot;https://github.com/MikeMcl/bignumber.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigNumbers&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决了该问题，但引入了另一个具有讽刺意味的问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试将8.5加载到BigNumbers中时，我得知它实际上是8.4999&amp;hellip;，并且有15个以上的有效数字。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这意味着BigNumbers无法接受它（我相信我提到这个问题有点讽刺意味）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ce0db9bea2fbfefa7b87bc4a1388e1cc35b89b2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Better avoid having the problem&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最好避免出现问题&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92f696b23971dfa0a68250122f4ece948aba6e57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discrete functions or operators (like modula)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;离散函数或运算符（如模数）&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4abe6058e1666fa25cd7562739ff8d998c39bfd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input and output for floating point values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮点值的输入和输出&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a09079fe3f3cae3b532870bda64e5af716b17478" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Problem&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="241fda0675cef6227b22533c7fc0f61068a79a12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What can I do to avoid this problem?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我应该怎么做才能避免这个问题？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce9300b41e15ad2d19e7ece35b5fc60757beb39e" translate="yes" xml:space="preserve">
          <source>A (very quick) solution looks something like:</source>
          <target state="translated">一个(非常快速)的解决方案看起来像:</target>
        </trans-unit>
        <trans-unit id="33a2b5e174fcca7358ea0f736487477bfc1ffec7" translate="yes" xml:space="preserve">
          <source>A JavaScript library for arbitrary-precision decimal and non-decimal arithmetic.</source>
          <target state="translated">一个用于任意精度十进制和非十进制算术的JavaScript库。</target>
        </trans-unit>
        <trans-unit id="cdc228a5887707e65f81fcb3dccdf34e8acdcbf5" translate="yes" xml:space="preserve">
          <source>A small, fast JavaScript library for arbitrary-precision decimal arithmetic. The little sister to bignumber.js.</source>
          <target state="translated">一个小而快的JavaScript库,用于任意精度的十进制算术。是bignumber.js的小妹妹。</target>
        </trans-unit>
        <trans-unit id="24ab8c562d1e296af3223a66eb9647aaf3256c06" translate="yes" xml:space="preserve">
          <source>A special check/correction on intermediate calculation results, immediately after applying the discrete function or operator might be required.
For a specific case (modula operator), see my answer on question: &lt;a href=&quot;https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/45346570#45346570&quot;&gt;Why does modulus operator return fractional number in javascript?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在应用离散函数或运算符之后，可能需要立即对中间计算结果进行特殊检查/校正。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于特定情况（模运算符），请参阅我对以下问题的回答：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/45346570#45346570&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为什么模数运算符会在javascript中返回小数？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e147f80845946fb26fa310a4077a3d65e96df84" translate="yes" xml:space="preserve">
          <source>Add a small value to the outputs before rounding/formatting them which is smaller than or equal to 1/4 of the desired precision and bigger than the maximum expected error caused by rounding errors on input and during calculation. If that is not possible the combination of the precision of the used data type isn't enough to deliver the desired output precision for your calculation.</source>
          <target state="translated">在四舍五入前,在输出中加入一个小值,这个值要小于或等于所需精度的14,并且要大于输入和计算过程中的四舍五入误差造成的最大预期误差。如果不能做到这一点,则所使用的数据类型的精度组合不足以为您的计算提供所需的输出精度。</target>
        </trans-unit>
        <trans-unit id="9ec5991d0491a50ed072932cfd75f49e54ea8673" translate="yes" xml:space="preserve">
          <source>An arbitrary-precision Decimal type for JavaScript.</source>
          <target state="translated">JavaScript的任意精度十进制类型。</target>
        </trans-unit>
        <trans-unit id="22b59d0bd4142a0ac4d0949aed1e7a4055828148" translate="yes" xml:space="preserve">
          <source>Are you only performing multiplication?  If so then you can use to your advantage a neat secret about decimal arithmetic.  That is that &lt;code&gt;NumberOfDecimals(X) + NumberOfDecimals(Y) = ExpectedNumberOfDecimals&lt;/code&gt;. That is to say that if we have &lt;code&gt;0.123 * 0.12&lt;/code&gt; then we know that there will be 5 decimal places because &lt;code&gt;0.123&lt;/code&gt; has 3 decimal places and &lt;code&gt;0.12&lt;/code&gt; has two. Thus if JavaScript gave us a number like &lt;code&gt;0.014760000002&lt;/code&gt; we can safely round to the 5th decimal place without fear of losing precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您只执行乘法吗？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果是这样，那么您可以利用有关十进制算术的巧妙秘密。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那就是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;NumberOfDecimals(X) + NumberOfDecimals(Y) = ExpectedNumberOfDecimals&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也就是说，如果我们有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.123 * 0.12&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那么我们知道将有5个小数位，因为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.123&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有3个小数位，而&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.12&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有2 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;个小数位&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，如果JavaScript给我们一个像&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.014760000002&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的数字，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们可以安全地舍入到小数点后第五位，而不必担心精度下降。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c873412f7d33e43d993fd7170b2548732ae1976" translate="yes" xml:space="preserve">
          <source>Because the rounding adds an error which can cause the total error to be more then half of the desired precision, the output should be corrected based on expected precision of inputs and desired precision of output. You should</source>
          <target state="translated">因为四舍五入会增加一个误差,会导致总误差超过预期精度的一半,所以应该根据输入的预期精度和输出的预期精度来修正输出。您应该</target>
        </trans-unit>
        <trans-unit id="5292ab4ae2ac6f1f1671909362adce21a8d03efb" translate="yes" xml:space="preserve">
          <source>Big.js</source>
          <target state="translated">Big.js</target>
        </trans-unit>
        <trans-unit id="d66c7d4989fa88e8c1967fe5c794a60a171e4bb4" translate="yes" xml:space="preserve">
          <source>Does anyone have a good solution so that in such case I get the correct result &lt;code&gt;0.02&lt;/code&gt;? I know there are functions like &lt;code&gt;toFixed&lt;/code&gt; or rounding would be another possibility, but I'd like to really have the whole number printed without any cutting and rounding. Just wanted to know if one of you has some nice, elegant solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有没有人有一个好的解决方案，这样在这种情况下我可以获得正确的结果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.02&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我知道还有诸如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;toFixed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或四舍五入之&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类的函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是另一种可能性，但是我真的想在不进行任何舍入和四舍五入的情况下真正打印整个数字。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是想知道你们中的一个人是否有一些不错的，优雅的解决方案。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="c341e94c1b98a43dae4389df37cf0aada6e3fee0" translate="yes" xml:space="preserve">
          <source>Fix:</source>
          <target state="translated">Fix:</target>
        </trans-unit>
        <trans-unit id="4056e753845c8a8fd4a301c49e68620745f4fc19" translate="yes" xml:space="preserve">
          <source>Floating point can't store all decimal values exactly. So when using floating point formats there will always be rounding errors on the input values.
The errors on the inputs of course results on errors on the output.
In case of a discrete function or operator there can be big differences on the output around the point where the function or operator is discrete.</source>
          <target state="translated">浮点数不能准确地存储所有的小数点值。所以在使用浮点格式的时候,输入值总是会出现四舍五入的错误。当然,输入上的错误也会导致输出上的错误。如果是离散的函数或运算符,在函数或运算符离散的点周围,输出可能会有很大的差异。</target>
        </trans-unit>
        <trans-unit id="aeb92746f89ae3b376318f5f1b422a3f62e2d554" translate="yes" xml:space="preserve">
          <source>For the mathematically inclined: &lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于数学倾向：&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd67f72c65d9c61d8d2450191828d1627d8d5146" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://floating-point-gui.de/&quot;&gt;Floating-Point Guide&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://floating-point-gui.de/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮点指南&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3aade10752679fef5dd7ea1f4d15d9b02c98c3e" translate="yes" xml:space="preserve">
          <source>Have a look at &lt;a href=&quot;http://en.wikipedia.org/wiki/Fixed-point_arithmetic&quot;&gt;Fixed-point arithmetic&lt;/a&gt;. It will probably solve your problem, if the range of numbers you want to operate on is small (eg, currency). I would round it off to a few decimal values, which is the simplest solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;看一下&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Fixed-point_arithmetic&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定点算法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您要操作的数字范围较小（例如，货币），则可能会解决您的问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我会将其四舍五入为几个十进制值，这是最简单的解决方案。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b83cbd138fff23024c94f3b4bad484eafc94fff3" translate="yes" xml:space="preserve">
          <source>Here's some code using BigNumber:</source>
          <target state="translated">下面是一些使用BigNumber的代码。</target>
        </trans-unit>
        <trans-unit id="ee81411664de7bb4caaa5929799806ccb568b7b0" translate="yes" xml:space="preserve">
          <source>How to deal with floating point number precision in JavaScript</source>
          <target state="translated">如何处理JavaScript中的浮点数字精度问题</target>
        </trans-unit>
        <trans-unit id="c8df9c129f17bfcc385ced7492e4b82ccec5e93a" translate="yes" xml:space="preserve">
          <source>I definitely recommend using a tested library like &lt;a href=&quot;https://github.com/guipn/sinful.js/blob/master/sinful.js&quot;&gt;SinfulJS&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我绝对建议使用经过测试的库，例如&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/guipn/sinful.js/blob/master/sinful.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SinfulJS&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a853ef4121663b373e78e17939e2d11ca4c83986" translate="yes" xml:space="preserve">
          <source>I had a nasty rounding error problem with mod 3. Sometimes when I should get 0 I would get .000...01. That's easy enough to handle, just test for &amp;lt;= .01. But then sometimes I would get 2.99999999999998. OUCH!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我在mod 3上遇到了一个令人讨厌的舍入错误问题。有时，当我得到0时，我会得到.000 ... 01。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这很容易处理，只需测试&amp;lt;= .01。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是有时候我会得到2.99999999999998。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;哎哟！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9f9d35c2b34cb9f3475700d017c4d1185419e3c" translate="yes" xml:space="preserve">
          <source>I have the following dummy test script:</source>
          <target state="translated">我有以下假人测试脚本:</target>
        </trans-unit>
        <trans-unit id="ba55b9d67e3d6448720f1cc36080a3e415841b6d" translate="yes" xml:space="preserve">
          <source>I like Pedro Ladaria's solution and use something similar.</source>
          <target state="translated">我喜欢Pedro Ladaria的解决方案,并使用类似的东西。</target>
        </trans-unit>
        <trans-unit id="11e4c0a4884796e3eaf68f789faed2b433d2248f" translate="yes" xml:space="preserve">
          <source>I'm finding &lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;BigNumber.js&lt;/a&gt; meets my needs.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我发现&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigNumber.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;符合我的需求。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="970fc9047311aa9e995057a784ac862b33e2831e" translate="yes" xml:space="preserve">
          <source>If the first point really applies to you, use &lt;a href=&quot;https://web.archive.org/web/20150511085914/https://github.com/dtrebbien/BigDecimal.js&quot;&gt;BigDecimal for JavaScript&lt;/a&gt;, which is not elegant at all, but actually solves the problem rather than providing an imperfect workaround.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果第一点确实适用于您，请&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://web.archive.org/web/20150511085914/https://github.com/dtrebbien/BigDecimal.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对JavaScript&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigDecimal&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这一点都不优雅，但实际上可以解决问题，而不是提供不完善的解决方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f6e317ec81ade40f1e9e97cedccdc40678ac775d" translate="yes" xml:space="preserve">
          <source>If you are doing if-s/comparisons and don't want to cut of then you also need a small constant, usually called eps, which is one decimal place higher than max expected error. Say that your cut-off is last two decimals - then your eps has 1 at the 3rd place from the last (3rd least significant) and you can use it to compare whether the result is within eps range of expected (0.02 -eps &amp;lt; 0.1*0.2 &amp;lt; 0.02 +eps).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您要进行if-s /比较，并且不希望减少，则还需要一个小的常数，通常称为eps，该常数比最大期望误差高一个小数位。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设您的截止数是最后两位小数-那么您的eps在最后一位的第三位（最低有效位第三），您可以使用它来比较结果是否在预期的eps范围内（0.02 -eps &amp;lt;0.1 * 0.2 &amp;lt;0.02 + eps）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3fb645f140e6b7fba5cf80b199367d878602c09e" translate="yes" xml:space="preserve">
          <source>If you have no decimal datatype available, an alternative is to work
  with integers, e.g. do money
  calculations entirely in cents. But
  this is more work and has some
  drawbacks.</source>
          <target state="translated">如果你没有可用的十进制数据类型,另一种方法是使用整数,例如,完全用美分进行货币计算。但这是比较麻烦的,也有一些缺点。</target>
        </trans-unit>
        <trans-unit id="f9a231822977eedb774b63cec0c1a0376b172063" translate="yes" xml:space="preserve">
          <source>If you just don&amp;rsquo;t want to see all those extra decimal places: simply
  format your result rounded to a fixed
  number of decimal places when
  displaying it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您只是不想看到所有这些多余的小数位：只需在显示结果时将结果格式舍入为固定的小数位数即可。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42fc965d2e7933faeb52ad0042fa265db75c529f" translate="yes" xml:space="preserve">
          <source>If you really need your results to add up exactly, especially when you
  work with money: use a special decimal
  datatype.</source>
          <target state="translated">如果你真的需要你的结果精确地加起来,特别是当你处理钱的时候:使用特殊的十进制数据类型。</target>
        </trans-unit>
        <trans-unit id="d5f63b24009028d7cd1e82a2dcdac457c43a8f72" translate="yes" xml:space="preserve">
          <source>If you're dealing with floats &lt;em&gt;always&lt;/em&gt; expect small rounding errors, so you'll also always have to round the displayed result to something sensible. In return you get very very fast and powerful arithmetic because all the computations are in the native binary of the processor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果要处理浮点数，则&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总是会&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;期望出现较小的舍入误差，因此，您还必须始终将显示的结果舍入到合理的值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为回报，您将获得非常非常快速且强大的算法，因为所有计算都在处理器的本机二进制文件中。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76df916b62840bf387c4d5f679f0bb56b6c112cd" translate="yes" xml:space="preserve">
          <source>In this case:</source>
          <target state="translated">在这种情况下。</target>
        </trans-unit>
        <trans-unit id="dc35e05387823f39d75255f34cb157621bf93da5" translate="yes" xml:space="preserve">
          <source>It has good &lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;documentation&lt;/a&gt; and the author is very diligent responding to feedback.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它具有良好的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://mikemcl.github.io/bignumber.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文档&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，作者非常努力地回应反馈。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c0dbedb40544f549861aab974817b42583eb09a3" translate="yes" xml:space="preserve">
          <source>It is often more efficient to avoid these problems by using data types (integer or fixed point formats) for calculations like this which can store the expected input without rounding errors.
An example of that is that you should never use floating point values for financial calculations.</source>
          <target state="translated">通常情况下,使用数据类型(整数或定点格式)来进行这样的计算,可以存储预期的输入,而不会出现四舍五入的错误,这样的计算往往能更有效地避免这些问题。这方面的一个例子是,在财务计算中千万不要使用浮点值。</target>
        </trans-unit>
        <trans-unit id="448607d7ba223d62964e7cd11aa31257cd4a3f9c" translate="yes" xml:space="preserve">
          <source>Many systems omit working with decimals this way. That is the reason why many systems work with cents (as integer) instead of dollars/euro's (as floating point).</source>
          <target state="translated">许多系统都省略了小数的工作方式。这就是为什么很多系统都是用美分(作为整数)而不是美元(作为浮点数)来工作的原因。</target>
        </trans-unit>
        <trans-unit id="6d6f9a91ba210d6d0d8e1736e610c0911b4b3dfe" translate="yes" xml:space="preserve">
          <source>Most of the time the solution is not to switch to fixed-point arithmetic, mainly because it's much slower and 99% of the time you just don't need the accuracy. If you're dealing with stuff that does need that level of accuracy (for instance financial transactions) Javascript probably isn't the best tool to use anyway (as you've want to enforce the fixed-point types a static language is probably better).</source>
          <target state="translated">大多数时候,解决办法是不改用定点运算,主要是因为它的速度要慢得多,而且99%的时候,你不需要这样的精度。如果你要处理的东西确实需要那么高的精度(例如金融交易),Javascript可能不是最好的工具(因为你想强制执行定点类型,静态语言可能更好)。</target>
        </trans-unit>
        <trans-unit id="9bf7090b248473b9077c1c5f6937631d47c5fe07" translate="yes" xml:space="preserve">
          <source>Note that the first point only applies if you really need specific precise &lt;em&gt;decimal&lt;/em&gt; behaviour. Most people don't need that, they're just irritated that their programs don't work correctly with numbers like 1/10 without realizing that they wouldn't even blink at the same error if it occurred with 1/3.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，只有在您确实需要特定的精确&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;十进制&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行为时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，第一点才适用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大多数人并不需要它，只是因为他们的程序无法正确处理1/10之类的数字而感到恼火，却没有意识到如果发生1/3，即使出现相同的错误也不会眨眼。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb097215ec09eb0024375e4ae22d1c146c281243" translate="yes" xml:space="preserve">
          <source>Note: When dealing with 32 or 64 bit floats, you should use toPrecision(7) and toPrecision(15) for best results.  See &lt;a href=&quot;https://stackoverflow.com/questions/28045787/how-many-decimal-places-does-the-primitive-float-and-double-support&quot;&gt;this question&lt;/a&gt; for info as to why.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意：处理32或64位浮点数时，应使用toPrecision（7）和toPrecision（15）以获得最佳结果。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/28045787/how-many-decimal-places-does-the-primitive-float-and-double-support&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此问题&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的信息，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;见此问题&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="11195d73ee275b234990d7d7cb1e88d873fcca46" translate="yes" xml:space="preserve">
          <source>Notice that for the general purpose use, this behavior is likely to be acceptable.</source>
          <target state="translated">注意,对于一般的用途,这种行为很可能是可以接受的。</target>
        </trans-unit>
        <trans-unit id="3290637a00912e04380d8c64be613af76228d4bf" translate="yes" xml:space="preserve">
          <source>Numerical errors accumulate with every further operation and if you don't cut it off early it's just going to grow. Numerical libraries which present results that look clean simply cut off the last 2 digits at every step, numerical co-processors also have a &quot;normal&quot; and &quot;full&quot; lenght for the same reason. Cuf-offs are cheap for a processor but very expensive for you in a script (multiplying and dividing and using pov(...)). Good math lib would provide floor(x,n) to do the cut-off for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2839401e766a935656ba07eb6b9d6b7c03f3cac8" translate="yes" xml:space="preserve">
          <source>Of course that won't help much with irrational numbers. But you may want to optimize your computations in the way they will cause the least problem (e.g. detecting situations like &lt;code&gt;sqrt(3)^2)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，这对于无理数不会有太大帮助。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是您可能希望以它们引起最少问题的方式优化计算（例如，检测类似&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sqrt(3)^2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63652065953c408e91fa63939df078c88343bbe4" translate="yes" xml:space="preserve">
          <source>Of course, otherwise I'll round to some 10 digits or so.</source>
          <target state="translated">当然,否则我会四舍五入到10位数左右。</target>
        </trans-unit>
        <trans-unit id="56ceded875df16b30aabedd0be6143d73e5f2da8" translate="yes" xml:space="preserve">
          <source>Output using the following function:</source>
          <target state="translated">使用以下功能的产出:</target>
        </trans-unit>
        <trans-unit id="1a87200547de52dcba232ee8140c48ce625448de" translate="yes" xml:space="preserve">
          <source>Pay attention to the output &lt;code&gt;toFixedCurrency(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意&lt;/font&gt;&lt;/font&gt; &lt;code&gt;toFixedCurrency(x)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的输出&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7ccc77c464d68ec4d4d9bc39d5016a33fe1860ca" translate="yes" xml:space="preserve">
          <source>Round inputs to the expected precision or make sure no values can be entered with higher precision.</source>
          <target state="translated">四舍五入到预期的精度,或者确保不能输入精度较高的值。</target>
        </trans-unit>
        <trans-unit id="fea441daf71749c24a14635d2315d7865e68e5f8" translate="yes" xml:space="preserve">
          <source>Simple solution to ironic problem:</source>
          <target state="translated">简单的解决了讽刺的问题。</target>
        </trans-unit>
        <trans-unit id="5fa04705106510002b87a6a2c96b7082fb446b6c" translate="yes" xml:space="preserve">
          <source>So at the very least you should make global var/constant with pov(10,n) - meaning that you decided on the precision you need :-) Then do:</source>
          <target state="translated">所以,至少你应该用pov(10,n)做全局的varconstant---这意味着你决定了你需要的精度:-)那么就这样做。</target>
        </trans-unit>
        <trans-unit id="87f4cc4a8551195a42d1a9c700149f90f3ab76a5" translate="yes" xml:space="preserve">
          <source>So instead of performing the comparison like this</source>
          <target state="translated">所以,与其这样进行比较,还不如这样做</target>
        </trans-unit>
        <trans-unit id="04289cf569c9ea315b899e01e3ff8127ebce2c75" translate="yes" xml:space="preserve">
          <source>So, when using floating point variables, you should always be aware of this. And whatever output you want from a calculation with floating points should always be formatted/conditioned before displaying with this in mind.</source>
          <target state="translated">所以,在使用浮点变量时,你应该时刻注意这一点。而且无论你想从浮点计算中得到什么输出,都应该在显示之前考虑到这一点,进行格式化处理。</target>
        </trans-unit>
        <trans-unit id="a55f20d8ecae19b33f63d58dc9371e763bf4f2d9" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;http://2ality.com/2015/04/numbers-math-es6.html#numberepsilon&quot;&gt;http://2ality.com/2015/04/numbers-math-es6.html#numberepsilon&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;资料来源：&lt;/font&gt;&lt;a href=&quot;http://2ality.com/2015/04/numbers-math-es6.html#numberepsilon&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//2ality.com/2015/04/numbers-math-es6.html#numberepsilon&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d25e632121467e8635330d7167a552d2e9181c60" translate="yes" xml:space="preserve">
          <source>Surprisingly, this function has not been posted yet although others have similar variations of it. It is from the MDN web docs for Math.round().
It's concise and allows for varying precision.</source>
          <target state="translated">令人惊讶的是,这个函数还没有被发布,尽管其他人也有类似的变化。它来自于Math.round()的MDN web docs。它很简洁,而且允许不同的精度。</target>
        </trans-unit>
        <trans-unit id="87dbc587972268868e6cbe059d1ed329fd1a5fc4" translate="yes" xml:space="preserve">
          <source>That depends on what kind of
  calculations you&amp;rsquo;re doing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这取决于您正在执行哪种计算。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c927531832108bc06279d31503b601200af52f43" translate="yes" xml:space="preserve">
          <source>The problem arises when comparing those floating points values to determine an appropriate action.</source>
          <target state="translated">当比较这些浮点值来确定适当的行动时,问题就出现了。</target>
        </trans-unit>
        <trans-unit id="55b1d2cc4477268763bd5500964d5b184e3991ae" translate="yes" xml:space="preserve">
          <source>The recommended approach is to use correction factors (multiply by a suitable power of 10 so that the arithmetic happens between integers).  For example, in the case of &lt;code&gt;0.1 * 0.2&lt;/code&gt;, the correction factor is &lt;code&gt;10&lt;/code&gt;, and you are performing the calculation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;推荐的方法是使用校正因子（乘以10的适当幂，以便在整数之间进行算术运算）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.1 * 0.2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的情况下&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，校正因子为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;10&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您正在执行计算：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b6daa3471e97c035d55063d4c0b0d8e3d0cf9a7" translate="yes" xml:space="preserve">
          <source>The result you've got is correct and fairly consistent across floating point implementations in different languages, processors and operating systems - the only thing that changes is the level of the inaccuracy when the float is actually a double (or higher).</source>
          <target state="translated">你得到的结果是正确的,而且在不同的语言、处理器和操作系统中的浮点实现是相当一致的--唯一改变的是当浮点实际上是双倍(或更高)时的不准确程度。</target>
        </trans-unit>
        <trans-unit id="578414fc1ccf375f1c3022393ae84492ed9b86d6" translate="yes" xml:space="preserve">
          <source>The round() function at phpjs.org works nicely: &lt;a href=&quot;http://phpjs.org/functions/round&quot;&gt;http://phpjs.org/functions/round&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;phpjs.org上的round（）函数很好地工作：&lt;/font&gt;&lt;a href=&quot;http://phpjs.org/functions/round&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ://phpjs.org/functions/round&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7aa22287f011062f40011982b9b1e4267305ec01" translate="yes" xml:space="preserve">
          <source>The same author has 2 other similar libraries:</source>
          <target state="translated">同一作者还有2个类似的图书馆。</target>
        </trans-unit>
        <trans-unit id="45b18900669ce60100b2a8139e01034f4d63e1c4" translate="yes" xml:space="preserve">
          <source>These 2 things are usually not done and in most cases the differences caused by not doing them are too small to be important for most users, but I already had a project where output wasn't accepted by the users without those corrections.</source>
          <target state="translated">这2件事情通常是不做的,而且在大多数情况下,不做这2件事情造成的差异太小,对大多数用户来说是不重要的,但我已经有一个项目,在没有这些修正的情况下,输出不被用户接受。</target>
        </trans-unit>
        <trans-unit id="995e6adcd7dd4e903f9034755d0f02e5f32e42e5" translate="yes" xml:space="preserve">
          <source>These conditions work correctly:</source>
          <target state="translated">这些条件都能正常工作。</target>
        </trans-unit>
        <trans-unit id="30a1e69eaf576087f4adc95f66859b6980b7efbd" translate="yes" xml:space="preserve">
          <source>This function will determine the needed precision from the multiplication of two floating point numbers and return a result with the appropriate precision. Elegant though it is not.</source>
          <target state="translated">该函数将从两个浮点数的乘法运算中确定所需的精度,并返回一个具有适当精度的结果。虽然很优雅,但它并不优雅。</target>
        </trans-unit>
        <trans-unit id="1c60c8cf88cdadc5ddf53a3cf7f9de9f9bf4f000" translate="yes" xml:space="preserve">
          <source>This just adds a digit to the right when rounding decimals.
MDN has updated the Math.round page so maybe someone could provide a 
better solution.</source>
          <target state="translated">这只是在小数点四舍五入时在右边增加了一个数字。MDN已经更新了Math.round页面,也许有人可以提供一个更好的解决方案。</target>
        </trans-unit>
        <trans-unit id="22f1374e80bb9c8ef8c66feafcef8948c3f17d13" translate="yes" xml:space="preserve">
          <source>This will print the result &lt;code&gt;0.020000000000000004&lt;/code&gt; while it should just print &lt;code&gt;0.02&lt;/code&gt; (if you use your calculator). As far as I understood this is due to errors in the floating point multiplication precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将打印结果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.020000000000000004&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而应该只打印&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.02&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（如果使用计算器）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;据我了解，这是由于浮点乘法精度的错误。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b4e4dd5dedd60c21b1e2d40ef5986a69c044c8f" translate="yes" xml:space="preserve">
          <source>This works for me:</source>
          <target state="translated">这对我来说很有效。</target>
        </trans-unit>
        <trans-unit id="41a41835f3c82af8647a7b77cb179b50a5405429" translate="yes" xml:space="preserve">
          <source>To avoid this you should work with integer values instead of floating points. So when you want to have 2 positions precision work with the values * 100, for 3 positions use 1000. When displaying you use a formatter to put in the separator.</source>
          <target state="translated">为了避免这种情况,你应该使用整数值而不是浮点。所以当你想让2个位置的精度用*100,3个位置用1000。在显示的时候,你要用一个格式化器来输入分隔符。</target>
        </trans-unit>
        <trans-unit id="9f4481943972d21f141fcea329ac4f83c9332934" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;http://www.diveintojavascript.com/projects/javascript-sprintf&quot;&gt;javascript-sprintf&lt;/a&gt;, you would call it like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.diveintojavascript.com/projects/javascript-sprintf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;javascript-sprintf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您将这样称呼它：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7818ea1fdff45e1ca14750be6d4169bfaee57e85" translate="yes" xml:space="preserve">
          <source>Try my chiliadic arithmetic library, which you can see &lt;a href=&quot;http://www.daniweb.com/forums/thread222006.html&quot;&gt;here&lt;/a&gt;.
If you want a later version, I can get you one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试一下我的Chiliadic算术库，您可以&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.daniweb.com/forums/thread222006.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;看到&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您想要更高的版本，我可以帮助您。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="069816246ed77462eefa613586edbd76e4fd87a2" translate="yes" xml:space="preserve">
          <source>UPDATE: Aug/20/2019
Just noticed this error. I believe it's due to a floating point precision error with Math.round().</source>
          <target state="translated">UPDATE:Aug202019刚刚注意到这个错误。我认为是由于Math.round()的浮点精度错误造成的。</target>
        </trans-unit>
        <trans-unit id="16e517b2e990ed3cf70be817c23709bd8d7accfa" translate="yes" xml:space="preserve">
          <source>Unlike Pedros solution this will round up 0.999...repeating and is accurate to plus/minus one on the least significant digit.</source>
          <target state="translated">与Pedros的解决方案不同的是,这个方案可以四舍五入0.999...........重复,并且精确到最小的数字上的加减1。</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">Use</target>
        </trans-unit>
        <trans-unit id="c9fa3b375e9e156eb9d66c9445e57dd3139fe0c4" translate="yes" xml:space="preserve">
          <source>Use Number(1.234443).toFixed(2); it will print 1.23</source>
          <target state="translated">使用Number(1.234443).toFixed(2);它将打印1.23</target>
        </trans-unit>
        <trans-unit id="8dbb2394fd5cea4a5a0bceabe5ea9e242ad8b66c" translate="yes" xml:space="preserve">
          <source>Very very simple))</source>
          <target state="translated">非常简单))</target>
        </trans-unit>
        <trans-unit id="a6dda06638f436253a8d23045c0f9134a35f024c" translate="yes" xml:space="preserve">
          <source>When discrete operators or functions are involved, extra corrections might be required to make sure the output is as expected. Rounding and adding small corrections before rounding can't solve the problem.</source>
          <target state="translated">当涉及到离散运算符或函数时,可能需要进行额外的修正,以确保输出符合预期。四舍五入和在四舍五入之前添加小的修正是不能解决问题的。</target>
        </trans-unit>
        <trans-unit id="99becbd0dffc744e204763d33ed726f31f4a99ac" translate="yes" xml:space="preserve">
          <source>When only continuous functions and operators are used, rounding to the desired precision often will do (don't truncate).  Standard formatting features used to convert floats to string will usually do this for you.</source>
          <target state="translated">当只使用连续函数和运算符时,通常四舍五入到所需的精度就可以了(不要截断)。用于将浮点数转换为字符串的标准格式化功能通常可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="c6d73c873914a39afca0e4eb9a2e40a4035e5e08" translate="yes" xml:space="preserve">
          <source>With the advent of ES6, a new constant &lt;code&gt;Number.EPSILON&lt;/code&gt; is defined to determine the acceptable error margin :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;随着ES6的到来，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定义了&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个新的常量&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来确定可接受的误差范围：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14be6040fc36980e04bebea70f3f947216b405d0" translate="yes" xml:space="preserve">
          <source>You are looking for an &lt;code&gt;sprintf&lt;/code&gt; implementation for JavaScript, so that you can write out floats with small errors in them (since they are stored in binary format) in a format that you expect.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您正在寻找&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaScript &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sprintf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实现，以便可以以期望的格式写出带有小错误的浮点数（因为它们以二进制格式存储）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec9ba5ceb02278a88d554e12764f6b29484e13fb" translate="yes" xml:space="preserve">
          <source>You are right, the reason for that is limited precision of floating point numbers. Store your rational numbers as a division of two integer numbers and in most situations you'll be able to store numbers without any precision loss. When it comes to printing, you may want to display the result as fraction. With representation I proposed, it becomes trivial.</source>
          <target state="translated">你说的没错,原因是浮点数的精度有限。将有理数存储为两个整数的除法,在大多数情况下,你就可以在不损失任何精度的情况下存储数字。当涉及到打印的时候,你可能会想把结果显示为分数。有了我提出的表示法,这就变得琐碎了。</target>
        </trans-unit>
        <trans-unit id="4ffd7bd84840ca50d76440ccf8ca0c3594bc487e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;parseFloat()&lt;/code&gt; and &lt;code&gt;toFixed()&lt;/code&gt; if you want to bypass this issue for a small operation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您想通过一个较小的操作来绕过此问题，则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parseFloat()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;toFixed()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="40157fe7c1bc40e6a5655614855b704359d6e483" translate="yes" xml:space="preserve">
          <source>You can't represent most decimal fractions exactly with binary floating point types (which is what ECMAScript uses to represent floating point values). So there isn't an elegant solution unless you use arbitrary precision arithmetic types or a decimal based floating point type. For example, &lt;a href=&quot;http://blogs.msdn.com/b/oldnewthing/archive/2004/05/25/141253.aspx&quot;&gt;the Calculator app that ships with Windows now uses arbitrary precision arithmetic to solve this problem&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您不能完全使用二进制浮点类型（这是ECMAScript用来表示浮点值）来精确表示大多数小数部分。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，除非您使用任意精度的算术类型或基于十进制的浮点类型，否则没有一个好的解决方案。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msdn.com/b/oldnewthing/archive/2004/05/25/141253.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Windows附带的Calculator应用程序现在使用任意精度算法来解决此问题&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1cfea31bd9e2d6a6462a80aa994ae5ee23456ce" translate="yes" xml:space="preserve">
          <source>You could also keep doing math and only cut-off at the end - assuming that you are only displaying and not doing if-s with results. If you can do that, then .toFixed(...) might be more efficient.</source>
          <target state="translated">你也可以继续做数学运算,只在最后截断--假设你只显示而不是用结果做if-s。如果你可以这样做,那么.toFixed(...)可能会更有效。</target>
        </trans-unit>
        <trans-unit id="efdde9427ae67b144eb864b034a322d41713c6fa" translate="yes" xml:space="preserve">
          <source>You just have to make up your mind on how many decimal digits you actually want - can't have the cake and eat it too :-)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92e6abf5f2b79acdec60ef0de73fe34f00ef252" translate="yes" xml:space="preserve">
          <source>You may also use  &lt;a href=&quot;http://www.w3schools.com/jsref/jsref_tofixed.asp&quot;&gt;Number.toFixed()&lt;/a&gt;  for display purposes, if you'd rather not include  more files merely for floating point rounding to a given precision.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 如果您不想仅出于浮点舍入到给定精度的目的而添加更多文件，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也可以将 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.w3schools.com/jsref/jsref_tofixed.asp&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Number.toFixed（）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用于显示目的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edfa60213bd8f2d844928a429d60cb63e965db84" translate="yes" xml:space="preserve">
          <source>You're looking for the elegant solution then I'm afraid this is it: floats are quick but have small rounding errors - always round to something sensible when displaying their results.</source>
          <target state="translated">你正在寻找优雅的解决方案,那么恐怕就是这个了:浮子速度快,但有小的四舍五入误差--显示结果时,总是要四舍五入到合理的东西。</target>
        </trans-unit>
        <trans-unit id="4eab28434b44398092c734e075943f499d2e137c" translate="yes" xml:space="preserve">
          <source>and &lt;a href=&quot;https://github.com/MikeMcl/decimal.js/&quot;&gt;Decimal.js&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/MikeMcl/decimal.js/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Decimal.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31fbdc945417c8ee525f933924cfe13a7f2424af" translate="yes" xml:space="preserve">
          <source>big.js: minimalist; easy-to-use; precision specified in decimal places; precision applied to division only.</source>
          <target state="translated">big.js:极简主义;易于使用;精度以小数位指定;精度仅适用于除法。</target>
        </trans-unit>
        <trans-unit id="b09fe83f641a1a95cde4fd67164f2ee057e13d0a" translate="yes" xml:space="preserve">
          <source>bignumber.js: bases 2-64; configuration options; NaN; Infinity; precision specified in decimal places; precision applied to division only; base prefixes.</source>
          <target state="translated">bignumber.js:基数为2-64;配置选项;NaN;无穷大;精度以小数位指定;精度仅适用于除法;基数前缀。</target>
        </trans-unit>
        <trans-unit id="ca0fb1811849befef678634dcad67c0b4854e51b" translate="yes" xml:space="preserve">
          <source>console.log((parseFloat(0.1) + parseFloat(0.2)).toFixed(1) == parseFloat(0.3).toFixed(1));</source>
          <target state="translated">console.log((((parseFloat(0.1)+parseFloat(0.2))).toFixed(1)==parseFloat(0.3).toFixed(1)))。</target>
        </trans-unit>
        <trans-unit id="a72717b86f4f1d0fa2a38b2fab25f2b271a2264a" translate="yes" xml:space="preserve">
          <source>console.log(precisionRound(1234.5678, -1));
   // expected output: 1230</source>
          <target state="translated">console.log(precisionRound(1234.5678,-1));/预期输出。1230</target>
        </trans-unit>
        <trans-unit id="d0fef98d2af7d1d1a6c13739c51a505822c3b782" translate="yes" xml:space="preserve">
          <source>console.log(precisionRound(1234.5678, 1));
   // expected output: 1234.6</source>
          <target state="translated">console.log(precisionRound(1234.5678,1));/预期输出。1234.6</target>
        </trans-unit>
        <trans-unit id="057764ffca879ed98c1fe3d95161aa733b9b4ef2" translate="yes" xml:space="preserve">
          <source>decimal.js: bases 2-64; configuration options; NaN; Infinity; non-integer powers, exp, ln, log; precision specified in significant digits; precision always applied; random numbers.</source>
          <target state="translated">decimal.js:基数为2-64;配置选项;NaN;无穷大;非整数次方,exp,ln,log;精度指定为重要数字;精度始终应用;随机数。</target>
        </trans-unit>
        <trans-unit id="da3f5b4eb74efe48286815d68ffd305b61e0751e" translate="yes" xml:space="preserve">
          <source>link to detailed comparisons</source>
          <target state="translated">详细比较的链接</target>
        </trans-unit>
        <trans-unit id="9cbee38ce3307e66953c2a713e6ab5747f3d951e" translate="yes" xml:space="preserve">
          <source>not elegant but does the job (removes trailing zeros)</source>
          <target state="translated">不雅观,但也很好用</target>
        </trans-unit>
        <trans-unit id="4fcdee7cbb8d16776e4fba9f1cd17e31d1427924" translate="yes" xml:space="preserve">
          <source>to print out your number as a float with two decimal places.</source>
          <target state="translated">用来打印出你的数字作为一个带两位小数的浮点数。</target>
        </trans-unit>
        <trans-unit id="428fd5c08f7f539b3d5e5c5b24c3f54e50e227a7" translate="yes" xml:space="preserve">
          <source>while adding two  float value its never give the precise values so we need to fixed this to certain number that will help us to compare.</source>
          <target state="translated">当添加两个浮动值时,它永远不会给出精确的值,所以我们需要将其固定为一定的数字,这将帮助我们进行比较。</target>
        </trans-unit>
        <trans-unit id="e8f984f0c891a245d25e57c3d16b020e0d0d3e8d" translate="yes" xml:space="preserve">
          <source>you can define a custom compare function, like this :</source>
          <target state="translated">你可以定义一个自定义的比较函数,像这样。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
