<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1461432">
    <body>
      <group id="1461432">
        <trans-unit id="c2404ea2f29e7ab77959bfb06fcb1abdcc2f6bfb" translate="yes" xml:space="preserve">
          <source>&quot;Decay&quot; refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from &quot;N-element array of T&quot; to &quot;pointer to T&quot; and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt; operators, or the array is a string literal being used as an initializer in a declaration.</source>
          <target state="translated">&quot;Decaimiento&quot; se refiere a la conversi&amp;oacute;n impl&amp;iacute;cita de una expresi&amp;oacute;n de un tipo de matriz a un tipo de puntero. En la mayor&amp;iacute;a de los contextos, cuando el compilador ve una expresi&amp;oacute;n de matriz, convierte el tipo de expresi&amp;oacute;n de &quot;matriz de elementos N de T&quot; a &quot;puntero a T&quot; y establece el valor de la expresi&amp;oacute;n en la direcci&amp;oacute;n del primer elemento de la matriz . Las excepciones a esta regla son cuando una matriz es un operando de los operadores &lt;code&gt;sizeof&lt;/code&gt; o &lt;code&gt;&amp;amp;&lt;/code&gt; , o la matriz es un literal de cadena que se utiliza como inicializador en una declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fef5835d12d6938604c510c22163d431de85b202" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Arrays, in C, have no value.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Las matrices, en C, no tienen valor.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe835ea58c4d708d4f4a321d5b813bf895ce8133" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr_to_first_element&lt;/code&gt; is a simple pointer to char.</source>
          <target state="translated">&lt;code&gt;ptr_to_first_element&lt;/code&gt; es un puntero simple a char.</target>
        </trans-unit>
        <trans-unit id="c83d8701def450df5855c504c476be72a0e69b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof()&lt;/code&gt; gives the size taken up by the array, not the size of a pointer.</source>
          <target state="translated">&lt;code&gt;sizeof()&lt;/code&gt; proporciona el tama&amp;ntilde;o que ocupa la matriz, no el tama&amp;ntilde;o de un puntero.</target>
        </trans-unit>
        <trans-unit id="352817c6a3ad6badcefa105a8b04e5ee011102d1" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 The constant U should be known at compile-time.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1 La constante U debe conocerse en tiempo de compilaci&amp;oacute;n.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="87f646e9df809142304089153cda433ffa37875b" translate="yes" xml:space="preserve">
          <source>Actually, it's just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.</source>
          <target state="translated">En realidad,es sólo que si quieres pasar una matriz en algún lugar,pero se pasa el puntero en su lugar (porque quién diablos pasaría toda la matriz por ti),la gente dice que esa pobre matriz se descompuso en puntero.</target>
        </trans-unit>
        <trans-unit id="5e6b27cbe389e55e514a50765e64ae7f3252c7df" translate="yes" xml:space="preserve">
          <source>Again, when an array is an operand of &lt;code&gt;sizeof&lt;/code&gt;, it's not converted to a pointer type.</source>
          <target state="translated">Nuevamente, cuando una matriz es un operando de &lt;code&gt;sizeof&lt;/code&gt; , no se convierte en un tipo de puntero.</target>
        </trans-unit>
        <trans-unit id="943937f9cb4127159565add162479c03bf6ba720" translate="yes" xml:space="preserve">
          <source>An lvalue or rvalue of type &amp;ldquo;array of N T&amp;rdquo; or &amp;ldquo;array of unknown bound of T&amp;rdquo; &lt;strong&gt;can&lt;/strong&gt; be converted to an rvalue
  of type &amp;ldquo;pointer to T.&amp;rdquo;</source>
          <target state="translated">Un valor o valor de tipo &quot;matriz de N T&quot; o &quot;matriz de l&amp;iacute;mite desconocido de T&quot; &lt;strong&gt;se&lt;/strong&gt; puede convertir en un valor de tipo &quot;puntero a T&quot;.</target>
        </trans-unit>
        <trans-unit id="572d04428c30798e603b05f06992752d438676f3" translate="yes" xml:space="preserve">
          <source>Array decaying means that, when an array is passed as a parameter to a function, it's treated identically to (&quot;decays to&quot;) a pointer.</source>
          <target state="translated">El decaimiento de los arreglos significa que,cuando se pasa un arreglo como parámetro a una función,se trata de manera idéntica a (&quot;decae&quot;)un puntero.</target>
        </trans-unit>
        <trans-unit id="2504de460ca48ca652515d2e95d788ac6397c47d" translate="yes" xml:space="preserve">
          <source>Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:</source>
          <target state="translated">Los arreglos son básicamente lo mismo que los punteros en CC++,pero no del todo.Una vez que conviertes un arreglo:</target>
        </trans-unit>
        <trans-unit id="f6b98d449f169ec5000ed0687a72f8d69aaa611a" translate="yes" xml:space="preserve">
          <source>Assume the following code:</source>
          <target state="translated">Asume el siguiente código:</target>
        </trans-unit>
        <trans-unit id="d623c4ac7a1b6a2336cd3de0984beb4c6ce2f3a5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;ptr_to_first_element&lt;/code&gt; and &lt;code&gt;ptr_to_array&lt;/code&gt; have the same &lt;em&gt;value&lt;/em&gt;; the base address of a.  However, they are different types and are treated differently, as shown below:</source>
          <target state="translated">Tanto &lt;code&gt;ptr_to_first_element&lt;/code&gt; como &lt;code&gt;ptr_to_array&lt;/code&gt; tienen el mismo &lt;em&gt;valor&lt;/em&gt; ; la direcci&amp;oacute;n base de a. Sin embargo, son diferentes tipos y se tratan de manera diferente, como se muestra a continuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="c0ba2510f593d5c4730c7b53d78941d20631790f" translate="yes" xml:space="preserve">
          <source>Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a
  string literal used to initialize an array, an expression that has type &amp;lsquo;&amp;lsquo;array of type&amp;rsquo;&amp;rsquo; is
  converted to an expression with type &amp;lsquo;&amp;lsquo;pointer to type&amp;rsquo;&amp;rsquo; that points to the initial element of
  the array object and is not an lvalue.</source>
          <target state="translated">Excepto cuando es el operando del operador sizeof o el operador unario &amp;amp;, o es un literal de cadena utilizado para inicializar una matriz, una expresi&amp;oacute;n que tiene el tipo '' matriz de tipo '' se convierte en una expresi&amp;oacute;n con tipo '' puntero a escriba '' que apunta al elemento inicial del objeto de matriz y no es un valor l.</target>
        </trans-unit>
        <trans-unit id="e4620cd591c8d41594b31aea3b33cac9222653f8" translate="yes" xml:space="preserve">
          <source>First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.</source>
          <target state="translated">Primero,cuando se trata de conjuntos multidimensionales en C y C++,sólo se pierde la primera dimensión.Esto se debe a que las matrices están dispuestas contiguamente en la memoria,por lo que el compilador debe saber todo menos la primera dimensión para poder calcular las compensaciones en ese bloque de memoria.</target>
        </trans-unit>
        <trans-unit id="b67d5b515aef01ab7697545039259ee6299aa621" translate="yes" xml:space="preserve">
          <source>For more details, check out this &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot;&gt;article about array decay&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte este &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot;&gt;art&amp;iacute;culo sobre la disminuci&amp;oacute;n de la matriz&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66a3f61a4f5c9cc8f0c9f707c2704a039bff9f2c" translate="yes" xml:space="preserve">
          <source>Function foo expects the value of an array. But, in C, arrays have no value! So &lt;code&gt;foo&lt;/code&gt; gets instead the address of the first element of the array.</source>
          <target state="translated">La funci&amp;oacute;n foo espera el valor de una matriz. Pero, en C, &amp;iexcl;las matrices no tienen valor! Entonces, &lt;code&gt;foo&lt;/code&gt; obtiene la direcci&amp;oacute;n del primer elemento de la matriz.</target>
        </trans-unit>
        <trans-unit id="93ddb0141afd9ecfa44949d318cd4b180a79e263" translate="yes" xml:space="preserve">
          <source>Here's what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):</source>
          <target state="translated">Esto es lo que dice la norma (C99 6.3.2.13-Otros operandos-Valores,matrices y designadores de función):</target>
        </trans-unit>
        <trans-unit id="2f69062bcf9c16e967805dcc3676465f9bdff391" translate="yes" xml:space="preserve">
          <source>I might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.</source>
          <target state="translated">También podría pensar que esto muestra la superioridad de C++vs C.Al menos en la referencia (juego de palabras)de pasar una matriz por referencia.</target>
        </trans-unit>
        <trans-unit id="2bbc8143578adf65237b78876ca44811525cc8b6" translate="yes" xml:space="preserve">
          <source>I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.</source>
          <target state="translated">Podría ser tan audaz como para pensar que hay cuatro (4)maneras de pasar una matriz como el argumento de la función.También aquí está el código corto pero de trabajo para su lectura.</target>
        </trans-unit>
        <trans-unit id="7264ad7e3ffb4141844d0c336996116af4bb0122" translate="yes" xml:space="preserve">
          <source>If you're passing an array by value, what you're really doing is copying a pointer - a pointer to the array's first element is copied to the parameter (whose type should also be a pointer the array element's type). This works due to array's decaying nature; once decayed, &lt;code&gt;sizeof&lt;/code&gt; no longer gives the complete array's size, because it essentially becomes a pointer.  This is why it's preferred (among other reasons) to pass by reference or pointer.</source>
          <target state="translated">Si est&amp;aacute; pasando una matriz por valor, lo que realmente est&amp;aacute; haciendo es copiar un puntero: un puntero al primer elemento de la matriz se copia en el par&amp;aacute;metro (cuyo tipo tambi&amp;eacute;n debe ser un puntero del tipo del elemento de matriz). Esto funciona debido a la naturaleza decadente de la matriz; una vez deca&amp;iacute;do, &lt;code&gt;sizeof&lt;/code&gt; ya no da el tama&amp;ntilde;o completo de la matriz, porque esencialmente se convierte en un puntero. Es por eso que se prefiere (entre otras razones) pasar por referencia o puntero.</target>
        </trans-unit>
        <trans-unit id="2426ce0cfd2ae39e025a59289febb3d5f7fe28cd" translate="yes" xml:space="preserve">
          <source>In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it &quot;decays into a pointer&quot; (sic); when you compare an array to something else, again it &quot;decays into a pointer&quot; (sic); ...</source>
          <target state="translated">En una función,todos los parámetros se pasan por valor (los arrays no son una excepción).Cuando se pasa una matriz en una función &quot;decae en un puntero&quot; (sic);cuando se compara una matriz con otra cosa,de nuevo &quot;decae en un puntero&quot; (sic);...</target>
        </trans-unit>
        <trans-unit id="ca3ac27f8fa7044755eff98bdc26d22a299a16a3" translate="yes" xml:space="preserve">
          <source>In the array indexing syntax you are used to seeing, again, the arr is 'decayed to a pointer'</source>
          <target state="translated">En la sintaxis de indexación de la matriz que estás acostumbrado a ver,de nuevo,la matriz está &quot;decaída a un puntero</target>
        </trans-unit>
        <trans-unit id="3acf04b7e934c50f3341e33ecbf3ddba739d41a7" translate="yes" xml:space="preserve">
          <source>In the comparison above, &lt;code&gt;arr&lt;/code&gt; has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable &lt;code&gt;ip&lt;/code&gt;.</source>
          <target state="translated">En la comparaci&amp;oacute;n anterior, &lt;code&gt;arr&lt;/code&gt; no tiene valor, por lo que se convierte en un puntero. Se convierte en un puntero a int. Ese puntero se puede comparar con la variable &lt;code&gt;ip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a608dabdd48971d982bdee712aa38cc50d33cc1" translate="yes" xml:space="preserve">
          <source>It's said that arrays &quot;decay&quot; into pointers.  A C++ array declared as &lt;code&gt;int numbers [5]&lt;/code&gt; cannot be re-pointed, i.e. you can't say &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt;. More importantly the term decay signifies loss of type and dimension; &lt;code&gt;numbers&lt;/code&gt; decay into &lt;code&gt;int*&lt;/code&gt; by losing the dimension information (count 5) and the type is not &lt;code&gt;int [5]&lt;/code&gt; any more. Look here for &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;cases where the decay doesn't happen&lt;/a&gt;.</source>
          <target state="translated">Se dice que las matrices &quot;decaen&quot; en punteros. Una matriz C ++ declarada como &lt;code&gt;int numbers [5]&lt;/code&gt; no se puede volver a se&amp;ntilde;alar, es decir, no se puede decir &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt; . M&amp;aacute;s importante a&amp;uacute;n, el t&amp;eacute;rmino decaimiento significa p&amp;eacute;rdida de tipo y dimensi&amp;oacute;n; &lt;code&gt;numbers&lt;/code&gt; decaen en &lt;code&gt;int*&lt;/code&gt; al perder la informaci&amp;oacute;n de dimensi&amp;oacute;n (cuenta 5) y el tipo ya no es &lt;code&gt;int [5]&lt;/code&gt; . Mire aqu&amp;iacute; para ver &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;casos en los que la descomposici&amp;oacute;n no ocurre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75b81db01f0edec0fed30d115d6b7d3ba38da199" translate="yes" xml:space="preserve">
          <source>It's when array rots and is being pointed at ;-)</source>
          <target state="translated">Es cuando la matriz se pudre y es apuntada ;-)</target>
        </trans-unit>
        <trans-unit id="d717086108630d7af551627a6f2f8097ecdd3d6e" translate="yes" xml:space="preserve">
          <source>Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn't cause nearly as much confusion as the automatic conversion of array names to pointers.</source>
          <target state="translated">Obsérvese que los nombres de las funciones actúan de manera similar,pero los punteros de las funciones se utilizan mucho menos y de una manera mucho más especializada que no causa casi tanta confusión como la conversión automática de los nombres de las matrices en punteros.</target>
        </trans-unit>
        <trans-unit id="f7e7f226b763b9d9ec2e0712651895d6237a9ebf" translate="yes" xml:space="preserve">
          <source>Of course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.</source>
          <target state="translated">Por supuesto que hay proyectos muy estrictos sin asignación de montones,sin excepciones y sin std::lib.El manejo de matrices nativas en C++es una característica del lenguaje de misión crítica,se podría decir.</target>
        </trans-unit>
        <trans-unit id="b67d400e1ef3e4e91eee3d3d9e452dd5495d95ea" translate="yes" xml:space="preserve">
          <source>Remember that the expression &lt;code&gt;a[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(a+i)&lt;/code&gt; (which only works if the array type is converted to a pointer type), so both &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; work the same. The expression &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(*a+i)&lt;/code&gt;.  The expressions &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; and &lt;code&gt;ptr_to_array[i]&lt;/code&gt; may lead to compiler warnings or errors depending on the context; they'll definitely do the wrong thing if you're expecting them to evaluate to &lt;code&gt;a[i]&lt;/code&gt;.</source>
          <target state="translated">Recuerde que la expresi&amp;oacute;n &lt;code&gt;a[i]&lt;/code&gt; se interpreta como &lt;code&gt;*(a+i)&lt;/code&gt; (que solo funciona si el tipo de matriz se convierte en un tipo de puntero), por lo que tanto &lt;code&gt;a[i]&lt;/code&gt; como &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; funcionan igual. La expresi&amp;oacute;n &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; se interpreta como &lt;code&gt;*(*a+i)&lt;/code&gt; . Las expresiones &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; y &lt;code&gt;ptr_to_array[i]&lt;/code&gt; pueden provocar advertencias o errores del compilador seg&amp;uacute;n el contexto; definitivamente har&amp;aacute;n lo incorrecto si esperas que eval&amp;uacute;en a &lt;code&gt;a[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21f571aadabef22c86699783c6de4b70ecead3c5" translate="yes" xml:space="preserve">
          <source>Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot;&gt;strcpy_s&lt;/a&gt;, and you can use a similar trick to reliably &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;get the number of elements in an array&lt;/a&gt;.</source>
          <target state="translated">En segundo lugar, en C ++, puede usar plantillas para deducir el tama&amp;ntilde;o de las matrices. Microsoft usa esto para las versiones C ++ de las funciones de Secure CRT como &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot;&gt;strcpy_s&lt;/a&gt; , y puede usar un truco similar para &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;obtener de&lt;/a&gt; manera confiable el n&amp;uacute;mero de elementos en una matriz .</target>
        </trans-unit>
        <trans-unit id="4cf7e537136bba43900f7f51100e034763e82e5d" translate="yes" xml:space="preserve">
          <source>So the conversion doesn't &lt;em&gt;have&lt;/em&gt; to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).</source>
          <target state="translated">Por lo tanto, la conversi&amp;oacute;n no &lt;em&gt;tiene&lt;/em&gt; que suceder como siempre ocurre en C (esto permite que las funciones se sobrecarguen o que las plantillas coincidan con el tipo de matriz).</target>
        </trans-unit>
        <trans-unit id="1f64d5bdb8222551b4c814f7020160a0c4d446a4" translate="yes" xml:space="preserve">
          <source>Sort-of exceptions to this rule:</source>
          <target state="translated">Hay más o menos excepciones a esta regla:</target>
        </trans-unit>
        <trans-unit id="374991ae64032aa0b674020550de47cc0d02fc4b" translate="yes" xml:space="preserve">
          <source>The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):</source>
          <target state="translated">El estándar C++(4.2 Conversión de matriz a puntero)afloja el requisito de conversión a (mina de énfasis):</target>
        </trans-unit>
        <trans-unit id="a0b4a750f64a796bb9c9e478100e4e15af5d260e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;a&lt;/code&gt; is of type &quot;80-element array of char&quot; and the expression &quot;This is a test&quot; is of type &quot;16-element array of char&quot; (in C; in C++ string literals are arrays of const char).  However, in the call to &lt;code&gt;strcpy()&lt;/code&gt;, neither expression is an operand of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, so their types are implicitly converted to &quot;pointer to char&quot;, and their values are set to the address of the first element in each.  What &lt;code&gt;strcpy()&lt;/code&gt; receives are not arrays, but pointers, as seen in its prototype:</source>
          <target state="translated">La expresi&amp;oacute;n &lt;code&gt;a&lt;/code&gt; es del tipo &quot;matriz de char de 80 elementos&quot; y la expresi&amp;oacute;n &quot;Esta es una prueba&quot; es del tipo &quot;matriz de char de 16 elementos&quot; (en C; en C ++ los literales de cadena son matrices de const char). Sin embargo, en la llamada a &lt;code&gt;strcpy()&lt;/code&gt; , ninguna expresi&amp;oacute;n es un operando de &lt;code&gt;sizeof&lt;/code&gt; o &lt;code&gt;&amp;amp;&lt;/code&gt; , por lo que sus tipos se convierten impl&amp;iacute;citamente en &quot;puntero a char&quot;, y sus valores se establecen en la direcci&amp;oacute;n del primer elemento en cada uno. Lo que &lt;code&gt;strcpy()&lt;/code&gt; recibe no son matrices, sino punteros, como se ve en su prototipo:</target>
        </trans-unit>
        <trans-unit id="cc1f2c92734a69f415a5acffe3a57fc184a7af29" translate="yes" xml:space="preserve">
          <source>The last two will give proper &lt;code&gt;sizeof&lt;/code&gt; info, while the first one won't since the array argument has decayed to be assigned to the parameter.</source>
          <target state="translated">Los dos &amp;uacute;ltimos dar&amp;aacute;n el &lt;code&gt;sizeof&lt;/code&gt; adecuado de informaci&amp;oacute;n, mientras que el primero no lo har&amp;aacute;, ya que el argumento de matriz ha deca&amp;iacute;do para asignarse al par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="96d0631bd8e97056f77f41e42872acd43b78edf7" translate="yes" xml:space="preserve">
          <source>The only times an array doesn't decay into a pointer are when it is the operand of the sizeof operator, or the &amp;amp; operator (the 'address of' operator), or as a string literal used to initialize a character array.</source>
          <target state="translated">Las &amp;uacute;nicas veces que una matriz no se descompone en un puntero es cuando es el operando del operador sizeof, o el operador &amp;amp; (la 'direcci&amp;oacute;n de' operador), o como un literal de cadena utilizado para inicializar una matriz de caracteres.</target>
        </trans-unit>
        <trans-unit id="2b526d981401e0c2d70d62bcd0c44f9ede8ae7e2" translate="yes" xml:space="preserve">
          <source>There are two complications or exceptions to the above.</source>
          <target state="translated">Hay dos complicaciones o excepciones a lo anterior.</target>
        </trans-unit>
        <trans-unit id="f81d6ffafbf5b704f07c47eca12d330779e7d845" translate="yes" xml:space="preserve">
          <source>This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I'm not sure if there's any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn't lying.</source>
          <target state="translated">Por eso también es por lo que en C se debe evitar el uso de los parámetros de la matriz en las definiciones de los prototipos de funciones (en mi opinión-no estoy seguro de que haya un acuerdo general).Causan confusión y son una ficción de todas formas-use parámetros de puntero y la confusión podría no desaparecer del todo,pero al menos la declaración de los parámetros no miente.</target>
        </trans-unit>
        <trans-unit id="8e6a15535b3af3a50ce3dc0aaf2505fc5db33d0b" translate="yes" xml:space="preserve">
          <source>This is not the same thing as an array pointer.  For example:</source>
          <target state="translated">Esto no es lo mismo que un puntero de matriz.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="def5eca561f95373c185551a5184d5c82b79c30e" translate="yes" xml:space="preserve">
          <source>This lost ability is referred to as &quot;decay&quot;.</source>
          <target state="translated">Esta habilidad perdida se conoce como &quot;decadencia&quot;.</target>
        </trans-unit>
        <trans-unit id="da4f48a08795c085825fa49034357d199855026e" translate="yes" xml:space="preserve">
          <source>This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.</source>
          <target state="translated">Esto significa que casi siempre que se usa el nombre de la matriz en una expresión,se convierte automáticamente en un puntero al primer elemento de la matriz.</target>
        </trans-unit>
        <trans-unit id="bf38c57dfd53ee57a7e7d131ca570ae92a570d9e" translate="yes" xml:space="preserve">
          <source>Three ways to pass in an array&lt;sup&gt;1&lt;/sup&gt;:</source>
          <target state="translated">Tres formas de pasar en una matriz &lt;sup&gt;1&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="6aa8d44a900157b56ec4f557db7604118f57c0eb" translate="yes" xml:space="preserve">
          <source>What is array to pointer decay</source>
          <target state="translated">¿Qué es el decaimiento de la matriz al puntero</target>
        </trans-unit>
        <trans-unit id="a116f6630933726f994dcd4f5a10875ec018b1d7" translate="yes" xml:space="preserve">
          <source>What is array to pointer decay? Is there any relation to array pointers?</source>
          <target state="translated">¿Qué es el decaimiento de la matriz al puntero? ¿Hay alguna relación con los punteros de la matriz?</target>
        </trans-unit>
        <trans-unit id="2dc4418ae9ebbb34e793477eb0fad36643b32b7a" translate="yes" xml:space="preserve">
          <source>When you write &lt;code&gt;arr[idx]&lt;/code&gt; you're really just saying &lt;code&gt;*(arr + idx)&lt;/code&gt;.</source>
          <target state="translated">Cuando escribes &lt;code&gt;arr[idx]&lt;/code&gt; realidad solo est&amp;aacute;s diciendo &lt;code&gt;*(arr + idx)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c5c7c7abeb7e74d4d39cb704af4b6c614a3f709" translate="yes" xml:space="preserve">
          <source>Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type &lt;code&gt;pointer to (type of array elements)&lt;/code&gt;.</source>
          <target state="translated">Donde se espera el valor de un objeto, pero el objeto es una matriz, se utiliza la direcci&amp;oacute;n de su primer elemento, con un &lt;code&gt;pointer to (type of array elements)&lt;/code&gt; tipo a (tipo de elementos de matriz) .</target>
        </trans-unit>
        <trans-unit id="8612b28344f7df5c3c84d9b73b89903f33d4c6f2" translate="yes" xml:space="preserve">
          <source>You can pass fixed-length arrays to functions within a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Puede pasar matrices de longitud fija a funciones dentro de una &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e204589387a540663ec39ea0b5a6f041d6878b6c" translate="yes" xml:space="preserve">
          <source>functions never really take arrays as parameters, only pointers, even when you specify an array parameter.</source>
          <target state="translated">Las funciones nunca toman realmente las matrices como parámetros,sólo punteros,incluso cuando se especifica un parámetro de la matriz.</target>
        </trans-unit>
        <trans-unit id="6bc2702e0131275e3964f40b6237c9f12cce8c25" translate="yes" xml:space="preserve">
          <source>into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):</source>
          <target state="translated">en un puntero (que funciona sin moldear,y por lo tanto puede ocurrir inesperadamente en algunos casos):</target>
        </trans-unit>
        <trans-unit id="412007ea4e463f6e39ce41519f9448bb091a3aa2" translate="yes" xml:space="preserve">
          <source>tl;dr: When you use an array you've define, you'll actually be using a pointer to its first element.</source>
          <target state="translated">Cuando usas una matriz que has definido,en realidad estarás usando un puntero a su primer elemento.</target>
        </trans-unit>
        <trans-unit id="ce713d143604dd99c2530308ef27ca215366f0d3" translate="yes" xml:space="preserve">
          <source>you lose the ability of the &lt;code&gt;sizeof&lt;/code&gt; operator to count elements in the array:</source>
          <target state="translated">pierde la capacidad del operador &lt;code&gt;sizeof&lt;/code&gt; de contar elementos en la matriz:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
