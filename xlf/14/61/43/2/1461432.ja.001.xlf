<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1461432">
    <body>
      <group id="1461432">
        <trans-unit id="c2404ea2f29e7ab77959bfb06fcb1abdcc2f6bfb" translate="yes" xml:space="preserve">
          <source>&quot;Decay&quot; refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from &quot;N-element array of T&quot; to &quot;pointer to T&quot; and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt; operators, or the array is a string literal being used as an initializer in a declaration.</source>
          <target state="translated">「ディケイ」とは、配列型からポインタ型への式の暗黙的な変換を指します。 ほとんどのコンテキストでは、コンパイラーが配列式を検出すると、式のタイプを「TのN要素配列」から「Tへのポインター」に変換し、式の値を配列の最初の要素のアドレスに設定します。 。 この規則の例外は、配列が &lt;code&gt;sizeof&lt;/code&gt; または &lt;code&gt;&amp;amp;&lt;/code&gt; 演算子のオペランドである場合、または配列が宣言で初期化子として使用されている文字列リテラルである場合です。</target>
        </trans-unit>
        <trans-unit id="fef5835d12d6938604c510c22163d431de85b202" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Arrays, in C, have no value.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Cの配列には値がありません。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe835ea58c4d708d4f4a321d5b813bf895ce8133" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr_to_first_element&lt;/code&gt; is a simple pointer to char.</source>
          <target state="translated">&lt;code&gt;ptr_to_first_element&lt;/code&gt; は、charへの単純なポインタです。</target>
        </trans-unit>
        <trans-unit id="c83d8701def450df5855c504c476be72a0e69b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof()&lt;/code&gt; gives the size taken up by the array, not the size of a pointer.</source>
          <target state="translated">&lt;code&gt;sizeof()&lt;/code&gt; は、ポインタのサイズではなく、配列が占めるサイズを示します。</target>
        </trans-unit>
        <trans-unit id="352817c6a3ad6badcefa105a8b04e5ee011102d1" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 The constant U should be known at compile-time.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1定数Uはコンパイル時に既知である必要があります。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="87f646e9df809142304089153cda433ffa37875b" translate="yes" xml:space="preserve">
          <source>Actually, it's just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.</source>
          <target state="translated">実際のところ、どこかに配列を渡したいのにポインタが代わりに渡されてしまうと(いったい誰が配列全体を渡すのかわからないので)、「かわいそうな配列はポインタに減衰した」と言われてしまうだけの話です。</target>
        </trans-unit>
        <trans-unit id="5e6b27cbe389e55e514a50765e64ae7f3252c7df" translate="yes" xml:space="preserve">
          <source>Again, when an array is an operand of &lt;code&gt;sizeof&lt;/code&gt;, it's not converted to a pointer type.</source>
          <target state="translated">繰り返しになりますが、配列が &lt;code&gt;sizeof&lt;/code&gt; のオペランドである場合、配列はポインター型に変換されません。</target>
        </trans-unit>
        <trans-unit id="943937f9cb4127159565add162479c03bf6ba720" translate="yes" xml:space="preserve">
          <source>An lvalue or rvalue of type &amp;ldquo;array of N T&amp;rdquo; or &amp;ldquo;array of unknown bound of T&amp;rdquo; &lt;strong&gt;can&lt;/strong&gt; be converted to an rvalue
  of type &amp;ldquo;pointer to T.&amp;rdquo;</source>
          <target state="translated">「N Tの配列」または「Tの未知の境界の配列」タイプの左辺値または右辺値は、「Tへのポインター」タイプの右辺値に変換&lt;strong&gt;でき&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="572d04428c30798e603b05f06992752d438676f3" translate="yes" xml:space="preserve">
          <source>Array decaying means that, when an array is passed as a parameter to a function, it's treated identically to (&quot;decays to&quot;) a pointer.</source>
          <target state="translated">配列の減衰とは、配列が関数のパラメータとして渡された場合、ポインタと同じように扱われる(「減衰する」)ことを意味します。</target>
        </trans-unit>
        <trans-unit id="2504de460ca48ca652515d2e95d788ac6397c47d" translate="yes" xml:space="preserve">
          <source>Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:</source>
          <target state="translated">配列は基本的にはCC++のポインタと同じですが、そうではありません。配列を変換したら</target>
        </trans-unit>
        <trans-unit id="f6b98d449f169ec5000ed0687a72f8d69aaa611a" translate="yes" xml:space="preserve">
          <source>Assume the following code:</source>
          <target state="translated">以下のコードを想定してください。</target>
        </trans-unit>
        <trans-unit id="d623c4ac7a1b6a2336cd3de0984beb4c6ce2f3a5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;ptr_to_first_element&lt;/code&gt; and &lt;code&gt;ptr_to_array&lt;/code&gt; have the same &lt;em&gt;value&lt;/em&gt;; the base address of a.  However, they are different types and are treated differently, as shown below:</source>
          <target state="translated">&lt;code&gt;ptr_to_first_element&lt;/code&gt; と &lt;code&gt;ptr_to_array&lt;/code&gt; の両方が同じ&lt;em&gt;値を&lt;/em&gt;持ってい&lt;em&gt;ます&lt;/em&gt; 。 aのベースアドレス。 ただし、以下に示すように、それらは異なるタイプであり、異なる方法で処理されます。</target>
        </trans-unit>
        <trans-unit id="c0ba2510f593d5c4730c7b53d78941d20631790f" translate="yes" xml:space="preserve">
          <source>Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a
  string literal used to initialize an array, an expression that has type &amp;lsquo;&amp;lsquo;array of type&amp;rsquo;&amp;rsquo; is
  converted to an expression with type &amp;lsquo;&amp;lsquo;pointer to type&amp;rsquo;&amp;rsquo; that points to the initial element of
  the array object and is not an lvalue.</source>
          <target state="translated">sizeof演算子または単項＆演算子のオペランドである場合、または配列の初期化に使用される文字列リテラルである場合を除いて、型 '' array of type ''の式は、型 '' pointer to type ''は、配列オブジェクトの初期要素を指し、左辺値ではありません。</target>
        </trans-unit>
        <trans-unit id="e4620cd591c8d41594b31aea3b33cac9222653f8" translate="yes" xml:space="preserve">
          <source>First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.</source>
          <target state="translated">まず、C および C++で多次元配列を扱う場合、1 次元だけが失われます。これは、配列がメモリ内に連続して配置されているため、コンパイラがそのメモリ・ブロックへのオフセットを計算できるようにするには、1 次元以外のすべての次元を知っている必要があるためです。</target>
        </trans-unit>
        <trans-unit id="b67d5b515aef01ab7697545039259ee6299aa621" translate="yes" xml:space="preserve">
          <source>For more details, check out this &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot;&gt;article about array decay&lt;/a&gt;.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot;&gt;配列の崩壊に関する&lt;/a&gt;この記事をご覧ください。</target>
        </trans-unit>
        <trans-unit id="66a3f61a4f5c9cc8f0c9f707c2704a039bff9f2c" translate="yes" xml:space="preserve">
          <source>Function foo expects the value of an array. But, in C, arrays have no value! So &lt;code&gt;foo&lt;/code&gt; gets instead the address of the first element of the array.</source>
          <target state="translated">関数fooは配列の値を予期しています。 しかし、Cでは、配列には値がありません！ そのため、 &lt;code&gt;foo&lt;/code&gt; は代わりに配列の最初の要素のアドレスを取得します。</target>
        </trans-unit>
        <trans-unit id="93ddb0141afd9ecfa44949d318cd4b180a79e263" translate="yes" xml:space="preserve">
          <source>Here's what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):</source>
          <target state="translated">これは、標準では次のように述べられています(C99 6.3.2.13-その他のオペランド-L値、配列、関数のデジグネータ)。</target>
        </trans-unit>
        <trans-unit id="2f69062bcf9c16e967805dcc3676465f9bdff391" translate="yes" xml:space="preserve">
          <source>I might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.</source>
          <target state="translated">また、これは C++と C++の優越性を示していると思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="2bbc8143578adf65237b78876ca44811525cc8b6" translate="yes" xml:space="preserve">
          <source>I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.</source>
          <target state="translated">関数の引数として配列を渡す方法が4つあると考えるのは大胆かもしれません。また、ここには短いですが動作するコードがあります。</target>
        </trans-unit>
        <trans-unit id="7264ad7e3ffb4141844d0c336996116af4bb0122" translate="yes" xml:space="preserve">
          <source>If you're passing an array by value, what you're really doing is copying a pointer - a pointer to the array's first element is copied to the parameter (whose type should also be a pointer the array element's type). This works due to array's decaying nature; once decayed, &lt;code&gt;sizeof&lt;/code&gt; no longer gives the complete array's size, because it essentially becomes a pointer.  This is why it's preferred (among other reasons) to pass by reference or pointer.</source>
          <target state="translated">配列を値で渡す場合、実際に行っているのは、ポインターのコピーです。配列の最初の要素へのポインターがパラメーターにコピーされます（その型は、配列要素の型のポインターでもある必要があります）。 これは、配列の減衰する性質のために機能します。 減衰すると、 &lt;code&gt;sizeof&lt;/code&gt; は配列の完全なサイズを提供しなくなります。これは、配列が本質的にポインタになるためです。 これが、（他の理由の中でも）参照またはポインタで渡すことが推奨される理由です。</target>
        </trans-unit>
        <trans-unit id="2426ce0cfd2ae39e025a59289febb3d5f7fe28cd" translate="yes" xml:space="preserve">
          <source>In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it &quot;decays into a pointer&quot; (sic); when you compare an array to something else, again it &quot;decays into a pointer&quot; (sic); ...</source>
          <target state="translated">関数では,すべてのパラメータは値で渡されます(配列も例外ではありません).関数で配列を渡すと,それは「ポインタに変化します」(sic);配列を他のものと比較すると,再び「ポインタに変化します」(sic);...</target>
        </trans-unit>
        <trans-unit id="ca3ac27f8fa7044755eff98bdc26d22a299a16a3" translate="yes" xml:space="preserve">
          <source>In the array indexing syntax you are used to seeing, again, the arr is 'decayed to a pointer'</source>
          <target state="translated">見慣れた配列インデックスの構文では,再び arr は 'decayed to a pointer' となります.</target>
        </trans-unit>
        <trans-unit id="3acf04b7e934c50f3341e33ecbf3ddba739d41a7" translate="yes" xml:space="preserve">
          <source>In the comparison above, &lt;code&gt;arr&lt;/code&gt; has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable &lt;code&gt;ip&lt;/code&gt;.</source>
          <target state="translated">上記の比較では、 &lt;code&gt;arr&lt;/code&gt; には値がないため、ポインターになります。 intへのポインタになります。 そのポインタは変数 &lt;code&gt;ip&lt;/code&gt; と比較できます。</target>
        </trans-unit>
        <trans-unit id="3a608dabdd48971d982bdee712aa38cc50d33cc1" translate="yes" xml:space="preserve">
          <source>It's said that arrays &quot;decay&quot; into pointers.  A C++ array declared as &lt;code&gt;int numbers [5]&lt;/code&gt; cannot be re-pointed, i.e. you can't say &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt;. More importantly the term decay signifies loss of type and dimension; &lt;code&gt;numbers&lt;/code&gt; decay into &lt;code&gt;int*&lt;/code&gt; by losing the dimension information (count 5) and the type is not &lt;code&gt;int [5]&lt;/code&gt; any more. Look here for &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;cases where the decay doesn't happen&lt;/a&gt;.</source>
          <target state="translated">配列はポインタに「減衰」すると言われています。 &lt;code&gt;int numbers [5]&lt;/code&gt; として宣言されたC ++配列は再ポイントできません。つまり、 &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt; とは言えません。 さらに重要なこととして、「崩壊」という用語はタイプと次元の喪失を意味します。 &lt;code&gt;numbers&lt;/code&gt; は、次元情報（カウント5）を失うことによって &lt;code&gt;int*&lt;/code&gt; 減衰し、型は &lt;code&gt;int [5]&lt;/code&gt; ではなくなります。 &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;減衰が発生しない場合については、&lt;/a&gt;こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="75b81db01f0edec0fed30d115d6b7d3ba38da199" translate="yes" xml:space="preserve">
          <source>It's when array rots and is being pointed at ;-)</source>
          <target state="translated">配列が腐って指されている時ですね ;-)</target>
        </trans-unit>
        <trans-unit id="d717086108630d7af551627a6f2f8097ecdd3d6e" translate="yes" xml:space="preserve">
          <source>Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn't cause nearly as much confusion as the automatic conversion of array names to pointers.</source>
          <target state="translated">関数名も似たような動作をしますが、関数ポインタの使用数ははるかに少なく、より専門的な方法で使用されるため、配列名からポインタへの自動変換ほどの混乱は起こらないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f7e7f226b763b9d9ec2e0712651895d6237a9ebf" translate="yes" xml:space="preserve">
          <source>Of course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.</source>
          <target state="translated">もちろん、ヒープの割り当ても例外もなく、std::libもないという非常に厳しいプロジェクトもありますが、C++のネイティブ配列処理は、そのようなプロジェクトには必須の言語機能と言えるでしょう。C++のネイティブ配列処理はミッションクリティカルな言語機能だと言えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b67d400e1ef3e4e91eee3d3d9e452dd5495d95ea" translate="yes" xml:space="preserve">
          <source>Remember that the expression &lt;code&gt;a[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(a+i)&lt;/code&gt; (which only works if the array type is converted to a pointer type), so both &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; work the same. The expression &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(*a+i)&lt;/code&gt;.  The expressions &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; and &lt;code&gt;ptr_to_array[i]&lt;/code&gt; may lead to compiler warnings or errors depending on the context; they'll definitely do the wrong thing if you're expecting them to evaluate to &lt;code&gt;a[i]&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;a[i]&lt;/code&gt; は &lt;code&gt;*(a+i)&lt;/code&gt; （配列タイプがポインタータイプに変換された場合にのみ機能する）として解釈されるため、 &lt;code&gt;a[i]&lt;/code&gt; と &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; どちらも同じように機能します。 式 &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; は &lt;code&gt;*(*a+i)&lt;/code&gt; として解釈されます。 式 &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; および &lt;code&gt;ptr_to_array[i]&lt;/code&gt; は、コンテキストによってコンパイラの警告またはエラーを引き起こす可能性があります。 それらが &lt;code&gt;a[i]&lt;/code&gt; に評価されることを期待している場合、それらは間違いなく間違った動作をします。</target>
        </trans-unit>
        <trans-unit id="21f571aadabef22c86699783c6de4b70ecead3c5" translate="yes" xml:space="preserve">
          <source>Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot;&gt;strcpy_s&lt;/a&gt;, and you can use a similar trick to reliably &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;get the number of elements in an array&lt;/a&gt;.</source>
          <target state="translated">次に、C ++では、テンプレートを使用して配列のサイズを推定できます。 Microsoftはこれを&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot;&gt;strcpy_sの&lt;/a&gt;ようなセキュアCRT関数のC ++バージョンに使用します。同様のトリックを使用&lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;して、配列内の要素の数&lt;/a&gt;を確実に取得できます。</target>
        </trans-unit>
        <trans-unit id="4cf7e537136bba43900f7f51100e034763e82e5d" translate="yes" xml:space="preserve">
          <source>So the conversion doesn't &lt;em&gt;have&lt;/em&gt; to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).</source>
          <target state="translated">そのため、変換はCで常に行われるように行う&lt;em&gt;必要&lt;/em&gt;はありません（これにより、関数をオーバーロードしたり、テンプレートを配列型に一致させたりできます）</target>
        </trans-unit>
        <trans-unit id="1f64d5bdb8222551b4c814f7020160a0c4d446a4" translate="yes" xml:space="preserve">
          <source>Sort-of exceptions to this rule:</source>
          <target state="translated">このルールには例外があります。</target>
        </trans-unit>
        <trans-unit id="374991ae64032aa0b674020550de47cc0d02fc4b" translate="yes" xml:space="preserve">
          <source>The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):</source>
          <target state="translated">C++標準(4.2 Array-to-pointer変換)では、変換要件を(強調鉱山)に緩くしています。</target>
        </trans-unit>
        <trans-unit id="a0b4a750f64a796bb9c9e478100e4e15af5d260e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;a&lt;/code&gt; is of type &quot;80-element array of char&quot; and the expression &quot;This is a test&quot; is of type &quot;16-element array of char&quot; (in C; in C++ string literals are arrays of const char).  However, in the call to &lt;code&gt;strcpy()&lt;/code&gt;, neither expression is an operand of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, so their types are implicitly converted to &quot;pointer to char&quot;, and their values are set to the address of the first element in each.  What &lt;code&gt;strcpy()&lt;/code&gt; receives are not arrays, but pointers, as seen in its prototype:</source>
          <target state="translated">式 &lt;code&gt;a&lt;/code&gt; のタイプは「80要素配列のchar」であり、式「This is a test」はタイプ「16要素配列のchar」です（Cでは、C ++文字列リテラルはconst charの配列です）。 ただし、 &lt;code&gt;strcpy()&lt;/code&gt; の呼び出しでは、どちらの式も &lt;code&gt;sizeof&lt;/code&gt; または &lt;code&gt;&amp;amp;&lt;/code&gt; のオペランドではないため、それらの型は暗黙的に「pointer to char」に変換され、それらの値はそれぞれの最初の要素のアドレスに設定されます。 &lt;code&gt;strcpy()&lt;/code&gt; が受け取るのは、そのプロトタイプに見られるように、配列ではなくポインタです。</target>
        </trans-unit>
        <trans-unit id="cc1f2c92734a69f415a5acffe3a57fc184a7af29" translate="yes" xml:space="preserve">
          <source>The last two will give proper &lt;code&gt;sizeof&lt;/code&gt; info, while the first one won't since the array argument has decayed to be assigned to the parameter.</source>
          <target state="translated">最後の2つは適切な &lt;code&gt;sizeof&lt;/code&gt; 情報を提供しますが、配列引数が減衰してパラメーターに割り当てられているため、最初の1つは提供されません。</target>
        </trans-unit>
        <trans-unit id="96d0631bd8e97056f77f41e42872acd43b78edf7" translate="yes" xml:space="preserve">
          <source>The only times an array doesn't decay into a pointer are when it is the operand of the sizeof operator, or the &amp;amp; operator (the 'address of' operator), or as a string literal used to initialize a character array.</source>
          <target state="translated">配列がポインタに減衰しないのは、それがsizeof演算子、または＆演算子（「アドレス」演算子）のオペランド、または文字配列の初期化に使用される文字列リテラルとしてのみです。</target>
        </trans-unit>
        <trans-unit id="2b526d981401e0c2d70d62bcd0c44f9ede8ae7e2" translate="yes" xml:space="preserve">
          <source>There are two complications or exceptions to the above.</source>
          <target state="translated">上記のような合併症や例外があります。</target>
        </trans-unit>
        <trans-unit id="f81d6ffafbf5b704f07c47eca12d330779e7d845" translate="yes" xml:space="preserve">
          <source>This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I'm not sure if there's any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn't lying.</source>
          <target state="translated">これが、C言語では関数のprototypedefinitionsで配列のパラメータを使うのを避けるべき理由でもあります(私の意見ですが、一般的な意見があるかどうかはわかりません)。ポインタパラメータを使えば、混乱は完全には解消されないかもしれませんが、少なくともパラメータ宣言は嘘をついていません。</target>
        </trans-unit>
        <trans-unit id="8e6a15535b3af3a50ce3dc0aaf2505fc5db33d0b" translate="yes" xml:space="preserve">
          <source>This is not the same thing as an array pointer.  For example:</source>
          <target state="translated">これは配列ポインタとは違います。例えば</target>
        </trans-unit>
        <trans-unit id="def5eca561f95373c185551a5184d5c82b79c30e" translate="yes" xml:space="preserve">
          <source>This lost ability is referred to as &quot;decay&quot;.</source>
          <target state="translated">この失われた能力を「衰退」といいます。</target>
        </trans-unit>
        <trans-unit id="da4f48a08795c085825fa49034357d199855026e" translate="yes" xml:space="preserve">
          <source>This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.</source>
          <target state="translated">これは、配列名が式の中で使用された場合はいつでも、配列の1番目の項目へのポインタに自動的に変換されることを意味します。</target>
        </trans-unit>
        <trans-unit id="bf38c57dfd53ee57a7e7d131ca570ae92a570d9e" translate="yes" xml:space="preserve">
          <source>Three ways to pass in an array&lt;sup&gt;1&lt;/sup&gt;:</source>
          <target state="translated">配列を渡す3つの方法&lt;sup&gt;1&lt;/sup&gt; ：</target>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="6aa8d44a900157b56ec4f557db7604118f57c0eb" translate="yes" xml:space="preserve">
          <source>What is array to pointer decay</source>
          <target state="translated">配列からポインタへの減衰とは</target>
        </trans-unit>
        <trans-unit id="a116f6630933726f994dcd4f5a10875ec018b1d7" translate="yes" xml:space="preserve">
          <source>What is array to pointer decay? Is there any relation to array pointers?</source>
          <target state="translated">配列からポインタへの減衰とは?配列ポインタとの関係はありますか?</target>
        </trans-unit>
        <trans-unit id="2dc4418ae9ebbb34e793477eb0fad36643b32b7a" translate="yes" xml:space="preserve">
          <source>When you write &lt;code&gt;arr[idx]&lt;/code&gt; you're really just saying &lt;code&gt;*(arr + idx)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr[idx]&lt;/code&gt; を書くときは、本当に &lt;code&gt;*(arr + idx)&lt;/code&gt; と言っているだけです。</target>
        </trans-unit>
        <trans-unit id="0c5c7c7abeb7e74d4d39cb704af4b6c614a3f709" translate="yes" xml:space="preserve">
          <source>Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type &lt;code&gt;pointer to (type of array elements)&lt;/code&gt;.</source>
          <target state="translated">オブジェクトの値が期待されているがオブジェクトが配列である場合は常に、最初の要素のアドレスが &lt;code&gt;pointer to (type of array elements)&lt;/code&gt; タイプポインターと共に代わりに使用されます 。</target>
        </trans-unit>
        <trans-unit id="8612b28344f7df5c3c84d9b73b89903f33d4c6f2" translate="yes" xml:space="preserve">
          <source>You can pass fixed-length arrays to functions within a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">固定長配列を &lt;code&gt;struct&lt;/code&gt; 内の関数に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="e204589387a540663ec39ea0b5a6f041d6878b6c" translate="yes" xml:space="preserve">
          <source>functions never really take arrays as parameters, only pointers, even when you specify an array parameter.</source>
          <target state="translated">関数は、配列のパラメータを指定したとしても、実際には配列をパラメータとして受け取ることはなく、ポインタのみを受け取ります。</target>
        </trans-unit>
        <trans-unit id="6bc2702e0131275e3964f40b6237c9f12cce8c25" translate="yes" xml:space="preserve">
          <source>into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):</source>
          <target state="translated">をポインタに変換します(これはキャストせずに動作するので、場合によっては予期せぬことが起こることもあります)。</target>
        </trans-unit>
        <trans-unit id="412007ea4e463f6e39ce41519f9448bb091a3aa2" translate="yes" xml:space="preserve">
          <source>tl;dr: When you use an array you've define, you'll actually be using a pointer to its first element.</source>
          <target state="translated">tl;dr:定義した配列を使うときは、実際にはその最初の要素へのポインタを使うことになります。</target>
        </trans-unit>
        <trans-unit id="ce713d143604dd99c2530308ef27ca215366f0d3" translate="yes" xml:space="preserve">
          <source>you lose the ability of the &lt;code&gt;sizeof&lt;/code&gt; operator to count elements in the array:</source>
          <target state="translated">配列内の要素をカウントする &lt;code&gt;sizeof&lt;/code&gt; 演算子の機能が失われます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
