<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1461432">
    <body>
      <group id="1461432">
        <trans-unit id="c2404ea2f29e7ab77959bfb06fcb1abdcc2f6bfb" translate="yes" xml:space="preserve">
          <source>&quot;Decay&quot; refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from &quot;N-element array of T&quot; to &quot;pointer to T&quot; and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt; operators, or the array is a string literal being used as an initializer in a declaration.</source>
          <target state="translated">&amp;laquo;Распад&amp;raquo; относится к неявному преобразованию выражения из типа массива в тип указателя. В большинстве случаев, когда компилятор видит выражение массива, он преобразует тип выражения из &amp;laquo;массива N-элемента T&amp;raquo; в &amp;laquo;указатель на T&amp;raquo; и устанавливает значение выражения в адрес первого элемента массива. , Исключением из этого правила является случай, когда массив является операндом оператора &lt;code&gt;sizeof&lt;/code&gt; или &lt;code&gt;&amp;amp;&lt;/code&gt; , или массив является строковым литералом, используемым в качестве инициализатора в объявлении.</target>
        </trans-unit>
        <trans-unit id="fef5835d12d6938604c510c22163d431de85b202" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Arrays, in C, have no value.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Массивы в Си не имеют значения.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe835ea58c4d708d4f4a321d5b813bf895ce8133" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr_to_first_element&lt;/code&gt; is a simple pointer to char.</source>
          <target state="translated">&lt;code&gt;ptr_to_first_element&lt;/code&gt; - это простой указатель на символ.</target>
        </trans-unit>
        <trans-unit id="c83d8701def450df5855c504c476be72a0e69b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof()&lt;/code&gt; gives the size taken up by the array, not the size of a pointer.</source>
          <target state="translated">&lt;code&gt;sizeof()&lt;/code&gt; дает размер, занятый массивом, а не размер указателя.</target>
        </trans-unit>
        <trans-unit id="352817c6a3ad6badcefa105a8b04e5ee011102d1" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 The constant U should be known at compile-time.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1 Константа U должна быть известна во время компиляции.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="87f646e9df809142304089153cda433ffa37875b" translate="yes" xml:space="preserve">
          <source>Actually, it's just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.</source>
          <target state="translated">На самом деле,просто если вы хотите где-то передать массив,а вместо него передается указатель (потому что кто,черт возьми,будет передавать за вас весь массив),люди говорят,что бедный массив распадается на указатель.</target>
        </trans-unit>
        <trans-unit id="5e6b27cbe389e55e514a50765e64ae7f3252c7df" translate="yes" xml:space="preserve">
          <source>Again, when an array is an operand of &lt;code&gt;sizeof&lt;/code&gt;, it's not converted to a pointer type.</source>
          <target state="translated">Опять же, когда массив является операндом &lt;code&gt;sizeof&lt;/code&gt; , он не преобразуется в тип указателя.</target>
        </trans-unit>
        <trans-unit id="943937f9cb4127159565add162479c03bf6ba720" translate="yes" xml:space="preserve">
          <source>An lvalue or rvalue of type &amp;ldquo;array of N T&amp;rdquo; or &amp;ldquo;array of unknown bound of T&amp;rdquo; &lt;strong&gt;can&lt;/strong&gt; be converted to an rvalue
  of type &amp;ldquo;pointer to T.&amp;rdquo;</source>
          <target state="translated">Значение l или значение типа &amp;laquo;массив из N T&amp;raquo; или &amp;laquo;массив неизвестных границ T&amp;raquo; &lt;strong&gt;может&lt;/strong&gt; быть преобразовано в значение типа &amp;laquo;указатель на T&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="572d04428c30798e603b05f06992752d438676f3" translate="yes" xml:space="preserve">
          <source>Array decaying means that, when an array is passed as a parameter to a function, it's treated identically to (&quot;decays to&quot;) a pointer.</source>
          <target state="translated">Распад массива означает,что когда массив передается в качестве параметра в функцию,он обрабатывается идентично (&quot;распадается на&quot;)указателю.</target>
        </trans-unit>
        <trans-unit id="2504de460ca48ca652515d2e95d788ac6397c47d" translate="yes" xml:space="preserve">
          <source>Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:</source>
          <target state="translated">Массивы в основном те же,что и указатели в CC++,но не совсем.После преобразования массива:</target>
        </trans-unit>
        <trans-unit id="f6b98d449f169ec5000ed0687a72f8d69aaa611a" translate="yes" xml:space="preserve">
          <source>Assume the following code:</source>
          <target state="translated">Допустим,следующий код:</target>
        </trans-unit>
        <trans-unit id="d623c4ac7a1b6a2336cd3de0984beb4c6ce2f3a5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;ptr_to_first_element&lt;/code&gt; and &lt;code&gt;ptr_to_array&lt;/code&gt; have the same &lt;em&gt;value&lt;/em&gt;; the base address of a.  However, they are different types and are treated differently, as shown below:</source>
          <target state="translated">И &lt;code&gt;ptr_to_first_element&lt;/code&gt; , и &lt;code&gt;ptr_to_array&lt;/code&gt; имеют одинаковое &lt;em&gt;значение&lt;/em&gt; ; Базовый адрес. Однако они относятся к разным типам и обрабатываются по-разному, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="c0ba2510f593d5c4730c7b53d78941d20631790f" translate="yes" xml:space="preserve">
          <source>Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a
  string literal used to initialize an array, an expression that has type &amp;lsquo;&amp;lsquo;array of type&amp;rsquo;&amp;rsquo; is
  converted to an expression with type &amp;lsquo;&amp;lsquo;pointer to type&amp;rsquo;&amp;rsquo; that points to the initial element of
  the array object and is not an lvalue.</source>
          <target state="translated">За исключением случаев, когда он является операндом оператора sizeof или унарного оператора &amp;amp;, или является строковым литералом, используемым для инициализации массива, выражение с типом '' массив типа '' преобразуется в выражение с указателем типа '' на тип '', который указывает на начальный элемент объекта массива и не является lvalue.</target>
        </trans-unit>
        <trans-unit id="e4620cd591c8d41594b31aea3b33cac9222653f8" translate="yes" xml:space="preserve">
          <source>First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.</source>
          <target state="translated">Во-первых,при работе с многомерными массивами в C и C++теряется только первое измерение.Это связано с тем,что массивы располагаются в памяти непрерывно,поэтому компилятор должен знать все измерение,кроме первого,чтобы иметь возможность вычислить смещения в этом блоке памяти.</target>
        </trans-unit>
        <trans-unit id="b67d5b515aef01ab7697545039259ee6299aa621" translate="yes" xml:space="preserve">
          <source>For more details, check out this &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot;&gt;article about array decay&lt;/a&gt;.</source>
          <target state="translated">Для более подробной информации, ознакомьтесь с этой &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot;&gt;статьей о распаде массива&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66a3f61a4f5c9cc8f0c9f707c2704a039bff9f2c" translate="yes" xml:space="preserve">
          <source>Function foo expects the value of an array. But, in C, arrays have no value! So &lt;code&gt;foo&lt;/code&gt; gets instead the address of the first element of the array.</source>
          <target state="translated">Функция foo ожидает значение массива. Но в Си массивы не имеют значения! Таким образом, &lt;code&gt;foo&lt;/code&gt; получает вместо этого адрес первого элемента массива.</target>
        </trans-unit>
        <trans-unit id="93ddb0141afd9ecfa44949d318cd4b180a79e263" translate="yes" xml:space="preserve">
          <source>Here's what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):</source>
          <target state="translated">Вот что говорится в стандарте (C99 6.3.2.13-Другие операнды-Значения,массивы и обозначения функций):</target>
        </trans-unit>
        <trans-unit id="2f69062bcf9c16e967805dcc3676465f9bdff391" translate="yes" xml:space="preserve">
          <source>I might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.</source>
          <target state="translated">Я также могу подумать,что это показывает превосходство С++над С.По крайней мере,в ссылке (pun intended)на передачу массива по ссылке.</target>
        </trans-unit>
        <trans-unit id="2bbc8143578adf65237b78876ca44811525cc8b6" translate="yes" xml:space="preserve">
          <source>I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.</source>
          <target state="translated">Я могу быть настолько смелым,что думаю,что есть четыре (4)способа передать массив в качестве аргумента функции.Также вот краткий,но работающий код для вашего прочтения.</target>
        </trans-unit>
        <trans-unit id="7264ad7e3ffb4141844d0c336996116af4bb0122" translate="yes" xml:space="preserve">
          <source>If you're passing an array by value, what you're really doing is copying a pointer - a pointer to the array's first element is copied to the parameter (whose type should also be a pointer the array element's type). This works due to array's decaying nature; once decayed, &lt;code&gt;sizeof&lt;/code&gt; no longer gives the complete array's size, because it essentially becomes a pointer.  This is why it's preferred (among other reasons) to pass by reference or pointer.</source>
          <target state="translated">Если вы передаете массив по значению, то вы действительно копируете указатель - указатель на первый элемент массива копируется в параметр (тип которого также должен быть указателем на тип элемента массива). Это работает из-за разлагающейся природы массива; после распада &lt;code&gt;sizeof&lt;/code&gt; больше не дает полный размер массива, потому что он по сути становится указателем. Вот почему предпочтительно (среди прочих причин) передавать по ссылке или по указателю.</target>
        </trans-unit>
        <trans-unit id="2426ce0cfd2ae39e025a59289febb3d5f7fe28cd" translate="yes" xml:space="preserve">
          <source>In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it &quot;decays into a pointer&quot; (sic); when you compare an array to something else, again it &quot;decays into a pointer&quot; (sic); ...</source>
          <target state="translated">В функции все параметры передаются по значению (массивы не являются исключением).При передаче массива в функции он &quot;распадается на указатель&quot; (sic);при сравнении массива с чем-то другим он снова &quot;распадается на указатель&quot; (sic);...</target>
        </trans-unit>
        <trans-unit id="ca3ac27f8fa7044755eff98bdc26d22a299a16a3" translate="yes" xml:space="preserve">
          <source>In the array indexing syntax you are used to seeing, again, the arr is 'decayed to a pointer'</source>
          <target state="translated">В синтаксисе индексирования массивов,к которому вы привыкли,опять же,arr 'распадается на указатель'.</target>
        </trans-unit>
        <trans-unit id="3acf04b7e934c50f3341e33ecbf3ddba739d41a7" translate="yes" xml:space="preserve">
          <source>In the comparison above, &lt;code&gt;arr&lt;/code&gt; has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable &lt;code&gt;ip&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше сравнении &lt;code&gt;arr&lt;/code&gt; не имеет значения, поэтому становится указателем. Это становится указателем на int. Этот указатель можно сравнить с переменной &lt;code&gt;ip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a608dabdd48971d982bdee712aa38cc50d33cc1" translate="yes" xml:space="preserve">
          <source>It's said that arrays &quot;decay&quot; into pointers.  A C++ array declared as &lt;code&gt;int numbers [5]&lt;/code&gt; cannot be re-pointed, i.e. you can't say &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt;. More importantly the term decay signifies loss of type and dimension; &lt;code&gt;numbers&lt;/code&gt; decay into &lt;code&gt;int*&lt;/code&gt; by losing the dimension information (count 5) and the type is not &lt;code&gt;int [5]&lt;/code&gt; any more. Look here for &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;cases where the decay doesn't happen&lt;/a&gt;.</source>
          <target state="translated">Говорят, что массивы &quot;распадаются&quot; на указатели. Массив C ++, объявленный как &lt;code&gt;int numbers [5]&lt;/code&gt; не может быть переназначен, то есть нельзя сказать, что &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt; . Что еще более важно термин распад означает потерю типа и размерности; &lt;code&gt;numbers&lt;/code&gt; превращаются в &lt;code&gt;int*&lt;/code&gt; , теряя информацию о размерах (количество 5), и тип больше не является &lt;code&gt;int [5]&lt;/code&gt; . Ищите здесь &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;случаи, когда распад не происходит&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75b81db01f0edec0fed30d115d6b7d3ba38da199" translate="yes" xml:space="preserve">
          <source>It's when array rots and is being pointed at ;-)</source>
          <target state="translated">Это когда массив сгнивает и на него указывают ;-)</target>
        </trans-unit>
        <trans-unit id="d717086108630d7af551627a6f2f8097ecdd3d6e" translate="yes" xml:space="preserve">
          <source>Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn't cause nearly as much confusion as the automatic conversion of array names to pointers.</source>
          <target state="translated">Обратите внимание,что имена функций действуют аналогичным образом,однако указатели функций используются гораздо меньше и гораздо более специализированным образом,что не вызывает почти такой же путаницы,как автоматическое преобразование имен массивов в указатели.</target>
        </trans-unit>
        <trans-unit id="f7e7f226b763b9d9ec2e0712651895d6237a9ebf" translate="yes" xml:space="preserve">
          <source>Of course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.</source>
          <target state="translated">Конечно же,есть чрезвычайно строгие проекты без распределения кучи,без исключений и без std::lib.Родная работа с массивами на C++,можно сказать,является критически важной особенностью языка.</target>
        </trans-unit>
        <trans-unit id="b67d400e1ef3e4e91eee3d3d9e452dd5495d95ea" translate="yes" xml:space="preserve">
          <source>Remember that the expression &lt;code&gt;a[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(a+i)&lt;/code&gt; (which only works if the array type is converted to a pointer type), so both &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; work the same. The expression &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(*a+i)&lt;/code&gt;.  The expressions &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; and &lt;code&gt;ptr_to_array[i]&lt;/code&gt; may lead to compiler warnings or errors depending on the context; they'll definitely do the wrong thing if you're expecting them to evaluate to &lt;code&gt;a[i]&lt;/code&gt;.</source>
          <target state="translated">Помните, что выражение &lt;code&gt;a[i]&lt;/code&gt; интерпретируется как &lt;code&gt;*(a+i)&lt;/code&gt; (которое работает только в том случае, если тип массива преобразуется в тип указателя), поэтому и &lt;code&gt;a[i]&lt;/code&gt; и &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; работают одинаково. Выражение &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; интерпретируется как &lt;code&gt;*(*a+i)&lt;/code&gt; . Выражения &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; и &lt;code&gt;ptr_to_array[i]&lt;/code&gt; могут приводить к предупреждениям или ошибкам компилятора в зависимости от контекста; они определенно поступят неправильно, если вы ожидаете, что они оценят &lt;code&gt;a[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21f571aadabef22c86699783c6de4b70ecead3c5" translate="yes" xml:space="preserve">
          <source>Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot;&gt;strcpy_s&lt;/a&gt;, and you can use a similar trick to reliably &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;get the number of elements in an array&lt;/a&gt;.</source>
          <target state="translated">Во-вторых, в C ++ вы можете использовать шаблоны для определения размера массивов. Microsoft использует это для версий Secure CRT на C ++, таких как &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot;&gt;strcpy_s&lt;/a&gt; , и вы можете использовать аналогичный прием для надежного &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;получения количества элементов в массиве&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cf7e537136bba43900f7f51100e034763e82e5d" translate="yes" xml:space="preserve">
          <source>So the conversion doesn't &lt;em&gt;have&lt;/em&gt; to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).</source>
          <target state="translated">Таким образом, преобразование не &lt;em&gt;должно&lt;/em&gt; происходить так, как это обычно происходит в C (это позволяет перегрузить функции или шаблоны соответствуют типу массива).</target>
        </trans-unit>
        <trans-unit id="1f64d5bdb8222551b4c814f7020160a0c4d446a4" translate="yes" xml:space="preserve">
          <source>Sort-of exceptions to this rule:</source>
          <target state="translated">Исключения из этого правила:</target>
        </trans-unit>
        <trans-unit id="374991ae64032aa0b674020550de47cc0d02fc4b" translate="yes" xml:space="preserve">
          <source>The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):</source>
          <target state="translated">Стандарт C++(4.2 преобразование из массива в указатель)ослабляет требование к преобразованию в (шахта фокусировки):</target>
        </trans-unit>
        <trans-unit id="a0b4a750f64a796bb9c9e478100e4e15af5d260e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;a&lt;/code&gt; is of type &quot;80-element array of char&quot; and the expression &quot;This is a test&quot; is of type &quot;16-element array of char&quot; (in C; in C++ string literals are arrays of const char).  However, in the call to &lt;code&gt;strcpy()&lt;/code&gt;, neither expression is an operand of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, so their types are implicitly converted to &quot;pointer to char&quot;, and their values are set to the address of the first element in each.  What &lt;code&gt;strcpy()&lt;/code&gt; receives are not arrays, but pointers, as seen in its prototype:</source>
          <target state="translated">Выражение &lt;code&gt;a&lt;/code&gt; относится к типу &amp;laquo;массив из 80 элементов char&amp;raquo;, а выражение &amp;laquo;это тест&amp;raquo; относится к типу &amp;laquo;массив из 16 элементов char&amp;raquo; (в C; в C ++ строковые литералы являются массивами const char). Однако в вызове &lt;code&gt;strcpy()&lt;/code&gt; ни одно из выражений не является операндом &lt;code&gt;sizeof&lt;/code&gt; или &lt;code&gt;&amp;amp;&lt;/code&gt; , поэтому их типы неявно преобразуются в &amp;laquo;указатель на символ&amp;raquo;, а их значения устанавливаются по адресу первого элемента в каждом. То, что получает &lt;code&gt;strcpy()&lt;/code&gt; это не массивы, а указатели, как видно из его прототипа:</target>
        </trans-unit>
        <trans-unit id="cc1f2c92734a69f415a5acffe3a57fc184a7af29" translate="yes" xml:space="preserve">
          <source>The last two will give proper &lt;code&gt;sizeof&lt;/code&gt; info, while the first one won't since the array argument has decayed to be assigned to the parameter.</source>
          <target state="translated">Последние два дадут правильный &lt;code&gt;sizeof&lt;/code&gt; информации, а первый - нет, так как аргумент массива распался для присвоения параметру.</target>
        </trans-unit>
        <trans-unit id="96d0631bd8e97056f77f41e42872acd43b78edf7" translate="yes" xml:space="preserve">
          <source>The only times an array doesn't decay into a pointer are when it is the operand of the sizeof operator, or the &amp;amp; operator (the 'address of' operator), or as a string literal used to initialize a character array.</source>
          <target state="translated">Единственный раз, когда массив не распадается на указатель, это когда он является операндом оператора sizeof или оператора &amp;amp; (оператор 'address of'), или как строковый литерал, используемый для инициализации массива символов.</target>
        </trans-unit>
        <trans-unit id="2b526d981401e0c2d70d62bcd0c44f9ede8ae7e2" translate="yes" xml:space="preserve">
          <source>There are two complications or exceptions to the above.</source>
          <target state="translated">Существуют два осложнения или исключения из вышесказанного.</target>
        </trans-unit>
        <trans-unit id="f81d6ffafbf5b704f07c47eca12d330779e7d845" translate="yes" xml:space="preserve">
          <source>This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I'm not sure if there's any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn't lying.</source>
          <target state="translated">Поэтому в C также следует избегать использования параметров массива в прототипах функций (на мой взгляд-я не уверен,есть ли какое-либо общее согласие).Они вызывают путаницу и в любом случае являются вымыслом-используйте параметры указателей,и путаница может не исчезнуть полностью,но,по крайней мере,объявление параметра не лжет.</target>
        </trans-unit>
        <trans-unit id="8e6a15535b3af3a50ce3dc0aaf2505fc5db33d0b" translate="yes" xml:space="preserve">
          <source>This is not the same thing as an array pointer.  For example:</source>
          <target state="translated">Это не то же самое,что указатель на массив.Например:</target>
        </trans-unit>
        <trans-unit id="def5eca561f95373c185551a5184d5c82b79c30e" translate="yes" xml:space="preserve">
          <source>This lost ability is referred to as &quot;decay&quot;.</source>
          <target state="translated">Эта потерянная способность называется &quot;распадом&quot;.</target>
        </trans-unit>
        <trans-unit id="da4f48a08795c085825fa49034357d199855026e" translate="yes" xml:space="preserve">
          <source>This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.</source>
          <target state="translated">Это означает,что практически каждый раз,когда имя массива используется в выражении,оно автоматически преобразуется в указатель на 1-й элемент массива.</target>
        </trans-unit>
        <trans-unit id="bf38c57dfd53ee57a7e7d131ca570ae92a570d9e" translate="yes" xml:space="preserve">
          <source>Three ways to pass in an array&lt;sup&gt;1&lt;/sup&gt;:</source>
          <target state="translated">Три способа передачи в массиве &lt;sup&gt;1&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="6aa8d44a900157b56ec4f557db7604118f57c0eb" translate="yes" xml:space="preserve">
          <source>What is array to pointer decay</source>
          <target state="translated">Что такое массив для распада указателей</target>
        </trans-unit>
        <trans-unit id="a116f6630933726f994dcd4f5a10875ec018b1d7" translate="yes" xml:space="preserve">
          <source>What is array to pointer decay? Is there any relation to array pointers?</source>
          <target state="translated">Что такое массив,чтобы указывать на распад? Есть ли какое-либо отношение к указателям на массив?</target>
        </trans-unit>
        <trans-unit id="2dc4418ae9ebbb34e793477eb0fad36643b32b7a" translate="yes" xml:space="preserve">
          <source>When you write &lt;code&gt;arr[idx]&lt;/code&gt; you're really just saying &lt;code&gt;*(arr + idx)&lt;/code&gt;.</source>
          <target state="translated">Когда вы пишете &lt;code&gt;arr[idx]&lt;/code&gt; вы на самом деле просто говорите &lt;code&gt;*(arr + idx)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c5c7c7abeb7e74d4d39cb704af4b6c614a3f709" translate="yes" xml:space="preserve">
          <source>Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type &lt;code&gt;pointer to (type of array elements)&lt;/code&gt;.</source>
          <target state="translated">Везде, где ожидается значение объекта, но объект является массивом, вместо него используется адрес его первого элемента с &lt;code&gt;pointer to (type of array elements)&lt;/code&gt; типа на (тип элементов массива) .</target>
        </trans-unit>
        <trans-unit id="8612b28344f7df5c3c84d9b73b89903f33d4c6f2" translate="yes" xml:space="preserve">
          <source>You can pass fixed-length arrays to functions within a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Вы можете передавать массивы фиксированной длины в функции внутри &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e204589387a540663ec39ea0b5a6f041d6878b6c" translate="yes" xml:space="preserve">
          <source>functions never really take arrays as parameters, only pointers, even when you specify an array parameter.</source>
          <target state="translated">функции никогда на самом деле не принимают массивы в качестве параметров,только указатели,даже если вы указываете параметр массива.</target>
        </trans-unit>
        <trans-unit id="6bc2702e0131275e3964f40b6237c9f12cce8c25" translate="yes" xml:space="preserve">
          <source>into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):</source>
          <target state="translated">в указатель (который работает без литья,и поэтому в некоторых случаях может произойти неожиданно):</target>
        </trans-unit>
        <trans-unit id="412007ea4e463f6e39ce41519f9448bb091a3aa2" translate="yes" xml:space="preserve">
          <source>tl;dr: When you use an array you've define, you'll actually be using a pointer to its first element.</source>
          <target state="translated">tl;dr:Когда вы используете массив,который вы определили,вы на самом деле будете использовать указатель на его первый элемент.</target>
        </trans-unit>
        <trans-unit id="ce713d143604dd99c2530308ef27ca215366f0d3" translate="yes" xml:space="preserve">
          <source>you lose the ability of the &lt;code&gt;sizeof&lt;/code&gt; operator to count elements in the array:</source>
          <target state="translated">вы теряете возможность оператора &lt;code&gt;sizeof&lt;/code&gt; считать элементы в массиве:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
