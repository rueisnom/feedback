<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1461432">
    <body>
      <group id="1461432">
        <trans-unit id="c2404ea2f29e7ab77959bfb06fcb1abdcc2f6bfb" translate="yes" xml:space="preserve">
          <source>&quot;Decay&quot; refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from &quot;N-element array of T&quot; to &quot;pointer to T&quot; and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt; operators, or the array is a string literal being used as an initializer in a declaration.</source>
          <target state="translated">&quot;부패&quot;는 배열 형식에서 포인터 형식으로 식을 암시 적으로 변환하는 것을 말합니다. 대부분의 컨텍스트에서 컴파일러는 배열 표현식을 볼 때 표현식 유형을 &quot;T의 N- 요소 배열&quot;에서 &quot;포인터에서 T&quot;로 변환하고 표현식의 값을 배열의 첫 번째 요소의 주소로 설정합니다. . 이 규칙의 예외는 배열이 &lt;code&gt;sizeof&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자의 피연산자이거나 배열이 선언에서 초기화 자로 사용되는 문자열 리터럴 인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="fef5835d12d6938604c510c22163d431de85b202" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Arrays, in C, have no value.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;C의 배열에는 값이 없습니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe835ea58c4d708d4f4a321d5b813bf895ce8133" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr_to_first_element&lt;/code&gt; is a simple pointer to char.</source>
          <target state="translated">&lt;code&gt;ptr_to_first_element&lt;/code&gt; 는 char에 대한 간단한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="c83d8701def450df5855c504c476be72a0e69b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof()&lt;/code&gt; gives the size taken up by the array, not the size of a pointer.</source>
          <target state="translated">&lt;code&gt;sizeof()&lt;/code&gt; 는 포인터의 크기가 아니라 배열이 차지하는 크기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="352817c6a3ad6badcefa105a8b04e5ee011102d1" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 The constant U should be known at compile-time.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1 컴파일 할 때 상수 U를 알아야합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="87f646e9df809142304089153cda433ffa37875b" translate="yes" xml:space="preserve">
          <source>Actually, it's just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.</source>
          <target state="translated">실제로, 어딘가에 배열을 전달하려고하지만 포인터가 대신 전달되는 경우 (도대체 누가 당신을 위해 전체 배열을 전달할 것이기 때문에) 사람들은 가난한 배열이 포인터로 부패했다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="5e6b27cbe389e55e514a50765e64ae7f3252c7df" translate="yes" xml:space="preserve">
          <source>Again, when an array is an operand of &lt;code&gt;sizeof&lt;/code&gt;, it's not converted to a pointer type.</source>
          <target state="translated">다시 말하지만 배열이 &lt;code&gt;sizeof&lt;/code&gt; 의 피연산자 인 경우 포인터 유형으로 변환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="943937f9cb4127159565add162479c03bf6ba720" translate="yes" xml:space="preserve">
          <source>An lvalue or rvalue of type &amp;ldquo;array of N T&amp;rdquo; or &amp;ldquo;array of unknown bound of T&amp;rdquo; &lt;strong&gt;can&lt;/strong&gt; be converted to an rvalue
  of type &amp;ldquo;pointer to T.&amp;rdquo;</source>
          <target state="translated">&quot;N T의 배열&quot;또는 &quot;T의 알려지지 않은 경계의 배열&quot;유형의 lvalue 또는 rvalue는 &quot;pointer to T&quot;유형의 rvalue로 변환 될 &lt;strong&gt;수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="572d04428c30798e603b05f06992752d438676f3" translate="yes" xml:space="preserve">
          <source>Array decaying means that, when an array is passed as a parameter to a function, it's treated identically to (&quot;decays to&quot;) a pointer.</source>
          <target state="translated">배열 소멸은 배열이 함수에 매개 변수로 전달 될 때 포인터와 동일하게 취급된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2504de460ca48ca652515d2e95d788ac6397c47d" translate="yes" xml:space="preserve">
          <source>Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:</source>
          <target state="translated">배열은 기본적으로 C / C ++의 포인터와 동일하지만 완전히 다릅니다. 배열을 변환하면 :</target>
        </trans-unit>
        <trans-unit id="f6b98d449f169ec5000ed0687a72f8d69aaa611a" translate="yes" xml:space="preserve">
          <source>Assume the following code:</source>
          <target state="translated">다음 코드를 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="d623c4ac7a1b6a2336cd3de0984beb4c6ce2f3a5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;ptr_to_first_element&lt;/code&gt; and &lt;code&gt;ptr_to_array&lt;/code&gt; have the same &lt;em&gt;value&lt;/em&gt;; the base address of a.  However, they are different types and are treated differently, as shown below:</source>
          <target state="translated">&lt;code&gt;ptr_to_first_element&lt;/code&gt; 와 &lt;code&gt;ptr_to_array&lt;/code&gt; 는 모두 같은 &lt;em&gt;값을 갖습니다&lt;/em&gt; . a의 기본 주소 그러나 유형이 다르며 아래와 같이 다르게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="c0ba2510f593d5c4730c7b53d78941d20631790f" translate="yes" xml:space="preserve">
          <source>Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a
  string literal used to initialize an array, an expression that has type &amp;lsquo;&amp;lsquo;array of type&amp;rsquo;&amp;rsquo; is
  converted to an expression with type &amp;lsquo;&amp;lsquo;pointer to type&amp;rsquo;&amp;rsquo; that points to the initial element of
  the array object and is not an lvalue.</source>
          <target state="translated">sizeof 연산자 또는 단항 &amp;amp; 연산자의 피연산자이거나 배열을 초기화하는 데 사용되는 문자열 리터럴 인 경우를 제외하고 ''array of type ''유형의 표현식은 ''pointer to type 유형의 표현식으로 변환됩니다. 배열 객체의 초기 요소를 가리키고 lvalue가 아닌 type ''입니다.</target>
        </trans-unit>
        <trans-unit id="e4620cd591c8d41594b31aea3b33cac9222653f8" translate="yes" xml:space="preserve">
          <source>First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.</source>
          <target state="translated">먼저 C 및 C ++에서 다차원 배열을 처리 할 때 첫 번째 차원 만 손실됩니다. 배열은 메모리에 연속적으로 배치되므로 컴파일러는 해당 메모리 블록에 대한 오프셋을 계산할 수있는 첫 번째 차원을 제외한 모든 것을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="b67d5b515aef01ab7697545039259ee6299aa621" translate="yes" xml:space="preserve">
          <source>For more details, check out this &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot;&gt;article about array decay&lt;/a&gt;.</source>
          <target state="translated">자세한 &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot;&gt;내용은 배열 붕괴에 대한&lt;/a&gt; 이 기사를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="66a3f61a4f5c9cc8f0c9f707c2704a039bff9f2c" translate="yes" xml:space="preserve">
          <source>Function foo expects the value of an array. But, in C, arrays have no value! So &lt;code&gt;foo&lt;/code&gt; gets instead the address of the first element of the array.</source>
          <target state="translated">함수 foo는 배열의 값을 기대합니다. 그러나 C에서는 배열에 가치가 없습니다! 따라서 &lt;code&gt;foo&lt;/code&gt; 는 대신 배열의 첫 번째 요소의 주소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="93ddb0141afd9ecfa44949d318cd4b180a79e263" translate="yes" xml:space="preserve">
          <source>Here's what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):</source>
          <target state="translated">표준의 내용은 다음과 같습니다 (C99 6.3.2.1/3-기타 피연산자-L 값, 배열 및 함수 지정자).</target>
        </trans-unit>
        <trans-unit id="2f69062bcf9c16e967805dcc3676465f9bdff391" translate="yes" xml:space="preserve">
          <source>I might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.</source>
          <target state="translated">나는 이것이 C ++ 대 C의 우수성을 보여줄 것이라고 생각할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bbc8143578adf65237b78876ca44811525cc8b6" translate="yes" xml:space="preserve">
          <source>I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.</source>
          <target state="translated">배열을 함수 인수로 전달하는 네 가지 방법이 있다고 생각하면 대담 할 수 있습니다. 또한 여기에 짧지 만 작동하는 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7264ad7e3ffb4141844d0c336996116af4bb0122" translate="yes" xml:space="preserve">
          <source>If you're passing an array by value, what you're really doing is copying a pointer - a pointer to the array's first element is copied to the parameter (whose type should also be a pointer the array element's type). This works due to array's decaying nature; once decayed, &lt;code&gt;sizeof&lt;/code&gt; no longer gives the complete array's size, because it essentially becomes a pointer.  This is why it's preferred (among other reasons) to pass by reference or pointer.</source>
          <target state="translated">값으로 배열을 전달하는 경우 실제로하는 것은 포인터를 복사하는 것입니다. 배열의 첫 번째 요소에 대한 포인터가 매개 변수에 복사됩니다 (이 유형은 배열 요소의 유형도 포인터 여야 함). 이것은 배열의 붕괴 특성으로 인해 작동합니다. 일단 소멸되면 &lt;code&gt;sizeof&lt;/code&gt; 는 더 이상 완전한 배열의 크기를 제공하지 않습니다. 본질적으로 포인터가되기 때문입니다. 그렇기 때문에 (다른 이유로) 참조 또는 포인터로 전달하는 것이 선호되는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="2426ce0cfd2ae39e025a59289febb3d5f7fe28cd" translate="yes" xml:space="preserve">
          <source>In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it &quot;decays into a pointer&quot; (sic); when you compare an array to something else, again it &quot;decays into a pointer&quot; (sic); ...</source>
          <target state="translated">함수에서 모든 매개 변수는 값으로 전달됩니다 (배열도 예외는 아닙니다). 함수에서 배열을 전달하면 &quot;포인터로 붕괴&quot;(sic); 배열을 다른 것과 비교하면 다시 &quot;포인터로 붕괴&quot;(sic); ...</target>
        </trans-unit>
        <trans-unit id="ca3ac27f8fa7044755eff98bdc26d22a299a16a3" translate="yes" xml:space="preserve">
          <source>In the array indexing syntax you are used to seeing, again, the arr is 'decayed to a pointer'</source>
          <target state="translated">배열 인덱싱 구문에서 arr은 '포인터로 쇠퇴합니다'</target>
        </trans-unit>
        <trans-unit id="3acf04b7e934c50f3341e33ecbf3ddba739d41a7" translate="yes" xml:space="preserve">
          <source>In the comparison above, &lt;code&gt;arr&lt;/code&gt; has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable &lt;code&gt;ip&lt;/code&gt;.</source>
          <target state="translated">위의 비교에서 &lt;code&gt;arr&lt;/code&gt; 에는 값이 없으므로 포인터가됩니다. int에 대한 포인터가됩니다. 이 포인터는 변수 &lt;code&gt;ip&lt;/code&gt; 와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a608dabdd48971d982bdee712aa38cc50d33cc1" translate="yes" xml:space="preserve">
          <source>It's said that arrays &quot;decay&quot; into pointers.  A C++ array declared as &lt;code&gt;int numbers [5]&lt;/code&gt; cannot be re-pointed, i.e. you can't say &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt;. More importantly the term decay signifies loss of type and dimension; &lt;code&gt;numbers&lt;/code&gt; decay into &lt;code&gt;int*&lt;/code&gt; by losing the dimension information (count 5) and the type is not &lt;code&gt;int [5]&lt;/code&gt; any more. Look here for &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;cases where the decay doesn't happen&lt;/a&gt;.</source>
          <target state="translated">배열은 포인터로 &quot;부패&quot;한다고합니다. &lt;code&gt;int numbers [5]&lt;/code&gt; 로 선언 된 C ++ 배열은 다시 지정할 수 없습니다. 즉 &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt; 이라고 말할 수 없습니다. 더 중요한 것은 붕괴라는 용어는 유형과 치수의 손실을 의미합니다. &lt;code&gt;numbers&lt;/code&gt; 는 차원 정보 (카운트 5)를 잃어 &lt;code&gt;int*&lt;/code&gt; 로 쇠퇴하고 유형은 더 이상 &lt;code&gt;int [5]&lt;/code&gt; 가 아닙니다. &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;부패가 발생하지 않는 경우는&lt;/a&gt; 여기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="75b81db01f0edec0fed30d115d6b7d3ba38da199" translate="yes" xml:space="preserve">
          <source>It's when array rots and is being pointed at ;-)</source>
          <target state="translated">배열이 썩고 ;-)을 가리킬 때입니다.</target>
        </trans-unit>
        <trans-unit id="d717086108630d7af551627a6f2f8097ecdd3d6e" translate="yes" xml:space="preserve">
          <source>Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn't cause nearly as much confusion as the automatic conversion of array names to pointers.</source>
          <target state="translated">함수 이름은 비슷한 방식으로 작동하지만 함수 포인터는 배열 이름을 포인터로 자동 변환하는 것만 큼 혼동을 일으키지 않도록 훨씬 덜 특수하게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7e7f226b763b9d9ec2e0712651895d6237a9ebf" translate="yes" xml:space="preserve">
          <source>Of course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.</source>
          <target state="translated">물론 힙 할당, 예외 및 std :: lib가없는 매우 엄격한 프로젝트가 있습니다. C ++ 네이티브 배열 처리는 미션 크리티컬 언어 기능입니다.</target>
        </trans-unit>
        <trans-unit id="b67d400e1ef3e4e91eee3d3d9e452dd5495d95ea" translate="yes" xml:space="preserve">
          <source>Remember that the expression &lt;code&gt;a[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(a+i)&lt;/code&gt; (which only works if the array type is converted to a pointer type), so both &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; work the same. The expression &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(*a+i)&lt;/code&gt;.  The expressions &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; and &lt;code&gt;ptr_to_array[i]&lt;/code&gt; may lead to compiler warnings or errors depending on the context; they'll definitely do the wrong thing if you're expecting them to evaluate to &lt;code&gt;a[i]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a[i]&lt;/code&gt; 표현식 은 &lt;code&gt;*(a+i)&lt;/code&gt; (배열 유형이 포인터 유형으로 변환 된 경우에만 작동 ) 로 해석되므로 &lt;code&gt;a[i]&lt;/code&gt; 와 &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; 는 동일하게 작동합니다. &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; 표현식은 &lt;code&gt;*(*a+i)&lt;/code&gt; 로 해석됩니다. &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; 및 &lt;code&gt;ptr_to_array[i]&lt;/code&gt; 표현식은 컨텍스트에 따라 컴파일러 경고 또는 오류를 유발할 수 있습니다. 당신이 그들에게 &lt;code&gt;a[i]&lt;/code&gt; 로 평가하기를 기대한다면 그들은 분명히 잘못된 일을 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="21f571aadabef22c86699783c6de4b70ecead3c5" translate="yes" xml:space="preserve">
          <source>Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot;&gt;strcpy_s&lt;/a&gt;, and you can use a similar trick to reliably &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;get the number of elements in an array&lt;/a&gt;.</source>
          <target state="translated">둘째, C ++에서는 템플릿을 사용하여 배열의 크기를 추론 할 수 있습니다. Microsoft는 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot;&gt;strcpy_s&lt;/a&gt; 와 같은 C ++ 버전의 Secure CRT 함수에 이것을 사용하며, 비슷한 트릭을 사용 &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;하여 배열의 요소 수&lt;/a&gt; 를 안정적으로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cf7e537136bba43900f7f51100e034763e82e5d" translate="yes" xml:space="preserve">
          <source>So the conversion doesn't &lt;em&gt;have&lt;/em&gt; to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).</source>
          <target state="translated">따라서 변환은 C에서 거의 항상 수행되는 것처럼 수행 될 &lt;em&gt;필요&lt;/em&gt; 가 없습니다 (이로 인해 함수 오버로드 또는 템플릿이 배열 유형에서 일치 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="1f64d5bdb8222551b4c814f7020160a0c4d446a4" translate="yes" xml:space="preserve">
          <source>Sort-of exceptions to this rule:</source>
          <target state="translated">이 규칙에 대한 정렬 예외 :</target>
        </trans-unit>
        <trans-unit id="374991ae64032aa0b674020550de47cc0d02fc4b" translate="yes" xml:space="preserve">
          <source>The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):</source>
          <target state="translated">C ++ 표준 (4.2 배열에서 포인터로의 변환)은 변환 요구 사항을 (강조 광산)으로 완화합니다.</target>
        </trans-unit>
        <trans-unit id="a0b4a750f64a796bb9c9e478100e4e15af5d260e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;a&lt;/code&gt; is of type &quot;80-element array of char&quot; and the expression &quot;This is a test&quot; is of type &quot;16-element array of char&quot; (in C; in C++ string literals are arrays of const char).  However, in the call to &lt;code&gt;strcpy()&lt;/code&gt;, neither expression is an operand of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, so their types are implicitly converted to &quot;pointer to char&quot;, and their values are set to the address of the first element in each.  What &lt;code&gt;strcpy()&lt;/code&gt; receives are not arrays, but pointers, as seen in its prototype:</source>
          <target state="translated">표현식 &lt;code&gt;a&lt;/code&gt; 는 &quot;80 요소 배열의 char&quot;유형이고, &quot;This is a test&quot;표현은 &quot;16 요소 배열의 char&quot;유형입니다 (C에서는 문자열 리터럴은 const char의 배열 임). 그러나 &lt;code&gt;strcpy()&lt;/code&gt; 호출에서 expression은 &lt;code&gt;sizeof&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;&lt;/code&gt; 의 피연산자이므로 해당 유형은 암시 적으로 &quot;pointer to char&quot;로 변환되며 값은 각 요소의 첫 번째 요소의 주소로 설정됩니다. &lt;code&gt;strcpy()&lt;/code&gt; 받는 것은 프로토 타입에서 볼 수있는 것처럼 배열이 아니라 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="cc1f2c92734a69f415a5acffe3a57fc184a7af29" translate="yes" xml:space="preserve">
          <source>The last two will give proper &lt;code&gt;sizeof&lt;/code&gt; info, while the first one won't since the array argument has decayed to be assigned to the parameter.</source>
          <target state="translated">마지막 두 개는 적절한 크기의 정보를 제공하지만 첫 번째 것은 배열 인수가 매개 변수에 할당되기 위해 쇠퇴 한 이후로는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96d0631bd8e97056f77f41e42872acd43b78edf7" translate="yes" xml:space="preserve">
          <source>The only times an array doesn't decay into a pointer are when it is the operand of the sizeof operator, or the &amp;amp; operator (the 'address of' operator), or as a string literal used to initialize a character array.</source>
          <target state="translated">배열이 포인터로 붕괴되지 않는 유일한 경우는 sizeof 연산자 또는 &amp;amp; 연산자 ( 'address of'연산자)의 피연산자이거나 문자 배열을 초기화하는 데 사용되는 문자열 리터럴 일 때입니다.</target>
        </trans-unit>
        <trans-unit id="2b526d981401e0c2d70d62bcd0c44f9ede8ae7e2" translate="yes" xml:space="preserve">
          <source>There are two complications or exceptions to the above.</source>
          <target state="translated">위의 두 가지 합병증이나 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f81d6ffafbf5b704f07c47eca12d330779e7d845" translate="yes" xml:space="preserve">
          <source>This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I'm not sure if there's any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn't lying.</source>
          <target state="translated">이것이 C에서 함수 프로토 타입 / 정의에서 배열 매개 변수를 사용하지 않아야하는 이유입니다 (제 의견으로는 일반적인 동의가 있는지 확실하지 않습니다). 그것들은 혼란을 야기하고 어쨌든 허구입니다-포인터 매개 변수를 사용하면 혼란이 완전히 사라지지는 않지만 적어도 매개 변수 선언은 거짓말이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8e6a15535b3af3a50ce3dc0aaf2505fc5db33d0b" translate="yes" xml:space="preserve">
          <source>This is not the same thing as an array pointer.  For example:</source>
          <target state="translated">이것은 배열 포인터와 동일하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="def5eca561f95373c185551a5184d5c82b79c30e" translate="yes" xml:space="preserve">
          <source>This lost ability is referred to as &quot;decay&quot;.</source>
          <target state="translated">이 손실 능력을 &quot;부패&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="da4f48a08795c085825fa49034357d199855026e" translate="yes" xml:space="preserve">
          <source>This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.</source>
          <target state="translated">즉, 배열 이름이 식에 사용될 때마다 배열의 첫 번째 항목에 대한 포인터로 자동 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="bf38c57dfd53ee57a7e7d131ca570ae92a570d9e" translate="yes" xml:space="preserve">
          <source>Three ways to pass in an array&lt;sup&gt;1&lt;/sup&gt;:</source>
          <target state="translated">배열을 전달하는 세 가지 방법 &lt;sup&gt;1&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="6aa8d44a900157b56ec4f557db7604118f57c0eb" translate="yes" xml:space="preserve">
          <source>What is array to pointer decay</source>
          <target state="translated">포인터 붕괴에 대한 배열이란?</target>
        </trans-unit>
        <trans-unit id="a116f6630933726f994dcd4f5a10875ec018b1d7" translate="yes" xml:space="preserve">
          <source>What is array to pointer decay? Is there any relation to array pointers?</source>
          <target state="translated">포인터 붕괴에 대한 배열이란 무엇입니까? 배열 포인터와 관련이 있습니까?</target>
        </trans-unit>
        <trans-unit id="2dc4418ae9ebbb34e793477eb0fad36643b32b7a" translate="yes" xml:space="preserve">
          <source>When you write &lt;code&gt;arr[idx]&lt;/code&gt; you're really just saying &lt;code&gt;*(arr + idx)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr[idx]&lt;/code&gt; 를 쓸 때 실제로는 &lt;code&gt;*(arr + idx)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c5c7c7abeb7e74d4d39cb704af4b6c614a3f709" translate="yes" xml:space="preserve">
          <source>Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type &lt;code&gt;pointer to (type of array elements)&lt;/code&gt;.</source>
          <target state="translated">객체의 값이 예상되지만 객체가 배열 인 경우 &lt;code&gt;pointer to (type of array elements)&lt;/code&gt; 유형 포인터 와 함께 첫 번째 요소의 주소가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8612b28344f7df5c3c84d9b73b89903f33d4c6f2" translate="yes" xml:space="preserve">
          <source>You can pass fixed-length arrays to functions within a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 내의 함수에 고정 길이 배열을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e204589387a540663ec39ea0b5a6f041d6878b6c" translate="yes" xml:space="preserve">
          <source>functions never really take arrays as parameters, only pointers, even when you specify an array parameter.</source>
          <target state="translated">함수는 배열을 매개 변수로 사용하지 않으며 배열 매개 변수를 지정하더라도 포인터 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6bc2702e0131275e3964f40b6237c9f12cce8c25" translate="yes" xml:space="preserve">
          <source>into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):</source>
          <target state="translated">포인터로 (캐스팅하지 않고 작동하므로 경우에 따라 예기치 않게 발생할 수 있음) :</target>
        </trans-unit>
        <trans-unit id="412007ea4e463f6e39ce41519f9448bb091a3aa2" translate="yes" xml:space="preserve">
          <source>tl;dr: When you use an array you've define, you'll actually be using a pointer to its first element.</source>
          <target state="translated">tl; dr : 정의한 배열을 사용할 때 실제로 첫 번째 요소에 대한 포인터를 사용하게됩니다.</target>
        </trans-unit>
        <trans-unit id="ce713d143604dd99c2530308ef27ca215366f0d3" translate="yes" xml:space="preserve">
          <source>you lose the ability of the &lt;code&gt;sizeof&lt;/code&gt; operator to count elements in the array:</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; 연산자가 배열의 요소를 계산하는 기능을 잃습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
