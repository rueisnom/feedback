<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1461432">
    <body>
      <group id="1461432">
        <trans-unit id="c2404ea2f29e7ab77959bfb06fcb1abdcc2f6bfb" translate="yes" xml:space="preserve">
          <source>&quot;Decay&quot; refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from &quot;N-element array of T&quot; to &quot;pointer to T&quot; and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt; operators, or the array is a string literal being used as an initializer in a declaration.</source>
          <target state="translated">&amp;ldquo;衰减&amp;rdquo;是指表达式从数组类型到指针类型的隐式转换。 在大多数情况下，当编译器看到数组表达式时，它将表达式的类型从&amp;ldquo; T的N个元素数组&amp;rdquo;转换为&amp;ldquo;指向T的指针&amp;rdquo;，并将表达式的值设置为数组第一个元素的地址。 该规则的例外情况是：数组是 &lt;code&gt;sizeof&lt;/code&gt; 或 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符的操作数，或者数组是在声明中用作初始化程序的字符串文字。</target>
        </trans-unit>
        <trans-unit id="fef5835d12d6938604c510c22163d431de85b202" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Arrays, in C, have no value.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;C语言中的数组没有任何价值。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe835ea58c4d708d4f4a321d5b813bf895ce8133" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr_to_first_element&lt;/code&gt; is a simple pointer to char.</source>
          <target state="translated">&lt;code&gt;ptr_to_first_element&lt;/code&gt; 是指向char的简单指针。</target>
        </trans-unit>
        <trans-unit id="c83d8701def450df5855c504c476be72a0e69b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof()&lt;/code&gt; gives the size taken up by the array, not the size of a pointer.</source>
          <target state="translated">&lt;code&gt;sizeof()&lt;/code&gt; 给出数组占用的大小，而不是指针的大小。</target>
        </trans-unit>
        <trans-unit id="352817c6a3ad6badcefa105a8b04e5ee011102d1" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 The constant U should be known at compile-time.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1常数U应该在编译时已知。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="87f646e9df809142304089153cda433ffa37875b" translate="yes" xml:space="preserve">
          <source>Actually, it's just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.</source>
          <target state="translated">其实就是如果你想把数组传到某个地方,却把指针传到了某个地方(因为谁特么会把整个数组都传给你),大家都说可怜的数组衰变成了指针。</target>
        </trans-unit>
        <trans-unit id="5e6b27cbe389e55e514a50765e64ae7f3252c7df" translate="yes" xml:space="preserve">
          <source>Again, when an array is an operand of &lt;code&gt;sizeof&lt;/code&gt;, it's not converted to a pointer type.</source>
          <target state="translated">同样，当数组是 &lt;code&gt;sizeof&lt;/code&gt; 的操作数时，它不会转换为指针类型。</target>
        </trans-unit>
        <trans-unit id="943937f9cb4127159565add162479c03bf6ba720" translate="yes" xml:space="preserve">
          <source>An lvalue or rvalue of type &amp;ldquo;array of N T&amp;rdquo; or &amp;ldquo;array of unknown bound of T&amp;rdquo; &lt;strong&gt;can&lt;/strong&gt; be converted to an rvalue
  of type &amp;ldquo;pointer to T.&amp;rdquo;</source>
          <target state="translated">可以将类型为&amp;ldquo; N T的数组&amp;rdquo;或&amp;ldquo; T的未知边界的数组&amp;rdquo;的左值或右值转换为&amp;ldquo;指向T的指针&amp;rdquo;的右值。</target>
        </trans-unit>
        <trans-unit id="572d04428c30798e603b05f06992752d438676f3" translate="yes" xml:space="preserve">
          <source>Array decaying means that, when an array is passed as a parameter to a function, it's treated identically to (&quot;decays to&quot;) a pointer.</source>
          <target state="translated">数组衰变意味着,当一个数组作为参数传递给一个函数时,它的处理方式与指针相同(&quot;衰变为&quot;)。</target>
        </trans-unit>
        <trans-unit id="2504de460ca48ca652515d2e95d788ac6397c47d" translate="yes" xml:space="preserve">
          <source>Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:</source>
          <target state="translated">数组基本上和CC++中的指针一样,但又不完全一样。一旦你转换了一个数组。</target>
        </trans-unit>
        <trans-unit id="f6b98d449f169ec5000ed0687a72f8d69aaa611a" translate="yes" xml:space="preserve">
          <source>Assume the following code:</source>
          <target state="translated">假设代码如下:</target>
        </trans-unit>
        <trans-unit id="d623c4ac7a1b6a2336cd3de0984beb4c6ce2f3a5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;ptr_to_first_element&lt;/code&gt; and &lt;code&gt;ptr_to_array&lt;/code&gt; have the same &lt;em&gt;value&lt;/em&gt;; the base address of a.  However, they are different types and are treated differently, as shown below:</source>
          <target state="translated">&lt;code&gt;ptr_to_first_element&lt;/code&gt; 和 &lt;code&gt;ptr_to_array&lt;/code&gt; 具有相同的&lt;em&gt;值&lt;/em&gt; ； a的基地址。 但是，它们是不同的类型，并且区别对待，如下所示：</target>
        </trans-unit>
        <trans-unit id="c0ba2510f593d5c4730c7b53d78941d20631790f" translate="yes" xml:space="preserve">
          <source>Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a
  string literal used to initialize an array, an expression that has type &amp;lsquo;&amp;lsquo;array of type&amp;rsquo;&amp;rsquo; is
  converted to an expression with type &amp;lsquo;&amp;lsquo;pointer to type&amp;rsquo;&amp;rsquo; that points to the initial element of
  the array object and is not an lvalue.</source>
          <target state="translated">除非它是sizeof运算符或一元＆运算符的操作数，或者是用于初始化数组的字符串文字，否则将类型为&amp;ldquo; array of type&amp;rdquo;的表达式转换为类型为&amp;ldquo; pointer to to&amp;rdquo;的表达式类型''，它指向数组对象的初始元素，不是左值。</target>
        </trans-unit>
        <trans-unit id="e4620cd591c8d41594b31aea3b33cac9222653f8" translate="yes" xml:space="preserve">
          <source>First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.</source>
          <target state="translated">首先,在C和C++中处理多维数组时,只有第一个维数组被丢失。这是因为数组在内存中是连续地排列的,所以编译器必须知道除了第一维以外的所有数组,才能计算出进入该内存块的偏移量。</target>
        </trans-unit>
        <trans-unit id="b67d5b515aef01ab7697545039259ee6299aa621" translate="yes" xml:space="preserve">
          <source>For more details, check out this &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot;&gt;article about array decay&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请查看&lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot;&gt;有关数组衰减的本文&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="66a3f61a4f5c9cc8f0c9f707c2704a039bff9f2c" translate="yes" xml:space="preserve">
          <source>Function foo expects the value of an array. But, in C, arrays have no value! So &lt;code&gt;foo&lt;/code&gt; gets instead the address of the first element of the array.</source>
          <target state="translated">函数foo需要一个数组的值。 但是，在C语言中，数组没有任何价值！ 因此 &lt;code&gt;foo&lt;/code&gt; 取而代之的是数组第一个元素的地址。</target>
        </trans-unit>
        <trans-unit id="93ddb0141afd9ecfa44949d318cd4b180a79e263" translate="yes" xml:space="preserve">
          <source>Here's what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):</source>
          <target state="translated">标准是这样说的(C99 6.3.2.13--其他操作数--L值、数组和函数代号)。</target>
        </trans-unit>
        <trans-unit id="2f69062bcf9c16e967805dcc3676465f9bdff391" translate="yes" xml:space="preserve">
          <source>I might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.</source>
          <target state="translated">我可能也会认为这说明了C++vs C的优越性,至少在通过引用(双关语)传递数组的引用中,我认为这说明了C++的优越性。</target>
        </trans-unit>
        <trans-unit id="2bbc8143578adf65237b78876ca44811525cc8b6" translate="yes" xml:space="preserve">
          <source>I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.</source>
          <target state="translated">我可能会大胆地认为有四种方法可以传递一个数组作为函数参数。这里还有一个简短而有效的代码,供大家参考。</target>
        </trans-unit>
        <trans-unit id="7264ad7e3ffb4141844d0c336996116af4bb0122" translate="yes" xml:space="preserve">
          <source>If you're passing an array by value, what you're really doing is copying a pointer - a pointer to the array's first element is copied to the parameter (whose type should also be a pointer the array element's type). This works due to array's decaying nature; once decayed, &lt;code&gt;sizeof&lt;/code&gt; no longer gives the complete array's size, because it essentially becomes a pointer.  This is why it's preferred (among other reasons) to pass by reference or pointer.</source>
          <target state="translated">如果要按值传递数组，则实际上是在复制指针-将指向数组第一个元素的指针复制到参数（其类型也应为数组元素类型的指针）。 这是由于数组的衰减特性而起作用的。 一旦衰减， &lt;code&gt;sizeof&lt;/code&gt; 不再给出完整数组的大小，因为它实际上成为了指针。 这就是为什么（除其他原因外）首选通过引用或指针传递。</target>
        </trans-unit>
        <trans-unit id="2426ce0cfd2ae39e025a59289febb3d5f7fe28cd" translate="yes" xml:space="preserve">
          <source>In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it &quot;decays into a pointer&quot; (sic); when you compare an array to something else, again it &quot;decays into a pointer&quot; (sic); ...</source>
          <target state="translated">在函数中,所有的参数都是通过值传递的(数组也不例外)。当你在函数中传递一个数组时,它会 &quot;衰减成一个指针&quot;(原文如此);当你把数组与其他的东西进行比较时,它又会 &quot;衰减成一个指针&quot;(原文如此);......</target>
        </trans-unit>
        <trans-unit id="ca3ac27f8fa7044755eff98bdc26d22a299a16a3" translate="yes" xml:space="preserve">
          <source>In the array indexing syntax you are used to seeing, again, the arr is 'decayed to a pointer'</source>
          <target state="translated">在你已经习惯了的数组索引语法中,同样,arr是 &quot;衰变为指针</target>
        </trans-unit>
        <trans-unit id="3acf04b7e934c50f3341e33ecbf3ddba739d41a7" translate="yes" xml:space="preserve">
          <source>In the comparison above, &lt;code&gt;arr&lt;/code&gt; has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable &lt;code&gt;ip&lt;/code&gt;.</source>
          <target state="translated">在上面的比较中， &lt;code&gt;arr&lt;/code&gt; 没有值，因此它成为一个指针。 它成为指向int的指针。 该指针可以与变量 &lt;code&gt;ip&lt;/code&gt; 进行比较。</target>
        </trans-unit>
        <trans-unit id="3a608dabdd48971d982bdee712aa38cc50d33cc1" translate="yes" xml:space="preserve">
          <source>It's said that arrays &quot;decay&quot; into pointers.  A C++ array declared as &lt;code&gt;int numbers [5]&lt;/code&gt; cannot be re-pointed, i.e. you can't say &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt;. More importantly the term decay signifies loss of type and dimension; &lt;code&gt;numbers&lt;/code&gt; decay into &lt;code&gt;int*&lt;/code&gt; by losing the dimension information (count 5) and the type is not &lt;code&gt;int [5]&lt;/code&gt; any more. Look here for &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;cases where the decay doesn't happen&lt;/a&gt;.</source>
          <target state="translated">据说数组会&amp;ldquo;衰减&amp;rdquo;到指针中。 声明为 &lt;code&gt;int numbers [5]&lt;/code&gt; 的C ++数组无法重新指向，即，您不能说 &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt; 。 更重要的是，术语&amp;ldquo;衰减&amp;rdquo;表示类型和尺寸的损失。 &lt;code&gt;numbers&lt;/code&gt; 丢失维信息（计数5）而变成 &lt;code&gt;int*&lt;/code&gt; ，类型不再是 &lt;code&gt;int [5]&lt;/code&gt; 。 在这里寻找&lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;不发生衰减的情况&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="75b81db01f0edec0fed30d115d6b7d3ba38da199" translate="yes" xml:space="preserve">
          <source>It's when array rots and is being pointed at ;-)</source>
          <target state="translated">这是当数组烂了,被指着的时候;-)</target>
        </trans-unit>
        <trans-unit id="d717086108630d7af551627a6f2f8097ecdd3d6e" translate="yes" xml:space="preserve">
          <source>Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn't cause nearly as much confusion as the automatic conversion of array names to pointers.</source>
          <target state="translated">请注意,函数名的作用与此类似,但函数指针的使用要少得多,而且使用的方式要专业得多,不会像数组名自动转换为指针那样引起混乱。</target>
        </trans-unit>
        <trans-unit id="f7e7f226b763b9d9ec2e0712651895d6237a9ebf" translate="yes" xml:space="preserve">
          <source>Of course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.</source>
          <target state="translated">当然也有极其严格的项目,没有堆分配,没有异常,没有 std::lib。可以说,C++的原生数组处理是任务关键的语言特性。</target>
        </trans-unit>
        <trans-unit id="b67d400e1ef3e4e91eee3d3d9e452dd5495d95ea" translate="yes" xml:space="preserve">
          <source>Remember that the expression &lt;code&gt;a[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(a+i)&lt;/code&gt; (which only works if the array type is converted to a pointer type), so both &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; work the same. The expression &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(*a+i)&lt;/code&gt;.  The expressions &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; and &lt;code&gt;ptr_to_array[i]&lt;/code&gt; may lead to compiler warnings or errors depending on the context; they'll definitely do the wrong thing if you're expecting them to evaluate to &lt;code&gt;a[i]&lt;/code&gt;.</source>
          <target state="translated">请记住，表达式 &lt;code&gt;a[i]&lt;/code&gt; 被解释为 &lt;code&gt;*(a+i)&lt;/code&gt; （仅在将数组类型转换为指针类型时才有效），因此 &lt;code&gt;a[i]&lt;/code&gt; 和 &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; 都相同。 表达式 &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; 解释为 &lt;code&gt;*(*a+i)&lt;/code&gt; 。 取决于上下文，表达式 &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; 和 &lt;code&gt;ptr_to_array[i]&lt;/code&gt; 可能导致编译器警告或错误。 如果您期望他们将评估为 &lt;code&gt;a[i]&lt;/code&gt; 那么他们肯定会做错事。</target>
        </trans-unit>
        <trans-unit id="21f571aadabef22c86699783c6de4b70ecead3c5" translate="yes" xml:space="preserve">
          <source>Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot;&gt;strcpy_s&lt;/a&gt;, and you can use a similar trick to reliably &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;get the number of elements in an array&lt;/a&gt;.</source>
          <target state="translated">其次，在C ++中，您可以使用模板来推断数组的大小。 Microsoft将它用于诸如&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot;&gt;strcpy_s之&lt;/a&gt;类的Secure CRT函数的C ++版本，并且您可以使用类似的技巧来可靠地&lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;获取数组中的元素数&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cf7e537136bba43900f7f51100e034763e82e5d" translate="yes" xml:space="preserve">
          <source>So the conversion doesn't &lt;em&gt;have&lt;/em&gt; to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).</source>
          <target state="translated">因此，转换不必像C语言中那样总是发生（这使函数重载或模板在数组类型上匹配）。</target>
        </trans-unit>
        <trans-unit id="1f64d5bdb8222551b4c814f7020160a0c4d446a4" translate="yes" xml:space="preserve">
          <source>Sort-of exceptions to this rule:</source>
          <target state="translated">算是这个规则的例外。</target>
        </trans-unit>
        <trans-unit id="374991ae64032aa0b674020550de47cc0d02fc4b" translate="yes" xml:space="preserve">
          <source>The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):</source>
          <target state="translated">C++标准(4.2 Array-to-pointer转换)将转换要求放宽到(强调是我的)。</target>
        </trans-unit>
        <trans-unit id="a0b4a750f64a796bb9c9e478100e4e15af5d260e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;a&lt;/code&gt; is of type &quot;80-element array of char&quot; and the expression &quot;This is a test&quot; is of type &quot;16-element array of char&quot; (in C; in C++ string literals are arrays of const char).  However, in the call to &lt;code&gt;strcpy()&lt;/code&gt;, neither expression is an operand of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, so their types are implicitly converted to &quot;pointer to char&quot;, and their values are set to the address of the first element in each.  What &lt;code&gt;strcpy()&lt;/code&gt; receives are not arrays, but pointers, as seen in its prototype:</source>
          <target state="translated">表达式 &lt;code&gt;a&lt;/code&gt; 的类型为&amp;ldquo; 80个元素的char数组&amp;rdquo;，表达式&amp;ldquo;这是一个测试&amp;rdquo;的类型为&amp;ldquo; 16个元素的char数组&amp;rdquo;（在C中；在C ++中，字符串文字是const char的数组）。 但是，在对 &lt;code&gt;strcpy()&lt;/code&gt; 的调用中，两个表达式都不是 &lt;code&gt;sizeof&lt;/code&gt; 或 &lt;code&gt;&amp;amp;&lt;/code&gt; 的操作数，因此它们的类型都隐式转换为&amp;ldquo; char的指针&amp;rdquo;，并且它们的值设置为每个中第一个元素的地址。 &lt;code&gt;strcpy()&lt;/code&gt; 接收的不是数组，而是指针，如其原型所示：</target>
        </trans-unit>
        <trans-unit id="cc1f2c92734a69f415a5acffe3a57fc184a7af29" translate="yes" xml:space="preserve">
          <source>The last two will give proper &lt;code&gt;sizeof&lt;/code&gt; info, while the first one won't since the array argument has decayed to be assigned to the parameter.</source>
          <target state="translated">最后两个将提供适当的 &lt;code&gt;sizeof&lt;/code&gt; 信息，而第一个则不会，因为array参数已衰减为可分配给该参数。</target>
        </trans-unit>
        <trans-unit id="96d0631bd8e97056f77f41e42872acd43b78edf7" translate="yes" xml:space="preserve">
          <source>The only times an array doesn't decay into a pointer are when it is the operand of the sizeof operator, or the &amp;amp; operator (the 'address of' operator), or as a string literal used to initialize a character array.</source>
          <target state="translated">数组唯一不会衰减为指针的情况是它是sizeof运算符的操作数或＆运算符（'address of'运算符）的操作数，或者是用作初始化字符数组的字符串文字。</target>
        </trans-unit>
        <trans-unit id="2b526d981401e0c2d70d62bcd0c44f9ede8ae7e2" translate="yes" xml:space="preserve">
          <source>There are two complications or exceptions to the above.</source>
          <target state="translated">上述情况有两种并发症或例外情况。</target>
        </trans-unit>
        <trans-unit id="f81d6ffafbf5b704f07c47eca12d330779e7d845" translate="yes" xml:space="preserve">
          <source>This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I'm not sure if there's any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn't lying.</source>
          <target state="translated">这也是为什么在C语言中你应该避免在函数原型定义中使用数组参数的原因(在我看来--我不确定是否有普遍的共识)。它们会造成混乱,而且无论如何都是一种虚构----使用指针参数,混乱可能不会完全消失,但至少参数声明没有说谎。</target>
        </trans-unit>
        <trans-unit id="8e6a15535b3af3a50ce3dc0aaf2505fc5db33d0b" translate="yes" xml:space="preserve">
          <source>This is not the same thing as an array pointer.  For example:</source>
          <target state="translated">这和数组指针是不一样的。比如说。</target>
        </trans-unit>
        <trans-unit id="def5eca561f95373c185551a5184d5c82b79c30e" translate="yes" xml:space="preserve">
          <source>This lost ability is referred to as &quot;decay&quot;.</source>
          <target state="translated">这种丧失的能力,被称为 &quot;腐化&quot;。</target>
        </trans-unit>
        <trans-unit id="da4f48a08795c085825fa49034357d199855026e" translate="yes" xml:space="preserve">
          <source>This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.</source>
          <target state="translated">这意味着,在表达式中使用数组名称的时候,几乎所有的数组名称都会自动转换为指向数组中的第1个项的指针。</target>
        </trans-unit>
        <trans-unit id="bf38c57dfd53ee57a7e7d131ca570ae92a570d9e" translate="yes" xml:space="preserve">
          <source>Three ways to pass in an array&lt;sup&gt;1&lt;/sup&gt;:</source>
          <target state="translated">传递数组&lt;sup&gt;1的&lt;/sup&gt;三种方法：</target>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="6aa8d44a900157b56ec4f557db7604118f57c0eb" translate="yes" xml:space="preserve">
          <source>What is array to pointer decay</source>
          <target state="translated">什么是数组到指针的衰落</target>
        </trans-unit>
        <trans-unit id="a116f6630933726f994dcd4f5a10875ec018b1d7" translate="yes" xml:space="preserve">
          <source>What is array to pointer decay? Is there any relation to array pointers?</source>
          <target state="translated">什么是数组对指针的衰减?和数组指针有什么关系吗?</target>
        </trans-unit>
        <trans-unit id="2dc4418ae9ebbb34e793477eb0fad36643b32b7a" translate="yes" xml:space="preserve">
          <source>When you write &lt;code&gt;arr[idx]&lt;/code&gt; you're really just saying &lt;code&gt;*(arr + idx)&lt;/code&gt;.</source>
          <target state="translated">当您编写 &lt;code&gt;arr[idx]&lt;/code&gt; 您实际上只是在说 &lt;code&gt;*(arr + idx)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c5c7c7abeb7e74d4d39cb704af4b6c614a3f709" translate="yes" xml:space="preserve">
          <source>Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type &lt;code&gt;pointer to (type of array elements)&lt;/code&gt;.</source>
          <target state="translated">无论何时需要对象的值但该对象是一个数组，都将使用其第一个元素的地址，并使用 &lt;code&gt;pointer to (type of array elements)&lt;/code&gt; 类型的指针 。</target>
        </trans-unit>
        <trans-unit id="8612b28344f7df5c3c84d9b73b89903f33d4c6f2" translate="yes" xml:space="preserve">
          <source>You can pass fixed-length arrays to functions within a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">您可以将固定长度的数组传递给 &lt;code&gt;struct&lt;/code&gt; 中的函数 。</target>
        </trans-unit>
        <trans-unit id="e204589387a540663ec39ea0b5a6f041d6878b6c" translate="yes" xml:space="preserve">
          <source>functions never really take arrays as parameters, only pointers, even when you specify an array parameter.</source>
          <target state="translated">函数从来没有真正地把数组作为参数,只有指针,即使你指定了一个数组参数。</target>
        </trans-unit>
        <trans-unit id="6bc2702e0131275e3964f40b6237c9f12cce8c25" translate="yes" xml:space="preserve">
          <source>into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):</source>
          <target state="translated">转为指针(在没有铸造的情况下也能正常工作,因此在某些情况下可能会出现意外情况)。</target>
        </trans-unit>
        <trans-unit id="412007ea4e463f6e39ce41519f9448bb091a3aa2" translate="yes" xml:space="preserve">
          <source>tl;dr: When you use an array you've define, you'll actually be using a pointer to its first element.</source>
          <target state="translated">tl;dr:当你使用你定义的数组时,你实际上会使用一个指向其第一个元素的指针。</target>
        </trans-unit>
        <trans-unit id="ce713d143604dd99c2530308ef27ca215366f0d3" translate="yes" xml:space="preserve">
          <source>you lose the ability of the &lt;code&gt;sizeof&lt;/code&gt; operator to count elements in the array:</source>
          <target state="translated">您将失去 &lt;code&gt;sizeof&lt;/code&gt; 运算符对数组中元素进行计数的能力：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
