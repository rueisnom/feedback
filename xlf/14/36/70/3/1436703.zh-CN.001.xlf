<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1436703">
    <body>
      <group id="1436703">
        <trans-unit id="f4e25ec010738edfa81015df5c8d0540f8058b4f" translate="yes" xml:space="preserve">
          <source>(you can probably also figure out what to do about dictionaries.</source>
          <target state="translated">(你大概也能算出字典的事情了吧。</target>
        </trans-unit>
        <trans-unit id="7d103faabf761c02013a9ffc061d63b9651e1f88" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;__repr__()&lt;/code&gt; is invoked when you simply write object's name on interactive python console and press enter.</source>
          <target state="translated">1）当您在交互式python控制台上简单地写对象名称并按Enter时，将调用 &lt;code&gt;__repr__()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9c72ee953d43911c466e0ca7aef8427b918dad3" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;__str__()&lt;/code&gt; is invoked when you use object with print statement.</source>
          <target state="translated">2）当您将对象与print语句一起使用时，将调用 &lt;code&gt;__str__()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2259cc53b4beb00ea0cb5f21e02d5747ef33b70" translate="yes" xml:space="preserve">
          <source>3) In case, if &lt;code&gt;__str__&lt;/code&gt; is missing, then print and any function using &lt;code&gt;str()&lt;/code&gt; invokes &lt;code&gt;__repr__()&lt;/code&gt; of object.</source>
          <target state="translated">3）如果缺少 &lt;code&gt;__str__&lt;/code&gt; ，则打印并使用 &lt;code&gt;str()&lt;/code&gt; 的任何函数调用对象的 &lt;code&gt;__repr__()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68209245d4a6dff79cdd29404b330579c8dc403f" translate="yes" xml:space="preserve">
          <source>4) &lt;code&gt;__str__()&lt;/code&gt; of containers, when invoked will execute &lt;code&gt;__repr__()&lt;/code&gt; method of its contained elements.</source>
          <target state="translated">4）容器的 &lt;code&gt;__str__()&lt;/code&gt; ，在调用时将对其包含的元素执行 &lt;code&gt;__repr__()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="bd4781db3f8860ef56abf646f6d70c15a94cac7c" translate="yes" xml:space="preserve">
          <source>5) &lt;code&gt;str()&lt;/code&gt; called within &lt;code&gt;__str__()&lt;/code&gt; could potentially recurse without a base case, and error on maximum recursion depth.</source>
          <target state="translated">5）在 &lt;code&gt;__str__()&lt;/code&gt; &lt;code&gt;str()&lt;/code&gt; 调用的str（）可能会在没有基本情况的情况下进行递归，并且会出现最大递归深度的错误。</target>
        </trans-unit>
        <trans-unit id="f944eb318831eb3307673ad51e244207b807a90e" translate="yes" xml:space="preserve">
          <source>6) &lt;code&gt;__repr__()&lt;/code&gt; can call &lt;code&gt;repr()&lt;/code&gt; which will attempt to avoid infinite recursion automatically, replacing an already represented object with &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">6） &lt;code&gt;__repr__()&lt;/code&gt; &lt;code&gt;repr()&lt;/code&gt; __（）可以调用repr（） ，它将尝试自动避免无限递归，用 &lt;code&gt;...&lt;/code&gt; 替换已经表示的对象。</target>
        </trans-unit>
        <trans-unit id="b63fbdd60bc6bc4b249dc838669a14dc09a22ace" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/95810/alex-martelli&quot;&gt;Alex&lt;/a&gt; summarized well but, surprisingly, was too succinct.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/95810/alex-martelli&quot;&gt;亚历克斯&lt;/a&gt;总结得很好，但令人惊讶的是，它太简洁了。</target>
        </trans-unit>
        <trans-unit id="cdccd33bc551383c9f81019018903d0deaca740a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__repr__&lt;/code&gt; can be invoked on an object by calling &lt;code&gt;repr(obj)&lt;/code&gt; and should return internal object (object fields/attributes)</source>
          <target state="translated">可以通过调用 &lt;code&gt;repr(obj)&lt;/code&gt; 在对象上调用 &lt;code&gt;__repr__&lt;/code&gt; ,并且应该返回内部对象（对象字段/属性）</target>
        </trans-unit>
        <trans-unit id="faf0d1f1312e3f35b3c3e35c73e72580ea5fad40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__repr__&lt;/code&gt; goal is to be unambiguous</source>
          <target state="translated">&lt;code&gt;__repr__&lt;/code&gt; 目标是明确的</target>
        </trans-unit>
        <trans-unit id="38772fe6e2a92c7f9e19245ea20f3baa852d9c88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__repr__&lt;/code&gt; is used everywhere, except by &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods (when a &lt;code&gt;__str__&lt;/code&gt;is defined !)</source>
          <target state="translated">除了 &lt;code&gt;print&lt;/code&gt; 和 &lt;code&gt;str&lt;/code&gt; 方法（定义了 &lt;code&gt;__str__&lt;/code&gt; ！）之外， &lt;code&gt;__repr__&lt;/code&gt; 随处可见。</target>
        </trans-unit>
        <trans-unit id="2f5f7a48c655f0e14ca4c1f56eae9dca508f1fce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__repr__&lt;/code&gt; is used to show a string representation of &lt;strong&gt;the&lt;/strong&gt; object.</source>
          <target state="translated">&lt;code&gt;__repr__&lt;/code&gt; 用于显示对象的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="c5f10753db206b6a0a329be9c1b34de815311211" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__repr__&lt;/code&gt; provides backup behavior if &lt;code&gt;__str__&lt;/code&gt; is missing.</source>
          <target state="translated">如果缺少 &lt;code&gt;__str__&lt;/code&gt; ,则 &lt;code&gt;__repr__&lt;/code&gt; 提供备份行为。</target>
        </trans-unit>
        <trans-unit id="c119ea20bcd02e26639d32bba5faa3419cb0eb92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__repr__&lt;/code&gt; return the real flesh body of a given object (return itself) for unambiguity to identify.</source>
          <target state="translated">&lt;code&gt;__repr__&lt;/code&gt; 返回给定对象的真实肉体（返回自身）以明确识别。</target>
        </trans-unit>
        <trans-unit id="d5c28cf192c3f3a579db8549c627a82851b6d844" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__str__&lt;/code&gt; &quot;&lt;em&gt;computes the &quot;informal&quot; string representation of an object. This differs from &lt;code&gt;__repr__&lt;/code&gt; in that it does not have to be a valid Python expression: a more convenient or concise representation may be used instead.&lt;/em&gt;&quot;</source>
          <target state="translated">&lt;code&gt;__str__&lt;/code&gt; &amp;rdquo; &lt;em&gt;计算对象的&amp;ldquo;非正式&amp;rdquo;字符串表示形式。与 &lt;code&gt;__repr__&lt;/code&gt; 的不同之处在于，它不必是有效的Python表达式：可以使用更方便或更简洁的表示形式。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bfa620b1a7431c4859f2c8da452e6862250529f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__str__&lt;/code&gt; (read as &quot;dunder (double-underscore) string&quot;) and &lt;code&gt;__repr__&lt;/code&gt; (read as &quot;dunder-repper&quot; (for &quot;representation&quot;)) are both special methods that return strings based on the state of the object.</source>
          <target state="translated">&lt;code&gt;__str__&lt;/code&gt; （读作&amp;ldquo; dunder（双下划线）字符串&amp;rdquo;）和 &lt;code&gt;__repr__&lt;/code&gt; （读作&amp;ldquo; dunder-repper&amp;rdquo;（对于&amp;ldquo;表示形式&amp;rdquo;））都是根据对象状态返回字符串的特殊方法。</target>
        </trans-unit>
        <trans-unit id="7c651efa9bf24f2b31c5de5fc79e0b5e3ff3b352" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__str__&lt;/code&gt; can be invoked on an object by calling &lt;code&gt;str(obj)&lt;/code&gt; and should return a human readable string.</source>
          <target state="translated">可以通过调用 &lt;code&gt;str(obj)&lt;/code&gt; 在对象上调用 &lt;code&gt;__str__&lt;/code&gt; ,并且应返回人类可读的字符串。</target>
        </trans-unit>
        <trans-unit id="1fe48568b7333a75afde0885d338596099b0b9ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__str__&lt;/code&gt; goal is to be readable</source>
          <target state="translated">&lt;code&gt;__str__&lt;/code&gt; 目标是可读性</target>
        </trans-unit>
        <trans-unit id="55ddd6314708d8a0588442c30c939e61ded9378b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__str__&lt;/code&gt; is used in to show a string representation of your object &lt;strong&gt;to be read easily&lt;/strong&gt; by others.</source>
          <target state="translated">&lt;code&gt;__str__&lt;/code&gt; 用于显示对象的字符串表示形式， &lt;strong&gt;以方便&lt;/strong&gt;他人&lt;strong&gt;阅读&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f171aea17d3f084f44acd3a77fda54fd0106bd50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__str__&lt;/code&gt; must return string object whereas &lt;code&gt;__repr__&lt;/code&gt; can return any python expression.</source>
          <target state="translated">&lt;code&gt;__str__&lt;/code&gt; 必须返回字符串对象，而 &lt;code&gt;__repr__&lt;/code&gt; 可以返回任何python表达式。</target>
        </trans-unit>
        <trans-unit id="7cbf41af4e945d63d8a427626efbd9a8369e420d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__str__&lt;/code&gt; return the string disguised body of a given object for readable of eyes</source>
          <target state="translated">&lt;code&gt;__str__&lt;/code&gt; 返回给定对象的字符串伪装体，以使眼睛可读</target>
        </trans-unit>
        <trans-unit id="d0148184e035bb53e9299f20ce4d944cfa214ba1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repr&lt;/code&gt; - Returns the canonical string representation of the object.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; -返回对象的规范字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="3c97d0c508bd7f652eb5099d0d84685d4a198697" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;str&lt;/code&gt; - Creates a new string object from the given object.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; -从给定的对象创建一个新的字符串对象。</target>
        </trans-unit>
        <trans-unit id="5f4d2fa5ab3c6b599a4287372ac939b133314c0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Python favors unambiguity over readability&lt;/em&gt;, the &lt;code&gt;__str__&lt;/code&gt; call of a &lt;code&gt;tuple&lt;/code&gt; calls the contained objects' &lt;code&gt;__repr__&lt;/code&gt;, the &lt;em&gt;&quot;formal&quot;&lt;/em&gt; representation of an object. Although the formal representation is harder to read than an informal one, it is unambiguous and more robust against bugs.</source>
          <target state="translated">&lt;em&gt;Python主张明确性胜于可读性&lt;/em&gt; ， &lt;code&gt;tuple&lt;/code&gt; 的 &lt;code&gt;__str__&lt;/code&gt; 调用调用包含的对象的 &lt;code&gt;__repr__&lt;/code&gt; ，即对象的&lt;em&gt;&amp;ldquo;形式&amp;rdquo;&lt;/em&gt;表示。 尽管正式表示比非正式表示更难读，但它对歧义没有任何歧义，并且更强大。</target>
        </trans-unit>
        <trans-unit id="2eb102ea6ac8d0cf17aff98429ed0b3c3f7cbcf9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;__repr__&lt;/code&gt;&lt;/strong&gt;: representation of python object usually eval will convert it back to that object</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;__repr__&lt;/code&gt; &lt;/strong&gt; ：python对象的表示形式，通常eval会将其转换回该对象</target>
        </trans-unit>
        <trans-unit id="014fecb0e8589f0d9e987d41a97f853e2d9063f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;__str__&lt;/code&gt;&lt;/strong&gt;: is whatever you think is that object in text form</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;__str__&lt;/code&gt; &lt;/strong&gt; ：您认为文本形式的对象是什么</target>
        </trans-unit>
        <trans-unit id="fe2ca45a3f9fe5c28bd8698502e23200d2fe1e5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Container&amp;rsquo;s &lt;code&gt;__str__&lt;/code&gt; uses contained objects&amp;rsquo; &lt;code&gt;__repr__&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;容器的 &lt;code&gt;__str__&lt;/code&gt; 使用包含对象的 &lt;code&gt;__repr__&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="313fdb212ef7d654563fd68a4dbe97b36573af9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default implementation is useless&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;默认实现是没有用的&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b638660706a1e4d9b0bfc3894141750f70ecc431" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The goal of &lt;code&gt;__repr__&lt;/code&gt; is to be unambiguous&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;__repr__&lt;/code&gt; 的目标是明确的&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dffbc9fa2806a68ab5b88a6dc66d657557e6645" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The goal of &lt;code&gt;__str__&lt;/code&gt; is to be readable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;__str__&lt;/code&gt; 的目标是易于阅读&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d7bff912bc70a87ac98674f745266dc1fd1ed585" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;repr = reproduce&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;repr =复制&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aed7370515328b7386d9c2d92149f875c62b2f66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;repr():&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;repr():&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0c1ca48e2a313fb24ab9d23a999e9c6f0750466" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;str = string (representation)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;str =字符串（表示形式）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00c5743fa341fadec53dc7207f7b70b9f864ec69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;str():&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;str():&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff67b9f7a4b9f4c8c271c3bb05146fb2115fc542" translate="yes" xml:space="preserve">
          <source>A basic requirement for a Python object is to provide usable 
       string   representations of itself, one used for debugging and
       logging, another for presentation to end users. That is why the</source>
          <target state="translated">对Python对象的一个基本要求是提供可用的字符串表示本身,一个用于调试和记录,另一个用于向最终用户展示。这就是为什么</target>
        </trans-unit>
        <trans-unit id="da308aeb7ec2f80344365b3a4d9fc4bfb4791053" translate="yes" xml:space="preserve">
          <source>A small but good example is also given on the same page as follows:</source>
          <target state="translated">下面也举了一个小而精的例子。</target>
        </trans-unit>
        <trans-unit id="9f008c6ab79e7861bf8d9ef2ff2fd5300056f5d4" translate="yes" xml:space="preserve">
          <source>Another example.</source>
          <target state="translated">又如:</target>
        </trans-unit>
        <trans-unit id="0c01c6cca37e136fdbf85630b4cfeb648b4e77e3" translate="yes" xml:space="preserve">
          <source>Apart from all the answers given, I would like to add few points :-</source>
          <target state="translated">除了所有的答案之外,我还想补充几点:--</target>
        </trans-unit>
        <trans-unit id="18289ef151e4e90c453904ba3b24e3b9634a21c7" translate="yes" xml:space="preserve">
          <source>As to &lt;code&gt;__repr__&lt;/code&gt;</source>
          <target state="translated">至于 &lt;code&gt;__repr__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32497f78a61159dd2d671ec8052a0c2d71c59903" translate="yes" xml:space="preserve">
          <source>As you see -- no difference, and no info beyond the class and object's &lt;code&gt;id&lt;/code&gt;.  If you only override one of the two...:</source>
          <target state="translated">如您所见-没有区别，没有任何信息超出类和对象的 &lt;code&gt;id&lt;/code&gt; 。 如果仅覆盖两个...之一：</target>
        </trans-unit>
        <trans-unit id="84962694189a72510e0996db2aa3ca43180bfbc9" translate="yes" xml:space="preserve">
          <source>As you're developing, you'll want to be able to reproduce objects in the same state, if possible. This, for example, is how the datetime object defines &lt;code&gt;__repr__&lt;/code&gt; (&lt;a href=&quot;https://github.com/python/cpython/blob/v3.7.3/Lib/datetime.py#L1876&quot;&gt;Python source&lt;/a&gt;). It is fairly complex, because of all of the attributes needed to reproduce such an object:</source>
          <target state="translated">在开发过程中，如果可能的话，您将希望能够以相同的状态再现对象。 例如，这就是datetime对象定义 &lt;code&gt;__repr__&lt;/code&gt; （ &lt;a href=&quot;https://github.com/python/cpython/blob/v3.7.3/Lib/datetime.py#L1876&quot;&gt;Python源&lt;/a&gt; ）的方式。 由于复制此类对象所需的所有属性，它相当复杂：</target>
        </trans-unit>
        <trans-unit id="de00522a3ff15a155a60dc6d8db9a728ede4b85d" translate="yes" xml:space="preserve">
          <source>At any time later, one can write a &lt;code&gt;__str__&lt;/code&gt; for a user-readable string representation of the instance, when one believes it to be necessary.</source>
          <target state="translated">在以后的任何时候，只要有人认为有必要，就可以为该实例的用户可读字符串表示形式编写 &lt;code&gt;__str__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40c9c9f611104210a4ec1ca0fe8d653c89cd780a" translate="yes" xml:space="preserve">
          <source>But you have to do the last step &amp;mdash; make sure every object you implement has a useful repr, so code like that can just work. This is why the &amp;ldquo;eval&amp;rdquo; thing comes up: if you have enough information so &lt;code&gt;eval(repr(c))==c&lt;/code&gt;, that means you know everything there is to know about &lt;code&gt;c&lt;/code&gt;. If that&amp;rsquo;s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about &lt;code&gt;c&lt;/code&gt; anyway. I usually use an eval-like format: &lt;code&gt;&quot;MyClass(this=%r,that=%r)&quot; % (self.this,self.that)&lt;/code&gt;. It does not mean that you can actually construct MyClass, or that those are the right constructor arguments &amp;mdash; but it is a useful form to express &amp;ldquo;this is everything you need to know about this instance&amp;rdquo;.</source>
          <target state="translated">但是，您必须做最后一步-确保实现的每个对象都有一个有用的代表，这样的代码才能正常工作。 这就是为什么出现&amp;ldquo; eval&amp;rdquo;的原因：如果您有足够的信息，所以 &lt;code&gt;eval(repr(c))==c&lt;/code&gt; ，这意味着您知道有关 &lt;code&gt;c&lt;/code&gt; 的所有知识。 如果那很容易（至少以一种模糊的方式），那就去做。 如果不是，请确保您仍然有足够的有关 &lt;code&gt;c&lt;/code&gt; 的信息。 我通常使用类似eval的格式： &lt;code&gt;&quot;MyClass(this=%r,that=%r)&quot; % (self.this,self.that)&lt;/code&gt; 。 这并不意味着您可以实际构造MyClass，也不意味着它们是正确的构造函数参数&amp;mdash;但这是表达&amp;ldquo;这是您需要了解的所有实例&amp;rdquo;的有用形式。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="4e523dace7302e3a2b6c27d81b9e20886d0d761f" translate="yes" xml:space="preserve">
          <source>Container&amp;rsquo;s &lt;code&gt;__str__&lt;/code&gt; uses contained objects&amp;rsquo; &lt;code&gt;__repr__&lt;/code&gt;</source>
          <target state="translated">容器的 &lt;code&gt;__str__&lt;/code&gt; 使用包含对象的 &lt;code&gt;__repr__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="864d1d58c0dc2b08ee9255a38de949183c561b18" translate="yes" xml:space="preserve">
          <source>Default Implementation of &lt;code&gt;__repr__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__repr__&lt;/code&gt; 的默认实现</target>
        </trans-unit>
        <trans-unit id="aaaac60719b4c68f3e6efde310393b8c1d9847fe" translate="yes" xml:space="preserve">
          <source>Define &lt;code&gt;__repr__&lt;/code&gt; for objects you write so you and other developers have a reproducible example when using it as you develop. Define &lt;code&gt;__str__&lt;/code&gt; when you need a human readable string representation of it.</source>
          <target state="translated">为您编写的对象定义 &lt;code&gt;__repr__&lt;/code&gt; ，以便您和其他开发人员在开发过程中使用它时都可以重现一个示例。 当您需要 &lt;code&gt;__str__&lt;/code&gt; 的人类可读的字符串表示形式时，请定义它。</target>
        </trans-unit>
        <trans-unit id="4e236371232f495613ed6a39714358170d0d9f34" translate="yes" xml:space="preserve">
          <source>Difference between __str__ and __repr__</source>
          <target state="translated">___str__和__repr__之间的区别</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="4f369676493c631748ef19bfb6774924b7209730" translate="yes" xml:space="preserve">
          <source>Excellent answers already cover the difference between &lt;code&gt;__str__&lt;/code&gt; and &lt;code&gt;__repr__&lt;/code&gt;, which for me boils down to the former being readable even by an end user, and the latter being as useful as possible to developers. Given that, I find that the default implementation of &lt;code&gt;__repr__&lt;/code&gt; often fails to achieve this goal because it &lt;em&gt;omits&lt;/em&gt; information useful to developers.</source>
          <target state="translated">优秀的答案已经涵盖了 &lt;code&gt;__str__&lt;/code&gt; 和 &lt;code&gt;__repr__&lt;/code&gt; 之间的差异，对我而言 ，这可以归结为前者甚至可以被最终用户阅读，而后者对开发人员则尽可能有用。 鉴于此，我发现 &lt;code&gt;__repr__&lt;/code&gt; 的默认实现通常无法实现此目标，因为它&lt;em&gt;忽略了&lt;/em&gt;对开发人员有用的信息。</target>
        </trans-unit>
        <trans-unit id="c4a1dd8c15a07bca489be9628dc1f211ec440334" translate="yes" xml:space="preserve">
          <source>First, let me reiterate the main points in &lt;a href=&quot;https://stackoverflow.com/a/1436756/3798217&quot;&gt;Alex&amp;rsquo;s post&lt;/a&gt;:</source>
          <target state="translated">首先，让我重申&lt;a href=&quot;https://stackoverflow.com/a/1436756/3798217&quot;&gt;Alex帖子中的&lt;/a&gt;要点：</target>
        </trans-unit>
        <trans-unit id="5e3c852250fcf645e78568a651ad7742888eb8a2" translate="yes" xml:space="preserve">
          <source>For this reason, if I have a simple enough &lt;code&gt;__str__&lt;/code&gt;, I generally just try to get the best of both worlds with something like:</source>
          <target state="translated">出于这个原因，如果我有足够简单的 &lt;code&gt;__str__&lt;/code&gt; ，我通常会尝试通过以下方式使两个方面都达到最佳：</target>
        </trans-unit>
        <trans-unit id="d8b2bba95481c8588d12d05e331a3236798bb686" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://web.archive.org/web/20071127054034/http://pyref.infogami.com/__str__&quot;&gt;an (An Unofficial) Python Reference Wiki (archive copy)&lt;/a&gt; by effbot:</source>
          <target state="translated">来自effbot &lt;a href=&quot;https://web.archive.org/web/20071127054034/http://pyref.infogami.com/__str__&quot;&gt;的（非官方）Python参考Wiki（归档副本）&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="68f24431a884f7a1a772f9f71c64bbfc2b1cd09e" translate="yes" xml:space="preserve">
          <source>From the book &lt;em&gt;Fluent Python&lt;/em&gt;:</source>
          <target state="translated">摘自&lt;em&gt;Fluent Python&lt;/em&gt;一书：</target>
        </trans-unit>
        <trans-unit id="af15b0cba5831475a6213180b44b72662c5c0098" translate="yes" xml:space="preserve">
          <source>Goal of &lt;code&gt;__repr__&lt;/code&gt;: unambiguous, possibly machine-readable via &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__repr__&lt;/code&gt; 的目标：明确，可能通过 &lt;code&gt;eval&lt;/code&gt; 机器可读</target>
        </trans-unit>
        <trans-unit id="0105a7007fd970dd8263d8d0ae6f24d9c2892859" translate="yes" xml:space="preserve">
          <source>Goal of &lt;code&gt;__str__&lt;/code&gt;: human-readable</source>
          <target state="translated">&lt;code&gt;__str__&lt;/code&gt; 的目标： 易于理解</target>
        </trans-unit>
        <trans-unit id="e0704423e912c87444daf4cf0591f6672b380ee4" translate="yes" xml:space="preserve">
          <source>Here is a good example:</source>
          <target state="translated">这里有一个很好的例子。</target>
        </trans-unit>
        <trans-unit id="b8278191aeedfa8063b69965a5b1296db0545f8f" translate="yes" xml:space="preserve">
          <source>Here is the documentation for str:</source>
          <target state="translated">以下是str的文档。</target>
        </trans-unit>
        <trans-unit id="6a609178fdb8d21ef587ebbb9a3a93386555889b" translate="yes" xml:space="preserve">
          <source>Here's the builtin help on &lt;code&gt;repr&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;repr&lt;/code&gt; 的内置帮助：</target>
        </trans-unit>
        <trans-unit id="0fc3e81e03b099edcb9f91f49f2a17d2385c23c4" translate="yes" xml:space="preserve">
          <source>Hope this help you build concrete grounds to explore more answers.</source>
          <target state="translated">希望这对你有帮助,建立具体的理由,探索更多的答案。</target>
        </trans-unit>
        <trans-unit id="43c6e54c0ea380985172fb9258afb936529b9683" translate="yes" xml:space="preserve">
          <source>How can &lt;code&gt;__repr__&lt;/code&gt; be useful?</source>
          <target state="translated">&lt;code&gt;__repr__&lt;/code&gt; 怎么有用？</target>
        </trans-unit>
        <trans-unit id="d13e0fa96adfcce8fde14c989cb30f63091e1e29" translate="yes" xml:space="preserve">
          <source>How do I implement them?</source>
          <target state="translated">如何实施?</target>
        </trans-unit>
        <trans-unit id="04b4dc21ec648f5aec0e86365a2e5648ee7f2c14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__repr__&lt;/code&gt; function is returning String representation of the object, we can skip implementation of &lt;code&gt;__str__&lt;/code&gt; function.</source>
          <target state="translated">如果 &lt;code&gt;__repr__&lt;/code&gt; 函数返回对象的字符串表示形式，则可以跳过 &lt;code&gt;__str__&lt;/code&gt; 函数的实现。</target>
        </trans-unit>
        <trans-unit id="ef49c726f39f583e5b3279b1fb0572c8420ec9ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__str__&lt;/code&gt; implementation is missing then &lt;code&gt;__repr__&lt;/code&gt; function is used as fallback. There is no fallback if &lt;code&gt;__repr__&lt;/code&gt; function implementation is missing.</source>
          <target state="translated">如果缺少 &lt;code&gt;__str__&lt;/code&gt; 实现，则将 &lt;code&gt;__repr__&lt;/code&gt; 函数用作后备。 如果缺少 &lt;code&gt;__repr__&lt;/code&gt; 函数实现，则没有回退。</target>
        </trans-unit>
        <trans-unit id="eaeb3628e2001cf7b36aab29fab6dd6a73818457" translate="yes" xml:space="preserve">
          <source>If we call &lt;code&gt;datetime.now&lt;/code&gt; in the shell, we'll see everything we need to recreate an equivalent datetime object. This is created by the datetime &lt;code&gt;__repr__&lt;/code&gt;:</source>
          <target state="translated">如果在外壳程序中调用 &lt;code&gt;datetime.now&lt;/code&gt; ，我们将看到重新创建等效的datetime对象所需的一切。 这是由datetime &lt;code&gt;__repr__&lt;/code&gt; 创建的：</target>
        </trans-unit>
        <trans-unit id="60df7928f256d4c1c316638019355408b8d03315" translate="yes" xml:space="preserve">
          <source>If we print a datetime object, we see a nice human readable (in fact, ISO) format. This is implemented by datetime's &lt;code&gt;__str__&lt;/code&gt;:</source>
          <target state="translated">如果我们打印日期时间对象，则会看到一种很好的人类可读（实际上是ISO）格式。 这是通过datetime的 &lt;code&gt;__str__&lt;/code&gt; 实现的：</target>
        </trans-unit>
        <trans-unit id="fe3e77348f584666cc0292c5252ffc936156bae2" translate="yes" xml:space="preserve">
          <source>If you print an object, or pass it to &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;str.format&lt;/code&gt;, or &lt;code&gt;str&lt;/code&gt;, then if a &lt;code&gt;__str__&lt;/code&gt; method is defined, that method will be called, otherwise, &lt;code&gt;__repr__&lt;/code&gt; will be used.</source>
          <target state="translated">如果打印对象，或将其传递给 &lt;code&gt;format&lt;/code&gt; ， &lt;code&gt;str.format&lt;/code&gt; 或 &lt;code&gt;str&lt;/code&gt; ，则如果定义了 &lt;code&gt;__str__&lt;/code&gt; 方法，则将调用该方法，否则将使用 &lt;code&gt;__repr__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="805626cceba2f927b93f675018fe4b6001406454" translate="yes" xml:space="preserve">
          <source>If you want your object to have a more human readable representation, you can implement &lt;code&gt;__str__&lt;/code&gt; next. Here's how the datetime object (&lt;a href=&quot;https://github.com/python/cpython/blob/v3.7.3/Lib/datetime.py#L1895&quot;&gt;Python source&lt;/a&gt;) implements &lt;code&gt;__str__&lt;/code&gt;, which it easily does because it already has a function to display it in ISO format:</source>
          <target state="translated">如果希望对象具有更易 &lt;code&gt;__str__&lt;/code&gt; 表示形式，则可以下一步实现__str__ 。 datetime对象（ &lt;a href=&quot;https://github.com/python/cpython/blob/v3.7.3/Lib/datetime.py#L1895&quot;&gt;Python源&lt;/a&gt; ）实现 &lt;code&gt;__str__&lt;/code&gt; 的方法很容易，因为它已经具有以ISO格式显示它的功能：</target>
        </trans-unit>
        <trans-unit id="073430142b98e2a3a71e88d7faacd82c17a8334f" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;__repr__&lt;/code&gt; for any class you implement. This should be second nature. Implement &lt;code&gt;__str__&lt;/code&gt; if you think it would be useful to have a string version which errs on the side of readability.</source>
          <target state="translated">为您实现的任何类实现 &lt;code&gt;__repr__&lt;/code&gt; 。 这应该是第二天性。 如果您认为有一个字符串版本会影响可读性会很有用，请实施 &lt;code&gt;__str__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7d488b9cb5355ef57328f1752264bf34aca81b8" translate="yes" xml:space="preserve">
          <source>In a nutshell:</source>
          <target state="translated">一言以蔽之。</target>
        </trans-unit>
        <trans-unit id="f632be7662be43e79ba5419e904ac5f988c7adb9" translate="yes" xml:space="preserve">
          <source>In all honesty, &lt;code&gt;eval(repr(obj))&lt;/code&gt; is never used. If you find yourself using it, you should stop, because &lt;code&gt;eval&lt;/code&gt; is dangerous, and strings are a very inefficient way to serialize your objects (use &lt;code&gt;pickle&lt;/code&gt; instead).</source>
          <target state="translated">&lt;code&gt;eval(repr(obj))&lt;/code&gt; 从未使用过eval（repr（obj）） 。 如果发现自己正在使用它，则应该停止操作，因为 &lt;code&gt;eval&lt;/code&gt; 很危险，而字符串是序列化对象的一种非常低效的方式（请改用 &lt;code&gt;pickle&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="292e4e3ccb8e900f7e45bea52808de8bb334eee9" translate="yes" xml:space="preserve">
          <source>In short, the goal of &lt;code&gt;__repr__&lt;/code&gt; is to be unambiguous and &lt;code&gt;__str__&lt;/code&gt; is to be
  readable.</source>
          <target state="translated">简而言之， &lt;code&gt;__repr__&lt;/code&gt; 的目标是明确的，并且 &lt;code&gt;__str__&lt;/code&gt; 是可读的。</target>
        </trans-unit>
        <trans-unit id="6c8531c2d32b10443b839413379f6984d3ce1679" translate="yes" xml:space="preserve">
          <source>It is a simple matter to recreate the object we lost because we didn't assign it to a variable by copying and pasting from the &lt;code&gt;__repr__&lt;/code&gt; output, and then printing it, and we get it in the same human readable output as the other object:</source>
          <target state="translated">重建丢失的对象很简单，因为我们没有通过复制和粘贴 &lt;code&gt;__repr__&lt;/code&gt; 输出，然后打印它来将其分配给变量，然后将其打印出来，并且将其与其他对象存储在相同的可读输出中：</target>
        </trans-unit>
        <trans-unit id="6b8e2060bed2c0d2f56ab93a4f32e7f1ef3c311b" translate="yes" xml:space="preserve">
          <source>Let me come right out and say it &amp;mdash; I do not believe in debuggers. I don&amp;rsquo;t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature &amp;mdash; most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a</source>
          <target state="translated">我马上说出来-我不相信调试器。 我真的不知道如何使用任何调试器，也从未认真使用过。 此外，我相信调试器的最大缺陷是它们的基本特性-我调试的大多数故障是很久以前发生的，它位于一个遥远的星系中。 这意味着我确实以宗教的热情相信伐木。 日志记录是任何体面的&amp;ldquo;一劳永逸&amp;rdquo;服务器系统的命脉。 使用Python可以轻松记录日志：也许有一些特定于项目的包装器，您只需要一个</target>
        </trans-unit>
        <trans-unit id="6c16523da5289e715510cd8ddc824ce517fad569" translate="yes" xml:space="preserve">
          <source>Let's look at how useful it can be, using the Python shell and &lt;code&gt;datetime&lt;/code&gt; objects. First we need to import the &lt;code&gt;datetime&lt;/code&gt; module:</source>
          <target state="translated">让我们看看使用Python shell和 &lt;code&gt;datetime&lt;/code&gt; 对象有多么有用。 首先，我们需要导入 &lt;code&gt;datetime&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="f5512e6b973186ee3d6e68271fdb6743c05107de" translate="yes" xml:space="preserve">
          <source>Let's say I want to create a &lt;code&gt;Fraction&lt;/code&gt; class where the string representation of a fraction is '(1/2)' and the object (Fraction class) is to be represented as 'Fraction (1,2)'</source>
          <target state="translated">假设我要创建一个 &lt;code&gt;Fraction&lt;/code&gt; 类，其中分数的字符串表示形式为&amp;ldquo;（1/2）&amp;rdquo;，而对象（分数类）将表示为&amp;ldquo;分数（1,2）&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0e9c67e09191353606a84fab248a3ac997049f12" translate="yes" xml:space="preserve">
          <source>My rule of thumb:  &lt;code&gt;__repr__&lt;/code&gt; is for developers, &lt;code&gt;__str__&lt;/code&gt; is for customers.</source>
          <target state="translated">我的经验法则： &lt;code&gt;__repr__&lt;/code&gt; 适用于开发人员， &lt;code&gt;__str__&lt;/code&gt; 适用于客户。</target>
        </trans-unit>
        <trans-unit id="7f94091f9bf63a214597fc0363dfb00129777f2a" translate="yes" xml:space="preserve">
          <source>Not very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you&amp;rsquo;re printing a list, just</source>
          <target state="translated">不是特别的。 具体而言，容器中的字符串会发现太容易打乱其字符串表示形式。 记住，面对歧义，Python抵制了猜测的诱惑。 如果您在打印列表时需要上述行为，则只需</target>
        </trans-unit>
        <trans-unit id="fd5f9deaf020d8b6861722b040fb7e4f5080e355" translate="yes" xml:space="preserve">
          <source>Note: I used &lt;code&gt;%r&lt;/code&gt; above, not &lt;code&gt;%s&lt;/code&gt;. You always want to use &lt;code&gt;repr()&lt;/code&gt; [or &lt;code&gt;%r&lt;/code&gt; formatting character, equivalently] inside &lt;code&gt;__repr__&lt;/code&gt; implementation, or you&amp;rsquo;re defeating the goal of repr. You want to be able to differentiate &lt;code&gt;MyClass(3)&lt;/code&gt; and &lt;code&gt;MyClass(&quot;3&quot;)&lt;/code&gt;.</source>
          <target state="translated">注意：我在上面使用 &lt;code&gt;%r&lt;/code&gt; ，而不是 &lt;code&gt;%s&lt;/code&gt; 。 您总是想在 &lt;code&gt;__repr__&lt;/code&gt; 实现中使用 &lt;code&gt;repr()&lt;/code&gt; [或等效地为 &lt;code&gt;%r&lt;/code&gt; 格式字符]，否则您将无法达到repr的目标。 您希望能够区分 &lt;code&gt;MyClass(3)&lt;/code&gt; 和 &lt;code&gt;MyClass(&quot;3&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6e8a0912dda5254ca8b3e57cb69ed14130cdaaa" translate="yes" xml:space="preserve">
          <source>On page 358 of the book &lt;strong&gt;&lt;em&gt;Python scripting for computational science&lt;/em&gt;&lt;/strong&gt; by Hans Petter Langtangen, it clearly states that</source>
          <target state="translated">在Hans Petter Langtangen &lt;strong&gt;&lt;em&gt;撰写的《用于计算科学&lt;/em&gt;&lt;/strong&gt;的&lt;strong&gt;&lt;em&gt;Python脚本&lt;/em&gt;&lt;/strong&gt; 》一书的第358页中，明确指出：</target>
        </trans-unit>
        <trans-unit id="f09747914187d47d66fb2f95e301adcb194fd8a5" translate="yes" xml:space="preserve">
          <source>One aspect that is missing in other answers. It's true that in general the pattern is:</source>
          <target state="translated">有一个方面,是其他答案中所欠缺的。一般情况下,模式确实是这样的。</target>
        </trans-unit>
        <trans-unit id="c7287b52c2d22c06ad4a63d14f2310d541b138bf" translate="yes" xml:space="preserve">
          <source>One important thing to keep in mind is that container's &lt;code&gt;__str__&lt;/code&gt; uses contained objects' &lt;code&gt;__repr__&lt;/code&gt;.</source>
          <target state="translated">要记住的重要一件事是容器的 &lt;code&gt;__str__&lt;/code&gt; 使用包含对象的 &lt;code&gt;__repr__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43b2e3cacce0653ce3967339fc290266006b6ec3" translate="yes" xml:space="preserve">
          <source>Other crucial tidbits to know: &lt;code&gt;__str__&lt;/code&gt; on a built-on container uses the &lt;code&gt;__repr__&lt;/code&gt;, NOT the &lt;code&gt;__str__&lt;/code&gt;, for the items it contains. And, despite the words on the subject found in typical docs, hardly anybody bothers making the &lt;code&gt;__repr__&lt;/code&gt; of objects be a string that &lt;code&gt;eval&lt;/code&gt; may use to build an equal object (it's just too hard, AND not knowing how the relevant module was actually imported makes it actually flat out impossible).</source>
          <target state="translated">要知道的其他关键 &lt;code&gt;__str__&lt;/code&gt; ：内置容器上的 &lt;code&gt;__repr__&lt;/code&gt; 使用__repr__而不是 &lt;code&gt;__str__&lt;/code&gt; 来包含其中的项目。 而且，尽管在典型文档中找到了有关主题的字眼，但几乎没有 &lt;code&gt;__repr__&lt;/code&gt; 使对象的__repr__成为 &lt;code&gt;eval&lt;/code&gt; 可以用来构建相等对象的字符串而烦恼 （这太难了，并且不知道相关模块实际上是如何导入的，实际上完全不可能）。</target>
        </trans-unit>
        <trans-unit id="bd2862cf0464e07a303cac55a775c88696076e0b" translate="yes" xml:space="preserve">
          <source>Read this documentation for repr:</source>
          <target state="translated">请阅读本文档以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="ce32a625388e3e4b97a5e1992ffdb3d71282f194" translate="yes" xml:space="preserve">
          <source>Return a string containing a nicely printable
  representation of an object. For strings, this returns the string
  itself. The difference with &lt;code&gt;repr(object)&lt;/code&gt; is that &lt;code&gt;str(object)&lt;/code&gt; does not
  always attempt to return a string that is acceptable to &lt;code&gt;eval()&lt;/code&gt;; its
  goal is to return a printable string. If no argument is given, returns
  the empty string, &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">返回一个字符串，其中包含对象的漂亮可打印表示形式。 对于字符串，这将返回字符串本身。 与 &lt;code&gt;repr(object)&lt;/code&gt; 的区别在于 &lt;code&gt;str(object)&lt;/code&gt; 并不总是尝试返回 &lt;code&gt;eval()&lt;/code&gt; 可接受的字符串； 它的目标是返回可打印的字符串。 如果未提供任何参数，则返回空字符串 &lt;code&gt;''&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2458a576572440d423de195dfad3208ee454921" translate="yes" xml:space="preserve">
          <source>Return a string containing a printable representation of an object. This is the same value yielded by conversions (reverse
  quotes). It is sometimes useful to be able to access this operation as
  an ordinary function. For many types, this function makes an attempt
  to return a string that would yield an object with the same value when
  passed to &lt;code&gt;eval()&lt;/code&gt;, otherwise the representation is a string enclosed in
  angle brackets that contains the name of the type of the object
  together with additional information often including the name and
  address of the object. A class can control what this function returns
  for its instances by defining a &lt;code&gt;__repr__()&lt;/code&gt; method.</source>
          <target state="translated">返回包含对象的可打印表示形式的字符串。 这与转化产生的值相同（反引号）。 能够以普通功能访问此操作有时很有用。 对于许多类型，此函数会尝试返回一个字符串，该字符串将在传递给 &lt;code&gt;eval()&lt;/code&gt; 时产生一个具有相同值的对象，否则表示形式是一个用尖括号括起来的字符串，其中包含该对象的类型名称附加信息通常包括对象的名称和地址。 类可以通过定义 &lt;code&gt;__repr__()&lt;/code&gt; 方法来控制此函数为其实例返回的内容 。</target>
        </trans-unit>
        <trans-unit id="3035c2da1436a67b6c4120172175da8e5d57def0" translate="yes" xml:space="preserve">
          <source>Returns nothing but error.</source>
          <target state="translated">除了错误,什么也不返回。</target>
        </trans-unit>
        <trans-unit id="b8270cef946d8069e43fdd480b8dcd6353712786" translate="yes" xml:space="preserve">
          <source>See it in an example</source>
          <target state="translated">在一个例子中可以看到</target>
        </trans-unit>
        <trans-unit id="0021e4289b6f8431d60ebd3598f12c0417e6cc77" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;__repr__ = __str__&lt;/code&gt;?</source>
          <target state="translated">设置 &lt;code&gt;__repr__ = __str__&lt;/code&gt; 吗？</target>
        </trans-unit>
        <trans-unit id="644756de68adbf936b72fd6b6c5cab6f7c43ee78" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;__repr__ = __str__&lt;/code&gt; is silly - &lt;code&gt;__repr__&lt;/code&gt; is a fallback for &lt;code&gt;__str__&lt;/code&gt; and a &lt;code&gt;__repr__&lt;/code&gt;, written for developers usage in debugging, should be written before you write a &lt;code&gt;__str__&lt;/code&gt;.</source>
          <target state="translated">设置 &lt;code&gt;__repr__ = __str__&lt;/code&gt; 是很愚蠢的 &lt;code&gt;__repr__&lt;/code&gt; 是__str__的后备，并且在编写 &lt;code&gt;__str__&lt;/code&gt; 之前应写一个供开发人员在调试中使用的__repr__ 。</target>
        </trans-unit>
        <trans-unit id="56f313c1fd657f2c4ef725602441c7bd15f8ce8d" translate="yes" xml:space="preserve">
          <source>Since it provides a backup for &lt;code&gt;__str__&lt;/code&gt;, if you can only write one, start with &lt;code&gt;__repr__&lt;/code&gt;</source>
          <target state="translated">由于它为 &lt;code&gt;__str__&lt;/code&gt; 提供了备份，如果只能写一个，请从 &lt;code&gt;__repr__&lt;/code&gt; 开始</target>
        </trans-unit>
        <trans-unit id="877b072c30445f6c706ce3a5afb6e8eb2eaa14f9" translate="yes" xml:space="preserve">
          <source>So one should first write a &lt;code&gt;__repr__&lt;/code&gt; that allows you to reinstantiate an equivalent object from the string it returns e.g. using &lt;code&gt;eval&lt;/code&gt; or by typing it in character-for-character in a Python shell.</source>
          <target state="translated">因此，应该首先编写一个 &lt;code&gt;__repr__&lt;/code&gt; ，它允许您从返回的字符串中重新实例化一个等效的对象，例如使用 &lt;code&gt;eval&lt;/code&gt; 或通过在Python shell中按字符输入字符。</target>
        </trans-unit>
        <trans-unit id="2498fecbd0f66d3d905b8b1ba674c8e645743a5c" translate="yes" xml:space="preserve">
          <source>So we can create a simple Fraction class:</source>
          <target state="translated">所以我们可以创建一个简单的分数类。</target>
        </trans-unit>
        <trans-unit id="fb2d4262f867454c0debc4ffffb1db8c8ed1958a" translate="yes" xml:space="preserve">
          <source>So, I prefer to understand them as</source>
          <target state="translated">所以,我更愿意把它们理解为</target>
        </trans-unit>
        <trans-unit id="9959e6a37cfa7f2a99846efe7b90651a3176e243" translate="yes" xml:space="preserve">
          <source>So, my advice: focus on making &lt;code&gt;__str__&lt;/code&gt; reasonably human-readable, and &lt;code&gt;__repr__&lt;/code&gt; as unambiguous as you possibly can, even if that interferes with the fuzzy unattainable goal of making &lt;code&gt;__repr__&lt;/code&gt;'s returned value acceptable as input to &lt;code&gt;__eval__&lt;/code&gt;!</source>
          <target state="translated">因此，我的建议是：着眼于使 &lt;code&gt;__str__&lt;/code&gt; 合理地为人类所理解 ，并 &lt;code&gt;__repr__&lt;/code&gt; 使__repr__模棱两可 ，即使这干扰了使 &lt;code&gt;__repr__&lt;/code&gt; 的返回值可以接受作为 &lt;code&gt;__eval__&lt;/code&gt; 的输入的模糊无法实现的目标！</target>
        </trans-unit>
        <trans-unit id="a56e63eaa5cc8becd3c7a2fe2d48751e646af5e3" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://www.journaldev.com/22460/python-str-repr-functions&quot;&gt;https://www.journaldev.com/22460/python-str-repr-functions&lt;/a&gt;</source>
          <target state="translated">资料来源： &lt;a href=&quot;https://www.journaldev.com/22460/python-str-repr-functions&quot;&gt;https&lt;/a&gt; : //www.journaldev.com/22460/python-str-repr-functions</target>
        </trans-unit>
        <trans-unit id="77e9d650548e453d78784a686ed816f82f0a086a" translate="yes" xml:space="preserve">
          <source>Specifically, it is not intended to be unambiguous &amp;mdash; notice that &lt;code&gt;str(3)==str(&quot;3&quot;)&lt;/code&gt;. Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date/time abstraction, the str can be &quot;2010/4/12 15:35:22&quot;, etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class &amp;mdash; as long is it supports readability, it is an improvement.</source>
          <target state="translated">具体来说，这并非旨在明确-请注意 &lt;code&gt;str(3)==str(&quot;3&quot;)&lt;/code&gt; 。 同样，如果实现IP抽象，则让其str看起来像192.168.1.1很好。 在实现日期/时间抽象时，str可以是&amp;ldquo; 2010/4/12 15:35:22&amp;rdquo;，等等。目标是以用户（而不是程序员）希望阅读的方式表示它。 砍掉无用的数字，冒充其他类别-只要它支持可读性，它就是一种进步。</target>
        </trans-unit>
        <trans-unit id="9a9ecf8f5d08776b3b2d8df998d3987bdc39a73d" translate="yes" xml:space="preserve">
          <source>That is, for most objects, if you type in what is printed by &lt;code&gt;repr&lt;/code&gt;, you should be able to create an equivalent object. &lt;em&gt;But this is not the default implementation.&lt;/em&gt;</source>
          <target state="translated">也就是说，对于大多数对象，如果键入 &lt;code&gt;repr&lt;/code&gt; 打印的内容，则应该能够创建等效对象。 &lt;em&gt;但这不是默认的实现。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b4dbc589e1fe42f258f8c10b02cabf8cbb7dfc5" translate="yes" xml:space="preserve">
          <source>That means by default you'll print the module the object is from, the class name, and the hexadecimal representation of its location in memory - for example:</source>
          <target state="translated">这意味着默认情况下,你会打印出对象的模块,类名,以及它在内存中的位置的十六进制表示--例如。</target>
        </trans-unit>
        <trans-unit id="29e212700ab6021fa4ca48619a674b68b76e1376" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__repr__&lt;/code&gt; aims at a complete string representation of the object;</source>
          <target state="translated">&lt;code&gt;__repr__&lt;/code&gt; 旨在对象的完整字符串表示形式；</target>
        </trans-unit>
        <trans-unit id="bb716d12482cdc344c24a75b7af653b25739bbfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__repr__&lt;/code&gt; method is called by the builtin function &lt;code&gt;repr&lt;/code&gt; and is what is echoed on your python shell when it evaluates an expression that returns an object.</source>
          <target state="translated">&lt;code&gt;__repr__&lt;/code&gt; 方法由内置函数 &lt;code&gt;repr&lt;/code&gt; 调用，并且在python shell评估返回对象的表达式时在python shell上回显。</target>
        </trans-unit>
        <trans-unit id="6571b1c17c83bfab38282b2f6a794fa3308f64bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__str__&lt;/code&gt; is to return a nice string for printing.</source>
          <target state="translated">&lt;code&gt;__str__&lt;/code&gt; 返回一个漂亮的字符串进行打印。</target>
        </trans-unit>
        <trans-unit id="ecbc7a93e0d86ff638ad9d89dbe3b826db5b1d3d" translate="yes" xml:space="preserve">
          <source>The default implementation is useless (it&amp;rsquo;s hard to think of one which wouldn&amp;rsquo;t be, but yeah)</source>
          <target state="translated">默认的实现是无用的（很难想到不会的，但是是的）</target>
        </trans-unit>
        <trans-unit id="af957f3a06259040cf9a2014cff25a442327a067" translate="yes" xml:space="preserve">
          <source>The default object &lt;code&gt;__repr__&lt;/code&gt; is (&lt;a href=&quot;https://github.com/python/cpython/blob/v3.7.3/Objects/object.c#L496&quot;&gt;C Python source&lt;/a&gt;) something like:</source>
          <target state="translated">默认对象 &lt;code&gt;__repr__&lt;/code&gt; 是（ &lt;a href=&quot;https://github.com/python/cpython/blob/v3.7.3/Objects/object.c#L496&quot;&gt;C Python源代码&lt;/a&gt; ）类似：</target>
        </trans-unit>
        <trans-unit id="6b121b39fc748ed516c66693a33cd8bd64b94d71" translate="yes" xml:space="preserve">
          <source>The differences:</source>
          <target state="translated">的区别。</target>
        </trans-unit>
        <trans-unit id="44f0edbd69c35ab3950af893859b5abe2da44d9a" translate="yes" xml:space="preserve">
          <source>Therefore, I would recommend setting &lt;code&gt;__repr__ = __str__&lt;/code&gt;. The reason is that &lt;code&gt;str(list)&lt;/code&gt; calls &lt;code&gt;repr&lt;/code&gt; on the elements (I consider this to be one of the biggest design flaws of Python that was not addressed by Python 3). An actual &lt;code&gt;repr&lt;/code&gt; will probably not be very helpful as the output of &lt;code&gt;print [your, objects]&lt;/code&gt;.</source>
          <target state="translated">因此，我建议设置 &lt;code&gt;__repr__ = __str__&lt;/code&gt; 。 原因是 &lt;code&gt;str(list)&lt;/code&gt; 对元素调用 &lt;code&gt;repr&lt;/code&gt; （我认为这是Python 3未能解决的Python最大的设计缺陷之一）。 实际的 &lt;code&gt;repr&lt;/code&gt; 可能不会作为 &lt;code&gt;print [your, objects]&lt;/code&gt; 的输出很有用。</target>
        </trans-unit>
        <trans-unit id="6ea0102b1ade3a32471b836651590fb17bbb31a8" translate="yes" xml:space="preserve">
          <source>This example may help:</source>
          <target state="translated">这个例子可能有帮助。</target>
        </trans-unit>
        <trans-unit id="49339628670c6a3832e3bdbcaeca84f8623045b6" translate="yes" xml:space="preserve">
          <source>This information isn't very useful, but there's no way to derive how one might accurately create a canonical representation of any given instance, and it's better than nothing, at least telling us how we might uniquely identify it in memory.</source>
          <target state="translated">这些信息并不是很有用,但没有办法推导出一个人可能会如何准确地创造出任何给定实例的正统表示,总比没有好,至少告诉我们如何在记忆中唯一地识别它。</target>
        </trans-unit>
        <trans-unit id="b9b41556bd7fa50eaa70e88b983e740b35a9b000" translate="yes" xml:space="preserve">
          <source>This is a critique of another answer here that suggests setting &lt;code&gt;__repr__ = __str__&lt;/code&gt;.</source>
          <target state="translated">这是对此处建议设置 &lt;code&gt;__repr__ = __str__&lt;/code&gt; 的另一个答案的批评。</target>
        </trans-unit>
        <trans-unit id="a2fd6fdc3ad7fb96e0d7fc2971066e31ecfbeeae" translate="yes" xml:space="preserve">
          <source>This is mostly a surprise because Python&amp;rsquo;s defaults tend to be fairly useful. However, in this case, having a default for &lt;code&gt;__repr__&lt;/code&gt; which would act like:</source>
          <target state="translated">这主要是令人惊讶的，因为Python的默认设置往往相当有用。 但是，在这种情况下， &lt;code&gt;__repr__&lt;/code&gt; 的默认设置将像这样：</target>
        </trans-unit>
        <trans-unit id="67cd48518a2a8df13e502456c444a68d3cfdbbf9" translate="yes" xml:space="preserve">
          <source>This means, in simple terms: almost every object you implement should have a functional &lt;code&gt;__repr__&lt;/code&gt; that&amp;rsquo;s usable for understanding the object. Implementing &lt;code&gt;__str__&lt;/code&gt; is optional: do that if you need a &amp;ldquo;pretty print&amp;rdquo; functionality (for example, used by a report generator).</source>
          <target state="translated">简单来说，这意味着：您实现的几乎每个对象都应具有可用于理解该对象的功能 &lt;code&gt;__repr__&lt;/code&gt; 。 &lt;code&gt;__str__&lt;/code&gt; 的实现是可选的：如果您需要&amp;ldquo;漂亮的打印&amp;rdquo;功能（例如，报表生成器使用），请执行此操作。</target>
        </trans-unit>
        <trans-unit id="42085e7e4d2aee0832344073213dbd133d70c2a0" translate="yes" xml:space="preserve">
          <source>This seems surprising, doesn&amp;rsquo;t it? It is a little, but how readable would it be if it used their &lt;code&gt;__str__&lt;/code&gt;?</source>
          <target state="translated">这似乎令人惊讶，不是吗？ 它有点，但是如果使用他们的 &lt;code&gt;__str__&lt;/code&gt; ,它将具有多大的可读性？</target>
        </trans-unit>
        <trans-unit id="a26f3ae40c34f7b11fe02427fe4fd04cac5639d4" translate="yes" xml:space="preserve">
          <source>To put it simply:</source>
          <target state="translated">简而言之。</target>
        </trans-unit>
        <trans-unit id="8378907aa75c6caee84a72343bf30d33e3a7b53b" translate="yes" xml:space="preserve">
          <source>To qualify this, in my experience, the most useful use case of the &lt;code&gt;repr&lt;/code&gt; function is to put a string inside another string (using string formatting). This way, you don't have to worry about escaping quotes or anything. But note that there is no &lt;code&gt;eval&lt;/code&gt; happening here.</source>
          <target state="translated">为了证明这一点，以我的经验， &lt;code&gt;repr&lt;/code&gt; 函数最有用的用例是将一个字符串放入另一个字符串中（使用字符串格式）。 这样，您不必担心转义引号或其他任何内容。 但是请注意，这里没有 &lt;code&gt;eval&lt;/code&gt; 发生。</target>
        </trans-unit>
        <trans-unit id="6f1a00ebb57a83f5f0b7867da20932536b2febbd" translate="yes" xml:space="preserve">
          <source>Understand &lt;code&gt;__str__&lt;/code&gt; and &lt;code&gt;__repr__&lt;/code&gt; intuitively and permanently distinguish them at all.</source>
          <target state="translated">直观地理解 &lt;code&gt;__str__&lt;/code&gt; 和 &lt;code&gt;__repr__&lt;/code&gt; 并将它们永久区分开。</target>
        </trans-unit>
        <trans-unit id="03a79c8a50c4a59545b4bfb6d58909546121fd13" translate="yes" xml:space="preserve">
          <source>Unfortunately, this differentiation is flawed, because the Python REPL and also IPython use &lt;code&gt;__repr__&lt;/code&gt; for printing objects in a REPL console (see related questions for &lt;a href=&quot;https://stackoverflow.com/questions/28304092/when-i-am-in-the-python-or-ipython-console-what-is-called-when-i-am-returned-an&quot;&gt;Python&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/41453624/tell-ipython-to-use-an-objects-str-instead-of-repr-for-output&quot;&gt;IPython&lt;/a&gt;). Thus, projects which are targeted for interactive console work (e.g., Numpy or Pandas) have started to ignore above rules and provide a human-readable &lt;code&gt;__repr__&lt;/code&gt; implementation instead.</source>
          <target state="translated">不幸的是，这种区别是有缺陷的，因为Python REPL和IPython都使用 &lt;code&gt;__repr__&lt;/code&gt; 在REPL控制台中打印对象（请参阅&lt;a href=&quot;https://stackoverflow.com/questions/28304092/when-i-am-in-the-python-or-ipython-console-what-is-called-when-i-am-returned-an&quot;&gt;Python&lt;/a&gt;和&lt;a href=&quot;https://stackoverflow.com/questions/41453624/tell-ipython-to-use-an-objects-str-instead-of-repr-for-output&quot;&gt;IPython的&lt;/a&gt;相关问题）。 因此，针对交互式控制台工作的项目（例如Numpy或Pandas）已经开始忽略上述规则，而是提供了易于 &lt;code&gt;__repr__&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="d425552c3ea6d5d498f843a30f17f4e97f960f37" translate="yes" xml:space="preserve">
          <source>Unless you specifically act to ensure otherwise, most classes don't have helpful results for either:</source>
          <target state="translated">除非你特别行动起来确保,否则大多数的班级对这两个都没有帮助的结果。</target>
        </trans-unit>
        <trans-unit id="8da03d1937c4a6f4140683d4255b1796a31a529c" translate="yes" xml:space="preserve">
          <source>We can do arithmetic operation on &lt;code&gt;__repr__&lt;/code&gt; results conveniently.</source>
          <target state="translated">我们可以方便地对 &lt;code&gt;__repr__&lt;/code&gt; 结果进行算术运算。</target>
        </trans-unit>
        <trans-unit id="4f85f4ba7750e93da922add9cea508b1a67639d0" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;__str__&lt;/code&gt; and &lt;code&gt;__repr__&lt;/code&gt; in Python?</source>
          <target state="translated">Python中 &lt;code&gt;__str__&lt;/code&gt; 和 &lt;code&gt;__repr__&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="c5101c72b933fdbfd13fbfd1e0e23863211f1a5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;print()&lt;/code&gt; is called on the result of &lt;code&gt;decimal.Decimal(23) / decimal.Decimal(&quot;1.05&quot;)&lt;/code&gt; the raw number is printed; this output is in &lt;strong&gt;string form&lt;/strong&gt; which can be achieved with &lt;code&gt;__str__()&lt;/code&gt;. If we simply enter the expression we get a &lt;code&gt;decimal.Decimal&lt;/code&gt; output &amp;mdash; this output is in &lt;strong&gt;representational form&lt;/strong&gt; which can be achieved with &lt;code&gt;__repr__()&lt;/code&gt;. All Python objects have two output forms. String form is designed to be human-readable. The representational form is designed to produce output that if fed to a Python interpreter would (when possible) reproduce the represented object.</source>
          <target state="translated">当对 &lt;code&gt;decimal.Decimal(23) / decimal.Decimal(&quot;1.05&quot;)&lt;/code&gt; 的结果调用 &lt;code&gt;print()&lt;/code&gt; 时，将打印原始数字； 此输出为&lt;strong&gt;字符串形式&lt;/strong&gt; ，可以使用 &lt;code&gt;__str__()&lt;/code&gt; 。 如果仅输入表达式，我们将得到一个 &lt;code&gt;decimal.Decimal&lt;/code&gt; 输出&amp;mdash;该输出采用&lt;strong&gt;表示形式&lt;/strong&gt; ，可以通过 &lt;code&gt;__repr__()&lt;/code&gt; 。 所有Python对象都有两种输出形式。 字符串形式被设计为易于阅读。 表示形式旨在产生输出，如果将其提供给Python解释器，则将（如果可能）再现所表示的对象。</target>
        </trans-unit>
        <trans-unit id="0f54f9c4d4034fe5f804a43aaeebd27a2f5995e3" translate="yes" xml:space="preserve">
          <source>You need a &lt;code&gt;__str__&lt;/code&gt; only when you need a textual representation of the object.</source>
          <target state="translated">仅当您需要对象的文本表示 &lt;code&gt;__str__&lt;/code&gt; 时才需要__str__ 。</target>
        </trans-unit>
        <trans-unit id="441f895c8ec78551715258a5a5e15e8d6f1eb05f" translate="yes" xml:space="preserve">
          <source>as you see, if you override &lt;code&gt;__repr__&lt;/code&gt;, that's ALSO used for &lt;code&gt;__str__&lt;/code&gt;, but not vice versa.</source>
          <target state="translated">如您所见，如果您覆盖 &lt;code&gt;__repr__&lt;/code&gt; ，那也将用于 &lt;code&gt;__str__&lt;/code&gt; ，反之亦然。</target>
        </trans-unit>
        <trans-unit id="7f53a68d324346fc8457a1665141697dcc97ee86" translate="yes" xml:space="preserve">
          <source>e.g.</source>
          <target state="translated">e.g.</target>
        </trans-unit>
        <trans-unit id="cda45dcc611254ff3003bdde139ca894ff86175f" translate="yes" xml:space="preserve">
          <source>from the user's point of view
although this is a misunderstanding I made when learning python.</source>
          <target state="translated">从用户的角度出发,虽然这是我在学习python时的一个误区。</target>
        </trans-unit>
        <trans-unit id="a093e3695065483806b6abbf8429d3c8e7d63e13" translate="yes" xml:space="preserve">
          <source>generates output for developer</source>
          <target state="translated">生成输出,供开发者使用</target>
        </trans-unit>
        <trans-unit id="2dc2c28c640022872f2c7552cb1fa62da2343b41" translate="yes" xml:space="preserve">
          <source>generates output for end-user</source>
          <target state="translated">为终端用户生成输出</target>
        </trans-unit>
        <trans-unit id="8855b3b6fcd8640700c4cf2c777aa5cc7b5fc8c1" translate="yes" xml:space="preserve">
          <source>if apply the operation on &lt;code&gt;__str__&lt;/code&gt;</source>
          <target state="translated">如果在 &lt;code&gt;__str__&lt;/code&gt; 上应用操作</target>
        </trans-unit>
        <trans-unit id="554a037b9e24b4770efca72ff88127f0f613f664" translate="yes" xml:space="preserve">
          <source>makes object readable</source>
          <target state="translated">可读性</target>
        </trans-unit>
        <trans-unit id="1030251168f82df0ed6176d6dfe47466406fc394" translate="yes" xml:space="preserve">
          <source>needs code that reproduces object</source>
          <target state="translated">需要重现对象的代码</target>
        </trans-unit>
        <trans-unit id="ed33972dc101924f80759b318ee2e02762394857" translate="yes" xml:space="preserve">
          <source>special methods &lt;code&gt;__repr__&lt;/code&gt; and &lt;code&gt;__str__&lt;/code&gt; exist in the data model.</source>
          <target state="translated">数据模型中存在特殊的方法 &lt;code&gt;__repr__&lt;/code&gt; 和 &lt;code&gt;__str__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="513cad09fa5d2989c48873b47d2411bf423f3483" translate="yes" xml:space="preserve">
          <source>would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if &lt;code&gt;__repr__&lt;/code&gt; is defined, and &lt;code&gt;__str__&lt;/code&gt; is not, the object will behave as though &lt;code&gt;__str__=__repr__&lt;/code&gt;.</source>
          <target state="translated">太危险了（例如，如果对象之间互相引用，则很容易陷入无限递归）。 因此，Python应对了。 请注意，有一个默认值为true：如果定义了 &lt;code&gt;__repr__&lt;/code&gt; ，而没有定义 &lt;code&gt;__str__&lt;/code&gt; ，则该对象的行为就像 &lt;code&gt;__str__=__repr__&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
