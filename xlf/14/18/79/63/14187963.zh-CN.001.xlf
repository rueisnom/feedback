<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/14187963">
    <body>
      <group id="14187963">
        <trans-unit id="abb6b4a544de50fb9bdc621b8b51a82d205e07c3" translate="yes" xml:space="preserve">
          <source>// set up the variable used for the instance of the main class</source>
          <target state="translated">/设置主类实例的变量,用于主类的实例</target>
        </trans-unit>
        <trans-unit id="e99f381ecf5a4f54dbd6192e3c9cbf4238c7dc10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newStage&lt;/code&gt; would be the new window. The problem is, I can't find a way to tell the controller where to look for the customer's info (by passing the id as parameter).</source>
          <target state="translated">&lt;code&gt;newStage&lt;/code&gt; 将是新窗口。 问题是，我找不到告诉控制器在哪里寻找客户信息的方法（通过将id作为参数传递）。</target>
        </trans-unit>
        <trans-unit id="cb5c34da153ae0147f32e5bc4d4c0c025d7a01aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;All files are listed in their entirety at the bottom of this post.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;所有文件均在此文章底部完整列出。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d19ee85e645013f2e6b5feb33ff2693ff70682e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Be careful NOT to use a static load function on the FXMLLoader, or you will not be able to get your controller from your loader instance.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意不要在FXMLLoader上使用静态加载函数，否则您将无法从加载程序实例中获取控制器。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3116d5258a5f9edea3c5a736e4390fd2fe59e466" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example for Spring Boot Dependency Injection&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Spring Boot依赖注入示例&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="74003107815f915a4cbe8fedd255db49b4dd35fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To set a controller on a loader (in JavaFX 2.x) you CANNOT also define a &lt;code&gt;fx:controller&lt;/code&gt; attribute in your fxml file.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;要在加载程序（在JavaFX 2.x中）上设置控制器，您也不能在fxml文件中定义 &lt;code&gt;fx:controller&lt;/code&gt; 属性。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="33bb599a4d9b3474e81c6ed136ffc6985664020e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Additional information supplied by StackOverflow user named &lt;a href=&quot;https://stackoverflow.com/users/1281217/bgmf&quot;&gt;@dzim&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;由StackOverflow用户&lt;a href=&quot;https://stackoverflow.com/users/1281217/bgmf&quot;&gt;@dzim&lt;/a&gt;提供的其他信息&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4fd9b1d0cef2b96ea8756f754cfda3df07303ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controller1.java:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Controller1.java:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="706060d063fd03f3ebcadfc4516d733aa40e2400" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controller1.java&lt;/strong&gt; - The controller for the first FXML layout.</source>
          <target state="translated">&lt;strong&gt;Controller1.java-&lt;/strong&gt;第一个FXML布局的控制器。</target>
        </trans-unit>
        <trans-unit id="a006dc4fa708bd933c7fe6fb94bd24a686b17f66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controller2.java:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Controller2.java:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad314d8b25f378a2fd5082b515d2bc0342fa369f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controller2.java&lt;/strong&gt; - The controller for the second FXML layout.</source>
          <target state="translated">&lt;strong&gt;Controller2.java-&lt;/strong&gt;第二个FXML布局的控制器。</target>
        </trans-unit>
        <trans-unit id="0b53f3af53d5ef2121636a2def3bc2e2451b965e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Follow-up Q&amp;amp;A&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;后续问答&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1dd65275cc31621283ddd43beeb8ed910906282a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Having the Controller Retrieve Parameters from an External Static Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;让控制器从外部静态方法检索参数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55d48d5a78ee7a1d081b3d7be28651cc57547a0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Layout1.fxml:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Layout1.fxml:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b2b3f469d405274016f600d777affb20d598614" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Layout1.fxml&lt;/strong&gt; - The FXML layout for the first scene.</source>
          <target state="translated">&lt;strong&gt;Layout1.fxml-&lt;/strong&gt;第一个场景的FXML布局。</target>
        </trans-unit>
        <trans-unit id="a7a323d9193e2d0fe847422dc0a6e84178e3c637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Layout2.fxml:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Layout2.fxml:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03c7533bc42ff9e8a98d5f08f566ce0586dacef9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Layout2.fxml&lt;/strong&gt; - The FXML layout for the second scene.</source>
          <target state="translated">&lt;strong&gt;Layout2.fxml-&lt;/strong&gt;第二个场景的FXML布局。</target>
        </trans-unit>
        <trans-unit id="9c3c79da97c928fef80b3521532f1e13afa52851" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Main.java:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Main.java:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57a371781447c4770a54384026c3775eca579201" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Main.java&lt;/strong&gt; - Simply used to start the application and call the first controller.</source>
          <target state="translated">&lt;strong&gt;Main.java-仅&lt;/strong&gt;用于启动应用程序并调用第一个控制器。</target>
        </trans-unit>
        <trans-unit id="e11a488151b7395c55e0d3c12c87f94afaa380d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Parameters Directly From the Caller to the Controller&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;直接从调用者向控制器传递参数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a9f0c31bf24b09da6c9598ec9c76a164314487f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recommended Approach&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;推荐方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c03de514f34813514a6852828a3ee6c4b50625e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remember first time you print the passing value you will get null,
You can use it after your windows loaded , same for everything you want to code for any other component.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;请记住，第一次打印传递的值时，您将获得null，您可以在Windows加载后使用它，对于要为任何其他组件编码的所有内容都可以使用它。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4162b0ad6ae79cf21c04d31cfdafeeafee2341b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting a Controller on the FXMLLoader&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在FXMLLoader上设置控制器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="073ae2218732d9358e80ae1902f7902306ce3628" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE CODE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;代码&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc3a49e13baab6a33567288b2af488d382bdf5c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Goal:&lt;/strong&gt; To demonstrate passing values from &lt;code&gt;Controller1&lt;/code&gt; to &lt;code&gt;Controller2&lt;/code&gt; and vice versa.</source>
          <target state="translated">&lt;strong&gt;目标：&lt;/strong&gt;演示将值从 &lt;code&gt;Controller1&lt;/code&gt; 传递到 &lt;code&gt;Controller2&lt;/code&gt; ，反之亦然。</target>
        </trans-unit>
        <trans-unit id="fdce1e5006393aac40047e8d65fd67c3594d9b86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Program Flow:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;程序流程：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4220ce2b1c8cc0c6d124ad94f3351aed39ea287a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This WORKS ..&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这个工作..&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a98ad4e808fd0c18fba4705e6e10d4bc876a15e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Dependency Injection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用依赖注入&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de0b045581aba063460234e9bfdb8df5c5d25f96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use an Event Bus&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用事件总线&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ff78f58a135f63eab81a0c70c9c59562db139b3" translate="yes" xml:space="preserve">
          <source>A new FXMLLoader is constructed as shown in the sample code i.e. &lt;code&gt;new FXMLLoader(location)&lt;/code&gt;.  The location is a URL and you can generate such a URL from an FXML resource by:</source>
          <target state="translated">如示例代码所示，构造一个新的FXMLLoader，即 &lt;code&gt;new FXMLLoader(location)&lt;/code&gt; 。 该位置是一个URL，您可以通过以下方式从FXML资源生成这样的URL：</target>
        </trans-unit>
        <trans-unit id="cf8369ad6aaa8d9c6c9831fbef32ea6a5785247b" translate="yes" xml:space="preserve">
          <source>A really nice, clean dependency injection approach is exemplified by the &lt;a href=&quot;https://github.com/AdamBien/afterburner.fx&quot;&gt;afterburner.fx framework&lt;/a&gt; with a sample &lt;a href=&quot;https://github.com/AdamBien/airhacks-control&quot;&gt;air-hacks application&lt;/a&gt; that uses it.  afterburner.fx relies on JEE6 &lt;a href=&quot;http://docs.oracle.com/javaee/6/api/javax/inject/package-summary.html&quot;&gt;javax.inject&lt;/a&gt; to perform the dependency injection.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/AdamBien/afterburner.fx&quot;&gt;afterburner.fx框架&lt;/a&gt;示例了一个很好的干净的依赖项注入方法，并使用了一个示例&lt;a href=&quot;https://github.com/AdamBien/airhacks-control&quot;&gt;空袭应用程序&lt;/a&gt; 。 afterburner.fx依靠JEE6 &lt;a href=&quot;http://docs.oracle.com/javaee/6/api/javax/inject/package-summary.html&quot;&gt;javax.inject&lt;/a&gt;来执行依赖项注入。</target>
        </trans-unit>
        <trans-unit id="7bb0e1b0ffe198292e784522ff3d4ebf10105789" translate="yes" xml:space="preserve">
          <source>Adding Spring Dependency Injection in JavaFX (JPA Repo, Service)</source>
          <target state="translated">在JavaFX中添加Spring依赖注入 (JPA Repo,服务)</target>
        </trans-unit>
        <trans-unit id="ebd3258f892399f87b6ea3e36e5d69058e5f29cf" translate="yes" xml:space="preserve">
          <source>An example of JavaFX application and controller dependency injection with Spring is provided in the answer to:</source>
          <target state="translated">JavaFX应用程序和控制器依赖注入与Spring的一个例子,在答案中提供了一个JavaFX应用程序和控制器依赖注入的例子。</target>
        </trans-unit>
        <trans-unit id="19e68b8d0194e5057adaf48bd6d1ea071bf200a9" translate="yes" xml:space="preserve">
          <source>And controller can check, if info is set. Also, you could use ObjectProperty for back-forward data transfering, if needed.</source>
          <target state="translated">而且控制器可以检查,如果信息被设置了,就可以检查。另外,如果需要的话,你可以使用ObjectProperty进行数据的后向传输。</target>
        </trans-unit>
        <trans-unit id="1cf8e2e9ab510630888b60536f5635d6e6ca8122" translate="yes" xml:space="preserve">
          <source>Another Controller</source>
          <target state="translated">另一个主计长</target>
        </trans-unit>
        <trans-unit id="c87d339dfeeb0ffcb18ef3ea996bc725cc487ee7" translate="yes" xml:space="preserve">
          <source>Any ideas?</source>
          <target state="translated">有什么想法吗?</target>
        </trans-unit>
        <trans-unit id="e92e3d33e059386c328d9b8d4ad381786b220316" translate="yes" xml:space="preserve">
          <source>Below are all the FXML files</source>
          <target state="translated">以下是所有的FXML文件</target>
        </trans-unit>
        <trans-unit id="07a6427feda30f20d22cedb205a0bd486316f5aa" translate="yes" xml:space="preserve">
          <source>Construct an FXMLLoader based upon fxml markup at a specified location</source>
          <target state="translated">在指定的位置构建一个基于fxml标记的FXMLLoader。</target>
        </trans-unit>
        <trans-unit id="84c08013cc1b8878e756f976d8b89868e75f3de8" translate="yes" xml:space="preserve">
          <source>Declare an instance of your class:</source>
          <target state="translated">申报一个类的实例。</target>
        </trans-unit>
        <trans-unit id="f68ec6d55942a0c9f7aca3b0a787a3b6dd7ff916" translate="yes" xml:space="preserve">
          <source>Declare your class as follows:</source>
          <target state="translated">申报你的类如下:</target>
        </trans-unit>
        <trans-unit id="54cb64146d9312c99e2870132fc6e3566cc21b79" translate="yes" xml:space="preserve">
          <source>Define value &lt;code&gt;External Text&lt;/code&gt; for namespace variable &lt;code&gt;labelText&lt;/code&gt;:</source>
          <target state="translated">为名称空间变量 &lt;code&gt;labelText&lt;/code&gt; 定义值 &lt;code&gt;External Text&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f86ef7c952f7f19ae04eda154561a0ccec2243b0" translate="yes" xml:space="preserve">
          <source>Due to the limitation on the &lt;code&gt;fx:controller&lt;/code&gt; definition in FXML, I personally prefer getting the controller from the FXMLLoader rather than setting the controller into the FXMLLoader.</source>
          <target state="translated">由于FXML中 &lt;code&gt;fx:controller&lt;/code&gt; 定义的限制，我个人更喜欢从FXMLLoader获取控制器，而不是将控制器设置为FXMLLoader。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="268be2165d2cdbe12455e11387e9be65790adc64" translate="yes" xml:space="preserve">
          <source>FXMLLoader instances themselves never know anything about domain objects.  You do not directly pass application specific domain objects into the FXMLLoader constructor, instead you:</source>
          <target state="translated">FXMLLoader实例本身从来不知道域对象。你不能直接将特定于应用程序的域对象传递到FXMLLoader构造函数中,相反,你可以将域对象直接传递给FXMLLoader。</target>
        </trans-unit>
        <trans-unit id="b59af5ad17a6394635c722d02c06978b624ebd48" translate="yes" xml:space="preserve">
          <source>FXMLLoader supports dependency injection systems like Guice, Spring or Java EE CDI by allowing you to set a custom controller factory on the FXMLLoader.  This provides a callback that you can use to create the controller instance with dependent values injected by the respective dependency injection system.</source>
          <target state="translated">FXMLLoader支持像Guice、Spring或Java EE CDI这样的依赖注入系统,允许你在FXMLLoader上设置一个自定义控制器工厂。这提供了一个回调,你可以用相应的依赖注入系统注入的依赖值来创建控制器实例。</target>
        </trans-unit>
        <trans-unit id="564d7d05702c681636e47b0e56aa76bbd6912a7a" translate="yes" xml:space="preserve">
          <source>First Controller</source>
          <target state="translated">首任主计长</target>
        </trans-unit>
        <trans-unit id="74baca43944f027d260475e891f0c430b557744c" translate="yes" xml:space="preserve">
          <source>For example:
The user chooses a customer from a &lt;code&gt;TableView&lt;/code&gt; and a new window is opened, showing the customer's info.</source>
          <target state="translated">例如：用户从 &lt;code&gt;TableView&lt;/code&gt; 中选择一个客户，并打开一个新窗口，显示该客户的信息。</target>
        </trans-unit>
        <trans-unit id="61d8d857d071491f65804bc615c9b9c10c888b1c" translate="yes" xml:space="preserve">
          <source>For larger, more complicated applications, it would be worthwhile investigating if you want to use &lt;a href=&quot;http://www.martinfowler.com/articles/injection.html&quot;&gt;Dependency Injection&lt;/a&gt; or &lt;a href=&quot;https://github.com/google/guava/wiki/EventBusExplained&quot;&gt;Event Bus&lt;/a&gt; mechanisms within your application.</source>
          <target state="translated">对于更大，更复杂的应用程序，如果您想在应用程序中使用&lt;a href=&quot;http://www.martinfowler.com/articles/injection.html&quot;&gt;依赖注入&lt;/a&gt;或&lt;a href=&quot;https://github.com/google/guava/wiki/EventBusExplained&quot;&gt;事件总线&lt;/a&gt;机制，则值得研究。</target>
        </trans-unit>
        <trans-unit id="2af30fac6d59dd4686931a4c5738334e1bd76128" translate="yes" xml:space="preserve">
          <source>For small applications I highly recommend passing parameters directly from the caller to the controller - it's simple, straightforward and requires no extra frameworks.</source>
          <target state="translated">对于小型应用,我强烈推荐从调用者直接将参数传递给控制器--简单、直接,不需要额外的框架。</target>
        </trans-unit>
        <trans-unit id="fb30866abb900dbe4c1555db00feeb0198683f29" translate="yes" xml:space="preserve">
          <source>Get a controller from the FXMLLoader instance.</source>
          <target state="translated">从FXMLLoader实例中获取一个控制器。</target>
        </trans-unit>
        <trans-unit id="09bd8a56267f0714c11a23f45e791bf42310feef" translate="yes" xml:space="preserve">
          <source>Greg Brown, the original FXML specification creator and implementor, often suggests considering use of an event bus, such as the Guava &lt;a href=&quot;https://github.com/google/guava/wiki/EventBusExplained&quot;&gt;EventBus&lt;/a&gt;, for communication between FXML instantiated controllers and other application logic.</source>
          <target state="translated">最初的FXML规范创建者和实现者Greg Brown通常建议考虑使用事件总线（例如Guava &lt;a href=&quot;https://github.com/google/guava/wiki/EventBusExplained&quot;&gt;EventBus）&lt;/a&gt;在FXML实例化控制器和其他应用程序逻辑之间进行通信。</target>
        </trans-unit>
        <trans-unit id="27fcd8e1c83c45efe40d40504a3d4d69ccb6583c" translate="yes" xml:space="preserve">
          <source>Here is a concrete implementation of the loader:</source>
          <target state="translated">以下是装载机的具体实现方法。</target>
        </trans-unit>
        <trans-unit id="a84a9140afa84ffebc2626b7b3d1170a63d51b51" translate="yes" xml:space="preserve">
          <source>Here is an example for passing parameters to a fxml document through namespace.</source>
          <target state="translated">下面是一个通过命名空间向fxml文档传递参数的例子。</target>
        </trans-unit>
        <trans-unit id="19c5371aebfbd8d50893fe6962bcbd568839ccb7" translate="yes" xml:space="preserve">
          <source>Here is an example for using a controller injected by Guice.</source>
          <target state="translated">下面是一个使用Guice注入的控制器的例子。</target>
        </trans-unit>
        <trans-unit id="20324de8dc7e477ff7d714fb91e7e53e9bd6438d" translate="yes" xml:space="preserve">
          <source>How can I pass parameters to a secondary window in javafx? Is there a way to communicate with the corresponding controller?</source>
          <target state="translated">如何在javafx中将参数传递给辅助窗口?是否有办法与相应的控制器进行通信?</target>
        </trans-unit>
        <trans-unit id="92b2ad8a5738a720470b310bf7e5ec71caff1f7e" translate="yes" xml:space="preserve">
          <source>I have a much simpler method creating an instance of the class using the initialize method.  I searched the Internet multiple days until finding this really simple method.</source>
          <target state="translated">我有一个更简单的方法,就是用初始化方法创建一个类的实例。我在网上搜索了好几天,直到发现这个方法真的很简单。</target>
        </trans-unit>
        <trans-unit id="27ad03be56ddb7b4d6f1994d440b5d583c9450c9" translate="yes" xml:space="preserve">
          <source>I realize this is a very old post and has some great answers already,
  but I wanted to make a simple MCVE to demonstrate one such approach and allow new coders a way to quickly see the concept in action.</source>
          <target state="translated">我知道这是一个很老的帖子,已经有了一些很好的答案,但我想做一个简单的MCVE来演示一个这样的方法,让新的编纂人员能够快速看到这个概念的实际操作。</target>
        </trans-unit>
        <trans-unit id="4817e5da2d13ac351d593aac00e2500c518d928e" translate="yes" xml:space="preserve">
          <source>In this example, we will use 5 files:</source>
          <target state="translated">在这个例子中,我们将使用5个文件。</target>
        </trans-unit>
        <trans-unit id="0bc3a14b314cd4233ac4624f9b57d27e6b49d011" translate="yes" xml:space="preserve">
          <source>Invoke methods on the retrieved controller to provide the controller with references to the domain objects.</source>
          <target state="translated">在检索到的控制器上调用方法,为控制器提供域对象的引用。</target>
        </trans-unit>
        <trans-unit id="1519e1c48675518575ae3a56fad2ff9c18a6e76e" translate="yes" xml:space="preserve">
          <source>It is a functional solution to a problem. A stage is returned from the &lt;code&gt;showCustomerDialog&lt;/code&gt; function so that a reference to it can be stored by an external class which may wish to do something, such as hide the stage based on a button click in the main window, at a later time.  An alternate, object-oriented solution could encapsulate the functionality and stage reference inside a CustomerDialog object or have a CustomerDialog extend Stage.  A full example for an object-oriented interface to a custom dialog encapsulating FXML, controller and model data is beyond the scope of this answer, but may make a worthwhile blog post for anybody inclined to create one.</source>
          <target state="translated">这是一个解决问题的功能。 从 &lt;code&gt;showCustomerDialog&lt;/code&gt; 函数返回一个阶段，以便以后可能希望做一些事情的外部类可以存储对它的引用，例如，根据在主窗口中单击按钮隐藏该阶段。 另一种面向对象的解决方案可以将功能和阶段引用封装在CustomerDialog对象中，或者具有CustomerDialog扩展阶段。 一个自定义对话框的面向对象的界面的完整示例，该示例对话框封装了FXML，控制器和模型数据，超出了此答案的范围，但对于那些愿意创建一个的人来说，可能是一个有价值的博客文章。</target>
        </trans-unit>
        <trans-unit id="997d74a1fe4edf3ad83a187a0cc538a2b99c157a" translate="yes" xml:space="preserve">
          <source>JavaFX FXML Parameter passing from Controller A to B and back</source>
          <target state="translated">JavaFXFXML参数从控制器A传到B,再传回来</target>
        </trans-unit>
        <trans-unit id="1d827930682be6484087708283eceeb882ca809b" translate="yes" xml:space="preserve">
          <source>Note this example loads the view into the center of a BoarderPane that is the root of the Scene in the Stage. This is irrelevant to the example (implementation detail of my specific use case) but decided to leave it in as some may find it useful.</source>
          <target state="translated">注意这个例子将视图加载到BoarderPane的中心,BoarderPane是舞台中场景的根部。这与本例无关(我的具体用例的实现细节),但由于有些人可能会觉得有用,所以决定留下它。</target>
        </trans-unit>
        <trans-unit id="15049a6d88f3144b5a82fe805a470268d5d15d62" translate="yes" xml:space="preserve">
          <source>Now you can pass parameter to any controller from whole application.</source>
          <target state="translated">现在你可以从整个应用程序中传递参数给任何控制器。</target>
        </trans-unit>
        <trans-unit id="d7ccca708d9c68061eeb7f18e3b2a0c5556a1197" translate="yes" xml:space="preserve">
          <source>Observe a documentation here:
&lt;a href=&quot;http://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html&quot;&gt;http://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html&lt;/a&gt;
Before the phrase &quot;In the first version, the handleButtonAction() is tagged with @FXML to allow markup defined in the controller's document to invoke it. In the second example, the button field is annotated to allow the loader to set its value. The initialize() method is similarly annotated.&quot;</source>
          <target state="translated">在此处查看文档： &lt;a href=&quot;http://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html&quot;&gt;http&lt;/a&gt; ://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html在短语&amp;ldquo;在第一个版本中，handleButtonAction（）标记有@FXML允许在控制器文档中定义的标记调用它。在第二个示例中，对button字段进行了注释，以允许加载程序设置其值。对initialize（）方法也进行了注释。</target>
        </trans-unit>
        <trans-unit id="d8ac46e645653969cd8ac02364f9ec75b6f42760" translate="yes" xml:space="preserve">
          <source>One the most fundamental concepts working with any programming language is how to navigate from one (window, form or page) to another. Also while doing this navigation the developer often wants to pass data from one (window, form or page) and display or use the data passed</source>
          <target state="translated">在任何编程语言中工作的最基本的概念之一就是如何从一个(窗口、表单或页面)导航到另一个(窗口、表单或页面)。同时,在做这个导航的时候,开发者往往希望从一个(窗口、表单或页面)中传递数据,并显示或使用传递的数据。</target>
        </trans-unit>
        <trans-unit id="b2bf2aed2ddc4511794d1966adc6fa68911ab1ec" translate="yes" xml:space="preserve">
          <source>Page One Controller</source>
          <target state="translated">第1页控制器</target>
        </trans-unit>
        <trans-unit id="11e30796b976252136488a8d426c5d1185cb04ba" translate="yes" xml:space="preserve">
          <source>Page Two Controller</source>
          <target state="translated">第2页 控制器</target>
        </trans-unit>
        <trans-unit id="6e7f1da0b4e58b6e2d7f5a29528c1de8906c7db4" translate="yes" xml:space="preserve">
          <source>Pass custom data to an FXML controller by retrieving the controller from the FXML loader instance and calling a method on the controller to initialize it with the required data values.</source>
          <target state="translated">通过从FXML加载器实例中检索控制器,并调用控制器上的方法将自定义数据传递给FXML控制器,用所需的数据值对其进行初始化。</target>
        </trans-unit>
        <trans-unit id="22c72866e6a4401e26ebf50b7dfb2e1fa00ebcfb" translate="yes" xml:space="preserve">
          <source>Passing Parameters JavaFX FXML</source>
          <target state="translated">传递参数JavaFXFXML</target>
        </trans-unit>
        <trans-unit id="8fd5798c451970311c96864a4b13348ab3cafe86" translate="yes" xml:space="preserve">
          <source>Set up a method in your class as follows:</source>
          <target state="translated">在你的类中设置一个方法,如下图所示。</target>
        </trans-unit>
        <trans-unit id="09d874c6430a34f9f94e2bc5956cc87249533aff" translate="yes" xml:space="preserve">
          <source>So, you can call page.setUserData(info);</source>
          <target state="translated">所以,你可以调用page.setUserData(info)。</target>
        </trans-unit>
        <trans-unit id="d16cd663d007203976f6b707c00861f099db0a30" translate="yes" xml:space="preserve">
          <source>So, you need to associate a controller with a node, and set a user data to the node.</source>
          <target state="translated">所以,你需要将一个控制器与一个节点关联,并将用户数据设置为节点。</target>
        </trans-unit>
        <trans-unit id="148506082c66e46a02527a315d5e969f66832ba3" translate="yes" xml:space="preserve">
          <source>Something like the following code:</source>
          <target state="translated">类似以下代码的东西。</target>
        </trans-unit>
        <trans-unit id="b3604b8191e868952c41b5db9aece8f1eff7c961" translate="yes" xml:space="preserve">
          <source>Sometimes, you might want to pass results back to the caller, in which case you can check out the answer to the related question:</source>
          <target state="translated">有时,你可能想把结果传回给来电者,这种情况下,你可以查看相关问题的答案。</target>
        </trans-unit>
        <trans-unit id="31bf3f8f69b932e3f1acbfc7c8959e44387c4888" translate="yes" xml:space="preserve">
          <source>Start Controller</source>
          <target state="translated">启动控制器</target>
        </trans-unit>
        <trans-unit id="f6dd8b657be24785f2abfdf37bda7351dd11294e" translate="yes" xml:space="preserve">
          <source>The EventBus is a simple but powerful publish/subscribe API with annotations that allows POJOs to communicate with each other anywhere in a JVM without having to refer to each other.</source>
          <target state="translated">EventBus是一个简单但功能强大的发布订阅API,它允许POJOs在JVM中的任何地方相互通信,而不需要相互引用。</target>
        </trans-unit>
        <trans-unit id="3f68fe9dd740f7622f2cddb0f86cb6d332806bb7" translate="yes" xml:space="preserve">
          <source>The code itself is also commented with some details of what is happening and how.</source>
          <target state="translated">代码本身也注释了一些细节的内容和方法。</target>
        </trans-unit>
        <trans-unit id="d7ee052192384333cece7c842a928f8c8c68c625" translate="yes" xml:space="preserve">
          <source>The first scene contains a &lt;code&gt;TextField&lt;/code&gt;, a &lt;code&gt;Button&lt;/code&gt;, and a &lt;code&gt;Label&lt;/code&gt;. When the &lt;code&gt;Button&lt;/code&gt; is clicked, the second window is loaded and displayed, including the text entered in the &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">第一个场景包含一个 &lt;code&gt;TextField&lt;/code&gt; ，一个 &lt;code&gt;Button&lt;/code&gt; 和一个 &lt;code&gt;Label&lt;/code&gt; 。 单击&amp;ldquo; &lt;code&gt;Button&lt;/code&gt; ，将加载并显示第二个窗口，包括在 &lt;code&gt;TextField&lt;/code&gt; 中输入的文本。</target>
        </trans-unit>
        <trans-unit id="e89b675bd57745459f9012d978836ee4fed7f3ef" translate="yes" xml:space="preserve">
          <source>The question of how to do it &quot;The Spring Boot Way&quot;, there was a discussion about JavaFX 2, which I anserwered in the attached permalink.
The approach is still valid and tested in March 2016, on Spring Boot v1.3.3.RELEASE:
&lt;a href=&quot;https://stackoverflow.com/a/36310391/1281217&quot;&gt;https://stackoverflow.com/a/36310391/1281217&lt;/a&gt;</source>
          <target state="translated">关于如何做的问题&amp;ldquo; Spring Boot Way&amp;rdquo;，有一个关于JavaFX 2的讨论，我在所附的永久链接中对此进行了解答。 该方法仍然有效并已在2016年3月的Spring Boot v1.3.3。上进行了测试。发布： &lt;a href=&quot;https://stackoverflow.com/a/36310391/1281217&quot;&gt;https&lt;/a&gt; ://stackoverflow.com/a/36310391/1281217</target>
        </trans-unit>
        <trans-unit id="82e3482bcddbb09c5152d3becc5b72853aaab86e" translate="yes" xml:space="preserve">
          <source>Then call the method in the initialize method:</source>
          <target state="translated">然后在初始化方法中调用该方法。</target>
        </trans-unit>
        <trans-unit id="695e286da54461134d0ffb2e93585086866574c4" translate="yes" xml:space="preserve">
          <source>Then in the second one declare a client, then at the bottom of your controller:</source>
          <target state="translated">然后在第二种申报一个客户端,然后在你的控制器的底部。</target>
        </trans-unit>
        <trans-unit id="c99fc6dd617a6cc2b70c852b05036d5464e823f3" translate="yes" xml:space="preserve">
          <source>This answer enumerates different mechanisms for passing parameters to FXML controllers.</source>
          <target state="translated">本回答列举了向FXML控制器传递参数的不同机制。</target>
        </trans-unit>
        <trans-unit id="4c574944de10a90935170be07d6274d1b56596f9" translate="yes" xml:space="preserve">
          <source>This blog (by another writer) provides an alternate, but similar, &lt;a href=&quot;https://web.archive.org/web/20160612045146/http://ed4becky.net/homepage/javafx-from-the-trenches-singleton-controllers/&quot;&gt;example&lt;/a&gt;.</source>
          <target state="translated">该博客（由另一位作者撰写）提供了一个替代&lt;a href=&quot;https://web.archive.org/web/20160612045146/http://ed4becky.net/homepage/javafx-from-the-trenches-singleton-controllers/&quot;&gt;示例&lt;/a&gt; ，但类似。</target>
        </trans-unit>
        <trans-unit id="d3f64e1b7d926162d53189f69a231b6f11f696f3" translate="yes" xml:space="preserve">
          <source>This is a very simple demonstration and could surely stand for some improvement, but should make the concept very clear.</source>
          <target state="translated">这是一个非常简单的演示,肯定可以站在一些改进,但应该让概念非常清晰。</target>
        </trans-unit>
        <trans-unit id="58ff871b6a93ce45b14af622b058f94e1d743f85" translate="yes" xml:space="preserve">
          <source>This method is exemplified by Sergey's answer to &lt;a href=&quot;https://stackoverflow.com/a/10136403/1155209&quot;&gt;Javafx 2.0 How-to Application.getParameters() in a Controller.java file&lt;/a&gt;.</source>
          <target state="translated">该方法以Sergey对&lt;a href=&quot;https://stackoverflow.com/a/10136403/1155209&quot;&gt;Controller.java文件中的Javafx 2.0 How-to Application.getParameters（）&lt;/a&gt;的回答为例 。</target>
        </trans-unit>
        <trans-unit id="e294a3637e40ee80112353a36d3e686c77f1a9e1" translate="yes" xml:space="preserve">
          <source>Upon entering text in the second scene's &lt;code&gt;TextField&lt;/code&gt; and clicking its &lt;code&gt;Button&lt;/code&gt;, the first scene's &lt;code&gt;Label&lt;/code&gt; is updated to show the entered text.</source>
          <target state="translated">在第二个场景的 &lt;code&gt;TextField&lt;/code&gt; 中输入文本并单击其 &lt;code&gt;Button&lt;/code&gt; 后 ，第一个场景的 &lt;code&gt;Label&lt;/code&gt; 将更新以显示输入的文本。</target>
        </trans-unit>
        <trans-unit id="e604afe2fab7851c738baa0703aa593c489afa8c" translate="yes" xml:space="preserve">
          <source>We said three because we will navigate between three (window, form or page) and use the concept of static variables to pass data around the (window, form or page)</source>
          <target state="translated">我们说三个,是因为我们将在三个(窗口、表单或页面)之间进行导航,并使用静态变量的概念,在(窗口、表单或页面)周围传递数据。</target>
        </trans-unit>
        <trans-unit id="db0a1b80667c8c0c7309198ff7e02cb67949b61e" translate="yes" xml:space="preserve">
          <source>We will also include some decision making code while we navigate</source>
          <target state="translated">我们在导航的同时,还将包括一些决策代码,我们也将包括一些决策代码。</target>
        </trans-unit>
        <trans-unit id="786077af3bc091aedfb5ac41432ace630b739b49" translate="yes" xml:space="preserve">
          <source>Which you could use to add your info to the Node.</source>
          <target state="translated">你可以用它将你的信息添加到Node中。</target>
        </trans-unit>
        <trans-unit id="17f368fb0c189ac7c03d30500a3d69c00c1c9daa" translate="yes" xml:space="preserve">
          <source>While most of the answers here provide good to excellent examples how to accomplish this we thought we would kick it up a notch or two or three</source>
          <target state="translated">虽然这里的大多数答案都提供了很好的或优秀的例子,但我们认为我们要把它提高一个或两个或三个档次。</target>
        </trans-unit>
        <trans-unit id="2aa783067aecb401bbd1b4f477cbd87034b29b91" translate="yes" xml:space="preserve">
          <source>Why answer a 6 year old question ?</source>
          <target state="translated">为什么回答一个6岁的问题?</target>
        </trans-unit>
        <trans-unit id="c1eb36ced7883a452884956390912cc17ae8f088" translate="yes" xml:space="preserve">
          <source>Within the second scene, there is also a &lt;code&gt;TextField&lt;/code&gt;, a &lt;code&gt;Button&lt;/code&gt;, and a &lt;code&gt;Label&lt;/code&gt;. The &lt;code&gt;Label&lt;/code&gt; will display the text entered in the &lt;code&gt;TextField&lt;/code&gt; on the first scene.</source>
          <target state="translated">在第二个场景内，还有一个 &lt;code&gt;TextField&lt;/code&gt; ，一个 &lt;code&gt;Button&lt;/code&gt; 和一个 &lt;code&gt;Label&lt;/code&gt; 。 &lt;code&gt;Label&lt;/code&gt; 将在第一个场景中显示在 &lt;code&gt;TextField&lt;/code&gt; 中输入的文本。</target>
        </trans-unit>
        <trans-unit id="921894831c197b9dfa4a8f25ac6ebda5487c7680" translate="yes" xml:space="preserve">
          <source>Yes you can.</source>
          <target state="translated">是的,你可以的</target>
        </trans-unit>
        <trans-unit id="73b530ca384585cc2ac29282203c5ad1b15c177c" translate="yes" xml:space="preserve">
          <source>You can construct a new controller in code, passing any parameters you want from your caller into the controller constructor.  Once you have constructed a controller, you can set it on an FXMLLoader instance &lt;em&gt;before&lt;/em&gt; you invoke the &lt;code&gt;load()&lt;/code&gt;&lt;em&gt;instance&lt;/em&gt; method.</source>
          <target state="translated">您可以用代码构造一个新的控制器，将您想要的任何参数从调用者传递到控制器构造函数中。 构造控制器后，可以&lt;em&gt;在&lt;/em&gt;调用 &lt;code&gt;load()&lt;/code&gt; &lt;em&gt;实例&lt;/em&gt;方法&lt;em&gt;之前&lt;/em&gt;在FXMLLoader实例上对其进行设置。</target>
        </trans-unit>
        <trans-unit id="3ead7a6dc421901bccc6c7ac969a9dde19578f7d" translate="yes" xml:space="preserve">
          <source>You can decide to use a public observable list to store public data, or just create a public setter method to store data and retrieve from the corresponding controller</source>
          <target state="translated">你可以决定使用一个公共可观察列表来存储公共数据,或者直接创建一个公共设置器方法来存储数据,并从相应的控制器中检索</target>
        </trans-unit>
        <trans-unit id="dcd8769e54975ae4d90bfc3d0d1dd8e004a1eea0" translate="yes" xml:space="preserve">
          <source>You have to create one Context Class.</source>
          <target state="translated">你必须创建一个上下文类。</target>
        </trans-unit>
        <trans-unit id="6f81053bd7041eb7c1619453fa02334681231969" translate="yes" xml:space="preserve">
          <source>You have to just set instance of controller in initialization using</source>
          <target state="translated">你只需要在初始化时用</target>
        </trans-unit>
        <trans-unit id="c0ccfe1fd7d9afe28f79a42585f7ea2c363af919" translate="yes" xml:space="preserve">
          <source>You need to add in the first controller:</source>
          <target state="translated">你需要在第一个控制器中加入。</target>
        </trans-unit>
        <trans-unit id="ed7bd1e5f4ebf3feafa43f27540f8e76a6da6195" translate="yes" xml:space="preserve">
          <source>and you can use it from your whole application just using</source>
          <target state="translated">而你可以从你的整个应用程序中使用它,只需使用</target>
        </trans-unit>
        <trans-unit id="488628eb4fb22f92bb0121af1c4d3873d629e952" translate="yes" xml:space="preserve">
          <source>javafx.scene.Node class has a pair of methods 
setUserData(Object)
 and 
Object getUserData()</source>
          <target state="translated">javafx.sene.Node类有一对方法setUserData(Object)和Object getUserData()</target>
        </trans-unit>
        <trans-unit id="bbd8c0d44e3b021ea295bd918cd65c9c5e691e93" translate="yes" xml:space="preserve">
          <source>on first method, why do you return Stage? The method can be void as well because you already giving the command show(); just before return stage;. How do you plan usage by returning the Stage</source>
          <target state="translated">在第一个方法中,为什么要返回Stage?这个方法也可以是空的,因为你在返回Stage;之前已经给了show();命令。你如何通过返回Stage</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
