<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/14187963">
    <body>
      <group id="14187963">
        <trans-unit id="abb6b4a544de50fb9bdc621b8b51a82d205e07c3" translate="yes" xml:space="preserve">
          <source>// set up the variable used for the instance of the main class</source>
          <target state="translated">// 메인 클래스의 인스턴스에 사용되는 변수를 설정</target>
        </trans-unit>
        <trans-unit id="e99f381ecf5a4f54dbd6192e3c9cbf4238c7dc10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newStage&lt;/code&gt; would be the new window. The problem is, I can't find a way to tell the controller where to look for the customer's info (by passing the id as parameter).</source>
          <target state="translated">&lt;code&gt;newStage&lt;/code&gt; 는 새 창입니다. 문제는 컨트롤러에 고객 정보를 어디에서 찾을 것인지 알려주는 방법을 찾을 수 없다는 것입니다 (id를 매개 변수로 전달하여).</target>
        </trans-unit>
        <trans-unit id="cb5c34da153ae0147f32e5bc4d4c0c025d7a01aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;All files are listed in their entirety at the bottom of this post.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;모든 파일은이 게시물의 맨 아래에 전체적으로 나열됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d19ee85e645013f2e6b5feb33ff2693ff70682e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Be careful NOT to use a static load function on the FXMLLoader, or you will not be able to get your controller from your loader instance.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;FXMLLoader에서 정적로드 기능을 사용하지 않도록주의하십시오. 그렇지 않으면 로더 인스턴스에서 컨트롤러를 가져올 수 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3116d5258a5f9edea3c5a736e4390fd2fe59e466" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example for Spring Boot Dependency Injection&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;스프링 부트 의존성 주입 예제&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="74003107815f915a4cbe8fedd255db49b4dd35fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To set a controller on a loader (in JavaFX 2.x) you CANNOT also define a &lt;code&gt;fx:controller&lt;/code&gt; attribute in your fxml file.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;로더 (JavaFX 2.x)에서 제어기를 설정하기 위해 fxml 파일에서 &lt;code&gt;fx:controller&lt;/code&gt; 속성을 정의 할 수도 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="33bb599a4d9b3474e81c6ed136ffc6985664020e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Additional information supplied by StackOverflow user named &lt;a href=&quot;https://stackoverflow.com/users/1281217/bgmf&quot;&gt;@dzim&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/users/1281217/bgmf&quot;&gt;@dzim&lt;/a&gt; 이라는 StackOverflow 사용자가 제공 한 추가 정보&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4fd9b1d0cef2b96ea8756f754cfda3df07303ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controller1.java:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Controller1.java:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="706060d063fd03f3ebcadfc4516d733aa40e2400" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controller1.java&lt;/strong&gt; - The controller for the first FXML layout.</source>
          <target state="translated">&lt;strong&gt;Controller1.java-&lt;/strong&gt; 첫 번째 FXML 레이아웃의 컨트롤러입니다.</target>
        </trans-unit>
        <trans-unit id="a006dc4fa708bd933c7fe6fb94bd24a686b17f66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controller2.java:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Controller2.java:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad314d8b25f378a2fd5082b515d2bc0342fa369f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controller2.java&lt;/strong&gt; - The controller for the second FXML layout.</source>
          <target state="translated">&lt;strong&gt;Controller2.java-&lt;/strong&gt; 두 번째 FXML 레이아웃의 컨트롤러입니다.</target>
        </trans-unit>
        <trans-unit id="0b53f3af53d5ef2121636a2def3bc2e2451b965e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Follow-up Q&amp;amp;A&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;후속 Q &amp;amp; A&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1dd65275cc31621283ddd43beeb8ed910906282a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Having the Controller Retrieve Parameters from an External Static Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컨트롤러가 외부 정적 메소드에서 매개 변수를 검색하도록하기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55d48d5a78ee7a1d081b3d7be28651cc57547a0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Layout1.fxml:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Layout1.fxml:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b2b3f469d405274016f600d777affb20d598614" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Layout1.fxml&lt;/strong&gt; - The FXML layout for the first scene.</source>
          <target state="translated">&lt;strong&gt;Layout1.fxml-&lt;/strong&gt; 첫 번째 장면의 FXML 레이아웃</target>
        </trans-unit>
        <trans-unit id="a7a323d9193e2d0fe847422dc0a6e84178e3c637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Layout2.fxml:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Layout2.fxml:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03c7533bc42ff9e8a98d5f08f566ce0586dacef9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Layout2.fxml&lt;/strong&gt; - The FXML layout for the second scene.</source>
          <target state="translated">&lt;strong&gt;Layout2.fxml-&lt;/strong&gt; 두 번째 장면의 FXML 레이아웃입니다.</target>
        </trans-unit>
        <trans-unit id="9c3c79da97c928fef80b3521532f1e13afa52851" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Main.java:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Main.java:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57a371781447c4770a54384026c3775eca579201" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Main.java&lt;/strong&gt; - Simply used to start the application and call the first controller.</source>
          <target state="translated">&lt;strong&gt;Main.java-&lt;/strong&gt; 응용 프로그램을 시작하고 첫 번째 컨트롤러를 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e11a488151b7395c55e0d3c12c87f94afaa380d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Parameters Directly From the Caller to the Controller&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;발신자에서 컨트롤러로 직접 매개 변수 전달&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a9f0c31bf24b09da6c9598ec9c76a164314487f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recommended Approach&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;권장 접근법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c03de514f34813514a6852828a3ee6c4b50625e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remember first time you print the passing value you will get null,
You can use it after your windows loaded , same for everything you want to code for any other component.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;전달하는 값을 처음 인쇄 할 때 null이된다는 것을 기억하십시오. 창을로드 한 후에는 다른 구성 요소에 대해 코딩하려는 모든 항목에 대해이 값을 사용할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4162b0ad6ae79cf21c04d31cfdafeeafee2341b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting a Controller on the FXMLLoader&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FXMLLoader에서 컨트롤러 설정&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="073ae2218732d9358e80ae1902f7902306ce3628" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE CODE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;코드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc3a49e13baab6a33567288b2af488d382bdf5c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Goal:&lt;/strong&gt; To demonstrate passing values from &lt;code&gt;Controller1&lt;/code&gt; to &lt;code&gt;Controller2&lt;/code&gt; and vice versa.</source>
          <target state="translated">&lt;strong&gt;목표 :&lt;/strong&gt; &lt;code&gt;Controller1&lt;/code&gt; 에서 &lt;code&gt;Controller2&lt;/code&gt; 로 또는 그 반대로 값을 전달하는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fdce1e5006393aac40047e8d65fd67c3594d9b86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Program Flow:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로그램 흐름 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4220ce2b1c8cc0c6d124ad94f3351aed39ea287a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This WORKS ..&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 작동합니다 ..&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a98ad4e808fd0c18fba4705e6e10d4bc876a15e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Dependency Injection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;의존성 주입 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de0b045581aba063460234e9bfdb8df5c5d25f96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use an Event Bus&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이벤트 버스 이용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ff78f58a135f63eab81a0c70c9c59562db139b3" translate="yes" xml:space="preserve">
          <source>A new FXMLLoader is constructed as shown in the sample code i.e. &lt;code&gt;new FXMLLoader(location)&lt;/code&gt;.  The location is a URL and you can generate such a URL from an FXML resource by:</source>
          <target state="translated">새 FXMLLoader는 샘플 코드 (예 : &lt;code&gt;new FXMLLoader(location)&lt;/code&gt; 표시된대로 구성됩니다. 위치는 URL이며 다음을 통해 FXML 리소스에서 이러한 URL을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8369ad6aaa8d9c6c9831fbef32ea6a5785247b" translate="yes" xml:space="preserve">
          <source>A really nice, clean dependency injection approach is exemplified by the &lt;a href=&quot;https://github.com/AdamBien/afterburner.fx&quot;&gt;afterburner.fx framework&lt;/a&gt; with a sample &lt;a href=&quot;https://github.com/AdamBien/airhacks-control&quot;&gt;air-hacks application&lt;/a&gt; that uses it.  afterburner.fx relies on JEE6 &lt;a href=&quot;http://docs.oracle.com/javaee/6/api/javax/inject/package-summary.html&quot;&gt;javax.inject&lt;/a&gt; to perform the dependency injection.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/AdamBien/afterburner.fx&quot;&gt;afterburner.fx 프레임 워크&lt;/a&gt; 에는이를 사용하는 샘플 &lt;a href=&quot;https://github.com/AdamBien/airhacks-control&quot;&gt;에어 핵 응용 프로그램&lt;/a&gt; 이 포함되어 있습니다. afterburner.fx는 JEE6 &lt;a href=&quot;http://docs.oracle.com/javaee/6/api/javax/inject/package-summary.html&quot;&gt;javax.inject&lt;/a&gt; 를 사용하여 종속성 주입을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7bb0e1b0ffe198292e784522ff3d4ebf10105789" translate="yes" xml:space="preserve">
          <source>Adding Spring Dependency Injection in JavaFX (JPA Repo, Service)</source>
          <target state="translated">JavaFX에서 스프링 종속성 주입 추가 (JPA Repo, Service)</target>
        </trans-unit>
        <trans-unit id="ebd3258f892399f87b6ea3e36e5d69058e5f29cf" translate="yes" xml:space="preserve">
          <source>An example of JavaFX application and controller dependency injection with Spring is provided in the answer to:</source>
          <target state="translated">Spring을 사용한 JavaFX 애플리케이션 및 컨트롤러 종속성 주입의 예는 다음에 대한 답변으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="19e68b8d0194e5057adaf48bd6d1ea071bf200a9" translate="yes" xml:space="preserve">
          <source>And controller can check, if info is set. Also, you could use ObjectProperty for back-forward data transfering, if needed.</source>
          <target state="translated">정보가 설정되어 있으면 컨트롤러가 확인할 수 있습니다. 또한 필요한 경우 뒤로 전달 데이터 전송에 ObjectProperty를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cf8e2e9ab510630888b60536f5635d6e6ca8122" translate="yes" xml:space="preserve">
          <source>Another Controller</source>
          <target state="translated">다른 컨트롤러</target>
        </trans-unit>
        <trans-unit id="c87d339dfeeb0ffcb18ef3ea996bc725cc487ee7" translate="yes" xml:space="preserve">
          <source>Any ideas?</source>
          <target state="translated">어떤 아이디어?</target>
        </trans-unit>
        <trans-unit id="e92e3d33e059386c328d9b8d4ad381786b220316" translate="yes" xml:space="preserve">
          <source>Below are all the FXML files</source>
          <target state="translated">아래는 모든 FXML 파일입니다</target>
        </trans-unit>
        <trans-unit id="07a6427feda30f20d22cedb205a0bd486316f5aa" translate="yes" xml:space="preserve">
          <source>Construct an FXMLLoader based upon fxml markup at a specified location</source>
          <target state="translated">지정된 위치에서 fxml 마크 업을 기반으로 FXMLLoader 생성</target>
        </trans-unit>
        <trans-unit id="84c08013cc1b8878e756f976d8b89868e75f3de8" translate="yes" xml:space="preserve">
          <source>Declare an instance of your class:</source>
          <target state="translated">클래스의 인스턴스를 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="f68ec6d55942a0c9f7aca3b0a787a3b6dd7ff916" translate="yes" xml:space="preserve">
          <source>Declare your class as follows:</source>
          <target state="translated">다음과 같이 수업을 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="54cb64146d9312c99e2870132fc6e3566cc21b79" translate="yes" xml:space="preserve">
          <source>Define value &lt;code&gt;External Text&lt;/code&gt; for namespace variable &lt;code&gt;labelText&lt;/code&gt;:</source>
          <target state="translated">네임 스페이스 변수 &lt;code&gt;labelText&lt;/code&gt; 에 대한 &lt;code&gt;External Text&lt;/code&gt; 값을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="f86ef7c952f7f19ae04eda154561a0ccec2243b0" translate="yes" xml:space="preserve">
          <source>Due to the limitation on the &lt;code&gt;fx:controller&lt;/code&gt; definition in FXML, I personally prefer getting the controller from the FXMLLoader rather than setting the controller into the FXMLLoader.</source>
          <target state="translated">FXML의 &lt;code&gt;fx:controller&lt;/code&gt; 정의에 대한 제한으로 인해 개인적으로 컨트롤러를 FXMLLoader로 설정하는 대신 FXMLLoader에서 컨트롤러를 얻는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="268be2165d2cdbe12455e11387e9be65790adc64" translate="yes" xml:space="preserve">
          <source>FXMLLoader instances themselves never know anything about domain objects.  You do not directly pass application specific domain objects into the FXMLLoader constructor, instead you:</source>
          <target state="translated">FXMLLoader 인스턴스 자체는 도메인 개체에 대해 전혀 알지 못합니다. 대신 응용 프로그램 특정 도메인 개체를 FXMLLoader 생성자로 직접 전달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b59af5ad17a6394635c722d02c06978b624ebd48" translate="yes" xml:space="preserve">
          <source>FXMLLoader supports dependency injection systems like Guice, Spring or Java EE CDI by allowing you to set a custom controller factory on the FXMLLoader.  This provides a callback that you can use to create the controller instance with dependent values injected by the respective dependency injection system.</source>
          <target state="translated">FXMLLoader는 Guice, Spring 또는 Java EE CDI와 같은 종속성 주입 시스템을 지원하여 FXMLLoader에서 사용자 정의 컨트롤러 팩토리를 설정할 수 있습니다. 이는 각각의 의존성 주입 시스템에 의해 주입 된 의존성 값으로 컨트롤러 인스턴스를 생성하는 데 사용할 수있는 콜백을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="564d7d05702c681636e47b0e56aa76bbd6912a7a" translate="yes" xml:space="preserve">
          <source>First Controller</source>
          <target state="translated">첫 컨트롤러</target>
        </trans-unit>
        <trans-unit id="74baca43944f027d260475e891f0c430b557744c" translate="yes" xml:space="preserve">
          <source>For example:
The user chooses a customer from a &lt;code&gt;TableView&lt;/code&gt; and a new window is opened, showing the customer's info.</source>
          <target state="translated">예를 들어 : 사용자가 &lt;code&gt;TableView&lt;/code&gt; 에서 고객을 선택하면 고객 정보를 보여주는 새 창이 열립니다.</target>
        </trans-unit>
        <trans-unit id="61d8d857d071491f65804bc615c9b9c10c888b1c" translate="yes" xml:space="preserve">
          <source>For larger, more complicated applications, it would be worthwhile investigating if you want to use &lt;a href=&quot;http://www.martinfowler.com/articles/injection.html&quot;&gt;Dependency Injection&lt;/a&gt; or &lt;a href=&quot;https://github.com/google/guava/wiki/EventBusExplained&quot;&gt;Event Bus&lt;/a&gt; mechanisms within your application.</source>
          <target state="translated">더 크고 복잡한 응용 프로그램의 경우 응용 프로그램 내에서 &lt;a href=&quot;http://www.martinfowler.com/articles/injection.html&quot;&gt;Dependency Injection&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/google/guava/wiki/EventBusExplained&quot;&gt;Event Bus&lt;/a&gt; 메커니즘을 사용하려는 경우 조사하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2af30fac6d59dd4686931a4c5738334e1bd76128" translate="yes" xml:space="preserve">
          <source>For small applications I highly recommend passing parameters directly from the caller to the controller - it's simple, straightforward and requires no extra frameworks.</source>
          <target state="translated">작은 응용 프로그램의 경우 호출자에서 컨트롤러로 직접 매개 변수를 전달하는 것이 좋습니다. 간단하고 간단하며 추가 프레임 워크가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb30866abb900dbe4c1555db00feeb0198683f29" translate="yes" xml:space="preserve">
          <source>Get a controller from the FXMLLoader instance.</source>
          <target state="translated">FXMLLoader 인스턴스에서 컨트롤러를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="09bd8a56267f0714c11a23f45e791bf42310feef" translate="yes" xml:space="preserve">
          <source>Greg Brown, the original FXML specification creator and implementor, often suggests considering use of an event bus, such as the Guava &lt;a href=&quot;https://github.com/google/guava/wiki/EventBusExplained&quot;&gt;EventBus&lt;/a&gt;, for communication between FXML instantiated controllers and other application logic.</source>
          <target state="translated">원래 FXML 사양 작성자이자 구현자인 Greg Brown은 FXML 인스턴스화 된 컨트롤러와 다른 응용 프로그램 논리 간의 통신을 위해 Guava &lt;a href=&quot;https://github.com/google/guava/wiki/EventBusExplained&quot;&gt;EventBus&lt;/a&gt; 와 같은 이벤트 버스 사용을 고려할 것을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="27fcd8e1c83c45efe40d40504a3d4d69ccb6583c" translate="yes" xml:space="preserve">
          <source>Here is a concrete implementation of the loader:</source>
          <target state="translated">로더의 구체적인 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a84a9140afa84ffebc2626b7b3d1170a63d51b51" translate="yes" xml:space="preserve">
          <source>Here is an example for passing parameters to a fxml document through namespace.</source>
          <target state="translated">다음은 네임 스페이스를 통해 매개 변수를 fxml 문서에 전달하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="19c5371aebfbd8d50893fe6962bcbd568839ccb7" translate="yes" xml:space="preserve">
          <source>Here is an example for using a controller injected by Guice.</source>
          <target state="translated">다음은 Guice가 주입 한 컨트롤러를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="20324de8dc7e477ff7d714fb91e7e53e9bd6438d" translate="yes" xml:space="preserve">
          <source>How can I pass parameters to a secondary window in javafx? Is there a way to communicate with the corresponding controller?</source>
          <target state="translated">javafx에서 보조 창에 매개 변수를 전달하려면 어떻게해야합니까? 해당 컨트롤러와 통신하는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="92b2ad8a5738a720470b310bf7e5ec71caff1f7e" translate="yes" xml:space="preserve">
          <source>I have a much simpler method creating an instance of the class using the initialize method.  I searched the Internet multiple days until finding this really simple method.</source>
          <target state="translated">initialize 메소드를 사용하여 클래스의 인스턴스를 작성하는 훨씬 간단한 메소드가 있습니다. 이 간단한 방법을 찾을 때까지 며칠 동안 인터넷을 검색했습니다.</target>
        </trans-unit>
        <trans-unit id="27ad03be56ddb7b4d6f1994d440b5d583c9450c9" translate="yes" xml:space="preserve">
          <source>I realize this is a very old post and has some great answers already,
  but I wanted to make a simple MCVE to demonstrate one such approach and allow new coders a way to quickly see the concept in action.</source>
          <target state="translated">나는 이것이 매우 오래된 게시물이라는 것을 알고 있으며 이미 훌륭한 답변을 얻었지만 그러한 접근법 중 하나를 보여주기 위해 간단한 MCVE를 만들고 새로운 코더가 개념을 실제로 볼 수있는 방법을 원했습니다.</target>
        </trans-unit>
        <trans-unit id="4817e5da2d13ac351d593aac00e2500c518d928e" translate="yes" xml:space="preserve">
          <source>In this example, we will use 5 files:</source>
          <target state="translated">이 예에서는 5 개의 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0bc3a14b314cd4233ac4624f9b57d27e6b49d011" translate="yes" xml:space="preserve">
          <source>Invoke methods on the retrieved controller to provide the controller with references to the domain objects.</source>
          <target state="translated">검색된 컨트롤러에서 메소드를 호출하여 컨트롤러에 도메인 오브젝트에 대한 참조를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="1519e1c48675518575ae3a56fad2ff9c18a6e76e" translate="yes" xml:space="preserve">
          <source>It is a functional solution to a problem. A stage is returned from the &lt;code&gt;showCustomerDialog&lt;/code&gt; function so that a reference to it can be stored by an external class which may wish to do something, such as hide the stage based on a button click in the main window, at a later time.  An alternate, object-oriented solution could encapsulate the functionality and stage reference inside a CustomerDialog object or have a CustomerDialog extend Stage.  A full example for an object-oriented interface to a custom dialog encapsulating FXML, controller and model data is beyond the scope of this answer, but may make a worthwhile blog post for anybody inclined to create one.</source>
          <target state="translated">문제에 대한 기능적 솔루션입니다. &lt;code&gt;showCustomerDialog&lt;/code&gt; 함수에서 스테이지가 반환되어 나중에 기본 창에서 버튼 클릭을 기반으로 스테이지를 숨기는 등의 작업을 수행하려는 외부 클래스에서 참조를 저장할 수 있습니다. 대체 객체 지향 솔루션은 CustomerDialog 객체 내부의 기능 및 단계 참조를 캡슐화하거나 CustomerDialog extend Stage를 가질 수 있습니다. FXML, 컨트롤러 및 모델 데이터를 캡슐화하는 사용자 정의 대화 상자에 대한 객체 지향 인터페이스의 전체 예는이 답변의 범위를 벗어 났지만 누구나 블로그 게시물을 작성하려는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="997d74a1fe4edf3ad83a187a0cc538a2b99c157a" translate="yes" xml:space="preserve">
          <source>JavaFX FXML Parameter passing from Controller A to B and back</source>
          <target state="translated">컨트롤러 A에서 B로 전달되는 JavaFX FXML 매개 변수</target>
        </trans-unit>
        <trans-unit id="1d827930682be6484087708283eceeb882ca809b" translate="yes" xml:space="preserve">
          <source>Note this example loads the view into the center of a BoarderPane that is the root of the Scene in the Stage. This is irrelevant to the example (implementation detail of my specific use case) but decided to leave it in as some may find it useful.</source>
          <target state="translated">이 예제는 스테이지에서 장면의 루트 인 BoarderPane의 중심으로 뷰를로드합니다. 이것은 예제 (내 특정 사용 사례의 구현 세부 사항)와 관련이 없지만 일부는 유용 할 수 있으므로 그대로두기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="15049a6d88f3144b5a82fe805a470268d5d15d62" translate="yes" xml:space="preserve">
          <source>Now you can pass parameter to any controller from whole application.</source>
          <target state="translated">이제 전체 애플리케이션에서 모든 컨트롤러에 매개 변수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7ccca708d9c68061eeb7f18e3b2a0c5556a1197" translate="yes" xml:space="preserve">
          <source>Observe a documentation here:
&lt;a href=&quot;http://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html&quot;&gt;http://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html&lt;/a&gt;
Before the phrase &quot;In the first version, the handleButtonAction() is tagged with @FXML to allow markup defined in the controller's document to invoke it. In the second example, the button field is annotated to allow the loader to set its value. The initialize() method is similarly annotated.&quot;</source>
          <target state="translated">다음 문서를 &lt;a href=&quot;http://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html&quot;&gt;참조&lt;/a&gt; 하십시오. http://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html &quot;첫 번째 버전에서 handleButtonAction ()은 @FXML로 태그 지정됩니다. 컨트롤러의 문서에 정의 된 마크 업이이를 호출 할 수 있도록합니다. 두 번째 예에서는 버튼 필드에 주석을 달아 로더가 값을 설정할 수 있도록합니다. initialize () 메소드도 비슷하게 주석이 달립니다. &quot;</target>
        </trans-unit>
        <trans-unit id="d8ac46e645653969cd8ac02364f9ec75b6f42760" translate="yes" xml:space="preserve">
          <source>One the most fundamental concepts working with any programming language is how to navigate from one (window, form or page) to another. Also while doing this navigation the developer often wants to pass data from one (window, form or page) and display or use the data passed</source>
          <target state="translated">프로그래밍 언어와 함께 작동하는 가장 기본적인 개념 중 하나는 하나의 창 (창, 양식 또는 페이지)에서 다른 창으로 이동하는 방법입니다. 또한이 탐색을 수행하는 동안 개발자는 종종 하나의 데이터 (창, 양식 또는 페이지)를 전달하고 전달 된 데이터를 표시하거나 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b2bf2aed2ddc4511794d1966adc6fa68911ab1ec" translate="yes" xml:space="preserve">
          <source>Page One Controller</source>
          <target state="translated">1 페이지 컨트롤러</target>
        </trans-unit>
        <trans-unit id="11e30796b976252136488a8d426c5d1185cb04ba" translate="yes" xml:space="preserve">
          <source>Page Two Controller</source>
          <target state="translated">2 페이지 컨트롤러</target>
        </trans-unit>
        <trans-unit id="6e7f1da0b4e58b6e2d7f5a29528c1de8906c7db4" translate="yes" xml:space="preserve">
          <source>Pass custom data to an FXML controller by retrieving the controller from the FXML loader instance and calling a method on the controller to initialize it with the required data values.</source>
          <target state="translated">FXML 로더 인스턴스에서 컨트롤러를 검색하고 컨트롤러에서 메서드를 호출하여 필요한 데이터 값으로 초기화하여 사용자 지정 데이터를 FXML 컨트롤러로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="22c72866e6a4401e26ebf50b7dfb2e1fa00ebcfb" translate="yes" xml:space="preserve">
          <source>Passing Parameters JavaFX FXML</source>
          <target state="translated">전달 매개 변수 JavaFX FXML</target>
        </trans-unit>
        <trans-unit id="8fd5798c451970311c96864a4b13348ab3cafe86" translate="yes" xml:space="preserve">
          <source>Set up a method in your class as follows:</source>
          <target state="translated">다음과 같이 클래스에서 메소드를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="09d874c6430a34f9f94e2bc5956cc87249533aff" translate="yes" xml:space="preserve">
          <source>So, you can call page.setUserData(info);</source>
          <target state="translated">따라서 page.setUserData (info);를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d16cd663d007203976f6b707c00861f099db0a30" translate="yes" xml:space="preserve">
          <source>So, you need to associate a controller with a node, and set a user data to the node.</source>
          <target state="translated">따라서 제어기를 노드와 연관시키고 사용자 데이터를 노드로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="148506082c66e46a02527a315d5e969f66832ba3" translate="yes" xml:space="preserve">
          <source>Something like the following code:</source>
          <target state="translated">다음 코드와 같은 것 :</target>
        </trans-unit>
        <trans-unit id="b3604b8191e868952c41b5db9aece8f1eff7c961" translate="yes" xml:space="preserve">
          <source>Sometimes, you might want to pass results back to the caller, in which case you can check out the answer to the related question:</source>
          <target state="translated">때로는 결과를 발신자에게 다시 전달할 수도 있습니다.이 경우 관련 질문에 대한 답변을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bf3f8f69b932e3f1acbfc7c8959e44387c4888" translate="yes" xml:space="preserve">
          <source>Start Controller</source>
          <target state="translated">컨트롤러 시작</target>
        </trans-unit>
        <trans-unit id="f6dd8b657be24785f2abfdf37bda7351dd11294e" translate="yes" xml:space="preserve">
          <source>The EventBus is a simple but powerful publish/subscribe API with annotations that allows POJOs to communicate with each other anywhere in a JVM without having to refer to each other.</source>
          <target state="translated">EventBus는 POJO가 서로 참조하지 않고도 JVM의 어느 곳에서나 서로 통신 할 수 있도록하는 주석이있는 단순하지만 강력한 발행 / 구독 API입니다.</target>
        </trans-unit>
        <trans-unit id="3f68fe9dd740f7622f2cddb0f86cb6d332806bb7" translate="yes" xml:space="preserve">
          <source>The code itself is also commented with some details of what is happening and how.</source>
          <target state="translated">또한 코드 자체에는 무슨 일이 일어나고 있는지에 대한 몇 가지 세부 사항이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7ee052192384333cece7c842a928f8c8c68c625" translate="yes" xml:space="preserve">
          <source>The first scene contains a &lt;code&gt;TextField&lt;/code&gt;, a &lt;code&gt;Button&lt;/code&gt;, and a &lt;code&gt;Label&lt;/code&gt;. When the &lt;code&gt;Button&lt;/code&gt; is clicked, the second window is loaded and displayed, including the text entered in the &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">첫 번째 장면에는 &lt;code&gt;TextField&lt;/code&gt; , &lt;code&gt;Button&lt;/code&gt; 및 &lt;code&gt;Label&lt;/code&gt; 이 있습니다. &lt;code&gt;Button&lt;/code&gt; 을 클릭하면 &lt;code&gt;TextField&lt;/code&gt; 에 입력 한 텍스트를 포함하여 두 번째 창이로드되어 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e89b675bd57745459f9012d978836ee4fed7f3ef" translate="yes" xml:space="preserve">
          <source>The question of how to do it &quot;The Spring Boot Way&quot;, there was a discussion about JavaFX 2, which I anserwered in the attached permalink.
The approach is still valid and tested in March 2016, on Spring Boot v1.3.3.RELEASE:
&lt;a href=&quot;https://stackoverflow.com/a/36310391/1281217&quot;&gt;https://stackoverflow.com/a/36310391/1281217&lt;/a&gt;</source>
          <target state="translated">&quot;The Spring Boot Way&quot;를 수행하는 방법에 대한 질문에 JavaFX 2에 대한 토론이있었습니다. 이 접근 방식은 2016 년 3 월 Spring Boot v1.3.3에서 여전히 유효하고 테스트되었습니다 .RELEASE : &lt;a href=&quot;https://stackoverflow.com/a/36310391/1281217&quot;&gt;https://stackoverflow.com/a/36310391/1281217&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="82e3482bcddbb09c5152d3becc5b72853aaab86e" translate="yes" xml:space="preserve">
          <source>Then call the method in the initialize method:</source>
          <target state="translated">그런 다음 initialize 메소드에서 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="695e286da54461134d0ffb2e93585086866574c4" translate="yes" xml:space="preserve">
          <source>Then in the second one declare a client, then at the bottom of your controller:</source>
          <target state="translated">그런 다음 두 번째 클라이언트에서 클라이언트를 선언 한 다음 컨트롤러 하단에서 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="c99fc6dd617a6cc2b70c852b05036d5464e823f3" translate="yes" xml:space="preserve">
          <source>This answer enumerates different mechanisms for passing parameters to FXML controllers.</source>
          <target state="translated">이 답변은 FXML 컨트롤러에 매개 변수를 전달하기위한 다양한 메커니즘을 열거합니다.</target>
        </trans-unit>
        <trans-unit id="4c574944de10a90935170be07d6274d1b56596f9" translate="yes" xml:space="preserve">
          <source>This blog (by another writer) provides an alternate, but similar, &lt;a href=&quot;https://web.archive.org/web/20160612045146/http://ed4becky.net/homepage/javafx-from-the-trenches-singleton-controllers/&quot;&gt;example&lt;/a&gt;.</source>
          <target state="translated">이 블로그 (다른 작가의)는 대안이지만 유사한 &lt;a href=&quot;https://web.archive.org/web/20160612045146/http://ed4becky.net/homepage/javafx-from-the-trenches-singleton-controllers/&quot;&gt;예제를 제공&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d3f64e1b7d926162d53189f69a231b6f11f696f3" translate="yes" xml:space="preserve">
          <source>This is a very simple demonstration and could surely stand for some improvement, but should make the concept very clear.</source>
          <target state="translated">이것은 매우 간단한 시연이며 일부 개선의 여지가 있지만 개념을 매우 명확하게 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="58ff871b6a93ce45b14af622b058f94e1d743f85" translate="yes" xml:space="preserve">
          <source>This method is exemplified by Sergey's answer to &lt;a href=&quot;https://stackoverflow.com/a/10136403/1155209&quot;&gt;Javafx 2.0 How-to Application.getParameters() in a Controller.java file&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;https://stackoverflow.com/a/10136403/1155209&quot;&gt;Controller.java 파일의 Javafx 2.0 How-to Application.getParameters ()에 대한&lt;/a&gt; Sergey의 답변으로 예시됩니다.</target>
        </trans-unit>
        <trans-unit id="e294a3637e40ee80112353a36d3e686c77f1a9e1" translate="yes" xml:space="preserve">
          <source>Upon entering text in the second scene's &lt;code&gt;TextField&lt;/code&gt; and clicking its &lt;code&gt;Button&lt;/code&gt;, the first scene's &lt;code&gt;Label&lt;/code&gt; is updated to show the entered text.</source>
          <target state="translated">두 번째 장면의 &lt;code&gt;TextField&lt;/code&gt; 에 텍스트를 입력하고 &lt;code&gt;Button&lt;/code&gt; 을 클릭하면 첫 번째 장면의 &lt;code&gt;Label&lt;/code&gt; 이 업데이트되어 입력 한 텍스트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e604afe2fab7851c738baa0703aa593c489afa8c" translate="yes" xml:space="preserve">
          <source>We said three because we will navigate between three (window, form or page) and use the concept of static variables to pass data around the (window, form or page)</source>
          <target state="translated">우리는 3 개 (윈도우, 폼 또는 페이지) 사이를 탐색하고 정적 변수 개념을 사용하여 (윈도우, 폼 또는 페이지) 주위에 데이터를 전달하기 때문에 3이라고 말했습니다.</target>
        </trans-unit>
        <trans-unit id="db0a1b80667c8c0c7309198ff7e02cb67949b61e" translate="yes" xml:space="preserve">
          <source>We will also include some decision making code while we navigate</source>
          <target state="translated">탐색하는 동안 의사 결정 코드도 포함시킬 것입니다</target>
        </trans-unit>
        <trans-unit id="786077af3bc091aedfb5ac41432ace630b739b49" translate="yes" xml:space="preserve">
          <source>Which you could use to add your info to the Node.</source>
          <target state="translated">노드에 정보를 추가하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17f368fb0c189ac7c03d30500a3d69c00c1c9daa" translate="yes" xml:space="preserve">
          <source>While most of the answers here provide good to excellent examples how to accomplish this we thought we would kick it up a notch or two or three</source>
          <target state="translated">여기에있는 대부분의 답변은이를 달성하는 방법에 대한 훌륭한 예를 제공하지만 우리는 그것을 한두 가지로 삼을 것이라고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="2aa783067aecb401bbd1b4f477cbd87034b29b91" translate="yes" xml:space="preserve">
          <source>Why answer a 6 year old question ?</source>
          <target state="translated">왜 6 살짜리 질문에 대답합니까?</target>
        </trans-unit>
        <trans-unit id="c1eb36ced7883a452884956390912cc17ae8f088" translate="yes" xml:space="preserve">
          <source>Within the second scene, there is also a &lt;code&gt;TextField&lt;/code&gt;, a &lt;code&gt;Button&lt;/code&gt;, and a &lt;code&gt;Label&lt;/code&gt;. The &lt;code&gt;Label&lt;/code&gt; will display the text entered in the &lt;code&gt;TextField&lt;/code&gt; on the first scene.</source>
          <target state="translated">두 번째 장면에는 &lt;code&gt;TextField&lt;/code&gt; , &lt;code&gt;Button&lt;/code&gt; 및 &lt;code&gt;Label&lt;/code&gt; 도 있습니다. &lt;code&gt;Label&lt;/code&gt; 은 첫 번째 장면에서 &lt;code&gt;TextField&lt;/code&gt; 에 입력 한 텍스트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="921894831c197b9dfa4a8f25ac6ebda5487c7680" translate="yes" xml:space="preserve">
          <source>Yes you can.</source>
          <target state="translated">그래 넌 할수있어.</target>
        </trans-unit>
        <trans-unit id="73b530ca384585cc2ac29282203c5ad1b15c177c" translate="yes" xml:space="preserve">
          <source>You can construct a new controller in code, passing any parameters you want from your caller into the controller constructor.  Once you have constructed a controller, you can set it on an FXMLLoader instance &lt;em&gt;before&lt;/em&gt; you invoke the &lt;code&gt;load()&lt;/code&gt;&lt;em&gt;instance&lt;/em&gt; method.</source>
          <target state="translated">호출자에서 원하는 매개 변수를 컨트롤러 생성자로 전달하여 코드로 새 컨트롤러를 구성 할 수 있습니다. 컨트롤러를 구성한 후에는 &lt;code&gt;load()&lt;/code&gt; &lt;em&gt;인스턴스&lt;/em&gt; 메서드를 호출 &lt;em&gt;하기 전에&lt;/em&gt; FXMLLoader 인스턴스에서 컨트롤러를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ead7a6dc421901bccc6c7ac969a9dde19578f7d" translate="yes" xml:space="preserve">
          <source>You can decide to use a public observable list to store public data, or just create a public setter method to store data and retrieve from the corresponding controller</source>
          <target state="translated">공개 관찰 가능 목록을 사용하여 공개 데이터를 저장하거나 공개 설정 기 메소드를 작성하여 데이터를 저장하고 해당 제어기에서 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd8769e54975ae4d90bfc3d0d1dd8e004a1eea0" translate="yes" xml:space="preserve">
          <source>You have to create one Context Class.</source>
          <target state="translated">하나의 컨텍스트 클래스를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f81053bd7041eb7c1619453fa02334681231969" translate="yes" xml:space="preserve">
          <source>You have to just set instance of controller in initialization using</source>
          <target state="translated">초기화를 사용하여 컨트롤러 인스턴스를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0ccfe1fd7d9afe28f79a42585f7ea2c363af919" translate="yes" xml:space="preserve">
          <source>You need to add in the first controller:</source>
          <target state="translated">첫 번째 컨트롤러를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed7bd1e5f4ebf3feafa43f27540f8e76a6da6195" translate="yes" xml:space="preserve">
          <source>and you can use it from your whole application just using</source>
          <target state="translated">그리고 당신은 그것을 사용하여 전체 응용 프로그램에서 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="488628eb4fb22f92bb0121af1c4d3873d629e952" translate="yes" xml:space="preserve">
          <source>javafx.scene.Node class has a pair of methods 
setUserData(Object)
 and 
Object getUserData()</source>
          <target state="translated">javafx.scene.Node 클래스에는 setUserData (Object) 및 Object getUserData () 메소드 쌍이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbd8c0d44e3b021ea295bd918cd65c9c5e691e93" translate="yes" xml:space="preserve">
          <source>on first method, why do you return Stage? The method can be void as well because you already giving the command show(); just before return stage;. How do you plan usage by returning the Stage</source>
          <target state="translated">첫 번째 방법에서는 왜 Stage를 반환합니까? show () 명령을 이미 제공했기 때문에이 메소드도 무효가 될 수 있습니다. 귀국 바로 전에;. 스테이지를 반환하여 사용을 계획하는 방법</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
