<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/14415881">
    <body>
      <group id="14415881">
        <trans-unit id="94c0dfc6b17aa37cab713289ff046437e179508f" translate="yes" xml:space="preserve">
          <source>&quot;if s pairs with a sock t in N&quot;.  How quickly can we &quot;remember&quot; what we've seen so far?</source>
          <target state="translated">&quot;如果s与N中的sock t配对&quot;。我们如何快速 &quot;记住 &quot;到目前为止所看到的东西?</target>
        </trans-unit>
        <trans-unit id="b5bdc0f37905c659679678b282a51daad6b30c24" translate="yes" xml:space="preserve">
          <source>&quot;remove t from N&quot; and &quot;add s to N&quot;.  How expensive is keeping track of what we've seen so far?</source>
          <target state="translated">&quot;从N中删除t &quot;和 &quot;向N中添加s&quot;。追踪到现在为止,我们看到的东西有多贵?</target>
        </trans-unit>
        <trans-unit id="257027605f38139d5816c62c3274fa0db3930e71" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;This approach can be fairly easily be implemented in an array, assuming that &quot;removing&quot; socks is an option.&lt;/s&gt; Actually, you don't even need to &quot;remove&quot; socks. If you don't need sorting of the socks (see below), then you can just move them around and end up with an array that has all the socks arranged in pairs in the array.</source>
          <target state="translated">&lt;s&gt;假设&amp;ldquo;移除&amp;rdquo;袜子是一种选择，则可以很容易地在阵列中实施此方法。&lt;/s&gt; 实际上，您甚至不需要&amp;ldquo;去除&amp;rdquo;袜子。 如果不需要对袜子进行排序（请参阅下文），则只需将它们四处移动即可得到一个数组，该数组将所有袜子成对排列。</target>
        </trans-unit>
        <trans-unit id="6fae469126cdfe9fb170ccabec0390cf8682c501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Heuristic:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Heuristic:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8be3cb9316f7f1176c171daf3e0ce96f2978c5e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithmic answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;算法答案：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6dd89168d13c44609bd0eb1bed16428f8b39446" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BTW&lt;/strong&gt;, I found that the sum of the transaction costs of sorting all the socks every time I needed a pair were far less than doing it once and binding the socks. A just-in-time works better because then you don't have to bind the socks, and there's also a diminishing marginal return (that is, you keep looking for that two or three socks that when somewhere in the laundry and that you need to finish matching your socks and you lose time on that).</source>
          <target state="translated">&lt;strong&gt;顺便说一句&lt;/strong&gt; ，我发现每次我需要一双袜子时对所有袜子进行分类的交易成本总和要比一次绑定袜子要少得多。 即时作业会更好，因为这样您就不必束缚袜子了，边际收益也会递减（也就是说，您一直在寻找两三只袜子，当它们放在洗衣房中的某个地方时，您需要完成与袜子的匹配，您会浪费时间）。</target>
        </trans-unit>
        <trans-unit id="2b5ac05a4a642e4eaddf91d074d8a86d8f9607d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1&lt;/strong&gt;: All socks are identical (this is what I do in real life by the way).</source>
          <target state="translated">&lt;strong&gt;情况1&lt;/strong&gt; ：所有袜子都是一样的（顺便说一句，这是我在现实生活中所做的）。</target>
        </trans-unit>
        <trans-unit id="49a8a493d307384ee45499ab7676db0d67425182" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2&lt;/strong&gt;: There are a constant number of combinations (ownership, color, size, texture, etc.).</source>
          <target state="translated">&lt;strong&gt;情况2&lt;/strong&gt; ：组合数量不变（所有权，颜色，大小，纹理等）。</target>
        </trans-unit>
        <trans-unit id="e00424d21a9c0392d4676ab7c8a9295c1d65c888" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 3&lt;/strong&gt;: The number of combinations is not known in advance (general case).</source>
          <target state="translated">&lt;strong&gt;情况3&lt;/strong&gt; ：事先不知道组合的数量（一般情况）。</target>
        </trans-unit>
        <trans-unit id="0b50c6f3b067c6fae56c03d06a7d861b64518113" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-algorithmic answer, yet &quot;efficient&quot; when I do it:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;非算法答案，但在执行时却&amp;ldquo;有效&amp;rdquo;：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f1ed3b5cf07fad91eb01fcb7a682e9e1f3420c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional&lt;/strong&gt; While you are searching the line and and the current sock you are looking at is identical to the previous, do step 2 for these socks.</source>
          <target state="translated">&lt;strong&gt;可选&lt;/strong&gt;在搜索线时，并且您正在查看的当前袜子与前面的袜子相同，请对这些袜子执行步骤2。</target>
        </trans-unit>
        <trans-unit id="4e7b1dad68f6cce31ec46db04710d5118a2d7aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preconditions:&lt;/strong&gt;
There is no guarantee that there are the same socks. If they are of the same color it doesn't mean they have the same size or pattern. Socks are randomly shuffled. There can be odd number of socks (some are missing, we don't know how many). Prepare to remember a variable &quot;index&quot; and set it to 0.</source>
          <target state="translated">&lt;strong&gt;前提：&lt;/strong&gt;不能保证有相同的袜子。 如果它们具有相同的颜色，并不表示它们具有相同的大小或图案。 袜子随机洗净。 袜子的数量可能是奇数（有些袜子缺失，我们不知道有多少）。 准备记住一个变量&amp;ldquo;索引&amp;rdquo;并将其设置为0。</target>
        </trans-unit>
        <trans-unit id="e8d739a374e59173c2a911ac09bb3cfac524d27d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recursively apply this scheme&lt;/strong&gt; until you have distributed all socks onto &lt;strong&gt;very small piles that you can visually process immediately&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;递归应用此方案，&lt;/strong&gt;直到将所有袜子分配到&lt;strong&gt;很小的绒头上，然后即可立即进行视觉处理&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b4b7ec4098550470ed2c4636c449a2c24d32ee0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, the question is basically:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;因此，问题基本上是：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08fda84558211c3c93b54ebc0219bb815255b9af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1:&lt;/strong&gt; Each time you put dirty socks in your laundry basket, tie them in a little knot. That way you will not have to do any sorting after the washing. Think of it like registering an index in a Mongo database. A little work ahead for some CPU savings in the future.</source>
          <target state="translated">&lt;strong&gt;解决方案1：&lt;/strong&gt;每次将脏袜子放在洗衣篮中时，都要打个小结。 这样，您将无需在清洗后进行任何分类。 可以将其视为在Mongo数据库中注册索引。 未来需要做一些工作以节省一些CPU。</target>
        </trans-unit>
        <trans-unit id="b93e25b8a424a36b38ce0b2f666db17b4cec3ad9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2:&lt;/strong&gt; If it's winter, you don't have to wear matching socks. We are programmers. Nobody needs to know, as long as it works.</source>
          <target state="translated">&lt;strong&gt;解决方案2：&lt;/strong&gt;如果是冬天，则不必穿配套的袜子。 我们是程序员。 只要有效，就没人需要知道。</target>
        </trans-unit>
        <trans-unit id="0094560f52b8dad6f4ad715c3c000c707e442bb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 3:&lt;/strong&gt; Spread the work. You want to perform such a complex CPU process asynchronously, without blocking the UI. Take that pile of socks and stuff them in a bag. Only look for a pair when you need it. That way the amount of work it takes is much less noticeable.</source>
          <target state="translated">&lt;strong&gt;解决方案3：&lt;/strong&gt;传播工作。 您想异步执行这样一个复杂的CPU进程，而又不会阻塞UI。 把那堆袜子塞进袋子里。 仅在需要时寻找一对。 这样，所需的工作量就不那么明显了。</target>
        </trans-unit>
        <trans-unit id="cd64c3cf6ffd817f997a05ddde37296211310d6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result&lt;/strong&gt; will have one or two piles: 1. &quot;matched&quot; and 2. &quot;missing&quot;</source>
          <target state="translated">&lt;strong&gt;结果&lt;/strong&gt;将有一堆或两堆：1.&amp;ldquo;匹配&amp;rdquo;和2.&amp;ldquo;缺失&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="1873002ca8758724d2c9adf28e13baa534b32d50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are trying to solve the wrong problem.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;您正在尝试解决错误的问题。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42553619c0d4d907f8c4939e4417b4728dc4eff8" translate="yes" xml:space="preserve">
          <source>A general &lt;em&gt;theoretical&lt;/em&gt; solution for a huge number of socks.</source>
          <target state="translated">大量袜子的一般&lt;em&gt;理论&lt;/em&gt;解决方案。</target>
        </trans-unit>
        <trans-unit id="86619e9b5473c8436c88e4580124cac4300c7011" translate="yes" xml:space="preserve">
          <source>A neat freak might use numeric labels for pairs as someone suggested.  This opens the door to a total ordering, which allows the human to use exactly the same algorithms we might with a CPU: binary search, trees, hashes, etc.</source>
          <target state="translated">一个整洁的怪胎可能会像有人建议的那样,用数字标签来表示数据对。这就打开了总排序的大门,使人类可以使用与CPU完全相同的算法:二进制搜索、树、哈希等。</target>
        </trans-unit>
        <trans-unit id="e2b68ea4fb20ff8e31763199ca38f49c47f03983" translate="yes" xml:space="preserve">
          <source>About parallelism:
As long as you toss both socks into the same bin, you can easily parallelize all of those steps.</source>
          <target state="translated">关于并行化。只要把两只袜子都扔到同一个垃圾桶里,就可以轻松地把这些步骤都平行起来。</target>
        </trans-unit>
        <trans-unit id="f6fc8d26eb16b2c7196aa947f223e3e3ed467028" translate="yes" xml:space="preserve">
          <source>After eliminating the fluro coloured, the socks with stripes, and the three pairs of long socks, you might end up with mostly white socks roughly sorted by how worn they are.</source>
          <target state="translated">剔除掉荧光色、带条纹的袜子和三双长筒袜后,你可能会发现大部分的白色袜子都是按磨损程度来排序的。</target>
        </trans-unit>
        <trans-unit id="98f0ebf5e1f426f9d4fb354b2d2f98129af56fdf" translate="yes" xml:space="preserve">
          <source>After that, there are only a few socks left. This is where I introduce previously unpaired socks into the system and process the remaining socks without any special algorithm - the remaining socks are very few and can be processed visually very fast.</source>
          <target state="translated">之后,就只剩下几只袜子了。这时,我就把之前未配对的袜子引入系统中,对剩下的袜子进行处理,不需要任何特殊的算法--剩下的袜子非常少,视觉上可以快速处理。</target>
        </trans-unit>
        <trans-unit id="f910680ab39d0aa8398bce15b13e098f9be2e9a8" translate="yes" xml:space="preserve">
          <source>After this, it's easy to do the hash partitioning algorithm. Usually, about 75% of the socks are already paired, leaving me with a very small subset of socks, and this subset is already (somewhat) clustered (I don't introduce much entropy into my basket after the preprocessing steps). Another thing is that the remaining clusters tend to be small enough to be handled at once, so it is possible to take a whole cluster out of the basket.</source>
          <target state="translated">做完这些,就很容易进行哈希分区算法了。通常情况下,大约75%的袜子已经配对好了,留给我的袜子子集非常小,而且这个子集已经(有点)聚类了(预处理步骤后,我不会给我的篮子引入太多的熵)。还有一点是,剩下的簇子集往往足够小,可以一次性处理,所以可以把整个簇子集从篮子里拿出来。</target>
        </trans-unit>
        <trans-unit id="a610a16cc6741362976a74534a8c23c401cdcb8f" translate="yes" xml:space="preserve">
          <source>Almost all the other algorithms (including &lt;a href=&quot;https://stackoverflow.com/a/14419556/1042311&quot;&gt;the top scoring answer by usr&lt;/a&gt;) sort, then remove pairs. I find that, as a human, it is better to minimize the number of socks being considered at one time.</source>
          <target state="translated">几乎所有其他算法（包括&lt;a href=&quot;https://stackoverflow.com/a/14419556/1042311&quot;&gt;usr得分最高的答案&lt;/a&gt; ）进行排序，然后删除对。 我发现，作为一个人，最好一次减少所考虑的袜子数量。</target>
        </trans-unit>
        <trans-unit id="eccc8c5a89378f08c10b8d673e29520d1e8e7126" translate="yes" xml:space="preserve">
          <source>Also, there could be added check for damaged socks also, as if the removal of those. It could be inserted between 2 and 3, and between 13 and 14.</source>
          <target state="translated">此外,还可以添加检查损坏的袜子也,如果删除这些。它可以在2和3之间,13和14之间插入。</target>
        </trans-unit>
        <trans-unit id="9788a20dd94a5a2bf372d767d6027859c72d11c2" translate="yes" xml:space="preserve">
          <source>Also, we don't need to assume a large number of socks, even for large families. Socks are taken out of the drawer and are worn, and then they are tossed in a place (maybe a bin) where they stay before being laundered. While I wouldn't call said bin a LIFO-Stack, I'd say it is safe to assume that</source>
          <target state="translated">另外,我们不需要承担大量的袜子,即使是大户人家也不需要。袜子从抽屉里拿出来,穿上之后,会被扔到一个地方(也许是一个垃圾桶)里,在洗衣服之前,袜子会在那里停留。虽然我不会把这个垃圾桶称为LIFO-Stack,但我认为可以这么认为。</target>
        </trans-unit>
        <trans-unit id="157fc609ec55f17f263d7a3a005a4071e377c228" translate="yes" xml:space="preserve">
          <source>Although the outputs are not exactly the same (in one case, just a boolean. In the other case, the pairs of socks), the asymptotic complexities are the same.</source>
          <target state="translated">虽然输出不完全相同(在一种情况下,只是一个布尔,在另一种情况下,是一对袜子),但近似复杂度是一样的。</target>
        </trans-unit>
        <trans-unit id="05e0d0df0a6446265996f77e214ab1168f512228" translate="yes" xml:space="preserve">
          <source>An alternative step 3 would involve comparing costs of buying the same amount of perhaps cheaper socks a few pairs at a time over the years and adding the cost of sorting socks, but take my word for it: buying in bulk is cheaper! Also, socks in storage increase in value at the rate of stock price inflation, which is more than you would get on many investments. Then again there is also storage cost, but socks really do not take much space on the top shelf of a closet.</source>
          <target state="translated">另一个步骤3会涉及到比较多年来一次买同样数量的也许更便宜的袜子,再加上分拣袜子的成本,但请相信我的话:大宗购买会更便宜!这也是我的一个建议。另外,储存中的袜子的价值会随着股票价格的上涨而增加,这比你在很多投资中得到的收益要多。再有就是储存成本也是有的,但是袜子真的不占用衣柜顶层的空间。</target>
        </trans-unit>
        <trans-unit id="3835c018ca31a4eabdd14cc9d36b8f5e0b2ee808" translate="yes" xml:space="preserve">
          <source>An obvious algorithm for sock sorting is:</source>
          <target state="translated">袜子分类的一个明显的算法是。</target>
        </trans-unit>
        <trans-unit id="56b599442bccb5b5949e6ad41c70544a44257d97" translate="yes" xml:space="preserve">
          <source>And more often than not, this is not just &lt;em&gt;any&lt;/em&gt; free time, it's &lt;em&gt;morning&lt;/em&gt; free time, which you could be spending in bed, or sipping your coffee, or leaving a bit early and not being caught in the traffic.</source>
          <target state="translated">而且，这不仅是&lt;em&gt;任何&lt;/em&gt;空闲时间，更是&lt;em&gt;早上的&lt;/em&gt;空闲时间，您可能会在床上度过，喝咖啡或早点离开而不会被交通堵塞。</target>
        </trans-unit>
        <trans-unit id="121979168ac388fe182e793a8f415d4c02e0bcfd" translate="yes" xml:space="preserve">
          <source>And there is a way!</source>
          <target state="translated">而且有办法了!</target>
        </trans-unit>
        <trans-unit id="aaed1a26327f668180ed38055a98d2f4a897c097" translate="yes" xml:space="preserve">
          <source>Applying the same idea to the practical problem of pairing socks, the apparent answer is: don't allow your socks to ever be unpaired. Socks are provided as a pair, put in the drawer as a pair (perhaps by balling them together), worn as a pair. But the point where unpairing is possible is in the washer, so all that's required is a physical mechanism that allows the socks to stay together and be washed efficiently.</source>
          <target state="translated">把同样的想法套用到袜子的实际搭配问题上,显然答案是:不要让你的袜子永远不配对。袜子是作为一双提供的,把袜子当做一双,放进抽屉里(也许是用球状的方式),当做一双穿。但可以解开配对的地方是在洗衣机里,所以只需要有一个物理机制,让袜子能保持在一起,有效地清洗就可以了。</target>
        </trans-unit>
        <trans-unit id="4447172c03cd07d366eaa6901d47c0105462f432" translate="yes" xml:space="preserve">
          <source>As a computer scientist I was thinking what I could do? Sorting (according to size/color/...) of course came to mind to achieve an O(NlogN) solution.</source>
          <target state="translated">作为一个计算机科学家,我在想,我能做什么?当然想到了排序(根据sizecolor...........)来实现O(NlogN)的解决方案。</target>
        </trans-unit>
        <trans-unit id="dea5f13104d5d8bafb26f6f1728af7ebead57e19" translate="yes" xml:space="preserve">
          <source>As a practical solution:</source>
          <target state="translated">作为一个实际的解决方案。</target>
        </trans-unit>
        <trans-unit id="0330f3b9f6b91d26ecc04e1313146ad77b320f18" translate="yes" xml:space="preserve">
          <source>As rapidly as possible, remove socks from the unsorted pile one at a time and place in piles in front of you. The piles should be arranged somewhat space-efficiently, with all socks pointing the same direction; the number of piles is limited by the distance you can easily reach. The selection of a pile on which to put a sock should be -- as rapidly as possible -- by putting a sock on a pile of apparently like socks; the occasional type I (putting a sock on a pile it doesn't belong to) or type II (putting a sock in its own pile when there's an existing pile of like socks) error can be tolerated -- the most important consideration is &lt;em&gt;speed&lt;/em&gt;. Once all the socks are in piles, rapidly go through the multi-sock piles creating pairs and removing them (these are heading for the drawer). If there are non-matching socks in the pile, re-pile them to their best (within the as-fast-as-possible constraint) pile. When all the multi-sock piles have been processed, match up remaining pairable socks that weren't paired due to type II errors. Whoosh, you're done -- and I have a lot of socks and don't wash them until a large fraction are dirty. Another practical note: I flip the top of one of a pair of socks down over the other, taking advantage of their elastic properties, so they stay together while being transported to the drawer and while in the drawer.</source>
          <target state="translated">尽快将袜子从未分类的绒头中一次取出，并成堆放置在您面前。 绒头应以节省空间的方式排列，所有的袜子都指向相同的方向。 桩数受您可以轻松到达的距离的限制。 应该（尽可能快地）选择袜子放在上面的一堆，方法是将袜子放在看上去像袜子的那堆上； 可以容忍偶然的I型（将袜子放在不属于它的堆上）或II型（在已有一堆类似袜子的情况下将袜子放入自己的堆中）错误-最重要的考虑因素是&lt;em&gt;速度&lt;/em&gt; 。 一旦所有袜子都堆成一堆，迅速穿过多袜子堆，创建成对并取下它们（这些都将移向抽屉）。 如果桩中有不匹配的袜子，请将其重新堆放到最佳状态（在尽可能快的约束内）。 处理完所有的多袜袜子后，将剩余的可配对袜子配对，这些袜子由于II型错误而没有配对。 糟糕，您已经完成了-我的袜子很多，在很大一部分脏掉之前不要洗它们。 另一个实用注意事项：我利用它们的弹性特性，将一对袜子中的一个的顶部向下翻转，使它们在运输到抽屉中和在抽屉中时保持在一起。</target>
        </trans-unit>
        <trans-unit id="21c82dc8d9601ae12e034b45a03f0358de859eb2" translate="yes" xml:space="preserve">
          <source>As the architecture of the human brain is completely different than a modern CPU, this question makes no practical sense.</source>
          <target state="translated">由于人脑的架构与现代CPU完全不同,这个问题没有实际意义。</target>
        </trans-unit>
        <trans-unit id="c9da0c9b1a26a80303bb8c443c01afa8a2584687" translate="yes" xml:space="preserve">
          <source>Assuming that the only operation for socks is to compare for equality, this algorithm is basically still an n&lt;sup&gt;2&lt;/sup&gt; algorithm, though I don't know about the average case (never learned to calculate that).</source>
          <target state="translated">假设袜子的唯一操作是比较是否相等，该算法基本上仍是n &lt;sup&gt;2&lt;/sup&gt;算法，尽管我不了解平均情况（从未学习过计算方法）。</target>
        </trans-unit>
        <trans-unit id="9ecfa67dfd0923fad315f8a06acb48f7f0237861" translate="yes" xml:space="preserve">
          <source>At least this is what I am using in real life, and I find it very efficient. The downside is it requires a flat surface, but it's usually abundant.</source>
          <target state="translated">至少我在现实生活中就是这么用的,我觉得效率很高。缺点是它需要一个平坦的表面,但通常情况下是很丰富的。</target>
        </trans-unit>
        <trans-unit id="5b86498f0344f03ab782a1075a31f259917a9553" translate="yes" xml:space="preserve">
          <source>At some point, the differences between socks are small enough that other people won't notice the difference, and any further matching effort is not needed.</source>
          <target state="translated">在某些时候,袜子之间的差异已经小到别人不会注意到的程度,不需要再做任何搭配的努力。</target>
        </trans-unit>
        <trans-unit id="7e52e0e243840d708880946b6c4315d013367de6" translate="yes" xml:space="preserve">
          <source>But for each sock to keep a reference to the other, there is a neat solution: a popper (or a 'snap button' if you're American), such as these:</source>
          <target state="translated">但是,为了让每只袜子都能与对方保持一个参照物,有一个整齐的解决方案:一个弹出器(如果你是美国人的话,可以用 &quot;卡扣&quot;),比如这些。</target>
        </trans-unit>
        <trans-unit id="b59dc09b425cf2a04ad8751ed78176abb3f57590" translate="yes" xml:space="preserve">
          <source>By pulling the distinctive socks first, you leave space to &quot;zoom&quot; in on the features which are less distinctive, to begin with.</source>
          <target state="translated">先拉开有特色的袜子,就可以留出空间来 &quot;放大 &quot;那些不那么有特色的特征,一开始就可以。</target>
        </trans-unit>
        <trans-unit id="325f07a647449aca13d04b404d5077e42950128f" translate="yes" xml:space="preserve">
          <source>By reducing my inputs to one of two types of socks (white socks for recreation, black socks for work), I only need to determine which of two socks I have in hand. (Technically, since they are never washed together, I have reduced the process to O(0) time)</source>
          <target state="translated">通过将我的投入减少到两种袜子中的一种(白袜用于娱乐,黑袜用于工作),我只需要确定我手中的两只袜子中的哪一只。严格来说,由于它们从来没有一起洗过,所以我把这个过程缩短为O(0)时间</target>
        </trans-unit>
        <trans-unit id="839d4561e5360dfca7e45fa2801c421ef3ca26fb" translate="yes" xml:space="preserve">
          <source>Choose one of the socks and put it away (create a 'bucket' for that pair)</source>
          <target state="translated">选择一双袜子,然后把它放好(为那一双袜子建立一个 &quot;桶&quot;)。</target>
        </trans-unit>
        <trans-unit id="5d6b924144b70d6a90942c0979240ccaa91f1233" translate="yes" xml:space="preserve">
          <source>Clearly, one cannot go faster than &lt;code&gt;O(N)&lt;/code&gt;, so we have reached the &lt;strong&gt;optimal lower bound&lt;/strong&gt;.</source>
          <target state="translated">显然，不能比 &lt;code&gt;O(N)&lt;/code&gt; 快，所以我们已经达到了&lt;strong&gt;最佳下限&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a74f91f894f5fdd53f2126400da6be5bbf36590" translate="yes" xml:space="preserve">
          <source>Combine with Other Task</source>
          <target state="translated">与其他任务相结合</target>
        </trans-unit>
        <trans-unit id="8ac6a3ace758bdb634f5dc66fbca8858d699c4a7" translate="yes" xml:space="preserve">
          <source>Consider a hash-table of  size  'N'.</source>
          <target state="translated">考虑一个大小为 &quot;N &quot;的哈希表。</target>
        </trans-unit>
        <trans-unit id="be4d36fcb52cd8affab669c9c320903855e4dd53" translate="yes" xml:space="preserve">
          <source>Consider than if you draw only one sock for the second stack of socks, as you are doing, your odds of finding the matching sock in a naive search is quite low.</source>
          <target state="translated">考虑一下,如果你只抽到一只袜子的第二叠袜子,就像你正在做的那样,你在天真的搜索中找到匹配的袜子的几率是相当低的。</target>
        </trans-unit>
        <trans-unit id="f9b1944832d9453a7dc17748fdc3d9173cbd95c9" translate="yes" xml:space="preserve">
          <source>Cost: Moving socks -&amp;gt; high, finding/search socks in line -&amp;gt; small</source>
          <target state="translated">成本：运动袜-&amp;gt;高，排队寻找/搜索袜-&amp;gt;小</target>
        </trans-unit>
        <trans-unit id="05201805c52c192640e03bce4060ac08d6051851" translate="yes" xml:space="preserve">
          <source>Create a hash table which will be used for unmatched socks, using the pattern as the hash. Iterate over the socks one by one. If the sock has a pattern match in the hash table, take the sock out of the table and make a pair. If the sock does not have a match, put it into the table.</source>
          <target state="translated">创建一个哈希表,用图案作为哈希表,用于未匹配的袜子。对袜子进行逐一迭代。如果袜子在哈希表中有匹配的图案,就把袜子从表中取出来,然后进行配对。如果袜子没有匹配,就把它放进桌子里。</target>
        </trans-unit>
        <trans-unit id="ece5b7e4f44f0c60b7df2b4d7656e3eb3246bbfd" translate="yes" xml:space="preserve">
          <source>Do until A is empty.</source>
          <target state="translated">做到A是空的为止。</target>
        </trans-unit>
        <trans-unit id="a3af62234185a8fbf95199db3ed4496b2e1b062b" translate="yes" xml:space="preserve">
          <source>Do until both X and Y is empty.</source>
          <target state="translated">做到X和Y都是空的为止。</target>
        </trans-unit>
        <trans-unit id="e74f486c764075c4dfed8abc5b9386d07590d29c" translate="yes" xml:space="preserve">
          <source>Don't waste your time moving socks around or looking for the best match, this all should be done in O(n), which we would also need for just putting them on the line unsorted.
The socks aren't paired yet, we only have several similarity clusters on the line. It's helpful that we have a limited set of socks here, as this helps us to create &quot;good&quot; clusters (for example, if there are only black socks in the set of socks, clustering by colours would not be the way to go)</source>
          <target state="translated">不要浪费时间把袜子搬来搬去,或者找最好的搭配,这一切应该都是在O(n)中完成的,这也是我们刚上线无排序的时候需要的。袜子还没有配对,我们只需要把几个相似性簇放在线上就可以了。在这里,我们有一个有限的袜子集是有帮助的,因为这有助于我们创建 &quot;好的 &quot;聚类(例如,如果袜子集中只有黑色的袜子,按颜色聚类就不是办法了</target>
        </trans-unit>
        <trans-unit id="e9b450d14bc2363d292c84f17cfad5cfbd58a458" translate="yes" xml:space="preserve">
          <source>Done</source>
          <target state="translated">Done</target>
        </trans-unit>
        <trans-unit id="9ec877009e8b5ea7edaecdf46b39cdf271ac5e08" translate="yes" xml:space="preserve">
          <source>Feel free to write down the formula to calculate how many samples you have to draw for a 50% odds of a match. IIRC it's an hypergeometric law.</source>
          <target state="translated">随意写下公式,计算出你要抽到多少个样本才能有50%的胜率。我想这是一个超几何定律。</target>
        </trans-unit>
        <trans-unit id="ee75e1685f87ca197f6c3aaaa97916949e86e0db" translate="yes" xml:space="preserve">
          <source>Find a pair by looking at the socks on the floor.</source>
          <target state="translated">通过看地板上的袜子,找到一双。</target>
        </trans-unit>
        <trans-unit id="2d7f4a781c3305161bd0ab2917bdad576999ed2c" translate="yes" xml:space="preserve">
          <source>Find a sock you like. Take all relevant features into account: colour in different lighting conditions, overall quality and durability, comfort in different climatic conditions, and odour absorption. Also important is, they should not lose elasticity in storage, so natural fabrics are good, and they should be available in a plastic wrapping.</source>
          <target state="translated">找到一款自己喜欢的袜子。要考虑到所有相关的特点:不同光照条件下的颜色、整体质量和耐用性、不同气候条件下的舒适度、吸味性。还有很重要的一点是,在储存过程中不能失去弹性,所以天然的面料为好,而且要有保鲜膜包装。</target>
        </trans-unit>
        <trans-unit id="a9a8d801aad71c6f999c991c92a663302901ccc9" translate="yes" xml:space="preserve">
          <source>Find all matched pairs, pack it and move packed pairs to &quot;matched&quot; pile;
 If there were no new matches - increment &quot;index&quot; by 1</source>
          <target state="translated">找到所有匹配的配对,将其打包,并将打包好的配对移动到 &quot;匹配的 &quot;堆中;如果没有新的匹配--将 &quot;索引 &quot;递增1</target>
        </trans-unit>
        <trans-unit id="52c3a2cfe2904b404c77eec5836501de1058b709" translate="yes" xml:space="preserve">
          <source>Find its match.</source>
          <target state="translated">找到它的匹配。</target>
        </trans-unit>
        <trans-unit id="c0a4340783c31b2ef43b6cdc9d203753e623f8c3" translate="yes" xml:space="preserve">
          <source>Find its pair</source>
          <target state="translated">查找其对</target>
        </trans-unit>
        <trans-unit id="9398e96bcda6ff722938ce7ced4416bbac5aa5f1" translate="yes" xml:space="preserve">
          <source>Find most distinctive sock.</source>
          <target state="translated">找到最有特色的袜子。</target>
        </trans-unit>
        <trans-unit id="82f8de3c35ca9b182c746b9a61ec6f2e62e7264c" translate="yes" xml:space="preserve">
          <source>First you can choose (hers, mine) - split them into 2 piles,</source>
          <target state="translated">首先你可以选择(她的,我的)--分成2堆。</target>
        </trans-unit>
        <trans-unit id="893e0080cad23ba3476d1e48d4706a557776aeeb" translate="yes" xml:space="preserve">
          <source>For a 'pair' object that keeps a pointer to each sock we could have a cloth bag that we use to keep the socks together. This seems like massive overhead.</source>
          <target state="translated">对于一个 &quot;pair &quot;对象,我们可以用一个布袋来保持每个袜子的指针。这似乎是一个巨大的开销。</target>
        </trans-unit>
        <trans-unit id="077ecc6cb20560a33edffb3287fdf7ac14426d24" translate="yes" xml:space="preserve">
          <source>For all remaining socks, I assume that their counterparts are still unwashed and put them away for the next iteration. If you register a growth of unpaired socks over time (a &quot;sock leak&quot;), you should check your bin - it might get randomized (do you have cats which sleep in there?)</source>
          <target state="translated">对于所有剩余的袜子,我假设它们的对应的袜子还没有洗干净,就把它们收起来,以便下一次迭代。如果随着时间的推移,你登记的未配对袜子的增长(&quot;袜子漏水&quot;),你应该检查你的垃圾箱--它可能会被随机化(你有猫咪在里面睡觉吗?</target>
        </trans-unit>
        <trans-unit id="cc92f3e9adf433b615dccfeb6da282fce4ea8901" translate="yes" xml:space="preserve">
          <source>For each color of socks, &lt;strong&gt;form a pile&lt;/strong&gt;. Iterate over all socks in your input basket &lt;strong&gt;and distribute them onto the color piles&lt;/strong&gt;.</source>
          <target state="translated">对于每种颜色的袜子， &lt;strong&gt;形成一堆&lt;/strong&gt; 。 遍历输入筐中的所有袜子&lt;strong&gt;并将它们分配到颜色堆上&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6414c797002dc91c1ae83eaf49240cdcbf24e18" translate="yes" xml:space="preserve">
          <source>For each line X and Y</source>
          <target state="translated">对于每行X和Y</target>
        </trans-unit>
        <trans-unit id="5855dab75f8b813fca7ffaa714ea108a4295227b" translate="yes" xml:space="preserve">
          <source>For the first sock, or if all previously-chosen socks have been paired, simply place the sock into the first &quot;slot&quot; of an &quot;array&quot; of unpaired socks in front of you.</source>
          <target state="translated">对于第一双袜子,或者如果之前选择的袜子都已经配对好了,只需将袜子放入你面前未配对的袜子 &quot;阵列 &quot;中的第一个 &quot;插槽&quot;。</target>
        </trans-unit>
        <trans-unit id="894192607ac808554f03c075fd0655a37e1ad671" translate="yes" xml:space="preserve">
          <source>For the following runtime analysis of pairing &lt;code&gt;n&lt;/code&gt; pairs of socks, we suppose that at least half of the &lt;code&gt;2n&lt;/code&gt; socks aren't hidden after step 1. So in the average case we can find &lt;code&gt;n/2&lt;/code&gt; pairs. This means that the loop is step 4 is executed &lt;code&gt;O(log n)&lt;/code&gt; times. Step 2 is executed &lt;code&gt;O(n^2)&lt;/code&gt; times. So we can conclude:</source>
          <target state="translated">对于下面的配对 &lt;code&gt;n&lt;/code&gt; 对袜子的运行时分析，我们假设 &lt;code&gt;2n&lt;/code&gt; 袜子中至少有一半在步骤1之后没有被隐藏。因此，在通常情况下，我们可以找到 &lt;code&gt;n/2&lt;/code&gt; 对袜子。 这意味着循环将步骤4执行 &lt;code&gt;O(log n)&lt;/code&gt; 次。 步骤2被执行 &lt;code&gt;O(n^2)&lt;/code&gt; 次。 因此我们可以得出以下结论：</target>
        </trans-unit>
        <trans-unit id="cd22dd03c04d34755de0454c107040828d993fa6" translate="yes" xml:space="preserve">
          <source>Forget &quot;index&quot;</source>
          <target state="translated">忘了 &quot;指数 &quot;吧</target>
        </trans-unit>
        <trans-unit id="754feeeb1411a93845cc30e2f433edcea6d8f1d0" translate="yes" xml:space="preserve">
          <source>From pile A of all socks:</source>
          <target state="translated">从所有袜子的A堆里</target>
        </trans-unit>
        <trans-unit id="88af6c6ae694d3f0adbd64981b429a7c2015afc5" translate="yes" xml:space="preserve">
          <source>From your question it is clear you don't have much actual experience with laundry :). You need an algorithm that works well with a small number of non-pairable socks.</source>
          <target state="translated">从你的问题中可以看出,你没有什么实际的洗衣经验:)。你需要一种算法,可以很好地处理少量的不可洗涤的袜子。</target>
        </trans-unit>
        <trans-unit id="0444a1d3195984e21f70709ff60bf0a46830a14e" translate="yes" xml:space="preserve">
          <source>Get rid of your old socks.</source>
          <target state="translated">脱掉你的旧袜子。</target>
        </trans-unit>
        <trans-unit id="a1a874f464be482c37caf7802d65a53aaacd038a" translate="yes" xml:space="preserve">
          <source>Given a pile of &lt;code&gt;n&lt;/code&gt; pairs of socks, containing &lt;code&gt;2n&lt;/code&gt; elements (assume each sock has exactly one matching pair), what is the best way to pair them up efficiently with up to logarithmic extra space? (I believe I can remember that amount of info if needed.)</source>
          <target state="translated">给定一堆 &lt;code&gt;n&lt;/code&gt; 对袜子，其中包含 &lt;code&gt;2n&lt;/code&gt; 个元素（假设每只袜子都具有一对完全匹配的袜子），最好的方法是将它们有效配对并具有对数的额外空间？ （我相信如果需要的话，我可以记住这么多信息。）</target>
        </trans-unit>
        <trans-unit id="92391b2bac5f63b1732ccf6a829b75982b2d6b4f" translate="yes" xml:space="preserve">
          <source>Go to 1</source>
          <target state="translated">转到1</target>
        </trans-unit>
        <trans-unit id="7548a76daeaf6efed0b0d32caeb5242aedd1b6ef" translate="yes" xml:space="preserve">
          <source>Grab a sock at random from the pile.</source>
          <target state="translated">从袜子堆里随机抓一只袜子。</target>
        </trans-unit>
        <trans-unit id="8b31726f5fe78e7abfdb271081348d3c49ef8d7a" translate="yes" xml:space="preserve">
          <source>Hashing or other not-in-place solutions are not an option, because I am not able to duplicate my socks (though it could be nice if I could).</source>
          <target state="translated">哈希特或其他不到位的解决方案不是一个选项,因为我无法复制我的袜子(虽然如果可以的话可能会很好)。</target>
        </trans-unit>
        <trans-unit id="0bebef8e20477195eae330c945bf1f33000ef38c" translate="yes" xml:space="preserve">
          <source>Have it Almost &lt;code&gt;O(n)&lt;/code&gt;!</source>
          <target state="translated">拥有几乎 &lt;code&gt;O(n)&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="d3cc97a68c770f1ea7c6ba0f7a34ec7739feed82" translate="yes" xml:space="preserve">
          <source>Here's an Omega(n log n) lower bound in comparison based model. (The only valid operation is comparing two socks.)</source>
          <target state="translated">下面是基于比较模型的Omega(n log n)下限。(唯一有效的操作是比较两只袜子)。</target>
        </trans-unit>
        <trans-unit id="08f1f9a1a68f065efbd777b85e911439d922e715" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for put_socks_on_line():</source>
          <target state="translated">下面是put_socks_on_line()的算法。</target>
        </trans-unit>
        <trans-unit id="54268b27bb372ae27ec075e414013dd493b79119" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for sort_remaining_clusters():</source>
          <target state="translated">下面是sort_remaining_clusters()的算法。</target>
        </trans-unit>
        <trans-unit id="a12197b6379a8cd2d9de831467c2eea0d417e206" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for take_socks_from_line():</source>
          <target state="translated">下面是 take_socks_from_line()的算法。</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">希望对你有帮助!</target>
        </trans-unit>
        <trans-unit id="5435330177144a505ebd78530841aed23ef79bd1" translate="yes" xml:space="preserve">
          <source>How to pair socks from a pile efficiently</source>
          <target state="translated">如何从一堆袜子中有效地搭配袜子</target>
        </trans-unit>
        <trans-unit id="0163309c2cf5dde27bf33b63dc03540e97a8c089" translate="yes" xml:space="preserve">
          <source>However in real life when the number of socks is relatively small (constant), these theoretically optimal algorithms wouldn't work well. It might take even more time than sequential search, which theoretically requires quadratic time.</source>
          <target state="translated">然而在现实生活中,当袜子的数量相对较少时(常数),这些理论上的最优算法不会很好地运行。它可能会比顺序搜索更耗费时间,而顺序搜索理论上需要四次方时间。</target>
        </trans-unit>
        <trans-unit id="c187385279c8ededa5efc4f1fe03ebf17e729283" translate="yes" xml:space="preserve">
          <source>However mechanical physics give us some goodies as well. We are not limited to move at most one sock with an arm. We can move a whole couple of them at once.</source>
          <target state="translated">然而机械物理学也给了我们一些好处。我们不受限制,最多只能用一只胳膊移动一只袜子。我们可以同时移动整整几只。</target>
        </trans-unit>
        <trans-unit id="4eb82567512fc8943c9bca03d3dcc2dfbfc9658a" translate="yes" xml:space="preserve">
          <source>However, as this have simillar complexity as selection sort, the time taken is far less due to the speeds of I/O(moving socks) and search(searching the line for a sock).</source>
          <target state="translated">但是,由于其复杂程度与选择排序相似,因此,由于IO(移动袜子)和搜索(搜索袜子)的速度不同,所花费的时间也不同。</target>
        </trans-unit>
        <trans-unit id="2e5ae82866972c6fb5d15e4d37146f8fd8f90802" translate="yes" xml:space="preserve">
          <source>Human beings will use various strategies to effect these. &lt;a href=&quot;http://garfield.library.upenn.edu/classics1979/A1979HX09600001.pdf&quot;&gt;Human memory &lt;em&gt;is&lt;/em&gt; associative&lt;/a&gt;, something like a hash table where feature sets of stored values are paired with the corresponding values themselves. For example, the concept of &quot;red car&quot; maps to all the red cars a person is capable of remembering. Someone with a perfect memory has a perfect mapping.  Most people are imperfect in this regard (and most others).  The associative map has a limited capacity. Mappings may &lt;em&gt;bleep&lt;/em&gt; out of existence under various circumstances (one beer too many), be recorded in error (&quot;I though her name was Betty, not Nettie&quot;), or never be overwritten even though we observe that the truth has changed (&quot;dad's car&quot; evokes &quot;orange Firebird&quot; when we actually knew he'd traded that in for the red Camaro).</source>
          <target state="translated">人类将使用各种策略来实现这些目标。 &lt;a href=&quot;http://garfield.library.upenn.edu/classics1979/A1979HX09600001.pdf&quot;&gt;人的记忆&lt;em&gt;是&lt;/em&gt;关联的&lt;/a&gt; ，类似于哈希表，其中存储的值的特征集与相应的值本身配对。 例如，&amp;ldquo;红色汽车&amp;rdquo;的概念映射到一个人能够记住的所有红色汽车。 具有完美记忆的人具有完美的映射。 大多数人在这方面（以及大多数其他人）并不完美。 关联地图的容量有限。 映射可能在各种情况下都不存在（一瓶啤酒太多），被错误记录（&amp;ldquo;我虽然她叫Betty，而不是Nettie&amp;rdquo;）或永远不会被覆盖，即使我们观察到事实已经改变（&amp;ldquo;爸爸的当我们实际上知道他用红色的Camaro换来的时候，&amp;ldquo;汽车&amp;rdquo;就唤起了&amp;ldquo;橙色的火鸟&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="be87a28a5429a75a2d77e39569b97b2cef88f1c6" translate="yes" xml:space="preserve">
          <source>Humans can win over CPU algorithms using the fact that &quot;finding a matching pair&quot; can be one operation for a set that isn't too big.</source>
          <target state="translated">人类可以利用 &quot;寻找匹配对 &quot;这个事实来战胜CPU算法,对于一个不是很大的集合,人类可以进行一次操作就能战胜CPU算法。</target>
        </trans-unit>
        <trans-unit id="b1ed976246d93e04e79fea702823d280ba48c2ad" translate="yes" xml:space="preserve">
          <source>I came out with another solution which would not promise fewer operations, neither less time consumption, but it should be tried to see if it can be a good-enough heuristic to provide less time consumption in huge series of sock pairing.</source>
          <target state="translated">我想出了另一个解决方案,它不会承诺更少的操作,也不会承诺更少的时间消耗,但应该尝试一下,看看它是否能成为一个足够好的启发式,在巨大的袜子配对系列中提供更少的时间消耗。</target>
        </trans-unit>
        <trans-unit id="b0d5c8c30ccdae2afc794d4c2db85857ecf68b61" translate="yes" xml:space="preserve">
          <source>I do that every morning and rarely need more than three draws - but I have &lt;code&gt;n&lt;/code&gt; similar pairs (around 10, give or take the lost ones) of &lt;code&gt;m&lt;/code&gt; shaped white socks. Now you can estimate the size of my stack of stocks :-)</source>
          <target state="translated">我每天早上都这样做，很少需要抽三张以上的纸，但是我有 &lt;code&gt;n&lt;/code&gt; 对类似的袜子（大约十双，输掉或丢掉了 &lt;code&gt;m&lt;/code&gt; 字形的白色袜子）。 现在您可以估计我的股票数量了：-)</target>
        </trans-unit>
        <trans-unit id="b28189bbbd02c084d10ef3c4022c033ec385886f" translate="yes" xml:space="preserve">
          <source>I do this by:</source>
          <target state="translated">我这样做是由。</target>
        </trans-unit>
        <trans-unit id="f58214503dfea8f36b2d81a7d7e31591c0696f80" translate="yes" xml:space="preserve">
          <source>I found integrating the process of sorting into hanging to dry makes it a breeze. I need to pick up each sock anyway, and hang it (move) and it costs me about nothing to hang it in a specific place on the strings. Now just not to force search of the whole buffer (the strings) I choose to place socks by color/shade. Darker left, brighter right, more colorful front etc. Now before I hang each sock, I look in its &quot;right vicinity&quot; if a matching one is there already - this limits &quot;scan&quot; to 2-3 other socks - and if it is, I hang the other one right next to it. Then I roll them into pairs while removing from the strings, when dry.</source>
          <target state="translated">我发现把分类的过程融入到挂晾晒的过程中,使之变得轻而易举。反正我需要拿起每只袜子,然后把它挂起来(移动),而把它挂在袜子串上的特定位置上,我的成本大约是零。现在,为了不强行搜索整个缓冲区(绳子),我选择将袜子按色差放置。较深的左边,较亮的右边,较鲜艳的前面等等。现在,在我挂上每只袜子之前,我先看一下它的 &quot;右边的附近 &quot;是否已经有匹配的袜子--这就把 &quot;扫描 &quot;的范围限制在2-3只,如果有的话,我就把另一只袜子挂在旁边。然后,我把它们卷成一对,等干了之后再从绳子上取下来。</target>
        </trans-unit>
        <trans-unit id="2af9d76529a0f3da9452d50f18323e0df517ebc3" translate="yes" xml:space="preserve">
          <source>I had derived this as a part of another puzzle,but I would be happy to be proven wrong. 
&lt;a href=&quot;https://appolo85.wordpress.com/2012/07/25/some-fun-with-hash-table-performance-analysis/&quot;&gt;Here's my blog article on the same&lt;/a&gt;</source>
          <target state="translated">我把这个作为另一个难题的一部分，但是我很高兴被证明是错误的。 &lt;a href=&quot;https://appolo85.wordpress.com/2012/07/25/some-fun-with-hash-table-performance-analysis/&quot;&gt;这是我在同一篇博客上的文章&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d670bfbf52f40edfc5d3d99f6588d8b35cfcbaa" translate="yes" xml:space="preserve">
          <source>I have taken simple steps to reduce my effort into a process taking O(1) time.</source>
          <target state="translated">我采取了一些简单的步骤,将自己的努力减少到一个过程中需要O(1)时间。</target>
        </trans-unit>
        <trans-unit id="6f7a73657ec6fa088026a984672b83ade80856e7" translate="yes" xml:space="preserve">
          <source>I hope I can contribute something new to this problem. I noticed that all of the answers neglect the fact that there are two points where you can perform &lt;strong&gt;preprocessing&lt;/strong&gt;, without slowing down your overall laundry performance.</source>
          <target state="translated">我希望我可以为这个问题做出新的贡献。 我注意到所有答案都忽略了一个事实，您可以在两个方面执行&lt;strong&gt;预处理&lt;/strong&gt; ，而不会降低整体洗衣性能。</target>
        </trans-unit>
        <trans-unit id="712bf975bcdafbec473428cad084553f88032e4b" translate="yes" xml:space="preserve">
          <source>I know that these algorithms take a lot of assumptions: a bin which acts as some sort of LIFO stack, a limited, normal washing machine, and a limited, normal clothesline - but this still works with very large numbers of socks.</source>
          <target state="translated">我知道这些算法需要很多假设:一个充当某种LIFO堆栈的垃圾桶,一个有限的、普通的洗衣机,以及一个有限的、普通的晾衣绳--但这仍然适用于数量非常多的袜子。</target>
        </trans-unit>
        <trans-unit id="76250d1db233c115621eea33b2e23f2fa2575836" translate="yes" xml:space="preserve">
          <source>I should point out that in order to improve the speed of the remaining steps, it is wise not to randomly pick the next sock, but to sequentially take sock after sock from each cluster.
Both preprocessing steps don't take more time than just putting the socks on the line or in the basket, which we have to do no matter what, so this should greatly enhance the laundry performance.</source>
          <target state="translated">我需要指出的是,为了提高剩下的步骤的速度,最好不要随机抽取下一个袜子,而是按顺序从每一簇袜子中抽取一个又一个袜子。这两个预处理步骤都不需要花费更多的时间,只需要把袜子放在线上或者放在篮子里就可以了,无论如何我们都要做,所以这应该会大大提高洗衣效果。</target>
        </trans-unit>
        <trans-unit id="059e704445c273ca6d35e7eca97772e45a2005db" translate="yes" xml:space="preserve">
          <source>I think that there should be an Omega(n&lt;sup&gt;2&lt;/sup&gt;) bound for the original problem if you allow equality tests only. My intuition is: Consider a graph where you add an edge after a test, and argue that if the graph is not dense the output is not uniquely determined.</source>
          <target state="translated">我认为，如果仅允许相等性测试，则应该为原始问题绑定Omega（n &lt;sup&gt;2&lt;/sup&gt; ）。 我的直觉是：考虑一个在测试后在其中添加边的图，并争辩说，如果该图不密集，则输出不是唯一确定的。</target>
        </trans-unit>
        <trans-unit id="efa09f0b1f8cd3ce6a3acb81e6f0774e3942dc69" translate="yes" xml:space="preserve">
          <source>I will appreciate an answer that addresses the following aspects:</source>
          <target state="translated">我希望得到一个能解决以下方面问题的答复:</target>
        </trans-unit>
        <trans-unit id="b480ebea69ff0685142986485477474b5d752c12" translate="yes" xml:space="preserve">
          <source>I'm looking forward to hear about any experiences or corrections.</source>
          <target state="translated">我很期待听到任何经验或改正。</target>
        </trans-unit>
        <trans-unit id="7e3fa720280a90386643c5f943bbc31f1027bcda" translate="yes" xml:space="preserve">
          <source>I've finished pairing my socks just right now, and I found that the best way to do it is the following:</source>
          <target state="translated">刚刚配完袜子,我发现最好的方法是以下几点。</target>
        </trans-unit>
        <trans-unit id="b298e00cd80e135c4ae40839f21a896eee2181a4" translate="yes" xml:space="preserve">
          <source>If &quot;index&quot; is greater then 2 (this could be value dependent on sock
 number because with greater number of socks there are less chance to
  pair them blindly) go to 11</source>
          <target state="translated">如果 &quot;指数 &quot;大于2(这个值可能取决于袜子的数量,因为袜子的数量越多,盲目配对的机会就越少),则转到11</target>
        </trans-unit>
        <trans-unit id="428e83ad437da92aef4bb4acff910ff3919184bd" translate="yes" xml:space="preserve">
          <source>If each sock had an integer called &quot;PairID&quot; one could easily distribute them into 10 buckets according to &lt;code&gt;PairID % 10&lt;/code&gt; (the last digit).</source>
          <target state="translated">如果每个袜子都有一个称为&amp;ldquo; PairID&amp;rdquo;的整数，则可以根据 &lt;code&gt;PairID % 10&lt;/code&gt; （最后一位）轻松地将它们分配到10个存储桶中。</target>
        </trans-unit>
        <trans-unit id="68824b3b629564ab1d8b0bad06e1c81bc8489125" translate="yes" xml:space="preserve">
          <source>If match found pair it, pack pair and move it to the &quot;matched&quot; pile</source>
          <target state="translated">如果发现匹配,则将其打包成对,并将其移动到 &quot;匹配 &quot;堆中。</target>
        </trans-unit>
        <trans-unit id="b8510e4192393a95bad638ba90d06ef53c82e071" translate="yes" xml:space="preserve">
          <source>If the &quot;move&quot; operation is fairly expensive, and the &quot;compare&quot; operation is cheap, and you need to move the whole set anyway, into a buffer where search is much faster than in original storage... just integrate sorting into the obligatory move.</source>
          <target state="translated">如果 &quot;移动 &quot;操作是相当昂贵的,而 &quot;比较 &quot;操作是便宜的,反正你需要把整个集子移动到一个缓冲区,在那里搜索比在原始存储中快得多..........只要把排序整合到强制移动中就可以了。</target>
        </trans-unit>
        <trans-unit id="9b3e803c4a76f4c4bd7562f58a50ba5f385ebf8f" translate="yes" xml:space="preserve">
          <source>If the next one is the pair of the previous one, then put it to the existing bucket, otherwise create a new one.</source>
          <target state="translated">如果下一个是上一个的对子,那就把它放到现有的桶里,否则创建一个新的。</target>
        </trans-unit>
        <trans-unit id="4a8ea1dd91e78f2f6ed036a3127326ca0c1544c5" translate="yes" xml:space="preserve">
          <source>If there are less then 6 socks, go to 11.</source>
          <target state="translated">如果少了6只袜子,就去11号。</target>
        </trans-unit>
        <trans-unit id="5101d1843bf2d194d47695b1f7bbc961cb8fc0b4" translate="yes" xml:space="preserve">
          <source>If there are still more then one socks go to 12</source>
          <target state="translated">如果还有更多的袜子,那就去12号。</target>
        </trans-unit>
        <trans-unit id="b79f9eb2311d2f31b42294fff21e572d50944666" translate="yes" xml:space="preserve">
          <source>If there is just one left go to 14</source>
          <target state="translated">如果只剩下一个,就去14号</target>
        </trans-unit>
        <trans-unit id="0580e1c44a88013044e269db8383aef639694455" translate="yes" xml:space="preserve">
          <source>If there is no match, put it on the &quot;missing&quot; pile.</source>
          <target state="translated">如果没有匹配的,就把它放在 &quot;缺失 &quot;的那一堆。</target>
        </trans-unit>
        <trans-unit id="a78596387c9d98455857ff9c74f61a0ca08821df" translate="yes" xml:space="preserve">
          <source>If there is no pair for the sock, move it to the &quot;missing&quot; pile</source>
          <target state="translated">如果没有合适的袜子,就把它移到 &quot;缺少的 &quot;堆里去</target>
        </trans-unit>
        <trans-unit id="c1faf9fe0339936f19f4a80510b7ee0dc13723d0" translate="yes" xml:space="preserve">
          <source>If we assume normal distribution, then the estimated number of 'insertions'  to have atleast one sock mapped to one bucket is NlogN  (ie, all buckets are full)</source>
          <target state="translated">如果我们假设正态分布,那么至少有一只袜子映射到一个桶上的 &quot;插入量 &quot;估计为NlogN(即所有桶都是满的)。</target>
        </trans-unit>
        <trans-unit id="7fee5c386c3eac901a5e47b38f613ae422e201ea" translate="yes" xml:space="preserve">
          <source>If you can pick a limited number of attributes, but enough attributes that can uniquely identify each pair, you should be done in O(k * n), which is O(n) if we can consider k is limited.</source>
          <target state="translated">如果你能挑出有限的属性,但有足够多的属性可以唯一地识别每一对属性,那么你应该在O(k*n)中完成,如果我们可以考虑k是有限的,也就是O(n)。</target>
        </trans-unit>
        <trans-unit id="362a61837395e933805325f6b6ebe951c78dd045" translate="yes" xml:space="preserve">
          <source>If you chose a fancy pair with different left and right sock, doing a full bucket sort to left and right foot buckets take O(N+M), where N is the number of socks and M is same as above. Somebody else can give the formula for average iterations of finding the first pair, but worst case for finding a pair with blind search is N/2+1, which becomes astronomically unlikely case for reasonable N. This can be sped up by using advanced image recognition algorithms and heuristics, when scanning the pile of unsorted socks with &lt;a href=&quot;http://www.urbandictionary.com/define.php?term=Mk1%20eyeball&quot;&gt;Mk1 Eyeball&lt;/a&gt;.</source>
          <target state="translated">如果您选择了左右袜子不同的花式对，则对左右脚桶进行完整的桶排序将取O（N + M），其中N是袜子的数量，M与上面的相同。 其他人可以给出寻找第一个对的平均迭代的公式，但是用盲搜索找到对的最坏情况是N / 2 + 1，这对于合理的N来说在天文学上不太可能出现。这可以通过使用高级图像来加快&lt;a href=&quot;http://www.urbandictionary.com/define.php?term=Mk1%20eyeball&quot;&gt;Mk1 Eyeball&lt;/a&gt;扫描一堆未分类的袜子时，识别算法和启发式算法。</target>
        </trans-unit>
        <trans-unit id="14a24a331e031cc668435241346b7c07a641d7fb" translate="yes" xml:space="preserve">
          <source>If you do not, put the current sock into the first open slot in the array.</source>
          <target state="translated">如果没有,则将当前的袜子放入阵列中的第一个开放槽中。</target>
        </trans-unit>
        <trans-unit id="71950a186d51133a9e0950587efebd65ce355f77" translate="yes" xml:space="preserve">
          <source>If you find an acceptable match, put both socks together and remove them from the array.</source>
          <target state="translated">如果找到可以接受的匹配,将两只袜子放在一起,从阵列中取出。</target>
        </trans-unit>
        <trans-unit id="6f824c95564ff831ff4658d289a3cc3fbd50a604" translate="yes" xml:space="preserve">
          <source>If you have 1000 socks, with 8 colors and an average distribution, you can make 4 piles of each 125 socks in c*n time. With a threshold of 5 socks you can sort every pile in 6 runs. (Counting 2 seconds to throw a sock on the right pile it will take you little under 4 hours.)</source>
          <target state="translated">如果你有1000双袜子,按8种颜色和平均分配,你可以在c*n时间内将每125双袜子分4堆,每堆125只袜子分4堆。以5个袜子的阈值,你可以把每堆袜子分拣6次。(算上2秒,把袜子扔到正确的堆上,需要4个小时以下的时间)。</target>
        </trans-unit>
        <trans-unit id="e6180d90736fe61c2fee7b217194e6e292349b2c" translate="yes" xml:space="preserve">
          <source>If you have just 60 socks, 3 colors and 2 sort of socks (yours / your wife's) you can sort every pile of 10 socks in 1 runs (Again threshold = 5). (Counting 2 seconds it will take you 2 min).</source>
          <target state="translated">如果你只有60只袜子,3种颜色和2种袜子(你的,你老婆的),你可以在1次运行中把每堆10只袜子分类(阈值=5)。算上2秒,需要2分钟)。</target>
        </trans-unit>
        <trans-unit id="1642673d491acf03991115db1b99d02263fa0f61" translate="yes" xml:space="preserve">
          <source>If you have one or more selected unpaired socks, check your current sock against all the unpaired socks in the array.</source>
          <target state="translated">如果您有一只或多只选定的未配对的袜子,请将当前的袜子与阵列中所有未配对的袜子进行核对。</target>
        </trans-unit>
        <trans-unit id="f56085360df34e1a4ad17c6698a237315bf8ce9d" translate="yes" xml:space="preserve">
          <source>In computer science this can be helpful:
We have a collection of n &lt;em&gt;things&lt;/em&gt;, an order on them (length) and also an equivalence relation (extra information, for example the color of socks). The equivalence relation allows us to make a partition of the original collection, and in every equivalence class our order is still maintained. The mapping of a &lt;em&gt;thing&lt;/em&gt; to it's equivalence class can be done in O(1), so only O(n) is needed to assign each item to a class. Now we have used our extra information and can proceed in any manner to sort every class. The advantage is that the data sets are already significantly smaller.</source>
          <target state="translated">在计算机科学中，这可能会有所帮助：我们有n种&lt;em&gt;东西&lt;/em&gt;的集合，它们的顺序（长度），以及等价关系（额外信息，例如袜子的颜色）。 等价关系使我们可以对原始集合进行划分，并且在每个等价类中，我们的订单仍然保持。 &lt;em&gt;事物&lt;/em&gt;到其对等类的映射可以在O（1）中完成，因此只需要O（n）就可以将每个项目分配给一个类。 现在，我们已经使用了额外的信息，并且可以以任何方式对每个类进行排序。 优点是数据集已经大大缩小了。</target>
        </trans-unit>
        <trans-unit id="95707802ab9dca781a74e6e8993e4a31c2c6a26e" translate="yes" xml:space="preserve">
          <source>In order to say how efficient it is to pair socks from a pile, we have to define the machine first, because the pairing isn't done whether by a turing nor by a random access machine, which are normally used as the basis for an algorithmic analysis.</source>
          <target state="translated">要说从桩上配对袜子的效率如何,我们必须先定义机器,因为配对不是由图灵和随机存取机来完成的,通常情况下,这些机器都是作为算法分析的基础。</target>
        </trans-unit>
        <trans-unit id="cb70cb2a381a9804b33c37786ed6892de88e1933" translate="yes" xml:space="preserve">
          <source>In the case of socks, perfect recall means looking at a sock &lt;code&gt;s&lt;/code&gt; always produces the memory of its sibling &lt;code&gt;t&lt;/code&gt;, including enough information (where it is on the ironing board) to locate &lt;code&gt;t&lt;/code&gt; in constant time.  A person with photographic memory accomplishes both 1 and 2 in constant time without fail.</source>
          <target state="translated">就袜子而言，完美的召回意味着看着袜子 &lt;code&gt;s&lt;/code&gt; 总是会产生其兄弟姐妹 &lt;code&gt;t&lt;/code&gt; 的记忆，包括足够的信息（在熨衣板上的信息）可以在恒定时间内定位 &lt;code&gt;t&lt;/code&gt; 。 具有照片记忆的人可以在恒定时间内完成1和2的工作。</target>
        </trans-unit>
        <trans-unit id="4d3725e32aaeb21f7a9e8878c8079a2ecffbc7fb" translate="yes" xml:space="preserve">
          <source>In the worst case it means that you will have n/2 different buckets, and you will have n-2 determinations about that which bucket contains the pair of the current sock. Obviously, this algorithm works well if you have just a few pairs; I did it with 12 pairs.</source>
          <target state="translated">在最坏的情况下,这意味着你将有n2个不同的桶,你将有n-2个关于哪一个桶包含当前袜子对的判断。很明显,如果你只有几对袜子,这个算法很好用;我是用12对袜子做的。</target>
        </trans-unit>
        <trans-unit id="aa2dcdaf17722e129a20d19adefefc64c27ec3f1" translate="yes" xml:space="preserve">
          <source>Is it equivalent to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;element distinctness problem&lt;/a&gt;?</source>
          <target state="translated">它等同于&lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;元素区分性问题&lt;/a&gt;吗？</target>
        </trans-unit>
        <trans-unit id="27a7682059354d7267300e1425434e6ec790e624" translate="yes" xml:space="preserve">
          <source>It is not so scientific, but it works well:)</source>
          <target state="translated">虽然不那么科学,但效果不错:)</target>
        </trans-unit>
        <trans-unit id="d923e9762ba91638d0414fad059bf2a39ed51197" translate="yes" xml:space="preserve">
          <source>It is possible to separate socks into general classes or types (white/black, ankle/crew, athletic/dress) when building your array, and &quot;drill-down&quot; to only compare like-for-like.</source>
          <target state="translated">在建立阵列时,可以将袜子分为一般的类目或类型(白黑、脚踝袜、运动袜),&quot;下钻&quot;,只进行同类比较。</target>
        </trans-unit>
        <trans-unit id="84b3dca37c877454cf4abb0e807d969bb8f0399f" translate="yes" xml:space="preserve">
          <source>It obviously requires some extra work to check if there is the matching sock already hanging somewhere and it would render solution &lt;code&gt;O(n^2)&lt;/code&gt; with coefficient about &lt;code&gt;1/2&lt;/code&gt; for a computer. But in this case the &quot;human factor&quot; is actually an advantage -- I usually can very quickly (almost &lt;code&gt;O(1)&lt;/code&gt;) identify the matching sock if it was already hung (probably some imperceptible in-brain caching is involved) -- consider it a kind of limited &quot;oracle&quot; as in &lt;a href=&quot;http://en.wikipedia.org/wiki/Oracle_machine&quot;&gt;Oracle Machine&lt;/a&gt; ;-) We, the humans have these advantages over digital machines in some cases ;-)</source>
          <target state="translated">很显然，这需要一些额外的工作来检查是否有匹配的袜子已经挂在某处，并且它将使解决方案 &lt;code&gt;O(n^2)&lt;/code&gt; 的系数约为计算机的 &lt;code&gt;1/2&lt;/code&gt; 。 但是在这种情况下，&amp;ldquo;人为因素&amp;rdquo;实际上是一个优势-我通常可以很快（几乎 &lt;code&gt;O(1)&lt;/code&gt; ）识别出匹配的袜子（如果已经挂了）（可能涉及了一些不可察觉的脑内缓存）-考虑这是&lt;a href=&quot;http://en.wikipedia.org/wiki/Oracle_machine&quot;&gt;Oracle Machine中&lt;/a&gt;一种有限的&amp;ldquo; oracle&amp;rdquo; ；-)在某些情况下，人类比数字计算机具有这些优势；-)</target>
        </trans-unit>
        <trans-unit id="39b5cd62e349d68c400a20da1e370efb8e1fc33f" translate="yes" xml:space="preserve">
          <source>It scales nearly indefinitely if &lt;strong&gt;each worker has its own set of piles&lt;/strong&gt;. Workers can then take big chunks of socks from the input basket (very little contention as they are doing it rarely) and they do not need to synchronise when distributing the socks at all (because they have thread-local piles). At the end, all workers need to union their pile-sets. I believe that can be done in O(log (worker count * piles per worker)) if the workers form an &lt;strong&gt;aggregation tree&lt;/strong&gt;.</source>
          <target state="translated">如果&lt;strong&gt;每个工人都有自己的桩，&lt;/strong&gt;它几乎可以无限扩展。 然后，工人可以从输入筐中取出大块的袜子（很少有竞争，因为他们很少这样做），并且在分配袜子时根本不需要同步（因为他们有局部线程堆）。 最后，所有工人都需要结合他们的桩组。 我相信，如果工人形成一个&lt;strong&gt;聚集树&lt;/strong&gt; ，可以用O（log（工人数*每个工人的堆数））来完成。</target>
        </trans-unit>
        <trans-unit id="150b46cd8303cca0bd34d1940b0ec0aedbf08053" translate="yes" xml:space="preserve">
          <source>It's better if there's no difference between left and right foot socks, but it's not critical. If socks are left-right symmetrical, finding a pair is O(1) operation, and sorting the socks is approximate O(M) operation, where M is the number of places in your house, which you have littered with socks, ideally some small constant number.</source>
          <target state="translated">如果左右脚的袜子没有区别,那就更好了,但这并不关键。如果袜子是左右对称的,找一双袜子是O(1)个操作,而对袜子进行分类是近似O(M)个操作,其中M是你家里有多少个地方被你扔了袜子,最好是一些小的常数。</target>
        </trans-unit>
        <trans-unit id="2f22939c37ecaebbcccfa9e1a61cd5e27c5cb274" translate="yes" xml:space="preserve">
          <source>It's often good to take a step back, and think a way around the problem.</source>
          <target state="translated">往往退一步,想个办法来解决这个问题是好事。</target>
        </trans-unit>
        <trans-unit id="150a08322f1488dee4632ea6718c405d63b39b1c" translate="yes" xml:space="preserve">
          <source>Iterate over each pile and &lt;strong&gt;distribute it by some other metric&lt;/strong&gt; (e.g. pattern) into the second set of piles</source>
          <target state="translated">遍历每个桩， &lt;strong&gt;并通过其他度量&lt;/strong&gt; （例如模式）将其&lt;strong&gt;分配&lt;/strong&gt;到第二组桩中</target>
        </trans-unit>
        <trans-unit id="5efd484584a49caf169c4dda344e416b18649fb1" translate="yes" xml:space="preserve">
          <source>Keep randomly picking socks from the stack and compare to your 5+1 socks for a match. As your stack grows, it will reduce your performance but raise your odds. Much faster.</source>
          <target state="translated">继续从堆栈中随机抽取袜子,并与你的5+1袜子进行比对。随着你的堆栈的增加,会降低你的成绩,但提高你的胜率。速度快了很多。</target>
        </trans-unit>
        <trans-unit id="1ca7ccdd0b7ccddb659ecda67d1ece6e151b36ca" translate="yes" xml:space="preserve">
          <source>Let 'N' correspond to an approximate upper-bound on the number of  number of unique colors/pattern of socks that you have.</source>
          <target state="translated">让'N'对应的是你所拥有的袜子的独特色块数量的近似上限。</target>
        </trans-unit>
        <trans-unit id="780bea650a8fdf34a596a74ddbd5fc938d04c33f" translate="yes" xml:space="preserve">
          <source>My algorithm:</source>
          <target state="translated">我的算法。</target>
        </trans-unit>
        <trans-unit id="74beaf9107fc04b7777303cee699390003158c90" translate="yes" xml:space="preserve">
          <source>My solution does not exactly correspond to your requirements, as it formally requires &lt;code&gt;O(n)&lt;/code&gt; &quot;extra&quot; space. However, considering my conditions it is very efficient in my practical application. Thus I think it should be interesting.</source>
          <target state="translated">我的解决方案不完全符合您的要求，因为它正式需要 &lt;code&gt;O(n)&lt;/code&gt; &amp;ldquo;额外&amp;rdquo;空间。 但是，考虑到我的条件，这在我的实际应用中非常有效。 因此，我认为这应该很有趣。</target>
        </trans-unit>
        <trans-unit id="5975233f2cbc212e70e2408f533f6faa08e21eb5" translate="yes" xml:space="preserve">
          <source>Now look for a match (visual pattern matching - humans are good at that with a small stack) inside the five you drew, if you don't find one, then add that to your five.</source>
          <target state="translated">现在,在你画的5个里面找一个匹配的(视觉模式匹配----人类擅长的是用小堆叠),如果没有找到,那就把它加到你的5个里面。</target>
        </trans-unit>
        <trans-unit id="a7486cfa8083fe6f612df25745068a14a1cac68b" translate="yes" xml:space="preserve">
          <source>Now the computer science in this problem is all about the steps</source>
          <target state="translated">现在,这个问题中的计算机科学都是关于步骤的问题</target>
        </trans-unit>
        <trans-unit id="870cccf30184352ba6b4960824e58b1bdd6d8989" translate="yes" xml:space="preserve">
          <source>Now the next question is simply whether you do your own laundry and your wife does hers. That is a problem likely in an &lt;strong&gt;entirely different domain of problems&lt;/strong&gt;. :)</source>
          <target state="translated">现在，下一个问题就是您是否自己洗衣服，而您的妻子是否洗衣服。 在&lt;strong&gt;完全不同的问题领域中，&lt;/strong&gt;这可能是一个&lt;strong&gt;问题&lt;/strong&gt; 。 :)</target>
        </trans-unit>
        <trans-unit id="e3d8d0fe5c35ea409447bff57847e6fc8b0f8f6d" translate="yes" xml:space="preserve">
          <source>Now this may not seem all that different from &quot;forming piles by color&quot; suggested by top answers but first, by not picking discrete piles but ranges, I have no problem classifying whether &quot;purple&quot; goes to &quot;red&quot; or &quot;blue&quot; pile; it just goes between. And then by integrating two operations (hang to dry and sort) the overhead of sorting while hanging is like 10% of what separate sorting would be.</source>
          <target state="translated">现在,这可能看起来和上面的答案所建议的 &quot;按颜色形成堆 &quot;没有什么区别,但首先,通过不选离散的堆,而是选范围,我对 &quot;紫色 &quot;到 &quot;红色 &quot;或 &quot;蓝色 &quot;堆的分类没有问题;它只是在两者之间。然后通过整合两个操作(晾晒和分类),在晾晒的同时进行分类的开销就像单独分类的10%。</target>
        </trans-unit>
        <trans-unit id="37e05d152e6390b47f7a7dde92949ba55f30e47c" translate="yes" xml:space="preserve">
          <source>Once you have a collision(a.k.a  : a match) simply remove that pair of socks. 
 Repeat the same experiment with the next batch of NlogN socks. 
The beauty of it is that you could be making NlogN parallel comparisons(collision-resolution) because of the way the human mind works.  :-)</source>
          <target state="translated">一旦你有一个碰撞(又名:匹配),只需将那对袜子移除。用下一批NlogN袜子重复同样的实验。它的好处是你可以进行NlogN并行比较(碰撞-分辨率),因为人的思维方式是这样的。)</target>
        </trans-unit>
        <trans-unit id="11a98af1a6e5c195360f3f6c711227cc208dadd9" translate="yes" xml:space="preserve">
          <source>Operation 4 is necessary, because when spreading socks over the floor some socks may hide others. Here is the analysis of the algorithm:</source>
          <target state="translated">操作4是必要的,因为在将袜子铺在地上时,有的袜子可能会遮住其他的袜子。下面就来分析一下这个算法。</target>
        </trans-unit>
        <trans-unit id="af6924e29957fb8b52cc30183bb2138601d75b4d" translate="yes" xml:space="preserve">
          <source>Optionally to step one, you pick up two sock from that line instead of two, as the caching memory is large enough we can quickly identify if either sock matches the current one on the line you are observing. If you are fortunate enough to have three arms, you could possibly parse three socks at the same time given that the memory of the subject is large enough.</source>
          <target state="translated">可选步骤一,你从那条线上拿起两只袜子,而不是两只,因为缓存内存足够大,我们可以快速识别出你所观察的那条线上的任何一只袜子是否与当前的那只袜子匹配。如果你有幸有三条手臂,鉴于主体的内存足够大,你可以或许同时解析三只袜子。</target>
        </trans-unit>
        <trans-unit id="77783bef2624f9f540cadff73ba6528b5aae021a" translate="yes" xml:space="preserve">
          <source>Oracle Machine is Better ;-)</source>
          <target state="translated">Oracle机器是更好的;--)</target>
        </trans-unit>
        <trans-unit id="f28b38127d74eab7d9b41752145290a2fc0d5c89" translate="yes" xml:space="preserve">
          <source>Order the socks!</source>
          <target state="translated">订购袜子!</target>
        </trans-unit>
        <trans-unit id="8c33de1b8688b9c866607960966f014e14b6a01b" translate="yes" xml:space="preserve">
          <source>Other than that, I cannot think of anything, but this method does seem to be pretty efficient in real life. :)</source>
          <target state="translated">除此以外,我想不出什么,但这个方法在现实生活中似乎确实很有效。)</target>
        </trans-unit>
        <trans-unit id="02341ed9b2710f0b78051065b72a305737d20c68" translate="yes" xml:space="preserve">
          <source>Our two preprocessing stages are &quot;putting the socks on the clothesline&quot; and &quot;Taking the socks from the clothesline&quot;, which we have to do, in order to get socks which are not only clean but also dry. As with washing machines, clotheslines are finite, and I assume that we have the whole part of the line where we put our socks in sight.</source>
          <target state="translated">我们的两个预处理阶段是 &quot;把袜子放在晾衣绳上 &quot;和 &quot;把袜子从晾衣绳上拿下来&quot;,为了得到的袜子不仅要干净,还要干爽。和洗衣机一样,晾衣绳也是有限的,我想,我们在晾衣绳上放袜子的那部分,我想,我们的袜子都是在视线内的。</target>
        </trans-unit>
        <trans-unit id="dd7e7c37ececf846bbc91969c59fe7ec34aa06d6" translate="yes" xml:space="preserve">
          <source>Pair blindly all socks to its neighbor (do not pack it)</source>
          <target state="translated">盲目地把所有的袜子都对准了它的邻居(不要包装它</target>
        </trans-unit>
        <trans-unit id="567d945bb762f9218b71f65d131b602db30011d2" translate="yes" xml:space="preserve">
          <source>Pick a sock</source>
          <target state="translated">挑一只袜子</target>
        </trans-unit>
        <trans-unit id="b3134987842b8171f3b2d20b9d928ea0449a744f" translate="yes" xml:space="preserve">
          <source>Pick any two of them to make a pair. Constant time.</source>
          <target state="translated">任意选取其中的2个来结成对子。恒定的时间。</target>
        </trans-unit>
        <trans-unit id="e6ad43d89c0be2bb101bd954d77aea3f0c680af6" translate="yes" xml:space="preserve">
          <source>Pick the first sock in line, search along the line until it finds the corresponding sock.</source>
          <target state="translated">挑选第一只袜子排队,沿线搜索,直到找到对应的袜子为止。</target>
        </trans-unit>
        <trans-unit id="f15a45dc12d70436ea09baf6beeb9021651aff15" translate="yes" xml:space="preserve">
          <source>Pick two socks, place corresponding X sock in X line, and Y sock in Y line at next available position.</source>
          <target state="translated">挑选两只袜子,将对应的X袜放在X线上,Y袜放在Y线下一个可用的位置。</target>
        </trans-unit>
        <trans-unit id="a42c6c1b50b0cb070b7169e8cfd43b7e499c1252" translate="yes" xml:space="preserve">
          <source>Pick up a first sock and place it on a table. Now pick another sock; if it matches the first picked, place it on top of the first. If not, place it on the table a small distance from the first. Pick a third sock; if it matches either of the previous two, place it on top of them or else place it a small distance from the third. Repeat until you have picked up all the socks.</source>
          <target state="translated">拿起第一只袜子,放在桌子上。现在拿起另一只袜子,如果和第一只袜子相吻合,就把它放在第一只袜子的上面。如果不符合,就把它放在离第一只袜子一小段距离的桌子上。挑选第三只袜子;如果它与前两只袜子中的任何一只相吻合,就把它放在上面,否则就把它放在离第三只袜子一小段距离。重复一遍,直到把所有的袜子都挑完为止。</target>
        </trans-unit>
        <trans-unit id="49d4ff963ae4bca3c41a677fe2b8a4851f0dc095" translate="yes" xml:space="preserve">
          <source>Pick up one from the stack of 2n-5.</source>
          <target state="translated">从2n-5的堆里拿起一个。</target>
        </trans-unit>
        <trans-unit id="38fc586cd4b8cb11aebfcde216a7bcd038fe8e83" translate="yes" xml:space="preserve">
          <source>Picking a distinctive sock (whatever catches my eye first in the pile).</source>
          <target state="translated">挑选一双有特色的袜子(在袜子堆里,不管是什么东西先吸引我的眼球)。</target>
        </trans-unit>
        <trans-unit id="afb37a344e3ab2d134c35252ebd3afec24338844" translate="yes" xml:space="preserve">
          <source>Place the new sock near into the current pile, with a distance based on how different it is. If you find yourself putting the sock on top of another because it is identical, form the pair there, and remove them. This means that future comparisons take less effort to find the correct place.</source>
          <target state="translated">将新的袜子就近放在当前的袜子堆里,根据不同的距离,将新的袜子放在当前的袜子堆里。如果你发现自己把袜子放在另一只袜子的上面,因为它是一样的,就把这对袜子放在那里,然后再把它们去掉。这就意味着以后的比较会少花点力气去找正确的地方。</target>
        </trans-unit>
        <trans-unit id="2f2ea3db77a1f1b6f771e24a207d47f22993a2ad" translate="yes" xml:space="preserve">
          <source>Problem solved. So, just get new socks, throw/donate your old ones away, and live happily ever after knowing you are saving money and time every day for the rest of your life.</source>
          <target state="translated">问题就解决了。所以,只要换上新的袜子,把旧的扔掉,知道自己每天都在省钱省时间,过上幸福的生活,这辈子就好了。</target>
        </trans-unit>
        <trans-unit id="b052f937ed7ad2c7eefbe92ef78e1f1391ca53d4" translate="yes" xml:space="preserve">
          <source>Put into the corresponding finished line of socks.</source>
          <target state="translated">放入相应的成品线的袜子。</target>
        </trans-unit>
        <trans-unit id="e069c49edbed651dbec011e37b87b876f834afc4" translate="yes" xml:space="preserve">
          <source>Quickly make piles of easily distinguishable socks. (Say by color)</source>
          <target state="translated">快速地做成堆的容易区分的袜子。(按颜色说)</target>
        </trans-unit>
        <trans-unit id="e8562ec8764aff77d8738bd6121e9835eeba9b2f" translate="yes" xml:space="preserve">
          <source>Quicksort every pile and use the length of the sock for comparison. As a human you can make a fairly quick decision which sock to use to partition that avoids worst case. (You can see multiple socks in parallel, use that to your advantage!)</source>
          <target state="translated">快速排序每一堆,用袜子的长度进行比较。作为一个人,你可以相当快地决定用哪只袜子来分区,避免了最坏的情况。(你可以看到多个袜子并列,利用这一点来发挥你的优势!)</target>
        </trans-unit>
        <trans-unit id="b577412dc9473d426d2ff6741d11dea5ca17a977" translate="yes" xml:space="preserve">
          <source>Real world approach:</source>
          <target state="translated">真实世界的方法。</target>
        </trans-unit>
        <trans-unit id="0bf66d17ab79cfe3be7fc141f104742b101b119a" translate="yes" xml:space="preserve">
          <source>Repeat from 1 until there are no socks on the floor.</source>
          <target state="translated">从1开始重复,直到地上没有袜子为止。</target>
        </trans-unit>
        <trans-unit id="0081c3494d7d5f15ad3d0b6fd53ac547753f32ff" translate="yes" xml:space="preserve">
          <source>Repeat from 1. until there are no more most distinctive socks.</source>
          <target state="translated">从1开始重复,直到没有最有特色的袜子了。</target>
        </trans-unit>
        <trans-unit id="e491132f83030e4bf9e1aa6139496611dff2738e" translate="yes" xml:space="preserve">
          <source>Repeat from 2 until no pair can be made.</source>
          <target state="translated">从2号开始重复,直到不能成对为止。</target>
        </trans-unit>
        <trans-unit id="f4ecdc41af265ed9bf91659fbd817baded2a6b44" translate="yes" xml:space="preserve">
          <source>Repeat with every sock.</source>
          <target state="translated">每只袜子都要重复一遍。</target>
        </trans-unit>
        <trans-unit id="2d3de6b4a64f840ca4b44c37b7e888adb2929c0e" translate="yes" xml:space="preserve">
          <source>Shuffle the rest</source>
          <target state="translated">把剩下的都洗掉</target>
        </trans-unit>
        <trans-unit id="20968b695bdd0c1693e57dfce2b017887a96213f" translate="yes" xml:space="preserve">
          <source>Since all washing machines I know about are limited in size (regardless of how many socks you have to wash), and the actual randomizing occurs in the washing machine, no matter how many socks we have, we always have small subsets which contain almost no singletons.</source>
          <target state="translated">由于我所知道的所有洗衣机都是有限的(不管你要洗多少袜子),而真正的随机化是在洗衣机里进行的,所以不管我们有多少袜子,我们总是会有一些小的子集,这些子集里几乎没有单子。</target>
        </trans-unit>
        <trans-unit id="20318f6c81a8cfa249bb075ab83674739820d4cc" translate="yes" xml:space="preserve">
          <source>Since you are interested in connections to element distinctness problem: proving the Omega(n log n) bound for element distinctness is harder, because the output is binary yes/no. Here, the output has to be a matching and the number of possible outputs suffices to get a decent bound. However, there's a variant connected to element distinctness. Suppose you are given 2n socks and wonder if they can be uniquely paired. You can get a reduction from ED by sending (a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;) to (a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;, a&lt;sub&gt;n&lt;/sub&gt;). (Parenthetically, the proof of hardness of ED is very interesting, &lt;a href=&quot;http://www.cs.dartmouth.edu/~ac/Teach/CS85-Spring08/lecnotes.pdf&quot;&gt;via topology&lt;/a&gt;.)</source>
          <target state="translated">由于您对与元素唯一性问题有关的连接感兴趣：证明针对元素唯一性的Omega（n log n）绑定比较困难，因为输出是二进制的yes / no。 这里，输出必须是匹配的，并且可能的输出数量足以获得合理的界限。 但是，存在与元素唯一性相关的变体。 假设您给了2n只袜子，想知道它们是否可以唯一配对。 您可以通过将（a &lt;sub&gt;1&lt;/sub&gt; ，a &lt;sub&gt;1&lt;/sub&gt; ，a &lt;sub&gt;2&lt;/sub&gt; ，...，a &lt;sub&gt;n&lt;/sub&gt; ）发送给（a &lt;sub&gt;1&lt;/sub&gt; ，a &lt;sub&gt;1&lt;/sub&gt; ，a &lt;sub&gt;2&lt;/sub&gt; ，a &lt;sub&gt;2&lt;/sub&gt; ，...，a &lt;sub&gt;n&lt;/sub&gt; ，a &lt;sub&gt;n&lt;/sub&gt; ）从ED减少。 （从理论上讲， &lt;a href=&quot;http://www.cs.dartmouth.edu/~ac/Teach/CS85-Spring08/lecnotes.pdf&quot;&gt;通过拓扑结构&lt;/a&gt;证明ED的硬度非常有趣。）</target>
        </trans-unit>
        <trans-unit id="b9194449f120d8f88fb9b2143ad9103b6ff573c9" translate="yes" xml:space="preserve">
          <source>Smile satisfied :)</source>
          <target state="translated">满意的微笑:)</target>
        </trans-unit>
        <trans-unit id="b4e8217ef1354bbb155dad8cbdc9f0568f1b9c6f" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;hashing&lt;/strong&gt; would be enough (and faster).</source>
          <target state="translated">因此&lt;strong&gt;散列&lt;/strong&gt;就足够了（并且更快）。</target>
        </trans-unit>
        <trans-unit id="efa0ae263e5ffda95375f84a7f6c55184e61109a" translate="yes" xml:space="preserve">
          <source>So depending on the previous analysis following operations should be used in descending order:</source>
          <target state="translated">所以根据前面的分析,下面的操作应按降序进行。</target>
        </trans-unit>
        <trans-unit id="c9e8e26a61696a80e259f278ce881a216a7ad149" translate="yes" xml:space="preserve">
          <source>So here is my suggestion:</source>
          <target state="translated">所以,我的建议是这样的。</target>
        </trans-unit>
        <trans-unit id="a55e40b80a0b84833274723db643350fd89429ca" translate="yes" xml:space="preserve">
          <source>So pick up five of them at random, and memorize their shape or their length.</source>
          <target state="translated">所以随意拿起其中的5个,记住它们的形状或长度。</target>
        </trans-unit>
        <trans-unit id="d199d875189556fbbb7c28bbf7b2d5145327cb1f" translate="yes" xml:space="preserve">
          <source>So the &quot;best&quot; algorithm depends on the qualities of the wetware/hardware/software that is running it and our willingness to &quot;cheat&quot; by imposing a total order on pairs.  Certainly a &quot;best&quot; &lt;em&gt;meta&lt;/em&gt;-algorithm is to hire the worlds best sock-sorter: a person or machine that can aquire and quickly store a huge set N of sock attribute sets in a 1-1 associative memory with constant time lookup, insert, and delete. Both people and machines like this can be procured. If you have one, you can pair all the socks in O(N) time for N pairs, which is optimal. The total order tags allow you to use standard hashing to get the same result with either a human or hardware computer.</source>
          <target state="translated">因此，&amp;ldquo;最佳&amp;rdquo;算法取决于运行它的湿件/硬件/软件的质量，以及我们对成对施加总订单的&amp;ldquo;作弊&amp;rdquo;意愿。 当然，&amp;ldquo;最佳&amp;rdquo; &lt;em&gt;元&lt;/em&gt;算法是雇用世界上最好的袜子分类器：一个人或机器，可以通过恒定的时间查找，插入，并删除。 这样的人和机器都可以采购。 如果您有一只袜子，则可以在O（N）时间内将所有袜子配对N对，这是最佳选择。 总订单标签使您可以使用标准哈希来与人机或硬件计算机获得相同的结果。</target>
        </trans-unit>
        <trans-unit id="2f4b0f3db658b3420736349f1a48e77a38793c53" translate="yes" xml:space="preserve">
          <source>So we have a total runtime complexity of &lt;strong&gt;&lt;code&gt;O(r*n^2 + w*(ln n + n))&lt;/code&gt;&lt;/strong&gt; where &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; are the factors for environmental read and environmental write operations respectively for a reasonable amount of socks. The cost of the logical and arithmetical operations are omitted, because we suppose that it takes a constant amount of logical and arithmetical operations to decide whether 2 socks belong to the same pair. This may not be feasible in every scenario.</source>
          <target state="translated">因此，我们的总运行时复杂度为&lt;strong&gt; &lt;code&gt;O(r*n^2 + w*(ln n + n))&lt;/code&gt; &lt;/strong&gt; ，其中 &lt;code&gt;r&lt;/code&gt; 和 &lt;code&gt;w&lt;/code&gt; 分别是合理数量的袜子的环境读取和环境写入操作的因素。 省略了逻辑和算术运算的成本，因为我们假设需要花费恒定数量的逻辑和算术运算来确定2个袜子是否属于同一对。 这可能并非在每种情况下都是可行的。</target>
        </trans-unit>
        <trans-unit id="c0ea279bcf3555464998141486451f10c76c5ac8" translate="yes" xml:space="preserve">
          <source>So, an algorithm for achieving O(1) sock pairing efficiency (assuming symmetrical sock) is:</source>
          <target state="translated">所以,实现O(1)袜口配对效率的算法是(假设袜口对称)。</target>
        </trans-unit>
        <trans-unit id="f20134ff73648500315de3e4a253b67d80cad96e" translate="yes" xml:space="preserve">
          <source>Socks, whether real ones or some analogous data structure, would be supplied in pairs.</source>
          <target state="translated">袜子,无论是真袜子还是类似的数据结构,都将成对提供。</target>
        </trans-unit>
        <trans-unit id="fb36d98db4ccebdf42bf060da6c7373f52f5a333" translate="yes" xml:space="preserve">
          <source>Some upfront effort is required to find desirable socks, and to purchase in sufficient quantity as to eliminate need for your existing socks. As I'd done this before my need for black socks, my effort was minimal, but mileage may vary.</source>
          <target state="translated">要找到理想的袜子,需要一些前期的努力,并购买足够数量的袜子,以消除对现有袜子的需求。由于我在需要黑袜之前就已经做过,所以我的努力是最小的,但里程可能会有差异。</target>
        </trans-unit>
        <trans-unit id="97926eed54a69097fde506b9ecf78b97bea5b72b" translate="yes" xml:space="preserve">
          <source>Someone with less than perfect memory might use a few commonsense equivalence classes based on features within his capability to track: size (papa, mama, baby), color (greenish, redish, etc.), pattern (argyle, plain, etc.), style (footie, knee-high, etc.).  So the ironing board would be divided into sections for the categories. This usually allows the category to be located in constant time by memory, but then a linear search through the category &quot;bucket&quot; is needed.</source>
          <target state="translated">记忆力不是很好的人可能会根据自己能力范围内的特征,用一些常识性的等价物分类来追踪:尺寸(爸爸、妈妈、宝宝)、颜色(偏绿、偏红等)、花纹(方格纹、素色等)、款式(脚踏、过膝等)。所以熨衣板会分门别类的划分。这样通常可以通过记忆来固定时间定位类别,但这时就需要通过类别 &quot;桶 &quot;来进行线性搜索。</target>
        </trans-unit>
        <trans-unit id="0159712802a0c2f7cfff59d6211ba6f0c4445923" translate="yes" xml:space="preserve">
          <source>Someone with no memory or imagination at all (sorry) will just keep the socks in one pile and do a linear search of the whole pile.</source>
          <target state="translated">完全没有记忆力和想象力的人(抱歉),会把袜子放在一堆,把整堆的袜子做一个线性搜索。</target>
        </trans-unit>
        <trans-unit id="b1831098d4a04bf674e6b5bfb3d588abdfb6668a" translate="yes" xml:space="preserve">
          <source>Sorting solutions have been proposed, but &lt;strong&gt;sorting is a little too much&lt;/strong&gt;: We don't need order; &lt;strong&gt;we just need equality groups&lt;/strong&gt;.</source>
          <target state="translated">已经提出了排序解决方案，但是&lt;strong&gt;排序有点过多&lt;/strong&gt; ：我们不需要定单； &lt;strong&gt;我们只需要平等团体&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cf30b649babee1fb3e3f2f2040697d3899e96be" translate="yes" xml:space="preserve">
          <source>Sorting, of course improves efficiency, especially in real life where you can easily &quot;insert&quot; a sock between two other socks. In computing the same could be achieved by a tree, but that's extra space. And, of course, we're back at NlogN (or a bit more, if there are several socks that are the same by sorting criteria, but not from the same pair).</source>
          <target state="translated">分类,当然可以提高效率,特别是在现实生活中,你可以很容易地将一只袜子 &quot;插入 &quot;到另外两只袜子之间。在计算中,同样可以用树来实现,但那是额外的空间。当然,我们又回到了NlogN(如果有几只袜子通过排序标准相同,但不是来自同一对袜子的话,也可以再多一点)。</target>
        </trans-unit>
        <trans-unit id="71a641aab14b65becb2573bd1e7dc80cfa779bbc" translate="yes" xml:space="preserve">
          <source>Spread all socks in the pile over the floor.</source>
          <target state="translated">将堆里的袜子全部铺在地上。</target>
        </trans-unit>
        <trans-unit id="1e59b3c211f85c725340aeaa57b22de5e88fedab" translate="yes" xml:space="preserve">
          <source>Starting a radix sort from that conceptual location by pulling socks from the pile based on similarity to that one.</source>
          <target state="translated">根据与该概念位置的相似性,从该概念位置开始进行Radix排序,将袜子从袜子堆中拉出,根据与该概念位置的相似性进行排序。</target>
        </trans-unit>
        <trans-unit id="9a81a4144276291d35bd6b866aad617bdf191bf6" translate="yes" xml:space="preserve">
          <source>Stop sorting piles when they reached a threshold at which you are comfortable to find spot pairs and unpairable socks instantly</source>
          <target state="translated">当它们达到一个阈值时,停止分类堆积,当它们达到一个阈值时,你就可以立即找到现货配对和不受欢迎的袜子,从而停止分类。</target>
        </trans-unit>
        <trans-unit id="c6852caa99233694cc2f8ce0670b34197c40d765" translate="yes" xml:space="preserve">
          <source>Such an upfront effort has been seen many times in very popular and effective code. Examples include #DEFINE'ing pi to several decimals (other examples exist, but that's the one that comes to mind right now).</source>
          <target state="translated">这种前期的努力已经在非常流行和有效的代码中看到过很多次了。例子包括#DEFINE'ing pi到几个小数(其他例子也有,但现在想到的就是这个)。</target>
        </trans-unit>
        <trans-unit id="0a5991dd9a6ef1577adeb97b95fcc60199512116" translate="yes" xml:space="preserve">
          <source>Suppose that you &lt;em&gt;know&lt;/em&gt; that your 2n socks are arranged this way:</source>
          <target state="translated">假设您&lt;em&gt;知道&lt;/em&gt;您的2n袜子是这样排列的：</target>
        </trans-unit>
        <trans-unit id="83358afe13545467fbcbbf957121011db2230479" translate="yes" xml:space="preserve">
          <source>The actual number of socks is not that large, I don't believe my spouse and I have more than 30 pairs. (And it is fairly easy to distinguish between my socks and hers; can this be used as well?)</source>
          <target state="translated">袜子的实际数量并不多,我不相信我和我的配偶有30多双。(而且相当容易区分我和她的袜子;这个也可以用这个来区分吗?)。</target>
        </trans-unit>
        <trans-unit id="052fd9e524e5e7a091878b38f361a3a987397d74" translate="yes" xml:space="preserve">
          <source>The algorithm</source>
          <target state="translated">算法</target>
        </trans-unit>
        <trans-unit id="f78fa21d86b0d267520ebd8d82fbaae7a3fc5c19" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(ln n + n)&lt;/code&gt; environmental modifications (step 1 &lt;code&gt;O(ln n)&lt;/code&gt; plus picking every pair of sock from the floor)</source>
          <target state="translated">该算法涉及 &lt;code&gt;O(ln n + n)&lt;/code&gt; 环境修改（步骤1 &lt;code&gt;O(ln n)&lt;/code&gt; 加上从地板上捡起的每一双袜子）</target>
        </trans-unit>
        <trans-unit id="1df9e4e8ccdefcdc14130712da6877c276e11de8" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(n^2)&lt;/code&gt; environmental reads from step 2</source>
          <target state="translated">该算法涉及步骤2中的 &lt;code&gt;O(n^2)&lt;/code&gt; 环境读数</target>
        </trans-unit>
        <trans-unit id="dd6aa1a815e2490fabaf33e117c8ad11f5692691" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(n^2)&lt;/code&gt; logical and arithmetic operations for comparing a sock with another in step 2</source>
          <target state="translated">该算法涉及 &lt;code&gt;O(n^2)&lt;/code&gt; 逻辑和算术运算，用于在步骤2中将袜子与另一只袜子进行比较</target>
        </trans-unit>
        <trans-unit id="bb51c91f5c283a2bdff31b863d5e5e5018eb57e0" translate="yes" xml:space="preserve">
          <source>The algorithm terminates with high probability. This is due to the fact that one is unable to find pairs of socks in step number 2.</source>
          <target state="translated">该算法以高概率终止。这是由于人们无法在步骤2中找到成对的袜子。</target>
        </trans-unit>
        <trans-unit id="165efb7623d4620b9e2c0a44514704d6b6dff038" translate="yes" xml:space="preserve">
          <source>The analysis</source>
          <target state="translated">分析结果</target>
        </trans-unit>
        <trans-unit id="abc7bc26ec5efcc62f2a9dd13e54ca3af8f26906" translate="yes" xml:space="preserve">
          <source>The answers till now don't make good use of our human pattern recognition capabilities. The game of Set provides a clue of how to do this well: put all socks in a two-dimensional space so you can both recognize them well and easily reach them with your hands. This limits you to an area of about 120 * 80 cm or so. From there select the pairs you recognize and remove them. Put extra socks in the free space and repeat. If you wash for people with easily recognizable socks (small kids come to mind), you can do a radix sort by selecting those socks first. This algorithm works well only when the  number of single socks is low</source>
          <target state="translated">直到现在的答案都没有很好地利用我们人类的模式识别能力。Set的游戏提供了一条线索,如何做好这一点:把所有的袜子放在一个二维空间里,这样你既能很好地识别它们,又能很容易地用手去够到它们。这就把你限制在一个大约120*80厘米左右的区域内。从那里选择你能识别的袜子对,然后把它们取出来。把多余的袜子放在空闲的空间里,然后重复一遍。如果你洗的是容易辨认的袜子(小个子的孩子就会想到),你可以先选择这些袜子,进行弧度排序。这种算法只有在单双袜子数量较少的情况下才会有很好的效果。</target>
        </trans-unit>
        <trans-unit id="4d052e124ee3ca4cc28b28a0fe3ffd3b80cede47" translate="yes" xml:space="preserve">
          <source>The best real-world partitioning I can think of is creating a &lt;strong&gt;rectangle of piles&lt;/strong&gt;: one dimension is color, the other is the pattern. Why a rectangle? Because we need O(1) random-access to piles. (A 3D &lt;a href=&quot;http://en.wikipedia.org/wiki/Cuboid&quot;&gt;cuboid&lt;/a&gt; would also work, but that is not very practical.)</source>
          <target state="translated">我能想到的最好的现实分区是创建一个&lt;strong&gt;矩形的矩形堆&lt;/strong&gt; ：一个维是颜色，另一个维是图案。 为什么是矩形？ 因为我们需要O（1）随机访问桩。 （3D &lt;a href=&quot;http://en.wikipedia.org/wiki/Cuboid&quot;&gt;长方体&lt;/a&gt;也可以使用，但这不是很实用。）</target>
        </trans-unit>
        <trans-unit id="4b89a467fe48adcd9cc2eef3b60f3e2f90973c34" translate="yes" xml:space="preserve">
          <source>The initial bucket sorting will speed up your process, because it divides your n socks into k buckets in &lt;code&gt;c*n&lt;/code&gt; time so than you will only have to do &lt;code&gt;c*n*log(k)&lt;/code&gt; work. (Not taking into account the threshold). So all in all you do about &lt;code&gt;n*c*(1 + log(k))&lt;/code&gt; work, where c is the time to throw a sock on a pile.</source>
          <target state="translated">最初的存储桶排序将加快您的处理速度，因为它可以在 &lt;code&gt;c*n&lt;/code&gt; 的时间内将n个袜子分成k个存储桶，因此您只需要执行 &lt;code&gt;c*n*log(k)&lt;/code&gt; 即可 。 （不考虑阈值）。 因此，您所做的所有工作都是关于 &lt;code&gt;n*c*(1 + log(k))&lt;/code&gt; 工作，其中c是将袜子扔到桩上的时间。</target>
        </trans-unit>
        <trans-unit id="3ab65ee84b4d8d43507a4f1bd4d7cc40b05e68c1" translate="yes" xml:space="preserve">
          <source>The machine</source>
          <target state="translated">机器</target>
        </trans-unit>
        <trans-unit id="7bb444117bc016eadc9752d11b231edb03e673d8" translate="yes" xml:space="preserve">
          <source>The machine is an abstraction of a the real world element called human being. It is able to read from the environment via a pair of eyes. And our machine model is able to manipulate the environment by using 2 arms. Logical and arithmetic operations are calculated using our brain (hopefully ;-)).</source>
          <target state="translated">机器是现实世界中被称为人的元素的抽象化。它能够通过一双眼睛从环境中读取信息。而我们的机器模型能够用两只手臂来操纵环境。逻辑运算和算术运算都是用我们的大脑来计算的(希望是;-))。</target>
        </trans-unit>
        <trans-unit id="7ecbe36be8e73003b52a651bfa1b97b3b6cb4fd9" translate="yes" xml:space="preserve">
          <source>The method can also be nested, if we have multiple equivalence relations -&amp;gt; make colour piles, than within every pile partition on texture, than sort on length. Any equivalence relation that creates a partition with more than 2 elements that have about even size will bring a speed improvement over sorting (provided we can directly assign a sock to its pile), and the sorting can happen very quickly on smaller data sets.</source>
          <target state="translated">如果我们有多个等价关系-&amp;gt;创建颜色桩，则该方法也可以嵌套，而不是在纹理上的每个桩分区内，在长度上进行排序。 如果任何等价关系创建的分区中有2个以上大小相等的元素，则排序速度会有所提高（前提是我们可以直接将袜子分配给其堆），并且排序可以在较小的数据集上快速进行。</target>
        </trans-unit>
        <trans-unit id="0a27a2fa6c14acbfbc60946013388db1b86f6b79" translate="yes" xml:space="preserve">
          <source>The problem of sorting &lt;strong&gt;your n pairs of socks is O(n)&lt;/strong&gt;. Before you throw them in the laundry &lt;strong&gt;basket&lt;/strong&gt;, you thread the left one to the right one. On taking them out, you cut the thread and put each pair into your drawer - 2 operations on n pairs, so O(n).</source>
          <target state="translated">对&lt;strong&gt;您的n双袜子&lt;/strong&gt;进行排序的问题&lt;strong&gt;是O（n）&lt;/strong&gt; 。 将它们扔进洗衣&lt;strong&gt;篮之前&lt;/strong&gt; ，请先将左侧的一个穿到右侧的一个上。 将它们取出时，您要剪断线并将每对放入抽屉中-n对上有2次操作，所以O（n）。</target>
        </trans-unit>
        <trans-unit id="c5d0caed9ed396ae40259a6681e3e2c91a16dfd9" translate="yes" xml:space="preserve">
          <source>The simplest answer is prior to allowing the pair to be separated, a single data structure for the pair should have been initialized that contained a pointer to the left and right sock, thus enabling socks to be referred to directly or via their pair. A sock may also be extended to contain a pointer to its partner.</source>
          <target state="translated">最简单的答案是,在允许将这对袜子分开之前,应该初始化了这对袜子的单一数据结构,其中包含一个指向左右袜子的指针,这样就可以直接或通过这对袜子来引用袜子。一个袜子也可以扩展到包含指向其伙伴的指针。</target>
        </trans-unit>
        <trans-unit id="1015cb01e1edc8548eb94937e6c0a8fd4cae64a4" translate="yes" xml:space="preserve">
          <source>The simplest parallelization strategy is to have multiple workers take from the input basket and put the socks onto the piles. This only scales up so much - imagine 100 people fighting over 10 piles. &lt;strong&gt;The synchronization costs&lt;/strong&gt; (manifesting themselves as hand-collisions and human communication) &lt;strong&gt;destroy efficiency and speed-up&lt;/strong&gt; (see the &lt;a href=&quot;http://www.perfdynamics.com/Manifesto/USLscalability.html&quot;&gt;Universal Scalability Law&lt;/a&gt;!). Is this prone to &lt;strong&gt;deadlocks&lt;/strong&gt;? No, because each worker only needs to access one pile at a time. With just one &quot;lock&quot; there cannot be a deadlock. &lt;strong&gt;Livelocks&lt;/strong&gt; might be possible depending on how the humans coordinate access to piles. They might just use &lt;a href=&quot;http://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;random backoff&lt;/a&gt; like network cards do that on a physical level to determine what card can exclusively access the network wire. If it works for &lt;a href=&quot;http://en.wikipedia.org/wiki/Network_interface_controller&quot;&gt;NICs&lt;/a&gt;, it should work for humans as well.</source>
          <target state="translated">最简单的并行化策略是让多名工人从输入筐中取出并将袜子放在堆上。 这只会扩展得如此之多-想象有100个人在10堆以上进行战斗。 &lt;strong&gt;同步成本&lt;/strong&gt; （表现为手动冲突和人际交流） &lt;strong&gt;破坏了效率和速度&lt;/strong&gt; （请参见《 &lt;a href=&quot;http://www.perfdynamics.com/Manifesto/USLscalability.html&quot;&gt;通用可扩展性法则》&lt;/a&gt; ！）。 这容易造成&lt;strong&gt;僵局&lt;/strong&gt;吗？ 否，因为每个工人一次只需要访问一堆。 只有一个&amp;ldquo;锁&amp;rdquo;就不会出现死锁。 根据人类如何协调对桩的访问，可能会出现&lt;strong&gt;活锁&lt;/strong&gt; 。 他们可能只使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;随机退避，&lt;/a&gt;就像网卡在物理级别上那样来确定哪些网卡可以独占访问网络线路。 如果它适用于&lt;a href=&quot;http://en.wikipedia.org/wiki/Network_interface_controller&quot;&gt;NIC&lt;/a&gt; ，它也应适用于人类。</target>
        </trans-unit>
        <trans-unit id="d2f49bc795ae24363a2c7470a93203b0fced4c88" translate="yes" xml:space="preserve">
          <source>The special condition in my case is that I don't use drying machine, just hang my cloths on an ordinary cloth dryer. Hanging cloths requires &lt;code&gt;O(n)&lt;/code&gt; operations (by the way, I always consider &lt;a href=&quot;http://en.wikipedia.org/wiki/Bin_packing_problem]&quot;&gt;bin packing&lt;/a&gt; problem here) and the problem by its nature requires the linear &quot;extra&quot; space. When I take a new sock from the bucket I to try hang it next to its pair if the pair is already hung. If its a sock from a new pair I leave some space next to it.</source>
          <target state="translated">我的特殊情况是我不使用烘干机，只是将衣服挂在普通的干衣机上。 挂布需要 &lt;code&gt;O(n)&lt;/code&gt; 运算（顺便说一句，我一直在这里考虑&lt;a href=&quot;http://en.wikipedia.org/wiki/Bin_packing_problem]&quot;&gt;箱装箱&lt;/a&gt;问题），而从本质上讲，该问题需要线性&amp;ldquo;额外&amp;rdquo;空间。 当我从水桶中取出新袜子时，如果袜子已经挂好，可以尝试将其挂在袜子对旁边。 如果是一对新袜子，我旁边会留一些空间。</target>
        </trans-unit>
        <trans-unit id="ce6af0db2fdccac900c8209f502eec96611a6b58" translate="yes" xml:space="preserve">
          <source>The theoretical limit is O(n) because you need to touch each sock (unless some are already paired somehow).</source>
          <target state="translated">理论上的极限是O(n),因为你需要触摸每一只袜子(除非有的袜子已经莫名其妙地成对了)。</target>
        </trans-unit>
        <trans-unit id="2103f930ed2f94482faf224a41b4b0491a977035" translate="yes" xml:space="preserve">
          <source>The worst-case scenario of this scheme is that every pair of socks is different enough that it must be matched exactly, and that the first &lt;em&gt;n/2&lt;/em&gt; socks you pick are all different. This is your &lt;em&gt;O&lt;/em&gt;(n&lt;sup&gt;2&lt;/sup&gt;) scenario, and it's &lt;em&gt;extremely&lt;/em&gt; unlikely. If the number of unique types of sock &lt;em&gt;t&lt;/em&gt; is less than the number of pairs &lt;em&gt;p = n/2&lt;/em&gt;, and the socks in each type are alike enough (usually in wear-related terms) that any sock of that type can be paired with any other, then as I inferred above, the maximum number of socks you will ever have to compare to is &lt;em&gt;t&lt;/em&gt;, after which the next one you pull &lt;em&gt;will&lt;/em&gt; match one of the unpaired socks. This scenario is much more likely in the average sock drawer than the worst-case, and reduces the worst-case complexity to &lt;em&gt;O&lt;/em&gt;(n*t) where usually &lt;em&gt;t &amp;lt;&amp;lt; n&lt;/em&gt;.</source>
          <target state="translated">此方案的最坏情况是每对袜子都足够不同，因此必须精确匹配，并且您选择的前&lt;em&gt;n / 2个&lt;/em&gt;袜子都不同。 这是您的&lt;em&gt;O&lt;/em&gt; （n &lt;sup&gt;2&lt;/sup&gt; ）情况，这&lt;em&gt;极&lt;/em&gt;不可能。 如果唯一类型的袜子的数量&lt;em&gt;t&lt;/em&gt;小于对数&lt;em&gt;p = n / 2&lt;/em&gt; ，并且每种类型的袜子都足够相似（通常以磨损相关的术语），则该类型的任何袜子都可以与任何袜子配对另外，正如我上面所推断的，您将不得不与之进行比较的最大袜子数是&lt;em&gt;t&lt;/em&gt; ，之后您拉出的下一只袜子&lt;em&gt;将&lt;/em&gt;与其中一只未配对的袜子匹配。 与最坏情况相比，这种情况在普通袜子抽屉中更可能发生，并将最坏情况的复杂性降低为&lt;em&gt;O&lt;/em&gt; （n * t），其中通常&lt;em&gt;t &amp;lt;&amp;lt; n&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="96b12eabde3d73be5eafb1e84e13a730dc8628d1" translate="yes" xml:space="preserve">
          <source>Then all you do is snap your socks together right after you take them off and put them in your washing basket, and again you've removed the problem of needing to pair your socks with a physical abstraction of the 'pair' concept.</source>
          <target state="translated">然后你要做的就是把你的袜子脱下来后马上扣在一起,放进你的洗涤篮子里,再一次消除了你的袜子需要配对的问题,用 &quot;配对 &quot;概念的物理抽象来进行配对。</target>
        </trans-unit>
        <trans-unit id="dced202b38f2d14c3908f94ad0c3a8bd7e6f6c93" translate="yes" xml:space="preserve">
          <source>There are two physical possibilities:</source>
          <target state="translated">有两种物理上的可能性。</target>
        </trans-unit>
        <trans-unit id="4e4e9e2d368abd05573c65b163fd925efb9322d4" translate="yes" xml:space="preserve">
          <source>This also means that you will almost certainly never have all your socks in the array, because socks will get removed as they're matched.</source>
          <target state="translated">这也意味着,你几乎肯定不会把所有的袜子都放在阵列中,因为袜子会在配对时被拆掉。</target>
        </trans-unit>
        <trans-unit id="bdfecabe5ec0a698991109d39b1c3465373ad88d" translate="yes" xml:space="preserve">
          <source>This approach will be favourable compared to any &lt;code&gt;c*x*n + O(1)&lt;/code&gt; method roughly as long as &lt;code&gt;log(k) &amp;lt; x - 1&lt;/code&gt;.</source>
          <target state="translated">与任何 &lt;code&gt;c*x*n + O(1)&lt;/code&gt; 方法相比，只要 &lt;code&gt;log(k) &amp;lt; x - 1&lt;/code&gt; 这种方法将是有利的。</target>
        </trans-unit>
        <trans-unit id="5d1f77ce46b573dd375b9b3f8133c6c3e6975fa2" translate="yes" xml:space="preserve">
          <source>This is asking the wrong question. The right question to ask is, why am I spending time sorting socks? How much does it cost on yearly basis, when you value your free time for X monetary units of your choice?</source>
          <target state="translated">这是问错了问题。正确的问题应该问的是,我为什么要花时间整理袜子?当你珍惜自己的空闲时间,用X个货币单位来换取你所选择的X个货币单位时,每年要花多少钱?</target>
        </trans-unit>
        <trans-unit id="c7adcd7ce06b47130e35aa217e78946ac1fdb2c3" translate="yes" xml:space="preserve">
          <source>This is how I actually do it, for &lt;em&gt;p&lt;/em&gt; pairs of socks (&lt;em&gt;n = 2p&lt;/em&gt; individual socks):</source>
          <target state="translated">对于&lt;em&gt;p&lt;/em&gt;对袜子（ &lt;em&gt;n = 2p&lt;/em&gt;个人袜子），我实际上就是这样做的：</target>
        </trans-unit>
        <trans-unit id="235c85c59d6f0d9269c7c93b100ce67634688f1b" translate="yes" xml:space="preserve">
          <source>This kind of recursive hash partitioning is actually being done by &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt; when it needs to hash join or hash aggregate over huge data sets. It distributes its build input stream into many partitions which are independent. This scheme scales to arbitrary amounts of data and multiple CPUs linearly.</source>
          <target state="translated">当需要对大型数据集进行哈希&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;联接&lt;/a&gt;或哈希聚合时，这种递归哈希分区实际上是由SQL Server完成的。 它将其构建输入流分配到许多独立的分区中。 该方案可线性扩展到任意数量的数据和多个CPU。</target>
        </trans-unit>
        <trans-unit id="71188b927e375c9f840b0228303d1ad03320f9ac" translate="yes" xml:space="preserve">
          <source>This question is actually deeply philosophical. At heart it's about whether the power of people to solve problems (the &quot;wetware&quot; of our brains) is equivalent to what can be accomplished by algorithms.</source>
          <target state="translated">这个问题其实是有深刻的哲学意义的。它的核心是关于人解决问题的能力(我们大脑的 &quot;湿器&quot;)是否等同于算法能够完成的事情。</target>
        </trans-unit>
        <trans-unit id="6137f79697d8c825e0bce0519a78dca5b385553f" translate="yes" xml:space="preserve">
          <source>This solves any computational pairing problem by removing it with a layer of abstraction.</source>
          <target state="translated">这就解决了任何计算配对的问题,用抽象层去掉它,就可以解决任何计算配对的问题。</target>
        </trans-unit>
        <trans-unit id="832509383b3fc443a9e0c7a64e684a8be877a579" translate="yes" xml:space="preserve">
          <source>This takes advantage of the human ability to fuzzy-match in O(1) time, which is somewhat equivalent to the establishment of a hash-map on a computing device.</source>
          <target state="translated">这就利用了人类在O(1)时间内进行模糊匹配的能力,这在一定程度上相当于在计算设备上建立了一个哈希图。</target>
        </trans-unit>
        <trans-unit id="bb9e4357cf8c4cf1055b16dd15145dc9529ca43b" translate="yes" xml:space="preserve">
          <source>Thus connecting the problem of pairing socks with the problem of hanging cloths I get &lt;code&gt;O(n)&lt;/code&gt; &quot;extra space&quot; for free, and have a solution that is about &lt;code&gt;O(n)&lt;/code&gt; in time, requires just a little more work than simple hanging cloths and allows to immediately access complete pair of socks even in a very bad Monday morning... ;-)</source>
          <target state="translated">因此，将袜子配对问题和挂布问题联系起来，我免费获得了 &lt;code&gt;O(n)&lt;/code&gt; &amp;ldquo;额外空间&amp;rdquo;，并且有一个时间约为 &lt;code&gt;O(n)&lt;/code&gt; 的解决方案，比简单的挂布需要更多的工作并且即使在一个非常糟糕的星期一早晨也可以立即使用整双袜子... ;-)</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="cc9192722da415eb15991bb6f24cb75e9e00289e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;. This is only linear time since comparison is not required.</source>
          <target state="translated">使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;基数排序&lt;/a&gt; 。 这只是线性时间，因为不需要比较。</target>
        </trans-unit>
        <trans-unit id="72e4524e8782dab66f9edff21207d55131fced9d" translate="yes" xml:space="preserve">
          <source>We also have to consider the intrinsic runtime of the atomic operations that can be carried out with these instruments. Due to physical constraints, operations which are carried out by an arm or eye have non constant time complexity. This is because we can't move an endlessly large pile of socks with an arm nor can an eye see the top sock on an endlessly large pile of socks.</source>
          <target state="translated">我们还必须考虑使用这些仪器进行的原子操作的内在运行时间。由于物理条件的限制,由手臂或眼睛进行的操作具有非恒定的时间复杂性。这是因为我们无法用手臂移动无尽的大堆袜子,眼睛也无法看到无尽的大堆袜子上的顶部袜子。</target>
        </trans-unit>
        <trans-unit id="fc41cda5f1c62ac5f64fac7531ea11668364e843" translate="yes" xml:space="preserve">
          <source>We can also make use of the fact that people only have a very limited amount of socks. So an environmental modification can involve all socks in the pile.</source>
          <target state="translated">我们也可以利用人们的袜子数量非常有限的事实来进行改造。所以一个环境改造,可以把所有的袜子都涉及到堆里的袜子。</target>
        </trans-unit>
        <trans-unit id="7f928a1fe0e4e26c3f5eb42941dbb73bf04c00c1" translate="yes" xml:space="preserve">
          <source>We have to do comparison to check whether two socks come in pair. Pick one of the &lt;code&gt;O(n log n)&lt;/code&gt; comparison-based sorting algorithms.</source>
          <target state="translated">我们必须进行比较以检查是否有两双袜子成对出现。 选择基于 &lt;code&gt;O(n log n)&lt;/code&gt; 比较的排序算法之一。</target>
        </trans-unit>
        <trans-unit id="8aff2e93d02cec92464795e91655b9cf0e01a5bf" translate="yes" xml:space="preserve">
          <source>What I do is that I pick up the first sock and put it down (say, on the edge of the laundry bowl). Then I pick up another sock and check to see if it's the same as the first sock. If it is, I remove them both. If it's not, I put it down next to the first sock. Then I pick up the third sock and compare that to the first two (if they're still there). Etc.</source>
          <target state="translated">我的做法是,我拿起第一只袜子,把它放下来(比如说,放在洗衣盆边上)。然后,我再拿起另一只袜子,检查一下,看看是否和第一只袜子一样。如果是,我就把它们都拿出来。如果不一样,我就把它放在第一只袜子旁边。然后,我拿起第三只袜子,和前两只袜子进行比较(如果还在的话)。以此类推。</target>
        </trans-unit>
        <trans-unit id="52fb31e5804c85af0c9ab1080840c1c1106a6ac7" translate="yes" xml:space="preserve">
          <source>What about &lt;strong&gt;parallelism&lt;/strong&gt;? Can multiple humans match the socks faster?</source>
          <target state="translated">那么&lt;strong&gt;并行性&lt;/strong&gt;呢？ 可以让多个人更快地匹配袜子吗？</target>
        </trans-unit>
        <trans-unit id="62ee3893b3dd45b1448958e4035d217abb5319ed" translate="yes" xml:space="preserve">
          <source>What about the &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;element distinctness problem&lt;/a&gt;? As the article states, the element distinctness problem can be solved in &lt;code&gt;O(N)&lt;/code&gt;. This is the same for the socks problem (also &lt;code&gt;O(N)&lt;/code&gt;, if you need only one distribution step (I proposed multiple steps only because humans are bad at calculations - one step is enough if you distribute on &lt;code&gt;md5(color, length, pattern, ...)&lt;/code&gt;, i.e. a &lt;strong&gt;perfect hash&lt;/strong&gt; of all attributes)).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;元素区分性问题&lt;/a&gt;呢？ 如文章所述，元素区别性问题可以在 &lt;code&gt;O(N)&lt;/code&gt; 中解决。 对于袜子问题（如果只需要一个分配步骤，也是 &lt;code&gt;O(N)&lt;/code&gt; （我提议多个步骤只是因为人类在计算上很差-如果您在 &lt;code&gt;md5(color, length, pattern, ...)&lt;/code&gt; ，即所有属性的&lt;strong&gt;完美哈希值&lt;/strong&gt; ））。</target>
        </trans-unit>
        <trans-unit id="d6e0a1a2a1c968e16f01d631ec79dc29fcbb8978" translate="yes" xml:space="preserve">
          <source>What we want to do is reduce the number of moves, and compensate with the number of searches. Also, we can utilize the multithreded environment of the Homo Sapiens to hold more things in the descision cache.</source>
          <target state="translated">我们要做的是减少移动次数,用搜索次数来弥补。同时,我们还可以利用智人的多核环境,在descision cache中保存更多的东西。</target>
        </trans-unit>
        <trans-unit id="40119aa23f988c392c776aef12173470a672ba85" translate="yes" xml:space="preserve">
          <source>When I sort socks, I do an approximate &lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;, dropping socks near other socks of the same colour/pattern type. Except in the case when I can see an exact match at/near the location I'm about to drop the sock I extract the pair at that point.</source>
          <target state="translated">在对袜子进行排序时，我会进行近似的&lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;基数排序&lt;/a&gt; ，将袜子放在其他具有相同颜色/图案类型的袜子附近。 除非在我即将放下袜子的位置/附近可以看到完全匹配的情况，否则我将在那一点提取这对袜子。</target>
        </trans-unit>
        <trans-unit id="dbe5289d9f14e85418adcf750eb06633c494d931" translate="yes" xml:space="preserve">
          <source>Whenever you pick up a sock, put it in one place.  Then the next sock you pick up, if it doesn't match the first sock, set it beside the first one.  If it does, there's a pair.  This way it doesn't really matter how many combinations there are, and there are only two possibilities for each sock you pick up -- either it has a match that's already in your array of socks, or it doesn't, which means you add it to a place in the array.</source>
          <target state="translated">每当你拿起一只袜子,就把它放在一个地方。然后下一只袜子,如果和第一只袜子不匹配,就把它放在第一只袜子旁边。如果对上了,就有一双。这样一来,有多少个组合并不重要,你拿起的每只袜子只有两种可能--要么它有一个已经在你的袜子阵列中的匹配,要么它没有,这意味着你把它添加到阵列中的一个地方。</target>
        </trans-unit>
        <trans-unit id="491d10d638725516cd524ff053d646b7db3211cb" translate="yes" xml:space="preserve">
          <source>Why five? Usually humans are good are remembering between five and seven different elements in the working memory - a bit like the human equivalent of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;RPN&lt;/a&gt; stack - five is a safe default.</source>
          <target state="translated">为什么是五个？ 通常，人类会记住在工作存储器中的五个到七个不同的元素（有点像&lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;RPN&lt;/a&gt;堆栈的人类等效元素），五个是安全的默认值。</target>
        </trans-unit>
        <trans-unit id="4e43cc34e87ad7b769f2e692b3183f1cf7531543" translate="yes" xml:space="preserve">
          <source>X = Yours, Y = Your spouses</source>
          <target state="translated">X=你的,Y=你的配偶</target>
        </trans-unit>
        <trans-unit id="bfa8f5c7b6006f4ab74b72c8afabacf5f628c548" translate="yes" xml:space="preserve">
          <source>Yesterday I was pairing the socks from the clean laundry and figured out the way I was doing it is not very efficient. I was doing a naive search&amp;nbsp;&amp;mdash; picking one sock and &quot;iterating&quot; the pile in order to find its pair. This requires iterating over n/2 * n/4 = n&lt;sup&gt;2&lt;/sup&gt;/8 socks on average.</source>
          <target state="translated">昨天我从干净的洗衣店里给袜子配对了，发现我做这件事的方式不是很有效。 我一直在天真地搜寻-挑选一只袜子并&amp;ldquo;反复&amp;rdquo;堆以找到那只袜子。 这需要平均迭代n / 2 * n / 4 = n 2/8个袜子。</target>
        </trans-unit>
        <trans-unit id="dbd5aa135244891d8a3e76bf37cc43c7ca49ef7d" translate="yes" xml:space="preserve">
          <source>Yet times to times, I have to do this again (lost socks, damaged socks, etc.), and I hate to discard perfectly good socks too often (and I wished they kept selling the same socks reference!), so I recently took a different approach.</source>
          <target state="translated">然而好几次,我又不得不这样做(丢失的袜子,损坏的袜子等),我讨厌太频繁地丢弃完全好的袜子(我希望他们继续卖相同的袜子参考!),所以最近我采取了不同的方法。</target>
        </trans-unit>
        <trans-unit id="65810e5cb0ea23b0c4ace9656f94508778f1c8cd" translate="yes" xml:space="preserve">
          <source>You can achieve O(n) with &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;. You just need to pick some attributes for the buckets.</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;基数排序&lt;/a&gt;实现O（n）。 您只需要为存储桶选择一些属性即可。</target>
        </trans-unit>
        <trans-unit id="ba38f2aaa4cb49326b1693f418fc55f635bc82d4" translate="yes" xml:space="preserve">
          <source>You don't need recursive partitioning if you can find a distribution key (hash key) that &lt;strong&gt;provides enough buckets&lt;/strong&gt; that each bucket is small enough to be processed very quickly. Unfortunately, I don't think socks have such a property.</source>
          <target state="translated">如果您可以找到一个&lt;strong&gt;提供足够存储桶&lt;/strong&gt;的分发密钥（哈希密钥），而每个存储桶足够小，可以非常快速地进行处理，则不需要递归分区。 不幸的是，我认为袜子没有这种特性。</target>
        </trans-unit>
        <trans-unit id="991cf8e975ca3081b3b2acc02dc579d8b387f197" translate="yes" xml:space="preserve">
          <source>You need to estimate how many pairs of socks you will need for the rest of your life, or perhaps until you retire and move to warmer climates with no need to wear socks ever again. If you are young, you could also estimate how long it takes before we'll all have sock-sorting robots in our homes, and the whole problem becomes irrelevant.</source>
          <target state="translated">你需要估算一下你的余生需要多少双袜子,或许直到你退休后搬到气候温暖的地方,再也不用穿袜子了。如果你还年轻,你也可以估算一下,在我们的家里都有袜子分类机器人之前,需要多长时间,整个问题就变得无关紧要了。</target>
        </trans-unit>
        <trans-unit id="fbfa245099ad6c7e954cd2c2f169e543c5ddc580" translate="yes" xml:space="preserve">
          <source>You need to find out how you can order your selected sock in bulk, and how much it costs, and do they deliver.</source>
          <target state="translated">你需要了解一下你所选择的袜子如何批量订购,费用是多少,以及他们会不会送货上门。</target>
        </trans-unit>
        <trans-unit id="a2c3fba934e9cc7f3bb5f1c5bf7698755a4d500b" translate="yes" xml:space="preserve">
          <source>any subset taken from the top of this bin generally contains both
socks of a pair.</source>
          <target state="translated">任何从这个仓的顶部取的子集一般都包含一对袜子。</target>
        </trans-unit>
        <trans-unit id="66103b5b15e1b774175c59b31bb92026836434e7" translate="yes" xml:space="preserve">
          <source>environmental modifications</source>
          <target state="translated">环境改造</target>
        </trans-unit>
        <trans-unit id="b72a142027a3d942512bfeebef1158e5555cdbf9" translate="yes" xml:space="preserve">
          <source>environmental reads</source>
          <target state="translated">环保读物</target>
        </trans-unit>
        <trans-unit id="73ed780668cf0ea89fb1a13af96da25121e815d0" translate="yes" xml:space="preserve">
          <source>logical and arithmetic operations</source>
          <target state="translated">逻辑运算和算术运算</target>
        </trans-unit>
        <trans-unit id="7b417589bff426c4c61c5b75b1f2b186688fc14d" translate="yes" xml:space="preserve">
          <source>p&lt;sub&gt;1&lt;/sub&gt; p&lt;sub&gt;2&lt;/sub&gt; p&lt;sub&gt;3&lt;/sub&gt; ... p&lt;sub&gt;n&lt;/sub&gt; p&lt;sub&gt;f(1)&lt;/sub&gt; p&lt;sub&gt;f(2)&lt;/sub&gt; ... p&lt;sub&gt;f(n)&lt;/sub&gt;</source>
          <target state="translated">p &lt;sub&gt;1&lt;/sub&gt; p &lt;sub&gt;2&lt;/sub&gt; p &lt;sub&gt;3&lt;/sub&gt; ... p &lt;sub&gt;n&lt;/sub&gt; p &lt;sub&gt;f（1）&lt;/sub&gt; p &lt;sub&gt;f（2）&lt;/sub&gt; ... p &lt;sub&gt;f（n）&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d64b5bfb8d253171cb7f047779677b1f366a37c7" translate="yes" xml:space="preserve">
          <source>people toss both of their socks roughly in the same area of the
bin,</source>
          <target state="translated">人们把两只袜子大概都扔在垃圾箱的同一区域。</target>
        </trans-unit>
        <trans-unit id="e7aa0c831ecd9e4ccd9acd48f58060ccc6e98d8a" translate="yes" xml:space="preserve">
          <source>step 1) discard all your existing socks</source>
          <target state="translated">步骤1)丢弃你现有的所有袜子</target>
        </trans-unit>
        <trans-unit id="85929a76b2535ede46f1da6de8472cf210e6cc72" translate="yes" xml:space="preserve">
          <source>step 2) go to &lt;a href=&quot;http://en.wikipedia.org/wiki/Walmart&quot;&gt;Walmart&lt;/a&gt; and buy them by packets of 10 - n packet of
white and m packets of black. No need for other colors in everyday's
life.</source>
          <target state="translated">步骤2）前往&lt;a href=&quot;http://en.wikipedia.org/wiki/Walmart&quot;&gt;沃尔玛（Walmart）&lt;/a&gt; ，以10包-白色n包和m黑色包的价格购买它们。 日常生活中无需其他颜色。</target>
        </trans-unit>
        <trans-unit id="f0bc37af84619514b988559161037a53edaa21ff" translate="yes" xml:space="preserve">
          <source>the bin is not randomized at any point, and therefore</source>
          <target state="translated">bin在任何一点上都不是随机化的,因此</target>
        </trans-unit>
        <trans-unit id="937822ebb59548bbc8c060e49cb9b98efb226b16" translate="yes" xml:space="preserve">
          <source>then length of the sock,</source>
          <target state="translated">然后是袜子的长度。</target>
        </trans-unit>
        <trans-unit id="f0604a64202bf39aaef8452c27dea8a360470c75" translate="yes" xml:space="preserve">
          <source>then texture,
....</source>
          <target state="translated">然后是纹理,......</target>
        </trans-unit>
        <trans-unit id="f0038d5ea027e24fd063b53770f561619dfa487e" translate="yes" xml:space="preserve">
          <source>then use colors (can have any order for the colors, e.g. alphabetically by color name) - split them into piles by color (remember to keep the initial order from step 1 for all socks in the same pile),</source>
          <target state="translated">然后使用颜色(可以有任何颜色的顺序,例如,按颜色名称的字母顺序)--按颜色将它们分成一堆(记住,对于同一堆中的所有袜子,要保持步骤1中的初始顺序)。</target>
        </trans-unit>
        <trans-unit id="4045b164d7574af579063ab4269d98a5011ed66a" translate="yes" xml:space="preserve">
          <source>where f is an unknown permutation of the set {1,2,...,n}. Knowing this cannot make the problem harder. There are n! possible outputs (matchings between first and second half), which means you need log(n!) = Omega(n log n) comparisons. This is obtainable by sorting.</source>
          <target state="translated">其中f是集合{1,2,...,n}的一个未知的permutation。知道这一点不能使问题更难解决。有n! 可能的输出(前半部分和后半部分之间的匹配),这意味着你需要log(n!)=Omega(n log n)的比较。这可以通过排序得到。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
