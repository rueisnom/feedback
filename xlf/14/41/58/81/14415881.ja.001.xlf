<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/14415881">
    <body>
      <group id="14415881">
        <trans-unit id="94c0dfc6b17aa37cab713289ff046437e179508f" translate="yes" xml:space="preserve">
          <source>&quot;if s pairs with a sock t in N&quot;.  How quickly can we &quot;remember&quot; what we've seen so far?</source>
          <target state="translated">&quot;もし s が N の靴下 t とペアになったら&quot; 今まで見てきたことを どれだけ早く &quot;思い出す &quot;ことができるでしょうか?</target>
        </trans-unit>
        <trans-unit id="b5bdc0f37905c659679678b282a51daad6b30c24" translate="yes" xml:space="preserve">
          <source>&quot;remove t from N&quot; and &quot;add s to N&quot;.  How expensive is keeping track of what we've seen so far?</source>
          <target state="translated">&quot;nからtを取り除く&quot; &quot;nにsを加える&quot; これまで見てきたものを記録しておくのは どれくらいのコストがかかるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="257027605f38139d5816c62c3274fa0db3930e71" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;This approach can be fairly easily be implemented in an array, assuming that &quot;removing&quot; socks is an option.&lt;/s&gt; Actually, you don't even need to &quot;remove&quot; socks. If you don't need sorting of the socks (see below), then you can just move them around and end up with an array that has all the socks arranged in pairs in the array.</source>
          <target state="translated">&lt;s&gt;この方法は、「靴下を取り除く」という選択肢があるとすれば、かなり簡単に配列に実装できます。&lt;/s&gt; 実際には、靴下を「取り除く」必要さえありません。 靴下をソートする必要がない場合（下記を参照）、それらを移動して、すべての靴下を配列でペアに配置した配列を作成できます。</target>
        </trans-unit>
        <trans-unit id="6fae469126cdfe9fb170ccabec0390cf8682c501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Heuristic:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Heuristic:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8be3cb9316f7f1176c171daf3e0ce96f2978c5e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithmic answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アルゴリズムの答え：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6dd89168d13c44609bd0eb1bed16428f8b39446" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BTW&lt;/strong&gt;, I found that the sum of the transaction costs of sorting all the socks every time I needed a pair were far less than doing it once and binding the socks. A just-in-time works better because then you don't have to bind the socks, and there's also a diminishing marginal return (that is, you keep looking for that two or three socks that when somewhere in the laundry and that you need to finish matching your socks and you lose time on that).</source>
          <target state="translated">&lt;strong&gt;ところで&lt;/strong&gt; 、ペアが必要になるたびにすべての靴下を並べ替えるトランザクションコストの合計は、一度実行して靴下をバインドするよりもはるかに少ないことがわかりました。 靴下を縛る必要がないため、ジャストインタイムの方が効果的です。また、限界利益が減少します（つまり、洗濯物のどこかにあるときに必要な靴下を2つか3つ探し続けます）あなたの靴下とのマッチングを完了すると、あなたはそれで時間を失います。</target>
        </trans-unit>
        <trans-unit id="2b5ac05a4a642e4eaddf91d074d8a86d8f9607d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1&lt;/strong&gt;: All socks are identical (this is what I do in real life by the way).</source>
          <target state="translated">&lt;strong&gt;ケース1&lt;/strong&gt; ：すべての靴下は同一です（これは実際に私が実際に行っていることです）。</target>
        </trans-unit>
        <trans-unit id="49a8a493d307384ee45499ab7676db0d67425182" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2&lt;/strong&gt;: There are a constant number of combinations (ownership, color, size, texture, etc.).</source>
          <target state="translated">&lt;strong&gt;ケース2&lt;/strong&gt; ：組み合わせの数は一定です（所有権、色、サイズ、テクスチャなど）。</target>
        </trans-unit>
        <trans-unit id="e00424d21a9c0392d4676ab7c8a9295c1d65c888" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 3&lt;/strong&gt;: The number of combinations is not known in advance (general case).</source>
          <target state="translated">&lt;strong&gt;ケース3&lt;/strong&gt; ：組み合わせの数が事前にわかっていない（一般的なケース）。</target>
        </trans-unit>
        <trans-unit id="0b50c6f3b067c6fae56c03d06a7d861b64518113" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-algorithmic answer, yet &quot;efficient&quot; when I do it:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;非アルゴリズム的な答えですが、それでも私は「効率的」です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f1ed3b5cf07fad91eb01fcb7a682e9e1f3420c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional&lt;/strong&gt; While you are searching the line and and the current sock you are looking at is identical to the previous, do step 2 for these socks.</source>
          <target state="translated">&lt;strong&gt;オプション&lt;/strong&gt;ラインを検索していて、現在表示している靴下が以前と同じである場合、これらの靴下に対して手順2を実行します。</target>
        </trans-unit>
        <trans-unit id="4e7b1dad68f6cce31ec46db04710d5118a2d7aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preconditions:&lt;/strong&gt;
There is no guarantee that there are the same socks. If they are of the same color it doesn't mean they have the same size or pattern. Socks are randomly shuffled. There can be odd number of socks (some are missing, we don't know how many). Prepare to remember a variable &quot;index&quot; and set it to 0.</source>
          <target state="translated">&lt;strong&gt;前提条件：&lt;/strong&gt;同じ靴下があることを保証するものではありません。 それらが同じ色である場合、それらが同じサイズまたはパターンであることを意味するわけではありません。 靴下はランダムにシャッフルされます。 靴下の数が奇数である可能性があります（いくつかは足りない、私たちは何枚かわかりません）。 変数「インデックス」を覚えて、0に設定する準備をします。</target>
        </trans-unit>
        <trans-unit id="e8d739a374e59173c2a911ac09bb3cfac524d27d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recursively apply this scheme&lt;/strong&gt; until you have distributed all socks onto &lt;strong&gt;very small piles that you can visually process immediately&lt;/strong&gt;</source>
          <target state="translated">すべての靴下を&lt;strong&gt;視覚的にすぐに処理できる非常に小さな山に&lt;/strong&gt;分配するまで、 &lt;strong&gt;このスキームを再帰的に適用&lt;/strong&gt; &lt;strong&gt;します&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b4b7ec4098550470ed2c4636c449a2c24d32ee0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, the question is basically:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;したがって、質問は基本的には次のとおりです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08fda84558211c3c93b54ebc0219bb815255b9af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1:&lt;/strong&gt; Each time you put dirty socks in your laundry basket, tie them in a little knot. That way you will not have to do any sorting after the washing. Think of it like registering an index in a Mongo database. A little work ahead for some CPU savings in the future.</source>
          <target state="translated">&lt;strong&gt;解決策1：&lt;/strong&gt;汚れた靴下を洗濯かごに入れるたびに、小さな結び目で結びます。 そうすれば、洗浄後に分別を行う必要はありません。 Mongoデータベースにインデックスを登録するようなものだと考えてください。 将来的には、いくつかのCPUを節約するために少し作業を進めます。</target>
        </trans-unit>
        <trans-unit id="b93e25b8a424a36b38ce0b2f666db17b4cec3ad9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2:&lt;/strong&gt; If it's winter, you don't have to wear matching socks. We are programmers. Nobody needs to know, as long as it works.</source>
          <target state="translated">&lt;strong&gt;解決策2：&lt;/strong&gt;冬なら、お揃いの靴下を着用する必要はありません。 私たちはプログラマーです。 それが機能する限り、誰も知る必要はありません。</target>
        </trans-unit>
        <trans-unit id="0094560f52b8dad6f4ad715c3c000c707e442bb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 3:&lt;/strong&gt; Spread the work. You want to perform such a complex CPU process asynchronously, without blocking the UI. Take that pile of socks and stuff them in a bag. Only look for a pair when you need it. That way the amount of work it takes is much less noticeable.</source>
          <target state="translated">&lt;strong&gt;解決策3：&lt;/strong&gt;仕事を広める。 このような複雑なCPUプロセスを、UIをブロックせずに非同期で実行したいとします。 その靴下の山を取り、バッグに詰めます。 必要なときだけペアを探してください。 そうすることで、必要な作業量が大幅に少なくなります。</target>
        </trans-unit>
        <trans-unit id="cd64c3cf6ffd817f997a05ddde37296211310d6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result&lt;/strong&gt; will have one or two piles: 1. &quot;matched&quot; and 2. &quot;missing&quot;</source>
          <target state="translated">&lt;strong&gt;結果&lt;/strong&gt;には、1つまたは2つのパイルがあります。1。「一致」および2.「欠落」</target>
        </trans-unit>
        <trans-unit id="1873002ca8758724d2c9adf28e13baa534b32d50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are trying to solve the wrong problem.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;あなたは間違った問題を解決しようとしています。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42553619c0d4d907f8c4939e4417b4728dc4eff8" translate="yes" xml:space="preserve">
          <source>A general &lt;em&gt;theoretical&lt;/em&gt; solution for a huge number of socks.</source>
          <target state="translated">靴下の膨大な数の一般&lt;em&gt;的&lt;/em&gt;な&lt;em&gt;理論的な&lt;/em&gt;ソリューション。</target>
        </trans-unit>
        <trans-unit id="86619e9b5473c8436c88e4580124cac4300c7011" translate="yes" xml:space="preserve">
          <source>A neat freak might use numeric labels for pairs as someone suggested.  This opens the door to a total ordering, which allows the human to use exactly the same algorithms we might with a CPU: binary search, trees, hashes, etc.</source>
          <target state="translated">きちんとしたフリークは、誰かが提案したようにペアに数値ラベルを使うかもしれない。これは完全な順序付けへの扉を開き、人間がCPUと全く同じアルゴリズムを使うことを可能にします:バイナリ検索、ツリー、ハッシュなど。</target>
        </trans-unit>
        <trans-unit id="e2b68ea4fb20ff8e31763199ca38f49c47f03983" translate="yes" xml:space="preserve">
          <source>About parallelism:
As long as you toss both socks into the same bin, you can easily parallelize all of those steps.</source>
          <target state="translated">平行化について。両方の靴下を同じビンに捨てる限り、それらの手順をすべて簡単に並列化することができます。</target>
        </trans-unit>
        <trans-unit id="f6fc8d26eb16b2c7196aa947f223e3e3ed467028" translate="yes" xml:space="preserve">
          <source>After eliminating the fluro coloured, the socks with stripes, and the three pairs of long socks, you might end up with mostly white socks roughly sorted by how worn they are.</source>
          <target state="translated">フルーロカラー、ストライプのソックス、ロングソックスの3足を除外すると、白のソックスがほとんどになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="98f0ebf5e1f426f9d4fb354b2d2f98129af56fdf" translate="yes" xml:space="preserve">
          <source>After that, there are only a few socks left. This is where I introduce previously unpaired socks into the system and process the remaining socks without any special algorithm - the remaining socks are very few and can be processed visually very fast.</source>
          <target state="translated">その後、残っている靴下はわずかです。ここで、以前にペアリングされていない靴下をシステムに導入して、特別なアルゴリズムを使わずに残った靴下を処理しています-残った靴下は非常に少なく、視覚的にも非常に速く処理することができます。</target>
        </trans-unit>
        <trans-unit id="f910680ab39d0aa8398bce15b13e098f9be2e9a8" translate="yes" xml:space="preserve">
          <source>After this, it's easy to do the hash partitioning algorithm. Usually, about 75% of the socks are already paired, leaving me with a very small subset of socks, and this subset is already (somewhat) clustered (I don't introduce much entropy into my basket after the preprocessing steps). Another thing is that the remaining clusters tend to be small enough to be handled at once, so it is possible to take a whole cluster out of the basket.</source>
          <target state="translated">この後、ハッシュ分割アルゴリズムを実行するのは簡単です。通常、靴下の約75%はすでにペアリングされているので、靴下の非常に小さなサブセットが残り、このサブセットはすでに(ある程度)クラスタ化されています(私は前処理ステップの後、バスケットにあまりエントロピーを導入していません)。もう一つは、残りのクラスターは一度に処理できるほど小さくなる傾向があるので、バスケットからクラスター全体を取り出すことができるということです。</target>
        </trans-unit>
        <trans-unit id="a610a16cc6741362976a74534a8c23c401cdcb8f" translate="yes" xml:space="preserve">
          <source>Almost all the other algorithms (including &lt;a href=&quot;https://stackoverflow.com/a/14419556/1042311&quot;&gt;the top scoring answer by usr&lt;/a&gt;) sort, then remove pairs. I find that, as a human, it is better to minimize the number of socks being considered at one time.</source>
          <target state="translated">他のほとんどすべてのアルゴリズム（ &lt;a href=&quot;https://stackoverflow.com/a/14419556/1042311&quot;&gt;usrによる上位スコアの回答&lt;/a&gt;を含む）は、ソートしてからペアを削除します。 人間としては、一度に考慮される靴下の数を最小限に抑える方が良いと私は思います。</target>
        </trans-unit>
        <trans-unit id="eccc8c5a89378f08c10b8d673e29520d1e8e7126" translate="yes" xml:space="preserve">
          <source>Also, there could be added check for damaged socks also, as if the removal of those. It could be inserted between 2 and 3, and between 13 and 14.</source>
          <target state="translated">また、それらの除去のように、破損した靴下のチェックを追加することもできます。2と3の間、13と14の間に入れることができます。</target>
        </trans-unit>
        <trans-unit id="9788a20dd94a5a2bf372d767d6027859c72d11c2" translate="yes" xml:space="preserve">
          <source>Also, we don't need to assume a large number of socks, even for large families. Socks are taken out of the drawer and are worn, and then they are tossed in a place (maybe a bin) where they stay before being laundered. While I wouldn't call said bin a LIFO-Stack, I'd say it is safe to assume that</source>
          <target state="translated">また、大家族でも靴下の枚数を多く想定する必要はありません。靴下は、引き出しから出して履いて、洗濯する前にビンのような場所に放り込まれています。私はそのビンをLIFOスタックとは呼びませんが、以下のように考えても良いと思います。</target>
        </trans-unit>
        <trans-unit id="157fc609ec55f17f263d7a3a005a4071e377c228" translate="yes" xml:space="preserve">
          <source>Although the outputs are not exactly the same (in one case, just a boolean. In the other case, the pairs of socks), the asymptotic complexities are the same.</source>
          <target state="translated">出力は厳密には同じではありませんが(あるケースではブーリアンだけ、他のケースでは靴下のペア)、漸近的な複雑さは同じです。</target>
        </trans-unit>
        <trans-unit id="05e0d0df0a6446265996f77e214ab1168f512228" translate="yes" xml:space="preserve">
          <source>An alternative step 3 would involve comparing costs of buying the same amount of perhaps cheaper socks a few pairs at a time over the years and adding the cost of sorting socks, but take my word for it: buying in bulk is cheaper! Also, socks in storage increase in value at the rate of stock price inflation, which is more than you would get on many investments. Then again there is also storage cost, but socks really do not take much space on the top shelf of a closet.</source>
          <target state="translated">別のステップ3では、同じ量の安い靴下を何年もかけて数足ずつ購入した場合のコストを比較し、靴下の仕分けにかかるコストを加えることになりますが、私の言葉を借りれば、まとめ買いの方が安いということです。また、保管されている靴下の価値は、株価のインフレ率に応じて上昇します。その後、再びストレージコストもありますが、靴下は本当にクローゼットの上の棚の上に多くのスペースを取ることはありません。</target>
        </trans-unit>
        <trans-unit id="3835c018ca31a4eabdd14cc9d36b8f5e0b2ee808" translate="yes" xml:space="preserve">
          <source>An obvious algorithm for sock sorting is:</source>
          <target state="translated">靴下のソートのための明白なアルゴリズムは</target>
        </trans-unit>
        <trans-unit id="56b599442bccb5b5949e6ad41c70544a44257d97" translate="yes" xml:space="preserve">
          <source>And more often than not, this is not just &lt;em&gt;any&lt;/em&gt; free time, it's &lt;em&gt;morning&lt;/em&gt; free time, which you could be spending in bed, or sipping your coffee, or leaving a bit early and not being caught in the traffic.</source>
          <target state="translated">そして、たいていの場合、これはただの自由時間ではなく、 &lt;em&gt;朝の&lt;/em&gt;自由時間であり、ベッドで過ごす、コーヒーを飲む、または少し早く出発して交通に巻き込まれない可能性があります。</target>
        </trans-unit>
        <trans-unit id="121979168ac388fe182e793a8f415d4c02e0bcfd" translate="yes" xml:space="preserve">
          <source>And there is a way!</source>
          <target state="translated">そして、方法があります!</target>
        </trans-unit>
        <trans-unit id="aaed1a26327f668180ed38055a98d2f4a897c097" translate="yes" xml:space="preserve">
          <source>Applying the same idea to the practical problem of pairing socks, the apparent answer is: don't allow your socks to ever be unpaired. Socks are provided as a pair, put in the drawer as a pair (perhaps by balling them together), worn as a pair. But the point where unpairing is possible is in the washer, so all that's required is a physical mechanism that allows the socks to stay together and be washed efficiently.</source>
          <target state="translated">同じ考えを靴下のペアリングという現実的な問題に当てはめてみると、明らかな答えは、「靴下は絶対にペアリングされていない状態にしてはいけない」ということです。靴下はペアで提供され、ペアで引き出しに入れられ、ペアで履かれます。しかし、ペアリングを外すことができるのは洗濯機の中なので、必要なのは、靴下がペアリングされたままで、効率的に洗濯できるような物理的なメカニズムなのです。</target>
        </trans-unit>
        <trans-unit id="4447172c03cd07d366eaa6901d47c0105462f432" translate="yes" xml:space="preserve">
          <source>As a computer scientist I was thinking what I could do? Sorting (according to size/color/...) of course came to mind to achieve an O(NlogN) solution.</source>
          <target state="translated">コンピュータ科学者として何ができるかを考えていました。O(NlogN)の解を得るためには、もちろんソート(サイズカラーによる...)が頭に浮かんできました。</target>
        </trans-unit>
        <trans-unit id="dea5f13104d5d8bafb26f6f1728af7ebead57e19" translate="yes" xml:space="preserve">
          <source>As a practical solution:</source>
          <target state="translated">現実的な解決策として</target>
        </trans-unit>
        <trans-unit id="0330f3b9f6b91d26ecc04e1313146ad77b320f18" translate="yes" xml:space="preserve">
          <source>As rapidly as possible, remove socks from the unsorted pile one at a time and place in piles in front of you. The piles should be arranged somewhat space-efficiently, with all socks pointing the same direction; the number of piles is limited by the distance you can easily reach. The selection of a pile on which to put a sock should be -- as rapidly as possible -- by putting a sock on a pile of apparently like socks; the occasional type I (putting a sock on a pile it doesn't belong to) or type II (putting a sock in its own pile when there's an existing pile of like socks) error can be tolerated -- the most important consideration is &lt;em&gt;speed&lt;/em&gt;. Once all the socks are in piles, rapidly go through the multi-sock piles creating pairs and removing them (these are heading for the drawer). If there are non-matching socks in the pile, re-pile them to their best (within the as-fast-as-possible constraint) pile. When all the multi-sock piles have been processed, match up remaining pairable socks that weren't paired due to type II errors. Whoosh, you're done -- and I have a lot of socks and don't wash them until a large fraction are dirty. Another practical note: I flip the top of one of a pair of socks down over the other, taking advantage of their elastic properties, so they stay together while being transported to the drawer and while in the drawer.</source>
          <target state="translated">できるだけ早く、並べ替えられていない山から靴下を1つずつ取り外し、目の前の山に置きます。 パイルは、すべての靴下が同じ方向を向くように、多少スペース効率よく配置する必要があります。 パイルの数は、簡単に到達できる距離によって制限されます。 靴下を置く山の選択は、一見したところ靴下のような山に靴下を置くことによって、可能な限り迅速に行う必要があります。 タイプI（属していないパイルに靴下を置く）またはタイプII（同じようなソックスの既存のパイルがある場合、それ自体のパイルに靴下を置く）エラーは許容できます-最も重要な考慮事項は&lt;em&gt;速度です&lt;/em&gt; 。 すべての靴下がパイルになったら、マルチソックパイルをすばやく通過してペアを作成し、それらを削除します（これらは引き出しに向かっています）。 パイルに一致しない靴下がある場合は、それらを（可能な限り高速の制約内で）最高のパイルに再度パイルします。 すべてのマルチソックパイルが処理されたら、タイプIIエラーのためにペアリングされなかった残りのペアリング可能なソックスを一致させます。 おっと、これで完了です。私は靴下をたくさん持っています。大部分が汚れるまで洗わないでください。 もう1つの実用的な注意：伸縮性のある特性を利用して、靴下のペアの一方の上部をもう一方の上部にひっくり返し、引き出しに運ばれているときも、引き出しの中にあるときも一緒にとどまります。</target>
        </trans-unit>
        <trans-unit id="21c82dc8d9601ae12e034b45a03f0358de859eb2" translate="yes" xml:space="preserve">
          <source>As the architecture of the human brain is completely different than a modern CPU, this question makes no practical sense.</source>
          <target state="translated">人間の脳のアーキテクチャは現代のCPUとは全く違うので、この質問は実用的には意味がありません。</target>
        </trans-unit>
        <trans-unit id="c9da0c9b1a26a80303bb8c443c01afa8a2584687" translate="yes" xml:space="preserve">
          <source>Assuming that the only operation for socks is to compare for equality, this algorithm is basically still an n&lt;sup&gt;2&lt;/sup&gt; algorithm, though I don't know about the average case (never learned to calculate that).</source>
          <target state="translated">靴下の唯一の演算が等しいかどうかを比較することであると仮定すると、このアルゴリズムは基本的にまだn &lt;sup&gt;2&lt;/sup&gt;アルゴリズムですが、平均的なケースについてはわかりません（それを計算することを学んだことはありません）。</target>
        </trans-unit>
        <trans-unit id="9ecfa67dfd0923fad315f8a06acb48f7f0237861" translate="yes" xml:space="preserve">
          <source>At least this is what I am using in real life, and I find it very efficient. The downside is it requires a flat surface, but it's usually abundant.</source>
          <target state="translated">少なくともこれは私が実際に使っているもので、非常に効率的だと感じています。欠点は、それが平らな面を必要とすることですが、それは通常豊富です。</target>
        </trans-unit>
        <trans-unit id="5b86498f0344f03ab782a1075a31f259917a9553" translate="yes" xml:space="preserve">
          <source>At some point, the differences between socks are small enough that other people won't notice the difference, and any further matching effort is not needed.</source>
          <target state="translated">ある時点では、靴下の違いは他の人が気づかないほど小さく、それ以上のマッチングの努力は必要ありません。</target>
        </trans-unit>
        <trans-unit id="7e52e0e243840d708880946b6c4315d013367de6" translate="yes" xml:space="preserve">
          <source>But for each sock to keep a reference to the other, there is a neat solution: a popper (or a 'snap button' if you're American), such as these:</source>
          <target state="translated">しかし、他の参照を維持するためにそれぞれの靴下のために、きちんとしたソリューションがあります:これらのようなポッパー(または 'スナップ ボタン' アメリカ人の場合)、。</target>
        </trans-unit>
        <trans-unit id="b59dc09b425cf2a04ad8751ed78176abb3f57590" translate="yes" xml:space="preserve">
          <source>By pulling the distinctive socks first, you leave space to &quot;zoom&quot; in on the features which are less distinctive, to begin with.</source>
          <target state="translated">特徴的な靴下を最初に引っ張ることで、特徴的ではない部分を「ズーム」するスペースを残します。</target>
        </trans-unit>
        <trans-unit id="325f07a647449aca13d04b404d5077e42950128f" translate="yes" xml:space="preserve">
          <source>By reducing my inputs to one of two types of socks (white socks for recreation, black socks for work), I only need to determine which of two socks I have in hand. (Technically, since they are never washed together, I have reduced the process to O(0) time)</source>
          <target state="translated">2種類の靴下(レクリエーション用の白い靴下、仕事用の黒い靴下)のうちの1種類にインプットを減らすことで、手元にある2種類の靴下のうち、どちらの靴下かを判断するだけで済むようになりました。(厳密には、これらの靴下は一緒に洗うことはないので、O(0)の時間で処理を終了しました)</target>
        </trans-unit>
        <trans-unit id="839d4561e5360dfca7e45fa2801c421ef3ca26fb" translate="yes" xml:space="preserve">
          <source>Choose one of the socks and put it away (create a 'bucket' for that pair)</source>
          <target state="translated">靴下の中から一つを選び、片付ける(そのペアのための「バケツ」を作る</target>
        </trans-unit>
        <trans-unit id="5d6b924144b70d6a90942c0979240ccaa91f1233" translate="yes" xml:space="preserve">
          <source>Clearly, one cannot go faster than &lt;code&gt;O(N)&lt;/code&gt;, so we have reached the &lt;strong&gt;optimal lower bound&lt;/strong&gt;.</source>
          <target state="translated">明らかに、 &lt;code&gt;O(N)&lt;/code&gt; より速く進むことはできないため、 &lt;strong&gt;最適な下限に&lt;/strong&gt;達しました。</target>
        </trans-unit>
        <trans-unit id="9a74f91f894f5fdd53f2126400da6be5bbf36590" translate="yes" xml:space="preserve">
          <source>Combine with Other Task</source>
          <target state="translated">他のタスクとの組み合わせ</target>
        </trans-unit>
        <trans-unit id="8ac6a3ace758bdb634f5dc66fbca8858d699c4a7" translate="yes" xml:space="preserve">
          <source>Consider a hash-table of  size  'N'.</source>
          <target state="translated">サイズ 'N' のハッシュテーブルを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="be4d36fcb52cd8affab669c9c320903855e4dd53" translate="yes" xml:space="preserve">
          <source>Consider than if you draw only one sock for the second stack of socks, as you are doing, your odds of finding the matching sock in a naive search is quite low.</source>
          <target state="translated">あなたがやっているように、あなたが2番目のスタックの靴下のために1つだけの靴下を描いた場合よりも、あなたのナイーブな検索で一致する靴下を見つける確率はかなり低いことを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="f9b1944832d9453a7dc17748fdc3d9173cbd95c9" translate="yes" xml:space="preserve">
          <source>Cost: Moving socks -&amp;gt; high, finding/search socks in line -&amp;gt; small</source>
          <target state="translated">コスト：靴下を移動する-&amp;gt;高い、靴下を並べて検索する-&amp;gt;小さい</target>
        </trans-unit>
        <trans-unit id="05201805c52c192640e03bce4060ac08d6051851" translate="yes" xml:space="preserve">
          <source>Create a hash table which will be used for unmatched socks, using the pattern as the hash. Iterate over the socks one by one. If the sock has a pattern match in the hash table, take the sock out of the table and make a pair. If the sock does not have a match, put it into the table.</source>
          <target state="translated">パターンをハッシュとして使用して、一致しない靴下のために使用されるハッシュテーブルを作成します。靴下を一足ずつ順に並べていきます。ハッシュテーブルのパターンと一致する靴下があれば、その靴下をテーブルから取り出してペアを作る。一致しない場合は、テーブルの中に入れる。</target>
        </trans-unit>
        <trans-unit id="ece5b7e4f44f0c60b7df2b4d7656e3eb3246bbfd" translate="yes" xml:space="preserve">
          <source>Do until A is empty.</source>
          <target state="translated">Aが空になるまでやる。</target>
        </trans-unit>
        <trans-unit id="a3af62234185a8fbf95199db3ed4496b2e1b062b" translate="yes" xml:space="preserve">
          <source>Do until both X and Y is empty.</source>
          <target state="translated">XとYの両方が空になるまで行います。</target>
        </trans-unit>
        <trans-unit id="e74f486c764075c4dfed8abc5b9386d07590d29c" translate="yes" xml:space="preserve">
          <source>Don't waste your time moving socks around or looking for the best match, this all should be done in O(n), which we would also need for just putting them on the line unsorted.
The socks aren't paired yet, we only have several similarity clusters on the line. It's helpful that we have a limited set of socks here, as this helps us to create &quot;good&quot; clusters (for example, if there are only black socks in the set of socks, clustering by colours would not be the way to go)</source>
          <target state="translated">靴下を移動させたり、最適なものを探したりして時間を無駄にしないでください。靴下はまだペアリングされていないので、ライン上にはいくつかの類似性のクラスタがあるだけです。靴下のセットが限られていることは、&quot;良い &quot;クラスタを作るのに役立つからです(例えば、靴下のセットの中に黒い靴下しかない場合、色でクラスタリングするのは良くありません)。</target>
        </trans-unit>
        <trans-unit id="e9b450d14bc2363d292c84f17cfad5cfbd58a458" translate="yes" xml:space="preserve">
          <source>Done</source>
          <target state="translated">Done</target>
        </trans-unit>
        <trans-unit id="9ec877009e8b5ea7edaecdf46b39cdf271ac5e08" translate="yes" xml:space="preserve">
          <source>Feel free to write down the formula to calculate how many samples you have to draw for a 50% odds of a match. IIRC it's an hypergeometric law.</source>
          <target state="translated">50%の確率で勝負するためには 何個のサンプルを描かなければならないか 計算する公式を自由に書いてください。私の記憶では双幾何学の法則です。</target>
        </trans-unit>
        <trans-unit id="ee75e1685f87ca197f6c3aaaa97916949e86e0db" translate="yes" xml:space="preserve">
          <source>Find a pair by looking at the socks on the floor.</source>
          <target state="translated">床に置いてある靴下を見て、一足を探してみましょう。</target>
        </trans-unit>
        <trans-unit id="2d7f4a781c3305161bd0ab2917bdad576999ed2c" translate="yes" xml:space="preserve">
          <source>Find a sock you like. Take all relevant features into account: colour in different lighting conditions, overall quality and durability, comfort in different climatic conditions, and odour absorption. Also important is, they should not lose elasticity in storage, so natural fabrics are good, and they should be available in a plastic wrapping.</source>
          <target state="translated">気に入った靴下を見つけてください。さまざまな照明条件での色、全体的な品質と耐久性、さまざまな気候条件での快適性、匂いの吸収性など、関連するすべての機能を考慮に入れてください。また、保管中に伸縮性を失ってはいけないので、天然素材のものが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="a9a8d801aad71c6f999c991c92a663302901ccc9" translate="yes" xml:space="preserve">
          <source>Find all matched pairs, pack it and move packed pairs to &quot;matched&quot; pile;
 If there were no new matches - increment &quot;index&quot; by 1</source>
          <target state="translated">マッチしたすべてのペアを見つけ、それを梱包し、梱包したペアを「matched」の山に移動する;新しいマッチがなかった場合は、「インデックス」を1インクリメントする</target>
        </trans-unit>
        <trans-unit id="52c3a2cfe2904b404c77eec5836501de1058b709" translate="yes" xml:space="preserve">
          <source>Find its match.</source>
          <target state="translated">マッチしたものを見つけてください。</target>
        </trans-unit>
        <trans-unit id="c0a4340783c31b2ef43b6cdc9d203753e623f8c3" translate="yes" xml:space="preserve">
          <source>Find its pair</source>
          <target state="translated">ペアを探す</target>
        </trans-unit>
        <trans-unit id="9398e96bcda6ff722938ce7ced4416bbac5aa5f1" translate="yes" xml:space="preserve">
          <source>Find most distinctive sock.</source>
          <target state="translated">最も特徴的な靴下を探します。</target>
        </trans-unit>
        <trans-unit id="82f8de3c35ca9b182c746b9a61ec6f2e62e7264c" translate="yes" xml:space="preserve">
          <source>First you can choose (hers, mine) - split them into 2 piles,</source>
          <target state="translated">最初にあなたが選ぶことができます(彼女の、私の)-2つの山にそれらを分割します。</target>
        </trans-unit>
        <trans-unit id="893e0080cad23ba3476d1e48d4706a557776aeeb" translate="yes" xml:space="preserve">
          <source>For a 'pair' object that keeps a pointer to each sock we could have a cloth bag that we use to keep the socks together. This seems like massive overhead.</source>
          <target state="translated">それぞれの靴下へのポインタを保持している「ペア」オブジェクトの場合、靴下を一緒に保持するために使用する布袋を持つことができます。これは膨大なオーバーヘッドのように思えます。</target>
        </trans-unit>
        <trans-unit id="077ecc6cb20560a33edffb3287fdf7ac14426d24" translate="yes" xml:space="preserve">
          <source>For all remaining socks, I assume that their counterparts are still unwashed and put them away for the next iteration. If you register a growth of unpaired socks over time (a &quot;sock leak&quot;), you should check your bin - it might get randomized (do you have cats which sleep in there?)</source>
          <target state="translated">残っているすべての靴下については、それらの靴下がまだ洗濯されていないと仮定して、次の反復のために片付けます。時間が経つにつれてペアリングされていない靴下が増えてきた場合(「靴下漏れ」)、自分の箱をチェックしてみてください。</target>
        </trans-unit>
        <trans-unit id="cc92f3e9adf433b615dccfeb6da282fce4ea8901" translate="yes" xml:space="preserve">
          <source>For each color of socks, &lt;strong&gt;form a pile&lt;/strong&gt;. Iterate over all socks in your input basket &lt;strong&gt;and distribute them onto the color piles&lt;/strong&gt;.</source>
          <target state="translated">靴下の色ごとに&lt;strong&gt;パイルを作り&lt;/strong&gt;ます。 入力バスケットのすべての靴下を反復処理し&lt;strong&gt;、カラーパイルに分散させます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6414c797002dc91c1ae83eaf49240cdcbf24e18" translate="yes" xml:space="preserve">
          <source>For each line X and Y</source>
          <target state="translated">各行XとYに対して</target>
        </trans-unit>
        <trans-unit id="5855dab75f8b813fca7ffaa714ea108a4295227b" translate="yes" xml:space="preserve">
          <source>For the first sock, or if all previously-chosen socks have been paired, simply place the sock into the first &quot;slot&quot; of an &quot;array&quot; of unpaired socks in front of you.</source>
          <target state="translated">最初の靴下の場合、または以前に選んだ靴下がすべてペアリングされている場合は、ペアリングされていない靴下が並んでいる「アレイ」の最初の「スロット」に靴下を置くだけです。</target>
        </trans-unit>
        <trans-unit id="894192607ac808554f03c075fd0655a37e1ad671" translate="yes" xml:space="preserve">
          <source>For the following runtime analysis of pairing &lt;code&gt;n&lt;/code&gt; pairs of socks, we suppose that at least half of the &lt;code&gt;2n&lt;/code&gt; socks aren't hidden after step 1. So in the average case we can find &lt;code&gt;n/2&lt;/code&gt; pairs. This means that the loop is step 4 is executed &lt;code&gt;O(log n)&lt;/code&gt; times. Step 2 is executed &lt;code&gt;O(n^2)&lt;/code&gt; times. So we can conclude:</source>
          <target state="translated">靴下の &lt;code&gt;n&lt;/code&gt; ペアをペアリングする次の実行時分析では、 &lt;code&gt;2n&lt;/code&gt; 靴下の少なくとも半分がステップ1の後で非表示にならないと仮定します。したがって、平均的なケースでは &lt;code&gt;n/2&lt;/code&gt; ペアを見つけることができます。 つまり、ステップ4のループは &lt;code&gt;O(log n)&lt;/code&gt; 回実行されます 。 ステップ2は &lt;code&gt;O(n^2)&lt;/code&gt; 回実行されます。 したがって、以下を結論付けることができます。</target>
        </trans-unit>
        <trans-unit id="cd22dd03c04d34755de0454c107040828d993fa6" translate="yes" xml:space="preserve">
          <source>Forget &quot;index&quot;</source>
          <target state="translated">インデックスを忘れて</target>
        </trans-unit>
        <trans-unit id="754feeeb1411a93845cc30e2f433edcea6d8f1d0" translate="yes" xml:space="preserve">
          <source>From pile A of all socks:</source>
          <target state="translated">すべての靴下のAの山から</target>
        </trans-unit>
        <trans-unit id="88af6c6ae694d3f0adbd64981b429a7c2015afc5" translate="yes" xml:space="preserve">
          <source>From your question it is clear you don't have much actual experience with laundry :). You need an algorithm that works well with a small number of non-pairable socks.</source>
          <target state="translated">あなたの質問から、あなたが洗濯の経験がないことは明らかです。)少ない数のペアリング不可能な靴下でもうまく機能するアルゴリズムが必要です。</target>
        </trans-unit>
        <trans-unit id="0444a1d3195984e21f70709ff60bf0a46830a14e" translate="yes" xml:space="preserve">
          <source>Get rid of your old socks.</source>
          <target state="translated">古い靴下を処分しましょう。</target>
        </trans-unit>
        <trans-unit id="a1a874f464be482c37caf7802d65a53aaacd038a" translate="yes" xml:space="preserve">
          <source>Given a pile of &lt;code&gt;n&lt;/code&gt; pairs of socks, containing &lt;code&gt;2n&lt;/code&gt; elements (assume each sock has exactly one matching pair), what is the best way to pair them up efficiently with up to logarithmic extra space? (I believe I can remember that amount of info if needed.)</source>
          <target state="translated">&lt;code&gt;2n&lt;/code&gt; 個の要素を含む &lt;code&gt;n&lt;/code&gt; ペアの靴下の山（各靴下に一致するペアが1つだけあると想定）を前提として、それらを対数の余分なスペースまで効率的にペアリングする最良の方法は何ですか？ （必要に応じて、その量の情報を思い出せると思います。）</target>
        </trans-unit>
        <trans-unit id="92391b2bac5f63b1732ccf6a829b75982b2d6b4f" translate="yes" xml:space="preserve">
          <source>Go to 1</source>
          <target state="translated">1へ</target>
        </trans-unit>
        <trans-unit id="7548a76daeaf6efed0b0d32caeb5242aedd1b6ef" translate="yes" xml:space="preserve">
          <source>Grab a sock at random from the pile.</source>
          <target state="translated">山の中からランダムに靴下をつかむ。</target>
        </trans-unit>
        <trans-unit id="8b31726f5fe78e7abfdb271081348d3c49ef8d7a" translate="yes" xml:space="preserve">
          <source>Hashing or other not-in-place solutions are not an option, because I am not able to duplicate my socks (though it could be nice if I could).</source>
          <target state="translated">ハッシュなどの場違いな解決策は、靴下の複製ができていないので(できればいいのですが)、仕方がありません。</target>
        </trans-unit>
        <trans-unit id="0bebef8e20477195eae330c945bf1f33000ef38c" translate="yes" xml:space="preserve">
          <source>Have it Almost &lt;code&gt;O(n)&lt;/code&gt;!</source>
          <target state="translated">ほぼ &lt;code&gt;O(n)&lt;/code&gt; にしてください！</target>
        </trans-unit>
        <trans-unit id="d3cc97a68c770f1ea7c6ba0f7a34ec7739feed82" translate="yes" xml:space="preserve">
          <source>Here's an Omega(n log n) lower bound in comparison based model. (The only valid operation is comparing two socks.)</source>
          <target state="translated">ここに比較ベースのモデルのオメガ(n log n)下限があります。(有効な操作は2つの靴下を比較することだけです)</target>
        </trans-unit>
        <trans-unit id="08f1f9a1a68f065efbd777b85e911439d922e715" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for put_socks_on_line():</source>
          <target state="translated">put_socks_on_line()のアルゴリズムです。</target>
        </trans-unit>
        <trans-unit id="54268b27bb372ae27ec075e414013dd493b79119" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for sort_remaining_clusters():</source>
          <target state="translated">sort_remaining_clusters()のアルゴリズムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a12197b6379a8cd2d9de831467c2eea0d417e206" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for take_socks_from_line():</source>
          <target state="translated">take_socks_from_line()のアルゴリズムです。</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">これが役に立つことを願っています</target>
        </trans-unit>
        <trans-unit id="5435330177144a505ebd78530841aed23ef79bd1" translate="yes" xml:space="preserve">
          <source>How to pair socks from a pile efficiently</source>
          <target state="translated">積み上げた靴下を効率よくペアリングする方法</target>
        </trans-unit>
        <trans-unit id="0163309c2cf5dde27bf33b63dc03540e97a8c089" translate="yes" xml:space="preserve">
          <source>However in real life when the number of socks is relatively small (constant), these theoretically optimal algorithms wouldn't work well. It might take even more time than sequential search, which theoretically requires quadratic time.</source>
          <target state="translated">しかし、実際の生活では、靴下の数が比較的少ない(一定)場合、これらの理論的に最適なアルゴリズムはうまく動作しません。理論的に二次時間を必要とする逐次探索よりもさらに時間がかかるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c187385279c8ededa5efc4f1fe03ebf17e729283" translate="yes" xml:space="preserve">
          <source>However mechanical physics give us some goodies as well. We are not limited to move at most one sock with an arm. We can move a whole couple of them at once.</source>
          <target state="translated">しかし、力学的な物理学は、私たちにもいくつかの利点を与えてくれます。私たちは腕で靴下を動かすことに制限されているわけではありません。私たちは、それらの全体のカップルを一度に移動することができます。</target>
        </trans-unit>
        <trans-unit id="4eb82567512fc8943c9bca03d3dcc2dfbfc9658a" translate="yes" xml:space="preserve">
          <source>However, as this have simillar complexity as selection sort, the time taken is far less due to the speeds of I/O(moving socks) and search(searching the line for a sock).</source>
          <target state="translated">しかし、これは選択ソートと似たような複雑さを持っているため、IO(靴下の移動)と検索(靴下を探す)の速度が速いため、かかる時間ははるかに短くなっています。</target>
        </trans-unit>
        <trans-unit id="2e5ae82866972c6fb5d15e4d37146f8fd8f90802" translate="yes" xml:space="preserve">
          <source>Human beings will use various strategies to effect these. &lt;a href=&quot;http://garfield.library.upenn.edu/classics1979/A1979HX09600001.pdf&quot;&gt;Human memory &lt;em&gt;is&lt;/em&gt; associative&lt;/a&gt;, something like a hash table where feature sets of stored values are paired with the corresponding values themselves. For example, the concept of &quot;red car&quot; maps to all the red cars a person is capable of remembering. Someone with a perfect memory has a perfect mapping.  Most people are imperfect in this regard (and most others).  The associative map has a limited capacity. Mappings may &lt;em&gt;bleep&lt;/em&gt; out of existence under various circumstances (one beer too many), be recorded in error (&quot;I though her name was Betty, not Nettie&quot;), or never be overwritten even though we observe that the truth has changed (&quot;dad's car&quot; evokes &quot;orange Firebird&quot; when we actually knew he'd traded that in for the red Camaro).</source>
          <target state="translated">人間はさまざまな戦略を使ってこれらを実現します。 &lt;a href=&quot;http://garfield.library.upenn.edu/classics1979/A1979HX09600001.pdf&quot;&gt;人間の記憶&lt;em&gt;は&lt;/em&gt;連想的であり&lt;/a&gt; 、格納された値の機能セットが対応する値自体とペアになっているハッシュテーブルのようなものです。 たとえば、「赤い車」の概念は、人が覚えることができるすべての赤い車に対応します。 完璧な記憶を持つ人は完璧なマッピングを持っています。 ほとんどの人はこの点で不完全です（そして他のほとんどの人）。 連想マップの容量は限られています。 マッピングは、さまざまな状況（1つのビールが多すぎる）で存在から&lt;em&gt;消える&lt;/em&gt;か、誤って記録される（「私は彼女の名前はNettieではなくBettyでした」）、または真実が変わったと観察しても（「お父さんの名前車」は「オレンジ色の火の鳥」を呼び起こし、彼が赤いカマロと交換したことを実際に知っていました。</target>
        </trans-unit>
        <trans-unit id="be87a28a5429a75a2d77e39569b97b2cef88f1c6" translate="yes" xml:space="preserve">
          <source>Humans can win over CPU algorithms using the fact that &quot;finding a matching pair&quot; can be one operation for a set that isn't too big.</source>
          <target state="translated">人間は、「一致するペアを見つける」ということが、大きすぎない集合に対して1つの操作で済むという事実を利用して、CPUアルゴリズムに勝つことができます。</target>
        </trans-unit>
        <trans-unit id="b1ed976246d93e04e79fea702823d280ba48c2ad" translate="yes" xml:space="preserve">
          <source>I came out with another solution which would not promise fewer operations, neither less time consumption, but it should be tried to see if it can be a good-enough heuristic to provide less time consumption in huge series of sock pairing.</source>
          <target state="translated">私は別の解決策を考え出しましたが、それは、より少ない操作を約束するものではなく、より少ない時間の消費を提供するために、靴下のペアリングの巨大なシリーズでより少ない時間の消費を提供するのに十分なヒューリスティックであることができるかどうかを確認するためにそれを試してみる必要があります。</target>
        </trans-unit>
        <trans-unit id="b0d5c8c30ccdae2afc794d4c2db85857ecf68b61" translate="yes" xml:space="preserve">
          <source>I do that every morning and rarely need more than three draws - but I have &lt;code&gt;n&lt;/code&gt; similar pairs (around 10, give or take the lost ones) of &lt;code&gt;m&lt;/code&gt; shaped white socks. Now you can estimate the size of my stack of stocks :-)</source>
          <target state="translated">私は毎朝それを行い、めったに3回以上のドローが必要になることはありません。しかし、 &lt;code&gt;m&lt;/code&gt; 型の白い靴下の &lt;code&gt;n&lt;/code&gt; 個の同様のペア（約10を与えるか、失くしたもの）を持っています。 今、あなたは私の株式のスタックのサイズを推定することができます:-)</target>
        </trans-unit>
        <trans-unit id="b28189bbbd02c084d10ef3c4022c033ec385886f" translate="yes" xml:space="preserve">
          <source>I do this by:</source>
          <target state="translated">私はこれをしています。</target>
        </trans-unit>
        <trans-unit id="f58214503dfea8f36b2d81a7d7e31591c0696f80" translate="yes" xml:space="preserve">
          <source>I found integrating the process of sorting into hanging to dry makes it a breeze. I need to pick up each sock anyway, and hang it (move) and it costs me about nothing to hang it in a specific place on the strings. Now just not to force search of the whole buffer (the strings) I choose to place socks by color/shade. Darker left, brighter right, more colorful front etc. Now before I hang each sock, I look in its &quot;right vicinity&quot; if a matching one is there already - this limits &quot;scan&quot; to 2-3 other socks - and if it is, I hang the other one right next to it. Then I roll them into pairs while removing from the strings, when dry.</source>
          <target state="translated">私は、仕分けのプロセスを乾燥させるためにぶら下げに統合すると、それが微風になります。私はとにかくそれぞれの靴下をピックアップし、それをハングアップする必要があります(移動)と、それは文字列上の特定の場所にそれをハングアップするために私には何のコストがかかります。今は、バッファ全体(紐)を無理に探さないように、靴下を色分けして配置しています。左が濃い色、右が明るい色、前がカラフルな色などです。それぞれの靴下を吊るす前に、その靴下の「右近」にマッチする靴下が既にあるかどうかを調べます-これにより、「スキャン」は2-3枚の靴下に制限されます-もしあれば、その隣にもう1枚の靴下を吊るします。そして、乾いたら、紐から外しながらペアにしていきます。</target>
        </trans-unit>
        <trans-unit id="2af9d76529a0f3da9452d50f18323e0df517ebc3" translate="yes" xml:space="preserve">
          <source>I had derived this as a part of another puzzle,but I would be happy to be proven wrong. 
&lt;a href=&quot;https://appolo85.wordpress.com/2012/07/25/some-fun-with-hash-table-performance-analysis/&quot;&gt;Here's my blog article on the same&lt;/a&gt;</source>
          <target state="translated">私はこれを別のパズルの一部として導出しましたが、間違っていることが証明されて嬉しいです。 &lt;a href=&quot;https://appolo85.wordpress.com/2012/07/25/some-fun-with-hash-table-performance-analysis/&quot;&gt;これは私の同じブログ記事です&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d670bfbf52f40edfc5d3d99f6588d8b35cfcbaa" translate="yes" xml:space="preserve">
          <source>I have taken simple steps to reduce my effort into a process taking O(1) time.</source>
          <target state="translated">私は自分の努力をO(1)の時間がかかるプロセスに減らすために、簡単なステップを踏んでいます。</target>
        </trans-unit>
        <trans-unit id="6f7a73657ec6fa088026a984672b83ade80856e7" translate="yes" xml:space="preserve">
          <source>I hope I can contribute something new to this problem. I noticed that all of the answers neglect the fact that there are two points where you can perform &lt;strong&gt;preprocessing&lt;/strong&gt;, without slowing down your overall laundry performance.</source>
          <target state="translated">私はこの問題に新しい何かを貢献できることを願っています。 洗濯の全体的なパフォーマンスを低下させることなく、 &lt;strong&gt;前処理&lt;/strong&gt;を実行できる点が2つあるという事実をすべての回答が無視していることに気付きました。</target>
        </trans-unit>
        <trans-unit id="712bf975bcdafbec473428cad084553f88032e4b" translate="yes" xml:space="preserve">
          <source>I know that these algorithms take a lot of assumptions: a bin which acts as some sort of LIFO stack, a limited, normal washing machine, and a limited, normal clothesline - but this still works with very large numbers of socks.</source>
          <target state="translated">私は、これらのアルゴリズムが多くの仮定を取ることを知っています:LIFOスタックのいくつかの種類として機能するビン、限定された通常の洗濯機、および限定された通常の洗濯機-しかし、これはまだ非常に大きな数の靴下で動作します。</target>
        </trans-unit>
        <trans-unit id="76250d1db233c115621eea33b2e23f2fa2575836" translate="yes" xml:space="preserve">
          <source>I should point out that in order to improve the speed of the remaining steps, it is wise not to randomly pick the next sock, but to sequentially take sock after sock from each cluster.
Both preprocessing steps don't take more time than just putting the socks on the line or in the basket, which we have to do no matter what, so this should greatly enhance the laundry performance.</source>
          <target state="translated">ここで指摘しておきたいのは、残りのステップのスピードを上げるためには、次の靴下をランダムに選ぶのではなく、各クラスターから順次靴下を取っていくのが賢明だということです。どちらの前処理ステップも、何があってもやらなければならない靴下をラインに並べたりカゴに入れたりするだけの作業よりも時間がかからないので、洗濯のパフォーマンスが格段に上がるはずです。</target>
        </trans-unit>
        <trans-unit id="059e704445c273ca6d35e7eca97772e45a2005db" translate="yes" xml:space="preserve">
          <source>I think that there should be an Omega(n&lt;sup&gt;2&lt;/sup&gt;) bound for the original problem if you allow equality tests only. My intuition is: Consider a graph where you add an edge after a test, and argue that if the graph is not dense the output is not uniquely determined.</source>
          <target state="translated">等価性テストのみを許可する場合、元の問題にはOmega（n &lt;sup&gt;2&lt;/sup&gt; ）の限界があるはずだと思います。 私の直感は、テスト後にエッジを追加するグラフを考え、グラフが密でない場合、出力は一意に決定されないと主張します。</target>
        </trans-unit>
        <trans-unit id="efa09f0b1f8cd3ce6a3acb81e6f0774e3942dc69" translate="yes" xml:space="preserve">
          <source>I will appreciate an answer that addresses the following aspects:</source>
          <target state="translated">以下のような点を取り上げた回答を評価したいと思います。</target>
        </trans-unit>
        <trans-unit id="b480ebea69ff0685142986485477474b5d752c12" translate="yes" xml:space="preserve">
          <source>I'm looking forward to hear about any experiences or corrections.</source>
          <target state="translated">経験談や修正点があれば教えていただけると嬉しいです。</target>
        </trans-unit>
        <trans-unit id="7e3fa720280a90386643c5f943bbc31f1027bcda" translate="yes" xml:space="preserve">
          <source>I've finished pairing my socks just right now, and I found that the best way to do it is the following:</source>
          <target state="translated">ちょうど今、靴下のペアリングが終わったところなのですが、一番いい方法を見つけたのは</target>
        </trans-unit>
        <trans-unit id="b298e00cd80e135c4ae40839f21a896eee2181a4" translate="yes" xml:space="preserve">
          <source>If &quot;index&quot; is greater then 2 (this could be value dependent on sock
 number because with greater number of socks there are less chance to
  pair them blindly) go to 11</source>
          <target state="translated">index&quot; が 2 よりも大きい場合は 11 に進みます。</target>
        </trans-unit>
        <trans-unit id="428e83ad437da92aef4bb4acff910ff3919184bd" translate="yes" xml:space="preserve">
          <source>If each sock had an integer called &quot;PairID&quot; one could easily distribute them into 10 buckets according to &lt;code&gt;PairID % 10&lt;/code&gt; (the last digit).</source>
          <target state="translated">各靴下に「PairID」と呼ばれる整数がある場合、 &lt;code&gt;PairID % 10&lt;/code&gt; （最後の桁）に従ってそれらを10個のバケットに簡単に分散できます。</target>
        </trans-unit>
        <trans-unit id="68824b3b629564ab1d8b0bad06e1c81bc8489125" translate="yes" xml:space="preserve">
          <source>If match found pair it, pack pair and move it to the &quot;matched&quot; pile</source>
          <target state="translated">一致する場合は、ペアを見つけて、ペアをパックして、それを &quot;一致した &quot;パイルに移動します。</target>
        </trans-unit>
        <trans-unit id="b8510e4192393a95bad638ba90d06ef53c82e071" translate="yes" xml:space="preserve">
          <source>If the &quot;move&quot; operation is fairly expensive, and the &quot;compare&quot; operation is cheap, and you need to move the whole set anyway, into a buffer where search is much faster than in original storage... just integrate sorting into the obligatory move.</source>
          <target state="translated">もし、「移動」操作がかなり高価で、「比較」操作が安価で、検索が元のストレージよりもはるかに高速なバッファに、とにかくセット全体を移動する必要があるならば...ソートを義務的な移動に統合すればいいだけです。</target>
        </trans-unit>
        <trans-unit id="9b3e803c4a76f4c4bd7562f58a50ba5f385ebf8f" translate="yes" xml:space="preserve">
          <source>If the next one is the pair of the previous one, then put it to the existing bucket, otherwise create a new one.</source>
          <target state="translated">次のバケットが前のバケットのペアであれば、それを既存のバケットに入れ、そうでなければ新しいバケットを作成します。</target>
        </trans-unit>
        <trans-unit id="4a8ea1dd91e78f2f6ed036a3127326ca0c1544c5" translate="yes" xml:space="preserve">
          <source>If there are less then 6 socks, go to 11.</source>
          <target state="translated">靴下が6枚以下の場合は11枚目へ。</target>
        </trans-unit>
        <trans-unit id="5101d1843bf2d194d47695b1f7bbc961cb8fc0b4" translate="yes" xml:space="preserve">
          <source>If there are still more then one socks go to 12</source>
          <target state="translated">まだある場合は、1つの靴下は12に行く</target>
        </trans-unit>
        <trans-unit id="b79f9eb2311d2f31b42294fff21e572d50944666" translate="yes" xml:space="preserve">
          <source>If there is just one left go to 14</source>
          <target state="translated">残り1つなら14へ</target>
        </trans-unit>
        <trans-unit id="0580e1c44a88013044e269db8383aef639694455" translate="yes" xml:space="preserve">
          <source>If there is no match, put it on the &quot;missing&quot; pile.</source>
          <target state="translated">マッチしない場合は、「足りない」の山に入れてください。</target>
        </trans-unit>
        <trans-unit id="a78596387c9d98455857ff9c74f61a0ca08821df" translate="yes" xml:space="preserve">
          <source>If there is no pair for the sock, move it to the &quot;missing&quot; pile</source>
          <target state="translated">靴下のペアがない場合は、「欠品」の山に移動します。</target>
        </trans-unit>
        <trans-unit id="c1faf9fe0339936f19f4a80510b7ee0dc13723d0" translate="yes" xml:space="preserve">
          <source>If we assume normal distribution, then the estimated number of 'insertions'  to have atleast one sock mapped to one bucket is NlogN  (ie, all buckets are full)</source>
          <target state="translated">正規分布を仮定すると、少なくとも1つの靴下を1つのバケツにマッピングするための「挿入」の推定数は、NlogN (つまり、すべてのバケツが満杯である)です。</target>
        </trans-unit>
        <trans-unit id="7fee5c386c3eac901a5e47b38f613ae422e201ea" translate="yes" xml:space="preserve">
          <source>If you can pick a limited number of attributes, but enough attributes that can uniquely identify each pair, you should be done in O(k * n), which is O(n) if we can consider k is limited.</source>
          <target state="translated">属性の数は限られているが、各ペアを一意に識別できるだけの十分な属性を選ぶことができれば、kが限られていると考えればO(k*n)で済むはずである。</target>
        </trans-unit>
        <trans-unit id="362a61837395e933805325f6b6ebe951c78dd045" translate="yes" xml:space="preserve">
          <source>If you chose a fancy pair with different left and right sock, doing a full bucket sort to left and right foot buckets take O(N+M), where N is the number of socks and M is same as above. Somebody else can give the formula for average iterations of finding the first pair, but worst case for finding a pair with blind search is N/2+1, which becomes astronomically unlikely case for reasonable N. This can be sped up by using advanced image recognition algorithms and heuristics, when scanning the pile of unsorted socks with &lt;a href=&quot;http://www.urbandictionary.com/define.php?term=Mk1%20eyeball&quot;&gt;Mk1 Eyeball&lt;/a&gt;.</source>
          <target state="translated">左右の靴下が異なるファンシーペアを選択した場合、フルバケットソートを左右の足バケットに実行するとO（N + M）がかかります。Nは靴下の数で、Mは上記と同じです。 他の誰かが最初のペアを見つける平均反復の式を与えることができますが、ブラインドサーチでペアを見つけるための最悪のケースはN / 2 + 1です。 &lt;a href=&quot;http://www.urbandictionary.com/define.php?term=Mk1%20eyeball&quot;&gt;Mk1 Eyeball&lt;/a&gt;でソートされていない靴下の山をスキャンするときの認識アルゴリズムとヒューリスティック。</target>
        </trans-unit>
        <trans-unit id="14a24a331e031cc668435241346b7c07a641d7fb" translate="yes" xml:space="preserve">
          <source>If you do not, put the current sock into the first open slot in the array.</source>
          <target state="translated">そうでない場合は、現在の靴下をアレイの最初に開いているスロットに入れます。</target>
        </trans-unit>
        <trans-unit id="71950a186d51133a9e0950587efebd65ce355f77" translate="yes" xml:space="preserve">
          <source>If you find an acceptable match, put both socks together and remove them from the array.</source>
          <target state="translated">一致するものが見つかったら、両方の靴下を一緒にして、配列から外します。</target>
        </trans-unit>
        <trans-unit id="6f824c95564ff831ff4658d289a3cc3fbd50a604" translate="yes" xml:space="preserve">
          <source>If you have 1000 socks, with 8 colors and an average distribution, you can make 4 piles of each 125 socks in c*n time. With a threshold of 5 socks you can sort every pile in 6 runs. (Counting 2 seconds to throw a sock on the right pile it will take you little under 4 hours.)</source>
          <target state="translated">8 色の靴下が 1000 枚あって、平均的な分布がある場合、125 枚の靴下を c*n 時間で 4 つのパイルに分けることができます。5個の靴下を基準にすると、6回の実行ですべての靴下を並べ替えることができます。(靴下を正しいパイルに投げるために2秒をカウントすると、4時間弱かかります)</target>
        </trans-unit>
        <trans-unit id="e6180d90736fe61c2fee7b217194e6e292349b2c" translate="yes" xml:space="preserve">
          <source>If you have just 60 socks, 3 colors and 2 sort of socks (yours / your wife's) you can sort every pile of 10 socks in 1 runs (Again threshold = 5). (Counting 2 seconds it will take you 2 min).</source>
          <target state="translated">もしあなたが60枚の靴下を持っていて、3色と2種類の靴下(あなたと奥さんの)を持っていたら、10枚の靴下の山を1回で分類することができます(ここでもしきい値は5)。(2秒を数えて2分)。</target>
        </trans-unit>
        <trans-unit id="1642673d491acf03991115db1b99d02263fa0f61" translate="yes" xml:space="preserve">
          <source>If you have one or more selected unpaired socks, check your current sock against all the unpaired socks in the array.</source>
          <target state="translated">選択されていないペアリングされていない靴下が 1 つ以上ある場合は、現在の靴下を配列内のすべてのペアリングされていない靴下と比較して確認します。</target>
        </trans-unit>
        <trans-unit id="f56085360df34e1a4ad17c6698a237315bf8ce9d" translate="yes" xml:space="preserve">
          <source>In computer science this can be helpful:
We have a collection of n &lt;em&gt;things&lt;/em&gt;, an order on them (length) and also an equivalence relation (extra information, for example the color of socks). The equivalence relation allows us to make a partition of the original collection, and in every equivalence class our order is still maintained. The mapping of a &lt;em&gt;thing&lt;/em&gt; to it's equivalence class can be done in O(1), so only O(n) is needed to assign each item to a class. Now we have used our extra information and can proceed in any manner to sort every class. The advantage is that the data sets are already significantly smaller.</source>
          <target state="translated">コンピュータサイエンスでは、これが役立ちます。n個のコレクション、それらの順序（長さ）、および等価関係（追加情報、たとえば靴下の色）があります。 同値関係により、元のコレクションのパーティションを作成でき、すべての同値クラスで順序が維持されます。 &lt;em&gt;モノ&lt;/em&gt;の等価クラスへのマッピングはO（1）で行うことができるため、各アイテムをクラスに割り当てるのに必要なのはO（n）だけです。 これで、追加情報を使用したので、あらゆる方法であらゆるクラスをソートできます。 利点は、データセットがすでにかなり小さいことです。</target>
        </trans-unit>
        <trans-unit id="95707802ab9dca781a74e6e8993e4a31c2c6a26e" translate="yes" xml:space="preserve">
          <source>In order to say how efficient it is to pair socks from a pile, we have to define the machine first, because the pairing isn't done whether by a turing nor by a random access machine, which are normally used as the basis for an algorithmic analysis.</source>
          <target state="translated">積み上げられた靴下をペアリングするのがどれだけ効率的かを言うためには、まず機械を定義しなければなりません。</target>
        </trans-unit>
        <trans-unit id="cb70cb2a381a9804b33c37786ed6892de88e1933" translate="yes" xml:space="preserve">
          <source>In the case of socks, perfect recall means looking at a sock &lt;code&gt;s&lt;/code&gt; always produces the memory of its sibling &lt;code&gt;t&lt;/code&gt;, including enough information (where it is on the ironing board) to locate &lt;code&gt;t&lt;/code&gt; in constant time.  A person with photographic memory accomplishes both 1 and 2 in constant time without fail.</source>
          <target state="translated">靴下の場合、完全な想起とは靴下 &lt;code&gt;s&lt;/code&gt; を見ると常に兄弟 &lt;code&gt;t&lt;/code&gt; のメモリが生成され、一定時間内に &lt;code&gt;t&lt;/code&gt; を特定するのに十分な情報（アイロン台上の場所）が含まれます。 写真の記憶を持つ人は、1と2の両方を確実に一定の時間で達成します。</target>
        </trans-unit>
        <trans-unit id="4d3725e32aaeb21f7a9e8878c8079a2ecffbc7fb" translate="yes" xml:space="preserve">
          <source>In the worst case it means that you will have n/2 different buckets, and you will have n-2 determinations about that which bucket contains the pair of the current sock. Obviously, this algorithm works well if you have just a few pairs; I did it with 12 pairs.</source>
          <target state="translated">最悪の場合、それはあなたがn2の異なるバケツを持つことを意味し、どのバケツが現在の靴下のペアを含むかについてのn-2の決定を持つことになります。明らかに,このアルゴリズムは,わずか数組のペアを持っている場合にうまく機能します.</target>
        </trans-unit>
        <trans-unit id="aa2dcdaf17722e129a20d19adefefc64c27ec3f1" translate="yes" xml:space="preserve">
          <source>Is it equivalent to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;element distinctness problem&lt;/a&gt;?</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;要素の明確性の問題&lt;/a&gt;と同等ですか？</target>
        </trans-unit>
        <trans-unit id="27a7682059354d7267300e1425434e6ec790e624" translate="yes" xml:space="preserve">
          <source>It is not so scientific, but it works well:)</source>
          <target state="translated">あまり科学的ではありませんが、うまく機能しています:)</target>
        </trans-unit>
        <trans-unit id="d923e9762ba91638d0414fad059bf2a39ed51197" translate="yes" xml:space="preserve">
          <source>It is possible to separate socks into general classes or types (white/black, ankle/crew, athletic/dress) when building your array, and &quot;drill-down&quot; to only compare like-for-like.</source>
          <target state="translated">アレイを構築する際に、靴下を一般的なクラスやタイプ(whiteblack,anklecrew,athleticdress)に分けることができ、「ドリルダウン」して似たようなものだけを比較することができます。</target>
        </trans-unit>
        <trans-unit id="84b3dca37c877454cf4abb0e807d969bb8f0399f" translate="yes" xml:space="preserve">
          <source>It obviously requires some extra work to check if there is the matching sock already hanging somewhere and it would render solution &lt;code&gt;O(n^2)&lt;/code&gt; with coefficient about &lt;code&gt;1/2&lt;/code&gt; for a computer. But in this case the &quot;human factor&quot; is actually an advantage -- I usually can very quickly (almost &lt;code&gt;O(1)&lt;/code&gt;) identify the matching sock if it was already hung (probably some imperceptible in-brain caching is involved) -- consider it a kind of limited &quot;oracle&quot; as in &lt;a href=&quot;http://en.wikipedia.org/wiki/Oracle_machine&quot;&gt;Oracle Machine&lt;/a&gt; ;-) We, the humans have these advantages over digital machines in some cases ;-)</source>
          <target state="translated">一致する靴下が既にどこかにぶら下がっているかどうかを確認するために、いくつかの追加の作業が明らかに必要であり、コンピュータの係数が約 &lt;code&gt;1/2&lt;/code&gt; のソリューション &lt;code&gt;O(n^2)&lt;/code&gt; をレンダリングします。 しかし、この場合、「ヒューマンファクター」は実際には利点です。一致する靴下が既にハングしている場合は、ほとんどの場合（ほぼ &lt;code&gt;O(1)&lt;/code&gt; ）一致する靴下を識別することができます（おそらく、わずかな脳内キャッシングが関係している可能性があります）。これは、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Oracle_machine&quot;&gt;Oracle Machineの&lt;/a&gt;ような一種の限定的な「オラクル」です;-)私たち人間は、場合によってはデジタルマシンに比べてこれらの利点があります;-)</target>
        </trans-unit>
        <trans-unit id="39b5cd62e349d68c400a20da1e370efb8e1fc33f" translate="yes" xml:space="preserve">
          <source>It scales nearly indefinitely if &lt;strong&gt;each worker has its own set of piles&lt;/strong&gt;. Workers can then take big chunks of socks from the input basket (very little contention as they are doing it rarely) and they do not need to synchronise when distributing the socks at all (because they have thread-local piles). At the end, all workers need to union their pile-sets. I believe that can be done in O(log (worker count * piles per worker)) if the workers form an &lt;strong&gt;aggregation tree&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;各ワーカーが独自のパイルセットを持っている&lt;/strong&gt;場合&lt;strong&gt;、&lt;/strong&gt;ほぼ無制限にスケーリング&lt;strong&gt;され&lt;/strong&gt;ます。 その後、ワーカーは入力バスケットから靴下の大きな塊を取り出すことができ（めったにそうしないため、競合はほとんどありません）、靴下を配布するときに同期する必要はありません（スレッドローカルパイルがあるため）。 最後に、すべての労働者は杭セットを結合する必要があります。 ワーカーが&lt;strong&gt;集約ツリーを&lt;/strong&gt;形成している場合、O（log（ワーカー数*ワーカーあたりのパイル））でそれを行うことができると思います。</target>
        </trans-unit>
        <trans-unit id="150b46cd8303cca0bd34d1940b0ec0aedbf08053" translate="yes" xml:space="preserve">
          <source>It's better if there's no difference between left and right foot socks, but it's not critical. If socks are left-right symmetrical, finding a pair is O(1) operation, and sorting the socks is approximate O(M) operation, where M is the number of places in your house, which you have littered with socks, ideally some small constant number.</source>
          <target state="translated">足の靴下は左右差がない方が良いのですが、致命的ではありません。靴下が左右対称であれば,一足を見つけるのはO(1)の作業であり,靴下を並べ替えるのはおおよそO(M)の作業であり,Mは家の中で靴下を散らかした場所の数であり,理想的には小さな定数である.</target>
        </trans-unit>
        <trans-unit id="2f22939c37ecaebbcccfa9e1a61cd5e27c5cb274" translate="yes" xml:space="preserve">
          <source>It's often good to take a step back, and think a way around the problem.</source>
          <target state="translated">一歩引いて、問題を回避する方法を考えるのが良いことが多いです。</target>
        </trans-unit>
        <trans-unit id="150a08322f1488dee4632ea6718c405d63b39b1c" translate="yes" xml:space="preserve">
          <source>Iterate over each pile and &lt;strong&gt;distribute it by some other metric&lt;/strong&gt; (e.g. pattern) into the second set of piles</source>
          <target state="translated">各パイルを反復処理し&lt;strong&gt;、他のメトリック&lt;/strong&gt; （パターンなど）で2番目のパイルのセットに&lt;strong&gt;分配します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5efd484584a49caf169c4dda344e416b18649fb1" translate="yes" xml:space="preserve">
          <source>Keep randomly picking socks from the stack and compare to your 5+1 socks for a match. As your stack grows, it will reduce your performance but raise your odds. Much faster.</source>
          <target state="translated">スタックからランダムに靴下を選び続け、5+1の靴下と比較して勝負しましょう。スタックが増えると、パフォーマンスは低下しますが、オッズは上がります。遥かに速いです。</target>
        </trans-unit>
        <trans-unit id="1ca7ccdd0b7ccddb659ecda67d1ece6e151b36ca" translate="yes" xml:space="preserve">
          <source>Let 'N' correspond to an approximate upper-bound on the number of  number of unique colors/pattern of socks that you have.</source>
          <target state="translated">N'は、自分が持っている靴下のユニークなカラーパターンの数のおおよその上限に相当します。</target>
        </trans-unit>
        <trans-unit id="780bea650a8fdf34a596a74ddbd5fc938d04c33f" translate="yes" xml:space="preserve">
          <source>My algorithm:</source>
          <target state="translated">私のアルゴリズム</target>
        </trans-unit>
        <trans-unit id="74beaf9107fc04b7777303cee699390003158c90" translate="yes" xml:space="preserve">
          <source>My solution does not exactly correspond to your requirements, as it formally requires &lt;code&gt;O(n)&lt;/code&gt; &quot;extra&quot; space. However, considering my conditions it is very efficient in my practical application. Thus I think it should be interesting.</source>
          <target state="translated">私のソリューションは、 &lt;code&gt;O(n)&lt;/code&gt; の 「余分な」スペースを正式に必要とするため、要件に正確に対応していません。 しかし、私の条件を考えると、実際のアプリケーションでは非常に効率的です。 だから面白いと思います。</target>
        </trans-unit>
        <trans-unit id="5975233f2cbc212e70e2408f533f6faa08e21eb5" translate="yes" xml:space="preserve">
          <source>Now look for a match (visual pattern matching - humans are good at that with a small stack) inside the five you drew, if you don't find one, then add that to your five.</source>
          <target state="translated">さて、あなたが描いた5つの中にマッチするもの(視覚的なパターンマッチング-人間は小さなスタックでそれを得意としています)を探して、1つが見つからなければ、あなたの5つにそれを追加します。</target>
        </trans-unit>
        <trans-unit id="a7486cfa8083fe6f612df25745068a14a1cac68b" translate="yes" xml:space="preserve">
          <source>Now the computer science in this problem is all about the steps</source>
          <target state="translated">さて、この問題のコンピュータサイエンスは、すべてのステップについての</target>
        </trans-unit>
        <trans-unit id="870cccf30184352ba6b4960824e58b1bdd6d8989" translate="yes" xml:space="preserve">
          <source>Now the next question is simply whether you do your own laundry and your wife does hers. That is a problem likely in an &lt;strong&gt;entirely different domain of problems&lt;/strong&gt;. :)</source>
          <target state="translated">さて、次の問題は、あなたが自分で洗濯をし、妻が自分で洗濯するかどうかです。 これは、 &lt;strong&gt;まったく別の問題領域で&lt;/strong&gt;起こりそうな&lt;strong&gt;問題&lt;/strong&gt;です。 :)</target>
        </trans-unit>
        <trans-unit id="e3d8d0fe5c35ea409447bff57847e6fc8b0f8f6d" translate="yes" xml:space="preserve">
          <source>Now this may not seem all that different from &quot;forming piles by color&quot; suggested by top answers but first, by not picking discrete piles but ranges, I have no problem classifying whether &quot;purple&quot; goes to &quot;red&quot; or &quot;blue&quot; pile; it just goes between. And then by integrating two operations (hang to dry and sort) the overhead of sorting while hanging is like 10% of what separate sorting would be.</source>
          <target state="translated">これは、トップアンサーが提案している「色でパイルを形成する」というのとは全く違うように見えるかもしれませんが、まず、離散的なパイルを選ぶのではなく、範囲を選ぶことで、「紫」が「赤」のパイルに行くのか「青」のパイルに行くのかを分類することに問題はなく、その間に行くだけです。そして、2つの操作(乾燥させるために吊るして仕分け)を統合することによって、吊るしている間の仕分けのオーバーヘッドは、別個の仕分けが何であるかの10%のようなものです。</target>
        </trans-unit>
        <trans-unit id="37e05d152e6390b47f7a7dde92949ba55f30e47c" translate="yes" xml:space="preserve">
          <source>Once you have a collision(a.k.a  : a match) simply remove that pair of socks. 
 Repeat the same experiment with the next batch of NlogN socks. 
The beauty of it is that you could be making NlogN parallel comparisons(collision-resolution) because of the way the human mind works.  :-)</source>
          <target state="translated">衝突(a.k.a:a match)があったら、その靴下を外してください。次のバッチのNlogNの靴下で同じ実験を繰り返します。この実験の素晴らしいところは、人間の心の働き方によって、NlogNの並列比較(衝突解決)ができることです。)</target>
        </trans-unit>
        <trans-unit id="11a98af1a6e5c195360f3f6c711227cc208dadd9" translate="yes" xml:space="preserve">
          <source>Operation 4 is necessary, because when spreading socks over the floor some socks may hide others. Here is the analysis of the algorithm:</source>
          <target state="translated">床に靴下を敷き詰めると、一部の靴下が他の靴下を隠してしまうことがあるため、操作4が必要である。以下、アルゴリズムの分析です。</target>
        </trans-unit>
        <trans-unit id="af6924e29957fb8b52cc30183bb2138601d75b4d" translate="yes" xml:space="preserve">
          <source>Optionally to step one, you pick up two sock from that line instead of two, as the caching memory is large enough we can quickly identify if either sock matches the current one on the line you are observing. If you are fortunate enough to have three arms, you could possibly parse three socks at the same time given that the memory of the subject is large enough.</source>
          <target state="translated">キャッシングメモリが十分に大きいので、どちらかの靴下が観測しているライン上の現在の靴下と一致しているかどうかを素早く識別することができます。もしあなたが幸運にも三本の腕を持っているのであれば、対象のメモリが十分に大きいので、三つの靴下を同時に解析することができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="77783bef2624f9f540cadff73ba6528b5aae021a" translate="yes" xml:space="preserve">
          <source>Oracle Machine is Better ;-)</source>
          <target state="translated">オラクルマシンの方が良いです ;-)</target>
        </trans-unit>
        <trans-unit id="f28b38127d74eab7d9b41752145290a2fc0d5c89" translate="yes" xml:space="preserve">
          <source>Order the socks!</source>
          <target state="translated">靴下を注文してください!</target>
        </trans-unit>
        <trans-unit id="8c33de1b8688b9c866607960966f014e14b6a01b" translate="yes" xml:space="preserve">
          <source>Other than that, I cannot think of anything, but this method does seem to be pretty efficient in real life. :)</source>
          <target state="translated">それ以外は思いつきませんが、この方法は実際にはかなり効率が良さそうですね :)</target>
        </trans-unit>
        <trans-unit id="02341ed9b2710f0b78051065b72a305737d20c68" translate="yes" xml:space="preserve">
          <source>Our two preprocessing stages are &quot;putting the socks on the clothesline&quot; and &quot;Taking the socks from the clothesline&quot;, which we have to do, in order to get socks which are not only clean but also dry. As with washing machines, clotheslines are finite, and I assume that we have the whole part of the line where we put our socks in sight.</source>
          <target state="translated">私たちが行っている前処理は「靴下を物干し竿に置く」と「物干し竿から靴下を取る」の2つで、きれいなだけでなく、乾いた靴下を手に入れるためには、この2つの作業を行わなければなりません。洗濯機もそうですが、物干し竿には限りがありますので、靴下を置く部分は全て目の前にあることを想定しています。</target>
        </trans-unit>
        <trans-unit id="dd7e7c37ececf846bbc91969c59fe7ec34aa06d6" translate="yes" xml:space="preserve">
          <source>Pair blindly all socks to its neighbor (do not pack it)</source>
          <target state="translated">その隣人に盲目的にすべての靴下をペア(それをパックしないでください</target>
        </trans-unit>
        <trans-unit id="567d945bb762f9218b71f65d131b602db30011d2" translate="yes" xml:space="preserve">
          <source>Pick a sock</source>
          <target state="translated">靴下を選ぶ</target>
        </trans-unit>
        <trans-unit id="b3134987842b8171f3b2d20b9d928ea0449a744f" translate="yes" xml:space="preserve">
          <source>Pick any two of them to make a pair. Constant time.</source>
          <target state="translated">その中から任意の2つを選んでペアを作ります。一定の時間。</target>
        </trans-unit>
        <trans-unit id="e6ad43d89c0be2bb101bd954d77aea3f0c680af6" translate="yes" xml:space="preserve">
          <source>Pick the first sock in line, search along the line until it finds the corresponding sock.</source>
          <target state="translated">並んでいる最初の靴下を選び、対応する靴下が見つかるまで線に沿って探します。</target>
        </trans-unit>
        <trans-unit id="f15a45dc12d70436ea09baf6beeb9021651aff15" translate="yes" xml:space="preserve">
          <source>Pick two socks, place corresponding X sock in X line, and Y sock in Y line at next available position.</source>
          <target state="translated">2枚の靴下を選び、対応するXの靴下をXのラインに、Yの靴下をYのラインの次の空いている位置に置きます。</target>
        </trans-unit>
        <trans-unit id="a42c6c1b50b0cb070b7169e8cfd43b7e499c1252" translate="yes" xml:space="preserve">
          <source>Pick up a first sock and place it on a table. Now pick another sock; if it matches the first picked, place it on top of the first. If not, place it on the table a small distance from the first. Pick a third sock; if it matches either of the previous two, place it on top of them or else place it a small distance from the third. Repeat until you have picked up all the socks.</source>
          <target state="translated">最初の靴下を拾ってテーブルの上に置きます。次に、もう一枚の靴下を拾って、最初に拾った靴下と同じであれば、最初の靴下の上に置いてください。そうでない場合は、最初の靴下から少し離れたテーブルの上に置きます。3枚目の靴下を選びます。前の2枚の靴下のどちらかにマッチしていたら、その上に置くか、3枚目から少し離れたところに置きます。すべての靴下を拾い集めるまで、これを繰り返します。</target>
        </trans-unit>
        <trans-unit id="49d4ff963ae4bca3c41a677fe2b8a4851f0dc095" translate="yes" xml:space="preserve">
          <source>Pick up one from the stack of 2n-5.</source>
          <target state="translated">2n-5のスタックから1つ拾う。</target>
        </trans-unit>
        <trans-unit id="38fc586cd4b8cb11aebfcde216a7bcd038fe8e83" translate="yes" xml:space="preserve">
          <source>Picking a distinctive sock (whatever catches my eye first in the pile).</source>
          <target state="translated">特徴的な靴下を選ぶ(山の中で最初に目に留まるもの)。</target>
        </trans-unit>
        <trans-unit id="afb37a344e3ab2d134c35252ebd3afec24338844" translate="yes" xml:space="preserve">
          <source>Place the new sock near into the current pile, with a distance based on how different it is. If you find yourself putting the sock on top of another because it is identical, form the pair there, and remove them. This means that future comparisons take less effort to find the correct place.</source>
          <target state="translated">新しい靴下を現在の山の近くに、どれだけ違うかを基準に距離を置いて置きます。同じ靴下だからといって他の靴下の上に重ねてしまう場合は、その靴下のペアを作って、そのペアを取り除きます。これは、将来の比較が正しい場所を見つけるための努力が少なくて済むことを意味します。</target>
        </trans-unit>
        <trans-unit id="2f2ea3db77a1f1b6f771e24a207d47f22993a2ad" translate="yes" xml:space="preserve">
          <source>Problem solved. So, just get new socks, throw/donate your old ones away, and live happily ever after knowing you are saving money and time every day for the rest of your life.</source>
          <target state="translated">問題は解決しました。新しい靴下を手に入れて、古い靴下を捨てて、残りの人生のために毎日お金と時間を節約して、ずっと幸せに暮らしましょう。</target>
        </trans-unit>
        <trans-unit id="b052f937ed7ad2c7eefbe92ef78e1f1391ca53d4" translate="yes" xml:space="preserve">
          <source>Put into the corresponding finished line of socks.</source>
          <target state="translated">対応する靴下の完成ラインに入れます。</target>
        </trans-unit>
        <trans-unit id="e069c49edbed651dbec011e37b87b876f834afc4" translate="yes" xml:space="preserve">
          <source>Quickly make piles of easily distinguishable socks. (Say by color)</source>
          <target state="translated">見分けやすい靴下の山を素早く作る。(色で言う)</target>
        </trans-unit>
        <trans-unit id="e8562ec8764aff77d8738bd6121e9835eeba9b2f" translate="yes" xml:space="preserve">
          <source>Quicksort every pile and use the length of the sock for comparison. As a human you can make a fairly quick decision which sock to use to partition that avoids worst case. (You can see multiple socks in parallel, use that to your advantage!)</source>
          <target state="translated">すべてのパイルをクイックソートし、比較のために靴下の長さを使用します。人間であれば、どの靴下を使用して最悪のケースを回避するかを素早く判断することができます。(複数の靴下を並行して見ることができるので、それを活用してください)</target>
        </trans-unit>
        <trans-unit id="b577412dc9473d426d2ff6741d11dea5ca17a977" translate="yes" xml:space="preserve">
          <source>Real world approach:</source>
          <target state="translated">現実世界からのアプローチ。</target>
        </trans-unit>
        <trans-unit id="0bf66d17ab79cfe3be7fc141f104742b101b119a" translate="yes" xml:space="preserve">
          <source>Repeat from 1 until there are no socks on the floor.</source>
          <target state="translated">床に靴下がなくなるまで1から繰り返します。</target>
        </trans-unit>
        <trans-unit id="0081c3494d7d5f15ad3d0b6fd53ac547753f32ff" translate="yes" xml:space="preserve">
          <source>Repeat from 1. until there are no more most distinctive socks.</source>
          <target state="translated">1.から最も特徴的な靴下がなくなるまで繰り返します。</target>
        </trans-unit>
        <trans-unit id="e491132f83030e4bf9e1aa6139496611dff2738e" translate="yes" xml:space="preserve">
          <source>Repeat from 2 until no pair can be made.</source>
          <target state="translated">2からペアが作れなくなるまで繰り返します。</target>
        </trans-unit>
        <trans-unit id="f4ecdc41af265ed9bf91659fbd817baded2a6b44" translate="yes" xml:space="preserve">
          <source>Repeat with every sock.</source>
          <target state="translated">靴下ごとに繰り返します。</target>
        </trans-unit>
        <trans-unit id="2d3de6b4a64f840ca4b44c37b7e888adb2929c0e" translate="yes" xml:space="preserve">
          <source>Shuffle the rest</source>
          <target state="translated">残りをシャッフルする</target>
        </trans-unit>
        <trans-unit id="20968b695bdd0c1693e57dfce2b017887a96213f" translate="yes" xml:space="preserve">
          <source>Since all washing machines I know about are limited in size (regardless of how many socks you have to wash), and the actual randomizing occurs in the washing machine, no matter how many socks we have, we always have small subsets which contain almost no singletons.</source>
          <target state="translated">私が知っているすべての洗濯機はサイズが限られており(何枚の靴下を洗っても関係なく)、実際のランダム化は洗濯機の中で行われるため、いくら靴下を持っていても、常にシングルトンがほとんど含まれていない小さなサブセットを持っています。</target>
        </trans-unit>
        <trans-unit id="20318f6c81a8cfa249bb075ab83674739820d4cc" translate="yes" xml:space="preserve">
          <source>Since you are interested in connections to element distinctness problem: proving the Omega(n log n) bound for element distinctness is harder, because the output is binary yes/no. Here, the output has to be a matching and the number of possible outputs suffices to get a decent bound. However, there's a variant connected to element distinctness. Suppose you are given 2n socks and wonder if they can be uniquely paired. You can get a reduction from ED by sending (a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;) to (a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;, a&lt;sub&gt;n&lt;/sub&gt;). (Parenthetically, the proof of hardness of ED is very interesting, &lt;a href=&quot;http://www.cs.dartmouth.edu/~ac/Teach/CS85-Spring08/lecnotes.pdf&quot;&gt;via topology&lt;/a&gt;.)</source>
          <target state="translated">要素の明確性の問題への接続に関心があるので、出力がバイナリのyes / noであるため、要素の明確性の限界であるOmega（n log n）を証明することは困難です。 ここで、出力は一致している必要があり、適切な範囲を得るには、可能な出力の数で十分です。 ただし、要素の明確性に関連するバリアントがあります。 2nの靴下が与えられ、それらを一意にペアにできるかどうか疑問に思います。 （a &lt;sub&gt;1&lt;/sub&gt; 、a &lt;sub&gt;2&lt;/sub&gt; 、...、a &lt;sub&gt;n&lt;/sub&gt; ）を（a &lt;sub&gt;1&lt;/sub&gt; 、a &lt;sub&gt;1&lt;/sub&gt; 、a &lt;sub&gt;2&lt;/sub&gt; 、a &lt;sub&gt;2&lt;/sub&gt; 、...、a &lt;sub&gt;n&lt;/sub&gt; 、a &lt;sub&gt;n&lt;/sub&gt; ）に送信することにより、EDから削減を得ることができます。 （括弧で言うと、EDの硬度の証明は&lt;a href=&quot;http://www.cs.dartmouth.edu/~ac/Teach/CS85-Spring08/lecnotes.pdf&quot;&gt;トポロジーを介して&lt;/a&gt;非常に興味深いものです 。）</target>
        </trans-unit>
        <trans-unit id="b9194449f120d8f88fb9b2143ad9103b6ff573c9" translate="yes" xml:space="preserve">
          <source>Smile satisfied :)</source>
          <target state="translated">満足の笑顔 :)</target>
        </trans-unit>
        <trans-unit id="b4e8217ef1354bbb155dad8cbdc9f0568f1b9c6f" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;hashing&lt;/strong&gt; would be enough (and faster).</source>
          <target state="translated">したがって、 &lt;strong&gt;ハッシュ&lt;/strong&gt;で十分です（より高速です）。</target>
        </trans-unit>
        <trans-unit id="efa0ae263e5ffda95375f84a7f6c55184e61109a" translate="yes" xml:space="preserve">
          <source>So depending on the previous analysis following operations should be used in descending order:</source>
          <target state="translated">そのため、前回の分析結果に応じて、以下の操作を降順に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c9e8e26a61696a80e259f278ce881a216a7ad149" translate="yes" xml:space="preserve">
          <source>So here is my suggestion:</source>
          <target state="translated">そこで私の提案です。</target>
        </trans-unit>
        <trans-unit id="a55e40b80a0b84833274723db643350fd89429ca" translate="yes" xml:space="preserve">
          <source>So pick up five of them at random, and memorize their shape or their length.</source>
          <target state="translated">だから、ランダムに5つピックアップして、その形状や長さを覚えてください。</target>
        </trans-unit>
        <trans-unit id="d199d875189556fbbb7c28bbf7b2d5145327cb1f" translate="yes" xml:space="preserve">
          <source>So the &quot;best&quot; algorithm depends on the qualities of the wetware/hardware/software that is running it and our willingness to &quot;cheat&quot; by imposing a total order on pairs.  Certainly a &quot;best&quot; &lt;em&gt;meta&lt;/em&gt;-algorithm is to hire the worlds best sock-sorter: a person or machine that can aquire and quickly store a huge set N of sock attribute sets in a 1-1 associative memory with constant time lookup, insert, and delete. Both people and machines like this can be procured. If you have one, you can pair all the socks in O(N) time for N pairs, which is optimal. The total order tags allow you to use standard hashing to get the same result with either a human or hardware computer.</source>
          <target state="translated">したがって、「最良の」アルゴリズムは、それを実行しているウェットウェア/ハードウェア/ソフトウェアの品質と、ペアに合計順序を課すことで「チート」する意欲に依存します。 確かに「最高の」 &lt;em&gt;メタ&lt;/em&gt;アルゴリズムは、世界最高のsock-sorterを採用することです。一定時間の検索、挿入、そして削除。 このような人と機械の両方を調達できます。 靴下がある場合は、すべての靴下をNペアのO（N）時間でペアにすることができます。これは最適です。 合計注文タグを使用すると、標準のハッシュを使用して、人間またはハードウェアのコンピューターで同じ結果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="2f4b0f3db658b3420736349f1a48e77a38793c53" translate="yes" xml:space="preserve">
          <source>So we have a total runtime complexity of &lt;strong&gt;&lt;code&gt;O(r*n^2 + w*(ln n + n))&lt;/code&gt;&lt;/strong&gt; where &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; are the factors for environmental read and environmental write operations respectively for a reasonable amount of socks. The cost of the logical and arithmetical operations are omitted, because we suppose that it takes a constant amount of logical and arithmetical operations to decide whether 2 socks belong to the same pair. This may not be feasible in every scenario.</source>
          <target state="translated">したがって、実行時の全体的な複雑さは&lt;strong&gt; &lt;code&gt;O(r*n^2 + w*(ln n + n))&lt;/code&gt; &lt;/strong&gt;ここで、 &lt;code&gt;r&lt;/code&gt; と &lt;code&gt;w&lt;/code&gt; は、それぞれ適切な量の靴下に対する環境読み取り操作と環境書き込み操作の要素です。 論理演算と算術演算のコストは省略されています。これは、2つの靴下が同じペアに属しているかどうかを判断するために一定量の論理演算と算術演算が必要になるためです。 これは、すべてのシナリオで実行できるとは限りません。</target>
        </trans-unit>
        <trans-unit id="c0ea279bcf3555464998141486451f10c76c5ac8" translate="yes" xml:space="preserve">
          <source>So, an algorithm for achieving O(1) sock pairing efficiency (assuming symmetrical sock) is:</source>
          <target state="translated">そこで、(対称的な靴下を想定して)O(1)の靴下のペアリング効率を達成するためのアルゴリズムがある。</target>
        </trans-unit>
        <trans-unit id="f20134ff73648500315de3e4a253b67d80cad96e" translate="yes" xml:space="preserve">
          <source>Socks, whether real ones or some analogous data structure, would be supplied in pairs.</source>
          <target state="translated">靴下は、本物であろうと、類似のデータ構造であろうと、ペアで供給される。</target>
        </trans-unit>
        <trans-unit id="fb36d98db4ccebdf42bf060da6c7373f52f5a333" translate="yes" xml:space="preserve">
          <source>Some upfront effort is required to find desirable socks, and to purchase in sufficient quantity as to eliminate need for your existing socks. As I'd done this before my need for black socks, my effort was minimal, but mileage may vary.</source>
          <target state="translated">望ましい靴下を見つけるためには、ある程度の前もっての努力が必要であり、既存の靴下を必要としないように十分な量を購入する必要があります。私は黒の靴下が必要になる前にこのようなことをしていたので、私の努力は最小限で済みましたが、マイレージは異なるかもしれません。</target>
        </trans-unit>
        <trans-unit id="97926eed54a69097fde506b9ecf78b97bea5b72b" translate="yes" xml:space="preserve">
          <source>Someone with less than perfect memory might use a few commonsense equivalence classes based on features within his capability to track: size (papa, mama, baby), color (greenish, redish, etc.), pattern (argyle, plain, etc.), style (footie, knee-high, etc.).  So the ironing board would be divided into sections for the categories. This usually allows the category to be located in constant time by memory, but then a linear search through the category &quot;bucket&quot; is needed.</source>
          <target state="translated">サイズ(パパ、ママ、赤ちゃん)、色(緑がかった、赤みがかったなど)、パターン(アーガイル、無地など)、スタイル(足袋、ニーハイなど)を追跡するために彼の能力の範囲内の機能に基づいて、いくつかの常識的な同等クラスを使用することがあります。そうすると、アイロン台はカテゴリーごとに分かれていることになります。これならば通常は記憶によって一定時間でカテゴリーの位置を特定することができるが、そうするとカテゴリーの「バケツ」から直線的な検索が必要になる。</target>
        </trans-unit>
        <trans-unit id="0159712802a0c2f7cfff59d6211ba6f0c4445923" translate="yes" xml:space="preserve">
          <source>Someone with no memory or imagination at all (sorry) will just keep the socks in one pile and do a linear search of the whole pile.</source>
          <target state="translated">記憶力も想像力も全くない人(ごめんなさい)は、靴下を一つの山にまとめておいて、その山全体を直線的に検索するだけです。</target>
        </trans-unit>
        <trans-unit id="b1831098d4a04bf674e6b5bfb3d588abdfb6668a" translate="yes" xml:space="preserve">
          <source>Sorting solutions have been proposed, but &lt;strong&gt;sorting is a little too much&lt;/strong&gt;: We don't need order; &lt;strong&gt;we just need equality groups&lt;/strong&gt;.</source>
          <target state="translated">並べ替えソリューションが提案されていますが、 &lt;strong&gt;並べ替えは少なすぎ&lt;/strong&gt;ます。順序は必要ありません。 &lt;strong&gt;平等グループが必要&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="2cf30b649babee1fb3e3f2f2040697d3899e96be" translate="yes" xml:space="preserve">
          <source>Sorting, of course improves efficiency, especially in real life where you can easily &quot;insert&quot; a sock between two other socks. In computing the same could be achieved by a tree, but that's extra space. And, of course, we're back at NlogN (or a bit more, if there are several socks that are the same by sorting criteria, but not from the same pair).</source>
          <target state="translated">並べ替えはもちろん効率を向上させますが、特に現実の生活では、他の 2 つの靴下の間に簡単に靴下を「挿入」することができます。計算では、木でも同じことができますが、余計なスペースが必要になります。そして、もちろん、NlogN (ソート基準によって同じ靴下が複数ある場合、同じペアの靴下ではありません)に戻ってきます。</target>
        </trans-unit>
        <trans-unit id="71a641aab14b65becb2573bd1e7dc80cfa779bbc" translate="yes" xml:space="preserve">
          <source>Spread all socks in the pile over the floor.</source>
          <target state="translated">パイルの中の靴下をすべて床の上に広げます。</target>
        </trans-unit>
        <trans-unit id="1e59b3c211f85c725340aeaa57b22de5e88fedab" translate="yes" xml:space="preserve">
          <source>Starting a radix sort from that conceptual location by pulling socks from the pile based on similarity to that one.</source>
          <target state="translated">その概念的な場所から、それとの類似性に基づいて山から靴下を引っ張ってきて、その概念的な場所から基底ソートを開始します。</target>
        </trans-unit>
        <trans-unit id="9a81a4144276291d35bd6b866aad617bdf191bf6" translate="yes" xml:space="preserve">
          <source>Stop sorting piles when they reached a threshold at which you are comfortable to find spot pairs and unpairable socks instantly</source>
          <target state="translated">スポットペアや絶望的な靴下を瞬時に見つけることができる快適な閾値に達したときに、パイルの仕分けを停止します。</target>
        </trans-unit>
        <trans-unit id="c6852caa99233694cc2f8ce0670b34197c40d765" translate="yes" xml:space="preserve">
          <source>Such an upfront effort has been seen many times in very popular and effective code. Examples include #DEFINE'ing pi to several decimals (other examples exist, but that's the one that comes to mind right now).</source>
          <target state="translated">このような前もっての努力は、非常に人気のある効果的なコードで何度も見られてきました。例としては、#DEFINE'ing pi to several decimals(他にも例はありますが、今思い浮かぶのはこれです)などがあります。</target>
        </trans-unit>
        <trans-unit id="0a5991dd9a6ef1577adeb97b95fcc60199512116" translate="yes" xml:space="preserve">
          <source>Suppose that you &lt;em&gt;know&lt;/em&gt; that your 2n socks are arranged this way:</source>
          <target state="translated">2nソックスが次のように配置されていることが&lt;em&gt;わかっ&lt;/em&gt;ているとします。</target>
        </trans-unit>
        <trans-unit id="83358afe13545467fbcbbf957121011db2230479" translate="yes" xml:space="preserve">
          <source>The actual number of socks is not that large, I don't believe my spouse and I have more than 30 pairs. (And it is fairly easy to distinguish between my socks and hers; can this be used as well?)</source>
          <target state="translated">実際の靴下の数はそれほど多くはなく、私と配偶者は30足以上は持っていないと思います。(そして、私の靴下と彼女の靴下を区別するのはかなり簡単です。これも使えるのでしょうか?)</target>
        </trans-unit>
        <trans-unit id="052fd9e524e5e7a091878b38f361a3a987397d74" translate="yes" xml:space="preserve">
          <source>The algorithm</source>
          <target state="translated">アルゴリズム</target>
        </trans-unit>
        <trans-unit id="f78fa21d86b0d267520ebd8d82fbaae7a3fc5c19" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(ln n + n)&lt;/code&gt; environmental modifications (step 1 &lt;code&gt;O(ln n)&lt;/code&gt; plus picking every pair of sock from the floor)</source>
          <target state="translated">アルゴリズムには &lt;code&gt;O(ln n + n)&lt;/code&gt; 環境の変更が含まれます（ステップ1 &lt;code&gt;O(ln n)&lt;/code&gt; に加えて、床から靴下のすべてのペアを選択します）</target>
        </trans-unit>
        <trans-unit id="1df9e4e8ccdefcdc14130712da6877c276e11de8" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(n^2)&lt;/code&gt; environmental reads from step 2</source>
          <target state="translated">アルゴリズムには、ステップ2からの &lt;code&gt;O(n^2)&lt;/code&gt; 環境読み取りが含まれます</target>
        </trans-unit>
        <trans-unit id="dd6aa1a815e2490fabaf33e117c8ad11f5692691" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(n^2)&lt;/code&gt; logical and arithmetic operations for comparing a sock with another in step 2</source>
          <target state="translated">このアルゴリズムには、手順2で靴下を別の靴下と比較するための &lt;code&gt;O(n^2)&lt;/code&gt; 論理演算および算術演算が含まれます。</target>
        </trans-unit>
        <trans-unit id="bb51c91f5c283a2bdff31b863d5e5e5018eb57e0" translate="yes" xml:space="preserve">
          <source>The algorithm terminates with high probability. This is due to the fact that one is unable to find pairs of socks in step number 2.</source>
          <target state="translated">このアルゴリズムは高確率で終了する。これは、ステップ番号2で靴下のペアを見つけることができないためである。</target>
        </trans-unit>
        <trans-unit id="165efb7623d4620b9e2c0a44514704d6b6dff038" translate="yes" xml:space="preserve">
          <source>The analysis</source>
          <target state="translated">分析</target>
        </trans-unit>
        <trans-unit id="abc7bc26ec5efcc62f2a9dd13e54ca3af8f26906" translate="yes" xml:space="preserve">
          <source>The answers till now don't make good use of our human pattern recognition capabilities. The game of Set provides a clue of how to do this well: put all socks in a two-dimensional space so you can both recognize them well and easily reach them with your hands. This limits you to an area of about 120 * 80 cm or so. From there select the pairs you recognize and remove them. Put extra socks in the free space and repeat. If you wash for people with easily recognizable socks (small kids come to mind), you can do a radix sort by selecting those socks first. This algorithm works well only when the  number of single socks is low</source>
          <target state="translated">今までの答えでは、人間のパターン認識能力が活かされていません。靴下をすべて二次元の空間に配置して、靴下をよく認識し、手で簡単に手に取ることができるようにします。これは、120×80cm程度の面積に制限されています。その中から、自分の認識した靴下を選んで取り除きます。空いたスペースに余分な靴下を入れて、繰り返します。もしあなたが簡単に認識できる靴下を持っている人(小さな子供が思い浮かびます)のために洗濯をする場合は、最初にその靴下を選択することで、基数ソートを行うことができます。このアルゴリズムは、一枚の靴下の数が少ない場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="4d052e124ee3ca4cc28b28a0fe3ffd3b80cede47" translate="yes" xml:space="preserve">
          <source>The best real-world partitioning I can think of is creating a &lt;strong&gt;rectangle of piles&lt;/strong&gt;: one dimension is color, the other is the pattern. Why a rectangle? Because we need O(1) random-access to piles. (A 3D &lt;a href=&quot;http://en.wikipedia.org/wiki/Cuboid&quot;&gt;cuboid&lt;/a&gt; would also work, but that is not very practical.)</source>
          <target state="translated">私が考えることができる最高の実世界のパーティション分割は&lt;strong&gt;、山の長方形を&lt;/strong&gt;作成することです。1つの次元は色で、もう1つの次元はパターンです。 なぜ長方形なのか？ パイルへのO（1）ランダムアクセスが必要だからです。 （3D &lt;a href=&quot;http://en.wikipedia.org/wiki/Cuboid&quot;&gt;直方体&lt;/a&gt;も機能しますが、あまり実用的ではありません。）</target>
        </trans-unit>
        <trans-unit id="4b89a467fe48adcd9cc2eef3b60f3e2f90973c34" translate="yes" xml:space="preserve">
          <source>The initial bucket sorting will speed up your process, because it divides your n socks into k buckets in &lt;code&gt;c*n&lt;/code&gt; time so than you will only have to do &lt;code&gt;c*n*log(k)&lt;/code&gt; work. (Not taking into account the threshold). So all in all you do about &lt;code&gt;n*c*(1 + log(k))&lt;/code&gt; work, where c is the time to throw a sock on a pile.</source>
          <target state="translated">最初のバケットの並べ替えは、 &lt;code&gt;c*n&lt;/code&gt; *時間でn個の靴下をk個のバケットに分割するため、 &lt;code&gt;c*n*log(k)&lt;/code&gt; の作業のみを実行する必要があるため、プロセスが高速化されます。 （しきい値を考慮していません）。 したがって、全体として、 &lt;code&gt;n*c*(1 + log(k))&lt;/code&gt; 作業について行うことになります。cは、靴下を山に投げる時間です。</target>
        </trans-unit>
        <trans-unit id="3ab65ee84b4d8d43507a4f1bd4d7cc40b05e68c1" translate="yes" xml:space="preserve">
          <source>The machine</source>
          <target state="translated">機械</target>
        </trans-unit>
        <trans-unit id="7bb444117bc016eadc9752d11b231edb03e673d8" translate="yes" xml:space="preserve">
          <source>The machine is an abstraction of a the real world element called human being. It is able to read from the environment via a pair of eyes. And our machine model is able to manipulate the environment by using 2 arms. Logical and arithmetic operations are calculated using our brain (hopefully ;-)).</source>
          <target state="translated">機械は人間という現実世界の要素を抽象化したものです。機械は一対の目を介して環境を読み取ることができます。そして、私たちのマシンモデルは、2本の腕を使って環境を操作することができます。論理演算や算術演算は頭を使って計算しています(期待しています)。</target>
        </trans-unit>
        <trans-unit id="7ecbe36be8e73003b52a651bfa1b97b3b6cb4fd9" translate="yes" xml:space="preserve">
          <source>The method can also be nested, if we have multiple equivalence relations -&amp;gt; make colour piles, than within every pile partition on texture, than sort on length. Any equivalence relation that creates a partition with more than 2 elements that have about even size will bring a speed improvement over sorting (provided we can directly assign a sock to its pile), and the sorting can happen very quickly on smaller data sets.</source>
          <target state="translated">複数の同値関係がある場合は、メソッドを入れ子にすることもできます-&amp;gt;テクスチャのすべてのパイルパーティション内で、長さでソートするよりも、カラーパイルを作成します。 ほぼ等しいサイズの2つを超える要素でパーティションを作成する同値関係は、並べ替えよりも速度が向上します（ただし、靴下をパイルに直接割り当てることができます）。並べ替えは、小さいデータセットで非常に迅速に実行できます。</target>
        </trans-unit>
        <trans-unit id="0a27a2fa6c14acbfbc60946013388db1b86f6b79" translate="yes" xml:space="preserve">
          <source>The problem of sorting &lt;strong&gt;your n pairs of socks is O(n)&lt;/strong&gt;. Before you throw them in the laundry &lt;strong&gt;basket&lt;/strong&gt;, you thread the left one to the right one. On taking them out, you cut the thread and put each pair into your drawer - 2 operations on n pairs, so O(n).</source>
          <target state="translated">&lt;strong&gt;n組の靴下&lt;/strong&gt;を並べ替える問題&lt;strong&gt;はO（n）&lt;/strong&gt;です。 それらを洗濯&lt;strong&gt;かご&lt;/strong&gt;に入れる前に、左のものを右のものに通します。 それらを取り出したら、糸を切り、各ペアを引き出しに入れます-nペアで2つの操作なので、O（n）。</target>
        </trans-unit>
        <trans-unit id="c5d0caed9ed396ae40259a6681e3e2c91a16dfd9" translate="yes" xml:space="preserve">
          <source>The simplest answer is prior to allowing the pair to be separated, a single data structure for the pair should have been initialized that contained a pointer to the left and right sock, thus enabling socks to be referred to directly or via their pair. A sock may also be extended to contain a pointer to its partner.</source>
          <target state="translated">最も単純な答えは、ペアを分離する前に、左右の靴下へのポインタを含むペア用の単一のデータ構造体が初期化されている必要があるということです。また、靴下はパートナーへのポインタを含むように拡張されてもよい。</target>
        </trans-unit>
        <trans-unit id="1015cb01e1edc8548eb94937e6c0a8fd4cae64a4" translate="yes" xml:space="preserve">
          <source>The simplest parallelization strategy is to have multiple workers take from the input basket and put the socks onto the piles. This only scales up so much - imagine 100 people fighting over 10 piles. &lt;strong&gt;The synchronization costs&lt;/strong&gt; (manifesting themselves as hand-collisions and human communication) &lt;strong&gt;destroy efficiency and speed-up&lt;/strong&gt; (see the &lt;a href=&quot;http://www.perfdynamics.com/Manifesto/USLscalability.html&quot;&gt;Universal Scalability Law&lt;/a&gt;!). Is this prone to &lt;strong&gt;deadlocks&lt;/strong&gt;? No, because each worker only needs to access one pile at a time. With just one &quot;lock&quot; there cannot be a deadlock. &lt;strong&gt;Livelocks&lt;/strong&gt; might be possible depending on how the humans coordinate access to piles. They might just use &lt;a href=&quot;http://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;random backoff&lt;/a&gt; like network cards do that on a physical level to determine what card can exclusively access the network wire. If it works for &lt;a href=&quot;http://en.wikipedia.org/wiki/Network_interface_controller&quot;&gt;NICs&lt;/a&gt;, it should work for humans as well.</source>
          <target state="translated">最も単純な並列化戦略は、複数のワーカーが入力バスケットから取り出して靴下をパイルに置くことです。 これは非常に大きくなるだけです-10人の山を越えて戦う100人を想像してみてください。 &lt;strong&gt;同期のコスト&lt;/strong&gt; （自分自身を衝突や人間のコミュニケーションとして表現する）は&lt;strong&gt;、効率とスピードアップを&lt;/strong&gt; &lt;a href=&quot;http://www.perfdynamics.com/Manifesto/USLscalability.html&quot;&gt;損ない&lt;/a&gt;ます（ ユニバーサルスケーラビリティ法を参照してください！）。 これは&lt;strong&gt;デッドロックを&lt;/strong&gt;起こしやすいですか？ いいえ。各ワーカーは一度に1つのパイルにアクセスするだけでよいためです。 「ロック」が1つだけの場合、デッドロックは発生しません。 人間が山へのアクセスを調整する方法によっては、 &lt;strong&gt;ライロック&lt;/strong&gt;が可能になる場合があります。 ネットワークカードのように&lt;a href=&quot;http://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;ランダムバックオフを&lt;/a&gt;使用して物理レベルで行うだけで、ネットワークワイヤーに排他的にアクセスできるカードを特定できます。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Network_interface_controller&quot;&gt;NIC&lt;/a&gt;で機能する場合は、人間でも機能するはずです。</target>
        </trans-unit>
        <trans-unit id="d2f49bc795ae24363a2c7470a93203b0fced4c88" translate="yes" xml:space="preserve">
          <source>The special condition in my case is that I don't use drying machine, just hang my cloths on an ordinary cloth dryer. Hanging cloths requires &lt;code&gt;O(n)&lt;/code&gt; operations (by the way, I always consider &lt;a href=&quot;http://en.wikipedia.org/wiki/Bin_packing_problem]&quot;&gt;bin packing&lt;/a&gt; problem here) and the problem by its nature requires the linear &quot;extra&quot; space. When I take a new sock from the bucket I to try hang it next to its pair if the pair is already hung. If its a sock from a new pair I leave some space next to it.</source>
          <target state="translated">私の場合の特別な条件は、私は乾燥機を使用せず、通常の布乾燥機に布を吊るすことです。 布を吊るすには &lt;code&gt;O(n)&lt;/code&gt; 操作が必要です（ちなみに、ここでは常に&lt;a href=&quot;http://en.wikipedia.org/wiki/Bin_packing_problem]&quot;&gt;ビンのパッキング&lt;/a&gt;問題を検討しています）。その性質上、問題は線形の「余分な」スペースを必要とします。 バケットから新しい靴下を取り出すとき、ペアがすでにハングしている場合は、ペアの隣にそれを掛けてみます。 新しい靴下の靴下の場合、その隣にスペースを残します。</target>
        </trans-unit>
        <trans-unit id="ce6af0db2fdccac900c8209f502eec96611a6b58" translate="yes" xml:space="preserve">
          <source>The theoretical limit is O(n) because you need to touch each sock (unless some are already paired somehow).</source>
          <target state="translated">それぞれの靴下を触る必要があるので、理論上の限界はO(n)です。</target>
        </trans-unit>
        <trans-unit id="2103f930ed2f94482faf224a41b4b0491a977035" translate="yes" xml:space="preserve">
          <source>The worst-case scenario of this scheme is that every pair of socks is different enough that it must be matched exactly, and that the first &lt;em&gt;n/2&lt;/em&gt; socks you pick are all different. This is your &lt;em&gt;O&lt;/em&gt;(n&lt;sup&gt;2&lt;/sup&gt;) scenario, and it's &lt;em&gt;extremely&lt;/em&gt; unlikely. If the number of unique types of sock &lt;em&gt;t&lt;/em&gt; is less than the number of pairs &lt;em&gt;p = n/2&lt;/em&gt;, and the socks in each type are alike enough (usually in wear-related terms) that any sock of that type can be paired with any other, then as I inferred above, the maximum number of socks you will ever have to compare to is &lt;em&gt;t&lt;/em&gt;, after which the next one you pull &lt;em&gt;will&lt;/em&gt; match one of the unpaired socks. This scenario is much more likely in the average sock drawer than the worst-case, and reduces the worst-case complexity to &lt;em&gt;O&lt;/em&gt;(n*t) where usually &lt;em&gt;t &amp;lt;&amp;lt; n&lt;/em&gt;.</source>
          <target state="translated">このスキームの最悪のシナリオは、靴下のすべてのペアが完全に一致する必要があるほど十分に異なり、最初に選択した&lt;em&gt;n / 2の&lt;/em&gt;靴下がすべて異なるというものです。 これは&lt;em&gt;O&lt;/em&gt; （n &lt;sup&gt;2&lt;/sup&gt; ）のシナリオであり、ほとんどあり得ません。 靴下&lt;em&gt;tの&lt;/em&gt;一意のタイプの数がペアの数&lt;em&gt;p = n / 2&lt;/em&gt;未満であり、各タイプの靴下が（通常は摩耗関連の用語で）十分に似ていて、そのタイプの靴下を任意の靴下と組み合わせることができる場合その他、次に、上記で推測したように、比較する必要がある靴下の最大数は&lt;em&gt;tです&lt;/em&gt; 。その後、次にプル&lt;em&gt;する&lt;/em&gt;靴下は、ペアになっていない靴下の1つと一致します。 このシナリオは、平均的な靴下の引き出しで最悪の場合よりもはるかに可能性が高く、最悪の場合の複雑さを&lt;em&gt;O&lt;/em&gt; （n * t）に減らします。通常、 &lt;em&gt;t &amp;lt;&amp;lt; n&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="96b12eabde3d73be5eafb1e84e13a730dc8628d1" translate="yes" xml:space="preserve">
          <source>Then all you do is snap your socks together right after you take them off and put them in your washing basket, and again you've removed the problem of needing to pair your socks with a physical abstraction of the 'pair' concept.</source>
          <target state="translated">靴下を脱いだらすぐにスナップして洗濯カゴに入れればいいだけなので、「ペア」という概念を物理的に抽象化して、靴下をペアリングする必要性の問題を取り除くことができます。</target>
        </trans-unit>
        <trans-unit id="dced202b38f2d14c3908f94ad0c3a8bd7e6f6c93" translate="yes" xml:space="preserve">
          <source>There are two physical possibilities:</source>
          <target state="translated">物理的には2つの可能性があります。</target>
        </trans-unit>
        <trans-unit id="4e4e9e2d368abd05573c65b163fd925efb9322d4" translate="yes" xml:space="preserve">
          <source>This also means that you will almost certainly never have all your socks in the array, because socks will get removed as they're matched.</source>
          <target state="translated">これはまた、靴下が揃うと取り除かれてしまうので、ほぼ確実にすべての靴下が揃うことはないということを意味しています。</target>
        </trans-unit>
        <trans-unit id="bdfecabe5ec0a698991109d39b1c3465373ad88d" translate="yes" xml:space="preserve">
          <source>This approach will be favourable compared to any &lt;code&gt;c*x*n + O(1)&lt;/code&gt; method roughly as long as &lt;code&gt;log(k) &amp;lt; x - 1&lt;/code&gt;.</source>
          <target state="translated">このアプローチは、 &lt;code&gt;log(k) &amp;lt; x - 1&lt;/code&gt; 限り、任意の &lt;code&gt;c*x*n + O(1)&lt;/code&gt; メソッドと比較して有利です。</target>
        </trans-unit>
        <trans-unit id="5d1f77ce46b573dd375b9b3f8133c6c3e6975fa2" translate="yes" xml:space="preserve">
          <source>This is asking the wrong question. The right question to ask is, why am I spending time sorting socks? How much does it cost on yearly basis, when you value your free time for X monetary units of your choice?</source>
          <target state="translated">これは間違った質問だ 正しい質問は、なぜ私は靴下の仕分けに時間を費やしているのか、ということです。自分の自由な時間を自分の選択したX通貨単位で評価すると、年間でどれくらいのコストがかかるのか?</target>
        </trans-unit>
        <trans-unit id="c7adcd7ce06b47130e35aa217e78946ac1fdb2c3" translate="yes" xml:space="preserve">
          <source>This is how I actually do it, for &lt;em&gt;p&lt;/em&gt; pairs of socks (&lt;em&gt;n = 2p&lt;/em&gt; individual socks):</source>
          <target state="translated">これが私が実際に行う方法です、靴下の&lt;em&gt;p&lt;/em&gt;ペア（ &lt;em&gt;n = 2pの&lt;/em&gt;個別の靴下）：</target>
        </trans-unit>
        <trans-unit id="235c85c59d6f0d9269c7c93b100ce67634688f1b" translate="yes" xml:space="preserve">
          <source>This kind of recursive hash partitioning is actually being done by &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt; when it needs to hash join or hash aggregate over huge data sets. It distributes its build input stream into many partitions which are independent. This scheme scales to arbitrary amounts of data and multiple CPUs linearly.</source>
          <target state="translated">この種の再帰的ハッシュパーティション分割は、巨大なデータセットで結合またはハッシュ集計をハッシュする必要がある場合に、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt;によって実際に行われます 。 ビルド入力ストリームを独立した多くのパーティションに分散します。 このスキームは、任意の量のデータと複数のCPUに線形にスケーリングします。</target>
        </trans-unit>
        <trans-unit id="71188b927e375c9f840b0228303d1ad03320f9ac" translate="yes" xml:space="preserve">
          <source>This question is actually deeply philosophical. At heart it's about whether the power of people to solve problems (the &quot;wetware&quot; of our brains) is equivalent to what can be accomplished by algorithms.</source>
          <target state="translated">この質問は実は哲学的に深いものです。その核心は、問題を解決するための人々の力(私たちの脳の「ウェットウェア」)が、アルゴリズムによって達成できることと同等かどうかということです。</target>
        </trans-unit>
        <trans-unit id="6137f79697d8c825e0bce0519a78dca5b385553f" translate="yes" xml:space="preserve">
          <source>This solves any computational pairing problem by removing it with a layer of abstraction.</source>
          <target state="translated">これは、抽象化されたレイヤーでそれを取り除くことで、あらゆる計算上のペアリング問題を解決します。</target>
        </trans-unit>
        <trans-unit id="832509383b3fc443a9e0c7a64e684a8be877a579" translate="yes" xml:space="preserve">
          <source>This takes advantage of the human ability to fuzzy-match in O(1) time, which is somewhat equivalent to the establishment of a hash-map on a computing device.</source>
          <target state="translated">これは、コンピューティングデバイス上でハッシュマップを確立するのと同じように、O(1)時間でファジーマッチを行う人間の能力を利用しています。</target>
        </trans-unit>
        <trans-unit id="bb9e4357cf8c4cf1055b16dd15145dc9529ca43b" translate="yes" xml:space="preserve">
          <source>Thus connecting the problem of pairing socks with the problem of hanging cloths I get &lt;code&gt;O(n)&lt;/code&gt; &quot;extra space&quot; for free, and have a solution that is about &lt;code&gt;O(n)&lt;/code&gt; in time, requires just a little more work than simple hanging cloths and allows to immediately access complete pair of socks even in a very bad Monday morning... ;-)</source>
          <target state="translated">したがって、ソックスのペアリングの問題と吊り布の問題を結びつけると、 &lt;code&gt;O(n)&lt;/code&gt; の 「余分なスペース」が無料で得られ、時間内に &lt;code&gt;O(n)&lt;/code&gt; 程度の解決策が得られ、単純な吊り布よりも少しだけ多くの作業が必要になります。非常に悪い月曜日の朝でも、靴下一式にすぐにアクセスできます... ;-)</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="cc9192722da415eb15991bb6f24cb75e9e00289e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;. This is only linear time since comparison is not required.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;基数ソートを&lt;/a&gt;使用します 。 比較が必要ないため、これは線形時間にすぎません。</target>
        </trans-unit>
        <trans-unit id="72e4524e8782dab66f9edff21207d55131fced9d" translate="yes" xml:space="preserve">
          <source>We also have to consider the intrinsic runtime of the atomic operations that can be carried out with these instruments. Due to physical constraints, operations which are carried out by an arm or eye have non constant time complexity. This is because we can't move an endlessly large pile of socks with an arm nor can an eye see the top sock on an endlessly large pile of socks.</source>
          <target state="translated">また、これらの機器で実行可能な原子操作の本質的な実行時間も考慮しなければならない。物理的な制約のため、腕や目によって実行される操作は、時間的な複雑さが一定ではありません。これは、果てしなく大きな靴下の山を腕で動かすことはできないし、目は果てしなく大きな靴下の山の上にある一番上の靴下を見ることもできないからです。</target>
        </trans-unit>
        <trans-unit id="fc41cda5f1c62ac5f64fac7531ea11668364e843" translate="yes" xml:space="preserve">
          <source>We can also make use of the fact that people only have a very limited amount of socks. So an environmental modification can involve all socks in the pile.</source>
          <target state="translated">また、人が持っている靴下の量が限られていることを利用することもできます。そのため、環境を改善するためには、すべての靴下の山を巻き込むことができます。</target>
        </trans-unit>
        <trans-unit id="7f928a1fe0e4e26c3f5eb42941dbb73bf04c00c1" translate="yes" xml:space="preserve">
          <source>We have to do comparison to check whether two socks come in pair. Pick one of the &lt;code&gt;O(n log n)&lt;/code&gt; comparison-based sorting algorithms.</source>
          <target state="translated">2つの靴下がペアになっているかどうかを確認するために比較を行う必要があります。 &lt;code&gt;O(n log n)&lt;/code&gt; 比較ベースのソートアルゴリズムの1つを選択します。</target>
        </trans-unit>
        <trans-unit id="8aff2e93d02cec92464795e91655b9cf0e01a5bf" translate="yes" xml:space="preserve">
          <source>What I do is that I pick up the first sock and put it down (say, on the edge of the laundry bowl). Then I pick up another sock and check to see if it's the same as the first sock. If it is, I remove them both. If it's not, I put it down next to the first sock. Then I pick up the third sock and compare that to the first two (if they're still there). Etc.</source>
          <target state="translated">私がやっていることは、最初の靴下を拾って、それを下に置くことです(例えば、洗濯機のボウルの端に)。そして、もう一枚の靴下を拾って、それが最初の靴下と同じかどうかを確認します。もしそうであれば、両方を取り除きます。そうでなければ、1枚目の靴下の隣に置きます。そして3枚目の靴下を拾い上げて、最初の2枚と比較します。などなど。</target>
        </trans-unit>
        <trans-unit id="52fb31e5804c85af0c9ab1080840c1c1106a6ac7" translate="yes" xml:space="preserve">
          <source>What about &lt;strong&gt;parallelism&lt;/strong&gt;? Can multiple humans match the socks faster?</source>
          <target state="translated">&lt;strong&gt;並列処理&lt;/strong&gt;についてはどうですか？ 複数の人間が靴下をより速く合わせることができますか？</target>
        </trans-unit>
        <trans-unit id="62ee3893b3dd45b1448958e4035d217abb5319ed" translate="yes" xml:space="preserve">
          <source>What about the &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;element distinctness problem&lt;/a&gt;? As the article states, the element distinctness problem can be solved in &lt;code&gt;O(N)&lt;/code&gt;. This is the same for the socks problem (also &lt;code&gt;O(N)&lt;/code&gt;, if you need only one distribution step (I proposed multiple steps only because humans are bad at calculations - one step is enough if you distribute on &lt;code&gt;md5(color, length, pattern, ...)&lt;/code&gt;, i.e. a &lt;strong&gt;perfect hash&lt;/strong&gt; of all attributes)).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;要素の明確性の問題は&lt;/a&gt;どうですか？ 記事で述べているように、要素の一意性の問題は &lt;code&gt;O(N)&lt;/code&gt; で解決できます。 これは、靴下の問題でも同じです（配布ステップが1つだけ必要な場合も &lt;code&gt;O(N)&lt;/code&gt; です（人間が計算が得意ではないため、複数のステップを提案しました &lt;code&gt;md5(color, length, pattern, ...)&lt;/code&gt; 配布する場合は1ステップで十分です） 、...） 、つまりすべての属性の&lt;strong&gt;完全なハッシュ&lt;/strong&gt; ））。</target>
        </trans-unit>
        <trans-unit id="d6e0a1a2a1c968e16f01d631ec79dc29fcbb8978" translate="yes" xml:space="preserve">
          <source>What we want to do is reduce the number of moves, and compensate with the number of searches. Also, we can utilize the multithreded environment of the Homo Sapiens to hold more things in the descision cache.</source>
          <target state="translated">やりたいことは、移動回数を減らし、検索回数で補うことです。また、ホモ・サピエンスのマルチスレッド環境を利用して、より多くのものを分割キャッシュに保持することができます。</target>
        </trans-unit>
        <trans-unit id="40119aa23f988c392c776aef12173470a672ba85" translate="yes" xml:space="preserve">
          <source>When I sort socks, I do an approximate &lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;, dropping socks near other socks of the same colour/pattern type. Except in the case when I can see an exact match at/near the location I'm about to drop the sock I extract the pair at that point.</source>
          <target state="translated">靴下を並べ替えるときは、近似の&lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;基数並べ替え&lt;/a&gt;を行い、同じ色/パターンタイプの他の靴下の近くに靴下を落とします。 靴下をドロップしようとしている場所またはその近くに完全一致が見られる場合を除いて、その時点でペアを抽出します。</target>
        </trans-unit>
        <trans-unit id="dbe5289d9f14e85418adcf750eb06633c494d931" translate="yes" xml:space="preserve">
          <source>Whenever you pick up a sock, put it in one place.  Then the next sock you pick up, if it doesn't match the first sock, set it beside the first one.  If it does, there's a pair.  This way it doesn't really matter how many combinations there are, and there are only two possibilities for each sock you pick up -- either it has a match that's already in your array of socks, or it doesn't, which means you add it to a place in the array.</source>
          <target state="translated">靴下を手に取ったら、必ず一か所に置きます。次に拾った靴下は、最初の靴下と合わなければ、最初の靴下の横に置く。合っていれば、ペアになっています。この方法では、靴下の組み合わせがいくつあっても問題ありません。</target>
        </trans-unit>
        <trans-unit id="491d10d638725516cd524ff053d646b7db3211cb" translate="yes" xml:space="preserve">
          <source>Why five? Usually humans are good are remembering between five and seven different elements in the working memory - a bit like the human equivalent of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;RPN&lt;/a&gt; stack - five is a safe default.</source>
          <target state="translated">なぜ５つ？ 通常、人間は優れています&lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;。RPN&lt;/a&gt;スタックに相当する人間のように、ワーキングメモリ内の5〜7個の異なる要素を覚えています。デフォルトは5つです。</target>
        </trans-unit>
        <trans-unit id="4e43cc34e87ad7b769f2e692b3183f1cf7531543" translate="yes" xml:space="preserve">
          <source>X = Yours, Y = Your spouses</source>
          <target state="translated">X=あなたのもの、Y=あなたの配偶者</target>
        </trans-unit>
        <trans-unit id="bfa8f5c7b6006f4ab74b72c8afabacf5f628c548" translate="yes" xml:space="preserve">
          <source>Yesterday I was pairing the socks from the clean laundry and figured out the way I was doing it is not very efficient. I was doing a naive search&amp;nbsp;&amp;mdash; picking one sock and &quot;iterating&quot; the pile in order to find its pair. This requires iterating over n/2 * n/4 = n&lt;sup&gt;2&lt;/sup&gt;/8 socks on average.</source>
          <target state="translated">昨日、きれいな洗濯物から靴下をペアリングしていて、その方法があまり効率的ではないことがわかりました。 私は素朴な検索を行っていました。靴下を1つ選び、そのペアを見つけるために山を &quot;反復&quot;しました。 これには、平均してn / 2 * n / 4 = n 2/8の靴下を反復処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="dbd5aa135244891d8a3e76bf37cc43c7ca49ef7d" translate="yes" xml:space="preserve">
          <source>Yet times to times, I have to do this again (lost socks, damaged socks, etc.), and I hate to discard perfectly good socks too often (and I wished they kept selling the same socks reference!), so I recently took a different approach.</source>
          <target state="translated">しかし、何度も何度も、私はこれを繰り返さなければならない(紛失した靴下、破損した靴下など)と、私はあまりにも頻繁に完全に良い靴下を捨てるのが嫌いです(そして、私は彼らが同じ靴下のリファレンスを販売し続けていたことを願っていました!)ので、最近、私は別のアプローチを取った。</target>
        </trans-unit>
        <trans-unit id="65810e5cb0ea23b0c4ace9656f94508778f1c8cd" translate="yes" xml:space="preserve">
          <source>You can achieve O(n) with &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;. You just need to pick some attributes for the buckets.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;基数ソートで&lt;/a&gt; O（n）を実現できます 。 バケットの属性をいくつか選択するだけです。</target>
        </trans-unit>
        <trans-unit id="ba38f2aaa4cb49326b1693f418fc55f635bc82d4" translate="yes" xml:space="preserve">
          <source>You don't need recursive partitioning if you can find a distribution key (hash key) that &lt;strong&gt;provides enough buckets&lt;/strong&gt; that each bucket is small enough to be processed very quickly. Unfortunately, I don't think socks have such a property.</source>
          <target state="translated">各バケットが非常に速く処理されるのに十分なほど小さい十分&lt;strong&gt;なバケット&lt;/strong&gt;を&lt;strong&gt;提供&lt;/strong&gt;する分散キー（ハッシュキー）を見つけることができる場合は、再帰的なパーティション分割は必要ありません。 残念ながら、靴下にはそのような特性はないと思います。</target>
        </trans-unit>
        <trans-unit id="991cf8e975ca3081b3b2acc02dc579d8b387f197" translate="yes" xml:space="preserve">
          <source>You need to estimate how many pairs of socks you will need for the rest of your life, or perhaps until you retire and move to warmer climates with no need to wear socks ever again. If you are young, you could also estimate how long it takes before we'll all have sock-sorting robots in our homes, and the whole problem becomes irrelevant.</source>
          <target state="translated">一生に何足の靴下が必要になるのか、あるいはリタイアして暖かい気候に引っ越して二度と靴下を履く必要がなくなるまでの期間を見積もる必要があります。もしあなたが若いのであれば、私たちの家に靴下仕分けロボットが来て、問題が無関係になるまでにどれくらいの時間がかかるかを見積もることもできます。</target>
        </trans-unit>
        <trans-unit id="fbfa245099ad6c7e954cd2c2f169e543c5ddc580" translate="yes" xml:space="preserve">
          <source>You need to find out how you can order your selected sock in bulk, and how much it costs, and do they deliver.</source>
          <target state="translated">あなたは、あなたが選択した靴下を一括で注文することができますどのように、それはどのくらいの費用がかかり、彼らは配信されているかを見つける必要があります。</target>
        </trans-unit>
        <trans-unit id="a2c3fba934e9cc7f3bb5f1c5bf7698755a4d500b" translate="yes" xml:space="preserve">
          <source>any subset taken from the top of this bin generally contains both
socks of a pair.</source>
          <target state="translated">このビンの先頭から取り出された部分集合は、一般的にペアの靴下の両方を含んでいます。</target>
        </trans-unit>
        <trans-unit id="66103b5b15e1b774175c59b31bb92026836434e7" translate="yes" xml:space="preserve">
          <source>environmental modifications</source>
          <target state="translated">環境改変</target>
        </trans-unit>
        <trans-unit id="b72a142027a3d942512bfeebef1158e5555cdbf9" translate="yes" xml:space="preserve">
          <source>environmental reads</source>
          <target state="translated">かんきょうよみとり</target>
        </trans-unit>
        <trans-unit id="73ed780668cf0ea89fb1a13af96da25121e815d0" translate="yes" xml:space="preserve">
          <source>logical and arithmetic operations</source>
          <target state="translated">論理演算</target>
        </trans-unit>
        <trans-unit id="7b417589bff426c4c61c5b75b1f2b186688fc14d" translate="yes" xml:space="preserve">
          <source>p&lt;sub&gt;1&lt;/sub&gt; p&lt;sub&gt;2&lt;/sub&gt; p&lt;sub&gt;3&lt;/sub&gt; ... p&lt;sub&gt;n&lt;/sub&gt; p&lt;sub&gt;f(1)&lt;/sub&gt; p&lt;sub&gt;f(2)&lt;/sub&gt; ... p&lt;sub&gt;f(n)&lt;/sub&gt;</source>
          <target state="translated">p &lt;sub&gt;1&lt;/sub&gt; p &lt;sub&gt;2&lt;/sub&gt; p &lt;sub&gt;3&lt;/sub&gt; ... p &lt;sub&gt;n&lt;/sub&gt; p &lt;sub&gt;f（1）&lt;/sub&gt; p &lt;sub&gt;f（2）&lt;/sub&gt; ... p &lt;sub&gt;f（n）&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d64b5bfb8d253171cb7f047779677b1f366a37c7" translate="yes" xml:space="preserve">
          <source>people toss both of their socks roughly in the same area of the
bin,</source>
          <target state="translated">人は靴下の両方を大まかに同じ場所に投げています。</target>
        </trans-unit>
        <trans-unit id="e7aa0c831ecd9e4ccd9acd48f58060ccc6e98d8a" translate="yes" xml:space="preserve">
          <source>step 1) discard all your existing socks</source>
          <target state="translated">ステップ1)今までの靴下をすべて捨てる</target>
        </trans-unit>
        <trans-unit id="85929a76b2535ede46f1da6de8472cf210e6cc72" translate="yes" xml:space="preserve">
          <source>step 2) go to &lt;a href=&quot;http://en.wikipedia.org/wiki/Walmart&quot;&gt;Walmart&lt;/a&gt; and buy them by packets of 10 - n packet of
white and m packets of black. No need for other colors in everyday's
life.</source>
          <target state="translated">ステップ2） &lt;a href=&quot;http://en.wikipedia.org/wiki/Walmart&quot;&gt;ウォルマートに&lt;/a&gt;行き、10のパケット-白のnパケットと黒のmパケットでそれらを購入します。 日常生活で他の色は必要ありません。</target>
        </trans-unit>
        <trans-unit id="f0bc37af84619514b988559161037a53edaa21ff" translate="yes" xml:space="preserve">
          <source>the bin is not randomized at any point, and therefore</source>
          <target state="translated">のビンはどの時点でもランダム化されていないので</target>
        </trans-unit>
        <trans-unit id="937822ebb59548bbc8c060e49cb9b98efb226b16" translate="yes" xml:space="preserve">
          <source>then length of the sock,</source>
          <target state="translated">次に靴下の長さ。</target>
        </trans-unit>
        <trans-unit id="f0604a64202bf39aaef8452c27dea8a360470c75" translate="yes" xml:space="preserve">
          <source>then texture,
....</source>
          <target state="translated">テクスチャ、......</target>
        </trans-unit>
        <trans-unit id="f0038d5ea027e24fd063b53770f561619dfa487e" translate="yes" xml:space="preserve">
          <source>then use colors (can have any order for the colors, e.g. alphabetically by color name) - split them into piles by color (remember to keep the initial order from step 1 for all socks in the same pile),</source>
          <target state="translated">その後、色を使用します(色の順番は自由に決められます。</target>
        </trans-unit>
        <trans-unit id="4045b164d7574af579063ab4269d98a5011ed66a" translate="yes" xml:space="preserve">
          <source>where f is an unknown permutation of the set {1,2,...,n}. Knowing this cannot make the problem harder. There are n! possible outputs (matchings between first and second half), which means you need log(n!) = Omega(n log n) comparisons. This is obtainable by sorting.</source>
          <target state="translated">ここで f は集合 {1,2,...,n}の未知の順列である.これを知っていても問題を難しくすることはできません.n! 可能な出力(前半と後半の間の一致)があるので、log(n!)=Omega(n log n)の比較が必要です。これはソートによって得られます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
