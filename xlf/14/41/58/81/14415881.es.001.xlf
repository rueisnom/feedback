<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/14415881">
    <body>
      <group id="14415881">
        <trans-unit id="94c0dfc6b17aa37cab713289ff046437e179508f" translate="yes" xml:space="preserve">
          <source>&quot;if s pairs with a sock t in N&quot;.  How quickly can we &quot;remember&quot; what we've seen so far?</source>
          <target state="translated">&quot;si s se empareja con un calcetín en N&quot;.¿Qué tan rápido podemos &quot;recordar&quot; lo que hemos visto hasta ahora?</target>
        </trans-unit>
        <trans-unit id="b5bdc0f37905c659679678b282a51daad6b30c24" translate="yes" xml:space="preserve">
          <source>&quot;remove t from N&quot; and &quot;add s to N&quot;.  How expensive is keeping track of what we've seen so far?</source>
          <target state="translated">&quot;quitar t de N&quot; y &quot;añadir s a N&quot;.¿Qué tan caro es llevar la cuenta de lo que hemos visto hasta ahora?</target>
        </trans-unit>
        <trans-unit id="257027605f38139d5816c62c3274fa0db3930e71" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;This approach can be fairly easily be implemented in an array, assuming that &quot;removing&quot; socks is an option.&lt;/s&gt; Actually, you don't even need to &quot;remove&quot; socks. If you don't need sorting of the socks (see below), then you can just move them around and end up with an array that has all the socks arranged in pairs in the array.</source>
          <target state="translated">&lt;s&gt;Este enfoque se puede implementar con bastante facilidad en una matriz, suponiendo que &quot;quitar&quot; los calcetines es una opci&amp;oacute;n.&lt;/s&gt; En realidad, ni siquiera necesita &quot;quitar&quot; los calcetines. Si no necesita clasificar los calcetines (ver a continuaci&amp;oacute;n), puede moverlos y terminar con una matriz que tiene todos los calcetines dispuestos en pares en la matriz.</target>
        </trans-unit>
        <trans-unit id="6fae469126cdfe9fb170ccabec0390cf8682c501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Heuristic:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Heuristic:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8be3cb9316f7f1176c171daf3e0ce96f2978c5e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithmic answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Respuesta algor&amp;iacute;tmica:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6dd89168d13c44609bd0eb1bed16428f8b39446" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BTW&lt;/strong&gt;, I found that the sum of the transaction costs of sorting all the socks every time I needed a pair were far less than doing it once and binding the socks. A just-in-time works better because then you don't have to bind the socks, and there's also a diminishing marginal return (that is, you keep looking for that two or three socks that when somewhere in the laundry and that you need to finish matching your socks and you lose time on that).</source>
          <target state="translated">&lt;strong&gt;Por cierto&lt;/strong&gt; , descubr&amp;iacute; que la suma de los costos de transacci&amp;oacute;n de ordenar todos los calcetines cada vez que necesitaba un par era mucho menor que hacerlo una vez y atar los calcetines. Un just-in-time funciona mejor porque entonces no tienes que atar los calcetines, y tambi&amp;eacute;n hay un retorno marginal decreciente (es decir, sigues buscando esos dos o tres calcetines que cuando est&amp;aacute;s en alg&amp;uacute;n lugar de la lavander&amp;iacute;a y que necesitas para terminar de combinar tus calcetines y pierdes tiempo con eso).</target>
        </trans-unit>
        <trans-unit id="2b5ac05a4a642e4eaddf91d074d8a86d8f9607d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1&lt;/strong&gt;: All socks are identical (this is what I do in real life by the way).</source>
          <target state="translated">&lt;strong&gt;Caso 1&lt;/strong&gt; : Todos los calcetines son id&amp;eacute;nticos (esto es lo que hago en la vida real por cierto).</target>
        </trans-unit>
        <trans-unit id="49a8a493d307384ee45499ab7676db0d67425182" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2&lt;/strong&gt;: There are a constant number of combinations (ownership, color, size, texture, etc.).</source>
          <target state="translated">&lt;strong&gt;Caso 2&lt;/strong&gt; : hay un n&amp;uacute;mero constante de combinaciones (propiedad, color, tama&amp;ntilde;o, textura, etc.).</target>
        </trans-unit>
        <trans-unit id="e00424d21a9c0392d4676ab7c8a9295c1d65c888" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 3&lt;/strong&gt;: The number of combinations is not known in advance (general case).</source>
          <target state="translated">&lt;strong&gt;Caso 3&lt;/strong&gt; : El n&amp;uacute;mero de combinaciones no se conoce de antemano (caso general).</target>
        </trans-unit>
        <trans-unit id="0b50c6f3b067c6fae56c03d06a7d861b64518113" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-algorithmic answer, yet &quot;efficient&quot; when I do it:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Respuesta no algor&amp;iacute;tmica, pero &quot;eficiente&quot; cuando lo hago:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f1ed3b5cf07fad91eb01fcb7a682e9e1f3420c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional&lt;/strong&gt; While you are searching the line and and the current sock you are looking at is identical to the previous, do step 2 for these socks.</source>
          <target state="translated">&lt;strong&gt;Opcional&lt;/strong&gt; Mientras busca la l&amp;iacute;nea y el calcet&amp;iacute;n actual que est&amp;aacute; viendo es id&amp;eacute;ntico al anterior, realice el paso 2 para estos calcetines.</target>
        </trans-unit>
        <trans-unit id="4e7b1dad68f6cce31ec46db04710d5118a2d7aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preconditions:&lt;/strong&gt;
There is no guarantee that there are the same socks. If they are of the same color it doesn't mean they have the same size or pattern. Socks are randomly shuffled. There can be odd number of socks (some are missing, we don't know how many). Prepare to remember a variable &quot;index&quot; and set it to 0.</source>
          <target state="translated">&lt;strong&gt;Condiciones previas:&lt;/strong&gt; no hay garant&amp;iacute;a de que haya los mismos calcetines. Si son del mismo color, no significa que tengan el mismo tama&amp;ntilde;o o patr&amp;oacute;n. Los calcetines se barajan al azar. Puede haber un n&amp;uacute;mero impar de calcetines (faltan algunos, no sabemos cu&amp;aacute;ntos). Prep&amp;aacute;rese para recordar una variable &quot;&amp;iacute;ndice&quot; y config&amp;uacute;rela en 0.</target>
        </trans-unit>
        <trans-unit id="e8d739a374e59173c2a911ac09bb3cfac524d27d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recursively apply this scheme&lt;/strong&gt; until you have distributed all socks onto &lt;strong&gt;very small piles that you can visually process immediately&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Aplique recursivamente este esquema&lt;/strong&gt; hasta que haya distribuido todos los calcetines en &lt;strong&gt;pilas muy peque&amp;ntilde;as que pueda procesar visualmente de inmediato.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b4b7ec4098550470ed2c4636c449a2c24d32ee0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, the question is basically:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Entonces, la pregunta es b&amp;aacute;sicamente:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08fda84558211c3c93b54ebc0219bb815255b9af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1:&lt;/strong&gt; Each time you put dirty socks in your laundry basket, tie them in a little knot. That way you will not have to do any sorting after the washing. Think of it like registering an index in a Mongo database. A little work ahead for some CPU savings in the future.</source>
          <target state="translated">&lt;strong&gt;Soluci&amp;oacute;n 1:&lt;/strong&gt; cada vez que coloque calcetines sucios en la canasta de la ropa, &amp;aacute;telos en un peque&amp;ntilde;o nudo. De esa manera no tendr&amp;aacute; que ordenar nada despu&amp;eacute;s del lavado. Piense en ello como registrar un &amp;iacute;ndice en una base de datos Mongo. Un poco de trabajo por delante para algunos ahorros de CPU en el futuro.</target>
        </trans-unit>
        <trans-unit id="b93e25b8a424a36b38ce0b2f666db17b4cec3ad9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2:&lt;/strong&gt; If it's winter, you don't have to wear matching socks. We are programmers. Nobody needs to know, as long as it works.</source>
          <target state="translated">&lt;strong&gt;Soluci&amp;oacute;n 2:&lt;/strong&gt; si es invierno, no tiene que usar medias a juego. Somos programadores Nadie necesita saber, mientras funcione.</target>
        </trans-unit>
        <trans-unit id="0094560f52b8dad6f4ad715c3c000c707e442bb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 3:&lt;/strong&gt; Spread the work. You want to perform such a complex CPU process asynchronously, without blocking the UI. Take that pile of socks and stuff them in a bag. Only look for a pair when you need it. That way the amount of work it takes is much less noticeable.</source>
          <target state="translated">&lt;strong&gt;Soluci&amp;oacute;n 3:&lt;/strong&gt; Difundir el trabajo. Desea realizar un proceso de CPU tan complejo de forma asincr&amp;oacute;nica, sin bloquear la interfaz de usuario. Toma esa pila de calcetines y m&amp;eacute;telos en una bolsa. Solo busque un par cuando lo necesite. De esa manera, la cantidad de trabajo que se necesita es mucho menos notable.</target>
        </trans-unit>
        <trans-unit id="cd64c3cf6ffd817f997a05ddde37296211310d6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result&lt;/strong&gt; will have one or two piles: 1. &quot;matched&quot; and 2. &quot;missing&quot;</source>
          <target state="translated">&lt;strong&gt;El resultado&lt;/strong&gt; tendr&amp;aacute; una o dos pilas: 1. &quot;emparejado&quot; y 2. &quot;faltante&quot;</target>
        </trans-unit>
        <trans-unit id="1873002ca8758724d2c9adf28e13baa534b32d50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are trying to solve the wrong problem.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Est&amp;aacute;s intentando resolver el problema equivocado.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42553619c0d4d907f8c4939e4417b4728dc4eff8" translate="yes" xml:space="preserve">
          <source>A general &lt;em&gt;theoretical&lt;/em&gt; solution for a huge number of socks.</source>
          <target state="translated">Una soluci&amp;oacute;n &lt;em&gt;te&amp;oacute;rica&lt;/em&gt; general para una gran cantidad de calcetines.</target>
        </trans-unit>
        <trans-unit id="86619e9b5473c8436c88e4580124cac4300c7011" translate="yes" xml:space="preserve">
          <source>A neat freak might use numeric labels for pairs as someone suggested.  This opens the door to a total ordering, which allows the human to use exactly the same algorithms we might with a CPU: binary search, trees, hashes, etc.</source>
          <target state="translated">Un fanático de la limpieza podría usar etiquetas numéricas para los pares,como alguien sugirió.Esto abre la puerta a un ordenamiento total,que permite al humano usar exactamente los mismos algoritmos que podríamos usar con una CPU:búsqueda binaria,árboles,hashes,etc.</target>
        </trans-unit>
        <trans-unit id="e2b68ea4fb20ff8e31763199ca38f49c47f03983" translate="yes" xml:space="preserve">
          <source>About parallelism:
As long as you toss both socks into the same bin, you can easily parallelize all of those steps.</source>
          <target state="translated">Sobre el paralelismo:Siempre y cuando arrojes ambos calcetines en el mismo recipiente,puedes fácilmente paralelizar todos esos pasos.</target>
        </trans-unit>
        <trans-unit id="f6fc8d26eb16b2c7196aa947f223e3e3ed467028" translate="yes" xml:space="preserve">
          <source>After eliminating the fluro coloured, the socks with stripes, and the three pairs of long socks, you might end up with mostly white socks roughly sorted by how worn they are.</source>
          <target state="translated">Después de eliminar el color fluro,los calcetines a rayas,y los tres pares de calcetines largos,se puede terminar con calcetines mayormente blancos ordenados aproximadamente según lo gastados que estén.</target>
        </trans-unit>
        <trans-unit id="98f0ebf5e1f426f9d4fb354b2d2f98129af56fdf" translate="yes" xml:space="preserve">
          <source>After that, there are only a few socks left. This is where I introduce previously unpaired socks into the system and process the remaining socks without any special algorithm - the remaining socks are very few and can be processed visually very fast.</source>
          <target state="translated">Después de eso,sólo quedan unos pocos calcetines.Aquí es donde introduzco los calcetines no emparejados previamente en el sistema y proceso los calcetines restantes sin ningún algoritmo especial-los calcetines restantes son muy pocos y pueden ser procesados visualmente muy rápido.</target>
        </trans-unit>
        <trans-unit id="f910680ab39d0aa8398bce15b13e098f9be2e9a8" translate="yes" xml:space="preserve">
          <source>After this, it's easy to do the hash partitioning algorithm. Usually, about 75% of the socks are already paired, leaving me with a very small subset of socks, and this subset is already (somewhat) clustered (I don't introduce much entropy into my basket after the preprocessing steps). Another thing is that the remaining clusters tend to be small enough to be handled at once, so it is possible to take a whole cluster out of the basket.</source>
          <target state="translated">Después de esto,es fácil hacer el algoritmo de partición de hachís.Normalmente,alrededor del 75% de los calcetines ya están emparejados,dejándome con un subconjunto muy pequeño de calcetines,y este subconjunto ya está (algo)agrupado (no introduzco mucha entropía en mi cesta después de los pasos de preprocesamiento).Otra cosa es que los grupos restantes tienden a ser lo suficientemente pequeños como para ser manipulados de una sola vez,por lo que es posible sacar un grupo entero de la cesta.</target>
        </trans-unit>
        <trans-unit id="a610a16cc6741362976a74534a8c23c401cdcb8f" translate="yes" xml:space="preserve">
          <source>Almost all the other algorithms (including &lt;a href=&quot;https://stackoverflow.com/a/14419556/1042311&quot;&gt;the top scoring answer by usr&lt;/a&gt;) sort, then remove pairs. I find that, as a human, it is better to minimize the number of socks being considered at one time.</source>
          <target state="translated">Casi todos los otros algoritmos (incluida &lt;a href=&quot;https://stackoverflow.com/a/14419556/1042311&quot;&gt;la respuesta de mayor puntuaci&amp;oacute;n por usr&lt;/a&gt; ) se ordenan y luego eliminan pares. Creo que, como humano, es mejor minimizar la cantidad de calcetines que se consideran al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="eccc8c5a89378f08c10b8d673e29520d1e8e7126" translate="yes" xml:space="preserve">
          <source>Also, there could be added check for damaged socks also, as if the removal of those. It could be inserted between 2 and 3, and between 13 and 14.</source>
          <target state="translated">Además,se podría añadir la comprobación de los calcetines dañados también,como si la eliminación de los mismos.Podría ser insertado entre 2 y 3,y entre 13 y 14.</target>
        </trans-unit>
        <trans-unit id="9788a20dd94a5a2bf372d767d6027859c72d11c2" translate="yes" xml:space="preserve">
          <source>Also, we don't need to assume a large number of socks, even for large families. Socks are taken out of the drawer and are worn, and then they are tossed in a place (maybe a bin) where they stay before being laundered. While I wouldn't call said bin a LIFO-Stack, I'd say it is safe to assume that</source>
          <target state="translated">Además,no necesitamos asumir un gran número de calcetines,incluso para las familias numerosas.Los calcetines se sacan del cajón y se usan,y luego se tiran en un lugar (tal vez un contenedor)donde se quedan antes de ser lavados.Aunque yo no llamaría a dicho contenedor una pila de vida,diría que es seguro asumir que</target>
        </trans-unit>
        <trans-unit id="157fc609ec55f17f263d7a3a005a4071e377c228" translate="yes" xml:space="preserve">
          <source>Although the outputs are not exactly the same (in one case, just a boolean. In the other case, the pairs of socks), the asymptotic complexities are the same.</source>
          <target state="translated">Aunque las salidas no son exactamente las mismas (en un caso,sólo un booleano.En el otro caso,los pares de calcetines),las complejidades asintóticas son las mismas.</target>
        </trans-unit>
        <trans-unit id="05e0d0df0a6446265996f77e214ab1168f512228" translate="yes" xml:space="preserve">
          <source>An alternative step 3 would involve comparing costs of buying the same amount of perhaps cheaper socks a few pairs at a time over the years and adding the cost of sorting socks, but take my word for it: buying in bulk is cheaper! Also, socks in storage increase in value at the rate of stock price inflation, which is more than you would get on many investments. Then again there is also storage cost, but socks really do not take much space on the top shelf of a closet.</source>
          <target state="translated">Un paso alternativo 3 implicaría comparar los costos de comprar la misma cantidad de calcetines tal vez más baratos unos pocos pares a la vez a lo largo de los años y añadir el costo de la clasificación de los calcetines,pero créanme:¡comprar a granel es más barato! Además,los calcetines almacenados aumentan de valor a la tasa de inflación del precio de las acciones,que es más de lo que se obtendría en muchas inversiones.Por otra parte,también hay un costo de almacenamiento,pero los calcetines realmente no ocupan mucho espacio en el estante superior de un armario.</target>
        </trans-unit>
        <trans-unit id="3835c018ca31a4eabdd14cc9d36b8f5e0b2ee808" translate="yes" xml:space="preserve">
          <source>An obvious algorithm for sock sorting is:</source>
          <target state="translated">Un algoritmo obvio para la clasificación de calcetines es:</target>
        </trans-unit>
        <trans-unit id="56b599442bccb5b5949e6ad41c70544a44257d97" translate="yes" xml:space="preserve">
          <source>And more often than not, this is not just &lt;em&gt;any&lt;/em&gt; free time, it's &lt;em&gt;morning&lt;/em&gt; free time, which you could be spending in bed, or sipping your coffee, or leaving a bit early and not being caught in the traffic.</source>
          <target state="translated">Y la mayor&amp;iacute;a de las veces, este no es solo &lt;em&gt;un&lt;/em&gt; tiempo libre, es el tiempo libre de la &lt;em&gt;ma&amp;ntilde;ana&lt;/em&gt; , que podr&amp;iacute;a pasar en la cama, tomar un caf&amp;eacute; o salir un poco temprano y no quedar atrapado en el tr&amp;aacute;fico.</target>
        </trans-unit>
        <trans-unit id="121979168ac388fe182e793a8f415d4c02e0bcfd" translate="yes" xml:space="preserve">
          <source>And there is a way!</source>
          <target state="translated">¡Y hay una manera!</target>
        </trans-unit>
        <trans-unit id="aaed1a26327f668180ed38055a98d2f4a897c097" translate="yes" xml:space="preserve">
          <source>Applying the same idea to the practical problem of pairing socks, the apparent answer is: don't allow your socks to ever be unpaired. Socks are provided as a pair, put in the drawer as a pair (perhaps by balling them together), worn as a pair. But the point where unpairing is possible is in the washer, so all that's required is a physical mechanism that allows the socks to stay together and be washed efficiently.</source>
          <target state="translated">Aplicando la misma idea al problema práctico de emparejar los calcetines,la respuesta aparente es:no permitas que tus calcetines nunca estén desparejados.Los calcetines se proporcionan como un par,se ponen en el cajón como un par (tal vez haciendo una bola con ellos),se usan como un par.Pero el punto en el que es posible desparejar los calcetines está en la lavadora,así que todo lo que se requiere es un mecanismo físico que permita que los calcetines permanezcan juntos y se laven eficientemente.</target>
        </trans-unit>
        <trans-unit id="4447172c03cd07d366eaa6901d47c0105462f432" translate="yes" xml:space="preserve">
          <source>As a computer scientist I was thinking what I could do? Sorting (according to size/color/...) of course came to mind to achieve an O(NlogN) solution.</source>
          <target state="translated">Como informático,estaba pensando en lo que podría hacer...Clasificar (según el tamaño y el color...)por supuesto se me ocurrió para lograr una solución O(NlogN).</target>
        </trans-unit>
        <trans-unit id="dea5f13104d5d8bafb26f6f1728af7ebead57e19" translate="yes" xml:space="preserve">
          <source>As a practical solution:</source>
          <target state="translated">Como una solución práctica:</target>
        </trans-unit>
        <trans-unit id="0330f3b9f6b91d26ecc04e1313146ad77b320f18" translate="yes" xml:space="preserve">
          <source>As rapidly as possible, remove socks from the unsorted pile one at a time and place in piles in front of you. The piles should be arranged somewhat space-efficiently, with all socks pointing the same direction; the number of piles is limited by the distance you can easily reach. The selection of a pile on which to put a sock should be -- as rapidly as possible -- by putting a sock on a pile of apparently like socks; the occasional type I (putting a sock on a pile it doesn't belong to) or type II (putting a sock in its own pile when there's an existing pile of like socks) error can be tolerated -- the most important consideration is &lt;em&gt;speed&lt;/em&gt;. Once all the socks are in piles, rapidly go through the multi-sock piles creating pairs and removing them (these are heading for the drawer). If there are non-matching socks in the pile, re-pile them to their best (within the as-fast-as-possible constraint) pile. When all the multi-sock piles have been processed, match up remaining pairable socks that weren't paired due to type II errors. Whoosh, you're done -- and I have a lot of socks and don't wash them until a large fraction are dirty. Another practical note: I flip the top of one of a pair of socks down over the other, taking advantage of their elastic properties, so they stay together while being transported to the drawer and while in the drawer.</source>
          <target state="translated">Tan r&amp;aacute;pido como sea posible, retire los calcetines de la pila sin clasificar uno a la vez y col&amp;oacute;quelos en pilas frente a usted. Las pilas deben estar dispuestas de manera eficiente en el espacio, con todos los calcetines apuntando en la misma direcci&amp;oacute;n; El n&amp;uacute;mero de pilas est&amp;aacute; limitado por la distancia que puede alcanzar f&amp;aacute;cilmente. La selecci&amp;oacute;n de un mont&amp;oacute;n sobre el cual colocar un calcet&amp;iacute;n debe hacerse, lo m&amp;aacute;s r&amp;aacute;pido posible, colocando un calcet&amp;iacute;n sobre un mont&amp;oacute;n de calcetines aparentemente similares; el tipo ocasional I (poner un calcet&amp;iacute;n en una pila a la que no pertenece) o el tipo II (poner un calcet&amp;iacute;n en su propia pila cuando hay una pila existente de calcetines similares) se puede tolerar: la consideraci&amp;oacute;n m&amp;aacute;s importante es la &lt;em&gt;velocidad&lt;/em&gt; . Una vez que todos los calcetines est&amp;eacute;n en pilas, pase r&amp;aacute;pidamente por las pilas de m&amp;uacute;ltiples calcetines creando pares y retir&amp;aacute;ndolos (estos se dirigen al caj&amp;oacute;n). Si hay calcetines que no coinciden en la pila, vuelva a apilarlos a su mejor pila (dentro de la restricci&amp;oacute;n lo m&amp;aacute;s r&amp;aacute;pido posible). Cuando se hayan procesado todas las pilas de calcetines m&amp;uacute;ltiples, combine los calcetines que se pueden emparejar restantes que no se emparejaron debido a errores de tipo II. Whoosh, ya terminaste, y tengo muchos calcetines y no los lavo hasta que una gran parte est&amp;eacute; sucia. Otra nota pr&amp;aacute;ctica: volteo la parte superior de un par de calcetines sobre el otro, aprovechando sus propiedades el&amp;aacute;sticas, para que permanezcan juntos mientras se transportan al caj&amp;oacute;n y mientras est&amp;aacute;n en el caj&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="21c82dc8d9601ae12e034b45a03f0358de859eb2" translate="yes" xml:space="preserve">
          <source>As the architecture of the human brain is completely different than a modern CPU, this question makes no practical sense.</source>
          <target state="translated">Como la arquitectura del cerebro humano es completamente diferente a la de un CPU moderno,esta pregunta no tiene sentido práctico.</target>
        </trans-unit>
        <trans-unit id="c9da0c9b1a26a80303bb8c443c01afa8a2584687" translate="yes" xml:space="preserve">
          <source>Assuming that the only operation for socks is to compare for equality, this algorithm is basically still an n&lt;sup&gt;2&lt;/sup&gt; algorithm, though I don't know about the average case (never learned to calculate that).</source>
          <target state="translated">Suponiendo que la &amp;uacute;nica operaci&amp;oacute;n para los calcetines es comparar la igualdad, este algoritmo sigue siendo b&amp;aacute;sicamente un algoritmo n &lt;sup&gt;2&lt;/sup&gt; , aunque no conozco el caso promedio (nunca aprend&amp;iacute; a calcular eso).</target>
        </trans-unit>
        <trans-unit id="9ecfa67dfd0923fad315f8a06acb48f7f0237861" translate="yes" xml:space="preserve">
          <source>At least this is what I am using in real life, and I find it very efficient. The downside is it requires a flat surface, but it's usually abundant.</source>
          <target state="translated">Al menos esto es lo que estoy usando en la vida real,y lo encuentro muy eficiente.La desventaja es que requiere una superficie plana,pero suele ser abundante.</target>
        </trans-unit>
        <trans-unit id="5b86498f0344f03ab782a1075a31f259917a9553" translate="yes" xml:space="preserve">
          <source>At some point, the differences between socks are small enough that other people won't notice the difference, and any further matching effort is not needed.</source>
          <target state="translated">En algún momento,las diferencias entre los calcetines son lo suficientemente pequeñas como para que otras personas no noten la diferencia,y no se necesita ningún otro esfuerzo de emparejamiento.</target>
        </trans-unit>
        <trans-unit id="7e52e0e243840d708880946b6c4315d013367de6" translate="yes" xml:space="preserve">
          <source>But for each sock to keep a reference to the other, there is a neat solution: a popper (or a 'snap button' if you're American), such as these:</source>
          <target state="translated">Pero para que cada calcetín mantenga una referencia al otro,hay una solución limpia:un popper (o un &quot;botón de presión&quot; si eres americano),como estos:</target>
        </trans-unit>
        <trans-unit id="b59dc09b425cf2a04ad8751ed78176abb3f57590" translate="yes" xml:space="preserve">
          <source>By pulling the distinctive socks first, you leave space to &quot;zoom&quot; in on the features which are less distinctive, to begin with.</source>
          <target state="translated">Al tirar de los calcetines distintivos primero,dejas espacio para &quot;acercar&quot; los rasgos menos distintivos,para empezar.</target>
        </trans-unit>
        <trans-unit id="325f07a647449aca13d04b404d5077e42950128f" translate="yes" xml:space="preserve">
          <source>By reducing my inputs to one of two types of socks (white socks for recreation, black socks for work), I only need to determine which of two socks I have in hand. (Technically, since they are never washed together, I have reduced the process to O(0) time)</source>
          <target state="translated">Reduciendo mis entradas a uno de los dos tipos de calcetines (calcetines blancos para el recreo,calcetines negros para el trabajo),sólo tengo que determinar cuál de los dos calcetines tengo a mano.(Técnicamente,como nunca se lavan juntos,he reducido el proceso a tiempo O(0))</target>
        </trans-unit>
        <trans-unit id="839d4561e5360dfca7e45fa2801c421ef3ca26fb" translate="yes" xml:space="preserve">
          <source>Choose one of the socks and put it away (create a 'bucket' for that pair)</source>
          <target state="translated">Escoge uno de los calcetines y guárdalo (crea un 'cubo' para ese par)</target>
        </trans-unit>
        <trans-unit id="5d6b924144b70d6a90942c0979240ccaa91f1233" translate="yes" xml:space="preserve">
          <source>Clearly, one cannot go faster than &lt;code&gt;O(N)&lt;/code&gt;, so we have reached the &lt;strong&gt;optimal lower bound&lt;/strong&gt;.</source>
          <target state="translated">Claramente, uno no puede ir m&amp;aacute;s r&amp;aacute;pido que &lt;code&gt;O(N)&lt;/code&gt; , por lo que hemos alcanzado el &lt;strong&gt;l&amp;iacute;mite inferior &amp;oacute;ptimo&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9a74f91f894f5fdd53f2126400da6be5bbf36590" translate="yes" xml:space="preserve">
          <source>Combine with Other Task</source>
          <target state="translated">Combinar con otras tareas</target>
        </trans-unit>
        <trans-unit id="8ac6a3ace758bdb634f5dc66fbca8858d699c4a7" translate="yes" xml:space="preserve">
          <source>Consider a hash-table of  size  'N'.</source>
          <target state="translated">Considere una tabla de hachís del tamaño 'N'.</target>
        </trans-unit>
        <trans-unit id="be4d36fcb52cd8affab669c9c320903855e4dd53" translate="yes" xml:space="preserve">
          <source>Consider than if you draw only one sock for the second stack of socks, as you are doing, your odds of finding the matching sock in a naive search is quite low.</source>
          <target state="translated">Considera que si sacas sólo un calcetín para la segunda pila de calcetines,como lo estás haciendo,tus probabilidades de encontrar el calcetín correspondiente en una búsqueda ingenua son bastante bajas.</target>
        </trans-unit>
        <trans-unit id="f9b1944832d9453a7dc17748fdc3d9173cbd95c9" translate="yes" xml:space="preserve">
          <source>Cost: Moving socks -&amp;gt; high, finding/search socks in line -&amp;gt; small</source>
          <target state="translated">Costo: mover calcetines -&amp;gt; alto, buscar / buscar calcetines en l&amp;iacute;nea -&amp;gt; peque&amp;ntilde;o</target>
        </trans-unit>
        <trans-unit id="05201805c52c192640e03bce4060ac08d6051851" translate="yes" xml:space="preserve">
          <source>Create a hash table which will be used for unmatched socks, using the pattern as the hash. Iterate over the socks one by one. If the sock has a pattern match in the hash table, take the sock out of the table and make a pair. If the sock does not have a match, put it into the table.</source>
          <target state="translated">Crear una tabla de hachís que se utilizará para los calcetines sin par,utilizando el patrón como hachís.Iterar sobre los calcetines uno por uno.Si el calcetín tiene un patrón que coincide en la tabla de hachís,saca el calcetín de la tabla y haz un par.Si el calcetín no tiene una coincidencia,ponlo en la mesa.</target>
        </trans-unit>
        <trans-unit id="ece5b7e4f44f0c60b7df2b4d7656e3eb3246bbfd" translate="yes" xml:space="preserve">
          <source>Do until A is empty.</source>
          <target state="translated">Hazlo hasta que A esté vacía.</target>
        </trans-unit>
        <trans-unit id="a3af62234185a8fbf95199db3ed4496b2e1b062b" translate="yes" xml:space="preserve">
          <source>Do until both X and Y is empty.</source>
          <target state="translated">Hazlo hasta que tanto X como Y estén vacíos.</target>
        </trans-unit>
        <trans-unit id="e74f486c764075c4dfed8abc5b9386d07590d29c" translate="yes" xml:space="preserve">
          <source>Don't waste your time moving socks around or looking for the best match, this all should be done in O(n), which we would also need for just putting them on the line unsorted.
The socks aren't paired yet, we only have several similarity clusters on the line. It's helpful that we have a limited set of socks here, as this helps us to create &quot;good&quot; clusters (for example, if there are only black socks in the set of socks, clustering by colours would not be the way to go)</source>
          <target state="translated">No pierdas el tiempo moviendo los calcetines o buscando la mejor combinación,todo esto debería hacerse en O(n),que también necesitaríamos para ponerlos en la línea sin clasificar.Los calcetines no están emparejados todavía,sólo tenemos varios grupos de similitudes en la línea.Es útil que tengamos un conjunto limitado de calcetines aquí,ya que esto nos ayuda a crear &quot;buenos&quot; grupos (por ejemplo,si sólo hay calcetines negros en el conjunto de calcetines,el agrupamiento por colores no sería el camino a seguir)</target>
        </trans-unit>
        <trans-unit id="e9b450d14bc2363d292c84f17cfad5cfbd58a458" translate="yes" xml:space="preserve">
          <source>Done</source>
          <target state="translated">Done</target>
        </trans-unit>
        <trans-unit id="9ec877009e8b5ea7edaecdf46b39cdf271ac5e08" translate="yes" xml:space="preserve">
          <source>Feel free to write down the formula to calculate how many samples you have to draw for a 50% odds of a match. IIRC it's an hypergeometric law.</source>
          <target state="translated">No dude en escribir la fórmula para calcular cuántas muestras debe extraer para un 50% de probabilidades de una coincidencia.IIRC es una ley hipergeométrica.</target>
        </trans-unit>
        <trans-unit id="ee75e1685f87ca197f6c3aaaa97916949e86e0db" translate="yes" xml:space="preserve">
          <source>Find a pair by looking at the socks on the floor.</source>
          <target state="translated">Encuentra un par mirando los calcetines en el suelo.</target>
        </trans-unit>
        <trans-unit id="2d7f4a781c3305161bd0ab2917bdad576999ed2c" translate="yes" xml:space="preserve">
          <source>Find a sock you like. Take all relevant features into account: colour in different lighting conditions, overall quality and durability, comfort in different climatic conditions, and odour absorption. Also important is, they should not lose elasticity in storage, so natural fabrics are good, and they should be available in a plastic wrapping.</source>
          <target state="translated">Encuentra un calcetín que te guste.Ten en cuenta todas las características relevantes:el color en diferentes condiciones de iluminación,la calidad y durabilidad general,el confort en diferentes condiciones climáticas y la absorción de olores.También es importante que no pierdan elasticidad en el almacenamiento,por lo que los tejidos naturales son buenos,y deben estar disponibles en un envoltorio de plástico.</target>
        </trans-unit>
        <trans-unit id="a9a8d801aad71c6f999c991c92a663302901ccc9" translate="yes" xml:space="preserve">
          <source>Find all matched pairs, pack it and move packed pairs to &quot;matched&quot; pile;
 If there were no new matches - increment &quot;index&quot; by 1</source>
          <target state="translated">Encuentra todos los pares coincidentes,empaquétalos y mueve los pares empaquetados a la pila de &quot;coincidencias&quot;;Si no hay nuevas coincidencias-incrementa el &quot;índice&quot; en 1</target>
        </trans-unit>
        <trans-unit id="52c3a2cfe2904b404c77eec5836501de1058b709" translate="yes" xml:space="preserve">
          <source>Find its match.</source>
          <target state="translated">Encuentra su coincidencia.</target>
        </trans-unit>
        <trans-unit id="c0a4340783c31b2ef43b6cdc9d203753e623f8c3" translate="yes" xml:space="preserve">
          <source>Find its pair</source>
          <target state="translated">Encuentra su par</target>
        </trans-unit>
        <trans-unit id="9398e96bcda6ff722938ce7ced4416bbac5aa5f1" translate="yes" xml:space="preserve">
          <source>Find most distinctive sock.</source>
          <target state="translated">Encuentra el calcetín más distintivo.</target>
        </trans-unit>
        <trans-unit id="82f8de3c35ca9b182c746b9a61ec6f2e62e7264c" translate="yes" xml:space="preserve">
          <source>First you can choose (hers, mine) - split them into 2 piles,</source>
          <target state="translated">Primero puedes elegir (el de ella,el mío)-dividirlos en 2 montones,</target>
        </trans-unit>
        <trans-unit id="893e0080cad23ba3476d1e48d4706a557776aeeb" translate="yes" xml:space="preserve">
          <source>For a 'pair' object that keeps a pointer to each sock we could have a cloth bag that we use to keep the socks together. This seems like massive overhead.</source>
          <target state="translated">Para un objeto &quot;par&quot; que mantiene un puntero en cada calcetín podríamos tener una bolsa de tela que usamos para mantener los calcetines juntos.Esto parece una enorme sobrecarga.</target>
        </trans-unit>
        <trans-unit id="077ecc6cb20560a33edffb3287fdf7ac14426d24" translate="yes" xml:space="preserve">
          <source>For all remaining socks, I assume that their counterparts are still unwashed and put them away for the next iteration. If you register a growth of unpaired socks over time (a &quot;sock leak&quot;), you should check your bin - it might get randomized (do you have cats which sleep in there?)</source>
          <target state="translated">Para todos los calcetines restantes,asumo que sus contrapartes aún están sin lavar y los guardo para la próxima iteración.Si registras un crecimiento de calcetines no emparejados con el tiempo (una &quot;fuga de calcetines&quot;),deberías revisar tu cubo de basura-puede que se ponga al azar (¿tienes gatos que duermen ahí?)</target>
        </trans-unit>
        <trans-unit id="cc92f3e9adf433b615dccfeb6da282fce4ea8901" translate="yes" xml:space="preserve">
          <source>For each color of socks, &lt;strong&gt;form a pile&lt;/strong&gt;. Iterate over all socks in your input basket &lt;strong&gt;and distribute them onto the color piles&lt;/strong&gt;.</source>
          <target state="translated">Para cada color de medias, &lt;strong&gt;forme una pila&lt;/strong&gt; . Itere sobre todos los calcetines en su cesta de entrada &lt;strong&gt;y distrib&amp;uacute;yalos en las pilas de colores&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d6414c797002dc91c1ae83eaf49240cdcbf24e18" translate="yes" xml:space="preserve">
          <source>For each line X and Y</source>
          <target state="translated">Para cada línea X e Y</target>
        </trans-unit>
        <trans-unit id="5855dab75f8b813fca7ffaa714ea108a4295227b" translate="yes" xml:space="preserve">
          <source>For the first sock, or if all previously-chosen socks have been paired, simply place the sock into the first &quot;slot&quot; of an &quot;array&quot; of unpaired socks in front of you.</source>
          <target state="translated">Para el primer calcetín,o si todos los calcetines previamente elegidos han sido emparejados,simplemente coloca el calcetín en la primera &quot;ranura&quot; de un &quot;conjunto&quot; de calcetines no emparejados delante de ti.</target>
        </trans-unit>
        <trans-unit id="894192607ac808554f03c075fd0655a37e1ad671" translate="yes" xml:space="preserve">
          <source>For the following runtime analysis of pairing &lt;code&gt;n&lt;/code&gt; pairs of socks, we suppose that at least half of the &lt;code&gt;2n&lt;/code&gt; socks aren't hidden after step 1. So in the average case we can find &lt;code&gt;n/2&lt;/code&gt; pairs. This means that the loop is step 4 is executed &lt;code&gt;O(log n)&lt;/code&gt; times. Step 2 is executed &lt;code&gt;O(n^2)&lt;/code&gt; times. So we can conclude:</source>
          <target state="translated">Para el siguiente an&amp;aacute;lisis de tiempo de ejecuci&amp;oacute;n de emparejar &lt;code&gt;n&lt;/code&gt; pares de calcetines, suponemos que al menos la mitad de los &lt;code&gt;2n&lt;/code&gt; calcetines no est&amp;aacute;n ocultos despu&amp;eacute;s del paso 1. Por lo tanto, en el caso promedio podemos encontrar &lt;code&gt;n/2&lt;/code&gt; pares. Esto significa que el ciclo del paso 4 se ejecuta &lt;code&gt;O(log n)&lt;/code&gt; veces. El paso 2 se ejecuta &lt;code&gt;O(n^2)&lt;/code&gt; veces. Entonces podemos concluir:</target>
        </trans-unit>
        <trans-unit id="cd22dd03c04d34755de0454c107040828d993fa6" translate="yes" xml:space="preserve">
          <source>Forget &quot;index&quot;</source>
          <target state="translated">Olvida el &quot;índice&quot;</target>
        </trans-unit>
        <trans-unit id="754feeeb1411a93845cc30e2f433edcea6d8f1d0" translate="yes" xml:space="preserve">
          <source>From pile A of all socks:</source>
          <target state="translated">De la pila A de todos los calcetines:</target>
        </trans-unit>
        <trans-unit id="88af6c6ae694d3f0adbd64981b429a7c2015afc5" translate="yes" xml:space="preserve">
          <source>From your question it is clear you don't have much actual experience with laundry :). You need an algorithm that works well with a small number of non-pairable socks.</source>
          <target state="translated">De su pregunta se desprende claramente que no tiene mucha experiencia real con la lavandería :).Necesitas un algoritmo que funcione bien con un pequeño número de calcetines no reparables.</target>
        </trans-unit>
        <trans-unit id="0444a1d3195984e21f70709ff60bf0a46830a14e" translate="yes" xml:space="preserve">
          <source>Get rid of your old socks.</source>
          <target state="translated">Deshazte de tus calcetines viejos.</target>
        </trans-unit>
        <trans-unit id="a1a874f464be482c37caf7802d65a53aaacd038a" translate="yes" xml:space="preserve">
          <source>Given a pile of &lt;code&gt;n&lt;/code&gt; pairs of socks, containing &lt;code&gt;2n&lt;/code&gt; elements (assume each sock has exactly one matching pair), what is the best way to pair them up efficiently with up to logarithmic extra space? (I believe I can remember that amount of info if needed.)</source>
          <target state="translated">Dado un mont&amp;oacute;n de &lt;code&gt;n&lt;/code&gt; pares de calcetines, que contienen &lt;code&gt;2n&lt;/code&gt; elementos (suponga que cada calcet&amp;iacute;n tiene exactamente un par coincidente), &amp;iquest;cu&amp;aacute;l es la mejor manera de emparejarlos de manera eficiente con hasta un espacio extra logar&amp;iacute;tmico? (Creo que puedo recordar esa cantidad de informaci&amp;oacute;n si es necesario).</target>
        </trans-unit>
        <trans-unit id="92391b2bac5f63b1732ccf6a829b75982b2d6b4f" translate="yes" xml:space="preserve">
          <source>Go to 1</source>
          <target state="translated">Ir a la 1</target>
        </trans-unit>
        <trans-unit id="7548a76daeaf6efed0b0d32caeb5242aedd1b6ef" translate="yes" xml:space="preserve">
          <source>Grab a sock at random from the pile.</source>
          <target state="translated">Coge un calcetín al azar del montón.</target>
        </trans-unit>
        <trans-unit id="8b31726f5fe78e7abfdb271081348d3c49ef8d7a" translate="yes" xml:space="preserve">
          <source>Hashing or other not-in-place solutions are not an option, because I am not able to duplicate my socks (though it could be nice if I could).</source>
          <target state="translated">El &quot;hashing&quot; u otras soluciones que no están en el lugar no son una opción,porque no soy capaz de duplicar mis calcetines (aunque estaría bien si pudiera).</target>
        </trans-unit>
        <trans-unit id="0bebef8e20477195eae330c945bf1f33000ef38c" translate="yes" xml:space="preserve">
          <source>Have it Almost &lt;code&gt;O(n)&lt;/code&gt;!</source>
          <target state="translated">&amp;iexcl;Tenlo casi &lt;code&gt;O(n)&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="d3cc97a68c770f1ea7c6ba0f7a34ec7739feed82" translate="yes" xml:space="preserve">
          <source>Here's an Omega(n log n) lower bound in comparison based model. (The only valid operation is comparing two socks.)</source>
          <target state="translated">Aquí hay un límite inferior Omega(n log n)en el modelo basado en la comparación.(La única operación válida es comparar dos calcetines.)</target>
        </trans-unit>
        <trans-unit id="08f1f9a1a68f065efbd777b85e911439d922e715" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for put_socks_on_line():</source>
          <target state="translated">Aquí está el algoritmo para put_socks_on_line():</target>
        </trans-unit>
        <trans-unit id="54268b27bb372ae27ec075e414013dd493b79119" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for sort_remaining_clusters():</source>
          <target state="translated">Aquí está el algoritmo para sort_remaining_clusters():</target>
        </trans-unit>
        <trans-unit id="a12197b6379a8cd2d9de831467c2eea0d417e206" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for take_socks_from_line():</source>
          <target state="translated">Aquí está el algoritmo de take_socks_from_line():</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">¡Espero que esto ayude!</target>
        </trans-unit>
        <trans-unit id="5435330177144a505ebd78530841aed23ef79bd1" translate="yes" xml:space="preserve">
          <source>How to pair socks from a pile efficiently</source>
          <target state="translated">Cómo emparejar calcetines de una pila de manera eficiente</target>
        </trans-unit>
        <trans-unit id="0163309c2cf5dde27bf33b63dc03540e97a8c089" translate="yes" xml:space="preserve">
          <source>However in real life when the number of socks is relatively small (constant), these theoretically optimal algorithms wouldn't work well. It might take even more time than sequential search, which theoretically requires quadratic time.</source>
          <target state="translated">Sin embargo,en la vida real,cuando el número de calcetines es relativamente pequeño (constante),estos algoritmos teóricamente óptimos no funcionarían bien.Podría llevar incluso más tiempo que la búsqueda secuencial,que teóricamente requiere un tiempo cuadrático.</target>
        </trans-unit>
        <trans-unit id="c187385279c8ededa5efc4f1fe03ebf17e729283" translate="yes" xml:space="preserve">
          <source>However mechanical physics give us some goodies as well. We are not limited to move at most one sock with an arm. We can move a whole couple of them at once.</source>
          <target state="translated">Sin embargo,la física mecánica también nos da algunas ventajas.No estamos limitados a mover como mucho un calcetín con un brazo.Podemos mover un par de ellos a la vez.</target>
        </trans-unit>
        <trans-unit id="4eb82567512fc8943c9bca03d3dcc2dfbfc9658a" translate="yes" xml:space="preserve">
          <source>However, as this have simillar complexity as selection sort, the time taken is far less due to the speeds of I/O(moving socks) and search(searching the line for a sock).</source>
          <target state="translated">Sin embargo,como esto tiene una complejidad similar a la de la selección,el tiempo que toma es mucho menor debido a las velocidades de IO (calcetines en movimiento)y de búsqueda (buscando la línea de un calcetín).</target>
        </trans-unit>
        <trans-unit id="2e5ae82866972c6fb5d15e4d37146f8fd8f90802" translate="yes" xml:space="preserve">
          <source>Human beings will use various strategies to effect these. &lt;a href=&quot;http://garfield.library.upenn.edu/classics1979/A1979HX09600001.pdf&quot;&gt;Human memory &lt;em&gt;is&lt;/em&gt; associative&lt;/a&gt;, something like a hash table where feature sets of stored values are paired with the corresponding values themselves. For example, the concept of &quot;red car&quot; maps to all the red cars a person is capable of remembering. Someone with a perfect memory has a perfect mapping.  Most people are imperfect in this regard (and most others).  The associative map has a limited capacity. Mappings may &lt;em&gt;bleep&lt;/em&gt; out of existence under various circumstances (one beer too many), be recorded in error (&quot;I though her name was Betty, not Nettie&quot;), or never be overwritten even though we observe that the truth has changed (&quot;dad's car&quot; evokes &quot;orange Firebird&quot; when we actually knew he'd traded that in for the red Camaro).</source>
          <target state="translated">Los seres humanos usar&amp;aacute;n varias estrategias para lograr esto. &lt;a href=&quot;http://garfield.library.upenn.edu/classics1979/A1979HX09600001.pdf&quot;&gt;La memoria humana &lt;em&gt;es&lt;/em&gt; asociativa&lt;/a&gt; , algo as&amp;iacute; como una tabla hash donde los conjuntos de caracter&amp;iacute;sticas de valores almacenados se combinan con los valores correspondientes. Por ejemplo, el concepto de &quot;auto rojo&quot; se asigna a todos los autos rojos que una persona es capaz de recordar. Alguien con una memoria perfecta tiene un mapeo perfecto. La mayor&amp;iacute;a de las personas son imperfectas a este respecto (y la mayor&amp;iacute;a de los dem&amp;aacute;s). El mapa asociativo tiene una capacidad limitada. Las asignaciones pueden desaparecer en varias circunstancias (una cerveza es demasiada), grabarse por error (&quot;aunque su nombre era Betty, no Nettie&quot;) o nunca sobrescribirse aunque observemos que la verdad ha cambiado (&quot;pap&amp;aacute; el auto &quot;evoca&quot; Firebird naranja &quot;cuando realmente sab&amp;iacute;amos que lo hab&amp;iacute;a cambiado por el Camaro rojo).</target>
        </trans-unit>
        <trans-unit id="be87a28a5429a75a2d77e39569b97b2cef88f1c6" translate="yes" xml:space="preserve">
          <source>Humans can win over CPU algorithms using the fact that &quot;finding a matching pair&quot; can be one operation for a set that isn't too big.</source>
          <target state="translated">Los humanos pueden ganarse a los algoritmos de la CPU usando el hecho de que &quot;encontrar un par coincidente&quot; puede ser una operación para un conjunto que no sea demasiado grande.</target>
        </trans-unit>
        <trans-unit id="b1ed976246d93e04e79fea702823d280ba48c2ad" translate="yes" xml:space="preserve">
          <source>I came out with another solution which would not promise fewer operations, neither less time consumption, but it should be tried to see if it can be a good-enough heuristic to provide less time consumption in huge series of sock pairing.</source>
          <target state="translated">Se me ocurrió otra solución que no prometía menos operaciones,ni menos consumo de tiempo,pero que debería intentarse para ver si puede ser lo suficientemente heurística como para proporcionar menos consumo de tiempo en enormes series de emparejamiento de calcetines.</target>
        </trans-unit>
        <trans-unit id="b0d5c8c30ccdae2afc794d4c2db85857ecf68b61" translate="yes" xml:space="preserve">
          <source>I do that every morning and rarely need more than three draws - but I have &lt;code&gt;n&lt;/code&gt; similar pairs (around 10, give or take the lost ones) of &lt;code&gt;m&lt;/code&gt; shaped white socks. Now you can estimate the size of my stack of stocks :-)</source>
          <target state="translated">Hago eso todas las ma&amp;ntilde;anas y rara vez necesito m&amp;aacute;s de tres sorteos, pero tengo &lt;code&gt;n&lt;/code&gt; pares similares (alrededor de 10, m&amp;aacute;s o menos los perdidos) de medias blancas en forma de &lt;code&gt;m&lt;/code&gt; . Ahora puede estimar el tama&amp;ntilde;o de mi pila de acciones :-)</target>
        </trans-unit>
        <trans-unit id="b28189bbbd02c084d10ef3c4022c033ec385886f" translate="yes" xml:space="preserve">
          <source>I do this by:</source>
          <target state="translated">Hago esto por:</target>
        </trans-unit>
        <trans-unit id="f58214503dfea8f36b2d81a7d7e31591c0696f80" translate="yes" xml:space="preserve">
          <source>I found integrating the process of sorting into hanging to dry makes it a breeze. I need to pick up each sock anyway, and hang it (move) and it costs me about nothing to hang it in a specific place on the strings. Now just not to force search of the whole buffer (the strings) I choose to place socks by color/shade. Darker left, brighter right, more colorful front etc. Now before I hang each sock, I look in its &quot;right vicinity&quot; if a matching one is there already - this limits &quot;scan&quot; to 2-3 other socks - and if it is, I hang the other one right next to it. Then I roll them into pairs while removing from the strings, when dry.</source>
          <target state="translated">Encontré que integrar el proceso de clasificación en la colada para secar lo convierte en una brisa.Necesito recoger cada calcetín de todos modos,y colgarlo (moverlo)y no me cuesta nada colgarlo en un lugar específico de las cuerdas.Ahora bien,para no forzar la búsqueda de todo el buffer (las cuerdas)elijo colocar los calcetines por color.Izquierda más oscura,derecha más brillante,frente más colorido,etc.Ahora,antes de colgar cada calcetín,miro en su &quot;vecindad derecha&quot; si ya hay uno igual-esto limita el &quot;escaneo&quot; a otros 2-3 calcetines-y si lo hay,cuelgo el otro justo al lado.Luego los enrollo en pares mientras los quito de las cuerdas,cuando están secos.</target>
        </trans-unit>
        <trans-unit id="2af9d76529a0f3da9452d50f18323e0df517ebc3" translate="yes" xml:space="preserve">
          <source>I had derived this as a part of another puzzle,but I would be happy to be proven wrong. 
&lt;a href=&quot;https://appolo85.wordpress.com/2012/07/25/some-fun-with-hash-table-performance-analysis/&quot;&gt;Here's my blog article on the same&lt;/a&gt;</source>
          <target state="translated">Hab&amp;iacute;a derivado esto como parte de otro rompecabezas, pero estar&amp;iacute;a feliz de que me demuestren lo contrario. &lt;a href=&quot;https://appolo85.wordpress.com/2012/07/25/some-fun-with-hash-table-performance-analysis/&quot;&gt;Aqu&amp;iacute; est&amp;aacute; mi art&amp;iacute;culo de blog sobre el mismo&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d670bfbf52f40edfc5d3d99f6588d8b35cfcbaa" translate="yes" xml:space="preserve">
          <source>I have taken simple steps to reduce my effort into a process taking O(1) time.</source>
          <target state="translated">He tomado medidas simples para reducir mi esfuerzo en un proceso que toma O(1)tiempo.</target>
        </trans-unit>
        <trans-unit id="6f7a73657ec6fa088026a984672b83ade80856e7" translate="yes" xml:space="preserve">
          <source>I hope I can contribute something new to this problem. I noticed that all of the answers neglect the fact that there are two points where you can perform &lt;strong&gt;preprocessing&lt;/strong&gt;, without slowing down your overall laundry performance.</source>
          <target state="translated">Espero poder aportar algo nuevo a este problema. Not&amp;eacute; que todas las respuestas descuidan el hecho de que hay dos puntos en los que puede realizar el &lt;strong&gt;preprocesamiento&lt;/strong&gt; , sin ralentizar su rendimiento general de lavado.</target>
        </trans-unit>
        <trans-unit id="712bf975bcdafbec473428cad084553f88032e4b" translate="yes" xml:space="preserve">
          <source>I know that these algorithms take a lot of assumptions: a bin which acts as some sort of LIFO stack, a limited, normal washing machine, and a limited, normal clothesline - but this still works with very large numbers of socks.</source>
          <target state="translated">Sé que estos algoritmos toman muchas suposiciones:una papelera que actúa como una especie de pila LIFO,una lavadora limitada y normal,y un tendedero limitado y normal,pero esto todavía funciona con un gran número de calcetines.</target>
        </trans-unit>
        <trans-unit id="76250d1db233c115621eea33b2e23f2fa2575836" translate="yes" xml:space="preserve">
          <source>I should point out that in order to improve the speed of the remaining steps, it is wise not to randomly pick the next sock, but to sequentially take sock after sock from each cluster.
Both preprocessing steps don't take more time than just putting the socks on the line or in the basket, which we have to do no matter what, so this should greatly enhance the laundry performance.</source>
          <target state="translated">Debo señalar que para mejorar la velocidad de los pasos restantes,es prudente no elegir al azar el siguiente calcetín,sino tomar secuencialmente calcetín tras calcetín de cada grupo.Ambos pasos de preprocesamiento no llevan más tiempo que poner los calcetines en la línea o en la cesta,lo que tenemos que hacer sin importar qué,así que esto debería mejorar enormemente el rendimiento de la lavandería.</target>
        </trans-unit>
        <trans-unit id="059e704445c273ca6d35e7eca97772e45a2005db" translate="yes" xml:space="preserve">
          <source>I think that there should be an Omega(n&lt;sup&gt;2&lt;/sup&gt;) bound for the original problem if you allow equality tests only. My intuition is: Consider a graph where you add an edge after a test, and argue that if the graph is not dense the output is not uniquely determined.</source>
          <target state="translated">Creo que deber&amp;iacute;a haber un Omega (n &lt;sup&gt;2&lt;/sup&gt; ) vinculado al problema original si solo se permiten pruebas de igualdad. Mi intuici&amp;oacute;n es: considere un gr&amp;aacute;fico donde agrega un borde despu&amp;eacute;s de una prueba, y argumenta que si el gr&amp;aacute;fico no es denso, la salida no se determina de manera &amp;uacute;nica.</target>
        </trans-unit>
        <trans-unit id="efa09f0b1f8cd3ce6a3acb81e6f0774e3942dc69" translate="yes" xml:space="preserve">
          <source>I will appreciate an answer that addresses the following aspects:</source>
          <target state="translated">Apreciaré una respuesta que aborde los siguientes aspectos:</target>
        </trans-unit>
        <trans-unit id="b480ebea69ff0685142986485477474b5d752c12" translate="yes" xml:space="preserve">
          <source>I'm looking forward to hear about any experiences or corrections.</source>
          <target state="translated">Estoy deseando escuchar cualquier experiencia o correcciones.</target>
        </trans-unit>
        <trans-unit id="7e3fa720280a90386643c5f943bbc31f1027bcda" translate="yes" xml:space="preserve">
          <source>I've finished pairing my socks just right now, and I found that the best way to do it is the following:</source>
          <target state="translated">He terminado de emparejar mis calcetines ahora mismo,y he descubierto que la mejor manera de hacerlo es la siguiente:</target>
        </trans-unit>
        <trans-unit id="b298e00cd80e135c4ae40839f21a896eee2181a4" translate="yes" xml:space="preserve">
          <source>If &quot;index&quot; is greater then 2 (this could be value dependent on sock
 number because with greater number of socks there are less chance to
  pair them blindly) go to 11</source>
          <target state="translated">Si el &quot;índice&quot; es mayor que 2 (este valor podría depender del número de calcetines porque con un mayor número de calcetines hay menos posibilidades de emparejarlos a ciegas)ir a 11</target>
        </trans-unit>
        <trans-unit id="428e83ad437da92aef4bb4acff910ff3919184bd" translate="yes" xml:space="preserve">
          <source>If each sock had an integer called &quot;PairID&quot; one could easily distribute them into 10 buckets according to &lt;code&gt;PairID % 10&lt;/code&gt; (the last digit).</source>
          <target state="translated">Si cada calcet&amp;iacute;n tuviera un n&amp;uacute;mero entero llamado &quot;PairID&quot;, uno podr&amp;iacute;a distribuirlos f&amp;aacute;cilmente en 10 cubos de acuerdo con &lt;code&gt;PairID % 10&lt;/code&gt; (el &amp;uacute;ltimo d&amp;iacute;gito).</target>
        </trans-unit>
        <trans-unit id="68824b3b629564ab1d8b0bad06e1c81bc8489125" translate="yes" xml:space="preserve">
          <source>If match found pair it, pack pair and move it to the &quot;matched&quot; pile</source>
          <target state="translated">Si coinciden,empáquenlo y muévanlo a la pila de &quot;coincidencias&quot;.</target>
        </trans-unit>
        <trans-unit id="b8510e4192393a95bad638ba90d06ef53c82e071" translate="yes" xml:space="preserve">
          <source>If the &quot;move&quot; operation is fairly expensive, and the &quot;compare&quot; operation is cheap, and you need to move the whole set anyway, into a buffer where search is much faster than in original storage... just integrate sorting into the obligatory move.</source>
          <target state="translated">Si la operación de &quot;mover&quot; es bastante cara,y la operación de &quot;comparar&quot; es barata,y necesitas mover todo el conjunto de todas formas,a un buffer donde la búsqueda es mucho más rápida que en el almacenamiento original...sólo tienes que integrar la clasificación en el movimiento obligatorio.</target>
        </trans-unit>
        <trans-unit id="9b3e803c4a76f4c4bd7562f58a50ba5f385ebf8f" translate="yes" xml:space="preserve">
          <source>If the next one is the pair of the previous one, then put it to the existing bucket, otherwise create a new one.</source>
          <target state="translated">Si el siguiente es el par del anterior,entonces póngalo en el cubo existente,de lo contrario cree uno nuevo.</target>
        </trans-unit>
        <trans-unit id="4a8ea1dd91e78f2f6ed036a3127326ca0c1544c5" translate="yes" xml:space="preserve">
          <source>If there are less then 6 socks, go to 11.</source>
          <target state="translated">Si hay menos de 6 calcetines,pasa a 11.</target>
        </trans-unit>
        <trans-unit id="5101d1843bf2d194d47695b1f7bbc961cb8fc0b4" translate="yes" xml:space="preserve">
          <source>If there are still more then one socks go to 12</source>
          <target state="translated">Si todavía hay más de un calcetín,pasa a ser el 12.</target>
        </trans-unit>
        <trans-unit id="b79f9eb2311d2f31b42294fff21e572d50944666" translate="yes" xml:space="preserve">
          <source>If there is just one left go to 14</source>
          <target state="translated">Si sólo queda uno,ve al 14</target>
        </trans-unit>
        <trans-unit id="0580e1c44a88013044e269db8383aef639694455" translate="yes" xml:space="preserve">
          <source>If there is no match, put it on the &quot;missing&quot; pile.</source>
          <target state="translated">Si no hay coincidencia,ponlo en la pila de &quot;desaparecidos&quot;.</target>
        </trans-unit>
        <trans-unit id="a78596387c9d98455857ff9c74f61a0ca08821df" translate="yes" xml:space="preserve">
          <source>If there is no pair for the sock, move it to the &quot;missing&quot; pile</source>
          <target state="translated">Si no hay un par para el calcetín,muévalo a la pila &quot;que falta&quot;.</target>
        </trans-unit>
        <trans-unit id="c1faf9fe0339936f19f4a80510b7ee0dc13723d0" translate="yes" xml:space="preserve">
          <source>If we assume normal distribution, then the estimated number of 'insertions'  to have atleast one sock mapped to one bucket is NlogN  (ie, all buckets are full)</source>
          <target state="translated">Si asumimos una distribución normal,entonces el número estimado de &quot;inserciones&quot; para tener al menos un calcetín asignado a un cubo es NlogN (es decir,todos los cubos están llenos)</target>
        </trans-unit>
        <trans-unit id="7fee5c386c3eac901a5e47b38f613ae422e201ea" translate="yes" xml:space="preserve">
          <source>If you can pick a limited number of attributes, but enough attributes that can uniquely identify each pair, you should be done in O(k * n), which is O(n) if we can consider k is limited.</source>
          <target state="translated">Si se puede elegir un número limitado de atributos,pero suficientes atributos que puedan identificar de manera única cada par,se debe hacer en O(k*n),que es O(n)si podemos considerar que k es limitado.</target>
        </trans-unit>
        <trans-unit id="362a61837395e933805325f6b6ebe951c78dd045" translate="yes" xml:space="preserve">
          <source>If you chose a fancy pair with different left and right sock, doing a full bucket sort to left and right foot buckets take O(N+M), where N is the number of socks and M is same as above. Somebody else can give the formula for average iterations of finding the first pair, but worst case for finding a pair with blind search is N/2+1, which becomes astronomically unlikely case for reasonable N. This can be sped up by using advanced image recognition algorithms and heuristics, when scanning the pile of unsorted socks with &lt;a href=&quot;http://www.urbandictionary.com/define.php?term=Mk1%20eyeball&quot;&gt;Mk1 Eyeball&lt;/a&gt;.</source>
          <target state="translated">Si elige un par elegante con diferentes calcetines izquierdo y derecho, haciendo una clasificaci&amp;oacute;n completa de los cubos del pie izquierdo y derecho tome O (N + M), donde N es el n&amp;uacute;mero de calcetines y M es el mismo que el anterior. Alguien m&amp;aacute;s puede dar la f&amp;oacute;rmula para las iteraciones promedio de encontrar el primer par, pero el peor caso para encontrar un par con b&amp;uacute;squeda ciega es N / 2 + 1, lo que se convierte en un caso astron&amp;oacute;micamente improbable para un N. razonable Esto puede acelerarse mediante el uso de una imagen avanzada algoritmos de reconocimiento y heur&amp;iacute;stica, al escanear la pila de calcetines sin clasificar con &lt;a href=&quot;http://www.urbandictionary.com/define.php?term=Mk1%20eyeball&quot;&gt;Mk1 Eyeball&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14a24a331e031cc668435241346b7c07a641d7fb" translate="yes" xml:space="preserve">
          <source>If you do not, put the current sock into the first open slot in the array.</source>
          <target state="translated">Si no lo haces,pon el calcetín actual en la primera ranura abierta de la matriz.</target>
        </trans-unit>
        <trans-unit id="71950a186d51133a9e0950587efebd65ce355f77" translate="yes" xml:space="preserve">
          <source>If you find an acceptable match, put both socks together and remove them from the array.</source>
          <target state="translated">Si encuentras una coincidencia aceptable,pon ambos calcetines juntos y quítalos del conjunto.</target>
        </trans-unit>
        <trans-unit id="6f824c95564ff831ff4658d289a3cc3fbd50a604" translate="yes" xml:space="preserve">
          <source>If you have 1000 socks, with 8 colors and an average distribution, you can make 4 piles of each 125 socks in c*n time. With a threshold of 5 socks you can sort every pile in 6 runs. (Counting 2 seconds to throw a sock on the right pile it will take you little under 4 hours.)</source>
          <target state="translated">Si tienes 1000 calcetines,con 8 colores y una distribución media,puedes hacer 4 pilas de cada 125 calcetines en tiempo c*n.Con un umbral de 5 calcetines puedes clasificar cada pila en 6 series.(Contando 2 segundos para lanzar un calcetín en la pila derecha te llevará poco menos de 4 horas.)</target>
        </trans-unit>
        <trans-unit id="e6180d90736fe61c2fee7b217194e6e292349b2c" translate="yes" xml:space="preserve">
          <source>If you have just 60 socks, 3 colors and 2 sort of socks (yours / your wife's) you can sort every pile of 10 socks in 1 runs (Again threshold = 5). (Counting 2 seconds it will take you 2 min).</source>
          <target state="translated">Si tienes sólo 60 calcetines,3 colores y 2 tipos de calcetines (los tuyos son los de tu esposa)puedes ordenar cada pila de 10 calcetines en 1 tirada (De nuevo el umbral=5).(Contando 2 segundos te tomará 2 min).</target>
        </trans-unit>
        <trans-unit id="1642673d491acf03991115db1b99d02263fa0f61" translate="yes" xml:space="preserve">
          <source>If you have one or more selected unpaired socks, check your current sock against all the unpaired socks in the array.</source>
          <target state="translated">Si tiene uno o más calcetines seleccionados no emparejados,compruebe su calcetín actual con todos los calcetines no emparejados del conjunto.</target>
        </trans-unit>
        <trans-unit id="f56085360df34e1a4ad17c6698a237315bf8ce9d" translate="yes" xml:space="preserve">
          <source>In computer science this can be helpful:
We have a collection of n &lt;em&gt;things&lt;/em&gt;, an order on them (length) and also an equivalence relation (extra information, for example the color of socks). The equivalence relation allows us to make a partition of the original collection, and in every equivalence class our order is still maintained. The mapping of a &lt;em&gt;thing&lt;/em&gt; to it's equivalence class can be done in O(1), so only O(n) is needed to assign each item to a class. Now we have used our extra information and can proceed in any manner to sort every class. The advantage is that the data sets are already significantly smaller.</source>
          <target state="translated">En inform&amp;aacute;tica, esto puede ser &amp;uacute;til: tenemos una colecci&amp;oacute;n de n &lt;em&gt;cosas&lt;/em&gt; , un orden en ellas (longitud) y tambi&amp;eacute;n una relaci&amp;oacute;n de equivalencia (informaci&amp;oacute;n adicional, por ejemplo, el color de los calcetines). La relaci&amp;oacute;n de equivalencia nos permite hacer una partici&amp;oacute;n de la colecci&amp;oacute;n original, y en cada clase de equivalencia nuestro orden a&amp;uacute;n se mantiene. La asignaci&amp;oacute;n de una &lt;em&gt;cosa&lt;/em&gt; a su clase de equivalencia se puede hacer en O (1), por lo que solo se necesita O (n) para asignar cada elemento a una clase. Ahora hemos utilizado nuestra informaci&amp;oacute;n adicional y podemos proceder de cualquier manera para ordenar cada clase. La ventaja es que los conjuntos de datos ya son significativamente m&amp;aacute;s peque&amp;ntilde;os.</target>
        </trans-unit>
        <trans-unit id="95707802ab9dca781a74e6e8993e4a31c2c6a26e" translate="yes" xml:space="preserve">
          <source>In order to say how efficient it is to pair socks from a pile, we have to define the machine first, because the pairing isn't done whether by a turing nor by a random access machine, which are normally used as the basis for an algorithmic analysis.</source>
          <target state="translated">Para decir cuán eficiente es el emparejamiento de los calcetines de una pila,tenemos que definir primero la máquina,porque el emparejamiento no se realiza ni por una turing ni por una máquina de acceso aleatorio,que normalmente se utilizan como base para un análisis algorítmico.</target>
        </trans-unit>
        <trans-unit id="cb70cb2a381a9804b33c37786ed6892de88e1933" translate="yes" xml:space="preserve">
          <source>In the case of socks, perfect recall means looking at a sock &lt;code&gt;s&lt;/code&gt; always produces the memory of its sibling &lt;code&gt;t&lt;/code&gt;, including enough information (where it is on the ironing board) to locate &lt;code&gt;t&lt;/code&gt; in constant time.  A person with photographic memory accomplishes both 1 and 2 in constant time without fail.</source>
          <target state="translated">En el caso de los calcetines, el recuerdo perfecto significa que mirar un calcet&amp;iacute;n siempre produce la memoria de su hermano &lt;code&gt;t&lt;/code&gt; , incluida suficiente informaci&amp;oacute;n (d&amp;oacute;nde est&amp;aacute; en la tabla de planchar) para ubicar &lt;code&gt;t&lt;/code&gt; en tiempo constante. Una persona con memoria fotogr&amp;aacute;fica logra tanto 1 como 2 en tiempo constante sin falta.</target>
        </trans-unit>
        <trans-unit id="4d3725e32aaeb21f7a9e8878c8079a2ecffbc7fb" translate="yes" xml:space="preserve">
          <source>In the worst case it means that you will have n/2 different buckets, and you will have n-2 determinations about that which bucket contains the pair of the current sock. Obviously, this algorithm works well if you have just a few pairs; I did it with 12 pairs.</source>
          <target state="translated">En el peor de los casos significa que tendrás n2 cubos diferentes,y tendrás n-2 determinaciones acerca de qué cubo contiene el par del calcetín actual.Obviamente,este algoritmo funciona bien si tienes sólo unos pocos pares;yo lo hice con 12 pares.</target>
        </trans-unit>
        <trans-unit id="aa2dcdaf17722e129a20d19adefefc64c27ec3f1" translate="yes" xml:space="preserve">
          <source>Is it equivalent to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;element distinctness problem&lt;/a&gt;?</source>
          <target state="translated">&amp;iquest;Es equivalente al &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;problema de distinci&amp;oacute;n de elementos&lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="27a7682059354d7267300e1425434e6ec790e624" translate="yes" xml:space="preserve">
          <source>It is not so scientific, but it works well:)</source>
          <target state="translated">No es tan científico,pero funciona bien:)</target>
        </trans-unit>
        <trans-unit id="d923e9762ba91638d0414fad059bf2a39ed51197" translate="yes" xml:space="preserve">
          <source>It is possible to separate socks into general classes or types (white/black, ankle/crew, athletic/dress) when building your array, and &quot;drill-down&quot; to only compare like-for-like.</source>
          <target state="translated">Es posible separar los calcetines en clases o tipos generales (blanco-negro,anklecrew,athleticdress)cuando se construye su conjunto,y &quot;drill-down&quot; para comparar sólo los similares.</target>
        </trans-unit>
        <trans-unit id="84b3dca37c877454cf4abb0e807d969bb8f0399f" translate="yes" xml:space="preserve">
          <source>It obviously requires some extra work to check if there is the matching sock already hanging somewhere and it would render solution &lt;code&gt;O(n^2)&lt;/code&gt; with coefficient about &lt;code&gt;1/2&lt;/code&gt; for a computer. But in this case the &quot;human factor&quot; is actually an advantage -- I usually can very quickly (almost &lt;code&gt;O(1)&lt;/code&gt;) identify the matching sock if it was already hung (probably some imperceptible in-brain caching is involved) -- consider it a kind of limited &quot;oracle&quot; as in &lt;a href=&quot;http://en.wikipedia.org/wiki/Oracle_machine&quot;&gt;Oracle Machine&lt;/a&gt; ;-) We, the humans have these advantages over digital machines in some cases ;-)</source>
          <target state="translated">Obviamente, requiere un poco de trabajo adicional para verificar si el calcet&amp;iacute;n correspondiente ya est&amp;aacute; colgando en alg&amp;uacute;n lugar y representar&amp;iacute;a la soluci&amp;oacute;n &lt;code&gt;O(n^2)&lt;/code&gt; con un coeficiente de aproximadamente &lt;code&gt;1/2&lt;/code&gt; para una computadora. Pero en este caso, el &quot;factor humano&quot; es realmente una ventaja: por lo general, puedo identificar muy r&amp;aacute;pidamente (casi &lt;code&gt;O(1)&lt;/code&gt; ) el calcet&amp;iacute;n correspondiente si ya estaba colgado (probablemente est&amp;eacute; involucrado un almacenamiento en el cerebro imperceptible) - considere es una especie de &quot;or&amp;aacute;culo&quot; limitado como en &lt;a href=&quot;http://en.wikipedia.org/wiki/Oracle_machine&quot;&gt;Oracle Machine&lt;/a&gt; ;-) Nosotros, los humanos tenemos estas ventajas sobre las m&amp;aacute;quinas digitales en algunos casos ;-)</target>
        </trans-unit>
        <trans-unit id="39b5cd62e349d68c400a20da1e370efb8e1fc33f" translate="yes" xml:space="preserve">
          <source>It scales nearly indefinitely if &lt;strong&gt;each worker has its own set of piles&lt;/strong&gt;. Workers can then take big chunks of socks from the input basket (very little contention as they are doing it rarely) and they do not need to synchronise when distributing the socks at all (because they have thread-local piles). At the end, all workers need to union their pile-sets. I believe that can be done in O(log (worker count * piles per worker)) if the workers form an &lt;strong&gt;aggregation tree&lt;/strong&gt;.</source>
          <target state="translated">Se escala casi indefinidamente si &lt;strong&gt;cada trabajador tiene su propio conjunto de pilas&lt;/strong&gt; . Luego, los trabajadores pueden tomar grandes cantidades de calcetines de la cesta de entrada (muy poca discusi&amp;oacute;n, ya que rara vez lo hacen) y no necesitan sincronizar al distribuir los calcetines (porque tienen pilas de hilos locales). Al final, todos los trabajadores necesitan unir sus conjuntos de pilas. Creo que se puede hacer en O (log (cuenta de trabajadores * pilas por trabajador)) si los trabajadores forman un &lt;strong&gt;&amp;aacute;rbol de agregaci&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="150b46cd8303cca0bd34d1940b0ec0aedbf08053" translate="yes" xml:space="preserve">
          <source>It's better if there's no difference between left and right foot socks, but it's not critical. If socks are left-right symmetrical, finding a pair is O(1) operation, and sorting the socks is approximate O(M) operation, where M is the number of places in your house, which you have littered with socks, ideally some small constant number.</source>
          <target state="translated">Es mejor si no hay diferencia entre los calcetines del pie izquierdo y derecho,pero no es crítico.Si los calcetines son simétricos izquierda-derecha,encontrar un par es una operación O(1),y clasificar los calcetines es una operación aproximada O(M),donde M es el número de lugares en tu casa,que has llenado de calcetines,idealmente algún número pequeño constante.</target>
        </trans-unit>
        <trans-unit id="2f22939c37ecaebbcccfa9e1a61cd5e27c5cb274" translate="yes" xml:space="preserve">
          <source>It's often good to take a step back, and think a way around the problem.</source>
          <target state="translated">A menudo es bueno dar un paso atrás,y pensar en una forma de evitar el problema.</target>
        </trans-unit>
        <trans-unit id="150a08322f1488dee4632ea6718c405d63b39b1c" translate="yes" xml:space="preserve">
          <source>Iterate over each pile and &lt;strong&gt;distribute it by some other metric&lt;/strong&gt; (e.g. pattern) into the second set of piles</source>
          <target state="translated">Iterar sobre cada pila y &lt;strong&gt;distribuirla por alguna otra m&amp;eacute;trica&lt;/strong&gt; (por ejemplo, patr&amp;oacute;n) en el segundo conjunto de pilas</target>
        </trans-unit>
        <trans-unit id="5efd484584a49caf169c4dda344e416b18649fb1" translate="yes" xml:space="preserve">
          <source>Keep randomly picking socks from the stack and compare to your 5+1 socks for a match. As your stack grows, it will reduce your performance but raise your odds. Much faster.</source>
          <target state="translated">Sigue eligiendo calcetines al azar de la pila y compáralos con tus calcetines de 5+1 para un partido.A medida que tu pila crezca,reducirá tu rendimiento pero aumentará tus probabilidades.Mucho más rápido.</target>
        </trans-unit>
        <trans-unit id="1ca7ccdd0b7ccddb659ecda67d1ece6e151b36ca" translate="yes" xml:space="preserve">
          <source>Let 'N' correspond to an approximate upper-bound on the number of  number of unique colors/pattern of socks that you have.</source>
          <target state="translated">Deje que la 'N' corresponda a un límite superior aproximado en el número de número de patrón de color único de los calcetines que tiene.</target>
        </trans-unit>
        <trans-unit id="780bea650a8fdf34a596a74ddbd5fc938d04c33f" translate="yes" xml:space="preserve">
          <source>My algorithm:</source>
          <target state="translated">Mi algoritmo:</target>
        </trans-unit>
        <trans-unit id="74beaf9107fc04b7777303cee699390003158c90" translate="yes" xml:space="preserve">
          <source>My solution does not exactly correspond to your requirements, as it formally requires &lt;code&gt;O(n)&lt;/code&gt; &quot;extra&quot; space. However, considering my conditions it is very efficient in my practical application. Thus I think it should be interesting.</source>
          <target state="translated">Mi soluci&amp;oacute;n no se corresponde exactamente con sus requisitos, ya que formalmente requiere &lt;code&gt;O(n)&lt;/code&gt; espacio &quot;extra&quot;. Sin embargo, teniendo en cuenta mis condiciones, es muy eficiente en mi aplicaci&amp;oacute;n pr&amp;aacute;ctica. Por lo tanto, creo que deber&amp;iacute;a ser interesante.</target>
        </trans-unit>
        <trans-unit id="5975233f2cbc212e70e2408f533f6faa08e21eb5" translate="yes" xml:space="preserve">
          <source>Now look for a match (visual pattern matching - humans are good at that with a small stack) inside the five you drew, if you don't find one, then add that to your five.</source>
          <target state="translated">Ahora busca una coincidencia (coincidencia de patrón visual-los humanos son buenos para eso con una pequeña pila)dentro de los cinco que dibujaste,si no encuentras una,entonces añádela a tus cinco.</target>
        </trans-unit>
        <trans-unit id="a7486cfa8083fe6f612df25745068a14a1cac68b" translate="yes" xml:space="preserve">
          <source>Now the computer science in this problem is all about the steps</source>
          <target state="translated">Ahora la ciencia de la computación en este problema es todo acerca de los pasos</target>
        </trans-unit>
        <trans-unit id="870cccf30184352ba6b4960824e58b1bdd6d8989" translate="yes" xml:space="preserve">
          <source>Now the next question is simply whether you do your own laundry and your wife does hers. That is a problem likely in an &lt;strong&gt;entirely different domain of problems&lt;/strong&gt;. :)</source>
          <target state="translated">Ahora la siguiente pregunta es simplemente si usted lava su propia ropa y si su esposa lava la suya. Ese es un problema probable en un &lt;strong&gt;dominio de problemas completamente diferente&lt;/strong&gt; . :)</target>
        </trans-unit>
        <trans-unit id="e3d8d0fe5c35ea409447bff57847e6fc8b0f8f6d" translate="yes" xml:space="preserve">
          <source>Now this may not seem all that different from &quot;forming piles by color&quot; suggested by top answers but first, by not picking discrete piles but ranges, I have no problem classifying whether &quot;purple&quot; goes to &quot;red&quot; or &quot;blue&quot; pile; it just goes between. And then by integrating two operations (hang to dry and sort) the overhead of sorting while hanging is like 10% of what separate sorting would be.</source>
          <target state="translated">Ahora bien,esto puede no parecer muy diferente de &quot;formar montones por color&quot; sugerido por las respuestas superiores pero primero,al no escoger montones discretos sino rangos,no tengo problema en clasificar si el &quot;púrpura&quot; va a la pila &quot;roja&quot; o &quot;azul&quot;;sólo va entre.Y luego integrando dos operaciones (colgar para secar y clasificar)la sobrecarga de clasificar mientras se cuelga es como el 10% de lo que sería una clasificación separada.</target>
        </trans-unit>
        <trans-unit id="37e05d152e6390b47f7a7dde92949ba55f30e47c" translate="yes" xml:space="preserve">
          <source>Once you have a collision(a.k.a  : a match) simply remove that pair of socks. 
 Repeat the same experiment with the next batch of NlogN socks. 
The beauty of it is that you could be making NlogN parallel comparisons(collision-resolution) because of the way the human mind works.  :-)</source>
          <target state="translated">Una vez que tienes una colisión (a.k.a:un fósforo)simplemente quita ese par de calcetines.Repita el mismo experimento con el siguiente lote de calcetines NlogN.La belleza de esto es que podrías estar haciendo comparaciones paralelas de NlogN (resolución de colisiones)por la forma en que trabaja la mente humana.)</target>
        </trans-unit>
        <trans-unit id="11a98af1a6e5c195360f3f6c711227cc208dadd9" translate="yes" xml:space="preserve">
          <source>Operation 4 is necessary, because when spreading socks over the floor some socks may hide others. Here is the analysis of the algorithm:</source>
          <target state="translated">La operación 4 es necesaria,porque al extender los calcetines en el suelo algunos calcetines pueden esconder otros.Aquí está el análisis del algoritmo:</target>
        </trans-unit>
        <trans-unit id="af6924e29957fb8b52cc30183bb2138601d75b4d" translate="yes" xml:space="preserve">
          <source>Optionally to step one, you pick up two sock from that line instead of two, as the caching memory is large enough we can quickly identify if either sock matches the current one on the line you are observing. If you are fortunate enough to have three arms, you could possibly parse three socks at the same time given that the memory of the subject is large enough.</source>
          <target state="translated">Opcionalmente al primer paso,se cogen dos calcetines de esa línea en lugar de dos,ya que la memoria caché es lo suficientemente grande como para que podamos identificar rápidamente si alguno de los calcetines coincide con el actual en la línea que se está observando.Si tienes la suerte de tener tres brazos,podrías analizar tres calcetines al mismo tiempo ya que la memoria del sujeto es lo suficientemente grande.</target>
        </trans-unit>
        <trans-unit id="77783bef2624f9f540cadff73ba6528b5aae021a" translate="yes" xml:space="preserve">
          <source>Oracle Machine is Better ;-)</source>
          <target state="translated">Oracle Machine es mejor ;-)</target>
        </trans-unit>
        <trans-unit id="f28b38127d74eab7d9b41752145290a2fc0d5c89" translate="yes" xml:space="preserve">
          <source>Order the socks!</source>
          <target state="translated">¡Pide los calcetines!</target>
        </trans-unit>
        <trans-unit id="8c33de1b8688b9c866607960966f014e14b6a01b" translate="yes" xml:space="preserve">
          <source>Other than that, I cannot think of anything, but this method does seem to be pretty efficient in real life. :)</source>
          <target state="translated">Aparte de eso,no se me ocurre nada más,pero este método parece ser bastante eficiente en la vida real.:)</target>
        </trans-unit>
        <trans-unit id="02341ed9b2710f0b78051065b72a305737d20c68" translate="yes" xml:space="preserve">
          <source>Our two preprocessing stages are &quot;putting the socks on the clothesline&quot; and &quot;Taking the socks from the clothesline&quot;, which we have to do, in order to get socks which are not only clean but also dry. As with washing machines, clotheslines are finite, and I assume that we have the whole part of the line where we put our socks in sight.</source>
          <target state="translated">Nuestras dos etapas de preprocesamiento son &quot;poner los calcetines en el tendedero&quot; y &quot;sacar los calcetines del tendedero&quot;,que es lo que tenemos que hacer,para conseguir calcetines que no sólo estén limpios sino también secos.Como en las lavadoras,los tendederos son finitos,y asumo que tenemos toda la parte del tendedero donde ponemos los calcetines a la vista.</target>
        </trans-unit>
        <trans-unit id="dd7e7c37ececf846bbc91969c59fe7ec34aa06d6" translate="yes" xml:space="preserve">
          <source>Pair blindly all socks to its neighbor (do not pack it)</source>
          <target state="translated">Empareje ciegamente todos los calcetines a su vecino (no los empaquete)</target>
        </trans-unit>
        <trans-unit id="567d945bb762f9218b71f65d131b602db30011d2" translate="yes" xml:space="preserve">
          <source>Pick a sock</source>
          <target state="translated">Escoge un calcetín</target>
        </trans-unit>
        <trans-unit id="b3134987842b8171f3b2d20b9d928ea0449a744f" translate="yes" xml:space="preserve">
          <source>Pick any two of them to make a pair. Constant time.</source>
          <target state="translated">Escoge dos cualquiera de ellos para hacer un par.Tiempo constante.</target>
        </trans-unit>
        <trans-unit id="e6ad43d89c0be2bb101bd954d77aea3f0c680af6" translate="yes" xml:space="preserve">
          <source>Pick the first sock in line, search along the line until it finds the corresponding sock.</source>
          <target state="translated">Escoge el primer calcetín en la línea,busca a lo largo de la línea hasta que encuentre el calcetín correspondiente.</target>
        </trans-unit>
        <trans-unit id="f15a45dc12d70436ea09baf6beeb9021651aff15" translate="yes" xml:space="preserve">
          <source>Pick two socks, place corresponding X sock in X line, and Y sock in Y line at next available position.</source>
          <target state="translated">Escoge dos calcetines,coloca el correspondiente calcetín X en la línea X,y el calcetín Y en la línea Y en la siguiente posición disponible.</target>
        </trans-unit>
        <trans-unit id="a42c6c1b50b0cb070b7169e8cfd43b7e499c1252" translate="yes" xml:space="preserve">
          <source>Pick up a first sock and place it on a table. Now pick another sock; if it matches the first picked, place it on top of the first. If not, place it on the table a small distance from the first. Pick a third sock; if it matches either of the previous two, place it on top of them or else place it a small distance from the third. Repeat until you have picked up all the socks.</source>
          <target state="translated">Coge un primer calcetín y colócalo en una mesa.Ahora coge otro calcetín;si coincide con el primero,colócalo encima del primero.Si no,colócalo en la mesa a una pequeña distancia del primero.Coge un tercer calcetín;si coincide con cualquiera de los dos anteriores,colócalo encima de ellos o bien colócalo a una pequeña distancia del tercero.Repita hasta que haya recogido todos los calcetines.</target>
        </trans-unit>
        <trans-unit id="49d4ff963ae4bca3c41a677fe2b8a4851f0dc095" translate="yes" xml:space="preserve">
          <source>Pick up one from the stack of 2n-5.</source>
          <target state="translated">Recoge uno de la pila de 2n-5.</target>
        </trans-unit>
        <trans-unit id="38fc586cd4b8cb11aebfcde216a7bcd038fe8e83" translate="yes" xml:space="preserve">
          <source>Picking a distinctive sock (whatever catches my eye first in the pile).</source>
          <target state="translated">Escoger un calcetín distintivo (lo que me llame la atención primero en la pila).</target>
        </trans-unit>
        <trans-unit id="afb37a344e3ab2d134c35252ebd3afec24338844" translate="yes" xml:space="preserve">
          <source>Place the new sock near into the current pile, with a distance based on how different it is. If you find yourself putting the sock on top of another because it is identical, form the pair there, and remove them. This means that future comparisons take less effort to find the correct place.</source>
          <target state="translated">Coloca el nuevo calcetín cerca de la pila actual,con una distancia basada en lo diferente que es.Si te encuentras poniendo el calcetín encima de otro porque es idéntico,forma el par allí,y quítalos.Esto significa que las futuras comparaciones requieren menos esfuerzo para encontrar el lugar correcto.</target>
        </trans-unit>
        <trans-unit id="2f2ea3db77a1f1b6f771e24a207d47f22993a2ad" translate="yes" xml:space="preserve">
          <source>Problem solved. So, just get new socks, throw/donate your old ones away, and live happily ever after knowing you are saving money and time every day for the rest of your life.</source>
          <target state="translated">Problema resuelto.Así que,sólo consigue calcetines nuevos,tira los viejos y vive feliz para siempre sabiendo que estás ahorrando dinero y tiempo todos los días por el resto de tu vida.</target>
        </trans-unit>
        <trans-unit id="b052f937ed7ad2c7eefbe92ef78e1f1391ca53d4" translate="yes" xml:space="preserve">
          <source>Put into the corresponding finished line of socks.</source>
          <target state="translated">Poner en la correspondiente línea terminada de calcetines.</target>
        </trans-unit>
        <trans-unit id="e069c49edbed651dbec011e37b87b876f834afc4" translate="yes" xml:space="preserve">
          <source>Quickly make piles of easily distinguishable socks. (Say by color)</source>
          <target state="translated">Rápidamente haga pilas de calcetines fácilmente distinguibles.(Diga por el color)</target>
        </trans-unit>
        <trans-unit id="e8562ec8764aff77d8738bd6121e9835eeba9b2f" translate="yes" xml:space="preserve">
          <source>Quicksort every pile and use the length of the sock for comparison. As a human you can make a fairly quick decision which sock to use to partition that avoids worst case. (You can see multiple socks in parallel, use that to your advantage!)</source>
          <target state="translated">Clasifica cada pila y usa la longitud del calcetín para comparar.Como humano puedes tomar una decisión bastante rápida sobre qué calcetín usar para dividir,lo que evita el peor de los casos.(Puedes ver varios calcetines en paralelo,¡utiliza eso a tu favor!)</target>
        </trans-unit>
        <trans-unit id="b577412dc9473d426d2ff6741d11dea5ca17a977" translate="yes" xml:space="preserve">
          <source>Real world approach:</source>
          <target state="translated">Enfoque del mundo real:</target>
        </trans-unit>
        <trans-unit id="0bf66d17ab79cfe3be7fc141f104742b101b119a" translate="yes" xml:space="preserve">
          <source>Repeat from 1 until there are no socks on the floor.</source>
          <target state="translated">Repita desde la 1 hasta que no haya calcetines en el suelo.</target>
        </trans-unit>
        <trans-unit id="0081c3494d7d5f15ad3d0b6fd53ac547753f32ff" translate="yes" xml:space="preserve">
          <source>Repeat from 1. until there are no more most distinctive socks.</source>
          <target state="translated">Repita desde el 1.hasta que no haya más calcetines más distintivos.</target>
        </trans-unit>
        <trans-unit id="e491132f83030e4bf9e1aa6139496611dff2738e" translate="yes" xml:space="preserve">
          <source>Repeat from 2 until no pair can be made.</source>
          <target state="translated">Repita desde el 2 hasta que no se pueda hacer un par.</target>
        </trans-unit>
        <trans-unit id="f4ecdc41af265ed9bf91659fbd817baded2a6b44" translate="yes" xml:space="preserve">
          <source>Repeat with every sock.</source>
          <target state="translated">Repite con cada calcetín.</target>
        </trans-unit>
        <trans-unit id="2d3de6b4a64f840ca4b44c37b7e888adb2929c0e" translate="yes" xml:space="preserve">
          <source>Shuffle the rest</source>
          <target state="translated">Baraja el resto</target>
        </trans-unit>
        <trans-unit id="20968b695bdd0c1693e57dfce2b017887a96213f" translate="yes" xml:space="preserve">
          <source>Since all washing machines I know about are limited in size (regardless of how many socks you have to wash), and the actual randomizing occurs in the washing machine, no matter how many socks we have, we always have small subsets which contain almost no singletons.</source>
          <target state="translated">Como todas las lavadoras que conozco son de tamaño limitado (independientemente de cuántos calcetines tengas que lavar),y la verdadera aleatoriedad se produce en la lavadora,no importa cuántos calcetines tengamos,siempre tenemos pequeños subconjuntos que casi no contienen singletones.</target>
        </trans-unit>
        <trans-unit id="20318f6c81a8cfa249bb075ab83674739820d4cc" translate="yes" xml:space="preserve">
          <source>Since you are interested in connections to element distinctness problem: proving the Omega(n log n) bound for element distinctness is harder, because the output is binary yes/no. Here, the output has to be a matching and the number of possible outputs suffices to get a decent bound. However, there's a variant connected to element distinctness. Suppose you are given 2n socks and wonder if they can be uniquely paired. You can get a reduction from ED by sending (a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;) to (a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;, a&lt;sub&gt;n&lt;/sub&gt;). (Parenthetically, the proof of hardness of ED is very interesting, &lt;a href=&quot;http://www.cs.dartmouth.edu/~ac/Teach/CS85-Spring08/lecnotes.pdf&quot;&gt;via topology&lt;/a&gt;.)</source>
          <target state="translated">Dado que est&amp;aacute; interesado en las conexiones con el problema de la distinci&amp;oacute;n de elementos: probar el l&amp;iacute;mite Omega (n log n) para la distinci&amp;oacute;n de elementos es m&amp;aacute;s dif&amp;iacute;cil, porque la salida es binaria s&amp;iacute; / no. Aqu&amp;iacute;, la salida tiene que coincidir y la cantidad de salidas posibles es suficiente para obtener un l&amp;iacute;mite decente. Sin embargo, hay una variante relacionada con la distinci&amp;oacute;n de elementos. Supongamos que le dan 2n calcetines y se pregunta si pueden combinarse de manera &amp;uacute;nica. Puede obtener una reducci&amp;oacute;n de ED enviando (a &lt;sub&gt;1&lt;/sub&gt; , a &lt;sub&gt;2&lt;/sub&gt; , ..., a &lt;sub&gt;n&lt;/sub&gt; ) a (a &lt;sub&gt;1&lt;/sub&gt; , a &lt;sub&gt;1&lt;/sub&gt; , a &lt;sub&gt;2&lt;/sub&gt; , a &lt;sub&gt;2&lt;/sub&gt; , ..., a &lt;sub&gt;n&lt;/sub&gt; , a &lt;sub&gt;n&lt;/sub&gt; ). (Entre par&amp;eacute;ntesis, la prueba de dureza de la disfunci&amp;oacute;n er&amp;eacute;ctil es muy interesante, a &lt;a href=&quot;http://www.cs.dartmouth.edu/~ac/Teach/CS85-Spring08/lecnotes.pdf&quot;&gt;trav&amp;eacute;s de la topolog&amp;iacute;a&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b9194449f120d8f88fb9b2143ad9103b6ff573c9" translate="yes" xml:space="preserve">
          <source>Smile satisfied :)</source>
          <target state="translated">Sonríe satisfecho :)</target>
        </trans-unit>
        <trans-unit id="b4e8217ef1354bbb155dad8cbdc9f0568f1b9c6f" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;hashing&lt;/strong&gt; would be enough (and faster).</source>
          <target state="translated">Entonces el &lt;strong&gt;hashing&lt;/strong&gt; ser&amp;iacute;a suficiente (y m&amp;aacute;s r&amp;aacute;pido).</target>
        </trans-unit>
        <trans-unit id="efa0ae263e5ffda95375f84a7f6c55184e61109a" translate="yes" xml:space="preserve">
          <source>So depending on the previous analysis following operations should be used in descending order:</source>
          <target state="translated">Por lo tanto,dependiendo del análisis anterior,las siguientes operaciones deben utilizarse en orden descendente:</target>
        </trans-unit>
        <trans-unit id="c9e8e26a61696a80e259f278ce881a216a7ad149" translate="yes" xml:space="preserve">
          <source>So here is my suggestion:</source>
          <target state="translated">Así que aquí está mi sugerencia:</target>
        </trans-unit>
        <trans-unit id="a55e40b80a0b84833274723db643350fd89429ca" translate="yes" xml:space="preserve">
          <source>So pick up five of them at random, and memorize their shape or their length.</source>
          <target state="translated">Así que coge cinco de ellos al azar,y memoriza su forma o su longitud.</target>
        </trans-unit>
        <trans-unit id="d199d875189556fbbb7c28bbf7b2d5145327cb1f" translate="yes" xml:space="preserve">
          <source>So the &quot;best&quot; algorithm depends on the qualities of the wetware/hardware/software that is running it and our willingness to &quot;cheat&quot; by imposing a total order on pairs.  Certainly a &quot;best&quot; &lt;em&gt;meta&lt;/em&gt;-algorithm is to hire the worlds best sock-sorter: a person or machine that can aquire and quickly store a huge set N of sock attribute sets in a 1-1 associative memory with constant time lookup, insert, and delete. Both people and machines like this can be procured. If you have one, you can pair all the socks in O(N) time for N pairs, which is optimal. The total order tags allow you to use standard hashing to get the same result with either a human or hardware computer.</source>
          <target state="translated">Por lo tanto, el &quot;mejor&quot; algoritmo depende de las cualidades del software / hardware / software que lo ejecuta y nuestra voluntad de &quot;enga&amp;ntilde;ar&quot; imponiendo un orden total en pares. Ciertamente, un &quot;mejor&quot; &lt;em&gt;meta-&lt;/em&gt; algoritmo es contratar al mejor clasificador de calcetines del mundo: una persona o m&amp;aacute;quina que pueda adquirir y almacenar r&amp;aacute;pidamente un gran conjunto N de conjuntos de atributos de calcet&amp;iacute;n en una memoria asociativa 1-1 con b&amp;uacute;squeda constante de tiempo, insertar, y eliminar Se pueden adquirir tanto personas como m&amp;aacute;quinas como esta. Si tiene uno, puede emparejar todos los calcetines en tiempo O (N) para N pares, lo cual es &amp;oacute;ptimo. Las etiquetas de orden total le permiten usar el hashing est&amp;aacute;ndar para obtener el mismo resultado con una computadora humana o de hardware.</target>
        </trans-unit>
        <trans-unit id="2f4b0f3db658b3420736349f1a48e77a38793c53" translate="yes" xml:space="preserve">
          <source>So we have a total runtime complexity of &lt;strong&gt;&lt;code&gt;O(r*n^2 + w*(ln n + n))&lt;/code&gt;&lt;/strong&gt; where &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; are the factors for environmental read and environmental write operations respectively for a reasonable amount of socks. The cost of the logical and arithmetical operations are omitted, because we suppose that it takes a constant amount of logical and arithmetical operations to decide whether 2 socks belong to the same pair. This may not be feasible in every scenario.</source>
          <target state="translated">Por lo tanto, tenemos una complejidad total de tiempo de ejecuci&amp;oacute;n de &lt;strong&gt; &lt;code&gt;O(r*n^2 + w*(ln n + n))&lt;/code&gt; &lt;/strong&gt; donde &lt;code&gt;r&lt;/code&gt; y &lt;code&gt;w&lt;/code&gt; son los factores para las operaciones de lectura y escritura ambiental, respectivamente, para una cantidad razonable de calcetines. El costo de las operaciones l&amp;oacute;gicas y aritm&amp;eacute;ticas se omite, porque suponemos que se necesita una cantidad constante de operaciones l&amp;oacute;gicas y aritm&amp;eacute;ticas para decidir si 2 calcetines pertenecen al mismo par. Esto puede no ser factible en todos los escenarios.</target>
        </trans-unit>
        <trans-unit id="c0ea279bcf3555464998141486451f10c76c5ac8" translate="yes" xml:space="preserve">
          <source>So, an algorithm for achieving O(1) sock pairing efficiency (assuming symmetrical sock) is:</source>
          <target state="translated">Por lo tanto,un algoritmo para lograr la eficiencia de emparejamiento del calcetín O(1)(suponiendo que el calcetín sea simétrico)es:</target>
        </trans-unit>
        <trans-unit id="f20134ff73648500315de3e4a253b67d80cad96e" translate="yes" xml:space="preserve">
          <source>Socks, whether real ones or some analogous data structure, would be supplied in pairs.</source>
          <target state="translated">Los calcetines,ya sean reales o con alguna estructura de datos análoga,se suministrarían en pares.</target>
        </trans-unit>
        <trans-unit id="fb36d98db4ccebdf42bf060da6c7373f52f5a333" translate="yes" xml:space="preserve">
          <source>Some upfront effort is required to find desirable socks, and to purchase in sufficient quantity as to eliminate need for your existing socks. As I'd done this before my need for black socks, my effort was minimal, but mileage may vary.</source>
          <target state="translated">Se requiere algún esfuerzo inicial para encontrar calcetines deseables y comprar en cantidad suficiente como para eliminar la necesidad de los calcetines existentes.Como ya lo había hecho antes de necesitar calcetines negros,mi esfuerzo fue mínimo,pero el kilometraje puede variar.</target>
        </trans-unit>
        <trans-unit id="97926eed54a69097fde506b9ecf78b97bea5b72b" translate="yes" xml:space="preserve">
          <source>Someone with less than perfect memory might use a few commonsense equivalence classes based on features within his capability to track: size (papa, mama, baby), color (greenish, redish, etc.), pattern (argyle, plain, etc.), style (footie, knee-high, etc.).  So the ironing board would be divided into sections for the categories. This usually allows the category to be located in constant time by memory, but then a linear search through the category &quot;bucket&quot; is needed.</source>
          <target state="translated">Alguien con una memoria menos que perfecta podría usar unas cuantas clases de equivalencia de sentido común basadas en características dentro de su capacidad de rastreo:tamaño (papá,mamá,bebé),color (verdoso,rojizo,etc.),patrón (argyle,liso,etc.),estilo (pie,hasta la rodilla,etc.).Así que la tabla de planchar se dividiría en secciones para las categorías.Esto suele permitir que la categoría se ubique en tiempo constante por memoria,pero entonces se necesita una búsqueda lineal a través de la categoría &quot;cubo&quot;.</target>
        </trans-unit>
        <trans-unit id="0159712802a0c2f7cfff59d6211ba6f0c4445923" translate="yes" xml:space="preserve">
          <source>Someone with no memory or imagination at all (sorry) will just keep the socks in one pile and do a linear search of the whole pile.</source>
          <target state="translated">Alguien sin memoria o imaginación (lo siento)mantendrá los calcetines en una pila y hará una búsqueda lineal de toda la pila.</target>
        </trans-unit>
        <trans-unit id="b1831098d4a04bf674e6b5bfb3d588abdfb6668a" translate="yes" xml:space="preserve">
          <source>Sorting solutions have been proposed, but &lt;strong&gt;sorting is a little too much&lt;/strong&gt;: We don't need order; &lt;strong&gt;we just need equality groups&lt;/strong&gt;.</source>
          <target state="translated">Se han propuesto &lt;strong&gt;soluciones de clasificaci&amp;oacute;n&lt;/strong&gt; , pero la &lt;strong&gt;clasificaci&amp;oacute;n es demasiado&lt;/strong&gt; : no necesitamos orden; &lt;strong&gt;solo necesitamos grupos de igualdad&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2cf30b649babee1fb3e3f2f2040697d3899e96be" translate="yes" xml:space="preserve">
          <source>Sorting, of course improves efficiency, especially in real life where you can easily &quot;insert&quot; a sock between two other socks. In computing the same could be achieved by a tree, but that's extra space. And, of course, we're back at NlogN (or a bit more, if there are several socks that are the same by sorting criteria, but not from the same pair).</source>
          <target state="translated">La clasificación,por supuesto,mejora la eficiencia,especialmente en la vida real donde puedes &quot;insertar&quot; fácilmente un calcetín entre otros dos calcetines.En la computación lo mismo podría ser logrado por un árbol,pero eso es espacio extra.Y,por supuesto,volvemos a NlogN (o un poco más,si hay varios calcetines que son iguales según el criterio de clasificación,pero no del mismo par).</target>
        </trans-unit>
        <trans-unit id="71a641aab14b65becb2573bd1e7dc80cfa779bbc" translate="yes" xml:space="preserve">
          <source>Spread all socks in the pile over the floor.</source>
          <target state="translated">Extiende todos los calcetines de la pila sobre el suelo.</target>
        </trans-unit>
        <trans-unit id="1e59b3c211f85c725340aeaa57b22de5e88fedab" translate="yes" xml:space="preserve">
          <source>Starting a radix sort from that conceptual location by pulling socks from the pile based on similarity to that one.</source>
          <target state="translated">Empezar una clase de radix desde ese lugar conceptual sacando calcetines del montón basado en la similitud con ese.</target>
        </trans-unit>
        <trans-unit id="9a81a4144276291d35bd6b866aad617bdf191bf6" translate="yes" xml:space="preserve">
          <source>Stop sorting piles when they reached a threshold at which you are comfortable to find spot pairs and unpairable socks instantly</source>
          <target state="translated">Deje de clasificar las pilas cuando lleguen a un umbral en el que se sienta cómodo para encontrar pares de manchas y calcetines no reparables al instante</target>
        </trans-unit>
        <trans-unit id="c6852caa99233694cc2f8ce0670b34197c40d765" translate="yes" xml:space="preserve">
          <source>Such an upfront effort has been seen many times in very popular and effective code. Examples include #DEFINE'ing pi to several decimals (other examples exist, but that's the one that comes to mind right now).</source>
          <target state="translated">Tal esfuerzo inicial se ha visto muchas veces en un código muy popular y efectivo.Los ejemplos incluyen #Definiendo pi a varios decimales (existen otros ejemplos,pero ese es el que me viene a la mente ahora mismo).</target>
        </trans-unit>
        <trans-unit id="0a5991dd9a6ef1577adeb97b95fcc60199512116" translate="yes" xml:space="preserve">
          <source>Suppose that you &lt;em&gt;know&lt;/em&gt; that your 2n socks are arranged this way:</source>
          <target state="translated">Suponga que &lt;em&gt;sabe&lt;/em&gt; que sus 2n calcetines est&amp;aacute;n dispuestos de esta manera:</target>
        </trans-unit>
        <trans-unit id="83358afe13545467fbcbbf957121011db2230479" translate="yes" xml:space="preserve">
          <source>The actual number of socks is not that large, I don't believe my spouse and I have more than 30 pairs. (And it is fairly easy to distinguish between my socks and hers; can this be used as well?)</source>
          <target state="translated">El número real de calcetines no es tan grande,no creo que mi cónyuge y yo tengamos más de 30 pares.(Y es bastante fácil distinguir entre mis calcetines y los de ella;¿se puede usar esto también?)</target>
        </trans-unit>
        <trans-unit id="052fd9e524e5e7a091878b38f361a3a987397d74" translate="yes" xml:space="preserve">
          <source>The algorithm</source>
          <target state="translated">El algoritmo</target>
        </trans-unit>
        <trans-unit id="f78fa21d86b0d267520ebd8d82fbaae7a3fc5c19" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(ln n + n)&lt;/code&gt; environmental modifications (step 1 &lt;code&gt;O(ln n)&lt;/code&gt; plus picking every pair of sock from the floor)</source>
          <target state="translated">El algoritmo implica &lt;code&gt;O(ln n + n)&lt;/code&gt; modificaciones ambientales (paso 1 &lt;code&gt;O(ln n)&lt;/code&gt; m&amp;aacute;s recoger cada par de calcetines del piso)</target>
        </trans-unit>
        <trans-unit id="1df9e4e8ccdefcdc14130712da6877c276e11de8" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(n^2)&lt;/code&gt; environmental reads from step 2</source>
          <target state="translated">El algoritmo involucra &lt;code&gt;O(n^2)&lt;/code&gt; lecturas ambientales del paso 2</target>
        </trans-unit>
        <trans-unit id="dd6aa1a815e2490fabaf33e117c8ad11f5692691" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(n^2)&lt;/code&gt; logical and arithmetic operations for comparing a sock with another in step 2</source>
          <target state="translated">El algoritmo involucra &lt;code&gt;O(n^2)&lt;/code&gt; operaciones l&amp;oacute;gicas y aritm&amp;eacute;ticas para comparar un calcet&amp;iacute;n con otro en el paso 2</target>
        </trans-unit>
        <trans-unit id="bb51c91f5c283a2bdff31b863d5e5e5018eb57e0" translate="yes" xml:space="preserve">
          <source>The algorithm terminates with high probability. This is due to the fact that one is unable to find pairs of socks in step number 2.</source>
          <target state="translated">El algoritmo termina con una alta probabilidad.Esto se debe a que no se pueden encontrar pares de calcetines en el paso número 2.</target>
        </trans-unit>
        <trans-unit id="165efb7623d4620b9e2c0a44514704d6b6dff038" translate="yes" xml:space="preserve">
          <source>The analysis</source>
          <target state="translated">El análisis</target>
        </trans-unit>
        <trans-unit id="abc7bc26ec5efcc62f2a9dd13e54ca3af8f26906" translate="yes" xml:space="preserve">
          <source>The answers till now don't make good use of our human pattern recognition capabilities. The game of Set provides a clue of how to do this well: put all socks in a two-dimensional space so you can both recognize them well and easily reach them with your hands. This limits you to an area of about 120 * 80 cm or so. From there select the pairs you recognize and remove them. Put extra socks in the free space and repeat. If you wash for people with easily recognizable socks (small kids come to mind), you can do a radix sort by selecting those socks first. This algorithm works well only when the  number of single socks is low</source>
          <target state="translated">Las respuestas hasta ahora no aprovechan nuestra capacidad de reconocimiento de patrones humanos.El juego de Set proporciona una pista de cómo hacer esto bien:poner todos los calcetines en un espacio bidimensional para que los reconozcan bien y los alcancen fácilmente con las manos.Esto te limita a un área de unos 120*80 cm más o menos.Desde allí selecciona los pares que reconoces y quítatelos.Ponga los calcetines adicionales en el espacio libre y repita.Si lavas para personas con calcetines fácilmente reconocibles (me vienen a la mente los niños pequeños),puedes hacer una clasificación radix seleccionando esos calcetines primero.Este algoritmo funciona bien sólo cuando el número de calcetines individuales es bajo</target>
        </trans-unit>
        <trans-unit id="4d052e124ee3ca4cc28b28a0fe3ffd3b80cede47" translate="yes" xml:space="preserve">
          <source>The best real-world partitioning I can think of is creating a &lt;strong&gt;rectangle of piles&lt;/strong&gt;: one dimension is color, the other is the pattern. Why a rectangle? Because we need O(1) random-access to piles. (A 3D &lt;a href=&quot;http://en.wikipedia.org/wiki/Cuboid&quot;&gt;cuboid&lt;/a&gt; would also work, but that is not very practical.)</source>
          <target state="translated">La mejor partici&amp;oacute;n del mundo real que se me ocurre es crear un &lt;strong&gt;rect&amp;aacute;ngulo de pilas&lt;/strong&gt; : una dimensi&amp;oacute;n es el color, la otra es el patr&amp;oacute;n. &amp;iquest;Por qu&amp;eacute; un rect&amp;aacute;ngulo? Porque necesitamos O (1) acceso aleatorio a las pilas. (Un &lt;a href=&quot;http://en.wikipedia.org/wiki/Cuboid&quot;&gt;cuboide&lt;/a&gt; 3D tambi&amp;eacute;n funcionar&amp;iacute;a, pero eso no es muy pr&amp;aacute;ctico).</target>
        </trans-unit>
        <trans-unit id="4b89a467fe48adcd9cc2eef3b60f3e2f90973c34" translate="yes" xml:space="preserve">
          <source>The initial bucket sorting will speed up your process, because it divides your n socks into k buckets in &lt;code&gt;c*n&lt;/code&gt; time so than you will only have to do &lt;code&gt;c*n*log(k)&lt;/code&gt; work. (Not taking into account the threshold). So all in all you do about &lt;code&gt;n*c*(1 + log(k))&lt;/code&gt; work, where c is the time to throw a sock on a pile.</source>
          <target state="translated">La clasificaci&amp;oacute;n inicial del dep&amp;oacute;sito acelerar&amp;aacute; su proceso, ya que divide sus n calcetines en k dep&amp;oacute;sitos en &lt;code&gt;c*n&lt;/code&gt; tiempo, de modo que solo tendr&amp;aacute; que hacer el trabajo &lt;code&gt;c*n*log(k)&lt;/code&gt; . (Sin tener en cuenta el umbral). Entonces, en general, lo que haces sobre el trabajo &lt;code&gt;n*c*(1 + log(k))&lt;/code&gt; , donde c es el momento de tirar un calcet&amp;iacute;n sobre una pila.</target>
        </trans-unit>
        <trans-unit id="3ab65ee84b4d8d43507a4f1bd4d7cc40b05e68c1" translate="yes" xml:space="preserve">
          <source>The machine</source>
          <target state="translated">La máquina</target>
        </trans-unit>
        <trans-unit id="7bb444117bc016eadc9752d11b231edb03e673d8" translate="yes" xml:space="preserve">
          <source>The machine is an abstraction of a the real world element called human being. It is able to read from the environment via a pair of eyes. And our machine model is able to manipulate the environment by using 2 arms. Logical and arithmetic operations are calculated using our brain (hopefully ;-)).</source>
          <target state="translated">La máquina es una abstracción de un elemento del mundo real llamado ser humano.Es capaz de leer el entorno a través de un par de ojos.Y nuestro modelo de máquina es capaz de manipular el entorno usando dos brazos.Las operaciones lógicas y aritméticas se calculan usando nuestro cerebro (esperemos ;-)).</target>
        </trans-unit>
        <trans-unit id="7ecbe36be8e73003b52a651bfa1b97b3b6cb4fd9" translate="yes" xml:space="preserve">
          <source>The method can also be nested, if we have multiple equivalence relations -&amp;gt; make colour piles, than within every pile partition on texture, than sort on length. Any equivalence relation that creates a partition with more than 2 elements that have about even size will bring a speed improvement over sorting (provided we can directly assign a sock to its pile), and the sorting can happen very quickly on smaller data sets.</source>
          <target state="translated">El m&amp;eacute;todo tambi&amp;eacute;n se puede anidar, si tenemos m&amp;uacute;ltiples relaciones de equivalencia -&amp;gt; hacer pilas de colores, que dentro de cada partici&amp;oacute;n de pila en la textura, que ordenar por longitud. Cualquier relaci&amp;oacute;n de equivalencia que cree una partici&amp;oacute;n con m&amp;aacute;s de 2 elementos que tengan un tama&amp;ntilde;o aproximado traer&amp;aacute; una mejora de velocidad sobre la clasificaci&amp;oacute;n (siempre que podamos asignar directamente un calcet&amp;iacute;n a su pila), y la clasificaci&amp;oacute;n puede ocurrir muy r&amp;aacute;pidamente en conjuntos de datos m&amp;aacute;s peque&amp;ntilde;os.</target>
        </trans-unit>
        <trans-unit id="0a27a2fa6c14acbfbc60946013388db1b86f6b79" translate="yes" xml:space="preserve">
          <source>The problem of sorting &lt;strong&gt;your n pairs of socks is O(n)&lt;/strong&gt;. Before you throw them in the laundry &lt;strong&gt;basket&lt;/strong&gt;, you thread the left one to the right one. On taking them out, you cut the thread and put each pair into your drawer - 2 operations on n pairs, so O(n).</source>
          <target state="translated">El problema de ordenar &lt;strong&gt;tus n pares de calcetines es O (n)&lt;/strong&gt; . Antes de tirarlos al &lt;strong&gt;cesto de&lt;/strong&gt; la ropa, enhebra el izquierdo al derecho. Al sacarlos, cortas el hilo y pones cada par en tu caj&amp;oacute;n - 2 operaciones en n pares, entonces O (n).</target>
        </trans-unit>
        <trans-unit id="c5d0caed9ed396ae40259a6681e3e2c91a16dfd9" translate="yes" xml:space="preserve">
          <source>The simplest answer is prior to allowing the pair to be separated, a single data structure for the pair should have been initialized that contained a pointer to the left and right sock, thus enabling socks to be referred to directly or via their pair. A sock may also be extended to contain a pointer to its partner.</source>
          <target state="translated">La respuesta más sencilla es que antes de permitir la separación de la pareja,se debería haber inicializado una estructura de datos única para la pareja que contuviera un puntero a la izquierda y a la derecha del calcetín,lo que permitiría referirse a los calcetines directamente o a través de su pareja.Un calcetín también puede extenderse para contener un puntero a su pareja.</target>
        </trans-unit>
        <trans-unit id="1015cb01e1edc8548eb94937e6c0a8fd4cae64a4" translate="yes" xml:space="preserve">
          <source>The simplest parallelization strategy is to have multiple workers take from the input basket and put the socks onto the piles. This only scales up so much - imagine 100 people fighting over 10 piles. &lt;strong&gt;The synchronization costs&lt;/strong&gt; (manifesting themselves as hand-collisions and human communication) &lt;strong&gt;destroy efficiency and speed-up&lt;/strong&gt; (see the &lt;a href=&quot;http://www.perfdynamics.com/Manifesto/USLscalability.html&quot;&gt;Universal Scalability Law&lt;/a&gt;!). Is this prone to &lt;strong&gt;deadlocks&lt;/strong&gt;? No, because each worker only needs to access one pile at a time. With just one &quot;lock&quot; there cannot be a deadlock. &lt;strong&gt;Livelocks&lt;/strong&gt; might be possible depending on how the humans coordinate access to piles. They might just use &lt;a href=&quot;http://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;random backoff&lt;/a&gt; like network cards do that on a physical level to determine what card can exclusively access the network wire. If it works for &lt;a href=&quot;http://en.wikipedia.org/wiki/Network_interface_controller&quot;&gt;NICs&lt;/a&gt;, it should work for humans as well.</source>
          <target state="translated">La estrategia de paralelizaci&amp;oacute;n m&amp;aacute;s simple es hacer que varios trabajadores tomen de la cesta de entrada y coloquen los calcetines en las pilas. Esto solo aumenta mucho: imagina a 100 personas peleando por 10 montones. &lt;strong&gt;Los costos de sincronizaci&amp;oacute;n&lt;/strong&gt; (que se manifiestan como colisiones manuales y comunicaci&amp;oacute;n humana) &lt;strong&gt;destruyen la eficiencia y la velocidad&lt;/strong&gt; (&amp;iexcl;vea la &lt;a href=&quot;http://www.perfdynamics.com/Manifesto/USLscalability.html&quot;&gt;Ley de escalabilidad universal&lt;/a&gt; !). &amp;iquest;Es propenso a &lt;strong&gt;puntos muertos&lt;/strong&gt; ? No, porque cada trabajador solo necesita acceder a un mont&amp;oacute;n a la vez. Con solo un &quot;bloqueo&quot; no puede haber un punto muerto. &lt;strong&gt;Livelocks&lt;/strong&gt; podr&amp;iacute;a ser posible dependiendo de c&amp;oacute;mo los humanos coordinen el acceso a las pilas. Es posible que solo utilicen &lt;a href=&quot;http://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;un retroceso aleatorio&lt;/a&gt; como las tarjetas de red lo hacen a nivel f&amp;iacute;sico para determinar qu&amp;eacute; tarjeta puede acceder exclusivamente al cable de red. Si funciona para las &lt;a href=&quot;http://en.wikipedia.org/wiki/Network_interface_controller&quot;&gt;NIC&lt;/a&gt; , tambi&amp;eacute;n deber&amp;iacute;a funcionar para los humanos.</target>
        </trans-unit>
        <trans-unit id="d2f49bc795ae24363a2c7470a93203b0fced4c88" translate="yes" xml:space="preserve">
          <source>The special condition in my case is that I don't use drying machine, just hang my cloths on an ordinary cloth dryer. Hanging cloths requires &lt;code&gt;O(n)&lt;/code&gt; operations (by the way, I always consider &lt;a href=&quot;http://en.wikipedia.org/wiki/Bin_packing_problem]&quot;&gt;bin packing&lt;/a&gt; problem here) and the problem by its nature requires the linear &quot;extra&quot; space. When I take a new sock from the bucket I to try hang it next to its pair if the pair is already hung. If its a sock from a new pair I leave some space next to it.</source>
          <target state="translated">La condici&amp;oacute;n especial en mi caso es que no uso secadora, solo cuelgo mis pa&amp;ntilde;os en una secadora de ropa com&amp;uacute;n. Colgar telas requiere operaciones &lt;code&gt;O(n)&lt;/code&gt; (por cierto, siempre considero un problema de &lt;a href=&quot;http://en.wikipedia.org/wiki/Bin_packing_problem]&quot;&gt;empaquetado del contenedor&lt;/a&gt; aqu&amp;iacute;) y el problema por su naturaleza requiere el espacio lineal &quot;extra&quot;. Cuando saco un calcet&amp;iacute;n nuevo del cubo, trato de colgarlo junto a su par si el par ya est&amp;aacute; colgado. Si es un calcet&amp;iacute;n de un nuevo par, dejo un espacio al lado.</target>
        </trans-unit>
        <trans-unit id="ce6af0db2fdccac900c8209f502eec96611a6b58" translate="yes" xml:space="preserve">
          <source>The theoretical limit is O(n) because you need to touch each sock (unless some are already paired somehow).</source>
          <target state="translated">El límite teórico es O(n)porque hay que tocar cada calcetín (a menos que algunos ya estén emparejados de alguna manera).</target>
        </trans-unit>
        <trans-unit id="2103f930ed2f94482faf224a41b4b0491a977035" translate="yes" xml:space="preserve">
          <source>The worst-case scenario of this scheme is that every pair of socks is different enough that it must be matched exactly, and that the first &lt;em&gt;n/2&lt;/em&gt; socks you pick are all different. This is your &lt;em&gt;O&lt;/em&gt;(n&lt;sup&gt;2&lt;/sup&gt;) scenario, and it's &lt;em&gt;extremely&lt;/em&gt; unlikely. If the number of unique types of sock &lt;em&gt;t&lt;/em&gt; is less than the number of pairs &lt;em&gt;p = n/2&lt;/em&gt;, and the socks in each type are alike enough (usually in wear-related terms) that any sock of that type can be paired with any other, then as I inferred above, the maximum number of socks you will ever have to compare to is &lt;em&gt;t&lt;/em&gt;, after which the next one you pull &lt;em&gt;will&lt;/em&gt; match one of the unpaired socks. This scenario is much more likely in the average sock drawer than the worst-case, and reduces the worst-case complexity to &lt;em&gt;O&lt;/em&gt;(n*t) where usually &lt;em&gt;t &amp;lt;&amp;lt; n&lt;/em&gt;.</source>
          <target state="translated">El peor de los casos de este esquema es que cada par de calcetines es lo suficientemente diferente como para que coincidan exactamente, y que los primeros &lt;em&gt;n / 2&lt;/em&gt; calcetines que elija sean todos diferentes. Este es su escenario &lt;em&gt;O&lt;/em&gt; (n &lt;sup&gt;2&lt;/sup&gt; ), y es &lt;em&gt;extremadamente&lt;/em&gt; improbable. Si el n&amp;uacute;mero de tipos &amp;uacute;nicos de calcet&amp;iacute;n &lt;em&gt;t&lt;/em&gt; es menor que el n&amp;uacute;mero de pares &lt;em&gt;p = n / 2&lt;/em&gt; , y los calcetines en cada tipo son lo suficientemente parecidos (generalmente en t&amp;eacute;rminos relacionados con el desgaste) que cualquier calcet&amp;iacute;n de ese tipo se puede combinar con cualquier otro, entonces, como deduje anteriormente, el n&amp;uacute;mero m&amp;aacute;ximo de calcetines con los que tendr&amp;aacute; que comparar es &lt;em&gt;t&lt;/em&gt; , despu&amp;eacute;s de lo cual el siguiente que tire coincidir&amp;aacute; con uno de los calcetines no apareados. Este escenario es mucho m&amp;aacute;s probable en el caj&amp;oacute;n de calcetines promedio que en el peor de los casos, y reduce la complejidad del peor de los casos a &lt;em&gt;O&lt;/em&gt; (n * t) donde generalmente &lt;em&gt;t &amp;lt;&amp;lt; n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="96b12eabde3d73be5eafb1e84e13a730dc8628d1" translate="yes" xml:space="preserve">
          <source>Then all you do is snap your socks together right after you take them off and put them in your washing basket, and again you've removed the problem of needing to pair your socks with a physical abstraction of the 'pair' concept.</source>
          <target state="translated">Entonces todo lo que haces es juntar los calcetines justo después de que te los quites y los pongas en la cesta de la ropa,y de nuevo has eliminado el problema de la necesidad de emparejar los calcetines con una abstracción física del concepto de &quot;emparejamiento&quot;.</target>
        </trans-unit>
        <trans-unit id="dced202b38f2d14c3908f94ad0c3a8bd7e6f6c93" translate="yes" xml:space="preserve">
          <source>There are two physical possibilities:</source>
          <target state="translated">Hay dos posibilidades físicas:</target>
        </trans-unit>
        <trans-unit id="4e4e9e2d368abd05573c65b163fd925efb9322d4" translate="yes" xml:space="preserve">
          <source>This also means that you will almost certainly never have all your socks in the array, because socks will get removed as they're matched.</source>
          <target state="translated">Esto también significa que casi seguro que nunca tendrás todos tus calcetines en el conjunto,porque los calcetines se quitarán a medida que se emparejen.</target>
        </trans-unit>
        <trans-unit id="bdfecabe5ec0a698991109d39b1c3465373ad88d" translate="yes" xml:space="preserve">
          <source>This approach will be favourable compared to any &lt;code&gt;c*x*n + O(1)&lt;/code&gt; method roughly as long as &lt;code&gt;log(k) &amp;lt; x - 1&lt;/code&gt;.</source>
          <target state="translated">Este enfoque ser&amp;aacute; favorable en comparaci&amp;oacute;n con cualquier m&amp;eacute;todo &lt;code&gt;c*x*n + O(1)&lt;/code&gt; aproximadamente siempre que &lt;code&gt;log(k) &amp;lt; x - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d1f77ce46b573dd375b9b3f8133c6c3e6975fa2" translate="yes" xml:space="preserve">
          <source>This is asking the wrong question. The right question to ask is, why am I spending time sorting socks? How much does it cost on yearly basis, when you value your free time for X monetary units of your choice?</source>
          <target state="translated">Esto es hacer la pregunta equivocada.La pregunta correcta es,¿por qué paso el tiempo clasificando calcetines? ¿Cuánto cuesta anualmente,cuando valoras tu tiempo libre por X unidades monetarias de tu elección?</target>
        </trans-unit>
        <trans-unit id="c7adcd7ce06b47130e35aa217e78946ac1fdb2c3" translate="yes" xml:space="preserve">
          <source>This is how I actually do it, for &lt;em&gt;p&lt;/em&gt; pairs of socks (&lt;em&gt;n = 2p&lt;/em&gt; individual socks):</source>
          <target state="translated">As&amp;iacute; es como lo hago realmente, para &lt;em&gt;p&lt;/em&gt; pares de medias ( &lt;em&gt;n = 2p&lt;/em&gt; medias individuales):</target>
        </trans-unit>
        <trans-unit id="235c85c59d6f0d9269c7c93b100ce67634688f1b" translate="yes" xml:space="preserve">
          <source>This kind of recursive hash partitioning is actually being done by &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt; when it needs to hash join or hash aggregate over huge data sets. It distributes its build input stream into many partitions which are independent. This scheme scales to arbitrary amounts of data and multiple CPUs linearly.</source>
          <target state="translated">Este tipo de particionamiento hash recursivo lo est&amp;aacute; haciendo realmente &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt; cuando necesita unir hash o agregar hash en grandes conjuntos de datos. Distribuye su flujo de entrada de compilaci&amp;oacute;n en muchas particiones que son independientes. Este esquema se escala a cantidades arbitrarias de datos y m&amp;uacute;ltiples CPU linealmente.</target>
        </trans-unit>
        <trans-unit id="71188b927e375c9f840b0228303d1ad03320f9ac" translate="yes" xml:space="preserve">
          <source>This question is actually deeply philosophical. At heart it's about whether the power of people to solve problems (the &quot;wetware&quot; of our brains) is equivalent to what can be accomplished by algorithms.</source>
          <target state="translated">Esta pregunta es en realidad profundamente filosófica.En el fondo se trata de si el poder de las personas para resolver problemas (el &quot;wetware&quot; de nuestros cerebros)es equivalente a lo que se puede lograr con los algoritmos.</target>
        </trans-unit>
        <trans-unit id="6137f79697d8c825e0bce0519a78dca5b385553f" translate="yes" xml:space="preserve">
          <source>This solves any computational pairing problem by removing it with a layer of abstraction.</source>
          <target state="translated">Esto resuelve cualquier problema de emparejamiento computacional eliminándolo con una capa de abstracción.</target>
        </trans-unit>
        <trans-unit id="832509383b3fc443a9e0c7a64e684a8be877a579" translate="yes" xml:space="preserve">
          <source>This takes advantage of the human ability to fuzzy-match in O(1) time, which is somewhat equivalent to the establishment of a hash-map on a computing device.</source>
          <target state="translated">Esto aprovecha la capacidad humana de hacer coincidir de forma difusa en tiempo de O(1),lo que equivale en cierto modo al establecimiento de un mapa de hachís en un dispositivo de computación.</target>
        </trans-unit>
        <trans-unit id="bb9e4357cf8c4cf1055b16dd15145dc9529ca43b" translate="yes" xml:space="preserve">
          <source>Thus connecting the problem of pairing socks with the problem of hanging cloths I get &lt;code&gt;O(n)&lt;/code&gt; &quot;extra space&quot; for free, and have a solution that is about &lt;code&gt;O(n)&lt;/code&gt; in time, requires just a little more work than simple hanging cloths and allows to immediately access complete pair of socks even in a very bad Monday morning... ;-)</source>
          <target state="translated">Por lo tanto, al conectar el problema de emparejar calcetines con el problema de colgar pa&amp;ntilde;os, obtengo &lt;code&gt;O(n)&lt;/code&gt; &quot;espacio adicional&quot; de forma gratuita, y tengo una soluci&amp;oacute;n que es aproximadamente &lt;code&gt;O(n)&lt;/code&gt; a tiempo, requiere un poco m&amp;aacute;s de trabajo que simples pa&amp;ntilde;os colgantes y permite acceder de inmediato a un par completo de calcetines incluso en un lunes muy malo ... ;-)</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="cc9192722da415eb15991bb6f24cb75e9e00289e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;. This is only linear time since comparison is not required.</source>
          <target state="translated">Usa la &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;clasificaci&amp;oacute;n por radix&lt;/a&gt; . Esto es solo tiempo lineal ya que no se requiere comparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="72e4524e8782dab66f9edff21207d55131fced9d" translate="yes" xml:space="preserve">
          <source>We also have to consider the intrinsic runtime of the atomic operations that can be carried out with these instruments. Due to physical constraints, operations which are carried out by an arm or eye have non constant time complexity. This is because we can't move an endlessly large pile of socks with an arm nor can an eye see the top sock on an endlessly large pile of socks.</source>
          <target state="translated">También tenemos que considerar el tiempo de ejecución intrínseco de las operaciones atómicas que se pueden llevar a cabo con estos instrumentos.Debido a las limitaciones físicas,las operaciones que se realizan con un brazo o un ojo no tienen una complejidad temporal constante.Esto se debe a que no podemos mover una pila infinitamente grande de calcetines con un brazo ni un ojo puede ver el calcetín de arriba en una pila infinitamente grande de calcetines.</target>
        </trans-unit>
        <trans-unit id="fc41cda5f1c62ac5f64fac7531ea11668364e843" translate="yes" xml:space="preserve">
          <source>We can also make use of the fact that people only have a very limited amount of socks. So an environmental modification can involve all socks in the pile.</source>
          <target state="translated">También podemos aprovechar el hecho de que la gente sólo tiene una cantidad muy limitada de calcetines.Así que una modificación ambiental puede involucrar a todos los calcetines de la pila.</target>
        </trans-unit>
        <trans-unit id="7f928a1fe0e4e26c3f5eb42941dbb73bf04c00c1" translate="yes" xml:space="preserve">
          <source>We have to do comparison to check whether two socks come in pair. Pick one of the &lt;code&gt;O(n log n)&lt;/code&gt; comparison-based sorting algorithms.</source>
          <target state="translated">Tenemos que hacer una comparaci&amp;oacute;n para verificar si dos calcetines vienen en pares. Elija uno de los algoritmos de clasificaci&amp;oacute;n basados ​​en la comparaci&amp;oacute;n &lt;code&gt;O(n log n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aff2e93d02cec92464795e91655b9cf0e01a5bf" translate="yes" xml:space="preserve">
          <source>What I do is that I pick up the first sock and put it down (say, on the edge of the laundry bowl). Then I pick up another sock and check to see if it's the same as the first sock. If it is, I remove them both. If it's not, I put it down next to the first sock. Then I pick up the third sock and compare that to the first two (if they're still there). Etc.</source>
          <target state="translated">Lo que hago es que cojo el primer calcetín y lo pongo en el borde de la lavandería.Luego cojo otro calcetín y compruebo si es el mismo que el primero.Si lo es,me quito los dos.Si no lo es,lo pongo al lado del primer calcetín.Luego tomo el tercer calcetín y lo comparo con los dos primeros (si todavía están ahí).Etc.</target>
        </trans-unit>
        <trans-unit id="52fb31e5804c85af0c9ab1080840c1c1106a6ac7" translate="yes" xml:space="preserve">
          <source>What about &lt;strong&gt;parallelism&lt;/strong&gt;? Can multiple humans match the socks faster?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa con el &lt;strong&gt;paralelismo&lt;/strong&gt; ? &amp;iquest;Pueden varios humanos igualar los calcetines m&amp;aacute;s r&amp;aacute;pido?</target>
        </trans-unit>
        <trans-unit id="62ee3893b3dd45b1448958e4035d217abb5319ed" translate="yes" xml:space="preserve">
          <source>What about the &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;element distinctness problem&lt;/a&gt;? As the article states, the element distinctness problem can be solved in &lt;code&gt;O(N)&lt;/code&gt;. This is the same for the socks problem (also &lt;code&gt;O(N)&lt;/code&gt;, if you need only one distribution step (I proposed multiple steps only because humans are bad at calculations - one step is enough if you distribute on &lt;code&gt;md5(color, length, pattern, ...)&lt;/code&gt;, i.e. a &lt;strong&gt;perfect hash&lt;/strong&gt; of all attributes)).</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa con el &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;problema de distinci&amp;oacute;n de elementos&lt;/a&gt; ? Como dice el art&amp;iacute;culo, el problema de distinci&amp;oacute;n de elementos se puede resolver en &lt;code&gt;O(N)&lt;/code&gt; . Esto es lo mismo para el problema de los calcetines (tambi&amp;eacute;n &lt;code&gt;O(N)&lt;/code&gt; , si solo necesita un paso de distribuci&amp;oacute;n (propuse varios pasos solo porque los humanos son malos en los c&amp;aacute;lculos; un paso es suficiente si distribuye en &lt;code&gt;md5(color, length, pattern, ...)&lt;/code&gt; , es decir, un &lt;strong&gt;hash perfecto&lt;/strong&gt; de todos los atributos)).</target>
        </trans-unit>
        <trans-unit id="d6e0a1a2a1c968e16f01d631ec79dc29fcbb8978" translate="yes" xml:space="preserve">
          <source>What we want to do is reduce the number of moves, and compensate with the number of searches. Also, we can utilize the multithreded environment of the Homo Sapiens to hold more things in the descision cache.</source>
          <target state="translated">Lo que queremos hacer es reducir el número de movimientos,y compensarlo con el número de búsquedas.Además,podemos utilizar el entorno multitratado del Homo Sapiens para guardar más cosas en el caché de descisión.</target>
        </trans-unit>
        <trans-unit id="40119aa23f988c392c776aef12173470a672ba85" translate="yes" xml:space="preserve">
          <source>When I sort socks, I do an approximate &lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;, dropping socks near other socks of the same colour/pattern type. Except in the case when I can see an exact match at/near the location I'm about to drop the sock I extract the pair at that point.</source>
          <target state="translated">Cuando clasifico calcetines, hago una &lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;clasificaci&amp;oacute;n&lt;/a&gt; aproximada de radix , dejando caer calcetines cerca de otros calcetines del mismo tipo de color / patr&amp;oacute;n. Excepto en el caso en que puedo ver una coincidencia exacta en / cerca de la ubicaci&amp;oacute;n donde estoy a punto de soltar el calcet&amp;iacute;n, extraigo el par en ese punto.</target>
        </trans-unit>
        <trans-unit id="dbe5289d9f14e85418adcf750eb06633c494d931" translate="yes" xml:space="preserve">
          <source>Whenever you pick up a sock, put it in one place.  Then the next sock you pick up, if it doesn't match the first sock, set it beside the first one.  If it does, there's a pair.  This way it doesn't really matter how many combinations there are, and there are only two possibilities for each sock you pick up -- either it has a match that's already in your array of socks, or it doesn't, which means you add it to a place in the array.</source>
          <target state="translated">Cada vez que recoja un calcetín,póngalo en un lugar.Luego el siguiente calcetín que recojas,si no coincide con el primer calcetín,ponlo al lado del primero.Si lo hace,hay un par.De esta manera no importa cuántas combinaciones haya,y sólo hay dos posibilidades para cada calcetín que recojas:o tiene una coincidencia que ya está en tu colección de calcetines,o no la tiene,lo que significa que lo añades a un lugar de la colección.</target>
        </trans-unit>
        <trans-unit id="491d10d638725516cd524ff053d646b7db3211cb" translate="yes" xml:space="preserve">
          <source>Why five? Usually humans are good are remembering between five and seven different elements in the working memory - a bit like the human equivalent of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;RPN&lt;/a&gt; stack - five is a safe default.</source>
          <target state="translated">&amp;iquest;Por que cinco? Por lo general, los humanos son buenos recordando entre cinco y siete elementos diferentes en la memoria de trabajo, un poco como el equivalente humano de una pila &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;RPN&lt;/a&gt; , cinco es un valor predeterminado seguro.</target>
        </trans-unit>
        <trans-unit id="4e43cc34e87ad7b769f2e692b3183f1cf7531543" translate="yes" xml:space="preserve">
          <source>X = Yours, Y = Your spouses</source>
          <target state="translated">X=Tuyo,Y=Tus cónyuges</target>
        </trans-unit>
        <trans-unit id="bfa8f5c7b6006f4ab74b72c8afabacf5f628c548" translate="yes" xml:space="preserve">
          <source>Yesterday I was pairing the socks from the clean laundry and figured out the way I was doing it is not very efficient. I was doing a naive search&amp;nbsp;&amp;mdash; picking one sock and &quot;iterating&quot; the pile in order to find its pair. This requires iterating over n/2 * n/4 = n&lt;sup&gt;2&lt;/sup&gt;/8 socks on average.</source>
          <target state="translated">Ayer estaba emparejando los calcetines de la ropa limpia y descubr&amp;iacute; que la forma en que lo hac&amp;iacute;a no es muy eficiente. Estaba haciendo una b&amp;uacute;squeda ingenua, escogiendo un calcet&amp;iacute;n y &quot;iterando&quot; la pila para encontrar su par. Esto requiere iterar sobre n / 2 * n / 4 = n 2/8 medias en promedio.</target>
        </trans-unit>
        <trans-unit id="dbd5aa135244891d8a3e76bf37cc43c7ca49ef7d" translate="yes" xml:space="preserve">
          <source>Yet times to times, I have to do this again (lost socks, damaged socks, etc.), and I hate to discard perfectly good socks too often (and I wished they kept selling the same socks reference!), so I recently took a different approach.</source>
          <target state="translated">Sin embargo,de vez en cuando,tengo que hacer esto de nuevo (calcetines perdidos,calcetines dañados,etc.),y odio desechar calcetines perfectamente buenos demasiado a menudo (¡y deseaba que siguieran vendiendo la misma referencia de los calcetines!),así que recientemente adopté un enfoque diferente.</target>
        </trans-unit>
        <trans-unit id="65810e5cb0ea23b0c4ace9656f94508778f1c8cd" translate="yes" xml:space="preserve">
          <source>You can achieve O(n) with &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;. You just need to pick some attributes for the buckets.</source>
          <target state="translated">Puede lograr O (n) con &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;clasificaci&amp;oacute;n de radix&lt;/a&gt; . Solo necesita elegir algunos atributos para los cubos.</target>
        </trans-unit>
        <trans-unit id="ba38f2aaa4cb49326b1693f418fc55f635bc82d4" translate="yes" xml:space="preserve">
          <source>You don't need recursive partitioning if you can find a distribution key (hash key) that &lt;strong&gt;provides enough buckets&lt;/strong&gt; that each bucket is small enough to be processed very quickly. Unfortunately, I don't think socks have such a property.</source>
          <target state="translated">No necesita particiones recursivas si puede encontrar una clave de distribuci&amp;oacute;n (clave hash) que &lt;strong&gt;proporcione suficientes&lt;/strong&gt; dep&amp;oacute;sitos para que cada dep&amp;oacute;sito sea lo suficientemente peque&amp;ntilde;o como para ser procesado muy r&amp;aacute;pidamente. Desafortunadamente, no creo que los calcetines tengan tal propiedad.</target>
        </trans-unit>
        <trans-unit id="991cf8e975ca3081b3b2acc02dc579d8b387f197" translate="yes" xml:space="preserve">
          <source>You need to estimate how many pairs of socks you will need for the rest of your life, or perhaps until you retire and move to warmer climates with no need to wear socks ever again. If you are young, you could also estimate how long it takes before we'll all have sock-sorting robots in our homes, and the whole problem becomes irrelevant.</source>
          <target state="translated">Necesitas estimar cuántos pares de calcetines necesitarás para el resto de tu vida,o quizás hasta que te retires y te mudes a climas más cálidos sin necesidad de usar calcetines nunca más.Si eres joven,también podrías estimar cuánto tiempo pasará antes de que todos tengamos robots clasificadores de calcetines en nuestras casas,y todo el problema se vuelve irrelevante.</target>
        </trans-unit>
        <trans-unit id="fbfa245099ad6c7e954cd2c2f169e543c5ddc580" translate="yes" xml:space="preserve">
          <source>You need to find out how you can order your selected sock in bulk, and how much it costs, and do they deliver.</source>
          <target state="translated">Tienes que averiguar cómo puedes pedir tu calcetín seleccionado a granel,y cuánto cuesta,y si te lo entregan.</target>
        </trans-unit>
        <trans-unit id="a2c3fba934e9cc7f3bb5f1c5bf7698755a4d500b" translate="yes" xml:space="preserve">
          <source>any subset taken from the top of this bin generally contains both
socks of a pair.</source>
          <target state="translated">cualquier subconjunto tomado de la parte superior de este recipiente generalmente contiene ambos calcetines de un par.</target>
        </trans-unit>
        <trans-unit id="66103b5b15e1b774175c59b31bb92026836434e7" translate="yes" xml:space="preserve">
          <source>environmental modifications</source>
          <target state="translated">modificaciones ambientales</target>
        </trans-unit>
        <trans-unit id="b72a142027a3d942512bfeebef1158e5555cdbf9" translate="yes" xml:space="preserve">
          <source>environmental reads</source>
          <target state="translated">las lecturas ambientales</target>
        </trans-unit>
        <trans-unit id="73ed780668cf0ea89fb1a13af96da25121e815d0" translate="yes" xml:space="preserve">
          <source>logical and arithmetic operations</source>
          <target state="translated">operaciones lógicas y aritméticas</target>
        </trans-unit>
        <trans-unit id="7b417589bff426c4c61c5b75b1f2b186688fc14d" translate="yes" xml:space="preserve">
          <source>p&lt;sub&gt;1&lt;/sub&gt; p&lt;sub&gt;2&lt;/sub&gt; p&lt;sub&gt;3&lt;/sub&gt; ... p&lt;sub&gt;n&lt;/sub&gt; p&lt;sub&gt;f(1)&lt;/sub&gt; p&lt;sub&gt;f(2)&lt;/sub&gt; ... p&lt;sub&gt;f(n)&lt;/sub&gt;</source>
          <target state="translated">p &lt;sub&gt;1&lt;/sub&gt; p &lt;sub&gt;2&lt;/sub&gt; p &lt;sub&gt;3&lt;/sub&gt; ... p &lt;sub&gt;n&lt;/sub&gt; p &lt;sub&gt;f (1)&lt;/sub&gt; p &lt;sub&gt;f (2)&lt;/sub&gt; ... p &lt;sub&gt;f (n)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d64b5bfb8d253171cb7f047779677b1f366a37c7" translate="yes" xml:space="preserve">
          <source>people toss both of their socks roughly in the same area of the
bin,</source>
          <target state="translated">la gente tira los dos calcetines aproximadamente en la misma zona de la papelera,</target>
        </trans-unit>
        <trans-unit id="e7aa0c831ecd9e4ccd9acd48f58060ccc6e98d8a" translate="yes" xml:space="preserve">
          <source>step 1) discard all your existing socks</source>
          <target state="translated">paso 1)descartar todos los calcetines existentes</target>
        </trans-unit>
        <trans-unit id="85929a76b2535ede46f1da6de8472cf210e6cc72" translate="yes" xml:space="preserve">
          <source>step 2) go to &lt;a href=&quot;http://en.wikipedia.org/wiki/Walmart&quot;&gt;Walmart&lt;/a&gt; and buy them by packets of 10 - n packet of
white and m packets of black. No need for other colors in everyday's
life.</source>
          <target state="translated">paso 2) ve a &lt;a href=&quot;http://en.wikipedia.org/wiki/Walmart&quot;&gt;Walmart&lt;/a&gt; y c&amp;oacute;mpralos en paquetes de 10 n paquetes de blanco y m paquetes de negro. No hay necesidad de otros colores en la vida cotidiana.</target>
        </trans-unit>
        <trans-unit id="f0bc37af84619514b988559161037a53edaa21ff" translate="yes" xml:space="preserve">
          <source>the bin is not randomized at any point, and therefore</source>
          <target state="translated">el contenedor no es aleatorio en ningún punto,y por lo tanto</target>
        </trans-unit>
        <trans-unit id="937822ebb59548bbc8c060e49cb9b98efb226b16" translate="yes" xml:space="preserve">
          <source>then length of the sock,</source>
          <target state="translated">y luego la longitud del calcetín,</target>
        </trans-unit>
        <trans-unit id="f0604a64202bf39aaef8452c27dea8a360470c75" translate="yes" xml:space="preserve">
          <source>then texture,
....</source>
          <target state="translated">...luego la textura,...</target>
        </trans-unit>
        <trans-unit id="f0038d5ea027e24fd063b53770f561619dfa487e" translate="yes" xml:space="preserve">
          <source>then use colors (can have any order for the colors, e.g. alphabetically by color name) - split them into piles by color (remember to keep the initial order from step 1 for all socks in the same pile),</source>
          <target state="translated">luego usar colores (puede tener cualquier orden para los colores,por ejemplo,alfabéticamente por el nombre del color)-dividirlos en montones por color (recuerde mantener el orden inicial del paso 1 para todos los calcetines en el mismo montón),</target>
        </trans-unit>
        <trans-unit id="4045b164d7574af579063ab4269d98a5011ed66a" translate="yes" xml:space="preserve">
          <source>where f is an unknown permutation of the set {1,2,...,n}. Knowing this cannot make the problem harder. There are n! possible outputs (matchings between first and second half), which means you need log(n!) = Omega(n log n) comparisons. This is obtainable by sorting.</source>
          <target state="translated">donde f es una permutación desconocida del conjunto {1,2,...,n}.Saber esto no puede hacer el problema más difícil.Hay n! salidas posibles (coincidencias entre la primera y la segunda mitad),lo que significa que necesitas comparaciones log(n!)=Omega(n log n).Esto se puede obtener clasificando.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
