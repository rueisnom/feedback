<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/14415881">
    <body>
      <group id="14415881">
        <trans-unit id="94c0dfc6b17aa37cab713289ff046437e179508f" translate="yes" xml:space="preserve">
          <source>&quot;if s pairs with a sock t in N&quot;.  How quickly can we &quot;remember&quot; what we've seen so far?</source>
          <target state="translated">&quot;если С парами с носком Т в Н&quot;.Как быстро мы &quot;вспомним&quot; то,что видели до сих пор?</target>
        </trans-unit>
        <trans-unit id="b5bdc0f37905c659679678b282a51daad6b30c24" translate="yes" xml:space="preserve">
          <source>&quot;remove t from N&quot; and &quot;add s to N&quot;.  How expensive is keeping track of what we've seen so far?</source>
          <target state="translated">&quot;удалить t из N&quot; и &quot;добавить s к N&quot;.Насколько дорого стоит отслеживание того,что мы видели до сих пор?</target>
        </trans-unit>
        <trans-unit id="257027605f38139d5816c62c3274fa0db3930e71" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;This approach can be fairly easily be implemented in an array, assuming that &quot;removing&quot; socks is an option.&lt;/s&gt; Actually, you don't even need to &quot;remove&quot; socks. If you don't need sorting of the socks (see below), then you can just move them around and end up with an array that has all the socks arranged in pairs in the array.</source>
          <target state="translated">&lt;s&gt;Этот подход может быть довольно легко реализован в массиве, предполагая, что &amp;laquo;удаление&amp;raquo; носков является опцией.&lt;/s&gt; На самом деле, вам даже не нужно &amp;laquo;снимать&amp;raquo; носки. Если вам не нужна сортировка носков (см. Ниже), то вы можете просто переместить их и получить массив, в котором все носки расположены попарно в массиве.</target>
        </trans-unit>
        <trans-unit id="6fae469126cdfe9fb170ccabec0390cf8682c501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Heuristic:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Heuristic:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8be3cb9316f7f1176c171daf3e0ce96f2978c5e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithmic answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Алгоритмический ответ:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6dd89168d13c44609bd0eb1bed16428f8b39446" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BTW&lt;/strong&gt;, I found that the sum of the transaction costs of sorting all the socks every time I needed a pair were far less than doing it once and binding the socks. A just-in-time works better because then you don't have to bind the socks, and there's also a diminishing marginal return (that is, you keep looking for that two or three socks that when somewhere in the laundry and that you need to finish matching your socks and you lose time on that).</source>
          <target state="translated">&lt;strong&gt;Кстати&lt;/strong&gt; , я обнаружил, что сумма транзакционных затрат на сортировку всех носков каждый раз, когда мне нужна пара, была намного меньше, чем если бы я делал это один раз и связывал носки. Своевременное использование работает лучше, потому что тогда вам не нужно связывать носки, а также уменьшается предельная отдача (то есть вы продолжаете искать те два или три носка, которые когда-то находятся в стирке, и которые вам нужны чтобы закончить сопоставление ваших носков, и вы теряете время на этом).</target>
        </trans-unit>
        <trans-unit id="2b5ac05a4a642e4eaddf91d074d8a86d8f9607d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1&lt;/strong&gt;: All socks are identical (this is what I do in real life by the way).</source>
          <target state="translated">&lt;strong&gt;Случай 1&lt;/strong&gt; : все носки идентичны (кстати, именно так я и поступаю в реальной жизни).</target>
        </trans-unit>
        <trans-unit id="49a8a493d307384ee45499ab7676db0d67425182" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2&lt;/strong&gt;: There are a constant number of combinations (ownership, color, size, texture, etc.).</source>
          <target state="translated">&lt;strong&gt;Случай 2&lt;/strong&gt; : существует постоянное количество комбинаций (принадлежность, цвет, размер, текстура и т. Д.).</target>
        </trans-unit>
        <trans-unit id="e00424d21a9c0392d4676ab7c8a9295c1d65c888" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 3&lt;/strong&gt;: The number of combinations is not known in advance (general case).</source>
          <target state="translated">&lt;strong&gt;Случай 3&lt;/strong&gt; : Количество комбинаций заранее неизвестно (общий случай).</target>
        </trans-unit>
        <trans-unit id="0b50c6f3b067c6fae56c03d06a7d861b64518113" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-algorithmic answer, yet &quot;efficient&quot; when I do it:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Неалгоритмический ответ, но все же &amp;laquo;эффективный&amp;raquo;, когда я делаю это:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f1ed3b5cf07fad91eb01fcb7a682e9e1f3420c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional&lt;/strong&gt; While you are searching the line and and the current sock you are looking at is identical to the previous, do step 2 for these socks.</source>
          <target state="translated">&lt;strong&gt;Необязательно&lt;/strong&gt; Пока вы ищете строку и текущий носок, на который вы смотрите, идентичен предыдущему, выполните шаг 2 для этих носков.</target>
        </trans-unit>
        <trans-unit id="4e7b1dad68f6cce31ec46db04710d5118a2d7aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preconditions:&lt;/strong&gt;
There is no guarantee that there are the same socks. If they are of the same color it doesn't mean they have the same size or pattern. Socks are randomly shuffled. There can be odd number of socks (some are missing, we don't know how many). Prepare to remember a variable &quot;index&quot; and set it to 0.</source>
          <target state="translated">&lt;strong&gt;Предварительные условия:&lt;/strong&gt; нет гарантии, что носки одинаковые. Если они одного цвета, это не значит, что они имеют одинаковый размер или рисунок. Носки в случайном порядке. Там может быть нечетное количество носков (некоторые отсутствуют, мы не знаем, сколько). Подготовьтесь запомнить переменную &amp;laquo;index&amp;raquo; и установите ее в 0.</target>
        </trans-unit>
        <trans-unit id="e8d739a374e59173c2a911ac09bb3cfac524d27d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recursively apply this scheme&lt;/strong&gt; until you have distributed all socks onto &lt;strong&gt;very small piles that you can visually process immediately&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Рекурсивно применяйте эту схему&lt;/strong&gt; до тех пор, пока вы не распределите все носки на &lt;strong&gt;очень маленькие кучи, которые можно сразу визуально обработать.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b4b7ec4098550470ed2c4636c449a2c24d32ee0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, the question is basically:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Итак, вопрос в основном:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08fda84558211c3c93b54ebc0219bb815255b9af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1:&lt;/strong&gt; Each time you put dirty socks in your laundry basket, tie them in a little knot. That way you will not have to do any sorting after the washing. Think of it like registering an index in a Mongo database. A little work ahead for some CPU savings in the future.</source>
          <target state="translated">&lt;strong&gt;Решение 1.&lt;/strong&gt; Каждый раз, когда вы кладете грязные носки в корзину для белья, завязывайте их в маленький узел. Таким образом, вам не придется делать какую-либо сортировку после стирки. Думайте об этом как о регистрации индекса в базе данных Mongo. Впереди немного работы для некоторой экономии процессора.</target>
        </trans-unit>
        <trans-unit id="b93e25b8a424a36b38ce0b2f666db17b4cec3ad9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2:&lt;/strong&gt; If it's winter, you don't have to wear matching socks. We are programmers. Nobody needs to know, as long as it works.</source>
          <target state="translated">&lt;strong&gt;Решение 2:&lt;/strong&gt; Если зима, вам не нужно носить соответствующие носки. Мы программисты. Никто не должен знать, пока это работает.</target>
        </trans-unit>
        <trans-unit id="0094560f52b8dad6f4ad715c3c000c707e442bb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 3:&lt;/strong&gt; Spread the work. You want to perform such a complex CPU process asynchronously, without blocking the UI. Take that pile of socks and stuff them in a bag. Only look for a pair when you need it. That way the amount of work it takes is much less noticeable.</source>
          <target state="translated">&lt;strong&gt;Решение 3:&lt;/strong&gt; Распространить работу. Вы хотите выполнить такой сложный процесс CPU асинхронно, не блокируя пользовательский интерфейс. Возьми эту кучу носков и положи в сумку. Ищите пару только тогда, когда вам это нужно. Таким образом, объем работы, которую он занимает, гораздо менее заметен.</target>
        </trans-unit>
        <trans-unit id="cd64c3cf6ffd817f997a05ddde37296211310d6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result&lt;/strong&gt; will have one or two piles: 1. &quot;matched&quot; and 2. &quot;missing&quot;</source>
          <target state="translated">&lt;strong&gt;Результат&lt;/strong&gt; будет иметь одну или две стопки: 1. &amp;laquo;совпадает&amp;raquo; и 2. &amp;laquo;отсутствует&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="1873002ca8758724d2c9adf28e13baa534b32d50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are trying to solve the wrong problem.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вы пытаетесь решить не ту проблему.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42553619c0d4d907f8c4939e4417b4728dc4eff8" translate="yes" xml:space="preserve">
          <source>A general &lt;em&gt;theoretical&lt;/em&gt; solution for a huge number of socks.</source>
          <target state="translated">Общее &lt;em&gt;теоретическое&lt;/em&gt; решение для огромного количества носков.</target>
        </trans-unit>
        <trans-unit id="86619e9b5473c8436c88e4580124cac4300c7011" translate="yes" xml:space="preserve">
          <source>A neat freak might use numeric labels for pairs as someone suggested.  This opens the door to a total ordering, which allows the human to use exactly the same algorithms we might with a CPU: binary search, trees, hashes, etc.</source>
          <target state="translated">Чистый урод может использовать числовые метки для пар,как кто-то предлагал.Это открывает дверь к полному упорядочению,что позволяет человеку использовать точно такие же алгоритмы,как и при работе с процессором:бинарный поиск,деревья,хэши и т.д.</target>
        </trans-unit>
        <trans-unit id="e2b68ea4fb20ff8e31763199ca38f49c47f03983" translate="yes" xml:space="preserve">
          <source>About parallelism:
As long as you toss both socks into the same bin, you can easily parallelize all of those steps.</source>
          <target state="translated">О параллельности:До тех пор,пока вы выбрасываете оба носка в одну корзину,вы можете легко распараллелить все эти шаги.</target>
        </trans-unit>
        <trans-unit id="f6fc8d26eb16b2c7196aa947f223e3e3ed467028" translate="yes" xml:space="preserve">
          <source>After eliminating the fluro coloured, the socks with stripes, and the three pairs of long socks, you might end up with mostly white socks roughly sorted by how worn they are.</source>
          <target state="translated">После устранения флюорографического цвета,носков с полосками и трех пар длинных носков,вы можете получить в основном белые носки,грубо отсортированные по тому,как они изношены.</target>
        </trans-unit>
        <trans-unit id="98f0ebf5e1f426f9d4fb354b2d2f98129af56fdf" translate="yes" xml:space="preserve">
          <source>After that, there are only a few socks left. This is where I introduce previously unpaired socks into the system and process the remaining socks without any special algorithm - the remaining socks are very few and can be processed visually very fast.</source>
          <target state="translated">После этого осталось всего несколько носков.Именно здесь я внедряю в систему ранее не ремонтировавшиеся носки и обрабатываю оставшиеся носки без какого-либо специального алгоритма-оставшихся носков очень мало и их можно визуально обработать очень быстро.</target>
        </trans-unit>
        <trans-unit id="f910680ab39d0aa8398bce15b13e098f9be2e9a8" translate="yes" xml:space="preserve">
          <source>After this, it's easy to do the hash partitioning algorithm. Usually, about 75% of the socks are already paired, leaving me with a very small subset of socks, and this subset is already (somewhat) clustered (I don't introduce much entropy into my basket after the preprocessing steps). Another thing is that the remaining clusters tend to be small enough to be handled at once, so it is possible to take a whole cluster out of the basket.</source>
          <target state="translated">После этого легко выполнить алгоритм разбиения хэша.Обычно около 75% носков уже спарены,оставляя мне очень маленькое подмножество носков,и это подмножество уже (несколько)сгруппировано (я не вношу много энтропии в свою корзину после шагов препроцессирования).Другое дело,что оставшиеся кластеры,как правило,достаточно малы,чтобы их можно было обрабатывать сразу,так что из корзины можно вытащить целый кластер.</target>
        </trans-unit>
        <trans-unit id="a610a16cc6741362976a74534a8c23c401cdcb8f" translate="yes" xml:space="preserve">
          <source>Almost all the other algorithms (including &lt;a href=&quot;https://stackoverflow.com/a/14419556/1042311&quot;&gt;the top scoring answer by usr&lt;/a&gt;) sort, then remove pairs. I find that, as a human, it is better to minimize the number of socks being considered at one time.</source>
          <target state="translated">Почти все другие алгоритмы (включая &lt;a href=&quot;https://stackoverflow.com/a/14419556/1042311&quot;&gt;самый лучший ответ от usr&lt;/a&gt; ) сортируют, а затем удаляют пары. Я считаю, что, как человек, лучше минимизировать количество носков, рассматриваемых одновременно.</target>
        </trans-unit>
        <trans-unit id="eccc8c5a89378f08c10b8d673e29520d1e8e7126" translate="yes" xml:space="preserve">
          <source>Also, there could be added check for damaged socks also, as if the removal of those. It could be inserted between 2 and 3, and between 13 and 14.</source>
          <target state="translated">Также может быть добавлена проверка на наличие поврежденных носков,как если бы они были сняты.Его можно вставлять между 2 и 3,и между 13 и 14.</target>
        </trans-unit>
        <trans-unit id="9788a20dd94a5a2bf372d767d6027859c72d11c2" translate="yes" xml:space="preserve">
          <source>Also, we don't need to assume a large number of socks, even for large families. Socks are taken out of the drawer and are worn, and then they are tossed in a place (maybe a bin) where they stay before being laundered. While I wouldn't call said bin a LIFO-Stack, I'd say it is safe to assume that</source>
          <target state="translated">Кроме того,нам не нужно предполагать большое количество носков,даже для многодетных семей.Носки достаются из ящика и надеваются,а затем их выбрасывают в место (может быть,в мусорное ведро),где они и остаются перед стиркой.Хотя я бы не назвал мусорное ведро LIFO-стэком,я бы сказал,что можно с уверенностью предположить.</target>
        </trans-unit>
        <trans-unit id="157fc609ec55f17f263d7a3a005a4071e377c228" translate="yes" xml:space="preserve">
          <source>Although the outputs are not exactly the same (in one case, just a boolean. In the other case, the pairs of socks), the asymptotic complexities are the same.</source>
          <target state="translated">Хотя выходные данные не совсем одинаковы (в одном случае-просто булевы,в другом-пары носков),асимптотические сложности одинаковы.</target>
        </trans-unit>
        <trans-unit id="05e0d0df0a6446265996f77e214ab1168f512228" translate="yes" xml:space="preserve">
          <source>An alternative step 3 would involve comparing costs of buying the same amount of perhaps cheaper socks a few pairs at a time over the years and adding the cost of sorting socks, but take my word for it: buying in bulk is cheaper! Also, socks in storage increase in value at the rate of stock price inflation, which is more than you would get on many investments. Then again there is also storage cost, but socks really do not take much space on the top shelf of a closet.</source>
          <target state="translated">Альтернативный шаг 3 будет заключаться в сравнении затрат на покупку одного и того же количества возможно более дешевых носков по несколько пар одновременно на протяжении многих лет и добавлении стоимости сортировки носков,но поверьте мне на слово:покупка оптом дешевле! Кроме того,носки на складе увеличивают стоимость при темпах инфляции цен на акции,что больше,чем вы бы получили на многих инвестициях.Потом опять же есть еще и стоимость хранения,но носки действительно не занимают много места на верхней полке шкафа.</target>
        </trans-unit>
        <trans-unit id="3835c018ca31a4eabdd14cc9d36b8f5e0b2ee808" translate="yes" xml:space="preserve">
          <source>An obvious algorithm for sock sorting is:</source>
          <target state="translated">Очевидный алгоритм сортировки носков:</target>
        </trans-unit>
        <trans-unit id="56b599442bccb5b5949e6ad41c70544a44257d97" translate="yes" xml:space="preserve">
          <source>And more often than not, this is not just &lt;em&gt;any&lt;/em&gt; free time, it's &lt;em&gt;morning&lt;/em&gt; free time, which you could be spending in bed, or sipping your coffee, or leaving a bit early and not being caught in the traffic.</source>
          <target state="translated">И чаще всего это не просто свободное время, это &lt;em&gt;утреннее&lt;/em&gt; свободное время, которое вы могли бы проводить в постели, или потягивая кофе, или уходить немного рано и не попасться в пробку.</target>
        </trans-unit>
        <trans-unit id="121979168ac388fe182e793a8f415d4c02e0bcfd" translate="yes" xml:space="preserve">
          <source>And there is a way!</source>
          <target state="translated">И есть способ!</target>
        </trans-unit>
        <trans-unit id="aaed1a26327f668180ed38055a98d2f4a897c097" translate="yes" xml:space="preserve">
          <source>Applying the same idea to the practical problem of pairing socks, the apparent answer is: don't allow your socks to ever be unpaired. Socks are provided as a pair, put in the drawer as a pair (perhaps by balling them together), worn as a pair. But the point where unpairing is possible is in the washer, so all that's required is a physical mechanism that allows the socks to stay together and be washed efficiently.</source>
          <target state="translated">Применяя ту же идею к практической проблеме спаривания носков,очевидный ответ заключается в следующем:не позволяйте вашим носкам когда-либо быть непарными.Носки поставляются как пара,кладутся в ящик как пара (возможно,сшивая их вместе),носятся как пара.Но место,где возможно снятие пары,находится в стиральной машине,поэтому все,что требуется-это физический механизм,позволяющий носкам оставаться вместе и эффективно стираться.</target>
        </trans-unit>
        <trans-unit id="4447172c03cd07d366eaa6901d47c0105462f432" translate="yes" xml:space="preserve">
          <source>As a computer scientist I was thinking what I could do? Sorting (according to size/color/...) of course came to mind to achieve an O(NlogN) solution.</source>
          <target state="translated">Как компьютерщик,я думал,что я могу сделать? Сортировка (согласно sizecolor...),конечно,пришла в голову для достижения решения O(NlogN).</target>
        </trans-unit>
        <trans-unit id="dea5f13104d5d8bafb26f6f1728af7ebead57e19" translate="yes" xml:space="preserve">
          <source>As a practical solution:</source>
          <target state="translated">Как практическое решение:</target>
        </trans-unit>
        <trans-unit id="0330f3b9f6b91d26ecc04e1313146ad77b320f18" translate="yes" xml:space="preserve">
          <source>As rapidly as possible, remove socks from the unsorted pile one at a time and place in piles in front of you. The piles should be arranged somewhat space-efficiently, with all socks pointing the same direction; the number of piles is limited by the distance you can easily reach. The selection of a pile on which to put a sock should be -- as rapidly as possible -- by putting a sock on a pile of apparently like socks; the occasional type I (putting a sock on a pile it doesn't belong to) or type II (putting a sock in its own pile when there's an existing pile of like socks) error can be tolerated -- the most important consideration is &lt;em&gt;speed&lt;/em&gt;. Once all the socks are in piles, rapidly go through the multi-sock piles creating pairs and removing them (these are heading for the drawer). If there are non-matching socks in the pile, re-pile them to their best (within the as-fast-as-possible constraint) pile. When all the multi-sock piles have been processed, match up remaining pairable socks that weren't paired due to type II errors. Whoosh, you're done -- and I have a lot of socks and don't wash them until a large fraction are dirty. Another practical note: I flip the top of one of a pair of socks down over the other, taking advantage of their elastic properties, so they stay together while being transported to the drawer and while in the drawer.</source>
          <target state="translated">Как можно быстрее снимайте носки с несортированной кучи по одному и укладывайте их в стопки перед собой. Сваи должны быть расположены несколько экономно, чтобы все носки были направлены в одном направлении; количество свай ограничено расстоянием, которое вы можете легко достичь. Выбор стопки, на которую можно надеть носок, следует - как можно быстрее - положить носок на стопку явно похожих носков; можно допустить случайную ошибку типа I (положить носок в стопку, к которой он не принадлежит) или типа II (положить носок в собственную стопку, когда имеется куча похожих носков) - наиболее важным фактором является &lt;em&gt;скорость&lt;/em&gt; , Как только все носки собраны в стопки, быстро пройдите через несколько носков, создавая пары и удаляя их (они направляются к ящику). Если в стопке есть несоответствующие носки, соберите их в лучшую (в пределах максимально возможной ограничения) стопку. Когда все кучи с несколькими носками были обработаны, сопоставьте оставшиеся пригодные для носки носки, которые не были спарены из-за ошибок типа II. Черт, ты молодец, а у меня много носков, и я не стираю их до тех пор, пока большая часть не станет грязной. Еще одно практическое замечание: я переворачиваю верх одной из пары носков поверх другой, используя их упругие свойства, чтобы они оставались вместе при транспортировке в ящик и в ящике.</target>
        </trans-unit>
        <trans-unit id="21c82dc8d9601ae12e034b45a03f0358de859eb2" translate="yes" xml:space="preserve">
          <source>As the architecture of the human brain is completely different than a modern CPU, this question makes no practical sense.</source>
          <target state="translated">Поскольку архитектура человеческого мозга полностью отличается от современного процессора,этот вопрос не имеет практического смысла.</target>
        </trans-unit>
        <trans-unit id="c9da0c9b1a26a80303bb8c443c01afa8a2584687" translate="yes" xml:space="preserve">
          <source>Assuming that the only operation for socks is to compare for equality, this algorithm is basically still an n&lt;sup&gt;2&lt;/sup&gt; algorithm, though I don't know about the average case (never learned to calculate that).</source>
          <target state="translated">Предполагая, что единственной операцией для носков является сравнение на равенство, этот алгоритм в основном все еще является алгоритмом n &lt;sup&gt;2&lt;/sup&gt; , хотя я не знаю насчет среднего случая (так и не научился его вычислять).</target>
        </trans-unit>
        <trans-unit id="9ecfa67dfd0923fad315f8a06acb48f7f0237861" translate="yes" xml:space="preserve">
          <source>At least this is what I am using in real life, and I find it very efficient. The downside is it requires a flat surface, but it's usually abundant.</source>
          <target state="translated">По крайней мере,это то,что я использую в реальной жизни,и я нахожу это очень эффективным.Недостатком является то,что для этого требуется плоская поверхность,но обычно она изобилует.</target>
        </trans-unit>
        <trans-unit id="5b86498f0344f03ab782a1075a31f259917a9553" translate="yes" xml:space="preserve">
          <source>At some point, the differences between socks are small enough that other people won't notice the difference, and any further matching effort is not needed.</source>
          <target state="translated">В какой-то момент разница между носками настолько мала,что другие люди не заметят ее,и никаких дополнительных усилий по подбору не требуется.</target>
        </trans-unit>
        <trans-unit id="7e52e0e243840d708880946b6c4315d013367de6" translate="yes" xml:space="preserve">
          <source>But for each sock to keep a reference to the other, there is a neat solution: a popper (or a 'snap button' if you're American), such as these:</source>
          <target state="translated">Но для того,чтобы каждый носок держал ссылку на другой,есть изящное решение:поппер (или &quot;кнопка защелкивания&quot;,если вы американец),например,такие:</target>
        </trans-unit>
        <trans-unit id="b59dc09b425cf2a04ad8751ed78176abb3f57590" translate="yes" xml:space="preserve">
          <source>By pulling the distinctive socks first, you leave space to &quot;zoom&quot; in on the features which are less distinctive, to begin with.</source>
          <target state="translated">Сначала потянув за отличительные носки,вы оставляете место для &quot;увеличения&quot; менее отличительных черт.</target>
        </trans-unit>
        <trans-unit id="325f07a647449aca13d04b404d5077e42950128f" translate="yes" xml:space="preserve">
          <source>By reducing my inputs to one of two types of socks (white socks for recreation, black socks for work), I only need to determine which of two socks I have in hand. (Technically, since they are never washed together, I have reduced the process to O(0) time)</source>
          <target state="translated">Сокращая свои затраты на один из двух видов носков (белые носки для отдыха,черные носки для работы),мне нужно только определить,какой из двух носков у меня в руках.(Технически,так как они никогда не стираются вместе,я сократил процесс до времени O(0)).</target>
        </trans-unit>
        <trans-unit id="839d4561e5360dfca7e45fa2801c421ef3ca26fb" translate="yes" xml:space="preserve">
          <source>Choose one of the socks and put it away (create a 'bucket' for that pair)</source>
          <target state="translated">Выберите один из носков и уберите его (создайте для этой пары &quot;ведро&quot;).</target>
        </trans-unit>
        <trans-unit id="5d6b924144b70d6a90942c0979240ccaa91f1233" translate="yes" xml:space="preserve">
          <source>Clearly, one cannot go faster than &lt;code&gt;O(N)&lt;/code&gt;, so we have reached the &lt;strong&gt;optimal lower bound&lt;/strong&gt;.</source>
          <target state="translated">Ясно, что нельзя идти быстрее, чем &lt;code&gt;O(N)&lt;/code&gt; , поэтому мы достигли &lt;strong&gt;оптимальной нижней границы&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9a74f91f894f5fdd53f2126400da6be5bbf36590" translate="yes" xml:space="preserve">
          <source>Combine with Other Task</source>
          <target state="translated">Сочетание с другими задачами</target>
        </trans-unit>
        <trans-unit id="8ac6a3ace758bdb634f5dc66fbca8858d699c4a7" translate="yes" xml:space="preserve">
          <source>Consider a hash-table of  size  'N'.</source>
          <target state="translated">Рассмотрим хэш-таблицу размера 'N'.</target>
        </trans-unit>
        <trans-unit id="be4d36fcb52cd8affab669c9c320903855e4dd53" translate="yes" xml:space="preserve">
          <source>Consider than if you draw only one sock for the second stack of socks, as you are doing, your odds of finding the matching sock in a naive search is quite low.</source>
          <target state="translated">Учтите,что если вы нарисуете только один носок для второй стопки носков,как вы это делаете,ваши шансы найти подходящий носок в наивном поиске довольно малы.</target>
        </trans-unit>
        <trans-unit id="f9b1944832d9453a7dc17748fdc3d9173cbd95c9" translate="yes" xml:space="preserve">
          <source>Cost: Moving socks -&amp;gt; high, finding/search socks in line -&amp;gt; small</source>
          <target state="translated">Стоимость: перемещение носков -&amp;gt; высокая, поиск / поиск носков в ряд -&amp;gt; маленькая</target>
        </trans-unit>
        <trans-unit id="05201805c52c192640e03bce4060ac08d6051851" translate="yes" xml:space="preserve">
          <source>Create a hash table which will be used for unmatched socks, using the pattern as the hash. Iterate over the socks one by one. If the sock has a pattern match in the hash table, take the sock out of the table and make a pair. If the sock does not have a match, put it into the table.</source>
          <target state="translated">Создайте хэш-таблицу,которая будет использоваться для несопоставимых носков,используя узор в качестве хэша.Итерация по носкам один за другим.Если носок имеет шаблон,совпадающий с хэш-таблицей,вытащите носок из таблицы и сделайте пару.Если носок не имеет совпадений,положите его в таблицу.</target>
        </trans-unit>
        <trans-unit id="ece5b7e4f44f0c60b7df2b4d7656e3eb3246bbfd" translate="yes" xml:space="preserve">
          <source>Do until A is empty.</source>
          <target state="translated">Делайте,пока А не опустеет.</target>
        </trans-unit>
        <trans-unit id="a3af62234185a8fbf95199db3ed4496b2e1b062b" translate="yes" xml:space="preserve">
          <source>Do until both X and Y is empty.</source>
          <target state="translated">Делайте,пока и X,и Y не станут пустыми.</target>
        </trans-unit>
        <trans-unit id="e74f486c764075c4dfed8abc5b9386d07590d29c" translate="yes" xml:space="preserve">
          <source>Don't waste your time moving socks around or looking for the best match, this all should be done in O(n), which we would also need for just putting them on the line unsorted.
The socks aren't paired yet, we only have several similarity clusters on the line. It's helpful that we have a limited set of socks here, as this helps us to create &quot;good&quot; clusters (for example, if there are only black socks in the set of socks, clustering by colours would not be the way to go)</source>
          <target state="translated">Не тратьте время на передвижение носков или поиск лучшего варианта,все это должно быть сделано в O(n),что нам также нужно для того,чтобы просто поставить их на линию несортированными.Носки еще не спарены,у нас только несколько кластеров схожести на линии.Полезно,что у нас здесь ограниченный набор носков,так как это помогает нам создавать &quot;хорошие&quot; кластеры (например,если в наборе носков есть только черные носки,кластеризация по цветам не будет правильным решением).</target>
        </trans-unit>
        <trans-unit id="e9b450d14bc2363d292c84f17cfad5cfbd58a458" translate="yes" xml:space="preserve">
          <source>Done</source>
          <target state="translated">Done</target>
        </trans-unit>
        <trans-unit id="9ec877009e8b5ea7edaecdf46b39cdf271ac5e08" translate="yes" xml:space="preserve">
          <source>Feel free to write down the formula to calculate how many samples you have to draw for a 50% odds of a match. IIRC it's an hypergeometric law.</source>
          <target state="translated">Не стесняйтесь записывать формулу,чтобы вычислить,сколько образцов вы должны нарисовать для 50-процентного шанса на матч.IIRC-это гипергеометрический закон.</target>
        </trans-unit>
        <trans-unit id="ee75e1685f87ca197f6c3aaaa97916949e86e0db" translate="yes" xml:space="preserve">
          <source>Find a pair by looking at the socks on the floor.</source>
          <target state="translated">Найдите пару,глядя на носки на полу.</target>
        </trans-unit>
        <trans-unit id="2d7f4a781c3305161bd0ab2917bdad576999ed2c" translate="yes" xml:space="preserve">
          <source>Find a sock you like. Take all relevant features into account: colour in different lighting conditions, overall quality and durability, comfort in different climatic conditions, and odour absorption. Also important is, they should not lose elasticity in storage, so natural fabrics are good, and they should be available in a plastic wrapping.</source>
          <target state="translated">Найди носок,который тебе нравится.Учитывайте все важные особенности:цвет в различных условиях освещения,общее качество и долговечность,комфорт в различных климатических условиях,а также поглощение запахов.Также важно,чтобы они не теряли эластичность при хранении,поэтому натуральные ткани хороши и должны быть в пластиковой упаковке.</target>
        </trans-unit>
        <trans-unit id="a9a8d801aad71c6f999c991c92a663302901ccc9" translate="yes" xml:space="preserve">
          <source>Find all matched pairs, pack it and move packed pairs to &quot;matched&quot; pile;
 If there were no new matches - increment &quot;index&quot; by 1</source>
          <target state="translated">Найти все совпадающие пары,упаковать их и переместить упакованные пары в &quot;совпадающую&quot; кучу;если новых совпадений не было-увеличить &quot;индекс&quot; на 1</target>
        </trans-unit>
        <trans-unit id="52c3a2cfe2904b404c77eec5836501de1058b709" translate="yes" xml:space="preserve">
          <source>Find its match.</source>
          <target state="translated">Найди его совпадение.</target>
        </trans-unit>
        <trans-unit id="c0a4340783c31b2ef43b6cdc9d203753e623f8c3" translate="yes" xml:space="preserve">
          <source>Find its pair</source>
          <target state="translated">Найти свою пару</target>
        </trans-unit>
        <trans-unit id="9398e96bcda6ff722938ce7ced4416bbac5aa5f1" translate="yes" xml:space="preserve">
          <source>Find most distinctive sock.</source>
          <target state="translated">Найдите самый характерный носок.</target>
        </trans-unit>
        <trans-unit id="82f8de3c35ca9b182c746b9a61ec6f2e62e7264c" translate="yes" xml:space="preserve">
          <source>First you can choose (hers, mine) - split them into 2 piles,</source>
          <target state="translated">Сначала вы можете выбрать (ее,мою)-разделите их на 2 кучи,</target>
        </trans-unit>
        <trans-unit id="893e0080cad23ba3476d1e48d4706a557776aeeb" translate="yes" xml:space="preserve">
          <source>For a 'pair' object that keeps a pointer to each sock we could have a cloth bag that we use to keep the socks together. This seems like massive overhead.</source>
          <target state="translated">Для &quot;парного&quot; предмета,который держит указатель на каждый носок,мы могли бы иметь тканевый мешок,который мы используем,чтобы держать носки вместе.Это похоже на массивные накладные расходы.</target>
        </trans-unit>
        <trans-unit id="077ecc6cb20560a33edffb3287fdf7ac14426d24" translate="yes" xml:space="preserve">
          <source>For all remaining socks, I assume that their counterparts are still unwashed and put them away for the next iteration. If you register a growth of unpaired socks over time (a &quot;sock leak&quot;), you should check your bin - it might get randomized (do you have cats which sleep in there?)</source>
          <target state="translated">Для всех оставшихся носков,я полагаю,что их коллеги все еще не вымыты и посадили их на следующую итерацию.Если вы регистрируете рост непарных носков с течением времени (&quot;утечка носков&quot;),вам следует проверить мусорное ведро-оно может стать случайным (есть ли у вас кошки,которые там спят?).</target>
        </trans-unit>
        <trans-unit id="cc92f3e9adf433b615dccfeb6da282fce4ea8901" translate="yes" xml:space="preserve">
          <source>For each color of socks, &lt;strong&gt;form a pile&lt;/strong&gt;. Iterate over all socks in your input basket &lt;strong&gt;and distribute them onto the color piles&lt;/strong&gt;.</source>
          <target state="translated">Для каждого цвета носков &lt;strong&gt;сформируйте кучу&lt;/strong&gt; . Переберите все носки в вашей корзине &lt;strong&gt;и распределите их по цветам&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d6414c797002dc91c1ae83eaf49240cdcbf24e18" translate="yes" xml:space="preserve">
          <source>For each line X and Y</source>
          <target state="translated">Для каждой строки X и Y</target>
        </trans-unit>
        <trans-unit id="5855dab75f8b813fca7ffaa714ea108a4295227b" translate="yes" xml:space="preserve">
          <source>For the first sock, or if all previously-chosen socks have been paired, simply place the sock into the first &quot;slot&quot; of an &quot;array&quot; of unpaired socks in front of you.</source>
          <target state="translated">Для первого носка,или если все ранее выбранные носки были спарены,просто поместите носок в первый &quot;паз&quot; &quot;массива&quot; непаренных носков перед собой.</target>
        </trans-unit>
        <trans-unit id="894192607ac808554f03c075fd0655a37e1ad671" translate="yes" xml:space="preserve">
          <source>For the following runtime analysis of pairing &lt;code&gt;n&lt;/code&gt; pairs of socks, we suppose that at least half of the &lt;code&gt;2n&lt;/code&gt; socks aren't hidden after step 1. So in the average case we can find &lt;code&gt;n/2&lt;/code&gt; pairs. This means that the loop is step 4 is executed &lt;code&gt;O(log n)&lt;/code&gt; times. Step 2 is executed &lt;code&gt;O(n^2)&lt;/code&gt; times. So we can conclude:</source>
          <target state="translated">Для следующего анализа времени выполнения пар &lt;code&gt;n&lt;/code&gt; пар носков мы предполагаем, что по крайней мере половина из &lt;code&gt;2n&lt;/code&gt; носков не скрыта после шага 1. Так что в среднем случае мы можем найти &lt;code&gt;n/2&lt;/code&gt; пары. Это означает, что цикл шага 4 выполняется &lt;code&gt;O(log n)&lt;/code&gt; раз. Шаг 2 выполняется &lt;code&gt;O(n^2)&lt;/code&gt; раз. Итак, мы можем сделать вывод:</target>
        </trans-unit>
        <trans-unit id="cd22dd03c04d34755de0454c107040828d993fa6" translate="yes" xml:space="preserve">
          <source>Forget &quot;index&quot;</source>
          <target state="translated">Забудьте про &quot;индекс&quot;</target>
        </trans-unit>
        <trans-unit id="754feeeb1411a93845cc30e2f433edcea6d8f1d0" translate="yes" xml:space="preserve">
          <source>From pile A of all socks:</source>
          <target state="translated">Из кучи А всех носков:</target>
        </trans-unit>
        <trans-unit id="88af6c6ae694d3f0adbd64981b429a7c2015afc5" translate="yes" xml:space="preserve">
          <source>From your question it is clear you don't have much actual experience with laundry :). You need an algorithm that works well with a small number of non-pairable socks.</source>
          <target state="translated">Из вашего вопроса ясно,что у вас нет большого фактического опыта в стирке :).Вам нужен алгоритм,который бы хорошо работал с небольшим количеством небритых носков.</target>
        </trans-unit>
        <trans-unit id="0444a1d3195984e21f70709ff60bf0a46830a14e" translate="yes" xml:space="preserve">
          <source>Get rid of your old socks.</source>
          <target state="translated">Избавься от своих старых носков.</target>
        </trans-unit>
        <trans-unit id="a1a874f464be482c37caf7802d65a53aaacd038a" translate="yes" xml:space="preserve">
          <source>Given a pile of &lt;code&gt;n&lt;/code&gt; pairs of socks, containing &lt;code&gt;2n&lt;/code&gt; elements (assume each sock has exactly one matching pair), what is the best way to pair them up efficiently with up to logarithmic extra space? (I believe I can remember that amount of info if needed.)</source>
          <target state="translated">Учитывая кучу из &lt;code&gt;n&lt;/code&gt; пар носков, содержащих &lt;code&gt;2n&lt;/code&gt; элементов (предположим, что каждый носок имеет ровно одну совпадающую пару), каков наилучший способ их эффективного сопряжения с логарифмическим дополнительным пространством? (Я верю, что могу запомнить это количество информации, если это необходимо.)</target>
        </trans-unit>
        <trans-unit id="92391b2bac5f63b1732ccf6a829b75982b2d6b4f" translate="yes" xml:space="preserve">
          <source>Go to 1</source>
          <target state="translated">Перейти на 1</target>
        </trans-unit>
        <trans-unit id="7548a76daeaf6efed0b0d32caeb5242aedd1b6ef" translate="yes" xml:space="preserve">
          <source>Grab a sock at random from the pile.</source>
          <target state="translated">Хватай носок наугад из кучи.</target>
        </trans-unit>
        <trans-unit id="8b31726f5fe78e7abfdb271081348d3c49ef8d7a" translate="yes" xml:space="preserve">
          <source>Hashing or other not-in-place solutions are not an option, because I am not able to duplicate my socks (though it could be nice if I could).</source>
          <target state="translated">Хэширование или другие нестандартные решения-это не вариант,потому что я не могу дублировать носки (хотя было бы неплохо,если бы я мог).</target>
        </trans-unit>
        <trans-unit id="0bebef8e20477195eae330c945bf1f33000ef38c" translate="yes" xml:space="preserve">
          <source>Have it Almost &lt;code&gt;O(n)&lt;/code&gt;!</source>
          <target state="translated">Имейте это почти &lt;code&gt;O(n)&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="d3cc97a68c770f1ea7c6ba0f7a34ec7739feed82" translate="yes" xml:space="preserve">
          <source>Here's an Omega(n log n) lower bound in comparison based model. (The only valid operation is comparing two socks.)</source>
          <target state="translated">Вот нижний предел модели,основанной на сравнении,Omega(n log n).(Единственная корректная операция-это сравнение двух носков).</target>
        </trans-unit>
        <trans-unit id="08f1f9a1a68f065efbd777b85e911439d922e715" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for put_socks_on_line():</source>
          <target state="translated">Вот алгоритм для функции put_socks_on_line():</target>
        </trans-unit>
        <trans-unit id="54268b27bb372ae27ec075e414013dd493b79119" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for sort_remaining_clusters():</source>
          <target state="translated">Вот алгоритм функции sort_remaining_clusters():</target>
        </trans-unit>
        <trans-unit id="a12197b6379a8cd2d9de831467c2eea0d417e206" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for take_socks_from_line():</source>
          <target state="translated">Вот алгоритм для функции take_socks_from_line():</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">Надеюсь,это поможет!</target>
        </trans-unit>
        <trans-unit id="5435330177144a505ebd78530841aed23ef79bd1" translate="yes" xml:space="preserve">
          <source>How to pair socks from a pile efficiently</source>
          <target state="translated">Как эффективно спаривать носки из кучи.</target>
        </trans-unit>
        <trans-unit id="0163309c2cf5dde27bf33b63dc03540e97a8c089" translate="yes" xml:space="preserve">
          <source>However in real life when the number of socks is relatively small (constant), these theoretically optimal algorithms wouldn't work well. It might take even more time than sequential search, which theoretically requires quadratic time.</source>
          <target state="translated">Однако в реальной жизни,когда количество носков относительно невелико (постоянно),эти теоретически оптимальные алгоритмы не будут работать хорошо.Это может занять даже больше времени,чем последовательный поиск,который теоретически требует квадратичного времени.</target>
        </trans-unit>
        <trans-unit id="c187385279c8ededa5efc4f1fe03ebf17e729283" translate="yes" xml:space="preserve">
          <source>However mechanical physics give us some goodies as well. We are not limited to move at most one sock with an arm. We can move a whole couple of them at once.</source>
          <target state="translated">Однако,механическая физика тоже дает нам некоторые лакомства.Мы не ограничиваемся перемещением максимум одного носка с рукой.Мы можем переместить сразу целую пару.</target>
        </trans-unit>
        <trans-unit id="4eb82567512fc8943c9bca03d3dcc2dfbfc9658a" translate="yes" xml:space="preserve">
          <source>However, as this have simillar complexity as selection sort, the time taken is far less due to the speeds of I/O(moving socks) and search(searching the line for a sock).</source>
          <target state="translated">Однако,так как это имеет симулярную сложность в качестве сортировки селекции,время,необходимое для этого,намного меньше из-за скоростей IO(перемещение носков)и поиска (поиск линии для носка).</target>
        </trans-unit>
        <trans-unit id="2e5ae82866972c6fb5d15e4d37146f8fd8f90802" translate="yes" xml:space="preserve">
          <source>Human beings will use various strategies to effect these. &lt;a href=&quot;http://garfield.library.upenn.edu/classics1979/A1979HX09600001.pdf&quot;&gt;Human memory &lt;em&gt;is&lt;/em&gt; associative&lt;/a&gt;, something like a hash table where feature sets of stored values are paired with the corresponding values themselves. For example, the concept of &quot;red car&quot; maps to all the red cars a person is capable of remembering. Someone with a perfect memory has a perfect mapping.  Most people are imperfect in this regard (and most others).  The associative map has a limited capacity. Mappings may &lt;em&gt;bleep&lt;/em&gt; out of existence under various circumstances (one beer too many), be recorded in error (&quot;I though her name was Betty, not Nettie&quot;), or never be overwritten even though we observe that the truth has changed (&quot;dad's car&quot; evokes &quot;orange Firebird&quot; when we actually knew he'd traded that in for the red Camaro).</source>
          <target state="translated">Люди будут использовать различные стратегии для достижения этих целей. &lt;a href=&quot;http://garfield.library.upenn.edu/classics1979/A1979HX09600001.pdf&quot;&gt;Человеческая память &lt;em&gt;является&lt;/em&gt; ассоциативной&lt;/a&gt; , что-то вроде хеш-таблицы, в которой наборы функций сохраненных значений связаны с соответствующими значениями. Например, понятие &amp;laquo;красная машина&amp;raquo; отображает все красные машины, которые человек способен запомнить. У кого-то с прекрасной памятью есть прекрасное отображение. Большинство людей несовершенны в этом отношении (и большинство других). Ассоциативная карта имеет ограниченную емкость. Сопоставления могут &lt;em&gt;исчезать&lt;/em&gt; при различных обстоятельствах (одно пиво слишком много), записываться по ошибке (&amp;laquo;хотя ее звали Бетти, а не Нетти&amp;raquo;) или никогда не перезаписываться, даже если мы наблюдаем, что правда изменилась (&amp;laquo;папа машина &quot;вызывает&quot; оранжевую Жар-птицу &quot;, когда мы на самом деле знали, что он обменял ее на красный Камаро).</target>
        </trans-unit>
        <trans-unit id="be87a28a5429a75a2d77e39569b97b2cef88f1c6" translate="yes" xml:space="preserve">
          <source>Humans can win over CPU algorithms using the fact that &quot;finding a matching pair&quot; can be one operation for a set that isn't too big.</source>
          <target state="translated">Люди могут одержать победу над процессорными алгоритмами,используя тот факт,что &quot;поиск подходящей пары&quot; может быть одной операцией для не слишком большого набора.</target>
        </trans-unit>
        <trans-unit id="b1ed976246d93e04e79fea702823d280ba48c2ad" translate="yes" xml:space="preserve">
          <source>I came out with another solution which would not promise fewer operations, neither less time consumption, but it should be tried to see if it can be a good-enough heuristic to provide less time consumption in huge series of sock pairing.</source>
          <target state="translated">Я вышел с другим решением,которое не обещало бы меньшее количество операций,ни меньшее потребление времени,но следует попытаться понять,может ли оно быть достаточно эвристическим,чтобы обеспечить меньшее потребление времени в огромной серии носковых пар.</target>
        </trans-unit>
        <trans-unit id="b0d5c8c30ccdae2afc794d4c2db85857ecf68b61" translate="yes" xml:space="preserve">
          <source>I do that every morning and rarely need more than three draws - but I have &lt;code&gt;n&lt;/code&gt; similar pairs (around 10, give or take the lost ones) of &lt;code&gt;m&lt;/code&gt; shaped white socks. Now you can estimate the size of my stack of stocks :-)</source>
          <target state="translated">Я делаю это каждое утро и редко нуждаюсь в более чем трех розыгрышах - но у меня есть &lt;code&gt;n&lt;/code&gt; одинаковых пар (около 10, дайте или возьмите потерянные) белых носков в форме &lt;code&gt;m&lt;/code&gt; . Теперь вы можете оценить размер моего стека акций :-)</target>
        </trans-unit>
        <trans-unit id="b28189bbbd02c084d10ef3c4022c033ec385886f" translate="yes" xml:space="preserve">
          <source>I do this by:</source>
          <target state="translated">Я делаю это:</target>
        </trans-unit>
        <trans-unit id="f58214503dfea8f36b2d81a7d7e31591c0696f80" translate="yes" xml:space="preserve">
          <source>I found integrating the process of sorting into hanging to dry makes it a breeze. I need to pick up each sock anyway, and hang it (move) and it costs me about nothing to hang it in a specific place on the strings. Now just not to force search of the whole buffer (the strings) I choose to place socks by color/shade. Darker left, brighter right, more colorful front etc. Now before I hang each sock, I look in its &quot;right vicinity&quot; if a matching one is there already - this limits &quot;scan&quot; to 2-3 other socks - and if it is, I hang the other one right next to it. Then I roll them into pairs while removing from the strings, when dry.</source>
          <target state="translated">Я обнаружил,что интеграция процесса сортировки в подвешивание для высыхания делает его ветер.Мне все равно нужно поднять каждый носок и повесить его (двигаться),и это ничего не стоит,чтобы повесить его в определенном месте на струнах.Теперь просто,чтобы не заставлять искать весь буфер (струны),я выбираю размещение носков по цветовому оттенку.Более темный левый,более яркий правый,более красочный фронт и т.д.Теперь перед тем,как повесить каждый носок,я смотрю в его &quot;правую окрестность&quot;,если уже есть подходящий-это ограничивает &quot;сканирование&quot; до 2-3 других носков-и если он есть,я вешаю другой прямо рядом с ним.Затем,когда они высохнут,я скатываю их в пары при снятии с струн,когда они высохнут.</target>
        </trans-unit>
        <trans-unit id="2af9d76529a0f3da9452d50f18323e0df517ebc3" translate="yes" xml:space="preserve">
          <source>I had derived this as a part of another puzzle,but I would be happy to be proven wrong. 
&lt;a href=&quot;https://appolo85.wordpress.com/2012/07/25/some-fun-with-hash-table-performance-analysis/&quot;&gt;Here's my blog article on the same&lt;/a&gt;</source>
          <target state="translated">Я получил это как часть другой загадки, но я был бы счастлив оказаться неправым. &lt;a href=&quot;https://appolo85.wordpress.com/2012/07/25/some-fun-with-hash-table-performance-analysis/&quot;&gt;Вот моя статья в блоге на том же&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d670bfbf52f40edfc5d3d99f6588d8b35cfcbaa" translate="yes" xml:space="preserve">
          <source>I have taken simple steps to reduce my effort into a process taking O(1) time.</source>
          <target state="translated">Я предпринял простые шаги,чтобы сократить свои усилия в процессе,который занимает время O(1).</target>
        </trans-unit>
        <trans-unit id="6f7a73657ec6fa088026a984672b83ade80856e7" translate="yes" xml:space="preserve">
          <source>I hope I can contribute something new to this problem. I noticed that all of the answers neglect the fact that there are two points where you can perform &lt;strong&gt;preprocessing&lt;/strong&gt;, without slowing down your overall laundry performance.</source>
          <target state="translated">Я надеюсь, что смогу внести что-то новое в эту проблему. Я заметил, что во всех ответах игнорируется тот факт, что есть две точки, в которых вы можете выполнить &lt;strong&gt;предварительную обработку&lt;/strong&gt; , не снижая общую производительность стирки.</target>
        </trans-unit>
        <trans-unit id="712bf975bcdafbec473428cad084553f88032e4b" translate="yes" xml:space="preserve">
          <source>I know that these algorithms take a lot of assumptions: a bin which acts as some sort of LIFO stack, a limited, normal washing machine, and a limited, normal clothesline - but this still works with very large numbers of socks.</source>
          <target state="translated">Я знаю,что эти алгоритмы берут много предположений:мусорное ведро,которое действует как своего рода LIFO стопка,ограниченная,нормальная стиральная машина,и ограниченная,нормальная бельевая веревка-но это все равно работает с очень большим количеством носков.</target>
        </trans-unit>
        <trans-unit id="76250d1db233c115621eea33b2e23f2fa2575836" translate="yes" xml:space="preserve">
          <source>I should point out that in order to improve the speed of the remaining steps, it is wise not to randomly pick the next sock, but to sequentially take sock after sock from each cluster.
Both preprocessing steps don't take more time than just putting the socks on the line or in the basket, which we have to do no matter what, so this should greatly enhance the laundry performance.</source>
          <target state="translated">Следует отметить,что для того,чтобы увеличить скорость оставшихся шагов,разумно не выбирать случайным образом следующий носок,а последовательно брать носок за носком из каждого кластера.Оба этапа предварительной обработки не занимают больше времени,чем просто положить носки на линию или в корзину,что мы должны сделать несмотря ни на что,так что это должно значительно повысить производительность белья.</target>
        </trans-unit>
        <trans-unit id="059e704445c273ca6d35e7eca97772e45a2005db" translate="yes" xml:space="preserve">
          <source>I think that there should be an Omega(n&lt;sup&gt;2&lt;/sup&gt;) bound for the original problem if you allow equality tests only. My intuition is: Consider a graph where you add an edge after a test, and argue that if the graph is not dense the output is not uniquely determined.</source>
          <target state="translated">Я думаю, что для исходной задачи должна быть оценка Omega (n &lt;sup&gt;2&lt;/sup&gt; ), если вы разрешаете только тесты на равенство. Моя интуиция такова: рассмотрим график, в который вы добавляете ребро после теста, и утверждайте, что если график не плотный, выходной результат определяется не однозначно.</target>
        </trans-unit>
        <trans-unit id="efa09f0b1f8cd3ce6a3acb81e6f0774e3942dc69" translate="yes" xml:space="preserve">
          <source>I will appreciate an answer that addresses the following aspects:</source>
          <target state="translated">Я буду признателен за ответ,в котором рассматриваются следующие аспекты:</target>
        </trans-unit>
        <trans-unit id="b480ebea69ff0685142986485477474b5d752c12" translate="yes" xml:space="preserve">
          <source>I'm looking forward to hear about any experiences or corrections.</source>
          <target state="translated">Я с нетерпением жду любых переживаний или исправлений.</target>
        </trans-unit>
        <trans-unit id="7e3fa720280a90386643c5f943bbc31f1027bcda" translate="yes" xml:space="preserve">
          <source>I've finished pairing my socks just right now, and I found that the best way to do it is the following:</source>
          <target state="translated">Я только что закончил пару носков и обнаружил,что лучший способ сделать это-это следующее:</target>
        </trans-unit>
        <trans-unit id="b298e00cd80e135c4ae40839f21a896eee2181a4" translate="yes" xml:space="preserve">
          <source>If &quot;index&quot; is greater then 2 (this could be value dependent on sock
 number because with greater number of socks there are less chance to
  pair them blindly) go to 11</source>
          <target state="translated">Если &quot;индекс&quot; больше 2 (это может быть значение,зависящее от номера носка,потому что при большем количестве носков меньше шансов соединить их вслепую)переходим к 11</target>
        </trans-unit>
        <trans-unit id="428e83ad437da92aef4bb4acff910ff3919184bd" translate="yes" xml:space="preserve">
          <source>If each sock had an integer called &quot;PairID&quot; one could easily distribute them into 10 buckets according to &lt;code&gt;PairID % 10&lt;/code&gt; (the last digit).</source>
          <target state="translated">Если бы у каждого носка было целое число с именем &amp;laquo;PairID&amp;raquo;, можно было бы легко распределить их по 10 сегментам в соответствии с &lt;code&gt;PairID % 10&lt;/code&gt; (последняя цифра).</target>
        </trans-unit>
        <trans-unit id="68824b3b629564ab1d8b0bad06e1c81bc8489125" translate="yes" xml:space="preserve">
          <source>If match found pair it, pack pair and move it to the &quot;matched&quot; pile</source>
          <target state="translated">Если найдена подходящая пара,упакуйте ее и переместите в &quot;подходящую&quot; кучу.</target>
        </trans-unit>
        <trans-unit id="b8510e4192393a95bad638ba90d06ef53c82e071" translate="yes" xml:space="preserve">
          <source>If the &quot;move&quot; operation is fairly expensive, and the &quot;compare&quot; operation is cheap, and you need to move the whole set anyway, into a buffer where search is much faster than in original storage... just integrate sorting into the obligatory move.</source>
          <target state="translated">Если операция &quot;переместить&quot; достаточно дорогая,а операция &quot;сравнить&quot; дешевая,и вам все равно нужно переместить весь набор,в буфер,где поиск происходит намного быстрее,чем в оригинальном хранилище...просто интегрируйте сортировку в обязательный ход.</target>
        </trans-unit>
        <trans-unit id="9b3e803c4a76f4c4bd7562f58a50ba5f385ebf8f" translate="yes" xml:space="preserve">
          <source>If the next one is the pair of the previous one, then put it to the existing bucket, otherwise create a new one.</source>
          <target state="translated">Если следующий-это пара предыдущего,то положите его в существующее ведро,в противном случае создайте новое.</target>
        </trans-unit>
        <trans-unit id="4a8ea1dd91e78f2f6ed036a3127326ca0c1544c5" translate="yes" xml:space="preserve">
          <source>If there are less then 6 socks, go to 11.</source>
          <target state="translated">Если там меньше 6 носков,переходите к 11.</target>
        </trans-unit>
        <trans-unit id="5101d1843bf2d194d47695b1f7bbc961cb8fc0b4" translate="yes" xml:space="preserve">
          <source>If there are still more then one socks go to 12</source>
          <target state="translated">Если их еще больше,то один носок до 12.</target>
        </trans-unit>
        <trans-unit id="b79f9eb2311d2f31b42294fff21e572d50944666" translate="yes" xml:space="preserve">
          <source>If there is just one left go to 14</source>
          <target state="translated">Если остался только один,переходите к 14.</target>
        </trans-unit>
        <trans-unit id="0580e1c44a88013044e269db8383aef639694455" translate="yes" xml:space="preserve">
          <source>If there is no match, put it on the &quot;missing&quot; pile.</source>
          <target state="translated">Если совпадений нет,положите его на &quot;недостающую&quot; кучу.</target>
        </trans-unit>
        <trans-unit id="a78596387c9d98455857ff9c74f61a0ca08821df" translate="yes" xml:space="preserve">
          <source>If there is no pair for the sock, move it to the &quot;missing&quot; pile</source>
          <target state="translated">Если для носка нет пары,переместите его в &quot;недостающую&quot; кучу.</target>
        </trans-unit>
        <trans-unit id="c1faf9fe0339936f19f4a80510b7ee0dc13723d0" translate="yes" xml:space="preserve">
          <source>If we assume normal distribution, then the estimated number of 'insertions'  to have atleast one sock mapped to one bucket is NlogN  (ie, all buckets are full)</source>
          <target state="translated">Если мы предположим нормальное распределение,то предполагаемое количество &quot;вставок&quot;,чтобы один носок был привязан к одному ведру,будет NlogN (т.е.все ведра заполнены).</target>
        </trans-unit>
        <trans-unit id="7fee5c386c3eac901a5e47b38f613ae422e201ea" translate="yes" xml:space="preserve">
          <source>If you can pick a limited number of attributes, but enough attributes that can uniquely identify each pair, you should be done in O(k * n), which is O(n) if we can consider k is limited.</source>
          <target state="translated">Если вы можете выбрать ограниченное количество атрибутов,но достаточно атрибутов,которые могут однозначно идентифицировать каждую пару,вы должны сделать это в O(k*n),то есть в O(n),если мы можем считать k ограниченным.</target>
        </trans-unit>
        <trans-unit id="362a61837395e933805325f6b6ebe951c78dd045" translate="yes" xml:space="preserve">
          <source>If you chose a fancy pair with different left and right sock, doing a full bucket sort to left and right foot buckets take O(N+M), where N is the number of socks and M is same as above. Somebody else can give the formula for average iterations of finding the first pair, but worst case for finding a pair with blind search is N/2+1, which becomes astronomically unlikely case for reasonable N. This can be sped up by using advanced image recognition algorithms and heuristics, when scanning the pile of unsorted socks with &lt;a href=&quot;http://www.urbandictionary.com/define.php?term=Mk1%20eyeball&quot;&gt;Mk1 Eyeball&lt;/a&gt;.</source>
          <target state="translated">Если вы выбрали причудливую пару с разными левыми и правыми носками, для полной сортировки ведер по левому и правому ведрам потребуется O (N + M), где N - количество носков, а M такое же, как указано выше. Кто-то другой может дать формулу для средних итераций нахождения первой пары, но наихудшим случаем для нахождения пары с слепым поиском является N / 2 + 1, что становится астрономически маловероятным для разумного N. Это можно ускорить, используя расширенное изображение. алгоритмы распознавания и эвристика, при сканировании стопки несортированных носков с помощью &lt;a href=&quot;http://www.urbandictionary.com/define.php?term=Mk1%20eyeball&quot;&gt;Mk1 Eyeball&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14a24a331e031cc668435241346b7c07a641d7fb" translate="yes" xml:space="preserve">
          <source>If you do not, put the current sock into the first open slot in the array.</source>
          <target state="translated">Если нет,то поместите текущий носок в первый открытый слот массива.</target>
        </trans-unit>
        <trans-unit id="71950a186d51133a9e0950587efebd65ce355f77" translate="yes" xml:space="preserve">
          <source>If you find an acceptable match, put both socks together and remove them from the array.</source>
          <target state="translated">Если вы нашли приемлемое совпадение,сложите оба носка вместе и удалите их из массива.</target>
        </trans-unit>
        <trans-unit id="6f824c95564ff831ff4658d289a3cc3fbd50a604" translate="yes" xml:space="preserve">
          <source>If you have 1000 socks, with 8 colors and an average distribution, you can make 4 piles of each 125 socks in c*n time. With a threshold of 5 socks you can sort every pile in 6 runs. (Counting 2 seconds to throw a sock on the right pile it will take you little under 4 hours.)</source>
          <target state="translated">Если у вас 1000 носков,с 8 цветами и средним распределением,вы можете сделать 4 сваи из каждых 125 носков в c*n времени.При пороге 5 носков вы можете отсортировать каждую кучу за 6 прогонов.(Считая 2 секунды,чтобы бросить носок на нужную кучу,это займет у вас чуть меньше 4 часов).</target>
        </trans-unit>
        <trans-unit id="e6180d90736fe61c2fee7b217194e6e292349b2c" translate="yes" xml:space="preserve">
          <source>If you have just 60 socks, 3 colors and 2 sort of socks (yours / your wife's) you can sort every pile of 10 socks in 1 runs (Again threshold = 5). (Counting 2 seconds it will take you 2 min).</source>
          <target state="translated">Если у вас всего 60 носков,3 цвета и 2 вида носков (у вашей жены),вы можете отсортировать каждую кучу из 10 носков за 1 прогон (опять же порог=5).(Счет 2 секунды займет у вас 2 минуты).</target>
        </trans-unit>
        <trans-unit id="1642673d491acf03991115db1b99d02263fa0f61" translate="yes" xml:space="preserve">
          <source>If you have one or more selected unpaired socks, check your current sock against all the unpaired socks in the array.</source>
          <target state="translated">Если у вас один или несколько выбранных непарных носков,проверьте текущий носок на наличие всех непарных носков в массиве.</target>
        </trans-unit>
        <trans-unit id="f56085360df34e1a4ad17c6698a237315bf8ce9d" translate="yes" xml:space="preserve">
          <source>In computer science this can be helpful:
We have a collection of n &lt;em&gt;things&lt;/em&gt;, an order on them (length) and also an equivalence relation (extra information, for example the color of socks). The equivalence relation allows us to make a partition of the original collection, and in every equivalence class our order is still maintained. The mapping of a &lt;em&gt;thing&lt;/em&gt; to it's equivalence class can be done in O(1), so only O(n) is needed to assign each item to a class. Now we have used our extra information and can proceed in any manner to sort every class. The advantage is that the data sets are already significantly smaller.</source>
          <target state="translated">В информатике это может быть полезно: у нас есть коллекция из n &lt;em&gt;вещей&lt;/em&gt; , порядок их (длина), а также отношение эквивалентности (дополнительная информация, например, цвет носков). Отношение эквивалентности позволяет нам сделать разбиение исходной коллекции, и в каждом классе эквивалентности наш порядок все еще сохраняется. Сопоставление &lt;em&gt;вещи&lt;/em&gt; с ее классом эквивалентности может быть выполнено в O (1), поэтому для присвоения каждого элемента классу требуется только O (n). Теперь мы использовали нашу дополнительную информацию и можем отсортировать каждый класс любым способом. Преимущество состоит в том, что наборы данных уже значительно меньше.</target>
        </trans-unit>
        <trans-unit id="95707802ab9dca781a74e6e8993e4a31c2c6a26e" translate="yes" xml:space="preserve">
          <source>In order to say how efficient it is to pair socks from a pile, we have to define the machine first, because the pairing isn't done whether by a turing nor by a random access machine, which are normally used as the basis for an algorithmic analysis.</source>
          <target state="translated">Для того,чтобы сказать,насколько эффективным является сопряжение носков из кучи,мы должны сначала определить машину,потому что сопряжение не осуществляется ни машиной turing,ни машиной со случайным доступом,которые обычно используются в качестве основы алгоритмического анализа.</target>
        </trans-unit>
        <trans-unit id="cb70cb2a381a9804b33c37786ed6892de88e1933" translate="yes" xml:space="preserve">
          <source>In the case of socks, perfect recall means looking at a sock &lt;code&gt;s&lt;/code&gt; always produces the memory of its sibling &lt;code&gt;t&lt;/code&gt;, including enough information (where it is on the ironing board) to locate &lt;code&gt;t&lt;/code&gt; in constant time.  A person with photographic memory accomplishes both 1 and 2 in constant time without fail.</source>
          <target state="translated">В случае носков, идеальный отзыв означает, что взгляд на носок &lt;code&gt;s&lt;/code&gt; всегда производит память его родного &lt;code&gt;t&lt;/code&gt; , включая достаточно информации (где она находится на гладильной доске), чтобы найти &lt;code&gt;t&lt;/code&gt; в постоянном времени. Человек с фотографической памятью обязательно выполняет и 1, и 2 за постоянное время</target>
        </trans-unit>
        <trans-unit id="4d3725e32aaeb21f7a9e8878c8079a2ecffbc7fb" translate="yes" xml:space="preserve">
          <source>In the worst case it means that you will have n/2 different buckets, and you will have n-2 determinations about that which bucket contains the pair of the current sock. Obviously, this algorithm works well if you have just a few pairs; I did it with 12 pairs.</source>
          <target state="translated">В худшем случае это означает,что у вас будет n2 разных ведра,и у вас будет n-2 определения о том,какое ведро содержит пару текущего носка.Очевидно,что этот алгоритм хорошо работает,если у вас всего несколько пар;я сделал это с 12 парами.</target>
        </trans-unit>
        <trans-unit id="aa2dcdaf17722e129a20d19adefefc64c27ec3f1" translate="yes" xml:space="preserve">
          <source>Is it equivalent to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;element distinctness problem&lt;/a&gt;?</source>
          <target state="translated">Это эквивалентно &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;проблеме отличимости элемента&lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="27a7682059354d7267300e1425434e6ec790e624" translate="yes" xml:space="preserve">
          <source>It is not so scientific, but it works well:)</source>
          <target state="translated">Это не так научно,но работает хорошо:)</target>
        </trans-unit>
        <trans-unit id="d923e9762ba91638d0414fad059bf2a39ed51197" translate="yes" xml:space="preserve">
          <source>It is possible to separate socks into general classes or types (white/black, ankle/crew, athletic/dress) when building your array, and &quot;drill-down&quot; to only compare like-for-like.</source>
          <target state="translated">При построении массива можно разделить носки на общие классы или типы (белый черный,лодыжка,спортивный костюм),и &quot;сверлить&quot;,чтобы сравнить только похожие на &quot;like-for-like&quot;.</target>
        </trans-unit>
        <trans-unit id="84b3dca37c877454cf4abb0e807d969bb8f0399f" translate="yes" xml:space="preserve">
          <source>It obviously requires some extra work to check if there is the matching sock already hanging somewhere and it would render solution &lt;code&gt;O(n^2)&lt;/code&gt; with coefficient about &lt;code&gt;1/2&lt;/code&gt; for a computer. But in this case the &quot;human factor&quot; is actually an advantage -- I usually can very quickly (almost &lt;code&gt;O(1)&lt;/code&gt;) identify the matching sock if it was already hung (probably some imperceptible in-brain caching is involved) -- consider it a kind of limited &quot;oracle&quot; as in &lt;a href=&quot;http://en.wikipedia.org/wiki/Oracle_machine&quot;&gt;Oracle Machine&lt;/a&gt; ;-) We, the humans have these advantages over digital machines in some cases ;-)</source>
          <target state="translated">Очевидно, что требуется дополнительная работа, чтобы проверить, есть ли где-нибудь висящий соответствующий носок, и это даст решение &lt;code&gt;O(n^2)&lt;/code&gt; с коэффициентом около &lt;code&gt;1/2&lt;/code&gt; для компьютера. Но в этом случае &amp;laquo;человеческий фактор&amp;raquo; на самом деле является преимуществом - я обычно могу очень быстро (почти &lt;code&gt;O(1)&lt;/code&gt; ) идентифицировать соответствующий носок, если он уже был подвешен (возможно, имеет место некоторое незаметное кэширование в мозге) - рассмотрим это своего рода ограниченный &amp;laquo;оракул&amp;raquo;, как в &lt;a href=&quot;http://en.wikipedia.org/wiki/Oracle_machine&quot;&gt;Oracle Machine&lt;/a&gt; ;-) Мы, люди, в некоторых случаях имеем эти преимущества перед цифровыми машинами ;-)</target>
        </trans-unit>
        <trans-unit id="39b5cd62e349d68c400a20da1e370efb8e1fc33f" translate="yes" xml:space="preserve">
          <source>It scales nearly indefinitely if &lt;strong&gt;each worker has its own set of piles&lt;/strong&gt;. Workers can then take big chunks of socks from the input basket (very little contention as they are doing it rarely) and they do not need to synchronise when distributing the socks at all (because they have thread-local piles). At the end, all workers need to union their pile-sets. I believe that can be done in O(log (worker count * piles per worker)) if the workers form an &lt;strong&gt;aggregation tree&lt;/strong&gt;.</source>
          <target state="translated">Он масштабируется почти до бесконечности, если у &lt;strong&gt;каждого работника свой набор свай&lt;/strong&gt; . Затем работники могут взять большие куски носков из входной корзины (очень мало споров, поскольку они делают это редко), и им вообще не нужно синхронизироваться при распределении носков (потому что они имеют локальные сваи). В конце все рабочие должны объединить свои наборы груды. Я считаю, что это можно сделать в O (журнал (количество рабочих * свай на одного рабочего)), если рабочие формируют &lt;strong&gt;дерево агрегации&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="150b46cd8303cca0bd34d1940b0ec0aedbf08053" translate="yes" xml:space="preserve">
          <source>It's better if there's no difference between left and right foot socks, but it's not critical. If socks are left-right symmetrical, finding a pair is O(1) operation, and sorting the socks is approximate O(M) operation, where M is the number of places in your house, which you have littered with socks, ideally some small constant number.</source>
          <target state="translated">Лучше,если нет разницы между носками для левой и правой ноги,но это не критично.Если носки левой и правой симметричны,то нахождение пары является операцией O(1),а сортировка носков-это приблизительная операция O(M),где M-это количество мест в вашем доме,которое вы замусорили носками,в идеале-какое-то небольшое постоянное число.</target>
        </trans-unit>
        <trans-unit id="2f22939c37ecaebbcccfa9e1a61cd5e27c5cb274" translate="yes" xml:space="preserve">
          <source>It's often good to take a step back, and think a way around the problem.</source>
          <target state="translated">Часто хорошо сделать шаг назад,и подумать о том,как обойти проблему.</target>
        </trans-unit>
        <trans-unit id="150a08322f1488dee4632ea6718c405d63b39b1c" translate="yes" xml:space="preserve">
          <source>Iterate over each pile and &lt;strong&gt;distribute it by some other metric&lt;/strong&gt; (e.g. pattern) into the second set of piles</source>
          <target state="translated">Выполните итерацию по каждой стопке и &lt;strong&gt;распределите ее по некоторой другой метрике&lt;/strong&gt; (например, по шаблону) во второй набор стопок.</target>
        </trans-unit>
        <trans-unit id="5efd484584a49caf169c4dda344e416b18649fb1" translate="yes" xml:space="preserve">
          <source>Keep randomly picking socks from the stack and compare to your 5+1 socks for a match. As your stack grows, it will reduce your performance but raise your odds. Much faster.</source>
          <target state="translated">Выбирайте носки из стопки случайным образом и сравнивайте их с Вашими носками 5+1 за матч.По мере роста Вашей стопки,это уменьшит Вашу производительность,но увеличит Ваши шансы.Гораздо быстрее.</target>
        </trans-unit>
        <trans-unit id="1ca7ccdd0b7ccddb659ecda67d1ece6e151b36ca" translate="yes" xml:space="preserve">
          <source>Let 'N' correspond to an approximate upper-bound on the number of  number of unique colors/pattern of socks that you have.</source>
          <target state="translated">Пусть 'N' соответствует приблизительному верхнему пределу по количеству уникальных цветовых оттенков носков,которые у вас есть.</target>
        </trans-unit>
        <trans-unit id="780bea650a8fdf34a596a74ddbd5fc938d04c33f" translate="yes" xml:space="preserve">
          <source>My algorithm:</source>
          <target state="translated">Мой алгоритм:</target>
        </trans-unit>
        <trans-unit id="74beaf9107fc04b7777303cee699390003158c90" translate="yes" xml:space="preserve">
          <source>My solution does not exactly correspond to your requirements, as it formally requires &lt;code&gt;O(n)&lt;/code&gt; &quot;extra&quot; space. However, considering my conditions it is very efficient in my practical application. Thus I think it should be interesting.</source>
          <target state="translated">Мое решение не совсем соответствует вашим требованиям, так как формально требует &lt;code&gt;O(n)&lt;/code&gt; &amp;laquo;дополнительного&amp;raquo; пространства. Однако, учитывая мои условия, это очень эффективно в моем практическом применении. Таким образом, я думаю, что это должно быть интересно.</target>
        </trans-unit>
        <trans-unit id="5975233f2cbc212e70e2408f533f6faa08e21eb5" translate="yes" xml:space="preserve">
          <source>Now look for a match (visual pattern matching - humans are good at that with a small stack) inside the five you drew, if you don't find one, then add that to your five.</source>
          <target state="translated">Теперь ищите совпадение (визуальное совпадение по шаблону-у людей это хорошо получается с небольшим стеком)внутри пятерки,которую вы нарисовали,если вы ее не найдете,то добавьте ее к пятерке.</target>
        </trans-unit>
        <trans-unit id="a7486cfa8083fe6f612df25745068a14a1cac68b" translate="yes" xml:space="preserve">
          <source>Now the computer science in this problem is all about the steps</source>
          <target state="translated">Теперь компьютерная наука в этой проблеме-это все шаги.</target>
        </trans-unit>
        <trans-unit id="870cccf30184352ba6b4960824e58b1bdd6d8989" translate="yes" xml:space="preserve">
          <source>Now the next question is simply whether you do your own laundry and your wife does hers. That is a problem likely in an &lt;strong&gt;entirely different domain of problems&lt;/strong&gt;. :)</source>
          <target state="translated">Теперь следующий вопрос - просто ли вы стираете самостоятельно, а ваша жена занимается стиркой? Это проблема, вероятно, в &lt;strong&gt;совершенно другой области проблем&lt;/strong&gt; . :)</target>
        </trans-unit>
        <trans-unit id="e3d8d0fe5c35ea409447bff57847e6fc8b0f8f6d" translate="yes" xml:space="preserve">
          <source>Now this may not seem all that different from &quot;forming piles by color&quot; suggested by top answers but first, by not picking discrete piles but ranges, I have no problem classifying whether &quot;purple&quot; goes to &quot;red&quot; or &quot;blue&quot; pile; it just goes between. And then by integrating two operations (hang to dry and sort) the overhead of sorting while hanging is like 10% of what separate sorting would be.</source>
          <target state="translated">Теперь это может показаться не все,что отличается от &quot;формирования свай по цвету&quot;,предложенный верхней ответы,но,во-первых,не выбирая дискретных свай,но диапазоны,у меня нет проблем классификации ли &quot;фиолетовый&quot; идет на &quot;красный&quot; или &quot;синий&quot; ворс,он просто идет между ними.А затем,объединив две операции (повесить,чтобы высохнуть и сортировать),накладные расходы на сортировку в то время как повесить составляет около 10% от того,что отдельная сортировка будет.</target>
        </trans-unit>
        <trans-unit id="37e05d152e6390b47f7a7dde92949ba55f30e47c" translate="yes" xml:space="preserve">
          <source>Once you have a collision(a.k.a  : a match) simply remove that pair of socks. 
 Repeat the same experiment with the next batch of NlogN socks. 
The beauty of it is that you could be making NlogN parallel comparisons(collision-resolution) because of the way the human mind works.  :-)</source>
          <target state="translated">После столкновения(a.k.a:a match)просто снимите эту пару носков.Повторите этот же эксперимент со следующей партией носков NlogN.Прелесть заключается в том,что вы можете делать NlogN параллельные сравнения(столкновение-разрешение)из-за того,как работает человеческий разум.:-)</target>
        </trans-unit>
        <trans-unit id="11a98af1a6e5c195360f3f6c711227cc208dadd9" translate="yes" xml:space="preserve">
          <source>Operation 4 is necessary, because when spreading socks over the floor some socks may hide others. Here is the analysis of the algorithm:</source>
          <target state="translated">Эксплуатация 4 необходима,так как при разбрасывании носков по полу одни носки могут спрятать другие.Предлагаем вашему вниманию анализ алгоритма:</target>
        </trans-unit>
        <trans-unit id="af6924e29957fb8b52cc30183bb2138601d75b4d" translate="yes" xml:space="preserve">
          <source>Optionally to step one, you pick up two sock from that line instead of two, as the caching memory is large enough we can quickly identify if either sock matches the current one on the line you are observing. If you are fortunate enough to have three arms, you could possibly parse three socks at the same time given that the memory of the subject is large enough.</source>
          <target state="translated">Дополнительно к первому шагу вы берете два носка из этой строки,а не два,так как кэшируемая память достаточно велика,мы можем быстро определить,соответствует ли любой носок текущему на наблюдаемой вами строке.Если вам повезло,что у вас три руки,вы можете разобрать три носка одновременно,учитывая,что память предмета достаточно велика.</target>
        </trans-unit>
        <trans-unit id="77783bef2624f9f540cadff73ba6528b5aae021a" translate="yes" xml:space="preserve">
          <source>Oracle Machine is Better ;-)</source>
          <target state="translated">Машина Oracle лучше ;-)</target>
        </trans-unit>
        <trans-unit id="f28b38127d74eab7d9b41752145290a2fc0d5c89" translate="yes" xml:space="preserve">
          <source>Order the socks!</source>
          <target state="translated">Закажите носки!</target>
        </trans-unit>
        <trans-unit id="8c33de1b8688b9c866607960966f014e14b6a01b" translate="yes" xml:space="preserve">
          <source>Other than that, I cannot think of anything, but this method does seem to be pretty efficient in real life. :)</source>
          <target state="translated">Кроме этого,я ничего не могу придумать,но этот метод,похоже,довольно эффективен в реальной жизни.:)</target>
        </trans-unit>
        <trans-unit id="02341ed9b2710f0b78051065b72a305737d20c68" translate="yes" xml:space="preserve">
          <source>Our two preprocessing stages are &quot;putting the socks on the clothesline&quot; and &quot;Taking the socks from the clothesline&quot;, which we have to do, in order to get socks which are not only clean but also dry. As with washing machines, clotheslines are finite, and I assume that we have the whole part of the line where we put our socks in sight.</source>
          <target state="translated">Два наших этапа предварительной обработки-это &quot;надевание носков на бельевую веревку&quot; и &quot;снятие носков с бельевой веревки&quot;,что мы должны сделать,чтобы получить носки,которые не только чистые,но и сухие.Как и в случае со стиральными машинами,бельевые веревки конечны,и я предполагаю,что у нас есть вся часть линии,на которую мы ставим носки.</target>
        </trans-unit>
        <trans-unit id="dd7e7c37ececf846bbc91969c59fe7ec34aa06d6" translate="yes" xml:space="preserve">
          <source>Pair blindly all socks to its neighbor (do not pack it)</source>
          <target state="translated">Слепо пару носков к соседу (не паковать).</target>
        </trans-unit>
        <trans-unit id="567d945bb762f9218b71f65d131b602db30011d2" translate="yes" xml:space="preserve">
          <source>Pick a sock</source>
          <target state="translated">Выбери носок</target>
        </trans-unit>
        <trans-unit id="b3134987842b8171f3b2d20b9d928ea0449a744f" translate="yes" xml:space="preserve">
          <source>Pick any two of them to make a pair. Constant time.</source>
          <target state="translated">Выбери любых двоих,чтобы сделать пару.Постоянное время.</target>
        </trans-unit>
        <trans-unit id="e6ad43d89c0be2bb101bd954d77aea3f0c680af6" translate="yes" xml:space="preserve">
          <source>Pick the first sock in line, search along the line until it finds the corresponding sock.</source>
          <target state="translated">Выберите первый носок в линии,ищите по линии,пока не найдёте соответствующий носок.</target>
        </trans-unit>
        <trans-unit id="f15a45dc12d70436ea09baf6beeb9021651aff15" translate="yes" xml:space="preserve">
          <source>Pick two socks, place corresponding X sock in X line, and Y sock in Y line at next available position.</source>
          <target state="translated">Выберите два носка,поместите соответствующий носок Х в линию Х,и носок Y в линию Y на следующей доступной позиции.</target>
        </trans-unit>
        <trans-unit id="a42c6c1b50b0cb070b7169e8cfd43b7e499c1252" translate="yes" xml:space="preserve">
          <source>Pick up a first sock and place it on a table. Now pick another sock; if it matches the first picked, place it on top of the first. If not, place it on the table a small distance from the first. Pick a third sock; if it matches either of the previous two, place it on top of them or else place it a small distance from the third. Repeat until you have picked up all the socks.</source>
          <target state="translated">Возьми первый носок и положи его на стол.Теперь выберите другой носок;если он соответствует первому выбранному,положите его поверх первого.Если нет,положите его на стол на небольшом расстоянии от первого.Выберите третий носок;если он совпадает с одним из двух предыдущих,поместите его поверх них,либо поместите его на небольшое расстояние от третьего.Повторяйте до тех пор,пока не подберете все носки.</target>
        </trans-unit>
        <trans-unit id="49d4ff963ae4bca3c41a677fe2b8a4851f0dc095" translate="yes" xml:space="preserve">
          <source>Pick up one from the stack of 2n-5.</source>
          <target state="translated">Возьми одну из стопки 2n-5.</target>
        </trans-unit>
        <trans-unit id="38fc586cd4b8cb11aebfcde216a7bcd038fe8e83" translate="yes" xml:space="preserve">
          <source>Picking a distinctive sock (whatever catches my eye first in the pile).</source>
          <target state="translated">Выбирая отличительный носок (то,что первым бросается в глаза в куче).</target>
        </trans-unit>
        <trans-unit id="afb37a344e3ab2d134c35252ebd3afec24338844" translate="yes" xml:space="preserve">
          <source>Place the new sock near into the current pile, with a distance based on how different it is. If you find yourself putting the sock on top of another because it is identical, form the pair there, and remove them. This means that future comparisons take less effort to find the correct place.</source>
          <target state="translated">Поместите новый носок рядом с текущей кучей,с расстоянием,основанным на том,насколько он отличается.Если вы обнаружили,что кладете носок поверх другого,потому что он идентичен,сформируйте пару там,и удалите их.Это означает,что для будущих сравнений потребуется меньше усилий,чтобы найти правильное место.</target>
        </trans-unit>
        <trans-unit id="2f2ea3db77a1f1b6f771e24a207d47f22993a2ad" translate="yes" xml:space="preserve">
          <source>Problem solved. So, just get new socks, throw/donate your old ones away, and live happily ever after knowing you are saving money and time every day for the rest of your life.</source>
          <target state="translated">Проблема решена.Так что просто купите новые носки,выбросьте старые и живите долго и счастливо,зная,что вы каждый день экономите деньги и время до конца своей жизни.</target>
        </trans-unit>
        <trans-unit id="b052f937ed7ad2c7eefbe92ef78e1f1391ca53d4" translate="yes" xml:space="preserve">
          <source>Put into the corresponding finished line of socks.</source>
          <target state="translated">Положите в соответствующую готовую линию носков.</target>
        </trans-unit>
        <trans-unit id="e069c49edbed651dbec011e37b87b876f834afc4" translate="yes" xml:space="preserve">
          <source>Quickly make piles of easily distinguishable socks. (Say by color)</source>
          <target state="translated">Быстро делайте кучи легко различимых носков.(Скажем по цвету)</target>
        </trans-unit>
        <trans-unit id="e8562ec8764aff77d8738bd6121e9835eeba9b2f" translate="yes" xml:space="preserve">
          <source>Quicksort every pile and use the length of the sock for comparison. As a human you can make a fairly quick decision which sock to use to partition that avoids worst case. (You can see multiple socks in parallel, use that to your advantage!)</source>
          <target state="translated">Quicksort каждая куча и использовать длину носка для сравнения.Как человек,вы можете принять довольно быстрое решение,какой носок использовать для разбиения,что позволяет избежать худшего случая.(Вы можете видеть несколько носков параллельно,используйте это в своих интересах!).</target>
        </trans-unit>
        <trans-unit id="b577412dc9473d426d2ff6741d11dea5ca17a977" translate="yes" xml:space="preserve">
          <source>Real world approach:</source>
          <target state="translated">Подход в реальном мире:</target>
        </trans-unit>
        <trans-unit id="0bf66d17ab79cfe3be7fc141f104742b101b119a" translate="yes" xml:space="preserve">
          <source>Repeat from 1 until there are no socks on the floor.</source>
          <target state="translated">Повторяйте с 1 до тех пор,пока на полу нет носков.</target>
        </trans-unit>
        <trans-unit id="0081c3494d7d5f15ad3d0b6fd53ac547753f32ff" translate="yes" xml:space="preserve">
          <source>Repeat from 1. until there are no more most distinctive socks.</source>
          <target state="translated">Повторяйте с 1.до тех пор,пока не будет больше нет наиболее характерных носков.</target>
        </trans-unit>
        <trans-unit id="e491132f83030e4bf9e1aa6139496611dff2738e" translate="yes" xml:space="preserve">
          <source>Repeat from 2 until no pair can be made.</source>
          <target state="translated">Повторяйте с 2 до тех пор,пока ни одна пара не будет выполнена.</target>
        </trans-unit>
        <trans-unit id="f4ecdc41af265ed9bf91659fbd817baded2a6b44" translate="yes" xml:space="preserve">
          <source>Repeat with every sock.</source>
          <target state="translated">Повторяйте с каждым носком.</target>
        </trans-unit>
        <trans-unit id="2d3de6b4a64f840ca4b44c37b7e888adb2929c0e" translate="yes" xml:space="preserve">
          <source>Shuffle the rest</source>
          <target state="translated">Шаркайте остальное</target>
        </trans-unit>
        <trans-unit id="20968b695bdd0c1693e57dfce2b017887a96213f" translate="yes" xml:space="preserve">
          <source>Since all washing machines I know about are limited in size (regardless of how many socks you have to wash), and the actual randomizing occurs in the washing machine, no matter how many socks we have, we always have small subsets which contain almost no singletons.</source>
          <target state="translated">Так как все стиральные машины,о которых я знаю,ограничены в размерах (независимо от того,сколько носков нужно постирать),а фактическое рандомизирование происходит в стиральной машине,независимо от того,сколько носков у нас есть,у нас всегда есть небольшие подмножества,которые почти не содержат синглонов.</target>
        </trans-unit>
        <trans-unit id="20318f6c81a8cfa249bb075ab83674739820d4cc" translate="yes" xml:space="preserve">
          <source>Since you are interested in connections to element distinctness problem: proving the Omega(n log n) bound for element distinctness is harder, because the output is binary yes/no. Here, the output has to be a matching and the number of possible outputs suffices to get a decent bound. However, there's a variant connected to element distinctness. Suppose you are given 2n socks and wonder if they can be uniquely paired. You can get a reduction from ED by sending (a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;) to (a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;, a&lt;sub&gt;n&lt;/sub&gt;). (Parenthetically, the proof of hardness of ED is very interesting, &lt;a href=&quot;http://www.cs.dartmouth.edu/~ac/Teach/CS85-Spring08/lecnotes.pdf&quot;&gt;via topology&lt;/a&gt;.)</source>
          <target state="translated">Поскольку вас интересуют связи с проблемой отличимости элементов: доказать, что Omega (n log n) ограничен для отличимости элементов, сложнее, потому что выходные данные являются двоичными да / нет. Здесь выходные данные должны совпадать, а количество возможных выходных сигналов достаточно для получения достойной границы. Тем не менее, есть вариант, связанный с различимостью элементов. Предположим, вы получили 2n носков и задаетесь вопросом, могут ли они быть уникально спарены. Вы можете получить сокращение от ED, отправив (a &lt;sub&gt;1&lt;/sub&gt; , a &lt;sub&gt;2&lt;/sub&gt; , ..., a &lt;sub&gt;n&lt;/sub&gt; ) в (a &lt;sub&gt;1&lt;/sub&gt; , a &lt;sub&gt;1&lt;/sub&gt; , a &lt;sub&gt;2&lt;/sub&gt; , a &lt;sub&gt;2&lt;/sub&gt; , ..., a &lt;sub&gt;n&lt;/sub&gt; , a &lt;sub&gt;n&lt;/sub&gt; ). (В скобках, доказательство твердости ED очень интересно, &lt;a href=&quot;http://www.cs.dartmouth.edu/~ac/Teach/CS85-Spring08/lecnotes.pdf&quot;&gt;через топологию&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="b9194449f120d8f88fb9b2143ad9103b6ff573c9" translate="yes" xml:space="preserve">
          <source>Smile satisfied :)</source>
          <target state="translated">Улыбнитесь довольны :)</target>
        </trans-unit>
        <trans-unit id="b4e8217ef1354bbb155dad8cbdc9f0568f1b9c6f" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;hashing&lt;/strong&gt; would be enough (and faster).</source>
          <target state="translated">Так что &lt;strong&gt;хеширования&lt;/strong&gt; будет достаточно (и быстрее).</target>
        </trans-unit>
        <trans-unit id="efa0ae263e5ffda95375f84a7f6c55184e61109a" translate="yes" xml:space="preserve">
          <source>So depending on the previous analysis following operations should be used in descending order:</source>
          <target state="translated">Поэтому,в зависимости от предыдущего анализа,следует использовать следующие операции в порядке убывания:</target>
        </trans-unit>
        <trans-unit id="c9e8e26a61696a80e259f278ce881a216a7ad149" translate="yes" xml:space="preserve">
          <source>So here is my suggestion:</source>
          <target state="translated">Так что вот мое предложение:</target>
        </trans-unit>
        <trans-unit id="a55e40b80a0b84833274723db643350fd89429ca" translate="yes" xml:space="preserve">
          <source>So pick up five of them at random, and memorize their shape or their length.</source>
          <target state="translated">Так что возьмите пятерых наугад и запомните их форму или длину.</target>
        </trans-unit>
        <trans-unit id="d199d875189556fbbb7c28bbf7b2d5145327cb1f" translate="yes" xml:space="preserve">
          <source>So the &quot;best&quot; algorithm depends on the qualities of the wetware/hardware/software that is running it and our willingness to &quot;cheat&quot; by imposing a total order on pairs.  Certainly a &quot;best&quot; &lt;em&gt;meta&lt;/em&gt;-algorithm is to hire the worlds best sock-sorter: a person or machine that can aquire and quickly store a huge set N of sock attribute sets in a 1-1 associative memory with constant time lookup, insert, and delete. Both people and machines like this can be procured. If you have one, you can pair all the socks in O(N) time for N pairs, which is optimal. The total order tags allow you to use standard hashing to get the same result with either a human or hardware computer.</source>
          <target state="translated">Таким образом, &amp;laquo;лучший&amp;raquo; алгоритм зависит от качества работающего на нем программного обеспечения / программного обеспечения / программного обеспечения, а также от нашей готовности &amp;laquo;обманывать&amp;raquo; путем наложения общего порядка на пары. Конечно, &amp;laquo;лучшим&amp;raquo; &lt;em&gt;мета-&lt;/em&gt; алгоритмом является найм лучшего в мире сортировщика носков: человека или машины, которые могут найти и быстро сохранить огромное множество N наборов атрибутов носка в ассоциативной памяти 1-1 с постоянным поиском по времени, вставкой, и удалить. И люди, и машины, подобные этой, могут быть закуплены. Если у вас есть один, вы можете соединить все носки за O (N) времени для N пар, что является оптимальным. Теги общего заказа позволяют вам использовать стандартное хеширование, чтобы получить тот же результат на человеческом или аппаратном компьютере.</target>
        </trans-unit>
        <trans-unit id="2f4b0f3db658b3420736349f1a48e77a38793c53" translate="yes" xml:space="preserve">
          <source>So we have a total runtime complexity of &lt;strong&gt;&lt;code&gt;O(r*n^2 + w*(ln n + n))&lt;/code&gt;&lt;/strong&gt; where &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; are the factors for environmental read and environmental write operations respectively for a reasonable amount of socks. The cost of the logical and arithmetical operations are omitted, because we suppose that it takes a constant amount of logical and arithmetical operations to decide whether 2 socks belong to the same pair. This may not be feasible in every scenario.</source>
          <target state="translated">Таким образом, мы имеем общую сложность времени выполнения &lt;strong&gt; &lt;code&gt;O(r*n^2 + w*(ln n + n))&lt;/code&gt; &lt;/strong&gt; где &lt;code&gt;r&lt;/code&gt; и &lt;code&gt;w&lt;/code&gt; - факторы для операций чтения из среды и записи в среде соответственно для разумного количества носков. Стоимость логических и арифметических операций опущена, потому что мы предполагаем, что требуется постоянное количество логических и арифметических операций, чтобы решить, принадлежат ли 2 носка к одной паре. Это может быть неосуществимо в каждом сценарии.</target>
        </trans-unit>
        <trans-unit id="c0ea279bcf3555464998141486451f10c76c5ac8" translate="yes" xml:space="preserve">
          <source>So, an algorithm for achieving O(1) sock pairing efficiency (assuming symmetrical sock) is:</source>
          <target state="translated">Итак,алгоритм достижения эффективности пары носков O(1)(предполагая симметричный носок)есть:</target>
        </trans-unit>
        <trans-unit id="f20134ff73648500315de3e4a253b67d80cad96e" translate="yes" xml:space="preserve">
          <source>Socks, whether real ones or some analogous data structure, would be supplied in pairs.</source>
          <target state="translated">Носки,будь то настоящие или какая-либо аналогичная структура данных,поставлялись бы парами.</target>
        </trans-unit>
        <trans-unit id="fb36d98db4ccebdf42bf060da6c7373f52f5a333" translate="yes" xml:space="preserve">
          <source>Some upfront effort is required to find desirable socks, and to purchase in sufficient quantity as to eliminate need for your existing socks. As I'd done this before my need for black socks, my effort was minimal, but mileage may vary.</source>
          <target state="translated">Нужно приложить определенные усилия,чтобы найти желаемые носки и приобрести их в достаточном количестве,чтобы избавиться от необходимости носить существующие носки.Как я делал это до того,как мне понадобились черные носки,мои усилия были минимальными,но пробег может варьироваться.</target>
        </trans-unit>
        <trans-unit id="97926eed54a69097fde506b9ecf78b97bea5b72b" translate="yes" xml:space="preserve">
          <source>Someone with less than perfect memory might use a few commonsense equivalence classes based on features within his capability to track: size (papa, mama, baby), color (greenish, redish, etc.), pattern (argyle, plain, etc.), style (footie, knee-high, etc.).  So the ironing board would be divided into sections for the categories. This usually allows the category to be located in constant time by memory, but then a linear search through the category &quot;bucket&quot; is needed.</source>
          <target state="translated">Кто-то с менее чем идеальной памятью может использовать несколько классов эквивалентности здравого смысла,основанных на особенностях его способности отслеживать:размер (папа,мама,ребенок),цвет (зеленоватый,красноватый и т.д.),рисунок (аргил,обычный и т.д.),стиль (фути,колено высотой и т.д.).Таким образом,гладильная доска будет разделена на разделы по категориям.Обычно это позволяет по памяти располагать категорию в постоянном времени,но затем необходим линейный поиск по категории &quot;ведро&quot;.</target>
        </trans-unit>
        <trans-unit id="0159712802a0c2f7cfff59d6211ba6f0c4445923" translate="yes" xml:space="preserve">
          <source>Someone with no memory or imagination at all (sorry) will just keep the socks in one pile and do a linear search of the whole pile.</source>
          <target state="translated">Кто-то,у кого вообще нет памяти или воображения (извините),будет просто держать носки в одной кучке и делать линейный поиск по всей кучке.</target>
        </trans-unit>
        <trans-unit id="b1831098d4a04bf674e6b5bfb3d588abdfb6668a" translate="yes" xml:space="preserve">
          <source>Sorting solutions have been proposed, but &lt;strong&gt;sorting is a little too much&lt;/strong&gt;: We don't need order; &lt;strong&gt;we just need equality groups&lt;/strong&gt;.</source>
          <target state="translated">Решения для сортировки были предложены, но &lt;strong&gt;сортировка - это слишком много&lt;/strong&gt; : нам не нужен порядок; &lt;strong&gt;нам просто нужны группы равенства&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2cf30b649babee1fb3e3f2f2040697d3899e96be" translate="yes" xml:space="preserve">
          <source>Sorting, of course improves efficiency, especially in real life where you can easily &quot;insert&quot; a sock between two other socks. In computing the same could be achieved by a tree, but that's extra space. And, of course, we're back at NlogN (or a bit more, if there are several socks that are the same by sorting criteria, but not from the same pair).</source>
          <target state="translated">Сортировка,конечно,повышает эффективность,особенно в реальной жизни,где вы можете легко &quot;вставить&quot; носок между двумя другими носками.В вычислениях то же самое может быть достигнуто деревом,но это дополнительное пространство.И,конечно же,мы вернулись на NlogN (или чуть больше,если есть несколько носков,которые по критериям сортировки одинаковы,но не из одной пары).</target>
        </trans-unit>
        <trans-unit id="71a641aab14b65becb2573bd1e7dc80cfa779bbc" translate="yes" xml:space="preserve">
          <source>Spread all socks in the pile over the floor.</source>
          <target state="translated">Разложите все носки в куче по полу.</target>
        </trans-unit>
        <trans-unit id="1e59b3c211f85c725340aeaa57b22de5e88fedab" translate="yes" xml:space="preserve">
          <source>Starting a radix sort from that conceptual location by pulling socks from the pile based on similarity to that one.</source>
          <target state="translated">Начиная сортировку по радиусу от этого концептуального места,вытаскивая носки из кучи на основе сходства с этой.</target>
        </trans-unit>
        <trans-unit id="9a81a4144276291d35bd6b866aad617bdf191bf6" translate="yes" xml:space="preserve">
          <source>Stop sorting piles when they reached a threshold at which you are comfortable to find spot pairs and unpairable socks instantly</source>
          <target state="translated">Прекратить сортировку свай,когда они достигли порога,при котором вы удобно найти место пары и непригодных носков мгновенно</target>
        </trans-unit>
        <trans-unit id="c6852caa99233694cc2f8ce0670b34197c40d765" translate="yes" xml:space="preserve">
          <source>Such an upfront effort has been seen many times in very popular and effective code. Examples include #DEFINE'ing pi to several decimals (other examples exist, but that's the one that comes to mind right now).</source>
          <target state="translated">Такая авангардная работа не раз была замечена в очень популярном и эффективном коде.В качестве примеров можно привести #DEFINE'ing pi до нескольких десятичных знаков (другие примеры существуют,но именно они сейчас приходят на ум).</target>
        </trans-unit>
        <trans-unit id="0a5991dd9a6ef1577adeb97b95fcc60199512116" translate="yes" xml:space="preserve">
          <source>Suppose that you &lt;em&gt;know&lt;/em&gt; that your 2n socks are arranged this way:</source>
          <target state="translated">Предположим, вы &lt;em&gt;знаете,&lt;/em&gt; что ваши 2n носки расположены следующим образом:</target>
        </trans-unit>
        <trans-unit id="83358afe13545467fbcbbf957121011db2230479" translate="yes" xml:space="preserve">
          <source>The actual number of socks is not that large, I don't believe my spouse and I have more than 30 pairs. (And it is fairly easy to distinguish between my socks and hers; can this be used as well?)</source>
          <target state="translated">Реальное количество носков не такое уж большое,я не верю своему супругу и у меня более 30 пар.(И довольно легко отличить мои носки от ее;можно ли это тоже использовать?).</target>
        </trans-unit>
        <trans-unit id="052fd9e524e5e7a091878b38f361a3a987397d74" translate="yes" xml:space="preserve">
          <source>The algorithm</source>
          <target state="translated">Алгоритм</target>
        </trans-unit>
        <trans-unit id="f78fa21d86b0d267520ebd8d82fbaae7a3fc5c19" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(ln n + n)&lt;/code&gt; environmental modifications (step 1 &lt;code&gt;O(ln n)&lt;/code&gt; plus picking every pair of sock from the floor)</source>
          <target state="translated">Алгоритм включает в себя &lt;code&gt;O(ln n + n)&lt;/code&gt; модификаций среды (шаг 1 &lt;code&gt;O(ln n)&lt;/code&gt; плюс подбор каждой пары носков с пола)</target>
        </trans-unit>
        <trans-unit id="1df9e4e8ccdefcdc14130712da6877c276e11de8" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(n^2)&lt;/code&gt; environmental reads from step 2</source>
          <target state="translated">Алгоритм включает &lt;code&gt;O(n^2)&lt;/code&gt; чтения среды из шага 2</target>
        </trans-unit>
        <trans-unit id="dd6aa1a815e2490fabaf33e117c8ad11f5692691" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(n^2)&lt;/code&gt; logical and arithmetic operations for comparing a sock with another in step 2</source>
          <target state="translated">Алгоритм включает &lt;code&gt;O(n^2)&lt;/code&gt; логических и арифметических операций для сравнения носка с другим на шаге 2</target>
        </trans-unit>
        <trans-unit id="bb51c91f5c283a2bdff31b863d5e5e5018eb57e0" translate="yes" xml:space="preserve">
          <source>The algorithm terminates with high probability. This is due to the fact that one is unable to find pairs of socks in step number 2.</source>
          <target state="translated">Алгоритм заканчивается с высокой вероятностью.Это связано с тем,что на шаге №2 не удается найти пары носков.</target>
        </trans-unit>
        <trans-unit id="165efb7623d4620b9e2c0a44514704d6b6dff038" translate="yes" xml:space="preserve">
          <source>The analysis</source>
          <target state="translated">Анализ</target>
        </trans-unit>
        <trans-unit id="abc7bc26ec5efcc62f2a9dd13e54ca3af8f26906" translate="yes" xml:space="preserve">
          <source>The answers till now don't make good use of our human pattern recognition capabilities. The game of Set provides a clue of how to do this well: put all socks in a two-dimensional space so you can both recognize them well and easily reach them with your hands. This limits you to an area of about 120 * 80 cm or so. From there select the pairs you recognize and remove them. Put extra socks in the free space and repeat. If you wash for people with easily recognizable socks (small kids come to mind), you can do a radix sort by selecting those socks first. This algorithm works well only when the  number of single socks is low</source>
          <target state="translated">Ответы до сих пор не используют возможности распознавания человеческих образов.В игре Сет есть подсказка,как это хорошо сделать:поместите все носки в двухмерное пространство,чтобы вы могли как хорошо их распознать,так и легко до них дотянуться руками.Это ограничивает вас в пространстве около 120*80 см или около того.Отсюда выбирайте пары,которые вы узнаете,и удаляйте их.Положите дополнительные носки в свободное пространство и повторите.Если вы стираете для людей с легко узнаваемыми носками (на ум приходят маленькие дети),вы можете сделать сортировку по радиксу,выбрав сначала эти носки.Этот алгоритм хорошо работает только тогда,когда количество одиночных носков невелико.</target>
        </trans-unit>
        <trans-unit id="4d052e124ee3ca4cc28b28a0fe3ffd3b80cede47" translate="yes" xml:space="preserve">
          <source>The best real-world partitioning I can think of is creating a &lt;strong&gt;rectangle of piles&lt;/strong&gt;: one dimension is color, the other is the pattern. Why a rectangle? Because we need O(1) random-access to piles. (A 3D &lt;a href=&quot;http://en.wikipedia.org/wiki/Cuboid&quot;&gt;cuboid&lt;/a&gt; would also work, but that is not very practical.)</source>
          <target state="translated">Лучшее реальное разделение, которое я могу придумать, - это создание &lt;strong&gt;прямоугольника куч&lt;/strong&gt; : одно измерение - это цвет, а другое - это рисунок. Почему прямоугольник? Потому что нам нужен O (1) произвольный доступ к кучам. (3D &lt;a href=&quot;http://en.wikipedia.org/wiki/Cuboid&quot;&gt;кубоид&lt;/a&gt; также подойдет, но это не очень практично.)</target>
        </trans-unit>
        <trans-unit id="4b89a467fe48adcd9cc2eef3b60f3e2f90973c34" translate="yes" xml:space="preserve">
          <source>The initial bucket sorting will speed up your process, because it divides your n socks into k buckets in &lt;code&gt;c*n&lt;/code&gt; time so than you will only have to do &lt;code&gt;c*n*log(k)&lt;/code&gt; work. (Not taking into account the threshold). So all in all you do about &lt;code&gt;n*c*(1 + log(k))&lt;/code&gt; work, where c is the time to throw a sock on a pile.</source>
          <target state="translated">Первоначальная сортировка сегментов ускорит ваш процесс, потому что она делит ваши n носков на k сегментов за &lt;code&gt;c*n&lt;/code&gt; время, так что вам остается только выполнить &lt;code&gt;c*n*log(k)&lt;/code&gt; . (Без учета порога). Таким образом, в целом вы делаете &lt;code&gt;n*c*(1 + log(k))&lt;/code&gt; работу, где c - это время, чтобы бросить носок в кучу.</target>
        </trans-unit>
        <trans-unit id="3ab65ee84b4d8d43507a4f1bd4d7cc40b05e68c1" translate="yes" xml:space="preserve">
          <source>The machine</source>
          <target state="translated">Машина</target>
        </trans-unit>
        <trans-unit id="7bb444117bc016eadc9752d11b231edb03e673d8" translate="yes" xml:space="preserve">
          <source>The machine is an abstraction of a the real world element called human being. It is able to read from the environment via a pair of eyes. And our machine model is able to manipulate the environment by using 2 arms. Logical and arithmetic operations are calculated using our brain (hopefully ;-)).</source>
          <target state="translated">Машина-это абстракция элемента реального мира,называемого человеком.Она способна читать из окружающей среды парой глаз.А наша модель машины способна манипулировать окружающей средой с помощью двух рук.Логические и арифметические операции вычисляются с помощью нашего мозга (будем надеяться ;-)).</target>
        </trans-unit>
        <trans-unit id="7ecbe36be8e73003b52a651bfa1b97b3b6cb4fd9" translate="yes" xml:space="preserve">
          <source>The method can also be nested, if we have multiple equivalence relations -&amp;gt; make colour piles, than within every pile partition on texture, than sort on length. Any equivalence relation that creates a partition with more than 2 elements that have about even size will bring a speed improvement over sorting (provided we can directly assign a sock to its pile), and the sorting can happen very quickly on smaller data sets.</source>
          <target state="translated">Этот метод также может быть вложенным, если мы имеем несколько отношений эквивалентности -&amp;gt; создаем цветные кучи, чем внутри каждой секции кучи по текстуре, чем сортируем по длине Любое отношение эквивалентности, при котором создается раздел с более чем двумя элементами, которые имеют примерно одинаковый размер, принесет улучшение скорости по сравнению с сортировкой (при условии, что мы можем напрямую назначить носок для его кучи), и сортировка может выполняться очень быстро на меньших наборах данных.</target>
        </trans-unit>
        <trans-unit id="0a27a2fa6c14acbfbc60946013388db1b86f6b79" translate="yes" xml:space="preserve">
          <source>The problem of sorting &lt;strong&gt;your n pairs of socks is O(n)&lt;/strong&gt;. Before you throw them in the laundry &lt;strong&gt;basket&lt;/strong&gt;, you thread the left one to the right one. On taking them out, you cut the thread and put each pair into your drawer - 2 operations on n pairs, so O(n).</source>
          <target state="translated">Проблема сортировки &lt;strong&gt;ваших n пар носков - O (n)&lt;/strong&gt; . Прежде чем выбросить их в &lt;strong&gt;корзину&lt;/strong&gt; для белья, проденьте левую в правую. Вынув их, вы обрезаете нить и кладете каждую пару в ящик - 2 операции по n парам, поэтому O (n).</target>
        </trans-unit>
        <trans-unit id="c5d0caed9ed396ae40259a6681e3e2c91a16dfd9" translate="yes" xml:space="preserve">
          <source>The simplest answer is prior to allowing the pair to be separated, a single data structure for the pair should have been initialized that contained a pointer to the left and right sock, thus enabling socks to be referred to directly or via their pair. A sock may also be extended to contain a pointer to its partner.</source>
          <target state="translated">Самый простой ответ-перед тем,как позволить паре быть разделенной,необходимо было инициализировать единую структуру данных для пары,которая содержала бы указатель на левый и правый носок,позволяя,таким образом,ссылаться на носки напрямую или через их пару.Носок также может быть расширен,чтобы содержать указатель на своего партнера.</target>
        </trans-unit>
        <trans-unit id="1015cb01e1edc8548eb94937e6c0a8fd4cae64a4" translate="yes" xml:space="preserve">
          <source>The simplest parallelization strategy is to have multiple workers take from the input basket and put the socks onto the piles. This only scales up so much - imagine 100 people fighting over 10 piles. &lt;strong&gt;The synchronization costs&lt;/strong&gt; (manifesting themselves as hand-collisions and human communication) &lt;strong&gt;destroy efficiency and speed-up&lt;/strong&gt; (see the &lt;a href=&quot;http://www.perfdynamics.com/Manifesto/USLscalability.html&quot;&gt;Universal Scalability Law&lt;/a&gt;!). Is this prone to &lt;strong&gt;deadlocks&lt;/strong&gt;? No, because each worker only needs to access one pile at a time. With just one &quot;lock&quot; there cannot be a deadlock. &lt;strong&gt;Livelocks&lt;/strong&gt; might be possible depending on how the humans coordinate access to piles. They might just use &lt;a href=&quot;http://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;random backoff&lt;/a&gt; like network cards do that on a physical level to determine what card can exclusively access the network wire. If it works for &lt;a href=&quot;http://en.wikipedia.org/wiki/Network_interface_controller&quot;&gt;NICs&lt;/a&gt;, it should work for humans as well.</source>
          <target state="translated">Самая простая стратегия распараллеливания состоит в том, чтобы несколько рабочих брали из корзины ввода и помещали носки на сваи. Это только увеличивает масштаб - представьте, что 100 человек сражаются за 10 куч. &lt;strong&gt;Затраты на синхронизацию&lt;/strong&gt; (проявляющиеся как столкновения рук и общение с людьми) &lt;strong&gt;разрушают эффективность и ускорение&lt;/strong&gt; (см. &lt;a href=&quot;http://www.perfdynamics.com/Manifesto/USLscalability.html&quot;&gt;Закон&lt;/a&gt; о всеобщей масштабируемости !). Это склонно к &lt;strong&gt;тупикам&lt;/strong&gt; ? Нет, потому что каждый работник должен иметь доступ только к одной куче за раз. Только с одним &amp;laquo;замком&amp;raquo; не может быть тупика. &lt;strong&gt;Блокировки&lt;/strong&gt; могут быть возможны в зависимости от того, как люди координируют доступ к кучам. Они могут просто использовать &lt;a href=&quot;http://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;случайный откат,&lt;/a&gt; как это делают сетевые карты на физическом уровне, чтобы определить, какая карта может иметь доступ исключительно к сетевому проводу. Если это работает для &lt;a href=&quot;http://en.wikipedia.org/wiki/Network_interface_controller&quot;&gt;сетевых карт&lt;/a&gt; , это должно работать и для людей.</target>
        </trans-unit>
        <trans-unit id="d2f49bc795ae24363a2c7470a93203b0fced4c88" translate="yes" xml:space="preserve">
          <source>The special condition in my case is that I don't use drying machine, just hang my cloths on an ordinary cloth dryer. Hanging cloths requires &lt;code&gt;O(n)&lt;/code&gt; operations (by the way, I always consider &lt;a href=&quot;http://en.wikipedia.org/wiki/Bin_packing_problem]&quot;&gt;bin packing&lt;/a&gt; problem here) and the problem by its nature requires the linear &quot;extra&quot; space. When I take a new sock from the bucket I to try hang it next to its pair if the pair is already hung. If its a sock from a new pair I leave some space next to it.</source>
          <target state="translated">Особое условие в моем случае заключается в том, что я не пользуюсь сушильной машиной, а просто вешаю одежду на обычную сушилку для белья. Подвешивание тканей требует &lt;code&gt;O(n)&lt;/code&gt; операций (кстати, я всегда рассматриваю здесь проблему &lt;a href=&quot;http://en.wikipedia.org/wiki/Bin_packing_problem]&quot;&gt;упаковки бина&lt;/a&gt; ), а проблема по своей природе требует линейного &amp;laquo;дополнительного&amp;raquo; пространства. Когда я беру новый носок из ведра, я пытаюсь повесить его рядом с его парой, если пара уже повешена. Если это носок из новой пары, я оставляю немного места рядом с ним.</target>
        </trans-unit>
        <trans-unit id="ce6af0db2fdccac900c8209f502eec96611a6b58" translate="yes" xml:space="preserve">
          <source>The theoretical limit is O(n) because you need to touch each sock (unless some are already paired somehow).</source>
          <target state="translated">Теоретическим ограничением является O(n),потому что вам нужно дотронуться до каждого носка (если только некоторые из них уже каким-то образом не спарены).</target>
        </trans-unit>
        <trans-unit id="2103f930ed2f94482faf224a41b4b0491a977035" translate="yes" xml:space="preserve">
          <source>The worst-case scenario of this scheme is that every pair of socks is different enough that it must be matched exactly, and that the first &lt;em&gt;n/2&lt;/em&gt; socks you pick are all different. This is your &lt;em&gt;O&lt;/em&gt;(n&lt;sup&gt;2&lt;/sup&gt;) scenario, and it's &lt;em&gt;extremely&lt;/em&gt; unlikely. If the number of unique types of sock &lt;em&gt;t&lt;/em&gt; is less than the number of pairs &lt;em&gt;p = n/2&lt;/em&gt;, and the socks in each type are alike enough (usually in wear-related terms) that any sock of that type can be paired with any other, then as I inferred above, the maximum number of socks you will ever have to compare to is &lt;em&gt;t&lt;/em&gt;, after which the next one you pull &lt;em&gt;will&lt;/em&gt; match one of the unpaired socks. This scenario is much more likely in the average sock drawer than the worst-case, and reduces the worst-case complexity to &lt;em&gt;O&lt;/em&gt;(n*t) where usually &lt;em&gt;t &amp;lt;&amp;lt; n&lt;/em&gt;.</source>
          <target state="translated">Наихудший сценарий этой схемы состоит в том, что каждая пара носков достаточно различна, что должно точно соответствовать ей, и что все первые &lt;em&gt;выбранные&lt;/em&gt; носки &lt;em&gt;n / 2&lt;/em&gt; различны. Это ваш сценарий &lt;em&gt;O&lt;/em&gt; (n &lt;sup&gt;2&lt;/sup&gt; ), и он &lt;em&gt;крайне&lt;/em&gt; маловероятен. Если число уникальных типов носков &lt;em&gt;t&lt;/em&gt; меньше, чем количество пар &lt;em&gt;p = n / 2&lt;/em&gt; , и носки в каждом типе достаточно похожи (обычно в терминах, связанных с износом), то любой носок этого типа можно соединить с любым В остальном, как я и предполагал выше, максимальное количество носков, с которыми вам когда-либо придется сравнивать, - это &lt;em&gt;t&lt;/em&gt; , после чего следующий, который вы потянете, &lt;em&gt;будет&lt;/em&gt; соответствовать одному из непарных носков. Этот сценарий гораздо более вероятен в среднем ящике с носками, чем в худшем случае, и снижает сложность в худшем случае до &lt;em&gt;O&lt;/em&gt; (n * t), где обычно &lt;em&gt;t &amp;lt;&amp;lt; n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="96b12eabde3d73be5eafb1e84e13a730dc8628d1" translate="yes" xml:space="preserve">
          <source>Then all you do is snap your socks together right after you take them off and put them in your washing basket, and again you've removed the problem of needing to pair your socks with a physical abstraction of the 'pair' concept.</source>
          <target state="translated">Затем все,что вы делаете,это скрепляете носки сразу после того,как вы их снимаете,и кладете их в стиральную корзину,и опять же вы устраняете проблему,связанную с необходимостью сочетать носки с физической абстракцией понятия &quot;пара&quot;.</target>
        </trans-unit>
        <trans-unit id="dced202b38f2d14c3908f94ad0c3a8bd7e6f6c93" translate="yes" xml:space="preserve">
          <source>There are two physical possibilities:</source>
          <target state="translated">Есть две физические возможности:</target>
        </trans-unit>
        <trans-unit id="4e4e9e2d368abd05573c65b163fd925efb9322d4" translate="yes" xml:space="preserve">
          <source>This also means that you will almost certainly never have all your socks in the array, because socks will get removed as they're matched.</source>
          <target state="translated">Это также означает,что у вас почти наверняка никогда не будет всех носков в массиве,потому что носки будут удаляться по мере их совмещения.</target>
        </trans-unit>
        <trans-unit id="bdfecabe5ec0a698991109d39b1c3465373ad88d" translate="yes" xml:space="preserve">
          <source>This approach will be favourable compared to any &lt;code&gt;c*x*n + O(1)&lt;/code&gt; method roughly as long as &lt;code&gt;log(k) &amp;lt; x - 1&lt;/code&gt;.</source>
          <target state="translated">Этот подход будет выгоден по сравнению с любым методом &lt;code&gt;c*x*n + O(1)&lt;/code&gt; примерно до тех пор, пока &lt;code&gt;log(k) &amp;lt; x - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d1f77ce46b573dd375b9b3f8133c6c3e6975fa2" translate="yes" xml:space="preserve">
          <source>This is asking the wrong question. The right question to ask is, why am I spending time sorting socks? How much does it cost on yearly basis, when you value your free time for X monetary units of your choice?</source>
          <target state="translated">Это неправильный вопрос.Правильный вопрос-зачем я трачу время на сортировку носков? Сколько это стоит в год,когда вы оцениваете свое свободное время за Х денежных единиц по вашему выбору?</target>
        </trans-unit>
        <trans-unit id="c7adcd7ce06b47130e35aa217e78946ac1fdb2c3" translate="yes" xml:space="preserve">
          <source>This is how I actually do it, for &lt;em&gt;p&lt;/em&gt; pairs of socks (&lt;em&gt;n = 2p&lt;/em&gt; individual socks):</source>
          <target state="translated">Вот как я на самом деле это делаю для &lt;em&gt;p&lt;/em&gt; пар носков ( &lt;em&gt;n = 2p&lt;/em&gt; отдельных носков):</target>
        </trans-unit>
        <trans-unit id="235c85c59d6f0d9269c7c93b100ce67634688f1b" translate="yes" xml:space="preserve">
          <source>This kind of recursive hash partitioning is actually being done by &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt; when it needs to hash join or hash aggregate over huge data sets. It distributes its build input stream into many partitions which are independent. This scheme scales to arbitrary amounts of data and multiple CPUs linearly.</source>
          <target state="translated">Этот вид рекурсивного разбиения хеша фактически выполняется &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server,&lt;/a&gt; когда ему необходимо хеш-соединение или хеш-агрегация для огромных наборов данных. Он распределяет свой входной поток сборки на множество независимых разделов. Эта схема линейно масштабируется до произвольных объемов данных и нескольких процессоров.</target>
        </trans-unit>
        <trans-unit id="71188b927e375c9f840b0228303d1ad03320f9ac" translate="yes" xml:space="preserve">
          <source>This question is actually deeply philosophical. At heart it's about whether the power of people to solve problems (the &quot;wetware&quot; of our brains) is equivalent to what can be accomplished by algorithms.</source>
          <target state="translated">Этот вопрос на самом деле глубоко философский.В глубине души речь идет о том,эквивалентна ли способность людей решать проблемы (&quot;мокрое ПО&quot; нашего мозга)тому,что может быть достигнуто с помощью алгоритмов.</target>
        </trans-unit>
        <trans-unit id="6137f79697d8c825e0bce0519a78dca5b385553f" translate="yes" xml:space="preserve">
          <source>This solves any computational pairing problem by removing it with a layer of abstraction.</source>
          <target state="translated">Это решает любую вычислительную задачу объединения,удаляя ее с помощью слоя абстракции.</target>
        </trans-unit>
        <trans-unit id="832509383b3fc443a9e0c7a64e684a8be877a579" translate="yes" xml:space="preserve">
          <source>This takes advantage of the human ability to fuzzy-match in O(1) time, which is somewhat equivalent to the establishment of a hash-map on a computing device.</source>
          <target state="translated">При этом используется способность человека к нечеткому совпадению во времени O(1),что в некоторой степени эквивалентно созданию хеш-карты на вычислительном устройстве.</target>
        </trans-unit>
        <trans-unit id="bb9e4357cf8c4cf1055b16dd15145dc9529ca43b" translate="yes" xml:space="preserve">
          <source>Thus connecting the problem of pairing socks with the problem of hanging cloths I get &lt;code&gt;O(n)&lt;/code&gt; &quot;extra space&quot; for free, and have a solution that is about &lt;code&gt;O(n)&lt;/code&gt; in time, requires just a little more work than simple hanging cloths and allows to immediately access complete pair of socks even in a very bad Monday morning... ;-)</source>
          <target state="translated">Таким образом, соединяя проблему сопряжения носков с проблемой подвешивания тканей, я получаю &lt;code&gt;O(n)&lt;/code&gt; &amp;laquo;дополнительное пространство&amp;raquo; бесплатно, и у меня есть решение, которое составляет около &lt;code&gt;O(n)&lt;/code&gt; во времени, требует чуть больше работы, чем простые висящие ткани. и позволяет сразу получить доступ к полной паре носков даже в очень плохое утро понедельника ... ;-)</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="cc9192722da415eb15991bb6f24cb75e9e00289e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;. This is only linear time since comparison is not required.</source>
          <target state="translated">Используйте &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;основную сортировку&lt;/a&gt; . Это только линейное время, так как сравнение не требуется.</target>
        </trans-unit>
        <trans-unit id="72e4524e8782dab66f9edff21207d55131fced9d" translate="yes" xml:space="preserve">
          <source>We also have to consider the intrinsic runtime of the atomic operations that can be carried out with these instruments. Due to physical constraints, operations which are carried out by an arm or eye have non constant time complexity. This is because we can't move an endlessly large pile of socks with an arm nor can an eye see the top sock on an endlessly large pile of socks.</source>
          <target state="translated">Мы также должны учитывать внутреннее время выполнения атомных операций,которые могут быть выполнены с помощью этих приборов.В связи с физическими ограничениями,операции,выполняемые рукой или глазом,не имеют постоянной временной сложности.Это связано с тем,что мы не можем перемещать бесконечно большую кучу носков рукой,а глаз не может видеть верхний носок на бесконечно большой кучке носков.</target>
        </trans-unit>
        <trans-unit id="fc41cda5f1c62ac5f64fac7531ea11668364e843" translate="yes" xml:space="preserve">
          <source>We can also make use of the fact that people only have a very limited amount of socks. So an environmental modification can involve all socks in the pile.</source>
          <target state="translated">Мы также можем использовать тот факт,что у людей есть только очень ограниченное количество носков.Таким образом,изменение окружающей среды может затронуть все носки в куче.</target>
        </trans-unit>
        <trans-unit id="7f928a1fe0e4e26c3f5eb42941dbb73bf04c00c1" translate="yes" xml:space="preserve">
          <source>We have to do comparison to check whether two socks come in pair. Pick one of the &lt;code&gt;O(n log n)&lt;/code&gt; comparison-based sorting algorithms.</source>
          <target state="translated">Мы должны сделать сравнение, чтобы проверить, входят ли два носка в пару. Выберите один из алгоритмов сортировки на основе сравнения &lt;code&gt;O(n log n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aff2e93d02cec92464795e91655b9cf0e01a5bf" translate="yes" xml:space="preserve">
          <source>What I do is that I pick up the first sock and put it down (say, on the edge of the laundry bowl). Then I pick up another sock and check to see if it's the same as the first sock. If it is, I remove them both. If it's not, I put it down next to the first sock. Then I pick up the third sock and compare that to the first two (if they're still there). Etc.</source>
          <target state="translated">Что я делаю,так это беру первый носок и кладу его вниз (скажем,на край чашки для белья).Затем я подбираю другой носок и проверяю,не совпадает ли он с первым носком.Если это так,то я снимаю их оба.Если нет,я кладу их рядом с первым носком.Потом подбираю третий носок и сравниваю его с первыми двумя (если они все еще там).И т.д.</target>
        </trans-unit>
        <trans-unit id="52fb31e5804c85af0c9ab1080840c1c1106a6ac7" translate="yes" xml:space="preserve">
          <source>What about &lt;strong&gt;parallelism&lt;/strong&gt;? Can multiple humans match the socks faster?</source>
          <target state="translated">А как насчет &lt;strong&gt;параллелизма&lt;/strong&gt; ? Могут ли несколько человек подобрать носки быстрее?</target>
        </trans-unit>
        <trans-unit id="62ee3893b3dd45b1448958e4035d217abb5319ed" translate="yes" xml:space="preserve">
          <source>What about the &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;element distinctness problem&lt;/a&gt;? As the article states, the element distinctness problem can be solved in &lt;code&gt;O(N)&lt;/code&gt;. This is the same for the socks problem (also &lt;code&gt;O(N)&lt;/code&gt;, if you need only one distribution step (I proposed multiple steps only because humans are bad at calculations - one step is enough if you distribute on &lt;code&gt;md5(color, length, pattern, ...)&lt;/code&gt;, i.e. a &lt;strong&gt;perfect hash&lt;/strong&gt; of all attributes)).</source>
          <target state="translated">Как насчет &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;проблемы отличимости элементов&lt;/a&gt; ? Как говорится в статье, проблема разграничения элементов может быть решена в &lt;code&gt;O(N)&lt;/code&gt; . Это то же самое для проблемы с носками (также &lt;code&gt;O(N)&lt;/code&gt; , если вам нужен только один шаг распределения (я предложил несколько шагов только потому, что люди плохо разбираются в вычислениях - достаточно одного шага, если вы распространяете на &lt;code&gt;md5(color, length, pattern, ...)&lt;/code&gt; , то есть &lt;strong&gt;идеальный хэш&lt;/strong&gt; всех атрибутов)).</target>
        </trans-unit>
        <trans-unit id="d6e0a1a2a1c968e16f01d631ec79dc29fcbb8978" translate="yes" xml:space="preserve">
          <source>What we want to do is reduce the number of moves, and compensate with the number of searches. Also, we can utilize the multithreded environment of the Homo Sapiens to hold more things in the descision cache.</source>
          <target state="translated">Что мы хотим сделать,так это уменьшить количество ходов и компенсировать их количеством поисков.Кроме того,мы можем использовать многоступенчатую среду Homo Sapiens,чтобы удержать больше вещей в кэш-памяти спуска.</target>
        </trans-unit>
        <trans-unit id="40119aa23f988c392c776aef12173470a672ba85" translate="yes" xml:space="preserve">
          <source>When I sort socks, I do an approximate &lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;, dropping socks near other socks of the same colour/pattern type. Except in the case when I can see an exact match at/near the location I'm about to drop the sock I extract the pair at that point.</source>
          <target state="translated">Когда я сортирую носки, я делаю приблизительную &lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;сортировку по радиусу&lt;/a&gt; , опуская носки рядом с другими носками того же типа цвета / рисунка. За исключением случая, когда я могу увидеть точное совпадение в / около места, я собираюсь сбросить носок, я извлекаю пару в этой точке.</target>
        </trans-unit>
        <trans-unit id="dbe5289d9f14e85418adcf750eb06633c494d931" translate="yes" xml:space="preserve">
          <source>Whenever you pick up a sock, put it in one place.  Then the next sock you pick up, if it doesn't match the first sock, set it beside the first one.  If it does, there's a pair.  This way it doesn't really matter how many combinations there are, and there are only two possibilities for each sock you pick up -- either it has a match that's already in your array of socks, or it doesn't, which means you add it to a place in the array.</source>
          <target state="translated">Всякий раз,когда подбираешь носок,кладешь его на одно место.Затем следующий носок,если он не совпадает с первым,поставьте рядом с первым.Если совпадает,то есть пара.Таким образом,не имеет значения,сколько комбинаций есть,и для каждого подобранного носка есть только две возможности-либо у него есть совпадение,которое уже есть в вашем массиве носков,либо нет,что означает,что вы добавляете его в место в массиве.</target>
        </trans-unit>
        <trans-unit id="491d10d638725516cd524ff053d646b7db3211cb" translate="yes" xml:space="preserve">
          <source>Why five? Usually humans are good are remembering between five and seven different elements in the working memory - a bit like the human equivalent of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;RPN&lt;/a&gt; stack - five is a safe default.</source>
          <target state="translated">Почему пять? Обычно люди хорошо помнят от пяти до семи различных элементов в рабочей памяти - немного похоже на человеческий эквивалент стека &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;RPN&lt;/a&gt; - пять - безопасное значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4e43cc34e87ad7b769f2e692b3183f1cf7531543" translate="yes" xml:space="preserve">
          <source>X = Yours, Y = Your spouses</source>
          <target state="translated">X=Твои,Y=Твои супруги</target>
        </trans-unit>
        <trans-unit id="bfa8f5c7b6006f4ab74b72c8afabacf5f628c548" translate="yes" xml:space="preserve">
          <source>Yesterday I was pairing the socks from the clean laundry and figured out the way I was doing it is not very efficient. I was doing a naive search&amp;nbsp;&amp;mdash; picking one sock and &quot;iterating&quot; the pile in order to find its pair. This requires iterating over n/2 * n/4 = n&lt;sup&gt;2&lt;/sup&gt;/8 socks on average.</source>
          <target state="translated">Вчера я спаривал носки из чистого белья и понял, что делать это не очень эффективно. Я делал наивный поиск - выбирал один носок и &amp;laquo;перебирал&amp;raquo; кучу, чтобы найти ее пару. Это требует итерации в среднем по n / 2 * n / 4 = n 2/8 носков.</target>
        </trans-unit>
        <trans-unit id="dbd5aa135244891d8a3e76bf37cc43c7ca49ef7d" translate="yes" xml:space="preserve">
          <source>Yet times to times, I have to do this again (lost socks, damaged socks, etc.), and I hate to discard perfectly good socks too often (and I wished they kept selling the same socks reference!), so I recently took a different approach.</source>
          <target state="translated">Но время от времени мне приходится делать это снова (потерянные носки,поврежденные носки и т.д.),и я ненавижу слишком часто выбрасывать совершенно хорошие носки (и я хотел бы,чтобы они продолжали продавать те же самые ссылки на носки!),поэтому в последнее время я выбрал другой подход.</target>
        </trans-unit>
        <trans-unit id="65810e5cb0ea23b0c4ace9656f94508778f1c8cd" translate="yes" xml:space="preserve">
          <source>You can achieve O(n) with &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;. You just need to pick some attributes for the buckets.</source>
          <target state="translated">Вы можете достичь O (n) с помощью &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt; . Вам просто нужно выбрать некоторые атрибуты для ведер.</target>
        </trans-unit>
        <trans-unit id="ba38f2aaa4cb49326b1693f418fc55f635bc82d4" translate="yes" xml:space="preserve">
          <source>You don't need recursive partitioning if you can find a distribution key (hash key) that &lt;strong&gt;provides enough buckets&lt;/strong&gt; that each bucket is small enough to be processed very quickly. Unfortunately, I don't think socks have such a property.</source>
          <target state="translated">Вам не нужно рекурсивное разбиение, если вы можете найти ключ распределения (хеш-ключ), который &lt;strong&gt;предоставляет достаточно сегментов, так&lt;/strong&gt; что каждый блок достаточно мал, чтобы обрабатываться очень быстро. К сожалению, я не думаю, что носки имеют такое свойство.</target>
        </trans-unit>
        <trans-unit id="991cf8e975ca3081b3b2acc02dc579d8b387f197" translate="yes" xml:space="preserve">
          <source>You need to estimate how many pairs of socks you will need for the rest of your life, or perhaps until you retire and move to warmer climates with no need to wear socks ever again. If you are young, you could also estimate how long it takes before we'll all have sock-sorting robots in our homes, and the whole problem becomes irrelevant.</source>
          <target state="translated">Вам нужно оценить,сколько пар носков вам понадобится на всю оставшуюся жизнь,или,возможно,до тех пор,пока вы не выйдете на пенсию и не переедете в более теплый климат,где вам больше не придется носить носки.Если вы молоды,вы также можете оценить,сколько времени потребуется для того,чтобы у всех нас дома появились роботы для сортировки носков,и вся проблема становится неактуальной.</target>
        </trans-unit>
        <trans-unit id="fbfa245099ad6c7e954cd2c2f169e543c5ddc580" translate="yes" xml:space="preserve">
          <source>You need to find out how you can order your selected sock in bulk, and how much it costs, and do they deliver.</source>
          <target state="translated">Вам необходимо узнать,как можно заказать выбранный вами носок оптом,и сколько он стоит,и как он доставляется.</target>
        </trans-unit>
        <trans-unit id="a2c3fba934e9cc7f3bb5f1c5bf7698755a4d500b" translate="yes" xml:space="preserve">
          <source>any subset taken from the top of this bin generally contains both
socks of a pair.</source>
          <target state="translated">Любое подмножество,взятое из верхней части этой корзины,как правило,содержит оба носка пары.</target>
        </trans-unit>
        <trans-unit id="66103b5b15e1b774175c59b31bb92026836434e7" translate="yes" xml:space="preserve">
          <source>environmental modifications</source>
          <target state="translated">экологические изменения</target>
        </trans-unit>
        <trans-unit id="b72a142027a3d942512bfeebef1158e5555cdbf9" translate="yes" xml:space="preserve">
          <source>environmental reads</source>
          <target state="translated">экологические чтения</target>
        </trans-unit>
        <trans-unit id="73ed780668cf0ea89fb1a13af96da25121e815d0" translate="yes" xml:space="preserve">
          <source>logical and arithmetic operations</source>
          <target state="translated">логические и арифметические действия</target>
        </trans-unit>
        <trans-unit id="7b417589bff426c4c61c5b75b1f2b186688fc14d" translate="yes" xml:space="preserve">
          <source>p&lt;sub&gt;1&lt;/sub&gt; p&lt;sub&gt;2&lt;/sub&gt; p&lt;sub&gt;3&lt;/sub&gt; ... p&lt;sub&gt;n&lt;/sub&gt; p&lt;sub&gt;f(1)&lt;/sub&gt; p&lt;sub&gt;f(2)&lt;/sub&gt; ... p&lt;sub&gt;f(n)&lt;/sub&gt;</source>
          <target state="translated">p &lt;sub&gt;1&lt;/sub&gt; p &lt;sub&gt;2&lt;/sub&gt; p &lt;sub&gt;3&lt;/sub&gt; ... p &lt;sub&gt;n&lt;/sub&gt; p &lt;sub&gt;f (1)&lt;/sub&gt; p &lt;sub&gt;f (2)&lt;/sub&gt; ... p &lt;sub&gt;f (n)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d64b5bfb8d253171cb7f047779677b1f366a37c7" translate="yes" xml:space="preserve">
          <source>people toss both of their socks roughly in the same area of the
bin,</source>
          <target state="translated">люди выбрасывают оба носка примерно в одну и ту же зону мусорного контейнера,</target>
        </trans-unit>
        <trans-unit id="e7aa0c831ecd9e4ccd9acd48f58060ccc6e98d8a" translate="yes" xml:space="preserve">
          <source>step 1) discard all your existing socks</source>
          <target state="translated">шаг 1)Сбросьте все существующие носки</target>
        </trans-unit>
        <trans-unit id="85929a76b2535ede46f1da6de8472cf210e6cc72" translate="yes" xml:space="preserve">
          <source>step 2) go to &lt;a href=&quot;http://en.wikipedia.org/wiki/Walmart&quot;&gt;Walmart&lt;/a&gt; and buy them by packets of 10 - n packet of
white and m packets of black. No need for other colors in everyday's
life.</source>
          <target state="translated">шаг 2) зайдите в &lt;a href=&quot;http://en.wikipedia.org/wiki/Walmart&quot;&gt;Walmart&lt;/a&gt; и купите их по 10 пакетов по 10 штук белого цвета и по m пакетов черного цвета. Нет необходимости в других цветах в повседневной жизни.</target>
        </trans-unit>
        <trans-unit id="f0bc37af84619514b988559161037a53edaa21ff" translate="yes" xml:space="preserve">
          <source>the bin is not randomized at any point, and therefore</source>
          <target state="translated">мусорная корзина не является случайной,и поэтому</target>
        </trans-unit>
        <trans-unit id="937822ebb59548bbc8c060e49cb9b98efb226b16" translate="yes" xml:space="preserve">
          <source>then length of the sock,</source>
          <target state="translated">потом длина носка,</target>
        </trans-unit>
        <trans-unit id="f0604a64202bf39aaef8452c27dea8a360470c75" translate="yes" xml:space="preserve">
          <source>then texture,
....</source>
          <target state="translated">затем текстура,...</target>
        </trans-unit>
        <trans-unit id="f0038d5ea027e24fd063b53770f561619dfa487e" translate="yes" xml:space="preserve">
          <source>then use colors (can have any order for the colors, e.g. alphabetically by color name) - split them into piles by color (remember to keep the initial order from step 1 for all socks in the same pile),</source>
          <target state="translated">затем используйте цвета (может иметь любой порядок для цветов,например,в алфавитном порядке по названию цвета)-разделите их на кучи по цвету (не забудьте сохранить исходный порядок с шага 1 для всех носков в одной куче),</target>
        </trans-unit>
        <trans-unit id="4045b164d7574af579063ab4269d98a5011ed66a" translate="yes" xml:space="preserve">
          <source>where f is an unknown permutation of the set {1,2,...,n}. Knowing this cannot make the problem harder. There are n! possible outputs (matchings between first and second half), which means you need log(n!) = Omega(n log n) comparisons. This is obtainable by sorting.</source>
          <target state="translated">где f-неизвестная перестановка набора {1,2,...,n}.Знание этого не может усложнить проблему.Есть n! возможных выходов (совпадений между первой и второй половиной),то есть нужны log(n!)=Omega(n log n)сравнения.Это можно получить путем сортировки.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
