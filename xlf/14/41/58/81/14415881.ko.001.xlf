<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/14415881">
    <body>
      <group id="14415881">
        <trans-unit id="94c0dfc6b17aa37cab713289ff046437e179508f" translate="yes" xml:space="preserve">
          <source>&quot;if s pairs with a sock t in N&quot;.  How quickly can we &quot;remember&quot; what we've seen so far?</source>
          <target state="translated">&quot;s가 n의 양말 t와 쌍을 이룬다면&quot;. 지금까지 본 것을 얼마나 빨리 &quot;기억&quot;할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b5bdc0f37905c659679678b282a51daad6b30c24" translate="yes" xml:space="preserve">
          <source>&quot;remove t from N&quot; and &quot;add s to N&quot;.  How expensive is keeping track of what we've seen so far?</source>
          <target state="translated">&quot;t를 N에서 제거&quot;및 &quot;s를 N에 추가&quot; 우리가 지금까지 본 것을 추적하는 데 얼마나 비쌉니까?</target>
        </trans-unit>
        <trans-unit id="257027605f38139d5816c62c3274fa0db3930e71" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;This approach can be fairly easily be implemented in an array, assuming that &quot;removing&quot; socks is an option.&lt;/s&gt; Actually, you don't even need to &quot;remove&quot; socks. If you don't need sorting of the socks (see below), then you can just move them around and end up with an array that has all the socks arranged in pairs in the array.</source>
          <target state="translated">&lt;s&gt;양말을 &quot;제거&quot;하는 것이 옵션이라고 가정하면이 방법은 어레이에서 쉽게 구현할 수 있습니다.&lt;/s&gt; 실제로, 양말을 &quot;제거&quot;할 필요조차 없습니다. 양말을 정렬 할 필요가 없다면 (아래 참조) 양말을 옮기고 모든 양말이 배열로 배열 된 배열로 끝낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fae469126cdfe9fb170ccabec0390cf8682c501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Heuristic:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Heuristic:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8be3cb9316f7f1176c171daf3e0ce96f2978c5e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithmic answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;알고리즘 답변 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6dd89168d13c44609bd0eb1bed16428f8b39446" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BTW&lt;/strong&gt;, I found that the sum of the transaction costs of sorting all the socks every time I needed a pair were far less than doing it once and binding the socks. A just-in-time works better because then you don't have to bind the socks, and there's also a diminishing marginal return (that is, you keep looking for that two or three socks that when somewhere in the laundry and that you need to finish matching your socks and you lose time on that).</source>
          <target state="translated">&lt;strong&gt;BTW&lt;/strong&gt; , 나는 한 쌍이 필요할 때마다 모든 양말을 분류하는 데 드는 거래 비용의 합계가 한 번만하고 양말을 묶는 것보다 훨씬 적다는 것을 알았습니다. 양말을 묶을 필요가 없기 때문에 Just-in-Time이 더 잘 작동하며, 한계 수익도 감소합니다. 즉 세탁소 어딘가에 필요할 때 2 ~ 3 개의 양말을 계속 찾고 있습니다. 양말을 맞추기 위해 시간을 잃어 버립니다).</target>
        </trans-unit>
        <trans-unit id="2b5ac05a4a642e4eaddf91d074d8a86d8f9607d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1&lt;/strong&gt;: All socks are identical (this is what I do in real life by the way).</source>
          <target state="translated">&lt;strong&gt;사례 1&lt;/strong&gt; : 모든 양말은 동일합니다 (실제로 제가하는 일입니다).</target>
        </trans-unit>
        <trans-unit id="49a8a493d307384ee45499ab7676db0d67425182" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2&lt;/strong&gt;: There are a constant number of combinations (ownership, color, size, texture, etc.).</source>
          <target state="translated">&lt;strong&gt;사례 2&lt;/strong&gt; : 일정한 조합 (소유권, 색상, 크기, 질감 등)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e00424d21a9c0392d4676ab7c8a9295c1d65c888" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 3&lt;/strong&gt;: The number of combinations is not known in advance (general case).</source>
          <target state="translated">&lt;strong&gt;사례 3&lt;/strong&gt; : 조합 수는 미리 알려져 있지 않습니다 (일반 사례).</target>
        </trans-unit>
        <trans-unit id="0b50c6f3b067c6fae56c03d06a7d861b64518113" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-algorithmic answer, yet &quot;efficient&quot; when I do it:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;비 알고리즘 대답이지만 내가 할 때 &quot;효율적&quot;입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f1ed3b5cf07fad91eb01fcb7a682e9e1f3420c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional&lt;/strong&gt; While you are searching the line and and the current sock you are looking at is identical to the previous, do step 2 for these socks.</source>
          <target state="translated">&lt;strong&gt;선택 사항&lt;/strong&gt; 회선을 검색 중이고 현재보고있는 양말이 이전 양말과 동일하지만 양말에 대해 2 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4e7b1dad68f6cce31ec46db04710d5118a2d7aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preconditions:&lt;/strong&gt;
There is no guarantee that there are the same socks. If they are of the same color it doesn't mean they have the same size or pattern. Socks are randomly shuffled. There can be odd number of socks (some are missing, we don't know how many). Prepare to remember a variable &quot;index&quot; and set it to 0.</source>
          <target state="translated">&lt;strong&gt;전제 조건 :&lt;/strong&gt; 동일한 양말이 있다는 보장은 없습니다. 색상이 같다고해서 크기 나 패턴이 같은 것은 아닙니다. 양말은 무작위로 섞습니다. 홀수의 양말이있을 수 있습니다 (일부는 누락되어 있습니다. 얼마나 많은지 알 수 없습니다). 변수 &quot;index&quot;를 기억하고 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e8d739a374e59173c2a911ac09bb3cfac524d27d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recursively apply this scheme&lt;/strong&gt; until you have distributed all socks onto &lt;strong&gt;very small piles that you can visually process immediately&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;시각적으로 즉시 처리 할 수있는 매우 작은 더미&lt;/strong&gt; 에 모든 양말을 뿌릴 때 &lt;strong&gt;까지이 체계를 재귀 적으로 적용&lt;/strong&gt; &lt;strong&gt;하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b4b7ec4098550470ed2c4636c449a2c24d32ee0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, the question is basically:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;따라서 문제는 기본적으로 다음과 같습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08fda84558211c3c93b54ebc0219bb815255b9af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1:&lt;/strong&gt; Each time you put dirty socks in your laundry basket, tie them in a little knot. That way you will not have to do any sorting after the washing. Think of it like registering an index in a Mongo database. A little work ahead for some CPU savings in the future.</source>
          <target state="translated">&lt;strong&gt;해결 방법 1 :&lt;/strong&gt; 더러운 양말을 세탁 바구니에 넣을 때마다 작은 매듭으로 묶으십시오. 이렇게하면 세탁 후에 정렬 할 필요가 없습니다. Mongo 데이터베이스에 색인을 등록하는 것처럼 생각하십시오. 향후 약간의 CPU 절약을 위해 약간의 노력이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b93e25b8a424a36b38ce0b2f666db17b4cec3ad9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2:&lt;/strong&gt; If it's winter, you don't have to wear matching socks. We are programmers. Nobody needs to know, as long as it works.</source>
          <target state="translated">&lt;strong&gt;해결책 2 :&lt;/strong&gt; 겨울철이면 양말을 신지 않아도됩니다. 우리는 프로그래머입니다. 그것이 작동하는 한 아무도 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0094560f52b8dad6f4ad715c3c000c707e442bb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 3:&lt;/strong&gt; Spread the work. You want to perform such a complex CPU process asynchronously, without blocking the UI. Take that pile of socks and stuff them in a bag. Only look for a pair when you need it. That way the amount of work it takes is much less noticeable.</source>
          <target state="translated">&lt;strong&gt;해결책 3 : 일을&lt;/strong&gt; 전파하십시오. UI를 차단하지 않고 복잡한 CPU 프로세스를 비동기 적으로 수행하려고합니다. 그 양말 더미를 가지고 가방에 넣습니다. 필요할 때만 쌍을 찾으십시오. 그렇게하면 작업량이 눈에 띄게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="cd64c3cf6ffd817f997a05ddde37296211310d6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result&lt;/strong&gt; will have one or two piles: 1. &quot;matched&quot; and 2. &quot;missing&quot;</source>
          <target state="translated">&lt;strong&gt;결과&lt;/strong&gt; 에는 하나 또는 두 개의 파일이 있습니다 : 1. &quot;일치&quot;및 2. &quot;누락&quot;</target>
        </trans-unit>
        <trans-unit id="1873002ca8758724d2c9adf28e13baa534b32d50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are trying to solve the wrong problem.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;잘못된 문제를 해결하려고합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42553619c0d4d907f8c4939e4417b4728dc4eff8" translate="yes" xml:space="preserve">
          <source>A general &lt;em&gt;theoretical&lt;/em&gt; solution for a huge number of socks.</source>
          <target state="translated">수많은 양말에 대한 일반적인 &lt;em&gt;이론적&lt;/em&gt; 솔루션.</target>
        </trans-unit>
        <trans-unit id="86619e9b5473c8436c88e4580124cac4300c7011" translate="yes" xml:space="preserve">
          <source>A neat freak might use numeric labels for pairs as someone suggested.  This opens the door to a total ordering, which allows the human to use exactly the same algorithms we might with a CPU: binary search, trees, hashes, etc.</source>
          <target state="translated">깔끔한 괴물은 누군가가 제안한대로 쌍에 숫자 레이블을 사용할 수 있습니다. 이것은 전체 순서의 문을 열어 주므로 인간은 이진 검색, 트리, 해시 등 CPU와 동일한 알고리즘을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b68ea4fb20ff8e31763199ca38f49c47f03983" translate="yes" xml:space="preserve">
          <source>About parallelism:
As long as you toss both socks into the same bin, you can easily parallelize all of those steps.</source>
          <target state="translated">병렬 처리 정보 : 두 양말을 같은 통에 넣는 한 모든 단계를 쉽게 병렬 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f6fc8d26eb16b2c7196aa947f223e3e3ed467028" translate="yes" xml:space="preserve">
          <source>After eliminating the fluro coloured, the socks with stripes, and the three pairs of long socks, you might end up with mostly white socks roughly sorted by how worn they are.</source>
          <target state="translated">형광색, 줄무늬가있는 양말 및 3 쌍의 긴 양말을 제거한 후에는 대부분 흰색 양말이 마모 정도에 따라 분류 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98f0ebf5e1f426f9d4fb354b2d2f98129af56fdf" translate="yes" xml:space="preserve">
          <source>After that, there are only a few socks left. This is where I introduce previously unpaired socks into the system and process the remaining socks without any special algorithm - the remaining socks are very few and can be processed visually very fast.</source>
          <target state="translated">그 후에는 양말이 몇 개 남았습니다. 이전에 페어링되지 않은 양말을 시스템에 도입하고 특별한 알고리즘없이 나머지 양말을 처리하는 곳입니다. 남은 양말은 거의 없으며 시각적으로 매우 빠르게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f910680ab39d0aa8398bce15b13e098f9be2e9a8" translate="yes" xml:space="preserve">
          <source>After this, it's easy to do the hash partitioning algorithm. Usually, about 75% of the socks are already paired, leaving me with a very small subset of socks, and this subset is already (somewhat) clustered (I don't introduce much entropy into my basket after the preprocessing steps). Another thing is that the remaining clusters tend to be small enough to be handled at once, so it is possible to take a whole cluster out of the basket.</source>
          <target state="translated">이 후에는 해시 파티셔닝 알고리즘을 쉽게 수행 할 수 있습니다. 일반적으로 양말의 약 75 %가 이미 페어링되어 양말의 매우 작은 하위 집합으로 남겨 두고이 하위 집합이 이미 클러스터되어 있습니다 (전처리 단계 후에 바구니에 많은 엔트로피를 도입하지 않습니다). 또 다른 것은 나머지 클러스터가 한 번에 처리하기에 충분히 작은 경향이 있으므로 전체 클러스터를 바구니에서 꺼낼 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a610a16cc6741362976a74534a8c23c401cdcb8f" translate="yes" xml:space="preserve">
          <source>Almost all the other algorithms (including &lt;a href=&quot;https://stackoverflow.com/a/14419556/1042311&quot;&gt;the top scoring answer by usr&lt;/a&gt;) sort, then remove pairs. I find that, as a human, it is better to minimize the number of socks being considered at one time.</source>
          <target state="translated">거의 모든 다른 알고리즘 ( &lt;a href=&quot;https://stackoverflow.com/a/14419556/1042311&quot;&gt;usr의 최고 점수 답변&lt;/a&gt; 포함)을 정렬 한 다음 제거합니다. 인간으로서 한 번에 고려되는 양말의 수를 최소화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eccc8c5a89378f08c10b8d673e29520d1e8e7126" translate="yes" xml:space="preserve">
          <source>Also, there could be added check for damaged socks also, as if the removal of those. It could be inserted between 2 and 3, and between 13 and 14.</source>
          <target state="translated">또한, 양말을 제거하는 것처럼 손상된 양말도 검사 할 수 있습니다. 2와 3 사이, 13과 14 사이에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9788a20dd94a5a2bf372d767d6027859c72d11c2" translate="yes" xml:space="preserve">
          <source>Also, we don't need to assume a large number of socks, even for large families. Socks are taken out of the drawer and are worn, and then they are tossed in a place (maybe a bin) where they stay before being laundered. While I wouldn't call said bin a LIFO-Stack, I'd say it is safe to assume that</source>
          <target state="translated">또한 대가족에게도 많은 양말을 사용할 필요가 없습니다. 양말은 서랍에서 꺼내서 착용 한 다음 세탁하기 전에 보관할 수있는 장소 (통)에 던져집니다. 나는 bin을 LIFO-Stack이라고 말하지는 않지만, 가정하는 것이 안전하다고 말하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="157fc609ec55f17f263d7a3a005a4071e377c228" translate="yes" xml:space="preserve">
          <source>Although the outputs are not exactly the same (in one case, just a boolean. In the other case, the pairs of socks), the asymptotic complexities are the same.</source>
          <target state="translated">출력이 정확히 동일하지는 않지만 (한 경우 부울 만, 다른 경우에는 양말 쌍), 점근 적 복잡성은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="05e0d0df0a6446265996f77e214ab1168f512228" translate="yes" xml:space="preserve">
          <source>An alternative step 3 would involve comparing costs of buying the same amount of perhaps cheaper socks a few pairs at a time over the years and adding the cost of sorting socks, but take my word for it: buying in bulk is cheaper! Also, socks in storage increase in value at the rate of stock price inflation, which is more than you would get on many investments. Then again there is also storage cost, but socks really do not take much space on the top shelf of a closet.</source>
          <target state="translated">대안적인 3 단계는 수년에 걸쳐 같은 양의 싼 양말을 몇 쌍씩 구매하는 비용을 비교하고 양말을 분류하는 데 드는 비용을 추가하는 것을 포함하지만 대량 구매는 더 저렴합니다! 또한 스토리지의 양말은 주가 인플레이션 율에 따라 가치가 상승하므로 많은 투자에서 얻을 수있는 것 이상입니다. 그런 다음 스토리지 비용이 다시 발생하지만 양말은 옷장의 상단 선반에 많은 공간을 차지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3835c018ca31a4eabdd14cc9d36b8f5e0b2ee808" translate="yes" xml:space="preserve">
          <source>An obvious algorithm for sock sorting is:</source>
          <target state="translated">양말 정렬을위한 확실한 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56b599442bccb5b5949e6ad41c70544a44257d97" translate="yes" xml:space="preserve">
          <source>And more often than not, this is not just &lt;em&gt;any&lt;/em&gt; free time, it's &lt;em&gt;morning&lt;/em&gt; free time, which you could be spending in bed, or sipping your coffee, or leaving a bit early and not being caught in the traffic.</source>
          <target state="translated">그리고 더 자주, 이것은 자유 시간이 아니라 &lt;em&gt;아침&lt;/em&gt; 자유 시간입니다. &lt;em&gt;아침에&lt;/em&gt; 시간을 보내거나, 커피를 마시거나, 조금 일찍 떠나거나 교통 체증에 빠지지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="121979168ac388fe182e793a8f415d4c02e0bcfd" translate="yes" xml:space="preserve">
          <source>And there is a way!</source>
          <target state="translated">그리고 방법이 있습니다!</target>
        </trans-unit>
        <trans-unit id="aaed1a26327f668180ed38055a98d2f4a897c097" translate="yes" xml:space="preserve">
          <source>Applying the same idea to the practical problem of pairing socks, the apparent answer is: don't allow your socks to ever be unpaired. Socks are provided as a pair, put in the drawer as a pair (perhaps by balling them together), worn as a pair. But the point where unpairing is possible is in the washer, so all that's required is a physical mechanism that allows the socks to stay together and be washed efficiently.</source>
          <target state="translated">양말 짝짓기의 실제 문제에 동일한 아이디어를 적용 할 때 명백한 답은 양말이 짝을 이루지 않도록하는 것입니다. 양말은 한 쌍으로 제공되며, 서랍에 한 쌍으로 (아마 함께 묶어서) 서랍에 넣습니다. 그러나 페어링을 해제 할 수있는 시점은 세탁기에 있으므로 양말이 함께 머무르고 효율적으로 세척 할 수있는 물리적 메커니즘 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="4447172c03cd07d366eaa6901d47c0105462f432" translate="yes" xml:space="preserve">
          <source>As a computer scientist I was thinking what I could do? Sorting (according to size/color/...) of course came to mind to achieve an O(NlogN) solution.</source>
          <target state="translated">컴퓨터 과학자로서 내가 할 수있는 일을 생각하고 있었습니까? 물론 (크기 / 색상 / ...에 따라) 정렬은 O (NlogN) 솔루션을 달성하기 위해 떠 올랐습니다.</target>
        </trans-unit>
        <trans-unit id="dea5f13104d5d8bafb26f6f1728af7ebead57e19" translate="yes" xml:space="preserve">
          <source>As a practical solution:</source>
          <target state="translated">실용적인 해결책으로 :</target>
        </trans-unit>
        <trans-unit id="0330f3b9f6b91d26ecc04e1313146ad77b320f18" translate="yes" xml:space="preserve">
          <source>As rapidly as possible, remove socks from the unsorted pile one at a time and place in piles in front of you. The piles should be arranged somewhat space-efficiently, with all socks pointing the same direction; the number of piles is limited by the distance you can easily reach. The selection of a pile on which to put a sock should be -- as rapidly as possible -- by putting a sock on a pile of apparently like socks; the occasional type I (putting a sock on a pile it doesn't belong to) or type II (putting a sock in its own pile when there's an existing pile of like socks) error can be tolerated -- the most important consideration is &lt;em&gt;speed&lt;/em&gt;. Once all the socks are in piles, rapidly go through the multi-sock piles creating pairs and removing them (these are heading for the drawer). If there are non-matching socks in the pile, re-pile them to their best (within the as-fast-as-possible constraint) pile. When all the multi-sock piles have been processed, match up remaining pairable socks that weren't paired due to type II errors. Whoosh, you're done -- and I have a lot of socks and don't wash them until a large fraction are dirty. Another practical note: I flip the top of one of a pair of socks down over the other, taking advantage of their elastic properties, so they stay together while being transported to the drawer and while in the drawer.</source>
          <target state="translated">가능한 빨리 분류되지 않은 파일에서 양말을 한 번에 하나씩 제거하고 앞에있는 더미에 두십시오. 말뚝은 모든 공간이 같은 방향을 향하도록 공간 효율적으로 배치되어야한다. 파일 수는 쉽게 도달 할 수있는 거리에 따라 제한됩니다. 양말을 놓을 더미의 선택은 양말과 같은 양말 더미에 양말을 씌워서 가능한 한 빨리해야합니다. 가끔 발생하는 제 1 종 (속하지 않은 말뚝에 양말을 씌우는 것) 또는 제 2 종 (양말과 같은 기존 말뚝이있을 때 양말을 꽂는 것) 오류는 용인 될 수 있습니다. 가장 중요한 고려 사항은 &lt;em&gt;속도입니다&lt;/em&gt; . 모든 양말이 말뚝에 쌓이면 신속하게 쌍 양말 말뚝을 통해 페어를 만들어 제거합니다 (이것은 서랍으로 향합니다). 말뚝에 일치하지 않는 양말이있는 경우, 가능한 한 빠른 속도로 구속 된 말뚝으로 다시 쌓아 놓으십시오. 모든 멀티 양말 더미가 처리되면 유형 II 오류로 인해 페어링되지 않은 나머지 페어링 가능한 양말을 맞추십시오. 우와, 다 끝났어요. 양말이 많고 더러워 질 때까지 씻지 마세요. 또 다른 실용적인 참고 사항 : 나는 탄성 특성을 이용하여 양말 한 켤레 중 하나의 상단을 다른 양말보다 아래로 뒤집습니다. 따라서 서랍으로 운반하는 동안과 서랍에있는 동안 함께 머물러 있습니다.</target>
        </trans-unit>
        <trans-unit id="21c82dc8d9601ae12e034b45a03f0358de859eb2" translate="yes" xml:space="preserve">
          <source>As the architecture of the human brain is completely different than a modern CPU, this question makes no practical sense.</source>
          <target state="translated">인간 두뇌의 구조는 현대의 CPU와 완전히 다르기 때문에이 질문은 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9da0c9b1a26a80303bb8c443c01afa8a2584687" translate="yes" xml:space="preserve">
          <source>Assuming that the only operation for socks is to compare for equality, this algorithm is basically still an n&lt;sup&gt;2&lt;/sup&gt; algorithm, though I don't know about the average case (never learned to calculate that).</source>
          <target state="translated">양말의 유일한 연산이 평등을 비교하는 것이라고 가정하면이 알고리즘은 기본적으로 여전히 n &lt;sup&gt;2&lt;/sup&gt; 알고리즘이지만 평균 사례에 대해서는 알지 못합니다 (절대로 계산하는 법을 배운 적이 없음).</target>
        </trans-unit>
        <trans-unit id="9ecfa67dfd0923fad315f8a06acb48f7f0237861" translate="yes" xml:space="preserve">
          <source>At least this is what I am using in real life, and I find it very efficient. The downside is it requires a flat surface, but it's usually abundant.</source>
          <target state="translated">적어도 이것이 실제 생활에서 사용하는 것이므로 매우 효율적입니다. 단점은 평평한 표면이 필요하지만 일반적으로 풍부하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b86498f0344f03ab782a1075a31f259917a9553" translate="yes" xml:space="preserve">
          <source>At some point, the differences between socks are small enough that other people won't notice the difference, and any further matching effort is not needed.</source>
          <target state="translated">어떤 시점에서 양말의 차이는 다른 사람들이 그 차이를 느끼지 못할 정도로 작기 때문에 더 이상 일치하는 노력이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e52e0e243840d708880946b6c4315d013367de6" translate="yes" xml:space="preserve">
          <source>But for each sock to keep a reference to the other, there is a neat solution: a popper (or a 'snap button' if you're American), such as these:</source>
          <target state="translated">그러나 각 양말이 다른 양말에 대한 참조를 유지하기 위해 다음과 같은 깔끔한 해결책이 있습니다 : 포퍼 (또는 미국인 경우 '스냅 버튼').</target>
        </trans-unit>
        <trans-unit id="b59dc09b425cf2a04ad8751ed78176abb3f57590" translate="yes" xml:space="preserve">
          <source>By pulling the distinctive socks first, you leave space to &quot;zoom&quot; in on the features which are less distinctive, to begin with.</source>
          <target state="translated">독특한 양말을 먼저 잡아 당김으로써 덜 독특한 기능부터 시작하여 공간을 &quot;확대&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="325f07a647449aca13d04b404d5077e42950128f" translate="yes" xml:space="preserve">
          <source>By reducing my inputs to one of two types of socks (white socks for recreation, black socks for work), I only need to determine which of two socks I have in hand. (Technically, since they are never washed together, I have reduced the process to O(0) time)</source>
          <target state="translated">입력을 두 가지 유형의 양말 (레크리에이션 용 흰색 양말, 검은 색 양말 용 양말) 중 하나로 줄임으로써, 내가 가지고있는 두 양말 중 어느 양말 만 결정하면됩니다. (기술적으로는 결코 함께 씻지 않기 때문에 공정을 O (0) 시간으로 줄였습니다)</target>
        </trans-unit>
        <trans-unit id="839d4561e5360dfca7e45fa2801c421ef3ca26fb" translate="yes" xml:space="preserve">
          <source>Choose one of the socks and put it away (create a 'bucket' for that pair)</source>
          <target state="translated">양말 중 하나를 선택하여 치워주십시오 (해당 쌍의 '버킷'생성)</target>
        </trans-unit>
        <trans-unit id="5d6b924144b70d6a90942c0979240ccaa91f1233" translate="yes" xml:space="preserve">
          <source>Clearly, one cannot go faster than &lt;code&gt;O(N)&lt;/code&gt;, so we have reached the &lt;strong&gt;optimal lower bound&lt;/strong&gt;.</source>
          <target state="translated">분명히, &lt;code&gt;O(N)&lt;/code&gt; 보다 더 빨리 갈 수 없으므로 &lt;strong&gt;최적의 하한에&lt;/strong&gt; 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="9a74f91f894f5fdd53f2126400da6be5bbf36590" translate="yes" xml:space="preserve">
          <source>Combine with Other Task</source>
          <target state="translated">다른 작업과 결합</target>
        </trans-unit>
        <trans-unit id="8ac6a3ace758bdb634f5dc66fbca8858d699c4a7" translate="yes" xml:space="preserve">
          <source>Consider a hash-table of  size  'N'.</source>
          <target state="translated">크기가 'N'인 해시 테이블을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="be4d36fcb52cd8affab669c9c320903855e4dd53" translate="yes" xml:space="preserve">
          <source>Consider than if you draw only one sock for the second stack of socks, as you are doing, your odds of finding the matching sock in a naive search is quite low.</source>
          <target state="translated">당신이하고있는 것처럼 두 번째 양말 묶음에 양말을 하나만 그리는 것보다 순진한 검색에서 일치하는 양말을 찾을 확률은 매우 낮습니다.</target>
        </trans-unit>
        <trans-unit id="f9b1944832d9453a7dc17748fdc3d9173cbd95c9" translate="yes" xml:space="preserve">
          <source>Cost: Moving socks -&amp;gt; high, finding/search socks in line -&amp;gt; small</source>
          <target state="translated">비용 : 양말 이동-&amp;gt; 높음, 양말 찾기 / 검색-&amp;gt; 소형</target>
        </trans-unit>
        <trans-unit id="05201805c52c192640e03bce4060ac08d6051851" translate="yes" xml:space="preserve">
          <source>Create a hash table which will be used for unmatched socks, using the pattern as the hash. Iterate over the socks one by one. If the sock has a pattern match in the hash table, take the sock out of the table and make a pair. If the sock does not have a match, put it into the table.</source>
          <target state="translated">패턴을 해시로 사용하여 일치하지 않는 양말에 사용될 해시 테이블을 만듭니다. 양말을 하나씩 반복하십시오. 양말이 해시 테이블에서 패턴과 일치하는 경우 양말을 테이블에서 꺼내 쌍을 만드십시오. 양말이 일치하지 않으면 테이블에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="ece5b7e4f44f0c60b7df2b4d7656e3eb3246bbfd" translate="yes" xml:space="preserve">
          <source>Do until A is empty.</source>
          <target state="translated">A가 비워 질 때까지하십시오.</target>
        </trans-unit>
        <trans-unit id="a3af62234185a8fbf95199db3ed4496b2e1b062b" translate="yes" xml:space="preserve">
          <source>Do until both X and Y is empty.</source>
          <target state="translated">X와 Y가 모두 비워 질 때까지하십시오.</target>
        </trans-unit>
        <trans-unit id="e74f486c764075c4dfed8abc5b9386d07590d29c" translate="yes" xml:space="preserve">
          <source>Don't waste your time moving socks around or looking for the best match, this all should be done in O(n), which we would also need for just putting them on the line unsorted.
The socks aren't paired yet, we only have several similarity clusters on the line. It's helpful that we have a limited set of socks here, as this helps us to create &quot;good&quot; clusters (for example, if there are only black socks in the set of socks, clustering by colours would not be the way to go)</source>
          <target state="translated">양말을 움직이거나 최고의 경기를 찾는 데 시간을 낭비하지 마십시오.이 모든 것은 O (n)에서 수행해야하며, 분류되지 않은 라인에 올려 놓아야합니다. 양말은 아직 페어링되지 않았으며, 몇 개의 유사성 클러스터 만 있습니다. 여기에 양말 세트가 제한되어있어 &quot;좋은&quot;클러스터를 만들 수 있습니다 (예 : 양말 세트에 검은 색 양말 만있는 경우 색상별로 클러스터링 할 수 없음)</target>
        </trans-unit>
        <trans-unit id="e9b450d14bc2363d292c84f17cfad5cfbd58a458" translate="yes" xml:space="preserve">
          <source>Done</source>
          <target state="translated">Done</target>
        </trans-unit>
        <trans-unit id="9ec877009e8b5ea7edaecdf46b39cdf271ac5e08" translate="yes" xml:space="preserve">
          <source>Feel free to write down the formula to calculate how many samples you have to draw for a 50% odds of a match. IIRC it's an hypergeometric law.</source>
          <target state="translated">일치 확률이 50 % 일 때 얼마나 많은 샘플을 그려야하는지 계산하려면 공식을 적어 두십시오. IIRC는 초 지오메트리 법칙입니다.</target>
        </trans-unit>
        <trans-unit id="ee75e1685f87ca197f6c3aaaa97916949e86e0db" translate="yes" xml:space="preserve">
          <source>Find a pair by looking at the socks on the floor.</source>
          <target state="translated">바닥에 양말을 보면서 쌍을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="2d7f4a781c3305161bd0ab2917bdad576999ed2c" translate="yes" xml:space="preserve">
          <source>Find a sock you like. Take all relevant features into account: colour in different lighting conditions, overall quality and durability, comfort in different climatic conditions, and odour absorption. Also important is, they should not lose elasticity in storage, so natural fabrics are good, and they should be available in a plastic wrapping.</source>
          <target state="translated">당신이 좋아하는 양말을 찾으십시오. 다양한 조명 조건에서의 색상, 전반적인 품질 및 내구성, 다양한 기후 조건에서의 편안함 및 냄새 흡수 등 모든 관련 기능을 고려하십시오. 또한 중요한 점은 보관시 탄성을 잃지 않아야하므로 천연 직물이 좋고 플라스틱 포장재로 제공해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9a8d801aad71c6f999c991c92a663302901ccc9" translate="yes" xml:space="preserve">
          <source>Find all matched pairs, pack it and move packed pairs to &quot;matched&quot; pile;
 If there were no new matches - increment &quot;index&quot; by 1</source>
          <target state="translated">일치하는 쌍을 모두 찾아서 포장 한 다음 묶은 쌍을 &quot;일치 한&quot;파일로 옮깁니다. 새로운 일치 항목이없는 경우 &quot;인덱스&quot;를 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="52c3a2cfe2904b404c77eec5836501de1058b709" translate="yes" xml:space="preserve">
          <source>Find its match.</source>
          <target state="translated">일치하는 것을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c0a4340783c31b2ef43b6cdc9d203753e623f8c3" translate="yes" xml:space="preserve">
          <source>Find its pair</source>
          <target state="translated">쌍 찾기</target>
        </trans-unit>
        <trans-unit id="9398e96bcda6ff722938ce7ced4416bbac5aa5f1" translate="yes" xml:space="preserve">
          <source>Find most distinctive sock.</source>
          <target state="translated">가장 독특한 양말을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="82f8de3c35ca9b182c746b9a61ec6f2e62e7264c" translate="yes" xml:space="preserve">
          <source>First you can choose (hers, mine) - split them into 2 piles,</source>
          <target state="translated">먼저 (그녀, 내)를 선택할 수 있습니다-두 더미로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="893e0080cad23ba3476d1e48d4706a557776aeeb" translate="yes" xml:space="preserve">
          <source>For a 'pair' object that keeps a pointer to each sock we could have a cloth bag that we use to keep the socks together. This seems like massive overhead.</source>
          <target state="translated">각 양말에 대한 포인터를 유지하는 '쌍'개체의 경우 양말을 함께 보관하는 데 사용할 천 가방을 가질 수 있습니다. 이것은 엄청난 오버 헤드처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="077ecc6cb20560a33edffb3287fdf7ac14426d24" translate="yes" xml:space="preserve">
          <source>For all remaining socks, I assume that their counterparts are still unwashed and put them away for the next iteration. If you register a growth of unpaired socks over time (a &quot;sock leak&quot;), you should check your bin - it might get randomized (do you have cats which sleep in there?)</source>
          <target state="translated">남아있는 모든 양말에 대해, 나는 그들의 대응 물이 여전히 씻지 않은 것으로 가정하고 다음 반복을 위해 그들을 버립니다. 시간이 지남에 따라 짝을 이루지 않은 양말의 성장을 등록하면 ( &quot;양말 누출&quot;) 쓰레기통을 확인해야합니다. 쓰레기통이 무작위로 나올 수 있습니다 (잠자는 고양이가 있습니까?)</target>
        </trans-unit>
        <trans-unit id="cc92f3e9adf433b615dccfeb6da282fce4ea8901" translate="yes" xml:space="preserve">
          <source>For each color of socks, &lt;strong&gt;form a pile&lt;/strong&gt;. Iterate over all socks in your input basket &lt;strong&gt;and distribute them onto the color piles&lt;/strong&gt;.</source>
          <target state="translated">양말의 각 색상에 &lt;strong&gt;대해 더미를 형성하십시오&lt;/strong&gt; . 입력 바구니에있는 모든 양말을 반복 &lt;strong&gt;하여 색상 더미에 분배&lt;/strong&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="d6414c797002dc91c1ae83eaf49240cdcbf24e18" translate="yes" xml:space="preserve">
          <source>For each line X and Y</source>
          <target state="translated">각 라인 X 및 Y</target>
        </trans-unit>
        <trans-unit id="5855dab75f8b813fca7ffaa714ea108a4295227b" translate="yes" xml:space="preserve">
          <source>For the first sock, or if all previously-chosen socks have been paired, simply place the sock into the first &quot;slot&quot; of an &quot;array&quot; of unpaired socks in front of you.</source>
          <target state="translated">첫 번째 양말의 경우 또는 이전에 선택한 모든 양말이 쌍을 이루는 경우 양말을 앞쪽에있는 짝을 이루지 않은 양말의 &quot;배열&quot;의 첫 번째 &quot;슬롯&quot;에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="894192607ac808554f03c075fd0655a37e1ad671" translate="yes" xml:space="preserve">
          <source>For the following runtime analysis of pairing &lt;code&gt;n&lt;/code&gt; pairs of socks, we suppose that at least half of the &lt;code&gt;2n&lt;/code&gt; socks aren't hidden after step 1. So in the average case we can find &lt;code&gt;n/2&lt;/code&gt; pairs. This means that the loop is step 4 is executed &lt;code&gt;O(log n)&lt;/code&gt; times. Step 2 is executed &lt;code&gt;O(n^2)&lt;/code&gt; times. So we can conclude:</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 쌍의 양말을 페어링하는 다음 런타임 분석의 경우 &lt;code&gt;2n&lt;/code&gt; 양말의 적어도 절반이 1 단계 후에 숨겨지지 않은 것으로 가정합니다. 따라서 평균적으로 &lt;code&gt;n/2&lt;/code&gt; 쌍을 찾을 수 있습니다. 이것은 루프가 단계 4가 &lt;code&gt;O(log n)&lt;/code&gt; 번 실행됨을 의미한다. 2 단계는 &lt;code&gt;O(n^2)&lt;/code&gt; 번 실행됩니다. 따라서 결론을 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd22dd03c04d34755de0454c107040828d993fa6" translate="yes" xml:space="preserve">
          <source>Forget &quot;index&quot;</source>
          <target state="translated">&quot;인덱스&quot;를 잊어 버려</target>
        </trans-unit>
        <trans-unit id="754feeeb1411a93845cc30e2f433edcea6d8f1d0" translate="yes" xml:space="preserve">
          <source>From pile A of all socks:</source>
          <target state="translated">모든 양말 더미 A에서 :</target>
        </trans-unit>
        <trans-unit id="88af6c6ae694d3f0adbd64981b429a7c2015afc5" translate="yes" xml:space="preserve">
          <source>From your question it is clear you don't have much actual experience with laundry :). You need an algorithm that works well with a small number of non-pairable socks.</source>
          <target state="translated">귀하의 질문에서 세탁에 대한 실제 경험이 많지 않다는 것이 분명합니다 :). 적은 수의 페어링 할 수없는 양말과 잘 작동하는 알고리즘이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0444a1d3195984e21f70709ff60bf0a46830a14e" translate="yes" xml:space="preserve">
          <source>Get rid of your old socks.</source>
          <target state="translated">오래된 양말을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a1a874f464be482c37caf7802d65a53aaacd038a" translate="yes" xml:space="preserve">
          <source>Given a pile of &lt;code&gt;n&lt;/code&gt; pairs of socks, containing &lt;code&gt;2n&lt;/code&gt; elements (assume each sock has exactly one matching pair), what is the best way to pair them up efficiently with up to logarithmic extra space? (I believe I can remember that amount of info if needed.)</source>
          <target state="translated">&lt;code&gt;2n&lt;/code&gt; 요소를 포함하는 &lt;code&gt;n&lt;/code&gt; 쌍의 양말 더미 (각 양말에 정확히 한 쌍의 일치하는 쌍이 있다고 가정)가 있으면 최대 로그 공간까지 효율적으로 묶을 수있는 가장 좋은 방법은 무엇입니까? (필요하다면 그 정도의 정보를 기억할 수 있다고 생각합니다.)</target>
        </trans-unit>
        <trans-unit id="92391b2bac5f63b1732ccf6a829b75982b2d6b4f" translate="yes" xml:space="preserve">
          <source>Go to 1</source>
          <target state="translated">1로 이동</target>
        </trans-unit>
        <trans-unit id="7548a76daeaf6efed0b0d32caeb5242aedd1b6ef" translate="yes" xml:space="preserve">
          <source>Grab a sock at random from the pile.</source>
          <target state="translated">더미에서 양말을 무작위로 잡습니다.</target>
        </trans-unit>
        <trans-unit id="8b31726f5fe78e7abfdb271081348d3c49ef8d7a" translate="yes" xml:space="preserve">
          <source>Hashing or other not-in-place solutions are not an option, because I am not able to duplicate my socks (though it could be nice if I could).</source>
          <target state="translated">내 양말을 복제 할 수 없기 때문에 해싱 또는 다른 비 현장 솔루션은 옵션이 아닙니다 (가능한 경우 좋을 수도 있지만).</target>
        </trans-unit>
        <trans-unit id="0bebef8e20477195eae330c945bf1f33000ef38c" translate="yes" xml:space="preserve">
          <source>Have it Almost &lt;code&gt;O(n)&lt;/code&gt;!</source>
          <target state="translated">거의 &lt;code&gt;O(n)&lt;/code&gt; 하세요!</target>
        </trans-unit>
        <trans-unit id="d3cc97a68c770f1ea7c6ba0f7a34ec7739feed82" translate="yes" xml:space="preserve">
          <source>Here's an Omega(n log n) lower bound in comparison based model. (The only valid operation is comparing two socks.)</source>
          <target state="translated">다음은 비교 기반 모델에서 Omega (n log n) 하한입니다. (유일한 유효한 작업은 두 양말을 비교하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="08f1f9a1a68f065efbd777b85e911439d922e715" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for put_socks_on_line():</source>
          <target state="translated">put_socks_on_line ()의 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54268b27bb372ae27ec075e414013dd493b79119" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for sort_remaining_clusters():</source>
          <target state="translated">sort_remaining_clusters ()의 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a12197b6379a8cd2d9de831467c2eea0d417e206" translate="yes" xml:space="preserve">
          <source>Here's the algorithm for take_socks_from_line():</source>
          <target state="translated">take_socks_from_line ()의 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">도움이 되었기를 바랍니다!</target>
        </trans-unit>
        <trans-unit id="5435330177144a505ebd78530841aed23ef79bd1" translate="yes" xml:space="preserve">
          <source>How to pair socks from a pile efficiently</source>
          <target state="translated">더미에서 양말을 효율적으로 페어링하는 방법</target>
        </trans-unit>
        <trans-unit id="0163309c2cf5dde27bf33b63dc03540e97a8c089" translate="yes" xml:space="preserve">
          <source>However in real life when the number of socks is relatively small (constant), these theoretically optimal algorithms wouldn't work well. It might take even more time than sequential search, which theoretically requires quadratic time.</source>
          <target state="translated">그러나 양말의 수가 상대적으로 적은 (일정한) 실제 생활에서 이러한 이론적으로 최적의 알고리즘은 제대로 작동하지 않습니다. 이론적으로 2 차 시간이 필요한 순차 검색보다 시간이 더 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c187385279c8ededa5efc4f1fe03ebf17e729283" translate="yes" xml:space="preserve">
          <source>However mechanical physics give us some goodies as well. We are not limited to move at most one sock with an arm. We can move a whole couple of them at once.</source>
          <target state="translated">그러나 기계 물리학은 우리에게도 장점을 제공합니다. 우리는 팔로 최대 하나의 양말을 움직일 수 있습니다. 우리는 한 번에 전체 몇 개를 움직일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eb82567512fc8943c9bca03d3dcc2dfbfc9658a" translate="yes" xml:space="preserve">
          <source>However, as this have simillar complexity as selection sort, the time taken is far less due to the speeds of I/O(moving socks) and search(searching the line for a sock).</source>
          <target state="translated">그러나 이것은 선택 정렬과 유사성이 복잡하기 때문에 I / O (이동 양말) 및 검색 (삭스 라인 검색)의 속도로 인해 걸리는 시간이 훨씬 짧습니다.</target>
        </trans-unit>
        <trans-unit id="2e5ae82866972c6fb5d15e4d37146f8fd8f90802" translate="yes" xml:space="preserve">
          <source>Human beings will use various strategies to effect these. &lt;a href=&quot;http://garfield.library.upenn.edu/classics1979/A1979HX09600001.pdf&quot;&gt;Human memory &lt;em&gt;is&lt;/em&gt; associative&lt;/a&gt;, something like a hash table where feature sets of stored values are paired with the corresponding values themselves. For example, the concept of &quot;red car&quot; maps to all the red cars a person is capable of remembering. Someone with a perfect memory has a perfect mapping.  Most people are imperfect in this regard (and most others).  The associative map has a limited capacity. Mappings may &lt;em&gt;bleep&lt;/em&gt; out of existence under various circumstances (one beer too many), be recorded in error (&quot;I though her name was Betty, not Nettie&quot;), or never be overwritten even though we observe that the truth has changed (&quot;dad's car&quot; evokes &quot;orange Firebird&quot; when we actually knew he'd traded that in for the red Camaro).</source>
          <target state="translated">인간은이를 위해 다양한 전략을 사용할 것입니다. &lt;a href=&quot;http://garfield.library.upenn.edu/classics1979/A1979HX09600001.pdf&quot;&gt;휴먼 메모리 &lt;em&gt;는&lt;/em&gt;&lt;/a&gt; 저장된 값의 기능 세트가 해당 값 자체와 쌍을 이루는 해시 테이블과 같이 연관성 이 있습니다. 예를 들어, &quot;빨간 차&quot;라는 개념은 사람이 기억할 수있는 모든 빨간 차에 매핑됩니다. 완벽한 메모리를 가진 사람에게는 완벽한 매핑이 있습니다. 대부분의 사람들은 이와 관련하여 불완전합니다. 연관 맵의 용량이 제한되어 있습니다. 매핑은 다양한 상황에서 존재하지 않을 수 있습니다 (한 맥주가 너무 많음). 오류 ( &quot;그녀의 이름은 네티가 아니라 베티 였지만&quot;)로 기록되거나 진실이 변경되었다는 것을 발견하더라도 덮어 쓰지 않을 수 있습니다 ( &quot;아빠의 우리가 실제로 빨간 카마로와 거래했다는 것을 알았을 때 car &quot;는&quot;오렌지 파이어 버드 &quot;를 연상시킵니다.</target>
        </trans-unit>
        <trans-unit id="be87a28a5429a75a2d77e39569b97b2cef88f1c6" translate="yes" xml:space="preserve">
          <source>Humans can win over CPU algorithms using the fact that &quot;finding a matching pair&quot; can be one operation for a set that isn't too big.</source>
          <target state="translated">인간은 &quot;일치하는 쌍 찾기&quot;가 너무 크지 않은 세트에 대해 하나의 작업이 될 수 있다는 사실을 사용하여 CPU 알고리즘을 이길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1ed976246d93e04e79fea702823d280ba48c2ad" translate="yes" xml:space="preserve">
          <source>I came out with another solution which would not promise fewer operations, neither less time consumption, but it should be tried to see if it can be a good-enough heuristic to provide less time consumption in huge series of sock pairing.</source>
          <target state="translated">나는 적은 작업, 적은 시간 소비를 약속하지 않는 다른 솔루션을 찾았지만, 일련의 양말 쌍에서 적은 시간의 소비를 제공하는 충분한 휴리스틱이 될 수 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0d5c8c30ccdae2afc794d4c2db85857ecf68b61" translate="yes" xml:space="preserve">
          <source>I do that every morning and rarely need more than three draws - but I have &lt;code&gt;n&lt;/code&gt; similar pairs (around 10, give or take the lost ones) of &lt;code&gt;m&lt;/code&gt; shaped white socks. Now you can estimate the size of my stack of stocks :-)</source>
          <target state="translated">나는 매일 아침 그렇게하고 거의 3 개 이상의 무승부를 필요로하지 않는다. 그러나 나는 &lt;code&gt;m&lt;/code&gt; 모양의 흰색 양말과 비슷한 쌍 (약 10 개, 잃어버린 것을주고 받음)이있다. 이제 주식의 스택 크기를 추정 할 수 있습니다 :-)</target>
        </trans-unit>
        <trans-unit id="b28189bbbd02c084d10ef3c4022c033ec385886f" translate="yes" xml:space="preserve">
          <source>I do this by:</source>
          <target state="translated">나는 이것을 다음과 같이한다 :</target>
        </trans-unit>
        <trans-unit id="f58214503dfea8f36b2d81a7d7e31591c0696f80" translate="yes" xml:space="preserve">
          <source>I found integrating the process of sorting into hanging to dry makes it a breeze. I need to pick up each sock anyway, and hang it (move) and it costs me about nothing to hang it in a specific place on the strings. Now just not to force search of the whole buffer (the strings) I choose to place socks by color/shade. Darker left, brighter right, more colorful front etc. Now before I hang each sock, I look in its &quot;right vicinity&quot; if a matching one is there already - this limits &quot;scan&quot; to 2-3 other socks - and if it is, I hang the other one right next to it. Then I roll them into pairs while removing from the strings, when dry.</source>
          <target state="translated">건조 과정에 걸이하는 과정을 통합하면 산들 바람이됩니다. 어쨌든 각 양말을 집어 들고 걸어 (이동) 문자열의 특정 장소에 매달아 놓는 데 비용이 들지 않습니다. 이제 전체 버퍼 (열)를 강제로 검색하지 않기 위해 양말을 색상 / 음영으로 배치하기로 선택했습니다. 더 어두운 왼쪽, 더 밝은 오른쪽, 더 화려한 전면 등. 각 양말을 걸기 전에 일치하는 양말이 이미있는 경우 &quot;오른쪽 부근&quot;을 살펴 봅니다. 이렇게하면 &quot;스캔&quot;이 2-3 개의 다른 양말로 제한됩니다. , 나는 바로 옆에 다른 것을 걸었다. 그런 다음 건조 할 때 끈에서 제거하면서 쌍으로 굴립니다.</target>
        </trans-unit>
        <trans-unit id="2af9d76529a0f3da9452d50f18323e0df517ebc3" translate="yes" xml:space="preserve">
          <source>I had derived this as a part of another puzzle,but I would be happy to be proven wrong. 
&lt;a href=&quot;https://appolo85.wordpress.com/2012/07/25/some-fun-with-hash-table-performance-analysis/&quot;&gt;Here's my blog article on the same&lt;/a&gt;</source>
          <target state="translated">나는 이것을 다른 퍼즐의 일부로 도출했지만 잘못되었다는 것이 기쁘다. &lt;a href=&quot;https://appolo85.wordpress.com/2012/07/25/some-fun-with-hash-table-performance-analysis/&quot;&gt;여기에 내 블로그 기사가 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d670bfbf52f40edfc5d3d99f6588d8b35cfcbaa" translate="yes" xml:space="preserve">
          <source>I have taken simple steps to reduce my effort into a process taking O(1) time.</source>
          <target state="translated">O (1) 시간이 걸리는 프로세스로의 노력을 줄이기 위해 간단한 단계를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="6f7a73657ec6fa088026a984672b83ade80856e7" translate="yes" xml:space="preserve">
          <source>I hope I can contribute something new to this problem. I noticed that all of the answers neglect the fact that there are two points where you can perform &lt;strong&gt;preprocessing&lt;/strong&gt;, without slowing down your overall laundry performance.</source>
          <target state="translated">이 문제에 새로운 것을 기여할 수 있기를 바랍니다. 나는 모든 답변이 전체 세탁 성능을 저하시키지 않으면 서 &lt;strong&gt;전처리&lt;/strong&gt; 를 수행 할 수있는 두 가지 점이 있다는 사실을 무시한다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="712bf975bcdafbec473428cad084553f88032e4b" translate="yes" xml:space="preserve">
          <source>I know that these algorithms take a lot of assumptions: a bin which acts as some sort of LIFO stack, a limited, normal washing machine, and a limited, normal clothesline - but this still works with very large numbers of socks.</source>
          <target state="translated">나는 이러한 알고리즘이 많은 가정을 취한다는 것을 알고 있습니다 : 일종의 LIFO 스택, 제한된 세탁기 및 제한된 빨랫줄 역할을하는 쓰레기통-여전히 많은 양말과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="76250d1db233c115621eea33b2e23f2fa2575836" translate="yes" xml:space="preserve">
          <source>I should point out that in order to improve the speed of the remaining steps, it is wise not to randomly pick the next sock, but to sequentially take sock after sock from each cluster.
Both preprocessing steps don't take more time than just putting the socks on the line or in the basket, which we have to do no matter what, so this should greatly enhance the laundry performance.</source>
          <target state="translated">나머지 단계의 속도를 높이려면 다음 양말을 무작위로 선택하는 것이 아니라 각 클러스터에서 양말 후 양말을 순차적으로 가져가는 것이 현명합니다. 두 전처리 단계는 양말을 줄이나 바구니에 넣는 것보다 시간이 오래 걸리지 않습니다. 우리는 무엇이든 상관없이 세탁 성능을 크게 향상시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="059e704445c273ca6d35e7eca97772e45a2005db" translate="yes" xml:space="preserve">
          <source>I think that there should be an Omega(n&lt;sup&gt;2&lt;/sup&gt;) bound for the original problem if you allow equality tests only. My intuition is: Consider a graph where you add an edge after a test, and argue that if the graph is not dense the output is not uniquely determined.</source>
          <target state="translated">평등 테스트 만 허용하는 경우 원래 문제에 대해 Omega (n &lt;sup&gt;2&lt;/sup&gt; )가 있어야한다고 생각합니다. 내 직감은 : 테스트 후 가장자리를 추가하는 그래프를 고려하고 그래프가 조밀하지 않으면 출력이 고유하게 결정되지 않는다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="efa09f0b1f8cd3ce6a3acb81e6f0774e3942dc69" translate="yes" xml:space="preserve">
          <source>I will appreciate an answer that addresses the following aspects:</source>
          <target state="translated">다음과 같은 측면을 다루는 답변에 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="b480ebea69ff0685142986485477474b5d752c12" translate="yes" xml:space="preserve">
          <source>I'm looking forward to hear about any experiences or corrections.</source>
          <target state="translated">나는 경험이나 수정에 대해 듣고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="7e3fa720280a90386643c5f943bbc31f1027bcda" translate="yes" xml:space="preserve">
          <source>I've finished pairing my socks just right now, and I found that the best way to do it is the following:</source>
          <target state="translated">지금 바로 양말 페어링을 마쳤으며 최선의 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b298e00cd80e135c4ae40839f21a896eee2181a4" translate="yes" xml:space="preserve">
          <source>If &quot;index&quot; is greater then 2 (this could be value dependent on sock
 number because with greater number of socks there are less chance to
  pair them blindly) go to 11</source>
          <target state="translated">&quot;index&quot;가 2보다 크면 (양말의 수가 많을수록 맹목적으로 짝을 지을 기회가 적으므로 양말 수에 따라 값이 달라질 수 있음) 11로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="428e83ad437da92aef4bb4acff910ff3919184bd" translate="yes" xml:space="preserve">
          <source>If each sock had an integer called &quot;PairID&quot; one could easily distribute them into 10 buckets according to &lt;code&gt;PairID % 10&lt;/code&gt; (the last digit).</source>
          <target state="translated">각 양말에 &quot;PairID&quot;라는 정수가 있으면 &lt;code&gt;PairID % 10&lt;/code&gt; (마지막 숫자)에 따라 10 개의 버킷으로 쉽게 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68824b3b629564ab1d8b0bad06e1c81bc8489125" translate="yes" xml:space="preserve">
          <source>If match found pair it, pack pair and move it to the &quot;matched&quot; pile</source>
          <target state="translated">일치하는 것이 발견되면 쌍을 포장하고 &quot;일치 한&quot;파일로 옮깁니다.</target>
        </trans-unit>
        <trans-unit id="b8510e4192393a95bad638ba90d06ef53c82e071" translate="yes" xml:space="preserve">
          <source>If the &quot;move&quot; operation is fairly expensive, and the &quot;compare&quot; operation is cheap, and you need to move the whole set anyway, into a buffer where search is much faster than in original storage... just integrate sorting into the obligatory move.</source>
          <target state="translated">&quot;이동&quot;작업이 상당히 비싸고 &quot;비교&quot;작업이 저렴하고 어쨌든 전체 세트를 원래 스토리지보다 검색 속도가 훨씬 빠른 버퍼로 이동해야하는 경우 정렬을 필수 항목으로 통합하기 만하면됩니다. 움직임.</target>
        </trans-unit>
        <trans-unit id="9b3e803c4a76f4c4bd7562f58a50ba5f385ebf8f" translate="yes" xml:space="preserve">
          <source>If the next one is the pair of the previous one, then put it to the existing bucket, otherwise create a new one.</source>
          <target state="translated">다음 항목이 이전 항목의 쌍인 경우 기존 버킷에 넣고 그렇지 않으면 새 버킷을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4a8ea1dd91e78f2f6ed036a3127326ca0c1544c5" translate="yes" xml:space="preserve">
          <source>If there are less then 6 socks, go to 11.</source>
          <target state="translated">양말이 6 개 미만이면 11로 가십시오.</target>
        </trans-unit>
        <trans-unit id="5101d1843bf2d194d47695b1f7bbc961cb8fc0b4" translate="yes" xml:space="preserve">
          <source>If there are still more then one socks go to 12</source>
          <target state="translated">여전히 양말이 하나 더 있으면 12 개로갑니다.</target>
        </trans-unit>
        <trans-unit id="b79f9eb2311d2f31b42294fff21e572d50944666" translate="yes" xml:space="preserve">
          <source>If there is just one left go to 14</source>
          <target state="translated">하나만 남은 경우 14로 이동</target>
        </trans-unit>
        <trans-unit id="0580e1c44a88013044e269db8383aef639694455" translate="yes" xml:space="preserve">
          <source>If there is no match, put it on the &quot;missing&quot; pile.</source>
          <target state="translated">일치하는 것이 없으면 &quot;누락 된&quot;파일 위에 놓으십시오.</target>
        </trans-unit>
        <trans-unit id="a78596387c9d98455857ff9c74f61a0ca08821df" translate="yes" xml:space="preserve">
          <source>If there is no pair for the sock, move it to the &quot;missing&quot; pile</source>
          <target state="translated">양말을위한 쌍이 없다면, &quot;누락 된&quot;말뚝으로 옮기십시오.</target>
        </trans-unit>
        <trans-unit id="c1faf9fe0339936f19f4a80510b7ee0dc13723d0" translate="yes" xml:space="preserve">
          <source>If we assume normal distribution, then the estimated number of 'insertions'  to have atleast one sock mapped to one bucket is NlogN  (ie, all buckets are full)</source>
          <target state="translated">정규 분포를 가정하면 하나의 버킷에 하나의 양말이 매핑 된 것으로 예상되는 '삽입'수는 NlogN입니다 (즉, 모든 버킷이 가득 참).</target>
        </trans-unit>
        <trans-unit id="7fee5c386c3eac901a5e47b38f613ae422e201ea" translate="yes" xml:space="preserve">
          <source>If you can pick a limited number of attributes, but enough attributes that can uniquely identify each pair, you should be done in O(k * n), which is O(n) if we can consider k is limited.</source>
          <target state="translated">제한된 수의 속성을 선택할 수 있지만 각 쌍을 고유하게 식별 할 수있는 충분한 속성을 선택할 수있는 경우 k가 제한되는 것으로 간주 될 수있는 경우 O (n) 인 O (k * n)에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="362a61837395e933805325f6b6ebe951c78dd045" translate="yes" xml:space="preserve">
          <source>If you chose a fancy pair with different left and right sock, doing a full bucket sort to left and right foot buckets take O(N+M), where N is the number of socks and M is same as above. Somebody else can give the formula for average iterations of finding the first pair, but worst case for finding a pair with blind search is N/2+1, which becomes astronomically unlikely case for reasonable N. This can be sped up by using advanced image recognition algorithms and heuristics, when scanning the pile of unsorted socks with &lt;a href=&quot;http://www.urbandictionary.com/define.php?term=Mk1%20eyeball&quot;&gt;Mk1 Eyeball&lt;/a&gt;.</source>
          <target state="translated">왼쪽과 오른쪽 양말이 다른 멋진 페어를 선택한 경우 왼쪽과 오른쪽 발 버킷에 전체 버킷 정렬을 수행하면 O (N + M)을 사용합니다. 여기서 N은 양말 수이고 M은 위와 같습니다. 다른 사람이 첫 번째 쌍을 찾는 평균 반복에 대한 공식을 제공 할 수 있지만 블라인드 검색을 사용하는 쌍을 찾는 최악의 경우는 N / 2 + 1이며 합리적인 N의 경우 천문학적으로는 거의 불가능합니다. 이는 고급 이미지를 사용하여 가속화 할 수 있습니다 &lt;a href=&quot;http://www.urbandictionary.com/define.php?term=Mk1%20eyeball&quot;&gt;Mk1 Eyeball을 사용&lt;/a&gt; 하여 분류되지 않은 양말 더미를 스캔 할 때 인식 알고리즘 및 휴리스틱.</target>
        </trans-unit>
        <trans-unit id="14a24a331e031cc668435241346b7c07a641d7fb" translate="yes" xml:space="preserve">
          <source>If you do not, put the current sock into the first open slot in the array.</source>
          <target state="translated">그렇지 않으면 현재 양말을 어레이의 첫 번째 열린 슬롯에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="71950a186d51133a9e0950587efebd65ce355f77" translate="yes" xml:space="preserve">
          <source>If you find an acceptable match, put both socks together and remove them from the array.</source>
          <target state="translated">허용되는 일치하는 것을 찾으면 두 양말을 함께 모아 어레이에서 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6f824c95564ff831ff4658d289a3cc3fbd50a604" translate="yes" xml:space="preserve">
          <source>If you have 1000 socks, with 8 colors and an average distribution, you can make 4 piles of each 125 socks in c*n time. With a threshold of 5 socks you can sort every pile in 6 runs. (Counting 2 seconds to throw a sock on the right pile it will take you little under 4 hours.)</source>
          <target state="translated">8 개의 색상과 평균 분포를 가진 1000 개의 양말이 있다면, 각 125 개의 양말을 4 개씩 c * n 시간 안에 만들 수 있습니다. 5 개의 양말 임계 값을 사용하면 모든 더미를 6 개의 런으로 분류 할 수 있습니다. (오른쪽 더미에 양말을 던지기 위해 2 초를 세면 4 시간 미만의 시간이 걸립니다.)</target>
        </trans-unit>
        <trans-unit id="e6180d90736fe61c2fee7b217194e6e292349b2c" translate="yes" xml:space="preserve">
          <source>If you have just 60 socks, 3 colors and 2 sort of socks (yours / your wife's) you can sort every pile of 10 socks in 1 runs (Again threshold = 5). (Counting 2 seconds it will take you 2 min).</source>
          <target state="translated">양말 60 개, 색상 3 개, 양말 2 종 (귀하 / 부인) 만 있다면 10 개의 양말 더미를 한 번에 정렬 할 수 있습니다 (임계 값 = 5). (2 초를 세는 데 2 ​​분이 걸립니다).</target>
        </trans-unit>
        <trans-unit id="1642673d491acf03991115db1b99d02263fa0f61" translate="yes" xml:space="preserve">
          <source>If you have one or more selected unpaired socks, check your current sock against all the unpaired socks in the array.</source>
          <target state="translated">하나 이상의 짝을 이루지 않은 양말을 선택한 경우 어레이의 모든 짝을 이루지 않은 양말에 대해 현재 양말을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f56085360df34e1a4ad17c6698a237315bf8ce9d" translate="yes" xml:space="preserve">
          <source>In computer science this can be helpful:
We have a collection of n &lt;em&gt;things&lt;/em&gt;, an order on them (length) and also an equivalence relation (extra information, for example the color of socks). The equivalence relation allows us to make a partition of the original collection, and in every equivalence class our order is still maintained. The mapping of a &lt;em&gt;thing&lt;/em&gt; to it's equivalence class can be done in O(1), so only O(n) is needed to assign each item to a class. Now we have used our extra information and can proceed in any manner to sort every class. The advantage is that the data sets are already significantly smaller.</source>
          <target state="translated">컴퓨터 과학에서 이것은 도움이 될 수 있습니다. 우리는 n &lt;em&gt;가지&lt;/em&gt; 컬렉션, 그것들의 순서 (길이) 및 동등성 관계 (예 : 양말의 색상과 같은 추가 정보)를 가지고 있습니다. 동등성 관계를 통해 우리는 원래 컬렉션의 파티션을 만들 수 있으며 모든 동등성 클래스에서 우리의 순서는 여전히 유지됩니다. 해당 항목의 동등 클래스에 대한 맵핑은 O (1)에서 수행 할 수 있으므로 각 항목을 클래스에 지정하는 데 O (n) 만 필요합니다. 이제 추가 정보를 사용했으며 모든 클래스를 정렬하기 위해 어떤 방식 으로든 진행할 수 있습니다. 장점은 데이터 세트가 이미 상당히 작다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="95707802ab9dca781a74e6e8993e4a31c2c6a26e" translate="yes" xml:space="preserve">
          <source>In order to say how efficient it is to pair socks from a pile, we have to define the machine first, because the pairing isn't done whether by a turing nor by a random access machine, which are normally used as the basis for an algorithmic analysis.</source>
          <target state="translated">말뚝에서 양말을 페어링하는 것이 얼마나 효율적인지 말하려면 튜링 또는 랜덤 액세스 머신에 의해 페어링이 수행되지 않기 때문에 머신을 먼저 정의해야합니다. 알고리즘 분석.</target>
        </trans-unit>
        <trans-unit id="cb70cb2a381a9804b33c37786ed6892de88e1933" translate="yes" xml:space="preserve">
          <source>In the case of socks, perfect recall means looking at a sock &lt;code&gt;s&lt;/code&gt; always produces the memory of its sibling &lt;code&gt;t&lt;/code&gt;, including enough information (where it is on the ironing board) to locate &lt;code&gt;t&lt;/code&gt; in constant time.  A person with photographic memory accomplishes both 1 and 2 in constant time without fail.</source>
          <target state="translated">양말의 경우, 완벽한 리콜이란 양말을 보면 항상 일정한 시간에 &lt;code&gt;t&lt;/code&gt; 를 찾을 수있는 충분한 정보 (다리미판에있는 위치)를 포함하여 형제 자매의 기억을 만들어내는 것을 의미합니다. 사진 메모리가있는 사람은 일정한 시간에 1과 2를 동시에 달성합니다.</target>
        </trans-unit>
        <trans-unit id="4d3725e32aaeb21f7a9e8878c8079a2ecffbc7fb" translate="yes" xml:space="preserve">
          <source>In the worst case it means that you will have n/2 different buckets, and you will have n-2 determinations about that which bucket contains the pair of the current sock. Obviously, this algorithm works well if you have just a few pairs; I did it with 12 pairs.</source>
          <target state="translated">최악의 경우 n / 2 개의 다른 버킷이 있고 현재 버킷의 쌍을 포함하는 버킷에 대한 n-2 결정이 있음을 의미합니다. 분명히,이 알고리즘은 몇 쌍만 있으면 잘 작동합니다. 나는 12 쌍으로 해냈습니다.</target>
        </trans-unit>
        <trans-unit id="aa2dcdaf17722e129a20d19adefefc64c27ec3f1" translate="yes" xml:space="preserve">
          <source>Is it equivalent to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;element distinctness problem&lt;/a&gt;?</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;요소 구별 문제&lt;/a&gt; 와 동등합니까?</target>
        </trans-unit>
        <trans-unit id="27a7682059354d7267300e1425434e6ec790e624" translate="yes" xml:space="preserve">
          <source>It is not so scientific, but it works well:)</source>
          <target state="translated">그것은 과학적이지는 않지만 잘 작동합니다 :)</target>
        </trans-unit>
        <trans-unit id="d923e9762ba91638d0414fad059bf2a39ed51197" translate="yes" xml:space="preserve">
          <source>It is possible to separate socks into general classes or types (white/black, ankle/crew, athletic/dress) when building your array, and &quot;drill-down&quot; to only compare like-for-like.</source>
          <target state="translated">어레이를 구성 할 때 양말을 일반 클래스 또는 유형 (흰색 / 검정색, 발목 / 승무원, 운동 / 드레스)으로 분리 할 수 ​​있으며 &quot;드릴 다운 (drill-down)&quot;만으로 유사하게 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84b3dca37c877454cf4abb0e807d969bb8f0399f" translate="yes" xml:space="preserve">
          <source>It obviously requires some extra work to check if there is the matching sock already hanging somewhere and it would render solution &lt;code&gt;O(n^2)&lt;/code&gt; with coefficient about &lt;code&gt;1/2&lt;/code&gt; for a computer. But in this case the &quot;human factor&quot; is actually an advantage -- I usually can very quickly (almost &lt;code&gt;O(1)&lt;/code&gt;) identify the matching sock if it was already hung (probably some imperceptible in-brain caching is involved) -- consider it a kind of limited &quot;oracle&quot; as in &lt;a href=&quot;http://en.wikipedia.org/wiki/Oracle_machine&quot;&gt;Oracle Machine&lt;/a&gt; ;-) We, the humans have these advantages over digital machines in some cases ;-)</source>
          <target state="translated">일치하는 양말이 이미 어딘가에 있는지 확인하려면 추가 작업이 필요하며 컴퓨터의 경우 계수가 약 &lt;code&gt;1/2&lt;/code&gt; 인 솔루션 &lt;code&gt;O(n^2)&lt;/code&gt; 가 렌더링됩니다. 그러나이 경우 &quot;인간적 요인&quot;은 실제로 이점입니다. 매우 빨리 (거의 &lt;code&gt;O(1)&lt;/code&gt; ) 일치하는 양말이 이미 걸린 경우 식별 할 수 있습니다 (아마도 무시할 수없는 뇌 내 캐싱이 관련되어 있음)-고려하십시오 &lt;a href=&quot;http://en.wikipedia.org/wiki/Oracle_machine&quot;&gt;Oracle Machine&lt;/a&gt; 에서와 같이 일종의 제한된 &quot;오라클&quot;;-) 우리는 인간이 경우에 따라 디지털 머신보다 이러한 장점을 가지고 있습니다. ;-)</target>
        </trans-unit>
        <trans-unit id="39b5cd62e349d68c400a20da1e370efb8e1fc33f" translate="yes" xml:space="preserve">
          <source>It scales nearly indefinitely if &lt;strong&gt;each worker has its own set of piles&lt;/strong&gt;. Workers can then take big chunks of socks from the input basket (very little contention as they are doing it rarely) and they do not need to synchronise when distributing the socks at all (because they have thread-local piles). At the end, all workers need to union their pile-sets. I believe that can be done in O(log (worker count * piles per worker)) if the workers form an &lt;strong&gt;aggregation tree&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;각 작업자가 자신의 더미를 가지고&lt;/strong&gt; 있다면 거의 무한정으로 확장됩니다. 그런 다음 작업자는 입력 바구니에서 큰 양말 덩어리를 가져갈 수 있으며 (드물게하는 것처럼 아주 적은 경합) 양말을 분배 할 때 동기화 할 필요가 없습니다 (스레드 로컬 더미가 있기 때문에). 결국, 모든 노동자들은 말뚝 집합을 연합시켜야합니다. 작업자가 &lt;strong&gt;집계 트리를&lt;/strong&gt; 구성하면 O (로그 (작업 자당 * 작업 자당 파일 수))로 수행 할 수 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="150b46cd8303cca0bd34d1940b0ec0aedbf08053" translate="yes" xml:space="preserve">
          <source>It's better if there's no difference between left and right foot socks, but it's not critical. If socks are left-right symmetrical, finding a pair is O(1) operation, and sorting the socks is approximate O(M) operation, where M is the number of places in your house, which you have littered with socks, ideally some small constant number.</source>
          <target state="translated">왼쪽 발 양말과 오른쪽 발 양말 사이에 차이가 없다면 더 좋지만 중요하지는 않습니다. 양말이 좌우 대칭 인 경우 쌍을 찾는 것은 O (1) 연산이고 양말을 정렬하는 것은 대략 O (M) 연산입니다. 여기서 M은 집안의 장소 수이며 양말로 흩어진 곳은 이상적입니다. 작은 상수.</target>
        </trans-unit>
        <trans-unit id="2f22939c37ecaebbcccfa9e1a61cd5e27c5cb274" translate="yes" xml:space="preserve">
          <source>It's often good to take a step back, and think a way around the problem.</source>
          <target state="translated">한 걸음 물러서서 문제를 해결하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="150a08322f1488dee4632ea6718c405d63b39b1c" translate="yes" xml:space="preserve">
          <source>Iterate over each pile and &lt;strong&gt;distribute it by some other metric&lt;/strong&gt; (e.g. pattern) into the second set of piles</source>
          <target state="translated">각 파일을 반복하고 &lt;strong&gt;다른 메트릭&lt;/strong&gt; (예 : 패턴)으로 두 번째 파일 세트로 &lt;strong&gt;분배&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5efd484584a49caf169c4dda344e416b18649fb1" translate="yes" xml:space="preserve">
          <source>Keep randomly picking socks from the stack and compare to your 5+1 socks for a match. As your stack grows, it will reduce your performance but raise your odds. Much faster.</source>
          <target state="translated">더미에서 양말을 무작위로 뽑아 5 + 1 양말과 비교하십시오. 스택이 커지면 성능이 저하되지만 확률은 높아집니다. 훨씬 더 빨리.</target>
        </trans-unit>
        <trans-unit id="1ca7ccdd0b7ccddb659ecda67d1ece6e151b36ca" translate="yes" xml:space="preserve">
          <source>Let 'N' correspond to an approximate upper-bound on the number of  number of unique colors/pattern of socks that you have.</source>
          <target state="translated">'N'은 가지고있는 독특한 색상의 수 / 양말 패턴의 대략적인 상한에 해당하십시오.</target>
        </trans-unit>
        <trans-unit id="780bea650a8fdf34a596a74ddbd5fc938d04c33f" translate="yes" xml:space="preserve">
          <source>My algorithm:</source>
          <target state="translated">내 알고리즘 :</target>
        </trans-unit>
        <trans-unit id="74beaf9107fc04b7777303cee699390003158c90" translate="yes" xml:space="preserve">
          <source>My solution does not exactly correspond to your requirements, as it formally requires &lt;code&gt;O(n)&lt;/code&gt; &quot;extra&quot; space. However, considering my conditions it is very efficient in my practical application. Thus I think it should be interesting.</source>
          <target state="translated">내 솔루션은 공식적으로 &lt;code&gt;O(n)&lt;/code&gt; &quot;추가&quot;공간이 필요하므로 요구 사항과 정확히 일치하지 않습니다. 그러나 내 조건을 고려하면 실제 응용 프로그램에서 매우 효율적입니다. 따라서 재미있을 것 같아요.</target>
        </trans-unit>
        <trans-unit id="5975233f2cbc212e70e2408f533f6faa08e21eb5" translate="yes" xml:space="preserve">
          <source>Now look for a match (visual pattern matching - humans are good at that with a small stack) inside the five you drew, if you don't find one, then add that to your five.</source>
          <target state="translated">이제 당신이 그린 5 개 안에서 일치하는 것을 찾으십시오 (시각적 패턴 일치-사람은 작은 스택으로 잘합니다). 하나를 찾지 못하면 5 개에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a7486cfa8083fe6f612df25745068a14a1cac68b" translate="yes" xml:space="preserve">
          <source>Now the computer science in this problem is all about the steps</source>
          <target state="translated">이제이 문제의 컴퓨터 과학은 모든 단계에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="870cccf30184352ba6b4960824e58b1bdd6d8989" translate="yes" xml:space="preserve">
          <source>Now the next question is simply whether you do your own laundry and your wife does hers. That is a problem likely in an &lt;strong&gt;entirely different domain of problems&lt;/strong&gt;. :)</source>
          <target state="translated">다음 질문은 당신이 세탁을하고 아내가 그녀를하는 것입니다. 그것은 &lt;strong&gt;완전히 다른 문제 영역에서 발생하는 문제&lt;/strong&gt; 입니다. :)</target>
        </trans-unit>
        <trans-unit id="e3d8d0fe5c35ea409447bff57847e6fc8b0f8f6d" translate="yes" xml:space="preserve">
          <source>Now this may not seem all that different from &quot;forming piles by color&quot; suggested by top answers but first, by not picking discrete piles but ranges, I have no problem classifying whether &quot;purple&quot; goes to &quot;red&quot; or &quot;blue&quot; pile; it just goes between. And then by integrating two operations (hang to dry and sort) the overhead of sorting while hanging is like 10% of what separate sorting would be.</source>
          <target state="translated">이제 이것은 최고 답변에서 제안한 &quot;색상으로 말뚝 만들기&quot;와 다를 것 같지는 않지만 먼저 개별 말뚝을 선택하지 않고 범위를 선택하여 &quot;보라&quot;가 &quot;빨간색&quot;또는 &quot;파란색&quot;말뚝으로 분류되는지에 대한 문제는 없습니다. 그것은 단지 사이에 있습니다. 그리고 두 가지 작업을 통합 (건조 및 정렬)하면 정렬하는 동안 정렬 오버 헤드가 별도 정렬의 10 %와 같습니다.</target>
        </trans-unit>
        <trans-unit id="37e05d152e6390b47f7a7dde92949ba55f30e47c" translate="yes" xml:space="preserve">
          <source>Once you have a collision(a.k.a  : a match) simply remove that pair of socks. 
 Repeat the same experiment with the next batch of NlogN socks. 
The beauty of it is that you could be making NlogN parallel comparisons(collision-resolution) because of the way the human mind works.  :-)</source>
          <target state="translated">충돌 (일명 : 성냥)이 발생하면 양말을 제거하십시오. 다음 NlogN 양말 배치로 동일한 실험을 반복하십시오. 그것의 장점은 인간의 마음이 작동하는 방식으로 NlogN 병렬 비교 (충돌 해결)를 할 수 있다는 것입니다. :-)</target>
        </trans-unit>
        <trans-unit id="11a98af1a6e5c195360f3f6c711227cc208dadd9" translate="yes" xml:space="preserve">
          <source>Operation 4 is necessary, because when spreading socks over the floor some socks may hide others. Here is the analysis of the algorithm:</source>
          <target state="translated">양말을 바닥에 뿌릴 때 일부 양말이 다른 양말을 숨길 수 있기 때문에 작업 4가 필요합니다. 알고리즘 분석은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af6924e29957fb8b52cc30183bb2138601d75b4d" translate="yes" xml:space="preserve">
          <source>Optionally to step one, you pick up two sock from that line instead of two, as the caching memory is large enough we can quickly identify if either sock matches the current one on the line you are observing. If you are fortunate enough to have three arms, you could possibly parse three socks at the same time given that the memory of the subject is large enough.</source>
          <target state="translated">선택적으로 1 단계를 수행하려면 캐싱 메모리가 충분히 크기 때문에 두 라인 대신 두 라인의 양말을 선택합니다. 어느 양말이 현재 관찰중인 라인의 양말과 일치하는지 빠르게 식별 할 수 있습니다. 팔이 3 개가 될만큼 운이 좋으면 대상의 메모리가 충분히 크다면 양말 3 개를 동시에 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77783bef2624f9f540cadff73ba6528b5aae021a" translate="yes" xml:space="preserve">
          <source>Oracle Machine is Better ;-)</source>
          <target state="translated">Oracle Machine이 더 좋습니다 ;-)</target>
        </trans-unit>
        <trans-unit id="f28b38127d74eab7d9b41752145290a2fc0d5c89" translate="yes" xml:space="preserve">
          <source>Order the socks!</source>
          <target state="translated">양말을 주문하십시오!</target>
        </trans-unit>
        <trans-unit id="8c33de1b8688b9c866607960966f014e14b6a01b" translate="yes" xml:space="preserve">
          <source>Other than that, I cannot think of anything, but this method does seem to be pretty efficient in real life. :)</source>
          <target state="translated">그 외에는 아무 것도 생각할 수 없지만이 방법은 실제 생활에서는 꽤 효율적인 것 같습니다. :)</target>
        </trans-unit>
        <trans-unit id="02341ed9b2710f0b78051065b72a305737d20c68" translate="yes" xml:space="preserve">
          <source>Our two preprocessing stages are &quot;putting the socks on the clothesline&quot; and &quot;Taking the socks from the clothesline&quot;, which we have to do, in order to get socks which are not only clean but also dry. As with washing machines, clotheslines are finite, and I assume that we have the whole part of the line where we put our socks in sight.</source>
          <target state="translated">우리의 두 가지 전처리 단계는 &quot;빨리 빨랫줄에 양말 넣기&quot;와 &quot;빨랫줄에서 양말 가져 오기&quot;로, 깨끗하고 건조한 양말을 얻기 위해해야합니다. 세탁기와 마찬가지로 빨랫줄은 유한하며 양말을 놓는 줄의 일부가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="dd7e7c37ececf846bbc91969c59fe7ec34aa06d6" translate="yes" xml:space="preserve">
          <source>Pair blindly all socks to its neighbor (do not pack it)</source>
          <target state="translated">맹목적으로 모든 양말을 이웃과 묶습니다 (포장하지 마십시오)</target>
        </trans-unit>
        <trans-unit id="567d945bb762f9218b71f65d131b602db30011d2" translate="yes" xml:space="preserve">
          <source>Pick a sock</source>
          <target state="translated">양말을 선택</target>
        </trans-unit>
        <trans-unit id="b3134987842b8171f3b2d20b9d928ea0449a744f" translate="yes" xml:space="preserve">
          <source>Pick any two of them to make a pair. Constant time.</source>
          <target state="translated">쌍을 만들기 위해 둘 중 하나를 선택하십시오. 일정한 시간.</target>
        </trans-unit>
        <trans-unit id="e6ad43d89c0be2bb101bd954d77aea3f0c680af6" translate="yes" xml:space="preserve">
          <source>Pick the first sock in line, search along the line until it finds the corresponding sock.</source>
          <target state="translated">줄에서 첫 번째 양말을 골라 해당 양말을 찾을 때까지 줄을 따라 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="f15a45dc12d70436ea09baf6beeb9021651aff15" translate="yes" xml:space="preserve">
          <source>Pick two socks, place corresponding X sock in X line, and Y sock in Y line at next available position.</source>
          <target state="translated">양말 두 개를 골라, 해당 X 양말을 X 라인에, Y 양말을 Y 라인에 다음 위치에 놓습니다.</target>
        </trans-unit>
        <trans-unit id="a42c6c1b50b0cb070b7169e8cfd43b7e499c1252" translate="yes" xml:space="preserve">
          <source>Pick up a first sock and place it on a table. Now pick another sock; if it matches the first picked, place it on top of the first. If not, place it on the table a small distance from the first. Pick a third sock; if it matches either of the previous two, place it on top of them or else place it a small distance from the third. Repeat until you have picked up all the socks.</source>
          <target state="translated">첫 번째 양말을 집어 테이블에 놓으십시오. 이제 다른 양말을 고르십시오. 처음 선택한 것과 일치하면 첫 번째 위에 놓습니다. 그렇지 않은 경우 첫 번째 테이블과 약간 떨어진 테이블에 놓으십시오. 세 번째 양말을 선택하십시오. 이전 두 가지 중 하나와 일치하면 그 위에 놓거나 세 번째에서 약간 떨어진 곳에 배치하십시오. 양말을 모두들 때까지 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="49d4ff963ae4bca3c41a677fe2b8a4851f0dc095" translate="yes" xml:space="preserve">
          <source>Pick up one from the stack of 2n-5.</source>
          <target state="translated">2n-5 스택에서 하나를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="38fc586cd4b8cb11aebfcde216a7bcd038fe8e83" translate="yes" xml:space="preserve">
          <source>Picking a distinctive sock (whatever catches my eye first in the pile).</source>
          <target state="translated">독특한 양말을 고르기 (무엇보다 먼저 내 눈을 사로 잡는 것).</target>
        </trans-unit>
        <trans-unit id="afb37a344e3ab2d134c35252ebd3afec24338844" translate="yes" xml:space="preserve">
          <source>Place the new sock near into the current pile, with a distance based on how different it is. If you find yourself putting the sock on top of another because it is identical, form the pair there, and remove them. This means that future comparisons take less effort to find the correct place.</source>
          <target state="translated">새 양말을 현재 더미 가까이에두고 거리를두고 거리를 두십시오. 양말이 동일하기 때문에 양말을 다른 양말 위에 놓는 것을 발견하면 거기에 쌍을 형성하고 제거하십시오. 이는 향후 비교시 정확한 장소를 찾는 데 더 적은 노력이 필요함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2f2ea3db77a1f1b6f771e24a207d47f22993a2ad" translate="yes" xml:space="preserve">
          <source>Problem solved. So, just get new socks, throw/donate your old ones away, and live happily ever after knowing you are saving money and time every day for the rest of your life.</source>
          <target state="translated">문제 해결됨. 따라서 새 양말을 구입하고, 오래된 양말을 버리고 기부하고, 평생 동안 매일 돈과 시간을 절약하고 있다는 것을 알고 행복하게 살 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b052f937ed7ad2c7eefbe92ef78e1f1391ca53d4" translate="yes" xml:space="preserve">
          <source>Put into the corresponding finished line of socks.</source>
          <target state="translated">완성 된 양말 라인에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="e069c49edbed651dbec011e37b87b876f834afc4" translate="yes" xml:space="preserve">
          <source>Quickly make piles of easily distinguishable socks. (Say by color)</source>
          <target state="translated">쉽게 구별 할 수있는 양말 더미를 빠르게 만듭니다. (컬러로 말해)</target>
        </trans-unit>
        <trans-unit id="e8562ec8764aff77d8738bd6121e9835eeba9b2f" translate="yes" xml:space="preserve">
          <source>Quicksort every pile and use the length of the sock for comparison. As a human you can make a fairly quick decision which sock to use to partition that avoids worst case. (You can see multiple socks in parallel, use that to your advantage!)</source>
          <target state="translated">모든 더미를 퀵 정렬하고 양말 길이를 사용하여 비교하십시오. 인간은 최악의 경우를 피하기 위해 파티션에 사용할 양말을 상당히 빨리 결정할 수 있습니다. (여러 양말을 동시에 볼 수 있으므로 이점을 활용하십시오!)</target>
        </trans-unit>
        <trans-unit id="b577412dc9473d426d2ff6741d11dea5ca17a977" translate="yes" xml:space="preserve">
          <source>Real world approach:</source>
          <target state="translated">실제 접근 방식 :</target>
        </trans-unit>
        <trans-unit id="0bf66d17ab79cfe3be7fc141f104742b101b119a" translate="yes" xml:space="preserve">
          <source>Repeat from 1 until there are no socks on the floor.</source>
          <target state="translated">바닥에 양말이 없을 때까지 1부터 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="0081c3494d7d5f15ad3d0b6fd53ac547753f32ff" translate="yes" xml:space="preserve">
          <source>Repeat from 1. until there are no more most distinctive socks.</source>
          <target state="translated">가장 독특한 양말이 더 이상 없을 때까지 1부터 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="e491132f83030e4bf9e1aa6139496611dff2738e" translate="yes" xml:space="preserve">
          <source>Repeat from 2 until no pair can be made.</source>
          <target state="translated">쌍을 만들 수 없을 때까지 2부터 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="f4ecdc41af265ed9bf91659fbd817baded2a6b44" translate="yes" xml:space="preserve">
          <source>Repeat with every sock.</source>
          <target state="translated">모든 양말마다 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="2d3de6b4a64f840ca4b44c37b7e888adb2929c0e" translate="yes" xml:space="preserve">
          <source>Shuffle the rest</source>
          <target state="translated">나머지를 섞으십시오</target>
        </trans-unit>
        <trans-unit id="20968b695bdd0c1693e57dfce2b017887a96213f" translate="yes" xml:space="preserve">
          <source>Since all washing machines I know about are limited in size (regardless of how many socks you have to wash), and the actual randomizing occurs in the washing machine, no matter how many socks we have, we always have small subsets which contain almost no singletons.</source>
          <target state="translated">내가 아는 모든 세탁기는 크기가 제한되어 있기 때문에 (세탁 해야하는 양말의 수에 관계없이) 세탁기의 실제 무작위 화는 양말의 수에 관계없이 항상 거의 포함되지 않은 작은 하위 집합을 가지고 있습니다 싱글 톤.</target>
        </trans-unit>
        <trans-unit id="20318f6c81a8cfa249bb075ab83674739820d4cc" translate="yes" xml:space="preserve">
          <source>Since you are interested in connections to element distinctness problem: proving the Omega(n log n) bound for element distinctness is harder, because the output is binary yes/no. Here, the output has to be a matching and the number of possible outputs suffices to get a decent bound. However, there's a variant connected to element distinctness. Suppose you are given 2n socks and wonder if they can be uniquely paired. You can get a reduction from ED by sending (a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;) to (a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;, a&lt;sub&gt;n&lt;/sub&gt;). (Parenthetically, the proof of hardness of ED is very interesting, &lt;a href=&quot;http://www.cs.dartmouth.edu/~ac/Teach/CS85-Spring08/lecnotes.pdf&quot;&gt;via topology&lt;/a&gt;.)</source>
          <target state="translated">요소 구별 문제에 대한 연결에 관심이 있기 때문에 출력이 이진 예 / 아니오이기 때문에 요소 구별에 대해 바인딩 된 Omega (n log n)을 증명하는 것이 더 어렵습니다. 여기서 출력은 일치해야하며 가능한 출력 수는 적절한 범위를 확보하기에 충분합니다. 그러나 요소의 구별과 관련된 변형이 있습니다. 2n 양말이 제공되고 그들이 독특한 짝을 지을 수 있는지 궁금해한다고 가정하십시오. (a &lt;sub&gt;1&lt;/sub&gt; , a &lt;sub&gt;2&lt;/sub&gt; , ..., a &lt;sub&gt;n&lt;/sub&gt; )을 (a &lt;sub&gt;1&lt;/sub&gt; , a &lt;sub&gt;1&lt;/sub&gt; , a &lt;sub&gt;2&lt;/sub&gt; , a &lt;sub&gt;2&lt;/sub&gt; , ..., a &lt;sub&gt;n&lt;/sub&gt; , a &lt;sub&gt;n&lt;/sub&gt; )로 보내면 ED를 줄일 수 있습니다. (유명하게도, ED의 경도 증명은 &lt;a href=&quot;http://www.cs.dartmouth.edu/~ac/Teach/CS85-Spring08/lecnotes.pdf&quot;&gt;토폴로지를 통해&lt;/a&gt; 매우 흥미 롭습니다.)</target>
        </trans-unit>
        <trans-unit id="b9194449f120d8f88fb9b2143ad9103b6ff573c9" translate="yes" xml:space="preserve">
          <source>Smile satisfied :)</source>
          <target state="translated">미소 만족 :)</target>
        </trans-unit>
        <trans-unit id="b4e8217ef1354bbb155dad8cbdc9f0568f1b9c6f" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;hashing&lt;/strong&gt; would be enough (and faster).</source>
          <target state="translated">따라서 &lt;strong&gt;해싱&lt;/strong&gt; 이면 충분하고 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="efa0ae263e5ffda95375f84a7f6c55184e61109a" translate="yes" xml:space="preserve">
          <source>So depending on the previous analysis following operations should be used in descending order:</source>
          <target state="translated">따라서 이전 분석에 따라 다음 작업을 내림차순으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9e8e26a61696a80e259f278ce881a216a7ad149" translate="yes" xml:space="preserve">
          <source>So here is my suggestion:</source>
          <target state="translated">여기 내 제안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a55e40b80a0b84833274723db643350fd89429ca" translate="yes" xml:space="preserve">
          <source>So pick up five of them at random, and memorize their shape or their length.</source>
          <target state="translated">따라서 5 개를 무작위로 집어 들고 모양이나 길이를 외우십시오.</target>
        </trans-unit>
        <trans-unit id="d199d875189556fbbb7c28bbf7b2d5145327cb1f" translate="yes" xml:space="preserve">
          <source>So the &quot;best&quot; algorithm depends on the qualities of the wetware/hardware/software that is running it and our willingness to &quot;cheat&quot; by imposing a total order on pairs.  Certainly a &quot;best&quot; &lt;em&gt;meta&lt;/em&gt;-algorithm is to hire the worlds best sock-sorter: a person or machine that can aquire and quickly store a huge set N of sock attribute sets in a 1-1 associative memory with constant time lookup, insert, and delete. Both people and machines like this can be procured. If you have one, you can pair all the socks in O(N) time for N pairs, which is optimal. The total order tags allow you to use standard hashing to get the same result with either a human or hardware computer.</source>
          <target state="translated">따라서 &quot;최상의&quot;알고리즘은이를 실행하는웨어웨어 / 하드웨어 / 소프트웨어의 품질과 쌍에 총 질서를 부과함으로써 &quot;치트&quot;하려는 의지에 달려 있습니다. 확실히 &quot;최상의&quot; &lt;em&gt;메타-&lt;/em&gt; 알고리즘은 세계 최고의 양말 분류기를 고용하는 것입니다. 일정한 시간 조회, 삽입, 1-1 연관 메모리에서 거대한 N 세트의 양말 속성 세트를 획득하고 빠르게 저장할 수있는 사람 또는 기계 삭제하십시오. 이와 같은 사람과 기계를 모두 조달 할 수 있습니다. 하나가 있으면 모든 양말을 N 쌍의 O (N) 시간에 페어링 할 수 있습니다. 이것이 최적입니다. 총 주문 태그를 사용하면 표준 해싱을 사용하여 사람 또는 하드웨어 컴퓨터에서 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f4b0f3db658b3420736349f1a48e77a38793c53" translate="yes" xml:space="preserve">
          <source>So we have a total runtime complexity of &lt;strong&gt;&lt;code&gt;O(r*n^2 + w*(ln n + n))&lt;/code&gt;&lt;/strong&gt; where &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; are the factors for environmental read and environmental write operations respectively for a reasonable amount of socks. The cost of the logical and arithmetical operations are omitted, because we suppose that it takes a constant amount of logical and arithmetical operations to decide whether 2 socks belong to the same pair. This may not be feasible in every scenario.</source>
          <target state="translated">따라서 총 런타임 복잡도는 &lt;strong&gt; &lt;code&gt;O(r*n^2 + w*(ln n + n))&lt;/code&gt; &lt;/strong&gt; 여기서 &lt;code&gt;r&lt;/code&gt; 과 &lt;code&gt;w&lt;/code&gt; 는 합리적인 양의 양말에 대한 환경 읽기 및 환경 쓰기 작업의 요소입니다. 논리 및 산술 연산의 비용은 생략됩니다. 왜냐하면 두 양말이 동일한 쌍에 속하는지 여부를 결정하기 위해서는 일정한 양의 논리 및 산술 연산이 필요하다고 가정하기 때문입니다. 모든 시나리오에서 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c0ea279bcf3555464998141486451f10c76c5ac8" translate="yes" xml:space="preserve">
          <source>So, an algorithm for achieving O(1) sock pairing efficiency (assuming symmetrical sock) is:</source>
          <target state="translated">따라서 O (1) 양말 페어링 효율을 달성하기위한 알고리즘은 다음과 같습니다 (대칭 양말 가정).</target>
        </trans-unit>
        <trans-unit id="f20134ff73648500315de3e4a253b67d80cad96e" translate="yes" xml:space="preserve">
          <source>Socks, whether real ones or some analogous data structure, would be supplied in pairs.</source>
          <target state="translated">실제 구조이든 유사한 데이터 구조 든 양말은 쌍으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fb36d98db4ccebdf42bf060da6c7373f52f5a333" translate="yes" xml:space="preserve">
          <source>Some upfront effort is required to find desirable socks, and to purchase in sufficient quantity as to eliminate need for your existing socks. As I'd done this before my need for black socks, my effort was minimal, but mileage may vary.</source>
          <target state="translated">바람직한 양말을 찾고 기존 양말의 필요성을 없애기 위해 충분한 수량으로 구매하려면 약간의 사전 노력이 필요합니다. 검은 양말이 필요하기 전에이 작업을 수행 한 결과, 노력이 최소화되었지만 마일리지가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97926eed54a69097fde506b9ecf78b97bea5b72b" translate="yes" xml:space="preserve">
          <source>Someone with less than perfect memory might use a few commonsense equivalence classes based on features within his capability to track: size (papa, mama, baby), color (greenish, redish, etc.), pattern (argyle, plain, etc.), style (footie, knee-high, etc.).  So the ironing board would be divided into sections for the categories. This usually allows the category to be located in constant time by memory, but then a linear search through the category &quot;bucket&quot; is needed.</source>
          <target state="translated">완벽한 기억력이 부족한 사람은 추적 할 수있는 기능 (크기 (파파, 엄마, 아기), 색 (녹색, 붉은 등), 패턴 (아가일, 평등 등)에 따라 몇 가지 상식 등가 클래스를 사용할 수 있습니다. 스타일, 푸티 지, 무릎 높이 등. 따라서 다리미판은 카테고리별로 섹션으로 나뉩니다. 이것은 일반적으로 범주가 메모리에 의해 일정한 시간에 위치하도록 허용하지만 범주 &quot;버킷&quot;을 통한 선형 검색이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0159712802a0c2f7cfff59d6211ba6f0c4445923" translate="yes" xml:space="preserve">
          <source>Someone with no memory or imagination at all (sorry) will just keep the socks in one pile and do a linear search of the whole pile.</source>
          <target state="translated">전혀 기억이나 상상력이없는 사람 (죄송합니다)은 양말을 한 더미에 보관하고 전체 더미를 선형 적으로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="b1831098d4a04bf674e6b5bfb3d588abdfb6668a" translate="yes" xml:space="preserve">
          <source>Sorting solutions have been proposed, but &lt;strong&gt;sorting is a little too much&lt;/strong&gt;: We don't need order; &lt;strong&gt;we just need equality groups&lt;/strong&gt;.</source>
          <target state="translated">정렬 솔루션이 제안되었지만 &lt;strong&gt;정렬이 너무 많습니다&lt;/strong&gt; . 주문이 필요 없습니다. &lt;strong&gt;우리는 평등 그룹 만 있으면됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2cf30b649babee1fb3e3f2f2040697d3899e96be" translate="yes" xml:space="preserve">
          <source>Sorting, of course improves efficiency, especially in real life where you can easily &quot;insert&quot; a sock between two other socks. In computing the same could be achieved by a tree, but that's extra space. And, of course, we're back at NlogN (or a bit more, if there are several socks that are the same by sorting criteria, but not from the same pair).</source>
          <target state="translated">정렬은 물론 효율성을 향상 시키며, 특히 두 양말 사이에 양말을 쉽게 &quot;삽입&quot;할 수있는 실제 생활에서 향상됩니다. 계산에서 나무에 의해 동일한 것을 달성 할 수 있지만 추가 공간입니다. 물론 NlogN으로 돌아갑니다 (또는 정렬 기준에 따라 동일하지만 동일한 쌍이 아닌 여러 양말이있는 경우).</target>
        </trans-unit>
        <trans-unit id="71a641aab14b65becb2573bd1e7dc80cfa779bbc" translate="yes" xml:space="preserve">
          <source>Spread all socks in the pile over the floor.</source>
          <target state="translated">더미의 모든 양말을 바닥에 펼칩니다.</target>
        </trans-unit>
        <trans-unit id="1e59b3c211f85c725340aeaa57b22de5e88fedab" translate="yes" xml:space="preserve">
          <source>Starting a radix sort from that conceptual location by pulling socks from the pile based on similarity to that one.</source>
          <target state="translated">더미와 양말의 유사성에 따라 양말을 당겨서 개념적 위치에서 기수 정렬을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9a81a4144276291d35bd6b866aad617bdf191bf6" translate="yes" xml:space="preserve">
          <source>Stop sorting piles when they reached a threshold at which you are comfortable to find spot pairs and unpairable socks instantly</source>
          <target state="translated">스팟 페어와 페어링 할 수없는 양말을 즉시 찾을 수있는 임계 값에 도달하면 파일 정렬을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="c6852caa99233694cc2f8ce0670b34197c40d765" translate="yes" xml:space="preserve">
          <source>Such an upfront effort has been seen many times in very popular and effective code. Examples include #DEFINE'ing pi to several decimals (other examples exist, but that's the one that comes to mind right now).</source>
          <target state="translated">이러한 선구자 적 노력은 매우 인기 있고 효과적인 코드에서 여러 번 나타났습니다. 예를 들어 # DEFINE'ing pi to some decimals (다른 예제는 있지만 지금은 마음에 듭니다).</target>
        </trans-unit>
        <trans-unit id="0a5991dd9a6ef1577adeb97b95fcc60199512116" translate="yes" xml:space="preserve">
          <source>Suppose that you &lt;em&gt;know&lt;/em&gt; that your 2n socks are arranged this way:</source>
          <target state="translated">2n 양말이 이런 식으로 배열되어 있음을 &lt;em&gt;알고&lt;/em&gt; 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="83358afe13545467fbcbbf957121011db2230479" translate="yes" xml:space="preserve">
          <source>The actual number of socks is not that large, I don't believe my spouse and I have more than 30 pairs. (And it is fairly easy to distinguish between my socks and hers; can this be used as well?)</source>
          <target state="translated">양말의 실제 개수는 그다지 크지 않습니다. 배우자를 믿지 않으며 30 쌍 이상이 있습니다. (그리고 내 양말과 양말을 구별하는 것은 상당히 쉽습니다. 이것도 사용할 수 있습니까?)</target>
        </trans-unit>
        <trans-unit id="052fd9e524e5e7a091878b38f361a3a987397d74" translate="yes" xml:space="preserve">
          <source>The algorithm</source>
          <target state="translated">알고리즘</target>
        </trans-unit>
        <trans-unit id="f78fa21d86b0d267520ebd8d82fbaae7a3fc5c19" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(ln n + n)&lt;/code&gt; environmental modifications (step 1 &lt;code&gt;O(ln n)&lt;/code&gt; plus picking every pair of sock from the floor)</source>
          <target state="translated">이 알고리즘에는 &lt;code&gt;O(ln n + n)&lt;/code&gt; 환경 수정이 포함됩니다 (1 단계 &lt;code&gt;O(ln n)&lt;/code&gt; 및 바닥에서 모든 양말 쌍 선택)</target>
        </trans-unit>
        <trans-unit id="1df9e4e8ccdefcdc14130712da6877c276e11de8" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(n^2)&lt;/code&gt; environmental reads from step 2</source>
          <target state="translated">이 알고리즘은 &lt;code&gt;O(n^2)&lt;/code&gt; 단계의 O (n ^ 2) 환경 판독을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="dd6aa1a815e2490fabaf33e117c8ad11f5692691" translate="yes" xml:space="preserve">
          <source>The algorithm involves &lt;code&gt;O(n^2)&lt;/code&gt; logical and arithmetic operations for comparing a sock with another in step 2</source>
          <target state="translated">알고리즘은 &lt;code&gt;O(n^2)&lt;/code&gt; 단계에서 양말을 다른 양말과 비교하기위한 O (n ^ 2) 논리 및 산술 연산을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bb51c91f5c283a2bdff31b863d5e5e5018eb57e0" translate="yes" xml:space="preserve">
          <source>The algorithm terminates with high probability. This is due to the fact that one is unable to find pairs of socks in step number 2.</source>
          <target state="translated">알고리즘은 높은 확률로 종료됩니다. 이것은 단계 번호 2에서 양말 쌍을 찾을 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="165efb7623d4620b9e2c0a44514704d6b6dff038" translate="yes" xml:space="preserve">
          <source>The analysis</source>
          <target state="translated">분석</target>
        </trans-unit>
        <trans-unit id="abc7bc26ec5efcc62f2a9dd13e54ca3af8f26906" translate="yes" xml:space="preserve">
          <source>The answers till now don't make good use of our human pattern recognition capabilities. The game of Set provides a clue of how to do this well: put all socks in a two-dimensional space so you can both recognize them well and easily reach them with your hands. This limits you to an area of about 120 * 80 cm or so. From there select the pairs you recognize and remove them. Put extra socks in the free space and repeat. If you wash for people with easily recognizable socks (small kids come to mind), you can do a radix sort by selecting those socks first. This algorithm works well only when the  number of single socks is low</source>
          <target state="translated">지금까지의 답변은 인간의 패턴 인식 기능을 잘 활용하지 못합니다. Set 게임은이 작업을 잘 수행하는 방법에 대한 실마리를 제공합니다. 모든 양말을 2 차원 공간에두면 잘 인식하고 손으로 쉽게 닿을 수 있습니다. 약 120 * 80 cm 정도의 영역으로 제한됩니다. 거기에서 인식하는 쌍을 선택하고 제거하십시오. 여유 공간에 여분의 양말을 넣고 반복하십시오. 쉽게 알아볼 수있는 양말이있는 사람들 (작은 아이들이 떠오를 것)을 씻는 경우 먼저 양말을 선택하여 기수를 분류 할 수 있습니다. 이 알고리즘은 단일 양말의 수가 적은 경우에만 잘 작동합니다</target>
        </trans-unit>
        <trans-unit id="4d052e124ee3ca4cc28b28a0fe3ffd3b80cede47" translate="yes" xml:space="preserve">
          <source>The best real-world partitioning I can think of is creating a &lt;strong&gt;rectangle of piles&lt;/strong&gt;: one dimension is color, the other is the pattern. Why a rectangle? Because we need O(1) random-access to piles. (A 3D &lt;a href=&quot;http://en.wikipedia.org/wiki/Cuboid&quot;&gt;cuboid&lt;/a&gt; would also work, but that is not very practical.)</source>
          <target state="translated">내가 생각할 수있는 가장 실제 파티션은 &lt;strong&gt;사각형의 더미를&lt;/strong&gt; 만드는 것입니다. 한 차원은 색상이고 다른 차원은 패턴입니다. 왜 직사각형입니까? 우리는 파일에 O (1) 랜덤 액세스가 필요하기 때문입니다. (3D &lt;a href=&quot;http://en.wikipedia.org/wiki/Cuboid&quot;&gt;직육면체&lt;/a&gt; 도 작동하지만 그다지 실용적이지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="4b89a467fe48adcd9cc2eef3b60f3e2f90973c34" translate="yes" xml:space="preserve">
          <source>The initial bucket sorting will speed up your process, because it divides your n socks into k buckets in &lt;code&gt;c*n&lt;/code&gt; time so than you will only have to do &lt;code&gt;c*n*log(k)&lt;/code&gt; work. (Not taking into account the threshold). So all in all you do about &lt;code&gt;n*c*(1 + log(k))&lt;/code&gt; work, where c is the time to throw a sock on a pile.</source>
          <target state="translated">초기 버킷 정렬은 &lt;code&gt;c*n*log(k)&lt;/code&gt; 작업 만 수행하는 것보다 n 양말을 &lt;code&gt;c*n&lt;/code&gt; 시간 내에 k 버킷으로 나누기 때문에 프로세스 속도를 높입니다. (임계 값을 고려하지 않음). 그래서 당신은 &lt;code&gt;n*c*(1 + log(k))&lt;/code&gt; 일에 대해 무엇을합니까? 여기서 c는 말뚝에 양말을 던지는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="3ab65ee84b4d8d43507a4f1bd4d7cc40b05e68c1" translate="yes" xml:space="preserve">
          <source>The machine</source>
          <target state="translated">기계</target>
        </trans-unit>
        <trans-unit id="7bb444117bc016eadc9752d11b231edb03e673d8" translate="yes" xml:space="preserve">
          <source>The machine is an abstraction of a the real world element called human being. It is able to read from the environment via a pair of eyes. And our machine model is able to manipulate the environment by using 2 arms. Logical and arithmetic operations are calculated using our brain (hopefully ;-)).</source>
          <target state="translated">기계는 인간이라는 현실 세계 요소의 추상화입니다. 한 쌍의 눈을 통해 환경에서 읽을 수 있습니다. 우리의 기계 모델은 2 개의 팔을 사용하여 환경을 조작 할 수 있습니다. 논리 및 산술 연산은 우리의 뇌를 사용하여 계산됩니다 (바람직하게 ;-)).</target>
        </trans-unit>
        <trans-unit id="7ecbe36be8e73003b52a651bfa1b97b3b6cb4fd9" translate="yes" xml:space="preserve">
          <source>The method can also be nested, if we have multiple equivalence relations -&amp;gt; make colour piles, than within every pile partition on texture, than sort on length. Any equivalence relation that creates a partition with more than 2 elements that have about even size will bring a speed improvement over sorting (provided we can directly assign a sock to its pile), and the sorting can happen very quickly on smaller data sets.</source>
          <target state="translated">텍스처에있는 모든 파일 파티션 내에서 길이에 따라 정렬하는 것보다 여러 등가 관계가있는 경우-&amp;gt; 색상 파일을 만드는 경우에도이 방법을 중첩 할 수 있습니다. 크기가 약 2 개 이상인 파티션을 만드는 등가 관계는 정렬 속도를 향상 시키며 (파일에 직접 양말을 할당 할 수있는 경우) 정렬은 더 작은 데이터 세트에서 매우 빠르게 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a27a2fa6c14acbfbc60946013388db1b86f6b79" translate="yes" xml:space="preserve">
          <source>The problem of sorting &lt;strong&gt;your n pairs of socks is O(n)&lt;/strong&gt;. Before you throw them in the laundry &lt;strong&gt;basket&lt;/strong&gt;, you thread the left one to the right one. On taking them out, you cut the thread and put each pair into your drawer - 2 operations on n pairs, so O(n).</source>
          <target state="translated">&lt;strong&gt;n 쌍의 양말&lt;/strong&gt; 을 정렬하는 문제 &lt;strong&gt;는 O (n)&lt;/strong&gt; 입니다. 세탁물 &lt;strong&gt;바구니&lt;/strong&gt; 에 버리기 전에 왼쪽을 오른쪽으로 꿰십시오. 그것들을 꺼내면 실을 자르고 각 쌍을 서랍에 넣습니다-n 쌍에 대해 2 개의 조작이므로 O (n).</target>
        </trans-unit>
        <trans-unit id="c5d0caed9ed396ae40259a6681e3e2c91a16dfd9" translate="yes" xml:space="preserve">
          <source>The simplest answer is prior to allowing the pair to be separated, a single data structure for the pair should have been initialized that contained a pointer to the left and right sock, thus enabling socks to be referred to directly or via their pair. A sock may also be extended to contain a pointer to its partner.</source>
          <target state="translated">가장 간단한 대답은 쌍을 분리하기 전에 왼쪽 및 오른쪽 양말에 대한 포인터가 포함 된 쌍의 단일 데이터 구조를 초기화해야하므로 양말을 직접 또는 쌍을 통해 참조 할 수 있습니다. 양말은 파트너에 대한 포인터를 포함하도록 확장 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1015cb01e1edc8548eb94937e6c0a8fd4cae64a4" translate="yes" xml:space="preserve">
          <source>The simplest parallelization strategy is to have multiple workers take from the input basket and put the socks onto the piles. This only scales up so much - imagine 100 people fighting over 10 piles. &lt;strong&gt;The synchronization costs&lt;/strong&gt; (manifesting themselves as hand-collisions and human communication) &lt;strong&gt;destroy efficiency and speed-up&lt;/strong&gt; (see the &lt;a href=&quot;http://www.perfdynamics.com/Manifesto/USLscalability.html&quot;&gt;Universal Scalability Law&lt;/a&gt;!). Is this prone to &lt;strong&gt;deadlocks&lt;/strong&gt;? No, because each worker only needs to access one pile at a time. With just one &quot;lock&quot; there cannot be a deadlock. &lt;strong&gt;Livelocks&lt;/strong&gt; might be possible depending on how the humans coordinate access to piles. They might just use &lt;a href=&quot;http://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;random backoff&lt;/a&gt; like network cards do that on a physical level to determine what card can exclusively access the network wire. If it works for &lt;a href=&quot;http://en.wikipedia.org/wiki/Network_interface_controller&quot;&gt;NICs&lt;/a&gt;, it should work for humans as well.</source>
          <target state="translated">가장 간단한 병렬화 전략은 여러 명의 작업자가 입력 바구니에서 가져 와서 양말을 더미에 놓는 것입니다. 이것은 너무 커집니다. 100 명이 10 개의 더미를 놓고 싸우는 것을 상상해보십시오. &lt;strong&gt;동기화 비용&lt;/strong&gt; (수동 충돌 및 인적 커뮤니케이션으로 인한 피해) &lt;strong&gt;은 효율성과 속도 향상을 파괴합니다&lt;/strong&gt; ( &lt;a href=&quot;http://www.perfdynamics.com/Manifesto/USLscalability.html&quot;&gt;Universal Scalability Law&lt;/a&gt; ! 참조). &lt;strong&gt;교착 상태&lt;/strong&gt; 가 발생하기 &lt;strong&gt;쉽&lt;/strong&gt; 습니까? 아니요, 각 작업자는 한 번에 하나의 파일에만 액세스하면됩니다. 하나의 &quot;잠금&quot;만 있으면 교착 상태가 될 수 없습니다. 사람이 파일에 대한 접근을 조정하는 방법에 따라 &lt;strong&gt;라이브 록&lt;/strong&gt; 이 가능할 수 있습니다. 네트워크 카드가 물리적 수준에서 수행하는 것처럼 &lt;a href=&quot;http://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;임의의 백 오프를&lt;/a&gt; 사용하여 네트워크 와이어에 독점적으로 액세스 할 수있는 카드를 결정할 수도 있습니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Network_interface_controller&quot;&gt;NIC&lt;/a&gt; 에서도 작동한다면 사람에게도 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2f49bc795ae24363a2c7470a93203b0fced4c88" translate="yes" xml:space="preserve">
          <source>The special condition in my case is that I don't use drying machine, just hang my cloths on an ordinary cloth dryer. Hanging cloths requires &lt;code&gt;O(n)&lt;/code&gt; operations (by the way, I always consider &lt;a href=&quot;http://en.wikipedia.org/wiki/Bin_packing_problem]&quot;&gt;bin packing&lt;/a&gt; problem here) and the problem by its nature requires the linear &quot;extra&quot; space. When I take a new sock from the bucket I to try hang it next to its pair if the pair is already hung. If its a sock from a new pair I leave some space next to it.</source>
          <target state="translated">필자의 경우 특별한 조건은 건조기를 사용하지 않고 일반 천 건조기에 천을 걸어 두는 것입니다. 매달린 천에는 &lt;code&gt;O(n)&lt;/code&gt; 작업이 필요하지만 ( 여기서는 항상 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bin_packing_problem]&quot;&gt;빈 포장&lt;/a&gt; 문제를 고려합니다) 본질적으로 문제는 선형 &quot;추가&quot;공간이 필요합니다. 버킷에서 새 양말을 가져갈 때 페어가 이미 걸려있는 경우 페어 옆에 걸려 고합니다. 새 쌍의 양말이라면 옆에 약간의 공간이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="ce6af0db2fdccac900c8209f502eec96611a6b58" translate="yes" xml:space="preserve">
          <source>The theoretical limit is O(n) because you need to touch each sock (unless some are already paired somehow).</source>
          <target state="translated">이론적으로 제한은 O (n)입니다. 왜냐하면 각 양말을 만져야하기 때문입니다 (일부는 이미 짝을 이루지 않는 한).</target>
        </trans-unit>
        <trans-unit id="2103f930ed2f94482faf224a41b4b0491a977035" translate="yes" xml:space="preserve">
          <source>The worst-case scenario of this scheme is that every pair of socks is different enough that it must be matched exactly, and that the first &lt;em&gt;n/2&lt;/em&gt; socks you pick are all different. This is your &lt;em&gt;O&lt;/em&gt;(n&lt;sup&gt;2&lt;/sup&gt;) scenario, and it's &lt;em&gt;extremely&lt;/em&gt; unlikely. If the number of unique types of sock &lt;em&gt;t&lt;/em&gt; is less than the number of pairs &lt;em&gt;p = n/2&lt;/em&gt;, and the socks in each type are alike enough (usually in wear-related terms) that any sock of that type can be paired with any other, then as I inferred above, the maximum number of socks you will ever have to compare to is &lt;em&gt;t&lt;/em&gt;, after which the next one you pull &lt;em&gt;will&lt;/em&gt; match one of the unpaired socks. This scenario is much more likely in the average sock drawer than the worst-case, and reduces the worst-case complexity to &lt;em&gt;O&lt;/em&gt;(n*t) where usually &lt;em&gt;t &amp;lt;&amp;lt; n&lt;/em&gt;.</source>
          <target state="translated">이 체계의 최악의 시나리오는 모든 양말 쌍이 정확히 일치해야하기에 충분히 다르고 선택한 첫 번째 &lt;em&gt;n / 2&lt;/em&gt; 양말이 모두 다르다는 것입니다. 이것은 귀하의 &lt;em&gt;O&lt;/em&gt; (n &lt;sup&gt;2&lt;/sup&gt; ) 시나리오이며 &lt;em&gt;극히 드&lt;/em&gt; like니다. 양말 &lt;em&gt;t&lt;/em&gt; 의 고유 한 유형의 수가 &lt;em&gt;p = n / 2&lt;/em&gt; 쌍의 수보다 적고, 각 유형의 양말이 유사하게 (일반적으로 마모 관련 용어로) 해당 유형의 양말이 다른, 위에서 위에서 유추 한 것처럼, 당신이 비교해야 할 양말의 최대 수는 &lt;em&gt;t입니다&lt;/em&gt; . 그 후에 다음으로 당기는 양말은 짝을 이루지 않은 양말 중 하나와 일치합니다. 이 시나리오는 평균 양말 서랍에서 최악의 경우보다 훨씬 가능성이 높으며, 최악의 경우 복잡성을 보통 &lt;em&gt;t &amp;lt;&amp;lt; n 인&lt;/em&gt; &lt;em&gt;O&lt;/em&gt; (n * t)로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="96b12eabde3d73be5eafb1e84e13a730dc8628d1" translate="yes" xml:space="preserve">
          <source>Then all you do is snap your socks together right after you take them off and put them in your washing basket, and again you've removed the problem of needing to pair your socks with a physical abstraction of the 'pair' concept.</source>
          <target state="translated">그런 다음 양말을 벗고 세탁 바구니에 넣은 직후 양말을 꽂아 놓고 '쌍'개념의 물리적 추상화와 양말을 페어링 해야하는 문제를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="dced202b38f2d14c3908f94ad0c3a8bd7e6f6c93" translate="yes" xml:space="preserve">
          <source>There are two physical possibilities:</source>
          <target state="translated">두 가지 물리적 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e4e9e2d368abd05573c65b163fd925efb9322d4" translate="yes" xml:space="preserve">
          <source>This also means that you will almost certainly never have all your socks in the array, because socks will get removed as they're matched.</source>
          <target state="translated">이것은 양말이 일치함에 따라 양말이 제거되기 때문에 배열에 양말이 거의 없을 것임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bdfecabe5ec0a698991109d39b1c3465373ad88d" translate="yes" xml:space="preserve">
          <source>This approach will be favourable compared to any &lt;code&gt;c*x*n + O(1)&lt;/code&gt; method roughly as long as &lt;code&gt;log(k) &amp;lt; x - 1&lt;/code&gt;.</source>
          <target state="translated">이 접근법은 대략 &lt;code&gt;log(k) &amp;lt; x - 1&lt;/code&gt; 임의의 &lt;code&gt;c*x*n + O(1)&lt;/code&gt; 방법과 비교하여 유리할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d1f77ce46b573dd375b9b3f8133c6c3e6975fa2" translate="yes" xml:space="preserve">
          <source>This is asking the wrong question. The right question to ask is, why am I spending time sorting socks? How much does it cost on yearly basis, when you value your free time for X monetary units of your choice?</source>
          <target state="translated">이것은 잘못된 질문입니다. 올바른 질문은 왜 양말을 분류하는 데 시간을 보내고 있습니까? 선택한 X 통화 단위의 자유 시간을 소중하게 생각할 때 연간 비용은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="c7adcd7ce06b47130e35aa217e78946ac1fdb2c3" translate="yes" xml:space="preserve">
          <source>This is how I actually do it, for &lt;em&gt;p&lt;/em&gt; pairs of socks (&lt;em&gt;n = 2p&lt;/em&gt; individual socks):</source>
          <target state="translated">이것은 양말의 &lt;em&gt;p&lt;/em&gt; 쌍 ( &lt;em&gt;n = 2p&lt;/em&gt; 개별 양말)에 대해 실제로 실제로하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="235c85c59d6f0d9269c7c93b100ce67634688f1b" translate="yes" xml:space="preserve">
          <source>This kind of recursive hash partitioning is actually being done by &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt; when it needs to hash join or hash aggregate over huge data sets. It distributes its build input stream into many partitions which are independent. This scheme scales to arbitrary amounts of data and multiple CPUs linearly.</source>
          <target state="translated">이러한 종류의 재귀 해시 파티셔닝은 실제로 대규모 데이터 세트에 대해 조인 또는 해시 집계를 해시해야 할 때 &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt; 에서 수행됩니다. 빌드 입력 스트림을 독립적 인 많은 파티션으로 분배합니다. 이 체계는 임의의 양의 데이터와 여러 CPU로 선형 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="71188b927e375c9f840b0228303d1ad03320f9ac" translate="yes" xml:space="preserve">
          <source>This question is actually deeply philosophical. At heart it's about whether the power of people to solve problems (the &quot;wetware&quot; of our brains) is equivalent to what can be accomplished by algorithms.</source>
          <target state="translated">이 질문은 실제로 매우 철학적입니다. 핵심은 문제를 해결하는 사람들의 힘 (뇌의 &quot;웨어웨어&quot;)이 알고리즘으로 달성 할 수있는 것과 동등한 지에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6137f79697d8c825e0bce0519a78dca5b385553f" translate="yes" xml:space="preserve">
          <source>This solves any computational pairing problem by removing it with a layer of abstraction.</source>
          <target state="translated">이를 통해 추상화 계층으로 문제를 해결하여 모든 계산 쌍 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="832509383b3fc443a9e0c7a64e684a8be877a579" translate="yes" xml:space="preserve">
          <source>This takes advantage of the human ability to fuzzy-match in O(1) time, which is somewhat equivalent to the establishment of a hash-map on a computing device.</source>
          <target state="translated">이것은 O (1) 시간에 퍼지 매치하는 인간 능력을 활용하는데, 이는 컴퓨팅 장치에서 해시 맵을 설정하는 것과 다소 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bb9e4357cf8c4cf1055b16dd15145dc9529ca43b" translate="yes" xml:space="preserve">
          <source>Thus connecting the problem of pairing socks with the problem of hanging cloths I get &lt;code&gt;O(n)&lt;/code&gt; &quot;extra space&quot; for free, and have a solution that is about &lt;code&gt;O(n)&lt;/code&gt; in time, requires just a little more work than simple hanging cloths and allows to immediately access complete pair of socks even in a very bad Monday morning... ;-)</source>
          <target state="translated">따라서 양말 연결 문제와 천 걸기 문제를 무료로 &lt;code&gt;O(n)&lt;/code&gt; &quot;추가 공간&quot;을 얻었고, 약 &lt;code&gt;O(n)&lt;/code&gt; 정도의 솔루션을 가지고 있으며, 간단한 걸기 천보다 약간 더 많은 작업이 필요합니다. 그리고 월요일 아침에 아주 나쁜 아침에도 양말 한 켤레에 즉시 접근 할 수 있습니다 ... ;-)</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="cc9192722da415eb15991bb6f24cb75e9e00289e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;. This is only linear time since comparison is not required.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;기수 정렬을&lt;/a&gt; 사용하십시오. 비교가 필요하지 않기 때문에 이것은 단지 선형 시간입니다.</target>
        </trans-unit>
        <trans-unit id="72e4524e8782dab66f9edff21207d55131fced9d" translate="yes" xml:space="preserve">
          <source>We also have to consider the intrinsic runtime of the atomic operations that can be carried out with these instruments. Due to physical constraints, operations which are carried out by an arm or eye have non constant time complexity. This is because we can't move an endlessly large pile of socks with an arm nor can an eye see the top sock on an endlessly large pile of socks.</source>
          <target state="translated">또한 이러한 계측기로 수행 할 수있는 원자 연산의 고유 런타임을 고려해야합니다. 물리적 제약으로 인해 팔이나 눈으로 수행되는 작업은 시간이 일정하지 않습니다. 우리는 팔로 끝없이 큰 양말 더미를 움직일 수없고 끝없이 큰 양말 더미에서 맨 위 양말을 볼 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fc41cda5f1c62ac5f64fac7531ea11668364e843" translate="yes" xml:space="preserve">
          <source>We can also make use of the fact that people only have a very limited amount of socks. So an environmental modification can involve all socks in the pile.</source>
          <target state="translated">또한 사람들은 양말이 매우 제한되어 있다는 사실을 활용할 수 있습니다. 따라서 환경 수정에는 더미의 모든 양말이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f928a1fe0e4e26c3f5eb42941dbb73bf04c00c1" translate="yes" xml:space="preserve">
          <source>We have to do comparison to check whether two socks come in pair. Pick one of the &lt;code&gt;O(n log n)&lt;/code&gt; comparison-based sorting algorithms.</source>
          <target state="translated">양말 두 개가 짝을 이루는 지 확인하려면 비교를해야합니다. &lt;code&gt;O(n log n)&lt;/code&gt; 비교 기반 정렬 알고리즘 중 하나를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="8aff2e93d02cec92464795e91655b9cf0e01a5bf" translate="yes" xml:space="preserve">
          <source>What I do is that I pick up the first sock and put it down (say, on the edge of the laundry bowl). Then I pick up another sock and check to see if it's the same as the first sock. If it is, I remove them both. If it's not, I put it down next to the first sock. Then I pick up the third sock and compare that to the first two (if they're still there). Etc.</source>
          <target state="translated">내가하는 것은 첫 양말을 집어 내려 놓는 것입니다 (세탁기의 가장자리에). 그런 다음 다른 양말을 집어 들고 첫 양말과 같은지 확인합니다. 그렇다면 둘 다 제거합니다. 그렇지 않은 경우 첫 양말 옆에 내려 놓습니다. 그런 다음 세 번째 양말을 집어 들고 첫 번째 양말과 비교하십시오 (아직 거기있는 경우). 기타.</target>
        </trans-unit>
        <trans-unit id="52fb31e5804c85af0c9ab1080840c1c1106a6ac7" translate="yes" xml:space="preserve">
          <source>What about &lt;strong&gt;parallelism&lt;/strong&gt;? Can multiple humans match the socks faster?</source>
          <target state="translated">&lt;strong&gt;병렬 처리는&lt;/strong&gt; 어떻습니까? 여러 사람이 양말을 더 빨리 맞출 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="62ee3893b3dd45b1448958e4035d217abb5319ed" translate="yes" xml:space="preserve">
          <source>What about the &lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;element distinctness problem&lt;/a&gt;? As the article states, the element distinctness problem can be solved in &lt;code&gt;O(N)&lt;/code&gt;. This is the same for the socks problem (also &lt;code&gt;O(N)&lt;/code&gt;, if you need only one distribution step (I proposed multiple steps only because humans are bad at calculations - one step is enough if you distribute on &lt;code&gt;md5(color, length, pattern, ...)&lt;/code&gt;, i.e. a &lt;strong&gt;perfect hash&lt;/strong&gt; of all attributes)).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Element_distinctness_problem&quot;&gt;요소 구별 문제는&lt;/a&gt; 어떻습니까? 기사에서 알 수 있듯이 요소 구별 문제는 &lt;code&gt;O(N)&lt;/code&gt; 에서 해결할 수 있습니다. 이것은 양말 문제와 동일합니다 (분산 단계가 하나만 필요한 경우 &lt;code&gt;O(N)&lt;/code&gt; (인간이 계산에 나쁘기 때문에 여러 단계 만 제안했습니다 &lt;code&gt;md5(color, length, pattern, ...)&lt;/code&gt; 배포하면 한 단계면 충분합니다 (색상, 길이, 패턴) , ...) , 즉 모든 속성의 &lt;strong&gt;완벽한 해시&lt;/strong&gt; )).</target>
        </trans-unit>
        <trans-unit id="d6e0a1a2a1c968e16f01d631ec79dc29fcbb8978" translate="yes" xml:space="preserve">
          <source>What we want to do is reduce the number of moves, and compensate with the number of searches. Also, we can utilize the multithreded environment of the Homo Sapiens to hold more things in the descision cache.</source>
          <target state="translated">우리가 원하는 것은 이동 횟수를 줄이고 검색 횟수를 보완하는 것입니다. 또한 Homo Sapiens의 다중 스레드 환경을 활용하여 Descision Cache에 더 많은 것을 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40119aa23f988c392c776aef12173470a672ba85" translate="yes" xml:space="preserve">
          <source>When I sort socks, I do an approximate &lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;, dropping socks near other socks of the same colour/pattern type. Except in the case when I can see an exact match at/near the location I'm about to drop the sock I extract the pair at that point.</source>
          <target state="translated">양말을 정렬 할 때 근사 &lt;a href=&quot;https://en.wikipedia.org/wiki/Radix_sort&quot;&gt;기수 정렬&lt;/a&gt; 을 수행하여 동일한 색상 / 패턴 유형의 다른 양말 근처에 양말을 떨어 뜨립니다. 양말을 떨어 뜨리려고하는 위치에서 / 가까운 곳에서 정확히 일치하는 것을 볼 수있는 경우를 제외하고는 그 시점에서 쌍을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="dbe5289d9f14e85418adcf750eb06633c494d931" translate="yes" xml:space="preserve">
          <source>Whenever you pick up a sock, put it in one place.  Then the next sock you pick up, if it doesn't match the first sock, set it beside the first one.  If it does, there's a pair.  This way it doesn't really matter how many combinations there are, and there are only two possibilities for each sock you pick up -- either it has a match that's already in your array of socks, or it doesn't, which means you add it to a place in the array.</source>
          <target state="translated">양말을 집어 올릴 때마다 한 곳에 두십시오. 그런 다음, 다음 양말이 첫 양말과 일치하지 않으면 첫 양말과 일치하도록 설정하십시오. 그렇다면 쌍이 있습니다. 이 방법으로 얼마나 많은 조합이 있는지는 중요하지 않으며, 양말마다 선택할 수있는 두 가지 가능성이 있습니다. 이미 양말 배열에 일치하는 것이 있거나 그렇지 않은 것입니다. 배열의 장소에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="491d10d638725516cd524ff053d646b7db3211cb" translate="yes" xml:space="preserve">
          <source>Why five? Usually humans are good are remembering between five and seven different elements in the working memory - a bit like the human equivalent of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;RPN&lt;/a&gt; stack - five is a safe default.</source>
          <target state="translated">왜 다섯? 일반적으로 인간은 작업 메모리에서 5 ~ 7 개의 서로 다른 요소를 기억하고 있습니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;RPN&lt;/a&gt; 스택과 같은 약간의 요소입니다. 5는 안전한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="4e43cc34e87ad7b769f2e692b3183f1cf7531543" translate="yes" xml:space="preserve">
          <source>X = Yours, Y = Your spouses</source>
          <target state="translated">X = 당신, Y = 배우자</target>
        </trans-unit>
        <trans-unit id="bfa8f5c7b6006f4ab74b72c8afabacf5f628c548" translate="yes" xml:space="preserve">
          <source>Yesterday I was pairing the socks from the clean laundry and figured out the way I was doing it is not very efficient. I was doing a naive search&amp;nbsp;&amp;mdash; picking one sock and &quot;iterating&quot; the pile in order to find its pair. This requires iterating over n/2 * n/4 = n&lt;sup&gt;2&lt;/sup&gt;/8 socks on average.</source>
          <target state="translated">어제 나는 깨끗한 세탁물에서 양말을 페어링하고 있었고 내가하는 방식이 그렇게 효율적이지 않다는 것을 알았습니다. 나는 순진한 검색을하고있었습니다. 양말 한 개를 골라 짝을 찾기 위해 더미를 &quot;추적&quot;했습니다. 평균적으로 n / 2 * n / 4 = n 2/8 양말을 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbd5aa135244891d8a3e76bf37cc43c7ca49ef7d" translate="yes" xml:space="preserve">
          <source>Yet times to times, I have to do this again (lost socks, damaged socks, etc.), and I hate to discard perfectly good socks too often (and I wished they kept selling the same socks reference!), so I recently took a different approach.</source>
          <target state="translated">그러나 때때로, 나는 이것을 다시해야합니다 (양말 양말, 손상된 양말 등), 나는 아주 좋은 양말을 너무 자주 버리는 것을 싫어합니다 (그리고 나는 그들이 같은 양말 참조를 계속 팔기를 바랐습니다!). 다른 접근법.</target>
        </trans-unit>
        <trans-unit id="65810e5cb0ea23b0c4ace9656f94508778f1c8cd" translate="yes" xml:space="preserve">
          <source>You can achieve O(n) with &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;radix sort&lt;/a&gt;. You just need to pick some attributes for the buckets.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;기수 정렬을 사용&lt;/a&gt; 하여 O (n)을 달성 할 수 있습니다. 버킷의 일부 속성 만 선택하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ba38f2aaa4cb49326b1693f418fc55f635bc82d4" translate="yes" xml:space="preserve">
          <source>You don't need recursive partitioning if you can find a distribution key (hash key) that &lt;strong&gt;provides enough buckets&lt;/strong&gt; that each bucket is small enough to be processed very quickly. Unfortunately, I don't think socks have such a property.</source>
          <target state="translated">각 버킷이 매우 빠르게 처리 될 수있을만큼 &lt;strong&gt;충분한 버킷&lt;/strong&gt; 을 &lt;strong&gt;제공&lt;/strong&gt; 하는 배포 키 (해시 키)를 찾을 수있는 경우 재귀 파티션을 수행 할 필요가 없습니다. 불행히도 양말에는 그런 성질이 없다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="991cf8e975ca3081b3b2acc02dc579d8b387f197" translate="yes" xml:space="preserve">
          <source>You need to estimate how many pairs of socks you will need for the rest of your life, or perhaps until you retire and move to warmer climates with no need to wear socks ever again. If you are young, you could also estimate how long it takes before we'll all have sock-sorting robots in our homes, and the whole problem becomes irrelevant.</source>
          <target state="translated">남은 평생 동안 필요한 양말 한 켤레를 추정하거나 양말을 다시 착용 할 필요없이 은퇴하고 따뜻한 기후로 이동할 때까지 추정해야합니다. 당신이 어릴 경우, 우리 모두가 집에 양말 분류 로봇을 갖기까지 걸리는 시간을 추정 할 수 있으며 전체 문제는 무의미합니다.</target>
        </trans-unit>
        <trans-unit id="fbfa245099ad6c7e954cd2c2f169e543c5ddc580" translate="yes" xml:space="preserve">
          <source>You need to find out how you can order your selected sock in bulk, and how much it costs, and do they deliver.</source>
          <target state="translated">선택한 양말을 대량으로 주문할 수있는 방법과 비용, 배송 방법을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="a2c3fba934e9cc7f3bb5f1c5bf7698755a4d500b" translate="yes" xml:space="preserve">
          <source>any subset taken from the top of this bin generally contains both
socks of a pair.</source>
          <target state="translated">이 빈의 상단에서 가져온 부분 집합에는 일반적으로 한 쌍의 양말이 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="66103b5b15e1b774175c59b31bb92026836434e7" translate="yes" xml:space="preserve">
          <source>environmental modifications</source>
          <target state="translated">환경 수정</target>
        </trans-unit>
        <trans-unit id="b72a142027a3d942512bfeebef1158e5555cdbf9" translate="yes" xml:space="preserve">
          <source>environmental reads</source>
          <target state="translated">환경 판독</target>
        </trans-unit>
        <trans-unit id="73ed780668cf0ea89fb1a13af96da25121e815d0" translate="yes" xml:space="preserve">
          <source>logical and arithmetic operations</source>
          <target state="translated">논리 및 산술 연산</target>
        </trans-unit>
        <trans-unit id="7b417589bff426c4c61c5b75b1f2b186688fc14d" translate="yes" xml:space="preserve">
          <source>p&lt;sub&gt;1&lt;/sub&gt; p&lt;sub&gt;2&lt;/sub&gt; p&lt;sub&gt;3&lt;/sub&gt; ... p&lt;sub&gt;n&lt;/sub&gt; p&lt;sub&gt;f(1)&lt;/sub&gt; p&lt;sub&gt;f(2)&lt;/sub&gt; ... p&lt;sub&gt;f(n)&lt;/sub&gt;</source>
          <target state="translated">p &lt;sub&gt;1&lt;/sub&gt; p &lt;sub&gt;2&lt;/sub&gt; p &lt;sub&gt;3&lt;/sub&gt; ... p &lt;sub&gt;n&lt;/sub&gt; p &lt;sub&gt;f (1)&lt;/sub&gt; p &lt;sub&gt;f (2)&lt;/sub&gt; ... p &lt;sub&gt;f (n)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d64b5bfb8d253171cb7f047779677b1f366a37c7" translate="yes" xml:space="preserve">
          <source>people toss both of their socks roughly in the same area of the
bin,</source>
          <target state="translated">사람들은 쓰레기통의 같은 지역에 양말을 대고 던졌습니다.</target>
        </trans-unit>
        <trans-unit id="e7aa0c831ecd9e4ccd9acd48f58060ccc6e98d8a" translate="yes" xml:space="preserve">
          <source>step 1) discard all your existing socks</source>
          <target state="translated">1 단계) 기존 양말을 모두 버립니다.</target>
        </trans-unit>
        <trans-unit id="85929a76b2535ede46f1da6de8472cf210e6cc72" translate="yes" xml:space="preserve">
          <source>step 2) go to &lt;a href=&quot;http://en.wikipedia.org/wiki/Walmart&quot;&gt;Walmart&lt;/a&gt; and buy them by packets of 10 - n packet of
white and m packets of black. No need for other colors in everyday's
life.</source>
          <target state="translated">2 단계) &lt;a href=&quot;http://en.wikipedia.org/wiki/Walmart&quot;&gt;Walmart&lt;/a&gt; 로 가서 10-n 개의 흰색 패킷과 m 개의 검은 패킷으로 구입하십시오. 일상 생활에서 다른 색상이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0bc37af84619514b988559161037a53edaa21ff" translate="yes" xml:space="preserve">
          <source>the bin is not randomized at any point, and therefore</source>
          <target state="translated">빈은 어느 시점에서나 무작위 화되지 않으므로</target>
        </trans-unit>
        <trans-unit id="937822ebb59548bbc8c060e49cb9b98efb226b16" translate="yes" xml:space="preserve">
          <source>then length of the sock,</source>
          <target state="translated">양말 길이</target>
        </trans-unit>
        <trans-unit id="f0604a64202bf39aaef8452c27dea8a360470c75" translate="yes" xml:space="preserve">
          <source>then texture,
....</source>
          <target state="translated">그런 다음 질감, ....</target>
        </trans-unit>
        <trans-unit id="f0038d5ea027e24fd063b53770f561619dfa487e" translate="yes" xml:space="preserve">
          <source>then use colors (can have any order for the colors, e.g. alphabetically by color name) - split them into piles by color (remember to keep the initial order from step 1 for all socks in the same pile),</source>
          <target state="translated">그런 다음 색상을 사용하십시오 (예 : 색상 이름을 기준으로 알파벳 순서대로 정렬 가능)-색상별로 더미로 나눕니다 (모든 양말에 대해 1 단계부터 동일한 더미에있는 초기 순서를 유지해야 함),</target>
        </trans-unit>
        <trans-unit id="4045b164d7574af579063ab4269d98a5011ed66a" translate="yes" xml:space="preserve">
          <source>where f is an unknown permutation of the set {1,2,...,n}. Knowing this cannot make the problem harder. There are n! possible outputs (matchings between first and second half), which means you need log(n!) = Omega(n log n) comparisons. This is obtainable by sorting.</source>
          <target state="translated">여기서 f는 집합 {1,2, ..., n}의 알 수없는 순열입니다. 이것을 아는 것은 문제를 더 어렵게 만들 수 없습니다. n이 있습니다! 가능한 출력 (전반과 후반의 일치), 즉 log (n!) = Omega (n log n) 비교가 필요합니다. 이것은 정렬하여 얻을 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
