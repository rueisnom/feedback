<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/142003">
    <body>
      <group id="142003">
        <trans-unit id="188db66d173d4c9c2cfa9e511a3c47dec8d733cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.Invoke.aspx&quot;&gt;System.Windows.Forms.Control.Invoke&lt;/a&gt; causes separate thread to wait till invoked method is completed:</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.Invoke.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Windows.Forms.Control.Invoke&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;导致单独的线程等待被调用的方法完成：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b08f66fef449672cfaa633f9861c9a00cc32b791" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker.aspx&lt;/a&gt;
Especially how it interacts with the UI layer.  Based on your posting, this seems to answer your issues.</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://msdn.microsoft.com/zh-cn/library/system.componentmodel.backgroundworker.aspx&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 特别是它如何与UI层交互。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据您的发布，这似乎可以回答您的问题。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b7965917cff32d36bf584aca78251de387009568" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.forms.control.begininvoke.aspx&quot;&gt;System.Windows.Forms.Control.BeginInvoke&lt;/a&gt; doesn't cause the separate thread to wait till invoked method is completed:</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.forms.control.begininvoke.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Windows.Forms.Control.BeginInvoke&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不会导致单独的线程等待被调用的方法完成：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f179616c726b43ddcc9b91ce608c46a0384df631" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Adding Try Catch, Auto Exception Logging and CallBack&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;添加尝试捕获，自动异常记录和回调&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02b82bf3e1a93f8ba1612e9de1b8c929f472b3ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CODE 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代码1&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b4b8c627349bf8556faac2b36ba11933a91a73b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CODE 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代码2&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c64b3f64bb6e2c8f237028444f8986be6c5de7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Helper Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;辅助方法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d01e1b1b685912218f856209e992cf7eda468b42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sample Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;样品用量&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f48b85708799dddd7d170178b98378d48ba3ef3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The situation is this&lt;/strong&gt;: I want to load data into a global variable based on the value of a control. I don't want to change the value of a control from the child thread. I'm not going to do it ever from a child thread.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;情况是这样的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：我想根据控件的值将数据加载到全局变量中。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我不想从子线程更改控件的值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我永远不会从子线程执行此操作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b0f6d52f0ce8e1b8420e81cb7ac6939a953f9bb" translate="yes" xml:space="preserve">
          <source>A new look using Async/Await and callbacks.  You only need one line of code if you keep the extension method in your project.</source>
          <target state="translated">使用AsyncAwait和回调的新外观。如果你的项目中保留了扩展方法,你只需要一行代码。</target>
        </trans-unit>
        <trans-unit id="10cd2c24f0128f883483255b77925485053df4ed" translate="yes" xml:space="preserve">
          <source>Action y; //declared inside class</source>
          <target state="translated">Action y;/declared inside class</target>
        </trans-unit>
        <trans-unit id="cb79c66b7f8d28de3fc3f880507b51d98360509c" translate="yes" xml:space="preserve">
          <source>Along the same lines as previous answers,
but a very short addition that Allows to use all Control properties without having cross thread invokation exception.</source>
          <target state="translated">与前面的答案相同,但有一个非常简短的补充,允许使用所有的Control属性而不需要跨线程调用异常。</target>
        </trans-unit>
        <trans-unit id="1aab0db270befbe2cc543d0f9a0c314c3fecc18f" translate="yes" xml:space="preserve">
          <source>And then you can simply do this:</source>
          <target state="translated">然后你就可以简单地这样做。</target>
        </trans-unit>
        <trans-unit id="e563cfe6387964bed8d4c1dc6a73365021f8f182" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://stackoverflow.com/questions/142003/cross-thread-operation-not-valid-control-accessed-from-a-thread-other-than-the#142108&quot;&gt;Prerak K's update comment&lt;/a&gt; (since deleted):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/142003/cross-thread-operation-not-valid-control-accessed-from-a-thread-other-than-the#142108&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Prera​​k K的更新评论&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（已删除）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f02661ee29e185e6d9abcf024d2514249fcc84e8" translate="yes" xml:space="preserve">
          <source>Attempt to access member of &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.aspx&quot;&gt;System.Windows.Forms.Control&lt;/a&gt; from different thread than UI thread will cause cross-thread exception.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从与UI线程不同的线程&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;访问&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Windows.Forms.Control的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成员&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将导致跨线程异常。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cfdd5e6174b1a9e8455dfd6042b09c1c44548556" translate="yes" xml:space="preserve">
          <source>BUT BUT BUT... it seems I'm back to square one. The Application again 
become nonresponsive. It seems to be due to the execution of line #1 if condition. The loading task is again done by the parent thread and not the third that I spawned.</source>
          <target state="translated">但是,但是,但是...........看来我又回到了原点。应用程序再次变得没有响应。这似乎是由于执行第1行的if条件造成的。加载任务又是由父线程完成,而不是我生成的第三个线程。</target>
        </trans-unit>
        <trans-unit id="e806c824f4885208f95601392ddec281715b6125" translate="yes" xml:space="preserve">
          <source>BeginInvoke</source>
          <target state="translated">BeginInvoke</target>
        </trans-unit>
        <trans-unit id="7e1eb90aeacc6371f31ec12607e6b77603cff00e" translate="yes" xml:space="preserve">
          <source>BeginInvoke and Invoke methods</source>
          <target state="translated">BeginInvoke和Invoke方法</target>
        </trans-unit>
        <trans-unit id="70d07c050238bbf5aa3eb59615b4c99eb6627933" translate="yes" xml:space="preserve">
          <source>Code solution</source>
          <target state="translated">解决方案代码</target>
        </trans-unit>
        <trans-unit id="b66709ec059bd1186d2b063b070bd5f38f3d1119" translate="yes" xml:space="preserve">
          <source>Control.InvokeRequired is only useful when working controls inherited from Control class while SynchronizationContext can be used anywhere. Some useful information is as following links</source>
          <target state="translated">Control.InvokeRequired只在继承自Control类的工作控件时有用,而SynchronizationContext可以在任何地方使用。一些有用的信息如下链接</target>
        </trans-unit>
        <trans-unit id="2b4f504792a7d3d8a5efefe60cded3f2a7d2003b" translate="yes" xml:space="preserve">
          <source>Controls in .NET are not generally thread safe.  That means you shouldn't access a control from a thread other than the one where it lives.  To get around this, you need to &lt;em&gt;invoke&lt;/em&gt; the control, which is what your 2nd sample is attempting.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET中的控件通常不是线程安全的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这意味着您不应从线程所在的线程之外的其他线程访问控件。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了解决这个问题，您需要&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;控件，这是您的第二个示例正在尝试的操作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="33313311234b81fdae5aa7348d61d1bc6e33a818" translate="yes" xml:space="preserve">
          <source>Cross Thread Update UI using SynchronizationContext | .Net</source>
          <target state="translated">.Net</target>
        </trans-unit>
        <trans-unit id="be815dc42b8a797003d5531a64533af2a74f1719" translate="yes" xml:space="preserve">
          <source>Cross Thread Update UI | .Net</source>
          <target state="translated">.Net</target>
        </trans-unit>
        <trans-unit id="e9bb0bb589d5c347c935e02e87343fd4f2a930b3" translate="yes" xml:space="preserve">
          <source>Cross-thread operation not valid: Control accessed from a thread other than the thread it was created on</source>
          <target state="translated">跨线程操作无效。从其创建的线程以外的线程访问的控件</target>
        </trans-unit>
        <trans-unit id="8e017ff03d8165f00dbf60bb448b579dc23e4fe4" translate="yes" xml:space="preserve">
          <source>Cross-thread operation not valid: Control accessed from a thread other than the thread it was created on.</source>
          <target state="translated">跨线程操作无效。控件从其创建的线程以外的线程访问。</target>
        </trans-unit>
        <trans-unit id="bddf02b4126e53c1f13950bdf5e4a39586e4e4f6" translate="yes" xml:space="preserve">
          <source>Declare some variable to hold these kind of values in a separate class (which will work as data holder) . Create static instance of this class adn you can access it over any thread.</source>
          <target state="translated">在一个单独的类中声明一些变量来保存这些值(它将作为数据持有者)。创建这个类的静态实例,你可以在任何线程中访问它。</target>
        </trans-unit>
        <trans-unit id="123b323a9c351a5ebb88f8ec09aaf2db8a751fb0" translate="yes" xml:space="preserve">
          <source>Do your serious processing in the separate thread &lt;em&gt;before&lt;/em&gt; you attempt to switch back to the control's thread. For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试切换回控件的线程&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之前，&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在单独的线程中&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;认真的处理&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="60f9af3a2f24f2af9f9a91b2a5ae749f345720d6" translate="yes" xml:space="preserve">
          <source>Follow the simplest (in my opinion) way to modify objects from another thread:</source>
          <target state="translated">按照最简单的方法(在我看来)从另一个线程修改对象。</target>
        </trans-unit>
        <trans-unit id="acb8ac032e9a32b9a23d12bd5e58825505e22c07" translate="yes" xml:space="preserve">
          <source>For example to get the text from a Control of the UI thread:</source>
          <target state="translated">例如,从UI线程的Control中获取文本。</target>
        </trans-unit>
        <trans-unit id="7cbce1ffbd6ee372f6df762dc576ebce5da16f80" translate="yes" xml:space="preserve">
          <source>Here is an alternative way if the object you are working with doesn't have</source>
          <target state="translated">如果你所处理的对象不具备下列条件,这里有一个替代方法</target>
        </trans-unit>
        <trans-unit id="6ff4f0325ec93e20a54e6dfdb9e4a75bf91f624c" translate="yes" xml:space="preserve">
          <source>How do I resolve this and also what is the effect of execution of Line#1 if block?</source>
          <target state="translated">如何解决,还有就是执行Line#1 if块的效果如何?</target>
        </trans-unit>
        <trans-unit id="fa692e8d344ff6df7cf07ee2b7c9fe0b50c2db13" translate="yes" xml:space="preserve">
          <source>However, in your case all you've done is pass the long-running method back to the main thread.  Of course, that's not really what you want to do.  You need to rethink this a little so that all you're doing on the main thread is setting a quick property here and there.</source>
          <target state="translated">然而,在你的情况下,你所做的只是将长效方法传回主线程。当然,这不是你想做的。你需要重新思考一下,让你在主线程上做的只是在这里和那里设置一个快速属性。</target>
        </trans-unit>
        <trans-unit id="8cdc91e53389735002c286b7024465e76f1efa91" translate="yes" xml:space="preserve">
          <source>I don't know whether I perceived this right or wrong. I'm new to threading.</source>
          <target state="translated">我不知道我的看法是对还是错。我是个新手,对线程是个新手。</target>
        </trans-unit>
        <trans-unit id="ba62435312b33eee202bc134f8bb89332edb69a1" translate="yes" xml:space="preserve">
          <source>I find the check-and-invoke code which needs to be littered within all methods related to forms to be way too verbose and unneeded. Here's a simple extension method which lets you do away with it completely:</source>
          <target state="translated">我发现在所有与表单相关的方法中,检查和调用的代码都需要在表单相关的方法中出现,这样的代码太过冗长,也不需要。这里有一个简单的扩展方法,可以让你完全不需要它。</target>
        </trans-unit>
        <trans-unit id="5727013a40b87c44992738d0ec452f4710a03f79" translate="yes" xml:space="preserve">
          <source>I found a need for this while programming an iOS-Phone monotouch app controller in a visual studio winforms prototype project outside of xamarin stuidio. Preferring to program in VS over xamarin studio as much as possible, I wanted the controller to be completely decoupled from the phone framework. This way implementing this for other frameworks like Android and Windows Phone would be much easier for future uses.</source>
          <target state="translated">我在xamarin stuidio之外的visual studio winforms原型项目中编程一个iOS-Phone单点触控应用控制器时发现了这样的需求。我希望尽可能的在VS中编程,而不是在xamarin studio中编程,我希望控制器完全脱离手机框架。这样一来,在其他框架如Android和Windows Phone等框架中实现这一点,在未来的使用中会更容易。</target>
        </trans-unit>
        <trans-unit id="c981f66dd28eae20b0fc9d1e6878e24d83038c9d" translate="yes" xml:space="preserve">
          <source>I guess I have not presented the question properly.</source>
          <target state="translated">我想我没有把这个问题说得很好。</target>
        </trans-unit>
        <trans-unit id="f2c17598b9d8facd47c7d6d9fd1a42a1a7c2225f" translate="yes" xml:space="preserve">
          <source>I have a scenario. (Windows Forms, C#, .NET)</source>
          <target state="translated">我有一个场景。(Windows Forms,C#,.NET)</target>
        </trans-unit>
        <trans-unit id="8756c26dbafa8ca5df197a4c5358bd23a6769a32" translate="yes" xml:space="preserve">
          <source>I have had this problem with the &lt;code&gt;FileSystemWatcher&lt;/code&gt; and found that the following code solved the problem:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;FileSystemWatcher&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;遇到了这个问题，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;发现以下代码解决了该问题：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fc06fa8eeeff0d4cee63db4981453c5d558f4ca6" translate="yes" xml:space="preserve">
          <source>I know its too late now. However even today if you are having trouble accessing cross thread controls? This is the shortest answer till date :P</source>
          <target state="translated">我知道现在太晚了。然而,即使是今天,如果你在访问跨线程控制方面遇到了困难?这是到目前为止最短的答案:P</target>
        </trans-unit>
        <trans-unit id="bd6a56d96a50a7f3890f9fea016d9353c383e061" translate="yes" xml:space="preserve">
          <source>I used a background worker thread which will be loading the data and when done will notify the application that it has done its work.</source>
          <target state="translated">我使用了一个后台工作者线程,它将加载数据,完成后会通知应用程序完成工作。</target>
        </trans-unit>
        <trans-unit id="11bda0b4109646097331b5e1a84ecee321f8f166" translate="yes" xml:space="preserve">
          <source>I wanted a solution where the GUI could respond to events without the burden of dealing with the cross threading switching code behind every button click. Basically let the class controller handle that to keep the client code simple. You could possibly have many events on the GUI where as if you could handle it in one place in the class would be cleaner. I am not a multi theading expert, let me know if this is flawed.</source>
          <target state="translated">我想要一个解决方案,让GUI可以响应事件,而不需要处理每个按钮点击后的跨线程切换代码。基本上让类控制器来处理,以保持客户端代码简单。你可以在GUI上有很多事件,如果你可以在类中的一个地方处理,那就更干净了。我不是一个多着色专家,如果这有什么缺陷请告诉我。</target>
        </trans-unit>
        <trans-unit id="1dc4ea206863855cf11c55fdea62c6200cb32d43" translate="yes" xml:space="preserve">
          <source>If there is no work for UI thread, then there are idle gaps that can be used by a not-UI related computing.</source>
          <target state="translated">如果没有UI线程的工作,那么就有闲置的空隙,可以通过非UI相关的计算来使用。</target>
        </trans-unit>
        <trans-unit id="571d9b8eb3e4a243b7be528b330a174a67d33133" translate="yes" xml:space="preserve">
          <source>In order to use mentioned gaps use &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.Invoke.aspx&quot;&gt;System.Windows.Forms.Control.Invoke&lt;/a&gt; or &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.forms.control.begininvoke.aspx&quot;&gt;System.Windows.Forms.Control.BeginInvoke&lt;/a&gt; methods:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了使用提到的差距，请使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.Invoke.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Windows.Forms.Control.Invoke&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.forms.control.begininvoke.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Windows.Forms.Control.BeginInvoke&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c65605adf5270f5065089b0189da542274d30db0" translate="yes" xml:space="preserve">
          <source>Invoke</source>
          <target state="translated">Invoke</target>
        </trans-unit>
        <trans-unit id="6805079961da21949bf5d9fbbcc3a83a07caa8b0" translate="yes" xml:space="preserve">
          <source>It works the same as above, but it is a different approach if you don't have an object with invokerequired, but do have access to the MainForm</source>
          <target state="translated">它的工作原理与上述相同,但如果你没有一个带invokerequired的对象,但你有访问MainForm的权限,那就是不同的方法了。</target>
        </trans-unit>
        <trans-unit id="3ec62eadcadcfc5efeb0aacb5b51428741b2ea40" translate="yes" xml:space="preserve">
          <source>No more messing around - simple.</source>
          <target state="translated">不用再瞎折腾了--简单。</target>
        </trans-unit>
        <trans-unit id="317885447cebb59204ea4ad82dcf6fe62ef4e311" translate="yes" xml:space="preserve">
          <source>Now came a real problem. All the UI (main form and its child usercontrols) was created on the primary main thread. In the LOAD method of the usercontrol I'm fetching data based on the values of some control (like textbox) on userControl.</source>
          <target state="translated">现在,一个真正的问题来了。所有的UI(主窗体和它的子用户控件)都是在主线程上创建的。在usercontrol的LOAD方法中,我根据userControl上的一些控件(如textbox)的值来获取数据。</target>
        </trans-unit>
        <trans-unit id="6112946a0eb6d655e60266427479a1c4232a8b3f" translate="yes" xml:space="preserve">
          <source>Please read the &lt;em&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/ms741870(v=vs.100).aspx&quot;&gt;Threading Model&lt;/a&gt;&lt;/em&gt; in UI applications in order to understand basic concepts. The link navigates to page that describes the WPF threading model. However, Windows Forms utilizes the same idea.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请阅读&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;UI应用程序中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/ms741870(v=vs.100).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;线程模型&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以了解基本概念。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;链接导航到描述WPF线程模型的页面。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，Windows窗体使用相同的想法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64619dc0c40ce140ba6f4ef2c349a7e2752bed80" translate="yes" xml:space="preserve">
          <source>Read answers on question &lt;a href=&quot;https://stackoverflow.com/questions/661561/how-to-update-the-gui-from-another-thread-in-c&quot;&gt;How to update the GUI from another thread in C#?&lt;/a&gt;.
For C# 5.0 and .NET 4.5 the recommended solution is &lt;a href=&quot;https://stackoverflow.com/a/18033198/2042090&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;阅读有关问题的答案&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/661561/how-to-update-the-gui-from-another-thread-in-c&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如何从C＃中的另一个线程更新GUI？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于C＃5.0和.NET 4.5，推荐的解决方案在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/18033198/2042090&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此处&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8a69dfc54c5bce979e0ffbd80496f7ceba3dc6e9" translate="yes" xml:space="preserve">
          <source>Return value in e.result and use it to set yout textbox value in backgroundWorker_RunWorkerCompleted event</source>
          <target state="translated">返回e.result中的值,并使用它来设置backgroundWorker_RunWorkerCompleted事件中的文本框值。</target>
        </trans-unit>
        <trans-unit id="825328a92a9a854ed0c343502c00599dd1f2cbb2" translate="yes" xml:space="preserve">
          <source>Same question : how-to-update-the-gui-from-another-thread-in-c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4a4b96cfa36805e2b0bf7ece72400ff7c5b3f9" translate="yes" xml:space="preserve">
          <source>See my &lt;a href=&quot;http://pobox.com/~skeet/csharp/threads&quot;&gt;threading article&lt;/a&gt; for a &lt;a href=&quot;http://pobox.com/~skeet/csharp/threads/winforms.shtml&quot;&gt;WinForms example&lt;/a&gt; - although the article was written before BackgroundWorker arrived on the scene, and I'm afraid I haven't updated it in that respect. BackgroundWorker merely simplifies the callback a bit.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参阅我的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://pobox.com/~skeet/csharp/threads&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;线程文章&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://pobox.com/~skeet/csharp/threads/winforms.shtml&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;WinForms示例&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -尽管该文章是在BackgroundWorker出现之前编写的，但恐怕我在这方面还没有进行更新。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BackgroundWorker只是稍微简化了回调。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9dc63bb2af5cd1e369af72f5dacfe14b82975a3c" translate="yes" xml:space="preserve">
          <source>Simply use this:</source>
          <target state="translated">只需使用这个就可以了。</target>
        </trans-unit>
        <trans-unit id="1dac47504b6b788b5c47fdaff1885a75afdf6b76" translate="yes" xml:space="preserve">
          <source>Since there is only one thread, all UI operations are queued as work items into that thread:</source>
          <target state="translated">因为只有一个线程,所以所有的UI操作都作为工作项目排队进入该线程。</target>
        </trans-unit>
        <trans-unit id="ca3dfccb87aa730c28a796edb3d768d8d436a705" translate="yes" xml:space="preserve">
          <source>Situation is this: I want to load data into a global variable based on the value of a control. I don't want to change the value of a control from the child thread. I'm not going to do it ever from a child thread.</source>
          <target state="translated">现在的情况是这样的。我想根据一个控件的值将数据加载到一个全局变量中。我不想从子线程中改变一个控件的值。我不打算从子线程中进行。</target>
        </trans-unit>
        <trans-unit id="007fba3b2e8669fc9d40baae6a1c625b5e85c51f" translate="yes" xml:space="preserve">
          <source>So only accessing the value so that corresponding data can be fetched from the database.</source>
          <target state="translated">所以只有访问值,才能从数据库中提取相应的数据。</target>
        </trans-unit>
        <trans-unit id="eca82d18def17ca9cce31cc41d22c93508540736" translate="yes" xml:space="preserve">
          <source>So only accessing the value so that the corresponding data can be fetched from the database.</source>
          <target state="translated">所以只有访问该值,才能从数据库中获取相应的数据。</target>
        </trans-unit>
        <trans-unit id="da058dfc9ca2752ce55fbc0f92315b0398b06010" translate="yes" xml:space="preserve">
          <source>The Exception it gave was</source>
          <target state="translated">它给出的例外是</target>
        </trans-unit>
        <trans-unit id="1047482cad9df3cdaa6be5f15ea3276103df8f39" translate="yes" xml:space="preserve">
          <source>The GUI form is unaware the controller is running asynchronous tasks.</source>
          <target state="translated">GUI形式不知道控制器正在运行异步任务。</target>
        </trans-unit>
        <trans-unit id="19d06018c19bcd9c0a4105dbdeeb4ee2195588c2" translate="yes" xml:space="preserve">
          <source>The UI Thread</source>
          <target state="translated">UI 线程</target>
        </trans-unit>
        <trans-unit id="fe9de2423a7f187bb172474a2f8e37ff9f33dad5" translate="yes" xml:space="preserve">
          <source>The cleanest (and proper) solution for UI cross-threading issues is to use SynchronizationContext, see &lt;a href=&quot;http://www.lostechies.com/blogs/gabrielschenker/archive/2009/01/23/synchronizing-calls-to-the-ui-in-a-multi-threaded-application.aspx&quot;&gt;Synchronizing calls to the UI in a multi-threaded application&lt;/a&gt; article, it explains it very nicely.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决UI跨线程问题的最干净（也是正确的）解决方案是使用SynchronizationContext，请参阅&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.lostechies.com/blogs/gabrielschenker/archive/2009/01/23/synchronizing-calls-to-the-ui-in-a-multi-threaded-application.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多线程应用程序&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文章&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的&amp;ldquo;同步对UI的调用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;，它很好地解释了该问题。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5e4b02a5f418b4350e0984de858f8589ac2bfa1" translate="yes" xml:space="preserve">
          <source>The computing overhead of method being invoked should be small as well as computing overhead of event handler methods because the UI thread is used there - the same that is responsible for handling user input. Regardless if this is &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.Invoke.aspx&quot;&gt;System.Windows.Forms.Control.Invoke&lt;/a&gt; or &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.forms.control.begininvoke.aspx&quot;&gt;System.Windows.Forms.Control.BeginInvoke&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被调用的方法的计算开销应该和事件处理程序方法的计算开销一样小，因为在那里使用了UI线程-负责处理用户输入的线程。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无论是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.Invoke.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Windows.Forms.Control.Invoke&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.forms.control.begininvoke.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Windows.Forms.Control.BeginInvoke&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6537fb373ef1813017b553425872eb57bfb45771" translate="yes" xml:space="preserve">
          <source>The control then uses the current form object to deal with the events, and will therefore be on the same thread.</source>
          <target state="translated">然后该控件使用当前窗体对象来处理事件,因此将在同一线程上。</target>
        </trans-unit>
        <trans-unit id="157ae424ce08780f6b4f7141bd4d5e96a8e210de" translate="yes" xml:space="preserve">
          <source>The pseudocode would look like this:</source>
          <target state="translated">伪代码看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="fbc043659f6ec8ac7ca50bd4589cba0e3a307d16" translate="yes" xml:space="preserve">
          <source>The solution you want then should look like:</source>
          <target state="translated">那么你想要的解决方案应该是这样的。</target>
        </trans-unit>
        <trans-unit id="099ea64091e8a542c01994ac0975274cb7f43b1b" translate="yes" xml:space="preserve">
          <source>The user control does some heavy data operation, such that if I directly call the &lt;code&gt;UserControl_Load&lt;/code&gt; method the UI become nonresponsive for the duration for load method execution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用户控件执行一些繁重的数据操作，因此，如果我直接调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;UserControl_Load&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法，则UI在装入方法执行期间将无响应。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="300c681df157ada97ca4a46ad24788d6d9af63d0" translate="yes" xml:space="preserve">
          <source>There are two options for cross thread operations.</source>
          <target state="translated">有两个选项可以进行跨线程操作。</target>
        </trans-unit>
        <trans-unit id="a10d0e39c285e5bd47b26b31b08df24c211d6cb8" translate="yes" xml:space="preserve">
          <source>There is a main form which hosts some user control.</source>
          <target state="translated">有一个主形式,它承载着一些用户控制。</target>
        </trans-unit>
        <trans-unit id="712298864f58d1bc4e135e572306280a7bb5f5c0" translate="yes" xml:space="preserve">
          <source>There is only one thread (UI thread), that is allowed to access &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.aspx&quot;&gt;System.Windows.Forms.Control&lt;/a&gt; and its subclasses members.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只有一个线程（UI线程）被允许访问&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Windows.Forms.Control&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;及其子类成员。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dab8ded28f92359e5f9c9d5860d88fe29108ae1f" translate="yes" xml:space="preserve">
          <source>This is how i access any form control from a thread.</source>
          <target state="translated">这就是我如何从一个线程中访问任何表单控制。</target>
        </trans-unit>
        <trans-unit id="53eb53cfb175a2ba78c619db5044612631695c15" translate="yes" xml:space="preserve">
          <source>This is not the recommended way to solve this error but you can suppress it quickly, it will do the job . I prefer this for prototypes or demos . add</source>
          <target state="translated">这不是推荐的解决这个错误的方法,但你可以快速地抑制它,它将完成工作。我更喜欢这个方法来做原型或演示。</target>
        </trans-unit>
        <trans-unit id="5c075d610f8d84cda1a4650d52585b952930449f" translate="yes" xml:space="preserve">
          <source>This is useful if you are working with the main form in a class other than the main form with an object that is in the main form, but doesn't have InvokeRequired</source>
          <target state="translated">当你在主窗体以外的类中使用主窗体中的对象,但没有InvokeRequired的对象时,这很有用</target>
        </trans-unit>
        <trans-unit id="009bfa89936ed96950785b24d7516548a4c10347" translate="yes" xml:space="preserve">
          <source>Threading Model in UI</source>
          <target state="translated">UI中的线程模型</target>
        </trans-unit>
        <trans-unit id="8a6182575d1d703a7e9fe67917963edfbb7ce8e7" translate="yes" xml:space="preserve">
          <source>To know more about this I did some googling and a suggestion came up like using the following code</source>
          <target state="translated">为了了解更多关于这个问题,我做了一些googling,并提出了一个建议,如使用以下代码</target>
        </trans-unit>
        <trans-unit id="001a1fd40d11d458591444449ac11f946e331eee" translate="yes" xml:space="preserve">
          <source>To overcome this I load data on different thread (trying to change existing code as little as I can)</source>
          <target state="translated">为了克服这个问题,我将数据加载到不同的线程上(尽量少修改现有的代码)。</target>
        </trans-unit>
        <trans-unit id="fe7088016fa44427af7e7e4bffaaaddee05b6c72" translate="yes" xml:space="preserve">
          <source>To perform computing expensive operation always use separate thread. Since .NET 2.0 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker.aspx&quot;&gt;BackgroundWorker&lt;/a&gt; is dedicated to performing computing expensive operations in Windows Forms. However in new solutions you should use the async-await pattern as described &lt;a href=&quot;https://stackoverflow.com/a/18033198/2042090&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要执行计算昂贵的操作，请始终使用单独的线程。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于.NET 2.0 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BackgroundWorker&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;致力于在Windows窗体中执行计算昂贵的操作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然而，在新的解决方案所描述的，你应该使用异步的await模式&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/18033198/2042090&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="216578d6cead1ef22c17300b5671dfd5094bfade" translate="yes" xml:space="preserve">
          <source>Two Ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e102a55b2ef3c3b3674b65d518da442a44ef1a0c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.Invoke.aspx&quot;&gt;System.Windows.Forms.Control.Invoke&lt;/a&gt; or &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.forms.control.begininvoke.aspx&quot;&gt;System.Windows.Forms.Control.BeginInvoke&lt;/a&gt; methods only to update a user interface. If you use them for heavy computations, your application will block:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Control.Invoke.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Windows.Forms.Control.Invoke&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.forms.control.begininvoke.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Windows.Forms.Control.BeginInvoke&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法来更新用户界面。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果将它们用于繁重的计算，则您的应用程序将阻止：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90636b72ea85ff1c8dfd10b10b077f8f1d322dbf" translate="yes" xml:space="preserve">
          <source>You can add other things to the Extension method such as wrapping it in a Try/Catch statement, allowing caller to tell it what type to return after completion, an exception callback to caller:</source>
          <target state="translated">你可以给Extension方法添加其他的东西,比如把它封装在一个TryCatch语句中,让调用者告诉它完成后返回什么类型,异常回调给调用者。</target>
        </trans-unit>
        <trans-unit id="13c62830d3a2b4de687637e949d6bdc107bde7fb" translate="yes" xml:space="preserve">
          <source>You need to look at the Backgroundworker example:</source>
          <target state="translated">你需要看一下背景工人的例子。</target>
        </trans-unit>
        <trans-unit id="ed47376c5cec61c82f0fb915f389554c0b9052b5" translate="yes" xml:space="preserve">
          <source>You only want to use Invoke or BeginInvoke for the bare minimum piece of work required to change the UI. Your &quot;heavy&quot; method should execute on another thread (e.g. via BackgroundWorker) but then using Control.Invoke/Control.BeginInvoke just to update the UI. That way your UI thread will be free to handle UI events etc.</source>
          <target state="translated">你只想用Invoke或BeginInvoke来完成改变UI所需的最基本的工作。你的 &quot;重 &quot;方法应该在另一个线程上执行(例如,通过BackgroundWorker),但使用Control.InvokeControl.BeginInvoke只是为了更新UI。这样,你的UI线程就可以自由地处理UI事件等。</target>
        </trans-unit>
        <trans-unit id="40308d92efc743e625f62d66941764aa9ca38d25" translate="yes" xml:space="preserve">
          <source>and second one is to use</source>
          <target state="translated">二是用</target>
        </trans-unit>
        <trans-unit id="524b958350bb765d714297d4f83c944518e97a08" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;Form1()&lt;/code&gt; constructor .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Form1()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;构造函数中。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f9b7374b4586c6e99c3bed35092c20f937f35f17" translate="yes" xml:space="preserve">
          <source>label1.Invoke(y=()=&amp;gt;label1.Text=&quot;text&quot;);</source>
          <target state="translated">label1.Invoke(y=()=&amp;gt;label1.Text=&quot;text&quot;);</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
