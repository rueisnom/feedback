<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/36628418">
    <body>
      <group id="36628418">
        <trans-unit id="8584b9fc9c78f36dbcad73668ac8face924fb95b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's see how different sanitizing methods affect the password -&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다양한 살균 방법이 암호에 어떤 영향을 미치는지 봅시다-&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="993e426272dc393d633c21e33ded7154d984ff4b" translate="yes" xml:space="preserve">
          <source>Additional Mapping Rule: Any instances of non-ASCII space MUST be
     mapped to ASCII space (U+0020); a non-ASCII space is any Unicode
     code point having a Unicode general category of &quot;Zs&quot; (with the
     exception of U+0020).</source>
          <target state="translated">추가 매핑 규칙 : 비 ASCII 공간의 인스턴스는 반드시 ASCII 공간 (U + 0020)에 매핑해야합니다. 비 ASCII 공간은 유니 코드 일반 범주 &quot;Zs&quot;(U + 0020 제외)를 갖는 모든 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="cd42ef8da1a91f2450cd1212ca3d7bfb2c94f765" translate="yes" xml:space="preserve">
          <source>Before hashing the password, you should normalise it as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7613#section-4&quot;&gt;section 4 of RFC 7613&lt;/a&gt;.  In particular:</source>
          <target state="translated">비밀번호를 해시하기 전에 &lt;a href=&quot;https://tools.ietf.org/html/rfc7613#section-4&quot;&gt;RFC 7613의 섹션 4에&lt;/a&gt; 설명 된대로 비밀번호를 정규화해야합니다. 특히:</target>
        </trans-unit>
        <trans-unit id="c4ad68993deef0064341abbbc8f7bdf52d78bf7e" translate="yes" xml:space="preserve">
          <source>Cleansing User Passwords</source>
          <target state="translated">사용자 비밀번호 정리</target>
        </trans-unit>
        <trans-unit id="4c7b83a9818b81fd2eb75d1d84d4ae0e8fa385d0" translate="yes" xml:space="preserve">
          <source>Could be hashed to &lt;code&gt;$2y$10$1tOKcWUWBW5gBka04tGMO.BH7gs/qjAHZsC5wyG0zmI2C.KgaqU5G&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$2y$10$1tOKcWUWBW5gBka04tGMO.BH7gs/qjAHZsC5wyG0zmI2C.KgaqU5G&lt;/code&gt; 로 해시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cf1c4fafb69452ffdc4cd55a0ba0cebece07899" translate="yes" xml:space="preserve">
          <source>How should I escape or cleanse user-provided passwords before I hash them and store them in my database?</source>
          <target state="translated">사용자가 제공 한 비밀번호를 해시하여 데이터베이스에 저장하기 전에 어떻게 이스케이프하거나 정리해야합니까?</target>
        </trans-unit>
        <trans-unit id="5dae5be14975f6336e3378cdf664d2fc045e34c8" translate="yes" xml:space="preserve">
          <source>If you follow the mantras of allowing users to use the &lt;a href=&quot;https://xkcd.com/936/&quot;&gt;passwords / phrases&lt;/a&gt; they desire and you &lt;a href=&quot;http://jayblanchard.net/security_fail_passwords.html&quot;&gt;don't limit passwords&lt;/a&gt;, allowing any length, any number of spaces and any special characters hashing will make the password/passphrase safe no matter what is contained within the password. As of right now the most common hash (the default), &lt;a href=&quot;http://php.net/manual/en/password.constants.php&quot;&gt;&lt;code&gt;PASSWORD_BCRYPT&lt;/code&gt;&lt;/a&gt;, turns the password into a 60 character wide string containing a random salt along with the hashed password information and a cost (the algorithmic cost of creating the hash):</source>
          <target state="translated">사용자가 원하는 &lt;a href=&quot;https://xkcd.com/936/&quot;&gt;비밀번호 / 구절&lt;/a&gt; 을 사용하도록 허용하고 비밀번호를 &lt;a href=&quot;http://jayblanchard.net/security_fail_passwords.html&quot;&gt;제한하지 않는&lt;/a&gt; 길이, 길이, 공백 및 특수 문자 해싱을 허용하는 내용에 따라 비밀번호 / 비밀번호가 포함되어있는 내용에 관계없이 비밀번호 / 비밀번호가 안전합니다. 비밀번호. 현재 가장 일반적인 해시 (기본값) 인 &lt;a href=&quot;http://php.net/manual/en/password.constants.php&quot;&gt; &lt;code&gt;PASSWORD_BCRYPT&lt;/code&gt; &lt;/a&gt; 는 비밀번호를 해시 된 비밀번호 정보 및 비용 (해시를 작성하는 알고리즘 비용)과 함께 임의의 소금이 포함 된 60 자 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="26a65262e8cd2a578fc0f4a062da77338e02bd81" translate="yes" xml:space="preserve">
          <source>Normalization Rule: Unicode Normalization Form C (NFC) MUST be
     applied to all characters.</source>
          <target state="translated">정규화 규칙 : 모든 문자에 NFC (Unicode Normalization Form C)를 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce65f23c1bb991038111916fed990ae39379a8f9" translate="yes" xml:space="preserve">
          <source>PASSWORD_BCRYPT is used to create new password hashes using the CRYPT_BLOWFISH algorithm. This will always result in a hash using the &quot;$2y$&quot; crypt format, which is always 60 characters wide.</source>
          <target state="translated">PASSWORD_BCRYPT는 CRYPT_BLOWFISH 알고리즘을 사용하여 새 비밀번호 해시를 작성하는 데 사용됩니다. 이렇게하면 항상 &quot;$ 2y $&quot;암호화 형식을 사용하는 해시가 발생하며 항상 60 자입니다.</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="63837fcad7ce457f056c83742176fbd69432d1fc" translate="yes" xml:space="preserve">
          <source>The act of hashing a password is the act of making the password safe to store in your database.  The hash function doesn't give special meaning to any bytes, so no cleansing of its input is required for security reasons</source>
          <target state="translated">비밀번호를 해시하는 행위는 비밀번호를 데이터베이스에 안전하게 저장하는 행위입니다. 해시 함수는 바이트에 특별한 의미를 부여하지 않으므로 보안상의 이유로 입력을 정리할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="feb555691dadde95b7d9a6a18fa6e85ab5daf0b7" translate="yes" xml:space="preserve">
          <source>The password is &lt;code&gt;I'm a &quot;dessert topping&quot; &amp;amp; a &amp;lt;floor wax&amp;gt;!&lt;/code&gt; (There are 5 spaces at the end of the password which are not displayed here.)</source>
          <target state="translated">암호는 &lt;code&gt;I'm a &quot;dessert topping&quot; &amp;amp; a &amp;lt;floor wax&amp;gt;!&lt;/code&gt; (암호 끝에는 5 칸이 표시되어 있지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="dbf8102cff6399c48e82f6e369e4ed7d537a12d6" translate="yes" xml:space="preserve">
          <source>The space requirements for storing the hash are subject to change as different hashing methods are added to the function, so it is always better to go larger on the column type for the stored hash, such as &lt;code&gt;VARCHAR(255)&lt;/code&gt; or &lt;code&gt;TEXT&lt;/code&gt;.</source>
          <target state="translated">해시 저장에 필요한 공간 요구 사항은 다른 해싱 방법이 함수에 추가 될 때 변경 될 수 있으므로 &lt;code&gt;VARCHAR(255)&lt;/code&gt; 또는 &lt;code&gt;TEXT&lt;/code&gt; 와 같이 저장된 해시의 열 유형을 더 크게 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2945462a303bfcb25eb372109a372bf65a9cde6d" translate="yes" xml:space="preserve">
          <source>This attempts to ensure that if the user types the same password but using a different input method, the password should still be accepted.</source>
          <target state="translated">이렇게하면 사용자가 동일한 암호를 입력했지만 다른 입력 방법을 사용하는 경우에도 암호를 그대로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e90840f680684198f73a8aa5f29b24d2d026e171" translate="yes" xml:space="preserve">
          <source>Using a PHP version less than 5.5? You can use the &lt;code&gt;password_hash()&lt;/code&gt;&lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility pack&lt;/a&gt;.</source>
          <target state="translated">5.5 미만의 PHP 버전을 사용하십니까? &lt;code&gt;password_hash()&lt;/code&gt; &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;호환 기능 팩을&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40f9bf51e55b0e770125a81675f59fe1177266be" translate="yes" xml:space="preserve">
          <source>What happens when we send these to &lt;code&gt;password_hash()&lt;/code&gt;? They all get hashed, just as the query did above. The problem comes in when you try to verify the password. If we employ one or more of these methods we must re-employ them prior to comparing them with &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;&lt;code&gt;password_verify()&lt;/code&gt;&lt;/a&gt;. The following would fail:</source>
          <target state="translated">우리가 이것을 &lt;code&gt;password_hash()&lt;/code&gt; 보내면 어떻게됩니까? 쿼리가 위에서했던 것처럼 모두 해시됩니다. 암호를 확인하려고하면 문제가 발생합니다. 이러한 메소드 중 하나 이상을 사용하는 경우 &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt; &lt;code&gt;password_verify()&lt;/code&gt; &lt;/a&gt; 와 비교하기 전에 해당 메소드를 다시 사용해야합니다. 다음은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="cf7173ef9053b8b0fcd2284d238e848860c0b112" translate="yes" xml:space="preserve">
          <source>When PHP developers consider hashing users' passwords for security purposes, they often tend to think of those passwords like they would any other user-provided data. This subject comes up often in PHP questions related to password storage; the developer often wants to cleanse the password using functions such as &lt;code&gt;escape_string()&lt;/code&gt;(in various iterations), &lt;code&gt;htmlspecialchars()&lt;/code&gt;, &lt;code&gt;addslashes()&lt;/code&gt; and others before hashing it and storing it in the database.</source>
          <target state="translated">PHP 개발자는 보안 목적으로 사용자 비밀번호 해싱을 고려할 때 종종 다른 사용자 제공 데이터와 같은 비밀번호를 생각하는 경향이 있습니다. 이 주제는 종종 암호 저장과 관련된 PHP 질문에서 나타납니다. 개발자는 종종 &lt;code&gt;escape_string()&lt;/code&gt; (다양한 반복), &lt;code&gt;htmlspecialchars()&lt;/code&gt; , &lt;code&gt;addslashes()&lt;/code&gt; 등의 함수를 사용하여 암호를 정리하여 해시하고 데이터베이스에 저장하려고합니다.</target>
        </trans-unit>
        <trans-unit id="563585def1cd6c2bc25d69e62939e8d210b0a248" translate="yes" xml:space="preserve">
          <source>When we apply the following methods of trimming we get some wildy different results:</source>
          <target state="translated">다음과 같은 트리밍 방법을 적용하면 약간 다른 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d654cef1c3ae03d4ad2b6cc790e7cec71243c5b1" translate="yes" xml:space="preserve">
          <source>You could use a complete SQL query as your password and it would be hashed, making it unexecutable by the SQL engine e.g.,</source>
          <target state="translated">완전한 SQL 쿼리를 암호로 사용할 수 있으며 해시되어 SQL 엔진에서 실행할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="b3561d5cf09d787a977934588e811a43d9c68706" translate="yes" xml:space="preserve">
          <source>You really shouldn't use &lt;a href=&quot;https://security.stackexchange.com/questions/19906/is-md5-considered-insecure&quot;&gt;MD5 password hashes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://security.stackexchange.com/questions/19906/is-md5-considered-insecure&quot;&gt;MD5 암호 해시를&lt;/a&gt; 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="de6c80d4166acf55031f3d82a36a9538fa673f08" translate="yes" xml:space="preserve">
          <source>You should never escape, trim or use any other cleansing mechanism on passwords you'll be hashing with PHP's &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;&lt;code&gt;password_hash()&lt;/code&gt;&lt;/a&gt; for a number of reasons, the single largest of which is because doing additional cleansing to the password requires unnecessary additional code.</source>
          <target state="translated">여러 가지 이유로 PHP의 &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt; &lt;code&gt;password_hash()&lt;/code&gt; &lt;/a&gt; 를 사용하여 해싱 할 비밀번호에 대해 다른 정리 메커니즘을 이스케이프 처리, 트리밍 또는 사용해서는 안됩니다. 가장 큰 이유는 비밀번호를 추가로 정리하는 데 불필요한 추가 코드가 필요하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d1a0f994fbdfb81a6dc7477fff34fdb2a5eb3c37" translate="yes" xml:space="preserve">
          <source>You will argue (and you see it in every post where user data is accepted for use in your systems) that we should cleanse all user input and you would be right for every other piece of information we're accepting from our users. Passwords are different. &lt;em&gt;Hashed passwords cannot offer any SQL injection threat because the string is turned into hash prior to storing in the database.&lt;/em&gt;</source>
          <target state="translated">모든 사용자 입력을 정리해야하며 사용자가받는 다른 모든 정보에 적합하다고 주장 할 것입니다 (시스템에서 사용자 데이터가 허용되는 모든 게시물에서 볼 수 있습니다). 비밀번호가 다릅니다. &lt;em&gt;해시 된 비밀번호는 데이터베이스에 저장하기 전에 문자열이 해시로 변환되므로 SQL 삽입 위협을 제공 할 수 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8254c491075ba65f6b2a0dcd3390a961757f4feb" translate="yes" xml:space="preserve">
          <source>You would have to run the posted password through the cleansing method you chose before using the result of that in password verification. It is an unnecessary set of steps and will make the hash no better.</source>
          <target state="translated">비밀번호 확인에 비밀번호를 사용하기 전에 선택한 정리 방법을 통해 게시 된 비밀번호를 실행해야합니다. 불필요한 단계 세트이며 해시를 개선하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
