<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/36628418">
    <body>
      <group id="36628418">
        <trans-unit id="8584b9fc9c78f36dbcad73668ac8face924fb95b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's see how different sanitizing methods affect the password -&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;让我们看看不同的清理方法如何影响密码-&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="993e426272dc393d633c21e33ded7154d984ff4b" translate="yes" xml:space="preserve">
          <source>Additional Mapping Rule: Any instances of non-ASCII space MUST be
     mapped to ASCII space (U+0020); a non-ASCII space is any Unicode
     code point having a Unicode general category of &quot;Zs&quot; (with the
     exception of U+0020).</source>
          <target state="translated">附加的映射规则。任何非ASCII空间的实例必须被映射到ASCII空间(U+0020);非ASCII空间是指任何Unicode代码点的通用类别为 &quot;Zs &quot;的Unicode代码点(U+0020除外)。</target>
        </trans-unit>
        <trans-unit id="cd42ef8da1a91f2450cd1212ca3d7bfb2c94f765" translate="yes" xml:space="preserve">
          <source>Before hashing the password, you should normalise it as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7613#section-4&quot;&gt;section 4 of RFC 7613&lt;/a&gt;.  In particular:</source>
          <target state="translated">在哈希密码之前，您应该按照&lt;a href=&quot;https://tools.ietf.org/html/rfc7613#section-4&quot;&gt;RFC 7613的第4节中的&lt;/a&gt;描述对其进行规范化。 特别是：</target>
        </trans-unit>
        <trans-unit id="c4ad68993deef0064341abbbc8f7bdf52d78bf7e" translate="yes" xml:space="preserve">
          <source>Cleansing User Passwords</source>
          <target state="translated">清理用户密码</target>
        </trans-unit>
        <trans-unit id="4c7b83a9818b81fd2eb75d1d84d4ae0e8fa385d0" translate="yes" xml:space="preserve">
          <source>Could be hashed to &lt;code&gt;$2y$10$1tOKcWUWBW5gBka04tGMO.BH7gs/qjAHZsC5wyG0zmI2C.KgaqU5G&lt;/code&gt;</source>
          <target state="translated">可以哈希为 &lt;code&gt;$2y$10$1tOKcWUWBW5gBka04tGMO.BH7gs/qjAHZsC5wyG0zmI2C.KgaqU5G&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3cf1c4fafb69452ffdc4cd55a0ba0cebece07899" translate="yes" xml:space="preserve">
          <source>How should I escape or cleanse user-provided passwords before I hash them and store them in my database?</source>
          <target state="translated">在对用户提供的密码进行散列并存储到数据库中之前,我应该如何转义或清除用户提供的密码?</target>
        </trans-unit>
        <trans-unit id="5dae5be14975f6336e3378cdf664d2fc045e34c8" translate="yes" xml:space="preserve">
          <source>If you follow the mantras of allowing users to use the &lt;a href=&quot;https://xkcd.com/936/&quot;&gt;passwords / phrases&lt;/a&gt; they desire and you &lt;a href=&quot;http://jayblanchard.net/security_fail_passwords.html&quot;&gt;don't limit passwords&lt;/a&gt;, allowing any length, any number of spaces and any special characters hashing will make the password/passphrase safe no matter what is contained within the password. As of right now the most common hash (the default), &lt;a href=&quot;http://php.net/manual/en/password.constants.php&quot;&gt;&lt;code&gt;PASSWORD_BCRYPT&lt;/code&gt;&lt;/a&gt;, turns the password into a 60 character wide string containing a random salt along with the hashed password information and a cost (the algorithmic cost of creating the hash):</source>
          <target state="translated">如果您遵循允许用户使用他们想要的&lt;a href=&quot;https://xkcd.com/936/&quot;&gt;密码/短语&lt;/a&gt;的口号，并且&lt;a href=&quot;http://jayblanchard.net/security_fail_passwords.html&quot;&gt;不限制密码&lt;/a&gt; ，允许任何长度，任意数量的空格和任何特殊字符散列，那么无论密码中包含什么内容，密码/密码都是安全的。密码。 到目前为止，最常见的哈希（默认值） &lt;a href=&quot;http://php.net/manual/en/password.constants.php&quot;&gt; &lt;code&gt;PASSWORD_BCRYPT&lt;/code&gt; &lt;/a&gt;将密码转换为60个字符的字符串，其中包含随机盐以及哈希密码信息和开销（创建哈希的算法开销）：</target>
        </trans-unit>
        <trans-unit id="26a65262e8cd2a578fc0f4a062da77338e02bd81" translate="yes" xml:space="preserve">
          <source>Normalization Rule: Unicode Normalization Form C (NFC) MUST be
     applied to all characters.</source>
          <target state="translated">归一化规则。Unicode Normalization Form C (NFC)必须应用于所有字符。</target>
        </trans-unit>
        <trans-unit id="ce65f23c1bb991038111916fed990ae39379a8f9" translate="yes" xml:space="preserve">
          <source>PASSWORD_BCRYPT is used to create new password hashes using the CRYPT_BLOWFISH algorithm. This will always result in a hash using the &quot;$2y$&quot; crypt format, which is always 60 characters wide.</source>
          <target state="translated">PASSWORD_BCRYPT用于使用CRYPT_BLOWFISH算法创建新的密码散列。这总是会产生一个使用&quot;$2y$&quot;密码格式的散列,其宽度总是60个字符。</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="63837fcad7ce457f056c83742176fbd69432d1fc" translate="yes" xml:space="preserve">
          <source>The act of hashing a password is the act of making the password safe to store in your database.  The hash function doesn't give special meaning to any bytes, so no cleansing of its input is required for security reasons</source>
          <target state="translated">密码散列的行为就是让密码安全地存储在数据库中的行为。散列函数不赋予任何字节的特殊意义,所以出于安全考虑,不需要对其输入进行清洗。</target>
        </trans-unit>
        <trans-unit id="feb555691dadde95b7d9a6a18fa6e85ab5daf0b7" translate="yes" xml:space="preserve">
          <source>The password is &lt;code&gt;I'm a &quot;dessert topping&quot; &amp;amp; a &amp;lt;floor wax&amp;gt;!&lt;/code&gt; (There are 5 spaces at the end of the password which are not displayed here.)</source>
          <target state="translated">密码是 &lt;code&gt;I'm a &quot;dessert topping&quot; &amp;amp; a &amp;lt;floor wax&amp;gt;!&lt;/code&gt; （密码末尾有5个空格，此处未显示。）</target>
        </trans-unit>
        <trans-unit id="dbf8102cff6399c48e82f6e369e4ed7d537a12d6" translate="yes" xml:space="preserve">
          <source>The space requirements for storing the hash are subject to change as different hashing methods are added to the function, so it is always better to go larger on the column type for the stored hash, such as &lt;code&gt;VARCHAR(255)&lt;/code&gt; or &lt;code&gt;TEXT&lt;/code&gt;.</source>
          <target state="translated">由于向函数添加了不同的哈希方法，因此存储哈希值的空间要求可能会发生变化，因此，最好为存储的哈希值增加列类型，例如 &lt;code&gt;VARCHAR(255)&lt;/code&gt; 或 &lt;code&gt;TEXT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2945462a303bfcb25eb372109a372bf65a9cde6d" translate="yes" xml:space="preserve">
          <source>This attempts to ensure that if the user types the same password but using a different input method, the password should still be accepted.</source>
          <target state="translated">这样做是为了确保如果用户输入相同的密码,但使用不同的输入法,密码仍应被接受。</target>
        </trans-unit>
        <trans-unit id="e90840f680684198f73a8aa5f29b24d2d026e171" translate="yes" xml:space="preserve">
          <source>Using a PHP version less than 5.5? You can use the &lt;code&gt;password_hash()&lt;/code&gt;&lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility pack&lt;/a&gt;.</source>
          <target state="translated">使用的PHP版本低于5.5？ 您可以使用 &lt;code&gt;password_hash()&lt;/code&gt; &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;兼容性包&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="40f9bf51e55b0e770125a81675f59fe1177266be" translate="yes" xml:space="preserve">
          <source>What happens when we send these to &lt;code&gt;password_hash()&lt;/code&gt;? They all get hashed, just as the query did above. The problem comes in when you try to verify the password. If we employ one or more of these methods we must re-employ them prior to comparing them with &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;&lt;code&gt;password_verify()&lt;/code&gt;&lt;/a&gt;. The following would fail:</source>
          <target state="translated">将它们发送到 &lt;code&gt;password_hash()&lt;/code&gt; 会发生什么？ 就像上面的查询一样，它们都被散列了。 当您尝试验证密码时出现问题。 如果我们采用这些方法中的一种或多种，​​则必须先重新使用它们，然后再将它们与&lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt; &lt;code&gt;password_verify()&lt;/code&gt; &lt;/a&gt;进行比较。 以下内容将失败：</target>
        </trans-unit>
        <trans-unit id="cf7173ef9053b8b0fcd2284d238e848860c0b112" translate="yes" xml:space="preserve">
          <source>When PHP developers consider hashing users' passwords for security purposes, they often tend to think of those passwords like they would any other user-provided data. This subject comes up often in PHP questions related to password storage; the developer often wants to cleanse the password using functions such as &lt;code&gt;escape_string()&lt;/code&gt;(in various iterations), &lt;code&gt;htmlspecialchars()&lt;/code&gt;, &lt;code&gt;addslashes()&lt;/code&gt; and others before hashing it and storing it in the database.</source>
          <target state="translated">当PHP开发人员出于安全目的考虑对用户密码进行哈希处理时，他们通常会像对待其他任何用户提供的数据一样考虑这些密码。 这个主题经常出现在与密码存储有关的PHP问题中。 开发人员通常希望在对哈希进行哈希处理并将其存储在数据库之前，使用诸如 &lt;code&gt;escape_string()&lt;/code&gt; （在各种迭代中）， &lt;code&gt;htmlspecialchars()&lt;/code&gt; ， &lt;code&gt;addslashes()&lt;/code&gt; 等函数清除密码。</target>
        </trans-unit>
        <trans-unit id="563585def1cd6c2bc25d69e62939e8d210b0a248" translate="yes" xml:space="preserve">
          <source>When we apply the following methods of trimming we get some wildy different results:</source>
          <target state="translated">当我们应用以下的修剪方法时,会得到一些不同的效果。</target>
        </trans-unit>
        <trans-unit id="d654cef1c3ae03d4ad2b6cc790e7cec71243c5b1" translate="yes" xml:space="preserve">
          <source>You could use a complete SQL query as your password and it would be hashed, making it unexecutable by the SQL engine e.g.,</source>
          <target state="translated">你可以使用一个完整的SQL查询作为你的密码,它将被散列,使其无法被SQL引擎执行,例如:。</target>
        </trans-unit>
        <trans-unit id="b3561d5cf09d787a977934588e811a43d9c68706" translate="yes" xml:space="preserve">
          <source>You really shouldn't use &lt;a href=&quot;https://security.stackexchange.com/questions/19906/is-md5-considered-insecure&quot;&gt;MD5 password hashes&lt;/a&gt;.</source>
          <target state="translated">您真的不应该使用&lt;a href=&quot;https://security.stackexchange.com/questions/19906/is-md5-considered-insecure&quot;&gt;MD5密码哈希&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="de6c80d4166acf55031f3d82a36a9538fa673f08" translate="yes" xml:space="preserve">
          <source>You should never escape, trim or use any other cleansing mechanism on passwords you'll be hashing with PHP's &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;&lt;code&gt;password_hash()&lt;/code&gt;&lt;/a&gt; for a number of reasons, the single largest of which is because doing additional cleansing to the password requires unnecessary additional code.</source>
          <target state="translated">出于多种原因，您绝不能对将要用PHP的&lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt; &lt;code&gt;password_hash()&lt;/code&gt; &lt;/a&gt;进行哈希处理的密码进行转义，修剪或使用任何其他清除机制，其中最大的一个原因是，对密码进行额外的清除需要不必要的额外代码。</target>
        </trans-unit>
        <trans-unit id="d1a0f994fbdfb81a6dc7477fff34fdb2a5eb3c37" translate="yes" xml:space="preserve">
          <source>You will argue (and you see it in every post where user data is accepted for use in your systems) that we should cleanse all user input and you would be right for every other piece of information we're accepting from our users. Passwords are different. &lt;em&gt;Hashed passwords cannot offer any SQL injection threat because the string is turned into hash prior to storing in the database.&lt;/em&gt;</source>
          <target state="translated">您会争论不休（并且您会在接受系统使用用户数据的每篇文章中看到它），我们应该清除所有用户输入，并且您将接受我们从用户那里接受的所有其他信息。 密码不同。 &lt;em&gt;哈希密码无法提供任何SQL注入威胁，因为在将字符串存储到数据库之前将其转换为哈希。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8254c491075ba65f6b2a0dcd3390a961757f4feb" translate="yes" xml:space="preserve">
          <source>You would have to run the posted password through the cleansing method you chose before using the result of that in password verification. It is an unnecessary set of steps and will make the hash no better.</source>
          <target state="translated">你必须通过你选择的清洗方法来运行已发布的密码,然后再将其结果用于密码验证。这是一组不必要的步骤,而且会使散列没有更好的效果。</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
