<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/36628418">
    <body>
      <group id="36628418">
        <trans-unit id="8584b9fc9c78f36dbcad73668ac8face924fb95b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's see how different sanitizing methods affect the password -&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Давайте посмотрим, как различные методы очистки влияют на пароль -&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="993e426272dc393d633c21e33ded7154d984ff4b" translate="yes" xml:space="preserve">
          <source>Additional Mapping Rule: Any instances of non-ASCII space MUST be
     mapped to ASCII space (U+0020); a non-ASCII space is any Unicode
     code point having a Unicode general category of &quot;Zs&quot; (with the
     exception of U+0020).</source>
          <target state="translated">Дополнительное правило картирования:Любые случаи не-ASCII пространства ДОЛЖНЫ быть отображены на ASCII пространство (U+0020);не-ASCII пространство-это любая точка кода Юникода,имеющая общую категорию &quot;Zs&quot; Юникода (за исключением U+0020).</target>
        </trans-unit>
        <trans-unit id="cd42ef8da1a91f2450cd1212ca3d7bfb2c94f765" translate="yes" xml:space="preserve">
          <source>Before hashing the password, you should normalise it as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7613#section-4&quot;&gt;section 4 of RFC 7613&lt;/a&gt;.  In particular:</source>
          <target state="translated">Перед хэшированием пароля его следует нормализовать, как описано в &lt;a href=&quot;https://tools.ietf.org/html/rfc7613#section-4&quot;&gt;разделе 4 RFC 7613&lt;/a&gt; . Особенно:</target>
        </trans-unit>
        <trans-unit id="c4ad68993deef0064341abbbc8f7bdf52d78bf7e" translate="yes" xml:space="preserve">
          <source>Cleansing User Passwords</source>
          <target state="translated">Очищение паролей пользователей</target>
        </trans-unit>
        <trans-unit id="4c7b83a9818b81fd2eb75d1d84d4ae0e8fa385d0" translate="yes" xml:space="preserve">
          <source>Could be hashed to &lt;code&gt;$2y$10$1tOKcWUWBW5gBka04tGMO.BH7gs/qjAHZsC5wyG0zmI2C.KgaqU5G&lt;/code&gt;</source>
          <target state="translated">Может быть хэшировано до &lt;code&gt;$2y$10$1tOKcWUWBW5gBka04tGMO.BH7gs/qjAHZsC5wyG0zmI2C.KgaqU5G&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3cf1c4fafb69452ffdc4cd55a0ba0cebece07899" translate="yes" xml:space="preserve">
          <source>How should I escape or cleanse user-provided passwords before I hash them and store them in my database?</source>
          <target state="translated">Как мне удалить или очистить предоставленные пользователем пароли до того,как я их хэширую и храню в своей базе данных?</target>
        </trans-unit>
        <trans-unit id="5dae5be14975f6336e3378cdf664d2fc045e34c8" translate="yes" xml:space="preserve">
          <source>If you follow the mantras of allowing users to use the &lt;a href=&quot;https://xkcd.com/936/&quot;&gt;passwords / phrases&lt;/a&gt; they desire and you &lt;a href=&quot;http://jayblanchard.net/security_fail_passwords.html&quot;&gt;don't limit passwords&lt;/a&gt;, allowing any length, any number of spaces and any special characters hashing will make the password/passphrase safe no matter what is contained within the password. As of right now the most common hash (the default), &lt;a href=&quot;http://php.net/manual/en/password.constants.php&quot;&gt;&lt;code&gt;PASSWORD_BCRYPT&lt;/code&gt;&lt;/a&gt;, turns the password into a 60 character wide string containing a random salt along with the hashed password information and a cost (the algorithmic cost of creating the hash):</source>
          <target state="translated">Если вы следуете мантрам, позволяющим пользователям использовать &lt;a href=&quot;https://xkcd.com/936/&quot;&gt;пароли / фразы, которые&lt;/a&gt; они хотят, и вы &lt;a href=&quot;http://jayblanchard.net/security_fail_passwords.html&quot;&gt;не ограничиваете пароли&lt;/a&gt; , разрешая любую длину, любое количество пробелов и хеширование любых специальных символов, то пароль / пароль будет безопасным независимо от того, что содержится в нем. пароль. На данный момент самый распространенный хэш (по умолчанию), &lt;a href=&quot;http://php.net/manual/en/password.constants.php&quot;&gt; &lt;code&gt;PASSWORD_BCRYPT&lt;/code&gt; &lt;/a&gt; , превращает пароль в строку шириной 60 символов, содержащую случайную соль, информацию о хэшированном пароле и стоимость (алгоритмическую стоимость создания хэша):</target>
        </trans-unit>
        <trans-unit id="26a65262e8cd2a578fc0f4a062da77338e02bd81" translate="yes" xml:space="preserve">
          <source>Normalization Rule: Unicode Normalization Form C (NFC) MUST be
     applied to all characters.</source>
          <target state="translated">Правило нормализации:Юникод Форма Нормализации C (NFC)ДОЛЖНА применяться ко всем символам.</target>
        </trans-unit>
        <trans-unit id="ce65f23c1bb991038111916fed990ae39379a8f9" translate="yes" xml:space="preserve">
          <source>PASSWORD_BCRYPT is used to create new password hashes using the CRYPT_BLOWFISH algorithm. This will always result in a hash using the &quot;$2y$&quot; crypt format, which is always 60 characters wide.</source>
          <target state="translated">PASSWORD_BCRYPT используется для создания новых хэшей паролей с использованием алгоритма CRYPT_BLOWFISH.В результате всегда будет получаться хэш с использованием криптографического формата &quot;$2y$&quot;,который всегда имеет ширину 60 символов.</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="63837fcad7ce457f056c83742176fbd69432d1fc" translate="yes" xml:space="preserve">
          <source>The act of hashing a password is the act of making the password safe to store in your database.  The hash function doesn't give special meaning to any bytes, so no cleansing of its input is required for security reasons</source>
          <target state="translated">Акт хэширования пароля-это акт безопасного хранения пароля в вашей базе данных.Хэш-функция не придает особого значения никаким байтам,поэтому по соображениям безопасности не требуется очистка ее ввода</target>
        </trans-unit>
        <trans-unit id="feb555691dadde95b7d9a6a18fa6e85ab5daf0b7" translate="yes" xml:space="preserve">
          <source>The password is &lt;code&gt;I'm a &quot;dessert topping&quot; &amp;amp; a &amp;lt;floor wax&amp;gt;!&lt;/code&gt; (There are 5 spaces at the end of the password which are not displayed here.)</source>
          <target state="translated">Пароль - &lt;code&gt;I'm a &quot;dessert topping&quot; &amp;amp; a &amp;lt;floor wax&amp;gt;!&lt;/code&gt; (В конце пароля есть 5 пробелов, которые здесь не отображаются.)</target>
        </trans-unit>
        <trans-unit id="dbf8102cff6399c48e82f6e369e4ed7d537a12d6" translate="yes" xml:space="preserve">
          <source>The space requirements for storing the hash are subject to change as different hashing methods are added to the function, so it is always better to go larger on the column type for the stored hash, such as &lt;code&gt;VARCHAR(255)&lt;/code&gt; or &lt;code&gt;TEXT&lt;/code&gt;.</source>
          <target state="translated">Требования к пространству для хранения хеша могут изменяться по мере добавления в функцию различных методов хеширования, поэтому всегда лучше увеличить размер столбца для хранимого хеша, например &lt;code&gt;VARCHAR(255)&lt;/code&gt; или &lt;code&gt;TEXT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2945462a303bfcb25eb372109a372bf65a9cde6d" translate="yes" xml:space="preserve">
          <source>This attempts to ensure that if the user types the same password but using a different input method, the password should still be accepted.</source>
          <target state="translated">При этом делается попытка убедиться,что если пользователь вводит один и тот же пароль,но использует другой метод ввода,то пароль все равно должен быть принят.</target>
        </trans-unit>
        <trans-unit id="e90840f680684198f73a8aa5f29b24d2d026e171" translate="yes" xml:space="preserve">
          <source>Using a PHP version less than 5.5? You can use the &lt;code&gt;password_hash()&lt;/code&gt;&lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;compatibility pack&lt;/a&gt;.</source>
          <target state="translated">Используете версию PHP меньше чем 5.5? Вы можете использовать &lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;пакет совместимости&lt;/a&gt; &lt;code&gt;password_hash()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40f9bf51e55b0e770125a81675f59fe1177266be" translate="yes" xml:space="preserve">
          <source>What happens when we send these to &lt;code&gt;password_hash()&lt;/code&gt;? They all get hashed, just as the query did above. The problem comes in when you try to verify the password. If we employ one or more of these methods we must re-employ them prior to comparing them with &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt;&lt;code&gt;password_verify()&lt;/code&gt;&lt;/a&gt;. The following would fail:</source>
          <target state="translated">Что происходит, когда мы отправляем их в &lt;code&gt;password_hash()&lt;/code&gt; ? Все они хешируются, как и запрос выше. Проблема возникает, когда вы пытаетесь подтвердить пароль. Если мы используем один или несколько из этих методов, мы должны повторно использовать их, прежде чем сравнивать их с &lt;a href=&quot;http://php.net/manual/en/function.password-verify.php&quot;&gt; &lt;code&gt;password_verify()&lt;/code&gt; &lt;/a&gt; . Следующее не получится:</target>
        </trans-unit>
        <trans-unit id="cf7173ef9053b8b0fcd2284d238e848860c0b112" translate="yes" xml:space="preserve">
          <source>When PHP developers consider hashing users' passwords for security purposes, they often tend to think of those passwords like they would any other user-provided data. This subject comes up often in PHP questions related to password storage; the developer often wants to cleanse the password using functions such as &lt;code&gt;escape_string()&lt;/code&gt;(in various iterations), &lt;code&gt;htmlspecialchars()&lt;/code&gt;, &lt;code&gt;addslashes()&lt;/code&gt; and others before hashing it and storing it in the database.</source>
          <target state="translated">Когда разработчики PHP рассматривают хеширование паролей пользователей в целях безопасности, они часто склонны думать о тех паролях, как о любых других пользовательских данных. Эта тема часто возникает в вопросах PHP, связанных с хранением пароля; Разработчик часто хочет очистить пароль, используя такие функции, как &lt;code&gt;escape_string()&lt;/code&gt; (в различных итерациях), &lt;code&gt;htmlspecialchars()&lt;/code&gt; , &lt;code&gt;addslashes()&lt;/code&gt; и другие, прежде чем хешировать его и хранить в базе данных.</target>
        </trans-unit>
        <trans-unit id="563585def1cd6c2bc25d69e62939e8d210b0a248" translate="yes" xml:space="preserve">
          <source>When we apply the following methods of trimming we get some wildy different results:</source>
          <target state="translated">Когда мы применяем следующие методы обрезки,мы получаем несколько диких различных результатов:</target>
        </trans-unit>
        <trans-unit id="d654cef1c3ae03d4ad2b6cc790e7cec71243c5b1" translate="yes" xml:space="preserve">
          <source>You could use a complete SQL query as your password and it would be hashed, making it unexecutable by the SQL engine e.g.,</source>
          <target state="translated">В качестве пароля можно использовать полный SQL-запрос,который будет хэшироваться,что сделает его невыполнимым,например,с помощью SQL-движка,</target>
        </trans-unit>
        <trans-unit id="b3561d5cf09d787a977934588e811a43d9c68706" translate="yes" xml:space="preserve">
          <source>You really shouldn't use &lt;a href=&quot;https://security.stackexchange.com/questions/19906/is-md5-considered-insecure&quot;&gt;MD5 password hashes&lt;/a&gt;.</source>
          <target state="translated">Вы действительно не должны использовать &lt;a href=&quot;https://security.stackexchange.com/questions/19906/is-md5-considered-insecure&quot;&gt;хеши паролей MD5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de6c80d4166acf55031f3d82a36a9538fa673f08" translate="yes" xml:space="preserve">
          <source>You should never escape, trim or use any other cleansing mechanism on passwords you'll be hashing with PHP's &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt;&lt;code&gt;password_hash()&lt;/code&gt;&lt;/a&gt; for a number of reasons, the single largest of which is because doing additional cleansing to the password requires unnecessary additional code.</source>
          <target state="translated">Вы никогда не должны избегать, обрезать или использовать любой другой механизм очистки паролей, которые вы хэшируете с PHP &lt;a href=&quot;http://php.net/manual/en/function.password-hash.php&quot;&gt; &lt;code&gt;password_hash()&lt;/code&gt; &lt;/a&gt; по ряду причин, самая большая из которых заключается в том, что дополнительная очистка пароля требует ненужного дополнительного кода.</target>
        </trans-unit>
        <trans-unit id="d1a0f994fbdfb81a6dc7477fff34fdb2a5eb3c37" translate="yes" xml:space="preserve">
          <source>You will argue (and you see it in every post where user data is accepted for use in your systems) that we should cleanse all user input and you would be right for every other piece of information we're accepting from our users. Passwords are different. &lt;em&gt;Hashed passwords cannot offer any SQL injection threat because the string is turned into hash prior to storing in the database.&lt;/em&gt;</source>
          <target state="translated">Вы будете утверждать (и вы увидите это в каждом посте, где пользовательские данные принимаются для использования в ваших системах), что мы должны очистить весь пользовательский ввод, и вы будете правы в отношении любой другой части информации, которую мы принимаем от наших пользователей. Пароли разные. &lt;em&gt;Хешированные пароли не могут представлять угрозу для SQL-инъекций, поскольку строка преобразуется в хеш-код перед сохранением в базе данных.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8254c491075ba65f6b2a0dcd3390a961757f4feb" translate="yes" xml:space="preserve">
          <source>You would have to run the posted password through the cleansing method you chose before using the result of that in password verification. It is an unnecessary set of steps and will make the hash no better.</source>
          <target state="translated">Прежде чем использовать результат проверки пароля,вы должны будете запустить опубликованный пароль методом очистки,который вы выбрали.Это ненужный набор шагов и сделает хэш не лучше.</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
