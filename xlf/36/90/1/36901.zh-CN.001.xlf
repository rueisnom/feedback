<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/36901">
    <body>
      <group id="36901">
        <trans-unit id="c4923479209994d522d1740b7cd3097f3afa7e4b" translate="yes" xml:space="preserve">
          <source>'*' operator unpacks data structure such as a list or tuple  into arguments needed by function definition.</source>
          <target state="translated">'*'操作符将数据结构(如列表或元组)解压成函数定义所需的参数。</target>
        </trans-unit>
        <trans-unit id="74a58a15f76f4145555ab65613e710dee0aaca7d" translate="yes" xml:space="preserve">
          <source>'**' operator unpacks a dictionary into arguments needed by function definition.</source>
          <target state="translated">'**' 操作符将字典解压成函数定义所需的参数。</target>
        </trans-unit>
        <trans-unit id="f6b359d1865f19eb9d426f416d514730a67eccfc" translate="yes" xml:space="preserve">
          <source>(Thanks to mgilson for the PEP link.)</source>
          <target state="translated">(感谢mgilson提供的PEP链接)</target>
        </trans-unit>
        <trans-unit id="1b2bdd544173f0325e186a3d408936d76a7cd87a" translate="yes" xml:space="preserve">
          <source>* can also unpack a &lt;strong&gt;generator&lt;/strong&gt;</source>
          <target state="translated">*也可以打开&lt;strong&gt;发电机&lt;/strong&gt;包装</target>
        </trans-unit>
        <trans-unit id="02de2d002252b3da90ad05f886293cf0484ac3b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**&lt;/code&gt; is exclusively reserved for dictionaries.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 专为字典保留。</target>
        </trans-unit>
        <trans-unit id="2cf326c516844f4113fcb75fd6abb41f6827695c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**&lt;/code&gt; means receive variable arguments as dictionary</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 表示将可变参数作为字典接收</target>
        </trans-unit>
        <trans-unit id="ea91a0e8fbc5ce9fc1d1887ac061d90237e80a67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**kwargs&lt;/code&gt; allows for any number of optional keyword arguments (parameters), which will be in a dict named &lt;code&gt;kwargs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;**kwargs&lt;/code&gt; 允许任意数量的可选关键字参数（参数），这些参数将在名为 &lt;code&gt;kwargs&lt;/code&gt; 的字典中。</target>
        </trans-unit>
        <trans-unit id="d80585a56779acc5b0ad3eb5b9e73d9ef7e74bfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**kwargs&lt;/code&gt; allows you to pass keyworded variable length of arguments to a function. You should use &lt;code&gt;**kwargs&lt;/code&gt; if you want to handle named arguments in a function.</source>
          <target state="translated">&lt;code&gt;**kwargs&lt;/code&gt; 允许您将关键字的可变参数长度传递给函数。 如果要处理函数中的命名参数，则应使用 &lt;code&gt;**kwargs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc450e8410bb5b81c3faf57ca5dfbdb36fe0c4d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; have special usage in the function argument list. &lt;code&gt;*&lt;/code&gt;
implies that the argument is a list and &lt;code&gt;**&lt;/code&gt; implies that the argument
is a dictionary. This allows functions to take arbitrary number of
arguments</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;**&lt;/code&gt; 在函数参数列表中有特殊用法。 &lt;code&gt;*&lt;/code&gt; 表示参数是列表， &lt;code&gt;**&lt;/code&gt; 表示参数是字典。 这允许函数接受任意数量的参数</target>
        </trans-unit>
        <trans-unit id="646e6f68fc6fc0f172910b7ae53e333ccdbdf675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; means receive variable arguments as tuple</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 表示将可变参数作为元组接收</target>
        </trans-unit>
        <trans-unit id="d4541b9e96a6ad3672a7c02ad538b463d7bbae10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt; (typically said &quot;star-args&quot;) and &lt;code&gt;**kwargs&lt;/code&gt; (stars can be implied by saying &quot;kwargs&quot;, but be explicit with &quot;double-star kwargs&quot;) are common idioms of Python for using the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; notation. These specific variable names aren't required (e.g. you could use &lt;code&gt;*foos&lt;/code&gt; and &lt;code&gt;**bars&lt;/code&gt;), but a departure from convention is likely to enrage your fellow Python coders.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; （通常称为&amp;ldquo; star-args&amp;rdquo;）和 &lt;code&gt;**kwargs&lt;/code&gt; （可以通过说&amp;ldquo; kwargs&amp;rdquo;来暗示星号，但对于&amp;ldquo; double-star kwargs&amp;rdquo;可以明确表示）是使用 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;**&lt;/code&gt; 表示法的Python的常见用法。 。 这些特定的变量名不是必需的（例如，您可以使用 &lt;code&gt;*foos&lt;/code&gt; 和 &lt;code&gt;**bars&lt;/code&gt; ），但是背离约定可能会激怒您的Python编码人员。</target>
        </trans-unit>
        <trans-unit id="000a612bbb899711b6d999e67117df15d720c4f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt; allows for any number of optional positional arguments (parameters), which will be assigned to a tuple named &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 允许任意数量的可选位置参数（参数），这些参数将分配给名为 &lt;code&gt;args&lt;/code&gt; 的元组。</target>
        </trans-unit>
        <trans-unit id="a21e58e874efd5d5471e19924132aa39fd60ecd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt;: allow you to pass a variable number of arguments to a function.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 和 &lt;code&gt;**kwargs&lt;/code&gt; ：允许您将可变数量的参数传递给函数。</target>
        </trans-unit>
        <trans-unit id="c11b9a4bbc515b4b84ebc72faf0f618df2cf435e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt;: is used to send a non-keyworded variable length argument list to the function:</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; ：用于将非关键字的可变长度参数列表发送给函数：</target>
        </trans-unit>
        <trans-unit id="cd293480f3802120e494ecb797df550cbc0da842" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bar(100)&lt;/code&gt; prints:</source>
          <target state="translated">&lt;code&gt;bar(100)&lt;/code&gt; 打印：</target>
        </trans-unit>
        <trans-unit id="2b19bee1d5c998645875739dbaa2f77f25bdfd4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;def bar(param1, **param2):&lt;/code&gt; is a method can accept arbitrary number of values with keys for &lt;code&gt;*param2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;def bar(param1, **param2):&lt;/code&gt; 是一种方法，可以使用 &lt;code&gt;*param2&lt;/code&gt; 的键接受任意数量的值</target>
        </trans-unit>
        <trans-unit id="fa9db175acae07bc148fd8a18e1d86066bfbe76a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;def foo(param1, *param2):&lt;/code&gt; is a method can accept arbitrary number of values for &lt;code&gt;*param2&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;def foo(param1, *param2):&lt;/code&gt; 是一种可以接受任意数量的 &lt;code&gt;*param2&lt;/code&gt; 值的方法，</target>
        </trans-unit>
        <trans-unit id="d457e800acd00734cfb232f7d555b2be33e3a422" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;param1&lt;/code&gt; is a simple parameter.</source>
          <target state="translated">&lt;code&gt;param1&lt;/code&gt; 是一个简单的参数。</target>
        </trans-unit>
        <trans-unit id="b83429dc7d3f741551503d2152003ebd8a2a0d36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) single *&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）单*&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbc1a1b748546fc5fee7f5a2eb2a422aaa998044" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Now &lt;code&gt;**&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）现在 &lt;code&gt;**&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad4ca10d4f8dfe916ff3af0ee489a423135bb817" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BONUS:&lt;/strong&gt; From python 3.8 onward, one can use &lt;code&gt;/&lt;/code&gt; in function definition to enforce  positional only parameters. In the following example, parameters a and b are &lt;strong&gt;positional-only&lt;/strong&gt;, while c or d can be positional or keyword, and e or f are required to be keywords:</source>
          <target state="translated">&lt;strong&gt;奖励：&lt;/strong&gt;从python 3.8开始，可以使用 &lt;code&gt;/&lt;/code&gt; in函数定义来强制仅位置参数。 在下面的示例中，参数a和b是&lt;strong&gt;仅位置信息&lt;/strong&gt; ，而c或d可以是位置信息或关键字，而e或f必须是关键字：</target>
        </trans-unit>
        <trans-unit id="e5c53baf9a2776f02becbdc77ff91727f9331686" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9982a3d97a9090ed22f6a37e2cf0f2ae71f563db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b72348d158a4f2c8789aa3aca14e843c932286c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3: practical usage in decorators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;示例3：装饰器中的实际用法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="610c569442d4ee811a21008a245c9213c6a6ed47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To accept any number of keyword arguments using &lt;code&gt;**kwargs&lt;/code&gt;:&lt;/strong&gt;&lt;code&gt;def foo(**kwargs): pass&lt;/code&gt;, here 'foo' accepts any number of keyword arguments, i. e., the following calls are valid &lt;code&gt;foo(name='Tom')&lt;/code&gt;, &lt;code&gt;foo(name='Tom', age=33)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;要使用 &lt;code&gt;**kwargs&lt;/code&gt; 接受任意数量的关键字参数：&lt;/strong&gt; &lt;code&gt;def foo(**kwargs): pass&lt;/code&gt; ，此处的'foo'接受任意数量的关键字参数，即，以下调用是有效的 &lt;code&gt;foo(name='Tom')&lt;/code&gt; ， &lt;code&gt;foo(name='Tom', age=33)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b288f38f2636ab753bb7bef6bd186943d14ecacc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To accept any number of positional and keyword arguments using &lt;code&gt;*args, **kwargs&lt;/code&gt;:&lt;/strong&gt;&lt;code&gt;def foo(*args, **kwargs): pass&lt;/code&gt;, here &lt;code&gt;foo&lt;/code&gt; accepts any number of positional and keyword arguments, i. e., the following calls are valid &lt;code&gt;foo(1,name='Tom')&lt;/code&gt;, &lt;code&gt;foo(1, 'bar', name='Tom', age=33)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;要使用 &lt;code&gt;*args, **kwargs&lt;/code&gt; 接受任意数量的位置和关键字参数：&lt;/strong&gt; &lt;code&gt;def foo(*args, **kwargs): pass&lt;/code&gt; ，此处 &lt;code&gt;foo&lt;/code&gt; 接受任意数量的位置和关键字参数，即，以下调用是有效的 &lt;code&gt;foo(1,name='Tom')&lt;/code&gt; ， &lt;code&gt;foo(1, 'bar', name='Tom', age=33)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdbf64b072553f800b4d1528b6368138ca2c56ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To accept any number of positional arguments using &lt;code&gt;*args&lt;/code&gt;:&lt;/strong&gt;&lt;code&gt;def foo(*args): pass&lt;/code&gt;, here &lt;code&gt;foo&lt;/code&gt; accepts any number of positional arguments, i. e., the following calls are valid &lt;code&gt;foo(1)&lt;/code&gt;, &lt;code&gt;foo(1, 'bar')&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;要使用 &lt;code&gt;*args&lt;/code&gt; 接受任意数量的位置参数：&lt;/strong&gt; &lt;code&gt;def foo(*args): pass&lt;/code&gt; ，此处 &lt;code&gt;foo&lt;/code&gt; 接受任意数量的位置参数，即，以下调用是有效的 &lt;code&gt;foo(1)&lt;/code&gt; ， &lt;code&gt;foo(1, 'bar')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d249b30f21813b362e014d115b40c5bf792a281e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To enforce keyword only arguments using &lt;code&gt;*&lt;/code&gt;:&lt;/strong&gt;&lt;code&gt;def foo(pos1, pos2, *, kwarg1): pass&lt;/code&gt;, here &lt;code&gt;*&lt;/code&gt; means that foo only accept keyword arguments after pos2, hence &lt;code&gt;foo(1, 2, 3)&lt;/code&gt; raises TypeError but &lt;code&gt;foo(1, 2, kwarg1=3)&lt;/code&gt; is ok.</source>
          <target state="translated">&lt;strong&gt;要使用 &lt;code&gt;*&lt;/code&gt; 强制执行仅关键字参数&lt;/strong&gt; &lt;code&gt;def foo(pos1, pos2, *, kwarg1): pass&lt;/code&gt; &lt;code&gt;foo(1, 2, kwarg1=3)&lt;/code&gt; 可以。</target>
        </trans-unit>
        <trans-unit id="8b0981f8cf0aa7145101e76ca36408f9c0a5506c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To express no further interest in more keyword arguments using &lt;code&gt;\**_&lt;/code&gt; (Note: this is a convention only):&lt;/strong&gt;&lt;code&gt;def foo(bar, baz, **_): pass&lt;/code&gt; means (by convention) &lt;code&gt;foo&lt;/code&gt; only uses &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; arguments in its working and will ignore others.</source>
          <target state="translated">&lt;strong&gt;要使用 &lt;code&gt;\**_&lt;/code&gt; 表示对更多关键字参数不再感兴趣（请注意：这仅是一种约定）：&lt;/strong&gt; &lt;code&gt;def foo(bar, baz, **_): pass&lt;/code&gt; 表示（按照约定） &lt;code&gt;foo&lt;/code&gt; 仅在以下情况下使用 &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 参数它的工作，将忽略其他人。</target>
        </trans-unit>
        <trans-unit id="7ab830ff0e82e8ba04ae92cec214286e4c980ac6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To express no further interest in more positional arguments using &lt;code&gt;*_&lt;/code&gt; (Note: this is a convention only):&lt;/strong&gt;&lt;code&gt;def foo(bar, baz, *_): pass&lt;/code&gt; means (by convention) &lt;code&gt;foo&lt;/code&gt; only uses &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; arguments in its working and will ignore others.</source>
          <target state="translated">&lt;strong&gt;要使用 &lt;code&gt;*_&lt;/code&gt; 表示对更多位置参数没有进一步的兴趣（请注意：这仅是一种约定）：&lt;/strong&gt; &lt;code&gt;def foo(bar, baz, *_): pass&lt;/code&gt; 表示（按照约定） &lt;code&gt;foo&lt;/code&gt; 在其工作和操作中仅使用 &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 参数会忽略别人。</target>
        </trans-unit>
        <trans-unit id="5e4d39811d8cee940c5d59a19b14f749dcb48295" translate="yes" xml:space="preserve">
          <source>A good example of using both in a function is:</source>
          <target state="translated">一个很好的例子是在一个函数中使用这两个函数。</target>
        </trans-unit>
        <trans-unit id="a298513579e35207d98c0815b66416f3f97b4698" translate="yes" xml:space="preserve">
          <source>A subclass can then be</source>
          <target state="translated">然后一个子类可以是</target>
        </trans-unit>
        <trans-unit id="62bf8fc9bc68216425b83b033a2d2bd97805418e" translate="yes" xml:space="preserve">
          <source>Again, more simply, here we require &lt;code&gt;kwarg&lt;/code&gt; to be given by name, not positionally:</source>
          <target state="translated">再次，更简单地说，在这里我们要求 &lt;code&gt;kwarg&lt;/code&gt; 必须使用名称而不是位置：</target>
        </trans-unit>
        <trans-unit id="809e68b98d39b103a32103257a2b244cf31ca467" translate="yes" xml:space="preserve">
          <source>Also Python 3 adds new semantic (refer &lt;a href=&quot;https://www.python.org/dev/peps/pep-3102/&quot;&gt;PEP 3102&lt;/a&gt;):</source>
          <target state="translated">Python 3还添加了新的语义（请参阅&lt;a href=&quot;https://www.python.org/dev/peps/pep-3102/&quot;&gt;PEP 3102&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="4c8e088035f2b1475516b7fc43ddabb9edcbe3ba" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;*&lt;/code&gt; can be used by itself  to indicate that keyword only arguments follow, without allowing for unlimited positional arguments.</source>
          <target state="translated">此外， &lt;code&gt;*&lt;/code&gt; 可以单独使用*表示仅紧随关键字的参数，而不允许无限的位置自变量。</target>
        </trans-unit>
        <trans-unit id="6a6f5c8171b3aff6eb567735beb28045eb8b3581" translate="yes" xml:space="preserve">
          <source>Also, a subclass with a new attribute which makes sense only to that subclass instance can call the Base class &lt;code&gt;__init__&lt;/code&gt; to offload the attributes setting.
This is done through *args and **kwargs. kwargs mainly used so that code is readable using named arguments. For example,</source>
          <target state="translated">另外，具有仅对该子类实例有意义的新属性的子类可以调用基类 &lt;code&gt;__init__&lt;/code&gt; 来卸载属性设置。 这是通过* args和** kwargs完成的。 主要使用kwargs，以便使用命名参数可以读取代码。 例如，</target>
        </trans-unit>
        <trans-unit id="941017aafd6ce8752031e7a86c40872c1d44c7ad" translate="yes" xml:space="preserve">
          <source>An example from Python3 Document</source>
          <target state="translated">Python3文档中的一个例子</target>
        </trans-unit>
        <trans-unit id="f728b4c46940ef4939aedd7c78d82235855c9e4f" translate="yes" xml:space="preserve">
          <source>And by factoring out our code, which &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; allows us to do, we reduce lines of code, improve readability and maintainability, and have sole canonical locations for the logic in our program. If we need to change any part of this structure, we have one place in which to make each change.</source>
          <target state="translated">通过分解代码，使 &lt;code&gt;*args&lt;/code&gt; 和 &lt;code&gt;**kwargs&lt;/code&gt; 可以执行代码，我们减少了代码行，提高了可读性和可维护性，并且在程序中具有唯一的规范逻辑。 如果需要更改此结构的任何部分，则可以在一个位置进行每次更改。</target>
        </trans-unit>
        <trans-unit id="be56e527c4927fc931b3d869b5999e5e9411b330" translate="yes" xml:space="preserve">
          <source>And now every wrapped function can be written much more succinctly, as we've factored out the redundancy:</source>
          <target state="translated">而现在,每一个被包裹的函数都可以写得更简洁,因为我们已经把多余的东西都计算出来了。</target>
        </trans-unit>
        <trans-unit id="272a5867ff3c6c36ec58af2ec1adc2e2bdae6b60" translate="yes" xml:space="preserve">
          <source>And we can no longer accept unlimited positional arguments because we don't have &lt;code&gt;*args*&lt;/code&gt;:</source>
          <target state="translated">而且我们不再可以接受无限的位置参数，因为我们没有 &lt;code&gt;*args*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0b07a246fb1c6724bf5bb8d0fd6c30ceab979dfd" translate="yes" xml:space="preserve">
          <source>Another usage of the &lt;code&gt;*l&lt;/code&gt; idiom is to &lt;strong&gt;unpack argument lists&lt;/strong&gt; when calling a function.</source>
          <target state="translated">&lt;code&gt;*l&lt;/code&gt; 惯用语的另一种用法是在调用函数时&lt;strong&gt;解压缩参数列表&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="a56026bb3260c8f7cdf5974b41089feb98cd65e7" translate="yes" xml:space="preserve">
          <source>As another example, we can use dict expansion in &lt;code&gt;str.format&lt;/code&gt;:</source>
          <target state="translated">再举一个例子，我们可以在 &lt;code&gt;str.format&lt;/code&gt; 中使用dict扩展：</target>
        </trans-unit>
        <trans-unit id="f9506ad8d7ec60bc7b5829a999c8ceb09f4d0fb8" translate="yes" xml:space="preserve">
          <source>Basically, any number of &lt;strong&gt;positional arguments&lt;/strong&gt; can use *args and any &lt;strong&gt;named arguments&lt;/strong&gt; (or kwargs aka keyword arguments) can use **kwargs.</source>
          <target state="translated">基本上，任何数量的&lt;strong&gt;位置参数&lt;/strong&gt;都可以使用* args，任何&lt;strong&gt;命名参数&lt;/strong&gt; （或kwargs aka关键字参数）都可以使用** kwargs。</target>
        </trans-unit>
        <trans-unit id="193b10038bc8a0af892c8f2e776952cf5897379c" translate="yes" xml:space="preserve">
          <source>Below are 6 different use cases for &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; in python programming:</source>
          <target state="translated">以下是python编程中 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;**&lt;/code&gt; 的 6种不同用例：</target>
        </trans-unit>
        <trans-unit id="58a0baf8c6804e8201dd4d22f25df94546e28974" translate="yes" xml:space="preserve">
          <source>Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:</source>
          <target state="translated">这两个成语都可以和正常的参数混合在一起,让一组固定参数和一些可变参数。</target>
        </trans-unit>
        <trans-unit id="7f3f07a76c207ae0c4904e706b58ba513add5c23" translate="yes" xml:space="preserve">
          <source>Building on nickd's &lt;a href=&quot;https://stackoverflow.com/a/36911/8588359&quot;&gt;answer&lt;/a&gt;...</source>
          <target state="translated">建立在昵称的&lt;a href=&quot;https://stackoverflow.com/a/36911/8588359&quot;&gt;答案上&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="292f60f275382399afa74120ffd27ed50a5e4820" translate="yes" xml:space="preserve">
          <source>Defining Functions</source>
          <target state="translated">定义功能</target>
        </trans-unit>
        <trans-unit id="d3520f614d39ec8a767708415cb67124ef323ade" translate="yes" xml:space="preserve">
          <source>Expansion, Passing any number of arguments</source>
          <target state="translated">扩展,传递任意数量的参数</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="14f3e8fd51b161882e6b5aa2d0b75cf99f633ba9" translate="yes" xml:space="preserve">
          <source>For example, Python 2's xrange does not explicitly expect &lt;code&gt;*args&lt;/code&gt;, but since it takes 3 integers as arguments:</source>
          <target state="translated">例如，Python 2的xrange并不明确期望 &lt;code&gt;*args&lt;/code&gt; ，但是因为它需要3个整数作为参数：</target>
        </trans-unit>
        <trans-unit id="7af97b435f13f14645d917b304a83fcd1be73671" translate="yes" xml:space="preserve">
          <source>For example, the syntax for implementing &lt;strong&gt;varargs&lt;/strong&gt; in Java as follows:</source>
          <target state="translated">例如，在Java中实现&lt;strong&gt;varargs&lt;/strong&gt;的语法如下：</target>
        </trans-unit>
        <trans-unit id="493e6e7861151089d2bbb7ac7589c01c800e24d0" translate="yes" xml:space="preserve">
          <source>For those of you who learn by examples!</source>
          <target state="translated">对于那些以身作则学习的人来说!</target>
        </trans-unit>
        <trans-unit id="7ba7aff8700fed3c1874a29167ef370d01a8a7b7" translate="yes" xml:space="preserve">
          <source>From the Python documentation:</source>
          <target state="translated">来自于Python文档。</target>
        </trans-unit>
        <trans-unit id="e620618aef9f68baf0a6922ef26c1ee6d6334c80" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;kwarg2&lt;/code&gt; again must be an explicitly named, keyword argument:</source>
          <target state="translated">在这里， &lt;code&gt;kwarg2&lt;/code&gt; 再次必须是一个明确命名的关键字参数：</target>
        </trans-unit>
        <trans-unit id="72539057bd10b616a696bb7c198c6fa4c5f6db94" translate="yes" xml:space="preserve">
          <source>I want to give an example which others haven't  mentioned</source>
          <target state="translated">我想举一个别人没有提到的例子。</target>
        </trans-unit>
        <trans-unit id="f0eb94c0b755223ff3d41798dad7d9d87841455e" translate="yes" xml:space="preserve">
          <source>If any keyword argument does not correspond to a formal parameter name, a TypeError exception is raised, unless a formal parameter using the syntax &quot;**identifier&quot; is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments.</source>
          <target state="translated">如果任何关键字参数与正式参数名称不对应,则会产生一个TypeError异常,除非有一个使用语法 &quot;**identifier &quot;的正式参数;在这种情况下,该正式参数会接收一个包含多余的关键字参数的字典(使用关键字作为键值,而参数值作为相应的值),如果没有多余的关键字参数,则接收一个(新的)空字典。</target>
        </trans-unit>
        <trans-unit id="a4500c45138c4750180a1f2aeda2a22aab649db8" translate="yes" xml:space="preserve">
          <source>If applicable, &lt;code&gt;**&lt;/code&gt; must come after &lt;code&gt;*&lt;/code&gt;, always.</source>
          <target state="translated">如果适用， &lt;code&gt;**&lt;/code&gt; 必须始终在 &lt;code&gt;*&lt;/code&gt; 之后。</target>
        </trans-unit>
        <trans-unit id="efc74abb309d2f65c1476683ef984eb8eebc2d17" translate="yes" xml:space="preserve">
          <source>If there are more positional arguments than there are formal parameter slots, a TypeError exception is raised, unless a formal parameter using the syntax &quot;*identifier&quot; is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments).</source>
          <target state="translated">如果位置参数多于形式参数槽,则会产生一个TypeError异常,除非有一个使用语法 &quot;*identifier &quot;的形式参数;在这种情况下,该形式参数会接收一个包含多余的位置参数的元组(如果没有多余的位置参数,则接收一个空元组)。</target>
        </trans-unit>
        <trans-unit id="66c49fe41a858b7f28cff7b597d5e664961e5e4d" translate="yes" xml:space="preserve">
          <source>In Python 3 it is possible to use &lt;code&gt;*l&lt;/code&gt; on the left side of an assignment (&lt;a href=&quot;http://www.python.org/dev/peps/pep-3132/&quot;&gt;Extended Iterable Unpacking&lt;/a&gt;), though it gives a list instead of a tuple in this context:</source>
          <target state="translated">在Python 3中，可以在赋值的左侧使用 &lt;code&gt;*l&lt;/code&gt; （ &lt;a href=&quot;http://www.python.org/dev/peps/pep-3132/&quot;&gt;扩展的可迭代拆包&lt;/a&gt; ），尽管在这种情况下它给出的是列表而不是元组：</target>
        </trans-unit>
        <trans-unit id="8691aef17626aa432a214ae58f6b125acef8b90e" translate="yes" xml:space="preserve">
          <source>In Python 3.5, you can also use this syntax in &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, and &lt;code&gt;set&lt;/code&gt; displays (also sometimes called literals). See &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0448/&quot;&gt;PEP 488: Additional Unpacking Generalizations&lt;/a&gt;.</source>
          <target state="translated">在Python 3.5中，还可以在 &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;dict&lt;/code&gt; ， &lt;code&gt;tuple&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; display（有时也称为文字）中使用此语法。 请参阅&lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0448/&quot;&gt;PEP 488：其他拆包概述&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb835208e8f00e81b3abf80c30e2f9a12d147dfa" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;function call&lt;/strong&gt; the '*' &lt;strong&gt;unpacks&lt;/strong&gt; data structure of tuple or list into positional or keyword arguments to be received by function definition.</source>
          <target state="translated">在&lt;strong&gt;函数调用中&lt;/strong&gt; ，&amp;ldquo; *&amp;rdquo;将元组或列表的数据结构&lt;strong&gt;解压缩&lt;/strong&gt;为位置或关键字参数，以供函数定义接收。</target>
        </trans-unit>
        <trans-unit id="6675a7f7c18173022240f8345a27606cfd7103d2" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;function call&lt;/strong&gt; the '**' &lt;strong&gt;unpacks&lt;/strong&gt; data structure of dictionary into positional or keyword arguments to be received by function definition.</source>
          <target state="translated">在&lt;strong&gt;函数调用中&lt;/strong&gt; ，&amp;ldquo; **&amp;rdquo;将字典的数据结构&lt;strong&gt;解压缩&lt;/strong&gt;为位置或关键字参数，以供函数定义接收。</target>
        </trans-unit>
        <trans-unit id="983cd25b8c190befd85158d737e65c788cae99aa" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;function definition&lt;/strong&gt; the '*' &lt;strong&gt;packs&lt;/strong&gt; positional arguments into a tuple.</source>
          <target state="translated">在&lt;strong&gt;函数定义中&lt;/strong&gt; ，&amp;ldquo; *&amp;rdquo; &lt;strong&gt;将&lt;/strong&gt;位置参数&lt;strong&gt;打包&lt;/strong&gt;到元组中。</target>
        </trans-unit>
        <trans-unit id="8242ded2b6c77202b6aba67403b98d26e3b9f8a7" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;function definition&lt;/strong&gt; the '**' &lt;strong&gt;packs&lt;/strong&gt; keyword arguments into a dictionary.</source>
          <target state="translated">在&lt;strong&gt;函数定义中&lt;/strong&gt; ，&amp;ldquo; **&amp;rdquo; &lt;strong&gt;将&lt;/strong&gt;关键字参数&lt;strong&gt;打包&lt;/strong&gt;到字典中。</target>
        </trans-unit>
        <trans-unit id="58735475502a63f86aa44994b9acb298f79302cd" translate="yes" xml:space="preserve">
          <source>In addition to function calls, *args and **kwargs are useful in class hierarchies and also avoid having to write &lt;code&gt;__init__&lt;/code&gt; method in Python. Similar usage can seen in frameworks like Django code.</source>
          <target state="translated">除函数调用外，* args和** kwargs在类层次结构中很有用，并且还避免了必须在Python中编写 &lt;code&gt;__init__&lt;/code&gt; 方法。 在类似Django代码的框架中可以看到类似的用法。</target>
        </trans-unit>
        <trans-unit id="bb34dbc12b27d5ff2442c4a9c7fb3c9d138f554a" translate="yes" xml:space="preserve">
          <source>In addition to the answers in this thread, here is another detail that was not mentioned elsewhere. This expands on the &lt;a href=&quot;https://stackoverflow.com/a/47580283/42223&quot;&gt;answer by Brad Solomon&lt;/a&gt;</source>
          <target state="translated">除了此主题中的答案以外，这是其他地方未提及的另一个细节。 这扩展&lt;a href=&quot;https://stackoverflow.com/a/47580283/42223&quot;&gt;了布拉德&amp;middot;所罗门&lt;/a&gt;的答案</target>
        </trans-unit>
        <trans-unit id="29d133b1e0b3cf691330c1265f0ade4596a9ef8c" translate="yes" xml:space="preserve">
          <source>In function &lt;strong&gt;definition&lt;/strong&gt; The '**' operator packs the received arguments into a dictionary.</source>
          <target state="translated">在函数&lt;strong&gt;定义中&lt;/strong&gt; ，&amp;ldquo; **&amp;rdquo;运算符将接收到的参数打包到字典中。</target>
        </trans-unit>
        <trans-unit id="28cb4f66a57b75adf03d90ef92f1211c290e7b52" translate="yes" xml:space="preserve">
          <source>In function &lt;strong&gt;definition&lt;/strong&gt; the '*' operator packs the received arguments into a tuple.</source>
          <target state="translated">在函数&lt;strong&gt;定义中&lt;/strong&gt; ，&amp;ldquo; *&amp;rdquo;运算符将接收到的参数打包到一个元组中。</target>
        </trans-unit>
        <trans-unit id="841557c0934b1382a8328ac98e096ab23880171f" translate="yes" xml:space="preserve">
          <source>In the following method definitions, what does the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; do for &lt;code&gt;param2&lt;/code&gt;?</source>
          <target state="translated">在以下方法定义中， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;**&lt;/code&gt; 对 &lt;code&gt;param2&lt;/code&gt; 有何作用？</target>
        </trans-unit>
        <trans-unit id="31c9310dcc0195a2b23932b6507e5eb5f7d2c26a" translate="yes" xml:space="preserve">
          <source>In this example, we see that if we try to pass &lt;code&gt;kwarg&lt;/code&gt; positionally, we get an error:</source>
          <target state="translated">在此示例中，我们看到如果尝试通过位置传递 &lt;code&gt;kwarg&lt;/code&gt; ， 则会收到错误消息：</target>
        </trans-unit>
        <trans-unit id="cf7edb843a9194f38e1949d77a78828942274ba5" translate="yes" xml:space="preserve">
          <source>It also allows multiple iterables to be unpacked in a single function call.</source>
          <target state="translated">它还允许在一个函数调用中解压多个迭代项。</target>
        </trans-unit>
        <trans-unit id="4035e8005d566ecb14be86fc663eabe8f865894f" translate="yes" xml:space="preserve">
          <source>It is also possible to use this the other way around:</source>
          <target state="translated">也可以反过来用。</target>
        </trans-unit>
        <trans-unit id="c05cd1bca9e7cae9cdcb250882a9c06c018ab02d" translate="yes" xml:space="preserve">
          <source>It packs arguments passed to the function into &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;dict&lt;/code&gt; respectively inside the function body. When you define a function signature like this:</source>
          <target state="translated">它将传递给函数的参数分别打包到函数体内的 &lt;code&gt;list&lt;/code&gt; 和 &lt;code&gt;dict&lt;/code&gt; 中 。 当定义这样的函数签名时：</target>
        </trans-unit>
        <trans-unit id="dfb09dacdeab7cfd3c08651d82a2887a40500007" translate="yes" xml:space="preserve">
          <source>It's also worth noting that you can use &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; when calling functions as well. This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary. For example, if you have the following function:</source>
          <target state="translated">还值得注意的是，在调用函数时也可以使用 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;**&lt;/code&gt; 。 这是一个快捷方式，允许您使用列表/元组或字典将多个参数直接传递给函数。 例如，如果您具有以下功能：</target>
        </trans-unit>
        <trans-unit id="7901e31b6d26720b22aaec3f1116bd71366e50e7" translate="yes" xml:space="preserve">
          <source>Let us first understand what are positional arguments and keyword arguments.
Below is an example of function definition with &lt;strong&gt;Positional arguments.&lt;/strong&gt;</source>
          <target state="translated">首先让我们了解什么是位置参数和关键字参数。 下面是带有&lt;strong&gt;位置参数&lt;/strong&gt;的函数定义的示例&lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4b23038a2cc7c7d11a51aa8537b685f687d5820" translate="yes" xml:space="preserve">
          <source>Let us get straight to an example and then discuss it.</source>
          <target state="translated">让我们直接举个例子,然后讨论一下。</target>
        </trans-unit>
        <trans-unit id="87e52c50e2e0e5058b445b9067a0a72b6d2cd8d7" translate="yes" xml:space="preserve">
          <source>Let us show this by defining a function that takes two normal variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and can accept more arguments as &lt;code&gt;myArgs&lt;/code&gt;, and can accept even more arguments as &lt;code&gt;myKW&lt;/code&gt;. Later, we will show how to feed &lt;code&gt;y&lt;/code&gt; using &lt;code&gt;myArgDict&lt;/code&gt;.</source>
          <target state="translated">让我们通过定义一个接受两个普通变量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的函数来说明这一点，该函数可以接受更多参数作为 &lt;code&gt;myArgs&lt;/code&gt; ，可以接受更多参数作为 &lt;code&gt;myKW&lt;/code&gt; 。 稍后，我们将展示如何使用 &lt;code&gt;myArgDict&lt;/code&gt; 来输入 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb41e5bdd359dec6da0c1f298c3c0b43cc86932e" translate="yes" xml:space="preserve">
          <source>Let's call this function with &lt;code&gt;foo(1, 2, 3, 4, e=5, f=6, g=7)&lt;/code&gt;</source>
          <target state="translated">让我们用 &lt;code&gt;foo(1, 2, 3, 4, e=5, f=6, g=7)&lt;/code&gt; 调用此函数</target>
        </trans-unit>
        <trans-unit id="a245374ac3ff8ea606f1d3b17466eb8e31c565f7" translate="yes" xml:space="preserve">
          <source>New in Python 3: Defining functions with keyword only arguments</source>
          <target state="translated">在Python 3中的新功能:定义仅有关键字参数的函数</target>
        </trans-unit>
        <trans-unit id="91a5336d571b1fe3c1f7791c93e16e9bd59c5ada" translate="yes" xml:space="preserve">
          <source>Non-optional argument assignment happens first.</source>
          <target state="translated">非选项论证任务首先发生。</target>
        </trans-unit>
        <trans-unit id="91448b75d21315f518a18d8fc42a1ce53bf91a2a" translate="yes" xml:space="preserve">
          <source>Note: The keys in &lt;code&gt;mydict&lt;/code&gt; have to be named exactly like the parameters of function &lt;code&gt;foo&lt;/code&gt;. Otherwise it will throw a &lt;code&gt;TypeError&lt;/code&gt;:</source>
          <target state="translated">注意： &lt;code&gt;mydict&lt;/code&gt; 中的键必须完全像 &lt;code&gt;foo&lt;/code&gt; 函数的参数一样命名。 否则会抛出 &lt;code&gt;TypeError&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="24ebde1388a779e5d0c30351caa8f0ace467cf94" translate="yes" xml:space="preserve">
          <source>Now let us see an example of '**' used in function definition:</source>
          <target state="translated">现在让我们来看一个函数定义中使用的 &quot;**&quot;的例子。</target>
        </trans-unit>
        <trans-unit id="b619a1ead86d849e65e82eda63f8fe990eca62f9" translate="yes" xml:space="preserve">
          <source>Now let us study an example of function definition with &lt;strong&gt;keyword arguments&lt;/strong&gt;:</source>
          <target state="translated">现在让我们研究一个带有&lt;strong&gt;关键字参数&lt;/strong&gt;的函数定义示例：</target>
        </trans-unit>
        <trans-unit id="4a2039738304b820b9d7fa888013e4fe9300e160" translate="yes" xml:space="preserve">
          <source>Now let us study the '*' operator and '**' operator.</source>
          <target state="translated">现在让我们研究一下'*'算子和'**'算子。</target>
        </trans-unit>
        <trans-unit id="2bbdf3ea245d185075329f6ce6fb3db2e270559b" translate="yes" xml:space="preserve">
          <source>Now let us study the '*' operator use in &lt;strong&gt;function definition&lt;/strong&gt;.
Example:</source>
          <target state="translated">现在让我们研究&lt;strong&gt;函数定义中&lt;/strong&gt;使用'*'运算符。 例：</target>
        </trans-unit>
        <trans-unit id="ab3d3532798f22ac8cd363026830e3bc22bd4736" translate="yes" xml:space="preserve">
          <source>OK, so maybe we're not seeing the utility yet. So imagine you have several functions with redundant code before and/or after the differentiating code. The following named functions are just pseudo-code for illustrative purposes.</source>
          <target state="translated">OK,所以也许我们还没有看到实用性。所以想象一下,你有几个函数在区分代码前后有冗余的代码。下面命名的函数只是伪代码,以示说明。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="b1586a28b4adf696fa94b895eeaff2889a1ab757" translate="yes" xml:space="preserve">
          <source>Please note these operators can be used in 2 areas:</source>
          <target state="translated">请注意,这些运营商可以在2个领域使用。</target>
        </trans-unit>
        <trans-unit id="d6b4ce72d3b7c0e1f8d8a432ab3632aac2b48700" translate="yes" xml:space="preserve">
          <source>Python 2 compatible demos</source>
          <target state="translated">Python 2兼容的演示</target>
        </trans-unit>
        <trans-unit id="56fce8c175adcf994a88eaf001f3be01c032ad86" translate="yes" xml:space="preserve">
          <source>Quick Example</source>
          <target state="translated">快速示例</target>
        </trans-unit>
        <trans-unit id="ae5980edbf86fe41fa4f231cd5375aec2949aed3" translate="yes" xml:space="preserve">
          <source>Relatedly: uses for the star/splat operators have been &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;expanded&lt;/a&gt; in Python 3</source>
          <target state="translated">相关：在Python 3中已&lt;a href=&quot;https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;扩展&lt;/a&gt;了star / splat运算符的用法</target>
        </trans-unit>
        <trans-unit id="f5cf0ceedb335135a295394a6abb33e7369b6ed4" translate="yes" xml:space="preserve">
          <source>So remember</source>
          <target state="translated">所以要记住</target>
        </trans-unit>
        <trans-unit id="7727bb5c748719530e5365f60dc1345a08cbbc5e" translate="yes" xml:space="preserve">
          <source>So remember:</source>
          <target state="translated">所以要记住。</target>
        </trans-unit>
        <trans-unit id="4daa26ea0c8c2263bb963c398bb22881ee6e987a" translate="yes" xml:space="preserve">
          <source>So this is a function definition with positional arguments.
You can call it with keyword/named arguments as well:</source>
          <target state="translated">所以这是一个带位置参数的函数定义。你也可以用键名参数来调用它。</target>
        </trans-unit>
        <trans-unit id="0f4462555ad3a05048aab639fb7bffc0533da2ae" translate="yes" xml:space="preserve">
          <source>So we now know function definitions with positional as well as keyword arguments.</source>
          <target state="translated">所以,我们现在知道函数的定义除了关键字参数外,还包含了位置参数。</target>
        </trans-unit>
        <trans-unit id="4c070a54b1f4117ae25ca6094d330ad2f48f23e5" translate="yes" xml:space="preserve">
          <source>Such function accepts only 3 positional arguments, and everything after &lt;code&gt;*&lt;/code&gt; can only be passed as keyword arguments.</source>
          <target state="translated">该函数仅接受3个位置参数， &lt;code&gt;*&lt;/code&gt; 之后的所有内容只能作为关键字参数传递。</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="32602316336694ff9b888c208e8e51d3fc544690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**kwargs&lt;/code&gt; will give you all 
&lt;strong&gt;keyword arguments&lt;/strong&gt; except for those corresponding to a formal parameter as a dictionary.</source>
          <target state="translated">&lt;code&gt;**kwargs&lt;/code&gt; 将为您提供所有&lt;strong&gt;关键字参数，&lt;/strong&gt;但那些与字典形式参数相对应的&lt;strong&gt;参数&lt;/strong&gt;除外。</target>
        </trans-unit>
        <trans-unit id="cf63e04524574cf4580aa2c7181367ee304b6f02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; is a common idiom to allow arbitrary number of arguments to functions as described in the section &lt;a href=&quot;http://docs.python.org/dev/tutorial/controlflow.html#more-on-defining-functions&quot;&gt;more on defining functions&lt;/a&gt; in the Python documentation.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 和 &lt;code&gt;**kwargs&lt;/code&gt; 是一个常见的习惯用法，它允许对函数使用任意数量的参数，如在Python文档中&lt;a href=&quot;http://docs.python.org/dev/tutorial/controlflow.html#more-on-defining-functions&quot;&gt;有关定义函数&lt;/a&gt;的小节中所述。</target>
        </trans-unit>
        <trans-unit id="3712da16870cb2acecd53004226f6aed43506f17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*args&lt;/code&gt; will give you all function parameters &lt;a href=&quot;https://docs.python.org/dev/tutorial/controlflow.html#arbitrary-argument-lists&quot;&gt;as a tuple&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 将为您提供所有函数参数&lt;a href=&quot;https://docs.python.org/dev/tutorial/controlflow.html#arbitrary-argument-lists&quot;&gt;为元组&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="93b505fb3abc4a37f6c7efe50f5052207c2aa74a" translate="yes" xml:space="preserve">
          <source>The complete code is &lt;a href=&quot;http://harisankar-krishnaswamy.blogspot.sg/2015/08/using-args-and-kwargs-python-code-post.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">完整的代码在&lt;a href=&quot;http://harisankar-krishnaswamy.blogspot.sg/2015/08/using-args-and-kwargs-python-code-post.html&quot;&gt;这里&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a896ce94825ba4df77e4618c23aa21e3591103c9" translate="yes" xml:space="preserve">
          <source>The double ** means there can be any number of extra named parameters. &lt;code&gt;bar()&lt;/code&gt; can be invoked like &lt;code&gt;bar(1, a=2, b=3)&lt;/code&gt;. In the body of bar() param2 is a dictionary containing {'a':2, 'b':3 }</source>
          <target state="translated">双**表示可以有任意数量的额外命名参数。 可以像 &lt;code&gt;bar(1, a=2, b=3)&lt;/code&gt; 一样调用bar（） 。 在bar（）的主体中，param2是一个包含{'a'：2，'b'：3}的字典。</target>
        </trans-unit>
        <trans-unit id="504eb92669c468e236a773b315b925eb19aaf5ee" translate="yes" xml:space="preserve">
          <source>The following function describes how they can be used, and demonstrates behavior. Note the named &lt;code&gt;b&lt;/code&gt; argument will be consumed by the second positional argument before :</source>
          <target state="translated">以下功能描述了如何使用它们，并演示了行为。 注意，命名的 &lt;code&gt;b&lt;/code&gt; 参数将由前面的第二个位置参数使用：</target>
        </trans-unit>
        <trans-unit id="e443aae8785e85d922c3fa35db5f6379233330af" translate="yes" xml:space="preserve">
          <source>The function recieving the parameters does not have to know that they are being expanded.</source>
          <target state="translated">接收参数的函数不需要知道这些参数正在被扩展。</target>
        </trans-unit>
        <trans-unit id="fafee0b6f78ca93506971dffb50240f2686eae25" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;**&lt;/code&gt; is to give you the ability to feed a function's arguments by providing a dictionary (e.g. &lt;code&gt;f(**{'x' : 1, 'y' : 2})&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 的目的是通过提供字典（例如 &lt;code&gt;f(**{'x' : 1, 'y' : 2})&lt;/code&gt; ）使您能够输入函数的参数。</target>
        </trans-unit>
        <trans-unit id="2f5a6a43eafba8c82a9d72f0ede407675439bd2a" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;*&lt;/code&gt;  is to give you the ability to define a function that can take an arbitrary number of arguments provided as a list (e.g. &lt;code&gt;f(*myList)&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 的目的是使您能够定义一个函数，该函数可以接受以列表形式提供的任意数量的参数（例如 &lt;code&gt;f(*myList)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0540e6129858e4f8523a3a6fa9049a40a569a1e2" translate="yes" xml:space="preserve">
          <source>The single * means that there can be any number of extra positional arguments. &lt;code&gt;foo()&lt;/code&gt; can be invoked like &lt;code&gt;foo(1,2,3,4,5)&lt;/code&gt;. In the body of foo() param2 is a sequence containing 2-5.</source>
          <target state="translated">单个*表示可以有任意数量的额外位置参数。 可以像 &lt;code&gt;foo(1,2,3,4,5)&lt;/code&gt; 一样调用foo（） 。 在foo（）主体中，param2是一个包含2-5的序列。</target>
        </trans-unit>
        <trans-unit id="2d1570fcc1afe648dd6fd1efa9f4eba37db798fb" translate="yes" xml:space="preserve">
          <source>The subclass then be instantiated as</source>
          <target state="translated">然后将子类实例化为</target>
        </trans-unit>
        <trans-unit id="7e318ae5502f2c6caa085e9130b7c26c1122e926" translate="yes" xml:space="preserve">
          <source>The use of '*' operator and '**' operator in &lt;strong&gt;function call.&lt;/strong&gt;</source>
          <target state="translated">在&lt;strong&gt;函数调用中&lt;/strong&gt;使用&amp;ldquo; *&amp;rdquo;运算符和&amp;ldquo; **&amp;rdquo;运算符&lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="221ec3c13c3ff3139d5fa30b8bad1a628fef59e9" translate="yes" xml:space="preserve">
          <source>The zip() receives multiple iretable args, and return a generator.</source>
          <target state="translated">zip()接收多个iretable args,并返回一个生成器。</target>
        </trans-unit>
        <trans-unit id="a62bafe25d51ed5be42368872e804941b20a4a6e" translate="yes" xml:space="preserve">
          <source>They allow for &lt;strong&gt;functions to be defined to accept&lt;/strong&gt; and for &lt;strong&gt;users to pass&lt;/strong&gt; any number of arguments, positional (&lt;code&gt;*&lt;/code&gt;) and keyword (&lt;code&gt;**&lt;/code&gt;).</source>
          <target state="translated">它们允许&lt;strong&gt;定义函数以接受&lt;/strong&gt;和允许&lt;strong&gt;用户传递&lt;/strong&gt;任意数量的参数，位置（ &lt;code&gt;*&lt;/code&gt; ）和关键字（ &lt;code&gt;**&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="76e5ec318c3f4aae99285e9dc60f5a60d259a905" translate="yes" xml:space="preserve">
          <source>This also works in reverse, i.e. from the caller side. for example if you have a function defined as:</source>
          <target state="translated">这也可以反其道而行之,即从调用方看,例如,如果你有一个函数定义为:</target>
        </trans-unit>
        <trans-unit id="f71bfb2e76b0ba5c8edbecd4ae4daf6a4102ad02" translate="yes" xml:space="preserve">
          <source>This example would help you remember &lt;code&gt;*args&lt;/code&gt;, &lt;code&gt;**kwargs&lt;/code&gt; and even &lt;code&gt;super&lt;/code&gt; and inheritance in Python at once.</source>
          <target state="translated">这个示例将帮助您立即记住Python中的 &lt;code&gt;*args&lt;/code&gt; ， &lt;code&gt;**kwargs&lt;/code&gt; 甚至 &lt;code&gt;super&lt;/code&gt; 和继承。</target>
        </trans-unit>
        <trans-unit id="2e78a575536cd3c81799e8d59abbcc1aef7ff457" translate="yes" xml:space="preserve">
          <source>This is somewhat similar to what you can do with python &lt;code&gt;f-strings&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/questions/tagged/f-string&quot;&gt;f-string&lt;/a&gt; but with the added overhead of declaring a dict to hold the variables (f-string does not require a dict).</source>
          <target state="translated">这有点类似于您可以使用python &lt;code&gt;f-strings&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/questions/tagged/f-string&quot;&gt;f-string进行的操作，&lt;/a&gt;但是增加了声明保留变量的字典的开销（f-string不需要字典）。</target>
        </trans-unit>
        <trans-unit id="e9f49a602092f2600ab4dbfbc225050cee771531" translate="yes" xml:space="preserve">
          <source>This really just serves to summarize Lorin Hochstein's &lt;a href=&quot;https://stackoverflow.com/a/36926/7954504&quot;&gt;answer&lt;/a&gt; but I find it helpful.</source>
          <target state="translated">这确实只是用来总结Lorin Hochstein的&lt;a href=&quot;https://stackoverflow.com/a/36926/7954504&quot;&gt;答案，&lt;/a&gt;但我发现它很有帮助。</target>
        </trans-unit>
        <trans-unit id="c41e617275ef98f70808b26e784db9772637feed" translate="yes" xml:space="preserve">
          <source>This table is handy for using &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; in function &lt;em&gt;construction&lt;/em&gt; and function &lt;em&gt;call&lt;/em&gt;:</source>
          <target state="translated">该表非常适合在函数&lt;em&gt;构造&lt;/em&gt;和函数&lt;em&gt;调用中&lt;/em&gt;使用 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;**&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d26fb807a328081eaceffc49cd97f7b17a9ac470" translate="yes" xml:space="preserve">
          <source>Unpacking with &lt;code&gt;**&lt;/code&gt; is also useful when using python &lt;code&gt;str.format&lt;/code&gt;.</source>
          <target state="translated">使用python &lt;code&gt;str.format&lt;/code&gt; 时，用 &lt;code&gt;**&lt;/code&gt; 拆包也很有用。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="99fb84d8b321ffa9a9069c867daeb8f9d53c541c" translate="yes" xml:space="preserve">
          <source>Use with string formatting</source>
          <target state="translated">与字符串格式化一起使用</target>
        </trans-unit>
        <trans-unit id="4a799ab566a9451f574fb3da7249ae89668ffe3b" translate="yes" xml:space="preserve">
          <source>Used like the following:</source>
          <target state="translated">用法如下:</target>
        </trans-unit>
        <trans-unit id="43a00a174601ad173cf07207f8cd33994f1103d9" translate="yes" xml:space="preserve">
          <source>We can also call it using another function, into which we just provide &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">我们还可以使用另一个函数来调用它，我们仅向其中提供 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eec1d477fb271bf52684fd29e0ae7094d81e0a4d" translate="yes" xml:space="preserve">
          <source>We can check the online help for the function's signature, with &lt;code&gt;help(foo)&lt;/code&gt;, which tells us</source>
          <target state="translated">我们可以使用 &lt;code&gt;help(foo)&lt;/code&gt; 来检查在线帮助中该函数的签名，它告诉我们</target>
        </trans-unit>
        <trans-unit id="071466cc8ede79b9743ebb45f3b9307858ccd94e" translate="yes" xml:space="preserve">
          <source>We might be able to handle this differently, but we can certainly extract the redundancy with a decorator, and so our below example demonstrates how &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; can be very useful:</source>
          <target state="translated">我们也许可以用不同的方式处理这个问题，但是我们当然可以用装饰器提取冗余，因此下面的示例演示 &lt;code&gt;*args&lt;/code&gt; 和 &lt;code&gt;**kwargs&lt;/code&gt; 如何非常有用：</target>
        </trans-unit>
        <trans-unit id="b7ea4cbb24ea5b0d07e6f28ecfaf88c925dadd18" translate="yes" xml:space="preserve">
          <source>We must explicitly pass the &lt;code&gt;kwarg&lt;/code&gt; parameter as a keyword argument.</source>
          <target state="translated">我们必须显式地将 &lt;code&gt;kwarg&lt;/code&gt; 参数作为关键字参数传递。</target>
        </trans-unit>
        <trans-unit id="afb7cb9daf1c756ee48ed6afd251e0968bb9474f" translate="yes" xml:space="preserve">
          <source>We typically use these when we don't know what our function is going to receive or how many arguments we may be passing, and sometimes even when naming every variable separately would get very messy and redundant (but this is a case where usually explicit is better than implicit).</source>
          <target state="translated">我们通常在不知道我们的函数要接收什么或者我们可能要传递多少个参数的时候使用这些,有时甚至在给每个变量分别命名的时候也会变得非常混乱和多余(但这种情况下,通常显式比隐式好)。</target>
        </trans-unit>
        <trans-unit id="233bc8dee4817e4eae3ea779d6439f59b4f59bbb" translate="yes" xml:space="preserve">
          <source>What does ** (double star/asterisk) and * (star/asterisk) do for parameters</source>
          <target state="translated">**(双星标)和*(星标)对参数有什么作用?</target>
        </trans-unit>
        <trans-unit id="043cce10c16f63cb0c473e49b9c9a719c0674492" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;**&lt;/code&gt; (double star) and &lt;code&gt;*&lt;/code&gt; (star) do for parameters</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; （双星）和 &lt;code&gt;*&lt;/code&gt; （星）对参数有什么作用</target>
        </trans-unit>
        <trans-unit id="8af1dddd6c2192a020edaa51d45191a8693034d0" translate="yes" xml:space="preserve">
          <source>Will produce:</source>
          <target state="translated">将产生。</target>
        </trans-unit>
        <trans-unit id="1ed3fd9bd4c1f256dcc104023a64d45285ef0146" translate="yes" xml:space="preserve">
          <source>With the following code:</source>
          <target state="translated">用以下代码:</target>
        </trans-unit>
        <trans-unit id="89e91d292d7914d17c805c0dd69622e7e39268be" translate="yes" xml:space="preserve">
          <source>You can (and should) choose any appropriate name, but if the intention is for the arguments to be of non-specific semantics, &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; are standard names.</source>
          <target state="translated">您可以（并且应该）选择任何适当的名称，但是如果意图是使参数具有非特定的语义，则 &lt;code&gt;args&lt;/code&gt; 和 &lt;code&gt;kwargs&lt;/code&gt; 是标准名称。</target>
        </trans-unit>
        <trans-unit id="c10ea9af188d5d91cbab26c0e813033c66126cd5" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; to pass in parameters from lists (or any iterable) and dicts (or any mapping), respectively.</source>
          <target state="translated">您还可以使用 &lt;code&gt;*args&lt;/code&gt; 和 &lt;code&gt;**kwargs&lt;/code&gt; 分别从列表（或任何可迭代的）和字典（或任何映射）中传入参数。</target>
        </trans-unit>
        <trans-unit id="b42ee187d69586d1f39155928626c35d1cde5fb8" translate="yes" xml:space="preserve">
          <source>You can call this function with positional arguments as well:</source>
          <target state="translated">你也可以用位置参数来调用这个函数。</target>
        </trans-unit>
        <trans-unit id="277476897ef47b624210790858b6cdfcc04e5aa8" translate="yes" xml:space="preserve">
          <source>You can do things like:</source>
          <target state="translated">你可以做这样的事情:</target>
        </trans-unit>
        <trans-unit id="080bdd4b11396c960350e4e97d2ff50dbf02b258" translate="yes" xml:space="preserve">
          <source>You can have &lt;a href=&quot;https://www.python.org/dev/peps/pep-3102/&quot;&gt;keyword only arguments&lt;/a&gt; after the &lt;code&gt;*args&lt;/code&gt; - for example, here, &lt;code&gt;kwarg2&lt;/code&gt; must be given as a keyword argument - not positionally:</source>
          <target state="translated">您可以在 &lt;code&gt;*args&lt;/code&gt; 之后使用&lt;a href=&quot;https://www.python.org/dev/peps/pep-3102/&quot;&gt;仅关键字&lt;/a&gt; 参数 -例如，在这里，必须将 &lt;code&gt;kwarg2&lt;/code&gt; 作为关键字参数-而不是位置：</target>
        </trans-unit>
        <trans-unit id="794557036415543543af5f1912c1507e42924507" translate="yes" xml:space="preserve">
          <source>You cannot use a non-optional argument twice.</source>
          <target state="translated">你不能两次使用非选项参数。</target>
        </trans-unit>
        <trans-unit id="8be25461c64d172078a03a0ec37aabb6b3175e9f" translate="yes" xml:space="preserve">
          <source>a) &lt;strong&gt;function call&lt;/strong&gt;</source>
          <target state="translated">a） &lt;strong&gt;函数调用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b8ece01faa7de12cfc700e3749c548d91f9ccb9" translate="yes" xml:space="preserve">
          <source>b) &lt;strong&gt;function definition&lt;/strong&gt;</source>
          <target state="translated">b） &lt;strong&gt;功能定义&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08311cc2119febe4e48dfcb0db0929fd8ae81d7e" translate="yes" xml:space="preserve">
          <source>it can be called with any number of arguments and keyword arguments. The non-keyword arguments get packed into a list called &lt;code&gt;args&lt;/code&gt; inside the the function body and the keyword arguments get packed into a dict called &lt;code&gt;kwds&lt;/code&gt; inside the function body.</source>
          <target state="translated">可以使用任意数量的参数和关键字参数来调用它。 非关键字参数打包到函数体内的一个名为 &lt;code&gt;args&lt;/code&gt; 的列表中，而关键字参数打包到函数体内的一个称为 &lt;code&gt;kwds&lt;/code&gt; 的dict中。</target>
        </trans-unit>
        <trans-unit id="f185697f8ffee0494f5a9ca561ffa16269aaa2e4" translate="yes" xml:space="preserve">
          <source>now inside the function body, when the function is called, there are two local variables, &lt;code&gt;args&lt;/code&gt; which is a list having value &lt;code&gt;[&quot;this&quot;, &quot;is a list of&quot;, &quot;non-keyword&quot;, &quot;arguments&quot;]&lt;/code&gt; and &lt;code&gt;kwds&lt;/code&gt; which is a &lt;code&gt;dict&lt;/code&gt; having value &lt;code&gt;{&quot;keyword&quot; : &quot;ligma&quot;, &quot;options&quot; : [1,2,3]}&lt;/code&gt;</source>
          <target state="translated">现在在函数体内，当调用函数时，有两个局部变量 &lt;code&gt;args&lt;/code&gt; ，这是一个具有值 &lt;code&gt;[&quot;this&quot;, &quot;is a list of&quot;, &quot;non-keyword&quot;, &quot;arguments&quot;]&lt;/code&gt; 和 &lt;code&gt;kwds&lt;/code&gt; 的列表是具有值 &lt;code&gt;{&quot;keyword&quot; : &quot;ligma&quot;, &quot;options&quot; : [1,2,3]}&lt;/code&gt; 的 &lt;code&gt;dict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a47e545e87233be9061b9f3c1748aeec79ce9e9" translate="yes" xml:space="preserve">
          <source>python 3.x</source>
          <target state="translated">python 3.x</target>
        </trans-unit>
        <trans-unit id="07fcd4ad0499856dfdeabb4c0a597ca70871dd39" translate="yes" xml:space="preserve">
          <source>the output is</source>
          <target state="translated">输出是</target>
        </trans-unit>
        <trans-unit id="c0312cefbf9b17e9389098ab519b7a2c6225ccac" translate="yes" xml:space="preserve">
          <source>unpacking with &lt;code&gt;**&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 开箱</target>
        </trans-unit>
        <trans-unit id="469f623755b36ae79ca6ef17aeded6d0e236120c" translate="yes" xml:space="preserve">
          <source>unzip_x will be [1, 2, 3], unzip_y will be [4, 5, 6]</source>
          <target state="translated">unzip_x将为[1,2,3],unzip_y将为[4,5,6]</target>
        </trans-unit>
        <trans-unit id="b45d58392bc34be02450e99b0b277b08dd9bca68" translate="yes" xml:space="preserve">
          <source>use with string formatting</source>
          <target state="translated">套用</target>
        </trans-unit>
        <trans-unit id="fb8d239cc4547ad356ef28527d756262f9bef562" translate="yes" xml:space="preserve">
          <source>when the '*' or '**' operator is used in a &lt;strong&gt;function call&lt;/strong&gt; -</source>
          <target state="translated">在&lt;strong&gt;函数调用中&lt;/strong&gt;使用&amp;ldquo; *&amp;rdquo;或&amp;ldquo; **&amp;rdquo;运算符时-</target>
        </trans-unit>
        <trans-unit id="d8655e943d84ac23e65b556422ceb5ee5d1db650" translate="yes" xml:space="preserve">
          <source>which can be instatiated as</source>
          <target state="translated">可以说是</target>
        </trans-unit>
        <trans-unit id="99c16e7d13d5e5df076271fc43ca71919374d7b2" translate="yes" xml:space="preserve">
          <source>which prints:</source>
          <target state="translated">哪些印刷品。</target>
        </trans-unit>
        <trans-unit id="56f64359bcaff739c2bfb83bbb0ff89946112fc6" translate="yes" xml:space="preserve">
          <source>you can call it with by unpacking iterables or mappings you have in the calling scope:</source>
          <target state="translated">你可以通过在调用范围中解压迭代或映射来调用它。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
