<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/36901">
    <body>
      <group id="36901">
        <trans-unit id="c4923479209994d522d1740b7cd3097f3afa7e4b" translate="yes" xml:space="preserve">
          <source>'*' operator unpacks data structure such as a list or tuple  into arguments needed by function definition.</source>
          <target state="translated">'*'연산자는 목록 또는 튜플과 같은 데이터 구조를 함수 정의에 필요한 인수로 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="74a58a15f76f4145555ab65613e710dee0aaca7d" translate="yes" xml:space="preserve">
          <source>'**' operator unpacks a dictionary into arguments needed by function definition.</source>
          <target state="translated">'**'연산자는 함수 정의에 필요한 인수로 사전을 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="f6b359d1865f19eb9d426f416d514730a67eccfc" translate="yes" xml:space="preserve">
          <source>(Thanks to mgilson for the PEP link.)</source>
          <target state="translated">(PEP 링크에 대해 mgilson에게 감사합니다.)</target>
        </trans-unit>
        <trans-unit id="1b2bdd544173f0325e186a3d408936d76a7cd87a" translate="yes" xml:space="preserve">
          <source>* can also unpack a &lt;strong&gt;generator&lt;/strong&gt;</source>
          <target state="translated">* 또한 &lt;strong&gt;발전기의&lt;/strong&gt; 포장을 풀 수 있습니다</target>
        </trans-unit>
        <trans-unit id="02de2d002252b3da90ad05f886293cf0484ac3b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**&lt;/code&gt; is exclusively reserved for dictionaries.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 사전 전용으로 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf326c516844f4113fcb75fd6abb41f6827695c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**&lt;/code&gt; means receive variable arguments as dictionary</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 는 변수 인수를 사전으로 받는다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="ea91a0e8fbc5ce9fc1d1887ac061d90237e80a67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**kwargs&lt;/code&gt; allows for any number of optional keyword arguments (parameters), which will be in a dict named &lt;code&gt;kwargs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;**kwargs&lt;/code&gt; 는 kwargs 라는 dict에있는 선택적 키워드 인수 (매개 변수)를 여러 개 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d80585a56779acc5b0ad3eb5b9e73d9ef7e74bfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**kwargs&lt;/code&gt; allows you to pass keyworded variable length of arguments to a function. You should use &lt;code&gt;**kwargs&lt;/code&gt; if you want to handle named arguments in a function.</source>
          <target state="translated">&lt;code&gt;**kwargs&lt;/code&gt; 를 사용하면 키워드로 가변 길이의 인수를 함수에 전달할 수 있습니다. 함수에서 명명 된 인수를 처리하려면 &lt;code&gt;**kwargs&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc450e8410bb5b81c3faf57ca5dfbdb36fe0c4d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; have special usage in the function argument list. &lt;code&gt;*&lt;/code&gt;
implies that the argument is a list and &lt;code&gt;**&lt;/code&gt; implies that the argument
is a dictionary. This allows functions to take arbitrary number of
arguments</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;**&lt;/code&gt; 는 함수 인수 목록에서 특별한 용도로 사용됩니다. &lt;code&gt;*&lt;/code&gt; 는 인수가 목록임을 의미하고 &lt;code&gt;**&lt;/code&gt; 는 인수가 사전임을 의미합니다. 이를 통해 함수는 임의의 수의 인수를 취할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="646e6f68fc6fc0f172910b7ae53e333ccdbdf675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; means receive variable arguments as tuple</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 가변 인수를 튜플로 받는다는 의미</target>
        </trans-unit>
        <trans-unit id="d4541b9e96a6ad3672a7c02ad538b463d7bbae10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt; (typically said &quot;star-args&quot;) and &lt;code&gt;**kwargs&lt;/code&gt; (stars can be implied by saying &quot;kwargs&quot;, but be explicit with &quot;double-star kwargs&quot;) are common idioms of Python for using the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; notation. These specific variable names aren't required (e.g. you could use &lt;code&gt;*foos&lt;/code&gt; and &lt;code&gt;**bars&lt;/code&gt;), but a departure from convention is likely to enrage your fellow Python coders.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; (일반적으로 &quot;star-args&quot;라고 함) 및 &lt;code&gt;**kwargs&lt;/code&gt; (별은 &quot;kwargs&quot;를 말함으로써 암시 될 수 있지만 &quot;double-star kwargs&quot;로 명시적임)는 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;**&lt;/code&gt; 표기법을 사용하는 Python의 일반적인 관용구입니다. . 이러한 특정 변수 이름은 필요하지 않지만 (예 : &lt;code&gt;*foos&lt;/code&gt; 및 &lt;code&gt;**bars&lt;/code&gt; 를 사용할 수 있음) 관례에서 벗어나면 동료 Python 코더가 분노 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="000a612bbb899711b6d999e67117df15d720c4f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt; allows for any number of optional positional arguments (parameters), which will be assigned to a tuple named &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 는 args 라는 튜플에 할당 될 선택적 위치 인수 (매개 변수)를 원하는 수만큼 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a21e58e874efd5d5471e19924132aa39fd60ecd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt;: allow you to pass a variable number of arguments to a function.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 및 &lt;code&gt;**kwargs&lt;/code&gt; : 가변 개수의 인수를 함수에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c11b9a4bbc515b4b84ebc72faf0f618df2cf435e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt;: is used to send a non-keyworded variable length argument list to the function:</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; : 키워드가 아닌 가변 길이 인수 목록을 함수에 보내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd293480f3802120e494ecb797df550cbc0da842" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bar(100)&lt;/code&gt; prints:</source>
          <target state="translated">&lt;code&gt;bar(100)&lt;/code&gt; 인쇄 :</target>
        </trans-unit>
        <trans-unit id="2b19bee1d5c998645875739dbaa2f77f25bdfd4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;def bar(param1, **param2):&lt;/code&gt; is a method can accept arbitrary number of values with keys for &lt;code&gt;*param2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;def bar(param1, **param2):&lt;/code&gt; &lt;code&gt;*param2&lt;/code&gt; 에 대한 키를 사용하여 임의의 수의 값을 허용 할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="fa9db175acae07bc148fd8a18e1d86066bfbe76a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;def foo(param1, *param2):&lt;/code&gt; is a method can accept arbitrary number of values for &lt;code&gt;*param2&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;def foo(param1, *param2):&lt;/code&gt; &lt;code&gt;*param2&lt;/code&gt; 에 대해 임의의 수의 값을받을 수있는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="d457e800acd00734cfb232f7d555b2be33e3a422" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;param1&lt;/code&gt; is a simple parameter.</source>
          <target state="translated">&lt;code&gt;param1&lt;/code&gt; 은 간단한 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="b83429dc7d3f741551503d2152003ebd8a2a0d36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) single *&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) 싱글 *&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbc1a1b748546fc5fee7f5a2eb2a422aaa998044" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Now &lt;code&gt;**&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) 이제 &lt;code&gt;**&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad4ca10d4f8dfe916ff3af0ee489a423135bb817" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BONUS:&lt;/strong&gt; From python 3.8 onward, one can use &lt;code&gt;/&lt;/code&gt; in function definition to enforce  positional only parameters. In the following example, parameters a and b are &lt;strong&gt;positional-only&lt;/strong&gt;, while c or d can be positional or keyword, and e or f are required to be keywords:</source>
          <target state="translated">&lt;strong&gt;보너스 :&lt;/strong&gt; 파이썬 3.8부터는 함수 정의에서 &lt;code&gt;/&lt;/code&gt; 를 사용하여 위치 만 매개 변수를 적용 할 수 있습니다. 다음 예에서 매개 변수 a 및 b는 &lt;strong&gt;위치 전용&lt;/strong&gt; 이며 c 또는 d는 위치 또는 키워드 일 수 있으며 e 또는 f는 키워드 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e5c53baf9a2776f02becbdc77ff91727f9331686" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9982a3d97a9090ed22f6a37e2cf0f2ae71f563db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b72348d158a4f2c8789aa3aca14e843c932286c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3: practical usage in decorators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 3 : 데코레이터에서의 실제 사용법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="610c569442d4ee811a21008a245c9213c6a6ed47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To accept any number of keyword arguments using &lt;code&gt;**kwargs&lt;/code&gt;:&lt;/strong&gt;&lt;code&gt;def foo(**kwargs): pass&lt;/code&gt;, here 'foo' accepts any number of keyword arguments, i. e., the following calls are valid &lt;code&gt;foo(name='Tom')&lt;/code&gt;, &lt;code&gt;foo(name='Tom', age=33)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;**kwargs&lt;/code&gt; :&lt;/strong&gt; &lt;code&gt;def foo(**kwargs): pass&lt;/code&gt; &lt;strong&gt;사용하여 여러 개의 키워드 인수를 허용하려면&lt;/strong&gt; 여기서 'foo'는 여러 개의 키워드 인수를 허용합니다. 즉, 다음 호출은 유효한 &lt;code&gt;foo(name='Tom')&lt;/code&gt; , &lt;code&gt;foo(name='Tom', age=33)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b288f38f2636ab753bb7bef6bd186943d14ecacc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To accept any number of positional and keyword arguments using &lt;code&gt;*args, **kwargs&lt;/code&gt;:&lt;/strong&gt;&lt;code&gt;def foo(*args, **kwargs): pass&lt;/code&gt;, here &lt;code&gt;foo&lt;/code&gt; accepts any number of positional and keyword arguments, i. e., the following calls are valid &lt;code&gt;foo(1,name='Tom')&lt;/code&gt;, &lt;code&gt;foo(1, 'bar', name='Tom', age=33)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;*args, **kwargs&lt;/code&gt; 사용하여 여러 위치 및 키워드 인수를 허용하려면 ** kwargs :&lt;/strong&gt; &lt;code&gt;def foo(*args, **kwargs): pass&lt;/code&gt; , 여기서 &lt;code&gt;foo&lt;/code&gt; 는 여러 위치 및 키워드 인수를 허용합니다. 즉, 다음 호출은 유효한 &lt;code&gt;foo(1,name='Tom')&lt;/code&gt; , &lt;code&gt;foo(1, 'bar', name='Tom', age=33)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdbf64b072553f800b4d1528b6368138ca2c56ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To accept any number of positional arguments using &lt;code&gt;*args&lt;/code&gt;:&lt;/strong&gt;&lt;code&gt;def foo(*args): pass&lt;/code&gt;, here &lt;code&gt;foo&lt;/code&gt; accepts any number of positional arguments, i. e., the following calls are valid &lt;code&gt;foo(1)&lt;/code&gt;, &lt;code&gt;foo(1, 'bar')&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;*args&lt;/code&gt; :&lt;/strong&gt; &lt;code&gt;def foo(*args): pass&lt;/code&gt; &lt;strong&gt;사용하여 여러 개의 위치 인수를 허용하려면&lt;/strong&gt; 여기에서 &lt;code&gt;foo&lt;/code&gt; 는 여러 개의 위치 인수를 허용합니다. 즉, 다음 호출은 유효한 &lt;code&gt;foo(1)&lt;/code&gt; , &lt;code&gt;foo(1, 'bar')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d249b30f21813b362e014d115b40c5bf792a281e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To enforce keyword only arguments using &lt;code&gt;*&lt;/code&gt;:&lt;/strong&gt;&lt;code&gt;def foo(pos1, pos2, *, kwarg1): pass&lt;/code&gt;, here &lt;code&gt;*&lt;/code&gt; means that foo only accept keyword arguments after pos2, hence &lt;code&gt;foo(1, 2, 3)&lt;/code&gt; raises TypeError but &lt;code&gt;foo(1, 2, kwarg1=3)&lt;/code&gt; is ok.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;*&lt;/code&gt; :&lt;/strong&gt; &lt;code&gt;def foo(pos1, pos2, *, kwarg1): pass&lt;/code&gt; , here &lt;code&gt;*&lt;/code&gt; 를 &lt;strong&gt;사용하여 키워드 만 인수를 적용하려면&lt;/strong&gt; foo는 pos2 뒤에 키워드 인수 만 허용하므로 &lt;code&gt;foo(1, 2, 3)&lt;/code&gt; 은 TypeError를 발생 시키지만 &lt;code&gt;foo(1, 2, kwarg1=3)&lt;/code&gt; 은 정상 입니다.</target>
        </trans-unit>
        <trans-unit id="8b0981f8cf0aa7145101e76ca36408f9c0a5506c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To express no further interest in more keyword arguments using &lt;code&gt;\**_&lt;/code&gt; (Note: this is a convention only):&lt;/strong&gt;&lt;code&gt;def foo(bar, baz, **_): pass&lt;/code&gt; means (by convention) &lt;code&gt;foo&lt;/code&gt; only uses &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; arguments in its working and will ignore others.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;\**_&lt;/code&gt; 사용하여 더 많은 키워드 인수에 더 이상 관심을 나타내지 않으려면 (참고 : 이것은 규칙에 불과합니다) :&lt;/strong&gt; &lt;code&gt;def foo(bar, baz, **_): pass&lt;/code&gt; 는 (규칙에 따라) &lt;code&gt;foo&lt;/code&gt; 는 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 인수 만 사용 합니다 . 그것은 작동하고 다른 사람들을 무시할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ab830ff0e82e8ba04ae92cec214286e4c980ac6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To express no further interest in more positional arguments using &lt;code&gt;*_&lt;/code&gt; (Note: this is a convention only):&lt;/strong&gt;&lt;code&gt;def foo(bar, baz, *_): pass&lt;/code&gt; means (by convention) &lt;code&gt;foo&lt;/code&gt; only uses &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; arguments in its working and will ignore others.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;*_&lt;/code&gt; 를 사용하여 더 많은 위치 인수에 더 이상 관심을 나타내지 않으려면 (참고 : 이것은 규칙에 불과합니다) :&lt;/strong&gt; &lt;code&gt;def foo(bar, baz, *_): pass&lt;/code&gt; 는 (규칙에 따라) &lt;code&gt;foo&lt;/code&gt; 는 작업에서 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 인수 만 사용 합니다. 다른 사람을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5e4d39811d8cee940c5d59a19b14f749dcb48295" translate="yes" xml:space="preserve">
          <source>A good example of using both in a function is:</source>
          <target state="translated">함수에서 둘 다 사용하는 좋은 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a298513579e35207d98c0815b66416f3f97b4698" translate="yes" xml:space="preserve">
          <source>A subclass can then be</source>
          <target state="translated">그러면 서브 클래스는</target>
        </trans-unit>
        <trans-unit id="62bf8fc9bc68216425b83b033a2d2bd97805418e" translate="yes" xml:space="preserve">
          <source>Again, more simply, here we require &lt;code&gt;kwarg&lt;/code&gt; to be given by name, not positionally:</source>
          <target state="translated">다시 말하면, 여기서 간단히 &lt;code&gt;kwarg&lt;/code&gt; 가 위치가 아닌 이름으로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="809e68b98d39b103a32103257a2b244cf31ca467" translate="yes" xml:space="preserve">
          <source>Also Python 3 adds new semantic (refer &lt;a href=&quot;https://www.python.org/dev/peps/pep-3102/&quot;&gt;PEP 3102&lt;/a&gt;):</source>
          <target state="translated">또한 Python 3은 새로운 의미를 추가합니다 ( &lt;a href=&quot;https://www.python.org/dev/peps/pep-3102/&quot;&gt;PEP 3102&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="4c8e088035f2b1475516b7fc43ddabb9edcbe3ba" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;*&lt;/code&gt; can be used by itself  to indicate that keyword only arguments follow, without allowing for unlimited positional arguments.</source>
          <target state="translated">또한 &lt;code&gt;*&lt;/code&gt; 를 사용하면 무제한 위치 인수를 허용하지 않고 키워드 만 인수 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="6a6f5c8171b3aff6eb567735beb28045eb8b3581" translate="yes" xml:space="preserve">
          <source>Also, a subclass with a new attribute which makes sense only to that subclass instance can call the Base class &lt;code&gt;__init__&lt;/code&gt; to offload the attributes setting.
This is done through *args and **kwargs. kwargs mainly used so that code is readable using named arguments. For example,</source>
          <target state="translated">또한 해당 서브 클래스 인스턴스에만 해당되는 새로운 속성을 가진 서브 클래스는 기본 클래스 &lt;code&gt;__init__&lt;/code&gt; 를 호출하여 속성 설정을 오프로드 할 수 있습니다. 이것은 * args 및 ** kwargs를 통해 수행됩니다. kwargs는 주로 명명 된 인수를 사용하여 코드를 읽을 수 있도록 주로 사용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="941017aafd6ce8752031e7a86c40872c1d44c7ad" translate="yes" xml:space="preserve">
          <source>An example from Python3 Document</source>
          <target state="translated">Python3 문서의 예</target>
        </trans-unit>
        <trans-unit id="f728b4c46940ef4939aedd7c78d82235855c9e4f" translate="yes" xml:space="preserve">
          <source>And by factoring out our code, which &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; allows us to do, we reduce lines of code, improve readability and maintainability, and have sole canonical locations for the logic in our program. If we need to change any part of this structure, we have one place in which to make each change.</source>
          <target state="translated">그리고 &lt;code&gt;*args&lt;/code&gt; 와 &lt;code&gt;**kwargs&lt;/code&gt; 로 우리가 할 수있는 코드를 고려하여 코드 줄을 줄이고, 가독성과 유지 관리 성을 향상 시키며, 프로그램의 논리를위한 유일한 표준 위치를 갖습니다. 이 구조의 일부를 변경해야 할 경우 각 변경을 수행 할 수있는 한 곳이 있습니다.</target>
        </trans-unit>
        <trans-unit id="be56e527c4927fc931b3d869b5999e5e9411b330" translate="yes" xml:space="preserve">
          <source>And now every wrapped function can be written much more succinctly, as we've factored out the redundancy:</source>
          <target state="translated">이제 중복성을 고려하여 모든 랩핑 된 함수를 훨씬 간결하게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="272a5867ff3c6c36ec58af2ec1adc2e2bdae6b60" translate="yes" xml:space="preserve">
          <source>And we can no longer accept unlimited positional arguments because we don't have &lt;code&gt;*args*&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;*args*&lt;/code&gt; 가 없으므로 더 이상 무제한 위치 인수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b07a246fb1c6724bf5bb8d0fd6c30ceab979dfd" translate="yes" xml:space="preserve">
          <source>Another usage of the &lt;code&gt;*l&lt;/code&gt; idiom is to &lt;strong&gt;unpack argument lists&lt;/strong&gt; when calling a function.</source>
          <target state="translated">&lt;code&gt;*l&lt;/code&gt; 관용구의 다른 사용법은 함수를 호출 할 때 &lt;strong&gt;인수 목록의 압축&lt;/strong&gt; 을 &lt;strong&gt;푸는&lt;/strong&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="a56026bb3260c8f7cdf5974b41089feb98cd65e7" translate="yes" xml:space="preserve">
          <source>As another example, we can use dict expansion in &lt;code&gt;str.format&lt;/code&gt;:</source>
          <target state="translated">또 다른 예로 &lt;code&gt;str.format&lt;/code&gt; 에서 dict 확장을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9506ad8d7ec60bc7b5829a999c8ceb09f4d0fb8" translate="yes" xml:space="preserve">
          <source>Basically, any number of &lt;strong&gt;positional arguments&lt;/strong&gt; can use *args and any &lt;strong&gt;named arguments&lt;/strong&gt; (or kwargs aka keyword arguments) can use **kwargs.</source>
          <target state="translated">기본적으로 임의의 수의 &lt;strong&gt;위치 인수&lt;/strong&gt; 는 * args를 사용할 수 있으며 &lt;strong&gt;명명 된 인수&lt;/strong&gt; (또는 키워드 인수 인 kwargs)는 ** kwargs를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="193b10038bc8a0af892c8f2e776952cf5897379c" translate="yes" xml:space="preserve">
          <source>Below are 6 different use cases for &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; in python programming:</source>
          <target state="translated">다음은 파이썬 프로그래밍에서 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;**&lt;/code&gt; 의 6 가지 사용 사례입니다.</target>
        </trans-unit>
        <trans-unit id="58a0baf8c6804e8201dd4d22f25df94546e28974" translate="yes" xml:space="preserve">
          <source>Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:</source>
          <target state="translated">두 관용구를 일반 인수와 함께 사용하여 고정 및 일부 가변 인수 세트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f3f07a76c207ae0c4904e706b58ba513add5c23" translate="yes" xml:space="preserve">
          <source>Building on nickd's &lt;a href=&quot;https://stackoverflow.com/a/36911/8588359&quot;&gt;answer&lt;/a&gt;...</source>
          <target state="translated">nickd의 &lt;a href=&quot;https://stackoverflow.com/a/36911/8588359&quot;&gt;답변&lt;/a&gt; 을 바탕으로 ...</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="292f60f275382399afa74120ffd27ed50a5e4820" translate="yes" xml:space="preserve">
          <source>Defining Functions</source>
          <target state="translated">함수 정의</target>
        </trans-unit>
        <trans-unit id="d3520f614d39ec8a767708415cb67124ef323ade" translate="yes" xml:space="preserve">
          <source>Expansion, Passing any number of arguments</source>
          <target state="translated">여러 인수를 전달하여 확장</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="14f3e8fd51b161882e6b5aa2d0b75cf99f633ba9" translate="yes" xml:space="preserve">
          <source>For example, Python 2's xrange does not explicitly expect &lt;code&gt;*args&lt;/code&gt;, but since it takes 3 integers as arguments:</source>
          <target state="translated">예를 들어, 파이썬 2의 xrange는 명시 적으로 &lt;code&gt;*args&lt;/code&gt; 를 기대하지 않지만 3 개의 정수를 인수로 사용하기 때문에 :</target>
        </trans-unit>
        <trans-unit id="7af97b435f13f14645d917b304a83fcd1be73671" translate="yes" xml:space="preserve">
          <source>For example, the syntax for implementing &lt;strong&gt;varargs&lt;/strong&gt; in Java as follows:</source>
          <target state="translated">예를 들어, Java에서 &lt;strong&gt;varargs&lt;/strong&gt; 를 구현하기위한 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="493e6e7861151089d2bbb7ac7589c01c800e24d0" translate="yes" xml:space="preserve">
          <source>For those of you who learn by examples!</source>
          <target state="translated">예를 통해 배우는 사람들을 위해!</target>
        </trans-unit>
        <trans-unit id="7ba7aff8700fed3c1874a29167ef370d01a8a7b7" translate="yes" xml:space="preserve">
          <source>From the Python documentation:</source>
          <target state="translated">파이썬 문서에서 :</target>
        </trans-unit>
        <trans-unit id="e620618aef9f68baf0a6922ef26c1ee6d6334c80" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;kwarg2&lt;/code&gt; again must be an explicitly named, keyword argument:</source>
          <target state="translated">여기서 &lt;code&gt;kwarg2&lt;/code&gt; 는 다시 명시 적으로 명명 된 키워드 인수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="72539057bd10b616a696bb7c198c6fa4c5f6db94" translate="yes" xml:space="preserve">
          <source>I want to give an example which others haven't  mentioned</source>
          <target state="translated">다른 사람들이 언급하지 않은 예를 드리고 싶습니다</target>
        </trans-unit>
        <trans-unit id="f0eb94c0b755223ff3d41798dad7d9d87841455e" translate="yes" xml:space="preserve">
          <source>If any keyword argument does not correspond to a formal parameter name, a TypeError exception is raised, unless a formal parameter using the syntax &quot;**identifier&quot; is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments.</source>
          <target state="translated">키워드 인수가 공식 매개 변수 이름과 일치하지 않으면 &quot;** identifier&quot;구문을 사용하는 공식 매개 변수가 없으면 TypeError 예외가 발생합니다. 이 경우 해당 형식 매개 변수는 초과 키워드 인수 (키워드로 키워드 및 인수 값을 해당 값으로 사용)를 포함하는 사전 또는 초과 키워드 인수가없는 경우 (새) 빈 사전을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a4500c45138c4750180a1f2aeda2a22aab649db8" translate="yes" xml:space="preserve">
          <source>If applicable, &lt;code&gt;**&lt;/code&gt; must come after &lt;code&gt;*&lt;/code&gt;, always.</source>
          <target state="translated">해당되는 경우 &lt;code&gt;**&lt;/code&gt; 는 항상 &lt;code&gt;*&lt;/code&gt; 뒤에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="efc74abb309d2f65c1476683ef984eb8eebc2d17" translate="yes" xml:space="preserve">
          <source>If there are more positional arguments than there are formal parameter slots, a TypeError exception is raised, unless a formal parameter using the syntax &quot;*identifier&quot; is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments).</source>
          <target state="translated">형식 매개 변수 슬롯보다 위치 인수가 더 많은 경우 &quot;* identifier&quot;구문을 사용하는 형식 매개 변수가 없으면 TypeError 예외가 발생합니다. 이 경우, 형식 매개 변수는 초과 위치 인수를 포함하는 튜플을 수신합니다 (또는 초과 위치 인수가없는 경우 빈 튜플).</target>
        </trans-unit>
        <trans-unit id="66c49fe41a858b7f28cff7b597d5e664961e5e4d" translate="yes" xml:space="preserve">
          <source>In Python 3 it is possible to use &lt;code&gt;*l&lt;/code&gt; on the left side of an assignment (&lt;a href=&quot;http://www.python.org/dev/peps/pep-3132/&quot;&gt;Extended Iterable Unpacking&lt;/a&gt;), though it gives a list instead of a tuple in this context:</source>
          <target state="translated">파이썬 3에서는 할당의 왼쪽에서 &lt;code&gt;*l&lt;/code&gt; 을 사용할 수 있지만 ( &lt;a href=&quot;http://www.python.org/dev/peps/pep-3132/&quot;&gt;Extended Iterable Unpacking&lt;/a&gt; )이 컨텍스트에서 튜플 대신 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8691aef17626aa432a214ae58f6b125acef8b90e" translate="yes" xml:space="preserve">
          <source>In Python 3.5, you can also use this syntax in &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, and &lt;code&gt;set&lt;/code&gt; displays (also sometimes called literals). See &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0448/&quot;&gt;PEP 488: Additional Unpacking Generalizations&lt;/a&gt;.</source>
          <target state="translated">Python 3.5에서는 &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;tuple&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; display (때로는 리터럴이라고도 함)에서이 구문을 사용할 수 있습니다. &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0448/&quot;&gt;PEP 488 : 추가 포장 풀기 일반화를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb835208e8f00e81b3abf80c30e2f9a12d147dfa" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;function call&lt;/strong&gt; the '*' &lt;strong&gt;unpacks&lt;/strong&gt; data structure of tuple or list into positional or keyword arguments to be received by function definition.</source>
          <target state="translated">&lt;strong&gt;함수 호출&lt;/strong&gt; 에서 '*'는 튜플 또는 목록의 데이터 구조를 함수 정의에 의해 수신 될 위치 또는 키워드 인수로 &lt;strong&gt;압축 해제&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6675a7f7c18173022240f8345a27606cfd7103d2" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;function call&lt;/strong&gt; the '**' &lt;strong&gt;unpacks&lt;/strong&gt; data structure of dictionary into positional or keyword arguments to be received by function definition.</source>
          <target state="translated">&lt;strong&gt;함수 호출&lt;/strong&gt; 에서 '**'는 사전의 데이터 구조를 함수 정의가 수신 할 위치 또는 키워드 인수로 &lt;strong&gt;압축 해제&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="983cd25b8c190befd85158d737e65c788cae99aa" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;function definition&lt;/strong&gt; the '*' &lt;strong&gt;packs&lt;/strong&gt; positional arguments into a tuple.</source>
          <target state="translated">&lt;strong&gt;함수 정의&lt;/strong&gt; 에서 '*' &lt;strong&gt;는&lt;/strong&gt; 위치 인수를 튜플에 묶습니다.</target>
        </trans-unit>
        <trans-unit id="8242ded2b6c77202b6aba67403b98d26e3b9f8a7" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;function definition&lt;/strong&gt; the '**' &lt;strong&gt;packs&lt;/strong&gt; keyword arguments into a dictionary.</source>
          <target state="translated">&lt;strong&gt;함수 정의&lt;/strong&gt; 에서 '**' &lt;strong&gt;는&lt;/strong&gt; 키워드 인수를 사전에 &lt;strong&gt;압축&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="58735475502a63f86aa44994b9acb298f79302cd" translate="yes" xml:space="preserve">
          <source>In addition to function calls, *args and **kwargs are useful in class hierarchies and also avoid having to write &lt;code&gt;__init__&lt;/code&gt; method in Python. Similar usage can seen in frameworks like Django code.</source>
          <target state="translated">함수 호출 외에도 * args 및 ** kwargs는 클래스 계층에서 유용하며 Python에서 &lt;code&gt;__init__&lt;/code&gt; 메서드를 작성하지 않아도됩니다. Django 코드와 같은 프레임 워크에서도 비슷한 사용법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb34dbc12b27d5ff2442c4a9c7fb3c9d138f554a" translate="yes" xml:space="preserve">
          <source>In addition to the answers in this thread, here is another detail that was not mentioned elsewhere. This expands on the &lt;a href=&quot;https://stackoverflow.com/a/47580283/42223&quot;&gt;answer by Brad Solomon&lt;/a&gt;</source>
          <target state="translated">이 스레드의 답변 외에도 다른 곳에서는 언급되지 않은 또 다른 세부 사항이 있습니다. 이것은 &lt;a href=&quot;https://stackoverflow.com/a/47580283/42223&quot;&gt;Brad Solomon&lt;/a&gt; 의 답변으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="29d133b1e0b3cf691330c1265f0ade4596a9ef8c" translate="yes" xml:space="preserve">
          <source>In function &lt;strong&gt;definition&lt;/strong&gt; The '**' operator packs the received arguments into a dictionary.</source>
          <target state="translated">함수 &lt;strong&gt;정의&lt;/strong&gt; 에서 '**'연산자는 수신 된 인수를 사전에 압축합니다.</target>
        </trans-unit>
        <trans-unit id="28cb4f66a57b75adf03d90ef92f1211c290e7b52" translate="yes" xml:space="preserve">
          <source>In function &lt;strong&gt;definition&lt;/strong&gt; the '*' operator packs the received arguments into a tuple.</source>
          <target state="translated">함수 &lt;strong&gt;정의&lt;/strong&gt; 에서 '*'연산자는 수신 된 인수를 튜플에 압축합니다.</target>
        </trans-unit>
        <trans-unit id="841557c0934b1382a8328ac98e096ab23880171f" translate="yes" xml:space="preserve">
          <source>In the following method definitions, what does the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; do for &lt;code&gt;param2&lt;/code&gt;?</source>
          <target state="translated">다음 메소드 정의에서 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;**&lt;/code&gt; 는 &lt;code&gt;param2&lt;/code&gt; 에 대해 무엇을 수행합니까?</target>
        </trans-unit>
        <trans-unit id="31c9310dcc0195a2b23932b6507e5eb5f7d2c26a" translate="yes" xml:space="preserve">
          <source>In this example, we see that if we try to pass &lt;code&gt;kwarg&lt;/code&gt; positionally, we get an error:</source>
          <target state="translated">이 예에서 &lt;code&gt;kwarg&lt;/code&gt; 를 위치 적으로 전달하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf7edb843a9194f38e1949d77a78828942274ba5" translate="yes" xml:space="preserve">
          <source>It also allows multiple iterables to be unpacked in a single function call.</source>
          <target state="translated">또한 하나의 함수 호출로 여러 iterable을 압축 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4035e8005d566ecb14be86fc663eabe8f865894f" translate="yes" xml:space="preserve">
          <source>It is also possible to use this the other way around:</source>
          <target state="translated">다른 방법으로 이것을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c05cd1bca9e7cae9cdcb250882a9c06c018ab02d" translate="yes" xml:space="preserve">
          <source>It packs arguments passed to the function into &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;dict&lt;/code&gt; respectively inside the function body. When you define a function signature like this:</source>
          <target state="translated">함수에 전달 된 인수를 함수 본문 내에서 각각 &lt;code&gt;list&lt;/code&gt; 과 &lt;code&gt;dict&lt;/code&gt; 로 묶습니다 . 다음과 같이 함수 서명을 정의 할 때 :</target>
        </trans-unit>
        <trans-unit id="dfb09dacdeab7cfd3c08651d82a2887a40500007" translate="yes" xml:space="preserve">
          <source>It's also worth noting that you can use &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; when calling functions as well. This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary. For example, if you have the following function:</source>
          <target state="translated">함수를 호출 할 때 &lt;code&gt;*&lt;/code&gt; 와 &lt;code&gt;**&lt;/code&gt; 를 사용할 수 있다는 점도 주목할 가치가 있습니다. 리스트 / 튜플 또는 사전을 사용하여 여러 인수를 함수에 직접 전달할 수있는 바로 가기입니다. 예를 들어, 다음 기능이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="7901e31b6d26720b22aaec3f1116bd71366e50e7" translate="yes" xml:space="preserve">
          <source>Let us first understand what are positional arguments and keyword arguments.
Below is an example of function definition with &lt;strong&gt;Positional arguments.&lt;/strong&gt;</source>
          <target state="translated">위치 인수와 키워드 인수가 무엇인지 먼저 이해합시다. 아래는 &lt;strong&gt;위치 인수를&lt;/strong&gt; 사용한 함수 정의의 예입니다 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4b23038a2cc7c7d11a51aa8537b685f687d5820" translate="yes" xml:space="preserve">
          <source>Let us get straight to an example and then discuss it.</source>
          <target state="translated">우리가 직접 예를 들어서 논의 해 보자.</target>
        </trans-unit>
        <trans-unit id="87e52c50e2e0e5058b445b9067a0a72b6d2cd8d7" translate="yes" xml:space="preserve">
          <source>Let us show this by defining a function that takes two normal variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and can accept more arguments as &lt;code&gt;myArgs&lt;/code&gt;, and can accept even more arguments as &lt;code&gt;myKW&lt;/code&gt;. Later, we will show how to feed &lt;code&gt;y&lt;/code&gt; using &lt;code&gt;myArgDict&lt;/code&gt;.</source>
          <target state="translated">두 개의 정규 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 를 취하고 더 많은 인수를 &lt;code&gt;myArgs&lt;/code&gt; 로 허용하고 더 많은 인수를 myKW 로 허용하는 함수를 정의하여이를 보여 &lt;code&gt;myKW&lt;/code&gt; . 나중에 &lt;code&gt;myArgDict&lt;/code&gt; 를 사용하여 &lt;code&gt;y&lt;/code&gt; 를 공급하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bb41e5bdd359dec6da0c1f298c3c0b43cc86932e" translate="yes" xml:space="preserve">
          <source>Let's call this function with &lt;code&gt;foo(1, 2, 3, 4, e=5, f=6, g=7)&lt;/code&gt;</source>
          <target state="translated">이 함수를 &lt;code&gt;foo(1, 2, 3, 4, e=5, f=6, g=7)&lt;/code&gt; 호출 해 봅시다</target>
        </trans-unit>
        <trans-unit id="a245374ac3ff8ea606f1d3b17466eb8e31c565f7" translate="yes" xml:space="preserve">
          <source>New in Python 3: Defining functions with keyword only arguments</source>
          <target state="translated">Python 3의 새로운 기능 : 키워드 전용 인수로 함수 정의</target>
        </trans-unit>
        <trans-unit id="91a5336d571b1fe3c1f7791c93e16e9bd59c5ada" translate="yes" xml:space="preserve">
          <source>Non-optional argument assignment happens first.</source>
          <target state="translated">비 선택적 인수 할당이 먼저 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91448b75d21315f518a18d8fc42a1ce53bf91a2a" translate="yes" xml:space="preserve">
          <source>Note: The keys in &lt;code&gt;mydict&lt;/code&gt; have to be named exactly like the parameters of function &lt;code&gt;foo&lt;/code&gt;. Otherwise it will throw a &lt;code&gt;TypeError&lt;/code&gt;:</source>
          <target state="translated">참고 : &lt;code&gt;mydict&lt;/code&gt; 의 키 이름은 &lt;code&gt;foo&lt;/code&gt; 함수의 매개 변수와 정확히 동일해야합니다. 그렇지 않으면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="24ebde1388a779e5d0c30351caa8f0ace467cf94" translate="yes" xml:space="preserve">
          <source>Now let us see an example of '**' used in function definition:</source>
          <target state="translated">이제 함수 정의에 사용 된 '**'의 예를 보자.</target>
        </trans-unit>
        <trans-unit id="b619a1ead86d849e65e82eda63f8fe990eca62f9" translate="yes" xml:space="preserve">
          <source>Now let us study an example of function definition with &lt;strong&gt;keyword arguments&lt;/strong&gt;:</source>
          <target state="translated">이제 &lt;strong&gt;키워드 인수를 사용&lt;/strong&gt; 하여 함수 정의의 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4a2039738304b820b9d7fa888013e4fe9300e160" translate="yes" xml:space="preserve">
          <source>Now let us study the '*' operator and '**' operator.</source>
          <target state="translated">이제 '*'연산자와 '**'연산자를 연구하겠습니다.</target>
        </trans-unit>
        <trans-unit id="2bbdf3ea245d185075329f6ce6fb3db2e270559b" translate="yes" xml:space="preserve">
          <source>Now let us study the '*' operator use in &lt;strong&gt;function definition&lt;/strong&gt;.
Example:</source>
          <target state="translated">이제 &lt;strong&gt;함수 정의&lt;/strong&gt; 에서 '*'연산자 사용을 연구하자. 예:</target>
        </trans-unit>
        <trans-unit id="ab3d3532798f22ac8cd363026830e3bc22bd4736" translate="yes" xml:space="preserve">
          <source>OK, so maybe we're not seeing the utility yet. So imagine you have several functions with redundant code before and/or after the differentiating code. The following named functions are just pseudo-code for illustrative purposes.</source>
          <target state="translated">좋아, 아마도 우리는 유틸리티를 아직 보지 못했을 것입니다. 따라서 차별화 코드 전후에 중복 코드가있는 여러 기능이 있다고 상상해보십시오. 다음의 명명 된 함수는 설명을위한 의사 코드 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="b1586a28b4adf696fa94b895eeaff2889a1ab757" translate="yes" xml:space="preserve">
          <source>Please note these operators can be used in 2 areas:</source>
          <target state="translated">이 연산자는 두 가지 영역에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6b4ce72d3b7c0e1f8d8a432ab3632aac2b48700" translate="yes" xml:space="preserve">
          <source>Python 2 compatible demos</source>
          <target state="translated">파이썬 2 호환 데모</target>
        </trans-unit>
        <trans-unit id="56fce8c175adcf994a88eaf001f3be01c032ad86" translate="yes" xml:space="preserve">
          <source>Quick Example</source>
          <target state="translated">빠른 예</target>
        </trans-unit>
        <trans-unit id="ae5980edbf86fe41fa4f231cd5375aec2949aed3" translate="yes" xml:space="preserve">
          <source>Relatedly: uses for the star/splat operators have been &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;expanded&lt;/a&gt; in Python 3</source>
          <target state="translated">관련 : 스타 / 스 플랫 연산자의 사용이 Python 3에서 &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations&quot;&gt;확장&lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f5cf0ceedb335135a295394a6abb33e7369b6ed4" translate="yes" xml:space="preserve">
          <source>So remember</source>
          <target state="translated">그러니 기억해</target>
        </trans-unit>
        <trans-unit id="7727bb5c748719530e5365f60dc1345a08cbbc5e" translate="yes" xml:space="preserve">
          <source>So remember:</source>
          <target state="translated">기억하십시오 :</target>
        </trans-unit>
        <trans-unit id="4daa26ea0c8c2263bb963c398bb22881ee6e987a" translate="yes" xml:space="preserve">
          <source>So this is a function definition with positional arguments.
You can call it with keyword/named arguments as well:</source>
          <target state="translated">이것은 위치 인자를 가진 함수 정의입니다. 키워드 / 명명 된 인수로 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f4462555ad3a05048aab639fb7bffc0533da2ae" translate="yes" xml:space="preserve">
          <source>So we now know function definitions with positional as well as keyword arguments.</source>
          <target state="translated">이제 우리는 키워드 인수뿐만 아니라 위치와 함수 정의를 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c070a54b1f4117ae25ca6094d330ad2f48f23e5" translate="yes" xml:space="preserve">
          <source>Such function accepts only 3 positional arguments, and everything after &lt;code&gt;*&lt;/code&gt; can only be passed as keyword arguments.</source>
          <target state="translated">이러한 함수는 3 개의 위치 인수 만 허용하며 &lt;code&gt;*&lt;/code&gt; 뒤의 모든 항목은 키워드 인수로만 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="32602316336694ff9b888c208e8e51d3fc544690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**kwargs&lt;/code&gt; will give you all 
&lt;strong&gt;keyword arguments&lt;/strong&gt; except for those corresponding to a formal parameter as a dictionary.</source>
          <target state="translated">&lt;code&gt;**kwargs&lt;/code&gt; 는 사전 매개 변수에 해당하는 &lt;strong&gt;키워드 인수를&lt;/strong&gt; 제외한 모든 &lt;strong&gt;키워드 인수를&lt;/strong&gt; 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cf63e04524574cf4580aa2c7181367ee304b6f02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; is a common idiom to allow arbitrary number of arguments to functions as described in the section &lt;a href=&quot;http://docs.python.org/dev/tutorial/controlflow.html#more-on-defining-functions&quot;&gt;more on defining functions&lt;/a&gt; in the Python documentation.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 및 &lt;code&gt;**kwargs&lt;/code&gt; 는 Python 문서에서 &lt;a href=&quot;http://docs.python.org/dev/tutorial/controlflow.html#more-on-defining-functions&quot;&gt;함수 정의&lt;/a&gt; 에 대한 추가 절에 설명 된대로 함수에 임의의 수의 인수를 허용하는 일반적인 관용구입니다.</target>
        </trans-unit>
        <trans-unit id="3712da16870cb2acecd53004226f6aed43506f17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*args&lt;/code&gt; will give you all function parameters &lt;a href=&quot;https://docs.python.org/dev/tutorial/controlflow.html#arbitrary-argument-lists&quot;&gt;as a tuple&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 는 모든 함수 매개 변수 &lt;a href=&quot;https://docs.python.org/dev/tutorial/controlflow.html#arbitrary-argument-lists&quot;&gt;를 튜플로 제공합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93b505fb3abc4a37f6c7efe50f5052207c2aa74a" translate="yes" xml:space="preserve">
          <source>The complete code is &lt;a href=&quot;http://harisankar-krishnaswamy.blogspot.sg/2015/08/using-args-and-kwargs-python-code-post.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">완전한 코드는 &lt;a href=&quot;http://harisankar-krishnaswamy.blogspot.sg/2015/08/using-args-and-kwargs-python-code-post.html&quot;&gt;여기에 있습니다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a896ce94825ba4df77e4618c23aa21e3591103c9" translate="yes" xml:space="preserve">
          <source>The double ** means there can be any number of extra named parameters. &lt;code&gt;bar()&lt;/code&gt; can be invoked like &lt;code&gt;bar(1, a=2, b=3)&lt;/code&gt;. In the body of bar() param2 is a dictionary containing {'a':2, 'b':3 }</source>
          <target state="translated">이중 **은 추가로 명명 된 매개 변수가 여러 개있을 수 있음을 의미합니다. &lt;code&gt;bar()&lt;/code&gt; 는 &lt;code&gt;bar(1, a=2, b=3)&lt;/code&gt; 과 같이 호출 할 수 있습니다. bar ()의 본문에서 param2는 { 'a': 2, 'b': 3}을 포함하는 사전입니다.</target>
        </trans-unit>
        <trans-unit id="504eb92669c468e236a773b315b925eb19aaf5ee" translate="yes" xml:space="preserve">
          <source>The following function describes how they can be used, and demonstrates behavior. Note the named &lt;code&gt;b&lt;/code&gt; argument will be consumed by the second positional argument before :</source>
          <target state="translated">다음 함수는 사용법을 설명하고 동작을 보여줍니다. 명명 된 &lt;code&gt;b&lt;/code&gt; 인수는 다음의 두 번째 위치 인수에 의해 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="e443aae8785e85d922c3fa35db5f6379233330af" translate="yes" xml:space="preserve">
          <source>The function recieving the parameters does not have to know that they are being expanded.</source>
          <target state="translated">매개 변수를받는 기능은 확장되고 있음을 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fafee0b6f78ca93506971dffb50240f2686eae25" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;**&lt;/code&gt; is to give you the ability to feed a function's arguments by providing a dictionary (e.g. &lt;code&gt;f(**{'x' : 1, 'y' : 2})&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 의 목적은 사전을 제공하여 함수의 인수를 제공하는 기능을 제공하는 것입니다 (예 : &lt;code&gt;f(**{'x' : 1, 'y' : 2})&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2f5a6a43eafba8c82a9d72f0ede407675439bd2a" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;*&lt;/code&gt;  is to give you the ability to define a function that can take an arbitrary number of arguments provided as a list (e.g. &lt;code&gt;f(*myList)&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 의 목적은리스트로 제공되는 임의의 수의 인수를 취할 수있는 함수를 정의하는 기능을 제공하는 것입니다 (예 : &lt;code&gt;f(*myList)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0540e6129858e4f8523a3a6fa9049a40a569a1e2" translate="yes" xml:space="preserve">
          <source>The single * means that there can be any number of extra positional arguments. &lt;code&gt;foo()&lt;/code&gt; can be invoked like &lt;code&gt;foo(1,2,3,4,5)&lt;/code&gt;. In the body of foo() param2 is a sequence containing 2-5.</source>
          <target state="translated">단일 *는 추가 위치 인수가 여러 개있을 수 있음을 의미합니다. &lt;code&gt;foo()&lt;/code&gt; 는 &lt;code&gt;foo(1,2,3,4,5)&lt;/code&gt; 와 같이 호출 할 수 있습니다. foo ()의 본문에서 param2는 2-5를 포함하는 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="2d1570fcc1afe648dd6fd1efa9f4eba37db798fb" translate="yes" xml:space="preserve">
          <source>The subclass then be instantiated as</source>
          <target state="translated">그런 다음 서브 클래스는 다음과 같이 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="7e318ae5502f2c6caa085e9130b7c26c1122e926" translate="yes" xml:space="preserve">
          <source>The use of '*' operator and '**' operator in &lt;strong&gt;function call.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;함수 호출&lt;/strong&gt; 에서 '*'연산자 및 '**'연산자 사용</target>
        </trans-unit>
        <trans-unit id="221ec3c13c3ff3139d5fa30b8bad1a628fef59e9" translate="yes" xml:space="preserve">
          <source>The zip() receives multiple iretable args, and return a generator.</source>
          <target state="translated">zip ()은 여러 개의 실행 가능한 인수를 수신하고 생성기를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a62bafe25d51ed5be42368872e804941b20a4a6e" translate="yes" xml:space="preserve">
          <source>They allow for &lt;strong&gt;functions to be defined to accept&lt;/strong&gt; and for &lt;strong&gt;users to pass&lt;/strong&gt; any number of arguments, positional (&lt;code&gt;*&lt;/code&gt;) and keyword (&lt;code&gt;**&lt;/code&gt;).</source>
          <target state="translated">이를 통해 &lt;strong&gt;함수가 수용되도록 정의 할 수&lt;/strong&gt; 있으며 &lt;strong&gt;사용자는&lt;/strong&gt; 위치 ( &lt;code&gt;*&lt;/code&gt; ) 및 키워드 ( &lt;code&gt;**&lt;/code&gt; ) 수의 인수 &lt;strong&gt;를 전달할&lt;/strong&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76e5ec318c3f4aae99285e9dc60f5a60d259a905" translate="yes" xml:space="preserve">
          <source>This also works in reverse, i.e. from the caller side. for example if you have a function defined as:</source>
          <target state="translated">이것은 역으로, 즉 발신자 측에서도 작동합니다. 예를 들어 다음과 같이 정의 된 함수가있는 경우</target>
        </trans-unit>
        <trans-unit id="f71bfb2e76b0ba5c8edbecd4ae4daf6a4102ad02" translate="yes" xml:space="preserve">
          <source>This example would help you remember &lt;code&gt;*args&lt;/code&gt;, &lt;code&gt;**kwargs&lt;/code&gt; and even &lt;code&gt;super&lt;/code&gt; and inheritance in Python at once.</source>
          <target state="translated">이 예제는 파이썬에서 &lt;code&gt;*args&lt;/code&gt; , &lt;code&gt;**kwargs&lt;/code&gt; 그리고 심지어 &lt;code&gt;super&lt;/code&gt; 및 상속을 기억하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="2e78a575536cd3c81799e8d59abbcc1aef7ff457" translate="yes" xml:space="preserve">
          <source>This is somewhat similar to what you can do with python &lt;code&gt;f-strings&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/questions/tagged/f-string&quot;&gt;f-string&lt;/a&gt; but with the added overhead of declaring a dict to hold the variables (f-string does not require a dict).</source>
          <target state="translated">이것은 파이썬 &lt;code&gt;f-strings&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/questions/tagged/f-string&quot;&gt;f-string으로&lt;/a&gt; 할 수있는 것과 다소 유사하지만 변수를 보유하도록 dict를 선언하는 오버 헤드가 추가됩니다 (f-string에는 dict가 필요하지 않음).</target>
        </trans-unit>
        <trans-unit id="e9f49a602092f2600ab4dbfbc225050cee771531" translate="yes" xml:space="preserve">
          <source>This really just serves to summarize Lorin Hochstein's &lt;a href=&quot;https://stackoverflow.com/a/36926/7954504&quot;&gt;answer&lt;/a&gt; but I find it helpful.</source>
          <target state="translated">이것은 실제로 Lorin Hochstein의 &lt;a href=&quot;https://stackoverflow.com/a/36926/7954504&quot;&gt;답변&lt;/a&gt; 을 요약하는 데 도움이되지만 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c41e617275ef98f70808b26e784db9772637feed" translate="yes" xml:space="preserve">
          <source>This table is handy for using &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; in function &lt;em&gt;construction&lt;/em&gt; and function &lt;em&gt;call&lt;/em&gt;:</source>
          <target state="translated">이 테이블은 함수 &lt;em&gt;구성&lt;/em&gt; 및 함수 &lt;em&gt;호출&lt;/em&gt; 에서 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;**&lt;/code&gt; 를 사용하는 데 편리합니다.</target>
        </trans-unit>
        <trans-unit id="d26fb807a328081eaceffc49cd97f7b17a9ac470" translate="yes" xml:space="preserve">
          <source>Unpacking with &lt;code&gt;**&lt;/code&gt; is also useful when using python &lt;code&gt;str.format&lt;/code&gt;.</source>
          <target state="translated">python &lt;code&gt;str.format&lt;/code&gt; 을 사용할 때 &lt;code&gt;**&lt;/code&gt; 로 압축을 풀 때도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="99fb84d8b321ffa9a9069c867daeb8f9d53c541c" translate="yes" xml:space="preserve">
          <source>Use with string formatting</source>
          <target state="translated">문자열 형식과 함께 사용</target>
        </trans-unit>
        <trans-unit id="4a799ab566a9451f574fb3da7249ae89668ffe3b" translate="yes" xml:space="preserve">
          <source>Used like the following:</source>
          <target state="translated">다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="43a00a174601ad173cf07207f8cd33994f1103d9" translate="yes" xml:space="preserve">
          <source>We can also call it using another function, into which we just provide &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">다른 함수를 사용하여 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eec1d477fb271bf52684fd29e0ae7094d81e0a4d" translate="yes" xml:space="preserve">
          <source>We can check the online help for the function's signature, with &lt;code&gt;help(foo)&lt;/code&gt;, which tells us</source>
          <target state="translated">&lt;code&gt;help(foo)&lt;/code&gt; 를 사용하여 함수의 서명에 대한 온라인 도움말을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="071466cc8ede79b9743ebb45f3b9307858ccd94e" translate="yes" xml:space="preserve">
          <source>We might be able to handle this differently, but we can certainly extract the redundancy with a decorator, and so our below example demonstrates how &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; can be very useful:</source>
          <target state="translated">우리는 이것을 다르게 처리 할 수 ​​있지만 데코레이터로 중복성을 확실히 추출 할 수 있으므로 아래 예제는 &lt;code&gt;*args&lt;/code&gt; 및 &lt;code&gt;**kwargs&lt;/code&gt; 가 매우 유용한 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b7ea4cbb24ea5b0d07e6f28ecfaf88c925dadd18" translate="yes" xml:space="preserve">
          <source>We must explicitly pass the &lt;code&gt;kwarg&lt;/code&gt; parameter as a keyword argument.</source>
          <target state="translated">&lt;code&gt;kwarg&lt;/code&gt; 매개 변수를 키워드 인수로 명시 적으로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="afb7cb9daf1c756ee48ed6afd251e0968bb9474f" translate="yes" xml:space="preserve">
          <source>We typically use these when we don't know what our function is going to receive or how many arguments we may be passing, and sometimes even when naming every variable separately would get very messy and redundant (but this is a case where usually explicit is better than implicit).</source>
          <target state="translated">우리는 일반적으로 함수가 무엇을 받거나 전달할 인수 수를 알지 못하는 경우에 사용하며 때로는 모든 변수를 개별적으로 명명하는 것이 매우 지저분하고 중복 될 수 있습니다 (그러나 일반적으로 명시 적 인 경우 암시 적보다 낫습니다).</target>
        </trans-unit>
        <trans-unit id="233bc8dee4817e4eae3ea779d6439f59b4f59bbb" translate="yes" xml:space="preserve">
          <source>What does ** (double star/asterisk) and * (star/asterisk) do for parameters</source>
          <target state="translated">매개 변수에 대해 ** (더블 스타 / 별표) 및 * (스타 / 별표)는 무엇을합니까</target>
        </trans-unit>
        <trans-unit id="043cce10c16f63cb0c473e49b9c9a719c0674492" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;**&lt;/code&gt; (double star) and &lt;code&gt;*&lt;/code&gt; (star) do for parameters</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; (더블 스타) 및 &lt;code&gt;*&lt;/code&gt; (스타)는 매개 변수에 대해 수행하는 작업</target>
        </trans-unit>
        <trans-unit id="8af1dddd6c2192a020edaa51d45191a8693034d0" translate="yes" xml:space="preserve">
          <source>Will produce:</source>
          <target state="translated">생산할 것이다 :</target>
        </trans-unit>
        <trans-unit id="1ed3fd9bd4c1f256dcc104023a64d45285ef0146" translate="yes" xml:space="preserve">
          <source>With the following code:</source>
          <target state="translated">다음 코드로</target>
        </trans-unit>
        <trans-unit id="89e91d292d7914d17c805c0dd69622e7e39268be" translate="yes" xml:space="preserve">
          <source>You can (and should) choose any appropriate name, but if the intention is for the arguments to be of non-specific semantics, &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; are standard names.</source>
          <target state="translated">적절한 이름을 선택할 수 있고 선택해야하지만 인수가 비특이적 의미론 인 경우 &lt;code&gt;args&lt;/code&gt; 및 &lt;code&gt;kwargs&lt;/code&gt; 는 표준 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c10ea9af188d5d91cbab26c0e813033c66126cd5" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; to pass in parameters from lists (or any iterable) and dicts (or any mapping), respectively.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 및 &lt;code&gt;**kwargs&lt;/code&gt; 를 사용하여 각각 목록 (또는 반복 가능) 및 dicts (또는 모든 맵핑)에서 매개 변수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b42ee187d69586d1f39155928626c35d1cde5fb8" translate="yes" xml:space="preserve">
          <source>You can call this function with positional arguments as well:</source>
          <target state="translated">위치 인수와 함께이 함수를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="277476897ef47b624210790858b6cdfcc04e5aa8" translate="yes" xml:space="preserve">
          <source>You can do things like:</source>
          <target state="translated">다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="080bdd4b11396c960350e4e97d2ff50dbf02b258" translate="yes" xml:space="preserve">
          <source>You can have &lt;a href=&quot;https://www.python.org/dev/peps/pep-3102/&quot;&gt;keyword only arguments&lt;/a&gt; after the &lt;code&gt;*args&lt;/code&gt; - for example, here, &lt;code&gt;kwarg2&lt;/code&gt; must be given as a keyword argument - not positionally:</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 다음에 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3102/&quot;&gt;키워드 만 인수를&lt;/a&gt; 가질 수 있습니다. 예를 들어, 여기서 &lt;code&gt;kwarg2&lt;/code&gt; 는 키워드 인수로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="794557036415543543af5f1912c1507e42924507" translate="yes" xml:space="preserve">
          <source>You cannot use a non-optional argument twice.</source>
          <target state="translated">비 선택적 인수는 두 번 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8be25461c64d172078a03a0ec37aabb6b3175e9f" translate="yes" xml:space="preserve">
          <source>a) &lt;strong&gt;function call&lt;/strong&gt;</source>
          <target state="translated">a) &lt;strong&gt;함수 호출&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b8ece01faa7de12cfc700e3749c548d91f9ccb9" translate="yes" xml:space="preserve">
          <source>b) &lt;strong&gt;function definition&lt;/strong&gt;</source>
          <target state="translated">b) &lt;strong&gt;기능 정의&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08311cc2119febe4e48dfcb0db0929fd8ae81d7e" translate="yes" xml:space="preserve">
          <source>it can be called with any number of arguments and keyword arguments. The non-keyword arguments get packed into a list called &lt;code&gt;args&lt;/code&gt; inside the the function body and the keyword arguments get packed into a dict called &lt;code&gt;kwds&lt;/code&gt; inside the function body.</source>
          <target state="translated">여러 개의 인수와 키워드 인수로 호출 할 수 있습니다. 키워드가 아닌 인수는 함수 본문 내에서 &lt;code&gt;args&lt;/code&gt; 라는 목록으로 압축되고 키워드 인수는 함수 본문 내에서 &lt;code&gt;kwds&lt;/code&gt; 라는 dict로 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="f185697f8ffee0494f5a9ca561ffa16269aaa2e4" translate="yes" xml:space="preserve">
          <source>now inside the function body, when the function is called, there are two local variables, &lt;code&gt;args&lt;/code&gt; which is a list having value &lt;code&gt;[&quot;this&quot;, &quot;is a list of&quot;, &quot;non-keyword&quot;, &quot;arguments&quot;]&lt;/code&gt; and &lt;code&gt;kwds&lt;/code&gt; which is a &lt;code&gt;dict&lt;/code&gt; having value &lt;code&gt;{&quot;keyword&quot; : &quot;ligma&quot;, &quot;options&quot; : [1,2,3]}&lt;/code&gt;</source>
          <target state="translated">이제 함수 본문 안에 함수가 호출 될 때 값 &lt;code&gt;[&quot;this&quot;, &quot;is a list of&quot;, &quot;non-keyword&quot;, &quot;arguments&quot;]&lt;/code&gt; 목록 인 &lt;code&gt;args&lt;/code&gt; ,&quot;비 키워드 &quot;,&quot;arguments &quot;] 및 &lt;code&gt;kwds&lt;/code&gt; 라는 두 개의 로컬 변수가 있습니다. &lt;code&gt;{&quot;keyword&quot; : &quot;ligma&quot;, &quot;options&quot; : [1,2,3]}&lt;/code&gt; 값을 가진 &lt;code&gt;dict&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a47e545e87233be9061b9f3c1748aeec79ce9e9" translate="yes" xml:space="preserve">
          <source>python 3.x</source>
          <target state="translated">파이썬 3.x</target>
        </trans-unit>
        <trans-unit id="07fcd4ad0499856dfdeabb4c0a597ca70871dd39" translate="yes" xml:space="preserve">
          <source>the output is</source>
          <target state="translated">출력은</target>
        </trans-unit>
        <trans-unit id="c0312cefbf9b17e9389098ab519b7a2c6225ccac" translate="yes" xml:space="preserve">
          <source>unpacking with &lt;code&gt;**&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 로 포장 풀기</target>
        </trans-unit>
        <trans-unit id="469f623755b36ae79ca6ef17aeded6d0e236120c" translate="yes" xml:space="preserve">
          <source>unzip_x will be [1, 2, 3], unzip_y will be [4, 5, 6]</source>
          <target state="translated">unzip_x는 [1, 2, 3]이되고 unzip_y는 [4, 5, 6]이됩니다</target>
        </trans-unit>
        <trans-unit id="b45d58392bc34be02450e99b0b277b08dd9bca68" translate="yes" xml:space="preserve">
          <source>use with string formatting</source>
          <target state="translated">문자열 형식과 함께 사용</target>
        </trans-unit>
        <trans-unit id="fb8d239cc4547ad356ef28527d756262f9bef562" translate="yes" xml:space="preserve">
          <source>when the '*' or '**' operator is used in a &lt;strong&gt;function call&lt;/strong&gt; -</source>
          <target state="translated">&lt;strong&gt;함수 호출에&lt;/strong&gt; '*'또는 '**'연산자를 사용하는 경우-</target>
        </trans-unit>
        <trans-unit id="d8655e943d84ac23e65b556422ceb5ee5d1db650" translate="yes" xml:space="preserve">
          <source>which can be instatiated as</source>
          <target state="translated">로 설명 될 수있는</target>
        </trans-unit>
        <trans-unit id="99c16e7d13d5e5df076271fc43ca71919374d7b2" translate="yes" xml:space="preserve">
          <source>which prints:</source>
          <target state="translated">어떤 인쇄 :</target>
        </trans-unit>
        <trans-unit id="56f64359bcaff739c2bfb83bbb0ff89946112fc6" translate="yes" xml:space="preserve">
          <source>you can call it with by unpacking iterables or mappings you have in the calling scope:</source>
          <target state="translated">호출 범위에있는 iterables 또는 맵핑을 압축 해제하여 호출 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
