<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3653462">
    <body>
      <group id="3653462">
        <trans-unit id="d68ac24c321858792a3fd7d90f6c8f7e5621af67" translate="yes" xml:space="preserve">
          <source>&quot;One reason was laziness&quot;.</source>
          <target state="translated">&quot;한가지 이유는 게으름이었다&quot;.</target>
        </trans-unit>
        <trans-unit id="1e15595d4b61fc0c392aa5cde87d99860881780b" translate="yes" xml:space="preserve">
          <source>(Some users would dispute the statement in my previous paragraph, saying that &quot;you can never know what requirements will be added in the future&quot;. These users are either misguided or stating a religious conviction. Sometimes it is advantageous to work to the requirements you have before you.)</source>
          <target state="translated">(일부 사용자는 이전 단락의 내용에 이의를 제기하여 &quot;앞으로 어떤 요구 사항이 추가 될지 알 수 없습니다&quot;라고 말하면서 이의를 제기 할 수 있습니다. 당신 앞에 있습니다.)</target>
        </trans-unit>
        <trans-unit id="308f7be66f9bcb2ede05a32d3482ece472e075d6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/6097849/querying-an-xml-list-in-sql-server-using-xquery&quot;&gt;querying an XML list in sql server using Xquery&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/6097849/querying-an-xml-list-in-sql-server-using-xquery&quot;&gt;Xquery를 사용하여 SQL Server에서 XML 목록 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2af6a2d81420798d27f429d6e245a10ba6797ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idlist REGEXP '[[:&amp;lt;:]]2[[:&amp;gt;:]]'&lt;/code&gt;&lt;sup&gt;*&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;idlist REGEXP '[[:&amp;lt;:]]2[[:&amp;gt;:]]'&lt;/code&gt; &lt;sup&gt;*&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ceb7c30bd62e944fe612dfbf214d0de8dd27f5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't delete a value from the list without fetching the whole list.</source>
          <target state="translated">&lt;strong&gt;CSV 사용 :&lt;/strong&gt; 전체 목록을 가져 오지 않고 목록에서 값을 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e16ed75068d203de985c0f7cace1deb2bdec614" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't enforce uniqueness: no way to prevent 1,2,3,3,3,5</source>
          <target state="translated">&lt;strong&gt;CSV 사용 :&lt;/strong&gt; 고유성을 강제 할 수 없음 : 1,2,3,3,3,5를 막을 방법이 없습니다</target>
        </trans-unit>
        <trans-unit id="56d2e6fab6ec52b379ff543420fc07624f74b279" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't ensure that each value is the right data type: no way to prevent 1,2,3,banana,5</source>
          <target state="translated">&lt;strong&gt;CSV 사용 :&lt;/strong&gt; 각 값이 올바른 데이터 유형인지 확인할 수 없음 : 1,2,3, 바나나, 5</target>
        </trans-unit>
        <trans-unit id="ee8fce5b979b677ccbf13f03d48f11ac6dc3093e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.</source>
          <target state="translated">&lt;strong&gt;CSV 사용 :&lt;/strong&gt; 외래 키 제약 조건을 사용하여 값을 조회 테이블에 연결할 수 없습니다. 참조 무결성을 강화할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="207282a8a3febbda7d40ff068fc2fae70d0a5488" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to count elements in the list, or do other aggregate queries.**</source>
          <target state="translated">&lt;strong&gt;CSV 사용 :&lt;/strong&gt; 목록에서 요소를 계산하기 어렵거나 다른 집계 쿼리를 수행합니다. **</target>
        </trans-unit>
        <trans-unit id="3591709e1dc9bf747156834af12cddd44e3c1158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to fetch the list in sorted order.</source>
          <target state="translated">&lt;strong&gt;CSV 사용 :&lt;/strong&gt; 목록을 정렬 된 순서로 가져 오기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="d546b408530db95f4a006946947eeefa1dfca92e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to join the values to the lookup table they reference.**</source>
          <target state="translated">&lt;strong&gt;CSV :&lt;/strong&gt; 값을 참조하는 조회 테이블에 결합하기가 어렵습니다. **</target>
        </trans-unit>
        <trans-unit id="ec63eb94e2584480f09be601555ff5cb30795b74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan.</source>
          <target state="translated">&lt;strong&gt;CSV 사용 :&lt;/strong&gt; 목록에서 지정된 값을 가진 모든 엔티티를 검색하기가 어렵습니다. 비효율적 인 테이블 스캔을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="166b5d1f8e15e8d1cec21bf82cd86ed9b8b02ff7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Plus a lot of comma characters.</source>
          <target state="translated">&lt;strong&gt;CSV 사용 :&lt;/strong&gt; 많은 쉼표 문자.</target>
        </trans-unit>
        <trans-unit id="de8b7eba7a8dee55ede44f1d46b07f0db2f694d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Storing integers as strings takes about twice as much space as storing binary integers.</source>
          <target state="translated">&lt;strong&gt;CSV 사용 :&lt;/strong&gt; 정수를 문자열로 저장하면 이진 정수를 저장하는 것보다 두 배의 공간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="345c84752cdc393407da764c9c782bfd2c02f009" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; not particularly hard</source>
          <target state="translated">&lt;strong&gt;XML로 :&lt;/strong&gt; 특별히 어렵지 않은</target>
        </trans-unit>
        <trans-unit id="d52f99f730e5b0559ad92a5581464421c481b313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; single items can be removed</source>
          <target state="translated">&lt;strong&gt;XML :&lt;/strong&gt; 단일 항목을 제거 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d127c28ca1579d55218956f68a9f58909c540d73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; still an issue</source>
          <target state="translated">&lt;strong&gt;XML로 :&lt;/strong&gt; 여전히 문제</target>
        </trans-unit>
        <trans-unit id="b345e440db0366b1bc401363308731d2d7f1508a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; storage is even worse than a csv</source>
          <target state="translated">&lt;strong&gt;XML을 사용하면&lt;/strong&gt; 스토리지가 CSV보다 더 나빠집니다.</target>
        </trans-unit>
        <trans-unit id="4b44193a79ad8c85453d9ca9ede7d0699345d2a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; tags are used instead of commas</source>
          <target state="translated">&lt;strong&gt;XML :&lt;/strong&gt; 태그가 쉼표 대신 사용됩니다</target>
        </trans-unit>
        <trans-unit id="299faa449be7786936f6646db5550c3571502592" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; values in a tag can be forced to be the correct type</source>
          <target state="translated">&lt;strong&gt;XML을 사용하면&lt;/strong&gt; 태그의 값을 올바른 유형으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ee5b742559eada20e128ff736b7d14932603b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; xml field can be indexed</source>
          <target state="translated">&lt;strong&gt;XML :&lt;/strong&gt; XML 필드를 색인 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a713f943138b961f296abe723ab2d81166668115" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt; MySQL 8.0 no longer supports this word-boundary expression syntax.</source>
          <target state="translated">MySQL 8.0은 더 이상이 단어 경계 표현 구문을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c451c3b9291f22b6c5debc7170bb7a45e6b2675" translate="yes" xml:space="preserve">
          <source>A second criticism is that putting raw input results directly into a database, without any validation or binding at all, leaves you open to SQL injection attacks.</source>
          <target state="translated">두 번째 비판은 유효성 검사 나 바인딩없이 원시 입력 결과를 데이터베이스에 직접 넣는 것이 SQL 인젝션 공격에 노출된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0043a32ea8c37d6143e889a94b95144c1d95ef21" translate="yes" xml:space="preserve">
          <source>Another problem with the comma separated list is ensuring the values are consistent - storing text means the possibility of typos...</source>
          <target state="translated">쉼표로 구분 된 목록의 또 다른 문제점은 값이 일관성을 유지하는 것입니다. 텍스트를 저장하면 오타가 발생할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a5772680ad6d9e0da29214f7d7a90bd5bce7f2a" translate="yes" xml:space="preserve">
          <source>By being an xml field, some of the concerns can be addressed.</source>
          <target state="translated">xml 필드이기 때문에 일부 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96484fc83fcf63f76507517efe55769d93c8351d" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t delete a value from the list without fetching the whole list.</source>
          <target state="translated">전체 목록을 가져 오지 않고 목록에서 값을 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e342bb4206cf556c313a7fa707fa608068f4d41" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t enforce uniqueness: no way to prevent &lt;em&gt;1,2,3,3,3,5&lt;/em&gt;</source>
          <target state="translated">독창성을 강요 할 수 없음 : &lt;em&gt;1,2,3,3,3,5&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d1e23e394102b96f65790a58c9b56d3fa91be9c" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t ensure that each value is the right data type: no way to prevent &lt;em&gt;1,2,3,banana,5&lt;/em&gt;</source>
          <target state="translated">각 값이 올바른 데이터 유형인지 보장 할 수 없음 : &lt;em&gt;1,2,3, 바나나, 5&lt;/em&gt; 를 막을 방법 없음</target>
        </trans-unit>
        <trans-unit id="64461d6b927467f175babcaa6dfee593f032e245" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.</source>
          <target state="translated">외래 키 제약 조건을 사용하여 값을 조회 테이블에 연결할 수 없습니다. 참조 무결성을 강화할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d4903c42663fd89a04a7592de03256b26c309966" translate="yes" xml:space="preserve">
          <source>Can't store a list longer than what fits in the string column.</source>
          <target state="translated">문자열 열에 맞는 것보다 더 긴 목록을 저장할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="082848626a434057c827806a8fd39ae812f9ff3e" translate="yes" xml:space="preserve">
          <source>Comma-separated lists are wrong enough that I made this the first chapter in my book: &lt;a href=&quot;http://www.pragprog.com/titles/bksqla/sql-antipatterns&quot;&gt;SQL Antipatterns: Avoiding the Pitfalls of Database Programming&lt;/a&gt;.</source>
          <target state="translated">쉼표로 구분 된 목록은이 책을 내 책의 첫 번째 장으로 만들 정도로 충분히 잘못되었습니다. &lt;a href=&quot;http://www.pragprog.com/titles/bksqla/sql-antipatterns&quot;&gt;SQL Antipatterns : 데이터베이스 프로그래밍의 함정 피하기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a1b0d85f6d36e43dd10314a16ce8957095a7c74" translate="yes" xml:space="preserve">
          <source>Hard to count elements in the list, or do other aggregate queries.</source>
          <target state="translated">목록의 요소를 계산하거나 다른 집계 쿼리를 수행하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="823a889b45ed2185a283c44397992f042154b32a" translate="yes" xml:space="preserve">
          <source>Hard to fetch the list in sorted order.</source>
          <target state="translated">정렬 된 순서로 목록을 가져 오기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="569f55146a5b0b5ccc52a1131e4d457a3d13e287" translate="yes" xml:space="preserve">
          <source>Hard to join the values to the lookup table they reference.</source>
          <target state="translated">값을 참조하는 조회 테이블에 결합하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="0d810b097c19e6f50b0523535bfffff879a11570" translate="yes" xml:space="preserve">
          <source>Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan. May have to resort to regular expressions, for example in MySQL:</source>
          <target state="translated">목록에서 지정된 값을 가진 모든 엔티티를 검색하기가 어렵습니다. 비효율적 인 테이블 스캔을 사용해야합니다. 예를 들어 MySQL에서 정규 표현식을 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f7c041a1a12ca4cd5aea56bdf5e32098bb7611a" translate="yes" xml:space="preserve">
          <source>Having said this: if the data you are choosing to store this way is data that you will never need to query by, then there may be a case for storing it in the way you have chosen.</source>
          <target state="translated">이렇게 말한 경우 :이 방법으로 저장하려는 데이터가 쿼리 할 필요가없는 데이터 인 경우 선택한 방식으로 데이터를 저장하는 경우가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c16c6ccd0c663eeab5678238a0bfe5252ec79798" translate="yes" xml:space="preserve">
          <source>I needed a multi-value column, it could be implemented as an xml field</source>
          <target state="translated">다중 값 열이 필요했습니다 .xml 필드로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10dc0ee5f03cdb71f15e2cb4aa8c52ef1963754e" translate="yes" xml:space="preserve">
          <source>I thought the saved time and simpler code was worth it in my situation, is this a defensible design choice, or should I have normalized it from the start?</source>
          <target state="translated">절약 된 시간과 간단한 코드가 제 상황에서 가치가 있다고 생각했습니다. 이것이 방어적인 디자인 선택입니까, 아니면 처음부터 정규화해야합니까?</target>
        </trans-unit>
        <trans-unit id="28e7a833b484b5bd612c1994a32514df4ed75fdb" translate="yes" xml:space="preserve">
          <source>I would probably take the middle ground: make each field in the CSV into a separate column in the database, but not worry much about normalization (at least for now). At some point, normalization &lt;em&gt;might&lt;/em&gt; become interesting, but with all the data shoved into a single column you're gaining virtually no benefit from using a database at all. You need to separate the data into logical fields/columns/whatever you want to call them before you can manipulate it meaningfully at all.</source>
          <target state="translated">아마도 중간 단계를 취할 것입니다 : CSV의 각 필드를 데이터베이스의 별도 열로 만들지 만 (현재는 적어도) 정규화에 대해 크게 걱정하지 마십시오. 어떤 시점에서 정규화 &lt;em&gt;는&lt;/em&gt; 흥미로워 질 &lt;em&gt;수&lt;/em&gt; 있지만 모든 데이터를 단일 열로 가져 오면 데이터베이스를 전혀 사용하지 않아도됩니다. 의미있는 데이터를 조작하기 전에 데이터를 논리 필드 / 열 / 전화하려는 항목으로 분리해야합니다.</target>
        </trans-unit>
        <trans-unit id="b03148bc19d2bd86b90c069d0d7ac9d993ddaf36" translate="yes" xml:space="preserve">
          <source>If you have a fixed number of boolean fields, you could use a &lt;code&gt;INT(1) NOT NULL&lt;/code&gt; (or &lt;code&gt;BIT NOT NULL&lt;/code&gt; if it exists) or &lt;code&gt;CHAR (0)&lt;/code&gt; (nullable) for each. You could also use a &lt;code&gt;SET&lt;/code&gt; (I forget the exact syntax).</source>
          <target state="translated">고정 된 수의 부울 필드가있는 경우 각각에 대해 &lt;code&gt;INT(1) NOT NULL&lt;/code&gt; (또는 존재하는 경우 &lt;code&gt;BIT NOT NULL&lt;/code&gt; ) 또는 &lt;code&gt;CHAR (0)&lt;/code&gt; (널 (NULL) 입력 가능)을 사용할 수 있습니다. &lt;code&gt;SET&lt;/code&gt; 을 사용할 수도 있습니다 (정확한 구문을 잊어 버렸습니다).</target>
        </trans-unit>
        <trans-unit id="b51caecb70bf82d71efd94cda96a700d5ee3373c" translate="yes" xml:space="preserve">
          <source>Imagine a web form with a set of check boxes (any or all of them can be selected). I chose to save them in a comma separated list of values stored in one column of the database table.</source>
          <target state="translated">확인란 세트가있는 웹 양식을 상상해보십시오 (일부 또는 모두 선택할 수 있음). 데이터베이스 테이블의 한 열에 저장된 값을 쉼표로 구분 된 값 목록에 저장하기로했습니다.</target>
        </trans-unit>
        <trans-unit id="d3cb8dde911f769cd7183cd9cc767ec03b879e9f" translate="yes" xml:space="preserve">
          <source>In addition to violating &lt;a href=&quot;http://en.wikipedia.org/wiki/1NF&quot;&gt;First Normal Form&lt;/a&gt; because of the repeating group of values stored in a single column, comma-separated lists have a lot of other more practical problems:</source>
          <target state="translated">단일 열에 저장된 반복되는 값 그룹으로 인해 &lt;a href=&quot;http://en.wikipedia.org/wiki/1NF&quot;&gt;첫 번째 정규형&lt;/a&gt; 을 위반하는 것 외에도 쉼표로 구분 된 목록에는 다른 여러 가지 실질적인 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe2e1c3207f9e33e8e2f1f3d075479803691398e" translate="yes" xml:space="preserve">
          <source>In general anything can be defensible if it meets the requirements of your project.  This doesn't mean that people will agree with or want to defend your decision...</source>
          <target state="translated">일반적으로 프로젝트 요구 사항을 충족하면 방어 할 수 있습니다. 이것은 사람들이 당신의 결정에 동의하거나 방어하기를 원한다는 의미는 아닙니다 ...</target>
        </trans-unit>
        <trans-unit id="e3701cdbecde26ed063beb5e13072aaf223d9db1" translate="yes" xml:space="preserve">
          <source>In general, storing data in this way is suboptimal (e.g. harder to do efficient queries) and may cause maintenance issues if you modify the items in your form.  Perhaps you could have found a middle ground and used an integer representing a set of bit flags instead?</source>
          <target state="translated">일반적으로 이런 방식으로 데이터를 저장하는 것은 차선책이므로 (예 : 효율적인 쿼리를 수행하기가 더 어렵습니다) 양식에서 항목을 수정하면 유지 관리 문제가 발생할 수 있습니다. 아마도 중간 접지를 발견하고 대신 비트 플래그 세트를 나타내는 정수를 사용했을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a3bf060c7229a7de0c733617110b5fb79a611283" translate="yes" xml:space="preserve">
          <source>In short, using XML gets around some of the issues with delimited list AND can be converted to a delimited list as needed</source>
          <target state="translated">요컨대, XML을 사용하면 구분 된 목록의 일부 문제가 발생하고 필요에 따라 구분 된 목록으로 변환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="aeac6386d7b159eafa028850b5bc0c1ef63f2fb4" translate="yes" xml:space="preserve">
          <source>Is storing a delimited list in a database column really that bad</source>
          <target state="translated">데이터베이스 열에 구분 목록을 저장하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="97e14d78d8fcd13dfe964f4b10dc17b1a77e933f" translate="yes" xml:space="preserve">
          <source>It breaks first normal form.</source>
          <target state="translated">첫 번째 정상적인 형태를 break습니다.</target>
        </trans-unit>
        <trans-unit id="80115ba213ccc5865ea9eacf73cb79e12bcf165b" translate="yes" xml:space="preserve">
          <source>It could be converted to a comma delimited as necessary</source>
          <target state="translated">필요에 따라 쉼표로 구분하여 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="912626e5ca115be5c77c6a33ebf715da01ac2286" translate="yes" xml:space="preserve">
          <source>Now, I know that the correct solution would be to create a second table and properly normalize the database. It was quicker to implement the easy solution, and I wanted to have a proof-of-concept of that application quickly and without having to spend too much time on it.</source>
          <target state="translated">이제 올바른 해결책은 두 번째 테이블을 만들고 데이터베이스를 올바르게 정규화하는 것입니다. 쉬운 솔루션을 구현하는 것이 더 빨랐으며 너무 많은 시간을 들이지 않고도 해당 응용 프로그램의 개념을 신속하게 증명하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="6ac999a9ea9159ccedab7c41ae7027da9d5975cb" translate="yes" xml:space="preserve">
          <source>Or leave it as it is and learn the painful lesson of a SQL injection attack.</source>
          <target state="translated">또는 그대로두고 SQL 주입 공격에 대한 고통스러운 교훈을 배우십시오.</target>
        </trans-unit>
        <trans-unit id="b4fd9c9094921aa024f79d741e132ebfd65b918a" translate="yes" xml:space="preserve">
          <source>Some more context, this is a small internal application that essentially replaces an Excel file that was stored on a shared folder. I'm also asking because I'm thinking about cleaning up the program and make it more maintainable. There are some things in there I'm not entirely happy with, one of them is the topic of this question.</source>
          <target state="translated">좀 더 많은 맥락에서 이것은 공유 폴더에 저장된 Excel 파일을 본질적으로 대체하는 작은 내부 응용 프로그램입니다. 나는 또한 프로그램을 정리하고 더 유지하기 쉽게 만드는 것에 대해 생각하고 있기 때문에 묻습니다. 거기에 내가 완전히 만족하지 않는 것들이 있습니다. 그중 하나 가이 질문의 주제입니다.</target>
        </trans-unit>
        <trans-unit id="1e1888bea44887d7106486a4c61a983782604b84" translate="yes" xml:space="preserve">
          <source>There are numerous questions on SO asking:</source>
          <target state="translated">SO 요청에 대한 수많은 질문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a84b7e969e00182b83777fed2208ed47140465d" translate="yes" xml:space="preserve">
          <source>There are times when you need to employ denormalization, but as &lt;a href=&quot;https://stackoverflow.com/a/3653507/578288&quot;&gt;@OMG Ponies mentions&lt;/a&gt;, these are exception cases.  Any non-relational &amp;ldquo;optimization&amp;rdquo; benefits one type of query at the expense of other uses of the data, so be sure you know which of your queries need to be treated so specially that they deserve denormalization.</source>
          <target state="translated">비정규 화를 사용해야 할 때가 있지만 &lt;a href=&quot;https://stackoverflow.com/a/3653507/578288&quot;&gt;@OMG Ponies가 언급했듯이&lt;/a&gt; 예외는 예외입니다. 관계형이 아닌 &quot;최적화&quot;는 다른 유형의 데이터 사용을 희생하여 한 가지 유형의 쿼리에 도움이되므로 비정규 화를 수행 할 수 있도록 특별히 처리해야하는 쿼리를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a69f4ce2a888b0fa6f01d65a683a22ce67bbfb61" translate="yes" xml:space="preserve">
          <source>These are all symptoms of denormalized data, and highlight why you should always model for normalized data.  Denormalization &lt;em&gt;can&lt;/em&gt; be a query optimization, &lt;strong&gt;&lt;em&gt;to be applied when the need actually presents itself&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">이는 모두 비정규 화 된 데이터의 증상이며 항상 정규화 된 데이터를 모델링해야하는 이유를 강조합니다. 비정규 화 &lt;em&gt;는&lt;/em&gt; &lt;strong&gt;&lt;em&gt;요구가 실제로 제시 될 때 적용되는&lt;/em&gt;&lt;/strong&gt; 쿼리 최적화 일 &lt;strong&gt;&lt;em&gt;수 있습니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="78c32156deeaf2132bbf7495a555c415ae3d6de1" translate="yes" xml:space="preserve">
          <source>This rings alarm bells. The only reason you should do something like this is that you know how to do it &quot;the right way&quot; but you have come to the conclusion that there is a tangible reason not to do it that way.</source>
          <target state="translated">알람 벨이 울립니다. 이와 같은 일을해야하는 유일한 이유는 &quot;올바른 방법&quot;을 수행하는 방법을 알고 있지만 그렇게하지 않는 확실한 이유가 있다는 결론에 이르렀 기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="80ae79906b4af913c8570f4d8e489f10152b94c4" translate="yes" xml:space="preserve">
          <source>To solve these problems, you have to write tons of application code, reinventing functionality that the RDBMS &lt;em&gt;already provides much more efficiently&lt;/em&gt;.</source>
          <target state="translated">이러한 문제를 해결하려면 수많은 응용 프로그램 코드를 작성하여 RDBMS가 &lt;em&gt;이미 훨씬 더 효율적으로 제공&lt;/em&gt; 하는 기능을 다시 개발해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a2f298a9edab70d9b108437f88211587fed4d83" translate="yes" xml:space="preserve">
          <source>Well I've been using a key/value pair tab separated list in a NTEXT column in SQL Server for more than 4 years now and it works. You do lose the flexibility of making queries but on the other hand, if you have a library that persists/derpersists the key value pair then it's not a that bad idea.</source>
          <target state="translated">글쎄, 지금 4 년 이상 SQL Server의 NTEXT 열에서 키 / 값 쌍 탭으로 구분 된 목록을 사용 해왔으며 작동합니다. 쿼리의 유연성을 잃지 만 반면에 키 값 쌍을 유지 / 파생하는 라이브러리가있는 경우 그다지 나쁜 생각이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="23b6479b9f4b73c294ee003479355e4d49c741ed" translate="yes" xml:space="preserve">
          <source>What you're calling laziness and lack of SQL knowledge is the stuff that neophytes are made of.  I'd recommend taking the time to do it properly and view it as an opportunity to learn.</source>
          <target state="translated">게으름이라고 부르고 SQL 지식이 부족하다는 것은 네오 피테가 만들어내는 것입니다. 시간을내어 제대로하고 배우는 기회로 여길 것을 권합니다.</target>
        </trans-unit>
        <trans-unit id="0da840e085ebfe0f26931a3075af7cadfe521dc0" translate="yes" xml:space="preserve">
          <source>Yes, I would say that it really is that bad.  It's a defensible choice, but that doesn't make it correct or good.</source>
          <target state="translated">그렇습니다, 나는 그것이 정말로 나쁘다고 말합니다. 그것은 선택의 여지가 있지만 그것이 정확하거나 좋지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c0421fdef72069541967dceb38557cfa5b088a0" translate="yes" xml:space="preserve">
          <source>Yes, it &lt;em&gt;is&lt;/em&gt; that bad.  My view is that if you don't like using relational databases then look for an alternative that suits you better, there are lots of interesting &quot;NOSQL&quot; projects out there with some really advanced features.</source>
          <target state="translated">그렇습니다. 제 생각에는 관계형 데이터베이스를 사용하는 것이 마음에 들지 않으면 자신에게 더 적합한 대안을 찾으면 정말 고급 기능을 갖춘 흥미로운 &quot;NOSQL&quot;프로젝트가 많이 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac1512f8b79726851af69c8b05819175a17cd5cc" translate="yes" xml:space="preserve">
          <source>how to get a count of specific values from the comma separated list</source>
          <target state="translated">쉼표로 구분 된 목록에서 특정 값의 개수를 얻는 방법</target>
        </trans-unit>
        <trans-unit id="22bb0c71811e7ae7fb998abd6e1d9e06140ec61b" translate="yes" xml:space="preserve">
          <source>how to get records that have only the same 2/3/etc specific value from that comma separated list</source>
          <target state="translated">쉼표로 구분 된 목록에서 동일한 2 / 3 / etc 특정 값만있는 레코드를 얻는 방법</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
