<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3653462">
    <body>
      <group id="3653462">
        <trans-unit id="d68ac24c321858792a3fd7d90f6c8f7e5621af67" translate="yes" xml:space="preserve">
          <source>&quot;One reason was laziness&quot;.</source>
          <target state="translated">&quot;一个原因是懒惰&quot;。</target>
        </trans-unit>
        <trans-unit id="1e15595d4b61fc0c392aa5cde87d99860881780b" translate="yes" xml:space="preserve">
          <source>(Some users would dispute the statement in my previous paragraph, saying that &quot;you can never know what requirements will be added in the future&quot;. These users are either misguided or stating a religious conviction. Sometimes it is advantageous to work to the requirements you have before you.)</source>
          <target state="translated">(有些用户会对我上一段的说法提出异议,说 &quot;你永远不可能知道将来会增加什么要求&quot;。这些用户不是被误导了,就是在陈述一种宗教信仰。有时候,按照自己面前的要求去努力,是有好处的)。</target>
        </trans-unit>
        <trans-unit id="308f7be66f9bcb2ede05a32d3482ece472e075d6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/6097849/querying-an-xml-list-in-sql-server-using-xquery&quot;&gt;querying an XML list in sql server using Xquery&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/6097849/querying-an-xml-list-in-sql-server-using-xquery&quot;&gt;使用Xquery在sql服务器中查询XML列表&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2af6a2d81420798d27f429d6e245a10ba6797ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idlist REGEXP '[[:&amp;lt;:]]2[[:&amp;gt;:]]'&lt;/code&gt;&lt;sup&gt;*&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;idlist REGEXP '[[:&amp;lt;:]]2[[:&amp;gt;:]]'&lt;/code&gt; &lt;sup&gt;*&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ceb7c30bd62e944fe612dfbf214d0de8dd27f5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't delete a value from the list without fetching the whole list.</source>
          <target state="translated">&lt;strong&gt;使用CSV：&lt;/strong&gt;无法在不获取整个列表的情况下从列表中删除值。</target>
        </trans-unit>
        <trans-unit id="9e16ed75068d203de985c0f7cace1deb2bdec614" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't enforce uniqueness: no way to prevent 1,2,3,3,3,5</source>
          <target state="translated">&lt;strong&gt;使用CSV：&lt;/strong&gt;无法强制唯一性：无法阻止1,2,3,3,3,5</target>
        </trans-unit>
        <trans-unit id="56d2e6fab6ec52b379ff543420fc07624f74b279" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't ensure that each value is the right data type: no way to prevent 1,2,3,banana,5</source>
          <target state="translated">&lt;strong&gt;使用CSV：&lt;/strong&gt;无法确保每个值都是正确的数据类型：无法阻止1,2,3，banana，5</target>
        </trans-unit>
        <trans-unit id="ee8fce5b979b677ccbf13f03d48f11ac6dc3093e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.</source>
          <target state="translated">&lt;strong&gt;使用CSV：&lt;/strong&gt;无法使用外键约束将值链接到查找表； 无法强制执行参照完整性。</target>
        </trans-unit>
        <trans-unit id="207282a8a3febbda7d40ff068fc2fae70d0a5488" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to count elements in the list, or do other aggregate queries.**</source>
          <target state="translated">&lt;strong&gt;使用CSV：&lt;/strong&gt;难以计算列表中的元素，或执行其他汇总查询。**</target>
        </trans-unit>
        <trans-unit id="3591709e1dc9bf747156834af12cddd44e3c1158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to fetch the list in sorted order.</source>
          <target state="translated">&lt;strong&gt;使用CSV：&lt;/strong&gt;很难按排序顺序获取列表。</target>
        </trans-unit>
        <trans-unit id="d546b408530db95f4a006946947eeefa1dfca92e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to join the values to the lookup table they reference.**</source>
          <target state="translated">&lt;strong&gt;使用CSV：&lt;/strong&gt;很难将值连接到它们引用的查找表中。**</target>
        </trans-unit>
        <trans-unit id="ec63eb94e2584480f09be601555ff5cb30795b74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan.</source>
          <target state="translated">&lt;strong&gt;使用CSV：&lt;/strong&gt;难以在列表中搜索具有给定值的所有实体； 您必须使用效率低下的表格扫描。</target>
        </trans-unit>
        <trans-unit id="166b5d1f8e15e8d1cec21bf82cd86ed9b8b02ff7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Plus a lot of comma characters.</source>
          <target state="translated">&lt;strong&gt;使用CSV：&lt;/strong&gt;加上许多逗号字符。</target>
        </trans-unit>
        <trans-unit id="de8b7eba7a8dee55ede44f1d46b07f0db2f694d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Storing integers as strings takes about twice as much space as storing binary integers.</source>
          <target state="translated">&lt;strong&gt;使用CSV：&lt;/strong&gt;将整数存储为字符串所需的空间大约是存储二进制整数的两倍。</target>
        </trans-unit>
        <trans-unit id="345c84752cdc393407da764c9c782bfd2c02f009" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; not particularly hard</source>
          <target state="translated">&lt;strong&gt;使用XML：&lt;/strong&gt;不是特别困难</target>
        </trans-unit>
        <trans-unit id="d52f99f730e5b0559ad92a5581464421c481b313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; single items can be removed</source>
          <target state="translated">&lt;strong&gt;使用XML：&lt;/strong&gt;可以删除单个项目</target>
        </trans-unit>
        <trans-unit id="d127c28ca1579d55218956f68a9f58909c540d73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; still an issue</source>
          <target state="translated">&lt;strong&gt;使用XML：&lt;/strong&gt;仍然是一个问题</target>
        </trans-unit>
        <trans-unit id="b345e440db0366b1bc401363308731d2d7f1508a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; storage is even worse than a csv</source>
          <target state="translated">&lt;strong&gt;使用XML：&lt;/strong&gt;存储甚至比csv更糟</target>
        </trans-unit>
        <trans-unit id="4b44193a79ad8c85453d9ca9ede7d0699345d2a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; tags are used instead of commas</source>
          <target state="translated">&lt;strong&gt;使用XML：使用&lt;/strong&gt;标签代替逗号</target>
        </trans-unit>
        <trans-unit id="299faa449be7786936f6646db5550c3571502592" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; values in a tag can be forced to be the correct type</source>
          <target state="translated">&lt;strong&gt;使用XML：&lt;/strong&gt;可以将标记中的值强制为正确的类型</target>
        </trans-unit>
        <trans-unit id="7ee5b742559eada20e128ff736b7d14932603b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; xml field can be indexed</source>
          <target state="translated">&lt;strong&gt;使用XML：&lt;/strong&gt;可以对xml字段建立索引</target>
        </trans-unit>
        <trans-unit id="a713f943138b961f296abe723ab2d81166668115" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt; MySQL 8.0 no longer supports this word-boundary expression syntax.</source>
          <target state="translated">&lt;sup&gt;*&lt;/sup&gt; MySQL 8.0不再支持此字边界表达式语法。</target>
        </trans-unit>
        <trans-unit id="8c451c3b9291f22b6c5debc7170bb7a45e6b2675" translate="yes" xml:space="preserve">
          <source>A second criticism is that putting raw input results directly into a database, without any validation or binding at all, leaves you open to SQL injection attacks.</source>
          <target state="translated">第二个批评是,将原始输入结果直接放到数据库中,完全不做任何验证或绑定,会让你容易受到SQL注入攻击。</target>
        </trans-unit>
        <trans-unit id="0043a32ea8c37d6143e889a94b95144c1d95ef21" translate="yes" xml:space="preserve">
          <source>Another problem with the comma separated list is ensuring the values are consistent - storing text means the possibility of typos...</source>
          <target state="translated">逗号分隔的列表的另一个问题是确保值的一致性--存储文本意味着可能出现错别字.....</target>
        </trans-unit>
        <trans-unit id="0a5772680ad6d9e0da29214f7d7a90bd5bce7f2a" translate="yes" xml:space="preserve">
          <source>By being an xml field, some of the concerns can be addressed.</source>
          <target state="translated">通过做xml字段,可以解决一些顾虑。</target>
        </trans-unit>
        <trans-unit id="96484fc83fcf63f76507517efe55769d93c8351d" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t delete a value from the list without fetching the whole list.</source>
          <target state="translated">如果不获取整个列表，则无法从列表中删除值。</target>
        </trans-unit>
        <trans-unit id="5e342bb4206cf556c313a7fa707fa608068f4d41" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t enforce uniqueness: no way to prevent &lt;em&gt;1,2,3,3,3,5&lt;/em&gt;</source>
          <target state="translated">无法强制唯一性：无法阻止&lt;em&gt;1,2,3,3,3,5&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d1e23e394102b96f65790a58c9b56d3fa91be9c" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t ensure that each value is the right data type: no way to prevent &lt;em&gt;1,2,3,banana,5&lt;/em&gt;</source>
          <target state="translated">无法确保每个值都是正确的数据类型：无法阻止&lt;em&gt;1,2,3，banana，5&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64461d6b927467f175babcaa6dfee593f032e245" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.</source>
          <target state="translated">不能使用外键约束将值链接到查找表； 无法强制执行参照完整性。</target>
        </trans-unit>
        <trans-unit id="d4903c42663fd89a04a7592de03256b26c309966" translate="yes" xml:space="preserve">
          <source>Can't store a list longer than what fits in the string column.</source>
          <target state="translated">不能存储比字符串列中的内容更长的列表。</target>
        </trans-unit>
        <trans-unit id="082848626a434057c827806a8fd39ae812f9ff3e" translate="yes" xml:space="preserve">
          <source>Comma-separated lists are wrong enough that I made this the first chapter in my book: &lt;a href=&quot;http://www.pragprog.com/titles/bksqla/sql-antipatterns&quot;&gt;SQL Antipatterns: Avoiding the Pitfalls of Database Programming&lt;/a&gt;.</source>
          <target state="translated">逗号分隔的列表是非常错误的，以至于我在本书的第一章中做了这本书： &lt;a href=&quot;http://www.pragprog.com/titles/bksqla/sql-antipatterns&quot;&gt;SQL Antipatterns：避免数据库编程的陷阱&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a1b0d85f6d36e43dd10314a16ce8957095a7c74" translate="yes" xml:space="preserve">
          <source>Hard to count elements in the list, or do other aggregate queries.</source>
          <target state="translated">难以统计列表中的元素,或做其他聚合查询。</target>
        </trans-unit>
        <trans-unit id="823a889b45ed2185a283c44397992f042154b32a" translate="yes" xml:space="preserve">
          <source>Hard to fetch the list in sorted order.</source>
          <target state="translated">很难按排序的顺序获取列表。</target>
        </trans-unit>
        <trans-unit id="569f55146a5b0b5ccc52a1131e4d457a3d13e287" translate="yes" xml:space="preserve">
          <source>Hard to join the values to the lookup table they reference.</source>
          <target state="translated">很难将值连接到它们所引用的查找表上。</target>
        </trans-unit>
        <trans-unit id="0d810b097c19e6f50b0523535bfffff879a11570" translate="yes" xml:space="preserve">
          <source>Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan. May have to resort to regular expressions, for example in MySQL:</source>
          <target state="translated">很难在列表中搜索所有具有给定值的实体;你必须使用低效的表扫描。可能不得不求助于正则表达式,例如在MySQL中。</target>
        </trans-unit>
        <trans-unit id="1f7c041a1a12ca4cd5aea56bdf5e32098bb7611a" translate="yes" xml:space="preserve">
          <source>Having said this: if the data you are choosing to store this way is data that you will never need to query by, then there may be a case for storing it in the way you have chosen.</source>
          <target state="translated">说了这么多:如果你选择这种方式存储的数据是你永远也不需要查询的数据,那么你选择的存储方式可能是有道理的。</target>
        </trans-unit>
        <trans-unit id="c16c6ccd0c663eeab5678238a0bfe5252ec79798" translate="yes" xml:space="preserve">
          <source>I needed a multi-value column, it could be implemented as an xml field</source>
          <target state="translated">我需要一个多值列,它可以作为一个xml字段实现。</target>
        </trans-unit>
        <trans-unit id="10dc0ee5f03cdb71f15e2cb4aa8c52ef1963754e" translate="yes" xml:space="preserve">
          <source>I thought the saved time and simpler code was worth it in my situation, is this a defensible design choice, or should I have normalized it from the start?</source>
          <target state="translated">我觉得在我这种情况下,省下的时间和更简单的代码是值得的,这样的设计选择是否是可圈可点的,还是一开始就应该把它规范化?</target>
        </trans-unit>
        <trans-unit id="28e7a833b484b5bd612c1994a32514df4ed75fdb" translate="yes" xml:space="preserve">
          <source>I would probably take the middle ground: make each field in the CSV into a separate column in the database, but not worry much about normalization (at least for now). At some point, normalization &lt;em&gt;might&lt;/em&gt; become interesting, but with all the data shoved into a single column you're gaining virtually no benefit from using a database at all. You need to separate the data into logical fields/columns/whatever you want to call them before you can manipulate it meaningfully at all.</source>
          <target state="translated">我可能会采取中间立场：将CSV中的每个字段放入数据库中的单独列中，但不必担心标准化（至少现在如此）。 在某些时候，规范化&lt;em&gt;可能&lt;/em&gt;会变得很有趣，但是将所有数据推到一个单独的列中，使用数据库几乎没有任何好处。 您需要将数据分为逻辑字段/列/任何要调用的内容，然后才能进行有意义的操作。</target>
        </trans-unit>
        <trans-unit id="b03148bc19d2bd86b90c069d0d7ac9d993ddaf36" translate="yes" xml:space="preserve">
          <source>If you have a fixed number of boolean fields, you could use a &lt;code&gt;INT(1) NOT NULL&lt;/code&gt; (or &lt;code&gt;BIT NOT NULL&lt;/code&gt; if it exists) or &lt;code&gt;CHAR (0)&lt;/code&gt; (nullable) for each. You could also use a &lt;code&gt;SET&lt;/code&gt; (I forget the exact syntax).</source>
          <target state="translated">如果您具有固定数量的布尔字段，则可以为每个字段使用 &lt;code&gt;INT(1) NOT NULL&lt;/code&gt; （或 &lt;code&gt;BIT NOT NULL&lt;/code&gt; (如果存在））或 &lt;code&gt;CHAR (0)&lt;/code&gt; （可为空）。 您也可以使用 &lt;code&gt;SET&lt;/code&gt; （我忘记了确切的语法）。</target>
        </trans-unit>
        <trans-unit id="b51caecb70bf82d71efd94cda96a700d5ee3373c" translate="yes" xml:space="preserve">
          <source>Imagine a web form with a set of check boxes (any or all of them can be selected). I chose to save them in a comma separated list of values stored in one column of the database table.</source>
          <target state="translated">想象一个有一组复选框的Web表单(可以选择任意或全部的复选框)。我选择将它们保存在数据库表的一列中的逗号分隔的值列表中。</target>
        </trans-unit>
        <trans-unit id="d3cb8dde911f769cd7183cd9cc767ec03b879e9f" translate="yes" xml:space="preserve">
          <source>In addition to violating &lt;a href=&quot;http://en.wikipedia.org/wiki/1NF&quot;&gt;First Normal Form&lt;/a&gt; because of the repeating group of values stored in a single column, comma-separated lists have a lot of other more practical problems:</source>
          <target state="translated">除了由于存储在单个列中的值重复组而违反&lt;a href=&quot;http://en.wikipedia.org/wiki/1NF&quot;&gt;第一范式&lt;/a&gt;之外，逗号分隔的列表还有很多其他更实际的问题：</target>
        </trans-unit>
        <trans-unit id="fe2e1c3207f9e33e8e2f1f3d075479803691398e" translate="yes" xml:space="preserve">
          <source>In general anything can be defensible if it meets the requirements of your project.  This doesn't mean that people will agree with or want to defend your decision...</source>
          <target state="translated">一般来说,只要符合你的项目要求,任何事情都是可以辩护的。这并不意味着人们会同意或想为你的决定辩护.....</target>
        </trans-unit>
        <trans-unit id="e3701cdbecde26ed063beb5e13072aaf223d9db1" translate="yes" xml:space="preserve">
          <source>In general, storing data in this way is suboptimal (e.g. harder to do efficient queries) and may cause maintenance issues if you modify the items in your form.  Perhaps you could have found a middle ground and used an integer representing a set of bit flags instead?</source>
          <target state="translated">一般来说,以这种方式存储数据是次优的(例如,更难进行有效的查询),如果你修改表单中的项目,可能会导致维护问题。也许你可以找到一个中间点,用一个代表一组位标志的整数代替?</target>
        </trans-unit>
        <trans-unit id="a3bf060c7229a7de0c733617110b5fb79a611283" translate="yes" xml:space="preserve">
          <source>In short, using XML gets around some of the issues with delimited list AND can be converted to a delimited list as needed</source>
          <target state="translated">简而言之,使用XML可以绕过一些用分隔列表和可以根据需要转换为分隔列表的问题。</target>
        </trans-unit>
        <trans-unit id="aeac6386d7b159eafa028850b5bc0c1ef63f2fb4" translate="yes" xml:space="preserve">
          <source>Is storing a delimited list in a database column really that bad</source>
          <target state="translated">在数据库列中存储一个分隔符列表真的那么糟糕吗?</target>
        </trans-unit>
        <trans-unit id="97e14d78d8fcd13dfe964f4b10dc17b1a77e933f" translate="yes" xml:space="preserve">
          <source>It breaks first normal form.</source>
          <target state="translated">它首先打破了正常的形式。</target>
        </trans-unit>
        <trans-unit id="80115ba213ccc5865ea9eacf73cb79e12bcf165b" translate="yes" xml:space="preserve">
          <source>It could be converted to a comma delimited as necessary</source>
          <target state="translated">必要时可转换为以逗号为分隔符</target>
        </trans-unit>
        <trans-unit id="912626e5ca115be5c77c6a33ebf715da01ac2286" translate="yes" xml:space="preserve">
          <source>Now, I know that the correct solution would be to create a second table and properly normalize the database. It was quicker to implement the easy solution, and I wanted to have a proof-of-concept of that application quickly and without having to spend too much time on it.</source>
          <target state="translated">现在,我知道正确的解决方案应该是创建第二个表,并对数据库进行适当的规范化。实现这个简单的解决方案比较快,我希望能快速地完成这个应用的概念验证,而不需要花太多的时间在上面。</target>
        </trans-unit>
        <trans-unit id="6ac999a9ea9159ccedab7c41ae7027da9d5975cb" translate="yes" xml:space="preserve">
          <source>Or leave it as it is and learn the painful lesson of a SQL injection attack.</source>
          <target state="translated">或者任其自然,吸取SQL注入攻击的惨痛教训。</target>
        </trans-unit>
        <trans-unit id="b4fd9c9094921aa024f79d741e132ebfd65b918a" translate="yes" xml:space="preserve">
          <source>Some more context, this is a small internal application that essentially replaces an Excel file that was stored on a shared folder. I'm also asking because I'm thinking about cleaning up the program and make it more maintainable. There are some things in there I'm not entirely happy with, one of them is the topic of this question.</source>
          <target state="translated">再来点背景,这是一个内部的小程序,本质上是替换一个存储在共享文件夹中的Excel文件。我之所以这么问,也是因为我想清理一下这个程序,让它更容易维护。这里面有一些东西我不太满意,其中一个就是这个问题的主题。</target>
        </trans-unit>
        <trans-unit id="1e1888bea44887d7106486a4c61a983782604b84" translate="yes" xml:space="preserve">
          <source>There are numerous questions on SO asking:</source>
          <target state="translated">在SO问上有很多问题。</target>
        </trans-unit>
        <trans-unit id="9a84b7e969e00182b83777fed2208ed47140465d" translate="yes" xml:space="preserve">
          <source>There are times when you need to employ denormalization, but as &lt;a href=&quot;https://stackoverflow.com/a/3653507/578288&quot;&gt;@OMG Ponies mentions&lt;/a&gt;, these are exception cases.  Any non-relational &amp;ldquo;optimization&amp;rdquo; benefits one type of query at the expense of other uses of the data, so be sure you know which of your queries need to be treated so specially that they deserve denormalization.</source>
          <target state="translated">有时您需要使用非规范化，但是正如&lt;a href=&quot;https://stackoverflow.com/a/3653507/578288&quot;&gt;@OMG Ponies所提到的&lt;/a&gt; ，这是例外情况。 任何非关系型&amp;ldquo;优化&amp;rdquo;都会以一种查询类型为代价，而以其他用途使用数据为代价，因此请确保您知道哪些查询需要特别处理，以使它们值得进行非规范化处理。</target>
        </trans-unit>
        <trans-unit id="a69f4ce2a888b0fa6f01d65a683a22ce67bbfb61" translate="yes" xml:space="preserve">
          <source>These are all symptoms of denormalized data, and highlight why you should always model for normalized data.  Denormalization &lt;em&gt;can&lt;/em&gt; be a query optimization, &lt;strong&gt;&lt;em&gt;to be applied when the need actually presents itself&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">这些都是非规范化数据的症状，并突出说明了为什么应该始终为规范化数据建模。 非规范化&lt;em&gt;可以&lt;/em&gt;是查询优化， &lt;strong&gt;&lt;em&gt;可以在需求实际出现时应用&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="78c32156deeaf2132bbf7495a555c415ae3d6de1" translate="yes" xml:space="preserve">
          <source>This rings alarm bells. The only reason you should do something like this is that you know how to do it &quot;the right way&quot; but you have come to the conclusion that there is a tangible reason not to do it that way.</source>
          <target state="translated">这句话给人敲响了警钟。你之所以要做这样的事情,只是因为你知道怎么做才是 &quot;正确的方法&quot;,但你却得出了一个实实在在的结论,那就是有一个实实在在的理由,不应该这样做。</target>
        </trans-unit>
        <trans-unit id="80ae79906b4af913c8570f4d8e489f10152b94c4" translate="yes" xml:space="preserve">
          <source>To solve these problems, you have to write tons of application code, reinventing functionality that the RDBMS &lt;em&gt;already provides much more efficiently&lt;/em&gt;.</source>
          <target state="translated">为了解决这些问题，您必须编写大量的应用程序代码，以重新利用RDBMS &lt;em&gt;已经提供的&lt;/em&gt;功能，从而&lt;em&gt;更加有效&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a2f298a9edab70d9b108437f88211587fed4d83" translate="yes" xml:space="preserve">
          <source>Well I've been using a key/value pair tab separated list in a NTEXT column in SQL Server for more than 4 years now and it works. You do lose the flexibility of making queries but on the other hand, if you have a library that persists/derpersists the key value pair then it's not a that bad idea.</source>
          <target state="translated">嗯,我在SQL Server中的NTEXT列中使用键值对标签分离的列表已经有4年多了,它很好用。你确实失去了查询的灵活性,但另一方面,如果你有一个库,可以持久化地保存键值对,那么这也不是一个坏主意。</target>
        </trans-unit>
        <trans-unit id="23b6479b9f4b73c294ee003479355e4d49c741ed" translate="yes" xml:space="preserve">
          <source>What you're calling laziness and lack of SQL knowledge is the stuff that neophytes are made of.  I'd recommend taking the time to do it properly and view it as an opportunity to learn.</source>
          <target state="translated">你所说的懒惰和缺乏SQL知识,就是菜鸟的东西。我建议花点时间好好做,把它看成是学习的机会。</target>
        </trans-unit>
        <trans-unit id="0da840e085ebfe0f26931a3075af7cadfe521dc0" translate="yes" xml:space="preserve">
          <source>Yes, I would say that it really is that bad.  It's a defensible choice, but that doesn't make it correct or good.</source>
          <target state="translated">是的,我想说的是,真的有那么糟糕。这是一个可以辩解的选择,但这并不代表它是正确的、好的。</target>
        </trans-unit>
        <trans-unit id="9c0421fdef72069541967dceb38557cfa5b088a0" translate="yes" xml:space="preserve">
          <source>Yes, it &lt;em&gt;is&lt;/em&gt; that bad.  My view is that if you don't like using relational databases then look for an alternative that suits you better, there are lots of interesting &quot;NOSQL&quot; projects out there with some really advanced features.</source>
          <target state="translated">是的，那&lt;em&gt;很&lt;/em&gt;糟糕。 我的观点是，如果您不喜欢使用关系数据库，然后寻找更适合您的替代方法，那么这里有很多有趣的&amp;ldquo; NOSQL&amp;rdquo;项目，它们具有一些真正的高级功能。</target>
        </trans-unit>
        <trans-unit id="ac1512f8b79726851af69c8b05819175a17cd5cc" translate="yes" xml:space="preserve">
          <source>how to get a count of specific values from the comma separated list</source>
          <target state="translated">如何从逗号分隔的列表中获得特定值的计数方法</target>
        </trans-unit>
        <trans-unit id="22bb0c71811e7ae7fb998abd6e1d9e06140ec61b" translate="yes" xml:space="preserve">
          <source>how to get records that have only the same 2/3/etc specific value from that comma separated list</source>
          <target state="translated">如何从该逗号分隔的列表中获得只有相同的23个特定值的记录。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
