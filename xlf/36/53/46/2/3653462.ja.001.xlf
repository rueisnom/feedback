<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3653462">
    <body>
      <group id="3653462">
        <trans-unit id="d68ac24c321858792a3fd7d90f6c8f7e5621af67" translate="yes" xml:space="preserve">
          <source>&quot;One reason was laziness&quot;.</source>
          <target state="translated">&quot;一つの理由は怠惰だった&quot;</target>
        </trans-unit>
        <trans-unit id="1e15595d4b61fc0c392aa5cde87d99860881780b" translate="yes" xml:space="preserve">
          <source>(Some users would dispute the statement in my previous paragraph, saying that &quot;you can never know what requirements will be added in the future&quot;. These users are either misguided or stating a religious conviction. Sometimes it is advantageous to work to the requirements you have before you.)</source>
          <target state="translated">(前段落の「将来どんな要件が追加されるかは分からない」という発言に異論を唱えるユーザーもいるでしょう。このようなユーザーは見当違いか、宗教的な信念を述べているかのどちらかです。目の前にある要件に合わせて作業することが有利な場合もあります)</target>
        </trans-unit>
        <trans-unit id="308f7be66f9bcb2ede05a32d3482ece472e075d6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/6097849/querying-an-xml-list-in-sql-server-using-xquery&quot;&gt;querying an XML list in sql server using Xquery&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/6097849/querying-an-xml-list-in-sql-server-using-xquery&quot;&gt;Xqueryを使用してSQLサーバーのXMLリストをクエリする&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2af6a2d81420798d27f429d6e245a10ba6797ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idlist REGEXP '[[:&amp;lt;:]]2[[:&amp;gt;:]]'&lt;/code&gt;&lt;sup&gt;*&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;idlist REGEXP '[[:&amp;lt;:]]2[[:&amp;gt;:]]'&lt;/code&gt; &lt;sup&gt;*&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ceb7c30bd62e944fe612dfbf214d0de8dd27f5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't delete a value from the list without fetching the whole list.</source>
          <target state="translated">&lt;strong&gt;CSVの場合：&lt;/strong&gt;リスト全体をフェッチしないと、リストから値を削除できません。</target>
        </trans-unit>
        <trans-unit id="9e16ed75068d203de985c0f7cace1deb2bdec614" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't enforce uniqueness: no way to prevent 1,2,3,3,3,5</source>
          <target state="translated">&lt;strong&gt;CSVの場合：&lt;/strong&gt;一意性を適用できません：1、2、3、3、3、5を防ぐ方法はありません</target>
        </trans-unit>
        <trans-unit id="56d2e6fab6ec52b379ff543420fc07624f74b279" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't ensure that each value is the right data type: no way to prevent 1,2,3,banana,5</source>
          <target state="translated">&lt;strong&gt;CSVの場合：&lt;/strong&gt;各値が正しいデータ型であることを確認できません：1、2、3、バナナ、5を防ぐ方法はありません</target>
        </trans-unit>
        <trans-unit id="ee8fce5b979b677ccbf13f03d48f11ac6dc3093e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Can't use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.</source>
          <target state="translated">&lt;strong&gt;CSVを&lt;/strong&gt;使用する場合&lt;strong&gt;：&lt;/strong&gt;外部キー制約を使用して値をルックアップテーブルにリンクすることはできません。 参照整合性を適用する方法はありません。</target>
        </trans-unit>
        <trans-unit id="207282a8a3febbda7d40ff068fc2fae70d0a5488" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to count elements in the list, or do other aggregate queries.**</source>
          <target state="translated">&lt;strong&gt;CSVを使用する場合：&lt;/strong&gt;リスト内の要素を数えたり、他の集計クエリを実行したりすることは困難です。**</target>
        </trans-unit>
        <trans-unit id="3591709e1dc9bf747156834af12cddd44e3c1158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to fetch the list in sorted order.</source>
          <target state="translated">&lt;strong&gt;CSVの場合：&lt;/strong&gt;リストを並べ替えられた順序で取得するのは困難です。</target>
        </trans-unit>
        <trans-unit id="d546b408530db95f4a006946947eeefa1dfca92e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to join the values to the lookup table they reference.**</source>
          <target state="translated">&lt;strong&gt;CSVの場合：&lt;/strong&gt;値を参照するルックアップテーブルに結合するのは困難です。**</target>
        </trans-unit>
        <trans-unit id="ec63eb94e2584480f09be601555ff5cb30795b74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan.</source>
          <target state="translated">&lt;strong&gt;CSVの場合：&lt;/strong&gt;リスト内の特定の値を持つすべてのエンティティを検索するのは困難です。 非効率的なテーブルスキャンを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="166b5d1f8e15e8d1cec21bf82cd86ed9b8b02ff7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Plus a lot of comma characters.</source>
          <target state="translated">&lt;strong&gt;CSVの場合：&lt;/strong&gt;多数のコンマ文字を追加します。</target>
        </trans-unit>
        <trans-unit id="de8b7eba7a8dee55ede44f1d46b07f0db2f694d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With CSV:&lt;/strong&gt; Storing integers as strings takes about twice as much space as storing binary integers.</source>
          <target state="translated">&lt;strong&gt;CSVを使用する場合：&lt;/strong&gt;整数を文字列として格納するには、2進整数を格納する場合の約2倍のスペースが必要です。</target>
        </trans-unit>
        <trans-unit id="345c84752cdc393407da764c9c782bfd2c02f009" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; not particularly hard</source>
          <target state="translated">&lt;strong&gt;XMLの場合：&lt;/strong&gt;特に難しい</target>
        </trans-unit>
        <trans-unit id="d52f99f730e5b0559ad92a5581464421c481b313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; single items can be removed</source>
          <target state="translated">&lt;strong&gt;XMLの場合：&lt;/strong&gt;単一のアイテムを削除できます</target>
        </trans-unit>
        <trans-unit id="d127c28ca1579d55218956f68a9f58909c540d73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; still an issue</source>
          <target state="translated">&lt;strong&gt;XMLの場合：&lt;/strong&gt;まだ問題</target>
        </trans-unit>
        <trans-unit id="b345e440db0366b1bc401363308731d2d7f1508a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; storage is even worse than a csv</source>
          <target state="translated">&lt;strong&gt;XMLの場合：&lt;/strong&gt;ストレージはcsvよりもさらに悪い</target>
        </trans-unit>
        <trans-unit id="4b44193a79ad8c85453d9ca9ede7d0699345d2a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; tags are used instead of commas</source>
          <target state="translated">&lt;strong&gt;XMLの場合：&lt;/strong&gt;コンマの代わりにタグが使用されます</target>
        </trans-unit>
        <trans-unit id="299faa449be7786936f6646db5550c3571502592" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; values in a tag can be forced to be the correct type</source>
          <target state="translated">&lt;strong&gt;XMLの場合：&lt;/strong&gt;タグ内の値を強制的に正しいタイプにすることができます</target>
        </trans-unit>
        <trans-unit id="7ee5b742559eada20e128ff736b7d14932603b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With XML:&lt;/strong&gt; xml field can be indexed</source>
          <target state="translated">&lt;strong&gt;XMLの場合：&lt;/strong&gt; xmlフィールドにインデックスを付けることができます</target>
        </trans-unit>
        <trans-unit id="a713f943138b961f296abe723ab2d81166668115" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt; MySQL 8.0 no longer supports this word-boundary expression syntax.</source>
          <target state="translated">&lt;sup&gt;*&lt;/sup&gt; MySQL 8.0はこの単語境界式構文をサポートしなくなりました。</target>
        </trans-unit>
        <trans-unit id="8c451c3b9291f22b6c5debc7170bb7a45e6b2675" translate="yes" xml:space="preserve">
          <source>A second criticism is that putting raw input results directly into a database, without any validation or binding at all, leaves you open to SQL injection attacks.</source>
          <target state="translated">2つ目の批判は、生の入力結果を検証もバインドもせずにデータベースに直接入力すると、SQLインジェクション攻撃にさらされてしまうということです。</target>
        </trans-unit>
        <trans-unit id="0043a32ea8c37d6143e889a94b95144c1d95ef21" translate="yes" xml:space="preserve">
          <source>Another problem with the comma separated list is ensuring the values are consistent - storing text means the possibility of typos...</source>
          <target state="translated">カンマで区切られたリストのもう一つの問題は、値の一貫性を確保することです。</target>
        </trans-unit>
        <trans-unit id="0a5772680ad6d9e0da29214f7d7a90bd5bce7f2a" translate="yes" xml:space="preserve">
          <source>By being an xml field, some of the concerns can be addressed.</source>
          <target state="translated">xmlフィールドであることで、いくつかの懸念事項に対処することができます。</target>
        </trans-unit>
        <trans-unit id="96484fc83fcf63f76507517efe55769d93c8351d" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t delete a value from the list without fetching the whole list.</source>
          <target state="translated">リスト全体をフェッチしないと、リストから値を削除できません。</target>
        </trans-unit>
        <trans-unit id="5e342bb4206cf556c313a7fa707fa608068f4d41" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t enforce uniqueness: no way to prevent &lt;em&gt;1,2,3,3,3,5&lt;/em&gt;</source>
          <target state="translated">一意性を強制できません： &lt;em&gt;1、2、3、3、3、5&lt;/em&gt;を防ぐ方法はありません</target>
        </trans-unit>
        <trans-unit id="3d1e23e394102b96f65790a58c9b56d3fa91be9c" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t ensure that each value is the right data type: no way to prevent &lt;em&gt;1,2,3,banana,5&lt;/em&gt;</source>
          <target state="translated">各値が正しいデータ型であることを確認できません： &lt;em&gt;1,2,3、banana、5&lt;/em&gt;を防ぐ方法はありません</target>
        </trans-unit>
        <trans-unit id="64461d6b927467f175babcaa6dfee593f032e245" translate="yes" xml:space="preserve">
          <source>Can&amp;rsquo;t use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.</source>
          <target state="translated">外部キー制約を使用して値をルックアップテーブルにリンクすることはできません。 参照整合性を適用する方法はありません。</target>
        </trans-unit>
        <trans-unit id="d4903c42663fd89a04a7592de03256b26c309966" translate="yes" xml:space="preserve">
          <source>Can't store a list longer than what fits in the string column.</source>
          <target state="translated">文字列列の列に収まる長さよりも長いリストを保存できない。</target>
        </trans-unit>
        <trans-unit id="082848626a434057c827806a8fd39ae812f9ff3e" translate="yes" xml:space="preserve">
          <source>Comma-separated lists are wrong enough that I made this the first chapter in my book: &lt;a href=&quot;http://www.pragprog.com/titles/bksqla/sql-antipatterns&quot;&gt;SQL Antipatterns: Avoiding the Pitfalls of Database Programming&lt;/a&gt;.</source>
          <target state="translated">カンマ区切りのリストは間違っているので、この本を&lt;a href=&quot;http://www.pragprog.com/titles/bksqla/sql-antipatterns&quot;&gt;SQLアンチパターン：データベースプログラミングの落とし穴を回避する&lt;/a&gt;の最初の章にしました。</target>
        </trans-unit>
        <trans-unit id="5a1b0d85f6d36e43dd10314a16ce8957095a7c74" translate="yes" xml:space="preserve">
          <source>Hard to count elements in the list, or do other aggregate queries.</source>
          <target state="translated">リスト内の要素をカウントしたり、他の集計クエリを行うのが難しい。</target>
        </trans-unit>
        <trans-unit id="823a889b45ed2185a283c44397992f042154b32a" translate="yes" xml:space="preserve">
          <source>Hard to fetch the list in sorted order.</source>
          <target state="translated">リストをソート順に取得するのが難しい。</target>
        </trans-unit>
        <trans-unit id="569f55146a5b0b5ccc52a1131e4d457a3d13e287" translate="yes" xml:space="preserve">
          <source>Hard to join the values to the lookup table they reference.</source>
          <target state="translated">参照しているルックアップテーブルに値を結合するのが難しい。</target>
        </trans-unit>
        <trans-unit id="0d810b097c19e6f50b0523535bfffff879a11570" translate="yes" xml:space="preserve">
          <source>Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan. May have to resort to regular expressions, for example in MySQL:</source>
          <target state="translated">指定された値を持つすべてのエンティティをリストから検索するのは困難です。MySQLなどの正規表現に頼る必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="1f7c041a1a12ca4cd5aea56bdf5e32098bb7611a" translate="yes" xml:space="preserve">
          <source>Having said this: if the data you are choosing to store this way is data that you will never need to query by, then there may be a case for storing it in the way you have chosen.</source>
          <target state="translated">もし、この方法で保存することを選択しているデータが、決してクエリーする必要のないデータであれば、あなたが選択した方法で保存することができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c16c6ccd0c663eeab5678238a0bfe5252ec79798" translate="yes" xml:space="preserve">
          <source>I needed a multi-value column, it could be implemented as an xml field</source>
          <target state="translated">複数の値を持つカラムが必要だったので、xmlフィールドとして実装することができます。</target>
        </trans-unit>
        <trans-unit id="10dc0ee5f03cdb71f15e2cb4aa8c52ef1963754e" translate="yes" xml:space="preserve">
          <source>I thought the saved time and simpler code was worth it in my situation, is this a defensible design choice, or should I have normalized it from the start?</source>
          <target state="translated">私の状況では、時間の節約とコードのシンプル化は価値があると思ったのですが、これは防御可能な設計選択なのでしょうか、それとも最初から正規化しておくべきだったのでしょうか。</target>
        </trans-unit>
        <trans-unit id="28e7a833b484b5bd612c1994a32514df4ed75fdb" translate="yes" xml:space="preserve">
          <source>I would probably take the middle ground: make each field in the CSV into a separate column in the database, but not worry much about normalization (at least for now). At some point, normalization &lt;em&gt;might&lt;/em&gt; become interesting, but with all the data shoved into a single column you're gaining virtually no benefit from using a database at all. You need to separate the data into logical fields/columns/whatever you want to call them before you can manipulate it meaningfully at all.</source>
          <target state="translated">私はおそらく中立的な立場を取るでしょう。CSVの各フィールドをデータベースの個別の列にしますが、正規化についてはあまり気にしません（少なくとも現時点では）。 ある時点で、正規化&lt;em&gt;が&lt;/em&gt;興味深いものになる&lt;em&gt;可能性&lt;/em&gt;がありますが、すべてのデータが1つの列に入れられているため、データベースを使用してもほとんどメリットがありません。 意味のある操作を行う前に、データを論理フィールド/列/呼び出したいものに分割する必要があります。</target>
        </trans-unit>
        <trans-unit id="b03148bc19d2bd86b90c069d0d7ac9d993ddaf36" translate="yes" xml:space="preserve">
          <source>If you have a fixed number of boolean fields, you could use a &lt;code&gt;INT(1) NOT NULL&lt;/code&gt; (or &lt;code&gt;BIT NOT NULL&lt;/code&gt; if it exists) or &lt;code&gt;CHAR (0)&lt;/code&gt; (nullable) for each. You could also use a &lt;code&gt;SET&lt;/code&gt; (I forget the exact syntax).</source>
          <target state="translated">ブールフィールドの数が決まっている場合は、それぞれに &lt;code&gt;INT(1) NOT NULL&lt;/code&gt; （または、存在する場合は &lt;code&gt;BIT NOT NULL&lt;/code&gt; ）または &lt;code&gt;CHAR (0)&lt;/code&gt; （null可能）を使用できます。 また、 &lt;code&gt;SET&lt;/code&gt; を使用することもできます（正確な構文を忘れています）。</target>
        </trans-unit>
        <trans-unit id="b51caecb70bf82d71efd94cda96a700d5ee3373c" translate="yes" xml:space="preserve">
          <source>Imagine a web form with a set of check boxes (any or all of them can be selected). I chose to save them in a comma separated list of values stored in one column of the database table.</source>
          <target state="translated">チェックボックスのセットを持つWebフォームを想像してみてください(それらのうちのどれか、またはすべてを選択することができます)。私はそれらをデータベーステーブルの1列に保存された値のカンマ区切りのリストに保存することを選択しました。</target>
        </trans-unit>
        <trans-unit id="d3cb8dde911f769cd7183cd9cc767ec03b879e9f" translate="yes" xml:space="preserve">
          <source>In addition to violating &lt;a href=&quot;http://en.wikipedia.org/wiki/1NF&quot;&gt;First Normal Form&lt;/a&gt; because of the repeating group of values stored in a single column, comma-separated lists have a lot of other more practical problems:</source>
          <target state="translated">単一の列に格納された値の繰り返しグループが原因で&lt;a href=&quot;http://en.wikipedia.org/wiki/1NF&quot;&gt;第1正規形&lt;/a&gt;に違反することに加えて、コンマ区切りのリストには、他にも多くの実用的な問題があります。</target>
        </trans-unit>
        <trans-unit id="fe2e1c3207f9e33e8e2f1f3d075479803691398e" translate="yes" xml:space="preserve">
          <source>In general anything can be defensible if it meets the requirements of your project.  This doesn't mean that people will agree with or want to defend your decision...</source>
          <target state="translated">一般的には、プロジェクトの要件を満たしていれば、何でも擁護できます。これは、人々があなたの決定に同意したり、あなたの決定を擁護したりすることを意味するものではありません...</target>
        </trans-unit>
        <trans-unit id="e3701cdbecde26ed063beb5e13072aaf223d9db1" translate="yes" xml:space="preserve">
          <source>In general, storing data in this way is suboptimal (e.g. harder to do efficient queries) and may cause maintenance issues if you modify the items in your form.  Perhaps you could have found a middle ground and used an integer representing a set of bit flags instead?</source>
          <target state="translated">一般的に、この方法でデータを格納することは最適ではなく(例えば、効率的なクエリを行うのが難しくなる)、フォーム内の項目を変更した場合にメンテナンス上の問題が発生する可能性があります。おそらく、中間点を見つけて、代わりにビットフラグのセットを表す整数を使うことができたのではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="a3bf060c7229a7de0c733617110b5fb79a611283" translate="yes" xml:space="preserve">
          <source>In short, using XML gets around some of the issues with delimited list AND can be converted to a delimited list as needed</source>
          <target state="translated">要するに、XML を使用することで、区切りリスト AND の問題のいくつかを回避し、必要に応じて区切りリストに変換することができます。</target>
        </trans-unit>
        <trans-unit id="aeac6386d7b159eafa028850b5bc0c1ef63f2fb4" translate="yes" xml:space="preserve">
          <source>Is storing a delimited list in a database column really that bad</source>
          <target state="translated">区切りリストをデータベースのカラムに格納することは本当に悪いことなのでしょうか?</target>
        </trans-unit>
        <trans-unit id="97e14d78d8fcd13dfe964f4b10dc17b1a77e933f" translate="yes" xml:space="preserve">
          <source>It breaks first normal form.</source>
          <target state="translated">それは最初の通常のフォームを壊します。</target>
        </trans-unit>
        <trans-unit id="80115ba213ccc5865ea9eacf73cb79e12bcf165b" translate="yes" xml:space="preserve">
          <source>It could be converted to a comma delimited as necessary</source>
          <target state="translated">必要に応じてカンマ区切りに変換することができます。</target>
        </trans-unit>
        <trans-unit id="912626e5ca115be5c77c6a33ebf715da01ac2286" translate="yes" xml:space="preserve">
          <source>Now, I know that the correct solution would be to create a second table and properly normalize the database. It was quicker to implement the easy solution, and I wanted to have a proof-of-concept of that application quickly and without having to spend too much time on it.</source>
          <target state="translated">さて、2つ目のテーブルを作成して、データベースを適切に正規化するのが正しい解決策であることは分かっています。簡単な解決策を実装する方が手っ取り早く、時間をかけずに早くそのアプリケーションの概念実証をしたいと思ったのです。</target>
        </trans-unit>
        <trans-unit id="6ac999a9ea9159ccedab7c41ae7027da9d5975cb" translate="yes" xml:space="preserve">
          <source>Or leave it as it is and learn the painful lesson of a SQL injection attack.</source>
          <target state="translated">あるいは、そのままにしておいて、SQLインジェクション攻撃の痛快な教訓を学びましょう。</target>
        </trans-unit>
        <trans-unit id="b4fd9c9094921aa024f79d741e132ebfd65b918a" translate="yes" xml:space="preserve">
          <source>Some more context, this is a small internal application that essentially replaces an Excel file that was stored on a shared folder. I'm also asking because I'm thinking about cleaning up the program and make it more maintainable. There are some things in there I'm not entirely happy with, one of them is the topic of this question.</source>
          <target state="translated">もう少し詳しく説明すると、これは共有フォルダに保存されていたExcelファイルを本質的に置き換える小さな内部アプリケーションです。私はまた、プログラムをクリーンアップして、より保守性を高めることを考えているので質問しているのですが、その中には私が完全に満足していないものがいくつかあります。この中には私が完全に満足していないものがいくつかありますが、そのうちの一つがこの質問のトピックです。</target>
        </trans-unit>
        <trans-unit id="1e1888bea44887d7106486a4c61a983782604b84" translate="yes" xml:space="preserve">
          <source>There are numerous questions on SO asking:</source>
          <target state="translated">SOの質問には多数の質問があります。</target>
        </trans-unit>
        <trans-unit id="9a84b7e969e00182b83777fed2208ed47140465d" translate="yes" xml:space="preserve">
          <source>There are times when you need to employ denormalization, but as &lt;a href=&quot;https://stackoverflow.com/a/3653507/578288&quot;&gt;@OMG Ponies mentions&lt;/a&gt;, these are exception cases.  Any non-relational &amp;ldquo;optimization&amp;rdquo; benefits one type of query at the expense of other uses of the data, so be sure you know which of your queries need to be treated so specially that they deserve denormalization.</source>
          <target state="translated">非正規化を採用する必要がある場合もありますが、 &lt;a href=&quot;https://stackoverflow.com/a/3653507/578288&quot;&gt;@ OMG Poniesが言及しているように&lt;/a&gt; 、これらは例外的なケースです。 非リレーショナルな「最適化」は、データの他の用途を犠牲にして1種類のクエリにメリットをもたらすため、非正規化に値するほど特別に処理する必要があるクエリを必ず確認してください。</target>
        </trans-unit>
        <trans-unit id="a69f4ce2a888b0fa6f01d65a683a22ce67bbfb61" translate="yes" xml:space="preserve">
          <source>These are all symptoms of denormalized data, and highlight why you should always model for normalized data.  Denormalization &lt;em&gt;can&lt;/em&gt; be a query optimization, &lt;strong&gt;&lt;em&gt;to be applied when the need actually presents itself&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">これらはすべて非正規化データの症状であり、常に正規化データをモデル化する必要がある理由を強調しています。 非正規化&lt;em&gt;は&lt;/em&gt;クエリの最適化で&lt;strong&gt;&lt;em&gt;あり、ニーズが実際に存在する場合に適用されます&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="78c32156deeaf2132bbf7495a555c415ae3d6de1" translate="yes" xml:space="preserve">
          <source>This rings alarm bells. The only reason you should do something like this is that you know how to do it &quot;the right way&quot; but you have come to the conclusion that there is a tangible reason not to do it that way.</source>
          <target state="translated">これは警鐘を鳴らす。このようなことをしなければならない唯一の理由は、「正しい方法」を知っていても、その方法をしてはいけない具体的な理由があるという結論に達しているからです。</target>
        </trans-unit>
        <trans-unit id="80ae79906b4af913c8570f4d8e489f10152b94c4" translate="yes" xml:space="preserve">
          <source>To solve these problems, you have to write tons of application code, reinventing functionality that the RDBMS &lt;em&gt;already provides much more efficiently&lt;/em&gt;.</source>
          <target state="translated">これらの問題を解決するには、大量のアプリケーションコードを記述して、RDBMSが&lt;em&gt;すでにより効率的に提供し&lt;/em&gt;ている機能を再発明する&lt;em&gt;必要があります&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a2f298a9edab70d9b108437f88211587fed4d83" translate="yes" xml:space="preserve">
          <source>Well I've been using a key/value pair tab separated list in a NTEXT column in SQL Server for more than 4 years now and it works. You do lose the flexibility of making queries but on the other hand, if you have a library that persists/derpersists the key value pair then it's not a that bad idea.</source>
          <target state="translated">私は4年以上前からSQL ServerのNTEXTカラムでキーと値のペアをタブで区切ったリストを使用していますが、それはうまく機能しています。クエリ作成の柔軟性は失われますが、一方で、キー値ペアを永続化するライブラリがあれば、それはそれほど悪い考えではありません。</target>
        </trans-unit>
        <trans-unit id="23b6479b9f4b73c294ee003479355e4d49c741ed" translate="yes" xml:space="preserve">
          <source>What you're calling laziness and lack of SQL knowledge is the stuff that neophytes are made of.  I'd recommend taking the time to do it properly and view it as an opportunity to learn.</source>
          <target state="translated">怠惰といい、SQLの知識がないといいますのは、初心者がやることですよね。時間をかけてきちんとやって、学ぶ機会と捉えた方がいいと思います。</target>
        </trans-unit>
        <trans-unit id="0da840e085ebfe0f26931a3075af7cadfe521dc0" translate="yes" xml:space="preserve">
          <source>Yes, I would say that it really is that bad.  It's a defensible choice, but that doesn't make it correct or good.</source>
          <target state="translated">そうですね、本当にそれだけ悪いことだと思います。正当な選択だが、だからといってそれが正しいとか良いとかいうことにはならない。</target>
        </trans-unit>
        <trans-unit id="9c0421fdef72069541967dceb38557cfa5b088a0" translate="yes" xml:space="preserve">
          <source>Yes, it &lt;em&gt;is&lt;/em&gt; that bad.  My view is that if you don't like using relational databases then look for an alternative that suits you better, there are lots of interesting &quot;NOSQL&quot; projects out there with some really advanced features.</source>
          <target state="translated">はい、それ&lt;em&gt;は&lt;/em&gt;悪いです。 私の見解では、リレーショナルデータベースを使用したくない場合は、自分に適した代替案を探してください。非常に高度な機能を備えた興味深い「NOSQL」プロジェクトがたくさんあります。</target>
        </trans-unit>
        <trans-unit id="ac1512f8b79726851af69c8b05819175a17cd5cc" translate="yes" xml:space="preserve">
          <source>how to get a count of specific values from the comma separated list</source>
          <target state="translated">カンマ区切りのリストから特定の値のカウントを取得する方法</target>
        </trans-unit>
        <trans-unit id="22bb0c71811e7ae7fb998abd6e1d9e06140ec61b" translate="yes" xml:space="preserve">
          <source>how to get records that have only the same 2/3/etc specific value from that comma separated list</source>
          <target state="translated">カンマで区切られたリストから、同じ 23etc の特定の値だけを持つレコードを取得する方法</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
