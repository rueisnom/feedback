<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/46898">
    <body>
      <group id="46898">
        <trans-unit id="d30462a41bd01ccebda2cf58a3b8353e1b7840fd" translate="yes" xml:space="preserve">
          <source>0 (#:0):0, 1 (#:1):1, 2 (#:2):2, 3 (#:3):3, 4 (#:4):4, 5 (#:5):5, 6 (#:6):6, 7 (#:7):7, 8 (#:8):8, 9 (#:9):9, 10 (#:10):10,</source>
          <target state="translated">0 (#:0):0,1 (#:1):1,2 (#:2):2,3 (#:3):3,4 (#:4):4,5 (#:5):5,6 (#:6):6,7 (#:7):7,8 (#:8):8,9 (#:9):9,10 (#:10):10,</target>
        </trans-unit>
        <trans-unit id="2ddf1133bc32496871045e6d597d4d6a1dc1e8da" translate="yes" xml:space="preserve">
          <source>0 : 0, 1 : 1, 2 : 2, 3 : 3, 4 : 4, 5 : 5, 6 : 6, 7 : 7, 8 : 8, 9 : 9, 10 : 10,</source>
          <target state="translated">0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,10:10,</target>
        </trans-unit>
        <trans-unit id="40f71110f1c6d89a83d5d74998a6bae84cb0eac9" translate="yes" xml:space="preserve">
          <source>1.) Iterate through the &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#keySet%28%29&quot;&gt;&lt;code&gt;keys -&amp;gt; keySet()&lt;/code&gt;&lt;/a&gt; of the map:</source>
          <target state="translated">1.）マップの&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#keySet%28%29&quot;&gt; &lt;code&gt;keys -&amp;gt; keySet()&lt;/code&gt; &lt;/a&gt;を反復処理します。</target>
        </trans-unit>
        <trans-unit id="b434c39c68821bc91a36a5d79143911b1685346e" translate="yes" xml:space="preserve">
          <source>10 (#=10):10, 9 (#=9):9, 8 (#=8):8, 7 (#=7):7, 6 (#=6):6, 5 (#=5):5, 4 (#=4):4, 3 (#=3):3, 2 (#=2):2, 1 (#=1):1, 0 (#=0):0,</source>
          <target state="translated">10 (#=10):10,9 (#=9):9,8 (#=8):8,7 (#=7):7,6 (#=6):6,5 (#=5):5,4 (#=4):4,3 (#=3):3,2 (#=2):2,1 (#=1):1,0 (#=0):0,</target>
        </trans-unit>
        <trans-unit id="07e7842ae451e8b223fddd46806bc2418f4d8622" translate="yes" xml:space="preserve">
          <source>10 : 10, 9 : 9, 8 : 8, 7 : 7, 6 : 6, 5 : 5, 4 : 4, 3 : 3, 2 : 2, 1 : 1, 0 : 0,</source>
          <target state="translated">10:10,9:9,8:8,7:7,6:6,5:5,4:4,3:3,2:2,1:1,0:0,</target>
        </trans-unit>
        <trans-unit id="76c3ebd56308a64015138e37e4c85af5080783a3" translate="yes" xml:space="preserve">
          <source>2.) Iterate through the &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#values%28%29&quot;&gt;&lt;code&gt;values -&amp;gt; values()&lt;/code&gt;&lt;/a&gt; of the map:</source>
          <target state="translated">2.）マップの&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#values%28%29&quot;&gt; &lt;code&gt;values -&amp;gt; values()&lt;/code&gt; &lt;/a&gt;を反復処理します。</target>
        </trans-unit>
        <trans-unit id="a3bbdbbb036debbd91e9605d4745f68dd12997a6" translate="yes" xml:space="preserve">
          <source>3.) Iterate through the &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#entrySet%28%29&quot;&gt;&lt;code&gt;both -&amp;gt; entrySet()&lt;/code&gt;&lt;/a&gt; of the map:</source>
          <target state="translated">3.）マップの&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#entrySet%28%29&quot;&gt; &lt;code&gt;both -&amp;gt; entrySet()&lt;/code&gt; &lt;/a&gt;を反復します。</target>
        </trans-unit>
        <trans-unit id="0bdeeaef0187d00458632d3659a4402cd79e9934" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/46898/how-to-efficiently-iterate-over-each-entry-in-a-map/46908#46908&quot;&gt;@ScArcher2 has the more elegant Java 1.5 syntax&lt;/a&gt;. In 1.4, I would do something like this:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/46898/how-to-efficiently-iterate-over-each-entry-in-a-map/46908#46908&quot;&gt;@ ScArcher2には、よりエレガントなJava 1.5構文があります&lt;/a&gt; 。 1.4では、次のようにします。</target>
        </trans-unit>
        <trans-unit id="78fd64c50744c65d102273e78ce957c849ebbeff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is the canonical map implementation and doesn't make guarantees (or though it should not change order if no mutating operation are performed on it). &lt;code&gt;SortedMap&lt;/code&gt; will return entries based on the natural ordering of the keys, or a &lt;code&gt;Comparator&lt;/code&gt;, if provided. &lt;code&gt;LinkedHashMap&lt;/code&gt; will either return entries in insertion-order or access-order depending upon how it has been constructed. &lt;code&gt;EnumMap&lt;/code&gt; returns entries in natural order of keys.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; は正規のマップ実装であり、保証はしません（または、変更操作が実行されない場合は順序を変更しないでください）。 &lt;code&gt;SortedMap&lt;/code&gt; は、キーの自然な順序、または提供されている場合は &lt;code&gt;Comparator&lt;/code&gt; に基づいてエントリを返します。 &lt;code&gt;LinkedHashMap&lt;/code&gt; は、構築方法に応じて、挿入順またはアクセス順でエントリを返します。 &lt;code&gt;EnumMap&lt;/code&gt; は、キーの自然な順序でエントリを返します。</target>
        </trans-unit>
        <trans-unit id="df9e23213522feb0f851809e192dbba0cd4ef337" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NavigableMap&lt;/code&gt; interface</source>
          <target state="translated">&lt;code&gt;NavigableMap&lt;/code&gt; インターフェース</target>
        </trans-unit>
        <trans-unit id="b8061c26823755d99e280ad254f9a7a64a9225cb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;50 milliseconds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;50ミリ秒&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1f2a23cfa6ed0be46057a39259af74d813bd4b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;75 milliseconds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;75ミリ秒&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7551ebfccb1284552c4ac29e34b7aecc41ed5dfe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;76 milliseconds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;76ミリ秒&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87d7a5349b3fd394b840fd8e8315f40c28028239" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;How to iterate over the entries of a Map&lt;/em&gt; - @ScArcher2 has &lt;a href=&quot;https://stackoverflow.com/a/46908/1851302&quot;&gt;answered&lt;/a&gt; that perfectly.</source>
          <target state="translated">&lt;em&gt;マップのエントリを反復処理する方法&lt;/em&gt; -@ ScArcher2は完全にそれに&lt;a href=&quot;https://stackoverflow.com/a/46908/1851302&quot;&gt;答えまし&lt;/a&gt;た。</target>
        </trans-unit>
        <trans-unit id="8c8940fb37dfcfef05c009e102fb571f8441ea00" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you want to write a conditional for lambda you can write it like this:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ラムダの条件を記述したい場合は、次のように記述できます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a34520f314ded34eb3cacb1a2590ee9c9299821" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Moreover, there are 3 difference ways to Iterate Through a HashMap. They are as below&lt;/em&gt;_</source>
          <target state="translated">&lt;em&gt;さらに、HashMapを反復処理するには3つの異なる方法があります。&lt;/em&gt; &lt;em&gt;彼らは以下の通りです&lt;/em&gt; _</target>
        </trans-unit>
        <trans-unit id="ff6cb7605a078a3bfb48c2579c0969790a6fed46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the order of iteration&lt;/em&gt; - if you are just using &lt;code&gt;Map&lt;/code&gt;, then strictly speaking, there are &lt;strong&gt;no ordering guarantees&lt;/strong&gt;.  So you shouldn't really rely on the ordering given by any implementation.  However, the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt; interface extends &lt;code&gt;Map&lt;/code&gt; and provides exactly what you are looking for - implementations will aways give a consistent sort order.</source>
          <target state="translated">&lt;em&gt;反復の順序は何ですか？&lt;/em&gt; &lt;code&gt;Map&lt;/code&gt; を使用しているだけの場合、厳密に言うと、 &lt;strong&gt;順序の保証&lt;/strong&gt;はあり&lt;strong&gt;ません&lt;/strong&gt; 。 そのため、実装によって与えられた順序に実際に依存すべきではありません。 ただし、 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt; &lt;code&gt;SortedMap&lt;/code&gt; &lt;/a&gt;インターフェースは &lt;code&gt;Map&lt;/code&gt; を拡張し、 ユーザーが探しているものを正確に提供します。実装によって、一貫した並べ替え順序が提供されます。</target>
        </trans-unit>
        <trans-unit id="7b9f49f0624beecc76e4c400005cc314c104082e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(Update: I think this is no longer true.&lt;/strong&gt;) Note, &lt;code&gt;IdentityHashMap&lt;/code&gt;&lt;code&gt;entrySet&lt;/code&gt; iterator currently has a peculiar implementation which returns the same &lt;code&gt;Map.Entry&lt;/code&gt; instance for every item in the &lt;code&gt;entrySet&lt;/code&gt;! However, every time a new the iterator advances the &lt;code&gt;Map.Entry&lt;/code&gt; is updated.</source>
          <target state="translated">&lt;strong&gt;（更新：これはもう&lt;/strong&gt; &lt;code&gt;entrySet&lt;/code&gt; &lt;strong&gt;ないと思います。&lt;/strong&gt; ）注、 &lt;code&gt;IdentityHashMap&lt;/code&gt; entrySetイテレーターには現在、 &lt;code&gt;entrySet&lt;/code&gt; 内のすべての項目に対して同じ &lt;code&gt;Map.Entry&lt;/code&gt; インスタンスを返す固有の実装があります。 ただし、新しい反復子が &lt;code&gt;Map.Entry&lt;/code&gt; を進めるたびに更新されます。</target>
        </trans-unit>
        <trans-unit id="4b08e1ea1a9950c8944da65f4d98ac8bce434bec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Using &lt;code&gt;entrySet()&lt;/code&gt; in for each loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）各ループで &lt;code&gt;entrySet()&lt;/code&gt; ）を使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef4f8dcdb2b42abc6c11a4507ae8f995723b6a25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Using &lt;code&gt;keySet()&lt;/code&gt; in for each loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）各ループで &lt;code&gt;keySet()&lt;/code&gt; ）を使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ce455fc72a7bee227dd834267207040b1408afb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Using &lt;code&gt;entrySet()&lt;/code&gt; and iterator&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3） &lt;code&gt;entrySet()&lt;/code&gt; とイテレータを使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f68c4111f1efcd5940165c5462abd76292ca5156" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4) Using &lt;code&gt;keySet()&lt;/code&gt; and iterator&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4） &lt;code&gt;keySet()&lt;/code&gt; とイテレータを使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01ab40a6cbbbd4ccc44c8cf3e70babf4c8d349fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; is another useful extension&lt;/strong&gt; - this is a &lt;code&gt;SortedMap&lt;/code&gt; with additional methods for finding entries by their ordered position in the key set.  So potentially this can remove the need for iterating in the first place - you might be able to find the specific &lt;code&gt;entry&lt;/code&gt; you are after using the &lt;code&gt;higherEntry&lt;/code&gt;, &lt;code&gt;lowerEntry&lt;/code&gt;, &lt;code&gt;ceilingEntry&lt;/code&gt;, or &lt;code&gt;floorEntry&lt;/code&gt; methods.  The &lt;code&gt;descendingMap&lt;/code&gt; method even gives you an explicit method of &lt;strong&gt;reversing the traversal order&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt;は、もう1つの便利な拡張機能&lt;/strong&gt; &lt;code&gt;SortedMap&lt;/code&gt; これは、キーセット内の順序付けされた位置でエントリを検索するための追加のメソッドを持つSortedMapです 。 したがって、これにより、最初に反復する必要がなくなる可能性があります &lt;code&gt;floorEntry&lt;/code&gt; メソッド、 lowerEntryメソッド、 ceilingEntryメソッド、またはfloorEntryメソッドを使用すると、特定の &lt;code&gt;entry&lt;/code&gt; を見つけることができる場合があります。 &lt;code&gt;descendingMap&lt;/code&gt; メソッド&lt;strong&gt;は、走査順序&lt;/strong&gt;を&lt;strong&gt;逆に&lt;/strong&gt;する明示的な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="b0bdd3f912a52ada1dd392cd4ff14c74d0be6fcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;forEachOrdered&lt;/code&gt; vs &lt;code&gt;forEach&lt;/code&gt; with streams ?&lt;/strong&gt;
The &lt;code&gt;forEach&lt;/code&gt; does not follow encounter order (if defined) and is inherently non-deterministic in nature where as the &lt;code&gt;forEachOrdered&lt;/code&gt; does. So &lt;code&gt;forEach&lt;/code&gt; does not guarantee that the order would be kept. Also check &lt;a href=&quot;https://stackoverflow.com/questions/32797579/foreach-vs-foreachordered-in-java-8-stream&quot;&gt;this&lt;/a&gt; for more.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;forEachOrdered&lt;/code&gt; と &lt;code&gt;forEach&lt;/code&gt; をストリームで？&lt;/strong&gt; &lt;code&gt;forEach&lt;/code&gt; はエンカウンター順序（定義されている場合）に従いません。また、 &lt;code&gt;forEachOrdered&lt;/code&gt; がそうであるように、本質的に本質的に非決定的です。 したがって、 &lt;code&gt;forEach&lt;/code&gt; は順序が保持されることを保証しません。 詳細については、こちらも確認&lt;a href=&quot;https://stackoverflow.com/questions/32797579/foreach-vs-foreachordered-in-java-8-stream&quot;&gt;し&lt;/a&gt;てください。</target>
        </trans-unit>
        <trans-unit id="22c727b2a9f2723354a008790444a6d3c6f5ce17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An effective iterative solution over a Map is a 'for each' loop from Java 5 through Java 7. Here it is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Mapに対する効果的な反復ソリューションは、Java 5からJava 7までの「for each」ループです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c3c99f01f82e3dd15f6dea31f73807e5a330c16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Java 8 you can use a lambda expression to iterate over a Map. It is an enhanced 'forEach'&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java 8以降では、ラムダ式を使用してマップを反復できます。&lt;/strong&gt; &lt;strong&gt;拡張された「forEach」です&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8266e1e95a5d91ff447f8d45a4314d7d0606da42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterate over entries (Using forEach and Streams):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;エントリを反復処理します（forEachおよびStreamsを使用）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ef22017e708698482a126b2fe682a8f6d486473" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterate over keys:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;キーを反復する：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf9bdb43bd1b0449f7175e791319748eebbd91f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterate over values:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;値を反復する：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b958957df67e5e3894ae54fdec131a5fab7b7758" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java 8:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java 8：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4ac5345e9dfeab6eedab1bed3634a2d61b232bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lambda&lt;/strong&gt; Expression Java 8</source>
          <target state="translated">&lt;strong&gt;ラムダ&lt;/strong&gt;式Java 8</target>
        </trans-unit>
        <trans-unit id="cb33563a72610ed34b6b91ac165e4604be35ec62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I am a committer for Eclipse Collections.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;私はEclipseコレクションのコミッターです。</target>
        </trans-unit>
        <trans-unit id="4eaa4758fc373a92b0951b602e363208503de373" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Perfomance tests&lt;/strong&gt; (mode = AverageTime, system = Windows&amp;nbsp;8.1 64-bit, Intel i7-4790 3.60 GHz, 16&amp;nbsp;GB)</source>
          <target state="translated">&lt;strong&gt;パフォーマンステスト&lt;/strong&gt; （モード= AverageTime、システム= Windows 8.1 64ビット、Intel i7-4790 3.60 GHz、16 GB）</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a2c64a759bdeec979cf1625cb2640fed35b8352" translate="yes" xml:space="preserve">
          <source>All tests are on &lt;a href=&quot;https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/5.0-other-examples/src/main/java/other_examples/IterateThroughHashMapTest.java&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">すべてのテストは&lt;a href=&quot;https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/5.0-other-examples/src/main/java/other_examples/IterateThroughHashMapTest.java&quot;&gt;GitHubで&lt;/a&gt;行われます 。</target>
        </trans-unit>
        <trans-unit id="e62b6b46bd13f4fdff912caff47e1c5ab9468154" translate="yes" xml:space="preserve">
          <source>Also one can use &lt;strong&gt;Spliterator&lt;/strong&gt; for the same.</source>
          <target state="translated">また、 &lt;strong&gt;Splitatorator&lt;/strong&gt;を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="d4a128155fdd1ff9b255b50be54783cd11c5ad9a" translate="yes" xml:space="preserve">
          <source>And yes, the order will depend on the implementation - as well as (possibly) the order of insertion and other hard-to-control factors.</source>
          <target state="translated">そして、そうです、順序は実装に依存します-同様に(おそらく)挿入の順序やその他の制御が困難な要因と同様に。</target>
        </trans-unit>
        <trans-unit id="1987a85346ebed06208fda36057d3abf53a7dac9" translate="yes" xml:space="preserve">
          <source>Below is the sample code that I tried using &lt;strong&gt;Lambda Expression&lt;/strong&gt;. This stuff is so cool. Must try.</source>
          <target state="translated">以下は、 &lt;strong&gt;ラムダ式&lt;/strong&gt;を使用して試したサンプルコードです。 このものはとてもクールです。 しようとする必要があります。</target>
        </trans-unit>
        <trans-unit id="0091670d7a16db16eebf59a5b133fa1d4fcd9465" translate="yes" xml:space="preserve">
          <source>Both of these considerations are covered in the graphic table above.</source>
          <target state="translated">これらの考慮事項の両方は、上のグラフィックテーブルでカバーされています。</target>
        </trans-unit>
        <trans-unit id="837ca224c76bb8e31244cbe08276255126afae2e" translate="yes" xml:space="preserve">
          <source>Concurrency. If you are manipulating the map across threads, you must use an implementation that supports concurrency. Or wrap the map with &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)&quot;&gt;&lt;code&gt;Collections::synchronizedMap&lt;/code&gt;&lt;/a&gt; (less preferable).</source>
          <target state="translated">並行性。 スレッド間でマップを操作する場合は、並行性をサポートする実装を使用する必要があります。 または、マップを&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)&quot;&gt; &lt;code&gt;Collections::synchronizedMap&lt;/code&gt; &lt;/a&gt;でラップします（あまり好ましくありません）。</target>
        </trans-unit>
        <trans-unit id="a7a59840fd712513666eaaab628bba060fffd164" translate="yes" xml:space="preserve">
          <source>Custom order</source>
          <target state="translated">カスタムオーダー</target>
        </trans-unit>
        <trans-unit id="688d350fb8020500a3a5be3e3b008424818af135" translate="yes" xml:space="preserve">
          <source>Different implementations of &lt;code&gt;Map&lt;/code&gt; maintain different ordering of the key-value pairs.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; の実装が異なると、キーと値のペアの順序も異なります。</target>
        </trans-unit>
        <trans-unit id="7c4c9d6bd088dbbd8d4fa9483665571f6a073ca9" translate="yes" xml:space="preserve">
          <source>Easy-peasy!</source>
          <target state="translated">Easy-peasy!</target>
        </trans-unit>
        <trans-unit id="4959fdef810c5bd96c8690ab36e2ce54b0823aaf" translate="yes" xml:space="preserve">
          <source>Enum-definition order</source>
          <target state="translated">列挙定義順序</target>
        </trans-unit>
        <trans-unit id="27a91e453073eb90ef706eff0718c26b5d331956" translate="yes" xml:space="preserve">
          <source>Example of using iterator and generics:</source>
          <target state="translated">イテレータとジェネリックの使用例。</target>
        </trans-unit>
        <trans-unit id="dedaf2462a308ba9703f6ecfa549331ea9c670df" translate="yes" xml:space="preserve">
          <source>FYI, you can also use &lt;code&gt;map.keySet()&lt;/code&gt; and &lt;code&gt;map.values()&lt;/code&gt; if you're only interested in keys/values of the map and not the other.</source>
          <target state="translated">&lt;code&gt;map.values()&lt;/code&gt; 、マップのキー/値だけに関心があり、他のキー/値に関心がない場合は、 &lt;code&gt;map.keySet()&lt;/code&gt; とmap.values（）を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="56136984733171a2679dc40bd33baad71f4c3786" translate="yes" xml:space="preserve">
          <source>For a map with 10000 elements,  score 37.606 is the best</source>
          <target state="translated">10000要素の地図の場合、スコア37.606は</target>
        </trans-unit>
        <trans-unit id="a5c0d4e335042175498e0ebf6327fd535efec693" translate="yes" xml:space="preserve">
          <source>For a map with 100000 elements,  score 1184.767 is the best</source>
          <target state="translated">100000要素の地図の場合、スコア1184.767は</target>
        </trans-unit>
        <trans-unit id="c1de52942477197f09659d082fa1f4b07b8f1bd4" translate="yes" xml:space="preserve">
          <source>For a small map (100 elements), score 0.308 is the best</source>
          <target state="translated">小さなマップ(100要素)の場合、スコア0.308がベスト</target>
        </trans-unit>
        <trans-unit id="7c1760d6bcb4b3d1af55825b8f0c542185f248bd" translate="yes" xml:space="preserve">
          <source>For more information, follow &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;this&lt;/a&gt;.</source>
          <target state="translated">詳細については、こちらに従っ&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;てください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa0445de7e6bc5d4ad795d112414a663bfe8f9b3" translate="yes" xml:space="preserve">
          <source>Graphs (performance tests depending on map size)</source>
          <target state="translated">グラフ(マップサイズによる性能テスト</target>
        </trans-unit>
        <trans-unit id="bf9babdab1657af8a0b764ba2e4045ed70ec5482" translate="yes" xml:space="preserve">
          <source>HashMap (1):</source>
          <target state="translated">ハッシュマップ(1)。</target>
        </trans-unit>
        <trans-unit id="8b2a0ebe1a9c40551264d3a2911adb4c9595e1ae" translate="yes" xml:space="preserve">
          <source>HashMap (2):</source>
          <target state="translated">ハッシュマップ(2)。</target>
        </trans-unit>
        <trans-unit id="ae33e1c12dd25e01506d37831a6c63b1eed254c7" translate="yes" xml:space="preserve">
          <source>Here is comparison of their performances for a common data set stored in map by storing a million key value pairs in map and will iterate over map.</source>
          <target state="translated">ここでは、100万個のキーバリューペアをmapに格納し、map上で反復処理を行うことで、mapに格納された共通のデータセットに対する性能を比較しています。</target>
        </trans-unit>
        <trans-unit id="2944fefd1e8c80dfefdf09ccf6789028fa2e370d" translate="yes" xml:space="preserve">
          <source>How do I efficiently iterate over each entry in a Java Map</source>
          <target state="translated">Javaマップの各エントリを効率的に反復処理するにはどうすればよいか</target>
        </trans-unit>
        <trans-unit id="8c44dd09a51d3d7e7030ada02609d672731914d5" translate="yes" xml:space="preserve">
          <source>I have referred &lt;a href=&quot;http://howtodoinjava.com/2013/04/01/performance-comparison-of-different-ways-to-iterate-over-hashmap/&quot;&gt;&lt;code&gt;this link&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://howtodoinjava.com/2013/04/01/performance-comparison-of-different-ways-to-iterate-over-hashmap/&quot;&gt; &lt;code&gt;this link&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c86089bda3ea538b5612baeee4089a884b97993" translate="yes" xml:space="preserve">
          <source>If I have an object implementing the &lt;code&gt;Map&lt;/code&gt; interface in Java and I wish to iterate over every pair contained within it,  what is the most efficient way of going through the map?</source>
          <target state="translated">Javaで &lt;code&gt;Map&lt;/code&gt; インターフェースを実装するオブジェクトがあり、その中に含まれるすべてのペアを反復処理したい場合、マップを通過する最も効率的な方法は何ですか？</target>
        </trans-unit>
        <trans-unit id="7041d241864f2b22ad51ff33422107bb1546c0c8" translate="yes" xml:space="preserve">
          <source>If I have an object implementing the Map interface in Java and I wish to iterate over every pair contained within it, what is the most efficient way of going through the map?</source>
          <target state="translated">Java で Map インターフェースを実装したオブジェクトがあり、その中に含まれるすべてのペアを反復処理したい場合、マップを通過する最も効率的な方法は何ですか?</target>
        </trans-unit>
        <trans-unit id="79fa69f9b9f2bab1a018ec5832646f7d9c599a86" translate="yes" xml:space="preserve">
          <source>If efficiency of looping the keys is a priority for your app, then choose a &lt;code&gt;Map&lt;/code&gt; implementation that maintains the keys in your desired order.</source>
          <target state="translated">キーをループする効率がアプリの優先事項である場合は、キーを希望の順序で維持する &lt;code&gt;Map&lt;/code&gt; 実装を選択します。</target>
        </trans-unit>
        <trans-unit id="6411814b84ed759c763447c4612e9d83026c997c" translate="yes" xml:space="preserve">
          <source>If you are using an enum such as &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/DayOfWeek.html&quot;&gt;&lt;code&gt;DayOfWeek&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Month.html&quot;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/a&gt; as your keys, use the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/EnumMap.html&quot;&gt;&lt;code&gt;EnumMap&lt;/code&gt;&lt;/a&gt; class. Not only is this class &lt;em&gt;highly&lt;/em&gt; optimized to use very little memory and run very fast, it maintains your pairs in the order defined by the enum. For &lt;code&gt;DayOfWeek&lt;/code&gt;, for example, the key of &lt;code&gt;DayOfWeek.MONDAY&lt;/code&gt; will be first found when iterated, and the key of &lt;code&gt;DayOfWeek.SUNDAY&lt;/code&gt; will be last.</source>
          <target state="translated">キーとして&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/DayOfWeek.html&quot;&gt; &lt;code&gt;DayOfWeek&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Month.html&quot;&gt; &lt;code&gt;Month&lt;/code&gt; &lt;/a&gt;などの列挙型を使用している場合は、 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/EnumMap.html&quot;&gt; &lt;code&gt;EnumMap&lt;/code&gt; &lt;/a&gt;クラスを使用します。 このクラスは、メモリをほとんど使用せずに非常に高速に実行するように&lt;em&gt;高度に&lt;/em&gt;最適化されているだけでなく、列挙型で定義された順序でペアを維持しています。 たとえば、 &lt;code&gt;DayOfWeek&lt;/code&gt; の場合、反復時に &lt;code&gt;DayOfWeek.MONDAY&lt;/code&gt; のキーが最初に見つかり、 &lt;code&gt;DayOfWeek.SUNDAY&lt;/code&gt; のキーが最後になります。</target>
        </trans-unit>
        <trans-unit id="23cd9f2b5ed48db7c1117c31ae3a319fe97b4847" translate="yes" xml:space="preserve">
          <source>If you have a generic untyped Map you can use:</source>
          <target state="translated">一般的なタイプされていないMapがあれば、それを使用することができます。</target>
        </trans-unit>
        <trans-unit id="166cf4f9ea1423792bbb034bfbd9a29a1294960d" translate="yes" xml:space="preserve">
          <source>If you want a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; that keeps its pairs arranged by the &amp;ldquo;natural order&amp;rdquo; of the key, use &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt;&lt;code&gt;TreeMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt;&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;&lt;/a&gt;. The term &amp;ldquo;natural order&amp;rdquo; means the class of the keys implements &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;. The value returned by the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)&quot;&gt;&lt;code&gt;compareTo&lt;/code&gt;&lt;/a&gt; method is used for comparison in sorting.</source>
          <target state="translated">キーの「自然な順序」でペアを配置したままにする&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;が必要な場合は、 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt; &lt;code&gt;TreeMap&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt; &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; を&lt;/a&gt;使用します。 「自然順序」という用語は、キーのクラスが&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; を&lt;/a&gt;実装することを意味します。 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)&quot;&gt; &lt;code&gt;compareTo&lt;/code&gt; &lt;/a&gt;メソッドによって返される値は、並べ替えの比較に使用されます。</target>
        </trans-unit>
        <trans-unit id="529bd36b670d6dd0399407ab228c35de68313ff8" translate="yes" xml:space="preserve">
          <source>If you want the pairs of your map to be kept in their original order in which you inserted them into the map, use &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedHashMap.html&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">マップのペアを、マップに挿入したときの元の順序で保持したい場合は、 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedHashMap.html&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; を&lt;/a&gt;使用します 。</target>
        </trans-unit>
        <trans-unit id="7129ac34e2982430511674b7df7b084da57783b2" translate="yes" xml:space="preserve">
          <source>If you want to specify a custom sorting routine for your keys to be used in maintaining a sorted order, pass a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; implementation appropriate to the class of your keys. Use either &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt;&lt;code&gt;TreeMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt;&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;&lt;/a&gt;, passing your &lt;code&gt;Comparator&lt;/code&gt;.</source>
          <target state="translated">並べ替え順序の維持に使用するキーのカスタム並べ替えルーチンを指定する場合は、キーのクラスに適した&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt;実装を渡します。 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt; &lt;code&gt;TreeMap&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt; &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; の&lt;/a&gt;いずれかを使用して、 &lt;code&gt;Comparator&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="9315bf2cae9009ab8354820e1d5393ff67c46162" translate="yes" xml:space="preserve">
          <source>In Java 1.8 (Java 8) this has become lot easier by using &lt;strong&gt;forEach&lt;/strong&gt; method from Aggregate operations(&lt;strong&gt;Stream operations&lt;/strong&gt;) that looks similar to iterators from &lt;strong&gt;Iterable&lt;/strong&gt; Interface.</source>
          <target state="translated">Java 1.8（Java 8）では、 &lt;strong&gt;Iterable&lt;/strong&gt; Interfaceのイテレータに似たAggregateオペレーション（ &lt;strong&gt;Streamオペレーション&lt;/strong&gt; ）の&lt;strong&gt;forEach&lt;/strong&gt;メソッドを使用することで、これがはるかに簡単になりました。</target>
        </trans-unit>
        <trans-unit id="35888f9edee70791965f52086d548982634b5327" translate="yes" xml:space="preserve">
          <source>In Java 8 you can do it clean and fast using the new lambdas features:</source>
          <target state="translated">Java 8では、新しいラムダス機能を使って、クリーンで高速に実行することができます。</target>
        </trans-unit>
        <trans-unit id="d053ebfab1b4bad3db6c15f6e3252be1b563d13e" translate="yes" xml:space="preserve">
          <source>In Map one can Iteration over &lt;code&gt;keys&lt;/code&gt; and/or &lt;code&gt;values&lt;/code&gt; and/or &lt;code&gt;both (e.g., entrySet)&lt;/code&gt;  depends on one's interested in_ Like:</source>
          <target state="translated">Mapでは、 &lt;code&gt;keys&lt;/code&gt; や &lt;code&gt;values&lt;/code&gt; 、あるいは &lt;code&gt;both (e.g., entrySet)&lt;/code&gt; は、興味のある人に依存します。</target>
        </trans-unit>
        <trans-unit id="fc677eb8c592126da1f730119c25b473d0885049" translate="yes" xml:space="preserve">
          <source>In an idiosyncratic implementation, it might make some difference whether you use &lt;code&gt;map.keySet()&lt;/code&gt;, &lt;code&gt;map.entrySet()&lt;/code&gt; or something else. But I can't think of a reason why anyone would write it like that. Most likely it makes no difference to performance what you do.</source>
          <target state="translated">特異な実装では、 &lt;code&gt;map.keySet()&lt;/code&gt; 、 &lt;code&gt;map.entrySet()&lt;/code&gt; などを使用するかどうかに違いが生じる可能性があります。 しかし、誰もがそのように書く理由は考えられません。 ほとんどの場合、パフォーマンスには影響しません。</target>
        </trans-unit>
        <trans-unit id="473fd68b5588936170d01e9b550860d05cf2d9c8" translate="yes" xml:space="preserve">
          <source>In choosing a &lt;code&gt;Map&lt;/code&gt; implementation, also consider:</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 実装を選択する際には、次のことも考慮してください。</target>
        </trans-unit>
        <trans-unit id="c24842ac42e680dc877680a2f5d56059350889d8" translate="yes" xml:space="preserve">
          <source>In theory, the most efficient way will depend on which implementation of Map. The official way to do this is to call &lt;code&gt;map.entrySet()&lt;/code&gt;, which returns a set of &lt;code&gt;Map.Entry&lt;/code&gt;, each of which contains a key and a value (&lt;code&gt;entry.getKey()&lt;/code&gt; and &lt;code&gt;entry.getValue()&lt;/code&gt;).</source>
          <target state="translated">理論的には、最も効率的な方法は、Mapの実装によって異なります。 これを行う正式な方法は、 &lt;code&gt;map.entrySet()&lt;/code&gt; を呼び出すことです。これは、それぞれがキーと値（ &lt;code&gt;entry.getKey()&lt;/code&gt; および &lt;code&gt;entry.getValue()&lt;/code&gt; ）を含む &lt;code&gt;Map.Entry&lt;/code&gt; のセットを返します。</target>
        </trans-unit>
        <trans-unit id="aef18bcaa1a6078d0596df965e6f06bff342eebb" translate="yes" xml:space="preserve">
          <source>Including documentation links to Oracle Docs.
For more on &lt;strong&gt;Lambda&lt;/strong&gt; go to this &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;link&lt;/a&gt; and must read &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/streams/&quot;&gt;Aggregate Operations&lt;/a&gt; and for Spliterator go to this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html&quot;&gt;link&lt;/a&gt;.</source>
          <target state="translated">Oracle Docsへのドキュメントへのリンクを含みます。 &lt;strong&gt;Lambdaの&lt;/strong&gt;詳細については、この&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;リンクにアクセスして&lt;/a&gt; 、 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/streams/&quot;&gt;集約操作&lt;/a&gt;を読む必要があります。Splitatorについては、この&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html&quot;&gt;リンクに&lt;/a&gt;アクセスしてください 。</target>
        </trans-unit>
        <trans-unit id="c287a1bbff0a047aa1cc86cd23da90c9abec2a7c" translate="yes" xml:space="preserve">
          <source>Java 8</source>
          <target state="translated">ジャバハチ</target>
        </trans-unit>
        <trans-unit id="1a24293b0fdd436ea326a582b3900c6277396743" translate="yes" xml:space="preserve">
          <source>Just copy paste below statement to your code and rename the &lt;strong&gt;HashMap&lt;/strong&gt; variable from &lt;strong&gt;hm&lt;/strong&gt; to your HashMap variable to print out key-value pair.</source>
          <target state="translated">以下のステートメントをコピーしてコードにコピーし、 &lt;strong&gt;HashMap&lt;/strong&gt;変数の名前を&lt;strong&gt;hm&lt;/strong&gt;から&lt;strong&gt;HashMap&lt;/strong&gt;変数に変更して、キーと値のペアを出力します。</target>
        </trans-unit>
        <trans-unit id="db5c42f3ae489e1d2055785ca9044320a3138887" translate="yes" xml:space="preserve">
          <source>LinkedHashMap (1):</source>
          <target state="translated">LinkedHashMap (1)。</target>
        </trans-unit>
        <trans-unit id="73f20d040d451199d93293d63622c81c896ec906" translate="yes" xml:space="preserve">
          <source>LinkedHashMap (2):</source>
          <target state="translated">LinkedHashMap(2)。</target>
        </trans-unit>
        <trans-unit id="81595b19783c5714a55f00459b2855988e0e079e" translate="yes" xml:space="preserve">
          <source>Most compact with Java 8:</source>
          <target state="translated">Java 8で最もコンパクト。</target>
        </trans-unit>
        <trans-unit id="2f2c621cb10233dbf9ece2193f2f19a3f155495a" translate="yes" xml:space="preserve">
          <source>NULLs. Some implementations forbid/accept a NULL as key and/or value.</source>
          <target state="translated">NULL。一部の実装では、NULLをキーや値として受け取ることを禁止しています。</target>
        </trans-unit>
        <trans-unit id="f504a9f397b7b30ca39f0ef1407b932940292f78" translate="yes" xml:space="preserve">
          <source>Natural order</source>
          <target state="translated">自然秩序</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="58431d2cb2f2a436e30d687d47551e6350d00b91" translate="yes" xml:space="preserve">
          <source>Original insertion order</source>
          <target state="translated">オリジナルの挿入順序</target>
        </trans-unit>
        <trans-unit id="67ea52f1a7ae74f014909d25b0bddf410e9fbbb3" translate="yes" xml:space="preserve">
          <source>Other considerations</source>
          <target state="translated">その他の考慮事項</target>
        </trans-unit>
        <trans-unit id="0b379a43d717dba06857b0da94da11fa13a38e2f" translate="yes" xml:space="preserve">
          <source>See this table I created summarizing the various &lt;code&gt;Map&lt;/code&gt; implementations bundled with Java 11. Specifically, notice the &lt;em&gt;iteration order&lt;/em&gt; column. Click/tap to zoom.</source>
          <target state="translated">Java 11にバンドルされているさまざまな &lt;code&gt;Map&lt;/code&gt; 実装を要約して作成したこの表を参照してください。特に、 &lt;em&gt;反復順序の&lt;/em&gt;列に注目してください。 クリック/タップしてズームします。</target>
        </trans-unit>
        <trans-unit id="4595ac23a27791fe7fbe0d4d4c43740979d75813" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;Map&lt;/code&gt; implementations promise a certain iteration order, others do not.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; の実装によっては、特定の反復順序を約束するものとそうでないものがあります。</target>
        </trans-unit>
        <trans-unit id="44ea68cf30e14f2ddc12c26d6ae286ba0a85cc9c" translate="yes" xml:space="preserve">
          <source>Suppose you have one Map like:</source>
          <target state="translated">のようなマップが1つあったとします。</target>
        </trans-unit>
        <trans-unit id="8c5fb6a3a0e3368214ec978de8a33e83c0fd6ed4" translate="yes" xml:space="preserve">
          <source>Table (perfomance tests depending on map size)</source>
          <target state="translated">表(マップサイズに応じた性能テスト</target>
        </trans-unit>
        <trans-unit id="f9f6bd1eb290901a88aeb60726443ff7d66c84d2" translate="yes" xml:space="preserve">
          <source>The advantage with streams is they can be parallelized easily in case we want to. We simply need to use &lt;code&gt;parallelStream()&lt;/code&gt; in place of &lt;code&gt;stream()&lt;/code&gt; above.</source>
          <target state="translated">ストリームの利点は、必要に応じて簡単に並列化できることです。 上記の &lt;code&gt;stream()&lt;/code&gt; の代わりに &lt;code&gt;parallelStream()&lt;/code&gt; を使用するだけです。</target>
        </trans-unit>
        <trans-unit id="dbc9eb3726815146c387b80d2f2f63f5ddb55da3" translate="yes" xml:space="preserve">
          <source>The code below shows iteration through LinkedHashMap and normal HashMap (example). You will see difference in the order:</source>
          <target state="translated">以下のコードは、LinkedHashMapと通常のHashMapを繰り返したものです(例)。順番が違うのがわかると思います。</target>
        </trans-unit>
        <trans-unit id="e52b25a08f2a02df03a2dfe2046b8da6d3756b34" translate="yes" xml:space="preserve">
          <source>The correct way to do this is to use the accepted answer as it is the most efficient. I find the following code looks a bit cleaner.</source>
          <target state="translated">正しい方法は、最も効率的なので、受け入れられた答えを使うことです。私は以下のコードの方が少しすっきりしているように感じます。</target>
        </trans-unit>
        <trans-unit id="40692755bf402ab70ec2f1031f4cdb1100ed8d13" translate="yes" xml:space="preserve">
          <source>The older &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/SortedMap.html&quot;&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt; interface is effectively supplanted by the newer &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; interface. But you may find 3rd-party implementations implementing the older interface only.</source>
          <target state="translated">古い&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/SortedMap.html&quot;&gt; &lt;code&gt;SortedMap&lt;/code&gt; &lt;/a&gt;インターフェースは、新しい&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt;インターフェースに実質的に取って代わられました。 ただし、古いインターフェースのみを実装するサードパーティの実装を見つける場合があります。</target>
        </trans-unit>
        <trans-unit id="f4598b67765b6de694c769bc44b167a07f3ddbda" translate="yes" xml:space="preserve">
          <source>The ordering will always depend on the specific map implementation.
Using Java&amp;nbsp;8 you can use either of these:</source>
          <target state="translated">順序は常に特定のマップ実装に依存します。 Java 8を使用すると、次のいずれかを使用できます。</target>
        </trans-unit>
        <trans-unit id="bb0c23da405fcd789494b9eeb5a645b5955b59c8" translate="yes" xml:space="preserve">
          <source>The result will be the same (same order). The entrySet backed by the map so you are getting the same order. The second one is handy as it allows you to use lambdas, e.g. if you want only to print only Integer objects that are greater than 5:</source>
          <target state="translated">結果は同じ(同じ順番)になります。EntrySetはマップによってバックアップされているので、同じ順序で結果が得られます。2番目のものはラムダを使用することができるので便利です。</target>
        </trans-unit>
        <trans-unit id="9bbc8868f5a914986cb34d081536fd74a7785d90" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; will be inferred by the compiler and there is no need to use &lt;code&gt;Map.Entry&lt;/code&gt; anymore.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; のタイプはコンパイラーによって推測され、 &lt;code&gt;Map.Entry&lt;/code&gt; を使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="f90f64e5ecb7bd2bb1395d60d9486cc542f43710" translate="yes" xml:space="preserve">
          <source>Then you can do something like the below to iterate over map elements.</source>
          <target state="translated">そうすると、以下のようなことをしてマップ要素を反復処理することができます。</target>
        </trans-unit>
        <trans-unit id="bbfb9fdec90164bf482004ec9ff49df454fa2660" translate="yes" xml:space="preserve">
          <source>There are a lot of ways to do this. Below is a few simple steps:</source>
          <target state="translated">これを行うには、多くの方法があります。以下、簡単な方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="45fc9393135cf25ad84bcc71ef5e748db800c55d" translate="yes" xml:space="preserve">
          <source>There are several ways to iterate over map.</source>
          <target state="translated">マップを反復処理する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="8a85b761dfc0b6d7c4853d436ef0b85c865f89b6" translate="yes" xml:space="preserve">
          <source>This is a two part question:</source>
          <target state="translated">二部構成の質問です。</target>
        </trans-unit>
        <trans-unit id="b96a5d51c7d4e75b147cac932f1df8154b606b4e" translate="yes" xml:space="preserve">
          <source>To summarize the other answers and combine them with what I know, I found 10 main ways to do this (see below). Also, I wrote some performance tests (see results below). For example, if we want to find the sum of all of the keys and values of a map, we can write:</source>
          <target state="translated">他の回答をまとめて、自分が知っていることと組み合わせるために、主に10の方法を見つけました(下記参照)。また、性能テストもいくつか書いてみました(結果は下記参照)。例えば、地図のキーと値の合計を求める場合は、次のように書きます。</target>
        </trans-unit>
        <trans-unit id="eea8e2fbfdadecffc34ccb60883d55b390d62628" translate="yes" xml:space="preserve">
          <source>Try this with Java 1.4:</source>
          <target state="translated">Java 1.4で試してみてください。</target>
        </trans-unit>
        <trans-unit id="3e692e2cdce8ba138bff14befa18b3272b620418" translate="yes" xml:space="preserve">
          <source>Two of those implement the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; interface: &lt;code&gt;TreeMap&lt;/code&gt; &amp;amp; &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;.</source>
          <target state="translated">それらの2つは、 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt;インターフェースを実装します： &lt;code&gt;TreeMap&lt;/code&gt; および &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0814b143955158188c01052f3ceb5ba0f4bf1a4c" translate="yes" xml:space="preserve">
          <source>Typical code for iterating over a map is:</source>
          <target state="translated">マップを反復処理するための典型的なコードです。</target>
        </trans-unit>
        <trans-unit id="b0e1da2614eac9ef96d91f4a14fda3c203ed934e" translate="yes" xml:space="preserve">
          <source>Use Java 8:</source>
          <target state="translated">Java 8を使用します。</target>
        </trans-unit>
        <trans-unit id="633b42502a5c51154b31c24409538f2cf25201f7" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;IterableMap&lt;/strong&gt; of &lt;code&gt;Apache Collections&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Apache Collections&lt;/code&gt; &lt;strong&gt;IterableMap&lt;/strong&gt;の使用</target>
        </trans-unit>
        <trans-unit id="5e6ec89e4a5b8a80f2496e8cf6a0a4081c374aab" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;MutableMap&lt;/strong&gt; of Eclipse (CS) collections</source>
          <target state="translated">Eclipse（CS）コレクションの&lt;strong&gt;MutableMap&lt;/strong&gt;の使用</target>
        </trans-unit>
        <trans-unit id="b54a5fdfbc9ecf10962725149d2d419b3abbb3f0" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;for&lt;/strong&gt; and &lt;strong&gt;Map.Entry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;for&lt;/strong&gt;および&lt;strong&gt;Map.Entryの&lt;/strong&gt;使用</target>
        </trans-unit>
        <trans-unit id="eba2f7e5a0ff9fa992e5f7680f4ac9e7a9c58aea" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;forEach&lt;/strong&gt; from Java 8</source>
          <target state="translated">Java 8からの&lt;strong&gt;forEachの&lt;/strong&gt;使用</target>
        </trans-unit>
        <trans-unit id="a545ca6c32cca8a0529723e65006632305936d38" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;foreach&lt;/strong&gt; and &lt;strong&gt;Map.Entry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;foreach&lt;/strong&gt;と&lt;strong&gt;Map.Entryの&lt;/strong&gt;使用</target>
        </trans-unit>
        <trans-unit id="485ee3eaf55ad9e70f346bcb0862491cf0ee98ee" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;iterator&lt;/strong&gt; and &lt;strong&gt;Map.Entry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;イテレータ&lt;/strong&gt;と&lt;strong&gt;Map.Entryの&lt;/strong&gt;使用</target>
        </trans-unit>
        <trans-unit id="7cc9935ec102d94e6a964ac34ff58f749b4af47d" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;keySet&lt;/strong&gt; and &lt;strong&gt;foreach&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;keySet&lt;/strong&gt;と&lt;strong&gt;foreachの&lt;/strong&gt;使用</target>
        </trans-unit>
        <trans-unit id="88e9bb2e701d85507ea9e8debd7b4fbd4ad3778c" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;keySet&lt;/strong&gt; and &lt;strong&gt;iterator&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;keySet&lt;/strong&gt;と&lt;strong&gt;イテレーターの&lt;/strong&gt;使用</target>
        </trans-unit>
        <trans-unit id="36dae4ef0cd75cfeb8ecebf9eba9a9a61d11f34e" translate="yes" xml:space="preserve">
          <source>Using the Java 8 &lt;strong&gt;Stream API parallel&lt;/strong&gt;</source>
          <target state="translated">Java 8 &lt;strong&gt;Stream APIの並列使用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5caf9ed2a72d6f4ecbca766fb5691949d6216417" translate="yes" xml:space="preserve">
          <source>Using the Java 8 &lt;strong&gt;Stream API&lt;/strong&gt;</source>
          <target state="translated">Java 8 &lt;strong&gt;Stream APIの使用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eafcfcc9f356a37cd9ee651b3aa678c42fcbcb9e" translate="yes" xml:space="preserve">
          <source>We have got &lt;code&gt;forEach&lt;/code&gt; method that accepts a &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;lambda expression&lt;/a&gt;. We have also got &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;stream&lt;/a&gt; APIs. Consider a map:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;ラムダ式&lt;/a&gt;を受け入れる &lt;code&gt;forEach&lt;/code&gt; メソッドがあります。 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;ストリーム&lt;/a&gt; APIもあります。 地図を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="d798e0a7eca0befff8709b5ebe731b0fa73ec725" translate="yes" xml:space="preserve">
          <source>Will the ordering of elements depend on the specific map implementation that I have for the interface?</source>
          <target state="translated">要素の順序は、インターフェイスのために持っている特定のマップ実装に依存しますか?</target>
        </trans-unit>
        <trans-unit id="017762b012dd7225113538796ddba61ae61e2c5a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/eclipse/eclipse-collections&quot;&gt;Eclipse Collections&lt;/a&gt; (formerly &lt;a href=&quot;https://github.com/goldmansachs/gs-collections&quot;&gt;GS Collections&lt;/a&gt;), you would use the forEachKeyValue method on the &lt;a href=&quot;https://github.com/eclipse/eclipse-collections/blob/master/eclipse-collections-api/src/main/java/org/eclipse/collections/api/map/MapIterable.java&quot;&gt;MapIterable&lt;/a&gt; interface, which is inherited by the MutableMap and ImmutableMap interfaces and their implementations.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/eclipse/eclipse-collections&quot;&gt;Eclipseコレクション&lt;/a&gt; （以前の&lt;a href=&quot;https://github.com/goldmansachs/gs-collections&quot;&gt;GSコレクション&lt;/a&gt; ）では、 &lt;a href=&quot;https://github.com/eclipse/eclipse-collections/blob/master/eclipse-collections-api/src/main/java/org/eclipse/collections/api/map/MapIterable.java&quot;&gt;MapIterable&lt;/a&gt;インターフェイスでforEachKeyValueメソッドを使用します。これは、MutableMapおよびImmutableMapインターフェイスとそれらの実装によって継承されます。</target>
        </trans-unit>
        <trans-unit id="306de5f65025cadf9565e4afbdf42027db4cb2dc" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;Java 8&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java 8を使用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4699cd9129494ddc388093886dfdad742d8561b2" translate="yes" xml:space="preserve">
          <source>With Java 8 lambda syntax, you can write the code as follows:</source>
          <target state="translated">Java 8のラムダ構文では、以下のようにコードを書くことができます。</target>
        </trans-unit>
        <trans-unit id="b84aef87a2bc298b8e63f4075a8e2f44a93fdcfb" translate="yes" xml:space="preserve">
          <source>Yes, absolutely.</source>
          <target state="translated">そうですね、絶対に。</target>
        </trans-unit>
        <trans-unit id="cae53b76e40d2202c18f68f4690b03274ac40cb7" translate="yes" xml:space="preserve">
          <source>Yes, the order depends on the specific Map implementation.</source>
          <target state="translated">はい、順序は特定のマップの実装に依存します。</target>
        </trans-unit>
        <trans-unit id="daf91a238253e2d658f686a2323d495a7c1aa9a8" translate="yes" xml:space="preserve">
          <source>You can do it using generics:</source>
          <target state="translated">ジェネリックを使ってやればいい。</target>
        </trans-unit>
        <trans-unit id="c8f6998bce11971227c73926226c4fc1e993e492" translate="yes" xml:space="preserve">
          <source>You can see there are &lt;strong&gt;four &lt;code&gt;Map&lt;/code&gt; implementations maintaining an order&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;順序を維持する4つの &lt;code&gt;Map&lt;/code&gt; 実装&lt;/strong&gt;があることがわかります。</target>
        </trans-unit>
        <trans-unit id="1cbe0c6bd90ebdac70a867735970ee3858618266" translate="yes" xml:space="preserve">
          <source>You can use lambda expressions:</source>
          <target state="translated">ラムダ式を使うことができます。</target>
        </trans-unit>
        <trans-unit id="bd68512ae08ef0e4cfbba091825597ceb90fe6f4" translate="yes" xml:space="preserve">
          <source>[edit] I wrote &lt;code&gt;valueSet()&lt;/code&gt; originally but of course &lt;code&gt;entrySet()&lt;/code&gt; is actually the answer.</source>
          <target state="translated">[編集]私は &lt;code&gt;valueSet()&lt;/code&gt; を書きましたが、もちろん &lt;code&gt;entrySet()&lt;/code&gt; が実際の答えです。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
