<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/46898">
    <body>
      <group id="46898">
        <trans-unit id="d30462a41bd01ccebda2cf58a3b8353e1b7840fd" translate="yes" xml:space="preserve">
          <source>0 (#:0):0, 1 (#:1):1, 2 (#:2):2, 3 (#:3):3, 4 (#:4):4, 5 (#:5):5, 6 (#:6):6, 7 (#:7):7, 8 (#:8):8, 9 (#:9):9, 10 (#:10):10,</source>
          <target state="translated">0 (#:0):0,1 (#:1):1,2 (#:2):2,3 (#:3):3,4 (#:4):4,5 (#:5):5,6 (#:6):6,7 (#:7):7,8 (#:8):8,9 (#:9):9,10 (#:10):10,</target>
        </trans-unit>
        <trans-unit id="2ddf1133bc32496871045e6d597d4d6a1dc1e8da" translate="yes" xml:space="preserve">
          <source>0 : 0, 1 : 1, 2 : 2, 3 : 3, 4 : 4, 5 : 5, 6 : 6, 7 : 7, 8 : 8, 9 : 9, 10 : 10,</source>
          <target state="translated">0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,10:10,</target>
        </trans-unit>
        <trans-unit id="40f71110f1c6d89a83d5d74998a6bae84cb0eac9" translate="yes" xml:space="preserve">
          <source>1.) Iterate through the &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#keySet%28%29&quot;&gt;&lt;code&gt;keys -&amp;gt; keySet()&lt;/code&gt;&lt;/a&gt; of the map:</source>
          <target state="translated">1.）遍历地图的&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#keySet%28%29&quot;&gt; &lt;code&gt;keys -&amp;gt; keySet()&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="b434c39c68821bc91a36a5d79143911b1685346e" translate="yes" xml:space="preserve">
          <source>10 (#=10):10, 9 (#=9):9, 8 (#=8):8, 7 (#=7):7, 6 (#=6):6, 5 (#=5):5, 4 (#=4):4, 3 (#=3):3, 2 (#=2):2, 1 (#=1):1, 0 (#=0):0,</source>
          <target state="translated">10 (#=10):10,9 (#=9):9,8 (#=8):8,7 (#=7):7,6 (#=6):6,5 (#=5):5,4 (#=4):4,3 (#=3):3,2 (#=2):2,1 (#=1):1,0 (#=0):0,</target>
        </trans-unit>
        <trans-unit id="07e7842ae451e8b223fddd46806bc2418f4d8622" translate="yes" xml:space="preserve">
          <source>10 : 10, 9 : 9, 8 : 8, 7 : 7, 6 : 6, 5 : 5, 4 : 4, 3 : 3, 2 : 2, 1 : 1, 0 : 0,</source>
          <target state="translated">10:10,9:9,8:8,7:7,6:6,5:5,4:4,3:3,2:2,1:1,0:0,</target>
        </trans-unit>
        <trans-unit id="76c3ebd56308a64015138e37e4c85af5080783a3" translate="yes" xml:space="preserve">
          <source>2.) Iterate through the &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#values%28%29&quot;&gt;&lt;code&gt;values -&amp;gt; values()&lt;/code&gt;&lt;/a&gt; of the map:</source>
          <target state="translated">2.）遍历映射的&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#values%28%29&quot;&gt; &lt;code&gt;values -&amp;gt; values()&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="a3bbdbbb036debbd91e9605d4745f68dd12997a6" translate="yes" xml:space="preserve">
          <source>3.) Iterate through the &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#entrySet%28%29&quot;&gt;&lt;code&gt;both -&amp;gt; entrySet()&lt;/code&gt;&lt;/a&gt; of the map:</source>
          <target state="translated">3.）遍历地图的&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#entrySet%28%29&quot;&gt; &lt;code&gt;both -&amp;gt; entrySet()&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="0bdeeaef0187d00458632d3659a4402cd79e9934" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/46898/how-to-efficiently-iterate-over-each-entry-in-a-map/46908#46908&quot;&gt;@ScArcher2 has the more elegant Java 1.5 syntax&lt;/a&gt;. In 1.4, I would do something like this:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/46898/how-to-efficiently-iterate-over-each-entry-in-a-map/46908#46908&quot;&gt;@ ScArcher2具有更优雅的Java 1.5语法&lt;/a&gt; 。 在1.4中，我将执行以下操作：</target>
        </trans-unit>
        <trans-unit id="78fd64c50744c65d102273e78ce957c849ebbeff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is the canonical map implementation and doesn't make guarantees (or though it should not change order if no mutating operation are performed on it). &lt;code&gt;SortedMap&lt;/code&gt; will return entries based on the natural ordering of the keys, or a &lt;code&gt;Comparator&lt;/code&gt;, if provided. &lt;code&gt;LinkedHashMap&lt;/code&gt; will either return entries in insertion-order or access-order depending upon how it has been constructed. &lt;code&gt;EnumMap&lt;/code&gt; returns entries in natural order of keys.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 是规范的地图实现，并且不做任何保证（或者，如果不对其执行任何变异操作，则它不应更改顺序）。 &lt;code&gt;SortedMap&lt;/code&gt; 将根据键或 &lt;code&gt;Comparator&lt;/code&gt; （如果提供）的自然顺序返回条目。 &lt;code&gt;LinkedHashMap&lt;/code&gt; 将以插入顺序或访问顺序返回条目，具体取决于其构造方式。 &lt;code&gt;EnumMap&lt;/code&gt; 以键的自然顺序返回条目。</target>
        </trans-unit>
        <trans-unit id="df9e23213522feb0f851809e192dbba0cd4ef337" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NavigableMap&lt;/code&gt; interface</source>
          <target state="translated">&lt;code&gt;NavigableMap&lt;/code&gt; 界面</target>
        </trans-unit>
        <trans-unit id="b8061c26823755d99e280ad254f9a7a64a9225cb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;50 milliseconds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;50毫秒&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1f2a23cfa6ed0be46057a39259af74d813bd4b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;75 milliseconds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;75毫秒&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7551ebfccb1284552c4ac29e34b7aecc41ed5dfe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;76 milliseconds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;76毫秒&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87d7a5349b3fd394b840fd8e8315f40c28028239" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;How to iterate over the entries of a Map&lt;/em&gt; - @ScArcher2 has &lt;a href=&quot;https://stackoverflow.com/a/46908/1851302&quot;&gt;answered&lt;/a&gt; that perfectly.</source>
          <target state="translated">&lt;em&gt;如何遍历Map的条目&lt;/em&gt; -@ ScArcher2已经完美地&lt;a href=&quot;https://stackoverflow.com/a/46908/1851302&quot;&gt;回答了&lt;/a&gt;这一问题。</target>
        </trans-unit>
        <trans-unit id="8c8940fb37dfcfef05c009e102fb571f8441ea00" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you want to write a conditional for lambda you can write it like this:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;如果要为lambda写一个条件，可以这样写：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a34520f314ded34eb3cacb1a2590ee9c9299821" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Moreover, there are 3 difference ways to Iterate Through a HashMap. They are as below&lt;/em&gt;_</source>
          <target state="translated">&lt;em&gt;此外，有3种不同的方式可以通过HashMap进行迭代。&lt;/em&gt; &lt;em&gt;它们如下&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ff6cb7605a078a3bfb48c2579c0969790a6fed46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the order of iteration&lt;/em&gt; - if you are just using &lt;code&gt;Map&lt;/code&gt;, then strictly speaking, there are &lt;strong&gt;no ordering guarantees&lt;/strong&gt;.  So you shouldn't really rely on the ordering given by any implementation.  However, the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt; interface extends &lt;code&gt;Map&lt;/code&gt; and provides exactly what you are looking for - implementations will aways give a consistent sort order.</source>
          <target state="translated">&lt;em&gt;迭代的顺序是什么&lt;/em&gt; -如果仅使用 &lt;code&gt;Map&lt;/code&gt; ，那么严格来说， &lt;strong&gt;没有排序保证&lt;/strong&gt; 。 因此，您不应真正依赖任何实现所给出的顺序。 但是， &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt; &lt;code&gt;SortedMap&lt;/code&gt; &lt;/a&gt;接口扩展了 &lt;code&gt;Map&lt;/code&gt; 并提供了您所要查找的内容-实现将给出一致的排序顺序。</target>
        </trans-unit>
        <trans-unit id="7b9f49f0624beecc76e4c400005cc314c104082e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(Update: I think this is no longer true.&lt;/strong&gt;) Note, &lt;code&gt;IdentityHashMap&lt;/code&gt;&lt;code&gt;entrySet&lt;/code&gt; iterator currently has a peculiar implementation which returns the same &lt;code&gt;Map.Entry&lt;/code&gt; instance for every item in the &lt;code&gt;entrySet&lt;/code&gt;! However, every time a new the iterator advances the &lt;code&gt;Map.Entry&lt;/code&gt; is updated.</source>
          <target state="translated">&lt;strong&gt;（更新：我认为这不再成立。&lt;/strong&gt; ）注意， &lt;code&gt;IdentityHashMap&lt;/code&gt; &lt;code&gt;entrySet&lt;/code&gt; 迭代器当前具有一个特殊的实现，该实现为 &lt;code&gt;entrySet&lt;/code&gt; 中的每个项目都返回相同的 &lt;code&gt;Map.Entry&lt;/code&gt; 实例！ 但是，每次新的迭代器前进 &lt;code&gt;Map.Entry&lt;/code&gt; 都会更新。</target>
        </trans-unit>
        <trans-unit id="4b08e1ea1a9950c8944da65f4d98ac8bce434bec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Using &lt;code&gt;entrySet()&lt;/code&gt; in for each loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）在每个循环中使用 &lt;code&gt;entrySet()&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef4f8dcdb2b42abc6c11a4507ae8f995723b6a25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Using &lt;code&gt;keySet()&lt;/code&gt; in for each loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）在每个循环中使用 &lt;code&gt;keySet()&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ce455fc72a7bee227dd834267207040b1408afb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Using &lt;code&gt;entrySet()&lt;/code&gt; and iterator&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3）使用 &lt;code&gt;entrySet()&lt;/code&gt; 和迭代器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f68c4111f1efcd5940165c5462abd76292ca5156" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4) Using &lt;code&gt;keySet()&lt;/code&gt; and iterator&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4）使用 &lt;code&gt;keySet()&lt;/code&gt; 和迭代器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01ab40a6cbbbd4ccc44c8cf3e70babf4c8d349fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; is another useful extension&lt;/strong&gt; - this is a &lt;code&gt;SortedMap&lt;/code&gt; with additional methods for finding entries by their ordered position in the key set.  So potentially this can remove the need for iterating in the first place - you might be able to find the specific &lt;code&gt;entry&lt;/code&gt; you are after using the &lt;code&gt;higherEntry&lt;/code&gt;, &lt;code&gt;lowerEntry&lt;/code&gt;, &lt;code&gt;ceilingEntry&lt;/code&gt;, or &lt;code&gt;floorEntry&lt;/code&gt; methods.  The &lt;code&gt;descendingMap&lt;/code&gt; method even gives you an explicit method of &lt;strong&gt;reversing the traversal order&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt;是另一个有用的扩展&lt;/strong&gt; -这是 &lt;code&gt;SortedMap&lt;/code&gt; ,它具有其他方法，可以按键集中的顺序按顺序查找条目。 因此，这有可能消除了首先进行迭代的需要-您可以在使用 &lt;code&gt;higherEntry&lt;/code&gt; ， &lt;code&gt;lowerEntry&lt;/code&gt; ， &lt;code&gt;ceilingEntry&lt;/code&gt; 或 &lt;code&gt;floorEntry&lt;/code&gt; 方法之后找到要访问的特定 &lt;code&gt;entry&lt;/code&gt; 。 &lt;code&gt;descendingMap&lt;/code&gt; 方法甚至为您提供了一种&lt;strong&gt;反转遍历顺序&lt;/strong&gt;的显式方法。</target>
        </trans-unit>
        <trans-unit id="b0bdd3f912a52ada1dd392cd4ff14c74d0be6fcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;forEachOrdered&lt;/code&gt; vs &lt;code&gt;forEach&lt;/code&gt; with streams ?&lt;/strong&gt;
The &lt;code&gt;forEach&lt;/code&gt; does not follow encounter order (if defined) and is inherently non-deterministic in nature where as the &lt;code&gt;forEachOrdered&lt;/code&gt; does. So &lt;code&gt;forEach&lt;/code&gt; does not guarantee that the order would be kept. Also check &lt;a href=&quot;https://stackoverflow.com/questions/32797579/foreach-vs-foreachordered-in-java-8-stream&quot;&gt;this&lt;/a&gt; for more.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;forEachOrdered&lt;/code&gt; 与带有流的 &lt;code&gt;forEach&lt;/code&gt; 吗？&lt;/strong&gt; &lt;code&gt;forEach&lt;/code&gt; 不遵循遇到顺序（如果已定义），并且本质上与 &lt;code&gt;forEachOrdered&lt;/code&gt; 一样是不确定的 。 因此， &lt;code&gt;forEach&lt;/code&gt; 不保证订单会得到保留。 另请检查&lt;a href=&quot;https://stackoverflow.com/questions/32797579/foreach-vs-foreachordered-in-java-8-stream&quot;&gt;此&lt;/a&gt;内容。</target>
        </trans-unit>
        <trans-unit id="22c727b2a9f2723354a008790444a6d3c6f5ce17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An effective iterative solution over a Map is a 'for each' loop from Java 5 through Java 7. Here it is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在Map上有效的迭代解决方案是从Java 5到Java 7的&amp;ldquo; for each&amp;rdquo;循环。在这里：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c3c99f01f82e3dd15f6dea31f73807e5a330c16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Java 8 you can use a lambda expression to iterate over a Map. It is an enhanced 'forEach'&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在Java 8中，您可以使用lambda表达式来迭代Map。&lt;/strong&gt; &lt;strong&gt;它是增强的&amp;ldquo; forEach&amp;rdquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8266e1e95a5d91ff447f8d45a4314d7d0606da42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterate over entries (Using forEach and Streams):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;遍历条目（使用forEach和Streams）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ef22017e708698482a126b2fe682a8f6d486473" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterate over keys:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;遍历键：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf9bdb43bd1b0449f7175e791319748eebbd91f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterate over values:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;遍历值：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b958957df67e5e3894ae54fdec131a5fab7b7758" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java 8:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java 8：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4ac5345e9dfeab6eedab1bed3634a2d61b232bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lambda&lt;/strong&gt; Expression Java 8</source>
          <target state="translated">&lt;strong&gt;Lambda&lt;/strong&gt; Expression Java 8</target>
        </trans-unit>
        <trans-unit id="cb33563a72610ed34b6b91ac165e4604be35ec62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I am a committer for Eclipse Collections.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;我是Eclipse Collections的提交者。</target>
        </trans-unit>
        <trans-unit id="4eaa4758fc373a92b0951b602e363208503de373" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Perfomance tests&lt;/strong&gt; (mode = AverageTime, system = Windows&amp;nbsp;8.1 64-bit, Intel i7-4790 3.60 GHz, 16&amp;nbsp;GB)</source>
          <target state="translated">&lt;strong&gt;性能测试&lt;/strong&gt; （模式=平均时间，系统= Windows 8.1 64位，英特尔i7-4790 3.60 GHz，16 GB）</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a2c64a759bdeec979cf1625cb2640fed35b8352" translate="yes" xml:space="preserve">
          <source>All tests are on &lt;a href=&quot;https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/5.0-other-examples/src/main/java/other_examples/IterateThroughHashMapTest.java&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">所有测试都在&lt;a href=&quot;https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/5.0-other-examples/src/main/java/other_examples/IterateThroughHashMapTest.java&quot;&gt;GitHub上&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="e62b6b46bd13f4fdff912caff47e1c5ab9468154" translate="yes" xml:space="preserve">
          <source>Also one can use &lt;strong&gt;Spliterator&lt;/strong&gt; for the same.</source>
          <target state="translated">同样也可以使用&lt;strong&gt;Spliterator&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4a128155fdd1ff9b255b50be54783cd11c5ad9a" translate="yes" xml:space="preserve">
          <source>And yes, the order will depend on the implementation - as well as (possibly) the order of insertion and other hard-to-control factors.</source>
          <target state="translated">是的,顺序将取决于执行情况,以及(可能)插入的顺序和其他难以控制的因素。</target>
        </trans-unit>
        <trans-unit id="1987a85346ebed06208fda36057d3abf53a7dac9" translate="yes" xml:space="preserve">
          <source>Below is the sample code that I tried using &lt;strong&gt;Lambda Expression&lt;/strong&gt;. This stuff is so cool. Must try.</source>
          <target state="translated">以下是我使用&lt;strong&gt;Lambda Expression&lt;/strong&gt;尝试的示例代码。 这个东西真酷。 一定要试。</target>
        </trans-unit>
        <trans-unit id="0091670d7a16db16eebf59a5b133fa1d4fcd9465" translate="yes" xml:space="preserve">
          <source>Both of these considerations are covered in the graphic table above.</source>
          <target state="translated">上述两方面的考虑都在上图表格中有所涉及。</target>
        </trans-unit>
        <trans-unit id="837ca224c76bb8e31244cbe08276255126afae2e" translate="yes" xml:space="preserve">
          <source>Concurrency. If you are manipulating the map across threads, you must use an implementation that supports concurrency. Or wrap the map with &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)&quot;&gt;&lt;code&gt;Collections::synchronizedMap&lt;/code&gt;&lt;/a&gt; (less preferable).</source>
          <target state="translated">并发。 如果要跨线程操作映射，则必须使用支持并发的实现。 或使用&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)&quot;&gt; &lt;code&gt;Collections::synchronizedMap&lt;/code&gt; &lt;/a&gt;包装地图（不太理想）。</target>
        </trans-unit>
        <trans-unit id="a7a59840fd712513666eaaab628bba060fffd164" translate="yes" xml:space="preserve">
          <source>Custom order</source>
          <target state="translated">定制订单</target>
        </trans-unit>
        <trans-unit id="688d350fb8020500a3a5be3e3b008424818af135" translate="yes" xml:space="preserve">
          <source>Different implementations of &lt;code&gt;Map&lt;/code&gt; maintain different ordering of the key-value pairs.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 的不同实现保留键-值对的不同顺序。</target>
        </trans-unit>
        <trans-unit id="7c4c9d6bd088dbbd8d4fa9483665571f6a073ca9" translate="yes" xml:space="preserve">
          <source>Easy-peasy!</source>
          <target state="translated">Easy-peasy!</target>
        </trans-unit>
        <trans-unit id="4959fdef810c5bd96c8690ab36e2ce54b0823aaf" translate="yes" xml:space="preserve">
          <source>Enum-definition order</source>
          <target state="translated">Enum-definition顺序</target>
        </trans-unit>
        <trans-unit id="27a91e453073eb90ef706eff0718c26b5d331956" translate="yes" xml:space="preserve">
          <source>Example of using iterator and generics:</source>
          <target state="translated">使用迭代器和泛化器的例子。</target>
        </trans-unit>
        <trans-unit id="dedaf2462a308ba9703f6ecfa549331ea9c670df" translate="yes" xml:space="preserve">
          <source>FYI, you can also use &lt;code&gt;map.keySet()&lt;/code&gt; and &lt;code&gt;map.values()&lt;/code&gt; if you're only interested in keys/values of the map and not the other.</source>
          <target state="translated">仅供参考，如果您只对地图的键/值感兴趣，而对其他键/值不感兴趣，则也可以使用 &lt;code&gt;map.keySet()&lt;/code&gt; 和 &lt;code&gt;map.values()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56136984733171a2679dc40bd33baad71f4c3786" translate="yes" xml:space="preserve">
          <source>For a map with 10000 elements,  score 37.606 is the best</source>
          <target state="translated">对于一张有10000个元素的地图来说,37.606分是最好的。</target>
        </trans-unit>
        <trans-unit id="a5c0d4e335042175498e0ebf6327fd535efec693" translate="yes" xml:space="preserve">
          <source>For a map with 100000 elements,  score 1184.767 is the best</source>
          <target state="translated">对于一张有100000个元素的地图来说,1184.767分是最好的。</target>
        </trans-unit>
        <trans-unit id="c1de52942477197f09659d082fa1f4b07b8f1bd4" translate="yes" xml:space="preserve">
          <source>For a small map (100 elements), score 0.308 is the best</source>
          <target state="translated">对于一张小地图(100个元素)来说,0.308分是最好的。</target>
        </trans-unit>
        <trans-unit id="7c1760d6bcb4b3d1af55825b8f0c542185f248bd" translate="yes" xml:space="preserve">
          <source>For more information, follow &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;this&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请遵循&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;此&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa0445de7e6bc5d4ad795d112414a663bfe8f9b3" translate="yes" xml:space="preserve">
          <source>Graphs (performance tests depending on map size)</source>
          <target state="translated">图表(根据地图大小进行性能测试</target>
        </trans-unit>
        <trans-unit id="bf9babdab1657af8a0b764ba2e4045ed70ec5482" translate="yes" xml:space="preserve">
          <source>HashMap (1):</source>
          <target state="translated">HashMap(1)。</target>
        </trans-unit>
        <trans-unit id="8b2a0ebe1a9c40551264d3a2911adb4c9595e1ae" translate="yes" xml:space="preserve">
          <source>HashMap (2):</source>
          <target state="translated">HashMap(2)。</target>
        </trans-unit>
        <trans-unit id="ae33e1c12dd25e01506d37831a6c63b1eed254c7" translate="yes" xml:space="preserve">
          <source>Here is comparison of their performances for a common data set stored in map by storing a million key value pairs in map and will iterate over map.</source>
          <target state="translated">下面是通过在map中存储一百万个键值对,并将在map上迭代,比较它们对一个普通数据集的性能。</target>
        </trans-unit>
        <trans-unit id="2944fefd1e8c80dfefdf09ccf6789028fa2e370d" translate="yes" xml:space="preserve">
          <source>How do I efficiently iterate over each entry in a Java Map</source>
          <target state="translated">如何高效迭代Java地图中的每个条目?</target>
        </trans-unit>
        <trans-unit id="8c44dd09a51d3d7e7030ada02609d672731914d5" translate="yes" xml:space="preserve">
          <source>I have referred &lt;a href=&quot;http://howtodoinjava.com/2013/04/01/performance-comparison-of-different-ways-to-iterate-over-hashmap/&quot;&gt;&lt;code&gt;this link&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我已经提到了&lt;a href=&quot;http://howtodoinjava.com/2013/04/01/performance-comparison-of-different-ways-to-iterate-over-hashmap/&quot;&gt; &lt;code&gt;this link&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c86089bda3ea538b5612baeee4089a884b97993" translate="yes" xml:space="preserve">
          <source>If I have an object implementing the &lt;code&gt;Map&lt;/code&gt; interface in Java and I wish to iterate over every pair contained within it,  what is the most efficient way of going through the map?</source>
          <target state="translated">如果我有一个用Java实现 &lt;code&gt;Map&lt;/code&gt; 接口的对象，并且希望迭代其中包含的每对接口，那么遍历该映射的最有效方法是什么？</target>
        </trans-unit>
        <trans-unit id="7041d241864f2b22ad51ff33422107bb1546c0c8" translate="yes" xml:space="preserve">
          <source>If I have an object implementing the Map interface in Java and I wish to iterate over every pair contained within it, what is the most efficient way of going through the map?</source>
          <target state="translated">如果我有一个在Java中实现了Map接口的对象,我希望对其中包含的每一对对象进行迭代,请问最有效的方法是什么?</target>
        </trans-unit>
        <trans-unit id="79fa69f9b9f2bab1a018ec5832646f7d9c599a86" translate="yes" xml:space="preserve">
          <source>If efficiency of looping the keys is a priority for your app, then choose a &lt;code&gt;Map&lt;/code&gt; implementation that maintains the keys in your desired order.</source>
          <target state="translated">如果应用程序优先考虑循环键的效率，那么请选择 &lt;code&gt;Map&lt;/code&gt; 实现以所需的顺序维护键。</target>
        </trans-unit>
        <trans-unit id="6411814b84ed759c763447c4612e9d83026c997c" translate="yes" xml:space="preserve">
          <source>If you are using an enum such as &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/DayOfWeek.html&quot;&gt;&lt;code&gt;DayOfWeek&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Month.html&quot;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/a&gt; as your keys, use the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/EnumMap.html&quot;&gt;&lt;code&gt;EnumMap&lt;/code&gt;&lt;/a&gt; class. Not only is this class &lt;em&gt;highly&lt;/em&gt; optimized to use very little memory and run very fast, it maintains your pairs in the order defined by the enum. For &lt;code&gt;DayOfWeek&lt;/code&gt;, for example, the key of &lt;code&gt;DayOfWeek.MONDAY&lt;/code&gt; will be first found when iterated, and the key of &lt;code&gt;DayOfWeek.SUNDAY&lt;/code&gt; will be last.</source>
          <target state="translated">如果您使用&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/DayOfWeek.html&quot;&gt; &lt;code&gt;DayOfWeek&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Month.html&quot;&gt; &lt;code&gt;Month&lt;/code&gt; &lt;/a&gt;之类的枚举作为键，请使用&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/EnumMap.html&quot;&gt; &lt;code&gt;EnumMap&lt;/code&gt; &lt;/a&gt;类。 此类不仅经过&lt;em&gt;高度&lt;/em&gt;优化，以使用很少的内存并运行得非常快，而且还按枚举定义的顺序维护您的配对。 例如，对于 &lt;code&gt;DayOfWeek&lt;/code&gt; ，在迭代时将首先找到 &lt;code&gt;DayOfWeek.SUNDAY&lt;/code&gt; 的密钥，而DayOfWeek.SUNDAY的密钥将是最后一个。</target>
        </trans-unit>
        <trans-unit id="23cd9f2b5ed48db7c1117c31ae3a319fe97b4847" translate="yes" xml:space="preserve">
          <source>If you have a generic untyped Map you can use:</source>
          <target state="translated">如果你有一个通用的无类型地图,你可以使用。</target>
        </trans-unit>
        <trans-unit id="166cf4f9ea1423792bbb034bfbd9a29a1294960d" translate="yes" xml:space="preserve">
          <source>If you want a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; that keeps its pairs arranged by the &amp;ldquo;natural order&amp;rdquo; of the key, use &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt;&lt;code&gt;TreeMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt;&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;&lt;/a&gt;. The term &amp;ldquo;natural order&amp;rdquo; means the class of the keys implements &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;. The value returned by the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)&quot;&gt;&lt;code&gt;compareTo&lt;/code&gt;&lt;/a&gt; method is used for comparison in sorting.</source>
          <target state="translated">如果要使用按键的&amp;ldquo;自然顺序&amp;rdquo;排列其对的&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; ，请使用&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt; &lt;code&gt;TreeMap&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt; &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; &lt;/a&gt; 。 术语&amp;ldquo;自然顺序&amp;rdquo;是指键的类别实现&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 。 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)&quot;&gt; &lt;code&gt;compareTo&lt;/code&gt; &lt;/a&gt;方法返回的值用于排序中的比较。</target>
        </trans-unit>
        <trans-unit id="529bd36b670d6dd0399407ab228c35de68313ff8" translate="yes" xml:space="preserve">
          <source>If you want the pairs of your map to be kept in their original order in which you inserted them into the map, use &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedHashMap.html&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要以成对的原始顺序保留地图对，请使用&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedHashMap.html&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7129ac34e2982430511674b7df7b084da57783b2" translate="yes" xml:space="preserve">
          <source>If you want to specify a custom sorting routine for your keys to be used in maintaining a sorted order, pass a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; implementation appropriate to the class of your keys. Use either &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt;&lt;code&gt;TreeMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt;&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;&lt;/a&gt;, passing your &lt;code&gt;Comparator&lt;/code&gt;.</source>
          <target state="translated">如果要为密钥指定自定义排序例程，以用于维护排序顺序，请传递适合于密钥类的&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt;实现。 使用&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt; &lt;code&gt;TreeMap&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt; &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; &lt;/a&gt;传递您的 &lt;code&gt;Comparator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9315bf2cae9009ab8354820e1d5393ff67c46162" translate="yes" xml:space="preserve">
          <source>In Java 1.8 (Java 8) this has become lot easier by using &lt;strong&gt;forEach&lt;/strong&gt; method from Aggregate operations(&lt;strong&gt;Stream operations&lt;/strong&gt;) that looks similar to iterators from &lt;strong&gt;Iterable&lt;/strong&gt; Interface.</source>
          <target state="translated">在Java 1.8（Java 8）中，通过使用Aggregate操作（ &lt;strong&gt;Stream操作&lt;/strong&gt; ）中的&lt;strong&gt;forEach&lt;/strong&gt;方法看起来与&lt;strong&gt;Iterable&lt;/strong&gt; Interface中的迭代器类似，变得更加容易。</target>
        </trans-unit>
        <trans-unit id="35888f9edee70791965f52086d548982634b5327" translate="yes" xml:space="preserve">
          <source>In Java 8 you can do it clean and fast using the new lambdas features:</source>
          <target state="translated">在Java 8中,你可以使用新的lambdas功能来干净、快速地完成它。</target>
        </trans-unit>
        <trans-unit id="d053ebfab1b4bad3db6c15f6e3252be1b563d13e" translate="yes" xml:space="preserve">
          <source>In Map one can Iteration over &lt;code&gt;keys&lt;/code&gt; and/or &lt;code&gt;values&lt;/code&gt; and/or &lt;code&gt;both (e.g., entrySet)&lt;/code&gt;  depends on one's interested in_ Like:</source>
          <target state="translated">在Map中， &lt;code&gt;keys&lt;/code&gt; 和/或 &lt;code&gt;values&lt;/code&gt; 和/或 &lt;code&gt;both (e.g., entrySet)&lt;/code&gt; 迭代取决于人的兴趣in_ Like：</target>
        </trans-unit>
        <trans-unit id="fc677eb8c592126da1f730119c25b473d0885049" translate="yes" xml:space="preserve">
          <source>In an idiosyncratic implementation, it might make some difference whether you use &lt;code&gt;map.keySet()&lt;/code&gt;, &lt;code&gt;map.entrySet()&lt;/code&gt; or something else. But I can't think of a reason why anyone would write it like that. Most likely it makes no difference to performance what you do.</source>
          <target state="translated">在特有的实现中，无论使用 &lt;code&gt;map.keySet()&lt;/code&gt; ， &lt;code&gt;map.entrySet()&lt;/code&gt; 还是其他方法，都可能会有所不同。 但是我想不出有人会这样写的原因。 最有可能的是，它不会对您的工作产生任何影响。</target>
        </trans-unit>
        <trans-unit id="473fd68b5588936170d01e9b550860d05cf2d9c8" translate="yes" xml:space="preserve">
          <source>In choosing a &lt;code&gt;Map&lt;/code&gt; implementation, also consider:</source>
          <target state="translated">在选择 &lt;code&gt;Map&lt;/code&gt; 实现时，还应考虑：</target>
        </trans-unit>
        <trans-unit id="c24842ac42e680dc877680a2f5d56059350889d8" translate="yes" xml:space="preserve">
          <source>In theory, the most efficient way will depend on which implementation of Map. The official way to do this is to call &lt;code&gt;map.entrySet()&lt;/code&gt;, which returns a set of &lt;code&gt;Map.Entry&lt;/code&gt;, each of which contains a key and a value (&lt;code&gt;entry.getKey()&lt;/code&gt; and &lt;code&gt;entry.getValue()&lt;/code&gt;).</source>
          <target state="translated">从理论上讲，最有效的方法将取决于Map的实现方式。 官方的方法是调用 &lt;code&gt;map.entrySet()&lt;/code&gt; ，它返回一组 &lt;code&gt;Map.Entry&lt;/code&gt; ，每个Map.Entry包含一个键和一个值（ &lt;code&gt;entry.getKey()&lt;/code&gt; 和 &lt;code&gt;entry.getValue()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aef18bcaa1a6078d0596df965e6f06bff342eebb" translate="yes" xml:space="preserve">
          <source>Including documentation links to Oracle Docs.
For more on &lt;strong&gt;Lambda&lt;/strong&gt; go to this &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;link&lt;/a&gt; and must read &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/streams/&quot;&gt;Aggregate Operations&lt;/a&gt; and for Spliterator go to this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html&quot;&gt;link&lt;/a&gt;.</source>
          <target state="translated">包括指向Oracle Docs的文档链接。 有关&lt;strong&gt;Lambda的&lt;/strong&gt;更多信息，请访问此&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;链接，&lt;/a&gt;并且必须阅读&amp;ldquo; &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/streams/&quot;&gt;聚合操作&amp;rdquo;&lt;/a&gt; ；对于Spliterator，请访问此&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html&quot;&gt;链接&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c287a1bbff0a047aa1cc86cd23da90c9abec2a7c" translate="yes" xml:space="preserve">
          <source>Java 8</source>
          <target state="translated">Java 8</target>
        </trans-unit>
        <trans-unit id="1a24293b0fdd436ea326a582b3900c6277396743" translate="yes" xml:space="preserve">
          <source>Just copy paste below statement to your code and rename the &lt;strong&gt;HashMap&lt;/strong&gt; variable from &lt;strong&gt;hm&lt;/strong&gt; to your HashMap variable to print out key-value pair.</source>
          <target state="translated">只需将以下语句的粘贴粘贴复制到您的代码中，然后将&lt;strong&gt;HashMap&lt;/strong&gt;变量从&lt;strong&gt;hm&lt;/strong&gt;重命名为HashMap变量即可打印出键值对。</target>
        </trans-unit>
        <trans-unit id="db5c42f3ae489e1d2055785ca9044320a3138887" translate="yes" xml:space="preserve">
          <source>LinkedHashMap (1):</source>
          <target state="translated">LinkedHashMap(1)。</target>
        </trans-unit>
        <trans-unit id="73f20d040d451199d93293d63622c81c896ec906" translate="yes" xml:space="preserve">
          <source>LinkedHashMap (2):</source>
          <target state="translated">LinkedHashMap(2)。</target>
        </trans-unit>
        <trans-unit id="81595b19783c5714a55f00459b2855988e0e079e" translate="yes" xml:space="preserve">
          <source>Most compact with Java 8:</source>
          <target state="translated">最紧凑的是Java 8。</target>
        </trans-unit>
        <trans-unit id="2f2c621cb10233dbf9ece2193f2f19a3f155495a" translate="yes" xml:space="preserve">
          <source>NULLs. Some implementations forbid/accept a NULL as key and/or value.</source>
          <target state="translated">NULLs。有些实现不允许接受NULL作为键和值。</target>
        </trans-unit>
        <trans-unit id="f504a9f397b7b30ca39f0ef1407b932940292f78" translate="yes" xml:space="preserve">
          <source>Natural order</source>
          <target state="translated">自然秩序</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="58431d2cb2f2a436e30d687d47551e6350d00b91" translate="yes" xml:space="preserve">
          <source>Original insertion order</source>
          <target state="translated">原始插入顺序</target>
        </trans-unit>
        <trans-unit id="67ea52f1a7ae74f014909d25b0bddf410e9fbbb3" translate="yes" xml:space="preserve">
          <source>Other considerations</source>
          <target state="translated">其他方面的考虑</target>
        </trans-unit>
        <trans-unit id="0b379a43d717dba06857b0da94da11fa13a38e2f" translate="yes" xml:space="preserve">
          <source>See this table I created summarizing the various &lt;code&gt;Map&lt;/code&gt; implementations bundled with Java 11. Specifically, notice the &lt;em&gt;iteration order&lt;/em&gt; column. Click/tap to zoom.</source>
          <target state="translated">请参阅我创建的这张表，其中概述了与Java 11捆绑在一起的各种 &lt;code&gt;Map&lt;/code&gt; 实现。特别是，请注意&lt;em&gt;迭代顺序&lt;/em&gt;列。 单击/点击以缩放。</target>
        </trans-unit>
        <trans-unit id="4595ac23a27791fe7fbe0d4d4c43740979d75813" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;Map&lt;/code&gt; implementations promise a certain iteration order, others do not.</source>
          <target state="translated">有些 &lt;code&gt;Map&lt;/code&gt; 实现承诺一定的迭代顺序，而另一些则没有。</target>
        </trans-unit>
        <trans-unit id="44ea68cf30e14f2ddc12c26d6ae286ba0a85cc9c" translate="yes" xml:space="preserve">
          <source>Suppose you have one Map like:</source>
          <target state="translated">假设你有一张地图,如:</target>
        </trans-unit>
        <trans-unit id="8c5fb6a3a0e3368214ec978de8a33e83c0fd6ed4" translate="yes" xml:space="preserve">
          <source>Table (perfomance tests depending on map size)</source>
          <target state="translated">表(根据地图大小进行性能测试)</target>
        </trans-unit>
        <trans-unit id="f9f6bd1eb290901a88aeb60726443ff7d66c84d2" translate="yes" xml:space="preserve">
          <source>The advantage with streams is they can be parallelized easily in case we want to. We simply need to use &lt;code&gt;parallelStream()&lt;/code&gt; in place of &lt;code&gt;stream()&lt;/code&gt; above.</source>
          <target state="translated">流的优势在于，如果我们愿意的话，它们可以很容易地并行化。 我们只需要使用 &lt;code&gt;parallelStream()&lt;/code&gt; 代替上面的 &lt;code&gt;stream()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbc9eb3726815146c387b80d2f2f63f5ddb55da3" translate="yes" xml:space="preserve">
          <source>The code below shows iteration through LinkedHashMap and normal HashMap (example). You will see difference in the order:</source>
          <target state="translated">下面的代码显示了通过LinkedHashMap和普通HashMap的迭代(示例)。你会看到顺序上的差异。</target>
        </trans-unit>
        <trans-unit id="e52b25a08f2a02df03a2dfe2046b8da6d3756b34" translate="yes" xml:space="preserve">
          <source>The correct way to do this is to use the accepted answer as it is the most efficient. I find the following code looks a bit cleaner.</source>
          <target state="translated">正确的方法是使用公认的答案,因为这是最有效的。我觉得下面的代码看起来比较干净。</target>
        </trans-unit>
        <trans-unit id="40692755bf402ab70ec2f1031f4cdb1100ed8d13" translate="yes" xml:space="preserve">
          <source>The older &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/SortedMap.html&quot;&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt; interface is effectively supplanted by the newer &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; interface. But you may find 3rd-party implementations implementing the older interface only.</source>
          <target state="translated">较旧的&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/SortedMap.html&quot;&gt; &lt;code&gt;SortedMap&lt;/code&gt; &lt;/a&gt;界面实际上已由较新的&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt;界面取代。 但是您可能会发现第三方实现仅实现了较旧的接口。</target>
        </trans-unit>
        <trans-unit id="f4598b67765b6de694c769bc44b167a07f3ddbda" translate="yes" xml:space="preserve">
          <source>The ordering will always depend on the specific map implementation.
Using Java&amp;nbsp;8 you can use either of these:</source>
          <target state="translated">排序将始终取决于特定的地图实现。 使用Java 8，您可以使用以下两种方法之一：</target>
        </trans-unit>
        <trans-unit id="bb0c23da405fcd789494b9eeb5a645b5955b59c8" translate="yes" xml:space="preserve">
          <source>The result will be the same (same order). The entrySet backed by the map so you are getting the same order. The second one is handy as it allows you to use lambdas, e.g. if you want only to print only Integer objects that are greater than 5:</source>
          <target state="translated">结果将是一样的(相同的顺序)。entrySet是由map支持的,所以你得到的顺序是一样的。第二种方法很方便,因为它允许你使用lambdas,例如,如果你只想只打印大于5的Integer对象。</target>
        </trans-unit>
        <trans-unit id="9bbc8868f5a914986cb34d081536fd74a7785d90" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; will be inferred by the compiler and there is no need to use &lt;code&gt;Map.Entry&lt;/code&gt; anymore.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 的类型将由编译器推断，并且不再需要使用 &lt;code&gt;Map.Entry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f90f64e5ecb7bd2bb1395d60d9486cc542f43710" translate="yes" xml:space="preserve">
          <source>Then you can do something like the below to iterate over map elements.</source>
          <target state="translated">那么你可以做类似下面这样的事情来迭代地图元素。</target>
        </trans-unit>
        <trans-unit id="bbfb9fdec90164bf482004ec9ff49df454fa2660" translate="yes" xml:space="preserve">
          <source>There are a lot of ways to do this. Below is a few simple steps:</source>
          <target state="translated">方法有很多种。下面是几个简单的步骤。</target>
        </trans-unit>
        <trans-unit id="45fc9393135cf25ad84bcc71ef5e748db800c55d" translate="yes" xml:space="preserve">
          <source>There are several ways to iterate over map.</source>
          <target state="translated">有几种方法来迭代地图。</target>
        </trans-unit>
        <trans-unit id="8a85b761dfc0b6d7c4853d436ef0b85c865f89b6" translate="yes" xml:space="preserve">
          <source>This is a two part question:</source>
          <target state="translated">这是一个两部分的问题。</target>
        </trans-unit>
        <trans-unit id="b96a5d51c7d4e75b147cac932f1df8154b606b4e" translate="yes" xml:space="preserve">
          <source>To summarize the other answers and combine them with what I know, I found 10 main ways to do this (see below). Also, I wrote some performance tests (see results below). For example, if we want to find the sum of all of the keys and values of a map, we can write:</source>
          <target state="translated">为了总结其他答案,结合我所知道的内容,我找到了10个主要的方法(见下文)。另外,我还写了一些性能测试(见下面的结果)。例如,如果我们想找到一张地图的所有键和值的总和,我们可以写。</target>
        </trans-unit>
        <trans-unit id="eea8e2fbfdadecffc34ccb60883d55b390d62628" translate="yes" xml:space="preserve">
          <source>Try this with Java 1.4:</source>
          <target state="translated">用Java 1.4试试这个。</target>
        </trans-unit>
        <trans-unit id="3e692e2cdce8ba138bff14befa18b3272b620418" translate="yes" xml:space="preserve">
          <source>Two of those implement the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; interface: &lt;code&gt;TreeMap&lt;/code&gt; &amp;amp; &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;.</source>
          <target state="translated">其中两个实现&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt;接口： &lt;code&gt;TreeMap&lt;/code&gt; 和 &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0814b143955158188c01052f3ceb5ba0f4bf1a4c" translate="yes" xml:space="preserve">
          <source>Typical code for iterating over a map is:</source>
          <target state="translated">对地图进行迭代的典型代码是。</target>
        </trans-unit>
        <trans-unit id="b0e1da2614eac9ef96d91f4a14fda3c203ed934e" translate="yes" xml:space="preserve">
          <source>Use Java 8:</source>
          <target state="translated">使用Java 8。</target>
        </trans-unit>
        <trans-unit id="633b42502a5c51154b31c24409538f2cf25201f7" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;IterableMap&lt;/strong&gt; of &lt;code&gt;Apache Collections&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;Apache Collections&lt;/code&gt; &lt;strong&gt;IterableMap&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e6ec89e4a5b8a80f2496e8cf6a0a4081c374aab" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;MutableMap&lt;/strong&gt; of Eclipse (CS) collections</source>
          <target state="translated">使用Eclipse &lt;strong&gt;MutableMap&lt;/strong&gt; （CS）集合</target>
        </trans-unit>
        <trans-unit id="b54a5fdfbc9ecf10962725149d2d419b3abbb3f0" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;for&lt;/strong&gt; and &lt;strong&gt;Map.Entry&lt;/strong&gt;</source>
          <target state="translated">使用&lt;strong&gt;for&lt;/strong&gt;和&lt;strong&gt;Map.Entry&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eba2f7e5a0ff9fa992e5f7680f4ac9e7a9c58aea" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;forEach&lt;/strong&gt; from Java 8</source>
          <target state="translated">从Java 8使用&lt;strong&gt;forEach&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a545ca6c32cca8a0529723e65006632305936d38" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;foreach&lt;/strong&gt; and &lt;strong&gt;Map.Entry&lt;/strong&gt;</source>
          <target state="translated">使用&lt;strong&gt;foreach&lt;/strong&gt;和&lt;strong&gt;Map.Entry&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="485ee3eaf55ad9e70f346bcb0862491cf0ee98ee" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;iterator&lt;/strong&gt; and &lt;strong&gt;Map.Entry&lt;/strong&gt;</source>
          <target state="translated">使用&lt;strong&gt;迭代器&lt;/strong&gt;和&lt;strong&gt;Map.Entry&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc9935ec102d94e6a964ac34ff58f749b4af47d" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;keySet&lt;/strong&gt; and &lt;strong&gt;foreach&lt;/strong&gt;</source>
          <target state="translated">使用&lt;strong&gt;keySet&lt;/strong&gt;和&lt;strong&gt;foreach&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88e9bb2e701d85507ea9e8debd7b4fbd4ad3778c" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;keySet&lt;/strong&gt; and &lt;strong&gt;iterator&lt;/strong&gt;</source>
          <target state="translated">使用&lt;strong&gt;keySet&lt;/strong&gt;和&lt;strong&gt;迭代器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36dae4ef0cd75cfeb8ecebf9eba9a9a61d11f34e" translate="yes" xml:space="preserve">
          <source>Using the Java 8 &lt;strong&gt;Stream API parallel&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;并行&lt;/strong&gt;使用Java 8 &lt;strong&gt;Stream API&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5caf9ed2a72d6f4ecbca766fb5691949d6216417" translate="yes" xml:space="preserve">
          <source>Using the Java 8 &lt;strong&gt;Stream API&lt;/strong&gt;</source>
          <target state="translated">使用Java 8 &lt;strong&gt;Stream API&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eafcfcc9f356a37cd9ee651b3aa678c42fcbcb9e" translate="yes" xml:space="preserve">
          <source>We have got &lt;code&gt;forEach&lt;/code&gt; method that accepts a &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;lambda expression&lt;/a&gt;. We have also got &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;stream&lt;/a&gt; APIs. Consider a map:</source>
          <target state="translated">我们有接受&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;lambda表达式的&lt;/a&gt; &lt;code&gt;forEach&lt;/code&gt; 方法。 我们也有&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;流&lt;/a&gt; API。 考虑一张地图：</target>
        </trans-unit>
        <trans-unit id="d798e0a7eca0befff8709b5ebe731b0fa73ec725" translate="yes" xml:space="preserve">
          <source>Will the ordering of elements depend on the specific map implementation that I have for the interface?</source>
          <target state="translated">元素的排序是否取决于我对接口的具体地图实现?</target>
        </trans-unit>
        <trans-unit id="017762b012dd7225113538796ddba61ae61e2c5a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/eclipse/eclipse-collections&quot;&gt;Eclipse Collections&lt;/a&gt; (formerly &lt;a href=&quot;https://github.com/goldmansachs/gs-collections&quot;&gt;GS Collections&lt;/a&gt;), you would use the forEachKeyValue method on the &lt;a href=&quot;https://github.com/eclipse/eclipse-collections/blob/master/eclipse-collections-api/src/main/java/org/eclipse/collections/api/map/MapIterable.java&quot;&gt;MapIterable&lt;/a&gt; interface, which is inherited by the MutableMap and ImmutableMap interfaces and their implementations.</source>
          <target state="translated">对于&lt;a href=&quot;https://github.com/eclipse/eclipse-collections&quot;&gt;Eclipse Collections&lt;/a&gt; （以前称为&lt;a href=&quot;https://github.com/goldmansachs/gs-collections&quot;&gt;GS Collections&lt;/a&gt; ），您将在&lt;a href=&quot;https://github.com/eclipse/eclipse-collections/blob/master/eclipse-collections-api/src/main/java/org/eclipse/collections/api/map/MapIterable.java&quot;&gt;MapIterable&lt;/a&gt;接口上使用forEachKeyValue方法，该方法由MutableMap和ImmutableMap接口及其实现继承。</target>
        </trans-unit>
        <trans-unit id="306de5f65025cadf9565e4afbdf42027db4cb2dc" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;Java 8&lt;/strong&gt;</source>
          <target state="translated">使用&lt;strong&gt;Java 8&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4699cd9129494ddc388093886dfdad742d8561b2" translate="yes" xml:space="preserve">
          <source>With Java 8 lambda syntax, you can write the code as follows:</source>
          <target state="translated">使用Java 8 lambda语法,可以写出如下代码。</target>
        </trans-unit>
        <trans-unit id="b84aef87a2bc298b8e63f4075a8e2f44a93fdcfb" translate="yes" xml:space="preserve">
          <source>Yes, absolutely.</source>
          <target state="translated">是的,绝对的。</target>
        </trans-unit>
        <trans-unit id="cae53b76e40d2202c18f68f4690b03274ac40cb7" translate="yes" xml:space="preserve">
          <source>Yes, the order depends on the specific Map implementation.</source>
          <target state="translated">是的,这个订单取决于具体的地图实现。</target>
        </trans-unit>
        <trans-unit id="daf91a238253e2d658f686a2323d495a7c1aa9a8" translate="yes" xml:space="preserve">
          <source>You can do it using generics:</source>
          <target state="translated">你可以用通用语来做。</target>
        </trans-unit>
        <trans-unit id="c8f6998bce11971227c73926226c4fc1e993e492" translate="yes" xml:space="preserve">
          <source>You can see there are &lt;strong&gt;four &lt;code&gt;Map&lt;/code&gt; implementations maintaining an order&lt;/strong&gt;:</source>
          <target state="translated">您可以看到有&lt;strong&gt;四个 &lt;code&gt;Map&lt;/code&gt; 实现维护顺序&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="1cbe0c6bd90ebdac70a867735970ee3858618266" translate="yes" xml:space="preserve">
          <source>You can use lambda expressions:</source>
          <target state="translated">你可以使用lambda表达式。</target>
        </trans-unit>
        <trans-unit id="bd68512ae08ef0e4cfbba091825597ceb90fe6f4" translate="yes" xml:space="preserve">
          <source>[edit] I wrote &lt;code&gt;valueSet()&lt;/code&gt; originally but of course &lt;code&gt;entrySet()&lt;/code&gt; is actually the answer.</source>
          <target state="translated">[edit]我最初写的是 &lt;code&gt;valueSet()&lt;/code&gt; ,但是当然， &lt;code&gt;entrySet()&lt;/code&gt; 实际上是答案。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
