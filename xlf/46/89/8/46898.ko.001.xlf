<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/46898">
    <body>
      <group id="46898">
        <trans-unit id="d30462a41bd01ccebda2cf58a3b8353e1b7840fd" translate="yes" xml:space="preserve">
          <source>0 (#:0):0, 1 (#:1):1, 2 (#:2):2, 3 (#:3):3, 4 (#:4):4, 5 (#:5):5, 6 (#:6):6, 7 (#:7):7, 8 (#:8):8, 9 (#:9):9, 10 (#:10):10,</source>
          <target state="translated">0 (# : 0) : 0, 1 (# : 1) : 1, 2 (# : 2) : 2, 3 (# : 3) : 3, 4 (# : 4) : 4, 5 (# : 5 ) : 5, 6 (# : 6) : 6, 7 (# : 7) : 7, 8 (# : 8) : 8, 9 (# : 9) : 9, 10 (# : 10) : 10,</target>
        </trans-unit>
        <trans-unit id="2ddf1133bc32496871045e6d597d4d6a1dc1e8da" translate="yes" xml:space="preserve">
          <source>0 : 0, 1 : 1, 2 : 2, 3 : 3, 4 : 4, 5 : 5, 6 : 6, 7 : 7, 8 : 8, 9 : 9, 10 : 10,</source>
          <target state="translated">0 : 0, 1 : 1, 2 : 2, 3 : 3, 4 : 4, 5 : 5, 6 : 6, 7 : 7, 8 : 8, 9 : 9, 10:10,</target>
        </trans-unit>
        <trans-unit id="40f71110f1c6d89a83d5d74998a6bae84cb0eac9" translate="yes" xml:space="preserve">
          <source>1.) Iterate through the &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#keySet%28%29&quot;&gt;&lt;code&gt;keys -&amp;gt; keySet()&lt;/code&gt;&lt;/a&gt; of the map:</source>
          <target state="translated">1.) 맵의 &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#keySet%28%29&quot;&gt; &lt;code&gt;keys -&amp;gt; keySet()&lt;/code&gt; &lt;/a&gt; 을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="b434c39c68821bc91a36a5d79143911b1685346e" translate="yes" xml:space="preserve">
          <source>10 (#=10):10, 9 (#=9):9, 8 (#=8):8, 7 (#=7):7, 6 (#=6):6, 5 (#=5):5, 4 (#=4):4, 3 (#=3):3, 2 (#=2):2, 1 (#=1):1, 0 (#=0):0,</source>
          <target state="translated">10 (# = 10) : 10, 9 (# = 9) : 9, 8 (# = 8) : 8, 7 (# = 7) : 7, 6 (# = 6) : 6, 5 (# = 5 ) : 5, 4 (# = 4) : 4, 3 (# = 3) : 3, 2 (# = 2) : 2, 1 (# = 1) : 1, 0 (# = 0) : 0,</target>
        </trans-unit>
        <trans-unit id="07e7842ae451e8b223fddd46806bc2418f4d8622" translate="yes" xml:space="preserve">
          <source>10 : 10, 9 : 9, 8 : 8, 7 : 7, 6 : 6, 5 : 5, 4 : 4, 3 : 3, 2 : 2, 1 : 1, 0 : 0,</source>
          <target state="translated">10:10, 9 : 9, 8 : 8, 7 : 7, 6 : 6, 5 : 5, 4 : 4, 3 : 3, 2 : 2, 1 : 1, 0 : 0,</target>
        </trans-unit>
        <trans-unit id="76c3ebd56308a64015138e37e4c85af5080783a3" translate="yes" xml:space="preserve">
          <source>2.) Iterate through the &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#values%28%29&quot;&gt;&lt;code&gt;values -&amp;gt; values()&lt;/code&gt;&lt;/a&gt; of the map:</source>
          <target state="translated">2.) 맵의 &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#values%28%29&quot;&gt; &lt;code&gt;values -&amp;gt; values()&lt;/code&gt; &lt;/a&gt; 를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="a3bbdbbb036debbd91e9605d4745f68dd12997a6" translate="yes" xml:space="preserve">
          <source>3.) Iterate through the &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#entrySet%28%29&quot;&gt;&lt;code&gt;both -&amp;gt; entrySet()&lt;/code&gt;&lt;/a&gt; of the map:</source>
          <target state="translated">3.) 맵의 &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#entrySet%28%29&quot;&gt; &lt;code&gt;both -&amp;gt; entrySet()&lt;/code&gt; &lt;/a&gt; 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="0bdeeaef0187d00458632d3659a4402cd79e9934" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/46898/how-to-efficiently-iterate-over-each-entry-in-a-map/46908#46908&quot;&gt;@ScArcher2 has the more elegant Java 1.5 syntax&lt;/a&gt;. In 1.4, I would do something like this:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/46898/how-to-efficiently-iterate-over-each-entry-in-a-map/46908#46908&quot;&gt;@ ScArcher2는보다 우아한 Java 1.5 구문을 가지고&lt;/a&gt; 있습니다. 1.4에서는 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="78fd64c50744c65d102273e78ce957c849ebbeff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is the canonical map implementation and doesn't make guarantees (or though it should not change order if no mutating operation are performed on it). &lt;code&gt;SortedMap&lt;/code&gt; will return entries based on the natural ordering of the keys, or a &lt;code&gt;Comparator&lt;/code&gt;, if provided. &lt;code&gt;LinkedHashMap&lt;/code&gt; will either return entries in insertion-order or access-order depending upon how it has been constructed. &lt;code&gt;EnumMap&lt;/code&gt; returns entries in natural order of keys.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 표준 맵 구현이며 보장하지 않습니다 (또는 돌연변이 작업이 수행되지 않으면 순서를 변경해서는 안됩니다). &lt;code&gt;SortedMap&lt;/code&gt; 은 키의 자연스러운 순서 또는 제공된 경우 &lt;code&gt;Comparator&lt;/code&gt; 를 기반으로 항목을 반환합니다. &lt;code&gt;LinkedHashMap&lt;/code&gt; 은 구성 방식에 따라 게재 신청서 또는 액세스 순서로 항목을 반환합니다. &lt;code&gt;EnumMap&lt;/code&gt; 은 자연스럽게 키 순서로 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df9e23213522feb0f851809e192dbba0cd4ef337" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NavigableMap&lt;/code&gt; interface</source>
          <target state="translated">&lt;code&gt;NavigableMap&lt;/code&gt; 인터페이스</target>
        </trans-unit>
        <trans-unit id="b8061c26823755d99e280ad254f9a7a64a9225cb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;50 milliseconds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;50 밀리 초&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1f2a23cfa6ed0be46057a39259af74d813bd4b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;75 milliseconds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;75 밀리 초&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7551ebfccb1284552c4ac29e34b7aecc41ed5dfe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;76 milliseconds&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;76 밀리 초&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87d7a5349b3fd394b840fd8e8315f40c28028239" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;How to iterate over the entries of a Map&lt;/em&gt; - @ScArcher2 has &lt;a href=&quot;https://stackoverflow.com/a/46908/1851302&quot;&gt;answered&lt;/a&gt; that perfectly.</source>
          <target state="translated">@ ScArcher2 &lt;em&gt;맵의 항목을 반복하는 방법&lt;/em&gt; 은 완벽하게 &lt;a href=&quot;https://stackoverflow.com/a/46908/1851302&quot;&gt;답변&lt;/a&gt; 했습니다.</target>
        </trans-unit>
        <trans-unit id="8c8940fb37dfcfef05c009e102fb571f8441ea00" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you want to write a conditional for lambda you can write it like this:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;람다에 대한 조건부를 작성하려면 다음과 같이 작성할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a34520f314ded34eb3cacb1a2590ee9c9299821" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Moreover, there are 3 difference ways to Iterate Through a HashMap. They are as below&lt;/em&gt;_</source>
          <target state="translated">&lt;em&gt;또한 HashMap을 반복하는 세 가지 방법이 있습니다.&lt;/em&gt; &lt;em&gt;그들은 아래와 같습니다&lt;/em&gt; _</target>
        </trans-unit>
        <trans-unit id="ff6cb7605a078a3bfb48c2579c0969790a6fed46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the order of iteration&lt;/em&gt; - if you are just using &lt;code&gt;Map&lt;/code&gt;, then strictly speaking, there are &lt;strong&gt;no ordering guarantees&lt;/strong&gt;.  So you shouldn't really rely on the ordering given by any implementation.  However, the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt; interface extends &lt;code&gt;Map&lt;/code&gt; and provides exactly what you are looking for - implementations will aways give a consistent sort order.</source>
          <target state="translated">&lt;em&gt;반복 순서는 무엇입니까?&lt;/em&gt; &lt;code&gt;Map&lt;/code&gt; 을 사용하고 엄격히 말하면 &lt;strong&gt;순서 보장&lt;/strong&gt; 은 &lt;strong&gt;없습니다&lt;/strong&gt; . 따라서 구현에서 제공 한 순서에 의존해서는 안됩니다. 그러나 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt; &lt;code&gt;SortedMap&lt;/code&gt; &lt;/a&gt; 인터페이스는 &lt;code&gt;Map&lt;/code&gt; 을 확장하고 원하는 것을 정확하게 제공합니다. 구현은 일관된 정렬 순서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7b9f49f0624beecc76e4c400005cc314c104082e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(Update: I think this is no longer true.&lt;/strong&gt;) Note, &lt;code&gt;IdentityHashMap&lt;/code&gt;&lt;code&gt;entrySet&lt;/code&gt; iterator currently has a peculiar implementation which returns the same &lt;code&gt;Map.Entry&lt;/code&gt; instance for every item in the &lt;code&gt;entrySet&lt;/code&gt;! However, every time a new the iterator advances the &lt;code&gt;Map.Entry&lt;/code&gt; is updated.</source>
          <target state="translated">&lt;strong&gt;(업데이트 : 이것이 더 이상 사실이 아니라고 생각합니다.&lt;/strong&gt; ) 참고, &lt;code&gt;IdentityHashMap&lt;/code&gt; &lt;code&gt;entrySet&lt;/code&gt; 반복자에는 현재 entrySet의 모든 항목에 대해 동일한 &lt;code&gt;Map.Entry&lt;/code&gt; 인스턴스를 반환하는 고유 한 구현이 있습니다! 그러나 새로운 반복자가 &lt;code&gt;Map.Entry&lt;/code&gt; 를 진행할 때마다 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="4b08e1ea1a9950c8944da65f4d98ac8bce434bec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Using &lt;code&gt;entrySet()&lt;/code&gt; in for each loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) 각 루프에 대해 &lt;code&gt;entrySet()&lt;/code&gt; ) 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef4f8dcdb2b42abc6c11a4507ae8f995723b6a25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Using &lt;code&gt;keySet()&lt;/code&gt; in for each loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) 각 루프에 대해 &lt;code&gt;keySet()&lt;/code&gt; ) 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ce455fc72a7bee227dd834267207040b1408afb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Using &lt;code&gt;entrySet()&lt;/code&gt; and iterator&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3) &lt;code&gt;entrySet()&lt;/code&gt; 및 반복자 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f68c4111f1efcd5940165c5462abd76292ca5156" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4) Using &lt;code&gt;keySet()&lt;/code&gt; and iterator&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4) &lt;code&gt;keySet()&lt;/code&gt; 및 반복자 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01ab40a6cbbbd4ccc44c8cf3e70babf4c8d349fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; is another useful extension&lt;/strong&gt; - this is a &lt;code&gt;SortedMap&lt;/code&gt; with additional methods for finding entries by their ordered position in the key set.  So potentially this can remove the need for iterating in the first place - you might be able to find the specific &lt;code&gt;entry&lt;/code&gt; you are after using the &lt;code&gt;higherEntry&lt;/code&gt;, &lt;code&gt;lowerEntry&lt;/code&gt;, &lt;code&gt;ceilingEntry&lt;/code&gt;, or &lt;code&gt;floorEntry&lt;/code&gt; methods.  The &lt;code&gt;descendingMap&lt;/code&gt; method even gives you an explicit method of &lt;strong&gt;reversing the traversal order&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt; 은 또 다른 유용한 확장&lt;/strong&gt; 입니다. 이것은 키 세트에서 순서 된 위치에 따라 항목을 찾기위한 추가 메소드가있는 &lt;code&gt;SortedMap&lt;/code&gt; 입니다. 따라서 잠재적으로 이렇게하면 처음부터 반복 할 필요가 없어 질 수 있습니다. &lt;code&gt;higherEntry&lt;/code&gt; , &lt;code&gt;lowerEntry&lt;/code&gt; , &lt;code&gt;ceilingEntry&lt;/code&gt; 또는 &lt;code&gt;floorEntry&lt;/code&gt; 메소드를 사용한 후 특정 &lt;code&gt;entry&lt;/code&gt; 을 찾을 수 있습니다. &lt;code&gt;descendingMap&lt;/code&gt; 메소드 &lt;strong&gt;는 순회 순서&lt;/strong&gt; 를 &lt;strong&gt;취소&lt;/strong&gt; 하는 명시적인 메소드도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b0bdd3f912a52ada1dd392cd4ff14c74d0be6fcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;forEachOrdered&lt;/code&gt; vs &lt;code&gt;forEach&lt;/code&gt; with streams ?&lt;/strong&gt;
The &lt;code&gt;forEach&lt;/code&gt; does not follow encounter order (if defined) and is inherently non-deterministic in nature where as the &lt;code&gt;forEachOrdered&lt;/code&gt; does. So &lt;code&gt;forEach&lt;/code&gt; does not guarantee that the order would be kept. Also check &lt;a href=&quot;https://stackoverflow.com/questions/32797579/foreach-vs-foreachordered-in-java-8-stream&quot;&gt;this&lt;/a&gt; for more.</source>
          <target state="translated">&lt;strong&gt;스트림이있는 &lt;code&gt;forEachOrdered&lt;/code&gt; vs &lt;code&gt;forEach&lt;/code&gt; ?&lt;/strong&gt; &lt;code&gt;forEach&lt;/code&gt; 는 발생 순서 (정의 된 경우)를 &lt;code&gt;forEachOrdered&lt;/code&gt; 않으며 forEachOrdered 와 마찬가지로 본질적으로 비 결정적입니다. 따라서 &lt;code&gt;forEach&lt;/code&gt; 는 주문 유지를 보장하지 않습니다. &lt;a href=&quot;https://stackoverflow.com/questions/32797579/foreach-vs-foreachordered-in-java-8-stream&quot;&gt;이것도&lt;/a&gt; 더 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="22c727b2a9f2723354a008790444a6d3c6f5ce17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An effective iterative solution over a Map is a 'for each' loop from Java 5 through Java 7. Here it is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Map에 대한 효과적인 반복 솔루션은 Java 5에서 Java 7까지 'for each'루프입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c3c99f01f82e3dd15f6dea31f73807e5a330c16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Java 8 you can use a lambda expression to iterate over a Map. It is an enhanced 'forEach'&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java 8부터는 람다 식을 사용하여 맵을 반복 할 수 있습니다.&lt;/strong&gt; &lt;strong&gt;강화 된 'forEach'입니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8266e1e95a5d91ff447f8d45a4314d7d0606da42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterate over entries (Using forEach and Streams):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;항목 반복 (forEach 및 Stream 사용) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ef22017e708698482a126b2fe682a8f6d486473" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterate over keys:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;키 반복 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf9bdb43bd1b0449f7175e791319748eebbd91f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterate over values:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;값을 반복합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b958957df67e5e3894ae54fdec131a5fab7b7758" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java 8:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자바 8 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4ac5345e9dfeab6eedab1bed3634a2d61b232bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lambda&lt;/strong&gt; Expression Java 8</source>
          <target state="translated">&lt;strong&gt;람다&lt;/strong&gt; 식 자바 8</target>
        </trans-unit>
        <trans-unit id="cb33563a72610ed34b6b91ac165e4604be35ec62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I am a committer for Eclipse Collections.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 저는 Eclipse Collections의 커미터입니다.</target>
        </trans-unit>
        <trans-unit id="4eaa4758fc373a92b0951b602e363208503de373" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Perfomance tests&lt;/strong&gt; (mode = AverageTime, system = Windows&amp;nbsp;8.1 64-bit, Intel i7-4790 3.60 GHz, 16&amp;nbsp;GB)</source>
          <target state="translated">&lt;strong&gt;성능 테스트&lt;/strong&gt; (모드 = AverageTime, 시스템 = Windows 8.1 64 비트, Intel i7-4790 3.60GHz, 16GB)</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a2c64a759bdeec979cf1625cb2640fed35b8352" translate="yes" xml:space="preserve">
          <source>All tests are on &lt;a href=&quot;https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/5.0-other-examples/src/main/java/other_examples/IterateThroughHashMapTest.java&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">모든 테스트는 &lt;a href=&quot;https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/5.0-other-examples/src/main/java/other_examples/IterateThroughHashMapTest.java&quot;&gt;GitHub에서 이루어&lt;/a&gt; 집니다.</target>
        </trans-unit>
        <trans-unit id="e62b6b46bd13f4fdff912caff47e1c5ab9468154" translate="yes" xml:space="preserve">
          <source>Also one can use &lt;strong&gt;Spliterator&lt;/strong&gt; for the same.</source>
          <target state="translated">또한 &lt;strong&gt;Spliterator&lt;/strong&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4a128155fdd1ff9b255b50be54783cd11c5ad9a" translate="yes" xml:space="preserve">
          <source>And yes, the order will depend on the implementation - as well as (possibly) the order of insertion and other hard-to-control factors.</source>
          <target state="translated">그리고 예, 순서는 구현 순서와 삽입 순서 및 기타 제어하기 어려운 요소에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1987a85346ebed06208fda36057d3abf53a7dac9" translate="yes" xml:space="preserve">
          <source>Below is the sample code that I tried using &lt;strong&gt;Lambda Expression&lt;/strong&gt;. This stuff is so cool. Must try.</source>
          <target state="translated">다음은 &lt;strong&gt;Lambda Expression을&lt;/strong&gt; 사용하여 시도한 샘플 코드입니다. 이 물건은 너무 멋지다. 꼭 해봐.</target>
        </trans-unit>
        <trans-unit id="0091670d7a16db16eebf59a5b133fa1d4fcd9465" translate="yes" xml:space="preserve">
          <source>Both of these considerations are covered in the graphic table above.</source>
          <target state="translated">이러한 고려 사항은 위의 그래픽 표에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="837ca224c76bb8e31244cbe08276255126afae2e" translate="yes" xml:space="preserve">
          <source>Concurrency. If you are manipulating the map across threads, you must use an implementation that supports concurrency. Or wrap the map with &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)&quot;&gt;&lt;code&gt;Collections::synchronizedMap&lt;/code&gt;&lt;/a&gt; (less preferable).</source>
          <target state="translated">동시성. 여러 스레드에서 맵을 조작하는 경우 동시성을 지원하는 구현을 사용해야합니다. 또는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)&quot;&gt; &lt;code&gt;Collections::synchronizedMap&lt;/code&gt; &lt;/a&gt; 맵을 랩핑하십시오 (권장하지 않음).</target>
        </trans-unit>
        <trans-unit id="a7a59840fd712513666eaaab628bba060fffd164" translate="yes" xml:space="preserve">
          <source>Custom order</source>
          <target state="translated">맞춤 주문</target>
        </trans-unit>
        <trans-unit id="688d350fb8020500a3a5be3e3b008424818af135" translate="yes" xml:space="preserve">
          <source>Different implementations of &lt;code&gt;Map&lt;/code&gt; maintain different ordering of the key-value pairs.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 의 다른 구현은 키-값 쌍의 다른 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7c4c9d6bd088dbbd8d4fa9483665571f6a073ca9" translate="yes" xml:space="preserve">
          <source>Easy-peasy!</source>
          <target state="translated">Easy-peasy!</target>
        </trans-unit>
        <trans-unit id="4959fdef810c5bd96c8690ab36e2ce54b0823aaf" translate="yes" xml:space="preserve">
          <source>Enum-definition order</source>
          <target state="translated">열거 정의 순서</target>
        </trans-unit>
        <trans-unit id="27a91e453073eb90ef706eff0718c26b5d331956" translate="yes" xml:space="preserve">
          <source>Example of using iterator and generics:</source>
          <target state="translated">반복자와 제네릭을 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="dedaf2462a308ba9703f6ecfa549331ea9c670df" translate="yes" xml:space="preserve">
          <source>FYI, you can also use &lt;code&gt;map.keySet()&lt;/code&gt; and &lt;code&gt;map.values()&lt;/code&gt; if you're only interested in keys/values of the map and not the other.</source>
          <target state="translated">참고로, 맵의 키 / 값에만 관심이 있고 다른 맵에는 관심이 없다면 &lt;code&gt;map.keySet()&lt;/code&gt; 및 &lt;code&gt;map.values()&lt;/code&gt; 를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="56136984733171a2679dc40bd33baad71f4c3786" translate="yes" xml:space="preserve">
          <source>For a map with 10000 elements,  score 37.606 is the best</source>
          <target state="translated">요소가 10000 개인지도의 경우 37.606 점이 최고입니다.</target>
        </trans-unit>
        <trans-unit id="a5c0d4e335042175498e0ebf6327fd535efec693" translate="yes" xml:space="preserve">
          <source>For a map with 100000 elements,  score 1184.767 is the best</source>
          <target state="translated">100000 개의 요소가있는지도의 경우 1184.767 점이 최고입니다</target>
        </trans-unit>
        <trans-unit id="c1de52942477197f09659d082fa1f4b07b8f1bd4" translate="yes" xml:space="preserve">
          <source>For a small map (100 elements), score 0.308 is the best</source>
          <target state="translated">작은지도 (100 개 요소)의 경우 점수 0.308이 최고입니다</target>
        </trans-unit>
        <trans-unit id="7c1760d6bcb4b3d1af55825b8f0c542185f248bd" translate="yes" xml:space="preserve">
          <source>For more information, follow &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;this&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 다음을 수행 &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa0445de7e6bc5d4ad795d112414a663bfe8f9b3" translate="yes" xml:space="preserve">
          <source>Graphs (performance tests depending on map size)</source>
          <target state="translated">그래프 (지도 크기에 따른 성능 테스트)</target>
        </trans-unit>
        <trans-unit id="bf9babdab1657af8a0b764ba2e4045ed70ec5482" translate="yes" xml:space="preserve">
          <source>HashMap (1):</source>
          <target state="translated">해시 맵 (1) :</target>
        </trans-unit>
        <trans-unit id="8b2a0ebe1a9c40551264d3a2911adb4c9595e1ae" translate="yes" xml:space="preserve">
          <source>HashMap (2):</source>
          <target state="translated">해시 맵 (2) :</target>
        </trans-unit>
        <trans-unit id="ae33e1c12dd25e01506d37831a6c63b1eed254c7" translate="yes" xml:space="preserve">
          <source>Here is comparison of their performances for a common data set stored in map by storing a million key value pairs in map and will iterate over map.</source>
          <target state="translated">다음은 맵에 백만 개의 키 값 쌍을 저장하여 맵에 저장된 공통 데이터 세트의 성능을 비교 한 것이며 맵을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="2944fefd1e8c80dfefdf09ccf6789028fa2e370d" translate="yes" xml:space="preserve">
          <source>How do I efficiently iterate over each entry in a Java Map</source>
          <target state="translated">Java Map의 각 항목을 효율적으로 반복하는 방법</target>
        </trans-unit>
        <trans-unit id="8c44dd09a51d3d7e7030ada02609d672731914d5" translate="yes" xml:space="preserve">
          <source>I have referred &lt;a href=&quot;http://howtodoinjava.com/2013/04/01/performance-comparison-of-different-ways-to-iterate-over-hashmap/&quot;&gt;&lt;code&gt;this link&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://howtodoinjava.com/2013/04/01/performance-comparison-of-different-ways-to-iterate-over-hashmap/&quot;&gt; &lt;code&gt;this link&lt;/code&gt; &lt;/a&gt; 참조 했습니다 .</target>
        </trans-unit>
        <trans-unit id="9c86089bda3ea538b5612baeee4089a884b97993" translate="yes" xml:space="preserve">
          <source>If I have an object implementing the &lt;code&gt;Map&lt;/code&gt; interface in Java and I wish to iterate over every pair contained within it,  what is the most efficient way of going through the map?</source>
          <target state="translated">Java로 &lt;code&gt;Map&lt;/code&gt; 인터페이스를 구현하는 객체가 있고 그 안에 포함 된 모든 쌍을 반복하려면 맵을 통과하는 가장 효율적인 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7041d241864f2b22ad51ff33422107bb1546c0c8" translate="yes" xml:space="preserve">
          <source>If I have an object implementing the Map interface in Java and I wish to iterate over every pair contained within it, what is the most efficient way of going through the map?</source>
          <target state="translated">Java로 Map 인터페이스를 구현하는 객체가 있고 그 안에 포함 된 모든 쌍을 반복하려면 맵을 통과하는 가장 효율적인 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="79fa69f9b9f2bab1a018ec5832646f7d9c599a86" translate="yes" xml:space="preserve">
          <source>If efficiency of looping the keys is a priority for your app, then choose a &lt;code&gt;Map&lt;/code&gt; implementation that maintains the keys in your desired order.</source>
          <target state="translated">키 루프 효율성이 앱의 우선 순위 인 경우 원하는 순서로 키를 유지하는 &lt;code&gt;Map&lt;/code&gt; 구현을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="6411814b84ed759c763447c4612e9d83026c997c" translate="yes" xml:space="preserve">
          <source>If you are using an enum such as &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/DayOfWeek.html&quot;&gt;&lt;code&gt;DayOfWeek&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Month.html&quot;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/a&gt; as your keys, use the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/EnumMap.html&quot;&gt;&lt;code&gt;EnumMap&lt;/code&gt;&lt;/a&gt; class. Not only is this class &lt;em&gt;highly&lt;/em&gt; optimized to use very little memory and run very fast, it maintains your pairs in the order defined by the enum. For &lt;code&gt;DayOfWeek&lt;/code&gt;, for example, the key of &lt;code&gt;DayOfWeek.MONDAY&lt;/code&gt; will be first found when iterated, and the key of &lt;code&gt;DayOfWeek.SUNDAY&lt;/code&gt; will be last.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/DayOfWeek.html&quot;&gt; &lt;code&gt;DayOfWeek&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Month.html&quot;&gt; &lt;code&gt;Month&lt;/code&gt; &lt;/a&gt; 와 같은 열거 형을 키로 사용하는 경우 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/EnumMap.html&quot;&gt; &lt;code&gt;EnumMap&lt;/code&gt; &lt;/a&gt; 클래스를 사용하십시오. 이 클래스는 메모리를 거의 사용하지 않고 매우 빠르게 실행하도록 최적화되어있을뿐만 아니라 열거 형에서 정의한 순서대로 쌍을 유지합니다. 예를 들어 &lt;code&gt;DayOfWeek.MONDAY&lt;/code&gt; 경우 반복 할 때 DayOfWeek.MONDAY 키가 먼저 발견되고 &lt;code&gt;DayOfWeek.SUNDAY&lt;/code&gt; 키가 마지막에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="23cd9f2b5ed48db7c1117c31ae3a319fe97b4847" translate="yes" xml:space="preserve">
          <source>If you have a generic untyped Map you can use:</source>
          <target state="translated">일반 비 유형지도가있는 경우 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166cf4f9ea1423792bbb034bfbd9a29a1294960d" translate="yes" xml:space="preserve">
          <source>If you want a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; that keeps its pairs arranged by the &amp;ldquo;natural order&amp;rdquo; of the key, use &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt;&lt;code&gt;TreeMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt;&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;&lt;/a&gt;. The term &amp;ldquo;natural order&amp;rdquo; means the class of the keys implements &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;. The value returned by the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)&quot;&gt;&lt;code&gt;compareTo&lt;/code&gt;&lt;/a&gt; method is used for comparison in sorting.</source>
          <target state="translated">키의 &quot;자연 순서&quot;로 쌍을 정렬하는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 을 원하면 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt; &lt;code&gt;TreeMap&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt; &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; 을 사용하십시오&lt;/a&gt; . &quot;자연 순서&quot;라는 용어는 키의 클래스가 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; 을&lt;/a&gt; 구현 함을 의미합니다. &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)&quot;&gt; &lt;code&gt;compareTo&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 값은 정렬시 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="529bd36b670d6dd0399407ab228c35de68313ff8" translate="yes" xml:space="preserve">
          <source>If you want the pairs of your map to be kept in their original order in which you inserted them into the map, use &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedHashMap.html&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">맵 쌍을 맵에 삽입 한 원래 순서대로 유지하려면 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedHashMap.html&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; 을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7129ac34e2982430511674b7df7b084da57783b2" translate="yes" xml:space="preserve">
          <source>If you want to specify a custom sorting routine for your keys to be used in maintaining a sorted order, pass a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; implementation appropriate to the class of your keys. Use either &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt;&lt;code&gt;TreeMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt;&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;&lt;/a&gt;, passing your &lt;code&gt;Comparator&lt;/code&gt;.</source>
          <target state="translated">정렬 순서를 유지하는 데 키가 사용되도록 사용자 정의 정렬 루틴을 지정하려면 키 클래스에 적합한 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; 구현을 전달하십시오. &lt;code&gt;Comparator&lt;/code&gt; 전달하여 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html&quot;&gt; &lt;code&gt;TreeMap&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html&quot;&gt; &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; 을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9315bf2cae9009ab8354820e1d5393ff67c46162" translate="yes" xml:space="preserve">
          <source>In Java 1.8 (Java 8) this has become lot easier by using &lt;strong&gt;forEach&lt;/strong&gt; method from Aggregate operations(&lt;strong&gt;Stream operations&lt;/strong&gt;) that looks similar to iterators from &lt;strong&gt;Iterable&lt;/strong&gt; Interface.</source>
          <target state="translated">Java 1.8 (Java 8)에서는 &lt;strong&gt;Iterable&lt;/strong&gt; Interface의 반복자와 유사한 집계 작업 ( &lt;strong&gt;Stream operations&lt;/strong&gt; )의 &lt;strong&gt;forEach&lt;/strong&gt; 메소드를 사용하여 훨씬 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="35888f9edee70791965f52086d548982634b5327" translate="yes" xml:space="preserve">
          <source>In Java 8 you can do it clean and fast using the new lambdas features:</source>
          <target state="translated">Java 8에서는 새로운 람다 기능을 사용하여 깨끗하고 빠르게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d053ebfab1b4bad3db6c15f6e3252be1b563d13e" translate="yes" xml:space="preserve">
          <source>In Map one can Iteration over &lt;code&gt;keys&lt;/code&gt; and/or &lt;code&gt;values&lt;/code&gt; and/or &lt;code&gt;both (e.g., entrySet)&lt;/code&gt;  depends on one's interested in_ Like:</source>
          <target state="translated">Map에서 &lt;code&gt;keys&lt;/code&gt; 및 / 또는 &lt;code&gt;values&lt;/code&gt; 및 / 또는 &lt;code&gt;both (e.g., entrySet)&lt;/code&gt; 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc677eb8c592126da1f730119c25b473d0885049" translate="yes" xml:space="preserve">
          <source>In an idiosyncratic implementation, it might make some difference whether you use &lt;code&gt;map.keySet()&lt;/code&gt;, &lt;code&gt;map.entrySet()&lt;/code&gt; or something else. But I can't think of a reason why anyone would write it like that. Most likely it makes no difference to performance what you do.</source>
          <target state="translated">특유의 구현에서는 &lt;code&gt;map.keySet()&lt;/code&gt; , &lt;code&gt;map.entrySet()&lt;/code&gt; 또는 다른 것을 사용하는지에 따라 약간의 차이가 생길 수 있습니다. 그러나 나는 누군가가 그것을 그렇게 쓰는 이유를 생각할 수 없습니다. 대부분의 경우 성능에 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="473fd68b5588936170d01e9b550860d05cf2d9c8" translate="yes" xml:space="preserve">
          <source>In choosing a &lt;code&gt;Map&lt;/code&gt; implementation, also consider:</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 구현을 선택할 때 다음 사항도 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c24842ac42e680dc877680a2f5d56059350889d8" translate="yes" xml:space="preserve">
          <source>In theory, the most efficient way will depend on which implementation of Map. The official way to do this is to call &lt;code&gt;map.entrySet()&lt;/code&gt;, which returns a set of &lt;code&gt;Map.Entry&lt;/code&gt;, each of which contains a key and a value (&lt;code&gt;entry.getKey()&lt;/code&gt; and &lt;code&gt;entry.getValue()&lt;/code&gt;).</source>
          <target state="translated">이론적으로 가장 효율적인 방법은 Map의 구현에 따라 다릅니다. 이를위한 공식적인 방법은 &lt;code&gt;map.entrySet()&lt;/code&gt; 을 호출하는 것인데 , &lt;code&gt;Map.Entry&lt;/code&gt; 집합을 반환합니다. 각 Map.Entry 는 키와 값 ( &lt;code&gt;entry.getKey()&lt;/code&gt; 및 &lt;code&gt;entry.getValue()&lt;/code&gt; )을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="aef18bcaa1a6078d0596df965e6f06bff342eebb" translate="yes" xml:space="preserve">
          <source>Including documentation links to Oracle Docs.
For more on &lt;strong&gt;Lambda&lt;/strong&gt; go to this &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;link&lt;/a&gt; and must read &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/streams/&quot;&gt;Aggregate Operations&lt;/a&gt; and for Spliterator go to this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html&quot;&gt;link&lt;/a&gt;.</source>
          <target state="translated">Oracle Docs에 대한 설명서 링크 포함 &lt;strong&gt;Lambda&lt;/strong&gt; 에 대한 자세한 내용을 보려면이 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;링크&lt;/a&gt; 로 이동하여 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/streams/&quot;&gt;집계 작업을&lt;/a&gt; 읽어야하며 Spliterator의 경우이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html&quot;&gt;링크&lt;/a&gt; 로 이동 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c287a1bbff0a047aa1cc86cd23da90c9abec2a7c" translate="yes" xml:space="preserve">
          <source>Java 8</source>
          <target state="translated">자바 8</target>
        </trans-unit>
        <trans-unit id="1a24293b0fdd436ea326a582b3900c6277396743" translate="yes" xml:space="preserve">
          <source>Just copy paste below statement to your code and rename the &lt;strong&gt;HashMap&lt;/strong&gt; variable from &lt;strong&gt;hm&lt;/strong&gt; to your HashMap variable to print out key-value pair.</source>
          <target state="translated">아래 명령문을 코드에 복사하고 &lt;strong&gt;HashMap&lt;/strong&gt; 변수의 이름을 &lt;strong&gt;hm&lt;/strong&gt; 에서 &lt;strong&gt;HashMap&lt;/strong&gt; 변수로 &lt;strong&gt;바꾸어&lt;/strong&gt; 키-값 쌍을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="db5c42f3ae489e1d2055785ca9044320a3138887" translate="yes" xml:space="preserve">
          <source>LinkedHashMap (1):</source>
          <target state="translated">LinkedHashMap (1) :</target>
        </trans-unit>
        <trans-unit id="73f20d040d451199d93293d63622c81c896ec906" translate="yes" xml:space="preserve">
          <source>LinkedHashMap (2):</source>
          <target state="translated">LinkedHashMap (2) :</target>
        </trans-unit>
        <trans-unit id="81595b19783c5714a55f00459b2855988e0e079e" translate="yes" xml:space="preserve">
          <source>Most compact with Java 8:</source>
          <target state="translated">Java 8에서 가장 컴팩트 함 :</target>
        </trans-unit>
        <trans-unit id="2f2c621cb10233dbf9ece2193f2f19a3f155495a" translate="yes" xml:space="preserve">
          <source>NULLs. Some implementations forbid/accept a NULL as key and/or value.</source>
          <target state="translated">NULL입니다. 일부 구현에서는 NULL을 키 및 / 또는 값으로 금지 / 수락합니다.</target>
        </trans-unit>
        <trans-unit id="f504a9f397b7b30ca39f0ef1407b932940292f78" translate="yes" xml:space="preserve">
          <source>Natural order</source>
          <target state="translated">자연 질서</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="58431d2cb2f2a436e30d687d47551e6350d00b91" translate="yes" xml:space="preserve">
          <source>Original insertion order</source>
          <target state="translated">원본 게재 신청서</target>
        </trans-unit>
        <trans-unit id="67ea52f1a7ae74f014909d25b0bddf410e9fbbb3" translate="yes" xml:space="preserve">
          <source>Other considerations</source>
          <target state="translated">다른 고려 사항</target>
        </trans-unit>
        <trans-unit id="0b379a43d717dba06857b0da94da11fa13a38e2f" translate="yes" xml:space="preserve">
          <source>See this table I created summarizing the various &lt;code&gt;Map&lt;/code&gt; implementations bundled with Java 11. Specifically, notice the &lt;em&gt;iteration order&lt;/em&gt; column. Click/tap to zoom.</source>
          <target state="translated">Java 11과 함께 번들로 제공되는 다양한 &lt;code&gt;Map&lt;/code&gt; 구현을 요약 한이 표를 참조하십시오. 구체적으로 &lt;em&gt;반복 순서&lt;/em&gt; 열을 확인하십시오. 클릭 / 탭하여 확대합니다.</target>
        </trans-unit>
        <trans-unit id="4595ac23a27791fe7fbe0d4d4c43740979d75813" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;Map&lt;/code&gt; implementations promise a certain iteration order, others do not.</source>
          <target state="translated">일부 &lt;code&gt;Map&lt;/code&gt; 구현은 특정 반복 순서를 약속하지만 다른 일부는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44ea68cf30e14f2ddc12c26d6ae286ba0a85cc9c" translate="yes" xml:space="preserve">
          <source>Suppose you have one Map like:</source>
          <target state="translated">다음과 같은 하나의 맵이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="8c5fb6a3a0e3368214ec978de8a33e83c0fd6ed4" translate="yes" xml:space="preserve">
          <source>Table (perfomance tests depending on map size)</source>
          <target state="translated">표 (지도 크기에 따른 성능 테스트)</target>
        </trans-unit>
        <trans-unit id="f9f6bd1eb290901a88aeb60726443ff7d66c84d2" translate="yes" xml:space="preserve">
          <source>The advantage with streams is they can be parallelized easily in case we want to. We simply need to use &lt;code&gt;parallelStream()&lt;/code&gt; in place of &lt;code&gt;stream()&lt;/code&gt; above.</source>
          <target state="translated">스트림의 장점은 원하는 경우 쉽게 병렬화 할 수 있다는 것입니다. 위의 &lt;code&gt;stream()&lt;/code&gt; 대신에 &lt;code&gt;parallelStream()&lt;/code&gt; 을 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="dbc9eb3726815146c387b80d2f2f63f5ddb55da3" translate="yes" xml:space="preserve">
          <source>The code below shows iteration through LinkedHashMap and normal HashMap (example). You will see difference in the order:</source>
          <target state="translated">아래 코드는 LinkedHashMap 및 일반 HashMap (예)을 통한 반복을 보여줍니다. 순서에 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e52b25a08f2a02df03a2dfe2046b8da6d3756b34" translate="yes" xml:space="preserve">
          <source>The correct way to do this is to use the accepted answer as it is the most efficient. I find the following code looks a bit cleaner.</source>
          <target state="translated">이를 수행하는 올바른 방법은 승인 된 답변을 가장 효율적으로 사용하는 것입니다. 다음 코드가 약간 깨끗해 보입니다.</target>
        </trans-unit>
        <trans-unit id="40692755bf402ab70ec2f1031f4cdb1100ed8d13" translate="yes" xml:space="preserve">
          <source>The older &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/SortedMap.html&quot;&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt; interface is effectively supplanted by the newer &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; interface. But you may find 3rd-party implementations implementing the older interface only.</source>
          <target state="translated">이전의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/SortedMap.html&quot;&gt; &lt;code&gt;SortedMap&lt;/code&gt; &lt;/a&gt; 인터페이스는 최신 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt; 인터페이스에 의해 효과적으로 대체됩니다. 그러나 이전 인터페이스 만 구현하는 타사 구현을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4598b67765b6de694c769bc44b167a07f3ddbda" translate="yes" xml:space="preserve">
          <source>The ordering will always depend on the specific map implementation.
Using Java&amp;nbsp;8 you can use either of these:</source>
          <target state="translated">순서는 항상 특정지도 구현에 따라 다릅니다. Java 8을 사용하면 다음 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb0c23da405fcd789494b9eeb5a645b5955b59c8" translate="yes" xml:space="preserve">
          <source>The result will be the same (same order). The entrySet backed by the map so you are getting the same order. The second one is handy as it allows you to use lambdas, e.g. if you want only to print only Integer objects that are greater than 5:</source>
          <target state="translated">결과는 동일합니다 (동일한 순서). 동일한 순서를 얻도록 map이 지원하는 entrySet입니다. 두 번째는 람다를 사용할 수 있기 때문에 편리합니다. 예를 들어 5보다 큰 Integer 객체 만 인쇄하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="9bbc8868f5a914986cb34d081536fd74a7785d90" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; will be inferred by the compiler and there is no need to use &lt;code&gt;Map.Entry&lt;/code&gt; anymore.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 의 유형은 컴파일러에 의해 추론되며 더 이상 &lt;code&gt;Map.Entry&lt;/code&gt; 를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f90f64e5ecb7bd2bb1395d60d9486cc542f43710" translate="yes" xml:space="preserve">
          <source>Then you can do something like the below to iterate over map elements.</source>
          <target state="translated">그런 다음지도 요소를 반복하기 위해 아래와 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbfb9fdec90164bf482004ec9ff49df454fa2660" translate="yes" xml:space="preserve">
          <source>There are a lot of ways to do this. Below is a few simple steps:</source>
          <target state="translated">이를 수행하는 많은 방법이 있습니다. 다음은 몇 가지 간단한 단계입니다.</target>
        </trans-unit>
        <trans-unit id="45fc9393135cf25ad84bcc71ef5e748db800c55d" translate="yes" xml:space="preserve">
          <source>There are several ways to iterate over map.</source>
          <target state="translated">지도를 반복하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a85b761dfc0b6d7c4853d436ef0b85c865f89b6" translate="yes" xml:space="preserve">
          <source>This is a two part question:</source>
          <target state="translated">이것은 두 가지 질문입니다.</target>
        </trans-unit>
        <trans-unit id="b96a5d51c7d4e75b147cac932f1df8154b606b4e" translate="yes" xml:space="preserve">
          <source>To summarize the other answers and combine them with what I know, I found 10 main ways to do this (see below). Also, I wrote some performance tests (see results below). For example, if we want to find the sum of all of the keys and values of a map, we can write:</source>
          <target state="translated">다른 답변을 요약하고 내가 아는 것과 결합하기 위해 10 가지 주요 방법을 찾았습니다 (아래 참조). 또한 몇 가지 성능 테스트를 작성했습니다 (아래 결과 참조). 예를 들어지도의 모든 키와 값의 합계를 찾으려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea8e2fbfdadecffc34ccb60883d55b390d62628" translate="yes" xml:space="preserve">
          <source>Try this with Java 1.4:</source>
          <target state="translated">Java 1.4로 이것을 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="3e692e2cdce8ba138bff14befa18b3272b620418" translate="yes" xml:space="preserve">
          <source>Two of those implement the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; interface: &lt;code&gt;TreeMap&lt;/code&gt; &amp;amp; &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt; 2 개는 NavigableMap 인터페이스를 구현합니다 : &lt;code&gt;TreeMap&lt;/code&gt; &amp;amp; &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0814b143955158188c01052f3ceb5ba0f4bf1a4c" translate="yes" xml:space="preserve">
          <source>Typical code for iterating over a map is:</source>
          <target state="translated">지도를 반복하는 일반적인 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0e1da2614eac9ef96d91f4a14fda3c203ed934e" translate="yes" xml:space="preserve">
          <source>Use Java 8:</source>
          <target state="translated">Java 8을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="633b42502a5c51154b31c24409538f2cf25201f7" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;IterableMap&lt;/strong&gt; of &lt;code&gt;Apache Collections&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Apache Collections&lt;/code&gt; &lt;strong&gt;IterableMap&lt;/strong&gt; 사용</target>
        </trans-unit>
        <trans-unit id="5e6ec89e4a5b8a80f2496e8cf6a0a4081c374aab" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;MutableMap&lt;/strong&gt; of Eclipse (CS) collections</source>
          <target state="translated">이클립스 (CS) 컬렉션의 &lt;strong&gt;MutableMap&lt;/strong&gt; 사용</target>
        </trans-unit>
        <trans-unit id="b54a5fdfbc9ecf10962725149d2d419b3abbb3f0" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;for&lt;/strong&gt; and &lt;strong&gt;Map.Entry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;for&lt;/strong&gt; 및 &lt;strong&gt;Map.Entry 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eba2f7e5a0ff9fa992e5f7680f4ac9e7a9c58aea" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;forEach&lt;/strong&gt; from Java 8</source>
          <target state="translated">Java 8에서 &lt;strong&gt;forEach&lt;/strong&gt; 사용</target>
        </trans-unit>
        <trans-unit id="a545ca6c32cca8a0529723e65006632305936d38" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;foreach&lt;/strong&gt; and &lt;strong&gt;Map.Entry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;foreach&lt;/strong&gt; 및 &lt;strong&gt;Map.Entry 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="485ee3eaf55ad9e70f346bcb0862491cf0ee98ee" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;iterator&lt;/strong&gt; and &lt;strong&gt;Map.Entry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;반복자&lt;/strong&gt; 와 &lt;strong&gt;Map.Entry 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc9935ec102d94e6a964ac34ff58f749b4af47d" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;keySet&lt;/strong&gt; and &lt;strong&gt;foreach&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;keySet&lt;/strong&gt; 및 &lt;strong&gt;foreach 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88e9bb2e701d85507ea9e8debd7b4fbd4ad3778c" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;keySet&lt;/strong&gt; and &lt;strong&gt;iterator&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;keySet&lt;/strong&gt; 및 &lt;strong&gt;반복자 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36dae4ef0cd75cfeb8ecebf9eba9a9a61d11f34e" translate="yes" xml:space="preserve">
          <source>Using the Java 8 &lt;strong&gt;Stream API parallel&lt;/strong&gt;</source>
          <target state="translated">Java 8 &lt;strong&gt;Stream API 병렬 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5caf9ed2a72d6f4ecbca766fb5691949d6216417" translate="yes" xml:space="preserve">
          <source>Using the Java 8 &lt;strong&gt;Stream API&lt;/strong&gt;</source>
          <target state="translated">Java 8 &lt;strong&gt;스트림 API 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eafcfcc9f356a37cd9ee651b3aa678c42fcbcb9e" translate="yes" xml:space="preserve">
          <source>We have got &lt;code&gt;forEach&lt;/code&gt; method that accepts a &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;lambda expression&lt;/a&gt;. We have also got &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;stream&lt;/a&gt; APIs. Consider a map:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;람다 식&lt;/a&gt; 을 받아들이는 &lt;code&gt;forEach&lt;/code&gt; 메서드가 있습니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;스트림&lt;/a&gt; API도 있습니다. 지도를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d798e0a7eca0befff8709b5ebe731b0fa73ec725" translate="yes" xml:space="preserve">
          <source>Will the ordering of elements depend on the specific map implementation that I have for the interface?</source>
          <target state="translated">요소의 순서는 인터페이스에 대한 특정 맵 구현에 따라 달라 집니까?</target>
        </trans-unit>
        <trans-unit id="017762b012dd7225113538796ddba61ae61e2c5a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/eclipse/eclipse-collections&quot;&gt;Eclipse Collections&lt;/a&gt; (formerly &lt;a href=&quot;https://github.com/goldmansachs/gs-collections&quot;&gt;GS Collections&lt;/a&gt;), you would use the forEachKeyValue method on the &lt;a href=&quot;https://github.com/eclipse/eclipse-collections/blob/master/eclipse-collections-api/src/main/java/org/eclipse/collections/api/map/MapIterable.java&quot;&gt;MapIterable&lt;/a&gt; interface, which is inherited by the MutableMap and ImmutableMap interfaces and their implementations.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/eclipse/eclipse-collections&quot;&gt;Eclipse Collections&lt;/a&gt; (이전의 &lt;a href=&quot;https://github.com/goldmansachs/gs-collections&quot;&gt;GS Collections&lt;/a&gt; )를 사용하면 MuItMap 및 ImmutableMap 인터페이스 및 해당 구현에서 상속되는 &lt;a href=&quot;https://github.com/eclipse/eclipse-collections/blob/master/eclipse-collections-api/src/main/java/org/eclipse/collections/api/map/MapIterable.java&quot;&gt;MapIterable&lt;/a&gt; 인터페이스에서 forEachKeyValue 메소드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="306de5f65025cadf9565e4afbdf42027db4cb2dc" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;Java 8&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자바 8&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4699cd9129494ddc388093886dfdad742d8561b2" translate="yes" xml:space="preserve">
          <source>With Java 8 lambda syntax, you can write the code as follows:</source>
          <target state="translated">Java 8 람다 구문을 사용하면 다음과 같이 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84aef87a2bc298b8e63f4075a8e2f44a93fdcfb" translate="yes" xml:space="preserve">
          <source>Yes, absolutely.</source>
          <target state="translated">네 그럼요.</target>
        </trans-unit>
        <trans-unit id="cae53b76e40d2202c18f68f4690b03274ac40cb7" translate="yes" xml:space="preserve">
          <source>Yes, the order depends on the specific Map implementation.</source>
          <target state="translated">예, 순서는 특정지도 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="daf91a238253e2d658f686a2323d495a7c1aa9a8" translate="yes" xml:space="preserve">
          <source>You can do it using generics:</source>
          <target state="translated">제네릭을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8f6998bce11971227c73926226c4fc1e993e492" translate="yes" xml:space="preserve">
          <source>You can see there are &lt;strong&gt;four &lt;code&gt;Map&lt;/code&gt; implementations maintaining an order&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;순서를 유지하는 네 가지 &lt;code&gt;Map&lt;/code&gt; 구현&lt;/strong&gt; 이 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cbe0c6bd90ebdac70a867735970ee3858618266" translate="yes" xml:space="preserve">
          <source>You can use lambda expressions:</source>
          <target state="translated">람다 식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd68512ae08ef0e4cfbba091825597ceb90fe6f4" translate="yes" xml:space="preserve">
          <source>[edit] I wrote &lt;code&gt;valueSet()&lt;/code&gt; originally but of course &lt;code&gt;entrySet()&lt;/code&gt; is actually the answer.</source>
          <target state="translated">[edit] 원래 &lt;code&gt;valueSet()&lt;/code&gt; 작성했지만 물론 &lt;code&gt;entrySet()&lt;/code&gt; 이 실제로 답입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
