<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/4660142">
    <body>
      <group id="4660142">
        <trans-unit id="9396f5058c8dfed94f5b53595720fed9df43bfa6" translate="yes" xml:space="preserve">
          <source>&quot;Button2&quot; resides on a &lt;code&gt;Panel&lt;/code&gt;</source>
          <target state="translated">&amp;laquo;Button2&amp;raquo; находится на &lt;code&gt;Panel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db5a5b1d9a6c5f4c860c37395021bbd5362fafa2" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;&lt;strong&gt;&lt;em&gt;NullReferenceException&lt;/em&gt;&lt;/strong&gt;&amp;rsquo; also occurs when we forget to instantiate a reference type.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;NullReferenceException&lt;/em&gt;&lt;/strong&gt; также возникает, когда мы забываем создать экземпляр ссылочного типа.</target>
        </trans-unit>
        <trans-unit id="dcee1b5e3a8c625c5a9735ca8c8ec5d25be46495" translate="yes" xml:space="preserve">
          <source>(Another reason for non-using unsafe code unless you need it, by the way)</source>
          <target state="translated">(Кстати,еще одна причина неиспользования опасного кода,если он вам не нужен).</target>
        </trans-unit>
        <trans-unit id="673f15918a55d1f2ddf729938db9ca922559f3ca" translate="yes" xml:space="preserve">
          <source>.NET collections (of which there are many varieties - Lists, Dictionary, etc.) must also be instantiated or created.</source>
          <target state="translated">NET-коллекции (из которых существует множество разновидностей-Списки,Словарь и т.д.)также должны быть инстанциированы или созданы.</target>
        </trans-unit>
        <trans-unit id="c04d4ae82bc72a4bd980abe754c0c8da8a6d3e11" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/11244949/5407188&quot;&gt;Simon Mourier gave this example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/11244949/5407188&quot;&gt;Саймон Мурье привел этот пример&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="96e9ca8abbe2f8b39135700b77c31732f2dac12b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AndAlso&lt;/code&gt; is important. Subsequent tests will not be performed once the first &lt;code&gt;False&lt;/code&gt; condition is encountered. This allows the code to safely 'drill' into the object(s) one 'level' at a time, evaluating &lt;code&gt;myFoo.Bar&lt;/code&gt; only after (and if) &lt;code&gt;myFoo&lt;/code&gt; is determined to be valid. Object chains or paths can get quite long when coding complex objects:</source>
          <target state="translated">&lt;code&gt;AndAlso&lt;/code&gt; важно. Последующие тесты не будут выполняться после того, как будет &lt;code&gt;False&lt;/code&gt; первое ложное условие. Это позволяет коду безопасно &amp;laquo;углубляться&amp;raquo; в объект (ы) по одному &amp;laquo;уровню&amp;raquo; за раз, оценивая &lt;code&gt;myFoo.Bar&lt;/code&gt; только после того, как (и если) &lt;code&gt;myFoo&lt;/code&gt; определено как допустимое. Цепочки объектов или пути могут быть довольно длинными при кодировании сложных объектов:</target>
        </trans-unit>
        <trans-unit id="aa6c4cd32e971c86b94f356d10264f19fc10c956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C#&lt;/code&gt; has an &quot;unsafe&quot; mode which is, as the name implies, extremely dangerous because the normal safety mechanisms which provide memory safety and type safety are not enforced. &lt;strong&gt;You should not be writing unsafe code unless you have a thorough and deep understanding of how memory works&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;C#&lt;/code&gt; имеет &amp;laquo;небезопасный&amp;raquo; режим, который, как следует из названия, чрезвычайно опасен, поскольку обычные механизмы безопасности, которые обеспечивают безопасность памяти и безопасность типов, не применяются. &lt;strong&gt;Вы не должны писать небезопасный код, если у вас нет глубокого и глубокого понимания того, как работает память&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7bd3d214087af937aaa899e455d518fc953c1f01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C#&lt;/code&gt; supports &quot;iterator blocks&quot; (called &quot;generators&quot; in some other popular languages).  Null dereference exceptions can be particularly tricky to debug in iterator blocks because of deferred execution:</source>
          <target state="translated">&lt;code&gt;C#&lt;/code&gt; поддерживает &amp;laquo;блоки итераторов&amp;raquo; (называемые &amp;laquo;генераторами&amp;raquo; в некоторых других популярных языках). Исключения нулевого разыменования могут быть особенно сложны для отладки в блоках итератора из-за отложенного выполнения:</target>
        </trans-unit>
        <trans-unit id="b65a828172fbdbfca98814450da810920765da6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fill&lt;/code&gt; is a function returning the number of &lt;code&gt;Rows&lt;/code&gt; affected which can also be tested:</source>
          <target state="translated">&lt;code&gt;Fill&lt;/code&gt; - это функция, возвращающая количество затронутых &lt;code&gt;Rows&lt;/code&gt; которая также может быть проверена:</target>
        </trans-unit>
        <trans-unit id="29fd8c9bf04ffae44443b4d6b120d8e689bf6af6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FirstOrDefault&lt;/code&gt; returns the first item or the default value, which is &lt;code&gt;Nothing&lt;/code&gt; for reference types and never &lt;code&gt;DBNull&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;FirstOrDefault&lt;/code&gt; возвращает первый элемент или значение по умолчанию, которое является &lt;code&gt;Nothing&lt;/code&gt; для ссылочных типов и никогда не &lt;code&gt;DBNull&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dc1f250a72423388fb398e4efb0f2038c0f0e84a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; is implicitly cast to and from &lt;code&gt;T&lt;/code&gt; so you can use it just about anywhere you need it. For example, you can pass a &lt;code&gt;Person&lt;/code&gt; object to a method that takes a &lt;code&gt;NotNull&amp;lt;Person&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; неявно преобразуется в T и из &lt;code&gt;T&lt;/code&gt; , так что вы можете использовать его где угодно. Например, вы можете передать объект &lt;code&gt;Person&lt;/code&gt; в метод, который принимает &lt;code&gt;NotNull&amp;lt;Person&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="65aa590b67401c4fef80a64a246bc794d6e41210" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WPF&lt;/code&gt; controls are created during the call to &lt;code&gt;InitializeComponent&lt;/code&gt; in the order they appear in the visual tree.  A &lt;code&gt;NullReferenceException&lt;/code&gt; will be raised in the case of early-created controls with event handlers, etc. , that fire during &lt;code&gt;InitializeComponent&lt;/code&gt; which reference late-created controls.</source>
          <target state="translated">Элементы управления &lt;code&gt;WPF&lt;/code&gt; создаются во время вызова &lt;code&gt;InitializeComponent&lt;/code&gt; в порядке их появления в визуальном дереве. В случае ранее созданных элементов управления с обработчиками событий и т. &lt;code&gt;NullReferenceException&lt;/code&gt; Будет сгенерировано исключение NullReferenceException , которое срабатывает во время &lt;code&gt;InitializeComponent&lt;/code&gt; , ссылающегося на последние созданные элементы управления.</target>
        </trans-unit>
        <trans-unit id="250ae2f1196236ab82456278c60d302569df1d86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; throws when you try to iterate null collection. Usually caused by unexpected &lt;code&gt;null&lt;/code&gt; result from methods that return collections.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; бросает, когда вы пытаетесь повторить нулевую коллекцию. Обычно вызвано неожиданным &lt;code&gt;null&lt;/code&gt; результатом от методов, которые возвращают коллекции.</target>
        </trans-unit>
        <trans-unit id="e6b825efa75e489e263e621391b24d1af984c6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; can have different meanings:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; может иметь разные значения:</target>
        </trans-unit>
        <trans-unit id="a96f0fc9fadca9ec24ec9a32f5951496d8252794" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;ldquo;Hey wait, that member has no values so it can&amp;rsquo;t perform the task which you are handing it over.&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;laquo;Эй, подождите, у этого члена нет значений, поэтому он не может выполнить задачу, которую вы передаете&amp;raquo;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de7fbf64ea77b998421c892cac8cea0e19d55573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The arrays and collections cannot be initialized this way.&lt;/em&gt; This initialization code will run &lt;em&gt;before&lt;/em&gt; the constructor creates the &lt;code&gt;Form&lt;/code&gt; or the &lt;code&gt;Controls&lt;/code&gt;. As a result:</source>
          <target state="translated">&lt;em&gt;Массивы и коллекции не могут быть инициализированы таким образом.&lt;/em&gt; Этот код инициализации будет запущен &lt;em&gt;до&lt;/em&gt; того, как конструктор создаст &lt;code&gt;Form&lt;/code&gt; или &lt;code&gt;Controls&lt;/code&gt; . Как результат:</target>
        </trans-unit>
        <trans-unit id="c46586bc5c89bdef6d4b1e03c01b4dd0ec5d4806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Built-in like Nullable?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Встроенный как Nullable?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75800f606b4d1c6ba12f783ca4570bf7ff6448ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Проверьте аргументы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c09c6f450bd3f06e6cd9a53cf34fa6d2204595f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Combine with Extension&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Объединить с расширением&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c53baf9a2776f02becbdc77ff91727f9331686" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9982a3d97a9090ed22f6a37e2cf0f2ae71f563db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7846c489294df2d5060a36081cb8e8043018b8e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="850a808c9ba0be28dfd19e88b1b1677f0e685ba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example: Array of class objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример: массив объектов класса&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0832c4cbf43ec158d395216191b77095c211750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Missing the &lt;code&gt;New&lt;/code&gt; operator is the #1 cause of &lt;code&gt;NullReference Exceptions&lt;/code&gt;&lt;/strong&gt; seen in the Stack&amp;nbsp; Overflow questions reviewed.</source>
          <target state="translated">&lt;strong&gt;Отсутствие оператора &lt;code&gt;New&lt;/code&gt; является # 1 причиной &lt;code&gt;NullReference Exceptions&lt;/code&gt; &lt;/strong&gt; замеченных в рассмотренных вопросах переполнения стека.</target>
        </trans-unit>
        <trans-unit id="65dcf051b0f8d4d6b70a92dd10d98dbbb05e7cdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d3ff5e8673cda37c5affb24969d0778d496d93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that accessing it via &lt;code&gt;a.Value&lt;/code&gt; throws an &lt;code&gt;InvalidOperationException&lt;/code&gt; instead of a &lt;code&gt;NullReferenceException&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; - you should do the check beforehand, i.e. if you have another on-nullable variable &lt;code&gt;int b;&lt;/code&gt; then you should do assignments like &lt;code&gt;if (a.HasValue) { b = a.Value; }&lt;/code&gt; or shorter &lt;code&gt;if (a != null) { b = a; }&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Обратите внимание,&lt;/strong&gt; что доступ к нему через &lt;code&gt;a.Value&lt;/code&gt; вызывает &lt;code&gt;InvalidOperationException&lt;/code&gt; вместо &lt;code&gt;NullReferenceException&lt;/code&gt; , если &lt;code&gt;a&lt;/code&gt; равно &lt;code&gt;null&lt;/code&gt; - вы должны выполнить проверку заранее, т. Е. Если у вас есть другая переменная on-nullable &lt;code&gt;int b;&lt;/code&gt; тогда вы должны делать назначения вроде &lt;code&gt;if (a.HasValue) { b = a.Value; }&lt;/code&gt; } или короче, &lt;code&gt;if (a != null) { b = a; }&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="9d2ecfee61125d9d0e8d312294babd37f799e11c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; this applies to any and all control and component references making these illegal where they are:</source>
          <target state="translated">&lt;strong&gt;Обратите внимание, что&lt;/strong&gt; это относится ко всем без исключения ссылкам на элементы управления и компонентов, что делает их недопустимыми, если они:</target>
        </trans-unit>
        <trans-unit id="fa53a7cd617380a4fd41905587ebe1ed03bfd709" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Partial Remedy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Частичное Средство&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b45cb9af41d027f3c66db6de15f935162538c51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plain Code Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Решение с простым кодом&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c266b17f2c6ab7e2c85ed00ba5d7beabc25b959e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reason&lt;/strong&gt;
I am still not sure about the reason. But whenever any of the entity class will extend System.Web.UI.Page this error occurs.</source>
          <target state="translated">&lt;strong&gt;Причина,&lt;/strong&gt; я все еще не уверен в причине. Но всякий раз, когда какой-либо из классов сущностей расширяет System.Web.UI.Page, эта ошибка возникает.</target>
        </trans-unit>
        <trans-unit id="a268ab5a5be194c793236306a7663da71dfa4d72" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference types (these ones must be checked):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Типы ссылок (эти должны быть проверены):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87d7c3eb34164ea52ebb8bc8dd28ee4033a68905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Related Language Feature&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Родственный язык&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f132283beed6a6da06cca0d2093c020e2034387" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remedy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Remedy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00798c0e0efa455834c71c3500c45ed823e69637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR:&lt;/strong&gt; Try using &lt;code&gt;Html.Partial&lt;/code&gt; instead of &lt;code&gt;Renderpage&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;TL; DR:&lt;/strong&gt; попробуйте использовать &lt;code&gt;Html.Partial&lt;/code&gt; вместо &lt;code&gt;Renderpage&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb06fe911bd525f50ffb0ed996518a64e1313f34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is basically is a Null reference exception&lt;/strong&gt;. As &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;Microsoft&lt;/a&gt; states-</source>
          <target state="translated">&lt;strong&gt;Это в основном является нулевым ссылочным исключением&lt;/strong&gt; . Как заявляет &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;Microsoft,&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1aa4d335741197b3563f86a40f2c97a83f320da3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; It is worth mentioning that the term was coined by Bertrand Meyer &lt;a href=&quot;https://www.eiffel.com/values/design-by-contract/&quot;&gt;in connection with his design of the Eiffel programming language&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;ОБНОВЛЕНИЕ:&lt;/strong&gt; Стоит отметить, что этот термин был придуман Бертраном Мейером &lt;a href=&quot;https://www.eiffel.com/values/design-by-contract/&quot;&gt;в связи с его разработкой языка программирования Eiffel&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0181926e0a4573b951577d60df9ca7c39553610c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update C#8.0, 2019: Nullable reference types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обновление C # 8.0, 2019: Обнуляемые ссылочные типы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72b28d75192ac7fb08e2f8d3a79cec1a52ea9e34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Tools&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Используйте инструменты&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c87f2201b452dcaacc0b8af07815a06349212165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value types (you can simply ignore these ones):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Типы значений (вы можете просто игнорировать эти):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6d4f708a4dc9fe6716ce23566f161236c78feea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What can you do about it?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что вы можете сделать по этому поводу?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8caed790388a2aa0b4f38d928f3144b76a25e1b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;  If Break on Throws is too aggressive and the debugger stops on an NPE in the .NET or 3rd-party library, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/038tzxdw.aspx&quot;&gt;Break on User-Unhandled&lt;/a&gt; can be used to limit the exceptions caught. Additionally, VS2012 introduces &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn457346.aspx&quot;&gt;Just My Code&lt;/a&gt; which I recommend enabling as well.</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; Если Break on Throws слишком агрессивен и отладчик останавливается на NPE в .NET или сторонней библиотеке, можно использовать &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/038tzxdw.aspx&quot;&gt;Break on User-Unhandled&lt;/a&gt; для ограничения перехвата исключений. Кроме того, VS2012 представляет &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn457346.aspx&quot;&gt;Just My Code,&lt;/a&gt; который я также рекомендую включить.</target>
        </trans-unit>
        <trans-unit id="cf4e02ba110e4be0ec3bfb627b852463f12d2845" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MsgBox&lt;/code&gt; in the Catch which displays &lt;code&gt;Error while...&lt;/code&gt; will be of little help. This method also leads to &lt;em&gt;very bad&lt;/em&gt; Stack&amp;nbsp; Overflow questions, because you can't describe the actual exception, the object involved or even the line of code where it happens.</source>
          <target state="translated">&lt;code&gt;MsgBox&lt;/code&gt; в Catch, который отображает &lt;code&gt;Error while...&lt;/code&gt; будет мало помочь. Этот метод также приводит к &lt;em&gt;очень плохим&lt;/em&gt; вопросам переполнения стека, потому что вы не можете описать фактическое исключение, задействованный объект или даже строку кода, где это происходит.</target>
        </trans-unit>
        <trans-unit id="ba104c53b06fc122661823449802aea76782c8e0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NullReferenceException&lt;/code&gt; is thrown when we are trying to access Properties of a null object or when a string value becomes empty and we are trying to access string methods.</source>
          <target state="translated">&lt;code&gt;NullReferenceException&lt;/code&gt; генерируется, когда мы пытаемся получить доступ к свойствам нулевого объекта или когда строковое значение становится пустым, и мы пытаемся получить доступ к строковым методам.</target>
        </trans-unit>
        <trans-unit id="aa5b3e9455e644e78a417418f58466e0a5a103cd" translate="yes" xml:space="preserve">
          <source>A NullReferenceException exception is thrown when you try to access a
  member of a type whose value is null.</source>
          <target state="translated">Исключение NullReferenceException бросается,когда вы пытаетесь получить доступ к члену типа,значение которого равно нулю.</target>
        </trans-unit>
        <trans-unit id="f8ff26f3ebffad79c215bd07bdac08f78eb5f7da" translate="yes" xml:space="preserve">
          <source>A badly implemented Try/Catch can hide where the problem is and result in new ones:</source>
          <target state="translated">Плохо реализованный TryCatch может скрыть,где проблема,и привести к появлению новых:</target>
        </trans-unit>
        <trans-unit id="6d4ec18cde40fd73c38c9b684b0330cd485bb285" translate="yes" xml:space="preserve">
          <source>A common oversight is a class which uses a collection &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">Обычный недосмотр - это класс, который использует коллекцию &lt;code&gt;Type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d9cf0a18f606a29539af3e0ce3af33a36d691ebb" translate="yes" xml:space="preserve">
          <source>A more &quot;formal&quot; way of preventing such error conditions &lt;em&gt;while developing&lt;/em&gt; is applying &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;design by contract&lt;/a&gt;&lt;/em&gt; in your code. This means you need to set class &lt;em&gt;invariants&lt;/em&gt;, and/or even function/method &lt;em&gt;preconditions&lt;/em&gt; and &lt;em&gt;postconditions&lt;/em&gt; on your system, while developing.</source>
          <target state="translated">Более &amp;laquo;формальным&amp;raquo; способом предотвращения возникновения таких ошибок &lt;em&gt;при разработке&lt;/em&gt; является применение &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;проекта по контракту&lt;/a&gt;&lt;/em&gt; в вашем коде. Это означает, что вам нужно установить &lt;em&gt;инварианты&lt;/em&gt; класса и / или даже &lt;em&gt;предварительные условия&lt;/em&gt; и &lt;em&gt;постфункции&lt;/em&gt; в вашей системе при разработке.</target>
        </trans-unit>
        <trans-unit id="eebbb33808aa207e49bada59a5125167df24f614" translate="yes" xml:space="preserve">
          <source>A note on null dereferences in unsafe code</source>
          <target state="translated">Записка о нулевых разыменованиях в небезопасном коде</target>
        </trans-unit>
        <trans-unit id="8dafbafccce845b67afeb7b01438fe1945ef8d44" translate="yes" xml:space="preserve">
          <source>A nullable reference type is noted using the same syntax as nullable value types: a &lt;code&gt;?&lt;/code&gt; is appended to the type of the variable.</source>
          <target state="translated">Обнуляемый ссылочный тип отмечается с использованием того же синтаксиса, что и типы значений, допускающие значение NULL: a &lt;code&gt;?&lt;/code&gt; добавляется к типу переменной.</target>
        </trans-unit>
        <trans-unit id="6c02c614bce01e1bf2b2913bce9723ce07012a79" translate="yes" xml:space="preserve">
          <source>A typo is a problem here: &lt;code&gt;Employees&lt;/code&gt; vs &lt;code&gt;Employee&lt;/code&gt;. There was no &lt;code&gt;DataTable&lt;/code&gt; named &quot;Employee&quot; created, so a &lt;code&gt;NullReferenceException&lt;/code&gt; results trying to access it. Another potential problem is assuming there will be &lt;code&gt;Items&lt;/code&gt; which may not be so when the SQL includes a WHERE clause.</source>
          <target state="translated">Опечатка - проблема здесь: &lt;code&gt;Employees&lt;/code&gt; против &lt;code&gt;Employee&lt;/code&gt; . Не было создано &lt;code&gt;DataTable&lt;/code&gt; с именем &amp;laquo;Employee&amp;raquo;, поэтому при попытке доступа к нему возникает &lt;code&gt;NullReferenceException&lt;/code&gt; . Другая потенциальная проблема заключается в предположении, что будут &lt;code&gt;Items&lt;/code&gt; которых может не быть, если в SQL есть предложение WHERE.</target>
        </trans-unit>
        <trans-unit id="f6a5c83300e66ad46127b977adb89a522156c686" translate="yes" xml:space="preserve">
          <source>ASP.NET MVC empty view models</source>
          <target state="translated">ASP.NET MVC пустые модели просмотра</target>
        </trans-unit>
        <trans-unit id="80c38c96a03773866e5a09fd7dd429a0be9d8b8b" translate="yes" xml:space="preserve">
          <source>ASP.NET Page Life cycle:</source>
          <target state="translated">ASP.NET Page Жизненный цикл:</target>
        </trans-unit>
        <trans-unit id="3f5c6dc0c3d2cadb4509844c76624cbfb304e229" translate="yes" xml:space="preserve">
          <source>ASP.NET Session Values</source>
          <target state="translated">Сессия ASP.NET Ценности</target>
        </trans-unit>
        <trans-unit id="940be3748f3da7281fcd8700b0e3178729d37f82" translate="yes" xml:space="preserve">
          <source>Access Levels in Visual Basic</source>
          <target state="translated">Уровни доступа в Visual Basic</target>
        </trans-unit>
        <trans-unit id="b85c4bdae0c350f5711f14487cc734ddd712d0bb" translate="yes" xml:space="preserve">
          <source>Add a RigidBody to your object with AddComponent &amp;gt; Physics &amp;gt; Rigidbody</source>
          <target state="translated">Добавьте RigidBody к вашему объекту с помощью AddComponent&amp;gt; Физика&amp;gt; Rigidbody</target>
        </trans-unit>
        <trans-unit id="3c06a5e5b3bffeb1ffe32764c5df1d75e8641b16" translate="yes" xml:space="preserve">
          <source>Adding a case when the class name for entity used in entity framework is same as class name for a web form code-behind file.</source>
          <target state="translated">Добавление случая,когда имя класса для сущности,используемого в фреймворке сущностей,совпадает с именем класса для файла веб-формы,находящегося за кодом.</target>
        </trans-unit>
        <trans-unit id="64da57dde1ffb2a7b141dfc69a64073197586ac7" translate="yes" xml:space="preserve">
          <source>Alternatively, design by contract can be applied using &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Assertion_%28software_development%29&quot;&gt;assertions&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">В качестве альтернативы, дизайн по контракту может быть применен с использованием &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Assertion_%28software_development%29&quot;&gt;утверждений&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b7effb34e016a409606b0e15fd08ec8c4497e3b4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;(ComboBox5.SelectedItem IsNot Nothing) AndAlso...&lt;/code&gt;</source>
          <target state="translated">Кроме того, вы можете использовать &lt;code&gt;(ComboBox5.SelectedItem IsNot Nothing) AndAlso...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5666d3ec19bdd1846f3f244409d303ff8154592b" translate="yes" xml:space="preserve">
          <source>Although I have a feeling it was because Visual Studio was misreading the ampersands and brackets.</source>
          <target state="translated">Хотя у меня такое чувство,что это произошло из-за того,что Visual Studio неправильно прочитала амперсанды и скобки.</target>
        </trans-unit>
        <trans-unit id="9fd253c7dc5c61cba35ce66730957de70d270eee" translate="yes" xml:space="preserve">
          <source>Always initialize your objects before you try to do anything with them.</source>
          <target state="translated">Всегда инициализируйте свои объекты перед тем,как пытаться что-либо с ними сделать.</target>
        </trans-unit>
        <trans-unit id="3b6e8a6740e24bceb43df548fef899179aae1d8a" translate="yes" xml:space="preserve">
          <source>Among other things, this code does not anticipate that the user may not have selected something in one or more UI controls.  &lt;code&gt;ListBox1.SelectedItem&lt;/code&gt; may well be &lt;code&gt;Nothing&lt;/code&gt;, so &lt;code&gt;ListBox1.SelectedItem.ToString&lt;/code&gt; will result in an NRE.</source>
          <target state="translated">Помимо прочего, этот код не предполагает, что пользователь, возможно, не выбрал что-то в одном или нескольких элементах управления пользовательского интерфейса. &lt;code&gt;ListBox1.SelectedItem&lt;/code&gt; вполне может быть &lt;code&gt;Nothing&lt;/code&gt; , поэтому &lt;code&gt;ListBox1.SelectedItem.ToString&lt;/code&gt; приведет к NRE.</target>
        </trans-unit>
        <trans-unit id="88a4f159e8121bbcda704144caf67fd92f8461ea" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;Catch&lt;/code&gt; block is the devil's playground. This OP was baffled why he was getting an NRE in the &lt;code&gt;Finally&lt;/code&gt; block. In other situations, an empty &lt;code&gt;Catch&lt;/code&gt; may result in something else much further downstream going haywire and cause you to spend time looking at the wrong things in the wrong place for the problem. (The &quot;silent exception&quot; described above provides the same entertainment value.)</source>
          <target state="translated">Пустой блок &lt;code&gt;Catch&lt;/code&gt; - игровая площадка дьявола. Этот ОП был сбит с толку, почему он получил NRE в блоке &amp;laquo; &lt;code&gt;Finally&lt;/code&gt; . В других ситуациях пустой &lt;code&gt;Catch&lt;/code&gt; может привести к тому, что что-то гораздо более низкое по течению станет бесполезным, и вы потратите время на поиск неправильных вещей в неподходящем месте для решения проблемы. (Описанное выше &amp;laquo;тихое исключение&amp;raquo; обеспечивает ту же развлекательную ценность.)</target>
        </trans-unit>
        <trans-unit id="9157a41acb7ec9a4b1beccee4b4d84c91c8fa2d2" translate="yes" xml:space="preserve">
          <source>An example of this exception being thrown is: When you are trying to check something, that is null.</source>
          <target state="translated">Пример такого исключения:когда вы пытаетесь что-то проверить,это ноль.</target>
        </trans-unit>
        <trans-unit id="a1ec28efc8675e603132b97526fc40e135d46f85" translate="yes" xml:space="preserve">
          <source>And here is an example of how it could be used:</source>
          <target state="translated">И вот пример того,как его можно использовать:</target>
        </trans-unit>
        <trans-unit id="e727d2eac2d0a071ac7dcfe039aef6ace695286e" translate="yes" xml:space="preserve">
          <source>And it worked.</source>
          <target state="translated">И это сработало.</target>
        </trans-unit>
        <trans-unit id="324e44de5ebb6296d39aa1bfc28925673b0c6b21" translate="yes" xml:space="preserve">
          <source>Another case where &lt;code&gt;NullReferenceExceptions&lt;/code&gt; can happen is the (incorrect) use of the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/as&quot;&gt;&lt;code&gt;as&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">Другой случай, когда могут возникать &lt;code&gt;NullReferenceExceptions&lt;/code&gt; , - это (неправильное) использование &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/as&quot;&gt;оператора &lt;code&gt;as&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="faf985078920eb0c5453270c90bdc97bdefa6713" translate="yes" xml:space="preserve">
          <source>Another general case where one might receive this exception involves mocking classes during unit testing. Regardless of the mocking framework being used, you must ensure that all appropriate levels of the class hierarchy are properly mocked. In particular, all properties of &lt;code&gt;HttpContext&lt;/code&gt; which are referenced by the code under test must be mocked.</source>
          <target state="translated">Другой общий случай, когда можно получить это исключение, связан с классами насмешек во время модульного тестирования. Независимо от используемой среды моделирования, вы должны убедиться, что все соответствующие уровни иерархии классов должным образом смоделированы. В частности, все свойства &lt;code&gt;HttpContext&lt;/code&gt; ,на которые ссылается тестируемый код, должны быть проверены.</target>
        </trans-unit>
        <trans-unit id="defecdb8e8875605297d57b7667ccb8e2cd0b5be" translate="yes" xml:space="preserve">
          <source>Another scenario is when you cast a null object into a &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;value type&lt;/a&gt;. For example, the code below:</source>
          <target state="translated">Другой сценарий - когда вы приводите нулевой объект в &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;тип значения&lt;/a&gt; . Например, код ниже:</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="66865b7becb2eab1937b4ac3fd0252b0e3a5b1a9" translate="yes" xml:space="preserve">
          <source>Array Elements</source>
          <target state="translated">Элементы массива</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="b6fa4a287953008cbde69102b90389d57d42adc5" translate="yes" xml:space="preserve">
          <source>Arrays in Visual Basic</source>
          <target state="translated">Массивы в Visual Basic</target>
        </trans-unit>
        <trans-unit id="d1699665973226819efc1a3192672777466c31f6" translate="yes" xml:space="preserve">
          <source>Arrays must also be instantiated:</source>
          <target state="translated">Массивы также должны быть инстанциированы:</target>
        </trans-unit>
        <trans-unit id="38bc53bbadc56c1c1c3af2a66bca49127ec6ded9" translate="yes" xml:space="preserve">
          <source>As before, the &lt;code&gt;ds&lt;/code&gt; Dataset object was declared, but an instance was never created. The &lt;code&gt;DataAdapter&lt;/code&gt; will fill an existing &lt;code&gt;DataSet&lt;/code&gt;, not create one. In this case, since &lt;code&gt;ds&lt;/code&gt; is a local variable, &lt;em&gt;the IDE warns you&lt;/em&gt; that this might happen:</source>
          <target state="translated">Как и прежде, объект &lt;code&gt;ds&lt;/code&gt; Dataset был объявлен, но экземпляр не был создан. &lt;code&gt;DataAdapter&lt;/code&gt; заполнит существующий &lt;code&gt;DataSet&lt;/code&gt; , а не создаст его. В этом случае, поскольку &lt;code&gt;ds&lt;/code&gt; является локальной переменной, &lt;em&gt;IDE предупреждает вас о&lt;/em&gt; том, что это может произойти:</target>
        </trans-unit>
        <trans-unit id="a8225bf15fe959f426e87bc59fb66f54584b8477" translate="yes" xml:space="preserve">
          <source>As before, this is incorrect:</source>
          <target state="translated">Как и прежде,это неправильно:</target>
        </trans-unit>
        <trans-unit id="34d0293b6d44a69f8098139a2697ae8c8c463b8c" translate="yes" xml:space="preserve">
          <source>As before, you can test for Nothing, then for a specific value:</source>
          <target state="translated">Как и раньше,вы можете протестировать на &quot;Ничего&quot;,а затем на конкретную величину:</target>
        </trans-unit>
        <trans-unit id="8c8719c108394130c727bec7ba9f10b86c8bcb74" translate="yes" xml:space="preserve">
          <source>As seen in the above code, the statement 
&lt;strong&gt;Student s&lt;/strong&gt; - only declares the variable of type Student, note that the Student class is not instantiated at this point.
Hence, when the statement &lt;strong&gt;s.GetFullName()&lt;/strong&gt; gets executed, it will throw the NullReferenceException.</source>
          <target state="translated">Как видно из приведенного выше кода, оператор &lt;strong&gt;Student s&lt;/strong&gt; - только объявляет переменную типа Student, обратите внимание, что на этом этапе класс Student не создается. Следовательно, когда выполняется оператор &lt;strong&gt;s.GetFullName ()&lt;/strong&gt; , он генерирует исключение NullReferenceException.</target>
        </trans-unit>
        <trans-unit id="0238c2f1a73f80203ea54ce74e1fa5c52ec85a2b" translate="yes" xml:space="preserve">
          <source>As you can see above as with nullable you would access the underlying value through the &lt;code&gt;Value&lt;/code&gt; property. Alternatively, you can use an explicit or implicit cast, you can see an example with the return value below:</source>
          <target state="translated">Как вы можете видеть выше, как и для nullable, вы получите доступ к базовому значению через свойство &lt;code&gt;Value&lt;/code&gt; . Кроме того, вы можете использовать явное или неявное приведение, вы можете увидеть пример с возвращаемым значением ниже:</target>
        </trans-unit>
        <trans-unit id="55898edce8a3dc771bf65a61dd6c66bcff4e10b3" translate="yes" xml:space="preserve">
          <source>Assume that you have a class named Student.</source>
          <target state="translated">Предположим,у вас есть класс по имени Студент.</target>
        </trans-unit>
        <trans-unit id="be34f295e410696ad2a87bdbe307bddd6ac8d2e7" translate="yes" xml:space="preserve">
          <source>Basic Meaning</source>
          <target state="translated">Основной смысл</target>
        </trans-unit>
        <trans-unit id="f2896aad58b9a8eecc0ba25ee5c59866bcde93ab" translate="yes" xml:space="preserve">
          <source>Be aware that regardless of the scenario, the cause is always the same in .NET:</source>
          <target state="translated">Имейте в виду,что независимо от сценария,причина всегда одна и та же в .NET:</target>
        </trans-unit>
        <trans-unit id="4b8773ed0bc20f439c181fd5242b7f12bd9a63f5" translate="yes" xml:space="preserve">
          <source>Both a null pointer and a null reference in &lt;code&gt;C#&lt;/code&gt; are internally represented as the number zero, and so any attempt to dereference it into its corresponding memory storage causes the operating system to produce an error. The .NET runtime then detects this error and turns it into the null dereference exception.</source>
          <target state="translated">И нулевой указатель, и нулевая ссылка в &lt;code&gt;C#&lt;/code&gt; внутренне представлены как нулевое число, и поэтому любая попытка разыменовать его в соответствующее хранилище памяти приводит к ошибке операционной системы. Затем среда выполнения .NET обнаруживает эту ошибку и превращает ее в исключение нулевой разыменования.</target>
        </trans-unit>
        <trans-unit id="80ab619b17d9355ace0bbedb905733aed5398463" translate="yes" xml:space="preserve">
          <source>Bottom Line</source>
          <target state="translated">Итог</target>
        </trans-unit>
        <trans-unit id="21a8752f2df54d656b09cd2a499cb3a3403ec7ca" translate="yes" xml:space="preserve">
          <source>Breakpoints</source>
          <target state="translated">Breakpoints</target>
        </trans-unit>
        <trans-unit id="86d14f9a7de18ff1120d5c17aa3bb8490cf58228" translate="yes" xml:space="preserve">
          <source>But I was able to run the application with no problems with this &quot;error&quot;. I was able to get rid of the error by changing the structure of the &lt;code&gt;foreach&lt;/code&gt; loop to look like this:</source>
          <target state="translated">Но я смог запустить приложение без проблем с этой &amp;laquo;ошибкой&amp;raquo;. Мне удалось избавиться от ошибки, изменив структуру цикла &lt;code&gt;foreach&lt;/code&gt; так:</target>
        </trans-unit>
        <trans-unit id="342f568362575e92cb6067d8461a39a6a40941c4" translate="yes" xml:space="preserve">
          <source>But if you set &quot;property X must never have a null value&quot; as method precondition, then you can prevent the scenario described before:</source>
          <target state="translated">Но если в качестве предусловия метода задать &quot;свойство X никогда не должно иметь нулевого значения&quot;,то можно предотвратить описанный ранее сценарий:</target>
        </trans-unit>
        <trans-unit id="8e174293e71614f4dcd5e8efa21b20f2c2ea09dd" translate="yes" xml:space="preserve">
          <source>By doing that and making PostSharp part of your build process &lt;code&gt;obj&lt;/code&gt; will be checked for null at runtime. See: &lt;a href=&quot;http://www.postsharp.net/blog/post/Validating-parameters-field-and-properties-in-PostSharp-3&quot;&gt;PostSharp null check&lt;/a&gt;</source>
          <target state="translated">Сделав это и сделав PostSharp частью вашего процесса сборки, &lt;code&gt;obj&lt;/code&gt; будет проверен на null во время выполнения. Смотрите: &lt;a href=&quot;http://www.postsharp.net/blog/post/Validating-parameters-field-and-properties-in-PostSharp-3&quot;&gt;PostSharp нулевая проверка&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64c2e10dbbbf9ef720a7c8d02d4aa8e8cf77773e" translate="yes" xml:space="preserve">
          <source>By finding by name I mean some framework allow you to FIndObjects using strings and the code might look like this: &lt;strong&gt;FindObject(&quot;ObjectName&quot;);&lt;/strong&gt;</source>
          <target state="translated">Под поиском по имени я подразумеваю, что некоторые фреймворки позволяют вам FIndObjects использовать строки, и код может выглядеть так: &lt;strong&gt;FindObject (&quot;ObjectName&quot;);&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d2fbdf206c06f82b8ff7b2a9385b7bc273f6c" translate="yes" xml:space="preserve">
          <source>By following the program flow this way, you can find the location where the instance should not be null, and why it isn't properly set.</source>
          <target state="translated">Следуя потоку программы таким образом,вы можете найти место,где экземпляр не должен быть нулевым,и почему он не установлен должным образом.</target>
        </trans-unit>
        <trans-unit id="0af3e909e29bebca060f842d0113445956bb71a3" translate="yes" xml:space="preserve">
          <source>By writing a null check like this you prevent the null dereference, but you move the null argument exception to the point of the &lt;em&gt;iteration&lt;/em&gt;, not to the point of the &lt;em&gt;call&lt;/em&gt;, and that is &lt;em&gt;very confusing to debug&lt;/em&gt;.</source>
          <target state="translated">Путем написания нулевой проверки, подобной этой, вы предотвращаете разыменование нулевого значения, но перемещаете исключение нулевого аргумента в точку &lt;em&gt;итерации&lt;/em&gt; , а не в точку &lt;em&gt;вызова&lt;/em&gt; , и это &lt;em&gt;очень сбивает с толку при отладке&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="910e894dcb9055a378eccef35ef795771f7bb251" translate="yes" xml:space="preserve">
          <source>C# 6.0 introduced the &quot;null-conditional operator&quot; that helps with this a little. With this feature, you can reference nested objects and if any one of them is &lt;code&gt;null&lt;/code&gt; the whole expression returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">В C # 6.0 введен &amp;laquo;нулевой оператор&amp;raquo;, который немного помогает в этом. С помощью этой функции вы можете ссылаться на вложенные объекты, и если какой-либо из них является &lt;code&gt;null&lt;/code&gt; все выражение возвращает &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06971ac0fe2094d0b96705ec2de4ff7f4c00141d" translate="yes" xml:space="preserve">
          <source>C# has a nice shorthand for &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, you can make something nullable by putting a question mark after the type like so &lt;code&gt;int?&lt;/code&gt;.</source>
          <target state="translated">В C # есть хорошее сокращение для &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; , вы можете сделать что-нибудь обнуляемое, поставив вопросительный знак после типа вроде &lt;code&gt;int?&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3d4cb34a5ed28713ba6e8d1854e778ef083e674d" translate="yes" xml:space="preserve">
          <source>C#8.0 introduces &lt;strong&gt;nullable reference types&lt;/strong&gt; and &lt;strong&gt;non-nullable reference types&lt;/strong&gt;. So only nullable reference types must be checked to avoid a &lt;strong&gt;NullReferenceException&lt;/strong&gt;.</source>
          <target state="translated">В C # 8.0 вводятся &lt;strong&gt;пустые ссылочные типы&lt;/strong&gt; и &lt;strong&gt;ненулевые ссылочные типы&lt;/strong&gt; . Поэтому необходимо проверять только обнуляемые ссылочные типы, чтобы избежать исключения &lt;strong&gt;NullReferenceException&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8dc39f8dd9c9e597efd5512af193d73bcc466778" translate="yes" xml:space="preserve">
          <source>Cast with &lt;code&gt;as&lt;/code&gt;</source>
          <target state="translated">В ролях &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da4e05c5dc0d067c4057445c2673b31a895c9b01" translate="yes" xml:space="preserve">
          <source>Changing the order of the declarations in the &lt;code&gt;XAML&lt;/code&gt; (i.e., listing &lt;code&gt;label1&lt;/code&gt; before &lt;code&gt;comboBox1&lt;/code&gt;, ignoring issues of design philosophy, would at least resolve the &lt;code&gt;NullReferenceException&lt;/code&gt; here.</source>
          <target state="translated">Изменение порядка объявлений в &lt;code&gt;XAML&lt;/code&gt; (т. &lt;code&gt;label1&lt;/code&gt; Перечисление label1 перед &lt;code&gt;comboBox1&lt;/code&gt; , игнорируя проблемы философии проектирования, по крайней мере разрешило &lt;code&gt;NullReferenceException&lt;/code&gt; здесь исключение NullReferenceException .</target>
        </trans-unit>
        <trans-unit id="f13d71f0e899fe3b305b742c14c426e502ee6355" translate="yes" xml:space="preserve">
          <source>Class Objects / Creating an Instance</source>
          <target state="translated">Объекты класса Создание экземпляра</target>
        </trans-unit>
        <trans-unit id="a6748432889326a79c007d1ba17c6c7cd3373670" translate="yes" xml:space="preserve">
          <source>Collection/List/Dictionary</source>
          <target state="translated">Collection/List/Dictionary</target>
        </trans-unit>
        <trans-unit id="ac972fde3be5ca3a4dcab0cc67b75680615eb722" translate="yes" xml:space="preserve">
          <source>Combine &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; with an extension method and you can cover even more situations. Here is an example of what the extension method can look like:</source>
          <target state="translated">Объедините &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; с методом расширения, и вы сможете охватить еще больше ситуаций. Вот пример того, как может выглядеть метод расширения:</target>
        </trans-unit>
        <trans-unit id="223c2967787ab7e442128765b6827c843685a817" translate="yes" xml:space="preserve">
          <source>Compiler for the above code raises an error that variable &lt;strong&gt;obj&lt;/strong&gt; is unassigned which signifies that our variable has null values or nothing. Compiler for the above code raises an error that variable &lt;strong&gt;obj&lt;/strong&gt; is unassigned which signifies that our variable has null values or nothing.</source>
          <target state="translated">Компилятор для приведенного выше кода выдает ошибку, что переменная &lt;strong&gt;obj&lt;/strong&gt; не назначена, что означает, что наша переменная имеет нулевые значения или ничего. Компилятор для приведенного выше кода выдает ошибку, что переменная &lt;strong&gt;obj&lt;/strong&gt; не назначена, что означает, что наша переменная имеет нулевые значения или ничего.</target>
        </trans-unit>
        <trans-unit id="bee75ca77f753e4846b455441733f6641c4bf287" translate="yes" xml:space="preserve">
          <source>Controls</source>
          <target state="translated">Controls</target>
        </trans-unit>
        <trans-unit id="1ca5b6d459cb7e4e8503007684404f6a2c26c9c9" translate="yes" xml:space="preserve">
          <source>DBNull is not the same as Nothing</source>
          <target state="translated">DBNull-это не то же самое,что Nothing.</target>
        </trans-unit>
        <trans-unit id="428b235126d11ccf77cf5d994238ed0919097855" translate="yes" xml:space="preserve">
          <source>Data Provider Objects</source>
          <target state="translated">Объекты поставщиков данных</target>
        </trans-unit>
        <trans-unit id="5568339e9f5e145b4c2866450e19d8cc65b1f7d3" translate="yes" xml:space="preserve">
          <source>Debug and let the debugger break... It will directly take you to the variable that is broken... Now your task is to simply fix this.. Using the &lt;strong&gt;new&lt;/strong&gt; keyword in the appropriate place.</source>
          <target state="translated">Отладьте и дайте отладчику сломаться ... Он напрямую приведет вас к сломанной переменной ... Теперь ваша задача просто исправить это ... Используя ключевое слово &lt;strong&gt;new&lt;/strong&gt; в соответствующем месте.</target>
        </trans-unit>
        <trans-unit id="6f0b5050efbdbd9b4e9f63b62af3e9fede37125c" translate="yes" xml:space="preserve">
          <source>Debugger: For developers, we have the big weapon of Debugging with us. If have we face NullReferenceException during the development face we can use the debugger to get to the source of the exception.</source>
          <target state="translated">Отладчик:Для разработчиков у нас есть большое оружие отладки.Если мы столкнулись с NullReferenceException во время разработки,мы можем использовать отладчик,чтобы добраться до источника исключения.</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="36fd56a44db41a6f009807b50cd27bc9943148b1" translate="yes" xml:space="preserve">
          <source>Debugging showed the model was Null inside MyOtherView. Until I changed it to:</source>
          <target state="translated">Отладка показала,что модель была Null внутри MyOtherView.Пока я не изменил ее:</target>
        </trans-unit>
        <trans-unit id="f2bef4698e9e93b03fbe4d5bae9a889cb96e1075" translate="yes" xml:space="preserve">
          <source>Don't ignore compiler warnings (ever) and use &lt;code&gt;Option Strict On&lt;/code&gt; (always).</source>
          <target state="translated">Не игнорируйте предупреждения компилятора (всегда) и используйте &lt;code&gt;Option Strict On&lt;/code&gt; (всегда).</target>
        </trans-unit>
        <trans-unit id="a116c71d483a8e062649940a075d035fe0d15e1c" translate="yes" xml:space="preserve">
          <source>Don't use empty Try/Catch blocks - let the code crash so you can a) identify the cause b) identify the location and c) apply a proper remedy.  Try/Catch blocks are not intended to hide exceptions from the person uniquely qualified to fix them - the developer.</source>
          <target state="translated">Не используйте пустые блоки TryCatch-дайте коду упасть,чтобы вы могли а)определить причину b)определить местоположение и в)применить соответствующее средство правовой защиты.Блоки TryCatch не предназначены для того,чтобы скрывать исключения от человека,который обладает уникальной квалификацией для их исправления-разработчика.</target>
        </trans-unit>
        <trans-unit id="d7f04facb7d4fb7422ce98a991d56e72f4d24f7c" translate="yes" xml:space="preserve">
          <source>Edge case #1: concurrent access to a Dictionary</source>
          <target state="translated">Крайний регистр #1:одновременный доступ к словарю</target>
        </trans-unit>
        <trans-unit id="e3ea50cc0b7f4be81be2362bf41478f7130a1285" translate="yes" xml:space="preserve">
          <source>Edge case #2: unsafe code</source>
          <target state="translated">Образец кода #2:небезопасный код</target>
        </trans-unit>
        <trans-unit id="6a6853d6e749e4d5b00c4b8d872d66e337db122a" translate="yes" xml:space="preserve">
          <source>Either procedure will result in an NRE, because &lt;code&gt;barList&lt;/code&gt; is only declared, not instantiated. Creating an instance of &lt;code&gt;Foo&lt;/code&gt; will not also create an instance of the internal &lt;code&gt;barList&lt;/code&gt;. It may have been the intent to do this in the constructor:</source>
          <target state="translated">Любая процедура приведет к NRE, потому что &lt;code&gt;barList&lt;/code&gt; только объявлен, но не создан. Создание экземпляра &lt;code&gt;Foo&lt;/code&gt; также не создаст экземпляр внутреннего &lt;code&gt;barList&lt;/code&gt; . Возможно, это было сделано в конструкторе:</target>
        </trans-unit>
        <trans-unit id="46f567c4dcc5486e4285b45b12d7a9a6e106f7ff" translate="yes" xml:space="preserve">
          <source>Enjoy and have fun making games!</source>
          <target state="translated">Наслаждайтесь и получайте удовольствие,делая игры!</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="2ede17026a66f2bb53f3b6978daa3529c4d3bc25" translate="yes" xml:space="preserve">
          <source>Ex:</source>
          <target state="translated">Ex:</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7b7d48ea7b3b293c238f8dc4cd94aa16d688011e" translate="yes" xml:space="preserve">
          <source>Example 2 &amp;mdash; Beware of the NewRow</source>
          <target state="translated">Пример 2 - Остерегайтесь NewRow</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="deec6b3c379dce2b6012e423f46c379377857030" translate="yes" xml:space="preserve">
          <source>Examples and Remedies</source>
          <target state="translated">Примеры и средства правовой защиты</target>
        </trans-unit>
        <trans-unit id="489c7f142f084f70e38f635ba7b9b348e5d129a5" translate="yes" xml:space="preserve">
          <source>Exception handling: One of the important ways of managing this exception. Using simple try-catch-finally blocks we can control this exception and also maintain a log of it. This can be very useful when your application is on production stage.</source>
          <target state="translated">Обработка исключений:Один из важных способов управления этим исключением.Используя простые блоки try-catch-finally,мы можем контролировать это исключение,а также вести его журнал.Это может быть очень полезно,когда ваше приложение находится на стадии производства.</target>
        </trans-unit>
        <trans-unit id="863e0b11b844698fd5b45fe2becd1c066657e73f" translate="yes" xml:space="preserve">
          <source>Explicit Checking: We should adhere to the tradition of checking the objects, properties, methods, arrays, and collections whether they are null. This can be simply implemented using conditional statements like if-else if-else etc.</source>
          <target state="translated">Прямая проверка:Мы должны придерживаться традиции проверки объектов,свойств,методов,массивов и коллекций на предмет того,являются ли они нулевыми.Это можно просто реализовать,используя условные операторы,такие как if-else if-else и т.д.</target>
        </trans-unit>
        <trans-unit id="109df3f9e4f70aee4ff4534f310fc794f8dc97d8" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; and ignore null values.</source>
          <target state="translated">Явно проверяйте &lt;code&gt;null&lt;/code&gt; и игнорируйте нулевые значения.</target>
        </trans-unit>
        <trans-unit id="31543b579bc99ae672e332aadbdf4f54893ffe8c" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; and provide a default value.</source>
          <target state="translated">Явно проверьте наличие &lt;code&gt;null&lt;/code&gt; и укажите значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="be6cb31f6768070d27ac716dcf02c1e5b5d94512" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; from method calls and throw a custom exception.</source>
          <target state="translated">Явно проверяйте &lt;code&gt;null&lt;/code&gt; из вызовов методов и генерируйте пользовательское исключение.</target>
        </trans-unit>
        <trans-unit id="376a5f377acf229980dec162e286875baba55137" translate="yes" xml:space="preserve">
          <source>Finding The Cause</source>
          <target state="translated">Поиск причины</target>
        </trans-unit>
        <trans-unit id="036893902b168b7c15417cf8b62f2cd292a4a2cd" translate="yes" xml:space="preserve">
          <source>First, make sure that the correct error is going to be caught - see
&lt;a href=&quot;https://stackoverflow.com/questions/4475464/&quot;&gt;How do I allow breaking on 'System.NullReferenceException' in VS2010?&lt;/a&gt;&lt;em&gt;Note&lt;sup&gt;1&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">Во-первых, убедитесь, что будет обнаружена правильная ошибка - см. &lt;a href=&quot;https://stackoverflow.com/questions/4475464/&quot;&gt;Как разрешить разрыв на System.NullReferenceException в VS2010?&lt;/a&gt; &lt;em&gt;Примечание &lt;sup&gt;1&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a9bb411b345b451f4de56294a2e04b8bb44acd7" translate="yes" xml:space="preserve">
          <source>Floating-point types</source>
          <target state="translated">Типы с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="c3b57bba0c6478be6c3878f4976f8768bd6104c1" translate="yes" xml:space="preserve">
          <source>For More details : &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators&quot;&gt;Null-conditional Operators&lt;/a&gt;</source>
          <target state="translated">Для более подробной информации: &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators&quot;&gt;Нулевые операторы&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d625573dda6be4c24b311020c3d5caa8ee0507c" translate="yes" xml:space="preserve">
          <source>For discussion have a look at &lt;a href=&quot;https://stackoverflow.com/questions/17136455/nullreferenceexception-in-dbcontext-savechanges&quot;&gt;NullReferenceException in DbContext.saveChanges()&lt;/a&gt;</source>
          <target state="translated">Для обсуждения взгляните на &lt;a href=&quot;https://stackoverflow.com/questions/17136455/nullreferenceexception-in-dbcontext-savechanges&quot;&gt;NullReferenceException в DbContext.saveChanges ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88fa3152aa1a080052016562134c18cdbc4e0603" translate="yes" xml:space="preserve">
          <source>For example :</source>
          <target state="translated">Например :</target>
        </trans-unit>
        <trans-unit id="21d6357b4a277981b9a66afc8fcee08849d0a240" translate="yes" xml:space="preserve">
          <source>For example, methods can check the different arguments to see if they are null and throw an &lt;code&gt;ArgumentNullException&lt;/code&gt;, an exception obviously created for this exact purpose.</source>
          <target state="translated">Например, методы могут проверять различные аргументы, чтобы определить, являются ли они нулевыми, и генерировать &lt;code&gt;ArgumentNullException&lt;/code&gt; , исключение, явно созданное для этой конкретной цели.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="ea87f510412c7e56ffdecaf29378fffd0b2ac212" translate="yes" xml:space="preserve">
          <source>For instance,
in the following line the only code that &lt;em&gt;can&lt;/em&gt; cause the exception is if &lt;code&gt;myString&lt;/code&gt; evaluates to null. This can be verified by looking at the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa290869(v=vs.71).aspx&quot;&gt;Watch Window&lt;/a&gt; or running expressions in the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/f177hahy.aspx&quot;&gt;Immediate Window&lt;/a&gt;.</source>
          <target state="translated">Например, в следующей строке единственный код, который &lt;em&gt;может&lt;/em&gt; вызвать исключение, - это если &lt;code&gt;myString&lt;/code&gt; имеет значение null. Это можно проверить, посмотрев в &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa290869(v=vs.71).aspx&quot;&gt;окно просмотра&lt;/a&gt; или запустив выражения в &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/f177hahy.aspx&quot;&gt;Immediate Window&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ab9060f75e800aa736a6c6d4a9d5f39e13be8b" translate="yes" xml:space="preserve">
          <source>For me the reason was that I had rename the file and old file was still open.</source>
          <target state="translated">Для меня причина была в том,что я переименовал файл,а старый файл все еще был открыт.</target>
        </trans-unit>
        <trans-unit id="ae336d2485d45668cf4b510dc35f9a49b357aa3b" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx&quot;&gt;&lt;code&gt;List(Of T)&lt;/code&gt; Class&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx&quot;&gt; &lt;code&gt;List(Of T)&lt;/code&gt; Class&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cadad1fb936cd59a173ee4ad751226d192504b1" translate="yes" xml:space="preserve">
          <source>For more information, see:</source>
          <target state="translated">Для дополнительной информации,смотрите:</target>
        </trans-unit>
        <trans-unit id="4b6396c3009607565ca4b596f1d3cfe993427c34" translate="yes" xml:space="preserve">
          <source>For the sake of completeness DataContext class</source>
          <target state="translated">Для полноты класса DataContext</target>
        </trans-unit>
        <trans-unit id="f241b5f4ab6b5874d32e0e2ef564edcc65cde7d2" translate="yes" xml:space="preserve">
          <source>For this cause, &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264808%28v=vs.110%29.aspx&quot;&gt;Code Contracts&lt;/a&gt;&lt;/em&gt; project exists for .NET applications.</source>
          <target state="translated">По этой причине проект &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264808%28v=vs.110%29.aspx&quot;&gt;Code Contracts&lt;/a&gt;&lt;/em&gt; существует для приложений .NET.</target>
        </trans-unit>
        <trans-unit id="6cfbd5392a130ba8fc377b758d8e7cdc4f1a9d51" translate="yes" xml:space="preserve">
          <source>For your reference I made the code above available on GitHub, you can find it at:</source>
          <target state="translated">Для справки:я сделал код,приведённый выше,доступным на GitHub,вы можете найти его по адресу:</target>
        </trans-unit>
        <trans-unit id="c4a1d4b8ee2b3e9ff148b30c5b4c8d7bb468ba9c" translate="yes" xml:space="preserve">
          <source>Function Returning Nothing</source>
          <target state="translated">Функция возврата Ничего</target>
        </trans-unit>
        <trans-unit id="bda3e991f9ccd7f64923695508d53cbd3f8354a4" translate="yes" xml:space="preserve">
          <source>Further Notes: If you want unity to add a component to your object and you might have forgotten to add one, you can type &lt;code&gt;[RequireComponent(typeof(RigidBody))]&lt;/code&gt; above your class declaration (the space below all of your usings).</source>
          <target state="translated">Дополнительные примечания: Если вы хотите, чтобы &lt;code&gt;[RequireComponent(typeof(RigidBody))]&lt;/code&gt; добавил компонент к вашему объекту, и вы, возможно, забыли добавить его, вы можете ввести [RequireComponent (typeof (RigidBody))]] выше объявления класса (пробел под всеми вашими использованиями).</target>
        </trans-unit>
        <trans-unit id="6ba86cf22af12011257223c782b9c2388170dce0" translate="yes" xml:space="preserve">
          <source>Furthermore, the reason I didn't have &lt;code&gt;Html.Partial&lt;/code&gt; to begin with was because Visual Studio &lt;strong&gt;sometimes&lt;/strong&gt; throws error-looking squiggly lines under &lt;code&gt;Html.Partial&lt;/code&gt; if it's inside a differently constructed &lt;code&gt;foreach&lt;/code&gt; loop, even though it's not really an error:</source>
          <target state="translated">Кроме того, причина, по которой у меня не было &lt;code&gt;Html.Partial&lt;/code&gt; для начала, заключалась в том, что Visual Studio &lt;strong&gt;иногда&lt;/strong&gt; бросает волнистые строки, выглядящие как ошибки, в &lt;code&gt;Html.Partial&lt;/code&gt; , если он находится внутри цикла &lt;code&gt;foreach&lt;/code&gt; , сконструированного по-другому, даже если это на самом деле не ошибка:</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="84ae2f625a61a0ac0cabba1b58ebdefb9ccdd612" translate="yes" xml:space="preserve">
          <source>Generic dictionaries in .NET are not thread-safe and they &lt;em&gt;sometimes&lt;/em&gt; might throw a &lt;code&gt;NullReference&lt;/code&gt; or even (more frequent) a &lt;code&gt;KeyNotFoundException&lt;/code&gt; when you try to access a key from two concurrent threads. The exception is quite misleading in this case.</source>
          <target state="translated">Общие словари в .NET не являются поточно- &lt;code&gt;NullReference&lt;/code&gt; и &lt;em&gt;иногда&lt;/em&gt; могут выдавать NullReference или даже (чаще) &lt;code&gt;KeyNotFoundException&lt;/code&gt; при попытке получить доступ к ключу из двух параллельных потоков. Исключение весьма обманчиво в этом случае.</target>
        </trans-unit>
        <trans-unit id="5442e2b64fa09764b9f593867e59a97292c84059" translate="yes" xml:space="preserve">
          <source>GitHub</source>
          <target state="translated">GitHub</target>
        </trans-unit>
        <trans-unit id="d0a42f917789ed1adb6c6963e61a12fd3ef2255b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;comboBox1&lt;/code&gt; is created before &lt;code&gt;label1&lt;/code&gt;. If &lt;code&gt;comboBox1_SelectionChanged&lt;/code&gt; attempts to reference `label1, it will not yet have been created.</source>
          <target state="translated">Здесь &lt;code&gt;comboBox1&lt;/code&gt; создается до &lt;code&gt;label1&lt;/code&gt; . Если &lt;code&gt;comboBox1_SelectionChanged&lt;/code&gt; попытается сослаться на `label1, он еще не будет создан.</target>
        </trans-unit>
        <trans-unit id="5bb2ae17924e2d50220fe232232b8dca78bd0287" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Book&lt;/code&gt; and &lt;code&gt;Car&lt;/code&gt; are incompatible types; a &lt;code&gt;Car&lt;/code&gt; cannot be converted/cast to a &lt;code&gt;Book&lt;/code&gt;.  When this cast fails, &lt;code&gt;as&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;.  Using &lt;code&gt;mybook&lt;/code&gt; after this causes a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;Book&lt;/code&gt; и &lt;code&gt;Car&lt;/code&gt; являются несовместимыми типами; &lt;code&gt;Car&lt;/code&gt; не может быть преобразован / брошен в &lt;code&gt;Book&lt;/code&gt; . Когда это приведение не удается, &lt;code&gt;as&lt;/code&gt; возвращает &lt;code&gt;null&lt;/code&gt; . Использование &lt;code&gt;mybook&lt;/code&gt; после этого вызывает &lt;code&gt;NullReferenceException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0cfc5e03a074b5ff497538e30726ab43dd9c052" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SelectedDate&lt;/code&gt; is in fact a property - of &lt;code&gt;DateTime&lt;/code&gt; type - of the &lt;code&gt;Calendar&lt;/code&gt; Web Control type, and the binding could perfectly return something null. The implicit ASP.NET Generator will create a piece of code that will be equivalent to the cast code above. And this will raise a &lt;code&gt;NullReferenceException&lt;/code&gt; that is quite difficult to spot, because it lies in ASP.NET generated code which compiles fine...</source>
          <target state="translated">Здесь &lt;code&gt;SelectedDate&lt;/code&gt; на самом деле является свойством - типа &lt;code&gt;DateTime&lt;/code&gt; - типа веб-элемента управления &lt;code&gt;Calendar&lt;/code&gt; , и привязка может совершенно вернуть что-то нулевое. Неявный ASP.NET Generator создаст фрагмент кода, который будет эквивалентен приведенному выше коду. И это вызовет &lt;code&gt;NullReferenceException&lt;/code&gt; , которое довольно сложно обнаружить, поскольку оно находится в сгенерированном ASP.NET коде, который прекрасно компилируется ...</target>
        </trans-unit>
        <trans-unit id="ed1e9256d7edb2bcff5e3eaa417639f1f18c564e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;myWebBrowser&lt;/code&gt; or &lt;code&gt;Document&lt;/code&gt; could be Nothing or the &lt;code&gt;formfld1&lt;/code&gt; element may not exist.</source>
          <target state="translated">Здесь &lt;code&gt;myWebBrowser&lt;/code&gt; или &lt;code&gt;Document&lt;/code&gt; могут иметь значение Nothing или элемент &lt;code&gt;formfld1&lt;/code&gt; может не существовать.</target>
        </trans-unit>
        <trans-unit id="2320c69a11432eba5e88d70d8ffa3f27efc00ca3" translate="yes" xml:space="preserve">
          <source>Hope this helps too!</source>
          <target state="translated">Надеюсь,это тоже поможет!</target>
        </trans-unit>
        <trans-unit id="0ae3600ced7e6090a5b25d1e38293c3e4c119186" translate="yes" xml:space="preserve">
          <source>How can it be avoided?</source>
          <target state="translated">Как этого можно избежать?</target>
        </trans-unit>
        <trans-unit id="289dd28c102f868db09f817b7b706b35bc135e71" translate="yes" xml:space="preserve">
          <source>How do you find the source of a &lt;code&gt;NullReferenceException&lt;/code&gt;? Apart from looking at the exception itself, which will be thrown exactly at the location where it occurs, the general rules of debugging in Visual Studio apply: place strategic breakpoints and &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/esta7c62.aspx&quot;&gt;inspect your variables&lt;/a&gt;, either by hovering the mouse over their names, opening a (Quick)Watch window or using the various debugging panels like Locals and Autos.</source>
          <target state="translated">Как вы находите источник &lt;code&gt;NullReferenceException&lt;/code&gt; ? Помимо рассмотрения самого исключения, которое будет сгенерировано точно в том месте, где оно происходит, применяются общие правила отладки в Visual Studio: устанавливайте стратегические контрольные точки и &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/esta7c62.aspx&quot;&gt;проверяйте свои переменные&lt;/a&gt; , наведя указатель мыши на их имена, открывая ( Быстро) Наблюдайте за окном или используя различные панели отладки, такие как Locals и Autos.</target>
        </trans-unit>
        <trans-unit id="c9076ca26af1e797ee780559308ab39c1861f589" translate="yes" xml:space="preserve">
          <source>I have a different perspective to answering this. This sort of answers &lt;strong&gt;&quot;what else can I do to avoid it?&lt;/strong&gt;&quot;</source>
          <target state="translated">У меня другая точка зрения на ответ. Такого рода ответы &lt;strong&gt;&quot;что еще я могу сделать, чтобы избежать этого?&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="4b181a81f82b32a1fdd472eb539bf0016ed99f5f" translate="yes" xml:space="preserve">
          <source>I have some code and when it executes, it throws a &lt;code&gt;NullReferenceException&lt;/code&gt;, saying:</source>
          <target state="translated">У меня есть некоторый код, и когда он выполняется, он &lt;code&gt;NullReferenceException&lt;/code&gt; , говоря:</target>
        </trans-unit>
        <trans-unit id="039ba9acfb4e759d3a5ed8951d9aef9d9682bea4" translate="yes" xml:space="preserve">
          <source>I was getting &lt;code&gt;Object reference not set to an instance of an object&lt;/code&gt; when I tried to render a View within a View by sending it a Model, like this:</source>
          <target state="translated">Я получал &lt;code&gt;Object reference not set to an instance of an object&lt;/code&gt; когда пытался отрисовать представление в представлении, отправив ему модель, например так:</target>
        </trans-unit>
        <trans-unit id="cdd8f575833c363a288e4e756f1a133957aee9ea" translate="yes" xml:space="preserve">
          <source>I'll be using a RigidBody variable as an example.</source>
          <target state="translated">В качестве примера я буду использовать переменную RigidBody.</target>
        </trans-unit>
        <trans-unit id="fd9aa298728dbdb009eb67b0148c8d2d45bb648a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dgvBooks&lt;/code&gt; has &lt;code&gt;AutoGenerateColumns = True&lt;/code&gt;, it will create the columns, but it does not name them, so the above code fails when it references them by name.</source>
          <target state="translated">Если &lt;code&gt;dgvBooks&lt;/code&gt; имеет &lt;code&gt;AutoGenerateColumns = True&lt;/code&gt; , он создает столбцы, но не называет их, поэтому приведенный выше код завершается ошибкой, когда ссылается на них по имени.</target>
        </trans-unit>
        <trans-unit id="bb92213da41ab10c3a7c561c6d6e69a25df9059f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;whatever&lt;/code&gt; results in &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;MakeFrob&lt;/code&gt; will throw.  Now, you might think that the right thing to do is this:</source>
          <target state="translated">Если &lt;code&gt;whatever&lt;/code&gt; приведет к &lt;code&gt;null&lt;/code&gt; то &lt;code&gt;MakeFrob&lt;/code&gt; сгенерирует. Теперь вы можете подумать, что правильно сделать следующее:</target>
        </trans-unit>
        <trans-unit id="c31841110ff2a43d84d3c54ced95f988e30ba219" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CheckBox&lt;/code&gt; with &lt;code&gt;chkName&lt;/code&gt; can't be found (or exists in a &lt;code&gt;GroupBox&lt;/code&gt;), then &lt;code&gt;chk&lt;/code&gt; will be Nothing and be attempting to reference any property will result in an exception.</source>
          <target state="translated">Если &lt;code&gt;CheckBox&lt;/code&gt; с &lt;code&gt;chkName&lt;/code&gt; не может быть найден (или существует в &lt;code&gt;GroupBox&lt;/code&gt; ), то &lt;code&gt;chk&lt;/code&gt; будет Nothing и попытка ссылки на какое-либо свойство приведет к исключению.</target>
        </trans-unit>
        <trans-unit id="56b8e5facbdd4848585ce4e50ddd17e21345d1f4" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;NullReferenceException&lt;/code&gt; is thrown by &lt;code&gt;unsafe&lt;/code&gt; code, you might look at your pointer variables, and check them for &lt;code&gt;IntPtr.Zero&lt;/code&gt; or something. Which is the same thing (&quot;null pointer exception&quot;), but in unsafe code, variables are often cast to value-types/arrays, etc., and you bang your head against the wall, wondering how a value-type can throw this exception.</source>
          <target state="translated">Если &lt;code&gt;NullReferenceException&lt;/code&gt; вызывается &lt;code&gt;unsafe&lt;/code&gt; кодом, вы можете просмотреть переменные-указатели и проверить их на &lt;code&gt;IntPtr.Zero&lt;/code&gt; или чего-либо еще. Это то же самое (&amp;laquo;исключение нулевого указателя&amp;raquo;), но в небезопасном коде переменные часто приводятся к типам значений / массивам и т. Д., И вы бьетесь головой о стену, задаваясь вопросом, как тип значения может бросить это исключение.</target>
        </trans-unit>
        <trans-unit id="3ba69a96020f6c1697e9f0b564be8a369771f477" translate="yes" xml:space="preserve">
          <source>If it is caused on some &lt;strong&gt;database&lt;/strong&gt; commands because the object isn't present then all you need to do is do a null check and handle it:</source>
          <target state="translated">Если это вызвано в некоторых командах &lt;strong&gt;базы данных,&lt;/strong&gt; потому что объект не присутствует, тогда все, что вам нужно сделать, это сделать нулевую проверку и обработать ее:</target>
        </trans-unit>
        <trans-unit id="a0fc7e5c19cd4824faca0c76683d3494b34dba43" translate="yes" xml:space="preserve">
          <source>If one is getting this message during saving or compiling the build, just close all the files and then open any file to compile and save.</source>
          <target state="translated">Если кто-то получает это сообщение во время сохранения или компиляции сборки,просто закройте все файлы,а затем откройте любой файл для компиляции и сохранения.</target>
        </trans-unit>
        <trans-unit id="0b56c362f306a958689a4fcd2922fb1cfb57868c" translate="yes" xml:space="preserve">
          <source>If ref1 or ref2 or ref3 is null, then you'll get a &lt;code&gt;NullReferenceException&lt;/code&gt;. If you want to solve the problem, then find out which one is null by rewriting the expression to its simpler equivalent:</source>
          <target state="translated">Если ref1 или ref2 или ref3 равны нулю, вы получите &lt;code&gt;NullReferenceException&lt;/code&gt; . Если вы хотите решить проблему, то выясните, какая из них равна нулю, переписав выражение в его более простой эквивалент:</target>
        </trans-unit>
        <trans-unit id="1e7a62c30a52478b4caee9f5d2f2740eae4bcb26" translate="yes" xml:space="preserve">
          <source>If the exception occurs when referencing a property of &lt;code&gt;@Model&lt;/code&gt; in an &lt;code&gt;ASP.NET MVC View&lt;/code&gt;, you need to understand that the &lt;code&gt;Model&lt;/code&gt; gets set in your action method, when you &lt;code&gt;return&lt;/code&gt; a view. When you return an empty model (or model property) from your controller, the exception occurs when the views access it:</source>
          <target state="translated">Если исключение возникает при обращении к свойству &lt;code&gt;@Model&lt;/code&gt; в представлении &lt;code&gt;ASP.NET MVC View&lt;/code&gt; , необходимо понимать, что &lt;code&gt;Model&lt;/code&gt; устанавливается в вашем методе действия при &lt;code&gt;return&lt;/code&gt; представления. Когда вы возвращаете пустую модель (или свойство модели) из вашего контроллера, исключение возникает, когда представления обращаются к нему:</target>
        </trans-unit>
        <trans-unit id="a383d31e09e21027128bda7cc84f8a8c4c8d65f8" translate="yes" xml:space="preserve">
          <source>If the person does not have a title, this will throw an exception because it is trying to call &lt;code&gt;ToUpper&lt;/code&gt; on a property with a null value.</source>
          <target state="translated">Если у человека нет заголовка, это вызовет исключение, потому что он пытается вызвать &lt;code&gt;ToUpper&lt;/code&gt; для свойства с нулевым значением.</target>
        </trans-unit>
        <trans-unit id="5cf3aeda57ef955ddb285e14c6996f8c139ee9bf" translate="yes" xml:space="preserve">
          <source>If we consider common scenarios where this exception can be thrown, accessing properties withing object at the top.</source>
          <target state="translated">Если рассмотреть общие сценарии,в которых это исключение может быть брошено,то доступ к свойствам с объектом сверху.</target>
        </trans-unit>
        <trans-unit id="bd4df3cabfb26db423d61513abb17ea9d42bbc71" translate="yes" xml:space="preserve">
          <source>If you are debugging with Just My Code enabled, the behavior is slightly different. With Just My Code enabled, the debugger ignores first-chance common language runtime (CLR) exceptions that are thrown outside of My Code and do not pass through My Code</source>
          <target state="translated">Если вы отлаживаетесь с включенным Just My Code,поведение немного отличается.При включенной опции Just My Code отладчик игнорирует исключения из правил выполнения программы на общем языке (CLR),которые выбрасываются за пределы My Code и не проходят через My Code.</target>
        </trans-unit>
        <trans-unit id="5d011199f17f1b3224336bf477779ff919919146" translate="yes" xml:space="preserve">
          <source>If you are expecting the type conversion to always succeed (ie. you know what the object should be ahead of time), then you should use a cast:</source>
          <target state="translated">Если вы ожидаете,что преобразование типа всегда будет успешным (т.е.вы заранее знаете,каким должен быть объект),то вам следует использовать приведение:</target>
        </trans-unit>
        <trans-unit id="db5359f7b5259b8f8194c263074c45fca315ff8a" translate="yes" xml:space="preserve">
          <source>If you are unsure of the type, but you want to &lt;em&gt;try&lt;/em&gt; to use it as a specific type, then use &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">Если вы не уверены в типе, но хотите &lt;em&gt;попробовать&lt;/em&gt; использовать его как конкретный тип, используйте:</target>
        </trans-unit>
        <trans-unit id="1c923dbbe26d09b3ec56dc6968714cd47b9bf93d" translate="yes" xml:space="preserve">
          <source>If you are working with unsafe code and you get a null dereference exception, just be aware that the offending pointer need not be null. It can be any location in the lowest page, and this exception will be produced.</source>
          <target state="translated">Если вы работаете с небезопасным кодом и получаете исключение по нулевой ссылке,просто знайте,что указатель-нарушитель не обязательно должен быть нулевым.Это может быть любое место на самой нижней странице,и это исключение будет произведено.</target>
        </trans-unit>
        <trans-unit id="9eee74fa45beb820853095727a40c22279c9d0bc" translate="yes" xml:space="preserve">
          <source>If you do use a &lt;code&gt;For n&lt;/code&gt; loop, modify the row count or use &lt;code&gt;Exit For&lt;/code&gt; when &lt;code&gt;IsNewRow&lt;/code&gt; is true.</source>
          <target state="translated">Если вы используете цикл &lt;code&gt;For n&lt;/code&gt; , измените счетчик строк или используйте &lt;code&gt;Exit For&lt;/code&gt; , когда &lt;code&gt;IsNewRow&lt;/code&gt; имеет значение true.</target>
        </trans-unit>
        <trans-unit id="e09bc8a6a4e58664c4a3a3793f96ba758d2f4e9b" translate="yes" xml:space="preserve">
          <source>If you examine the reference source for &lt;code&gt;LINQ&lt;/code&gt; to Objects you will see that this technique is used throughout. It is slightly more clunky to write, but it makes debugging nullity errors much easier.  &lt;strong&gt;Optimize your code for the convenience of the caller, not the convenience of the author&lt;/strong&gt;.</source>
          <target state="translated">Если вы изучите источник ссылки для &lt;code&gt;LINQ&lt;/code&gt; to Objects, вы увидите, что этот метод используется повсеместно. Это немного более неуклюже, чтобы написать, но это делает отладку ошибок ничтожности намного легче. &lt;strong&gt;Оптимизируйте свой код для удобства звонящего, а не для удобства автора&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e93bb8e62bdb0cbe375e02bcdd4025ed3a5280b6" translate="yes" xml:space="preserve">
          <source>If you expect the reference sometimes to be null, you can check for it being &lt;code&gt;null&lt;/code&gt; before accessing instance members:</source>
          <target state="translated">Если вы ожидаете, что ссылка иногда будет нулевой, вы можете проверить ее на &lt;code&gt;null&lt;/code&gt; прежде чем обращаться к членам экземпляра:</target>
        </trans-unit>
        <trans-unit id="954ae9f52d37b1ad255f61190a8a7c1d85bef3ef" translate="yes" xml:space="preserve">
          <source>If you have not initialized a reference type, and you want to set or read one of its properties, it will throw a &lt;strong&gt;NullReferenceException&lt;/strong&gt;.</source>
          <target state="translated">Если вы не инициализировали ссылочный тип и хотите установить или прочитать одно из его свойств, оно выдаст &lt;strong&gt;исключение NullReferenceException&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c9b75db38115a136957814e589aeeb2dac83db23" translate="yes" xml:space="preserve">
          <source>If you want to avoid the child (Person) null reference, you could initialize it in the parent (Book) object's constructor.</source>
          <target state="translated">Если вы хотите избежать дочерней (Person)нулевой ссылки,вы можете инициализировать ее в конструкторе родительского (Book)объекта.</target>
        </trans-unit>
        <trans-unit id="7672c7bfcdb17d75fe7dfc75005f4c60663395f1" translate="yes" xml:space="preserve">
          <source>If you want to find out where the reference is or isn't set, right-click its name and select &quot;Find All References&quot;. You can then place a breakpoint at every found location and run your program with the debugger attached. Every time the debugger breaks on such a breakpoint, you need to determine whether you expect the reference to be non-null, inspect the variable, and verify that it points to an instance when you expect it to.</source>
          <target state="translated">Если вы хотите узнать,где находится или не находится ссылка,щелкните правой кнопкой мыши по ее имени и выберите &quot;Найти все ссылки&quot;.После этого Вы можете поместить точку останова в каждое найденное место и запустить программу с приложенным отладчиком.Каждый раз,когда отладчик прерывает работу в такой точке останова,необходимо определить,ожидаете ли вы,что ссылка не будет нулевой,осмотреть переменную и убедиться,что она указывает на экземпляр,когда вы этого ожидаете.</target>
        </trans-unit>
        <trans-unit id="124ed7dc2efaa392800e559d8512faa6fddfc4a6" translate="yes" xml:space="preserve">
          <source>If you're not sure whether the object is null, check it with &lt;code&gt;object == null&lt;/code&gt;.</source>
          <target state="translated">Если вы не уверены, является ли объект нулевым, проверьте его с помощью &lt;code&gt;object == null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9d87c823bab4a6a3c23f4fa35b0ab3165ebc81e" translate="yes" xml:space="preserve">
          <source>Imagine that &lt;code&gt;country&lt;/code&gt; is an object of type &lt;code&gt;Country&lt;/code&gt; that has a property called &lt;code&gt;State&lt;/code&gt; and so on. If &lt;code&gt;country&lt;/code&gt;, &lt;code&gt;State&lt;/code&gt;, &lt;code&gt;County&lt;/code&gt;, or &lt;code&gt;City&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;address will be&lt;/code&gt;null&lt;code&gt;. Therefore you only have to check whether&lt;/code&gt;address&lt;code&gt;is&lt;/code&gt;null`.</source>
          <target state="translated">Представьте, что &lt;code&gt;country&lt;/code&gt; - это объект типа &lt;code&gt;Country&lt;/code&gt; , у которого есть свойство &lt;code&gt;State&lt;/code&gt; и так далее. Если &lt;code&gt;country&lt;/code&gt; , &lt;code&gt;State&lt;/code&gt; , &lt;code&gt;County&lt;/code&gt; или &lt;code&gt;City&lt;/code&gt; имеют &lt;code&gt;null&lt;/code&gt; тогда &lt;code&gt;address will be&lt;/code&gt; нулевым &lt;code&gt;. Therefore you only have to check whether&lt;/code&gt; Поэтому вам нужно только проверить, &lt;code&gt;is&lt;/code&gt; ли адрес пустым.</target>
        </trans-unit>
        <trans-unit id="d8dc338b100fb641765e4200d2b3f89eb5c8d59d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C# 5&lt;/code&gt; and below, this can be guarded with:</source>
          <target state="translated">В &lt;code&gt;C# 5&lt;/code&gt; и ниже это может быть защищено с помощью:</target>
        </trans-unit>
        <trans-unit id="d9af0d957316871a93fd8ae5a5c0570ecd645f0d" translate="yes" xml:space="preserve">
          <source>In Visual Studio this is usually easy thanks to the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/sc65sadd.aspx&quot;&gt;Visual Studio Debugger&lt;/a&gt;.</source>
          <target state="translated">В Visual Studio это обычно легко благодаря &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/sc65sadd.aspx&quot;&gt;отладчику Visual Studio&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="442f25764599824025c21fd67a95683d7a1d4d49" translate="yes" xml:space="preserve">
          <source>In comparison to an ArgumentNullException which is typically thrown as a defensive measure if a method expects that what is being passed to it is not null.</source>
          <target state="translated">По сравнению с ArgumentNullException,который обычно бросается в качестве защитной меры,если метод ожидает,что то,что передается ему не является нулевым.</target>
        </trans-unit>
        <trans-unit id="0d6fbd94de7bcc900b19537b5bb326c45d6c0504" translate="yes" xml:space="preserve">
          <source>In general, you should use a cast or &lt;code&gt;as&lt;/code&gt;, as follows:</source>
          <target state="translated">В общем, вы должны использовать приведение или как:</target>
        </trans-unit>
        <trans-unit id="a745bf8342a8ec9dc29ec2f0e55b1f294b6ff60a" translate="yes" xml:space="preserve">
          <source>In more advanced cases, such as the following, you'll need to use one of the techniques above (Watch or Immediate Windows) to inspect the expressions to determine if &lt;code&gt;str1&lt;/code&gt; was null or if &lt;code&gt;str2&lt;/code&gt; was null.</source>
          <target state="translated">В более сложных случаях, таких как следующие, вам нужно использовать один из методов, описанных выше (Watch или Immediate Windows), чтобы проверить выражения, чтобы определить, был ли &lt;code&gt;str1&lt;/code&gt; нулевым или &lt;code&gt;str2&lt;/code&gt; нулевым.</target>
        </trans-unit>
        <trans-unit id="6c2d2f16f8b1cfa8d5861b4766e0faaf22391a45" translate="yes" xml:space="preserve">
          <source>In short, &lt;em&gt;class invariants&lt;/em&gt; ensure that there will be some constraints in your class that will not get violated in normal use (and therefore, the class will &lt;em&gt;not&lt;/em&gt; get in an inconsistent state). &lt;em&gt;Preconditions&lt;/em&gt; mean that data given as input to a function/method must follow some constraints set and &lt;strong&gt;never&lt;/strong&gt; violate them, and &lt;em&gt;postconditions&lt;/em&gt; mean that a function/method output must follow the set constraints again without ever violating them.
Contract conditions should &lt;strong&gt;never&lt;/strong&gt; be violated during execution of a bug-free program, therefore design by contract is checked in practice in debug mode, while being &lt;em&gt;disabled in releases&lt;/em&gt;, to maximize the developed system performance.</source>
          <target state="translated">Короче говоря, &lt;em&gt;инварианты класса&lt;/em&gt; гарантируют, что в вашем классе будут некоторые ограничения, которые не будут нарушаться при обычном использовании (и, следовательно, класс &lt;em&gt;не&lt;/em&gt; попадет в противоречивое состояние). &lt;em&gt;Предварительные условия&lt;/em&gt; означают, что данные, предоставляемые в качестве входных данных для функции / метода, должны следовать некоторым установленным ограничениям и &lt;strong&gt;никогда не&lt;/strong&gt; нарушать их, а &lt;em&gt;постусловия&lt;/em&gt; означают, что выходные данные функции / метода должны снова следовать установленным ограничениям, никогда не нарушая их. Условия контракта &lt;strong&gt;никогда не&lt;/strong&gt; должны нарушаться во время выполнения безошибочной программы, поэтому проектирование по контракту проверяется на практике в режиме отладки, хотя и &lt;em&gt;отключается в выпусках&lt;/em&gt; , чтобы максимизировать производительность разработанной системы.</target>
        </trans-unit>
        <trans-unit id="ee86d3f393a29644b6be92e8be9ec8a1afe52114" translate="yes" xml:space="preserve">
          <source>In the other direction, a &lt;strong&gt;&lt;em&gt;boxing&lt;/em&gt;&lt;/strong&gt; conversion &lt;em&gt;from&lt;/em&gt; a &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; which has &lt;code&gt;HasValue&lt;/code&gt; equal to &lt;code&gt;false&lt;/code&gt;&lt;em&gt;to&lt;/em&gt; a reference type, can give a &lt;code&gt;null&lt;/code&gt; reference which can then later lead to a &lt;code&gt;NullReferenceException&lt;/code&gt;. The classic example is:</source>
          <target state="translated">В другом направлении преобразование &lt;strong&gt;&lt;em&gt;бокса&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;из&lt;/em&gt; &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; которого &lt;code&gt;HasValue&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; &lt;em&gt;для&lt;/em&gt; ссылочного типа, может дать &lt;code&gt;null&lt;/code&gt; ссылку, которая впоследствии может привести к &lt;code&gt;NullReferenceException&lt;/code&gt; . Классический пример:</target>
        </trans-unit>
        <trans-unit id="7a5a670646192c2904df37f98794bc286c1f51c1" translate="yes" xml:space="preserve">
          <source>In unsafe mode, you should be aware of two important facts:</source>
          <target state="translated">В небезопасном режиме вы должны знать два важных факта:</target>
        </trans-unit>
        <trans-unit id="3be7faaf917ec1e75bc105ac00cd45db1f27d22a" translate="yes" xml:space="preserve">
          <source>In-built method: System methods such as GetValueOrDefault(),IsNullOrWhiteSpace() and IsNullorEmpty()  checks for nulls and assign the default value if there is a null value.</source>
          <target state="translated">Встроенный метод:Системные методы,такие как GetValueOrDefault(),IsNullOrWhiteSpace()и IsNullorEmpty()проверяют на наличие нулей и присваивают значение по умолчанию,если есть нулевое значение.</target>
        </trans-unit>
        <trans-unit id="8cbe1b61604257c69eb792f97e93456c4cc68afc" translate="yes" xml:space="preserve">
          <source>Indirect</source>
          <target state="translated">Indirect</target>
        </trans-unit>
        <trans-unit id="414415dac9332746c5ff97ecdc8a7f74c2f17f06" translate="yes" xml:space="preserve">
          <source>Initialize the settings collection in the form's &lt;code&gt;Load&lt;/code&gt; event handler, if/when needed:</source>
          <target state="translated">Инициализируйте коллекцию настроек в обработчике события &lt;code&gt;Load&lt;/code&gt; формы, если / когда это необходимо:</target>
        </trans-unit>
        <trans-unit id="234d47467506fc9f47ee7950fcdb7bb2ae54365b" translate="yes" xml:space="preserve">
          <source>Integral types</source>
          <target state="translated">Интегральные типы</target>
        </trans-unit>
        <trans-unit id="c3341d58f2612c2f24999b64faed81efad614d89" translate="yes" xml:space="preserve">
          <source>Interestingly, none of the answers on this page mention the two edge cases, hope no one minds if I add them:</source>
          <target state="translated">Интересно,что ни в одном из ответов на этой странице не упоминаются два крайних случая,надеюсь,никто не возражает,если я их добавлю:</target>
        </trans-unit>
        <trans-unit id="01bd706ed0b9c186751dc7af37426b554a904934" translate="yes" xml:space="preserve">
          <source>Introduced in &lt;code&gt;C# 8&lt;/code&gt; there null context's and nullable reference types perform static analysis on variables and provides a compiler warning if a value can be potentially null or have been set to null. The nullable reference types allows types to be explicitly allowed to be null.</source>
          <target state="translated">Введенный в &lt;code&gt;C# 8&lt;/code&gt; нулевой контекст и нулевые ссылочные типы выполняют статический анализ переменных и выдают предупреждение компилятора, если значение может быть потенциально нулевым или для него установлено нулевое значение. Обнуляемые ссылочные типы позволяют типам быть явно пустыми.</target>
        </trans-unit>
        <trans-unit id="cbf6007ad3f8db48b2caa744d94cf086e082dc37" translate="yes" xml:space="preserve">
          <source>It also arises when we forget to instantiate our objects. Using methods, properties, collections etc. which can return or set null values can also be the cause of this exception.</source>
          <target state="translated">Она также возникает,когда мы забываем конкретизировать наши объекты.Использование методов,свойств,коллекций и т.д.,которые могут возвращать или устанавливать нулевые значения,также может быть причиной этого исключения.</target>
        </trans-unit>
        <trans-unit id="6f40b22d84245ca604cc84dc6eef8a46a3df02af" translate="yes" xml:space="preserve">
          <source>It is curious that VB does not provide a warning, but the remedy is to &lt;strong&gt;declare&lt;/strong&gt; the containers at the form level, but &lt;strong&gt;initialize&lt;/strong&gt; them in form load event handler when the controls &lt;strong&gt;do&lt;/strong&gt; exist. This can be done in &lt;code&gt;Sub New&lt;/code&gt; as long as your code is after the &lt;code&gt;InitializeComponent&lt;/code&gt; call:</source>
          <target state="translated">Любопытно, что VB не выдает предупреждение, но решение состоит в том, чтобы &lt;strong&gt;объявить&lt;/strong&gt; контейнеры на уровне формы, но &lt;strong&gt;инициализировать&lt;/strong&gt; их в обработчике события загрузки формы, когда элементы управления существуют. Это можно сделать в &lt;code&gt;Sub New&lt;/code&gt; , если ваш код находится после вызова &lt;code&gt;InitializeComponent&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2eef644af3700e5795f998539dd59e2e7c297244" translate="yes" xml:space="preserve">
          <source>It is not possible to reference anything 'downstream' of a &lt;code&gt;null&lt;/code&gt; object.  This also applies to controls:</source>
          <target state="translated">Невозможно ссылаться на что-либо &amp;laquo;вниз по потоку&amp;raquo; от &lt;code&gt;null&lt;/code&gt; объекта. Это также относится к элементам управления:</target>
        </trans-unit>
        <trans-unit id="83c9a2a6f0cded3da8a2fd23d1724756e8709640" translate="yes" xml:space="preserve">
          <source>It means that the variable in question is pointed at nothing. I could generate this like so:</source>
          <target state="translated">Это означает,что рассматриваемая переменная ни на что не указывает.Я мог бы сгенерировать это так:</target>
        </trans-unit>
        <trans-unit id="725b5851f8a7590790831cee0a9a54440c5e452d" translate="yes" xml:space="preserve">
          <source>It means your code used an object reference variable that was set to null (i.e. it did not reference an actual object instance).</source>
          <target state="translated">Это означает,что в вашем коде использовалась переменная ссылка на объект,которая была установлена в ноль (т.е.она не ссылалась на фактический экземпляр объекта).</target>
        </trans-unit>
        <trans-unit id="0c813d120a6e5cc67f6c6bde99d1fd2ca0b51cc2" translate="yes" xml:space="preserve">
          <source>It will throw a &lt;code&gt;NullReferenceException&lt;/code&gt; on the cast. It seems quite obvious in the above sample, but this can happen in more &quot;late-binding&quot; intricate scenarios where the null object has been returned from some code you don't own, and the cast is for example generated by some automatic system.</source>
          <target state="translated">Это бросит &lt;code&gt;NullReferenceException&lt;/code&gt; на приведение. Это кажется вполне очевидным в приведенном выше примере, но это может произойти в более сложных запоздалых сценариях, когда нулевой объект был возвращен из некоторого кода, который вам не принадлежит, и приведение, например, генерируется некоторой автоматической системой.</target>
        </trans-unit>
        <trans-unit id="8179843545ce209e8ee908f48e63197ddb2508a8" translate="yes" xml:space="preserve">
          <source>It would be nice if C# had something like the &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; struct above and had a similar shorthand, maybe the exclamation point (!) so that you could write something like: &lt;code&gt;public void WriteName(Person! person)&lt;/code&gt;.</source>
          <target state="translated">Было бы хорошо, если бы C # имел что-то вроде структуры &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; выше и имел бы подобную стенограмму, может быть, восклицательный знак (!), Чтобы вы могли написать что-то вроде: &lt;code&gt;public void WriteName(Person! person)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="955b6d8394cf76a1d4fe4f8e7ef177275da55c14" translate="yes" xml:space="preserve">
          <source>It's a great feature, but it gives you less information. It doesn't make it obvious which of the 4 is null.</source>
          <target state="translated">Это отличная функция,но она дает меньше информации.Это не делает очевидным,какой из 4-х является нулевым.</target>
        </trans-unit>
        <trans-unit id="4bf150ddb62d4d1939db3d1e25f12fdd47b0ee5f" translate="yes" xml:space="preserve">
          <source>It's used to test for null before performing a member access (?.) or index (?[) operation.</source>
          <target state="translated">Используется для проверки на ноль перед выполнением операции доступа к члену (?)или индекса (?[).</target>
        </trans-unit>
        <trans-unit id="71c8a217f58ff5fc0e4a7d04b09748b7f1e8da29" translate="yes" xml:space="preserve">
          <source>Jagged Arrays</source>
          <target state="translated">зубчатые рейки</target>
        </trans-unit>
        <trans-unit id="4de379f88b7ef46e6cfa5de6e9908e85f89cf4f0" translate="yes" xml:space="preserve">
          <source>JetBrains' Resharper tool will identify every place in your code that has the possibility of a null reference error, allowing you to put in a null check. This error is the number one source of bugs, IMHO.</source>
          <target state="translated">Инструмент Resharper от JetBrains определит каждое место в вашем коде,которое имеет возможность ошибки нулевой ссылки,позволяя вам поставить нулевую проверку.Эта ошибка является источником ошибок номер один,IMHO.</target>
        </trans-unit>
        <trans-unit id="b2802386a0546365a801bdc9dc6dc071b11d5be6" translate="yes" xml:space="preserve">
          <source>Key Points</source>
          <target state="translated">Ключевые точки</target>
        </trans-unit>
        <trans-unit id="8ee0e49c20d5b975cccff63b65f6a1467d4f272c" translate="yes" xml:space="preserve">
          <source>LINQ &lt;code&gt;FirstOrDefault()&lt;/code&gt; and &lt;code&gt;SingleOrDefault()&lt;/code&gt;</source>
          <target state="translated">LINQ &lt;code&gt;FirstOrDefault()&lt;/code&gt; и &lt;code&gt;SingleOrDefault()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99356ca7906555a2f4c7dc97649a8efa6dbd0212" translate="yes" xml:space="preserve">
          <source>Like anything else, &lt;code&gt;null&lt;/code&gt; gets passed around. If it is &lt;code&gt;null&lt;/code&gt;&lt;em&gt;in&lt;/em&gt; method &quot;A&quot;, it could be that method &quot;B&quot; passed a &lt;code&gt;null&lt;/code&gt;&lt;em&gt;to&lt;/em&gt; method &quot;A&quot;.</source>
          <target state="translated">Как и все остальное, &lt;code&gt;null&lt;/code&gt; передается. Если &lt;em&gt;в&lt;/em&gt; методе &amp;laquo;A&amp;raquo; он равен &lt;code&gt;null&lt;/code&gt; , возможно, метод &amp;laquo;B&amp;raquo; передал &lt;code&gt;null&lt;/code&gt; методу &amp;laquo;A&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="aa96796b70166a01da429a974a3cc400dff498a8" translate="yes" xml:space="preserve">
          <source>Likewise, for arrays you can use &lt;code&gt;?[i]&lt;/code&gt; as follows:</source>
          <target state="translated">Аналогично, для массивов вы можете использовать &lt;code&gt;?[i]&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="5fd395238ed01cc167eb08a83b289717b17ed72a" translate="yes" xml:space="preserve">
          <source>Lists and Collection will simply be empty</source>
          <target state="translated">Списки и Коллекция будут просто пустыми</target>
        </trans-unit>
        <trans-unit id="b89d28bc5880c1090375f320e5a1517ea528fb46" translate="yes" xml:space="preserve">
          <source>Lists and Collections</source>
          <target state="translated">Списки и коллекции</target>
        </trans-unit>
        <trans-unit id="8ed2e69395a71ce749a19137034071d7ce924763" translate="yes" xml:space="preserve">
          <source>Literally the easiest way to fix a NullReferenceExeption has two ways.
If you have a GameObject for example with a script attached and a variable named rb (rigidbody) this variable will start null when you start your game.</source>
          <target state="translated">Буквально самый простой способ исправить NullReferenceExeption имеет два пути.Если у вас есть объект GameObject,например,с прикрепленным скриптом и переменной rb (жесткое тело),то эта переменная начнет с нуля,когда вы начнете игру.</target>
        </trans-unit>
        <trans-unit id="c42ff2b214ede29fd88c31705a2e471ec3556484" translate="yes" xml:space="preserve">
          <source>MSDN NullReference Exception</source>
          <target state="translated">Исключение из правил MSDN NullReference</target>
        </trans-unit>
        <trans-unit id="7ad8fdfe61e4454ef02db660ac35ba0748c9aa9d" translate="yes" xml:space="preserve">
          <source>MSDN: Best Practices for Exceptions</source>
          <target state="translated">MSDN:Передовая практика для исключений</target>
        </trans-unit>
        <trans-unit id="1799c9265044c387d0f81f0d8e6ab1b39fd3f4f5" translate="yes" xml:space="preserve">
          <source>MSDN: How to: Use the Try/Catch Block to Catch Exceptions</source>
          <target state="translated">MSDN:Как:Используйте блок TryCatch,чтобы поймать исключений</target>
        </trans-unit>
        <trans-unit id="78736f095b06c11f959a9bd8d826202e6b13baf7" translate="yes" xml:space="preserve">
          <source>Memory is virtualized in &lt;code&gt;Windows&lt;/code&gt;; each process gets a virtual memory space of many &quot;pages&quot; of memory that are tracked by the operating system. Each page of memory has flags set on it which determine how it may be used: read from, written to, executed, and so on.  The &lt;em&gt;lowest&lt;/em&gt; page is marked as &quot;produce an error if ever used in any way&quot;.</source>
          <target state="translated">Память виртуализирована в &lt;code&gt;Windows&lt;/code&gt; ; каждый процесс получает пространство виртуальной памяти из множества &amp;laquo;страниц&amp;raquo; памяти, которые отслеживаются операционной системой. На каждой странице памяти установлены флаги, которые определяют, как ее можно использовать: чтение, запись, выполнение и т. Д. Самая &lt;em&gt;нижняя&lt;/em&gt; страница помечена как &amp;laquo;выдает ошибку, если когда-либо использовалась каким-либо образом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e23cc54bff3a3a5d37dc37dc1662948bf36648f0" translate="yes" xml:space="preserve">
          <source>Methods call you expect to return an instance can return &lt;code&gt;null&lt;/code&gt;, for example when the object being sought cannot be found. You can choose to return a default value when this is the case:</source>
          <target state="translated">Вызов методов, которые вы ожидаете вернуть экземпляр, может вернуть &lt;code&gt;null&lt;/code&gt; , например, когда искомый объект не может быть найден. Вы можете вернуть значение по умолчанию, если это так:</target>
        </trans-unit>
        <trans-unit id="f2f65c39e9befac556a2ece0db1de4b0c904147b" translate="yes" xml:space="preserve">
          <source>More Specifically</source>
          <target state="translated">Более конкретно</target>
        </trans-unit>
        <trans-unit id="1f2886a5d0eb58ab959b4b21d407f74a59989572" translate="yes" xml:space="preserve">
          <source>More information is in &lt;em&gt;&lt;a href=&quot;https://www.dotnetperls.com/nullreferenceexception&quot;&gt;C# NullReferenceException and Null Parameter&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Больше информации в &lt;em&gt;&lt;a href=&quot;https://www.dotnetperls.com/nullreferenceexception&quot;&gt;C # NullReferenceException и Null Parameter&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="73d48e92ee90db3568c1d31a50c956aadebdfbd8" translate="yes" xml:space="preserve">
          <source>More realistic example - select nodes from XML document. Will throw if nodes are not found but initial debugging shows that all properties valid:</source>
          <target state="translated">Более реалистичный пример-выберите узлы из XML-документа.Будет бросаться,если узлы не найдены,но начальная отладка показывает,что все свойства действительны:</target>
        </trans-unit>
        <trans-unit id="f76899831263fd9799a64690d3ad0afc9100b2a4" translate="yes" xml:space="preserve">
          <source>My.Settings (StringCollection)</source>
          <target state="translated">Мои.настройки (StringCollection)</target>
        </trans-unit>
        <trans-unit id="41db439be65a63d22d9384237a7b090f77634c41" translate="yes" xml:space="preserve">
          <source>Name the columns manually, or reference by index:</source>
          <target state="translated">Назовите столбцы вручную или ссылку по индексу:</target>
        </trans-unit>
        <trans-unit id="f73fd087219997abb0b2070a7f8b9006bc9c6c3b" translate="yes" xml:space="preserve">
          <source>Nested Collection Initializers</source>
          <target state="translated">Инициализаторы вложенной коллекции</target>
        </trans-unit>
        <trans-unit id="c2ffcf7dcaf6a0db61f66aee4b7d2a32b5b706ba" translate="yes" xml:space="preserve">
          <source>Nested Object Initializers</source>
          <target state="translated">Инициализаторы вложенных объектов</target>
        </trans-unit>
        <trans-unit id="a9f6f220ca6e10feac65da97285e903dcd7c03df" translate="yes" xml:space="preserve">
          <source>New Operator</source>
          <target state="translated">Новый оператор</target>
        </trans-unit>
        <trans-unit id="594a0ab4e25b09bd873763aa42a8cfaed596e74c" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;Do not&lt;/strong&gt; use &lt;code&gt;Dim&lt;/code&gt; again in a procedure, including the constructor (&lt;code&gt;Sub New&lt;/code&gt;):</source>
          <target state="translated">Примечание: &lt;strong&gt;не&lt;/strong&gt; используйте &lt;code&gt;Dim&lt;/code&gt; снова в процедуре, включая конструктор ( &lt;code&gt;Sub New&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="b0c7d1634f143651ccf0114e6c5ffff2ff4f10cd" translate="yes" xml:space="preserve">
          <source>Note: Beginning with VS 2010, when initializing a local array using a literal and &lt;code&gt;Option Infer&lt;/code&gt;, the &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; and &lt;code&gt;New&lt;/code&gt; elements are optional:</source>
          <target state="translated">Примечание. Начиная с VS 2010, при инициализации локального массива с использованием литерала и &lt;code&gt;Option Infer&lt;/code&gt; элементы &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; и &lt;code&gt;New&lt;/code&gt; являются необязательными:</target>
        </trans-unit>
        <trans-unit id="378b211edf065e14fb27dcd1e7e1b744600ccaae" translate="yes" xml:space="preserve">
          <source>Now the title variable will be null instead of throwing an exception. C# 6 introduces a shorter syntax for this:</source>
          <target state="translated">Теперь вместо того,чтобы бросить исключение,переменная заголовка будет нулевой.C#6 вводит более короткий синтаксис:</target>
        </trans-unit>
        <trans-unit id="0e05b2f6e48a9c2172676721b07aa9534ae7f3f2" translate="yes" xml:space="preserve">
          <source>Now you are accessing this prop1 in some other class just like below:</source>
          <target state="translated">Теперь вы получаете доступ к этому prop1 в каком-то другом классе,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="baac228f016bc4ccca30fd630c5ff646abbf3f89" translate="yes" xml:space="preserve">
          <source>Now, consider another class where you are trying to retrieve the student's full name.</source>
          <target state="translated">Теперь рассмотрим другой класс,где ты пытаешься получить полное имя ученика.</target>
        </trans-unit>
        <trans-unit id="4850e4da722f36fec8d78291c92be908f1969d5e" translate="yes" xml:space="preserve">
          <source>Now, when I try to print the length of the string &lt;strong&gt;str&lt;/strong&gt;, I do get &lt;em&gt;An unhandled exception of type &amp;lsquo;System.NullReferenceException&amp;rsquo; occurred&lt;/em&gt; message because member &lt;strong&gt;str&lt;/strong&gt; is pointing to null and there can&amp;rsquo;t be any length of null.</source>
          <target state="translated">Теперь, когда я пытаюсь напечатать длину строки &lt;strong&gt;str&lt;/strong&gt; , я получаю сообщение о &lt;em&gt;необработанном исключении типа &amp;laquo;System.NullReferenceException&amp;raquo;,&lt;/em&gt; потому что член &lt;strong&gt;str&lt;/strong&gt; указывает на ноль и не может быть никакой длины ноль.</target>
        </trans-unit>
        <trans-unit id="eafd17582b015c89f4f72513d53f759c4bde2b05" translate="yes" xml:space="preserve">
          <source>Now, when the NullReferenceException is thrown (or unhandled) the debugger will stop (remember the rule set above?) on the line on which the exception occurred. Sometimes the error will be easy to spot.</source>
          <target state="translated">Теперь,когда NullReferenceException брошен (или не обработан),отладчик остановится (помните вышеприведенное правило?)на той строке,на которой произошло исключение.Иногда ошибку будет легко обнаружить.</target>
        </trans-unit>
        <trans-unit id="318279d9fb722f810e6e3f50b545a9a0404b55c6" translate="yes" xml:space="preserve">
          <source>Null operators: Null Coalescing operator and null conditional operators can also be used in handy while setting values to objects, variables, properties and fields.</source>
          <target state="translated">Нулл-операторы:Нулевой коалесцирующий оператор и нулевой условный оператор также могут быть использованы в удобстве при установке значений для объектов,переменных,свойств и полей.</target>
        </trans-unit>
        <trans-unit id="2eb936c96dfd3a82cf681dcf1e453a56150f03fb" translate="yes" xml:space="preserve">
          <source>NullReference Exception &amp;mdash; Visual Basic</source>
          <target state="translated">Исключение NullReference - Visual Basic</target>
        </trans-unit>
        <trans-unit id="108a53e72c1b0456c7d04a8155e32546371f242d" translate="yes" xml:space="preserve">
          <source>NullReferenceException arises due to our fault for not checking the object&amp;rsquo;s value. We often leave the object values unchecked in the code development.</source>
          <target state="translated">NullReferenceException возникает из-за нашей ошибки в том, что мы не проверили значение объекта. Мы часто оставляем значения объектов без контроля при разработке кода.</target>
        </trans-unit>
        <trans-unit id="b5713cc5880d61c8ee4043a97acf6d784d345341" translate="yes" xml:space="preserve">
          <source>NullReferenceException or Object reference not set to an instance of an object occurs when an object of the class you are trying to use is not instantiated.
For example:</source>
          <target state="translated">NullReferenceException или ссылка на объект,не установленная для экземпляра объекта,возникает,когда объект класса,который вы пытаетесь использовать,не инстанцируется.Например:</target>
        </trans-unit>
        <trans-unit id="498d55bb5d750bf94a55e680251545631183f0ad" translate="yes" xml:space="preserve">
          <source>NullReferenceException won't occur if we are using Value type members.</source>
          <target state="translated">NullReferenceException не произойдет,если мы используем члены типа Value.</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">Числовые типы</target>
        </trans-unit>
        <trans-unit id="3390ab1994cf8aa916e3506c4916e33bb1871966" translate="yes" xml:space="preserve">
          <source>Object Paths / Nested</source>
          <target state="translated">Вложенные пути объектов</target>
        </trans-unit>
        <trans-unit id="dfefbee8fa51c19a77377fdc99c6d1e91ac2ebb8" translate="yes" xml:space="preserve">
          <source>Object reference not set to an instance of an object.</source>
          <target state="translated">Ссылка на объект не установлена на экземпляр объекта.</target>
        </trans-unit>
        <trans-unit id="ffdbed86f65d9327dc3308e8c7e0ebc6a5dd365d" translate="yes" xml:space="preserve">
          <source>Object variables which are &lt;strong&gt;uninitialized&lt;/strong&gt; and hence &lt;strong&gt;point to nothing.&lt;/strong&gt; In this case, if you access properties or methods of such objects, it causes a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">Переменные объекта, которые &lt;strong&gt;неинициализированы&lt;/strong&gt; и, следовательно, &lt;strong&gt;ни на что не указывают.&lt;/strong&gt; В этом случае, если вы &lt;code&gt;NullReferenceException&lt;/code&gt; к свойствам или методам таких объектов, это вызывает исключение NullReferenceException .</target>
        </trans-unit>
        <trans-unit id="9f9388be3a14ac2bf1c68c14b6f7c7b0ba00f598" translate="yes" xml:space="preserve">
          <source>Of course, you &lt;em&gt;still&lt;/em&gt; have to check &lt;code&gt;title&lt;/code&gt; for null or use the null condition operator together with the null coalescing operator (&lt;code&gt;??&lt;/code&gt;) to supply a default value:</source>
          <target state="translated">Конечно, вам &lt;em&gt;все равно&lt;/em&gt; нужно проверить &lt;code&gt;title&lt;/code&gt; на null или использовать оператор условия null вместе с оператором объединения нулей ( &lt;code&gt;??&lt;/code&gt; ), чтобы задать значение по умолчанию:</target>
        </trans-unit>
        <trans-unit id="fa4b5d0f97e6455028a59f1925e67775d0a3150f" translate="yes" xml:space="preserve">
          <source>On the matter of &lt;strong&gt;&quot;what should I do about it&quot;&lt;/strong&gt;, there can be many answers.</source>
          <target state="translated">На вопрос &lt;strong&gt;&amp;laquo;что мне с этим делать&amp;raquo;&lt;/strong&gt; может быть много ответов.</target>
        </trans-unit>
        <trans-unit id="3d646273973e4205570d72f3076fd5fc36ee3360" translate="yes" xml:space="preserve">
          <source>Once &lt;em&gt;where&lt;/em&gt; the exception is throw has been located, it's usually trivial to reason backwards to find out where the null value was [incorrectly] introduced --</source>
          <target state="translated">Когда локализацией является исключение throw, обычно тривиально рассуждать в обратном направлении, чтобы выяснить, где было введено нулевое значение - неправильно</target>
        </trans-unit>
        <trans-unit id="2a462199e4fdd6a0af25f3adcac4accc6d33e906" translate="yes" xml:space="preserve">
          <source>Once you know what and where the problem is, it is usually fairly easy to fix and faster than posting a new question.</source>
          <target state="translated">Как только вы знаете,что и где проблема,это обычно довольно легко исправить и быстрее,чем написать новый вопрос.</target>
        </trans-unit>
        <trans-unit id="ae6cb7569ada63bc2d3e163016b98bc806afea38" translate="yes" xml:space="preserve">
          <source>One example of this is this simple ASP.NET binding fragment with the Calendar control:</source>
          <target state="translated">Одним из примеров этого является простой фрагмент привязки ASP.NET с управлением Calendar:</target>
        </trans-unit>
        <trans-unit id="79a8436face2b533d827001515951269d4bfb9b3" translate="yes" xml:space="preserve">
          <source>Only reference types, as the name is suggesting, can hold references or point literally to nothing (or 'null'). Whereas value types always contain a value.</source>
          <target state="translated">Только типы ссылок,как предполагает имя,могут содержать ссылки или точку буквально ни на что (или 'ноль').В то время как типы значений всегда содержат значение.</target>
        </trans-unit>
        <trans-unit id="025911f6c7d528b21a46faf9fcb9c34232aa12fe" translate="yes" xml:space="preserve">
          <source>Option Infer Statement</source>
          <target state="translated">Заявление об условных обозначениях</target>
        </trans-unit>
        <trans-unit id="f179578c51c822eb1fb66acea0ac9ffb6979808e" translate="yes" xml:space="preserve">
          <source>Or you can always code your own approach using plain old code. For example here is a struct that you can use to catch null references. It's modeled after the same concept as &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Или вы всегда можете написать свой собственный подход, используя простой старый код. Например, вот структура, которую вы можете использовать для перехвата нулевых ссылок. Он смоделирован по той же концепции, что и &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1b22ef513641d8af3ca046740205bbee48335bff" translate="yes" xml:space="preserve">
          <source>Or you can even use it when the method just returns &lt;code&gt;T&lt;/code&gt; (in this case &lt;code&gt;Person&lt;/code&gt;) by doing a cast. For example, the following code would just like the code above:</source>
          <target state="translated">Или вы можете даже использовать его, когда метод просто возвращает &lt;code&gt;T&lt;/code&gt; (в данном случае &lt;code&gt;Person&lt;/code&gt; ), выполняя приведение. Например, следующий код будет похож на код выше:</target>
        </trans-unit>
        <trans-unit id="c9a30ba5e221a0e082315c528b339ab02883ea86" translate="yes" xml:space="preserve">
          <source>Otherwise, the variable name will be assigned the value of the p.Spouse.FirstName.</source>
          <target state="translated">В противном случае,имени переменной будет присвоено значение p.Spouse.FirstName.</target>
        </trans-unit>
        <trans-unit id="350349ce41ad9ae3414e0ee6f0cc9d8fdd70adfe" translate="yes" xml:space="preserve">
          <source>Poorly Implemented Try/Catch</source>
          <target state="translated">Плохо реализованная система TryCatch</target>
        </trans-unit>
        <trans-unit id="cf56bb150b35de64b7d13c5c15cc44a04165e6c6" translate="yes" xml:space="preserve">
          <source>Possibly, other code prematurely invalidated an object still in use</source>
          <target state="translated">Возможно,другой код преждевременно признал недействительным еще используемый объект</target>
        </trans-unit>
        <trans-unit id="49dadac90d9e655d655da0a9465c937e3e41e55d" translate="yes" xml:space="preserve">
          <source>Range Variable (Indirect/Deferred)</source>
          <target state="translated">Переменная диапазона (IndirectDeferred)</target>
        </trans-unit>
        <trans-unit id="7bbbd80923d138130436a31cdb61e2a69e969c03" translate="yes" xml:space="preserve">
          <source>Rather than indirect references by name using the form's &lt;code&gt;Controls&lt;/code&gt; collection, use the control reference:</source>
          <target state="translated">Вместо косвенных ссылок по имени, используя коллекцию &lt;code&gt;Controls&lt;/code&gt; формы, используйте ссылку control:</target>
        </trans-unit>
        <trans-unit id="517a0d09eeac328a5dcd1752d817bf8b7bd38630" translate="yes" xml:space="preserve">
          <source>Referencing array elements later will result in an NRE. If you do this in &lt;code&gt;Form_Load&lt;/code&gt;, due to an odd bug, the IDE &lt;em&gt;may not&lt;/em&gt; report the exception when it happens. The exception will pop up &lt;em&gt;later&lt;/em&gt; when your code tries to use the array. This &quot;silent exception&quot; is &lt;a href=&quot;https://stackoverflow.com/a/4934010/1070452&quot;&gt;detailed in this post&lt;/a&gt;. For our purposes, the key is that when something catastrophic happens while creating a form (&lt;code&gt;Sub New&lt;/code&gt; or &lt;code&gt;Form Load&lt;/code&gt; event), exceptions may go unreported, the code exits the procedure and just displays the form.</source>
          <target state="translated">Ссылка на элементы массива позже приведет к NRE. Если вы сделаете это в &lt;code&gt;Form_Load&lt;/code&gt; из-за странной ошибки, IDE &lt;em&gt;может не&lt;/em&gt; сообщить об исключении, когда это произойдет. Исключение появится &lt;em&gt;позже,&lt;/em&gt; когда ваш код попытается использовать массив. Это &amp;laquo;тихое исключение&amp;raquo; &lt;a href=&quot;https://stackoverflow.com/a/4934010/1070452&quot;&gt;подробно описано в этом посте&lt;/a&gt; . Для наших целей ключевым моментом является то, что когда что-то катастрофическое происходит при создании формы (событие &lt;code&gt;Sub New&lt;/code&gt; или &lt;code&gt;Form Load&lt;/code&gt; ), исключения могут не сообщаться, код выходит из процедуры и просто отображает форму.</target>
        </trans-unit>
        <trans-unit id="d7961680dc43f2fb54210f44d5d5893f415a97ea" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;Exit Function&lt;/code&gt; in the function with &lt;code&gt;Return bList&lt;/code&gt;. Returning an &lt;em&gt;empty&lt;/em&gt;&lt;code&gt;List&lt;/code&gt; is not the same as returning &lt;code&gt;Nothing&lt;/code&gt;. If there is a chance that a returned object can be &lt;code&gt;Nothing&lt;/code&gt;, test before using it:</source>
          <target state="translated">Замените &lt;code&gt;Exit Function&lt;/code&gt; в функции на &lt;code&gt;Return bList&lt;/code&gt; . Возврат &lt;em&gt;пустого&lt;/em&gt; &lt;code&gt;List&lt;/code&gt; - это не то же самое, что возврат &lt;code&gt;Nothing&lt;/code&gt; . Если есть вероятность, что возвращаемый объект может быть &lt;code&gt;Nothing&lt;/code&gt; , протестируйте его перед использованием:</target>
        </trans-unit>
        <trans-unit id="e09009f0be2bc5dc475d39c72cbad2457332d844" translate="yes" xml:space="preserve">
          <source>Scope in Visual Basic</source>
          <target state="translated">Область применения визуальной основы</target>
        </trans-unit>
        <trans-unit id="ec36826e04a6ea83960855360f7576fa1a70dea9" translate="yes" xml:space="preserve">
          <source>See &quot;&lt;a href=&quot;https://stackoverflow.com/questions/19314340/nullreferenceexception-thrown-when-testing-custom-authorizationattribute&quot;&gt;NullReferenceException thrown when testing custom AuthorizationAttribute&lt;/a&gt;&quot; for a somewhat verbose example.</source>
          <target state="translated">См. &amp;laquo; &lt;a href=&quot;https://stackoverflow.com/questions/19314340/nullreferenceexception-thrown-when-testing-custom-authorizationattribute&quot;&gt;NullReferenceException, генерируемое при тестировании пользовательского AuthorizationAttribute&lt;/a&gt; &amp;raquo; для несколько подробного примера.</target>
        </trans-unit>
        <trans-unit id="dee0432b1dfd3821074c0b47888585c85bdf5bb0" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Data.DataTable(v=vs.110).aspx&quot;&gt;DataTable Class&lt;/a&gt;.</source>
          <target state="translated">Смотрите также &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Data.DataTable(v=vs.110).aspx&quot;&gt;DataTable Class&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">См.также:</target>
        </trans-unit>
        <trans-unit id="b81624007a72ba2076c9759224672d60d8e74940" translate="yes" xml:space="preserve">
          <source>Since VB is managing Settings for you, it is reasonable to expect it to initialize the collection. It will, but only if you have previously added an initial entry to the collection (in the Settings editor). Since the collection is (apparently) initialized when an item is added, it remains &lt;code&gt;Nothing&lt;/code&gt; when there are no items in the Settings editor to add.</source>
          <target state="translated">Поскольку VB управляет настройками для вас, разумно ожидать, что он инициализирует коллекцию. Это произойдет, но только если вы ранее добавили начальную запись в коллекцию (в редакторе настроек). Поскольку коллекция (по-видимому) инициализируется при добавлении элемента, она остается &lt;code&gt;Nothing&lt;/code&gt; если в редакторе настроек нет элементов, которые можно добавить.</target>
        </trans-unit>
        <trans-unit id="5e1ee4902767b648a32002c3f0eac6e8212d4c61" translate="yes" xml:space="preserve">
          <source>Since no other code in your &lt;code&gt;Sub New&lt;/code&gt; or &lt;code&gt;Form Load&lt;/code&gt; event will run after the NRE, &lt;em&gt;a great many other things&lt;/em&gt; can be left uninitialized.</source>
          <target state="translated">Поскольку никакой другой код в вашем событии &lt;code&gt;Sub New&lt;/code&gt; или &lt;code&gt;Form Load&lt;/code&gt; не будет выполняться после NRE, &lt;em&gt;многие другие вещи&lt;/em&gt; можно оставить неинициализированными.</target>
        </trans-unit>
        <trans-unit id="169ef3e9a5e6d08f8ec9f775f25ef7ca8fe0ba80" translate="yes" xml:space="preserve">
          <source>Since the problem is an object reference which is &lt;code&gt;Nothing&lt;/code&gt;, the answer is to examine them to find out which one. Then determine why it is not initialized. Hold the mouse over the various variables and Visual Studio (VS) will show their values - the culprit will be &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">Так как проблема - ссылка на объект, которая является &lt;code&gt;Nothing&lt;/code&gt; , ответ состоит в том, чтобы исследовать их, чтобы выяснить, какой. Затем определите, почему он не инициализирован. Наведите указатель мыши на различные переменные, и Visual Studio (VS) покажет их значения - виновником будет &lt;code&gt;Nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5af1e9a2d60a99283e7a7af80fb60c02d4755e0" translate="yes" xml:space="preserve">
          <source>Since this uses one table, using &lt;code&gt;Tables(0)&lt;/code&gt; will avoid spelling errors.  Examining &lt;code&gt;Rows.Count&lt;/code&gt; can also help:</source>
          <target state="translated">Поскольку для этого используется одна таблица, использование &lt;code&gt;Tables(0)&lt;/code&gt; позволит избежать орфографических ошибок. Изучение &lt;code&gt;Rows.Count&lt;/code&gt; также может помочь:</target>
        </trans-unit>
        <trans-unit id="5fb8e569fb6ed72a6dffcc33b03fceee972649a2" translate="yes" xml:space="preserve">
          <source>So how to tackle this:</source>
          <target state="translated">Итак,как с этим справиться:</target>
        </trans-unit>
        <trans-unit id="0af6f84e1abe20a8c228b77e487571323c47990e" translate="yes" xml:space="preserve">
          <source>So, as a practice we should always use null check, before accessing properties in such objects (specially in generic)</source>
          <target state="translated">Поэтому в качестве практики всегда следует использовать нулевую проверку,перед тем как обращаться к свойствам в таких объектах (особенно в общих)</target>
        </trans-unit>
        <trans-unit id="728a2ccae6943f95d4a0778979a96e78b85be334" translate="yes" xml:space="preserve">
          <source>So, if you're dealing with &lt;strong&gt;value types&lt;/strong&gt;, NullReferenceExceptions can &lt;strong&gt;not&lt;/strong&gt; occur. Though you need to keep alert when dealing with &lt;strong&gt;reference types&lt;/strong&gt;!</source>
          <target state="translated">Таким образом, если вы имеете дело с &lt;strong&gt;типами значений&lt;/strong&gt; , NullReferenceExceptions &lt;strong&gt;не&lt;/strong&gt; может возникнуть. Хотя вы должны быть начеку, когда имеете дело с &lt;strong&gt;ссылочными типами&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="3fef728484bb42f677ee7c22d16e57e13b623b0b" translate="yes" xml:space="preserve">
          <source>Some common scenarios where the exception can be thrown:</source>
          <target state="translated">Некоторые распространенные сценарии,в которых можно бросить исключение:</target>
        </trans-unit>
        <trans-unit id="270f67be70dbe22b11e82aa389399daab08d5ed7" translate="yes" xml:space="preserve">
          <source>Something which your code assumed would initialize an object, did not</source>
          <target state="translated">То,что,как предполагал ваш код,инициализирует объект,не было</target>
        </trans-unit>
        <trans-unit id="d79169ce047a865f22ceedf2f516d3f6a8bd12b3" translate="yes" xml:space="preserve">
          <source>Something you assumed would perform flawlessly to return an initialized object to your code, did not.</source>
          <target state="translated">То,что вы предполагали выполнить безупречно,чтобы вернуть инициализированный объект в ваш код,не выполнило.</target>
        </trans-unit>
        <trans-unit id="7b881a3646ad1ece01b3005831c5797e83c52c23" translate="yes" xml:space="preserve">
          <source>Sometimes the boxing happens in another way. For example with this non-generic extension method:</source>
          <target state="translated">Иногда бокс происходит по-другому.Например,с помощью этого неэнергетического метода расширения:</target>
        </trans-unit>
        <trans-unit id="c8202db459212644c10dde57d8e4df666ce482d5" translate="yes" xml:space="preserve">
          <source>Special techniques for debugging and fixing null derefs in iterators</source>
          <target state="translated">Специальные методы отладки и фиксации нулевого растрескивания в итераторах</target>
        </trans-unit>
        <trans-unit id="0fbbe68dcced5d9fa19046eaf6118ab8f81482e2" translate="yes" xml:space="preserve">
          <source>Specifically, in &lt;code&gt;HttpContext.Current.User.Identity.Name&lt;/code&gt;, the &lt;code&gt;HttpContext.Current&lt;/code&gt; could be null, or the &lt;code&gt;User&lt;/code&gt; property could be null, or the &lt;code&gt;Identity&lt;/code&gt; property could be null.</source>
          <target state="translated">В частности, в &lt;code&gt;HttpContext.Current.User.Identity.Name&lt;/code&gt; значение &lt;code&gt;HttpContext.Current&lt;/code&gt; может быть нулевым, либо свойство &lt;code&gt;User&lt;/code&gt; может быть нулевым, либо свойство &lt;code&gt;Identity&lt;/code&gt; может быть нулевым.</target>
        </trans-unit>
        <trans-unit id="f5dea8e13e62a3f32c925f340dc736efda53d43f" translate="yes" xml:space="preserve">
          <source>Suppose I have a class and member method in it. I have not instantiated my class but only named my class. Now if I try to use the method, the compiler will throw an error or issue a warning (depending on the compiler).</source>
          <target state="translated">Предположим,у меня есть класс и метод членства в нем.Я не инстанцировал свой класс,а только назвал свой класс.Теперь,если я попытаюсь использовать метод,компилятор выдаст ошибку или предупреждение (в зависимости от компилятора).</target>
        </trans-unit>
        <trans-unit id="a9bfffacd695cafe387b5dba29e8a53f54d17c9a" translate="yes" xml:space="preserve">
          <source>Suppose you have a web form Contact.aspx whose codebehind class is Contact and you have an entity name Contact.</source>
          <target state="translated">Предположим,у вас есть веб-форма Contact.aspx,чей кодовым классом является Contact,и у вас есть название организации Contact.</target>
        </trans-unit>
        <trans-unit id="a32dcf6bc661323f00cb04b17bca14992a13218c" translate="yes" xml:space="preserve">
          <source>System.NullReferenceException: Object reference not set to an instance
  of an object. at Program.Main()</source>
          <target state="translated">Система.Нульрефлексотерапия:Ссылка на объект не установлена на экземпляр объекта.в Program.Main()</target>
        </trans-unit>
        <trans-unit id="61b52702efd8978d72bc6dd4556000b0c5302229" translate="yes" xml:space="preserve">
          <source>Take the time required to understand the cause of the exception. Inspect for null expressions. Inspect the previous expressions which could have resulted in such null expressions. Add &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/ktf38f66(v=vs.90)&quot;&gt;breakpoints&lt;/a&gt; and step through the program as appropriate. &lt;em&gt;Use the debugger.&lt;/em&gt;</source>
          <target state="translated">Потратьте время, необходимое для понимания причины исключения. Осмотрите для нулевых выражений. Проверьте предыдущие выражения, которые могли привести к таким нулевым выражениям. Добавьте &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/ktf38f66(v=vs.90)&quot;&gt;точки останова&lt;/a&gt; и, при необходимости, выполните программу. &lt;em&gt;Используйте отладчик.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96355bac807e2bf7c816f87187a186dfb05609b3" translate="yes" xml:space="preserve">
          <source>That is, make a private helper method that has the iterator block logic, and a public surface method that does the null check and returns the iterator.  Now when &lt;code&gt;GetFrobs&lt;/code&gt; is called, the null check happens immediately, and then &lt;code&gt;GetFrobsForReal&lt;/code&gt; executes when the sequence is iterated.</source>
          <target state="translated">То есть создайте частный вспомогательный метод, который имеет блочную логику итератора, и метод открытой поверхности, который выполняет нулевую проверку и возвращает итератор. Теперь, когда &lt;code&gt;GetFrobs&lt;/code&gt; , проверка нуля происходит немедленно, и затем &lt;code&gt;GetFrobsForReal&lt;/code&gt; выполняется, когда последовательность повторяется.</target>
        </trans-unit>
        <trans-unit id="c98e5a07997fb98921d015b9962a6fe887151a12" translate="yes" xml:space="preserve">
          <source>That means if any member which doesn&amp;rsquo;t hold any value and we are making that member to perform certain task then the system will undoubtedly toss a message and say-</source>
          <target state="translated">Это означает, что если какой-либо участник, который не имеет никакого значения, и мы заставляем этого участника выполнять определенную задачу, то система, несомненно, бросит сообщение и скажет:</target>
        </trans-unit>
        <trans-unit id="cd6b57e6915e732c6a3454d47a45928771b568d1" translate="yes" xml:space="preserve">
          <source>That will throw the error because while I've declared the variable &quot;&lt;code&gt;connection&lt;/code&gt;&quot;, it's not pointed to anything. When I try to call the member &quot;&lt;code&gt;Open&lt;/code&gt;&quot;, there's no reference for it to resolve, and it will throw the error.</source>
          <target state="translated">Это приведет к ошибке, потому что, хотя я объявил переменную &amp;laquo; &lt;code&gt;connection&lt;/code&gt; &amp;raquo;, она ни на что не указана. Когда я пытаюсь вызвать члена &amp;laquo; &lt;code&gt;Open&lt;/code&gt; &amp;raquo;, нет ссылки для его разрешения, и он выдаст ошибку.</target>
        </trans-unit>
        <trans-unit id="af16544bdee6b293bf4ee765cfb10b13b80b318a" translate="yes" xml:space="preserve">
          <source>That's why dereferencing both a null pointer and a null reference produces the same exception.</source>
          <target state="translated">Поэтому разыменование и нулевого указателя,и нулевой ссылки приводит к одному и тому же исключению.</target>
        </trans-unit>
        <trans-unit id="832f18980c9adec58ccfc7eafce613c988307af0" translate="yes" xml:space="preserve">
          <source>The .NET runtime will throw a NullReferenceException when you attempt to perform an action on something which hasn't been instantiated i.e. the code above.</source>
          <target state="translated">Время выполнения .NET вызовет NullReferenceException,когда вы попытаетесь выполнить действие над чем-то,что не было инстанциировано,т.е.над приведенным выше кодом.</target>
        </trans-unit>
        <trans-unit id="26534d5f78e239955916af7b305fc5b41ba2ea2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DataAdapter&lt;/code&gt; will provide &lt;code&gt;TableNames&lt;/code&gt; as shown in the previous example, but it does not parse names from the SQL or database table. As a result, &lt;code&gt;ds.Tables(&quot;TICKET_RESERVATION&quot;)&lt;/code&gt; references a non-existent table.</source>
          <target state="translated">&lt;code&gt;DataAdapter&lt;/code&gt; предоставит &lt;code&gt;TableNames&lt;/code&gt; , как показано в предыдущем примере, но он не анализирует имена из таблицы SQL или базы данных. В результате &lt;code&gt;ds.Tables(&quot;TICKET_RESERVATION&quot;)&lt;/code&gt; ссылается на несуществующую таблицу.</target>
        </trans-unit>
        <trans-unit id="4e757d5d15663001bb33deeec07e2827ba5bd3a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsDBNull&lt;/code&gt; function is used to test if a &lt;em&gt;value&lt;/em&gt; equals &lt;code&gt;System.DBNull&lt;/code&gt;:  &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/tckcces5(v=vs.90)&quot;&gt;From MSDN:&lt;/a&gt;</source>
          <target state="translated">Функция &lt;code&gt;IsDBNull&lt;/code&gt; используется для проверки того, равно ли &lt;em&gt;значение&lt;/em&gt; &lt;code&gt;System.DBNull&lt;/code&gt; : &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/tckcces5(v=vs.90)&quot;&gt;из MSDN:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b413c4771f93ecdb1da4953c33951691d69e4d43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;New&lt;/code&gt; operator can often be used to create the instance when you declare it:</source>
          <target state="translated">Оператор &lt;code&gt;New&lt;/code&gt; часто можно использовать для создания экземпляра при его объявлении:</target>
        </trans-unit>
        <trans-unit id="40dbae9f26db30254b9c9f1a9df041f25f4ae4cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NullReference Exception&lt;/code&gt; for &lt;strong&gt;Visual Basic&lt;/strong&gt; is no different from the one in &lt;strong&gt;C#&lt;/strong&gt;. After all, they are both reporting the same exception defined in the .NET Framework which they both use. Causes unique to Visual Basic are rare (perhaps only one).</source>
          <target state="translated">&lt;code&gt;NullReference Exception&lt;/code&gt; для &lt;strong&gt;Visual Basic&lt;/strong&gt; ничем не отличается от &lt;strong&gt;C #&lt;/strong&gt; . В конце концов, они оба сообщают об одном и том же исключении, определенном в .NET Framework, которое они оба используют. Причины, уникальные для Visual Basic, встречаются редко (возможно, только одна).</target>
        </trans-unit>
        <trans-unit id="20d435cc2ffcce4a30d45f389b288f97cfa9298a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new Person&lt;/code&gt; only creates an instance of &lt;code&gt;Person&lt;/code&gt;, but the &lt;code&gt;Books&lt;/code&gt; collection is still &lt;code&gt;null&lt;/code&gt;. The collection &lt;code&gt;Initializer&lt;/code&gt; syntax does not create a collection
for &lt;code&gt;p1.Books&lt;/code&gt;, it only translates to the &lt;code&gt;p1.Books.Add(...)&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;new Person&lt;/code&gt; только создает экземпляр &lt;code&gt;Person&lt;/code&gt; , но коллекция &lt;code&gt;Books&lt;/code&gt; по-прежнему &lt;code&gt;null&lt;/code&gt; . Синтаксис &lt;code&gt;Initializer&lt;/code&gt; коллекции не создает коллекцию для &lt;code&gt;p1.Books&lt;/code&gt; , он только транслируется в &lt;code&gt;p1.Books.Add(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0b42fc2efda212a3943ac23d1a88e3d1f5590dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runtime&lt;/code&gt; throwing a &lt;code&gt;NullReferenceException&lt;/code&gt;&lt;strong&gt;always&lt;/strong&gt; means the same thing: you are trying to use a reference, and the reference is not initialized (or it was &lt;em&gt;once&lt;/em&gt; initialized, but is &lt;em&gt;no longer&lt;/em&gt; initialized).</source>
          <target state="translated">Время &lt;code&gt;runtime&lt;/code&gt; выбрасывающее &lt;code&gt;NullReferenceException&lt;/code&gt; &lt;strong&gt;всегда&lt;/strong&gt; означает одно и то же: вы пытаетесь использовать ссылку, и ссылка не инициализируется (или была &lt;em&gt;однажды&lt;/em&gt; инициализирована, но &lt;em&gt;больше не&lt;/em&gt; инициализирована).</target>
        </trans-unit>
        <trans-unit id="49a69af3cb15571971e9fd0f2918ddd41cf47307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;somevar&lt;/code&gt; assignment will result in an immediate NRE because Nothing doesn't have a &lt;code&gt;.Text&lt;/code&gt; property</source>
          <target state="translated">Назначение &lt;code&gt;somevar&lt;/code&gt; приведет к немедленному NRE, потому что Nothing не имеет свойства &lt;code&gt;.Text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d5d5590cc424a0742ec3b68941443b7a51567cc" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Remedy&lt;/strong&gt; is the same, reference the table by index:</source>
          <target state="translated">&lt;strong&gt;Средство не изменилось&lt;/strong&gt; , обратитесь к таблице по индексу:</target>
        </trans-unit>
        <trans-unit id="3040c6289873dac88d88f00dfa3143d8958589ea" translate="yes" xml:space="preserve">
          <source>The Array will contain five elements of Nothing</source>
          <target state="translated">Массив будет содержать пять элементов &quot;Ничего&quot;.</target>
        </trans-unit>
        <trans-unit id="27ceb372d3a055414ac4ebce858ea4ad711a0987" translate="yes" xml:space="preserve">
          <source>The DGV has a few quirks seen periodically:</source>
          <target state="translated">У DGV есть несколько причуд,которые мы периодически видим:</target>
        </trans-unit>
        <trans-unit id="c70e919024ee1fab6a7f20fb2647ea7464472447" translate="yes" xml:space="preserve">
          <source>The DataGridView</source>
          <target state="translated">DataGridView</target>
        </trans-unit>
        <trans-unit id="ef89f949d60a7ce3ba16474314cece6c25c1b417" translate="yes" xml:space="preserve">
          <source>The System.DBNull value indicates that the Object represents missing or non-existent data. DBNull is not the same as Nothing, which indicates that a variable has not yet been initialized.</source>
          <target state="translated">Значение System.DBNull указывает на то,что Объект представляет отсутствующие или несуществующие данные.DBNull не то же самое,что Nothing,что указывает на то,что переменная еще не инициализирована.</target>
        </trans-unit>
        <trans-unit id="3fab983167187e8d3c1de769d9fd8889b4da2253" translate="yes" xml:space="preserve">
          <source>The above code shows simple string which is assigned with a &lt;strong&gt;null&lt;/strong&gt; value.</source>
          <target state="translated">Приведенный выше код показывает простую строку, которой присваивается &lt;strong&gt;нулевое&lt;/strong&gt; значение.</target>
        </trans-unit>
        <trans-unit id="17d03251d7278b73c29dd924064c9cb221dda373" translate="yes" xml:space="preserve">
          <source>The array code may not be out of the woods yet. Any controls which are in a container control (like a &lt;code&gt;GroupBox&lt;/code&gt; or &lt;code&gt;Panel&lt;/code&gt;) will not be found in &lt;code&gt;Me.Controls&lt;/code&gt;; they will be in the Controls collection of that Panel or GroupBox. Nor will a control be returned when the control name is misspelled (&lt;code&gt;&quot;TeStBox2&quot;&lt;/code&gt;). In such cases, &lt;code&gt;Nothing&lt;/code&gt; will again be stored in those array elements and an NRE will result when you attempt to reference it.</source>
          <target state="translated">Код массива еще может быть не в лесу. Любые элементы управления, которые находятся в элементе управления контейнера (например, &lt;code&gt;GroupBox&lt;/code&gt; или &lt;code&gt;Panel&lt;/code&gt; ), не будут найдены в &lt;code&gt;Me.Controls&lt;/code&gt; ; они будут в коллекции Controls этой Panel или GroupBox. Также не будет возвращен элемент управления, если имя &lt;code&gt;&quot;TeStBox2&quot;&lt;/code&gt; управления написано с ошибкой ( &quot;TeStBox2&quot; ). В таких случаях &lt;code&gt;Nothing&lt;/code&gt; будет снова сохранено в этих элементах массива, и при попытке сослаться на него будет получено NRE.</target>
        </trans-unit>
        <trans-unit id="9152dbff2da4b545031d214da21c705228394a13" translate="yes" xml:space="preserve">
          <source>The array has been created, but the &lt;code&gt;Foo&lt;/code&gt; objects in it have not.</source>
          <target state="translated">Массив создан, а объекты &lt;code&gt;Foo&lt;/code&gt; в нем - нет.</target>
        </trans-unit>
        <trans-unit id="503f97cf7bd74b54164bcdafbce1e18337fefeac" translate="yes" xml:space="preserve">
          <source>The code is only testing &lt;code&gt;Items&lt;/code&gt; while both &lt;code&gt;myFoo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; may also be Nothing. The &lt;strong&gt;remedy&lt;/strong&gt; is to test the entire chain or path of objects one at a time:</source>
          <target state="translated">Код только тестирует &lt;code&gt;Items&lt;/code&gt; то время как &lt;code&gt;myFoo&lt;/code&gt; и &lt;code&gt;Bar&lt;/code&gt; также могут иметь значение Nothing. Средство &lt;strong&gt;защиты&lt;/strong&gt; состоит в том, чтобы проверить всю цепочку или путь объектов по одному:</target>
        </trans-unit>
        <trans-unit id="463bfd62c8f05004461fb5a31b8995846405c429" translate="yes" xml:space="preserve">
          <source>The constructor for the &lt;code&gt;ArgumentNullException&lt;/code&gt; even takes the name of the parameter and a message as arguments so you can tell the developer exactly what the problem is.</source>
          <target state="translated">Конструктор для &lt;code&gt;ArgumentNullException&lt;/code&gt; даже принимает имя параметра и сообщение в качестве аргумента, чтобы вы могли точно сказать разработчику, в чем заключается проблема.</target>
        </trans-unit>
        <trans-unit id="3316f1a701fde7c120bf71968a77f55f36491fce" translate="yes" xml:space="preserve">
          <source>The correct fix is:</source>
          <target state="translated">Правильное исправление:</target>
        </trans-unit>
        <trans-unit id="1294e0c3d65f0d8b731cd2b09629341a194dc6ce" translate="yes" xml:space="preserve">
          <source>The data Type and array size are inferred from the data being assigned. Class/Module level declarations still require &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; with &lt;code&gt;Option Strict&lt;/code&gt;:</source>
          <target state="translated">Тип данных и размер массива выводятся из назначаемых данных. Для объявлений уровня класса / модуля все еще требуется &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; с &lt;code&gt;Option Strict&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a67859648408e02bf57b5242710673d9d105f41" translate="yes" xml:space="preserve">
          <source>The developer is &lt;strong&gt;using &lt;code&gt;null&lt;/code&gt; intentionally to indicate there is no meaningful value available.&lt;/strong&gt; Note that C# has the concept of nullable datatypes for variables (like database tables can have nullable fields) - you can assign &lt;code&gt;null&lt;/code&gt; to them to indicate there is no value stored in it, for example &lt;code&gt;int? a = null;&lt;/code&gt; where the question mark indicates it is allowed to store null in variable &lt;code&gt;a&lt;/code&gt;. You can check that either with &lt;code&gt;if (a.HasValue) {...}&lt;/code&gt; or with &lt;code&gt;if (a==null) {...}&lt;/code&gt;. Nullable variables, like &lt;code&gt;a&lt;/code&gt; this example, allow to access the value via &lt;code&gt;a.Value&lt;/code&gt; explicitly, or just as normal via &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Разработчик &lt;strong&gt;намеренно использует значение &lt;code&gt;null&lt;/code&gt; , чтобы указать, что значимых доступных значений нет.&lt;/strong&gt; Обратите внимание, что в C # есть концепция обнуляемых типов данных для переменных (например, таблицы базы данных могут иметь обнуляемые поля) - вы можете присвоить им значение &lt;code&gt;null&lt;/code&gt; , чтобы указать, что в нем нет значения, например &lt;code&gt;int? a = null;&lt;/code&gt; а = ноль; где знак вопроса указывает, что разрешено хранить ноль в переменной &lt;code&gt;a&lt;/code&gt; . Вы можете проверить это либо с помощью &lt;code&gt;if (a.HasValue) {...}&lt;/code&gt; либо с помощью &lt;code&gt;if (a==null) {...}&lt;/code&gt; . Обнуляемые переменные, как и &lt;code&gt;a&lt;/code&gt; этом примере, позволяют получить доступ к значению через &lt;code&gt;a.Value&lt;/code&gt; явно или просто как обычно через &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45a964d78da459f6bbd37b8cd232d3a6efef6380" translate="yes" xml:space="preserve">
          <source>The error line &quot;Object reference not set to an instance of an object.
&quot; states that you have not assigned instance object to a object reference and still you are accessing properies/methods of that object.</source>
          <target state="translated">Строка ошибки &quot;Ссылка на объект не установлена на экземпляр объекта.&quot; указывает на то,что вы не назначили экземпляр объекта ссылкой на объект,и все равно имеете доступ к соответствующим методам этого объекта.</target>
        </trans-unit>
        <trans-unit id="a400e3953b7fb9b7c815f1ce88a4ab2b01f595e6" translate="yes" xml:space="preserve">
          <source>The error occurs when both the entity and codebehind class are in same namespace.
To fix this, rename the entity class or the codebehind class for Contact.aspx.</source>
          <target state="translated">Ошибка возникает в том случае,когда и сущность,и класс codebehind находятся в одном и том же пространстве имён.Чтобы исправить это,переименуйте класс сущности или класс codebehind для Contact.aspx.</target>
        </trans-unit>
        <trans-unit id="895203d5cc7b55ecb7ef70317a104cba1837e261" translate="yes" xml:space="preserve">
          <source>The examples (from Stack&amp;nbsp; Overflow posts) do not always show the best way to do something in the first place.</source>
          <target state="translated">Примеры (из сообщений Stack Overflow) не всегда показывают лучший способ сделать что-либо в первую очередь.</target>
        </trans-unit>
        <trans-unit id="d1d89f5634b915a9e16a0aaaf5998b7a175005a7" translate="yes" xml:space="preserve">
          <source>The exception error is:</source>
          <target state="translated">Ошибка исключения:</target>
        </trans-unit>
        <trans-unit id="4dabb60bda5cb5e73ecf06dcad355e8e1b245e9c" translate="yes" xml:space="preserve">
          <source>The exception itself says that something is being referred but whose value is not being set. So this denotes that it only occurs while using reference types as Value types are non-nullable.</source>
          <target state="translated">В самом исключении говорится,что что-то упоминается,но чье значение не устанавливается.Это означает,что это происходит только при использовании типов ссылок,так как типы Value не являются исчерпывающими.</target>
        </trans-unit>
        <trans-unit id="06815801582cc6befb5ef98b61f02e87744088ac" translate="yes" xml:space="preserve">
          <source>The hardest one .. if the &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;GC&lt;/a&gt;&lt;/strong&gt; collected the object already... This generally occurs if you are trying to find an object using strings... That is, finding it by name of the object then it may happen that the GC might already cleaned it up... This is hard to find and will become quite a problem... A better way to tackle this is do null checks wherever necessary during the development process. This will save you a lot of time.</source>
          <target state="translated">Сложнее всего ... если &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;GC уже&lt;/a&gt;&lt;/strong&gt; собрал объект ... Обычно это происходит, если вы пытаетесь найти объект с помощью строк ... То есть, находя его по имени объекта, может случиться так, что GC может уже Вычистил это ... Это трудно найти и станет большой проблемой ... Лучший способ справиться с этим - делать нулевые проверки везде, где это необходимо в процессе разработки. Это сэкономит вам много времени.</target>
        </trans-unit>
        <trans-unit id="6fe9c46a1f96250f3a78f255ee7a539166e5eefe" translate="yes" xml:space="preserve">
          <source>The message &lt;em&gt;&quot;Object not set to an instance of Object&quot;&lt;/em&gt; means you are trying to use an object which has not been initialized. This boils down to one of these:</source>
          <target state="translated">Сообщение &lt;em&gt;&amp;laquo;Объект не установлен в экземпляр объекта&amp;raquo;&lt;/em&gt; означает, что вы пытаетесь использовать объект, который не был инициализирован. Это сводится к одному из них:</target>
        </trans-unit>
        <trans-unit id="7e3ca54b85861772b0461d9717c527d72a64967f" translate="yes" xml:space="preserve">
          <source>The nested collection &lt;code&gt;Initializers&lt;/code&gt; behave the same:</source>
          <target state="translated">&lt;code&gt;Initializers&lt;/code&gt; вложенной коллекции ведут себя так же:</target>
        </trans-unit>
        <trans-unit id="90aa4a0c7a11c901e2c17878dabdd430757e21cc" translate="yes" xml:space="preserve">
          <source>The nullable annotation context and nullable warning context can be set for a project using the &lt;code&gt;Nullable&lt;/code&gt; element in your &lt;code&gt;csproj&lt;/code&gt; file. This element configures how the compiler interprets the nullability of types and what warnings are generated. Valid settings are:</source>
          <target state="translated">Обнуляемый контекст аннотации и обнуляемый контекст предупреждения могут быть установлены для проекта с использованием элемента &lt;code&gt;Nullable&lt;/code&gt; в вашем &lt;code&gt;csproj&lt;/code&gt; . Этот элемент определяет, как компилятор интерпретирует обнуляемость типов и какие предупреждения генерируются. Допустимые настройки:</target>
        </trans-unit>
        <trans-unit id="a10b33de1b42bbbc51b19833cb2f573dc939676f" translate="yes" xml:space="preserve">
          <source>The plain versions &lt;code&gt;First()&lt;/code&gt; and &lt;code&gt;Single()&lt;/code&gt; throw exceptions when there is nothing. The &quot;OrDefault&quot; versions return null in that case. So be aware of that.</source>
          <target state="translated">Простые версии &lt;code&gt;First()&lt;/code&gt; и &lt;code&gt;Single()&lt;/code&gt; генерируют исключения, когда ничего нет. Версии &amp;laquo;OrDefault&amp;raquo; в этом случае возвращают ноль. Так что знайте об этом.</target>
        </trans-unit>
        <trans-unit id="ca0d4b830b1ca78cc1cd2b85b0b059562a5a92dc" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;Dim&lt;/code&gt; does not create a CashRegister &lt;em&gt;object&lt;/em&gt;; it only declares a variable named &lt;code&gt;reg&lt;/code&gt; of that Type. &lt;em&gt;Declaring&lt;/em&gt; an object variable and creating an &lt;em&gt;instance&lt;/em&gt; are two different things.</source>
          <target state="translated">Проблема в том, что &lt;code&gt;Dim&lt;/code&gt; не создает &lt;em&gt;объект&lt;/em&gt; CashRegister; он только объявляет переменную с именем &lt;code&gt;reg&lt;/code&gt; этого типа. &lt;em&gt;Объявление&lt;/em&gt; переменной объекта и создание &lt;em&gt;экземпляра&lt;/em&gt; - это две разные вещи.</target>
        </trans-unit>
        <trans-unit id="f57a9af331b2b384f5e9bbf25e52891735f99da4" translate="yes" xml:space="preserve">
          <source>The rest of this article goes into more detail and shows mistakes that many programmers often make which can lead to a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">В остальной части этой статьи более подробно рассматриваются ошибки, которые часто допускают многие программисты, что может привести к &lt;code&gt;NullReferenceException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d27e02a7560754b5c14948489cc1146ab300619d" translate="yes" xml:space="preserve">
          <source>The result is that the name will be null when p is null or when p.Spouse is null.</source>
          <target state="translated">В результате имя будет нулевым,когда p будет нулевым или когда p.Spouse будет нулевым.</target>
        </trans-unit>
        <trans-unit id="09d1d7d139d2f9ffa7cf279ad2ecc6cf210c00d2" translate="yes" xml:space="preserve">
          <source>The same applies to nested object initializers:</source>
          <target state="translated">То же самое относится и к инициализаторам вложенных объектов:</target>
        </trans-unit>
        <trans-unit id="ed30a1778fd31736e38acd0c7306ed44aa097108" translate="yes" xml:space="preserve">
          <source>The shorthand to providing a default value when a &lt;code&gt;null&lt;/code&gt; is encountered:</source>
          <target state="translated">Сокращение для предоставления значения по умолчанию, когда встречается &lt;code&gt;null&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f4ffd808ec7172797ede1dca01b5953fc219db01" translate="yes" xml:space="preserve">
          <source>Then either &lt;a href=&quot;https://blogs.msdn.microsoft.com/zainnab/2010/11/01/start-debugging-vs-start-without-debugging/&quot;&gt;&lt;em&gt;Start with Debugging (F5)&lt;/em&gt;&lt;/a&gt; or &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/3s68z0b3.aspx&quot;&gt;&lt;em&gt;Attach [the VS Debugger] to Running Process&lt;/em&gt;&lt;/a&gt;. On occasion it may be useful to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.diagnostics.debugger.break(v=vs.110).aspx&quot;&gt;&lt;code&gt;Debugger.Break&lt;/code&gt;&lt;/a&gt;, which will prompt to launch the debugger.</source>
          <target state="translated">Затем либо &lt;a href=&quot;https://blogs.msdn.microsoft.com/zainnab/2010/11/01/start-debugging-vs-start-without-debugging/&quot;&gt;&lt;em&gt;начните с отладки (F5),&lt;/em&gt;&lt;/a&gt; либо &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/3s68z0b3.aspx&quot;&gt;&lt;em&gt;присоедините [отладчик VS] к запущенному процессу&lt;/em&gt;&lt;/a&gt; . Иногда может быть полезно использовать &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.diagnostics.debugger.break(v=vs.110).aspx&quot;&gt; &lt;code&gt;Debugger.Break&lt;/code&gt; &lt;/a&gt; , который предложит запустить отладчик.</target>
        </trans-unit>
        <trans-unit id="9cf2c6701fe17f333948c2b1849db6510ba64ad5" translate="yes" xml:space="preserve">
          <source>Then following code will throw a NullReferenceException when you call context.SaveChanges()</source>
          <target state="translated">Затем следующий код бросит NullReferenceException при вызове context.SaveChanges().</target>
        </trans-unit>
        <trans-unit id="7838ef23cdbcdcb9c6a670f31c478d1f79518c71" translate="yes" xml:space="preserve">
          <source>Then go into your script and type &lt;code&gt;rb = GetComponent&amp;lt;Rigidbody&amp;gt;();&lt;/code&gt;</source>
          <target state="translated">Затем войдите в свой скрипт и введите &lt;code&gt;rb = GetComponent&amp;lt;Rigidbody&amp;gt;();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad41fc4e6ef8e0d250fac274fb58d4f833539aab" translate="yes" xml:space="preserve">
          <source>There are also several libraries that can help. &quot;Resharper&quot; for example can provide you with warnings while you are writing code, especially if you use their attribute: &lt;a href=&quot;https://www.jetbrains.com/resharper/help/Reference__Code_Annotation_Attributes.html#NotNullAttribute&quot;&gt;NotNullAttribute&lt;/a&gt;</source>
          <target state="translated">Есть также несколько библиотек, которые могут помочь. Например, &amp;laquo;Resharper&amp;raquo; может выдавать вам предупреждения во время написания кода, особенно если вы используете их атрибут: &lt;a href=&quot;https://www.jetbrains.com/resharper/help/Reference__Code_Annotation_Attributes.html#NotNullAttribute&quot;&gt;NotNullAttribute&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbf732334378829eb2b72400cdd33b94ea5d2586" translate="yes" xml:space="preserve">
          <source>There are many good answers already here. You can also check more detailed description with examples on my &lt;a href=&quot;https://www.mistercode.net/2017/07/09/object-reference-not-set-to-an-instance-of-an-object/&quot;&gt;blog&lt;/a&gt;.</source>
          <target state="translated">Здесь уже есть много хороших ответов. Вы также можете проверить более подробное описание с примерами в моем &lt;a href=&quot;https://www.mistercode.net/2017/07/09/object-reference-not-set-to-an-instance-of-an-object/&quot;&gt;блоге&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="214fa86f68ca654e757c3e720dc78f2dd2fc2749" translate="yes" xml:space="preserve">
          <source>There are various ways and methods to avoid this renowned exception:</source>
          <target state="translated">Существуют различные способы и методы,чтобы избежать этого известного исключения:</target>
        </trans-unit>
        <trans-unit id="be839701a8b58386dc83c43578a529bbcc452e47" translate="yes" xml:space="preserve">
          <source>There is a lot of good answers here explaining what a null reference is and how to debug it. But there is very little on how to prevent the issue or at least make it easier to catch.</source>
          <target state="translated">Здесь много хороших ответов,объясняющих,что такое нулевая ссылка и как ее отлаживать.Но очень мало говорится о том,как предотвратить проблему или,по крайней мере,сделать ее легче поймать.</target>
        </trans-unit>
        <trans-unit id="7dbc715d0df7bdf0cd07c3dbe5ecb31f64abf37a" translate="yes" xml:space="preserve">
          <source>There is an extra comma in the SQL (after 'mailaddress') which results in an exception at &lt;code&gt;.ExecuteReader&lt;/code&gt;. After the &lt;code&gt;Catch&lt;/code&gt; does nothing, &lt;code&gt;Finally&lt;/code&gt; tries to perform clean up, but since you cannot &lt;code&gt;Close&lt;/code&gt; a null &lt;code&gt;DataReader&lt;/code&gt; object, a brand new &lt;code&gt;NullReferenceException&lt;/code&gt; results.</source>
          <target state="translated">В SQL есть дополнительная запятая (после 'mailaddress'), что приводит к исключению в &lt;code&gt;.ExecuteReader&lt;/code&gt; . После того, как &lt;code&gt;Catch&lt;/code&gt; ничего не делает, &lt;code&gt;Finally&lt;/code&gt; пытается выполнить очистку, но, поскольку вы не можете &lt;code&gt;Close&lt;/code&gt; нулевой объект &lt;code&gt;DataReader&lt;/code&gt; , возникает совершенно новое &lt;code&gt;NullReferenceException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee30cd268c28ea93084f9a9c56e3288e8f18511d" translate="yes" xml:space="preserve">
          <source>There's &quot;Microsoft Code Contracts&quot; where you use syntax like &lt;code&gt;Contract.Requires(obj != null)&lt;/code&gt; which gives you runtime and compile checking: &lt;a href=&quot;http://www.codeproject.com/Articles/103779/Introducing-Code-Contracts&quot;&gt;Introducing Code Contracts&lt;/a&gt;.</source>
          <target state="translated">Есть &amp;laquo;Microsoft Code Contracts&amp;raquo;, где вы используете синтаксис, такой как &lt;code&gt;Contract.Requires(obj != null)&lt;/code&gt; который дает вам время выполнения и проверку компиляции: &lt;a href=&quot;http://www.codeproject.com/Articles/103779/Introducing-Code-Contracts&quot;&gt;Введение в Code Contracts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4586f5d6a7aef8d40083704fd4255e79f766656f" translate="yes" xml:space="preserve">
          <source>There's also &quot;PostSharp&quot; which will allow you to just use attributes like this:</source>
          <target state="translated">Также есть &quot;PostSharp&quot;,который позволит вам просто использовать такие атрибуты:</target>
        </trans-unit>
        <trans-unit id="35e0b1c03698b5fbfb3417627f45417f72e5c0bb" translate="yes" xml:space="preserve">
          <source>These cases arise because of the special rules the runtime uses when boxing &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; instances.</source>
          <target state="translated">Эти случаи возникают из-за специальных правил, которые среда выполнения использует при &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; экземпляров Nullable &amp;lt;&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="7c521d1475010ead5d72d575d5eea6c50ec89923" translate="yes" xml:space="preserve">
          <source>These should be easy to find now that you know what you are looking for:</source>
          <target state="translated">Их должно быть легко найти теперь,когда ты знаешь,что ищешь:</target>
        </trans-unit>
        <trans-unit id="4bee35f92a41df1996281dd9bff320d1429a02b9" translate="yes" xml:space="preserve">
          <source>This answer will use Visual Basic terms, syntax, and context. The examples used come from a large number of past Stack&amp;nbsp; Overflow questions. This is to maximize relevance by using the &lt;em&gt;kinds&lt;/em&gt; of situations often seen in posts. A bit more explanation is also provided for those who might need it. An example similar to yours is &lt;em&gt;very&lt;/em&gt; likely listed here.</source>
          <target state="translated">В этом ответе будут использоваться термины, синтаксис и контекст Visual Basic. Используемые примеры взяты из большого количества прошлых вопросов о переполнении стека. Это делается для максимизации релевантности с помощью ситуаций, часто встречающихся в сообщениях. Немного больше объяснений также предоставляется тем, кому это может понадобиться. Пример, похожий на ваш, &lt;em&gt;очень&lt;/em&gt; вероятно, приведен здесь.</target>
        </trans-unit>
        <trans-unit id="43191fd8397e396ff48392d8f06628560c113ac6" translate="yes" xml:space="preserve">
          <source>This array has only been declared, not created. There are several ways to initialize an array:</source>
          <target state="translated">Этот массив только был объявлен,а не создан.Существует несколько способов инициализации массива:</target>
        </trans-unit>
        <trans-unit id="eebc527ad8416d09fe4ecd5b2aa132e7cea81190" translate="yes" xml:space="preserve">
          <source>This can be solved by following the convention to prefix fields with an underscore:</source>
          <target state="translated">Это можно решить,следуя конвенции,чтобы префиксные поля с подчеркиванием:</target>
        </trans-unit>
        <trans-unit id="801881e44b7fc86f8a4310a9936bccc2fea2500b" translate="yes" xml:space="preserve">
          <source>This doesn't throw an &lt;code&gt;InvalidCastException&lt;/code&gt; but returns a &lt;code&gt;null&lt;/code&gt; when the cast fails (and when &lt;code&gt;someObject&lt;/code&gt; is itself null). So be aware of that.</source>
          <target state="translated">Это не &lt;code&gt;InvalidCastException&lt;/code&gt; но возвращает ноль, когда приведение завершается неудачно (и когда &lt;code&gt;someObject&lt;/code&gt; сам по себе является нулем). Так что знайте об этом.</target>
        </trans-unit>
        <trans-unit id="8fef908ebbf6aa8923a642c4bd0b4053bc545790" translate="yes" xml:space="preserve">
          <source>This is a case of an object not being created as expected, but also demonstrates the counter usefulness of an empty &lt;code&gt;Catch&lt;/code&gt;.</source>
          <target state="translated">Это случай, когда объект создается не так, как ожидалось, но также демонстрирует полезность счетчика пустого &lt;code&gt;Catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e0fb87a39ead3f4c4ab6bccc75cb03367823f34" translate="yes" xml:space="preserve">
          <source>This is a case where the IDE will warn you that '&lt;em&gt;not all paths return a value and a &lt;code&gt;NullReferenceException&lt;/code&gt; may result&lt;/em&gt;'. You can suppress the warning, by replacing &lt;code&gt;Exit Function&lt;/code&gt; with &lt;code&gt;Return Nothing&lt;/code&gt;, but that does not solve the problem. Anything which tries to use the return when &lt;code&gt;someCondition = False&lt;/code&gt; will result in an NRE:</source>
          <target state="translated">Это тот случай, когда IDE предупредит вас, что &amp;laquo; &lt;em&gt;не все пути возвращают значение, и может возникнуть &lt;code&gt;NullReferenceException&lt;/code&gt; &lt;/em&gt; &amp;raquo;. Вы можете отключить предупреждение, заменив &lt;code&gt;Exit Function&lt;/code&gt; на &lt;code&gt;Return Nothing&lt;/code&gt; , но это не решит проблему. Все, что пытается использовать возврат, когда &lt;code&gt;someCondition = False&lt;/code&gt; приведет к NRE:</target>
        </trans-unit>
        <trans-unit id="0b561450c1d02029fb3ee4e5c3a3347ea45692b7" translate="yes" xml:space="preserve">
          <source>This is a fairly common way to get an NRE. In C#, depending on how it is coded, the IDE will report that &lt;code&gt;Controls&lt;/code&gt; does not exist in the current context, or &quot;cannot reference non-static member&quot;. So, to some extent, this is a VB-only situation. It is also complex because it can result in a failure cascade.</source>
          <target state="translated">Это довольно распространенный способ получить NRE. В C #, в зависимости от того, как это закодировано, IDE сообщит, что &lt;code&gt;Controls&lt;/code&gt; не существует в текущем контексте, или &amp;laquo;не может ссылаться на нестатический член&amp;raquo;. Так что, в некоторой степени, это ситуация только для VB. Это также сложно, потому что это может привести к каскаду сбоев.</target>
        </trans-unit>
        <trans-unit id="187877ad8cb14ddcbabe75238a1bb7a9668c909a" translate="yes" xml:space="preserve">
          <source>This is also sometimes called the safe navigation or Elvis (after its shape) operator. If the expression on the left side of the operator is null, then the right side will not be evaluated, and null is returned instead. That means cases like this:</source>
          <target state="translated">Это также иногда называется безопасной навигацией или оператором Elvis (по форме).Если выражение с левой стороны оператора является нулевым,то правая сторона не будет вычисляться,а вместо нее будет возвращен ноль.Это означает такие случаи:</target>
        </trans-unit>
        <trans-unit id="aa9ada07655b54e9494b58d5ce6297b70d859bb3" translate="yes" xml:space="preserve">
          <source>This is concept-based: there is no code for you to paste into your project. It is intended to help you understand what causes a &lt;code&gt;NullReferenceException&lt;/code&gt; (NRE), how to find it, how to fix it, and how to avoid it. An NRE can be caused many ways so this is unlikely to be your sole encounter.</source>
          <target state="translated">Это основано на концепции: нет кода для вставки в ваш проект. Он предназначен для того, чтобы помочь вам понять, что вызывает &lt;code&gt;NullReferenceException&lt;/code&gt; (NRE), как его найти, как его исправить и как его избежать. NRE может быть вызвано многими способами, так что вряд ли это будет ваша единственная встреча.</target>
        </trans-unit>
        <trans-unit id="888280c788011247e567ae3ed361d10e659b622d" translate="yes" xml:space="preserve">
          <source>This is why you get a NullReferenceExeption because the computer does not have data stored in that variable.</source>
          <target state="translated">Поэтому вы получаете NullReferenceExeption,потому что на компьютере нет данных,хранящихся в этой переменной.</target>
        </trans-unit>
        <trans-unit id="21425312feec06d5937e5aa46a43ef71033a5a70" translate="yes" xml:space="preserve">
          <source>This line of code works best under your &lt;code&gt;Start()&lt;/code&gt; or &lt;code&gt;Awake()&lt;/code&gt; functions.</source>
          <target state="translated">Эта строка кода лучше всего работает под вашими функциями &lt;code&gt;Start()&lt;/code&gt; или &lt;code&gt;Awake()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc1bf227c2a95d116418fc9c84ba8def88bc060c" translate="yes" xml:space="preserve">
          <source>This means the reference is &lt;code&gt;null&lt;/code&gt;, and you cannot access members (such as methods) through a &lt;code&gt;null&lt;/code&gt; reference. The simplest case:</source>
          <target state="translated">Это означает, что ссылка &lt;code&gt;null&lt;/code&gt; , и вы не можете получить доступ к элементам (таким как методы) через &lt;code&gt;null&lt;/code&gt; ссылку. Самый простой случай:</target>
        </trans-unit>
        <trans-unit id="77e6e4ba966d107a04d5daf44a984b939a965789" translate="yes" xml:space="preserve">
          <source>This reduces the number of null checks you have to do in some cases. The syntax is to put a question mark before each dot. Take the following code for example:</source>
          <target state="translated">Это уменьшает количество нулевых проверок,которые в некоторых случаях приходится делать.Синтаксис заключается в том,чтобы поставить знак вопроса перед каждой точкой.Возьмем,к примеру,следующий код:</target>
        </trans-unit>
        <trans-unit id="c0315d79171243f81b079786418630b61bc73573" translate="yes" xml:space="preserve">
          <source>This translates to</source>
          <target state="translated">Это означает,что</target>
        </trans-unit>
        <trans-unit id="bed843e1a4ee572be6dff42169c3a5deee5b21c5" translate="yes" xml:space="preserve">
          <source>This way, you can avoid &lt;code&gt;NullReferenceException&lt;/code&gt; cases that are results of violation of the constraints set. For example, if you use an object property &lt;code&gt;X&lt;/code&gt; in a class and later try to invoke one of its methods and &lt;code&gt;X&lt;/code&gt; has a null value, then this will lead to &lt;code&gt;NullReferenceException&lt;/code&gt;:</source>
          <target state="translated">Таким образом, вы можете избежать случаев исключения &lt;code&gt;NullReferenceException&lt;/code&gt; , которые являются результатом нарушения установленных ограничений. Например, если вы используете свойство объекта &lt;code&gt;X&lt;/code&gt; в классе, а затем пытаетесь вызвать один из его методов, а &lt;code&gt;X&lt;/code&gt; имеет нулевое значение, то это приведет к &lt;code&gt;NullReferenceException&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ca62aa267e13467726859928ccd74cc220dd2bbb" translate="yes" xml:space="preserve">
          <source>This will create a &lt;em&gt;local&lt;/em&gt; variable, &lt;code&gt;reg&lt;/code&gt;, which exists only in that context (sub). The &lt;code&gt;reg&lt;/code&gt; variable with module level &lt;code&gt;Scope&lt;/code&gt; which you will use everywhere else remains &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">Это создаст &lt;em&gt;локальную&lt;/em&gt; переменную, &lt;code&gt;reg&lt;/code&gt; , которая существует только в этом контексте (sub). Переменная &lt;code&gt;reg&lt;/code&gt; с уровнем модуля &lt;code&gt;Scope&lt;/code&gt; , которую вы будете использовать везде, &lt;code&gt;Nothing&lt;/code&gt; не остается.</target>
        </trans-unit>
        <trans-unit id="9886256ed1be06c975b72d5406cf9d7e42cde50b" translate="yes" xml:space="preserve">
          <source>This will do the following: If &lt;code&gt;myIntArray&lt;/code&gt; is null, the expression returns null and you can safely check it. If it contains an array, it will do the same as:
&lt;code&gt;elem = myIntArray[i];&lt;/code&gt; and returns the &lt;code&gt;i&amp;lt;sup&amp;gt;th&amp;lt;/sup&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">Это будет делать следующее: если &lt;code&gt;myIntArray&lt;/code&gt; имеет значение null, выражение возвращает значение null, и вы можете безопасно проверить его. Если он содержит массив, он будет делать то же самое, что и: &lt;code&gt;elem = myIntArray[i];&lt;/code&gt; и возвращает элемент &lt;code&gt;i&amp;lt;sup&amp;gt;th&amp;lt;/sup&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1db062d19edd3aad36fceee9160e7c1852968c5e" translate="yes" xml:space="preserve">
          <source>This will result in the title variable being &lt;code&gt;null&lt;/code&gt;, and the call to &lt;code&gt;ToUpper&lt;/code&gt; is not made if &lt;code&gt;person.Title&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Это приведет к тому, что переменная title будет иметь значение &lt;code&gt;null&lt;/code&gt; , а вызов &lt;code&gt;person.Title&lt;/code&gt; не будет выполнен, если person.Title имеет значение &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="037853ac976e876cd13f3318e4f680cf26902d26" translate="yes" xml:space="preserve">
          <source>This will throw a &lt;code&gt;NullReferenceException&lt;/code&gt; at the second line because you can't call the instance method &lt;code&gt;ToUpper()&lt;/code&gt; on a &lt;code&gt;string&lt;/code&gt; reference pointing to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Это создаст &lt;code&gt;NullReferenceException&lt;/code&gt; во второй строке, потому что вы не можете вызвать метод экземпляра &lt;code&gt;ToUpper()&lt;/code&gt; для &lt;code&gt;string&lt;/code&gt; ссылки, указывающей на &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4adf93e86d1600f5a1f1d298afde221268eccfe7" translate="yes" xml:space="preserve">
          <source>Though this check &lt;a href=&quot;https://stackoverflow.com/questions/3021538/debug-assert-appears-in-release-mode&quot;&gt;will not end up in your release build&lt;/a&gt;, causing it to throw the &lt;code&gt;NullReferenceException&lt;/code&gt; again when &lt;code&gt;book == null&lt;/code&gt; at runtime in release mode.</source>
          <target state="translated">Хотя эта проверка &lt;a href=&quot;https://stackoverflow.com/questions/3021538/debug-assert-appears-in-release-mode&quot;&gt;не закончится в вашей сборке релиза&lt;/a&gt; , она снова &lt;code&gt;NullReferenceException&lt;/code&gt; когда &lt;code&gt;book == null&lt;/code&gt; во время выполнения в режиме выпуска.</target>
        </trans-unit>
        <trans-unit id="fe4569d04b34db2feeacd18b55f433f11ceeaa79" translate="yes" xml:space="preserve">
          <source>To avoid this error:</source>
          <target state="translated">Чтобы избежать этой ошибки:</target>
        </trans-unit>
        <trans-unit id="b862da83d643fa0302757d37468767ad8e9ac824" translate="yes" xml:space="preserve">
          <source>To be clear, &lt;code&gt;Dim&lt;/code&gt; (or &lt;code&gt;Private&lt;/code&gt;) only &lt;em&gt;declares&lt;/em&gt; a variable and its &lt;code&gt;Type&lt;/code&gt;.   The &lt;em&gt;Scope&lt;/em&gt; of the variable - whether it exists for the entire module/class or is local to a procedure - is determined by &lt;em&gt;where&lt;/em&gt; it is declared. &lt;code&gt;Private | Friend | Public&lt;/code&gt; defines the access level, not &lt;em&gt;Scope&lt;/em&gt;.</source>
          <target state="translated">Для ясности, &lt;code&gt;Dim&lt;/code&gt; (или &lt;code&gt;Private&lt;/code&gt; ) &lt;em&gt;объявляет&lt;/em&gt; только переменную и ее &lt;code&gt;Type&lt;/code&gt; . &lt;em&gt;Область&lt;/em&gt; действия переменной - существует ли она для всего модуля / класса или является локальной для процедуры - определяется тем, &lt;em&gt;где&lt;/em&gt; она объявлена. &lt;code&gt;Private | Friend | Public&lt;/code&gt; Друг | Public определяет уровень доступа, а не &lt;em&gt;Scope&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5ccb716ef7518f5e4cae9d82dbbb0fdfc28ad185" translate="yes" xml:space="preserve">
          <source>To fix this you have to instantiate (assign object to reference of that class).</source>
          <target state="translated">Чтобы это исправить,необходимо инстанцировать (назначить объект на ссылку этого класса).</target>
        </trans-unit>
        <trans-unit id="cfce5bc74512f792b40d3fd4bb577d39ad331d72" translate="yes" xml:space="preserve">
          <source>To fully understand why a NullReferenceException is thrown, it is important to know the difference between &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;value types&lt;/a&gt; and [reference types][3].</source>
          <target state="translated">Чтобы полностью понять, почему выбрасывается исключение NullReferenceException, важно знать разницу между &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;типами значений&lt;/a&gt; и [ссылочными типами] [3].</target>
        </trans-unit>
        <trans-unit id="442fc389bbb8b0ecba07a137178cc20263b9b7c4" translate="yes" xml:space="preserve">
          <source>To prevent the error, objects that could be null should be tested for null before being used.</source>
          <target state="translated">Чтобы предотвратить ошибку,объекты,которые могут быть нулевыми,должны быть проверены на нулевой уровень перед использованием.</target>
        </trans-unit>
        <trans-unit id="2fc08c6abe8c008843158c3dfc2b4819d97175ce" translate="yes" xml:space="preserve">
          <source>To understand why that is, it helps to understand how .NET produces null dereference exceptions in the first place. (These details apply to .NET running on Windows; other operating systems use similar mechanisms.)</source>
          <target state="translated">Чтобы понять,почему это так,в первую очередь помогает понять,как .NET производит нулевые исключения разыменования.(Эти подробности применимы к .NET,работающей под Windows;другие операционные системы используют аналогичные механизмы).</target>
        </trans-unit>
        <trans-unit id="1c409f99322562874653d2f8a0ab2c648ed33f45" translate="yes" xml:space="preserve">
          <source>Typically, the &lt;code&gt;Settings&lt;/code&gt; collection will only need to be initialized the first time the application runs. An alternate remedy is to add an initial value to your collection in &lt;strong&gt;Project -&amp;gt; Settings | FooBars&lt;/strong&gt;, save the project, then remove the fake value.</source>
          <target state="translated">Как правило, коллекцию &lt;code&gt;Settings&lt;/code&gt; необходимо инициализировать только при первом запуске приложения. Альтернативное решение - добавить начальное значение к вашей коллекции в &lt;strong&gt;Project -&amp;gt; Settings |&lt;/strong&gt; &lt;strong&gt;FooBars&lt;/strong&gt; , сохраните проект, затем удалите поддельное значение.</target>
        </trans-unit>
        <trans-unit id="516c8eebca6e87f940176b1effe4b60b6c0ea266" translate="yes" xml:space="preserve">
          <source>Typically, the simplest remedy is used.</source>
          <target state="translated">Как правило,используется простейшее средство.</target>
        </trans-unit>
        <trans-unit id="44ae451f7b7bc5e89c459fa403f51f895a24e5e5" translate="yes" xml:space="preserve">
          <source>UI Controls</source>
          <target state="translated">элементы управления пользовательским интерфейсом</target>
        </trans-unit>
        <trans-unit id="0367a9753f91933f52263dc3499b7fad896e44c1" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, trying to use an item from &lt;code&gt;My.Settings&lt;/code&gt; which is a &lt;code&gt;StringCollection&lt;/code&gt; can result in a NullReference the first time you use it. The solution is the same, but not as obvious. Consider:</source>
          <target state="translated">При определенных обстоятельствах попытка использовать элемент из &lt;code&gt;My.Settings&lt;/code&gt; , который является &lt;code&gt;StringCollection&lt;/code&gt; , может привести к NullReference при первом его использовании. Решение то же самое, но не так очевидно. Рассматривать:</target>
        </trans-unit>
        <trans-unit id="5fd5faf037f6a68b87421df3d131d2dc06cf5ac5" translate="yes" xml:space="preserve">
          <source>Unhandled Exception:</source>
          <target state="translated">Исключение без обращения:</target>
        </trans-unit>
        <trans-unit id="13d1de28b167068f1cf58b6d8b42d1a864bfb7e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Debug.Assert&lt;/code&gt; if a value should never be &lt;code&gt;null&lt;/code&gt;, to catch the problem earlier than the exception occurs.</source>
          <target state="translated">Используйте &lt;code&gt;Debug.Assert&lt;/code&gt; , если значение никогда не должно быть &lt;code&gt;null&lt;/code&gt; , чтобы поймать проблему раньше, чем возникнет исключение.</target>
        </trans-unit>
        <trans-unit id="382f02f764a14908cf7b8365adec70912d5701d9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;GetValueOrDefault()&lt;/code&gt; for &lt;code&gt;nullable&lt;/code&gt; value types to provide a default value when they are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;GetValueOrDefault()&lt;/code&gt; для типов значений, &lt;code&gt;nullable&lt;/code&gt; значение NULL, чтобы обеспечить значение по умолчанию, когда они равны &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2998b45c318d095c3e4535a7950d83516d58ebb7" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;For/Each&lt;/code&gt; loop and test the &lt;code&gt;IsNewRow&lt;/code&gt; property to determine if it is that last row. This works whether &lt;code&gt;AllowUserToAddRows&lt;/code&gt; is true or not:</source>
          <target state="translated">Используйте цикл &lt;code&gt;For/Each&lt;/code&gt; и протестируйте свойство &lt;code&gt;IsNewRow&lt;/code&gt; , чтобы определить, является ли он последней строкой. Это работает, является ли &lt;code&gt;AllowUserToAddRows&lt;/code&gt; истинным или нет:</target>
        </trans-unit>
        <trans-unit id="1b21080b0c77e9baa935891138a35678155ae048" translate="yes" xml:space="preserve">
          <source>Use null context (available in C# 8):</source>
          <target state="translated">Использовать нулевой контекст (доступно на C#8):</target>
        </trans-unit>
        <trans-unit id="3c02b72e67d50c9e6e8df127d3c4c8b5ee96c2af" translate="yes" xml:space="preserve">
          <source>Use the null coalescing operator: &lt;code&gt;??&lt;/code&gt; [C#] or &lt;code&gt;If()&lt;/code&gt; [VB].</source>
          <target state="translated">Используйте оператор слияния null: &lt;code&gt;??&lt;/code&gt; [C #] или &lt;code&gt;If()&lt;/code&gt; [VB].</target>
        </trans-unit>
        <trans-unit id="eceb840fe473d205bb79bbfbe6842b028ab9de50" translate="yes" xml:space="preserve">
          <source>Use the null condition operator: &lt;code&gt;?.&lt;/code&gt; or &lt;code&gt;?[x]&lt;/code&gt; for arrays (available in C# 6 and VB.NET 14):</source>
          <target state="translated">Используйте нулевой оператор условия: &lt;code&gt;?.&lt;/code&gt; или &lt;code&gt;?[x]&lt;/code&gt; для массивов (доступно в C # 6 и VB.NET 14):</target>
        </trans-unit>
        <trans-unit id="e34781ddb98c0b7bad26d07124e848d7dc5380d0" translate="yes" xml:space="preserve">
          <source>User defined structs</source>
          <target state="translated">Пользовательские структуры</target>
        </trans-unit>
        <trans-unit id="4c9bf9d75e9c5172e3585c1c3082c6d25bacf2fa" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;List(Of T)&lt;/code&gt; will make it quite difficult to have an element without a valid object:</source>
          <target state="translated">Использование &lt;code&gt;List(Of T)&lt;/code&gt; значительно затруднит наличие элемента без допустимого объекта:</target>
        </trans-unit>
        <trans-unit id="e0cf661777181bb5bf4bab3c932185766cf29b18" translate="yes" xml:space="preserve">
          <source>Validate data before using it (also use &lt;code&gt;Option Strict&lt;/code&gt; and SQL parameters):</source>
          <target state="translated">Проверьте данные перед их использованием (также используйте параметры &lt;code&gt;Option Strict&lt;/code&gt; и SQL):</target>
        </trans-unit>
        <trans-unit id="3b3c5424e9429ade50d2ed4719daf8a5ef46e7c7" translate="yes" xml:space="preserve">
          <source>Value Types and Reference Types</source>
          <target state="translated">Типы значений и эталонные типы</target>
        </trans-unit>
        <trans-unit id="b7d9a51e2fb5186d4548644a10a85dfb83b90aff" translate="yes" xml:space="preserve">
          <source>Visual Basic Forms</source>
          <target state="translated">Визуальные основные формы</target>
        </trans-unit>
        <trans-unit id="914f780030704154b3755eefa6c85d3acdf3b1c7" translate="yes" xml:space="preserve">
          <source>Visual Basic tries to make the process clear repeatedly using &lt;strong&gt;&lt;code&gt;New&lt;/code&gt;&lt;/strong&gt;: Using the &lt;strong&gt;&lt;code&gt;New&lt;/code&gt;&lt;/strong&gt; Operator creates a &lt;strong&gt;new&lt;/strong&gt; object and calls &lt;strong&gt;&lt;code&gt;Sub New&lt;/code&gt;&lt;/strong&gt; -- the constructor -- where your object can perform any other initialization.</source>
          <target state="translated">Visual Basic пытается сделать процесс очистки многократно, используя &lt;strong&gt; &lt;code&gt;New&lt;/code&gt; &lt;/strong&gt; : с помощью оператора &lt;strong&gt; &lt;code&gt;New&lt;/code&gt; &lt;/strong&gt; создается &lt;strong&gt;новый&lt;/strong&gt; объект и вызывается &lt;strong&gt; &lt;code&gt;Sub New&lt;/code&gt; &lt;/strong&gt; - конструктор, - где ваш объект может выполнить любую другую инициализацию.</target>
        </trans-unit>
        <trans-unit id="4356f5b2bed387a822b4773e00b955c30fb15382" translate="yes" xml:space="preserve">
          <source>WPF Control Creation Order and Events</source>
          <target state="translated">Порядок и события создания управления WPF</target>
        </trans-unit>
        <trans-unit id="865749e3cc387179c321ac3469aa809ca6ea641d" translate="yes" xml:space="preserve">
          <source>Ways to Avoid</source>
          <target state="translated">Способы избежать</target>
        </trans-unit>
        <trans-unit id="b50ff997c836b3bf135585b592d9922fb8daa6c5" translate="yes" xml:space="preserve">
          <source>We can add data really easily actually in a few ways:</source>
          <target state="translated">Мы можем действительно легко добавлять данные на самом деле несколькими способами:</target>
        </trans-unit>
        <trans-unit id="171db29c0e9a7d26b4e0c78fa029495735b943f5" translate="yes" xml:space="preserve">
          <source>Well, in simple terms:</source>
          <target state="translated">Ну,проще говоря:</target>
        </trans-unit>
        <trans-unit id="54f0454febe335028ebb7ac67e60ee8639c8bb01" translate="yes" xml:space="preserve">
          <source>What about the second point? Dereferencing &lt;em&gt;any&lt;/em&gt; invalid pointer that falls in the lowest page of virtual memory causes the same operating system error, and thereby the same exception.</source>
          <target state="translated">Как насчет второго пункта? Разыменование &lt;em&gt;любого&lt;/em&gt; недопустимого указателя, который попадает на самую нижнюю страницу виртуальной памяти, вызывает ту же ошибку операционной системы и, следовательно, то же исключение.</target>
        </trans-unit>
        <trans-unit id="a57d36dd7547d0d01d63f5a0dca33743ac6b0190" translate="yes" xml:space="preserve">
          <source>What does that mean?</source>
          <target state="translated">Что это значит?</target>
        </trans-unit>
        <trans-unit id="dfc9e4324fb08b6a8f17d724cf8c6155af43dd1b" translate="yes" xml:space="preserve">
          <source>What does this mean, and what can I do to fix this error?</source>
          <target state="translated">Что это значит,и что я могу сделать,чтобы исправить эту ошибку?</target>
        </trans-unit>
        <trans-unit id="682501e35814b10bb49bcce3a8138d93e7237565" translate="yes" xml:space="preserve">
          <source>What is a NullReferenceException, and how do I fix it</source>
          <target state="translated">Что такое NullReferenceException,и как мне это исправить.</target>
        </trans-unit>
        <trans-unit id="2b175120120a58af183c09ae1970097e643335ca" translate="yes" xml:space="preserve">
          <source>What is the cause?</source>
          <target state="translated">В чем причина?</target>
        </trans-unit>
        <trans-unit id="4d05bb2729110f107617bc429ecb0bc63e601752" translate="yes" xml:space="preserve">
          <source>When a property of a null object accessed:</source>
          <target state="translated">При доступе к свойству нулевого объекта:</target>
        </trans-unit>
        <trans-unit id="24ee47a5b48927d93ac97774fc77bc2a3836d6a2" translate="yes" xml:space="preserve">
          <source>When a string method of an empty string accessed:</source>
          <target state="translated">При обращении к методу пустой строки:</target>
        </trans-unit>
        <trans-unit id="0d8ca3f12ffd0492f759832995654e7110254f83" translate="yes" xml:space="preserve">
          <source>When declared as a module/class level variable, as appears to be the case with &lt;code&gt;con&lt;/code&gt;, the compiler can't know if the object was created by an upstream procedure. Do not ignore warnings.</source>
          <target state="translated">Когда декларируется как переменная уровня модуля / класса, как это имеет место в случае с &lt;code&gt;con&lt;/code&gt; , компилятор не может знать, был ли объект создан вышестоящей процедурой. Не игнорируйте предупреждения.</target>
        </trans-unit>
        <trans-unit id="efc21187e8ea71d0502b9553436531ff09010739" translate="yes" xml:space="preserve">
          <source>When it is only appropriate to create the instance later:</source>
          <target state="translated">Когда уместно создать экземпляр только позже:</target>
        </trans-unit>
        <trans-unit id="e320e6e3ad0e90936d129472db697d3b8b8d6e80" translate="yes" xml:space="preserve">
          <source>When working &lt;strong&gt;across different layers&lt;/strong&gt;, for example in an MVC application, a controller needs services to call business operations. In such scenarios &lt;strong&gt;Dependency Injection Container&lt;/strong&gt; can be used to initialize the services to avoid the &lt;strong&gt;NullReferenceException&lt;/strong&gt;. So that means you don't need to worry about checking for null and just call the services from the controller as though they will always to available (and initialized) as either a singleton or a prototype.</source>
          <target state="translated">При работе &lt;strong&gt;на разных уровнях&lt;/strong&gt; , например, в приложении MVC, контроллеру нужны сервисы для вызова бизнес-операций. В таких сценариях &lt;strong&gt;Dependency Injection Container&lt;/strong&gt; можно использовать для инициализации служб, чтобы избежать исключения &lt;strong&gt;NullReferenceException&lt;/strong&gt; . Таким образом, это означает, что вам не нужно беспокоиться о проверке на null и просто вызывать сервисы из контроллера, как если бы они всегда были доступны (и инициализированы) в виде одиночного или прототипа.</target>
        </trans-unit>
        <trans-unit id="dba90f1005ef6b9743a2d890263f4e1876834da6" translate="yes" xml:space="preserve">
          <source>When you know during development that a method maybe can, but never should return &lt;code&gt;null&lt;/code&gt;, you can use &lt;code&gt;Debug.Assert()&lt;/code&gt; to break as soon as possible when it does occur:</source>
          <target state="translated">Если во время разработки вы знаете, что метод может, но никогда не должен возвращать &lt;code&gt;Debug.Assert()&lt;/code&gt; , вы можете использовать Debug.Assert () для прерывания как можно скорее, когда это произойдет:</target>
        </trans-unit>
        <trans-unit id="1492aaa2d900e272a66ec2ee7932c7c567523b15" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;DataGridView&lt;/code&gt; has &lt;code&gt;AllowUserToAddRows&lt;/code&gt; as &lt;code&gt;True&lt;/code&gt; (the default), the &lt;code&gt;Cells&lt;/code&gt; in the blank/new row at the bottom will all contain &lt;code&gt;Nothing&lt;/code&gt;.  Most attempts to use the contents (for example, &lt;code&gt;ToString&lt;/code&gt;) will result in an NRE.</source>
          <target state="translated">Когда ваш &lt;code&gt;DataGridView&lt;/code&gt; имеет значение &lt;code&gt;AllowUserToAddRows&lt;/code&gt; как &lt;code&gt;True&lt;/code&gt; (по умолчанию), &lt;code&gt;Cells&lt;/code&gt; в пустой / новой строке внизу все будут содержать &lt;code&gt;Nothing&lt;/code&gt; . Большинство попыток использовать содержимое (например, &lt;code&gt;ToString&lt;/code&gt; ) приводит к NRE.</target>
        </trans-unit>
        <trans-unit id="cdb948906225c5be7dabe665fe3268f2aa7f7d1b" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;what&lt;/em&gt; causes a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;NullReferenceExceptions&lt;/a&gt; and approaches to &lt;em&gt;avoid/fix&lt;/em&gt; such an exception have been addressed in other answers, what many programmers haven't learned yet is how to independently &lt;em&gt;debug&lt;/em&gt; such exceptions during development.</source>
          <target state="translated">В &lt;em&gt;то&lt;/em&gt; время &lt;em&gt;как&lt;/em&gt; причины других &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;исключений NullReferenceException&lt;/a&gt; и подходы, позволяющие &lt;em&gt;избежать / исправить&lt;/em&gt; такое исключение, были рассмотрены в других ответах, многие программисты еще не узнали, как самостоятельно &lt;em&gt;отлаживать&lt;/em&gt; такие исключения во время разработки.</target>
        </trans-unit>
        <trans-unit id="448dc745cee8454cb3051219a2b24ea7029e0795" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;new&lt;/code&gt; keyword is used, it only creates a new instance of &lt;code&gt;Book&lt;/code&gt;, but not a new instance of &lt;code&gt;Person&lt;/code&gt;, so the &lt;code&gt;Author&lt;/code&gt; the property is still &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Пока используется &lt;code&gt;new&lt;/code&gt; ключевое слово, оно создает только новый экземпляр &lt;code&gt;Book&lt;/code&gt; , но не новый экземпляр &lt;code&gt;Person&lt;/code&gt; , поэтому свойство &lt;code&gt;Author&lt;/code&gt; по-прежнему имеет значение &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d52f9ee0d5e0aa5f23d1b3b5d8e4d2e56fca0930" translate="yes" xml:space="preserve">
          <source>Why does this make sense?  Well, suppose we have a struct containing two ints, and an unmanaged pointer equal to null. If we attempt to dereference the second int in the struct, the &lt;code&gt;CLR&lt;/code&gt; will not attempt to access the storage at location zero; it will access the storage at location four. But logically this is a null dereference because we are getting to that address &lt;em&gt;via&lt;/em&gt; the null.</source>
          <target state="translated">Почему это имеет смысл? Хорошо, предположим, у нас есть структура, содержащая два целых числа и неуправляемый указатель, равный нулю. Если мы попытаемся разыменовать второе int в структуре, &lt;code&gt;CLR&lt;/code&gt; не будет пытаться получить доступ к хранилищу в нулевом местоположении; он получит доступ к хранилищу в расположении четыре. Но логически это нулевая разыменование, потому что мы получаем по этому адресу &lt;em&gt;через&lt;/em&gt; нуль.</target>
        </trans-unit>
        <trans-unit id="e5b3e5b5a3ce438cfd892d68ca821da56bd33f46" translate="yes" xml:space="preserve">
          <source>Why is this wrong?  Because the iterator block does not actually &lt;em&gt;run&lt;/em&gt; until the &lt;code&gt;foreach&lt;/code&gt;!  The call to &lt;code&gt;GetFrobs&lt;/code&gt; simply returns an object which &lt;em&gt;when iterated&lt;/em&gt; will run the iterator block.</source>
          <target state="translated">Почему это не так? Потому что блок итератора фактически не &lt;em&gt;работает&lt;/em&gt; до &lt;code&gt;foreach&lt;/code&gt; ! Вызов &lt;code&gt;GetFrobs&lt;/code&gt; просто возвращает объект, который &lt;em&gt;при повторении&lt;/em&gt; запускает блок итератора.</target>
        </trans-unit>
        <trans-unit id="dd8f068ecfc9cc04c00494e69ae5f6e0960b7ae7" translate="yes" xml:space="preserve">
          <source>Why it occurs?</source>
          <target state="translated">Почему это происходит?</target>
        </trans-unit>
        <trans-unit id="cce1faca008b524ebe3411e4a56c2cb194dc1b42" translate="yes" xml:space="preserve">
          <source>Working with databases presents many opportunities for a NullReference because there can be many objects (&lt;code&gt;Command&lt;/code&gt;, &lt;code&gt;Connection&lt;/code&gt;, &lt;code&gt;Transaction&lt;/code&gt;, &lt;code&gt;Dataset&lt;/code&gt;, &lt;code&gt;DataTable&lt;/code&gt;, &lt;code&gt;DataRows&lt;/code&gt;....) in use at once.  &lt;strong&gt;Note:&lt;/strong&gt; It does not matter which data provider you are using -- MySQL, SQL Server, OleDB, etc. -- the &lt;em&gt;concepts&lt;/em&gt; are the same.</source>
          <target state="translated">Работа с базами данных предоставляет множество возможностей для NullReference, поскольку одновременно может использоваться много объектов ( &lt;code&gt;Command&lt;/code&gt; , &lt;code&gt;Connection&lt;/code&gt; , &lt;code&gt;Transaction&lt;/code&gt; , &lt;code&gt;Dataset&lt;/code&gt; , &lt;code&gt;DataTable&lt;/code&gt; , &lt;code&gt;DataRows&lt;/code&gt; ....). &lt;strong&gt;Примечание.&lt;/strong&gt; Неважно, какой поставщик данных вы используете - MySQL, SQL Server, OleDB и т. Д. - &lt;em&gt;концепции&lt;/em&gt; совпадают.</target>
        </trans-unit>
        <trans-unit id="723856ede778551d9c785472d51c2f7fcbb54d7d" translate="yes" xml:space="preserve">
          <source>You are trying to access an object that isn't created or currently not in memory.</source>
          <target state="translated">Вы пытаетесь получить доступ к объекту,который не создан или в данный момент не находится в памяти.</target>
        </trans-unit>
        <trans-unit id="8aa880592f3584b0eb7955f587d23cf9a9b8e76b" translate="yes" xml:space="preserve">
          <source>You are trying to use a reference variable whose value is &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;.  When the value is &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; for the reference variable, that means it is not actually holding a reference to an instance of any object that exists on the heap.</source>
          <target state="translated">Вы пытаетесь использовать ссылочную переменную со значением &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; . Если для ссылочной переменной установлено значение &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; , это означает, что в действительности оно не содержит ссылку на экземпляр какого-либо объекта, который существует в куче.</target>
        </trans-unit>
        <trans-unit id="4b4d5b042ee1470a88bab9f1d60f9144e6f609fc" translate="yes" xml:space="preserve">
          <source>You are trying to use something that is &lt;code&gt;null&lt;/code&gt; (or &lt;code&gt;Nothing&lt;/code&gt; in VB.NET). This means you either set it to &lt;code&gt;null&lt;/code&gt;, or you never set it to anything at all.</source>
          <target state="translated">Вы пытаетесь использовать что-то, что является &lt;code&gt;null&lt;/code&gt; (или &lt;code&gt;Nothing&lt;/code&gt; в VB.NET). Это означает, что вы либо устанавливаете его на &lt;code&gt;null&lt;/code&gt; , либо никогда вообще ничего не устанавливаете.</target>
        </trans-unit>
        <trans-unit id="a4b2a4f8cb9ff198b895cb45c6d69095f67060ba" translate="yes" xml:space="preserve">
          <source>You are using the object that contains the null value reference. So it's giving a null exception. In the example the string value is null and when checking its length, the exception occurred.</source>
          <target state="translated">Вы используете объект,содержащий ссылку на нулевое значение.Таким образом,он дает нулевое исключение.В примере строковое значение является нулевым и при проверке его длины возникло исключение.</target>
        </trans-unit>
        <trans-unit id="c6e71d37b17fa53433b0f7d95131ec2c8f8e5dcd" translate="yes" xml:space="preserve">
          <source>You can add a component programmatically and assign the variable at the same time with one line of code: &lt;code&gt;rb = AddComponent&amp;lt;RigidBody&amp;gt;();&lt;/code&gt;</source>
          <target state="translated">Вы можете добавить компонент программно и назначить переменную одновременно одной строкой кода: &lt;code&gt;rb = AddComponent&amp;lt;RigidBody&amp;gt;();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c38e20677037c680c41cdbbd3a874a5b75b4783" translate="yes" xml:space="preserve">
          <source>You can also throw a custom exception, only to catch it in the calling code:</source>
          <target state="translated">Также можно бросить пользовательское исключение,только чтобы поймать его в коде вызова:</target>
        </trans-unit>
        <trans-unit id="17ea64ffa695b740770485aaba63974913381c9a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;Locals Window&lt;/code&gt; (&lt;strong&gt;Debug -&amp;gt; Windows -&amp;gt; Locals&lt;/strong&gt;) to examine your objects.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;Locals Window&lt;/code&gt; ( &lt;strong&gt;Debug -&amp;gt; Windows -&amp;gt; Locals&lt;/strong&gt; ), чтобы проверить ваши объекты.</target>
        </trans-unit>
        <trans-unit id="12a1a3c92ffa52e6b050bf7546290b5e6ce658b2" translate="yes" xml:space="preserve">
          <source>You can fix NullReferenceException in a clean way using Null-conditional Operators in c#6 and write less code to handle null checks.</source>
          <target state="translated">Вы можете исправить NullReferenceException чистым способом,используя Null-conditional Operators в c#6 и написать меньше кода для обработки нулевых проверок.</target>
        </trans-unit>
        <trans-unit id="2edd59e412b940b382162755da24e3b3a55a1a98" translate="yes" xml:space="preserve">
          <source>You can simply avoid this by checking if the variable is not null:</source>
          <target state="translated">Вы можете просто избежать этого,проверяя,не является ли переменная нулевой:</target>
        </trans-unit>
        <trans-unit id="d1588e2df3c8e2e5e50543e8a09e318c3ac852eb" translate="yes" xml:space="preserve">
          <source>You either never assigned something to the variable, never created an instance of the value assigned to the variable, or you set the variable equal to &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; manually, or you called a function that set the variable to &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; for you.</source>
          <target state="translated">Вы либо никогда не присваивали что-либо переменной, ни разу не создавали экземпляр значения, назначенного переменной, либо устанавливали переменную равной &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; вручную, либо вызывали функцию, которая устанавливает для переменной значение &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; для вас.</target>
        </trans-unit>
        <trans-unit id="f66228601ed3724d69b717ec6fe23f27ca71e042" translate="yes" xml:space="preserve">
          <source>You get the same exception for the same reason - &lt;code&gt;myList&lt;/code&gt; was only declared, but no instance created. The remedy is the same:</source>
          <target state="translated">Вы получаете то же исключение по той же причине - &lt;code&gt;myList&lt;/code&gt; был только объявлен, но экземпляр не создан. Средство защиты такое же:</target>
        </trans-unit>
        <trans-unit id="7d96029677307b05bf0beda9a46b585a9c96a9a3" translate="yes" xml:space="preserve">
          <source>You probably forgot the &lt;code&gt;New&lt;/code&gt; operator.</source>
          <target state="translated">Вы, вероятно, забыли &lt;code&gt;New&lt;/code&gt; оператор.</target>
        </trans-unit>
        <trans-unit id="9889cfa340b5a188c4545454aa3970b650ff6a92" translate="yes" xml:space="preserve">
          <source>You should also remove any Try/Catch blocks from the relevant code, especially ones where there is nothing in the Catch block. This will cause your code to crash when it tries to use an object which is &lt;code&gt;Nothing&lt;/code&gt;. &lt;strong&gt;This is what you want&lt;/strong&gt; because it will identify the exact &lt;em&gt;location&lt;/em&gt; of the problem, and allow you to identify the object causing it.</source>
          <target state="translated">Вам также следует удалить все блоки Try / Catch из соответствующего кода, особенно те, в которых нет ничего в блоке Catch. Это приведет к сбою вашего кода, когда он попытается использовать объект, который является &lt;code&gt;Nothing&lt;/code&gt; . &lt;strong&gt;Это то, что вы хотите,&lt;/strong&gt; потому что он определит точное &lt;em&gt;местоположение&lt;/em&gt; проблемы и позволит вам определить объект, вызывающий ее.</target>
        </trans-unit>
        <trans-unit id="7cf85e9877af0174191657bf941763d81f747650" translate="yes" xml:space="preserve">
          <source>You would use very similar to the same way you would use &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, except with the goal of accomplishing exactly the opposite - to not allow &lt;code&gt;null&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">Вы будете использовать очень похоже на то же самое, что и &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; , за исключением того, что вы выполняете с точностью до наоборот - чтобы не допустить &lt;code&gt;null&lt;/code&gt; . Вот некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="1cc0e4045b9e917b4e600760083043c55ca6aa29" translate="yes" xml:space="preserve">
          <source>Your code &lt;em&gt;declared&lt;/em&gt; an object variable, but it did not &lt;em&gt;initialize&lt;/em&gt; it (create an instance or '&lt;em&gt;instantiate&lt;/em&gt;' it)</source>
          <target state="translated">Ваш код &lt;em&gt;объявил&lt;/em&gt; переменную объекта, но он не &lt;em&gt;инициализировал&lt;/em&gt; ее (создайте экземпляр или создайте его экземпляр)</target>
        </trans-unit>
        <trans-unit id="1835adb6d4755dbbf56a8c76ede96fd8258bbc9c" translate="yes" xml:space="preserve">
          <source>above line throws error because reference of class myClass is declared but not instantiated or an instance of object is not assigned to referecne of that class.</source>
          <target state="translated">выше строка бросает ошибку,потому что ссылка на класс myClass объявлена,но не инстанциирована,или экземпляр объекта не назначен на referecne этого класса.</target>
        </trans-unit>
        <trans-unit id="163efa6e9cc8a00507230d1f61d9db3d11ab97db" translate="yes" xml:space="preserve">
          <source>and Contact entity class. Sometimes entity classes are partial classes so that you can extend them in other files too.</source>
          <target state="translated">и класс &quot;Контактная компания&quot;.Иногда классы сущностей являются частичными классами,поэтому их можно расширять и в других файлах.</target>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="45932d6fa98f39c5cd3f08cd951d8dc70fc5f7de" translate="yes" xml:space="preserve">
          <source>decimal</source>
          <target state="translated">decimal</target>
        </trans-unit>
        <trans-unit id="f7852992c275998df7dbb34bd4a576549f4622aa" translate="yes" xml:space="preserve">
          <source>dereferencing a null &lt;strong&gt;pointer&lt;/strong&gt; produces the same exception as dereferencing a null &lt;strong&gt;reference&lt;/strong&gt;</source>
          <target state="translated">разыменование нулевого &lt;strong&gt;указателя&lt;/strong&gt; приводит к тому же исключению, что и разыменование нулевой &lt;strong&gt;ссылки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b2e6f52aa2a81fb92f818a3436c6758ad33c8a3" translate="yes" xml:space="preserve">
          <source>dereferencing an invalid non-null pointer &lt;strong&gt;can&lt;/strong&gt; produce that exception
in some circumstances</source>
          <target state="translated">разыменование недопустимого ненулевого указателя &lt;strong&gt;может&lt;/strong&gt; вызвать это исключение при некоторых обстоятельствах</target>
        </trans-unit>
        <trans-unit id="b5031a46dd38e909839b52a146a7969402061271" translate="yes" xml:space="preserve">
          <source>disable: The nullable annotation context is disabled. The nullable warning context is disabled. Variables of a reference type are oblivious, just like earlier versions of C#. All nullability warnings are disabled.</source>
          <target state="translated">Вывести из строя:Отключен контекст отмены аннотации.Нулевой контекст предупреждения отключен.Переменные типа ссылок забываются,как и в более ранних версиях C#.Все предупреждения об аннулировании отключены.</target>
        </trans-unit>
        <trans-unit id="5452220584f9d82eacc9d4b64b556c642aa95fe3" translate="yes" xml:space="preserve">
          <source>dynamic</source>
          <target state="translated">dynamic</target>
        </trans-unit>
        <trans-unit id="707ee2e80d8a348ed040077b064ae8b11ce87533" translate="yes" xml:space="preserve">
          <source>enable: The nullable annotation context is enabled. The nullable warning context is enabled. Variables of a reference type, string for example, are non-nullable. All nullability warnings are enabled.</source>
          <target state="translated">Позволь:Включен нулевой контекст аннотации.Включен нулевой контекст предупреждения.Переменные типа ссылки,например,строка,не являются необратимыми.Включены все предупреждения об аннулировании.</target>
        </trans-unit>
        <trans-unit id="f93306a0064ddaa9f3c518dfda6d24b1659b5141" translate="yes" xml:space="preserve">
          <source>for example: let say you have a class called myClass and it contains one property prop1.</source>
          <target state="translated">Например:допустим,у вас есть класс под названием myClass,который содержит одно свойство prop1.</target>
        </trans-unit>
        <trans-unit id="4d3e8614703ea126434cc11d59e3c7a70c66d624" translate="yes" xml:space="preserve">
          <source>foreach</source>
          <target state="translated">foreach</target>
        </trans-unit>
        <trans-unit id="23ec53a4c09cf5266253f2e3ee5c91b8b4eb9045" translate="yes" xml:space="preserve">
          <source>in here , if address is null , then you will get NullReferenceException.</source>
          <target state="translated">здесь,если адрес нулевой,то вы получите NullReferenceException.</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">эквивалентно:</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1d02abd73c8fc5445c71c4fbe24bc25707ea3d7a" translate="yes" xml:space="preserve">
          <source>public class Form1
{
    private Customer customer;</source>
          <target state="translated">общественный класс Форма 1{частный заказчик;</target>
        </trans-unit>
        <trans-unit id="c133b31de2d5fc69bf6862d425df4a2337f78d3d" translate="yes" xml:space="preserve">
          <source>safeonly: The nullable annotation context is enabled. The nullable warning context is safeonly. Variables of a reference type are nonnullable. All safety nullability warnings are enabled.</source>
          <target state="translated">Безопасно:Включен нулевой контекст аннотации.Безопасен нулевой контекст предупреждения.Переменные типа ссылки не являются необнуляемыми.Включены все предупреждения о безопасном аннулировании.</target>
        </trans-unit>
        <trans-unit id="3a061cb7a56d7292f241332c224fcac2f287af0a" translate="yes" xml:space="preserve">
          <source>safeonlywarnings: The nullable annotation context is disabled. The nullable warning context is safeonly.
    Variables of a reference type are oblivious. All safety nullability warnings are enabled.</source>
          <target state="translated">Безопасные предупреждения:Контекст аннулируемой аннотации отключен.Нулевой контекст предупреждения безопасно отключен.Переменные типа ссылок забыты.Включены все предупреждения о ничтожности.</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="2abda58ce57dab947ad0b74eb5487833707a6213" translate="yes" xml:space="preserve">
          <source>the following code will be problematic:</source>
          <target state="translated">следующий код будет проблематичен:</target>
        </trans-unit>
        <trans-unit id="43a38bb2effe5dc812d40a39ec117e6b0fd8f1fc" translate="yes" xml:space="preserve">
          <source>warnings: The nullable annotation context is disabled. The nullable warning context is enabled. Variables of a reference type are oblivious. All nullability warnings are enabled.</source>
          <target state="translated">предупреждения:Контекст аннулируемой аннотации отключен.Включен нулевой контекст предупреждения.Переменные типа ссылок забыты.Включены все предупреждения об аннулировании.</target>
        </trans-unit>
        <trans-unit id="365054ee499f3b2258d3a22f7fa3f931704bc717" translate="yes" xml:space="preserve">
          <source>where an &lt;strong&gt;&lt;em&gt;unboxing&lt;/em&gt;&lt;/strong&gt; conversion (cast) &lt;em&gt;from&lt;/em&gt;&lt;code&gt;object&lt;/code&gt; (or from one of the classes &lt;code&gt;System.ValueType&lt;/code&gt; or &lt;code&gt;System.Enum&lt;/code&gt;, or from an interface type) &lt;em&gt;to&lt;/em&gt; a value type (other than &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt;) in itself gives the &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">где преобразование &lt;strong&gt;&lt;em&gt;распаковки&lt;/em&gt;&lt;/strong&gt; (приведение) &lt;em&gt;из&lt;/em&gt; &lt;code&gt;object&lt;/code&gt; (или из одного из классов &lt;code&gt;System.ValueType&lt;/code&gt; или &lt;code&gt;System.Enum&lt;/code&gt; или из типа интерфейса) &lt;em&gt;в&lt;/em&gt; тип значения (кроме &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; ) само по себе дает &lt;code&gt;NullReferenceException&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
