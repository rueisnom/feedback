<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/4660142">
    <body>
      <group id="4660142">
        <trans-unit id="9396f5058c8dfed94f5b53595720fed9df43bfa6" translate="yes" xml:space="preserve">
          <source>&quot;Button2&quot; resides on a &lt;code&gt;Panel&lt;/code&gt;</source>
          <target state="translated">&quot;Button2&quot;는 &lt;code&gt;Panel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db5a5b1d9a6c5f4c860c37395021bbd5362fafa2" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;&lt;strong&gt;&lt;em&gt;NullReferenceException&lt;/em&gt;&lt;/strong&gt;&amp;rsquo; also occurs when we forget to instantiate a reference type.</source>
          <target state="translated">' &lt;strong&gt;&lt;em&gt;NullReferenceException&lt;/em&gt;&lt;/strong&gt; '은 참조 유형을 인스턴스화하는 것을 잊었을 때도 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dcee1b5e3a8c625c5a9735ca8c8ec5d25be46495" translate="yes" xml:space="preserve">
          <source>(Another reason for non-using unsafe code unless you need it, by the way)</source>
          <target state="translated">(필요하지 않은 한 안전하지 않은 코드를 사용하지 않는 또 다른 이유)</target>
        </trans-unit>
        <trans-unit id="673f15918a55d1f2ddf729938db9ca922559f3ca" translate="yes" xml:space="preserve">
          <source>.NET collections (of which there are many varieties - Lists, Dictionary, etc.) must also be instantiated or created.</source>
          <target state="translated">.NET 컬렉션 (목록, 사전 등 다양한 종류가 있음)도 인스턴스화하거나 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="c04d4ae82bc72a4bd980abe754c0c8da8a6d3e11" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/11244949/5407188&quot;&gt;Simon Mourier gave this example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/11244949/5407188&quot;&gt;Simon Mourier가이 예를 들었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96e9ca8abbe2f8b39135700b77c31732f2dac12b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AndAlso&lt;/code&gt; is important. Subsequent tests will not be performed once the first &lt;code&gt;False&lt;/code&gt; condition is encountered. This allows the code to safely 'drill' into the object(s) one 'level' at a time, evaluating &lt;code&gt;myFoo.Bar&lt;/code&gt; only after (and if) &lt;code&gt;myFoo&lt;/code&gt; is determined to be valid. Object chains or paths can get quite long when coding complex objects:</source>
          <target state="translated">&lt;code&gt;AndAlso&lt;/code&gt; 중요합니다. 첫 번째 &lt;code&gt;False&lt;/code&gt; 조건이 발생하면 후속 테스트는 수행되지 않습니다. 이를 통해 코드는 한 번에 하나의 '레벨'로 객체를 안전하게 '드릴'할 수 있으며 &lt;code&gt;myFoo&lt;/code&gt; 가 유효한 것으로 판단 된 후에 만 &lt;code&gt;myFoo.Bar&lt;/code&gt; 를 평가할 수 있습니다. 복잡한 객체를 코딩 할 때 객체 체인 또는 경로가 상당히 길어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa6c4cd32e971c86b94f356d10264f19fc10c956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C#&lt;/code&gt; has an &quot;unsafe&quot; mode which is, as the name implies, extremely dangerous because the normal safety mechanisms which provide memory safety and type safety are not enforced. &lt;strong&gt;You should not be writing unsafe code unless you have a thorough and deep understanding of how memory works&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;C#&lt;/code&gt; 에는 &quot;안전하지 않은&quot;모드가 있는데, 이는 이름에서 알 수 있듯이 메모리 안전 및 형식 안전성을 제공하는 일반적인 안전 메커니즘이 적용되지 않기 때문에 매우 위험합니다. &lt;strong&gt;메모리 작동 방식을 철저하고 깊이 이해하지 않으면 안전하지 않은 코드를 작성해서는 안됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7bd3d214087af937aaa899e455d518fc953c1f01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C#&lt;/code&gt; supports &quot;iterator blocks&quot; (called &quot;generators&quot; in some other popular languages).  Null dereference exceptions can be particularly tricky to debug in iterator blocks because of deferred execution:</source>
          <target state="translated">&lt;code&gt;C#&lt;/code&gt; 은 &quot;반복자 블록&quot;(일부 인기있는 다른 언어에서는 &quot;생성기&quot;라고 함)을 지원합니다. Null 역 참조 예외는 지연된 실행으로 인해 반복기 블록에서 디버그하기가 특히 까다로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b65a828172fbdbfca98814450da810920765da6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fill&lt;/code&gt; is a function returning the number of &lt;code&gt;Rows&lt;/code&gt; affected which can also be tested:</source>
          <target state="translated">&lt;code&gt;Fill&lt;/code&gt; 는 영향을받는 &lt;code&gt;Rows&lt;/code&gt; 수를 반환하는 함수이며 테스트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="29fd8c9bf04ffae44443b4d6b120d8e689bf6af6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FirstOrDefault&lt;/code&gt; returns the first item or the default value, which is &lt;code&gt;Nothing&lt;/code&gt; for reference types and never &lt;code&gt;DBNull&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;FirstOrDefault&lt;/code&gt; 는 첫 번째 항목 또는 기본값을 반환합니다.이 값은 참조 유형에 대해서는 &lt;code&gt;Nothing&lt;/code&gt; 이며 결코 &lt;code&gt;DBNull&lt;/code&gt; 이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="dc1f250a72423388fb398e4efb0f2038c0f0e84a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; is implicitly cast to and from &lt;code&gt;T&lt;/code&gt; so you can use it just about anywhere you need it. For example, you can pass a &lt;code&gt;Person&lt;/code&gt; object to a method that takes a &lt;code&gt;NotNull&amp;lt;Person&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; 은 T에서 암시 적으로 캐스트되므로 필요한 곳 ​​어디에서나 사용할 수 있습니다. 예를 들어, &lt;code&gt;Person&lt;/code&gt; 객체를 &lt;code&gt;NotNull&amp;lt;Person&amp;gt;&lt;/code&gt; 을 취하는 메소드에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65aa590b67401c4fef80a64a246bc794d6e41210" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WPF&lt;/code&gt; controls are created during the call to &lt;code&gt;InitializeComponent&lt;/code&gt; in the order they appear in the visual tree.  A &lt;code&gt;NullReferenceException&lt;/code&gt; will be raised in the case of early-created controls with event handlers, etc. , that fire during &lt;code&gt;InitializeComponent&lt;/code&gt; which reference late-created controls.</source>
          <target state="translated">&lt;code&gt;InitializeComponent&lt;/code&gt; 를 호출하는 동안 시각적 트리에 나타나는 순서대로 &lt;code&gt;WPF&lt;/code&gt; 컨트롤이 만들어집니다. 늦게 생성 된 컨트롤을 참조하는 &lt;code&gt;InitializeComponent&lt;/code&gt; 중에 발생하는 이벤트 처리기 등을 사용하여 초기에 생성 된 컨트롤의 경우 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="250ae2f1196236ab82456278c60d302569df1d86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; throws when you try to iterate null collection. Usually caused by unexpected &lt;code&gt;null&lt;/code&gt; result from methods that return collections.</source>
          <target state="translated">null 수집을 반복하려고하면 &lt;code&gt;foreach&lt;/code&gt; 가 발생합니다. 일반적으로 컬렉션을 반환하는 메서드에서 예기치 않은 &lt;code&gt;null&lt;/code&gt; 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e6b825efa75e489e263e621391b24d1af984c6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; can have different meanings:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 은 다른 의미를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a96f0fc9fadca9ec24ec9a32f5951496d8252794" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;ldquo;Hey wait, that member has no values so it can&amp;rsquo;t perform the task which you are handing it over.&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&quot;잠깐만 요, 그 멤버는 가치가 없어서 당신이 맡고있는 작업을 수행 할 수 없습니다.&quot;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de7fbf64ea77b998421c892cac8cea0e19d55573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The arrays and collections cannot be initialized this way.&lt;/em&gt; This initialization code will run &lt;em&gt;before&lt;/em&gt; the constructor creates the &lt;code&gt;Form&lt;/code&gt; or the &lt;code&gt;Controls&lt;/code&gt;. As a result:</source>
          <target state="translated">&lt;em&gt;이 방법으로 배열과 컬렉션을 초기화 할 수 없습니다.&lt;/em&gt; 이 초기화 코드는 생성자가 &lt;code&gt;Form&lt;/code&gt; 또는 &lt;code&gt;Controls&lt;/code&gt; 를 만들기 &lt;em&gt;전에&lt;/em&gt; 실행됩니다. 결과적으로 :</target>
        </trans-unit>
        <trans-unit id="c46586bc5c89bdef6d4b1e03c01b4dd0ec5d4806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Built-in like Nullable?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Nullable처럼 내장되어 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75800f606b4d1c6ba12f783ca4570bf7ff6448ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;인수 확인&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c09c6f450bd3f06e6cd9a53cf34fa6d2204595f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Combine with Extension&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;확장과 결합&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c53baf9a2776f02becbdc77ff91727f9331686" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9982a3d97a9090ed22f6a37e2cf0f2ae71f563db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7846c489294df2d5060a36081cb8e8043018b8e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="850a808c9ba0be28dfd19e88b1b1677f0e685ba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example: Array of class objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 : 클래스 객체의 배열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0832c4cbf43ec158d395216191b77095c211750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Missing the &lt;code&gt;New&lt;/code&gt; operator is the #1 cause of &lt;code&gt;NullReference Exceptions&lt;/code&gt;&lt;/strong&gt; seen in the Stack&amp;nbsp; Overflow questions reviewed.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;New&lt;/code&gt; 연산자 누락은&lt;/strong&gt; 검토 된 스택 오버플로 질문에서 볼 수있는 &lt;strong&gt; &lt;code&gt;NullReference Exceptions&lt;/code&gt; 원인입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="65dcf051b0f8d4d6b70a92dd10d98dbbb05e7cdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d3ff5e8673cda37c5affb24969d0778d496d93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that accessing it via &lt;code&gt;a.Value&lt;/code&gt; throws an &lt;code&gt;InvalidOperationException&lt;/code&gt; instead of a &lt;code&gt;NullReferenceException&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; - you should do the check beforehand, i.e. if you have another on-nullable variable &lt;code&gt;int b;&lt;/code&gt; then you should do assignments like &lt;code&gt;if (a.HasValue) { b = a.Value; }&lt;/code&gt; or shorter &lt;code&gt;if (a != null) { b = a; }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;a.Value&lt;/code&gt; 를 통해 액세스하면 &lt;code&gt;NullReferenceException&lt;/code&gt; 대신 &lt;code&gt;InvalidOperationException&lt;/code&gt; 이 발생합니다. 미리 검사를 수행해야합니다. 예를 들어 다른 널 입력 가능 변수가있는 경우 &lt;code&gt;int b;&lt;/code&gt; 그런 다음 &lt;code&gt;if (a.HasValue) { b = a.Value; }&lt;/code&gt; 와 같은 할당을 수행해야합니다 . } 또는 더 짧은 &lt;code&gt;if (a != null) { b = a; }&lt;/code&gt; } .</target>
        </trans-unit>
        <trans-unit id="9d2ecfee61125d9d0e8d312294babd37f799e11c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; this applies to any and all control and component references making these illegal where they are:</source>
          <target state="translated">이는 다음과 같은 경우 불법으로 만드는 모든 제어 및 구성 요소 참조에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa53a7cd617380a4fd41905587ebe1ed03bfd709" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Partial Remedy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;부분 치료&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b45cb9af41d027f3c66db6de15f935162538c51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plain Code Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;일반 코드 솔루션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c266b17f2c6ab7e2c85ed00ba5d7beabc25b959e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reason&lt;/strong&gt;
I am still not sure about the reason. But whenever any of the entity class will extend System.Web.UI.Page this error occurs.</source>
          <target state="translated">&lt;strong&gt;이유&lt;/strong&gt; 나는 여전히 그 이유에 대해 확신하지 못한다. 그러나 엔터티 클래스가 System.Web.UI.Page를 확장 할 때마다이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a268ab5a5be194c793236306a7663da71dfa4d72" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference types (these ones must be checked):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참조 유형 (이 유형을 확인해야 함) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87d7c3eb34164ea52ebb8bc8dd28ee4033a68905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Related Language Feature&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;관련 언어 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f132283beed6a6da06cca0d2093c020e2034387" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remedy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Remedy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00798c0e0efa455834c71c3500c45ed823e69637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR:&lt;/strong&gt; Try using &lt;code&gt;Html.Partial&lt;/code&gt; instead of &lt;code&gt;Renderpage&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;TL; DR :&lt;/strong&gt; &lt;code&gt;Html.Partial&lt;/code&gt; 대신 Html.Partial을 사용해보십시오 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb06fe911bd525f50ffb0ed996518a64e1313f34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is basically is a Null reference exception&lt;/strong&gt;. As &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;Microsoft&lt;/a&gt; states-</source>
          <target state="translated">&lt;strong&gt;이것은 기본 적으로 Null 참조 예외&lt;/strong&gt; 입니다. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;Microsoft는 다음과&lt;/a&gt; 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="1aa4d335741197b3563f86a40f2c97a83f320da3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; It is worth mentioning that the term was coined by Bertrand Meyer &lt;a href=&quot;https://www.eiffel.com/values/design-by-contract/&quot;&gt;in connection with his design of the Eiffel programming language&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;업데이트 :&lt;/strong&gt; 이 용어는 &lt;a href=&quot;https://www.eiffel.com/values/design-by-contract/&quot;&gt;에펠 프로그래밍 언어의 디자인과 관련하여&lt;/a&gt; Bertrand Meyer 에 의해 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="0181926e0a4573b951577d60df9ca7c39553610c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update C#8.0, 2019: Nullable reference types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C # 8.0, 2019 업데이트 : Nullable 참조 유형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72b28d75192ac7fb08e2f8d3a79cec1a52ea9e34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Tools&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;도구 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c87f2201b452dcaacc0b8af07815a06349212165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value types (you can simply ignore these ones):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;값 유형 (단순히 무시할 수 있음) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6d4f708a4dc9fe6716ce23566f161236c78feea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What can you do about it?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그것에 대해 무엇을 할 수 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8caed790388a2aa0b4f38d928f3144b76a25e1b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;  If Break on Throws is too aggressive and the debugger stops on an NPE in the .NET or 3rd-party library, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/038tzxdw.aspx&quot;&gt;Break on User-Unhandled&lt;/a&gt; can be used to limit the exceptions caught. Additionally, VS2012 introduces &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn457346.aspx&quot;&gt;Just My Code&lt;/a&gt; which I recommend enabling as well.</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; Break on Throws가 너무 공격적이며 .NET 또는 타사 라이브러리의 NPE에서 디버거가 중지되면 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/038tzxdw.aspx&quot;&gt;User-Unhandled&lt;/a&gt; 에서 Break를 사용하여 포착 된 예외를 제한 할 수 있습니다. 또한 VS2012에는 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn457346.aspx&quot;&gt;Just My Code&lt;/a&gt; 가 도입되어 활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cf4e02ba110e4be0ec3bfb627b852463f12d2845" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MsgBox&lt;/code&gt; in the Catch which displays &lt;code&gt;Error while...&lt;/code&gt; will be of little help. This method also leads to &lt;em&gt;very bad&lt;/em&gt; Stack&amp;nbsp; Overflow questions, because you can't describe the actual exception, the object involved or even the line of code where it happens.</source>
          <target state="translated">Catch의 &lt;code&gt;MsgBox&lt;/code&gt; 는 &lt;code&gt;Error while...&lt;/code&gt; 을 표시하는데 도움이되지 않습니다. 이 방법은 또한 실제 예외, 관련된 객체 또는 발생하는 코드 라인을 설명 할 수 없기 때문에 &lt;em&gt;매우 잘못된&lt;/em&gt; 스택 오버플로 질문으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="ba104c53b06fc122661823449802aea76782c8e0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NullReferenceException&lt;/code&gt; is thrown when we are trying to access Properties of a null object or when a string value becomes empty and we are trying to access string methods.</source>
          <target state="translated">&lt;code&gt;NullReferenceException&lt;/code&gt; 은 null 객체의 속성에 액세스하려고하거나 문자열 값이 비어 있고 문자열 메서드에 액세스하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa5b3e9455e644e78a417418f58466e0a5a103cd" translate="yes" xml:space="preserve">
          <source>A NullReferenceException exception is thrown when you try to access a
  member of a type whose value is null.</source>
          <target state="translated">값이 null 인 유형의 멤버에 액세스하려고하면 NullReferenceException 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8ff26f3ebffad79c215bd07bdac08f78eb5f7da" translate="yes" xml:space="preserve">
          <source>A badly implemented Try/Catch can hide where the problem is and result in new ones:</source>
          <target state="translated">잘못 구현 된 Try / Catch는 문제가있는 위치를 숨기고 새로운 문제를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d4ec18cde40fd73c38c9b684b0330cd485bb285" translate="yes" xml:space="preserve">
          <source>A common oversight is a class which uses a collection &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">일반적인 감독은 컬렉션 &lt;code&gt;Type&lt;/code&gt; 을 사용하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d9cf0a18f606a29539af3e0ce3af33a36d691ebb" translate="yes" xml:space="preserve">
          <source>A more &quot;formal&quot; way of preventing such error conditions &lt;em&gt;while developing&lt;/em&gt; is applying &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;design by contract&lt;/a&gt;&lt;/em&gt; in your code. This means you need to set class &lt;em&gt;invariants&lt;/em&gt;, and/or even function/method &lt;em&gt;preconditions&lt;/em&gt; and &lt;em&gt;postconditions&lt;/em&gt; on your system, while developing.</source>
          <target state="translated">&lt;em&gt;개발하는 동안&lt;/em&gt; 이러한 오류 조건 &lt;em&gt;을&lt;/em&gt; 방지하는보다 &quot;공식적인&quot;방법은 &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;계약&lt;/a&gt;&lt;/em&gt; 에 따라 코드를 &lt;em&gt;설계하는&lt;/em&gt; 것입니다. 즉, 개발하는 동안 클래스 &lt;em&gt;불변&lt;/em&gt; 값을 설정하거나 시스템의 기능 / 메소드 &lt;em&gt;전제 조건&lt;/em&gt; 및 &lt;em&gt;사후 조건을&lt;/em&gt; 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="eebbb33808aa207e49bada59a5125167df24f614" translate="yes" xml:space="preserve">
          <source>A note on null dereferences in unsafe code</source>
          <target state="translated">안전하지 않은 코드에서 null 역 참조에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="8dafbafccce845b67afeb7b01438fe1945ef8d44" translate="yes" xml:space="preserve">
          <source>A nullable reference type is noted using the same syntax as nullable value types: a &lt;code&gt;?&lt;/code&gt; is appended to the type of the variable.</source>
          <target state="translated">널 입력 가능 참조 유형은 널 입력 가능 값 유형과 동일한 구문을 사용하여 표시됩니다 &lt;code&gt;?&lt;/code&gt; 변수 유형에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6c02c614bce01e1bf2b2913bce9723ce07012a79" translate="yes" xml:space="preserve">
          <source>A typo is a problem here: &lt;code&gt;Employees&lt;/code&gt; vs &lt;code&gt;Employee&lt;/code&gt;. There was no &lt;code&gt;DataTable&lt;/code&gt; named &quot;Employee&quot; created, so a &lt;code&gt;NullReferenceException&lt;/code&gt; results trying to access it. Another potential problem is assuming there will be &lt;code&gt;Items&lt;/code&gt; which may not be so when the SQL includes a WHERE clause.</source>
          <target state="translated">오타는 여기서 문제입니다 : &lt;code&gt;Employees&lt;/code&gt; vs &lt;code&gt;Employee&lt;/code&gt; . 이름이 &quot;Employee&quot;인 &lt;code&gt;DataTable&lt;/code&gt; 이 없으므로 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 액세스하려고합니다. 또 다른 잠재적 인 문제는 SQL에 WHERE 절이 포함되어있을 때 그렇지 않을 수있는 &lt;code&gt;Items&lt;/code&gt; 이 있다고 가정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6a5c83300e66ad46127b977adb89a522156c686" translate="yes" xml:space="preserve">
          <source>ASP.NET MVC empty view models</source>
          <target state="translated">ASP.NET MVC 빈 뷰 모델</target>
        </trans-unit>
        <trans-unit id="80c38c96a03773866e5a09fd7dd429a0be9d8b8b" translate="yes" xml:space="preserve">
          <source>ASP.NET Page Life cycle:</source>
          <target state="translated">ASP.NET 페이지 수명주기 :</target>
        </trans-unit>
        <trans-unit id="3f5c6dc0c3d2cadb4509844c76624cbfb304e229" translate="yes" xml:space="preserve">
          <source>ASP.NET Session Values</source>
          <target state="translated">ASP.NET 세션 값</target>
        </trans-unit>
        <trans-unit id="940be3748f3da7281fcd8700b0e3178729d37f82" translate="yes" xml:space="preserve">
          <source>Access Levels in Visual Basic</source>
          <target state="translated">Visual Basic의 액세스 수준</target>
        </trans-unit>
        <trans-unit id="b85c4bdae0c350f5711f14487cc734ddd712d0bb" translate="yes" xml:space="preserve">
          <source>Add a RigidBody to your object with AddComponent &amp;gt; Physics &amp;gt; Rigidbody</source>
          <target state="translated">AddComponent&amp;gt; Physics&amp;gt; Rigidbody를 사용하여 객체에 RigidBody 추가</target>
        </trans-unit>
        <trans-unit id="3c06a5e5b3bffeb1ffe32764c5df1d75e8641b16" translate="yes" xml:space="preserve">
          <source>Adding a case when the class name for entity used in entity framework is same as class name for a web form code-behind file.</source>
          <target state="translated">엔티티 프레임 워크에서 사용되는 엔티티의 클래스 이름이 웹 양식 코드 숨김 파일의 클래스 이름과 동일한 경우를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="64da57dde1ffb2a7b141dfc69a64073197586ac7" translate="yes" xml:space="preserve">
          <source>Alternatively, design by contract can be applied using &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Assertion_%28software_development%29&quot;&gt;assertions&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">또는 &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Assertion_%28software_development%29&quot;&gt;어설 션을&lt;/a&gt;&lt;/em&gt; 사용하여 계약 별 디자인을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7effb34e016a409606b0e15fd08ec8c4497e3b4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;(ComboBox5.SelectedItem IsNot Nothing) AndAlso...&lt;/code&gt;</source>
          <target state="translated">또는 &lt;code&gt;(ComboBox5.SelectedItem IsNot Nothing) AndAlso...&lt;/code&gt; 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5666d3ec19bdd1846f3f244409d303ff8154592b" translate="yes" xml:space="preserve">
          <source>Although I have a feeling it was because Visual Studio was misreading the ampersands and brackets.</source>
          <target state="translated">Visual Studio가 앰퍼샌드와 괄호를 잘못 읽고 있기 때문에 느낌이 들었습니다.</target>
        </trans-unit>
        <trans-unit id="9fd253c7dc5c61cba35ce66730957de70d270eee" translate="yes" xml:space="preserve">
          <source>Always initialize your objects before you try to do anything with them.</source>
          <target state="translated">무언가를 시도하기 전에 항상 객체를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="3b6e8a6740e24bceb43df548fef899179aae1d8a" translate="yes" xml:space="preserve">
          <source>Among other things, this code does not anticipate that the user may not have selected something in one or more UI controls.  &lt;code&gt;ListBox1.SelectedItem&lt;/code&gt; may well be &lt;code&gt;Nothing&lt;/code&gt;, so &lt;code&gt;ListBox1.SelectedItem.ToString&lt;/code&gt; will result in an NRE.</source>
          <target state="translated">무엇보다도이 코드는 사용자가 하나 이상의 UI 컨트롤에서 무언가를 선택하지 않았을 것으로 예상하지 않습니다. &lt;code&gt;ListBox1.SelectedItem&lt;/code&gt; 은 &lt;code&gt;Nothing&lt;/code&gt; 일 수 있으므로 &lt;code&gt;ListBox1.SelectedItem.ToString&lt;/code&gt; 은 NRE가됩니다.</target>
        </trans-unit>
        <trans-unit id="88a4f159e8121bbcda704144caf67fd92f8461ea" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;Catch&lt;/code&gt; block is the devil's playground. This OP was baffled why he was getting an NRE in the &lt;code&gt;Finally&lt;/code&gt; block. In other situations, an empty &lt;code&gt;Catch&lt;/code&gt; may result in something else much further downstream going haywire and cause you to spend time looking at the wrong things in the wrong place for the problem. (The &quot;silent exception&quot; described above provides the same entertainment value.)</source>
          <target state="translated">빈 &lt;code&gt;Catch&lt;/code&gt; 블록은 악마의 놀이터입니다. 이 OP는 왜 Final 블록에서 NRE를 받고 있었는지 당황했습니다. 다른 상황에서, 빈 &lt;code&gt;Catch&lt;/code&gt; 가 비어 있으면 하류로가는 훨씬 더 많은 다운 스트림이 생길 수 있으며 문제의 잘못된 장소에서 잘못된 것을 보는 데 시간을 소비하게됩니다. 위에서 설명한 &quot;자동 예외&quot;는 동일한 엔터테인먼트 가치를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9157a41acb7ec9a4b1beccee4b4d84c91c8fa2d2" translate="yes" xml:space="preserve">
          <source>An example of this exception being thrown is: When you are trying to check something, that is null.</source>
          <target state="translated">이 예외가 발생하는 예는 다음과 같습니다. 무언가를 확인하려고하면 null입니다.</target>
        </trans-unit>
        <trans-unit id="a1ec28efc8675e603132b97526fc40e135d46f85" translate="yes" xml:space="preserve">
          <source>And here is an example of how it could be used:</source>
          <target state="translated">다음은 사용 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="e727d2eac2d0a071ac7dcfe039aef6ace695286e" translate="yes" xml:space="preserve">
          <source>And it worked.</source>
          <target state="translated">그리고 효과가있었습니다.</target>
        </trans-unit>
        <trans-unit id="324e44de5ebb6296d39aa1bfc28925673b0c6b21" translate="yes" xml:space="preserve">
          <source>Another case where &lt;code&gt;NullReferenceExceptions&lt;/code&gt; can happen is the (incorrect) use of the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/as&quot;&gt;&lt;code&gt;as&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;NullReferenceExceptions&lt;/code&gt; 이 발생할 수있는 또 다른 경우는 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/as&quot;&gt; &lt;code&gt;as&lt;/code&gt; 연산자를&lt;/a&gt; 잘못 사용하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="faf985078920eb0c5453270c90bdc97bdefa6713" translate="yes" xml:space="preserve">
          <source>Another general case where one might receive this exception involves mocking classes during unit testing. Regardless of the mocking framework being used, you must ensure that all appropriate levels of the class hierarchy are properly mocked. In particular, all properties of &lt;code&gt;HttpContext&lt;/code&gt; which are referenced by the code under test must be mocked.</source>
          <target state="translated">이 예외가 발생할 수있는 또 다른 일반적인 경우는 단위 테스트 중에 클래스를 조롱하는 것입니다. 사용되는 조롱 프레임 워크에 관계없이 모든 적절한 수준의 클래스 계층 구조가 제대로 조롱되었는지 확인해야합니다. 특히 테스트중인 코드에서 참조하는 &lt;code&gt;HttpContext&lt;/code&gt; 의 모든 속성을 조롱해야합니다.</target>
        </trans-unit>
        <trans-unit id="defecdb8e8875605297d57b7667ccb8e2cd0b5be" translate="yes" xml:space="preserve">
          <source>Another scenario is when you cast a null object into a &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;value type&lt;/a&gt;. For example, the code below:</source>
          <target state="translated">또 다른 시나리오는 널 오브젝트를 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;값 유형&lt;/a&gt; 으로 캐스트 할 때입니다. 예를 들어 아래 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="66865b7becb2eab1937b4ac3fd0252b0e3a5b1a9" translate="yes" xml:space="preserve">
          <source>Array Elements</source>
          <target state="translated">배열 요소</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="b6fa4a287953008cbde69102b90389d57d42adc5" translate="yes" xml:space="preserve">
          <source>Arrays in Visual Basic</source>
          <target state="translated">Visual Basic의 배열</target>
        </trans-unit>
        <trans-unit id="d1699665973226819efc1a3192672777466c31f6" translate="yes" xml:space="preserve">
          <source>Arrays must also be instantiated:</source>
          <target state="translated">배열도 인스턴스화해야합니다.</target>
        </trans-unit>
        <trans-unit id="38bc53bbadc56c1c1c3af2a66bca49127ec6ded9" translate="yes" xml:space="preserve">
          <source>As before, the &lt;code&gt;ds&lt;/code&gt; Dataset object was declared, but an instance was never created. The &lt;code&gt;DataAdapter&lt;/code&gt; will fill an existing &lt;code&gt;DataSet&lt;/code&gt;, not create one. In this case, since &lt;code&gt;ds&lt;/code&gt; is a local variable, &lt;em&gt;the IDE warns you&lt;/em&gt; that this might happen:</source>
          <target state="translated">이전과 마찬가지로 &lt;code&gt;ds&lt;/code&gt; Dataset 객체가 선언되었지만 인스턴스가 생성되지 않았습니다. &lt;code&gt;DataAdapter&lt;/code&gt; 는 기존 &lt;code&gt;DataSet&lt;/code&gt; 을 채우지 않고 채 웁니다. 이 경우 &lt;code&gt;ds&lt;/code&gt; 는 로컬 변수이므로 &lt;em&gt;IDE는&lt;/em&gt; 이러한 상황이 발생할 &lt;em&gt;수&lt;/em&gt; 있음을 &lt;em&gt;경고합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a8225bf15fe959f426e87bc59fb66f54584b8477" translate="yes" xml:space="preserve">
          <source>As before, this is incorrect:</source>
          <target state="translated">이전과 같이 이것은 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34d0293b6d44a69f8098139a2697ae8c8c463b8c" translate="yes" xml:space="preserve">
          <source>As before, you can test for Nothing, then for a specific value:</source>
          <target state="translated">이전과 같이 Nothing을 테스트 한 다음 특정 값을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c8719c108394130c727bec7ba9f10b86c8bcb74" translate="yes" xml:space="preserve">
          <source>As seen in the above code, the statement 
&lt;strong&gt;Student s&lt;/strong&gt; - only declares the variable of type Student, note that the Student class is not instantiated at this point.
Hence, when the statement &lt;strong&gt;s.GetFullName()&lt;/strong&gt; gets executed, it will throw the NullReferenceException.</source>
          <target state="translated">위 코드에서 볼 수 있듯이 &lt;strong&gt;Student s&lt;/strong&gt; 문은 &lt;strong&gt;Student&lt;/strong&gt; 유형의 변수 만 선언합니다. 이때 Student 클래스는 인스턴스화되지 않습니다. 따라서 &lt;strong&gt;s.GetFullName ()&lt;/strong&gt; 문이 실행될 때 NullReferenceException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0238c2f1a73f80203ea54ce74e1fa5c52ec85a2b" translate="yes" xml:space="preserve">
          <source>As you can see above as with nullable you would access the underlying value through the &lt;code&gt;Value&lt;/code&gt; property. Alternatively, you can use an explicit or implicit cast, you can see an example with the return value below:</source>
          <target state="translated">위에서 null을 허용하는 것처럼 볼 수 있듯이 &lt;code&gt;Value&lt;/code&gt; 속성을 통해 기본 값에 액세스합니다. 또는 명시 적 또는 암시 적 캐스트를 사용할 수 있습니다. 아래 반환 값이있는 예제를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55898edce8a3dc771bf65a61dd6c66bcff4e10b3" translate="yes" xml:space="preserve">
          <source>Assume that you have a class named Student.</source>
          <target state="translated">Student라는 클래스가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="be34f295e410696ad2a87bdbe307bddd6ac8d2e7" translate="yes" xml:space="preserve">
          <source>Basic Meaning</source>
          <target state="translated">기본 의미</target>
        </trans-unit>
        <trans-unit id="f2896aad58b9a8eecc0ba25ee5c59866bcde93ab" translate="yes" xml:space="preserve">
          <source>Be aware that regardless of the scenario, the cause is always the same in .NET:</source>
          <target state="translated">시나리오에 관계없이 .NET에서는 원인이 항상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4b8773ed0bc20f439c181fd5242b7f12bd9a63f5" translate="yes" xml:space="preserve">
          <source>Both a null pointer and a null reference in &lt;code&gt;C#&lt;/code&gt; are internally represented as the number zero, and so any attempt to dereference it into its corresponding memory storage causes the operating system to produce an error. The .NET runtime then detects this error and turns it into the null dereference exception.</source>
          <target state="translated">&lt;code&gt;C#&lt;/code&gt; 에서 Null 포인터와 Null 참조는 모두 내부적으로 숫자 0으로 표시되므로이를 해당 메모리 저장소로 역 참조하려고하면 운영 체제에서 오류가 발생합니다. 그런 다음 .NET 런타임은이 오류를 감지하여 null 역 참조 예외로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="80ab619b17d9355ace0bbedb905733aed5398463" translate="yes" xml:space="preserve">
          <source>Bottom Line</source>
          <target state="translated">결론</target>
        </trans-unit>
        <trans-unit id="21a8752f2df54d656b09cd2a499cb3a3403ec7ca" translate="yes" xml:space="preserve">
          <source>Breakpoints</source>
          <target state="translated">Breakpoints</target>
        </trans-unit>
        <trans-unit id="86d14f9a7de18ff1120d5c17aa3bb8490cf58228" translate="yes" xml:space="preserve">
          <source>But I was able to run the application with no problems with this &quot;error&quot;. I was able to get rid of the error by changing the structure of the &lt;code&gt;foreach&lt;/code&gt; loop to look like this:</source>
          <target state="translated">그러나이 &quot;오류&quot;에 문제없이 응용 프로그램을 실행할 수있었습니다. &lt;code&gt;foreach&lt;/code&gt; 루프의 구조를 다음과 같이 변경하여 오류를 제거 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="342f568362575e92cb6067d8461a39a6a40941c4" translate="yes" xml:space="preserve">
          <source>But if you set &quot;property X must never have a null value&quot; as method precondition, then you can prevent the scenario described before:</source>
          <target state="translated">그러나 &quot;속성 X에 null 값이 없어야 함&quot;을 메소드 전제 조건으로 설정하면 앞에서 설명한 시나리오를 막을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e174293e71614f4dcd5e8efa21b20f2c2ea09dd" translate="yes" xml:space="preserve">
          <source>By doing that and making PostSharp part of your build process &lt;code&gt;obj&lt;/code&gt; will be checked for null at runtime. See: &lt;a href=&quot;http://www.postsharp.net/blog/post/Validating-parameters-field-and-properties-in-PostSharp-3&quot;&gt;PostSharp null check&lt;/a&gt;</source>
          <target state="translated">그렇게하고 빌드 프로세스의 PostSharp를 만들면 런타임에 &lt;code&gt;obj&lt;/code&gt; 가 null인지 확인합니다. 참조 : &lt;a href=&quot;http://www.postsharp.net/blog/post/Validating-parameters-field-and-properties-in-PostSharp-3&quot;&gt;PostSharp null 검사&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64c2e10dbbbf9ef720a7c8d02d4aa8e8cf77773e" translate="yes" xml:space="preserve">
          <source>By finding by name I mean some framework allow you to FIndObjects using strings and the code might look like this: &lt;strong&gt;FindObject(&quot;ObjectName&quot;);&lt;/strong&gt;</source>
          <target state="translated">이름으로 찾음에 따라 일부 프레임 워크에서 문자열을 사용하여 FIndObject를 찾을 수 있으며 코드는 다음과 같습니다. &lt;strong&gt;FindObject ( &quot;ObjectName&quot;);&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d2fbdf206c06f82b8ff7b2a9385b7bc273f6c" translate="yes" xml:space="preserve">
          <source>By following the program flow this way, you can find the location where the instance should not be null, and why it isn't properly set.</source>
          <target state="translated">이 방법으로 프로그램 흐름을 따르면 인스턴스가 null이 아니어야하는 위치와 제대로 설정되지 않은 이유를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0af3e909e29bebca060f842d0113445956bb71a3" translate="yes" xml:space="preserve">
          <source>By writing a null check like this you prevent the null dereference, but you move the null argument exception to the point of the &lt;em&gt;iteration&lt;/em&gt;, not to the point of the &lt;em&gt;call&lt;/em&gt;, and that is &lt;em&gt;very confusing to debug&lt;/em&gt;.</source>
          <target state="translated">이와 같이 null 검사를 작성하면 null 역 참조를 방지 할 수 있지만 null 인수 예외를 &lt;em&gt;호출&lt;/em&gt; 지점이 아닌 &lt;em&gt;반복&lt;/em&gt; 지점으로 이동하면 &lt;em&gt;디버그하기&lt;/em&gt; 가 &lt;em&gt;매우 복잡합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="910e894dcb9055a378eccef35ef795771f7bb251" translate="yes" xml:space="preserve">
          <source>C# 6.0 introduced the &quot;null-conditional operator&quot; that helps with this a little. With this feature, you can reference nested objects and if any one of them is &lt;code&gt;null&lt;/code&gt; the whole expression returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">C # 6.0에서는이를 지원하는 &quot;무조건 연산자&quot;가 도입되었습니다. 이 기능을 사용하면 중첩 된 객체를 참조 할 수 있으며 그 중 하나가 &lt;code&gt;null&lt;/code&gt; 이면 전체 표현식이 &lt;code&gt;null&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06971ac0fe2094d0b96705ec2de4ff7f4c00141d" translate="yes" xml:space="preserve">
          <source>C# has a nice shorthand for &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, you can make something nullable by putting a question mark after the type like so &lt;code&gt;int?&lt;/code&gt;.</source>
          <target state="translated">C #에는 &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; 약어가 있습니다. &lt;code&gt;int?&lt;/code&gt; 와 같은 형식 뒤에 물음표를 넣어서 nullable을 만들 수 있습니까? .</target>
        </trans-unit>
        <trans-unit id="3d4cb34a5ed28713ba6e8d1854e778ef083e674d" translate="yes" xml:space="preserve">
          <source>C#8.0 introduces &lt;strong&gt;nullable reference types&lt;/strong&gt; and &lt;strong&gt;non-nullable reference types&lt;/strong&gt;. So only nullable reference types must be checked to avoid a &lt;strong&gt;NullReferenceException&lt;/strong&gt;.</source>
          <target state="translated">C # 8.0은 &lt;strong&gt;널 입력 가능 참조 유형&lt;/strong&gt; 과 &lt;strong&gt;널 입력 불가능&lt;/strong&gt; &lt;strong&gt;참조 유형을&lt;/strong&gt; 도입 &lt;strong&gt;합니다&lt;/strong&gt; . 따라서 &lt;strong&gt;NullReferenceException&lt;/strong&gt; 을 피하려면 널 입력 가능 참조 유형 만 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="8dc39f8dd9c9e597efd5512af193d73bcc466778" translate="yes" xml:space="preserve">
          <source>Cast with &lt;code&gt;as&lt;/code&gt;</source>
          <target state="translated">로 캐스트</target>
        </trans-unit>
        <trans-unit id="da4e05c5dc0d067c4057445c2673b31a895c9b01" translate="yes" xml:space="preserve">
          <source>Changing the order of the declarations in the &lt;code&gt;XAML&lt;/code&gt; (i.e., listing &lt;code&gt;label1&lt;/code&gt; before &lt;code&gt;comboBox1&lt;/code&gt;, ignoring issues of design philosophy, would at least resolve the &lt;code&gt;NullReferenceException&lt;/code&gt; here.</source>
          <target state="translated">&lt;code&gt;XAML&lt;/code&gt; 에서 선언의 순서를 변경하면 (즉, 디자인 철학의 문제를 무시하고 &lt;code&gt;comboBox1&lt;/code&gt; 앞에 &lt;code&gt;label1&lt;/code&gt; 을 나열하는 경우) 여기서 적어도 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="f13d71f0e899fe3b305b742c14c426e502ee6355" translate="yes" xml:space="preserve">
          <source>Class Objects / Creating an Instance</source>
          <target state="translated">클래스 객체 / 인스턴스 생성</target>
        </trans-unit>
        <trans-unit id="a6748432889326a79c007d1ba17c6c7cd3373670" translate="yes" xml:space="preserve">
          <source>Collection/List/Dictionary</source>
          <target state="translated">Collection/List/Dictionary</target>
        </trans-unit>
        <trans-unit id="ac972fde3be5ca3a4dcab0cc67b75680615eb722" translate="yes" xml:space="preserve">
          <source>Combine &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; with an extension method and you can cover even more situations. Here is an example of what the extension method can look like:</source>
          <target state="translated">&lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; 을 확장 방법과 결합하면 더 많은 상황을 처리 할 수 ​​있습니다. 다음은 확장 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="223c2967787ab7e442128765b6827c843685a817" translate="yes" xml:space="preserve">
          <source>Compiler for the above code raises an error that variable &lt;strong&gt;obj&lt;/strong&gt; is unassigned which signifies that our variable has null values or nothing. Compiler for the above code raises an error that variable &lt;strong&gt;obj&lt;/strong&gt; is unassigned which signifies that our variable has null values or nothing.</source>
          <target state="translated">위 코드를위한 컴파일러는 변수 &lt;strong&gt;obj&lt;/strong&gt; 가 할당되지 않았다는 오류를 &lt;strong&gt;일으켜&lt;/strong&gt; 변수에 null 값이 있거나 없음을 나타냅니다. 위 코드를위한 컴파일러는 변수 &lt;strong&gt;obj&lt;/strong&gt; 가 할당되지 않았다는 오류를 &lt;strong&gt;일으켜&lt;/strong&gt; 변수에 null 값이 있거나 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bee75ca77f753e4846b455441733f6641c4bf287" translate="yes" xml:space="preserve">
          <source>Controls</source>
          <target state="translated">Controls</target>
        </trans-unit>
        <trans-unit id="1ca5b6d459cb7e4e8503007684404f6a2c26c9c9" translate="yes" xml:space="preserve">
          <source>DBNull is not the same as Nothing</source>
          <target state="translated">DBNull은 Nothing과 같지 않습니다</target>
        </trans-unit>
        <trans-unit id="428b235126d11ccf77cf5d994238ed0919097855" translate="yes" xml:space="preserve">
          <source>Data Provider Objects</source>
          <target state="translated">데이터 제공자 객체</target>
        </trans-unit>
        <trans-unit id="5568339e9f5e145b4c2866450e19d8cc65b1f7d3" translate="yes" xml:space="preserve">
          <source>Debug and let the debugger break... It will directly take you to the variable that is broken... Now your task is to simply fix this.. Using the &lt;strong&gt;new&lt;/strong&gt; keyword in the appropriate place.</source>
          <target state="translated">디버그하고 디버거를 중단 시키십시오 ... 직접 깨진 변수로 이동합니다 ... 이제 작업을 간단하게 수정하는 것입니다. 적절한 위치에서 &lt;strong&gt;새&lt;/strong&gt; 키워드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6f0b5050efbdbd9b4e9f63b62af3e9fede37125c" translate="yes" xml:space="preserve">
          <source>Debugger: For developers, we have the big weapon of Debugging with us. If have we face NullReferenceException during the development face we can use the debugger to get to the source of the exception.</source>
          <target state="translated">디버거 : 개발자에게는 큰 디버깅 무기가 있습니다. 개발 단계에서 NullReferenceException에 직면 한 경우 디버거를 사용하여 예외 소스에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="36fd56a44db41a6f009807b50cd27bc9943148b1" translate="yes" xml:space="preserve">
          <source>Debugging showed the model was Null inside MyOtherView. Until I changed it to:</source>
          <target state="translated">디버깅 결과 모델이 MyOtherView 내부에 Null 인 것으로 나타났습니다. 내가 그것을 바꿀 때까지 :</target>
        </trans-unit>
        <trans-unit id="f2bef4698e9e93b03fbe4d5bae9a889cb96e1075" translate="yes" xml:space="preserve">
          <source>Don't ignore compiler warnings (ever) and use &lt;code&gt;Option Strict On&lt;/code&gt; (always).</source>
          <target state="translated">컴파일러 경고를 무시하지 말고 &lt;code&gt;Option Strict On&lt;/code&gt; (항상)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a116c71d483a8e062649940a075d035fe0d15e1c" translate="yes" xml:space="preserve">
          <source>Don't use empty Try/Catch blocks - let the code crash so you can a) identify the cause b) identify the location and c) apply a proper remedy.  Try/Catch blocks are not intended to hide exceptions from the person uniquely qualified to fix them - the developer.</source>
          <target state="translated">빈 Try / Catch 블록을 사용하지 마십시오. 코드 충돌을 일으켜 a) 원인을 식별합니다. b) 위치를 식별하고 c) 적절한 해결책을 적용하십시오. Try / Catch 블록은 예외를 해결할 자격이있는 사람 (개발자)의 예외를 숨기려는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d7f04facb7d4fb7422ce98a991d56e72f4d24f7c" translate="yes" xml:space="preserve">
          <source>Edge case #1: concurrent access to a Dictionary</source>
          <target state="translated">에지 사례 # 1 : 사전에 동시 액세스</target>
        </trans-unit>
        <trans-unit id="e3ea50cc0b7f4be81be2362bf41478f7130a1285" translate="yes" xml:space="preserve">
          <source>Edge case #2: unsafe code</source>
          <target state="translated">에지 사례 # 2 : 안전하지 않은 코드</target>
        </trans-unit>
        <trans-unit id="6a6853d6e749e4d5b00c4b8d872d66e337db122a" translate="yes" xml:space="preserve">
          <source>Either procedure will result in an NRE, because &lt;code&gt;barList&lt;/code&gt; is only declared, not instantiated. Creating an instance of &lt;code&gt;Foo&lt;/code&gt; will not also create an instance of the internal &lt;code&gt;barList&lt;/code&gt;. It may have been the intent to do this in the constructor:</source>
          <target state="translated">&lt;code&gt;barList&lt;/code&gt; 는 인스턴스화되지 않고 선언되기 때문에 두 프로 시저 중 하나가 NRE가됩니다. &lt;code&gt;Foo&lt;/code&gt; 인스턴스를 만들면 내부 &lt;code&gt;barList&lt;/code&gt; 인스턴스도 만들어지지 않습니다. 생성자 에서이 작업을 수행하려는 의도 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46f567c4dcc5486e4285b45b12d7a9a6e106f7ff" translate="yes" xml:space="preserve">
          <source>Enjoy and have fun making games!</source>
          <target state="translated">즐기고 재미있는 게임 만들기!</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="2ede17026a66f2bb53f3b6978daa3529c4d3bc25" translate="yes" xml:space="preserve">
          <source>Ex:</source>
          <target state="translated">Ex:</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7b7d48ea7b3b293c238f8dc4cd94aa16d688011e" translate="yes" xml:space="preserve">
          <source>Example 2 &amp;mdash; Beware of the NewRow</source>
          <target state="translated">예 2 &amp;mdash; NewRow에주의</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="deec6b3c379dce2b6012e423f46c379377857030" translate="yes" xml:space="preserve">
          <source>Examples and Remedies</source>
          <target state="translated">예와 치료</target>
        </trans-unit>
        <trans-unit id="489c7f142f084f70e38f635ba7b9b348e5d129a5" translate="yes" xml:space="preserve">
          <source>Exception handling: One of the important ways of managing this exception. Using simple try-catch-finally blocks we can control this exception and also maintain a log of it. This can be very useful when your application is on production stage.</source>
          <target state="translated">예외 처리 :이 예외를 관리하는 중요한 방법 중 하나입니다. 간단한 try-catch-finally 블록을 사용하여이 예외를 제어하고 로그를 유지할 수도 있습니다. 응용 프로그램이 프로덕션 단계에있을 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="863e0b11b844698fd5b45fe2becd1c066657e73f" translate="yes" xml:space="preserve">
          <source>Explicit Checking: We should adhere to the tradition of checking the objects, properties, methods, arrays, and collections whether they are null. This can be simply implemented using conditional statements like if-else if-else etc.</source>
          <target state="translated">명시 적 검사 : 개체, 속성, 메서드, 배열 및 컬렉션이 null인지 여부를 확인하는 전통을 준수해야합니다. if-else if-else 등과 같은 조건문을 사용하여 간단하게 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="109df3f9e4f70aee4ff4534f310fc794f8dc97d8" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; and ignore null values.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 명시 적으로 확인하고 널 값을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="31543b579bc99ae672e332aadbdf4f54893ffe8c" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; and provide a default value.</source>
          <target state="translated">명시 적으로 &lt;code&gt;null&lt;/code&gt; 을 확인하고 기본값을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="be6cb31f6768070d27ac716dcf02c1e5b5d94512" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; from method calls and throw a custom exception.</source>
          <target state="translated">메소드 호출에서 &lt;code&gt;null&lt;/code&gt; 을 명시 적으로 확인하고 사용자 정의 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="376a5f377acf229980dec162e286875baba55137" translate="yes" xml:space="preserve">
          <source>Finding The Cause</source>
          <target state="translated">원인 찾기</target>
        </trans-unit>
        <trans-unit id="036893902b168b7c15417cf8b62f2cd292a4a2cd" translate="yes" xml:space="preserve">
          <source>First, make sure that the correct error is going to be caught - see
&lt;a href=&quot;https://stackoverflow.com/questions/4475464/&quot;&gt;How do I allow breaking on 'System.NullReferenceException' in VS2010?&lt;/a&gt;&lt;em&gt;Note&lt;sup&gt;1&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">먼저 올바른 오류가 발생하는지 확인하십시오 &lt;a href=&quot;https://stackoverflow.com/questions/4475464/&quot;&gt;-VS2010의 'System.NullReferenceException'차단을 어떻게 허용합니까?를&lt;/a&gt; 참조하십시오 . &lt;em&gt;참고 &lt;sup&gt;1&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a9bb411b345b451f4de56294a2e04b8bb44acd7" translate="yes" xml:space="preserve">
          <source>Floating-point types</source>
          <target state="translated">부동 소수점 유형</target>
        </trans-unit>
        <trans-unit id="c3b57bba0c6478be6c3878f4976f8768bd6104c1" translate="yes" xml:space="preserve">
          <source>For More details : &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators&quot;&gt;Null-conditional Operators&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators&quot;&gt;Null 조건부 연산자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d625573dda6be4c24b311020c3d5caa8ee0507c" translate="yes" xml:space="preserve">
          <source>For discussion have a look at &lt;a href=&quot;https://stackoverflow.com/questions/17136455/nullreferenceexception-in-dbcontext-savechanges&quot;&gt;NullReferenceException in DbContext.saveChanges()&lt;/a&gt;</source>
          <target state="translated">논의를 위해 &lt;a href=&quot;https://stackoverflow.com/questions/17136455/nullreferenceexception-in-dbcontext-savechanges&quot;&gt;DbContext.saveChanges ()의 NullReferenceException을&lt;/a&gt; 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="88fa3152aa1a080052016562134c18cdbc4e0603" translate="yes" xml:space="preserve">
          <source>For example :</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21d6357b4a277981b9a66afc8fcee08849d0a240" translate="yes" xml:space="preserve">
          <source>For example, methods can check the different arguments to see if they are null and throw an &lt;code&gt;ArgumentNullException&lt;/code&gt;, an exception obviously created for this exact purpose.</source>
          <target state="translated">예를 들어, 메소드는 다른 인수를 검사하여 인수가 널인지 확인하고 &lt;code&gt;ArgumentNullException&lt;/code&gt; 을 던질 수 있습니다. ArgumentNullException 이 예외적 인 목적으로 작성된 예외입니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea87f510412c7e56ffdecaf29378fffd0b2ac212" translate="yes" xml:space="preserve">
          <source>For instance,
in the following line the only code that &lt;em&gt;can&lt;/em&gt; cause the exception is if &lt;code&gt;myString&lt;/code&gt; evaluates to null. This can be verified by looking at the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa290869(v=vs.71).aspx&quot;&gt;Watch Window&lt;/a&gt; or running expressions in the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/f177hahy.aspx&quot;&gt;Immediate Window&lt;/a&gt;.</source>
          <target state="translated">예를 들어, 다음 줄에서 예외를 일으킬 &lt;em&gt;수&lt;/em&gt; 있는 유일한 코드는 &lt;code&gt;myString&lt;/code&gt; 이 null로 평가되는 경우입니다. 이는 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa290869(v=vs.71).aspx&quot;&gt;조사&lt;/a&gt; 식 창을 보거나 직접 실행 창 에서 식을 실행하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3ab9060f75e800aa736a6c6d4a9d5f39e13be8b" translate="yes" xml:space="preserve">
          <source>For me the reason was that I had rename the file and old file was still open.</source>
          <target state="translated">나에게 그 이유는 파일 이름을 바꾸고 이전 파일이 여전히 열려 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ae336d2485d45668cf4b510dc35f9a49b357aa3b" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx&quot;&gt;&lt;code&gt;List(Of T)&lt;/code&gt; Class&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx&quot;&gt; &lt;code&gt;List(Of T)&lt;/code&gt; Class를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cadad1fb936cd59a173ee4ad751226d192504b1" translate="yes" xml:space="preserve">
          <source>For more information, see:</source>
          <target state="translated">자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b6396c3009607565ca4b596f1d3cfe993427c34" translate="yes" xml:space="preserve">
          <source>For the sake of completeness DataContext class</source>
          <target state="translated">완전성을 위해 DataContext 클래스</target>
        </trans-unit>
        <trans-unit id="f241b5f4ab6b5874d32e0e2ef564edcc65cde7d2" translate="yes" xml:space="preserve">
          <source>For this cause, &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264808%28v=vs.110%29.aspx&quot;&gt;Code Contracts&lt;/a&gt;&lt;/em&gt; project exists for .NET applications.</source>
          <target state="translated">이로 인해 .NET 애플리케이션에 대한 &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264808%28v=vs.110%29.aspx&quot;&gt;Code Contracts&lt;/a&gt;&lt;/em&gt; 프로젝트가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="6cfbd5392a130ba8fc377b758d8e7cdc4f1a9d51" translate="yes" xml:space="preserve">
          <source>For your reference I made the code above available on GitHub, you can find it at:</source>
          <target state="translated">참고로 GitHub에서 위의 코드를 사용할 수 있도록 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="c4a1d4b8ee2b3e9ff148b30c5b4c8d7bb468ba9c" translate="yes" xml:space="preserve">
          <source>Function Returning Nothing</source>
          <target state="translated">아무것도 반환하지 않는 함수</target>
        </trans-unit>
        <trans-unit id="bda3e991f9ccd7f64923695508d53cbd3f8354a4" translate="yes" xml:space="preserve">
          <source>Further Notes: If you want unity to add a component to your object and you might have forgotten to add one, you can type &lt;code&gt;[RequireComponent(typeof(RigidBody))]&lt;/code&gt; above your class declaration (the space below all of your usings).</source>
          <target state="translated">추가 참고 사항 : 개체에 구성 요소를 추가하고 단일 구성 요소를 추가하지 않은 경우 클래스 선언 (모든 사용 아래의 공간 &lt;code&gt;[RequireComponent(typeof(RigidBody))]&lt;/code&gt; 위에 [RequireComponent (typeof (RigidBody))]를 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ba86cf22af12011257223c782b9c2388170dce0" translate="yes" xml:space="preserve">
          <source>Furthermore, the reason I didn't have &lt;code&gt;Html.Partial&lt;/code&gt; to begin with was because Visual Studio &lt;strong&gt;sometimes&lt;/strong&gt; throws error-looking squiggly lines under &lt;code&gt;Html.Partial&lt;/code&gt; if it's inside a differently constructed &lt;code&gt;foreach&lt;/code&gt; loop, even though it's not really an error:</source>
          <target state="translated">또한 &lt;code&gt;Html.Partial&lt;/code&gt; 을 시작하지 않은 이유는 Visual Studio가 &lt;code&gt;Html.Partial&lt;/code&gt; 아래에 오류처럼 보이는 구불 구불 한 줄을 던지기 때문입니다. 실제로 오류가 아니더라도 다르게 구성된 &lt;code&gt;foreach&lt;/code&gt; 루프 안에 있으면</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="84ae2f625a61a0ac0cabba1b58ebdefb9ccdd612" translate="yes" xml:space="preserve">
          <source>Generic dictionaries in .NET are not thread-safe and they &lt;em&gt;sometimes&lt;/em&gt; might throw a &lt;code&gt;NullReference&lt;/code&gt; or even (more frequent) a &lt;code&gt;KeyNotFoundException&lt;/code&gt; when you try to access a key from two concurrent threads. The exception is quite misleading in this case.</source>
          <target state="translated">.NET의 일반 사전은 스레드로부터 안전하지 않으며 두 개의 동시 스레드에서 키에 액세스하려고 할 때 &lt;code&gt;NullReference&lt;/code&gt; 또는 더 빈번한 &lt;code&gt;KeyNotFoundException&lt;/code&gt; 을 발생시킬 수 있습니다. 이 경우 예외는 오해의 소지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5442e2b64fa09764b9f593867e59a97292c84059" translate="yes" xml:space="preserve">
          <source>GitHub</source>
          <target state="translated">GitHub</target>
        </trans-unit>
        <trans-unit id="d0a42f917789ed1adb6c6963e61a12fd3ef2255b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;comboBox1&lt;/code&gt; is created before &lt;code&gt;label1&lt;/code&gt;. If &lt;code&gt;comboBox1_SelectionChanged&lt;/code&gt; attempts to reference `label1, it will not yet have been created.</source>
          <target state="translated">&lt;code&gt;comboBox1&lt;/code&gt; 은 &lt;code&gt;label1&lt;/code&gt; 이전에 작성됩니다. &lt;code&gt;comboBox1_SelectionChanged&lt;/code&gt; 가`label1을 참조하려고 시도하면 아직 작성되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="5bb2ae17924e2d50220fe232232b8dca78bd0287" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Book&lt;/code&gt; and &lt;code&gt;Car&lt;/code&gt; are incompatible types; a &lt;code&gt;Car&lt;/code&gt; cannot be converted/cast to a &lt;code&gt;Book&lt;/code&gt;.  When this cast fails, &lt;code&gt;as&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;.  Using &lt;code&gt;mybook&lt;/code&gt; after this causes a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;Book&lt;/code&gt; 과 &lt;code&gt;Car&lt;/code&gt; 는 호환되지 않는 유형입니다. &lt;code&gt;Car&lt;/code&gt; 는 &lt;code&gt;Book&lt;/code&gt; 으로 변환 / 전송할 수 없습니다. 이 캐스트가 실패하면 &lt;code&gt;as&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 을 반환합니다. 이 후 &lt;code&gt;mybook&lt;/code&gt; 을 사용하면 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f0cfc5e03a074b5ff497538e30726ab43dd9c052" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SelectedDate&lt;/code&gt; is in fact a property - of &lt;code&gt;DateTime&lt;/code&gt; type - of the &lt;code&gt;Calendar&lt;/code&gt; Web Control type, and the binding could perfectly return something null. The implicit ASP.NET Generator will create a piece of code that will be equivalent to the cast code above. And this will raise a &lt;code&gt;NullReferenceException&lt;/code&gt; that is quite difficult to spot, because it lies in ASP.NET generated code which compiles fine...</source>
          <target state="translated">여기서 &lt;code&gt;SelectedDate&lt;/code&gt; 는 실제로 &lt;code&gt;Calendar&lt;/code&gt; Web Control 유형의 속성 &lt;code&gt;DateTime&lt;/code&gt; 유형의 속성이며 바인딩은 null을 완벽하게 반환 할 수 있습니다. 암시 적 ASP.NET 생성기는 위의 캐스트 코드와 동등한 코드를 만듭니다. 그리고 이것은 잘 컴파일되는 ASP.NET 생성 코드에 있기 때문에 발견하기 어려운 &lt;code&gt;NullReferenceException&lt;/code&gt; 을 발생시킵니다 ...</target>
        </trans-unit>
        <trans-unit id="ed1e9256d7edb2bcff5e3eaa417639f1f18c564e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;myWebBrowser&lt;/code&gt; or &lt;code&gt;Document&lt;/code&gt; could be Nothing or the &lt;code&gt;formfld1&lt;/code&gt; element may not exist.</source>
          <target state="translated">여기에서 &lt;code&gt;myWebBrowser&lt;/code&gt; 또는 &lt;code&gt;Document&lt;/code&gt; 가 Nothing이거나 &lt;code&gt;formfld1&lt;/code&gt; 요소가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2320c69a11432eba5e88d70d8ffa3f27efc00ca3" translate="yes" xml:space="preserve">
          <source>Hope this helps too!</source>
          <target state="translated">이것이 도움이되기를 바랍니다!</target>
        </trans-unit>
        <trans-unit id="0ae3600ced7e6090a5b25d1e38293c3e4c119186" translate="yes" xml:space="preserve">
          <source>How can it be avoided?</source>
          <target state="translated">어떻게 피할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="289dd28c102f868db09f817b7b706b35bc135e71" translate="yes" xml:space="preserve">
          <source>How do you find the source of a &lt;code&gt;NullReferenceException&lt;/code&gt;? Apart from looking at the exception itself, which will be thrown exactly at the location where it occurs, the general rules of debugging in Visual Studio apply: place strategic breakpoints and &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/esta7c62.aspx&quot;&gt;inspect your variables&lt;/a&gt;, either by hovering the mouse over their names, opening a (Quick)Watch window or using the various debugging panels like Locals and Autos.</source>
          <target state="translated">&lt;code&gt;NullReferenceException&lt;/code&gt; 의 소스는 어떻게 찾습니까? 예외가 발생하는 위치에서 정확하게 발생하는 예외 자체를 보는 것 외에도 Visual Studio의 일반적인 디버깅 규칙이 적용됩니다. 전략적 중단 점을 배치하고 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/esta7c62.aspx&quot;&gt;변수를&lt;/a&gt; 이름 위에 마우스를 갖다 대면 ( 빨리보기) 또는 지역 및 자동차와 같은 다양한 디버깅 패널을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c9076ca26af1e797ee780559308ab39c1861f589" translate="yes" xml:space="preserve">
          <source>I have a different perspective to answering this. This sort of answers &lt;strong&gt;&quot;what else can I do to avoid it?&lt;/strong&gt;&quot;</source>
          <target state="translated">나는 이것에 대답하는 데 다른 관점을 가지고 있습니다. 이런 종류의 대답은 &lt;strong&gt;&quot;어떻게 피할 수 있습니까?&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="4b181a81f82b32a1fdd472eb539bf0016ed99f5f" translate="yes" xml:space="preserve">
          <source>I have some code and when it executes, it throws a &lt;code&gt;NullReferenceException&lt;/code&gt;, saying:</source>
          <target state="translated">코드가 있고 실행될 때 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생하여 다음 과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="039ba9acfb4e759d3a5ed8951d9aef9d9682bea4" translate="yes" xml:space="preserve">
          <source>I was getting &lt;code&gt;Object reference not set to an instance of an object&lt;/code&gt; when I tried to render a View within a View by sending it a Model, like this:</source>
          <target state="translated">다음과 같이 모델을 보내 뷰에서 뷰를 렌더링하려고 할 때 &lt;code&gt;Object reference not set to an instance of an object&lt;/code&gt; 가 객체의 인스턴스로 설정되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="cdd8f575833c363a288e4e756f1a133957aee9ea" translate="yes" xml:space="preserve">
          <source>I'll be using a RigidBody variable as an example.</source>
          <target state="translated">예를 들어 RigidBody 변수를 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="fd9aa298728dbdb009eb67b0148c8d2d45bb648a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dgvBooks&lt;/code&gt; has &lt;code&gt;AutoGenerateColumns = True&lt;/code&gt;, it will create the columns, but it does not name them, so the above code fails when it references them by name.</source>
          <target state="translated">&lt;code&gt;dgvBooks&lt;/code&gt; 에 &lt;code&gt;AutoGenerateColumns = True&lt;/code&gt; 인 경우 열을 만들지 만 이름을 지정하지 않으므로 이름으로 참조 할 때 위의 코드가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bb92213da41ab10c3a7c561c6d6e69a25df9059f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;whatever&lt;/code&gt; results in &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;MakeFrob&lt;/code&gt; will throw.  Now, you might think that the right thing to do is this:</source>
          <target state="translated">결과가 &lt;code&gt;null&lt;/code&gt; 이면 &lt;code&gt;MakeFrob&lt;/code&gt; 가 발생합니다. 이제해야 할 일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c31841110ff2a43d84d3c54ced95f988e30ba219" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CheckBox&lt;/code&gt; with &lt;code&gt;chkName&lt;/code&gt; can't be found (or exists in a &lt;code&gt;GroupBox&lt;/code&gt;), then &lt;code&gt;chk&lt;/code&gt; will be Nothing and be attempting to reference any property will result in an exception.</source>
          <target state="translated">&lt;code&gt;chkName&lt;/code&gt; 을 가진 &lt;code&gt;CheckBox&lt;/code&gt; 를 찾을 수 없거나 &lt;code&gt;GroupBox&lt;/code&gt; 에있는 경우 &lt;code&gt;chk&lt;/code&gt; 는 Nothing이되고 속성을 참조하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="56b8e5facbdd4848585ce4e50ddd17e21345d1f4" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;NullReferenceException&lt;/code&gt; is thrown by &lt;code&gt;unsafe&lt;/code&gt; code, you might look at your pointer variables, and check them for &lt;code&gt;IntPtr.Zero&lt;/code&gt; or something. Which is the same thing (&quot;null pointer exception&quot;), but in unsafe code, variables are often cast to value-types/arrays, etc., and you bang your head against the wall, wondering how a value-type can throw this exception.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 코드로 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생하면 포인터 변수를보고 &lt;code&gt;IntPtr.Zero&lt;/code&gt; 등을 확인할 수 있습니다. 어느 것이 똑같지 만 ( &quot;널 포인터 예외&quot;) 안전하지 않은 코드에서 변수는 종종 값 유형 / 배열 등으로 캐스트되고, 값 유형이 어떻게 이것을 던질 수 있는지 궁금해 벽에 머리를 부딪칩니다. 예외.</target>
        </trans-unit>
        <trans-unit id="3ba69a96020f6c1697e9f0b564be8a369771f477" translate="yes" xml:space="preserve">
          <source>If it is caused on some &lt;strong&gt;database&lt;/strong&gt; commands because the object isn't present then all you need to do is do a null check and handle it:</source>
          <target state="translated">오브젝트가 없기 때문에 일부 &lt;strong&gt;데이터베이스&lt;/strong&gt; 명령에서 발생하는 경우 널 점검을 수행하고 처리하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a0fc7e5c19cd4824faca0c76683d3494b34dba43" translate="yes" xml:space="preserve">
          <source>If one is getting this message during saving or compiling the build, just close all the files and then open any file to compile and save.</source>
          <target state="translated">빌드를 저장하거나 컴파일하는 동안이 메시지가 표시되면 모든 파일을 닫은 다음 파일을 열어 컴파일하고 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="0b56c362f306a958689a4fcd2922fb1cfb57868c" translate="yes" xml:space="preserve">
          <source>If ref1 or ref2 or ref3 is null, then you'll get a &lt;code&gt;NullReferenceException&lt;/code&gt;. If you want to solve the problem, then find out which one is null by rewriting the expression to its simpler equivalent:</source>
          <target state="translated">ref1 또는 ref2 또는 ref3이 null이면 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생 합니다. 문제를 해결하려면 식을 더 간단한 것으로 다시 작성하여 널 중 하나를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="1e7a62c30a52478b4caee9f5d2f2740eae4bcb26" translate="yes" xml:space="preserve">
          <source>If the exception occurs when referencing a property of &lt;code&gt;@Model&lt;/code&gt; in an &lt;code&gt;ASP.NET MVC View&lt;/code&gt;, you need to understand that the &lt;code&gt;Model&lt;/code&gt; gets set in your action method, when you &lt;code&gt;return&lt;/code&gt; a view. When you return an empty model (or model property) from your controller, the exception occurs when the views access it:</source>
          <target state="translated">&lt;code&gt;ASP.NET MVC View&lt;/code&gt; 에서 &lt;code&gt;@Model&lt;/code&gt; 속성을 참조 할 때 예외가 발생하면 뷰 를 &lt;code&gt;return&lt;/code&gt; 할 때 &lt;code&gt;Model&lt;/code&gt; 이 액션 메서드에서 설정됨을 이해해야합니다. 컨트롤러에서 빈 모델 (또는 모델 속성)을 반환하면 뷰가 액세스 할 때 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a383d31e09e21027128bda7cc84f8a8c4c8d65f8" translate="yes" xml:space="preserve">
          <source>If the person does not have a title, this will throw an exception because it is trying to call &lt;code&gt;ToUpper&lt;/code&gt; on a property with a null value.</source>
          <target state="translated">사람에게 제목이 없으면 null 값을 가진 속성에서 &lt;code&gt;ToUpper&lt;/code&gt; 를 호출하려고하기 때문에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5cf3aeda57ef955ddb285e14c6996f8c139ee9bf" translate="yes" xml:space="preserve">
          <source>If we consider common scenarios where this exception can be thrown, accessing properties withing object at the top.</source>
          <target state="translated">이 예외가 발생할 수있는 일반적인 시나리오를 고려하면 맨 위에 객체가있는 속성에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="bd4df3cabfb26db423d61513abb17ea9d42bbc71" translate="yes" xml:space="preserve">
          <source>If you are debugging with Just My Code enabled, the behavior is slightly different. With Just My Code enabled, the debugger ignores first-chance common language runtime (CLR) exceptions that are thrown outside of My Code and do not pass through My Code</source>
          <target state="translated">Just My Code를 사용하여 디버깅하는 경우 동작이 약간 다릅니다. 내 코드 만 사용으로 설정하면 디버거는 내 코드 외부에서 발생하고 내 코드를 통과하지 못하는 CLR (first-chance common language runtime) 예외를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5d011199f17f1b3224336bf477779ff919919146" translate="yes" xml:space="preserve">
          <source>If you are expecting the type conversion to always succeed (ie. you know what the object should be ahead of time), then you should use a cast:</source>
          <target state="translated">타입 변환이 항상 성공할 것으로 기대한다면 (즉, 객체가 무엇보다 앞서야하는지 알고 있다면) 캐스트를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db5359f7b5259b8f8194c263074c45fca315ff8a" translate="yes" xml:space="preserve">
          <source>If you are unsure of the type, but you want to &lt;em&gt;try&lt;/em&gt; to use it as a specific type, then use &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">유형이 확실하지 않지만 특정 유형으로 사용하려는 경우 다음 &lt;code&gt;as&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1c923dbbe26d09b3ec56dc6968714cd47b9bf93d" translate="yes" xml:space="preserve">
          <source>If you are working with unsafe code and you get a null dereference exception, just be aware that the offending pointer need not be null. It can be any location in the lowest page, and this exception will be produced.</source>
          <target state="translated">안전하지 않은 코드로 작업하고 null 역 참조 예외가 발생하는 경우 문제가되는 포인터가 null 일 필요는 없습니다. 가장 낮은 페이지의 어느 위치 에나있을 수 있으며이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9eee74fa45beb820853095727a40c22279c9d0bc" translate="yes" xml:space="preserve">
          <source>If you do use a &lt;code&gt;For n&lt;/code&gt; loop, modify the row count or use &lt;code&gt;Exit For&lt;/code&gt; when &lt;code&gt;IsNewRow&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;For n&lt;/code&gt; 루프 를 사용하는 경우 &lt;code&gt;IsNewRow&lt;/code&gt; 가 true 일 때 행 수를 수정하거나 &lt;code&gt;Exit For&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e09bc8a6a4e58664c4a3a3793f96ba758d2f4e9b" translate="yes" xml:space="preserve">
          <source>If you examine the reference source for &lt;code&gt;LINQ&lt;/code&gt; to Objects you will see that this technique is used throughout. It is slightly more clunky to write, but it makes debugging nullity errors much easier.  &lt;strong&gt;Optimize your code for the convenience of the caller, not the convenience of the author&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;LINQ&lt;/code&gt; to Objects의 참조 소스를 살펴보면이 기술이 전체적으로 사용되는 것을 볼 수 있습니다. 작성하는 것이 약간 더 복잡하지만 nullity 오류 디버깅이 훨씬 쉽습니다. &lt;strong&gt;작성자의 편의가 아닌 발신자의 편의를 위해 코드를 최적화하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e93bb8e62bdb0cbe375e02bcdd4025ed3a5280b6" translate="yes" xml:space="preserve">
          <source>If you expect the reference sometimes to be null, you can check for it being &lt;code&gt;null&lt;/code&gt; before accessing instance members:</source>
          <target state="translated">때때로 참조가 널이 될 것으로 예상되는 경우 인스턴스 멤버에 액세스하기 전에 참조가 &lt;code&gt;null&lt;/code&gt; 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="954ae9f52d37b1ad255f61190a8a7c1d85bef3ef" translate="yes" xml:space="preserve">
          <source>If you have not initialized a reference type, and you want to set or read one of its properties, it will throw a &lt;strong&gt;NullReferenceException&lt;/strong&gt;.</source>
          <target state="translated">참조 유형을 초기화하지 않고 해당 속성 중 하나를 설정하거나 읽으려면 &lt;strong&gt;NullReferenceException이 발생&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c9b75db38115a136957814e589aeeb2dac83db23" translate="yes" xml:space="preserve">
          <source>If you want to avoid the child (Person) null reference, you could initialize it in the parent (Book) object's constructor.</source>
          <target state="translated">하위 (Person) 널 참조를 피하려면 상위 (Book) 오브젝트의 생성자에서이를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7672c7bfcdb17d75fe7dfc75005f4c60663395f1" translate="yes" xml:space="preserve">
          <source>If you want to find out where the reference is or isn't set, right-click its name and select &quot;Find All References&quot;. You can then place a breakpoint at every found location and run your program with the debugger attached. Every time the debugger breaks on such a breakpoint, you need to determine whether you expect the reference to be non-null, inspect the variable, and verify that it points to an instance when you expect it to.</source>
          <target state="translated">참조가 설정되어 있거나 설정되어 있지 않은 곳을 찾으려면 해당 이름을 마우스 오른쪽 단추로 클릭하고 &quot;모든 참조 찾기&quot;를 선택하십시오. 그런 다음 발견 된 모든 위치에 중단 점을 배치하고 디버거가 연결된 상태에서 프로그램을 실행할 수 있습니다. 디버거가 이러한 중단 점에서 중단 될 때마다 참조가 널이 아닌 것으로 예상되는지 판별하고 변수를 검사하여 예상시 인스턴스를 가리키는 지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="124ed7dc2efaa392800e559d8512faa6fddfc4a6" translate="yes" xml:space="preserve">
          <source>If you're not sure whether the object is null, check it with &lt;code&gt;object == null&lt;/code&gt;.</source>
          <target state="translated">객체가 null인지 확실하지 않은 경우 &lt;code&gt;object == null&lt;/code&gt; 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f9d87c823bab4a6a3c23f4fa35b0ab3165ebc81e" translate="yes" xml:space="preserve">
          <source>Imagine that &lt;code&gt;country&lt;/code&gt; is an object of type &lt;code&gt;Country&lt;/code&gt; that has a property called &lt;code&gt;State&lt;/code&gt; and so on. If &lt;code&gt;country&lt;/code&gt;, &lt;code&gt;State&lt;/code&gt;, &lt;code&gt;County&lt;/code&gt;, or &lt;code&gt;City&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;address will be&lt;/code&gt;null&lt;code&gt;. Therefore you only have to check whether&lt;/code&gt;address&lt;code&gt;is&lt;/code&gt;null`.</source>
          <target state="translated">해당 &lt;code&gt;country&lt;/code&gt; 가 &lt;code&gt;State&lt;/code&gt; 등의 속성을 가진 &lt;code&gt;Country&lt;/code&gt; 유형의 객체라고 가정합니다. &lt;code&gt;country&lt;/code&gt; , &lt;code&gt;State&lt;/code&gt; , &lt;code&gt;County&lt;/code&gt; 또는 &lt;code&gt;City&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이면 &lt;code&gt;address will be&lt;/code&gt; null &lt;code&gt;. Therefore you only have to check whether&lt;/code&gt; 따라서 주소 &lt;code&gt;is&lt;/code&gt; null 인지 확인하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d8dc338b100fb641765e4200d2b3f89eb5c8d59d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C# 5&lt;/code&gt; and below, this can be guarded with:</source>
          <target state="translated">&lt;code&gt;C# 5&lt;/code&gt; 이하에서는 다음과 같이 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9af0d957316871a93fd8ae5a5c0570ecd645f0d" translate="yes" xml:space="preserve">
          <source>In Visual Studio this is usually easy thanks to the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/sc65sadd.aspx&quot;&gt;Visual Studio Debugger&lt;/a&gt;.</source>
          <target state="translated">Visual Studio에서는 일반적으로 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/sc65sadd.aspx&quot;&gt;Visual Studio Debugger&lt;/a&gt; 덕분에 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="442f25764599824025c21fd67a95683d7a1d4d49" translate="yes" xml:space="preserve">
          <source>In comparison to an ArgumentNullException which is typically thrown as a defensive measure if a method expects that what is being passed to it is not null.</source>
          <target state="translated">메소드가 전달되는 것이 널 (null)이 아닌 것으로 예상하는 경우 일반적으로 방어 수단으로 발생하는 ArgumentNullException과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="0d6fbd94de7bcc900b19537b5bb326c45d6c0504" translate="yes" xml:space="preserve">
          <source>In general, you should use a cast or &lt;code&gt;as&lt;/code&gt;, as follows:</source>
          <target state="translated">일반적으로 다음과 같이 캐스트 또는 &lt;code&gt;as&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a745bf8342a8ec9dc29ec2f0e55b1f294b6ff60a" translate="yes" xml:space="preserve">
          <source>In more advanced cases, such as the following, you'll need to use one of the techniques above (Watch or Immediate Windows) to inspect the expressions to determine if &lt;code&gt;str1&lt;/code&gt; was null or if &lt;code&gt;str2&lt;/code&gt; was null.</source>
          <target state="translated">다음과 같은 고급 사례의 경우 위의 기술 중 하나 (Watch 또는 Immediate Windows)를 사용하여 식을 검사하여 &lt;code&gt;str1&lt;/code&gt; 이 null인지 또는 &lt;code&gt;str2&lt;/code&gt; 가 null인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c2d2f16f8b1cfa8d5861b4766e0faaf22391a45" translate="yes" xml:space="preserve">
          <source>In short, &lt;em&gt;class invariants&lt;/em&gt; ensure that there will be some constraints in your class that will not get violated in normal use (and therefore, the class will &lt;em&gt;not&lt;/em&gt; get in an inconsistent state). &lt;em&gt;Preconditions&lt;/em&gt; mean that data given as input to a function/method must follow some constraints set and &lt;strong&gt;never&lt;/strong&gt; violate them, and &lt;em&gt;postconditions&lt;/em&gt; mean that a function/method output must follow the set constraints again without ever violating them.
Contract conditions should &lt;strong&gt;never&lt;/strong&gt; be violated during execution of a bug-free program, therefore design by contract is checked in practice in debug mode, while being &lt;em&gt;disabled in releases&lt;/em&gt;, to maximize the developed system performance.</source>
          <target state="translated">요컨대, &lt;em&gt;클래스 불변&lt;/em&gt; 은 클래스에 정상적인 사용에서 위반되지 않는 제약이 있는지 확인합니다 (따라서 클래스가 일관성이없는 상태에 &lt;em&gt;있지 않음&lt;/em&gt; ). &lt;em&gt;전제 조건&lt;/em&gt; 은 함수 / 메소드에 대한 입력으로 제공된 데이터가 일부 제한 조건 세트를 따라야하며이를 위반 &lt;strong&gt;하지&lt;/strong&gt; 않아야 함을 의미하며, &lt;em&gt;사후 조건&lt;/em&gt; 은 함수 / 메소드 출력이 설정된 제한 조건을 다시 위반하지 않고 다시 설정 제한 조건을 따라야 함을 의미합니다. 버그없는 프로그램을 실행하는 동안 계약 조건을 위반해서는 안되므로 개발 된 시스템 성능을 최대화하기 위해 &lt;em&gt;릴리스&lt;/em&gt; 에서 &lt;em&gt;비활성화 된&lt;/em&gt; 상태에서 디버그 모드에서 계약에 의한 설계를 실제로 검사합니다.</target>
        </trans-unit>
        <trans-unit id="ee86d3f393a29644b6be92e8be9ec8a1afe52114" translate="yes" xml:space="preserve">
          <source>In the other direction, a &lt;strong&gt;&lt;em&gt;boxing&lt;/em&gt;&lt;/strong&gt; conversion &lt;em&gt;from&lt;/em&gt; a &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; which has &lt;code&gt;HasValue&lt;/code&gt; equal to &lt;code&gt;false&lt;/code&gt;&lt;em&gt;to&lt;/em&gt; a reference type, can give a &lt;code&gt;null&lt;/code&gt; reference which can then later lead to a &lt;code&gt;NullReferenceException&lt;/code&gt;. The classic example is:</source>
          <target state="translated">다른 방향으로, &lt;code&gt;HasValue&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; 에서 참조 유형으로의 &lt;strong&gt;&lt;em&gt;복싱&lt;/em&gt;&lt;/strong&gt; 변환 &lt;em&gt;은&lt;/em&gt; &lt;code&gt;null&lt;/code&gt; 참조를 제공 한 다음 나중에 &lt;code&gt;NullReferenceException&lt;/code&gt; 으로 이어질 수 있습니다. 전형적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a5a670646192c2904df37f98794bc286c1f51c1" translate="yes" xml:space="preserve">
          <source>In unsafe mode, you should be aware of two important facts:</source>
          <target state="translated">안전하지 않은 모드에서는 다음 두 가지 중요한 사실을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3be7faaf917ec1e75bc105ac00cd45db1f27d22a" translate="yes" xml:space="preserve">
          <source>In-built method: System methods such as GetValueOrDefault(),IsNullOrWhiteSpace() and IsNullorEmpty()  checks for nulls and assign the default value if there is a null value.</source>
          <target state="translated">내장 된 메소드 : GetValueOrDefault (), IsNullOrWhiteSpace () 및 IsNullorEmpty ()와 같은 시스템 메소드는 널을 점검하고 널값이 있으면 기본값을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8cbe1b61604257c69eb792f97e93456c4cc68afc" translate="yes" xml:space="preserve">
          <source>Indirect</source>
          <target state="translated">Indirect</target>
        </trans-unit>
        <trans-unit id="414415dac9332746c5ff97ecdc8a7f74c2f17f06" translate="yes" xml:space="preserve">
          <source>Initialize the settings collection in the form's &lt;code&gt;Load&lt;/code&gt; event handler, if/when needed:</source>
          <target state="translated">필요한 경우 양식의 &lt;code&gt;Load&lt;/code&gt; 이벤트 처리기에서 설정 컬렉션을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="234d47467506fc9f47ee7950fcdb7bb2ae54365b" translate="yes" xml:space="preserve">
          <source>Integral types</source>
          <target state="translated">일체형</target>
        </trans-unit>
        <trans-unit id="c3341d58f2612c2f24999b64faed81efad614d89" translate="yes" xml:space="preserve">
          <source>Interestingly, none of the answers on this page mention the two edge cases, hope no one minds if I add them:</source>
          <target state="translated">흥미롭게도,이 페이지의 어떤 답변도 두 가지 경우를 언급하지 않으며, 내가 추가해도 아무도 신경 쓰지 않기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="01bd706ed0b9c186751dc7af37426b554a904934" translate="yes" xml:space="preserve">
          <source>Introduced in &lt;code&gt;C# 8&lt;/code&gt; there null context's and nullable reference types perform static analysis on variables and provides a compiler warning if a value can be potentially null or have been set to null. The nullable reference types allows types to be explicitly allowed to be null.</source>
          <target state="translated">&lt;code&gt;C# 8&lt;/code&gt; 도입 된 null 컨텍스트 및 nullable 참조 유형은 변수에 대한 정적 분석을 수행하고 값이 null이거나 잠재적으로 null로 설정된 경우 컴파일러 경고를 제공합니다. nullable 참조 형식을 사용하면 형식을 명시 적으로 null로 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf6007ad3f8db48b2caa744d94cf086e082dc37" translate="yes" xml:space="preserve">
          <source>It also arises when we forget to instantiate our objects. Using methods, properties, collections etc. which can return or set null values can also be the cause of this exception.</source>
          <target state="translated">객체를 인스턴스화하는 것을 잊었을 때도 발생합니다. null 값을 반환하거나 설정할 수있는 메서드, 속성, 컬렉션 등을 사용하는 것도이 예외의 원인 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f40b22d84245ca604cc84dc6eef8a46a3df02af" translate="yes" xml:space="preserve">
          <source>It is curious that VB does not provide a warning, but the remedy is to &lt;strong&gt;declare&lt;/strong&gt; the containers at the form level, but &lt;strong&gt;initialize&lt;/strong&gt; them in form load event handler when the controls &lt;strong&gt;do&lt;/strong&gt; exist. This can be done in &lt;code&gt;Sub New&lt;/code&gt; as long as your code is after the &lt;code&gt;InitializeComponent&lt;/code&gt; call:</source>
          <target state="translated">VB가 경고를 제공하지 않는 것이 궁금하지만 해결 방법은 컨테이너를 양식 레벨에서 &lt;strong&gt;선언&lt;/strong&gt; 하는 것이지만 컨트롤 &lt;strong&gt;이&lt;/strong&gt; 존재하면 양식로드 이벤트 핸들러에서 컨테이너를 &lt;strong&gt;초기화&lt;/strong&gt; 하는 것입니다. 코드가 &lt;code&gt;InitializeComponent&lt;/code&gt; 호출 이후에있는 한 &lt;code&gt;Sub New&lt;/code&gt; 에서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eef644af3700e5795f998539dd59e2e7c297244" translate="yes" xml:space="preserve">
          <source>It is not possible to reference anything 'downstream' of a &lt;code&gt;null&lt;/code&gt; object.  This also applies to controls:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 오브젝트의 '다운 스트림'을 참조 할 수 없습니다. 이것은 컨트롤에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="83c9a2a6f0cded3da8a2fd23d1724756e8709640" translate="yes" xml:space="preserve">
          <source>It means that the variable in question is pointed at nothing. I could generate this like so:</source>
          <target state="translated">문제의 변수가 아무것도 가리 키지 않았 음을 의미합니다. 나는 이것을 이렇게 생성 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="725b5851f8a7590790831cee0a9a54440c5e452d" translate="yes" xml:space="preserve">
          <source>It means your code used an object reference variable that was set to null (i.e. it did not reference an actual object instance).</source>
          <target state="translated">이는 코드에서 null로 설정된 객체 참조 변수를 사용했음을 의미합니다 (즉, 실제 객체 인스턴스를 참조하지 않음).</target>
        </trans-unit>
        <trans-unit id="0c813d120a6e5cc67f6c6bde99d1fd2ca0b51cc2" translate="yes" xml:space="preserve">
          <source>It will throw a &lt;code&gt;NullReferenceException&lt;/code&gt; on the cast. It seems quite obvious in the above sample, but this can happen in more &quot;late-binding&quot; intricate scenarios where the null object has been returned from some code you don't own, and the cast is for example generated by some automatic system.</source>
          <target state="translated">캐스트에서 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생합니다. 위의 샘플에서는 매우 분명해 보이지만 소유하지 않은 일부 코드에서 null 객체가 반환되고 캐스트가 일부 자동 시스템에 의해 생성되는보다 &quot;늦은 바인딩&quot;복잡한 시나리오에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8179843545ce209e8ee908f48e63197ddb2508a8" translate="yes" xml:space="preserve">
          <source>It would be nice if C# had something like the &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; struct above and had a similar shorthand, maybe the exclamation point (!) so that you could write something like: &lt;code&gt;public void WriteName(Person! person)&lt;/code&gt;.</source>
          <target state="translated">C #에 위의 &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; 구조체와 같은 것이 있고 느낌표 (!)와 비슷한 속기 (!)가 있으면 &lt;code&gt;public void WriteName(Person! person)&lt;/code&gt; 과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="955b6d8394cf76a1d4fe4f8e7ef177275da55c14" translate="yes" xml:space="preserve">
          <source>It's a great feature, but it gives you less information. It doesn't make it obvious which of the 4 is null.</source>
          <target state="translated">훌륭한 기능이지만 적은 정보를 제공합니다. 4 중 어느 것이 null인지는 분명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bf150ddb62d4d1939db3d1e25f12fdd47b0ee5f" translate="yes" xml:space="preserve">
          <source>It's used to test for null before performing a member access (?.) or index (?[) operation.</source>
          <target state="translated">멤버 액세스 (?.) 또는 인덱스 (? [) 조작을 수행하기 전에 널을 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="71c8a217f58ff5fc0e4a7d04b09748b7f1e8da29" translate="yes" xml:space="preserve">
          <source>Jagged Arrays</source>
          <target state="translated">들쭉날쭉 한 배열</target>
        </trans-unit>
        <trans-unit id="4de379f88b7ef46e6cfa5de6e9908e85f89cf4f0" translate="yes" xml:space="preserve">
          <source>JetBrains' Resharper tool will identify every place in your code that has the possibility of a null reference error, allowing you to put in a null check. This error is the number one source of bugs, IMHO.</source>
          <target state="translated">JetBrains의 Resharper 도구는 코드에서 null 참조 오류가 발생할 가능성이있는 모든 위치를 식별하여 null 검사를 수행 할 수 있습니다. 이 오류는 버그의 가장 큰 원인 인 IMHO입니다.</target>
        </trans-unit>
        <trans-unit id="b2802386a0546365a801bdc9dc6dc071b11d5be6" translate="yes" xml:space="preserve">
          <source>Key Points</source>
          <target state="translated">키 포인트</target>
        </trans-unit>
        <trans-unit id="8ee0e49c20d5b975cccff63b65f6a1467d4f272c" translate="yes" xml:space="preserve">
          <source>LINQ &lt;code&gt;FirstOrDefault()&lt;/code&gt; and &lt;code&gt;SingleOrDefault()&lt;/code&gt;</source>
          <target state="translated">LINQ &lt;code&gt;FirstOrDefault()&lt;/code&gt; 및 &lt;code&gt;SingleOrDefault()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99356ca7906555a2f4c7dc97649a8efa6dbd0212" translate="yes" xml:space="preserve">
          <source>Like anything else, &lt;code&gt;null&lt;/code&gt; gets passed around. If it is &lt;code&gt;null&lt;/code&gt;&lt;em&gt;in&lt;/em&gt; method &quot;A&quot;, it could be that method &quot;B&quot; passed a &lt;code&gt;null&lt;/code&gt;&lt;em&gt;to&lt;/em&gt; method &quot;A&quot;.</source>
          <target state="translated">다른 것과 마찬가지로 &lt;code&gt;null&lt;/code&gt; 도 전달됩니다. 메소드 &quot;A&quot; &lt;em&gt;에서&lt;/em&gt; &lt;code&gt;null&lt;/code&gt; 경우, 메소드 &quot;B&quot; &lt;em&gt;가&lt;/em&gt; 메소드 &quot;A&quot;에 &lt;code&gt;null&lt;/code&gt; &lt;em&gt;을&lt;/em&gt; 전달했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa96796b70166a01da429a974a3cc400dff498a8" translate="yes" xml:space="preserve">
          <source>Likewise, for arrays you can use &lt;code&gt;?[i]&lt;/code&gt; as follows:</source>
          <target state="translated">마찬가지로 배열의 경우 다음과 같이 &lt;code&gt;?[i]&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd395238ed01cc167eb08a83b289717b17ed72a" translate="yes" xml:space="preserve">
          <source>Lists and Collection will simply be empty</source>
          <target state="translated">목록과 컬렉션은 단순히 비어 있습니다</target>
        </trans-unit>
        <trans-unit id="b89d28bc5880c1090375f320e5a1517ea528fb46" translate="yes" xml:space="preserve">
          <source>Lists and Collections</source>
          <target state="translated">리스트와 컬렉션</target>
        </trans-unit>
        <trans-unit id="8ed2e69395a71ce749a19137034071d7ce924763" translate="yes" xml:space="preserve">
          <source>Literally the easiest way to fix a NullReferenceExeption has two ways.
If you have a GameObject for example with a script attached and a variable named rb (rigidbody) this variable will start null when you start your game.</source>
          <target state="translated">말 그대로 NullReferenceExeption을 수정하는 가장 쉬운 방법은 두 가지 방법이 있습니다. 예를 들어 스크립트가 첨부 된 게임 오브젝트와 rb (rigidbody)라는 변수가있는 경우 게임을 시작할 때이 변수는 null로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c42ff2b214ede29fd88c31705a2e471ec3556484" translate="yes" xml:space="preserve">
          <source>MSDN NullReference Exception</source>
          <target state="translated">MSDN NullReference 예외</target>
        </trans-unit>
        <trans-unit id="7ad8fdfe61e4454ef02db660ac35ba0748c9aa9d" translate="yes" xml:space="preserve">
          <source>MSDN: Best Practices for Exceptions</source>
          <target state="translated">MSDN : 예외에 대한 모범 사례</target>
        </trans-unit>
        <trans-unit id="1799c9265044c387d0f81f0d8e6ab1b39fd3f4f5" translate="yes" xml:space="preserve">
          <source>MSDN: How to: Use the Try/Catch Block to Catch Exceptions</source>
          <target state="translated">MSDN : 방법 : Try / Catch 블록을 사용하여 예외 포착</target>
        </trans-unit>
        <trans-unit id="78736f095b06c11f959a9bd8d826202e6b13baf7" translate="yes" xml:space="preserve">
          <source>Memory is virtualized in &lt;code&gt;Windows&lt;/code&gt;; each process gets a virtual memory space of many &quot;pages&quot; of memory that are tracked by the operating system. Each page of memory has flags set on it which determine how it may be used: read from, written to, executed, and so on.  The &lt;em&gt;lowest&lt;/em&gt; page is marked as &quot;produce an error if ever used in any way&quot;.</source>
          <target state="translated">메모리는 &lt;code&gt;Windows&lt;/code&gt; 에서 가상화됩니다. 각 프로세스는 운영 체제에서 추적하는 많은 &quot;페이지&quot;메모리의 가상 메모리 공간을 확보합니다. 각 메모리 페이지에는 읽기, 쓰기, 실행 등 사용 방법을 결정하는 플래그가 설정되어 있습니다. &lt;em&gt;가장 낮은&lt;/em&gt; 페이지는 &quot;어쨌든 사용 된 경우 오류 생성&quot;으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e23cc54bff3a3a5d37dc37dc1662948bf36648f0" translate="yes" xml:space="preserve">
          <source>Methods call you expect to return an instance can return &lt;code&gt;null&lt;/code&gt;, for example when the object being sought cannot be found. You can choose to return a default value when this is the case:</source>
          <target state="translated">찾고있는 객체를 찾을 수없는 경우와 같이 인스턴스를 반환 할 것으로 예상되는 메서드 호출은 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수 있습니다. 이 경우 기본값을 반환하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2f65c39e9befac556a2ece0db1de4b0c904147b" translate="yes" xml:space="preserve">
          <source>More Specifically</source>
          <target state="translated">더 구체적으로</target>
        </trans-unit>
        <trans-unit id="1f2886a5d0eb58ab959b4b21d407f74a59989572" translate="yes" xml:space="preserve">
          <source>More information is in &lt;em&gt;&lt;a href=&quot;https://www.dotnetperls.com/nullreferenceexception&quot;&gt;C# NullReferenceException and Null Parameter&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">자세한 내용은 &lt;em&gt;&lt;a href=&quot;https://www.dotnetperls.com/nullreferenceexception&quot;&gt;C # NullReferenceException 및 Null Parameter에&lt;/a&gt;&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="73d48e92ee90db3568c1d31a50c956aadebdfbd8" translate="yes" xml:space="preserve">
          <source>More realistic example - select nodes from XML document. Will throw if nodes are not found but initial debugging shows that all properties valid:</source>
          <target state="translated">보다 현실적인 예-XML 문서에서 노드를 선택하십시오. 노드를 찾을 수 없지만 초기 디버깅에서 모든 속성이 유효한 것으로 표시되면 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="f76899831263fd9799a64690d3ad0afc9100b2a4" translate="yes" xml:space="preserve">
          <source>My.Settings (StringCollection)</source>
          <target state="translated">내 설정 (StringCollection)</target>
        </trans-unit>
        <trans-unit id="41db439be65a63d22d9384237a7b090f77634c41" translate="yes" xml:space="preserve">
          <source>Name the columns manually, or reference by index:</source>
          <target state="translated">열 이름을 수동으로 지정하거나 색인으로 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f73fd087219997abb0b2070a7f8b9006bc9c6c3b" translate="yes" xml:space="preserve">
          <source>Nested Collection Initializers</source>
          <target state="translated">중첩 컬렉션 이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="c2ffcf7dcaf6a0db61f66aee4b7d2a32b5b706ba" translate="yes" xml:space="preserve">
          <source>Nested Object Initializers</source>
          <target state="translated">중첩 객체 이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="a9f6f220ca6e10feac65da97285e903dcd7c03df" translate="yes" xml:space="preserve">
          <source>New Operator</source>
          <target state="translated">새로운 연산자</target>
        </trans-unit>
        <trans-unit id="594a0ab4e25b09bd873763aa42a8cfaed596e74c" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;Do not&lt;/strong&gt; use &lt;code&gt;Dim&lt;/code&gt; again in a procedure, including the constructor (&lt;code&gt;Sub New&lt;/code&gt;):</source>
          <target state="translated">참고 : 생성자 ( &lt;code&gt;Sub New&lt;/code&gt; )를 포함하여 프로 시저에서 &lt;code&gt;Dim&lt;/code&gt; 을 다시 사용 &lt;strong&gt;하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b0c7d1634f143651ccf0114e6c5ffff2ff4f10cd" translate="yes" xml:space="preserve">
          <source>Note: Beginning with VS 2010, when initializing a local array using a literal and &lt;code&gt;Option Infer&lt;/code&gt;, the &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; and &lt;code&gt;New&lt;/code&gt; elements are optional:</source>
          <target state="translated">참고 : VS 2010부터 리터럴 및 &lt;code&gt;Option Infer&lt;/code&gt; 를 사용하여 로컬 배열을 초기화 할 때 &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; 및 &lt;code&gt;New&lt;/code&gt; 요소는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="378b211edf065e14fb27dcd1e7e1b744600ccaae" translate="yes" xml:space="preserve">
          <source>Now the title variable will be null instead of throwing an exception. C# 6 introduces a shorter syntax for this:</source>
          <target state="translated">이제 제목 변수는 예외를 던지는 대신 null이됩니다. C # 6은 이에 대한 더 짧은 구문을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="0e05b2f6e48a9c2172676721b07aa9534ae7f3f2" translate="yes" xml:space="preserve">
          <source>Now you are accessing this prop1 in some other class just like below:</source>
          <target state="translated">이제 다음과 같이 다른 클래스 에서이 prop1에 액세스하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="baac228f016bc4ccca30fd630c5ff646abbf3f89" translate="yes" xml:space="preserve">
          <source>Now, consider another class where you are trying to retrieve the student's full name.</source>
          <target state="translated">이제 학생의 전체 이름을 검색하려는 다른 수업을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4850e4da722f36fec8d78291c92be908f1969d5e" translate="yes" xml:space="preserve">
          <source>Now, when I try to print the length of the string &lt;strong&gt;str&lt;/strong&gt;, I do get &lt;em&gt;An unhandled exception of type &amp;lsquo;System.NullReferenceException&amp;rsquo; occurred&lt;/em&gt; message because member &lt;strong&gt;str&lt;/strong&gt; is pointing to null and there can&amp;rsquo;t be any length of null.</source>
          <target state="translated">이제 문자열 &lt;strong&gt;str&lt;/strong&gt; 의 길이를 인쇄하려고하면 멤버 &lt;strong&gt;str&lt;/strong&gt; 이 null을 가리키고 null 길이를 가질 수 없으므로 &lt;em&gt;'System.NullReferenceException'유형의 처리되지 않은 예외가 발생했습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eafd17582b015c89f4f72513d53f759c4bde2b05" translate="yes" xml:space="preserve">
          <source>Now, when the NullReferenceException is thrown (or unhandled) the debugger will stop (remember the rule set above?) on the line on which the exception occurred. Sometimes the error will be easy to spot.</source>
          <target state="translated">이제 NullReferenceException이 발생하거나 처리되지 않으면 디버거는 예외가 발생한 행에서 중지됩니다 (위의 규칙을 기억하십니까?). 때로는 오류를 쉽게 발견 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="318279d9fb722f810e6e3f50b545a9a0404b55c6" translate="yes" xml:space="preserve">
          <source>Null operators: Null Coalescing operator and null conditional operators can also be used in handy while setting values to objects, variables, properties and fields.</source>
          <target state="translated">Null 연산자 : Null Coalescing 연산자 및 Null 조건부 연산자를 사용하여 값을 개체, 변수, 속성 및 필드로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eb936c96dfd3a82cf681dcf1e453a56150f03fb" translate="yes" xml:space="preserve">
          <source>NullReference Exception &amp;mdash; Visual Basic</source>
          <target state="translated">NullReference 예외 &amp;mdash; Visual Basic</target>
        </trans-unit>
        <trans-unit id="108a53e72c1b0456c7d04a8155e32546371f242d" translate="yes" xml:space="preserve">
          <source>NullReferenceException arises due to our fault for not checking the object&amp;rsquo;s value. We often leave the object values unchecked in the code development.</source>
          <target state="translated">NullReferenceException은 객체 값을 확인하지 않은 오류로 인해 발생합니다. 우리는 종종 코드 개발에서 객체 값을 체크하지 않은 채로 둡니다.</target>
        </trans-unit>
        <trans-unit id="b5713cc5880d61c8ee4043a97acf6d784d345341" translate="yes" xml:space="preserve">
          <source>NullReferenceException or Object reference not set to an instance of an object occurs when an object of the class you are trying to use is not instantiated.
For example:</source>
          <target state="translated">사용하려는 클래스의 객체가 인스턴스화되지 않은 경우 NullReferenceException 또는 객체 참조가 객체의 인스턴스로 설정되지 않음이 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="498d55bb5d750bf94a55e680251545631183f0ad" translate="yes" xml:space="preserve">
          <source>NullReferenceException won't occur if we are using Value type members.</source>
          <target state="translated">Value 유형 멤버를 사용하는 경우 NullReferenceException이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">숫자 형</target>
        </trans-unit>
        <trans-unit id="3390ab1994cf8aa916e3506c4916e33bb1871966" translate="yes" xml:space="preserve">
          <source>Object Paths / Nested</source>
          <target state="translated">객체 경로 / 중첩</target>
        </trans-unit>
        <trans-unit id="dfefbee8fa51c19a77377fdc99c6d1e91ac2ebb8" translate="yes" xml:space="preserve">
          <source>Object reference not set to an instance of an object.</source>
          <target state="translated">객체 참조가 객체의 인스턴스로 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ffdbed86f65d9327dc3308e8c7e0ebc6a5dd365d" translate="yes" xml:space="preserve">
          <source>Object variables which are &lt;strong&gt;uninitialized&lt;/strong&gt; and hence &lt;strong&gt;point to nothing.&lt;/strong&gt; In this case, if you access properties or methods of such objects, it causes a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;초기화되지 않은&lt;/strong&gt; 객체 변수는 &lt;strong&gt;아무것도 가리 키지 않습니다.&lt;/strong&gt; 이 경우 해당 객체의 속성 또는 메서드에 액세스하면 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f9388be3a14ac2bf1c68c14b6f7c7b0ba00f598" translate="yes" xml:space="preserve">
          <source>Of course, you &lt;em&gt;still&lt;/em&gt; have to check &lt;code&gt;title&lt;/code&gt; for null or use the null condition operator together with the null coalescing operator (&lt;code&gt;??&lt;/code&gt;) to supply a default value:</source>
          <target state="translated">물론 기본값을 제공하려면 &lt;em&gt;여전히&lt;/em&gt; null &lt;code&gt;title&lt;/code&gt; 을 확인하거나 null 조건 연산자를 null 병합 연산자 ( &lt;code&gt;??&lt;/code&gt; )와 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa4b5d0f97e6455028a59f1925e67775d0a3150f" translate="yes" xml:space="preserve">
          <source>On the matter of &lt;strong&gt;&quot;what should I do about it&quot;&lt;/strong&gt;, there can be many answers.</source>
          <target state="translated">&lt;strong&gt;&quot;어떻게해야합니까&quot;&lt;/strong&gt; 와 관련하여 많은 답변이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d646273973e4205570d72f3076fd5fc36ee3360" translate="yes" xml:space="preserve">
          <source>Once &lt;em&gt;where&lt;/em&gt; the exception is throw has been located, it's usually trivial to reason backwards to find out where the null value was [incorrectly] introduced --</source>
          <target state="translated">예외가 발생하면 null 값이 [부적절하게] 도입 된 위치를 찾기 위해 거꾸로 추론하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="2a462199e4fdd6a0af25f3adcac4accc6d33e906" translate="yes" xml:space="preserve">
          <source>Once you know what and where the problem is, it is usually fairly easy to fix and faster than posting a new question.</source>
          <target state="translated">문제의 위치와 위치를 알고 나면 새로운 질문을 게시하는 것보다 수정하기가 쉽고 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ae6cb7569ada63bc2d3e163016b98bc806afea38" translate="yes" xml:space="preserve">
          <source>One example of this is this simple ASP.NET binding fragment with the Calendar control:</source>
          <target state="translated">이에 대한 한 가지 예는 Calendar 컨트롤이있는이 간단한 ASP.NET 바인딩 조각입니다.</target>
        </trans-unit>
        <trans-unit id="79a8436face2b533d827001515951269d4bfb9b3" translate="yes" xml:space="preserve">
          <source>Only reference types, as the name is suggesting, can hold references or point literally to nothing (or 'null'). Whereas value types always contain a value.</source>
          <target state="translated">이름에서 알 수 있듯이 참조 유형 만 참조를 보유하거나 문자 그대로 아무 것도 가리 키지 않을 수 있습니다 ( 'null'). 반면에 값 유형에는 항상 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="025911f6c7d528b21a46faf9fcb9c34232aa12fe" translate="yes" xml:space="preserve">
          <source>Option Infer Statement</source>
          <target state="translated">옵션 추론</target>
        </trans-unit>
        <trans-unit id="f179578c51c822eb1fb66acea0ac9ffb6979808e" translate="yes" xml:space="preserve">
          <source>Or you can always code your own approach using plain old code. For example here is a struct that you can use to catch null references. It's modeled after the same concept as &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">또는 항상 평범한 오래된 코드를 사용하여 자신 만의 방식을 코딩 할 수 있습니다. 예를 들어 다음은 널 참조를 포착하는 데 사용할 수있는 구조체입니다. &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 개념으로 모델링되었습니다.</target>
        </trans-unit>
        <trans-unit id="1b22ef513641d8af3ca046740205bbee48335bff" translate="yes" xml:space="preserve">
          <source>Or you can even use it when the method just returns &lt;code&gt;T&lt;/code&gt; (in this case &lt;code&gt;Person&lt;/code&gt;) by doing a cast. For example, the following code would just like the code above:</source>
          <target state="translated">또는 캐스팅을 수행하여 메소드가 &lt;code&gt;T&lt;/code&gt; (이 경우 &lt;code&gt;Person&lt;/code&gt; )를 반환 할 때도 사용할 수 있습니다. 예를 들어 다음 코드는 위 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9a30ba5e221a0e082315c528b339ab02883ea86" translate="yes" xml:space="preserve">
          <source>Otherwise, the variable name will be assigned the value of the p.Spouse.FirstName.</source>
          <target state="translated">그렇지 않으면 변수 이름에 p.Spouse.FirstName의 값이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="350349ce41ad9ae3414e0ee6f0cc9d8fdd70adfe" translate="yes" xml:space="preserve">
          <source>Poorly Implemented Try/Catch</source>
          <target state="translated">잘못 구현 된 시도 / 캐치</target>
        </trans-unit>
        <trans-unit id="cf56bb150b35de64b7d13c5c15cc44a04165e6c6" translate="yes" xml:space="preserve">
          <source>Possibly, other code prematurely invalidated an object still in use</source>
          <target state="translated">다른 코드가 아직 사용중인 객체를 조기에 무효화했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49dadac90d9e655d655da0a9465c937e3e41e55d" translate="yes" xml:space="preserve">
          <source>Range Variable (Indirect/Deferred)</source>
          <target state="translated">범위 변수 (간접 / 지연)</target>
        </trans-unit>
        <trans-unit id="7bbbd80923d138130436a31cdb61e2a69e969c03" translate="yes" xml:space="preserve">
          <source>Rather than indirect references by name using the form's &lt;code&gt;Controls&lt;/code&gt; collection, use the control reference:</source>
          <target state="translated">폼의 &lt;code&gt;Controls&lt;/code&gt; 컬렉션을 사용하여 이름으로 간접 참조하는 대신 컨트롤 참조를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="517a0d09eeac328a5dcd1752d817bf8b7bd38630" translate="yes" xml:space="preserve">
          <source>Referencing array elements later will result in an NRE. If you do this in &lt;code&gt;Form_Load&lt;/code&gt;, due to an odd bug, the IDE &lt;em&gt;may not&lt;/em&gt; report the exception when it happens. The exception will pop up &lt;em&gt;later&lt;/em&gt; when your code tries to use the array. This &quot;silent exception&quot; is &lt;a href=&quot;https://stackoverflow.com/a/4934010/1070452&quot;&gt;detailed in this post&lt;/a&gt;. For our purposes, the key is that when something catastrophic happens while creating a form (&lt;code&gt;Sub New&lt;/code&gt; or &lt;code&gt;Form Load&lt;/code&gt; event), exceptions may go unreported, the code exits the procedure and just displays the form.</source>
          <target state="translated">나중에 배열 요소를 참조하면 NRE가 발생합니다. 이상한 버그로 인해 &lt;code&gt;Form_Load&lt;/code&gt; 에서이 작업을 수행하면 IDE에서 예외가 발생했을 때보고 &lt;em&gt;하지 않을 수 있습니다&lt;/em&gt; . &lt;em&gt;나중에&lt;/em&gt; 코드에서 배열을 사용하려고하면 예외가 나타납니다. 이 &quot;자동 예외&quot;는 &lt;a href=&quot;https://stackoverflow.com/a/4934010/1070452&quot;&gt;이 게시물에 자세히 설명되어&lt;/a&gt; 있습니다. 우리의 목적을 위해, 핵심은 양식 ( &lt;code&gt;Sub New&lt;/code&gt; 또는 &lt;code&gt;Form Load&lt;/code&gt; 이벤트)을 작성하는 동안 심각한 상황이 발생하면 예외가보고되지 않고 코드가 프로 시저를 종료하고 양식 만 표시한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d7961680dc43f2fb54210f44d5d5893f415a97ea" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;Exit Function&lt;/code&gt; in the function with &lt;code&gt;Return bList&lt;/code&gt;. Returning an &lt;em&gt;empty&lt;/em&gt;&lt;code&gt;List&lt;/code&gt; is not the same as returning &lt;code&gt;Nothing&lt;/code&gt;. If there is a chance that a returned object can be &lt;code&gt;Nothing&lt;/code&gt;, test before using it:</source>
          <target state="translated">&lt;code&gt;Exit Function&lt;/code&gt; 을 &lt;code&gt;Return bList&lt;/code&gt; 로 바꾸십시오 . &lt;em&gt;빈&lt;/em&gt; &lt;code&gt;List&lt;/code&gt; 를 반환하는 &lt;code&gt;Nothing&lt;/code&gt; 을 반환하는 것과 다릅니다. 반환 된 객체가 &lt;code&gt;Nothing&lt;/code&gt; 일 가능성이있는 경우 사용하기 전에 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="e09009f0be2bc5dc475d39c72cbad2457332d844" translate="yes" xml:space="preserve">
          <source>Scope in Visual Basic</source>
          <target state="translated">Visual Basic의 범위</target>
        </trans-unit>
        <trans-unit id="ec36826e04a6ea83960855360f7576fa1a70dea9" translate="yes" xml:space="preserve">
          <source>See &quot;&lt;a href=&quot;https://stackoverflow.com/questions/19314340/nullreferenceexception-thrown-when-testing-custom-authorizationattribute&quot;&gt;NullReferenceException thrown when testing custom AuthorizationAttribute&lt;/a&gt;&quot; for a somewhat verbose example.</source>
          <target state="translated">다소 자세한 예제는 &quot; &lt;a href=&quot;https://stackoverflow.com/questions/19314340/nullreferenceexception-thrown-when-testing-custom-authorizationattribute&quot;&gt;사용자 정의 AuthorizationAttribute를 테스트 할 때 NullReferenceException 발생&lt;/a&gt; &quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dee0432b1dfd3821074c0b47888585c85bdf5bb0" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Data.DataTable(v=vs.110).aspx&quot;&gt;DataTable Class&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Data.DataTable(v=vs.110).aspx&quot;&gt;DataTable 클래스&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="b81624007a72ba2076c9759224672d60d8e74940" translate="yes" xml:space="preserve">
          <source>Since VB is managing Settings for you, it is reasonable to expect it to initialize the collection. It will, but only if you have previously added an initial entry to the collection (in the Settings editor). Since the collection is (apparently) initialized when an item is added, it remains &lt;code&gt;Nothing&lt;/code&gt; when there are no items in the Settings editor to add.</source>
          <target state="translated">VB가 설정을 관리하고 있으므로 모음을 초기화 할 것으로 기대하는 것이 합리적입니다. 이전에 컬렉션에 초기 항목을 추가 한 경우에만 설정 편집기에서 수행됩니다. 항목이 추가 될 때 컬렉션이 (명확하게) 초기화되기 때문에 설정 편집기에 추가 할 항목이 없으면 &lt;code&gt;Nothing&lt;/code&gt; 유지 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5e1ee4902767b648a32002c3f0eac6e8212d4c61" translate="yes" xml:space="preserve">
          <source>Since no other code in your &lt;code&gt;Sub New&lt;/code&gt; or &lt;code&gt;Form Load&lt;/code&gt; event will run after the NRE, &lt;em&gt;a great many other things&lt;/em&gt; can be left uninitialized.</source>
          <target state="translated">&lt;code&gt;Sub New&lt;/code&gt; 또는 &lt;code&gt;Form Load&lt;/code&gt; 이벤트의 다른 코드는 NRE 이후에 실행되지 않으므로 다른 &lt;em&gt;많은 것들이&lt;/em&gt; 초기화되지 않은 채 남아 &lt;em&gt;있을&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="169ef3e9a5e6d08f8ec9f775f25ef7ca8fe0ba80" translate="yes" xml:space="preserve">
          <source>Since the problem is an object reference which is &lt;code&gt;Nothing&lt;/code&gt;, the answer is to examine them to find out which one. Then determine why it is not initialized. Hold the mouse over the various variables and Visual Studio (VS) will show their values - the culprit will be &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">문제는 &lt;code&gt;Nothing&lt;/code&gt; 객체 참조이므로 답변을 조사하여 어느 것을 찾아야합니다. 그런 다음 초기화되지 않은 이유를 판별하십시오. 다양한 변수 위에 마우스를 대면 Visual Studio (VS)에 값이 표시됩니다. 원인은 &lt;code&gt;Nothing&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f5af1e9a2d60a99283e7a7af80fb60c02d4755e0" translate="yes" xml:space="preserve">
          <source>Since this uses one table, using &lt;code&gt;Tables(0)&lt;/code&gt; will avoid spelling errors.  Examining &lt;code&gt;Rows.Count&lt;/code&gt; can also help:</source>
          <target state="translated">이것은 하나의 테이블을 사용하므로 &lt;code&gt;Tables(0)&lt;/code&gt; 하면 철자 오류를 피할 수 있습니다. &lt;code&gt;Rows.Count&lt;/code&gt; 는 또한 다음을 도울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb8e569fb6ed72a6dffcc33b03fceee972649a2" translate="yes" xml:space="preserve">
          <source>So how to tackle this:</source>
          <target state="translated">그래서 이것을 해결하는 방법 :</target>
        </trans-unit>
        <trans-unit id="0af6f84e1abe20a8c228b77e487571323c47990e" translate="yes" xml:space="preserve">
          <source>So, as a practice we should always use null check, before accessing properties in such objects (specially in generic)</source>
          <target state="translated">따라서 실제로는 이러한 객체의 속성에 액세스하기 전에 항상 null 검사를 사용해야합니다 (특히 일반)</target>
        </trans-unit>
        <trans-unit id="728a2ccae6943f95d4a0778979a96e78b85be334" translate="yes" xml:space="preserve">
          <source>So, if you're dealing with &lt;strong&gt;value types&lt;/strong&gt;, NullReferenceExceptions can &lt;strong&gt;not&lt;/strong&gt; occur. Though you need to keep alert when dealing with &lt;strong&gt;reference types&lt;/strong&gt;!</source>
          <target state="translated">따라서 &lt;strong&gt;값 유형을&lt;/strong&gt; 처리하는 경우 NullReferenceExceptions가 발생할 수 &lt;strong&gt;없습니다&lt;/strong&gt; . &lt;strong&gt;참조 유형을&lt;/strong&gt; 다룰 때주의를 기울여야 &lt;strong&gt;합니다&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="3fef728484bb42f677ee7c22d16e57e13b623b0b" translate="yes" xml:space="preserve">
          <source>Some common scenarios where the exception can be thrown:</source>
          <target state="translated">예외가 발생할 수있는 몇 가지 일반적인 시나리오 :</target>
        </trans-unit>
        <trans-unit id="270f67be70dbe22b11e82aa389399daab08d5ed7" translate="yes" xml:space="preserve">
          <source>Something which your code assumed would initialize an object, did not</source>
          <target state="translated">코드에서 객체를 초기화한다고 가정했지만</target>
        </trans-unit>
        <trans-unit id="d79169ce047a865f22ceedf2f516d3f6a8bd12b3" translate="yes" xml:space="preserve">
          <source>Something you assumed would perform flawlessly to return an initialized object to your code, did not.</source>
          <target state="translated">초기화 된 객체를 코드에 반환하기 위해 완벽하게 수행한다고 가정하지는 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7b881a3646ad1ece01b3005831c5797e83c52c23" translate="yes" xml:space="preserve">
          <source>Sometimes the boxing happens in another way. For example with this non-generic extension method:</source>
          <target state="translated">때로는 권투가 다른 방식으로 발생합니다. 예를 들어이 제네릭이 아닌 확장 방법의 경우 :</target>
        </trans-unit>
        <trans-unit id="c8202db459212644c10dde57d8e4df666ce482d5" translate="yes" xml:space="preserve">
          <source>Special techniques for debugging and fixing null derefs in iterators</source>
          <target state="translated">반복자에서 널 참조를 디버깅하고 수정하는 특수 기술</target>
        </trans-unit>
        <trans-unit id="0fbbe68dcced5d9fa19046eaf6118ab8f81482e2" translate="yes" xml:space="preserve">
          <source>Specifically, in &lt;code&gt;HttpContext.Current.User.Identity.Name&lt;/code&gt;, the &lt;code&gt;HttpContext.Current&lt;/code&gt; could be null, or the &lt;code&gt;User&lt;/code&gt; property could be null, or the &lt;code&gt;Identity&lt;/code&gt; property could be null.</source>
          <target state="translated">특히 &lt;code&gt;HttpContext.Current.User.Identity.Name&lt;/code&gt; 에서 &lt;code&gt;HttpContext.Current&lt;/code&gt; 는 null이거나 &lt;code&gt;User&lt;/code&gt; 속성은 null이거나 &lt;code&gt;Identity&lt;/code&gt; 속성은 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5dea8e13e62a3f32c925f340dc736efda53d43f" translate="yes" xml:space="preserve">
          <source>Suppose I have a class and member method in it. I have not instantiated my class but only named my class. Now if I try to use the method, the compiler will throw an error or issue a warning (depending on the compiler).</source>
          <target state="translated">클래스와 멤버 메소드가 있다고 가정하십시오. 클래스를 인스턴스화하지 않았지만 클래스 이름 만 지정했습니다. 이제 메서드를 사용하려고하면 컴파일러에 따라 오류가 발생하거나 경고가 발생합니다 (컴파일러에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="a9bfffacd695cafe387b5dba29e8a53f54d17c9a" translate="yes" xml:space="preserve">
          <source>Suppose you have a web form Contact.aspx whose codebehind class is Contact and you have an entity name Contact.</source>
          <target state="translated">코드 숨김 클래스가 Contact 인 웹 양식 Contact.aspx가 있고 엔터티 이름이 Contact이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a32dcf6bc661323f00cb04b17bca14992a13218c" translate="yes" xml:space="preserve">
          <source>System.NullReferenceException: Object reference not set to an instance
  of an object. at Program.Main()</source>
          <target state="translated">System.NullReferenceException : 개체 참조가 개체의 인스턴스로 설정되지 않았습니다. Program.Main ()에서</target>
        </trans-unit>
        <trans-unit id="61b52702efd8978d72bc6dd4556000b0c5302229" translate="yes" xml:space="preserve">
          <source>Take the time required to understand the cause of the exception. Inspect for null expressions. Inspect the previous expressions which could have resulted in such null expressions. Add &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/ktf38f66(v=vs.90)&quot;&gt;breakpoints&lt;/a&gt; and step through the program as appropriate. &lt;em&gt;Use the debugger.&lt;/em&gt;</source>
          <target state="translated">예외의 원인을 이해하는 데 필요한 시간을 가지십시오. 널 표현식을 검사하십시오. 이러한 널 표현식을 초래할 수있는 이전 표현식을 검사하십시오. &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/ktf38f66(v=vs.90)&quot;&gt;중단 점을&lt;/a&gt; 추가하고 프로그램을 적절히 단계별로 진행하십시오. &lt;em&gt;디버거를 사용하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96355bac807e2bf7c816f87187a186dfb05609b3" translate="yes" xml:space="preserve">
          <source>That is, make a private helper method that has the iterator block logic, and a public surface method that does the null check and returns the iterator.  Now when &lt;code&gt;GetFrobs&lt;/code&gt; is called, the null check happens immediately, and then &lt;code&gt;GetFrobsForReal&lt;/code&gt; executes when the sequence is iterated.</source>
          <target state="translated">즉, 반복자 블록 논리가있는 개인 헬퍼 메소드와 널 점검을 수행하고 반복자를 리턴하는 공용 표면 메소드를 작성하십시오. 이제 &lt;code&gt;GetFrobs&lt;/code&gt; 가 호출되면 null 검사가 즉시 수행 된 다음 시퀀스가 ​​반복 될 때 &lt;code&gt;GetFrobsForReal&lt;/code&gt; 이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c98e5a07997fb98921d015b9962a6fe887151a12" translate="yes" xml:space="preserve">
          <source>That means if any member which doesn&amp;rsquo;t hold any value and we are making that member to perform certain task then the system will undoubtedly toss a message and say-</source>
          <target state="translated">즉, 가치가없는 회원이 있고 해당 회원이 특정 작업을 수행하도록하는 경우 시스템은 의심의 여지없이 메시지를 던져</target>
        </trans-unit>
        <trans-unit id="cd6b57e6915e732c6a3454d47a45928771b568d1" translate="yes" xml:space="preserve">
          <source>That will throw the error because while I've declared the variable &quot;&lt;code&gt;connection&lt;/code&gt;&quot;, it's not pointed to anything. When I try to call the member &quot;&lt;code&gt;Open&lt;/code&gt;&quot;, there's no reference for it to resolve, and it will throw the error.</source>
          <target state="translated">변수 &quot; &lt;code&gt;connection&lt;/code&gt; &quot;을 선언했지만 아무 것도 가리 키지 않기 때문에 오류가 발생합니다. &quot; &lt;code&gt;Open&lt;/code&gt; &quot;멤버를 호출하려고 할 때이를 해결할 참조가 없으며 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af16544bdee6b293bf4ee765cfb10b13b80b318a" translate="yes" xml:space="preserve">
          <source>That's why dereferencing both a null pointer and a null reference produces the same exception.</source>
          <target state="translated">따라서 널 포인터와 널 참조를 모두 역 참조하면 동일한 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="832f18980c9adec58ccfc7eafce613c988307af0" translate="yes" xml:space="preserve">
          <source>The .NET runtime will throw a NullReferenceException when you attempt to perform an action on something which hasn't been instantiated i.e. the code above.</source>
          <target state="translated">.NET 런타임은 인스턴스화되지 않은 무언가, 즉 위의 코드에서 작업을 수행하려고 할 때 NullReferenceException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="26534d5f78e239955916af7b305fc5b41ba2ea2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DataAdapter&lt;/code&gt; will provide &lt;code&gt;TableNames&lt;/code&gt; as shown in the previous example, but it does not parse names from the SQL or database table. As a result, &lt;code&gt;ds.Tables(&quot;TICKET_RESERVATION&quot;)&lt;/code&gt; references a non-existent table.</source>
          <target state="translated">&lt;code&gt;DataAdapter&lt;/code&gt; 는 이전 예에서와 같이 &lt;code&gt;TableNames&lt;/code&gt; 을 제공하지만 SQL 또는 데이터베이스 테이블에서 이름을 구문 분석하지는 않습니다. 결과적으로 &lt;code&gt;ds.Tables(&quot;TICKET_RESERVATION&quot;)&lt;/code&gt; 는 존재하지 않는 테이블을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="4e757d5d15663001bb33deeec07e2827ba5bd3a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsDBNull&lt;/code&gt; function is used to test if a &lt;em&gt;value&lt;/em&gt; equals &lt;code&gt;System.DBNull&lt;/code&gt;:  &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/tckcces5(v=vs.90)&quot;&gt;From MSDN:&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;IsDBNull&lt;/code&gt; 함수는 &lt;em&gt;값&lt;/em&gt; 이 &lt;code&gt;System.DBNull&lt;/code&gt; 과 같은지 테스트하는 데 사용됩니다 &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/tckcces5(v=vs.90)&quot;&gt;.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b413c4771f93ecdb1da4953c33951691d69e4d43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;New&lt;/code&gt; operator can often be used to create the instance when you declare it:</source>
          <target state="translated">&lt;code&gt;New&lt;/code&gt; 연산자는 종종 선언 할 때 인스턴스를 만드는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40dbae9f26db30254b9c9f1a9df041f25f4ae4cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NullReference Exception&lt;/code&gt; for &lt;strong&gt;Visual Basic&lt;/strong&gt; is no different from the one in &lt;strong&gt;C#&lt;/strong&gt;. After all, they are both reporting the same exception defined in the .NET Framework which they both use. Causes unique to Visual Basic are rare (perhaps only one).</source>
          <target state="translated">&lt;strong&gt;Visual Basic&lt;/strong&gt; 의 &lt;code&gt;NullReference Exception&lt;/code&gt; 는 &lt;strong&gt;C #의&lt;/strong&gt; 예외 와 다르지 않습니다. 결국 둘 다 .NET Framework에 정의 된 것과 동일한 예외를보고합니다. Visual Basic에 고유 한 원인은 거의 없습니다 (아마도 하나만).</target>
        </trans-unit>
        <trans-unit id="20d435cc2ffcce4a30d45f389b288f97cfa9298a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new Person&lt;/code&gt; only creates an instance of &lt;code&gt;Person&lt;/code&gt;, but the &lt;code&gt;Books&lt;/code&gt; collection is still &lt;code&gt;null&lt;/code&gt;. The collection &lt;code&gt;Initializer&lt;/code&gt; syntax does not create a collection
for &lt;code&gt;p1.Books&lt;/code&gt;, it only translates to the &lt;code&gt;p1.Books.Add(...)&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;new Person&lt;/code&gt; 은 &lt;code&gt;Person&lt;/code&gt; 의 인스턴스 만 생성하지만 &lt;code&gt;Books&lt;/code&gt; 컬렉션은 여전히 &lt;code&gt;null&lt;/code&gt; 입니다. Collection &lt;code&gt;Initializer&lt;/code&gt; 구문은 &lt;code&gt;p1.Books&lt;/code&gt; 에 대한 모음을 만들지 &lt;code&gt;p1.Books.Add(...)&lt;/code&gt; 문으로 만 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e0b42fc2efda212a3943ac23d1a88e3d1f5590dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runtime&lt;/code&gt; throwing a &lt;code&gt;NullReferenceException&lt;/code&gt;&lt;strong&gt;always&lt;/strong&gt; means the same thing: you are trying to use a reference, and the reference is not initialized (or it was &lt;em&gt;once&lt;/em&gt; initialized, but is &lt;em&gt;no longer&lt;/em&gt; initialized).</source>
          <target state="translated">&lt;code&gt;NullReferenceException&lt;/code&gt; 을 던지는 &lt;code&gt;runtime&lt;/code&gt; 은 &lt;strong&gt;항상&lt;/strong&gt; 같은 것을 의미합니다. 참조를 사용하려고 시도하고 있고 참조가 초기화되지 않았거나 &lt;em&gt;한 번&lt;/em&gt; 초기화되었지만 &lt;em&gt;더 이상&lt;/em&gt; 초기화 &lt;em&gt;되지 않았습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="49a69af3cb15571971e9fd0f2918ddd41cf47307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;somevar&lt;/code&gt; assignment will result in an immediate NRE because Nothing doesn't have a &lt;code&gt;.Text&lt;/code&gt; property</source>
          <target state="translated">Nothing에 &lt;code&gt;.Text&lt;/code&gt; 속성이 없기 때문에 &lt;code&gt;somevar&lt;/code&gt; 할당은 즉시 NRE가됩니다.</target>
        </trans-unit>
        <trans-unit id="6d5d5590cc424a0742ec3b68941443b7a51567cc" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Remedy&lt;/strong&gt; is the same, reference the table by index:</source>
          <target state="translated">&lt;strong&gt;해결책&lt;/strong&gt; 은 동일합니다. 색인으로 테이블을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3040c6289873dac88d88f00dfa3143d8958589ea" translate="yes" xml:space="preserve">
          <source>The Array will contain five elements of Nothing</source>
          <target state="translated">이 배열에는 Nothing의 다섯 가지 요소가 포함됩니다</target>
        </trans-unit>
        <trans-unit id="27ceb372d3a055414ac4ebce858ea4ad711a0987" translate="yes" xml:space="preserve">
          <source>The DGV has a few quirks seen periodically:</source>
          <target state="translated">DGV에는 다음과 같은 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c70e919024ee1fab6a7f20fb2647ea7464472447" translate="yes" xml:space="preserve">
          <source>The DataGridView</source>
          <target state="translated">DataGridView</target>
        </trans-unit>
        <trans-unit id="ef89f949d60a7ce3ba16474314cece6c25c1b417" translate="yes" xml:space="preserve">
          <source>The System.DBNull value indicates that the Object represents missing or non-existent data. DBNull is not the same as Nothing, which indicates that a variable has not yet been initialized.</source>
          <target state="translated">System.DBNull 값은 Object가 없거나 존재하지 않는 데이터를 나타냅니다. DBNull은 Nothing과 같지 않으므로 변수가 아직 초기화되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3fab983167187e8d3c1de769d9fd8889b4da2253" translate="yes" xml:space="preserve">
          <source>The above code shows simple string which is assigned with a &lt;strong&gt;null&lt;/strong&gt; value.</source>
          <target state="translated">위의 코드는 &lt;strong&gt;null&lt;/strong&gt; 값이 할당 된 간단한 문자열을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="17d03251d7278b73c29dd924064c9cb221dda373" translate="yes" xml:space="preserve">
          <source>The array code may not be out of the woods yet. Any controls which are in a container control (like a &lt;code&gt;GroupBox&lt;/code&gt; or &lt;code&gt;Panel&lt;/code&gt;) will not be found in &lt;code&gt;Me.Controls&lt;/code&gt;; they will be in the Controls collection of that Panel or GroupBox. Nor will a control be returned when the control name is misspelled (&lt;code&gt;&quot;TeStBox2&quot;&lt;/code&gt;). In such cases, &lt;code&gt;Nothing&lt;/code&gt; will again be stored in those array elements and an NRE will result when you attempt to reference it.</source>
          <target state="translated">배열 코드가 아직 숲에서 나오지 않았을 수 있습니다. 컨테이너 컨트롤 ( &lt;code&gt;GroupBox&lt;/code&gt; 또는 &lt;code&gt;Panel&lt;/code&gt; 과 같은)에있는 컨트롤은 &lt;code&gt;Me.Controls&lt;/code&gt; 에서 찾을 수 없습니다. 해당 패널 또는 GroupBox의 Controls 컬렉션에 있습니다. 제어 이름의 철자가 &lt;code&gt;&quot;TeStBox2&quot;&lt;/code&gt; 제어도 리턴되지 않습니다 ( &quot;TeStBox2&quot; ). 이러한 경우 해당 배열 요소에 &lt;code&gt;Nothing&lt;/code&gt; 다시 저장 되지 않으며 참조하려고하면 NRE가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9152dbff2da4b545031d214da21c705228394a13" translate="yes" xml:space="preserve">
          <source>The array has been created, but the &lt;code&gt;Foo&lt;/code&gt; objects in it have not.</source>
          <target state="translated">배열이 생성되었지만 그 안에 &lt;code&gt;Foo&lt;/code&gt; 개체가 없습니다.</target>
        </trans-unit>
        <trans-unit id="503f97cf7bd74b54164bcdafbce1e18337fefeac" translate="yes" xml:space="preserve">
          <source>The code is only testing &lt;code&gt;Items&lt;/code&gt; while both &lt;code&gt;myFoo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; may also be Nothing. The &lt;strong&gt;remedy&lt;/strong&gt; is to test the entire chain or path of objects one at a time:</source>
          <target state="translated">이 코드는 &lt;code&gt;Items&lt;/code&gt; 만 테스트하는 반면 &lt;code&gt;myFoo&lt;/code&gt; 와 &lt;code&gt;Bar&lt;/code&gt; 는 모두 아무것도 아닙니다. &lt;strong&gt;해결책&lt;/strong&gt; 은 한 번에 하나씩 전체 체인 또는 객체 경로를 테스트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="463bfd62c8f05004461fb5a31b8995846405c429" translate="yes" xml:space="preserve">
          <source>The constructor for the &lt;code&gt;ArgumentNullException&lt;/code&gt; even takes the name of the parameter and a message as arguments so you can tell the developer exactly what the problem is.</source>
          <target state="translated">&lt;code&gt;ArgumentNullException&lt;/code&gt; 의 생성자는 매개 변수 이름과 메시지를 인수로 사용하므로 개발자에게 문제가 무엇인지 정확하게 알려줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3316f1a701fde7c120bf71968a77f55f36491fce" translate="yes" xml:space="preserve">
          <source>The correct fix is:</source>
          <target state="translated">올바른 수정 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1294e0c3d65f0d8b731cd2b09629341a194dc6ce" translate="yes" xml:space="preserve">
          <source>The data Type and array size are inferred from the data being assigned. Class/Module level declarations still require &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; with &lt;code&gt;Option Strict&lt;/code&gt;:</source>
          <target state="translated">데이터 유형 및 배열 크기는 할당되는 데이터에서 유추됩니다. 클래스 / 모듈 레벨 선언에는 여전히 &lt;code&gt;Option Strict&lt;/code&gt; 가있는 &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0a67859648408e02bf57b5242710673d9d105f41" translate="yes" xml:space="preserve">
          <source>The developer is &lt;strong&gt;using &lt;code&gt;null&lt;/code&gt; intentionally to indicate there is no meaningful value available.&lt;/strong&gt; Note that C# has the concept of nullable datatypes for variables (like database tables can have nullable fields) - you can assign &lt;code&gt;null&lt;/code&gt; to them to indicate there is no value stored in it, for example &lt;code&gt;int? a = null;&lt;/code&gt; where the question mark indicates it is allowed to store null in variable &lt;code&gt;a&lt;/code&gt;. You can check that either with &lt;code&gt;if (a.HasValue) {...}&lt;/code&gt; or with &lt;code&gt;if (a==null) {...}&lt;/code&gt;. Nullable variables, like &lt;code&gt;a&lt;/code&gt; this example, allow to access the value via &lt;code&gt;a.Value&lt;/code&gt; explicitly, or just as normal via &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">개발자는 &lt;strong&gt;의미있는 값이 없음을 나타 내기 위해 의도적으로 &lt;code&gt;null&lt;/code&gt; 을 사용하고 있습니다.&lt;/strong&gt; C #에는 변수에 대한 nullable 데이터 유형 개념이 있습니다 (데이터베이스 테이블에 nullable 필드가있을 수 있음). 값이 저장되어 있지 않음을 나타 내기 위해 &lt;code&gt;null&lt;/code&gt; 을 지정할 수 있습니다 (예 : &lt;code&gt;int? a = null;&lt;/code&gt; a = 널; 여기서 물음표는 변수 &lt;code&gt;a&lt;/code&gt; 에 null을 저장할 수 있음을 나타냅니다. &lt;code&gt;if (a.HasValue) {...}&lt;/code&gt; 또는 &lt;code&gt;if (a==null) {...}&lt;/code&gt; 있습니다. 이 예제와 같이 &lt;code&gt;a.Value&lt;/code&gt; 입력 가능 변수를 사용하면 a.Value 를 통해 명시 적으로 또는 &lt;code&gt;a&lt;/code&gt; 를 통해 정상적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45a964d78da459f6bbd37b8cd232d3a6efef6380" translate="yes" xml:space="preserve">
          <source>The error line &quot;Object reference not set to an instance of an object.
&quot; states that you have not assigned instance object to a object reference and still you are accessing properies/methods of that object.</source>
          <target state="translated">오류 개체 &quot;개체 참조가 개체의 인스턴스로 설정되지 않았습니다.&quot;는 인스턴스 개체를 개체 참조에 할당하지 않았지만 여전히 해당 개체의 속성 / 방법에 액세스하고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a400e3953b7fb9b7c815f1ce88a4ab2b01f595e6" translate="yes" xml:space="preserve">
          <source>The error occurs when both the entity and codebehind class are in same namespace.
To fix this, rename the entity class or the codebehind class for Contact.aspx.</source>
          <target state="translated">엔티티 및 코드 숨김 클래스가 모두 동일한 네임 스페이스에있는 경우 오류가 발생합니다. 이 문제를 해결하려면 Contact.aspx의 엔터티 클래스 또는 코드 숨김 클래스의 이름을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="895203d5cc7b55ecb7ef70317a104cba1837e261" translate="yes" xml:space="preserve">
          <source>The examples (from Stack&amp;nbsp; Overflow posts) do not always show the best way to do something in the first place.</source>
          <target state="translated">스택 오버플로 게시물의 예제가 항상 처음에 무언가를 수행하는 가장 좋은 방법을 보여주지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1d89f5634b915a9e16a0aaaf5998b7a175005a7" translate="yes" xml:space="preserve">
          <source>The exception error is:</source>
          <target state="translated">예외 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4dabb60bda5cb5e73ecf06dcad355e8e1b245e9c" translate="yes" xml:space="preserve">
          <source>The exception itself says that something is being referred but whose value is not being set. So this denotes that it only occurs while using reference types as Value types are non-nullable.</source>
          <target state="translated">예외 자체는 무언가가 참조되고 있지만 값이 설정되지 않았다고 말합니다. 따라서 이것은 값 유형이 널 입력 불가능하므로 참조 유형을 사용하는 동안에 만 발생 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="06815801582cc6befb5ef98b61f02e87744088ac" translate="yes" xml:space="preserve">
          <source>The hardest one .. if the &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;GC&lt;/a&gt;&lt;/strong&gt; collected the object already... This generally occurs if you are trying to find an object using strings... That is, finding it by name of the object then it may happen that the GC might already cleaned it up... This is hard to find and will become quite a problem... A better way to tackle this is do null checks wherever necessary during the development process. This will save you a lot of time.</source>
          <target state="translated">가장 어려운 것은 .. &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;GC가&lt;/a&gt;&lt;/strong&gt; 이미 개체를 수집 한 경우 ... 이것은 일반적으로 문자열을 사용하여 개체를 찾으려고 할 때 발생합니다. 즉, 개체 이름으로 개체를 찾으면 GC가 이미 발생할 수 있습니다. 정리하기 ... 이것은 찾기가 어렵고 상당히 문제가 될 것입니다 ... 이것을 해결하는 더 좋은 방법은 개발 과정에서 필요한 곳에서 null 검사를하는 것입니다. 이렇게하면 많은 시간이 절약됩니다.</target>
        </trans-unit>
        <trans-unit id="6fe9c46a1f96250f3a78f255ee7a539166e5eefe" translate="yes" xml:space="preserve">
          <source>The message &lt;em&gt;&quot;Object not set to an instance of Object&quot;&lt;/em&gt; means you are trying to use an object which has not been initialized. This boils down to one of these:</source>
          <target state="translated">&lt;em&gt;&quot;개체가 개체의 인스턴스로 설정되지 않았습니다&quot;&lt;/em&gt; 라는 메시지는 초기화되지 않은 개체를 사용하려고 함을 나타냅니다. 이것은 다음 중 하나로 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="7e3ca54b85861772b0461d9717c527d72a64967f" translate="yes" xml:space="preserve">
          <source>The nested collection &lt;code&gt;Initializers&lt;/code&gt; behave the same:</source>
          <target state="translated">중첩 컬렉션 &lt;code&gt;Initializers&lt;/code&gt; 는 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="90aa4a0c7a11c901e2c17878dabdd430757e21cc" translate="yes" xml:space="preserve">
          <source>The nullable annotation context and nullable warning context can be set for a project using the &lt;code&gt;Nullable&lt;/code&gt; element in your &lt;code&gt;csproj&lt;/code&gt; file. This element configures how the compiler interprets the nullability of types and what warnings are generated. Valid settings are:</source>
          <target state="translated">&lt;code&gt;csproj&lt;/code&gt; 파일의 &lt;code&gt;Nullable&lt;/code&gt; 요소를 사용하여 프로젝트에 대해 Null 허용 주석 컨텍스트 및 Null 허용 경고 컨텍스트를 설정할 수 있습니다. 이 요소는 컴파일러가 형식의 null 허용 여부를 해석하는 방법과 생성되는 경고를 구성합니다. 유효한 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a10b33de1b42bbbc51b19833cb2f573dc939676f" translate="yes" xml:space="preserve">
          <source>The plain versions &lt;code&gt;First()&lt;/code&gt; and &lt;code&gt;Single()&lt;/code&gt; throw exceptions when there is nothing. The &quot;OrDefault&quot; versions return null in that case. So be aware of that.</source>
          <target state="translated">일반 버전 &lt;code&gt;First()&lt;/code&gt; 및 &lt;code&gt;Single()&lt;/code&gt; 은 아무것도 없을 때 예외를 발생시킵니다. 이 경우 &quot;OrDefault&quot;버전은 null을 반환합니다. 그러니 알아 두십시오.</target>
        </trans-unit>
        <trans-unit id="ca0d4b830b1ca78cc1cd2b85b0b059562a5a92dc" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;Dim&lt;/code&gt; does not create a CashRegister &lt;em&gt;object&lt;/em&gt;; it only declares a variable named &lt;code&gt;reg&lt;/code&gt; of that Type. &lt;em&gt;Declaring&lt;/em&gt; an object variable and creating an &lt;em&gt;instance&lt;/em&gt; are two different things.</source>
          <target state="translated">문제는 &lt;code&gt;Dim&lt;/code&gt; 이 CashRegister &lt;em&gt;오브젝트를&lt;/em&gt; 작성하지 않는다는 것입니다. 해당 유형의 &lt;code&gt;reg&lt;/code&gt; 라는 변수 만 선언합니다. 객체 변수 &lt;em&gt;선언&lt;/em&gt; 과 &lt;em&gt;인스턴스&lt;/em&gt; 생성은 서로 다른 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="f57a9af331b2b384f5e9bbf25e52891735f99da4" translate="yes" xml:space="preserve">
          <source>The rest of this article goes into more detail and shows mistakes that many programmers often make which can lead to a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">이 기사의 나머지 부분은 더 자세히 설명하고 많은 프로그래머가 종종 &lt;code&gt;NullReferenceException&lt;/code&gt; 을 일으킬 수있는 실수를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d27e02a7560754b5c14948489cc1146ab300619d" translate="yes" xml:space="preserve">
          <source>The result is that the name will be null when p is null or when p.Spouse is null.</source>
          <target state="translated">결과는 p가 null이거나 p.Spouse가 null 일 때 이름이 null이됩니다.</target>
        </trans-unit>
        <trans-unit id="09d1d7d139d2f9ffa7cf279ad2ecc6cf210c00d2" translate="yes" xml:space="preserve">
          <source>The same applies to nested object initializers:</source>
          <target state="translated">중첩 객체 이니셜 라이저에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ed30a1778fd31736e38acd0c7306ed44aa097108" translate="yes" xml:space="preserve">
          <source>The shorthand to providing a default value when a &lt;code&gt;null&lt;/code&gt; is encountered:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 발생했을 때 기본값을 제공하는 속기 :</target>
        </trans-unit>
        <trans-unit id="f4ffd808ec7172797ede1dca01b5953fc219db01" translate="yes" xml:space="preserve">
          <source>Then either &lt;a href=&quot;https://blogs.msdn.microsoft.com/zainnab/2010/11/01/start-debugging-vs-start-without-debugging/&quot;&gt;&lt;em&gt;Start with Debugging (F5)&lt;/em&gt;&lt;/a&gt; or &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/3s68z0b3.aspx&quot;&gt;&lt;em&gt;Attach [the VS Debugger] to Running Process&lt;/em&gt;&lt;/a&gt;. On occasion it may be useful to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.diagnostics.debugger.break(v=vs.110).aspx&quot;&gt;&lt;code&gt;Debugger.Break&lt;/code&gt;&lt;/a&gt;, which will prompt to launch the debugger.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://blogs.msdn.microsoft.com/zainnab/2010/11/01/start-debugging-vs-start-without-debugging/&quot;&gt;&lt;em&gt;디버깅 시작 (F5)&lt;/em&gt;&lt;/a&gt; 또는 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/3s68z0b3.aspx&quot;&gt;&lt;em&gt;[VS 디버거]를 실행중인 프로세스에 연결하십시오&lt;/em&gt;&lt;/a&gt; . 때때로 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.diagnostics.debugger.break(v=vs.110).aspx&quot;&gt; &lt;code&gt;Debugger.Break&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 유용 할 수 있는데, 이는 디버거를 시작하라는 프롬프트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9cf2c6701fe17f333948c2b1849db6510ba64ad5" translate="yes" xml:space="preserve">
          <source>Then following code will throw a NullReferenceException when you call context.SaveChanges()</source>
          <target state="translated">그런 다음 context를 호출하면 다음 코드에서 NullReferenceException이 발생합니다 .SaveChanges ()</target>
        </trans-unit>
        <trans-unit id="7838ef23cdbcdcb9c6a670f31c478d1f79518c71" translate="yes" xml:space="preserve">
          <source>Then go into your script and type &lt;code&gt;rb = GetComponent&amp;lt;Rigidbody&amp;gt;();&lt;/code&gt;</source>
          <target state="translated">그런 다음 스크립트로 이동하여 &lt;code&gt;rb = GetComponent&amp;lt;Rigidbody&amp;gt;();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad41fc4e6ef8e0d250fac274fb58d4f833539aab" translate="yes" xml:space="preserve">
          <source>There are also several libraries that can help. &quot;Resharper&quot; for example can provide you with warnings while you are writing code, especially if you use their attribute: &lt;a href=&quot;https://www.jetbrains.com/resharper/help/Reference__Code_Annotation_Attributes.html#NotNullAttribute&quot;&gt;NotNullAttribute&lt;/a&gt;</source>
          <target state="translated">도움을 줄 수있는 여러 라이브러리도 있습니다. 예를 들어 &quot;Resharper&quot;는 코드를 작성하는 동안, 특히 해당 속성을 사용하는 경우 경고를 제공 할 수 있습니다. &lt;a href=&quot;https://www.jetbrains.com/resharper/help/Reference__Code_Annotation_Attributes.html#NotNullAttribute&quot;&gt;NotNullAttribute&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbf732334378829eb2b72400cdd33b94ea5d2586" translate="yes" xml:space="preserve">
          <source>There are many good answers already here. You can also check more detailed description with examples on my &lt;a href=&quot;https://www.mistercode.net/2017/07/09/object-reference-not-set-to-an-instance-of-an-object/&quot;&gt;blog&lt;/a&gt;.</source>
          <target state="translated">이미 많은 좋은 답변이 있습니다. 내 &lt;a href=&quot;https://www.mistercode.net/2017/07/09/object-reference-not-set-to-an-instance-of-an-object/&quot;&gt;블로그의&lt;/a&gt; 예제를 통해 더 자세한 설명을 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="214fa86f68ca654e757c3e720dc78f2dd2fc2749" translate="yes" xml:space="preserve">
          <source>There are various ways and methods to avoid this renowned exception:</source>
          <target state="translated">이 예외를 피할 수있는 다양한 방법과 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="be839701a8b58386dc83c43578a529bbcc452e47" translate="yes" xml:space="preserve">
          <source>There is a lot of good answers here explaining what a null reference is and how to debug it. But there is very little on how to prevent the issue or at least make it easier to catch.</source>
          <target state="translated">여기에는 null 참조가 무엇인지 그리고 그것을 디버깅하는 방법을 설명하는 좋은 답변이 많이 있습니다. 그러나이 문제를 방지하거나 최소한 쉽게 잡을 수있는 방법은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="7dbc715d0df7bdf0cd07c3dbe5ecb31f64abf37a" translate="yes" xml:space="preserve">
          <source>There is an extra comma in the SQL (after 'mailaddress') which results in an exception at &lt;code&gt;.ExecuteReader&lt;/code&gt;. After the &lt;code&gt;Catch&lt;/code&gt; does nothing, &lt;code&gt;Finally&lt;/code&gt; tries to perform clean up, but since you cannot &lt;code&gt;Close&lt;/code&gt; a null &lt;code&gt;DataReader&lt;/code&gt; object, a brand new &lt;code&gt;NullReferenceException&lt;/code&gt; results.</source>
          <target state="translated">SQL에 여분의 쉼표가 있으며 ( 'mailaddress'뒤에) &lt;code&gt;.ExecuteReader&lt;/code&gt; 에서 예외가 발생합니다. &lt;code&gt;Catch&lt;/code&gt; 가 아무 작업도 수행하지 않으면 &lt;code&gt;Finally&lt;/code&gt; 정리를 수행하려고하지만 null &lt;code&gt;DataReader&lt;/code&gt; 개체를 &lt;code&gt;Close&lt;/code&gt; 수 없으므로 새로운 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ee30cd268c28ea93084f9a9c56e3288e8f18511d" translate="yes" xml:space="preserve">
          <source>There's &quot;Microsoft Code Contracts&quot; where you use syntax like &lt;code&gt;Contract.Requires(obj != null)&lt;/code&gt; which gives you runtime and compile checking: &lt;a href=&quot;http://www.codeproject.com/Articles/103779/Introducing-Code-Contracts&quot;&gt;Introducing Code Contracts&lt;/a&gt;.</source>
          <target state="translated">런타임 및 컴파일 검사를 제공하는 &lt;code&gt;Contract.Requires(obj != null)&lt;/code&gt; 와 같은 구문을 사용하는 &quot;Microsoft Code Contracts&quot;가 있습니다 : &lt;a href=&quot;http://www.codeproject.com/Articles/103779/Introducing-Code-Contracts&quot;&gt;Introducing Code Contracts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4586f5d6a7aef8d40083704fd4255e79f766656f" translate="yes" xml:space="preserve">
          <source>There's also &quot;PostSharp&quot; which will allow you to just use attributes like this:</source>
          <target state="translated">&quot;PostSharp&quot;도 있는데 다음과 같은 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35e0b1c03698b5fbfb3417627f45417f72e5c0bb" translate="yes" xml:space="preserve">
          <source>These cases arise because of the special rules the runtime uses when boxing &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; instances.</source>
          <target state="translated">이러한 경우는 &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; 인스턴스를 상자에 넣을 때 런타임에서 사용하는 특수 규칙으로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7c521d1475010ead5d72d575d5eea6c50ec89923" translate="yes" xml:space="preserve">
          <source>These should be easy to find now that you know what you are looking for:</source>
          <target state="translated">당신이 찾고있는 것을 알았으므로 이제 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bee35f92a41df1996281dd9bff320d1429a02b9" translate="yes" xml:space="preserve">
          <source>This answer will use Visual Basic terms, syntax, and context. The examples used come from a large number of past Stack&amp;nbsp; Overflow questions. This is to maximize relevance by using the &lt;em&gt;kinds&lt;/em&gt; of situations often seen in posts. A bit more explanation is also provided for those who might need it. An example similar to yours is &lt;em&gt;very&lt;/em&gt; likely listed here.</source>
          <target state="translated">이 답변은 Visual Basic 용어, 구문 및 컨텍스트를 사용합니다. 사용 된 예제는 과거의 많은 스택 오버플로 질문에서 비롯된 것입니다. 게시물에서 자주 볼 수있는 상황을 사용하여 관련성을 극대화합니다. 그것을 필요로하는 사람들을 위해 조금 더 설명이 제공됩니다. 귀하와 유사한 예가 여기에 나열되어있을 가능성이 큽니다.</target>
        </trans-unit>
        <trans-unit id="43191fd8397e396ff48392d8f06628560c113ac6" translate="yes" xml:space="preserve">
          <source>This array has only been declared, not created. There are several ways to initialize an array:</source>
          <target state="translated">이 배열은 선언되지 않았으며 생성되지 않았습니다. 배열을 초기화하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eebc527ad8416d09fe4ecd5b2aa132e7cea81190" translate="yes" xml:space="preserve">
          <source>This can be solved by following the convention to prefix fields with an underscore:</source>
          <target state="translated">필드에 밑줄을 붙이는 규칙에 따라 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="801881e44b7fc86f8a4310a9936bccc2fea2500b" translate="yes" xml:space="preserve">
          <source>This doesn't throw an &lt;code&gt;InvalidCastException&lt;/code&gt; but returns a &lt;code&gt;null&lt;/code&gt; when the cast fails (and when &lt;code&gt;someObject&lt;/code&gt; is itself null). So be aware of that.</source>
          <target state="translated">이것은 &lt;code&gt;InvalidCastException&lt;/code&gt; 을 발생 시키지 않지만 캐스트가 실패 할 때 (그리고 &lt;code&gt;someObject&lt;/code&gt; 자체가 null 일 경우) &lt;code&gt;null&lt;/code&gt; 을 반환합니다. 그러니 알아 두십시오.</target>
        </trans-unit>
        <trans-unit id="8fef908ebbf6aa8923a642c4bd0b4053bc545790" translate="yes" xml:space="preserve">
          <source>This is a case of an object not being created as expected, but also demonstrates the counter usefulness of an empty &lt;code&gt;Catch&lt;/code&gt;.</source>
          <target state="translated">이것은 예상대로 객체가 생성되지 않는 경우이지만 빈 &lt;code&gt;Catch&lt;/code&gt; 의 카운터 유용성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4e0fb87a39ead3f4c4ab6bccc75cb03367823f34" translate="yes" xml:space="preserve">
          <source>This is a case where the IDE will warn you that '&lt;em&gt;not all paths return a value and a &lt;code&gt;NullReferenceException&lt;/code&gt; may result&lt;/em&gt;'. You can suppress the warning, by replacing &lt;code&gt;Exit Function&lt;/code&gt; with &lt;code&gt;Return Nothing&lt;/code&gt;, but that does not solve the problem. Anything which tries to use the return when &lt;code&gt;someCondition = False&lt;/code&gt; will result in an NRE:</source>
          <target state="translated">IDE가 ' &lt;em&gt;모든 경로가 값을 반환하는 것은 아니며 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생할 수 있습니다&lt;/em&gt; '라고 경고하는 경우입니다. &lt;code&gt;Exit Function&lt;/code&gt; 을 &lt;code&gt;Return Nothing&lt;/code&gt; 으로 바꾸면 경고가 나타나지 않지만 문제가 해결되지는 않습니다. &lt;code&gt;someCondition = False&lt;/code&gt; 때 리턴 값을 사용하려고하면 NRE가됩니다.</target>
        </trans-unit>
        <trans-unit id="0b561450c1d02029fb3ee4e5c3a3347ea45692b7" translate="yes" xml:space="preserve">
          <source>This is a fairly common way to get an NRE. In C#, depending on how it is coded, the IDE will report that &lt;code&gt;Controls&lt;/code&gt; does not exist in the current context, or &quot;cannot reference non-static member&quot;. So, to some extent, this is a VB-only situation. It is also complex because it can result in a failure cascade.</source>
          <target state="translated">이것은 NRE를 얻는 매우 일반적인 방법입니다. C #에서는 코딩 방법에 따라 IDE가 현재 컨텍스트에 &lt;code&gt;Controls&lt;/code&gt; 이 없거나 &quot;정적이 아닌 멤버를 참조 할 수 없음&quot;을보고합니다. 따라서 어느 정도 VB 전용 상황입니다. 또한 캐스케이드 오류가 발생할 수 있으므로 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="187877ad8cb14ddcbabe75238a1bb7a9668c909a" translate="yes" xml:space="preserve">
          <source>This is also sometimes called the safe navigation or Elvis (after its shape) operator. If the expression on the left side of the operator is null, then the right side will not be evaluated, and null is returned instead. That means cases like this:</source>
          <target state="translated">안전 탐색 또는 Elvis (모양 이후) 연산자라고도합니다. 연산자의 왼쪽에있는 표현식이 널이면 오른쪽이 평가되지 않고 대신 널이 리턴됩니다. 이는 다음과 같은 경우를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="aa9ada07655b54e9494b58d5ce6297b70d859bb3" translate="yes" xml:space="preserve">
          <source>This is concept-based: there is no code for you to paste into your project. It is intended to help you understand what causes a &lt;code&gt;NullReferenceException&lt;/code&gt; (NRE), how to find it, how to fix it, and how to avoid it. An NRE can be caused many ways so this is unlikely to be your sole encounter.</source>
          <target state="translated">이것은 개념 기반입니다. 프로젝트에 붙여 넣을 코드는 없습니다. NRE ( &lt;code&gt;NullReferenceException&lt;/code&gt; )의 원인, 찾는 방법, 해결 방법 및 피하는 방법을 이해하는 데 도움이됩니다. NRE는 여러 가지 방법으로 발생할 수 있으므로 이것이 유일한 만남은 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="888280c788011247e567ae3ed361d10e659b622d" translate="yes" xml:space="preserve">
          <source>This is why you get a NullReferenceExeption because the computer does not have data stored in that variable.</source>
          <target state="translated">컴퓨터에 해당 변수에 저장된 데이터가 없기 때문에 NullReferenceExeption을 얻는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="21425312feec06d5937e5aa46a43ef71033a5a70" translate="yes" xml:space="preserve">
          <source>This line of code works best under your &lt;code&gt;Start()&lt;/code&gt; or &lt;code&gt;Awake()&lt;/code&gt; functions.</source>
          <target state="translated">이 코드 줄은 &lt;code&gt;Start()&lt;/code&gt; 또는 &lt;code&gt;Awake()&lt;/code&gt; 함수에서 가장 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dc1bf227c2a95d116418fc9c84ba8def88bc060c" translate="yes" xml:space="preserve">
          <source>This means the reference is &lt;code&gt;null&lt;/code&gt;, and you cannot access members (such as methods) through a &lt;code&gt;null&lt;/code&gt; reference. The simplest case:</source>
          <target state="translated">이는 참조가 &lt;code&gt;null&lt;/code&gt; 이며 &lt;code&gt;null&lt;/code&gt; 참조를 통해 멤버 (예 : 메소드)에 액세스 할 수 없음을 의미합니다. 가장 간단한 경우 :</target>
        </trans-unit>
        <trans-unit id="77e6e4ba966d107a04d5daf44a984b939a965789" translate="yes" xml:space="preserve">
          <source>This reduces the number of null checks you have to do in some cases. The syntax is to put a question mark before each dot. Take the following code for example:</source>
          <target state="translated">이를 통해 일부 경우에 수행해야하는 null 검사 횟수가 줄어 듭니다. 구문은 각 점 앞에 물음표를 넣는 것입니다. 예를 들어 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c0315d79171243f81b079786418630b61bc73573" translate="yes" xml:space="preserve">
          <source>This translates to</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="bed843e1a4ee572be6dff42169c3a5deee5b21c5" translate="yes" xml:space="preserve">
          <source>This way, you can avoid &lt;code&gt;NullReferenceException&lt;/code&gt; cases that are results of violation of the constraints set. For example, if you use an object property &lt;code&gt;X&lt;/code&gt; in a class and later try to invoke one of its methods and &lt;code&gt;X&lt;/code&gt; has a null value, then this will lead to &lt;code&gt;NullReferenceException&lt;/code&gt;:</source>
          <target state="translated">이러한 방식으로, 제한 조건 설정을 위반 한 결과 인 &lt;code&gt;NullReferenceException&lt;/code&gt; 을 피할 수 있습니다. 예를 들어 클래스에서 객체 속성 &lt;code&gt;X&lt;/code&gt; 를 사용하고 나중에 메소드 중 하나를 호출하려고 시도하고 &lt;code&gt;X&lt;/code&gt; 에 null 값이 있으면 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="ca62aa267e13467726859928ccd74cc220dd2bbb" translate="yes" xml:space="preserve">
          <source>This will create a &lt;em&gt;local&lt;/em&gt; variable, &lt;code&gt;reg&lt;/code&gt;, which exists only in that context (sub). The &lt;code&gt;reg&lt;/code&gt; variable with module level &lt;code&gt;Scope&lt;/code&gt; which you will use everywhere else remains &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">그러면 해당 컨텍스트 (sub)에만 존재하는 &lt;em&gt;로컬&lt;/em&gt; 변수 &lt;code&gt;reg&lt;/code&gt; 가 생성됩니다. 다른 곳에서 사용할 모듈 레벨 &lt;code&gt;Scope&lt;/code&gt; 의 &lt;code&gt;reg&lt;/code&gt; 변수는 &lt;code&gt;Nothing&lt;/code&gt; 으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="9886256ed1be06c975b72d5406cf9d7e42cde50b" translate="yes" xml:space="preserve">
          <source>This will do the following: If &lt;code&gt;myIntArray&lt;/code&gt; is null, the expression returns null and you can safely check it. If it contains an array, it will do the same as:
&lt;code&gt;elem = myIntArray[i];&lt;/code&gt; and returns the &lt;code&gt;i&amp;lt;sup&amp;gt;th&amp;lt;/sup&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;myIntArray&lt;/code&gt; 가 null 인 경우 표현식은 null을 반환하므로 안전하게 확인할 수 있습니다. 배열이 포함 된 경우 다음과 동일하게 수행됩니다. &lt;code&gt;elem = myIntArray[i];&lt;/code&gt; &lt;code&gt;i&amp;lt;sup&amp;gt;th&amp;lt;/sup&amp;gt;&lt;/code&gt; 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1db062d19edd3aad36fceee9160e7c1852968c5e" translate="yes" xml:space="preserve">
          <source>This will result in the title variable being &lt;code&gt;null&lt;/code&gt;, and the call to &lt;code&gt;ToUpper&lt;/code&gt; is not made if &lt;code&gt;person.Title&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">타이틀 변수는 &lt;code&gt;null&lt;/code&gt; 이되고, &lt;code&gt;person.Title&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우, &lt;code&gt;ToUpper&lt;/code&gt; 에의 호출은 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="037853ac976e876cd13f3318e4f680cf26902d26" translate="yes" xml:space="preserve">
          <source>This will throw a &lt;code&gt;NullReferenceException&lt;/code&gt; at the second line because you can't call the instance method &lt;code&gt;ToUpper()&lt;/code&gt; on a &lt;code&gt;string&lt;/code&gt; reference pointing to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 을 가리키는 &lt;code&gt;string&lt;/code&gt; 참조에서 인스턴스 메소드 &lt;code&gt;ToUpper()&lt;/code&gt; 를 호출 할 수 없기 때문에 두 번째 줄에서 &lt;code&gt;NullReferenceException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4adf93e86d1600f5a1f1d298afde221268eccfe7" translate="yes" xml:space="preserve">
          <source>Though this check &lt;a href=&quot;https://stackoverflow.com/questions/3021538/debug-assert-appears-in-release-mode&quot;&gt;will not end up in your release build&lt;/a&gt;, causing it to throw the &lt;code&gt;NullReferenceException&lt;/code&gt; again when &lt;code&gt;book == null&lt;/code&gt; at runtime in release mode.</source>
          <target state="translated">이 검사 &lt;a href=&quot;https://stackoverflow.com/questions/3021538/debug-assert-appears-in-release-mode&quot;&gt;는 릴리스 빌드에서 끝나지&lt;/a&gt; 않지만 릴리스 모드에서 런타임에 &lt;code&gt;book == null&lt;/code&gt; 일 때 &lt;code&gt;NullReferenceException&lt;/code&gt; 을 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="fe4569d04b34db2feeacd18b55f433f11ceeaa79" translate="yes" xml:space="preserve">
          <source>To avoid this error:</source>
          <target state="translated">이 오류를 피하려면</target>
        </trans-unit>
        <trans-unit id="b862da83d643fa0302757d37468767ad8e9ac824" translate="yes" xml:space="preserve">
          <source>To be clear, &lt;code&gt;Dim&lt;/code&gt; (or &lt;code&gt;Private&lt;/code&gt;) only &lt;em&gt;declares&lt;/em&gt; a variable and its &lt;code&gt;Type&lt;/code&gt;.   The &lt;em&gt;Scope&lt;/em&gt; of the variable - whether it exists for the entire module/class or is local to a procedure - is determined by &lt;em&gt;where&lt;/em&gt; it is declared. &lt;code&gt;Private | Friend | Public&lt;/code&gt; defines the access level, not &lt;em&gt;Scope&lt;/em&gt;.</source>
          <target state="translated">명확히하기 위해 &lt;code&gt;Dim&lt;/code&gt; (또는 &lt;code&gt;Private&lt;/code&gt; )은 변수와 &lt;code&gt;Type&lt;/code&gt; 만 &lt;em&gt;선언&lt;/em&gt; 합니다. 변수의 &lt;em&gt;범위 (&lt;/em&gt; 전체 모듈 / 클래스에 존재하는지 아니면 프로 시저에 로컬인지)는 선언 된 &lt;em&gt;위치에&lt;/em&gt; 따라 결정됩니다. &lt;code&gt;Private | Friend | Public&lt;/code&gt; 친구 | 공개 는 &lt;em&gt;범위가&lt;/em&gt; 아닌 액세스 레벨을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5ccb716ef7518f5e4cae9d82dbbb0fdfc28ad185" translate="yes" xml:space="preserve">
          <source>To fix this you have to instantiate (assign object to reference of that class).</source>
          <target state="translated">이 문제를 해결하려면 인스턴스화해야합니다 (객체를 해당 클래스의 참조로 지정).</target>
        </trans-unit>
        <trans-unit id="cfce5bc74512f792b40d3fd4bb577d39ad331d72" translate="yes" xml:space="preserve">
          <source>To fully understand why a NullReferenceException is thrown, it is important to know the difference between &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;value types&lt;/a&gt; and [reference types][3].</source>
          <target state="translated">NullReferenceException이 발생하는 이유를 완전히 이해하려면 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;값 유형&lt;/a&gt; 과 [참조 유형] [3]의 차이를 아는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="442fc389bbb8b0ecba07a137178cc20263b9b7c4" translate="yes" xml:space="preserve">
          <source>To prevent the error, objects that could be null should be tested for null before being used.</source>
          <target state="translated">오류를 방지하기 위해 널이 될 수있는 오브젝트를 사용하기 전에 널을 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="2fc08c6abe8c008843158c3dfc2b4819d97175ce" translate="yes" xml:space="preserve">
          <source>To understand why that is, it helps to understand how .NET produces null dereference exceptions in the first place. (These details apply to .NET running on Windows; other operating systems use similar mechanisms.)</source>
          <target state="translated">그 이유를 이해하려면 .NET이 우선 null 역 참조 예외를 생성하는 방법을 이해하는 데 도움이됩니다. (이 세부 사항은 Windows에서 실행되는 .NET에 적용되며 다른 운영 체제에서도 유사한 메커니즘을 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="1c409f99322562874653d2f8a0ab2c648ed33f45" translate="yes" xml:space="preserve">
          <source>Typically, the &lt;code&gt;Settings&lt;/code&gt; collection will only need to be initialized the first time the application runs. An alternate remedy is to add an initial value to your collection in &lt;strong&gt;Project -&amp;gt; Settings | FooBars&lt;/strong&gt;, save the project, then remove the fake value.</source>
          <target state="translated">일반적으로 &lt;code&gt;Settings&lt;/code&gt; 모음은 응용 프로그램을 처음 실행할 때만 초기화하면됩니다. 다른 해결 방법은 &lt;strong&gt;프로젝트-&amp;gt; 설정 |&lt;/strong&gt; &lt;strong&gt;FooBars&lt;/strong&gt; , 프로젝트를 저장 한 다음 가짜 값을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="516c8eebca6e87f940176b1effe4b60b6c0ea266" translate="yes" xml:space="preserve">
          <source>Typically, the simplest remedy is used.</source>
          <target state="translated">일반적으로 가장 간단한 치료법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="44ae451f7b7bc5e89c459fa403f51f895a24e5e5" translate="yes" xml:space="preserve">
          <source>UI Controls</source>
          <target state="translated">UI 컨트롤</target>
        </trans-unit>
        <trans-unit id="0367a9753f91933f52263dc3499b7fad896e44c1" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, trying to use an item from &lt;code&gt;My.Settings&lt;/code&gt; which is a &lt;code&gt;StringCollection&lt;/code&gt; can result in a NullReference the first time you use it. The solution is the same, but not as obvious. Consider:</source>
          <target state="translated">특정 상황에서 &lt;code&gt;My.Settings&lt;/code&gt; 에서 &lt;code&gt;StringCollection&lt;/code&gt; 인 항목을 사용하려고하면 처음 사용할 때 NullReference가 발생할 수 있습니다. 해결책은 동일하지만 명확하지 않습니다. 치다:</target>
        </trans-unit>
        <trans-unit id="5fd5faf037f6a68b87421df3d131d2dc06cf5ac5" translate="yes" xml:space="preserve">
          <source>Unhandled Exception:</source>
          <target state="translated">처리되지 않은 예외 :</target>
        </trans-unit>
        <trans-unit id="13d1de28b167068f1cf58b6d8b42d1a864bfb7e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Debug.Assert&lt;/code&gt; if a value should never be &lt;code&gt;null&lt;/code&gt;, to catch the problem earlier than the exception occurs.</source>
          <target state="translated">예외가 발생하기 전에 문제점을 조기에 발견하려면 값이 &lt;code&gt;null&lt;/code&gt; 이 아니어야하는 경우 &lt;code&gt;Debug.Assert&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="382f02f764a14908cf7b8365adec70912d5701d9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;GetValueOrDefault()&lt;/code&gt; for &lt;code&gt;nullable&lt;/code&gt; value types to provide a default value when they are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nullable&lt;/code&gt; 값 유형에 대해 &lt;code&gt;GetValueOrDefault()&lt;/code&gt; 를 사용하여 &lt;code&gt;null&lt;/code&gt; 일 때 기본값을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="2998b45c318d095c3e4535a7950d83516d58ebb7" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;For/Each&lt;/code&gt; loop and test the &lt;code&gt;IsNewRow&lt;/code&gt; property to determine if it is that last row. This works whether &lt;code&gt;AllowUserToAddRows&lt;/code&gt; is true or not:</source>
          <target state="translated">&lt;code&gt;For/Each&lt;/code&gt; 루프를 사용하고 &lt;code&gt;IsNewRow&lt;/code&gt; 속성을 테스트하여 마지막 행인지 확인하십시오. &lt;code&gt;AllowUserToAddRows&lt;/code&gt; 가 true인지 여부에 관계없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1b21080b0c77e9baa935891138a35678155ae048" translate="yes" xml:space="preserve">
          <source>Use null context (available in C# 8):</source>
          <target state="translated">null 컨텍스트 사용 (C # 8에서 사용 가능) :</target>
        </trans-unit>
        <trans-unit id="3c02b72e67d50c9e6e8df127d3c4c8b5ee96c2af" translate="yes" xml:space="preserve">
          <source>Use the null coalescing operator: &lt;code&gt;??&lt;/code&gt; [C#] or &lt;code&gt;If()&lt;/code&gt; [VB].</source>
          <target state="translated">널 병합 연산자를 사용하십시오. &lt;code&gt;??&lt;/code&gt; [C #] 또는 &lt;code&gt;If()&lt;/code&gt; [VB].</target>
        </trans-unit>
        <trans-unit id="eceb840fe473d205bb79bbfbe6842b028ab9de50" translate="yes" xml:space="preserve">
          <source>Use the null condition operator: &lt;code&gt;?.&lt;/code&gt; or &lt;code&gt;?[x]&lt;/code&gt; for arrays (available in C# 6 and VB.NET 14):</source>
          <target state="translated">널 조건 연산자 ( &lt;code&gt;?.&lt;/code&gt; 사용하십시오 . 또는 배열의 경우 &lt;code&gt;?[x]&lt;/code&gt; (C # 6 및 VB.NET 14에서 사용 가능) :</target>
        </trans-unit>
        <trans-unit id="e34781ddb98c0b7bad26d07124e848d7dc5380d0" translate="yes" xml:space="preserve">
          <source>User defined structs</source>
          <target state="translated">사용자 정의 구조체</target>
        </trans-unit>
        <trans-unit id="4c9bf9d75e9c5172e3585c1c3082c6d25bacf2fa" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;List(Of T)&lt;/code&gt; will make it quite difficult to have an element without a valid object:</source>
          <target state="translated">&lt;code&gt;List(Of T)&lt;/code&gt; 를 사용하면 유효한 객체가없는 요소를 갖는 것이 매우 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="e0cf661777181bb5bf4bab3c932185766cf29b18" translate="yes" xml:space="preserve">
          <source>Validate data before using it (also use &lt;code&gt;Option Strict&lt;/code&gt; and SQL parameters):</source>
          <target state="translated">사용하기 전에 데이터의 유효성을 검사하십시오 ( &lt;code&gt;Option Strict&lt;/code&gt; 및 SQL 매개 변수도 사용).</target>
        </trans-unit>
        <trans-unit id="3b3c5424e9429ade50d2ed4719daf8a5ef46e7c7" translate="yes" xml:space="preserve">
          <source>Value Types and Reference Types</source>
          <target state="translated">값 유형 및 참조 유형</target>
        </trans-unit>
        <trans-unit id="b7d9a51e2fb5186d4548644a10a85dfb83b90aff" translate="yes" xml:space="preserve">
          <source>Visual Basic Forms</source>
          <target state="translated">Visual Basic 양식</target>
        </trans-unit>
        <trans-unit id="914f780030704154b3755eefa6c85d3acdf3b1c7" translate="yes" xml:space="preserve">
          <source>Visual Basic tries to make the process clear repeatedly using &lt;strong&gt;&lt;code&gt;New&lt;/code&gt;&lt;/strong&gt;: Using the &lt;strong&gt;&lt;code&gt;New&lt;/code&gt;&lt;/strong&gt; Operator creates a &lt;strong&gt;new&lt;/strong&gt; object and calls &lt;strong&gt;&lt;code&gt;Sub New&lt;/code&gt;&lt;/strong&gt; -- the constructor -- where your object can perform any other initialization.</source>
          <target state="translated">Visual Basic은 &lt;strong&gt; &lt;code&gt;New&lt;/code&gt; 를&lt;/strong&gt; 사용하여 프로세스를 반복적으로 명확하게 만들려고합니다. &lt;strong&gt;New&lt;/strong&gt; 연산자를 사용하면 &lt;strong&gt;새&lt;/strong&gt; 개체가 만들어지고 개체가 다른 초기화를 수행 할 수있는 &lt;strong&gt; &lt;code&gt;Sub New&lt;/code&gt; (&lt;/strong&gt; 생성자)가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4356f5b2bed387a822b4773e00b955c30fb15382" translate="yes" xml:space="preserve">
          <source>WPF Control Creation Order and Events</source>
          <target state="translated">WPF 컨트롤 생성 순서 및 이벤트</target>
        </trans-unit>
        <trans-unit id="865749e3cc387179c321ac3469aa809ca6ea641d" translate="yes" xml:space="preserve">
          <source>Ways to Avoid</source>
          <target state="translated">피하는 방법</target>
        </trans-unit>
        <trans-unit id="b50ff997c836b3bf135585b592d9922fb8daa6c5" translate="yes" xml:space="preserve">
          <source>We can add data really easily actually in a few ways:</source>
          <target state="translated">실제로 몇 가지 방법으로 데이터를 실제로 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="171db29c0e9a7d26b4e0c78fa029495735b943f5" translate="yes" xml:space="preserve">
          <source>Well, in simple terms:</source>
          <target state="translated">간단히 말해서,</target>
        </trans-unit>
        <trans-unit id="54f0454febe335028ebb7ac67e60ee8639c8bb01" translate="yes" xml:space="preserve">
          <source>What about the second point? Dereferencing &lt;em&gt;any&lt;/em&gt; invalid pointer that falls in the lowest page of virtual memory causes the same operating system error, and thereby the same exception.</source>
          <target state="translated">두 번째 요점은 어떻습니까? 가상 메모리의 가장 낮은 페이지에 해당 &lt;em&gt;하는&lt;/em&gt; 잘못된 포인터를 참조하면 동일한 운영 체제 오류가 발생하여 동일한 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a57d36dd7547d0d01d63f5a0dca33743ac6b0190" translate="yes" xml:space="preserve">
          <source>What does that mean?</source>
          <target state="translated">그게 무슨 뜻이야?</target>
        </trans-unit>
        <trans-unit id="dfc9e4324fb08b6a8f17d724cf8c6155af43dd1b" translate="yes" xml:space="preserve">
          <source>What does this mean, and what can I do to fix this error?</source>
          <target state="translated">이것은 무엇을 의미하며이 오류를 해결하기 위해 무엇을 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="682501e35814b10bb49bcce3a8138d93e7237565" translate="yes" xml:space="preserve">
          <source>What is a NullReferenceException, and how do I fix it</source>
          <target state="translated">NullReferenceException은 무엇이며 어떻게 해결합니까?</target>
        </trans-unit>
        <trans-unit id="2b175120120a58af183c09ae1970097e643335ca" translate="yes" xml:space="preserve">
          <source>What is the cause?</source>
          <target state="translated">원인이 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4d05bb2729110f107617bc429ecb0bc63e601752" translate="yes" xml:space="preserve">
          <source>When a property of a null object accessed:</source>
          <target state="translated">null 객체의 속성에 액세스 한 경우 :</target>
        </trans-unit>
        <trans-unit id="24ee47a5b48927d93ac97774fc77bc2a3836d6a2" translate="yes" xml:space="preserve">
          <source>When a string method of an empty string accessed:</source>
          <target state="translated">빈 문자열의 문자열 메소드에 액세스 한 경우 :</target>
        </trans-unit>
        <trans-unit id="0d8ca3f12ffd0492f759832995654e7110254f83" translate="yes" xml:space="preserve">
          <source>When declared as a module/class level variable, as appears to be the case with &lt;code&gt;con&lt;/code&gt;, the compiler can't know if the object was created by an upstream procedure. Do not ignore warnings.</source>
          <target state="translated">&lt;code&gt;con&lt;/code&gt; 의 경우와 같이 모듈 / 클래스 레벨 변수로 선언되면 컴파일러는 객체가 업스트림 프로 시저에 의해 작성되었는지 알 수 없습니다. 경고를 무시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="efc21187e8ea71d0502b9553436531ff09010739" translate="yes" xml:space="preserve">
          <source>When it is only appropriate to create the instance later:</source>
          <target state="translated">나중에 인스턴스를 작성하는 것이 적절한 경우 :</target>
        </trans-unit>
        <trans-unit id="e320e6e3ad0e90936d129472db697d3b8b8d6e80" translate="yes" xml:space="preserve">
          <source>When working &lt;strong&gt;across different layers&lt;/strong&gt;, for example in an MVC application, a controller needs services to call business operations. In such scenarios &lt;strong&gt;Dependency Injection Container&lt;/strong&gt; can be used to initialize the services to avoid the &lt;strong&gt;NullReferenceException&lt;/strong&gt;. So that means you don't need to worry about checking for null and just call the services from the controller as though they will always to available (and initialized) as either a singleton or a prototype.</source>
          <target state="translated">MVC 애플리케이션과 같이 &lt;strong&gt;서로 다른 계층&lt;/strong&gt; 에서 작업 할 때 컨트롤러는 비즈니스 운영을 호출하는 서비스가 필요합니다. 이러한 시나리오에서는 &lt;strong&gt;Dependency Injection Container&lt;/strong&gt; 를 사용하여 &lt;strong&gt;NullReferenceException&lt;/strong&gt; 을 피하기 위해 서비스를 초기화 할 수 있습니다. 따라서 null 검사에 대해 걱정할 필요가 없으며 컨트롤러에서 서비스를 항상 싱글 톤 또는 프로토 타입으로 사용할 수있는 것처럼 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="dba90f1005ef6b9743a2d890263f4e1876834da6" translate="yes" xml:space="preserve">
          <source>When you know during development that a method maybe can, but never should return &lt;code&gt;null&lt;/code&gt;, you can use &lt;code&gt;Debug.Assert()&lt;/code&gt; to break as soon as possible when it does occur:</source>
          <target state="translated">개발 중에 메서드가 가능하지만 &lt;code&gt;null&lt;/code&gt; 을 반환해서는 안된다는 것을 알면 &lt;code&gt;Debug.Assert()&lt;/code&gt; 를 사용하여 가능한 빨리 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1492aaa2d900e272a66ec2ee7932c7c567523b15" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;DataGridView&lt;/code&gt; has &lt;code&gt;AllowUserToAddRows&lt;/code&gt; as &lt;code&gt;True&lt;/code&gt; (the default), the &lt;code&gt;Cells&lt;/code&gt; in the blank/new row at the bottom will all contain &lt;code&gt;Nothing&lt;/code&gt;.  Most attempts to use the contents (for example, &lt;code&gt;ToString&lt;/code&gt;) will result in an NRE.</source>
          <target state="translated">&lt;code&gt;DataGridView&lt;/code&gt; 에 &lt;code&gt;AllowUserToAddRows&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; (기본값) 인 경우 맨 아래에있는 빈 / 새 행의 &lt;code&gt;Cells&lt;/code&gt; 에는 모두 &lt;code&gt;Nothing&lt;/code&gt; 이 포함됩니다. 대부분의 내용 (예 : &lt;code&gt;ToString&lt;/code&gt; )을 사용하면 NRE가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cdb948906225c5be7dabe665fe3268f2aa7f7d1b" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;what&lt;/em&gt; causes a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;NullReferenceExceptions&lt;/a&gt; and approaches to &lt;em&gt;avoid/fix&lt;/em&gt; such an exception have been addressed in other answers, what many programmers haven't learned yet is how to independently &lt;em&gt;debug&lt;/em&gt; such exceptions during development.</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;NullReferenceExceptions을&lt;/a&gt; 유발하는 원인과 그러한 예외를 &lt;em&gt;피 / 수정&lt;/em&gt; 하는 접근법은 다른 답변에서 해결되었지만 많은 프로그래머가 아직 배우지 않은 것은 개발 중에 이러한 예외를 독립적으로 &lt;em&gt;디버깅&lt;/em&gt; 하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="448dc745cee8454cb3051219a2b24ea7029e0795" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;new&lt;/code&gt; keyword is used, it only creates a new instance of &lt;code&gt;Book&lt;/code&gt;, but not a new instance of &lt;code&gt;Person&lt;/code&gt;, so the &lt;code&gt;Author&lt;/code&gt; the property is still &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 키워드가 사용되는 동안 &lt;code&gt;Book&lt;/code&gt; 의 새 인스턴스 만 작성되지만 &lt;code&gt;Person&lt;/code&gt; 의 새 인스턴스는 작성되지 않으므로 &lt;code&gt;Author&lt;/code&gt; 속성은 여전히 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d52f9ee0d5e0aa5f23d1b3b5d8e4d2e56fca0930" translate="yes" xml:space="preserve">
          <source>Why does this make sense?  Well, suppose we have a struct containing two ints, and an unmanaged pointer equal to null. If we attempt to dereference the second int in the struct, the &lt;code&gt;CLR&lt;/code&gt; will not attempt to access the storage at location zero; it will access the storage at location four. But logically this is a null dereference because we are getting to that address &lt;em&gt;via&lt;/em&gt; the null.</source>
          <target state="translated">왜 이것이 의미가 있습니까? 두 개의 int를 포함하는 구조체와 null과 같은 관리되지 않는 포인터가 있다고 가정 해보십시오. 구조체에서 두 번째 int를 역 참조하려고하면 &lt;code&gt;CLR&lt;/code&gt; 은 위치 0에서 저장소에 액세스하려고 시도하지 않습니다. 위치 4의 스토리지에 액세스합니다. 그러나 논리적으로 이것은 null을 &lt;em&gt;통해&lt;/em&gt; 해당 주소에 도달하기 때문에 null 역 참조입니다.</target>
        </trans-unit>
        <trans-unit id="e5b3e5b5a3ce438cfd892d68ca821da56bd33f46" translate="yes" xml:space="preserve">
          <source>Why is this wrong?  Because the iterator block does not actually &lt;em&gt;run&lt;/em&gt; until the &lt;code&gt;foreach&lt;/code&gt;!  The call to &lt;code&gt;GetFrobs&lt;/code&gt; simply returns an object which &lt;em&gt;when iterated&lt;/em&gt; will run the iterator block.</source>
          <target state="translated">왜 이것이 잘못 되었습니까? 반복자 블록은 실제로 &lt;code&gt;foreach&lt;/code&gt; ! &lt;code&gt;GetFrobs&lt;/code&gt; 에 대한 호출은 단순히 &lt;em&gt;반복&lt;/em&gt; 될 &lt;em&gt;때&lt;/em&gt; 반복자 블록을 실행할 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd8f068ecfc9cc04c00494e69ae5f6e0960b7ae7" translate="yes" xml:space="preserve">
          <source>Why it occurs?</source>
          <target state="translated">왜 발생합니까?</target>
        </trans-unit>
        <trans-unit id="cce1faca008b524ebe3411e4a56c2cb194dc1b42" translate="yes" xml:space="preserve">
          <source>Working with databases presents many opportunities for a NullReference because there can be many objects (&lt;code&gt;Command&lt;/code&gt;, &lt;code&gt;Connection&lt;/code&gt;, &lt;code&gt;Transaction&lt;/code&gt;, &lt;code&gt;Dataset&lt;/code&gt;, &lt;code&gt;DataTable&lt;/code&gt;, &lt;code&gt;DataRows&lt;/code&gt;....) in use at once.  &lt;strong&gt;Note:&lt;/strong&gt; It does not matter which data provider you are using -- MySQL, SQL Server, OleDB, etc. -- the &lt;em&gt;concepts&lt;/em&gt; are the same.</source>
          <target state="translated">데이터베이스를 사용하면 한 번에 많은 오브젝트 ( &lt;code&gt;Command&lt;/code&gt; , &lt;code&gt;Connection&lt;/code&gt; , &lt;code&gt;Transaction&lt;/code&gt; , &lt;code&gt;Dataset&lt;/code&gt; , &lt;code&gt;DataTable&lt;/code&gt; , &lt;code&gt;DataRows&lt;/code&gt; ....)가 사용될 수 있으므로 NullReference에 많은 기회가 제공됩니다. &lt;strong&gt;참고 :&lt;/strong&gt; MySQL, SQL Server, OleDB 등 어떤 데이터 공급자를 사용하든 &lt;em&gt;개념&lt;/em&gt; 은 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="723856ede778551d9c785472d51c2f7fcbb54d7d" translate="yes" xml:space="preserve">
          <source>You are trying to access an object that isn't created or currently not in memory.</source>
          <target state="translated">작성되지 않았거나 현재 메모리에없는 오브젝트에 액세스하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8aa880592f3584b0eb7955f587d23cf9a9b8e76b" translate="yes" xml:space="preserve">
          <source>You are trying to use a reference variable whose value is &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;.  When the value is &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; for the reference variable, that means it is not actually holding a reference to an instance of any object that exists on the heap.</source>
          <target state="translated">값이 &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; 인 참조 변수를 사용하려고합니다. 참조 변수에 대한 값이 &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; 인 경우 실제로 힙에 존재하는 객체의 인스턴스에 대한 참조를 보유하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4b4d5b042ee1470a88bab9f1d60f9144e6f609fc" translate="yes" xml:space="preserve">
          <source>You are trying to use something that is &lt;code&gt;null&lt;/code&gt; (or &lt;code&gt;Nothing&lt;/code&gt; in VB.NET). This means you either set it to &lt;code&gt;null&lt;/code&gt;, or you never set it to anything at all.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 또는 VB.NET의 &lt;code&gt;Nothing&lt;/code&gt; 을 사용하려고합니다. 즉, &lt;code&gt;null&lt;/code&gt; 로 설정하거나 전혀 설정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a4b2a4f8cb9ff198b895cb45c6d69095f67060ba" translate="yes" xml:space="preserve">
          <source>You are using the object that contains the null value reference. So it's giving a null exception. In the example the string value is null and when checking its length, the exception occurred.</source>
          <target state="translated">널값 참조가 포함 된 오브젝트를 사용하고 있습니다. 따라서 null 예외가 발생합니다. 이 예에서 문자열 값은 null이며 길이를 확인할 때 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="c6e71d37b17fa53433b0f7d95131ec2c8f8e5dcd" translate="yes" xml:space="preserve">
          <source>You can add a component programmatically and assign the variable at the same time with one line of code: &lt;code&gt;rb = AddComponent&amp;lt;RigidBody&amp;gt;();&lt;/code&gt;</source>
          <target state="translated">프로그래밍 방식으로 구성 요소를 추가하고 한 줄의 코드로 변수를 동시에 지정할 수 있습니다. &lt;code&gt;rb = AddComponent&amp;lt;RigidBody&amp;gt;();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c38e20677037c680c41cdbbd3a874a5b75b4783" translate="yes" xml:space="preserve">
          <source>You can also throw a custom exception, only to catch it in the calling code:</source>
          <target state="translated">호출 코드에서 예외를 잡기 위해 사용자 정의 예외를 던질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ea64ffa695b740770485aaba63974913381c9a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;Locals Window&lt;/code&gt; (&lt;strong&gt;Debug -&amp;gt; Windows -&amp;gt; Locals&lt;/strong&gt;) to examine your objects.</source>
          <target state="translated">&lt;code&gt;Locals Window&lt;/code&gt; ( &lt;strong&gt;Debug-&amp;gt; Windows-&amp;gt; Locals&lt;/strong&gt; )을 사용하여 객체를 검사 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="12a1a3c92ffa52e6b050bf7546290b5e6ce658b2" translate="yes" xml:space="preserve">
          <source>You can fix NullReferenceException in a clean way using Null-conditional Operators in c#6 and write less code to handle null checks.</source>
          <target state="translated">c # 6의 Null 조건부 연산자를 사용하여 NullReferenceException을 깔끔하게 수정하고 null 검사를 처리하기 위해 적은 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2edd59e412b940b382162755da24e3b3a55a1a98" translate="yes" xml:space="preserve">
          <source>You can simply avoid this by checking if the variable is not null:</source>
          <target state="translated">변수가 null이 아닌지 확인하여 간단히 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1588e2df3c8e2e5e50543e8a09e318c3ac852eb" translate="yes" xml:space="preserve">
          <source>You either never assigned something to the variable, never created an instance of the value assigned to the variable, or you set the variable equal to &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; manually, or you called a function that set the variable to &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; for you.</source>
          <target state="translated">변수에 무언가를 할당하지 않았거나 변수에 지정된 값의 인스턴스를 생성하지 않았거나 변수를 수동으로 &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; 로 설정하거나 변수를 &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; 로 설정하는 함수를 호출했습니다.</target>
        </trans-unit>
        <trans-unit id="f66228601ed3724d69b717ec6fe23f27ca71e042" translate="yes" xml:space="preserve">
          <source>You get the same exception for the same reason - &lt;code&gt;myList&lt;/code&gt; was only declared, but no instance created. The remedy is the same:</source>
          <target state="translated">같은 이유로 같은 예외가 발생합니다. &lt;code&gt;myList&lt;/code&gt; 는 선언되었지만 인스턴스가 생성되지 않았습니다. 해결책은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7d96029677307b05bf0beda9a46b585a9c96a9a3" translate="yes" xml:space="preserve">
          <source>You probably forgot the &lt;code&gt;New&lt;/code&gt; operator.</source>
          <target state="translated">아마도 &lt;code&gt;New&lt;/code&gt; 연산자를 잊었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9889cfa340b5a188c4545454aa3970b650ff6a92" translate="yes" xml:space="preserve">
          <source>You should also remove any Try/Catch blocks from the relevant code, especially ones where there is nothing in the Catch block. This will cause your code to crash when it tries to use an object which is &lt;code&gt;Nothing&lt;/code&gt;. &lt;strong&gt;This is what you want&lt;/strong&gt; because it will identify the exact &lt;em&gt;location&lt;/em&gt; of the problem, and allow you to identify the object causing it.</source>
          <target state="translated">또한 관련 코드, 특히 Catch 블록에 아무것도없는 Try / Catch 블록을 제거해야합니다. &lt;code&gt;Nothing&lt;/code&gt; 객체를 사용하려고하면 코드가 중단됩니다. &lt;strong&gt;이것은&lt;/strong&gt; 문제의 정확한 &lt;em&gt;위치&lt;/em&gt; 를 식별하고 문제를 일으키는 개체를 식별 할 수 있기 때문에 &lt;strong&gt;원하는&lt;/strong&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="7cf85e9877af0174191657bf941763d81f747650" translate="yes" xml:space="preserve">
          <source>You would use very similar to the same way you would use &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, except with the goal of accomplishing exactly the opposite - to not allow &lt;code&gt;null&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">&lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; 사용하는 것과 같은 방식으로 매우 유사한 방법을 사용합니다. 단, &lt;code&gt;null&lt;/code&gt; 을 허용하지 않도록 정반대를 달성한다는 목표는 예외입니다. 여기 예시들이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1cc0e4045b9e917b4e600760083043c55ca6aa29" translate="yes" xml:space="preserve">
          <source>Your code &lt;em&gt;declared&lt;/em&gt; an object variable, but it did not &lt;em&gt;initialize&lt;/em&gt; it (create an instance or '&lt;em&gt;instantiate&lt;/em&gt;' it)</source>
          <target state="translated">코드에서 객체 변수를 &lt;em&gt;선언&lt;/em&gt; 했지만 &lt;em&gt;초기화&lt;/em&gt; 하지 않았습니다 (인스턴스 생성 또는 ' &lt;em&gt;인스턴스화&lt;/em&gt; ').</target>
        </trans-unit>
        <trans-unit id="1835adb6d4755dbbf56a8c76ede96fd8258bbc9c" translate="yes" xml:space="preserve">
          <source>above line throws error because reference of class myClass is declared but not instantiated or an instance of object is not assigned to referecne of that class.</source>
          <target state="translated">위의 행은 myClass 클래스의 참조가 선언되었지만 인스턴스화되지 않았거나 객체의 인스턴스가 해당 클래스의 참조에 지정되지 않았기 때문에 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="163efa6e9cc8a00507230d1f61d9db3d11ab97db" translate="yes" xml:space="preserve">
          <source>and Contact entity class. Sometimes entity classes are partial classes so that you can extend them in other files too.</source>
          <target state="translated">및 연락 엔티티 클래스. 때로는 엔티티 클래스가 부분 클래스이므로 다른 파일에서도 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="45932d6fa98f39c5cd3f08cd951d8dc70fc5f7de" translate="yes" xml:space="preserve">
          <source>decimal</source>
          <target state="translated">decimal</target>
        </trans-unit>
        <trans-unit id="f7852992c275998df7dbb34bd4a576549f4622aa" translate="yes" xml:space="preserve">
          <source>dereferencing a null &lt;strong&gt;pointer&lt;/strong&gt; produces the same exception as dereferencing a null &lt;strong&gt;reference&lt;/strong&gt;</source>
          <target state="translated">널 &lt;strong&gt;포인터&lt;/strong&gt; 를 역 참조하면 널 &lt;strong&gt;참조&lt;/strong&gt; 를 역 참조하는 것과 동일한 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b2e6f52aa2a81fb92f818a3436c6758ad33c8a3" translate="yes" xml:space="preserve">
          <source>dereferencing an invalid non-null pointer &lt;strong&gt;can&lt;/strong&gt; produce that exception
in some circumstances</source>
          <target state="translated">널 (null)이 아닌 널 (null)이 아닌 포인터를 참조 해제하면 일부 상황에서 해당 예외가 &lt;strong&gt;발생할 수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5031a46dd38e909839b52a146a7969402061271" translate="yes" xml:space="preserve">
          <source>disable: The nullable annotation context is disabled. The nullable warning context is disabled. Variables of a reference type are oblivious, just like earlier versions of C#. All nullability warnings are disabled.</source>
          <target state="translated">disable : 널 입력 가능 주석 컨텍스트가 사용 불가능합니다. 널 입력 가능 경고 컨텍스트가 사용 불가능합니다. C #의 이전 버전과 마찬가지로 참조 유형의 변수는 분명하지 않습니다. 모든 Null 허용 경고가 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="5452220584f9d82eacc9d4b64b556c642aa95fe3" translate="yes" xml:space="preserve">
          <source>dynamic</source>
          <target state="translated">dynamic</target>
        </trans-unit>
        <trans-unit id="707ee2e80d8a348ed040077b064ae8b11ce87533" translate="yes" xml:space="preserve">
          <source>enable: The nullable annotation context is enabled. The nullable warning context is enabled. Variables of a reference type, string for example, are non-nullable. All nullability warnings are enabled.</source>
          <target state="translated">enable : 널 입력 가능 주석 컨텍스트가 사용 가능합니다. 널 입력 가능 경고 컨텍스트가 사용 가능합니다. 예를 들어 문자열과 같은 참조 유형의 변수는 널 입력이 불가능합니다. 모든 Null 허용 경고가 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="f93306a0064ddaa9f3c518dfda6d24b1659b5141" translate="yes" xml:space="preserve">
          <source>for example: let say you have a class called myClass and it contains one property prop1.</source>
          <target state="translated">예를 들어 : myClass라는 클래스가 있고 prop1 속성이 하나 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="4d3e8614703ea126434cc11d59e3c7a70c66d624" translate="yes" xml:space="preserve">
          <source>foreach</source>
          <target state="translated">foreach</target>
        </trans-unit>
        <trans-unit id="23ec53a4c09cf5266253f2e3ee5c91b8b4eb9045" translate="yes" xml:space="preserve">
          <source>in here , if address is null , then you will get NullReferenceException.</source>
          <target state="translated">여기에서 address가 null이면 NullReferenceException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1d02abd73c8fc5445c71c4fbe24bc25707ea3d7a" translate="yes" xml:space="preserve">
          <source>public class Form1
{
    private Customer customer;</source>
          <target state="translated">공개 클래스 Form1 {개인 고객 고객;</target>
        </trans-unit>
        <trans-unit id="c133b31de2d5fc69bf6862d425df4a2337f78d3d" translate="yes" xml:space="preserve">
          <source>safeonly: The nullable annotation context is enabled. The nullable warning context is safeonly. Variables of a reference type are nonnullable. All safety nullability warnings are enabled.</source>
          <target state="translated">safeonly : nullable 주석 컨텍스트가 활성화되었습니다. 널 입력 가능 경고 컨텍스트는 안전합니다. 참조 유형의 변수는 널 입력이 불가능합니다. 모든 안전 무효 성 경고가 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="3a061cb7a56d7292f241332c224fcac2f287af0a" translate="yes" xml:space="preserve">
          <source>safeonlywarnings: The nullable annotation context is disabled. The nullable warning context is safeonly.
    Variables of a reference type are oblivious. All safety nullability warnings are enabled.</source>
          <target state="translated">safeonlywarnings : 널 입력 가능 주석 컨텍스트가 사용 불가능합니다. 널 입력 가능 경고 컨텍스트는 안전합니다. 참조 유형의 변수는 분명하지 않습니다. 모든 안전 무효 성 경고가 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="2abda58ce57dab947ad0b74eb5487833707a6213" translate="yes" xml:space="preserve">
          <source>the following code will be problematic:</source>
          <target state="translated">다음 코드는 문제가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="43a38bb2effe5dc812d40a39ec117e6b0fd8f1fc" translate="yes" xml:space="preserve">
          <source>warnings: The nullable annotation context is disabled. The nullable warning context is enabled. Variables of a reference type are oblivious. All nullability warnings are enabled.</source>
          <target state="translated">경고 : 널 입력 가능한 주석 컨텍스트가 사용 불가능합니다. 널 입력 가능 경고 컨텍스트가 사용 가능합니다. 참조 유형의 변수는 분명하지 않습니다. 모든 Null 허용 경고가 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="365054ee499f3b2258d3a22f7fa3f931704bc717" translate="yes" xml:space="preserve">
          <source>where an &lt;strong&gt;&lt;em&gt;unboxing&lt;/em&gt;&lt;/strong&gt; conversion (cast) &lt;em&gt;from&lt;/em&gt;&lt;code&gt;object&lt;/code&gt; (or from one of the classes &lt;code&gt;System.ValueType&lt;/code&gt; or &lt;code&gt;System.Enum&lt;/code&gt;, or from an interface type) &lt;em&gt;to&lt;/em&gt; a value type (other than &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt;) in itself gives the &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;object&lt;/code&gt; (또는 &lt;code&gt;System.ValueType&lt;/code&gt; 또는 &lt;code&gt;System.Enum&lt;/code&gt; 클래스 중 하나 또는 인터페이스 유형) &lt;em&gt;에서&lt;/em&gt; 값 유형 ( &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; 이외) &lt;em&gt;으로&lt;/em&gt; 의 &lt;strong&gt;&lt;em&gt;언 박싱&lt;/em&gt;&lt;/strong&gt; 변환 (캐스트)은 &lt;code&gt;NullReferenceException&lt;/code&gt; 을 제공합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
