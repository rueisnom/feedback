<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/4660142">
    <body>
      <group id="4660142">
        <trans-unit id="9396f5058c8dfed94f5b53595720fed9df43bfa6" translate="yes" xml:space="preserve">
          <source>&quot;Button2&quot; resides on a &lt;code&gt;Panel&lt;/code&gt;</source>
          <target state="translated">「Button2」は &lt;code&gt;Panel&lt;/code&gt; 上にあります</target>
        </trans-unit>
        <trans-unit id="db5a5b1d9a6c5f4c860c37395021bbd5362fafa2" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;&lt;strong&gt;&lt;em&gt;NullReferenceException&lt;/em&gt;&lt;/strong&gt;&amp;rsquo; also occurs when we forget to instantiate a reference type.</source>
          <target state="translated">' &lt;strong&gt;&lt;em&gt;NullReferenceException&lt;/em&gt;&lt;/strong&gt; 'は、参照型のインスタンス化を忘れた場合にも発生します。</target>
        </trans-unit>
        <trans-unit id="dcee1b5e3a8c625c5a9735ca8c8ec5d25be46495" translate="yes" xml:space="preserve">
          <source>(Another reason for non-using unsafe code unless you need it, by the way)</source>
          <target state="translated">(ところで、安全でないコードを必要としない限り使わないもう一つの理由)</target>
        </trans-unit>
        <trans-unit id="673f15918a55d1f2ddf729938db9ca922559f3ca" translate="yes" xml:space="preserve">
          <source>.NET collections (of which there are many varieties - Lists, Dictionary, etc.) must also be instantiated or created.</source>
          <target state="translated">.NETコレクション(リスト、辞書など多くの種類があります)もインスタンス化または作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="c04d4ae82bc72a4bd980abe754c0c8da8a6d3e11" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/11244949/5407188&quot;&gt;Simon Mourier gave this example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/11244949/5407188&quot;&gt;Simon Mourierがこの例を示しました&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="96e9ca8abbe2f8b39135700b77c31732f2dac12b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AndAlso&lt;/code&gt; is important. Subsequent tests will not be performed once the first &lt;code&gt;False&lt;/code&gt; condition is encountered. This allows the code to safely 'drill' into the object(s) one 'level' at a time, evaluating &lt;code&gt;myFoo.Bar&lt;/code&gt; only after (and if) &lt;code&gt;myFoo&lt;/code&gt; is determined to be valid. Object chains or paths can get quite long when coding complex objects:</source>
          <target state="translated">&lt;code&gt;AndAlso&lt;/code&gt; 重要です。 最初の &lt;code&gt;False&lt;/code&gt; 条件が発生すると、その後のテストは実行されません。 これにより、コードは一度に1レベルずつオブジェクトに安全に「ドリル」でき、 &lt;code&gt;myFoo&lt;/code&gt; が有効であると判断された後にのみ &lt;code&gt;myFoo.Bar&lt;/code&gt; を評価します。 複雑なオブジェクトをコーディングすると、オブジェクトチェーンまたはパスが非常に長くなることがあります。</target>
        </trans-unit>
        <trans-unit id="aa6c4cd32e971c86b94f356d10264f19fc10c956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C#&lt;/code&gt; has an &quot;unsafe&quot; mode which is, as the name implies, extremely dangerous because the normal safety mechanisms which provide memory safety and type safety are not enforced. &lt;strong&gt;You should not be writing unsafe code unless you have a thorough and deep understanding of how memory works&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;C#&lt;/code&gt; には、「安全でない」モードがあります。これは、その名前が示すように、メモリの安全性と型の安全性を提供する通常の安全メカニズムが強制されないため、非常に危険です。 &lt;strong&gt;メモリがどのように機能するかを十分に理解していない限り、安全でないコードを書くべきではありません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bd3d214087af937aaa899e455d518fc953c1f01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C#&lt;/code&gt; supports &quot;iterator blocks&quot; (called &quot;generators&quot; in some other popular languages).  Null dereference exceptions can be particularly tricky to debug in iterator blocks because of deferred execution:</source>
          <target state="translated">&lt;code&gt;C#&lt;/code&gt; は「イテレーターブロック」（他の一部の一般的な言語では「ジェネレーター」と呼ばれます）をサポートしています。 実行の遅延のため、null逆参照例外は反復子ブロックでデバッグするのが特に難しい場合があります。</target>
        </trans-unit>
        <trans-unit id="b65a828172fbdbfca98814450da810920765da6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fill&lt;/code&gt; is a function returning the number of &lt;code&gt;Rows&lt;/code&gt; affected which can also be tested:</source>
          <target state="translated">&lt;code&gt;Fill&lt;/code&gt; は、影響を受ける &lt;code&gt;Rows&lt;/code&gt; の数を返す関数であり、これもテストできます。</target>
        </trans-unit>
        <trans-unit id="29fd8c9bf04ffae44443b4d6b120d8e689bf6af6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FirstOrDefault&lt;/code&gt; returns the first item or the default value, which is &lt;code&gt;Nothing&lt;/code&gt; for reference types and never &lt;code&gt;DBNull&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;FirstOrDefault&lt;/code&gt; は、最初の項目またはデフォルト値を返します。これは、参照型では &lt;code&gt;Nothing&lt;/code&gt; であり、 &lt;code&gt;DBNull&lt;/code&gt; にはなりません。</target>
        </trans-unit>
        <trans-unit id="dc1f250a72423388fb398e4efb0f2038c0f0e84a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; is implicitly cast to and from &lt;code&gt;T&lt;/code&gt; so you can use it just about anywhere you need it. For example, you can pass a &lt;code&gt;Person&lt;/code&gt; object to a method that takes a &lt;code&gt;NotNull&amp;lt;Person&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; はTとの間で暗黙的にキャストされるため、必要な場所であればどこでも使用できます。 たとえば、 &lt;code&gt;Person&lt;/code&gt; オブジェクトを &lt;code&gt;NotNull&amp;lt;Person&amp;gt;&lt;/code&gt; メソッドに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="65aa590b67401c4fef80a64a246bc794d6e41210" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WPF&lt;/code&gt; controls are created during the call to &lt;code&gt;InitializeComponent&lt;/code&gt; in the order they appear in the visual tree.  A &lt;code&gt;NullReferenceException&lt;/code&gt; will be raised in the case of early-created controls with event handlers, etc. , that fire during &lt;code&gt;InitializeComponent&lt;/code&gt; which reference late-created controls.</source>
          <target state="translated">&lt;code&gt;WPF&lt;/code&gt; コントロールは、ビジュアルツリーに表示される順序で &lt;code&gt;InitializeComponent&lt;/code&gt; の呼び出し中に作成されます。 初期化されたコントロールを参照するイベントハンドラーなどを備えた初期に作成されたコントロールの場合、 &lt;code&gt;NullReferenceException&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="250ae2f1196236ab82456278c60d302569df1d86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; throws when you try to iterate null collection. Usually caused by unexpected &lt;code&gt;null&lt;/code&gt; result from methods that return collections.</source>
          <target state="translated">nullコレクションを反復しようとすると &lt;code&gt;foreach&lt;/code&gt; がスローします。 通常、コレクションを返すメソッドからの予期しない &lt;code&gt;null&lt;/code&gt; 結果が原因です。</target>
        </trans-unit>
        <trans-unit id="e6b825efa75e489e263e621391b24d1af984c6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; can have different meanings:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; にはさまざまな意味があります。</target>
        </trans-unit>
        <trans-unit id="a96f0fc9fadca9ec24ec9a32f5951496d8252794" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;ldquo;Hey wait, that member has no values so it can&amp;rsquo;t perform the task which you are handing it over.&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;「ちょっと待ってください、そのメンバーには値がないので、あなたが引き渡そうとしているタスクを実行できません。」&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de7fbf64ea77b998421c892cac8cea0e19d55573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The arrays and collections cannot be initialized this way.&lt;/em&gt; This initialization code will run &lt;em&gt;before&lt;/em&gt; the constructor creates the &lt;code&gt;Form&lt;/code&gt; or the &lt;code&gt;Controls&lt;/code&gt;. As a result:</source>
          <target state="translated">&lt;em&gt;配列とコレクションは、この方法では初期化できません。&lt;/em&gt; この初期化コードは、コンストラクターが &lt;code&gt;Form&lt;/code&gt; または &lt;code&gt;Controls&lt;/code&gt; を作成する&lt;em&gt;前&lt;/em&gt;に実行されます。 結果として：</target>
        </trans-unit>
        <trans-unit id="c46586bc5c89bdef6d4b1e03c01b4dd0ec5d4806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Built-in like Nullable?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Nullableのような組み込みですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75800f606b4d1c6ba12f783ca4570bf7ff6448ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;引数を確認する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c09c6f450bd3f06e6cd9a53cf34fa6d2204595f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Combine with Extension&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;拡張機能と組み合わせる&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c53baf9a2776f02becbdc77ff91727f9331686" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9982a3d97a9090ed22f6a37e2cf0f2ae71f563db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7846c489294df2d5060a36081cb8e8043018b8e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="850a808c9ba0be28dfd19e88b1b1677f0e685ba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example: Array of class objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例：クラスオブジェクトの配列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0832c4cbf43ec158d395216191b77095c211750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Missing the &lt;code&gt;New&lt;/code&gt; operator is the #1 cause of &lt;code&gt;NullReference Exceptions&lt;/code&gt;&lt;/strong&gt; seen in the Stack&amp;nbsp; Overflow questions reviewed.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;New&lt;/code&gt; 演算子がないことは、&lt;/strong&gt;レビューされたスタックオーバーフローの質問で見られる&lt;strong&gt; &lt;code&gt;NullReference Exceptions&lt;/code&gt; の最大の原因です&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="65dcf051b0f8d4d6b70a92dd10d98dbbb05e7cdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d3ff5e8673cda37c5affb24969d0778d496d93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that accessing it via &lt;code&gt;a.Value&lt;/code&gt; throws an &lt;code&gt;InvalidOperationException&lt;/code&gt; instead of a &lt;code&gt;NullReferenceException&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; - you should do the check beforehand, i.e. if you have another on-nullable variable &lt;code&gt;int b;&lt;/code&gt; then you should do assignments like &lt;code&gt;if (a.HasValue) { b = a.Value; }&lt;/code&gt; or shorter &lt;code&gt;if (a != null) { b = a; }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; の場合、 &lt;code&gt;a.Value&lt;/code&gt; を介してアクセスすると &lt;code&gt;NullReferenceException&lt;/code&gt; ではなく &lt;code&gt;InvalidOperationException&lt;/code&gt; がスローされることに注意してください。事前に確認する必要があります。つまり、null可能な別の変数 &lt;code&gt;int b;&lt;/code&gt; 次に、 &lt;code&gt;if (a.HasValue) { b = a.Value; }&lt;/code&gt; ような割り当てを行う必要があります。 }以下の &lt;code&gt;if (a != null) { b = a; }&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="9d2ecfee61125d9d0e8d312294babd37f799e11c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; this applies to any and all control and component references making these illegal where they are:</source>
          <target state="translated">これは、すべてのコントロールおよびコンポーネントの参照に適用され、これらが以下の場所で違法になることに&lt;strong&gt;注意してください&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa53a7cd617380a4fd41905587ebe1ed03bfd709" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Partial Remedy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;部分的な救済&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b45cb9af41d027f3c66db6de15f935162538c51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plain Code Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プレーンコードソリューション&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c266b17f2c6ab7e2c85ed00ba5d7beabc25b959e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reason&lt;/strong&gt;
I am still not sure about the reason. But whenever any of the entity class will extend System.Web.UI.Page this error occurs.</source>
          <target state="translated">&lt;strong&gt;理由&lt;/strong&gt;私はまだ&lt;strong&gt;理由がわかり&lt;/strong&gt;ません。 しかし、エンティティクラスのいずれかがSystem.Web.UI.Pageを拡張するたびに、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="a268ab5a5be194c793236306a7663da71dfa4d72" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference types (these ones must be checked):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;参照タイプ（これらはチェックする必要があります）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87d7c3eb34164ea52ebb8bc8dd28ee4033a68905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Related Language Feature&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;関連言語機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f132283beed6a6da06cca0d2093c020e2034387" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remedy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Remedy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00798c0e0efa455834c71c3500c45ed823e69637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR:&lt;/strong&gt; Try using &lt;code&gt;Html.Partial&lt;/code&gt; instead of &lt;code&gt;Renderpage&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;TL; DR：&lt;/strong&gt; &lt;code&gt;Html.Partial&lt;/code&gt; 代わりに &lt;code&gt;Renderpage&lt;/code&gt; を使用してみてください</target>
        </trans-unit>
        <trans-unit id="fb06fe911bd525f50ffb0ed996518a64e1313f34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is basically is a Null reference exception&lt;/strong&gt;. As &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;Microsoft&lt;/a&gt; states-</source>
          <target state="translated">&lt;strong&gt;これは基本的にnull参照の例外&lt;/strong&gt;です。 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;マイクロソフトが&lt;/a&gt;述べているように-</target>
        </trans-unit>
        <trans-unit id="1aa4d335741197b3563f86a40f2c97a83f320da3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; It is worth mentioning that the term was coined by Bertrand Meyer &lt;a href=&quot;https://www.eiffel.com/values/design-by-contract/&quot;&gt;in connection with his design of the Eiffel programming language&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;この用語が&lt;a href=&quot;https://www.eiffel.com/values/design-by-contract/&quot;&gt;彼のエッフェルプログラミング言語の設計に関連して&lt;/a&gt;バートランドマイヤーによって造られたことに言及する価値があります 。</target>
        </trans-unit>
        <trans-unit id="0181926e0a4573b951577d60df9ca7c39553610c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update C#8.0, 2019: Nullable reference types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C＃8.0、2019を更新：null可能な参照型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72b28d75192ac7fb08e2f8d3a79cec1a52ea9e34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Tools&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ツールを使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c87f2201b452dcaacc0b8af07815a06349212165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value types (you can simply ignore these ones):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;値のタイプ（これらは単純に無視できます）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6d4f708a4dc9fe6716ce23566f161236c78feea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What can you do about it?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;あなたはそれについて何ができますか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8caed790388a2aa0b4f38d928f3144b76a25e1b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;  If Break on Throws is too aggressive and the debugger stops on an NPE in the .NET or 3rd-party library, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/038tzxdw.aspx&quot;&gt;Break on User-Unhandled&lt;/a&gt; can be used to limit the exceptions caught. Additionally, VS2012 introduces &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn457346.aspx&quot;&gt;Just My Code&lt;/a&gt; which I recommend enabling as well.</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; Break on Throwsが非常に強力で、.NETまたはサードパーティライブラリのNPEでデバッガーが停止した場合、 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/038tzxdw.aspx&quot;&gt;Break on User-Unhandled&lt;/a&gt;を使用して、キャッチされる例外を制限できます。 さらに、VS2012は&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn457346.aspx&quot;&gt;Just My Code&lt;/a&gt;を導入しています。これも有効にすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="cf4e02ba110e4be0ec3bfb627b852463f12d2845" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MsgBox&lt;/code&gt; in the Catch which displays &lt;code&gt;Error while...&lt;/code&gt; will be of little help. This method also leads to &lt;em&gt;very bad&lt;/em&gt; Stack&amp;nbsp; Overflow questions, because you can't describe the actual exception, the object involved or even the line of code where it happens.</source>
          <target state="translated">キャッチ中に &lt;code&gt;Error while...&lt;/code&gt; を表示する &lt;code&gt;MsgBox&lt;/code&gt; はほとんど役に立ちません。 この方法は、実際の例外、関係するオブジェクト、またはそれが発生するコード行さえ記述できないため、 &lt;em&gt;非常に悪い&lt;/em&gt;スタックオーバーフローの質問&lt;em&gt;に&lt;/em&gt;もつながります。</target>
        </trans-unit>
        <trans-unit id="ba104c53b06fc122661823449802aea76782c8e0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NullReferenceException&lt;/code&gt; is thrown when we are trying to access Properties of a null object or when a string value becomes empty and we are trying to access string methods.</source>
          <target state="translated">&lt;code&gt;NullReferenceException&lt;/code&gt; は、nullオブジェクトのプロパティにアクセスしようとした場合、または文字列値が空になって文字列メソッドにアクセスしようとした場合にスローされます。</target>
        </trans-unit>
        <trans-unit id="aa5b3e9455e644e78a417418f58466e0a5a103cd" translate="yes" xml:space="preserve">
          <source>A NullReferenceException exception is thrown when you try to access a
  member of a type whose value is null.</source>
          <target state="translated">値が NULL の型のメンバにアクセスしようとすると、NullReferenceException 例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="f8ff26f3ebffad79c215bd07bdac08f78eb5f7da" translate="yes" xml:space="preserve">
          <source>A badly implemented Try/Catch can hide where the problem is and result in new ones:</source>
          <target state="translated">下手に実装されたTryCatchは、問題がどこにあるのかを隠してしまい、新たな問題が発生してしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="6d4ec18cde40fd73c38c9b684b0330cd485bb285" translate="yes" xml:space="preserve">
          <source>A common oversight is a class which uses a collection &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">一般的な見落としは、コレクション &lt;code&gt;Type&lt;/code&gt; を使用するクラスです。</target>
        </trans-unit>
        <trans-unit id="d9cf0a18f606a29539af3e0ce3af33a36d691ebb" translate="yes" xml:space="preserve">
          <source>A more &quot;formal&quot; way of preventing such error conditions &lt;em&gt;while developing&lt;/em&gt; is applying &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;design by contract&lt;/a&gt;&lt;/em&gt; in your code. This means you need to set class &lt;em&gt;invariants&lt;/em&gt;, and/or even function/method &lt;em&gt;preconditions&lt;/em&gt; and &lt;em&gt;postconditions&lt;/em&gt; on your system, while developing.</source>
          <target state="translated">&lt;em&gt;開発中に&lt;/em&gt;そのようなエラー状態&lt;em&gt;を&lt;/em&gt;防ぐより「正式な」方法は、コードで&lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;契約&lt;/a&gt;&lt;/em&gt;により&lt;em&gt;設計を&lt;/em&gt;適用することです。 つまり、開発中に、システムにクラス&lt;em&gt;不変式&lt;/em&gt;を設定したり、関数/メソッドの&lt;em&gt;事前条件&lt;/em&gt;や&lt;em&gt;事後条件&lt;/em&gt;を設定したりする必要があります。</target>
        </trans-unit>
        <trans-unit id="eebbb33808aa207e49bada59a5125167df24f614" translate="yes" xml:space="preserve">
          <source>A note on null dereferences in unsafe code</source>
          <target state="translated">安全ではないコードにおけるヌル参照の派生に関する注意事項</target>
        </trans-unit>
        <trans-unit id="8dafbafccce845b67afeb7b01438fe1945ef8d44" translate="yes" xml:space="preserve">
          <source>A nullable reference type is noted using the same syntax as nullable value types: a &lt;code&gt;?&lt;/code&gt; is appended to the type of the variable.</source>
          <target state="translated">null可能な参照型は、null可能な値型と同じ構文を使用して示されます &lt;code&gt;?&lt;/code&gt; 変数の型に追加されます。</target>
        </trans-unit>
        <trans-unit id="6c02c614bce01e1bf2b2913bce9723ce07012a79" translate="yes" xml:space="preserve">
          <source>A typo is a problem here: &lt;code&gt;Employees&lt;/code&gt; vs &lt;code&gt;Employee&lt;/code&gt;. There was no &lt;code&gt;DataTable&lt;/code&gt; named &quot;Employee&quot; created, so a &lt;code&gt;NullReferenceException&lt;/code&gt; results trying to access it. Another potential problem is assuming there will be &lt;code&gt;Items&lt;/code&gt; which may not be so when the SQL includes a WHERE clause.</source>
          <target state="translated">ここでのタイプミスは問題です： &lt;code&gt;Employees&lt;/code&gt; vs &lt;code&gt;Employee&lt;/code&gt; 。 「Employee」という名前の &lt;code&gt;DataTable&lt;/code&gt; は作成されなかったため、 &lt;code&gt;NullReferenceException&lt;/code&gt; がアクセスしようとしました。 もう1つの潜在的な問題は、SQLにWHERE句が含まれている場合にそうでない可能性がある &lt;code&gt;Items&lt;/code&gt; があると想定することです。</target>
        </trans-unit>
        <trans-unit id="f6a5c83300e66ad46127b977adb89a522156c686" translate="yes" xml:space="preserve">
          <source>ASP.NET MVC empty view models</source>
          <target state="translated">ASP.NET MVC 空のビューモデル</target>
        </trans-unit>
        <trans-unit id="80c38c96a03773866e5a09fd7dd429a0be9d8b8b" translate="yes" xml:space="preserve">
          <source>ASP.NET Page Life cycle:</source>
          <target state="translated">ASP.NETページのライフサイクル。</target>
        </trans-unit>
        <trans-unit id="3f5c6dc0c3d2cadb4509844c76624cbfb304e229" translate="yes" xml:space="preserve">
          <source>ASP.NET Session Values</source>
          <target state="translated">ASP.NET セッション値</target>
        </trans-unit>
        <trans-unit id="940be3748f3da7281fcd8700b0e3178729d37f82" translate="yes" xml:space="preserve">
          <source>Access Levels in Visual Basic</source>
          <target state="translated">Visual Basicのアクセスレベル</target>
        </trans-unit>
        <trans-unit id="b85c4bdae0c350f5711f14487cc734ddd712d0bb" translate="yes" xml:space="preserve">
          <source>Add a RigidBody to your object with AddComponent &amp;gt; Physics &amp;gt; Rigidbody</source>
          <target state="translated">AddComponent&amp;gt; Physics&amp;gt; RigidbodyでRigidBodyをオブジェクトに追加します</target>
        </trans-unit>
        <trans-unit id="3c06a5e5b3bffeb1ffe32764c5df1d75e8641b16" translate="yes" xml:space="preserve">
          <source>Adding a case when the class name for entity used in entity framework is same as class name for a web form code-behind file.</source>
          <target state="translated">エンティティフレームワークで使用するエンティティのクラス名が、Webフォームのコードバックファイルのクラス名と同じ場合の追加</target>
        </trans-unit>
        <trans-unit id="64da57dde1ffb2a7b141dfc69a64073197586ac7" translate="yes" xml:space="preserve">
          <source>Alternatively, design by contract can be applied using &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Assertion_%28software_development%29&quot;&gt;assertions&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">または、契約による設計は&lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Assertion_%28software_development%29&quot;&gt;アサーション&lt;/a&gt;&lt;/em&gt;を使用して適用できます。</target>
        </trans-unit>
        <trans-unit id="b7effb34e016a409606b0e15fd08ec8c4497e3b4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;(ComboBox5.SelectedItem IsNot Nothing) AndAlso...&lt;/code&gt;</source>
          <target state="translated">または、 &lt;code&gt;(ComboBox5.SelectedItem IsNot Nothing) AndAlso...&lt;/code&gt; 使用することもできます。</target>
        </trans-unit>
        <trans-unit id="5666d3ec19bdd1846f3f244409d303ff8154592b" translate="yes" xml:space="preserve">
          <source>Although I have a feeling it was because Visual Studio was misreading the ampersands and brackets.</source>
          <target state="translated">Visual Studio がアンパサンドと括弧を読み違えていたからだと思いますが。</target>
        </trans-unit>
        <trans-unit id="9fd253c7dc5c61cba35ce66730957de70d270eee" translate="yes" xml:space="preserve">
          <source>Always initialize your objects before you try to do anything with them.</source>
          <target state="translated">オブジェクトで何かをしようとする前に、必ずオブジェクトを初期化してください。</target>
        </trans-unit>
        <trans-unit id="3b6e8a6740e24bceb43df548fef899179aae1d8a" translate="yes" xml:space="preserve">
          <source>Among other things, this code does not anticipate that the user may not have selected something in one or more UI controls.  &lt;code&gt;ListBox1.SelectedItem&lt;/code&gt; may well be &lt;code&gt;Nothing&lt;/code&gt;, so &lt;code&gt;ListBox1.SelectedItem.ToString&lt;/code&gt; will result in an NRE.</source>
          <target state="translated">特に、このコードは、ユーザーが1つ以上のUIコントロールで何かを選択していない可能性があることを予期していません。 &lt;code&gt;ListBox1.SelectedItem&lt;/code&gt; は &lt;code&gt;Nothing&lt;/code&gt; である可能性があるため、 &lt;code&gt;ListBox1.SelectedItem.ToString&lt;/code&gt; はNREになります。</target>
        </trans-unit>
        <trans-unit id="88a4f159e8121bbcda704144caf67fd92f8461ea" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;Catch&lt;/code&gt; block is the devil's playground. This OP was baffled why he was getting an NRE in the &lt;code&gt;Finally&lt;/code&gt; block. In other situations, an empty &lt;code&gt;Catch&lt;/code&gt; may result in something else much further downstream going haywire and cause you to spend time looking at the wrong things in the wrong place for the problem. (The &quot;silent exception&quot; described above provides the same entertainment value.)</source>
          <target state="translated">空の &lt;code&gt;Catch&lt;/code&gt; ブロックは、悪魔の遊び場です。 このOPは、 &lt;code&gt;Finally&lt;/code&gt; ブロックでNREを取得する理由に困惑しました。 他の状況では、 &lt;code&gt;Catch&lt;/code&gt; が空になると、さらに下流で問題が発生し、問題の場所と場所を間違えるのに時間がかかる場合があります。 （上記の「サイレント例外」は、同じエンターテイメントの価値を提供します。）</target>
        </trans-unit>
        <trans-unit id="9157a41acb7ec9a4b1beccee4b4d84c91c8fa2d2" translate="yes" xml:space="preserve">
          <source>An example of this exception being thrown is: When you are trying to check something, that is null.</source>
          <target state="translated">この例外がスローされる例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a1ec28efc8675e603132b97526fc40e135d46f85" translate="yes" xml:space="preserve">
          <source>And here is an example of how it could be used:</source>
          <target state="translated">そして、その使い方の一例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="e727d2eac2d0a071ac7dcfe039aef6ace695286e" translate="yes" xml:space="preserve">
          <source>And it worked.</source>
          <target state="translated">そして、それが功を奏した。</target>
        </trans-unit>
        <trans-unit id="324e44de5ebb6296d39aa1bfc28925673b0c6b21" translate="yes" xml:space="preserve">
          <source>Another case where &lt;code&gt;NullReferenceExceptions&lt;/code&gt; can happen is the (incorrect) use of the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/as&quot;&gt;&lt;code&gt;as&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;NullReferenceExceptions&lt;/code&gt; が発生する可能性があるもう1つのケースは、 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/as&quot;&gt; &lt;code&gt;as&lt;/code&gt; 演算子の&lt;/a&gt; （正しくない）使用です。</target>
        </trans-unit>
        <trans-unit id="faf985078920eb0c5453270c90bdc97bdefa6713" translate="yes" xml:space="preserve">
          <source>Another general case where one might receive this exception involves mocking classes during unit testing. Regardless of the mocking framework being used, you must ensure that all appropriate levels of the class hierarchy are properly mocked. In particular, all properties of &lt;code&gt;HttpContext&lt;/code&gt; which are referenced by the code under test must be mocked.</source>
          <target state="translated">この例外が発生する可能性があるもう1つの一般的なケースは、ユニットテスト中にクラスをモックすることです。 使用されているモックフレームワークに関係なく、クラス階層のすべての適切なレベルが適切にモックされていることを確認する必要があります。 特に、テスト中のコードによって参照される &lt;code&gt;HttpContext&lt;/code&gt; のすべてのプロパティは、モックする必要があります。</target>
        </trans-unit>
        <trans-unit id="defecdb8e8875605297d57b7667ccb8e2cd0b5be" translate="yes" xml:space="preserve">
          <source>Another scenario is when you cast a null object into a &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;value type&lt;/a&gt;. For example, the code below:</source>
          <target state="translated">別のシナリオは、nullオブジェクトを&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;値型に&lt;/a&gt;キャストする場合です。 たとえば、次のコード：</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="66865b7becb2eab1937b4ac3fd0252b0e3a5b1a9" translate="yes" xml:space="preserve">
          <source>Array Elements</source>
          <target state="translated">配列要素</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="b6fa4a287953008cbde69102b90389d57d42adc5" translate="yes" xml:space="preserve">
          <source>Arrays in Visual Basic</source>
          <target state="translated">Visual Basicでの配列</target>
        </trans-unit>
        <trans-unit id="d1699665973226819efc1a3192672777466c31f6" translate="yes" xml:space="preserve">
          <source>Arrays must also be instantiated:</source>
          <target state="translated">配列もインスタンス化する必要があります。</target>
        </trans-unit>
        <trans-unit id="38bc53bbadc56c1c1c3af2a66bca49127ec6ded9" translate="yes" xml:space="preserve">
          <source>As before, the &lt;code&gt;ds&lt;/code&gt; Dataset object was declared, but an instance was never created. The &lt;code&gt;DataAdapter&lt;/code&gt; will fill an existing &lt;code&gt;DataSet&lt;/code&gt;, not create one. In this case, since &lt;code&gt;ds&lt;/code&gt; is a local variable, &lt;em&gt;the IDE warns you&lt;/em&gt; that this might happen:</source>
          <target state="translated">以前と同様に、 &lt;code&gt;ds&lt;/code&gt; Datasetオブジェクトが宣言されましたが、インスタンスは作成されませんでした。 &lt;code&gt;DataAdapter&lt;/code&gt; は、既存の &lt;code&gt;DataSet&lt;/code&gt; を作成しますが、作成しません。 この場合、 &lt;code&gt;ds&lt;/code&gt; はローカル変数である&lt;em&gt;ため、IDE&lt;/em&gt;はこれが発生する可能性がある&lt;em&gt;こと&lt;/em&gt;を&lt;em&gt;警告します&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8225bf15fe959f426e87bc59fb66f54584b8477" translate="yes" xml:space="preserve">
          <source>As before, this is incorrect:</source>
          <target state="translated">今まで通り、これは正しくありません。</target>
        </trans-unit>
        <trans-unit id="34d0293b6d44a69f8098139a2697ae8c8c463b8c" translate="yes" xml:space="preserve">
          <source>As before, you can test for Nothing, then for a specific value:</source>
          <target state="translated">前と同じように、Nothing をテストし、次に特定の値をテストすることができます。</target>
        </trans-unit>
        <trans-unit id="8c8719c108394130c727bec7ba9f10b86c8bcb74" translate="yes" xml:space="preserve">
          <source>As seen in the above code, the statement 
&lt;strong&gt;Student s&lt;/strong&gt; - only declares the variable of type Student, note that the Student class is not instantiated at this point.
Hence, when the statement &lt;strong&gt;s.GetFullName()&lt;/strong&gt; gets executed, it will throw the NullReferenceException.</source>
          <target state="translated">上記のコードに見られるように、ステートメント&lt;strong&gt;Student s&lt;/strong&gt; - &lt;strong&gt;Student&lt;/strong&gt;型の変数のみを宣言します。この時点ではStudentクラスはインスタンス化されていないことに注意してください。 したがって、ステートメント&lt;strong&gt;s.GetFullName（）&lt;/strong&gt;が実行されると、NullReferenceExceptionがスローされます。</target>
        </trans-unit>
        <trans-unit id="0238c2f1a73f80203ea54ce74e1fa5c52ec85a2b" translate="yes" xml:space="preserve">
          <source>As you can see above as with nullable you would access the underlying value through the &lt;code&gt;Value&lt;/code&gt; property. Alternatively, you can use an explicit or implicit cast, you can see an example with the return value below:</source>
          <target state="translated">上記のようにnullableと同様に、 &lt;code&gt;Value&lt;/code&gt; プロパティを介して基になる値にアクセスします。 または、明示的または暗黙的なキャストを使用できます。以下の戻り値の例を見ることができます。</target>
        </trans-unit>
        <trans-unit id="55898edce8a3dc771bf65a61dd6c66bcff4e10b3" translate="yes" xml:space="preserve">
          <source>Assume that you have a class named Student.</source>
          <target state="translated">Studentという名前のクラスがあるとします。</target>
        </trans-unit>
        <trans-unit id="be34f295e410696ad2a87bdbe307bddd6ac8d2e7" translate="yes" xml:space="preserve">
          <source>Basic Meaning</source>
          <target state="translated">基本的な意味</target>
        </trans-unit>
        <trans-unit id="f2896aad58b9a8eecc0ba25ee5c59866bcde93ab" translate="yes" xml:space="preserve">
          <source>Be aware that regardless of the scenario, the cause is always the same in .NET:</source>
          <target state="translated">.NETではシナリオに関係なく、原因は常に同じであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4b8773ed0bc20f439c181fd5242b7f12bd9a63f5" translate="yes" xml:space="preserve">
          <source>Both a null pointer and a null reference in &lt;code&gt;C#&lt;/code&gt; are internally represented as the number zero, and so any attempt to dereference it into its corresponding memory storage causes the operating system to produce an error. The .NET runtime then detects this error and turns it into the null dereference exception.</source>
          <target state="translated">&lt;code&gt;C#&lt;/code&gt; の nullポインターとnull参照はどちらも内部的には数値0として表されるため、対応するメモリストレージに逆参照しようとすると、オペレーティングシステムでエラーが発生します。 次に.NETランタイムはこのエラーを検出し、それをnull逆参照例外に変換します。</target>
        </trans-unit>
        <trans-unit id="80ab619b17d9355ace0bbedb905733aed5398463" translate="yes" xml:space="preserve">
          <source>Bottom Line</source>
          <target state="translated">ボトムライン</target>
        </trans-unit>
        <trans-unit id="21a8752f2df54d656b09cd2a499cb3a3403ec7ca" translate="yes" xml:space="preserve">
          <source>Breakpoints</source>
          <target state="translated">Breakpoints</target>
        </trans-unit>
        <trans-unit id="86d14f9a7de18ff1120d5c17aa3bb8490cf58228" translate="yes" xml:space="preserve">
          <source>But I was able to run the application with no problems with this &quot;error&quot;. I was able to get rid of the error by changing the structure of the &lt;code&gt;foreach&lt;/code&gt; loop to look like this:</source>
          <target state="translated">しかし、私はこの「エラー」で問題なくアプリケーションを実行することができました。 &lt;code&gt;foreach&lt;/code&gt; ループの構造を次のように変更することで、エラーを取り除くことができました。</target>
        </trans-unit>
        <trans-unit id="342f568362575e92cb6067d8461a39a6a40941c4" translate="yes" xml:space="preserve">
          <source>But if you set &quot;property X must never have a null value&quot; as method precondition, then you can prevent the scenario described before:</source>
          <target state="translated">しかし、メソッドの前提条件として「プロパティXは絶対にNULL値を持ってはいけない」と設定しておけば、先ほどのようなシナリオを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="8e174293e71614f4dcd5e8efa21b20f2c2ea09dd" translate="yes" xml:space="preserve">
          <source>By doing that and making PostSharp part of your build process &lt;code&gt;obj&lt;/code&gt; will be checked for null at runtime. See: &lt;a href=&quot;http://www.postsharp.net/blog/post/Validating-parameters-field-and-properties-in-PostSharp-3&quot;&gt;PostSharp null check&lt;/a&gt;</source>
          <target state="translated">これを行い、PostSharpをビルドプロセスの一部にすることにより、 &lt;code&gt;obj&lt;/code&gt; は実行時にnullかどうかがチェックされます。 参照： &lt;a href=&quot;http://www.postsharp.net/blog/post/Validating-parameters-field-and-properties-in-PostSharp-3&quot;&gt;PostSharp nullチェック&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64c2e10dbbbf9ef720a7c8d02d4aa8e8cf77773e" translate="yes" xml:space="preserve">
          <source>By finding by name I mean some framework allow you to FIndObjects using strings and the code might look like this: &lt;strong&gt;FindObject(&quot;ObjectName&quot;);&lt;/strong&gt;</source>
          <target state="translated">名前で検索するということは、一部のフレームワークでは文字列を使用してFIndObjectsを実行できることを意味し、コードは次のようになります&lt;strong&gt;。FindObject（ &quot;ObjectName&quot;）;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d2fbdf206c06f82b8ff7b2a9385b7bc273f6c" translate="yes" xml:space="preserve">
          <source>By following the program flow this way, you can find the location where the instance should not be null, and why it isn't properly set.</source>
          <target state="translated">このようにプログラムの流れを追うことで、インスタンスがNULLになってはいけない場所や、なぜ適切に設定されていないのかを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="0af3e909e29bebca060f842d0113445956bb71a3" translate="yes" xml:space="preserve">
          <source>By writing a null check like this you prevent the null dereference, but you move the null argument exception to the point of the &lt;em&gt;iteration&lt;/em&gt;, not to the point of the &lt;em&gt;call&lt;/em&gt;, and that is &lt;em&gt;very confusing to debug&lt;/em&gt;.</source>
          <target state="translated">このようにnullチェックを記述することにより、null逆参照を防ぐことができますが、null引数の例外を&lt;em&gt;呼び出し&lt;/em&gt;のポイントではなく&lt;em&gt;反復&lt;/em&gt;のポイントに移動するため、 &lt;em&gt;デバッグ&lt;/em&gt;が&lt;em&gt;非常に混乱し&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="910e894dcb9055a378eccef35ef795771f7bb251" translate="yes" xml:space="preserve">
          <source>C# 6.0 introduced the &quot;null-conditional operator&quot; that helps with this a little. With this feature, you can reference nested objects and if any one of them is &lt;code&gt;null&lt;/code&gt; the whole expression returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">C＃6.0では、これに少し役立つ「null条件演算子」が導入されました。 この機能を使用すると、ネストされたオブジェクトを参照でき、それらのいずれかが &lt;code&gt;null&lt;/code&gt; の場合 、式全体が &lt;code&gt;null&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="06971ac0fe2094d0b96705ec2de4ff7f4c00141d" translate="yes" xml:space="preserve">
          <source>C# has a nice shorthand for &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, you can make something nullable by putting a question mark after the type like so &lt;code&gt;int?&lt;/code&gt;.</source>
          <target state="translated">C＃には &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; 省略形があり &lt;code&gt;int?&lt;/code&gt; 型の後ろに疑問符を置くことで、何かをnull可能にできますか？ 。</target>
        </trans-unit>
        <trans-unit id="3d4cb34a5ed28713ba6e8d1854e778ef083e674d" translate="yes" xml:space="preserve">
          <source>C#8.0 introduces &lt;strong&gt;nullable reference types&lt;/strong&gt; and &lt;strong&gt;non-nullable reference types&lt;/strong&gt;. So only nullable reference types must be checked to avoid a &lt;strong&gt;NullReferenceException&lt;/strong&gt;.</source>
          <target state="translated">C＃8.0では、 &lt;strong&gt;null許容の参照型&lt;/strong&gt;と&lt;strong&gt;null不可の&lt;/strong&gt; &lt;strong&gt;参照型が&lt;/strong&gt;導入されてい&lt;strong&gt;ます&lt;/strong&gt; 。 したがって、 &lt;strong&gt;NullReferenceException&lt;/strong&gt;を回避するには、null許容の参照型のみをチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="8dc39f8dd9c9e597efd5512af193d73bcc466778" translate="yes" xml:space="preserve">
          <source>Cast with &lt;code&gt;as&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; でキャスト</target>
        </trans-unit>
        <trans-unit id="da4e05c5dc0d067c4057445c2673b31a895c9b01" translate="yes" xml:space="preserve">
          <source>Changing the order of the declarations in the &lt;code&gt;XAML&lt;/code&gt; (i.e., listing &lt;code&gt;label1&lt;/code&gt; before &lt;code&gt;comboBox1&lt;/code&gt;, ignoring issues of design philosophy, would at least resolve the &lt;code&gt;NullReferenceException&lt;/code&gt; here.</source>
          <target state="translated">&lt;code&gt;XAML&lt;/code&gt; で宣言の順序を変更すると（つまり、デザインフィロソフィーの問題を無視して、 &lt;code&gt;label1&lt;/code&gt; 前にlabel1をリストすると）、少なくともここでは &lt;code&gt;NullReferenceException&lt;/code&gt; が解決されます。</target>
        </trans-unit>
        <trans-unit id="f13d71f0e899fe3b305b742c14c426e502ee6355" translate="yes" xml:space="preserve">
          <source>Class Objects / Creating an Instance</source>
          <target state="translated">クラス オブジェクト インスタンスの作成</target>
        </trans-unit>
        <trans-unit id="a6748432889326a79c007d1ba17c6c7cd3373670" translate="yes" xml:space="preserve">
          <source>Collection/List/Dictionary</source>
          <target state="translated">Collection/List/Dictionary</target>
        </trans-unit>
        <trans-unit id="ac972fde3be5ca3a4dcab0cc67b75680615eb722" translate="yes" xml:space="preserve">
          <source>Combine &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; with an extension method and you can cover even more situations. Here is an example of what the extension method can look like:</source>
          <target state="translated">&lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; を拡張メソッドと組み合わせると、さらに多くの状況をカバーできます。 以下は、拡張メソッドの例です。</target>
        </trans-unit>
        <trans-unit id="223c2967787ab7e442128765b6827c843685a817" translate="yes" xml:space="preserve">
          <source>Compiler for the above code raises an error that variable &lt;strong&gt;obj&lt;/strong&gt; is unassigned which signifies that our variable has null values or nothing. Compiler for the above code raises an error that variable &lt;strong&gt;obj&lt;/strong&gt; is unassigned which signifies that our variable has null values or nothing.</source>
          <target state="translated">上記のコードのコンパイラーは、変数&lt;strong&gt;obj&lt;/strong&gt;が割り当てられていないというエラーを発生させます。これは、変数にnull値があるか何もないことを示します。 上記のコードのコンパイラーは、変数&lt;strong&gt;obj&lt;/strong&gt;が割り当てられていないというエラーを発生させます。これは、変数にnull値があるか何もないことを示します。</target>
        </trans-unit>
        <trans-unit id="bee75ca77f753e4846b455441733f6641c4bf287" translate="yes" xml:space="preserve">
          <source>Controls</source>
          <target state="translated">Controls</target>
        </trans-unit>
        <trans-unit id="1ca5b6d459cb7e4e8503007684404f6a2c26c9c9" translate="yes" xml:space="preserve">
          <source>DBNull is not the same as Nothing</source>
          <target state="translated">DBNullはNothingと同じではない</target>
        </trans-unit>
        <trans-unit id="428b235126d11ccf77cf5d994238ed0919097855" translate="yes" xml:space="preserve">
          <source>Data Provider Objects</source>
          <target state="translated">データプロバイダオブジェクト</target>
        </trans-unit>
        <trans-unit id="5568339e9f5e145b4c2866450e19d8cc65b1f7d3" translate="yes" xml:space="preserve">
          <source>Debug and let the debugger break... It will directly take you to the variable that is broken... Now your task is to simply fix this.. Using the &lt;strong&gt;new&lt;/strong&gt; keyword in the appropriate place.</source>
          <target state="translated">デバッグしてデバッガーを中断させます...中断された変数に直接移動します...ここでの作業は、これを単に修正することです。適切な場所で&lt;strong&gt;新しい&lt;/strong&gt;キーワードを使用します。</target>
        </trans-unit>
        <trans-unit id="6f0b5050efbdbd9b4e9f63b62af3e9fede37125c" translate="yes" xml:space="preserve">
          <source>Debugger: For developers, we have the big weapon of Debugging with us. If have we face NullReferenceException during the development face we can use the debugger to get to the source of the exception.</source>
          <target state="translated">デバッガーです。開発者にとって、私たちはデバッグという大きな武器を持っています。開発中に NullReferenceException に直面した場合、デバッガを使って例外の発生源を突き止めることができます。</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="36fd56a44db41a6f009807b50cd27bc9943148b1" translate="yes" xml:space="preserve">
          <source>Debugging showed the model was Null inside MyOtherView. Until I changed it to:</source>
          <target state="translated">デバッグするとMyOtherViewの中でモデルがNullになっていました。それを変更するまでは</target>
        </trans-unit>
        <trans-unit id="f2bef4698e9e93b03fbe4d5bae9a889cb96e1075" translate="yes" xml:space="preserve">
          <source>Don't ignore compiler warnings (ever) and use &lt;code&gt;Option Strict On&lt;/code&gt; (always).</source>
          <target state="translated">コンパイラの警告を無視しないで（常に）、 &lt;code&gt;Option Strict On&lt;/code&gt; を常に使用します。</target>
        </trans-unit>
        <trans-unit id="a116c71d483a8e062649940a075d035fe0d15e1c" translate="yes" xml:space="preserve">
          <source>Don't use empty Try/Catch blocks - let the code crash so you can a) identify the cause b) identify the location and c) apply a proper remedy.  Try/Catch blocks are not intended to hide exceptions from the person uniquely qualified to fix them - the developer.</source>
          <target state="translated">空の TryCatch ブロックを使用しないでください-コードをクラッシュさせて、a)原因を特定し、b)場所を特定し、c)適切な救済策を適用することができます。TryCatch ブロックは、例外を修正する資格のある開発者から例外を隠すことを目的としたものではありません。</target>
        </trans-unit>
        <trans-unit id="d7f04facb7d4fb7422ce98a991d56e72f4d24f7c" translate="yes" xml:space="preserve">
          <source>Edge case #1: concurrent access to a Dictionary</source>
          <target state="translated">エッジケース #1:ディクショナリへの同時アクセス</target>
        </trans-unit>
        <trans-unit id="e3ea50cc0b7f4be81be2362bf41478f7130a1285" translate="yes" xml:space="preserve">
          <source>Edge case #2: unsafe code</source>
          <target state="translated">エッジケース2:安全でないコード</target>
        </trans-unit>
        <trans-unit id="6a6853d6e749e4d5b00c4b8d872d66e337db122a" translate="yes" xml:space="preserve">
          <source>Either procedure will result in an NRE, because &lt;code&gt;barList&lt;/code&gt; is only declared, not instantiated. Creating an instance of &lt;code&gt;Foo&lt;/code&gt; will not also create an instance of the internal &lt;code&gt;barList&lt;/code&gt;. It may have been the intent to do this in the constructor:</source>
          <target state="translated">&lt;code&gt;barList&lt;/code&gt; はインスタンス化されずに宣言されるだけなので、どちらの手順でもNREになります。 &lt;code&gt;Foo&lt;/code&gt; のインスタンスを作成しても、内部の &lt;code&gt;barList&lt;/code&gt; のインスタンスは作成されません。 コンストラクタでこれを行う意図があったかもしれません：</target>
        </trans-unit>
        <trans-unit id="46f567c4dcc5486e4285b45b12d7a9a6e106f7ff" translate="yes" xml:space="preserve">
          <source>Enjoy and have fun making games!</source>
          <target state="translated">楽しく、楽しくゲームを作っていきましょう</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="2ede17026a66f2bb53f3b6978daa3529c4d3bc25" translate="yes" xml:space="preserve">
          <source>Ex:</source>
          <target state="translated">Ex:</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7b7d48ea7b3b293c238f8dc4cd94aa16d688011e" translate="yes" xml:space="preserve">
          <source>Example 2 &amp;mdash; Beware of the NewRow</source>
          <target state="translated">例2 &amp;mdash; NewRowに注意してください</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="deec6b3c379dce2b6012e423f46c379377857030" translate="yes" xml:space="preserve">
          <source>Examples and Remedies</source>
          <target state="translated">事例とレメディ</target>
        </trans-unit>
        <trans-unit id="489c7f142f084f70e38f635ba7b9b348e5d129a5" translate="yes" xml:space="preserve">
          <source>Exception handling: One of the important ways of managing this exception. Using simple try-catch-finally blocks we can control this exception and also maintain a log of it. This can be very useful when your application is on production stage.</source>
          <target state="translated">例外の処理。この例外を管理する重要な方法の一つです。シンプルなtry-catch-finallyブロックを使用することで、この例外を制御し、そのログを維持することができます。これは、アプリケーションが運用段階にあるときに非常に便利です。</target>
        </trans-unit>
        <trans-unit id="863e0b11b844698fd5b45fe2becd1c066657e73f" translate="yes" xml:space="preserve">
          <source>Explicit Checking: We should adhere to the tradition of checking the objects, properties, methods, arrays, and collections whether they are null. This can be simply implemented using conditional statements like if-else if-else etc.</source>
          <target state="translated">明示的なチェック オブジェクト、プロパティ、メソッド、配列、コレクションがNULLであるかどうかをチェックする伝統を守るべきです。これは if-else if-else などの条件文を使って簡単に実装できます。</target>
        </trans-unit>
        <trans-unit id="109df3f9e4f70aee4ff4534f310fc794f8dc97d8" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; and ignore null values.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; を明示的にチェックし、 null値を無視します。</target>
        </trans-unit>
        <trans-unit id="31543b579bc99ae672e332aadbdf4f54893ffe8c" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; and provide a default value.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; を明示的にチェックして、デフォルト値を指定します。</target>
        </trans-unit>
        <trans-unit id="be6cb31f6768070d27ac716dcf02c1e5b5d94512" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; from method calls and throw a custom exception.</source>
          <target state="translated">メソッド呼び出しから &lt;code&gt;null&lt;/code&gt; を明示的にチェックし、カスタム例外をスローします。</target>
        </trans-unit>
        <trans-unit id="376a5f377acf229980dec162e286875baba55137" translate="yes" xml:space="preserve">
          <source>Finding The Cause</source>
          <target state="translated">原因を見つける</target>
        </trans-unit>
        <trans-unit id="036893902b168b7c15417cf8b62f2cd292a4a2cd" translate="yes" xml:space="preserve">
          <source>First, make sure that the correct error is going to be caught - see
&lt;a href=&quot;https://stackoverflow.com/questions/4475464/&quot;&gt;How do I allow breaking on 'System.NullReferenceException' in VS2010?&lt;/a&gt;&lt;em&gt;Note&lt;sup&gt;1&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">最初に、正しいエラーがキャッチされることを確認します&lt;a href=&quot;https://stackoverflow.com/questions/4475464/&quot;&gt;-VS2010で「System.NullReferenceException」のブレークを許可するに&lt;/a&gt;はどうすればよいですか？を参照してください。 &lt;em&gt;注&lt;sup&gt;1&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a9bb411b345b451f4de56294a2e04b8bb44acd7" translate="yes" xml:space="preserve">
          <source>Floating-point types</source>
          <target state="translated">浮動小数点型</target>
        </trans-unit>
        <trans-unit id="c3b57bba0c6478be6c3878f4976f8768bd6104c1" translate="yes" xml:space="preserve">
          <source>For More details : &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators&quot;&gt;Null-conditional Operators&lt;/a&gt;</source>
          <target state="translated">詳細： &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators&quot;&gt;ヌル条件演算子&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d625573dda6be4c24b311020c3d5caa8ee0507c" translate="yes" xml:space="preserve">
          <source>For discussion have a look at &lt;a href=&quot;https://stackoverflow.com/questions/17136455/nullreferenceexception-in-dbcontext-savechanges&quot;&gt;NullReferenceException in DbContext.saveChanges()&lt;/a&gt;</source>
          <target state="translated">議論のため&lt;a href=&quot;https://stackoverflow.com/questions/17136455/nullreferenceexception-in-dbcontext-savechanges&quot;&gt;にDbContext.saveChanges（）のNullReferenceExceptionを&lt;/a&gt;見てください</target>
        </trans-unit>
        <trans-unit id="88fa3152aa1a080052016562134c18cdbc4e0603" translate="yes" xml:space="preserve">
          <source>For example :</source>
          <target state="translated">例えば。</target>
        </trans-unit>
        <trans-unit id="21d6357b4a277981b9a66afc8fcee08849d0a240" translate="yes" xml:space="preserve">
          <source>For example, methods can check the different arguments to see if they are null and throw an &lt;code&gt;ArgumentNullException&lt;/code&gt;, an exception obviously created for this exact purpose.</source>
          <target state="translated">たとえば、メソッドはさまざまな引数をチェックしてそれらがnullかどうかを確認し、 &lt;code&gt;ArgumentNullException&lt;/code&gt; をスローできます。これは、まさにこの目的のために作成された例外です。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="ea87f510412c7e56ffdecaf29378fffd0b2ac212" translate="yes" xml:space="preserve">
          <source>For instance,
in the following line the only code that &lt;em&gt;can&lt;/em&gt; cause the exception is if &lt;code&gt;myString&lt;/code&gt; evaluates to null. This can be verified by looking at the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa290869(v=vs.71).aspx&quot;&gt;Watch Window&lt;/a&gt; or running expressions in the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/f177hahy.aspx&quot;&gt;Immediate Window&lt;/a&gt;.</source>
          <target state="translated">たとえば、次の行で例外が発生する&lt;em&gt;可能&lt;/em&gt;性&lt;em&gt;が&lt;/em&gt;ある唯一のコードは、 &lt;code&gt;myString&lt;/code&gt; がnullと評価された場合です 。 これは、 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa290869(v=vs.71).aspx&quot;&gt;ウォッチウィンドウ&lt;/a&gt;を確認するか、 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/f177hahy.aspx&quot;&gt;イミディエイトウィンドウで&lt;/a&gt;式を実行することで確認できます。</target>
        </trans-unit>
        <trans-unit id="d3ab9060f75e800aa736a6c6d4a9d5f39e13be8b" translate="yes" xml:space="preserve">
          <source>For me the reason was that I had rename the file and old file was still open.</source>
          <target state="translated">私の場合は、ファイル名を変更しても古いファイルが開いたままだったのが原因でした。</target>
        </trans-unit>
        <trans-unit id="ae336d2485d45668cf4b510dc35f9a49b357aa3b" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx&quot;&gt;&lt;code&gt;List(Of T)&lt;/code&gt; Class&lt;/a&gt;.</source>
          <target state="translated">詳細については、「 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx&quot;&gt; &lt;code&gt;List(Of T)&lt;/code&gt; Class&lt;/a&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="3cadad1fb936cd59a173ee4ad751226d192504b1" translate="yes" xml:space="preserve">
          <source>For more information, see:</source>
          <target state="translated">詳細はこちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="4b6396c3009607565ca4b596f1d3cfe993427c34" translate="yes" xml:space="preserve">
          <source>For the sake of completeness DataContext class</source>
          <target state="translated">完全性のために DataContext クラス</target>
        </trans-unit>
        <trans-unit id="f241b5f4ab6b5874d32e0e2ef564edcc65cde7d2" translate="yes" xml:space="preserve">
          <source>For this cause, &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264808%28v=vs.110%29.aspx&quot;&gt;Code Contracts&lt;/a&gt;&lt;/em&gt; project exists for .NET applications.</source>
          <target state="translated">このため、.NETアプリケーション用の&lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264808%28v=vs.110%29.aspx&quot;&gt;Code Contracts&lt;/a&gt;&lt;/em&gt;プロジェクトが存在します。</target>
        </trans-unit>
        <trans-unit id="6cfbd5392a130ba8fc377b758d8e7cdc4f1a9d51" translate="yes" xml:space="preserve">
          <source>For your reference I made the code above available on GitHub, you can find it at:</source>
          <target state="translated">参考までに、上記のコードをGitHubで利用できるようにしました。</target>
        </trans-unit>
        <trans-unit id="c4a1d4b8ee2b3e9ff148b30c5b4c8d7bb468ba9c" translate="yes" xml:space="preserve">
          <source>Function Returning Nothing</source>
          <target state="translated">何も返さない関数</target>
        </trans-unit>
        <trans-unit id="bda3e991f9ccd7f64923695508d53cbd3f8354a4" translate="yes" xml:space="preserve">
          <source>Further Notes: If you want unity to add a component to your object and you might have forgotten to add one, you can type &lt;code&gt;[RequireComponent(typeof(RigidBody))]&lt;/code&gt; above your class declaration (the space below all of your usings).</source>
          <target state="translated">詳細注記：単一でコンポーネントをオブジェクトに追加したいが、コンポーネントを追加するのを忘れた場合は、クラス宣言の上に &lt;code&gt;[RequireComponent(typeof(RigidBody))]&lt;/code&gt; と入力できます（すべての使用の下のスペース）。</target>
        </trans-unit>
        <trans-unit id="6ba86cf22af12011257223c782b9c2388170dce0" translate="yes" xml:space="preserve">
          <source>Furthermore, the reason I didn't have &lt;code&gt;Html.Partial&lt;/code&gt; to begin with was because Visual Studio &lt;strong&gt;sometimes&lt;/strong&gt; throws error-looking squiggly lines under &lt;code&gt;Html.Partial&lt;/code&gt; if it's inside a differently constructed &lt;code&gt;foreach&lt;/code&gt; loop, even though it's not really an error:</source>
          <target state="translated">さらに、私が &lt;code&gt;Html.Partial&lt;/code&gt; を持っていなかった理由は、実際にはエラーではありませんが、異なる構成の &lt;code&gt;foreach&lt;/code&gt; ループ内にある場合、Visual Studio &lt;strong&gt;が&lt;/strong&gt; &lt;code&gt;Html.Partial&lt;/code&gt; の下でエラーに見える波線を&lt;strong&gt;時々&lt;/strong&gt;スローするためです。</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="84ae2f625a61a0ac0cabba1b58ebdefb9ccdd612" translate="yes" xml:space="preserve">
          <source>Generic dictionaries in .NET are not thread-safe and they &lt;em&gt;sometimes&lt;/em&gt; might throw a &lt;code&gt;NullReference&lt;/code&gt; or even (more frequent) a &lt;code&gt;KeyNotFoundException&lt;/code&gt; when you try to access a key from two concurrent threads. The exception is quite misleading in this case.</source>
          <target state="translated">.NETのジェネリックディクショナリはスレッドセーフではなく、2つの同時スレッドからキーにアクセスしようとすると、 &lt;code&gt;NullReference&lt;/code&gt; またはさらに（より頻繁に） &lt;code&gt;KeyNotFoundException&lt;/code&gt; がスローされる場合があります。 この場合、例外はかなり誤解を招きます。</target>
        </trans-unit>
        <trans-unit id="5442e2b64fa09764b9f593867e59a97292c84059" translate="yes" xml:space="preserve">
          <source>GitHub</source>
          <target state="translated">GitHub</target>
        </trans-unit>
        <trans-unit id="d0a42f917789ed1adb6c6963e61a12fd3ef2255b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;comboBox1&lt;/code&gt; is created before &lt;code&gt;label1&lt;/code&gt;. If &lt;code&gt;comboBox1_SelectionChanged&lt;/code&gt; attempts to reference `label1, it will not yet have been created.</source>
          <target state="translated">ここで、 &lt;code&gt;comboBox1&lt;/code&gt; は &lt;code&gt;label1&lt;/code&gt; の前に作成されます。 comboBox1_SelectionChangedが `label1を参照しようとした場合、まだ作成されていません。</target>
        </trans-unit>
        <trans-unit id="5bb2ae17924e2d50220fe232232b8dca78bd0287" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Book&lt;/code&gt; and &lt;code&gt;Car&lt;/code&gt; are incompatible types; a &lt;code&gt;Car&lt;/code&gt; cannot be converted/cast to a &lt;code&gt;Book&lt;/code&gt;.  When this cast fails, &lt;code&gt;as&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;.  Using &lt;code&gt;mybook&lt;/code&gt; after this causes a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;Book&lt;/code&gt; と &lt;code&gt;Car&lt;/code&gt; は互換性のないタイプです。 &lt;code&gt;Car&lt;/code&gt; を &lt;code&gt;Book&lt;/code&gt; 変換/キャストすることはできません。 このキャストが失敗すると、 &lt;code&gt;as&lt;/code&gt; は &lt;code&gt;null&lt;/code&gt; を返します 。 この後に &lt;code&gt;mybook&lt;/code&gt; を使用すると、 &lt;code&gt;NullReferenceException&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="f0cfc5e03a074b5ff497538e30726ab43dd9c052" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SelectedDate&lt;/code&gt; is in fact a property - of &lt;code&gt;DateTime&lt;/code&gt; type - of the &lt;code&gt;Calendar&lt;/code&gt; Web Control type, and the binding could perfectly return something null. The implicit ASP.NET Generator will create a piece of code that will be equivalent to the cast code above. And this will raise a &lt;code&gt;NullReferenceException&lt;/code&gt; that is quite difficult to spot, because it lies in ASP.NET generated code which compiles fine...</source>
          <target state="translated">ここで、 &lt;code&gt;SelectedDate&lt;/code&gt; は実際には &lt;code&gt;DateTime&lt;/code&gt; タイプの &lt;code&gt;Calendar&lt;/code&gt; Web Controlタイプのプロパティであり、バインディングは完全にnullを返す可能性があります。 暗黙のASP.NETジェネレーターは、上記のキャストコードと同等のコードを作成します。 そして、これはうまくコンパイルするASP.NET生成コードにあるため、見つけるのが非常に難しい &lt;code&gt;NullReferenceException&lt;/code&gt; を発生させます...</target>
        </trans-unit>
        <trans-unit id="ed1e9256d7edb2bcff5e3eaa417639f1f18c564e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;myWebBrowser&lt;/code&gt; or &lt;code&gt;Document&lt;/code&gt; could be Nothing or the &lt;code&gt;formfld1&lt;/code&gt; element may not exist.</source>
          <target state="translated">ここで、 &lt;code&gt;myWebBrowser&lt;/code&gt; または &lt;code&gt;Document&lt;/code&gt; がNothingであるか、 &lt;code&gt;formfld1&lt;/code&gt; 要素が存在しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="2320c69a11432eba5e88d70d8ffa3f27efc00ca3" translate="yes" xml:space="preserve">
          <source>Hope this helps too!</source>
          <target state="translated">これも役立つことを願っています</target>
        </trans-unit>
        <trans-unit id="0ae3600ced7e6090a5b25d1e38293c3e4c119186" translate="yes" xml:space="preserve">
          <source>How can it be avoided?</source>
          <target state="translated">どうすれば回避できるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="289dd28c102f868db09f817b7b706b35bc135e71" translate="yes" xml:space="preserve">
          <source>How do you find the source of a &lt;code&gt;NullReferenceException&lt;/code&gt;? Apart from looking at the exception itself, which will be thrown exactly at the location where it occurs, the general rules of debugging in Visual Studio apply: place strategic breakpoints and &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/esta7c62.aspx&quot;&gt;inspect your variables&lt;/a&gt;, either by hovering the mouse over their names, opening a (Quick)Watch window or using the various debugging panels like Locals and Autos.</source>
          <target state="translated">&lt;code&gt;NullReferenceException&lt;/code&gt; のソースをどのように見つけますか？ 例外が発生した場所で正確にスローされる例外自体を見ることとは別に、Visual Studioでのデバッグの一般的なルールが適用されます：戦略的ブレークポイントを配置&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/esta7c62.aspx&quot;&gt;し、変数&lt;/a&gt;を検査します。 Quick）Watchウィンドウ、またはLocalsやAutosなどのさまざまなデバッグパネルの使用。</target>
        </trans-unit>
        <trans-unit id="c9076ca26af1e797ee780559308ab39c1861f589" translate="yes" xml:space="preserve">
          <source>I have a different perspective to answering this. This sort of answers &lt;strong&gt;&quot;what else can I do to avoid it?&lt;/strong&gt;&quot;</source>
          <target state="translated">私はこれに答える別の視点を持っています。 この種の答えは&lt;strong&gt;「それを避けるために他に何ができるか？&lt;/strong&gt; 」</target>
        </trans-unit>
        <trans-unit id="4b181a81f82b32a1fdd472eb539bf0016ed99f5f" translate="yes" xml:space="preserve">
          <source>I have some code and when it executes, it throws a &lt;code&gt;NullReferenceException&lt;/code&gt;, saying:</source>
          <target state="translated">いくつかのコードがあり、実行すると &lt;code&gt;NullReferenceException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="039ba9acfb4e759d3a5ed8951d9aef9d9682bea4" translate="yes" xml:space="preserve">
          <source>I was getting &lt;code&gt;Object reference not set to an instance of an object&lt;/code&gt; when I tried to render a View within a View by sending it a Model, like this:</source>
          <target state="translated">次のように、モデルを送信してビュー内にビューをレンダリングしようとしたときに &lt;code&gt;Object reference not set to an instance of an object&lt;/code&gt; がオブジェクトのインスタンスに設定されていませんでした 。</target>
        </trans-unit>
        <trans-unit id="cdd8f575833c363a288e4e756f1a133957aee9ea" translate="yes" xml:space="preserve">
          <source>I'll be using a RigidBody variable as an example.</source>
          <target state="translated">今回はRigidBodyの変数を例に挙げてみます。</target>
        </trans-unit>
        <trans-unit id="fd9aa298728dbdb009eb67b0148c8d2d45bb648a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dgvBooks&lt;/code&gt; has &lt;code&gt;AutoGenerateColumns = True&lt;/code&gt;, it will create the columns, but it does not name them, so the above code fails when it references them by name.</source>
          <target state="translated">&lt;code&gt;dgvBooks&lt;/code&gt; に &lt;code&gt;AutoGenerateColumns = True&lt;/code&gt; がある場合、列は作成されますが、名前は付けられないため、上記のコードは名前で参照すると失敗します。</target>
        </trans-unit>
        <trans-unit id="bb92213da41ab10c3a7c561c6d6e69a25df9059f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;whatever&lt;/code&gt; results in &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;MakeFrob&lt;/code&gt; will throw.  Now, you might think that the right thing to do is this:</source>
          <target state="translated">結果が &lt;code&gt;null&lt;/code&gt; の場合、 &lt;code&gt;MakeFrob&lt;/code&gt; がスローします。 今、あなたは正しいことはこれだと思うかもしれません：</target>
        </trans-unit>
        <trans-unit id="c31841110ff2a43d84d3c54ced95f988e30ba219" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CheckBox&lt;/code&gt; with &lt;code&gt;chkName&lt;/code&gt; can't be found (or exists in a &lt;code&gt;GroupBox&lt;/code&gt;), then &lt;code&gt;chk&lt;/code&gt; will be Nothing and be attempting to reference any property will result in an exception.</source>
          <target state="translated">&lt;code&gt;chkName&lt;/code&gt; を持つ &lt;code&gt;CheckBox&lt;/code&gt; が見つからない（または &lt;code&gt;GroupBox&lt;/code&gt; に存在する）場合、 &lt;code&gt;chk&lt;/code&gt; はNothingになり、プロパティを参照しようとすると例外が発生します。</target>
        </trans-unit>
        <trans-unit id="56b8e5facbdd4848585ce4e50ddd17e21345d1f4" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;NullReferenceException&lt;/code&gt; is thrown by &lt;code&gt;unsafe&lt;/code&gt; code, you might look at your pointer variables, and check them for &lt;code&gt;IntPtr.Zero&lt;/code&gt; or something. Which is the same thing (&quot;null pointer exception&quot;), but in unsafe code, variables are often cast to value-types/arrays, etc., and you bang your head against the wall, wondering how a value-type can throw this exception.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; コードによって &lt;code&gt;NullReferenceException&lt;/code&gt; がスローされた場合は、ポインタ変数を調べて、 &lt;code&gt;IntPtr.Zero&lt;/code&gt; などが含まれていないか確認してください。 これは同じことですが（「nullポインタ例外」）、安全でないコードでは、変数が値の型/配列などにキャストされることが多く、壁に頭をぶつけて、値の型がこれをスローする方法を疑問に思います例外。</target>
        </trans-unit>
        <trans-unit id="3ba69a96020f6c1697e9f0b564be8a369771f477" translate="yes" xml:space="preserve">
          <source>If it is caused on some &lt;strong&gt;database&lt;/strong&gt; commands because the object isn't present then all you need to do is do a null check and handle it:</source>
          <target state="translated">オブジェクトが存在しないために一部の&lt;strong&gt;データベース&lt;/strong&gt;コマンドで発生した場合は、nullチェックを実行してそれを処理するだけです。</target>
        </trans-unit>
        <trans-unit id="a0fc7e5c19cd4824faca0c76683d3494b34dba43" translate="yes" xml:space="preserve">
          <source>If one is getting this message during saving or compiling the build, just close all the files and then open any file to compile and save.</source>
          <target state="translated">ビルドの保存やコンパイル中にこのメッセージが表示された場合は、すべてのファイルを閉じてから、任意のファイルを開いてコンパイルして保存してください。</target>
        </trans-unit>
        <trans-unit id="0b56c362f306a958689a4fcd2922fb1cfb57868c" translate="yes" xml:space="preserve">
          <source>If ref1 or ref2 or ref3 is null, then you'll get a &lt;code&gt;NullReferenceException&lt;/code&gt;. If you want to solve the problem, then find out which one is null by rewriting the expression to its simpler equivalent:</source>
          <target state="translated">ref1、ref2、またはref3がnullの場合、 &lt;code&gt;NullReferenceException&lt;/code&gt; が発生します。 問題を解決したい場合は、式をより単純な同等のものに書き直して、どれがnullかを調べます。</target>
        </trans-unit>
        <trans-unit id="1e7a62c30a52478b4caee9f5d2f2740eae4bcb26" translate="yes" xml:space="preserve">
          <source>If the exception occurs when referencing a property of &lt;code&gt;@Model&lt;/code&gt; in an &lt;code&gt;ASP.NET MVC View&lt;/code&gt;, you need to understand that the &lt;code&gt;Model&lt;/code&gt; gets set in your action method, when you &lt;code&gt;return&lt;/code&gt; a view. When you return an empty model (or model property) from your controller, the exception occurs when the views access it:</source>
          <target state="translated">&lt;code&gt;ASP.NET MVC View&lt;/code&gt; で &lt;code&gt;@Model&lt;/code&gt; のプロパティを参照しているときに例外が発生した場合、 ビューを &lt;code&gt;return&lt;/code&gt; ときに、アクションメソッドで &lt;code&gt;Model&lt;/code&gt; が設定されることを理解する必要があります。 コントローラーから空のモデル（またはモデルプロパティ）を返すと、ビューがアクセスしたときに例外が発生します。</target>
        </trans-unit>
        <trans-unit id="a383d31e09e21027128bda7cc84f8a8c4c8d65f8" translate="yes" xml:space="preserve">
          <source>If the person does not have a title, this will throw an exception because it is trying to call &lt;code&gt;ToUpper&lt;/code&gt; on a property with a null value.</source>
          <target state="translated">人物にタイトルがない場合、null値のプロパティで &lt;code&gt;ToUpper&lt;/code&gt; を呼び出そうとしているため、これは例外をスローします。</target>
        </trans-unit>
        <trans-unit id="5cf3aeda57ef955ddb285e14c6996f8c139ee9bf" translate="yes" xml:space="preserve">
          <source>If we consider common scenarios where this exception can be thrown, accessing properties withing object at the top.</source>
          <target state="translated">この例外がスローされる可能性がある一般的なシナリオを考えてみると、上部にあるオブジェクトを持つプロパティにアクセスします。</target>
        </trans-unit>
        <trans-unit id="bd4df3cabfb26db423d61513abb17ea9d42bbc71" translate="yes" xml:space="preserve">
          <source>If you are debugging with Just My Code enabled, the behavior is slightly different. With Just My Code enabled, the debugger ignores first-chance common language runtime (CLR) exceptions that are thrown outside of My Code and do not pass through My Code</source>
          <target state="translated">Just My Code を有効にしてデバッグしている場合は、動作が少し異なります。Just My Code を有効にした場合、デバッガは、My Code の外に投げられ、My Code を通らないファーストチャンスの共通言語ランタイム (CLR)例外を無視します。</target>
        </trans-unit>
        <trans-unit id="5d011199f17f1b3224336bf477779ff919919146" translate="yes" xml:space="preserve">
          <source>If you are expecting the type conversion to always succeed (ie. you know what the object should be ahead of time), then you should use a cast:</source>
          <target state="translated">型変換が常に成功することを期待している場合(つまり、オブジェクトが何であるべきかを事前に知っている場合)は、キャストを使うべきです。</target>
        </trans-unit>
        <trans-unit id="db5359f7b5259b8f8194c263074c45fca315ff8a" translate="yes" xml:space="preserve">
          <source>If you are unsure of the type, but you want to &lt;em&gt;try&lt;/em&gt; to use it as a specific type, then use &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">タイプがわからないが、特定のタイプとして使用したい場合は、次のように使用 &lt;code&gt;as&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="1c923dbbe26d09b3ec56dc6968714cd47b9bf93d" translate="yes" xml:space="preserve">
          <source>If you are working with unsafe code and you get a null dereference exception, just be aware that the offending pointer need not be null. It can be any location in the lowest page, and this exception will be produced.</source>
          <target state="translated">安全ではないコードで作業をしていて、NULL 宣言解除例外が発生した場合、問題となるポインタは NULL である必要はないことに注意してください。最下層ページのどの位置でもよいのですが、この例外が発生します。</target>
        </trans-unit>
        <trans-unit id="9eee74fa45beb820853095727a40c22279c9d0bc" translate="yes" xml:space="preserve">
          <source>If you do use a &lt;code&gt;For n&lt;/code&gt; loop, modify the row count or use &lt;code&gt;Exit For&lt;/code&gt; when &lt;code&gt;IsNewRow&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;For n&lt;/code&gt; ループを使用する場合は、行数を変更するか、 &lt;code&gt;IsNewRow&lt;/code&gt; がtrueのときに &lt;code&gt;Exit For&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="e09bc8a6a4e58664c4a3a3793f96ba758d2f4e9b" translate="yes" xml:space="preserve">
          <source>If you examine the reference source for &lt;code&gt;LINQ&lt;/code&gt; to Objects you will see that this technique is used throughout. It is slightly more clunky to write, but it makes debugging nullity errors much easier.  &lt;strong&gt;Optimize your code for the convenience of the caller, not the convenience of the author&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;LINQ&lt;/code&gt; to Objectsの参照ソースを調べると、この手法が全体で使用されていることがわかります。 書くのは少し不格好ですが、ヌルエラーのデバッグがはるかに簡単になります。 &lt;strong&gt;作成者の便宜ではなく、呼び出し元の便宜のためにコードを最適化します&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e93bb8e62bdb0cbe375e02bcdd4025ed3a5280b6" translate="yes" xml:space="preserve">
          <source>If you expect the reference sometimes to be null, you can check for it being &lt;code&gt;null&lt;/code&gt; before accessing instance members:</source>
          <target state="translated">参照がnullになることが予想される場合は、インスタンスメンバーにアクセスする前に &lt;code&gt;null&lt;/code&gt; かどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="954ae9f52d37b1ad255f61190a8a7c1d85bef3ef" translate="yes" xml:space="preserve">
          <source>If you have not initialized a reference type, and you want to set or read one of its properties, it will throw a &lt;strong&gt;NullReferenceException&lt;/strong&gt;.</source>
          <target state="translated">参照型を初期化しておらず、そのプロパティの1つを設定または読み取る場合は、 &lt;strong&gt;NullReferenceException&lt;/strong&gt;がスローされます。</target>
        </trans-unit>
        <trans-unit id="c9b75db38115a136957814e589aeeb2dac83db23" translate="yes" xml:space="preserve">
          <source>If you want to avoid the child (Person) null reference, you could initialize it in the parent (Book) object's constructor.</source>
          <target state="translated">子(Person)のnull参照を避けたい場合は、親(Book)オブジェクトのコンストラクタで初期化することができます。</target>
        </trans-unit>
        <trans-unit id="7672c7bfcdb17d75fe7dfc75005f4c60663395f1" translate="yes" xml:space="preserve">
          <source>If you want to find out where the reference is or isn't set, right-click its name and select &quot;Find All References&quot;. You can then place a breakpoint at every found location and run your program with the debugger attached. Every time the debugger breaks on such a breakpoint, you need to determine whether you expect the reference to be non-null, inspect the variable, and verify that it points to an instance when you expect it to.</source>
          <target state="translated">リファレンスが設定されている場所や設定されていない場所を確認したい場合は、その名前を右クリックして &quot;すべてのリファレンスを検索&quot; を選択します。そして、見つかったすべての場所にブレークポイントを置き、デバッガを接続した状態でプログラムを実行することができます。このようなブレークポイントでデバッガがブレークするたびに、参照が NULL ではないと予想しているかどうかを判断し、変数を検査し、予想しているときにインスタンスを指しているかどうかを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="124ed7dc2efaa392800e559d8512faa6fddfc4a6" translate="yes" xml:space="preserve">
          <source>If you're not sure whether the object is null, check it with &lt;code&gt;object == null&lt;/code&gt;.</source>
          <target state="translated">オブジェクトがnullかどうかわからない場合は、 &lt;code&gt;object == null&lt;/code&gt; で確認してください。</target>
        </trans-unit>
        <trans-unit id="f9d87c823bab4a6a3c23f4fa35b0ab3165ebc81e" translate="yes" xml:space="preserve">
          <source>Imagine that &lt;code&gt;country&lt;/code&gt; is an object of type &lt;code&gt;Country&lt;/code&gt; that has a property called &lt;code&gt;State&lt;/code&gt; and so on. If &lt;code&gt;country&lt;/code&gt;, &lt;code&gt;State&lt;/code&gt;, &lt;code&gt;County&lt;/code&gt;, or &lt;code&gt;City&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;address will be&lt;/code&gt;null&lt;code&gt;. Therefore you only have to check whether&lt;/code&gt;address&lt;code&gt;is&lt;/code&gt;null`.</source>
          <target state="translated">その &lt;code&gt;country&lt;/code&gt; が、 &lt;code&gt;Country&lt;/code&gt; のプロパティを持つ国タイプのオブジェクトであるとします。 &lt;code&gt;country&lt;/code&gt; 、 &lt;code&gt;State&lt;/code&gt; 、 &lt;code&gt;County&lt;/code&gt; 、または &lt;code&gt;City&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; の場合、 &lt;code&gt;address will be&lt;/code&gt; null になります &lt;code&gt;. Therefore you only have to check whether&lt;/code&gt; したがって、アドレス &lt;code&gt;is&lt;/code&gt; nullであるかどうかを確認するだけで済みます 。</target>
        </trans-unit>
        <trans-unit id="d8dc338b100fb641765e4200d2b3f89eb5c8d59d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C# 5&lt;/code&gt; and below, this can be guarded with:</source>
          <target state="translated">&lt;code&gt;C# 5&lt;/code&gt; 以下では、これは次のようにして保護できます。</target>
        </trans-unit>
        <trans-unit id="d9af0d957316871a93fd8ae5a5c0570ecd645f0d" translate="yes" xml:space="preserve">
          <source>In Visual Studio this is usually easy thanks to the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/sc65sadd.aspx&quot;&gt;Visual Studio Debugger&lt;/a&gt;.</source>
          <target state="translated">Visual Studioでは、これは&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/sc65sadd.aspx&quot;&gt;Visual Studio Debuggerの&lt;/a&gt;おかげで通常は簡単です。</target>
        </trans-unit>
        <trans-unit id="442f25764599824025c21fd67a95683d7a1d4d49" translate="yes" xml:space="preserve">
          <source>In comparison to an ArgumentNullException which is typically thrown as a defensive measure if a method expects that what is being passed to it is not null.</source>
          <target state="translated">ArgumentNullExceptionは、メソッドに渡されたものがNullではないことを期待している場合に、通常は防御手段としてスローされます。</target>
        </trans-unit>
        <trans-unit id="0d6fbd94de7bcc900b19537b5bb326c45d6c0504" translate="yes" xml:space="preserve">
          <source>In general, you should use a cast or &lt;code&gt;as&lt;/code&gt;, as follows:</source>
          <target state="translated">通常、次のように、キャストまたは &lt;code&gt;as&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="a745bf8342a8ec9dc29ec2f0e55b1f294b6ff60a" translate="yes" xml:space="preserve">
          <source>In more advanced cases, such as the following, you'll need to use one of the techniques above (Watch or Immediate Windows) to inspect the expressions to determine if &lt;code&gt;str1&lt;/code&gt; was null or if &lt;code&gt;str2&lt;/code&gt; was null.</source>
          <target state="translated">次のようなより高度なケースでは、上記の手法の1つ（ウォッチまたはイミディエイトウィンドウ）を使用して式を検査し、 &lt;code&gt;str1&lt;/code&gt; がnullであるか、 &lt;code&gt;str2&lt;/code&gt; がnullであるかを判断する必要があります。</target>
        </trans-unit>
        <trans-unit id="6c2d2f16f8b1cfa8d5861b4766e0faaf22391a45" translate="yes" xml:space="preserve">
          <source>In short, &lt;em&gt;class invariants&lt;/em&gt; ensure that there will be some constraints in your class that will not get violated in normal use (and therefore, the class will &lt;em&gt;not&lt;/em&gt; get in an inconsistent state). &lt;em&gt;Preconditions&lt;/em&gt; mean that data given as input to a function/method must follow some constraints set and &lt;strong&gt;never&lt;/strong&gt; violate them, and &lt;em&gt;postconditions&lt;/em&gt; mean that a function/method output must follow the set constraints again without ever violating them.
Contract conditions should &lt;strong&gt;never&lt;/strong&gt; be violated during execution of a bug-free program, therefore design by contract is checked in practice in debug mode, while being &lt;em&gt;disabled in releases&lt;/em&gt;, to maximize the developed system performance.</source>
          <target state="translated">つまり、 &lt;em&gt;クラスの不変&lt;/em&gt;条件は、通常の使用で違反しないクラスにいくつかの制約があることを保証します（したがって、クラスが矛盾した状態になることはあり&lt;em&gt;ませ&lt;/em&gt;ん）。 &lt;em&gt;前提条件&lt;/em&gt;は、関数/メソッドへの入力として与えられたデータがいくつかの制約セットに従う必要があり、それらに違反し&lt;strong&gt;ないことを&lt;/strong&gt;意味し、 &lt;em&gt;事後条件&lt;/em&gt;は、関数/メソッド出力が設定制約に違反することなく再び従わなければならないことを意味します。 バグのないプログラムの実行中は、契約条件に違反し&lt;strong&gt;ない&lt;/strong&gt;でください。したがって、開発モードでは契約による設計が実際にデバッグモードでチェックされ&lt;em&gt;ますが、リリース&lt;/em&gt;では&lt;em&gt;無効に&lt;/em&gt;なり、開発されたシステムパフォーマンスを最大化します。</target>
        </trans-unit>
        <trans-unit id="ee86d3f393a29644b6be92e8be9ec8a1afe52114" translate="yes" xml:space="preserve">
          <source>In the other direction, a &lt;strong&gt;&lt;em&gt;boxing&lt;/em&gt;&lt;/strong&gt; conversion &lt;em&gt;from&lt;/em&gt; a &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; which has &lt;code&gt;HasValue&lt;/code&gt; equal to &lt;code&gt;false&lt;/code&gt;&lt;em&gt;to&lt;/em&gt; a reference type, can give a &lt;code&gt;null&lt;/code&gt; reference which can then later lead to a &lt;code&gt;NullReferenceException&lt;/code&gt;. The classic example is:</source>
          <target state="translated">反対方向では、 &lt;code&gt;HasValue&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; &lt;em&gt;に&lt;/em&gt;等しい &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; &lt;em&gt;から&lt;/em&gt;参照型&lt;em&gt;への&lt;/em&gt; &lt;strong&gt;&lt;em&gt;ボクシング&lt;/em&gt;&lt;/strong&gt;変換&lt;em&gt;により&lt;/em&gt; 、 &lt;code&gt;null&lt;/code&gt; 参照が発生し、後で &lt;code&gt;NullReferenceException&lt;/code&gt; が発生する可能性があります。 古典的な例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7a5a670646192c2904df37f98794bc286c1f51c1" translate="yes" xml:space="preserve">
          <source>In unsafe mode, you should be aware of two important facts:</source>
          <target state="translated">不安モードでは、2つの重要な事実を知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="3be7faaf917ec1e75bc105ac00cd45db1f27d22a" translate="yes" xml:space="preserve">
          <source>In-built method: System methods such as GetValueOrDefault(),IsNullOrWhiteSpace() and IsNullorEmpty()  checks for nulls and assign the default value if there is a null value.</source>
          <target state="translated">内蔵メソッド。GetValueOrDefault(),IsNullOrWhiteSpace(),IsNullorEmpty()などのシステムメソッドは、ヌルをチェックし、ヌル値がある場合はデフォルト値を代入します。</target>
        </trans-unit>
        <trans-unit id="8cbe1b61604257c69eb792f97e93456c4cc68afc" translate="yes" xml:space="preserve">
          <source>Indirect</source>
          <target state="translated">Indirect</target>
        </trans-unit>
        <trans-unit id="414415dac9332746c5ff97ecdc8a7f74c2f17f06" translate="yes" xml:space="preserve">
          <source>Initialize the settings collection in the form's &lt;code&gt;Load&lt;/code&gt; event handler, if/when needed:</source>
          <target state="translated">必要に応じて、フォームの &lt;code&gt;Load&lt;/code&gt; イベントハンドラーで設定コレクションを初期化します。</target>
        </trans-unit>
        <trans-unit id="234d47467506fc9f47ee7950fcdb7bb2ae54365b" translate="yes" xml:space="preserve">
          <source>Integral types</source>
          <target state="translated">積分型</target>
        </trans-unit>
        <trans-unit id="c3341d58f2612c2f24999b64faed81efad614d89" translate="yes" xml:space="preserve">
          <source>Interestingly, none of the answers on this page mention the two edge cases, hope no one minds if I add them:</source>
          <target state="translated">興味深いことに、このページのどの回答も、2つのエッジケースについて言及していませんでした。</target>
        </trans-unit>
        <trans-unit id="01bd706ed0b9c186751dc7af37426b554a904934" translate="yes" xml:space="preserve">
          <source>Introduced in &lt;code&gt;C# 8&lt;/code&gt; there null context's and nullable reference types perform static analysis on variables and provides a compiler warning if a value can be potentially null or have been set to null. The nullable reference types allows types to be explicitly allowed to be null.</source>
          <target state="translated">&lt;code&gt;C# 8&lt;/code&gt; 導入されたnullコンテキストおよびnull可能な参照型は、変数の静的分析を実行し、値が潜在的にnullであるかnullに設定されている可能性がある場合にコンパイラ警告を提供します。 null可能な参照型により、型を明示的にnullにすることができます。</target>
        </trans-unit>
        <trans-unit id="cbf6007ad3f8db48b2caa744d94cf086e082dc37" translate="yes" xml:space="preserve">
          <source>It also arises when we forget to instantiate our objects. Using methods, properties, collections etc. which can return or set null values can also be the cause of this exception.</source>
          <target state="translated">また、オブジェクトのインスタンス化を忘れたときにも発生します。null 値を返したり設定したりできるメソッドやプロパティ、コレクションなどを使用すると、この例外が発生することがあります。</target>
        </trans-unit>
        <trans-unit id="6f40b22d84245ca604cc84dc6eef8a46a3df02af" translate="yes" xml:space="preserve">
          <source>It is curious that VB does not provide a warning, but the remedy is to &lt;strong&gt;declare&lt;/strong&gt; the containers at the form level, but &lt;strong&gt;initialize&lt;/strong&gt; them in form load event handler when the controls &lt;strong&gt;do&lt;/strong&gt; exist. This can be done in &lt;code&gt;Sub New&lt;/code&gt; as long as your code is after the &lt;code&gt;InitializeComponent&lt;/code&gt; call:</source>
          <target state="translated">VBが警告を出さないのは不思議ですが、救済策はフォームレベルでコンテナーを&lt;strong&gt;宣言&lt;/strong&gt;する&lt;strong&gt;ことです&lt;/strong&gt;が、コントロール&lt;strong&gt;が&lt;/strong&gt;存在する場合はフォームロードイベントハンドラーでそれらを&lt;strong&gt;初期化&lt;/strong&gt; &lt;strong&gt;し&lt;/strong&gt;ます。 コードが &lt;code&gt;InitializeComponent&lt;/code&gt; 呼び出しの後であれば、これは &lt;code&gt;Sub New&lt;/code&gt; で実行できます。</target>
        </trans-unit>
        <trans-unit id="2eef644af3700e5795f998539dd59e2e7c297244" translate="yes" xml:space="preserve">
          <source>It is not possible to reference anything 'downstream' of a &lt;code&gt;null&lt;/code&gt; object.  This also applies to controls:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; オブジェクトの「下流」を参照することはできません。 これはコントロールにも適用されます。</target>
        </trans-unit>
        <trans-unit id="83c9a2a6f0cded3da8a2fd23d1724756e8709640" translate="yes" xml:space="preserve">
          <source>It means that the variable in question is pointed at nothing. I could generate this like so:</source>
          <target state="translated">問題の変数が何も指していないことを意味します。こんな感じで生成できました。</target>
        </trans-unit>
        <trans-unit id="725b5851f8a7590790831cee0a9a54440c5e452d" translate="yes" xml:space="preserve">
          <source>It means your code used an object reference variable that was set to null (i.e. it did not reference an actual object instance).</source>
          <target state="translated">これは、あなたのコードがnullに設定されたオブジェクト参照変数を使用していることを意味します(つまり、実際のオブジェクトのインスタンスを参照していないことを意味します)。</target>
        </trans-unit>
        <trans-unit id="0c813d120a6e5cc67f6c6bde99d1fd2ca0b51cc2" translate="yes" xml:space="preserve">
          <source>It will throw a &lt;code&gt;NullReferenceException&lt;/code&gt; on the cast. It seems quite obvious in the above sample, but this can happen in more &quot;late-binding&quot; intricate scenarios where the null object has been returned from some code you don't own, and the cast is for example generated by some automatic system.</source>
          <target state="translated">キャストで &lt;code&gt;NullReferenceException&lt;/code&gt; をスローします。 上記のサンプルではそれは明らかなようですが、これは、所有していないコードからnullオブジェクトが返され、キャストがたとえば自動システムによって生成された、より「遅延バインディング」の複雑なシナリオで発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8179843545ce209e8ee908f48e63197ddb2508a8" translate="yes" xml:space="preserve">
          <source>It would be nice if C# had something like the &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; struct above and had a similar shorthand, maybe the exclamation point (!) so that you could write something like: &lt;code&gt;public void WriteName(Person! person)&lt;/code&gt;.</source>
          <target state="translated">C＃に上記の &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; 構造体のようなものがあり、同様の省略形、おそらく感嘆符（！）があれば、 &lt;code&gt;public void WriteName(Person! person)&lt;/code&gt; ように書くことができればいいでしょう。</target>
        </trans-unit>
        <trans-unit id="955b6d8394cf76a1d4fe4f8e7ef177275da55c14" translate="yes" xml:space="preserve">
          <source>It's a great feature, but it gives you less information. It doesn't make it obvious which of the 4 is null.</source>
          <target state="translated">素晴らしい機能ですが、情報量が少ないです。4のうちどれがヌルなのかが明らかにならない。</target>
        </trans-unit>
        <trans-unit id="4bf150ddb62d4d1939db3d1e25f12fdd47b0ee5f" translate="yes" xml:space="preserve">
          <source>It's used to test for null before performing a member access (?.) or index (?[) operation.</source>
          <target state="translated">これは、メンバーアクセス(?)やインデックス(?[)操作を実行する前に、NULLをテストするために使用されます。</target>
        </trans-unit>
        <trans-unit id="71c8a217f58ff5fc0e4a7d04b09748b7f1e8da29" translate="yes" xml:space="preserve">
          <source>Jagged Arrays</source>
          <target state="translated">ジャグド配列</target>
        </trans-unit>
        <trans-unit id="4de379f88b7ef46e6cfa5de6e9908e85f89cf4f0" translate="yes" xml:space="preserve">
          <source>JetBrains' Resharper tool will identify every place in your code that has the possibility of a null reference error, allowing you to put in a null check. This error is the number one source of bugs, IMHO.</source>
          <target state="translated">JetBrainsのResharperツールは、コード内のヌル参照エラーの可能性がある箇所をすべて特定し、ヌルチェックを行うことができます。このエラーはバグの一番の原因です。</target>
        </trans-unit>
        <trans-unit id="b2802386a0546365a801bdc9dc6dc071b11d5be6" translate="yes" xml:space="preserve">
          <source>Key Points</source>
          <target state="translated">キーポイント</target>
        </trans-unit>
        <trans-unit id="8ee0e49c20d5b975cccff63b65f6a1467d4f272c" translate="yes" xml:space="preserve">
          <source>LINQ &lt;code&gt;FirstOrDefault()&lt;/code&gt; and &lt;code&gt;SingleOrDefault()&lt;/code&gt;</source>
          <target state="translated">LINQ &lt;code&gt;FirstOrDefault()&lt;/code&gt; および &lt;code&gt;SingleOrDefault()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99356ca7906555a2f4c7dc97649a8efa6dbd0212" translate="yes" xml:space="preserve">
          <source>Like anything else, &lt;code&gt;null&lt;/code&gt; gets passed around. If it is &lt;code&gt;null&lt;/code&gt;&lt;em&gt;in&lt;/em&gt; method &quot;A&quot;, it could be that method &quot;B&quot; passed a &lt;code&gt;null&lt;/code&gt;&lt;em&gt;to&lt;/em&gt; method &quot;A&quot;.</source>
          <target state="translated">他と同様に、 &lt;code&gt;null&lt;/code&gt; が渡されます。 メソッド「A」で &lt;code&gt;null&lt;/code&gt; の場合、メソッド「B」がメソッド「A」に &lt;code&gt;null&lt;/code&gt; &lt;em&gt;を&lt;/em&gt;渡した可能性があります 。</target>
        </trans-unit>
        <trans-unit id="aa96796b70166a01da429a974a3cc400dff498a8" translate="yes" xml:space="preserve">
          <source>Likewise, for arrays you can use &lt;code&gt;?[i]&lt;/code&gt; as follows:</source>
          <target state="translated">同様に、配列の場合は、 &lt;code&gt;?[i]&lt;/code&gt; を次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="5fd395238ed01cc167eb08a83b289717b17ed72a" translate="yes" xml:space="preserve">
          <source>Lists and Collection will simply be empty</source>
          <target state="translated">リストとコレクションは単に空になります。</target>
        </trans-unit>
        <trans-unit id="b89d28bc5880c1090375f320e5a1517ea528fb46" translate="yes" xml:space="preserve">
          <source>Lists and Collections</source>
          <target state="translated">リストとコレクション</target>
        </trans-unit>
        <trans-unit id="8ed2e69395a71ce749a19137034071d7ce924763" translate="yes" xml:space="preserve">
          <source>Literally the easiest way to fix a NullReferenceExeption has two ways.
If you have a GameObject for example with a script attached and a variable named rb (rigidbody) this variable will start null when you start your game.</source>
          <target state="translated">NullReferenceExeptionを修正する最も簡単な方法は2つあります。例えば、スクリプトをアタッチしたGameObjectとrb(rididbody)という名前の変数がある場合、この変数はゲームを開始したときにNULLになります。</target>
        </trans-unit>
        <trans-unit id="c42ff2b214ede29fd88c31705a2e471ec3556484" translate="yes" xml:space="preserve">
          <source>MSDN NullReference Exception</source>
          <target state="translated">MSDN NullReference例外</target>
        </trans-unit>
        <trans-unit id="7ad8fdfe61e4454ef02db660ac35ba0748c9aa9d" translate="yes" xml:space="preserve">
          <source>MSDN: Best Practices for Exceptions</source>
          <target state="translated">MSDN.例外のベストプラクティス</target>
        </trans-unit>
        <trans-unit id="1799c9265044c387d0f81f0d8e6ab1b39fd3f4f5" translate="yes" xml:space="preserve">
          <source>MSDN: How to: Use the Try/Catch Block to Catch Exceptions</source>
          <target state="translated">MSDN.How to.TryCatch ブロックを使用して例外をキャッチする</target>
        </trans-unit>
        <trans-unit id="78736f095b06c11f959a9bd8d826202e6b13baf7" translate="yes" xml:space="preserve">
          <source>Memory is virtualized in &lt;code&gt;Windows&lt;/code&gt;; each process gets a virtual memory space of many &quot;pages&quot; of memory that are tracked by the operating system. Each page of memory has flags set on it which determine how it may be used: read from, written to, executed, and so on.  The &lt;em&gt;lowest&lt;/em&gt; page is marked as &quot;produce an error if ever used in any way&quot;.</source>
          <target state="translated">メモリは &lt;code&gt;Windows&lt;/code&gt; で仮想化されています 。 各プロセスは、オペレーティングシステムによって追跡されるメモリの多くの「ページ」の仮想メモリ空​​間を取得します。 メモリの各ページにはフラグが設定されており、使用方法（読み取り、書き込み、実行など）を決定します。 &lt;em&gt;一番下の&lt;/em&gt;ページは、「なんらかの方法で使用するとエラーが発生する」とマークされます。</target>
        </trans-unit>
        <trans-unit id="e23cc54bff3a3a5d37dc37dc1662948bf36648f0" translate="yes" xml:space="preserve">
          <source>Methods call you expect to return an instance can return &lt;code&gt;null&lt;/code&gt;, for example when the object being sought cannot be found. You can choose to return a default value when this is the case:</source>
          <target state="translated">たとえば、探しているオブジェクトが見つからない場合など、インスタンスを返すと予想されるメソッド呼び出しは &lt;code&gt;null&lt;/code&gt; を返す可能性があります。 この場合、デフォルト値を返すように選択できます。</target>
        </trans-unit>
        <trans-unit id="f2f65c39e9befac556a2ece0db1de4b0c904147b" translate="yes" xml:space="preserve">
          <source>More Specifically</source>
          <target state="translated">より具体的には</target>
        </trans-unit>
        <trans-unit id="1f2886a5d0eb58ab959b4b21d407f74a59989572" translate="yes" xml:space="preserve">
          <source>More information is in &lt;em&gt;&lt;a href=&quot;https://www.dotnetperls.com/nullreferenceexception&quot;&gt;C# NullReferenceException and Null Parameter&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">詳細については、 &lt;em&gt;&lt;a href=&quot;https://www.dotnetperls.com/nullreferenceexception&quot;&gt;C＃NullReferenceExceptionおよびNull Parameterを参照して&lt;/a&gt;&lt;/em&gt;ください。</target>
        </trans-unit>
        <trans-unit id="73d48e92ee90db3568c1d31a50c956aadebdfbd8" translate="yes" xml:space="preserve">
          <source>More realistic example - select nodes from XML document. Will throw if nodes are not found but initial debugging shows that all properties valid:</source>
          <target state="translated">より現実的な例-XML ドキュメントからノードを選択します。ノードが見つからない場合にスローされますが、最初のデバッグではすべてのプロパティが有効であることが示されています。</target>
        </trans-unit>
        <trans-unit id="f76899831263fd9799a64690d3ad0afc9100b2a4" translate="yes" xml:space="preserve">
          <source>My.Settings (StringCollection)</source>
          <target state="translated">My.Settings (StringCollection)</target>
        </trans-unit>
        <trans-unit id="41db439be65a63d22d9384237a7b090f77634c41" translate="yes" xml:space="preserve">
          <source>Name the columns manually, or reference by index:</source>
          <target state="translated">カラムに手動で名前を付けるか、インデックスで参照します。</target>
        </trans-unit>
        <trans-unit id="f73fd087219997abb0b2070a7f8b9006bc9c6c3b" translate="yes" xml:space="preserve">
          <source>Nested Collection Initializers</source>
          <target state="translated">入れ子になったコレクション初期化子</target>
        </trans-unit>
        <trans-unit id="c2ffcf7dcaf6a0db61f66aee4b7d2a32b5b706ba" translate="yes" xml:space="preserve">
          <source>Nested Object Initializers</source>
          <target state="translated">入れ子になったオブジェクトの初期化子</target>
        </trans-unit>
        <trans-unit id="a9f6f220ca6e10feac65da97285e903dcd7c03df" translate="yes" xml:space="preserve">
          <source>New Operator</source>
          <target state="translated">新オペレーター</target>
        </trans-unit>
        <trans-unit id="594a0ab4e25b09bd873763aa42a8cfaed596e74c" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;Do not&lt;/strong&gt; use &lt;code&gt;Dim&lt;/code&gt; again in a procedure, including the constructor (&lt;code&gt;Sub New&lt;/code&gt;):</source>
          <target state="translated">注：コンストラクター（ &lt;code&gt;Sub New&lt;/code&gt; ）を含むプロシージャで &lt;code&gt;Dim&lt;/code&gt; を再度使用&lt;strong&gt;しないでください&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0c7d1634f143651ccf0114e6c5ffff2ff4f10cd" translate="yes" xml:space="preserve">
          <source>Note: Beginning with VS 2010, when initializing a local array using a literal and &lt;code&gt;Option Infer&lt;/code&gt;, the &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; and &lt;code&gt;New&lt;/code&gt; elements are optional:</source>
          <target state="translated">注：VS 2010以降、リテラルと &lt;code&gt;Option Infer&lt;/code&gt; を使用してローカル配列を初期化する場合、 &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; および &lt;code&gt;New&lt;/code&gt; 要素はオプションです。</target>
        </trans-unit>
        <trans-unit id="378b211edf065e14fb27dcd1e7e1b744600ccaae" translate="yes" xml:space="preserve">
          <source>Now the title variable will be null instead of throwing an exception. C# 6 introduces a shorter syntax for this:</source>
          <target state="translated">これで、タイトル変数は例外を投げる代わりにNULLになります。C#6では、このためのより短い構文が導入されています。</target>
        </trans-unit>
        <trans-unit id="0e05b2f6e48a9c2172676721b07aa9534ae7f3f2" translate="yes" xml:space="preserve">
          <source>Now you are accessing this prop1 in some other class just like below:</source>
          <target state="translated">このprop1は、以下のように他のクラスでアクセスしています。</target>
        </trans-unit>
        <trans-unit id="baac228f016bc4ccca30fd630c5ff646abbf3f89" translate="yes" xml:space="preserve">
          <source>Now, consider another class where you are trying to retrieve the student's full name.</source>
          <target state="translated">さて、別のクラスで学生のフルネームを取得しようとしている場合を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="4850e4da722f36fec8d78291c92be908f1969d5e" translate="yes" xml:space="preserve">
          <source>Now, when I try to print the length of the string &lt;strong&gt;str&lt;/strong&gt;, I do get &lt;em&gt;An unhandled exception of type &amp;lsquo;System.NullReferenceException&amp;rsquo; occurred&lt;/em&gt; message because member &lt;strong&gt;str&lt;/strong&gt; is pointing to null and there can&amp;rsquo;t be any length of null.</source>
          <target state="translated">ここで、文字列&lt;strong&gt;strの&lt;/strong&gt;長さを出力しようとすると、メンバー&lt;strong&gt;str&lt;/strong&gt;がnullを指しているため、長さがnullであってはならないため、 &lt;em&gt;「System.NullReferenceException」タイプの未処理の例外が発生しました&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="eafd17582b015c89f4f72513d53f759c4bde2b05" translate="yes" xml:space="preserve">
          <source>Now, when the NullReferenceException is thrown (or unhandled) the debugger will stop (remember the rule set above?) on the line on which the exception occurred. Sometimes the error will be easy to spot.</source>
          <target state="translated">さて、NullReferenceException がスローされた (または処理されなかった)場合、デバッガは例外が発生した行で停止します (上記のルールを覚えていますか?)。時には、エラーを簡単に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="318279d9fb722f810e6e3f50b545a9a0404b55c6" translate="yes" xml:space="preserve">
          <source>Null operators: Null Coalescing operator and null conditional operators can also be used in handy while setting values to objects, variables, properties and fields.</source>
          <target state="translated">ヌル演算子。Null合体演算子とNULL条件演算子は、オブジェクト、変数、プロパティ、フィールドに値を設定する際にも便利に使用できます。</target>
        </trans-unit>
        <trans-unit id="2eb936c96dfd3a82cf681dcf1e453a56150f03fb" translate="yes" xml:space="preserve">
          <source>NullReference Exception &amp;mdash; Visual Basic</source>
          <target state="translated">NullReference例外&amp;mdash; Visual Basic</target>
        </trans-unit>
        <trans-unit id="108a53e72c1b0456c7d04a8155e32546371f242d" translate="yes" xml:space="preserve">
          <source>NullReferenceException arises due to our fault for not checking the object&amp;rsquo;s value. We often leave the object values unchecked in the code development.</source>
          <target state="translated">NullReferenceExceptionは、オブジェクトの値をチェックしないというフォールトが原因で発生します。 多くの場合、コード開発ではオブジェクト値をオフのままにします。</target>
        </trans-unit>
        <trans-unit id="b5713cc5880d61c8ee4043a97acf6d784d345341" translate="yes" xml:space="preserve">
          <source>NullReferenceException or Object reference not set to an instance of an object occurs when an object of the class you are trying to use is not instantiated.
For example:</source>
          <target state="translated">NullReferenceException またはオブジェクトのインスタンスにオブジェクト参照が設定されていない場合は、使用しようとしているクラスのオブジェクトがインスタンス化されていない場合に発生します。例えば、以下のような場合に発生します。</target>
        </trans-unit>
        <trans-unit id="498d55bb5d750bf94a55e680251545631183f0ad" translate="yes" xml:space="preserve">
          <source>NullReferenceException won't occur if we are using Value type members.</source>
          <target state="translated">Value型のメンバを使用している場合は、NullReferenceExceptionは発生しません。</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">数値型</target>
        </trans-unit>
        <trans-unit id="3390ab1994cf8aa916e3506c4916e33bb1871966" translate="yes" xml:space="preserve">
          <source>Object Paths / Nested</source>
          <target state="translated">オブジェクトパスのネスト</target>
        </trans-unit>
        <trans-unit id="dfefbee8fa51c19a77377fdc99c6d1e91ac2ebb8" translate="yes" xml:space="preserve">
          <source>Object reference not set to an instance of an object.</source>
          <target state="translated">オブジェクトのインスタンスにオブジェクト参照が設定されていません。</target>
        </trans-unit>
        <trans-unit id="ffdbed86f65d9327dc3308e8c7e0ebc6a5dd365d" translate="yes" xml:space="preserve">
          <source>Object variables which are &lt;strong&gt;uninitialized&lt;/strong&gt; and hence &lt;strong&gt;point to nothing.&lt;/strong&gt; In this case, if you access properties or methods of such objects, it causes a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;初期化さ&lt;/strong&gt;れて&lt;strong&gt;いない&lt;/strong&gt;ため&lt;strong&gt;に何もポイントしない&lt;/strong&gt;オブジェクト変数&lt;strong&gt;。&lt;/strong&gt; この場合、そのようなオブジェクトのプロパティまたはメソッドにアクセスすると、 &lt;code&gt;NullReferenceException&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="9f9388be3a14ac2bf1c68c14b6f7c7b0ba00f598" translate="yes" xml:space="preserve">
          <source>Of course, you &lt;em&gt;still&lt;/em&gt; have to check &lt;code&gt;title&lt;/code&gt; for null or use the null condition operator together with the null coalescing operator (&lt;code&gt;??&lt;/code&gt;) to supply a default value:</source>
          <target state="translated">もちろん、 &lt;code&gt;title&lt;/code&gt; のnullを確認するか、null条件演算子とnull結合演算子（ &lt;code&gt;??&lt;/code&gt; ）を使用してデフォルト値を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fa4b5d0f97e6455028a59f1925e67775d0a3150f" translate="yes" xml:space="preserve">
          <source>On the matter of &lt;strong&gt;&quot;what should I do about it&quot;&lt;/strong&gt;, there can be many answers.</source>
          <target state="translated">&lt;strong&gt;「どうすればいいか」については&lt;/strong&gt; 、答えがたくさんあります。</target>
        </trans-unit>
        <trans-unit id="3d646273973e4205570d72f3076fd5fc36ee3360" translate="yes" xml:space="preserve">
          <source>Once &lt;em&gt;where&lt;/em&gt; the exception is throw has been located, it's usually trivial to reason backwards to find out where the null value was [incorrectly] introduced --</source>
          <target state="translated">例外がスローされた場所が特定されると、通常、null値が[誤って]導入された場所を逆に推論するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="2a462199e4fdd6a0af25f3adcac4accc6d33e906" translate="yes" xml:space="preserve">
          <source>Once you know what and where the problem is, it is usually fairly easy to fix and faster than posting a new question.</source>
          <target state="translated">問題が何で、どこにあるのかがわかれば、通常はかなり簡単に解決でき、新しい質問を投稿するよりも早いです。</target>
        </trans-unit>
        <trans-unit id="ae6cb7569ada63bc2d3e163016b98bc806afea38" translate="yes" xml:space="preserve">
          <source>One example of this is this simple ASP.NET binding fragment with the Calendar control:</source>
          <target state="translated">その一例として、CalendarコントロールとのシンプルなASP.NETバインディングフラグメントがあります。</target>
        </trans-unit>
        <trans-unit id="79a8436face2b533d827001515951269d4bfb9b3" translate="yes" xml:space="preserve">
          <source>Only reference types, as the name is suggesting, can hold references or point literally to nothing (or 'null'). Whereas value types always contain a value.</source>
          <target state="translated">名前が示唆しているように、参照型だけが、参照を保持したり、文字通り何も指し示していない(または 'null' を指す)ことができます。一方、値の型には常に値が含まれています。</target>
        </trans-unit>
        <trans-unit id="025911f6c7d528b21a46faf9fcb9c34232aa12fe" translate="yes" xml:space="preserve">
          <source>Option Infer Statement</source>
          <target state="translated">オプションインファー文</target>
        </trans-unit>
        <trans-unit id="f179578c51c822eb1fb66acea0ac9ffb6979808e" translate="yes" xml:space="preserve">
          <source>Or you can always code your own approach using plain old code. For example here is a struct that you can use to catch null references. It's modeled after the same concept as &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">または、プレーンな古いコードを使用して、いつでも独自のアプローチをコーディングできます。 たとえば、次の例は、null参照をキャッチするために使用できる構造体です。 &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; と同じコンセプトに基づいてモデル化されています 。</target>
        </trans-unit>
        <trans-unit id="1b22ef513641d8af3ca046740205bbee48335bff" translate="yes" xml:space="preserve">
          <source>Or you can even use it when the method just returns &lt;code&gt;T&lt;/code&gt; (in this case &lt;code&gt;Person&lt;/code&gt;) by doing a cast. For example, the following code would just like the code above:</source>
          <target state="translated">または、メソッドがキャストを実行して &lt;code&gt;T&lt;/code&gt; （この場合は &lt;code&gt;Person&lt;/code&gt; ）を返すだけの場合にも使用できます。 たとえば、次のコードは上記のコードと同じです。</target>
        </trans-unit>
        <trans-unit id="c9a30ba5e221a0e082315c528b339ab02883ea86" translate="yes" xml:space="preserve">
          <source>Otherwise, the variable name will be assigned the value of the p.Spouse.FirstName.</source>
          <target state="translated">そうでなければ、変数名にはp.Spouse.FirstNameの値が代入されます。</target>
        </trans-unit>
        <trans-unit id="350349ce41ad9ae3414e0ee6f0cc9d8fdd70adfe" translate="yes" xml:space="preserve">
          <source>Poorly Implemented Try/Catch</source>
          <target state="translated">実装が不十分なTryCatch</target>
        </trans-unit>
        <trans-unit id="cf56bb150b35de64b7d13c5c15cc44a04165e6c6" translate="yes" xml:space="preserve">
          <source>Possibly, other code prematurely invalidated an object still in use</source>
          <target state="translated">他のコードがまだ使用中のオブジェクトを早期に無効にした可能性があります。</target>
        </trans-unit>
        <trans-unit id="49dadac90d9e655d655da0a9465c937e3e41e55d" translate="yes" xml:space="preserve">
          <source>Range Variable (Indirect/Deferred)</source>
          <target state="translated">範囲変数(IndirectDeferred</target>
        </trans-unit>
        <trans-unit id="7bbbd80923d138130436a31cdb61e2a69e969c03" translate="yes" xml:space="preserve">
          <source>Rather than indirect references by name using the form's &lt;code&gt;Controls&lt;/code&gt; collection, use the control reference:</source>
          <target state="translated">フォームの &lt;code&gt;Controls&lt;/code&gt; コレクションを使用した名前による間接参照ではなく、コントロール参照を使用します。</target>
        </trans-unit>
        <trans-unit id="517a0d09eeac328a5dcd1752d817bf8b7bd38630" translate="yes" xml:space="preserve">
          <source>Referencing array elements later will result in an NRE. If you do this in &lt;code&gt;Form_Load&lt;/code&gt;, due to an odd bug, the IDE &lt;em&gt;may not&lt;/em&gt; report the exception when it happens. The exception will pop up &lt;em&gt;later&lt;/em&gt; when your code tries to use the array. This &quot;silent exception&quot; is &lt;a href=&quot;https://stackoverflow.com/a/4934010/1070452&quot;&gt;detailed in this post&lt;/a&gt;. For our purposes, the key is that when something catastrophic happens while creating a form (&lt;code&gt;Sub New&lt;/code&gt; or &lt;code&gt;Form Load&lt;/code&gt; event), exceptions may go unreported, the code exits the procedure and just displays the form.</source>
          <target state="translated">後で配列要素を参照すると、NREになります。 これを &lt;code&gt;Form_Load&lt;/code&gt; で行うと、奇妙なバグが原因で、IDE &lt;em&gt;は&lt;/em&gt;例外が発生したときに例外を報告し&lt;em&gt;ない&lt;/em&gt;場合があります。 コードが配列を使用しようとすると、例外が&lt;em&gt;後で&lt;/em&gt;ポップアップします。 この「サイレント例外」 &lt;a href=&quot;https://stackoverflow.com/a/4934010/1070452&quot;&gt;については、この投稿で詳しく説明してい&lt;/a&gt;ます。 私たちの目的にとって重要なのは、フォームの作成中に致命的な事態（ &lt;code&gt;Sub New&lt;/code&gt; または &lt;code&gt;Form Load&lt;/code&gt; イベント）が発生すると、例外が報告されず、コードがプロシージャを終了してフォームを表示することです。</target>
        </trans-unit>
        <trans-unit id="d7961680dc43f2fb54210f44d5d5893f415a97ea" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;Exit Function&lt;/code&gt; in the function with &lt;code&gt;Return bList&lt;/code&gt;. Returning an &lt;em&gt;empty&lt;/em&gt;&lt;code&gt;List&lt;/code&gt; is not the same as returning &lt;code&gt;Nothing&lt;/code&gt;. If there is a chance that a returned object can be &lt;code&gt;Nothing&lt;/code&gt;, test before using it:</source>
          <target state="translated">&lt;code&gt;Exit Function&lt;/code&gt; を &lt;code&gt;Return bList&lt;/code&gt; に置き換えます。 &lt;em&gt;空の&lt;/em&gt; &lt;code&gt;List&lt;/code&gt; 返すことは、 &lt;code&gt;Nothing&lt;/code&gt; を返すことと同じではありません 。 返されたオブジェクトが &lt;code&gt;Nothing&lt;/code&gt; になる可能性がある場合は、使用する前にテストしてください。</target>
        </trans-unit>
        <trans-unit id="e09009f0be2bc5dc475d39c72cbad2457332d844" translate="yes" xml:space="preserve">
          <source>Scope in Visual Basic</source>
          <target state="translated">Visual Basicのスコープ</target>
        </trans-unit>
        <trans-unit id="ec36826e04a6ea83960855360f7576fa1a70dea9" translate="yes" xml:space="preserve">
          <source>See &quot;&lt;a href=&quot;https://stackoverflow.com/questions/19314340/nullreferenceexception-thrown-when-testing-custom-authorizationattribute&quot;&gt;NullReferenceException thrown when testing custom AuthorizationAttribute&lt;/a&gt;&quot; for a somewhat verbose example.</source>
          <target state="translated">やや冗長な例については、「 &lt;a href=&quot;https://stackoverflow.com/questions/19314340/nullreferenceexception-thrown-when-testing-custom-authorizationattribute&quot;&gt;カスタムAuthorizationAttributeのテスト時にスローされるNullReferenceException&lt;/a&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="dee0432b1dfd3821074c0b47888585c85bdf5bb0" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Data.DataTable(v=vs.110).aspx&quot;&gt;DataTable Class&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Data.DataTable(v=vs.110).aspx&quot;&gt;DataTableクラス&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="b81624007a72ba2076c9759224672d60d8e74940" translate="yes" xml:space="preserve">
          <source>Since VB is managing Settings for you, it is reasonable to expect it to initialize the collection. It will, but only if you have previously added an initial entry to the collection (in the Settings editor). Since the collection is (apparently) initialized when an item is added, it remains &lt;code&gt;Nothing&lt;/code&gt; when there are no items in the Settings editor to add.</source>
          <target state="translated">VBが設定を管理しているので、コレクションの初期化を期待するのが妥当です。 ただし、以前に（設定エディターで）コレクションに初期エントリを追加している場合に限ります。 コレクションは（見かけ上）アイテムが追加されるときに初期化されるため、設定エディターに追加するアイテムがない場合、コレクションは &lt;code&gt;Nothing&lt;/code&gt; のままです。</target>
        </trans-unit>
        <trans-unit id="5e1ee4902767b648a32002c3f0eac6e8212d4c61" translate="yes" xml:space="preserve">
          <source>Since no other code in your &lt;code&gt;Sub New&lt;/code&gt; or &lt;code&gt;Form Load&lt;/code&gt; event will run after the NRE, &lt;em&gt;a great many other things&lt;/em&gt; can be left uninitialized.</source>
          <target state="translated">&lt;code&gt;Sub New&lt;/code&gt; イベントまたは &lt;code&gt;Form Load&lt;/code&gt; イベントの他のコードはNREの後に実行されないため、他の&lt;em&gt;多くのもの&lt;/em&gt;を初期化せずに残す&lt;em&gt;こと&lt;/em&gt;ができます。</target>
        </trans-unit>
        <trans-unit id="169ef3e9a5e6d08f8ec9f775f25ef7ca8fe0ba80" translate="yes" xml:space="preserve">
          <source>Since the problem is an object reference which is &lt;code&gt;Nothing&lt;/code&gt;, the answer is to examine them to find out which one. Then determine why it is not initialized. Hold the mouse over the various variables and Visual Studio (VS) will show their values - the culprit will be &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">問題は &lt;code&gt;Nothing&lt;/code&gt; であるオブジェクト参照であるため、答えはそれらを調べてどれを見つけるかです。 次に、初期化されていない理由を判別します。 さまざまな変数の上にマウスを置くと、Visual Studio（VS）がそれらの値を表示します-原因は &lt;code&gt;Nothing&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f5af1e9a2d60a99283e7a7af80fb60c02d4755e0" translate="yes" xml:space="preserve">
          <source>Since this uses one table, using &lt;code&gt;Tables(0)&lt;/code&gt; will avoid spelling errors.  Examining &lt;code&gt;Rows.Count&lt;/code&gt; can also help:</source>
          <target state="translated">これは1つのテーブルを使用するため、 &lt;code&gt;Tables(0)&lt;/code&gt; を使用するとスペルミスを回避できます。 &lt;code&gt;Rows.Count&lt;/code&gt; を調べることも役立ちます：</target>
        </trans-unit>
        <trans-unit id="5fb8e569fb6ed72a6dffcc33b03fceee972649a2" translate="yes" xml:space="preserve">
          <source>So how to tackle this:</source>
          <target state="translated">では、どうやって取り組むか。</target>
        </trans-unit>
        <trans-unit id="0af6f84e1abe20a8c228b77e487571323c47990e" translate="yes" xml:space="preserve">
          <source>So, as a practice we should always use null check, before accessing properties in such objects (specially in generic)</source>
          <target state="translated">そのため、練習として、このようなオブジェクトのプロパティにアクセスする前には、常にヌルチェックを使用する必要があります(特にジェネリックな場合)。</target>
        </trans-unit>
        <trans-unit id="728a2ccae6943f95d4a0778979a96e78b85be334" translate="yes" xml:space="preserve">
          <source>So, if you're dealing with &lt;strong&gt;value types&lt;/strong&gt;, NullReferenceExceptions can &lt;strong&gt;not&lt;/strong&gt; occur. Though you need to keep alert when dealing with &lt;strong&gt;reference types&lt;/strong&gt;!</source>
          <target state="translated">したがって、 &lt;strong&gt;値型&lt;/strong&gt;を処理している&lt;strong&gt;場合&lt;/strong&gt; 、NullReferenceExceptions &lt;strong&gt;は&lt;/strong&gt;発生し&lt;strong&gt;ません&lt;/strong&gt; 。 ただし、 &lt;strong&gt;参照型&lt;/strong&gt;を扱う場合は注意が必要です。</target>
        </trans-unit>
        <trans-unit id="3fef728484bb42f677ee7c22d16e57e13b623b0b" translate="yes" xml:space="preserve">
          <source>Some common scenarios where the exception can be thrown:</source>
          <target state="translated">例外が投げられる一般的なシナリオをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="270f67be70dbe22b11e82aa389399daab08d5ed7" translate="yes" xml:space="preserve">
          <source>Something which your code assumed would initialize an object, did not</source>
          <target state="translated">あなたのコードでは、オブジェクトを初期化すると想定していたものが、初期化されませんでした。</target>
        </trans-unit>
        <trans-unit id="d79169ce047a865f22ceedf2f516d3f6a8bd12b3" translate="yes" xml:space="preserve">
          <source>Something you assumed would perform flawlessly to return an initialized object to your code, did not.</source>
          <target state="translated">あなたのコードに初期化されたオブジェクトを返すために完璧に実行されると仮定したものは、そうではありませんでした。</target>
        </trans-unit>
        <trans-unit id="7b881a3646ad1ece01b3005831c5797e83c52c23" translate="yes" xml:space="preserve">
          <source>Sometimes the boxing happens in another way. For example with this non-generic extension method:</source>
          <target state="translated">時々、別の方法でボクシングが起こることがあります。例えばこの非一般的な拡張方法では</target>
        </trans-unit>
        <trans-unit id="c8202db459212644c10dde57d8e4df666ce482d5" translate="yes" xml:space="preserve">
          <source>Special techniques for debugging and fixing null derefs in iterators</source>
          <target state="translated">イテレータにおけるヌルデフのデバッグと修正のための特別なテクニック</target>
        </trans-unit>
        <trans-unit id="0fbbe68dcced5d9fa19046eaf6118ab8f81482e2" translate="yes" xml:space="preserve">
          <source>Specifically, in &lt;code&gt;HttpContext.Current.User.Identity.Name&lt;/code&gt;, the &lt;code&gt;HttpContext.Current&lt;/code&gt; could be null, or the &lt;code&gt;User&lt;/code&gt; property could be null, or the &lt;code&gt;Identity&lt;/code&gt; property could be null.</source>
          <target state="translated">具体的には、 &lt;code&gt;HttpContext.Current.User.Identity.Name&lt;/code&gt; では、 &lt;code&gt;HttpContext.Current&lt;/code&gt; がnullであるか、 &lt;code&gt;User&lt;/code&gt; プロパティがnullであるか、 &lt;code&gt;Identity&lt;/code&gt; プロパティがnullである可能性があります。</target>
        </trans-unit>
        <trans-unit id="f5dea8e13e62a3f32c925f340dc736efda53d43f" translate="yes" xml:space="preserve">
          <source>Suppose I have a class and member method in it. I have not instantiated my class but only named my class. Now if I try to use the method, the compiler will throw an error or issue a warning (depending on the compiler).</source>
          <target state="translated">私がクラスとその中のメンバーメソッドを持っているとします。私は自分のクラスをインスタンス化していませんが、自分のクラスの名前を付けただけです。このメソッドを使おうとすると、コンパイラがエラーを出したり、警告を出したりします(コンパイラによります)。</target>
        </trans-unit>
        <trans-unit id="a9bfffacd695cafe387b5dba29e8a53f54d17c9a" translate="yes" xml:space="preserve">
          <source>Suppose you have a web form Contact.aspx whose codebehind class is Contact and you have an entity name Contact.</source>
          <target state="translated">WebフォームContact.aspxのコードバインドクラスがContactで、エンティティ名がContactであるとします。</target>
        </trans-unit>
        <trans-unit id="a32dcf6bc661323f00cb04b17bca14992a13218c" translate="yes" xml:space="preserve">
          <source>System.NullReferenceException: Object reference not set to an instance
  of an object. at Program.Main()</source>
          <target state="translated">System.NullReferenceException.オブジェクト参照がオブジェクトのインスタンスに設定されていません。</target>
        </trans-unit>
        <trans-unit id="61b52702efd8978d72bc6dd4556000b0c5302229" translate="yes" xml:space="preserve">
          <source>Take the time required to understand the cause of the exception. Inspect for null expressions. Inspect the previous expressions which could have resulted in such null expressions. Add &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/ktf38f66(v=vs.90)&quot;&gt;breakpoints&lt;/a&gt; and step through the program as appropriate. &lt;em&gt;Use the debugger.&lt;/em&gt;</source>
          <target state="translated">例外の原因を理解するのに必要な時間をかけてください。 null式を検査します。 そのようなnull式をもたらす可能性があった前の式を調べます。 &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/ktf38f66(v=vs.90)&quot;&gt;ブレークポイント&lt;/a&gt;を追加し、必要に応じてプログラムをステップ実行します。 &lt;em&gt;デバッガーを使用します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96355bac807e2bf7c816f87187a186dfb05609b3" translate="yes" xml:space="preserve">
          <source>That is, make a private helper method that has the iterator block logic, and a public surface method that does the null check and returns the iterator.  Now when &lt;code&gt;GetFrobs&lt;/code&gt; is called, the null check happens immediately, and then &lt;code&gt;GetFrobsForReal&lt;/code&gt; executes when the sequence is iterated.</source>
          <target state="translated">つまり、イテレータブロックロジックを持つプライベートヘルパーメソッドと、nullチェックを実行してイテレータを返すパブリックサーフェスメソッドを作成します。 &lt;code&gt;GetFrobs&lt;/code&gt; が呼び出されるとすぐにnullチェックが発生し、シーケンスが反復されるときに &lt;code&gt;GetFrobsForReal&lt;/code&gt; が実行されます。</target>
        </trans-unit>
        <trans-unit id="c98e5a07997fb98921d015b9962a6fe887151a12" translate="yes" xml:space="preserve">
          <source>That means if any member which doesn&amp;rsquo;t hold any value and we are making that member to perform certain task then the system will undoubtedly toss a message and say-</source>
          <target state="translated">つまり、値を保持していないメンバーがあり、そのメンバーに特定のタスクを実行させている場合、システムは間違いなくメッセージを投げて、</target>
        </trans-unit>
        <trans-unit id="cd6b57e6915e732c6a3454d47a45928771b568d1" translate="yes" xml:space="preserve">
          <source>That will throw the error because while I've declared the variable &quot;&lt;code&gt;connection&lt;/code&gt;&quot;, it's not pointed to anything. When I try to call the member &quot;&lt;code&gt;Open&lt;/code&gt;&quot;, there's no reference for it to resolve, and it will throw the error.</source>
          <target state="translated">変数 &quot; &lt;code&gt;connection&lt;/code&gt; &quot;を宣言しているのに、何も指定されていないため、エラーが発生します。 メンバーを「 &lt;code&gt;Open&lt;/code&gt; 」と呼び出そうとすると、解決するための参照がなく、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="af16544bdee6b293bf4ee765cfb10b13b80b318a" translate="yes" xml:space="preserve">
          <source>That's why dereferencing both a null pointer and a null reference produces the same exception.</source>
          <target state="translated">NULLポインタとNULL参照の両方を参照解除しても同じ例外が発生するのはそのためです。</target>
        </trans-unit>
        <trans-unit id="832f18980c9adec58ccfc7eafce613c988307af0" translate="yes" xml:space="preserve">
          <source>The .NET runtime will throw a NullReferenceException when you attempt to perform an action on something which hasn't been instantiated i.e. the code above.</source>
          <target state="translated">.NET ランタイムは、インスタンス化されていないもの、つまり上記のコードに対してアクションを実行しようとすると、NullReferenceException をスローします。</target>
        </trans-unit>
        <trans-unit id="26534d5f78e239955916af7b305fc5b41ba2ea2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DataAdapter&lt;/code&gt; will provide &lt;code&gt;TableNames&lt;/code&gt; as shown in the previous example, but it does not parse names from the SQL or database table. As a result, &lt;code&gt;ds.Tables(&quot;TICKET_RESERVATION&quot;)&lt;/code&gt; references a non-existent table.</source>
          <target state="translated">&lt;code&gt;DataAdapter&lt;/code&gt; は、前の例に示すように &lt;code&gt;TableNames&lt;/code&gt; を提供しますが、SQLまたはデータベーステーブルからの名前を解析しません。 その結果、 &lt;code&gt;ds.Tables(&quot;TICKET_RESERVATION&quot;)&lt;/code&gt; は存在しないテーブルを参照します。</target>
        </trans-unit>
        <trans-unit id="4e757d5d15663001bb33deeec07e2827ba5bd3a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsDBNull&lt;/code&gt; function is used to test if a &lt;em&gt;value&lt;/em&gt; equals &lt;code&gt;System.DBNull&lt;/code&gt;:  &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/tckcces5(v=vs.90)&quot;&gt;From MSDN:&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;IsDBNull&lt;/code&gt; 関数は、 &lt;em&gt;値&lt;/em&gt;が &lt;code&gt;System.DBNull&lt;/code&gt; と等しいかどうかをテストするために使用され&lt;em&gt;ます&lt;/em&gt; &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/tckcces5(v=vs.90)&quot;&gt;。MSDNから：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b413c4771f93ecdb1da4953c33951691d69e4d43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;New&lt;/code&gt; operator can often be used to create the instance when you declare it:</source>
          <target state="translated">&lt;code&gt;New&lt;/code&gt; 演算子は、宣言時にインスタンスを作成するためによく使用されます。</target>
        </trans-unit>
        <trans-unit id="40dbae9f26db30254b9c9f1a9df041f25f4ae4cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NullReference Exception&lt;/code&gt; for &lt;strong&gt;Visual Basic&lt;/strong&gt; is no different from the one in &lt;strong&gt;C#&lt;/strong&gt;. After all, they are both reporting the same exception defined in the .NET Framework which they both use. Causes unique to Visual Basic are rare (perhaps only one).</source>
          <target state="translated">&lt;strong&gt;Visual Basic&lt;/strong&gt;の &lt;code&gt;NullReference Exception&lt;/code&gt; は、 &lt;strong&gt;C＃の&lt;/strong&gt; 例外と同じです。 結局のところ、どちらも.NET Frameworkで定義されている同じ例外を報告しており、どちらも使用しています。 Visual Basicに固有の原因はまれです（おそらく1つのみ）。</target>
        </trans-unit>
        <trans-unit id="20d435cc2ffcce4a30d45f389b288f97cfa9298a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new Person&lt;/code&gt; only creates an instance of &lt;code&gt;Person&lt;/code&gt;, but the &lt;code&gt;Books&lt;/code&gt; collection is still &lt;code&gt;null&lt;/code&gt;. The collection &lt;code&gt;Initializer&lt;/code&gt; syntax does not create a collection
for &lt;code&gt;p1.Books&lt;/code&gt;, it only translates to the &lt;code&gt;p1.Books.Add(...)&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;new Person&lt;/code&gt; は &lt;code&gt;Person&lt;/code&gt; のインスタンスを作成するだけですが、 &lt;code&gt;Books&lt;/code&gt; コレクションは依然として &lt;code&gt;null&lt;/code&gt; です。 コレクション &lt;code&gt;Initializer&lt;/code&gt; 構文は、 &lt;code&gt;p1.Books&lt;/code&gt; のコレクションを作成せず、 &lt;code&gt;p1.Books.Add(...)&lt;/code&gt; ステートメントに変換するだけです。</target>
        </trans-unit>
        <trans-unit id="e0b42fc2efda212a3943ac23d1a88e3d1f5590dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runtime&lt;/code&gt; throwing a &lt;code&gt;NullReferenceException&lt;/code&gt;&lt;strong&gt;always&lt;/strong&gt; means the same thing: you are trying to use a reference, and the reference is not initialized (or it was &lt;em&gt;once&lt;/em&gt; initialized, but is &lt;em&gt;no longer&lt;/em&gt; initialized).</source>
          <target state="translated">&lt;code&gt;runtime&lt;/code&gt; が &lt;code&gt;NullReferenceException&lt;/code&gt; をスローすることは、 &lt;strong&gt;常に&lt;/strong&gt;同じことを意味します。参照を使用しようとしているが、参照が初期化されていない（または、 &lt;em&gt;一度&lt;/em&gt;初期化されたが、初期化されてい&lt;em&gt;ない&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="49a69af3cb15571971e9fd0f2918ddd41cf47307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;somevar&lt;/code&gt; assignment will result in an immediate NRE because Nothing doesn't have a &lt;code&gt;.Text&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;somevar&lt;/code&gt; の割り当てでは、 &lt;code&gt;.Text&lt;/code&gt; プロパティがないため、NREがすぐに発生します。</target>
        </trans-unit>
        <trans-unit id="6d5d5590cc424a0742ec3b68941443b7a51567cc" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Remedy&lt;/strong&gt; is the same, reference the table by index:</source>
          <target state="translated">&lt;strong&gt;対処法&lt;/strong&gt;は同じで、インデックスでテーブルを参照します。</target>
        </trans-unit>
        <trans-unit id="3040c6289873dac88d88f00dfa3143d8958589ea" translate="yes" xml:space="preserve">
          <source>The Array will contain five elements of Nothing</source>
          <target state="translated">配列には、Nothingの5つの要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="27ceb372d3a055414ac4ebce858ea4ad711a0987" translate="yes" xml:space="preserve">
          <source>The DGV has a few quirks seen periodically:</source>
          <target state="translated">DGVには定期的に見られるいくつかのクセがあります。</target>
        </trans-unit>
        <trans-unit id="c70e919024ee1fab6a7f20fb2647ea7464472447" translate="yes" xml:space="preserve">
          <source>The DataGridView</source>
          <target state="translated">DataGridView</target>
        </trans-unit>
        <trans-unit id="ef89f949d60a7ce3ba16474314cece6c25c1b417" translate="yes" xml:space="preserve">
          <source>The System.DBNull value indicates that the Object represents missing or non-existent data. DBNull is not the same as Nothing, which indicates that a variable has not yet been initialized.</source>
          <target state="translated">System.DBNull 値は、オブジェクトが存在しない、または存在しないデータを表していることを示します。DBNullは、変数がまだ初期化されていないことを示すNothingとは異なります。</target>
        </trans-unit>
        <trans-unit id="3fab983167187e8d3c1de769d9fd8889b4da2253" translate="yes" xml:space="preserve">
          <source>The above code shows simple string which is assigned with a &lt;strong&gt;null&lt;/strong&gt; value.</source>
          <target state="translated">上記のコードは、 &lt;strong&gt;null&lt;/strong&gt;値が割り当てられた単純な文字列を示してい&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="17d03251d7278b73c29dd924064c9cb221dda373" translate="yes" xml:space="preserve">
          <source>The array code may not be out of the woods yet. Any controls which are in a container control (like a &lt;code&gt;GroupBox&lt;/code&gt; or &lt;code&gt;Panel&lt;/code&gt;) will not be found in &lt;code&gt;Me.Controls&lt;/code&gt;; they will be in the Controls collection of that Panel or GroupBox. Nor will a control be returned when the control name is misspelled (&lt;code&gt;&quot;TeStBox2&quot;&lt;/code&gt;). In such cases, &lt;code&gt;Nothing&lt;/code&gt; will again be stored in those array elements and an NRE will result when you attempt to reference it.</source>
          <target state="translated">配列コードはまだ森から出ていないかもしれません。 コンテナコントロール（ &lt;code&gt;GroupBox&lt;/code&gt; や &lt;code&gt;Panel&lt;/code&gt; など ）にあるコントロールは、 Me.Controlsにはありません。 それらは、そのPanelまたはGroupBoxのControlsコレクションに含まれます。 また、コントロール名のスペルが間違っていても、コントロールは返されません（ &lt;code&gt;&quot;TeStBox2&quot;&lt;/code&gt; ）。 このような場合、これらの配列要素には何も格納されず、参照しようとするとNREが発生します。</target>
        </trans-unit>
        <trans-unit id="9152dbff2da4b545031d214da21c705228394a13" translate="yes" xml:space="preserve">
          <source>The array has been created, but the &lt;code&gt;Foo&lt;/code&gt; objects in it have not.</source>
          <target state="translated">配列は作成されましたが、その中の &lt;code&gt;Foo&lt;/code&gt; オブジェクトは作成されていません。</target>
        </trans-unit>
        <trans-unit id="503f97cf7bd74b54164bcdafbce1e18337fefeac" translate="yes" xml:space="preserve">
          <source>The code is only testing &lt;code&gt;Items&lt;/code&gt; while both &lt;code&gt;myFoo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; may also be Nothing. The &lt;strong&gt;remedy&lt;/strong&gt; is to test the entire chain or path of objects one at a time:</source>
          <target state="translated">コードは &lt;code&gt;Items&lt;/code&gt; をテストするだけですが、 &lt;code&gt;myFoo&lt;/code&gt; と &lt;code&gt;Bar&lt;/code&gt; の両方がNothingの場合もあります。 &lt;strong&gt;対策&lt;/strong&gt;は、オブジェクトのチェーン全体またはパスを一度に1つずつテストすることです。</target>
        </trans-unit>
        <trans-unit id="463bfd62c8f05004461fb5a31b8995846405c429" translate="yes" xml:space="preserve">
          <source>The constructor for the &lt;code&gt;ArgumentNullException&lt;/code&gt; even takes the name of the parameter and a message as arguments so you can tell the developer exactly what the problem is.</source>
          <target state="translated">&lt;code&gt;ArgumentNullException&lt;/code&gt; のコンストラクターは、パラメーターの名前とメッセージを引数として取り、開発者に問題が何であるかを正確に伝えることができます。</target>
        </trans-unit>
        <trans-unit id="3316f1a701fde7c120bf71968a77f55f36491fce" translate="yes" xml:space="preserve">
          <source>The correct fix is:</source>
          <target state="translated">正しい修正方法は</target>
        </trans-unit>
        <trans-unit id="1294e0c3d65f0d8b731cd2b09629341a194dc6ce" translate="yes" xml:space="preserve">
          <source>The data Type and array size are inferred from the data being assigned. Class/Module level declarations still require &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; with &lt;code&gt;Option Strict&lt;/code&gt;:</source>
          <target state="translated">データタイプと配列サイズは、割り当てられているデータから推測されます。 クラス/モジュールレベルの宣言には、 &lt;code&gt;Option Strict&lt;/code&gt; した &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="0a67859648408e02bf57b5242710673d9d105f41" translate="yes" xml:space="preserve">
          <source>The developer is &lt;strong&gt;using &lt;code&gt;null&lt;/code&gt; intentionally to indicate there is no meaningful value available.&lt;/strong&gt; Note that C# has the concept of nullable datatypes for variables (like database tables can have nullable fields) - you can assign &lt;code&gt;null&lt;/code&gt; to them to indicate there is no value stored in it, for example &lt;code&gt;int? a = null;&lt;/code&gt; where the question mark indicates it is allowed to store null in variable &lt;code&gt;a&lt;/code&gt;. You can check that either with &lt;code&gt;if (a.HasValue) {...}&lt;/code&gt; or with &lt;code&gt;if (a==null) {...}&lt;/code&gt;. Nullable variables, like &lt;code&gt;a&lt;/code&gt; this example, allow to access the value via &lt;code&gt;a.Value&lt;/code&gt; explicitly, or just as normal via &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">開発者は&lt;strong&gt;、意図的に &lt;code&gt;null&lt;/code&gt; を使用して、使用できる意味のある値がないことを示しています。&lt;/strong&gt; C＃には変数のnull許容データ型の概念があります（データベーステーブルはnull許容フィールドを持つことができるなど）-変数に &lt;code&gt;null&lt;/code&gt; を割り当てて、値が格納されていないことを示すことができます（例： &lt;code&gt;int? a = null;&lt;/code&gt; a = null; 疑問符は、変数 &lt;code&gt;a&lt;/code&gt; に nullを格納できることを示しています。 &lt;code&gt;if (a.HasValue) {...}&lt;/code&gt; または &lt;code&gt;if (a==null) {...}&lt;/code&gt; いずれかで確認できます 。 この例のようなnull可能な変数は、 &lt;code&gt;a.Value&lt;/code&gt; を介して明示的に、または。</target>
        </trans-unit>
        <trans-unit id="45a964d78da459f6bbd37b8cd232d3a6efef6380" translate="yes" xml:space="preserve">
          <source>The error line &quot;Object reference not set to an instance of an object.
&quot; states that you have not assigned instance object to a object reference and still you are accessing properies/methods of that object.</source>
          <target state="translated">オブジェクト参照がオブジェクトのインスタンスに設定されていません。&quot;は、オブジェクト参照にインスタンスオブジェクトを代入していないのに、そのオブジェクトの properiesmethods にアクセスしていることを示しています。</target>
        </trans-unit>
        <trans-unit id="a400e3953b7fb9b7c815f1ce88a4ab2b01f595e6" translate="yes" xml:space="preserve">
          <source>The error occurs when both the entity and codebehind class are in same namespace.
To fix this, rename the entity class or the codebehind class for Contact.aspx.</source>
          <target state="translated">エンティティクラスとコードバインドクラスが同じ名前空間にある場合にエラーが発生します。これを修正するには、Contact.aspxのエンティティクラスまたはコードバインドクラスの名前を変更してください。</target>
        </trans-unit>
        <trans-unit id="895203d5cc7b55ecb7ef70317a104cba1837e261" translate="yes" xml:space="preserve">
          <source>The examples (from Stack&amp;nbsp; Overflow posts) do not always show the best way to do something in the first place.</source>
          <target state="translated">（Stack Overflowの投稿からの）例は、最初から何かを行うための最良の方法を常に示しているわけではありません。</target>
        </trans-unit>
        <trans-unit id="d1d89f5634b915a9e16a0aaaf5998b7a175005a7" translate="yes" xml:space="preserve">
          <source>The exception error is:</source>
          <target state="translated">例外エラーになっています。</target>
        </trans-unit>
        <trans-unit id="4dabb60bda5cb5e73ecf06dcad355e8e1b245e9c" translate="yes" xml:space="preserve">
          <source>The exception itself says that something is being referred but whose value is not being set. So this denotes that it only occurs while using reference types as Value types are non-nullable.</source>
          <target state="translated">この例外自体は、何かが参照されているが、その値が設定されていないことを示しています。つまり、これは値の型が非 null 型であるため、参照型を使用している場合にのみ発生することを示しています。</target>
        </trans-unit>
        <trans-unit id="06815801582cc6befb5ef98b61f02e87744088ac" translate="yes" xml:space="preserve">
          <source>The hardest one .. if the &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;GC&lt;/a&gt;&lt;/strong&gt; collected the object already... This generally occurs if you are trying to find an object using strings... That is, finding it by name of the object then it may happen that the GC might already cleaned it up... This is hard to find and will become quite a problem... A better way to tackle this is do null checks wherever necessary during the development process. This will save you a lot of time.</source>
          <target state="translated">最も難しいもの.. &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;GC&lt;/a&gt;&lt;/strong&gt;がオブジェクトを既に収集している場合...これは一般に、文字列を使用してオブジェクトを検索しようとしている場合に発生します...つまり、オブジェクトの名前でオブジェクトを検索すると、GCがすでに発生している可能性があります。クリーンアップしました...これは見つけるのが難しく、かなり問題になります...これに取り組むためのより良い方法は、開発プロセス中に必要に応じてnullチェックを実行することです。 これにより、多くの時間を節約できます。</target>
        </trans-unit>
        <trans-unit id="6fe9c46a1f96250f3a78f255ee7a539166e5eefe" translate="yes" xml:space="preserve">
          <source>The message &lt;em&gt;&quot;Object not set to an instance of Object&quot;&lt;/em&gt; means you are trying to use an object which has not been initialized. This boils down to one of these:</source>
          <target state="translated">&lt;em&gt;「オブジェクトがオブジェクトのインスタンスに設定されていません」&lt;/em&gt;というメッセージは、初期化されていないオブジェクトを使用しようとしていることを意味します。 これは、次のいずれかに要約されます。</target>
        </trans-unit>
        <trans-unit id="7e3ca54b85861772b0461d9717c527d72a64967f" translate="yes" xml:space="preserve">
          <source>The nested collection &lt;code&gt;Initializers&lt;/code&gt; behave the same:</source>
          <target state="translated">ネストされたコレクションの &lt;code&gt;Initializers&lt;/code&gt; は同じように動作します。</target>
        </trans-unit>
        <trans-unit id="90aa4a0c7a11c901e2c17878dabdd430757e21cc" translate="yes" xml:space="preserve">
          <source>The nullable annotation context and nullable warning context can be set for a project using the &lt;code&gt;Nullable&lt;/code&gt; element in your &lt;code&gt;csproj&lt;/code&gt; file. This element configures how the compiler interprets the nullability of types and what warnings are generated. Valid settings are:</source>
          <target state="translated">nullsableアノテーションコンテキストとnullable警告コンテキストは、 &lt;code&gt;csproj&lt;/code&gt; ファイルの &lt;code&gt;Nullable&lt;/code&gt; 要素を使用してプロジェクトに設定できます。 この要素は、コンパイラーが型のNULL可能性を解釈する方法と生成される警告を構成します。 有効な設定は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a10b33de1b42bbbc51b19833cb2f573dc939676f" translate="yes" xml:space="preserve">
          <source>The plain versions &lt;code&gt;First()&lt;/code&gt; and &lt;code&gt;Single()&lt;/code&gt; throw exceptions when there is nothing. The &quot;OrDefault&quot; versions return null in that case. So be aware of that.</source>
          <target state="translated">プレーンバージョンの &lt;code&gt;First()&lt;/code&gt; および &lt;code&gt;Single()&lt;/code&gt; は、何もないときに例外をスローします。 その場合、「OrDefault」バージョンはnullを返します。 ですので注意してください。</target>
        </trans-unit>
        <trans-unit id="ca0d4b830b1ca78cc1cd2b85b0b059562a5a92dc" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;Dim&lt;/code&gt; does not create a CashRegister &lt;em&gt;object&lt;/em&gt;; it only declares a variable named &lt;code&gt;reg&lt;/code&gt; of that Type. &lt;em&gt;Declaring&lt;/em&gt; an object variable and creating an &lt;em&gt;instance&lt;/em&gt; are two different things.</source>
          <target state="translated">問題は、 &lt;code&gt;Dim&lt;/code&gt; がCashRegister &lt;em&gt;オブジェクトを&lt;/em&gt;作成しないことです。 そのタイプの &lt;code&gt;reg&lt;/code&gt; という名前の変数を宣言するだけです。 オブジェクト変数の&lt;em&gt;宣言&lt;/em&gt;と&lt;em&gt;インスタンスの&lt;/em&gt;作成は、2つの異なるものです。</target>
        </trans-unit>
        <trans-unit id="f57a9af331b2b384f5e9bbf25e52891735f99da4" translate="yes" xml:space="preserve">
          <source>The rest of this article goes into more detail and shows mistakes that many programmers often make which can lead to a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">この記事の残りの部分では、より詳細に説明し、多くのプログラマーがよく犯す &lt;code&gt;NullReferenceException&lt;/code&gt; につながる可能性のある間違いを示します。</target>
        </trans-unit>
        <trans-unit id="d27e02a7560754b5c14948489cc1146ab300619d" translate="yes" xml:space="preserve">
          <source>The result is that the name will be null when p is null or when p.Spouse is null.</source>
          <target state="translated">その結果、pがnullの場合は名前がnullになり、p.Spouseがnullの場合は名前がnullになります。</target>
        </trans-unit>
        <trans-unit id="09d1d7d139d2f9ffa7cf279ad2ecc6cf210c00d2" translate="yes" xml:space="preserve">
          <source>The same applies to nested object initializers:</source>
          <target state="translated">入れ子になったオブジェクトのイニシャライザも同様です。</target>
        </trans-unit>
        <trans-unit id="ed30a1778fd31736e38acd0c7306ed44aa097108" translate="yes" xml:space="preserve">
          <source>The shorthand to providing a default value when a &lt;code&gt;null&lt;/code&gt; is encountered:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; が発生したときにデフォルト値を提供するための省略表現：</target>
        </trans-unit>
        <trans-unit id="f4ffd808ec7172797ede1dca01b5953fc219db01" translate="yes" xml:space="preserve">
          <source>Then either &lt;a href=&quot;https://blogs.msdn.microsoft.com/zainnab/2010/11/01/start-debugging-vs-start-without-debugging/&quot;&gt;&lt;em&gt;Start with Debugging (F5)&lt;/em&gt;&lt;/a&gt; or &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/3s68z0b3.aspx&quot;&gt;&lt;em&gt;Attach [the VS Debugger] to Running Process&lt;/em&gt;&lt;/a&gt;. On occasion it may be useful to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.diagnostics.debugger.break(v=vs.110).aspx&quot;&gt;&lt;code&gt;Debugger.Break&lt;/code&gt;&lt;/a&gt;, which will prompt to launch the debugger.</source>
          <target state="translated">次に&lt;a href=&quot;https://blogs.msdn.microsoft.com/zainnab/2010/11/01/start-debugging-vs-start-without-debugging/&quot;&gt;&lt;em&gt;、デバッグから開始（F5）&lt;/em&gt;&lt;/a&gt;または&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/3s68z0b3.aspx&quot;&gt;&lt;em&gt;[VSデバッガ]を実行中のプロセスにアタッチし&lt;/em&gt;&lt;/a&gt;ます。 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.diagnostics.debugger.break(v=vs.110).aspx&quot;&gt; &lt;code&gt;Debugger.Break&lt;/code&gt; &lt;/a&gt;起動を促すDebugger.Breakを使用すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="9cf2c6701fe17f333948c2b1849db6510ba64ad5" translate="yes" xml:space="preserve">
          <source>Then following code will throw a NullReferenceException when you call context.SaveChanges()</source>
          <target state="translated">そうすると、以下のコードは、context.SaveChanges()を呼び出すと NullReferenceException をスローします。</target>
        </trans-unit>
        <trans-unit id="7838ef23cdbcdcb9c6a670f31c478d1f79518c71" translate="yes" xml:space="preserve">
          <source>Then go into your script and type &lt;code&gt;rb = GetComponent&amp;lt;Rigidbody&amp;gt;();&lt;/code&gt;</source>
          <target state="translated">次に、スクリプトに移動して、 &lt;code&gt;rb = GetComponent&amp;lt;Rigidbody&amp;gt;();&lt;/code&gt; と入力します。</target>
        </trans-unit>
        <trans-unit id="ad41fc4e6ef8e0d250fac274fb58d4f833539aab" translate="yes" xml:space="preserve">
          <source>There are also several libraries that can help. &quot;Resharper&quot; for example can provide you with warnings while you are writing code, especially if you use their attribute: &lt;a href=&quot;https://www.jetbrains.com/resharper/help/Reference__Code_Annotation_Attributes.html#NotNullAttribute&quot;&gt;NotNullAttribute&lt;/a&gt;</source>
          <target state="translated">役立つライブラリもいくつかあります。 たとえば、 &quot;Resharper&quot;は、コードを記述しているときに、特にその属性を使用する場合に警告を表示します： &lt;a href=&quot;https://www.jetbrains.com/resharper/help/Reference__Code_Annotation_Attributes.html#NotNullAttribute&quot;&gt;NotNullAttribute&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbf732334378829eb2b72400cdd33b94ea5d2586" translate="yes" xml:space="preserve">
          <source>There are many good answers already here. You can also check more detailed description with examples on my &lt;a href=&quot;https://www.mistercode.net/2017/07/09/object-reference-not-set-to-an-instance-of-an-object/&quot;&gt;blog&lt;/a&gt;.</source>
          <target state="translated">ここにはすでに多くの良い答えがあります。 また、私の&lt;a href=&quot;https://www.mistercode.net/2017/07/09/object-reference-not-set-to-an-instance-of-an-object/&quot;&gt;ブログ&lt;/a&gt;で例を使用して詳細な説明を確認することもできます。</target>
        </trans-unit>
        <trans-unit id="214fa86f68ca654e757c3e720dc78f2dd2fc2749" translate="yes" xml:space="preserve">
          <source>There are various ways and methods to avoid this renowned exception:</source>
          <target state="translated">この有名な例外を避けるためには、様々な方法や方法があります。</target>
        </trans-unit>
        <trans-unit id="be839701a8b58386dc83c43578a529bbcc452e47" translate="yes" xml:space="preserve">
          <source>There is a lot of good answers here explaining what a null reference is and how to debug it. But there is very little on how to prevent the issue or at least make it easier to catch.</source>
          <target state="translated">ここには、ヌル参照とは何か、そしてそれをデバッグする方法を説明する良い回答がたくさんあります。しかし、この問題を防ぐ方法や、少なくともキャッチしやすくする方法についてはほとんど書かれていません。</target>
        </trans-unit>
        <trans-unit id="7dbc715d0df7bdf0cd07c3dbe5ecb31f64abf37a" translate="yes" xml:space="preserve">
          <source>There is an extra comma in the SQL (after 'mailaddress') which results in an exception at &lt;code&gt;.ExecuteReader&lt;/code&gt;. After the &lt;code&gt;Catch&lt;/code&gt; does nothing, &lt;code&gt;Finally&lt;/code&gt; tries to perform clean up, but since you cannot &lt;code&gt;Close&lt;/code&gt; a null &lt;code&gt;DataReader&lt;/code&gt; object, a brand new &lt;code&gt;NullReferenceException&lt;/code&gt; results.</source>
          <target state="translated">SQLの余分なコンマ（ 'mailaddress'の後）があり、 &lt;code&gt;.ExecuteReader&lt;/code&gt; で例外が発生します 。 &lt;code&gt;Catch&lt;/code&gt; が何もしない場合、 &lt;code&gt;Finally&lt;/code&gt; クリーンアップを実行しようとしますが、null &lt;code&gt;DataReader&lt;/code&gt; オブジェクトを &lt;code&gt;Close&lt;/code&gt; ことができないため、新しい &lt;code&gt;NullReferenceException&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="ee30cd268c28ea93084f9a9c56e3288e8f18511d" translate="yes" xml:space="preserve">
          <source>There's &quot;Microsoft Code Contracts&quot; where you use syntax like &lt;code&gt;Contract.Requires(obj != null)&lt;/code&gt; which gives you runtime and compile checking: &lt;a href=&quot;http://www.codeproject.com/Articles/103779/Introducing-Code-Contracts&quot;&gt;Introducing Code Contracts&lt;/a&gt;.</source>
          <target state="translated">「Microsoft Code Contracts」があり、 &lt;code&gt;Contract.Requires(obj != null)&lt;/code&gt; ような構文を使用して、ランタイムとコンパイルのチェックを行うことができます： &lt;a href=&quot;http://www.codeproject.com/Articles/103779/Introducing-Code-Contracts&quot;&gt;コードコントラクトの紹介&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="4586f5d6a7aef8d40083704fd4255e79f766656f" translate="yes" xml:space="preserve">
          <source>There's also &quot;PostSharp&quot; which will allow you to just use attributes like this:</source>
          <target state="translated">こんな感じで属性だけでも使えるようになる「PostSharp」もあります。</target>
        </trans-unit>
        <trans-unit id="35e0b1c03698b5fbfb3417627f45417f72e5c0bb" translate="yes" xml:space="preserve">
          <source>These cases arise because of the special rules the runtime uses when boxing &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; instances.</source>
          <target state="translated">これらのケースは、 &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; インスタンスをボックス化するときにランタイムが使用する特別なルールが原因で発生します。</target>
        </trans-unit>
        <trans-unit id="7c521d1475010ead5d72d575d5eea6c50ec89923" translate="yes" xml:space="preserve">
          <source>These should be easy to find now that you know what you are looking for:</source>
          <target state="translated">これらは、あなたが探しているものを知っている今、簡単に見つけることができるはずです。</target>
        </trans-unit>
        <trans-unit id="4bee35f92a41df1996281dd9bff320d1429a02b9" translate="yes" xml:space="preserve">
          <source>This answer will use Visual Basic terms, syntax, and context. The examples used come from a large number of past Stack&amp;nbsp; Overflow questions. This is to maximize relevance by using the &lt;em&gt;kinds&lt;/em&gt; of situations often seen in posts. A bit more explanation is also provided for those who might need it. An example similar to yours is &lt;em&gt;very&lt;/em&gt; likely listed here.</source>
          <target state="translated">この回答では、Visual Basicの用語、構文、およびコンテキストを使用します。 使用されている例は、過去のスタックオーバーフローに関する多数の質問に基づいています。 これは、投稿でよく見られる状況を使用して関連性を最大化するためです。 それを必要とするかもしれない人々のために、もう少し説明が提供されます。 あなたに似た例がおそらくここにリストされています。</target>
        </trans-unit>
        <trans-unit id="43191fd8397e396ff48392d8f06628560c113ac6" translate="yes" xml:space="preserve">
          <source>This array has only been declared, not created. There are several ways to initialize an array:</source>
          <target state="translated">この配列は宣言されているだけで、作成されていません。配列を初期化する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="eebc527ad8416d09fe4ecd5b2aa132e7cea81190" translate="yes" xml:space="preserve">
          <source>This can be solved by following the convention to prefix fields with an underscore:</source>
          <target state="translated">これは、フィールドの前にアンダースコアを付ける慣習に従うことで解決できます。</target>
        </trans-unit>
        <trans-unit id="801881e44b7fc86f8a4310a9936bccc2fea2500b" translate="yes" xml:space="preserve">
          <source>This doesn't throw an &lt;code&gt;InvalidCastException&lt;/code&gt; but returns a &lt;code&gt;null&lt;/code&gt; when the cast fails (and when &lt;code&gt;someObject&lt;/code&gt; is itself null). So be aware of that.</source>
          <target state="translated">これは &lt;code&gt;InvalidCastException&lt;/code&gt; をスローしませんが、キャストが失敗した場合（および &lt;code&gt;someObject&lt;/code&gt; 自体がnullの場合）は &lt;code&gt;null&lt;/code&gt; を返します。 ですので注意してください。</target>
        </trans-unit>
        <trans-unit id="8fef908ebbf6aa8923a642c4bd0b4053bc545790" translate="yes" xml:space="preserve">
          <source>This is a case of an object not being created as expected, but also demonstrates the counter usefulness of an empty &lt;code&gt;Catch&lt;/code&gt;.</source>
          <target state="translated">これは、オブジェクトが期待どおりに作成されない場合ですが、空の &lt;code&gt;Catch&lt;/code&gt; のカウンターの有用性も示しています。</target>
        </trans-unit>
        <trans-unit id="4e0fb87a39ead3f4c4ab6bccc75cb03367823f34" translate="yes" xml:space="preserve">
          <source>This is a case where the IDE will warn you that '&lt;em&gt;not all paths return a value and a &lt;code&gt;NullReferenceException&lt;/code&gt; may result&lt;/em&gt;'. You can suppress the warning, by replacing &lt;code&gt;Exit Function&lt;/code&gt; with &lt;code&gt;Return Nothing&lt;/code&gt;, but that does not solve the problem. Anything which tries to use the return when &lt;code&gt;someCondition = False&lt;/code&gt; will result in an NRE:</source>
          <target state="translated">これは、IDEが「 &lt;em&gt;すべてのパスが値を返すわけではなく、 &lt;code&gt;NullReferenceException&lt;/code&gt; が発生する可能性&lt;/em&gt;がある」と警告する場合です。 &lt;code&gt;Exit Function&lt;/code&gt; を &lt;code&gt;Return Nothing&lt;/code&gt; に置き換えることで警告を抑制できますが、それでも問題は解決しません。 &lt;code&gt;someCondition = False&lt;/code&gt; ときにreturnを使用しようとすると、NREになります。</target>
        </trans-unit>
        <trans-unit id="0b561450c1d02029fb3ee4e5c3a3347ea45692b7" translate="yes" xml:space="preserve">
          <source>This is a fairly common way to get an NRE. In C#, depending on how it is coded, the IDE will report that &lt;code&gt;Controls&lt;/code&gt; does not exist in the current context, or &quot;cannot reference non-static member&quot;. So, to some extent, this is a VB-only situation. It is also complex because it can result in a failure cascade.</source>
          <target state="translated">これは、NREを取得するためのかなり一般的な方法です。 C＃では、コーディング方法に応じて、IDEは現在のコンテキストに &lt;code&gt;Controls&lt;/code&gt; が存在しない、または「非静的メンバーを参照できない」ことを報告します。 したがって、ある程度、これはVBのみの状況です。 また、カスケードが失敗する可能性があるため、複雑です。</target>
        </trans-unit>
        <trans-unit id="187877ad8cb14ddcbabe75238a1bb7a9668c909a" translate="yes" xml:space="preserve">
          <source>This is also sometimes called the safe navigation or Elvis (after its shape) operator. If the expression on the left side of the operator is null, then the right side will not be evaluated, and null is returned instead. That means cases like this:</source>
          <target state="translated">これは、安全なナビゲーションやエルビス(その形状にちなんだ)演算子と呼ばれることもあります。演算子の左側の式がnullの場合、右側の式は評価されず、代わりにnullが返されます。つまり、このようなケースです。</target>
        </trans-unit>
        <trans-unit id="aa9ada07655b54e9494b58d5ce6297b70d859bb3" translate="yes" xml:space="preserve">
          <source>This is concept-based: there is no code for you to paste into your project. It is intended to help you understand what causes a &lt;code&gt;NullReferenceException&lt;/code&gt; (NRE), how to find it, how to fix it, and how to avoid it. An NRE can be caused many ways so this is unlikely to be your sole encounter.</source>
          <target state="translated">これは概念ベースです。プロジェクトに貼り付けるコードはありません。 これは、 &lt;code&gt;NullReferenceException&lt;/code&gt; （NRE）の原因、その検出方法、修正方法、および回避方法を理解するのに役立つことを目的としています。 NREはさまざまな原因で発生する可能性があるため、これが唯一の遭遇であるとは限りません。</target>
        </trans-unit>
        <trans-unit id="888280c788011247e567ae3ed361d10e659b622d" translate="yes" xml:space="preserve">
          <source>This is why you get a NullReferenceExeption because the computer does not have data stored in that variable.</source>
          <target state="translated">これが、コンピュータがその変数にデータを保存していないために NullReferenceExeption を取得する理由です。</target>
        </trans-unit>
        <trans-unit id="21425312feec06d5937e5aa46a43ef71033a5a70" translate="yes" xml:space="preserve">
          <source>This line of code works best under your &lt;code&gt;Start()&lt;/code&gt; or &lt;code&gt;Awake()&lt;/code&gt; functions.</source>
          <target state="translated">このコード行は、 &lt;code&gt;Start()&lt;/code&gt; または &lt;code&gt;Awake()&lt;/code&gt; 関数の下で最適に機能します。</target>
        </trans-unit>
        <trans-unit id="dc1bf227c2a95d116418fc9c84ba8def88bc060c" translate="yes" xml:space="preserve">
          <source>This means the reference is &lt;code&gt;null&lt;/code&gt;, and you cannot access members (such as methods) through a &lt;code&gt;null&lt;/code&gt; reference. The simplest case:</source>
          <target state="translated">これは、参照が &lt;code&gt;null&lt;/code&gt; であり、 &lt;code&gt;null&lt;/code&gt; 参照を通じてメンバー（メソッドなど）にアクセスできないことを意味します。 最も単純なケース：</target>
        </trans-unit>
        <trans-unit id="77e6e4ba966d107a04d5daf44a984b939a965789" translate="yes" xml:space="preserve">
          <source>This reduces the number of null checks you have to do in some cases. The syntax is to put a question mark before each dot. Take the following code for example:</source>
          <target state="translated">これにより、いくつかのケースで行わなければならないヌルチェックの数を減らすことができます。構文は、各ドットの前にクエスチョンマークを付けることです。例えば、次のコードを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c0315d79171243f81b079786418630b61bc73573" translate="yes" xml:space="preserve">
          <source>This translates to</source>
          <target state="translated">これは次のように翻訳されます。</target>
        </trans-unit>
        <trans-unit id="bed843e1a4ee572be6dff42169c3a5deee5b21c5" translate="yes" xml:space="preserve">
          <source>This way, you can avoid &lt;code&gt;NullReferenceException&lt;/code&gt; cases that are results of violation of the constraints set. For example, if you use an object property &lt;code&gt;X&lt;/code&gt; in a class and later try to invoke one of its methods and &lt;code&gt;X&lt;/code&gt; has a null value, then this will lead to &lt;code&gt;NullReferenceException&lt;/code&gt;:</source>
          <target state="translated">このようにして、制約セットの違反の結果である &lt;code&gt;NullReferenceException&lt;/code&gt; ケースを回避できます。 たとえば、クラスでオブジェクトプロパティ &lt;code&gt;X&lt;/code&gt; を使用し、後でそのメソッドの1つを呼び出そうとし、 &lt;code&gt;X&lt;/code&gt; にnull値がある場合、これにより &lt;code&gt;NullReferenceException&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="ca62aa267e13467726859928ccd74cc220dd2bbb" translate="yes" xml:space="preserve">
          <source>This will create a &lt;em&gt;local&lt;/em&gt; variable, &lt;code&gt;reg&lt;/code&gt;, which exists only in that context (sub). The &lt;code&gt;reg&lt;/code&gt; variable with module level &lt;code&gt;Scope&lt;/code&gt; which you will use everywhere else remains &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">これにより、そのコンテキスト（サブ）にのみ存在する&lt;em&gt;ローカル&lt;/em&gt;変数 &lt;code&gt;reg&lt;/code&gt; が作成されます。 他の場所で使用するモジュールレベルの &lt;code&gt;Scope&lt;/code&gt; を持つ &lt;code&gt;reg&lt;/code&gt; 変数は &lt;code&gt;Nothing&lt;/code&gt; のままです。</target>
        </trans-unit>
        <trans-unit id="9886256ed1be06c975b72d5406cf9d7e42cde50b" translate="yes" xml:space="preserve">
          <source>This will do the following: If &lt;code&gt;myIntArray&lt;/code&gt; is null, the expression returns null and you can safely check it. If it contains an array, it will do the same as:
&lt;code&gt;elem = myIntArray[i];&lt;/code&gt; and returns the &lt;code&gt;i&amp;lt;sup&amp;gt;th&amp;lt;/sup&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">これにより、次の &lt;code&gt;myIntArray&lt;/code&gt; が行われます。myIntArrayがnullの場合、式はnullを返し、安全に確認できます。 配列が含まれている場合は、次と同じことを行い &lt;code&gt;elem = myIntArray[i];&lt;/code&gt; そして &lt;code&gt;i&amp;lt;sup&amp;gt;th&amp;lt;/sup&amp;gt;&lt;/code&gt; 要素を返します。</target>
        </trans-unit>
        <trans-unit id="1db062d19edd3aad36fceee9160e7c1852968c5e" translate="yes" xml:space="preserve">
          <source>This will result in the title variable being &lt;code&gt;null&lt;/code&gt;, and the call to &lt;code&gt;ToUpper&lt;/code&gt; is not made if &lt;code&gt;person.Title&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">これにより、title変数が &lt;code&gt;null&lt;/code&gt; になり、 &lt;code&gt;person.Title&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; の場合、 ToUpperへの &lt;code&gt;ToUpper&lt;/code&gt; は行われません。</target>
        </trans-unit>
        <trans-unit id="037853ac976e876cd13f3318e4f680cf26902d26" translate="yes" xml:space="preserve">
          <source>This will throw a &lt;code&gt;NullReferenceException&lt;/code&gt; at the second line because you can't call the instance method &lt;code&gt;ToUpper()&lt;/code&gt; on a &lt;code&gt;string&lt;/code&gt; reference pointing to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; を指す &lt;code&gt;string&lt;/code&gt; 参照でインスタンスメソッド &lt;code&gt;ToUpper()&lt;/code&gt; を呼び出すことができないため、2行目に &lt;code&gt;NullReferenceException&lt;/code&gt; がスローされます 。</target>
        </trans-unit>
        <trans-unit id="4adf93e86d1600f5a1f1d298afde221268eccfe7" translate="yes" xml:space="preserve">
          <source>Though this check &lt;a href=&quot;https://stackoverflow.com/questions/3021538/debug-assert-appears-in-release-mode&quot;&gt;will not end up in your release build&lt;/a&gt;, causing it to throw the &lt;code&gt;NullReferenceException&lt;/code&gt; again when &lt;code&gt;book == null&lt;/code&gt; at runtime in release mode.</source>
          <target state="translated">このチェック&lt;a href=&quot;https://stackoverflow.com/questions/3021538/debug-assert-appears-in-release-mode&quot;&gt;はリリースビルド&lt;/a&gt;で終了しないため 、リリースモードでの実行時に &lt;code&gt;book == null&lt;/code&gt; ときに再度 &lt;code&gt;NullReferenceException&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="fe4569d04b34db2feeacd18b55f433f11ceeaa79" translate="yes" xml:space="preserve">
          <source>To avoid this error:</source>
          <target state="translated">このエラーを回避するために</target>
        </trans-unit>
        <trans-unit id="b862da83d643fa0302757d37468767ad8e9ac824" translate="yes" xml:space="preserve">
          <source>To be clear, &lt;code&gt;Dim&lt;/code&gt; (or &lt;code&gt;Private&lt;/code&gt;) only &lt;em&gt;declares&lt;/em&gt; a variable and its &lt;code&gt;Type&lt;/code&gt;.   The &lt;em&gt;Scope&lt;/em&gt; of the variable - whether it exists for the entire module/class or is local to a procedure - is determined by &lt;em&gt;where&lt;/em&gt; it is declared. &lt;code&gt;Private | Friend | Public&lt;/code&gt; defines the access level, not &lt;em&gt;Scope&lt;/em&gt;.</source>
          <target state="translated">明確にするために、 &lt;code&gt;Dim&lt;/code&gt; （または &lt;code&gt;Private&lt;/code&gt; ）は変数とその &lt;code&gt;Type&lt;/code&gt; のみを&lt;em&gt;宣言&lt;/em&gt;します。 変数の&lt;em&gt;スコープ&lt;/em&gt; （モジュール/クラス全体に存在するか、プロシージャに対してローカルかどうか）は、変数が宣言されている&lt;em&gt;場所&lt;/em&gt;によって決まります。 &lt;code&gt;Private | Friend | Public&lt;/code&gt; 友達| Publicは&lt;em&gt;Scope&lt;/em&gt;ではなくアクセスレベルを定義します。</target>
        </trans-unit>
        <trans-unit id="5ccb716ef7518f5e4cae9d82dbbb0fdfc28ad185" translate="yes" xml:space="preserve">
          <source>To fix this you have to instantiate (assign object to reference of that class).</source>
          <target state="translated">これを修正するには、インスタンス化(オブジェクトをそのクラスの参照に代入する)する必要があります。</target>
        </trans-unit>
        <trans-unit id="cfce5bc74512f792b40d3fd4bb577d39ad331d72" translate="yes" xml:space="preserve">
          <source>To fully understand why a NullReferenceException is thrown, it is important to know the difference between &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;value types&lt;/a&gt; and [reference types][3].</source>
          <target state="translated">NullReferenceExceptionがスローされる理由を完全に理解するには、 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;値タイプ&lt;/a&gt;と[参照タイプ] [3]の違いを理解することが重要です。</target>
        </trans-unit>
        <trans-unit id="442fc389bbb8b0ecba07a137178cc20263b9b7c4" translate="yes" xml:space="preserve">
          <source>To prevent the error, objects that could be null should be tested for null before being used.</source>
          <target state="translated">エラーを防ぐために、NULLになる可能性のあるオブジェクトは、使用する前にNULLかどうかをテストする必要があります。</target>
        </trans-unit>
        <trans-unit id="2fc08c6abe8c008843158c3dfc2b4819d97175ce" translate="yes" xml:space="preserve">
          <source>To understand why that is, it helps to understand how .NET produces null dereference exceptions in the first place. (These details apply to .NET running on Windows; other operating systems use similar mechanisms.)</source>
          <target state="translated">その理由を理解するには、そもそも.NET がどのようにして NULL 参照解除例外を生成しているのかを理解するのに役立ちます (これらの詳細は Windows で動作する .NET に適用されます。(これらの詳細は Windows 上で動作する .NET に適用されます。他のオペレーティングシステムでも同様のメカニズムを使用しています)。</target>
        </trans-unit>
        <trans-unit id="1c409f99322562874653d2f8a0ab2c648ed33f45" translate="yes" xml:space="preserve">
          <source>Typically, the &lt;code&gt;Settings&lt;/code&gt; collection will only need to be initialized the first time the application runs. An alternate remedy is to add an initial value to your collection in &lt;strong&gt;Project -&amp;gt; Settings | FooBars&lt;/strong&gt;, save the project, then remove the fake value.</source>
          <target state="translated">通常、 &lt;code&gt;Settings&lt;/code&gt; コレクションは、アプリケーションの初回実行時にのみ初期化する必要があります。 別の方法は、 &lt;strong&gt;プロジェクト-&amp;gt;設定|で&lt;/strong&gt;コレクションに初期値を追加することです&lt;strong&gt;。&lt;/strong&gt; &lt;strong&gt;FooBars&lt;/strong&gt; 、プロジェクトを保存してから、偽の値を削除します。</target>
        </trans-unit>
        <trans-unit id="516c8eebca6e87f940176b1effe4b60b6c0ea266" translate="yes" xml:space="preserve">
          <source>Typically, the simplest remedy is used.</source>
          <target state="translated">一般的には、最も単純な救済措置が使用されます。</target>
        </trans-unit>
        <trans-unit id="44ae451f7b7bc5e89c459fa403f51f895a24e5e5" translate="yes" xml:space="preserve">
          <source>UI Controls</source>
          <target state="translated">UI コントロール</target>
        </trans-unit>
        <trans-unit id="0367a9753f91933f52263dc3499b7fad896e44c1" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, trying to use an item from &lt;code&gt;My.Settings&lt;/code&gt; which is a &lt;code&gt;StringCollection&lt;/code&gt; can result in a NullReference the first time you use it. The solution is the same, but not as obvious. Consider:</source>
          <target state="translated">特定の状況下では、 &lt;code&gt;StringCollection&lt;/code&gt; である &lt;code&gt;My.Settings&lt;/code&gt; のアイテムを使用しようとすると、初めて使用したときにNullReferenceが発生する可能性があります。 解決策は同じですが、それほど明白ではありません。 検討してください：</target>
        </trans-unit>
        <trans-unit id="5fd5faf037f6a68b87421df3d131d2dc06cf5ac5" translate="yes" xml:space="preserve">
          <source>Unhandled Exception:</source>
          <target state="translated">手つかずの例外。</target>
        </trans-unit>
        <trans-unit id="13d1de28b167068f1cf58b6d8b42d1a864bfb7e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Debug.Assert&lt;/code&gt; if a value should never be &lt;code&gt;null&lt;/code&gt;, to catch the problem earlier than the exception occurs.</source>
          <target state="translated">値が &lt;code&gt;null&lt;/code&gt; になり &lt;code&gt;Debug.Assert&lt;/code&gt; ない場合は、 Debug.Assertを使用して、例外が発生する前に問題をキャッチします。</target>
        </trans-unit>
        <trans-unit id="382f02f764a14908cf7b8365adec70912d5701d9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;GetValueOrDefault()&lt;/code&gt; for &lt;code&gt;nullable&lt;/code&gt; value types to provide a default value when they are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nullable&lt;/code&gt; 値の型に対して &lt;code&gt;GetValueOrDefault()&lt;/code&gt; を使用して、 &lt;code&gt;null&lt;/code&gt; のときにデフォルト値を提供します。</target>
        </trans-unit>
        <trans-unit id="2998b45c318d095c3e4535a7950d83516d58ebb7" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;For/Each&lt;/code&gt; loop and test the &lt;code&gt;IsNewRow&lt;/code&gt; property to determine if it is that last row. This works whether &lt;code&gt;AllowUserToAddRows&lt;/code&gt; is true or not:</source>
          <target state="translated">&lt;code&gt;For/Each&lt;/code&gt; ループを使用し、 &lt;code&gt;IsNewRow&lt;/code&gt; プロパティをテストして、最後の行かどうかを判断します。 これは、 &lt;code&gt;AllowUserToAddRows&lt;/code&gt; がtrueかどうかに関係なく機能します。</target>
        </trans-unit>
        <trans-unit id="1b21080b0c77e9baa935891138a35678155ae048" translate="yes" xml:space="preserve">
          <source>Use null context (available in C# 8):</source>
          <target state="translated">nullコンテキストを使用します(C#8で利用可能)。</target>
        </trans-unit>
        <trans-unit id="3c02b72e67d50c9e6e8df127d3c4c8b5ee96c2af" translate="yes" xml:space="preserve">
          <source>Use the null coalescing operator: &lt;code&gt;??&lt;/code&gt; [C#] or &lt;code&gt;If()&lt;/code&gt; [VB].</source>
          <target state="translated">nullの合体演算子を使用します。 [C＃]または &lt;code&gt;If()&lt;/code&gt; [VB]。</target>
        </trans-unit>
        <trans-unit id="eceb840fe473d205bb79bbfbe6842b028ab9de50" translate="yes" xml:space="preserve">
          <source>Use the null condition operator: &lt;code&gt;?.&lt;/code&gt; or &lt;code&gt;?[x]&lt;/code&gt; for arrays (available in C# 6 and VB.NET 14):</source>
          <target state="translated">NULL条件演算子を使用します： &lt;code&gt;?.&lt;/code&gt; または &lt;code&gt;?[x]&lt;/code&gt; 配列（C＃6およびVB.NET 14で利用可能）：</target>
        </trans-unit>
        <trans-unit id="e34781ddb98c0b7bad26d07124e848d7dc5380d0" translate="yes" xml:space="preserve">
          <source>User defined structs</source>
          <target state="translated">ユーザー定義構造体</target>
        </trans-unit>
        <trans-unit id="4c9bf9d75e9c5172e3585c1c3082c6d25bacf2fa" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;List(Of T)&lt;/code&gt; will make it quite difficult to have an element without a valid object:</source>
          <target state="translated">&lt;code&gt;List(Of T)&lt;/code&gt; を使用すると、有効なオブジェクトなしで要素を持つことが非常に難しくなります。</target>
        </trans-unit>
        <trans-unit id="e0cf661777181bb5bf4bab3c932185766cf29b18" translate="yes" xml:space="preserve">
          <source>Validate data before using it (also use &lt;code&gt;Option Strict&lt;/code&gt; and SQL parameters):</source>
          <target state="translated">使用する前にデータを検証します（ &lt;code&gt;Option Strict&lt;/code&gt; およびSQLパラメーターも使用します）。</target>
        </trans-unit>
        <trans-unit id="3b3c5424e9429ade50d2ed4719daf8a5ef46e7c7" translate="yes" xml:space="preserve">
          <source>Value Types and Reference Types</source>
          <target state="translated">値の型と参照の型</target>
        </trans-unit>
        <trans-unit id="b7d9a51e2fb5186d4548644a10a85dfb83b90aff" translate="yes" xml:space="preserve">
          <source>Visual Basic Forms</source>
          <target state="translated">Visual Basic フォーム</target>
        </trans-unit>
        <trans-unit id="914f780030704154b3755eefa6c85d3acdf3b1c7" translate="yes" xml:space="preserve">
          <source>Visual Basic tries to make the process clear repeatedly using &lt;strong&gt;&lt;code&gt;New&lt;/code&gt;&lt;/strong&gt;: Using the &lt;strong&gt;&lt;code&gt;New&lt;/code&gt;&lt;/strong&gt; Operator creates a &lt;strong&gt;new&lt;/strong&gt; object and calls &lt;strong&gt;&lt;code&gt;Sub New&lt;/code&gt;&lt;/strong&gt; -- the constructor -- where your object can perform any other initialization.</source>
          <target state="translated">Visual Basicは、 &lt;strong&gt; &lt;code&gt;New&lt;/code&gt; &lt;/strong&gt;を使用してプロセスを繰り返し明確にしようとします。New演算子を使用すると、 &lt;strong&gt;新しい&lt;/strong&gt;オブジェクトが作成され、 &lt;strong&gt; &lt;code&gt;Sub New&lt;/code&gt; &lt;/strong&gt; （コンストラクタ）が呼び出されます。ここで、オブジェクトは他の初期化を実行できます。</target>
        </trans-unit>
        <trans-unit id="4356f5b2bed387a822b4773e00b955c30fb15382" translate="yes" xml:space="preserve">
          <source>WPF Control Creation Order and Events</source>
          <target state="translated">WPFコントロールの作成順序とイベント</target>
        </trans-unit>
        <trans-unit id="865749e3cc387179c321ac3469aa809ca6ea641d" translate="yes" xml:space="preserve">
          <source>Ways to Avoid</source>
          <target state="translated">避ける方法</target>
        </trans-unit>
        <trans-unit id="b50ff997c836b3bf135585b592d9922fb8daa6c5" translate="yes" xml:space="preserve">
          <source>We can add data really easily actually in a few ways:</source>
          <target state="translated">私たちは、いくつかの方法で実際には本当に簡単にデータを追加することができます。</target>
        </trans-unit>
        <trans-unit id="171db29c0e9a7d26b4e0c78fa029495735b943f5" translate="yes" xml:space="preserve">
          <source>Well, in simple terms:</source>
          <target state="translated">まあ、簡単に言うと</target>
        </trans-unit>
        <trans-unit id="54f0454febe335028ebb7ac67e60ee8639c8bb01" translate="yes" xml:space="preserve">
          <source>What about the second point? Dereferencing &lt;em&gt;any&lt;/em&gt; invalid pointer that falls in the lowest page of virtual memory causes the same operating system error, and thereby the same exception.</source>
          <target state="translated">2番目のポイントはどうですか？ 仮想メモリの最下位ページにある無効なポインタを逆参照&lt;em&gt;する&lt;/em&gt;と、同じオペレーティングシステムエラーが発生し、同じ例外が発生します。</target>
        </trans-unit>
        <trans-unit id="a57d36dd7547d0d01d63f5a0dca33743ac6b0190" translate="yes" xml:space="preserve">
          <source>What does that mean?</source>
          <target state="translated">それはどういう意味なのか?</target>
        </trans-unit>
        <trans-unit id="dfc9e4324fb08b6a8f17d724cf8c6155af43dd1b" translate="yes" xml:space="preserve">
          <source>What does this mean, and what can I do to fix this error?</source>
          <target state="translated">これはどういう意味なのでしょうか、また、このエラーを修正するにはどうしたらいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="682501e35814b10bb49bcce3a8138d93e7237565" translate="yes" xml:space="preserve">
          <source>What is a NullReferenceException, and how do I fix it</source>
          <target state="translated">NullReferenceException とは何ですか?</target>
        </trans-unit>
        <trans-unit id="2b175120120a58af183c09ae1970097e643335ca" translate="yes" xml:space="preserve">
          <source>What is the cause?</source>
          <target state="translated">原因は何か?</target>
        </trans-unit>
        <trans-unit id="4d05bb2729110f107617bc429ecb0bc63e601752" translate="yes" xml:space="preserve">
          <source>When a property of a null object accessed:</source>
          <target state="translated">null オブジェクトのプロパティにアクセスした場合。</target>
        </trans-unit>
        <trans-unit id="24ee47a5b48927d93ac97774fc77bc2a3836d6a2" translate="yes" xml:space="preserve">
          <source>When a string method of an empty string accessed:</source>
          <target state="translated">空文字列の文字列メソッドにアクセスした場合。</target>
        </trans-unit>
        <trans-unit id="0d8ca3f12ffd0492f759832995654e7110254f83" translate="yes" xml:space="preserve">
          <source>When declared as a module/class level variable, as appears to be the case with &lt;code&gt;con&lt;/code&gt;, the compiler can't know if the object was created by an upstream procedure. Do not ignore warnings.</source>
          <target state="translated">モジュール/クラスレベル変数として宣言された場合、 &lt;code&gt;con&lt;/code&gt; の場合と同様に、コンパイラーはオブジェクトが上流のプロシージャによって作成されたかどうかを知ることができません。 警告を無視しないでください。</target>
        </trans-unit>
        <trans-unit id="efc21187e8ea71d0502b9553436531ff09010739" translate="yes" xml:space="preserve">
          <source>When it is only appropriate to create the instance later:</source>
          <target state="translated">インスタンスの作成が後回しにしかならない場合。</target>
        </trans-unit>
        <trans-unit id="e320e6e3ad0e90936d129472db697d3b8b8d6e80" translate="yes" xml:space="preserve">
          <source>When working &lt;strong&gt;across different layers&lt;/strong&gt;, for example in an MVC application, a controller needs services to call business operations. In such scenarios &lt;strong&gt;Dependency Injection Container&lt;/strong&gt; can be used to initialize the services to avoid the &lt;strong&gt;NullReferenceException&lt;/strong&gt;. So that means you don't need to worry about checking for null and just call the services from the controller as though they will always to available (and initialized) as either a singleton or a prototype.</source>
          <target state="translated">MVCアプリケーションなど、 &lt;strong&gt;さまざまなレイヤー&lt;/strong&gt;で作業する場合、コントローラーにはビジネスオペレーションを呼び出すサービスが必要です。 このようなシナリオでは、 &lt;strong&gt;依存性注入コンテナ&lt;/strong&gt;を使用してサービスを初期化し、 &lt;strong&gt;NullReferenceException&lt;/strong&gt;を回避できます。 つまり、nullのチェックについて心配する必要はなく、コントローラからサービスを呼び出すだけで、シングルトンまたはプロトタイプのいずれかとして常に利用可能（および初期化）であるかのように処理できます。</target>
        </trans-unit>
        <trans-unit id="dba90f1005ef6b9743a2d890263f4e1876834da6" translate="yes" xml:space="preserve">
          <source>When you know during development that a method maybe can, but never should return &lt;code&gt;null&lt;/code&gt;, you can use &lt;code&gt;Debug.Assert()&lt;/code&gt; to break as soon as possible when it does occur:</source>
          <target state="translated">開発中にメソッドが &lt;code&gt;null&lt;/code&gt; を返す可能性があるが絶対に返すべきではないことがわかっている場合は、 &lt;code&gt;Debug.Assert()&lt;/code&gt; を使用して、発生したときにできるだけ早くブレークすることができます。</target>
        </trans-unit>
        <trans-unit id="1492aaa2d900e272a66ec2ee7932c7c567523b15" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;DataGridView&lt;/code&gt; has &lt;code&gt;AllowUserToAddRows&lt;/code&gt; as &lt;code&gt;True&lt;/code&gt; (the default), the &lt;code&gt;Cells&lt;/code&gt; in the blank/new row at the bottom will all contain &lt;code&gt;Nothing&lt;/code&gt;.  Most attempts to use the contents (for example, &lt;code&gt;ToString&lt;/code&gt;) will result in an NRE.</source>
          <target state="translated">&lt;code&gt;DataGridView&lt;/code&gt; の &lt;code&gt;AllowUserToAddRows&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; （デフォルト）の場合、下部の空白/新しい行の &lt;code&gt;Cells&lt;/code&gt; にはすべて &lt;code&gt;Nothing&lt;/code&gt; が含まれます。 コンテンツ（たとえば、 &lt;code&gt;ToString&lt;/code&gt; ）を使用しようとすると、ほとんどの場合NREになります。</target>
        </trans-unit>
        <trans-unit id="cdb948906225c5be7dabe665fe3268f2aa7f7d1b" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;what&lt;/em&gt; causes a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;NullReferenceExceptions&lt;/a&gt; and approaches to &lt;em&gt;avoid/fix&lt;/em&gt; such an exception have been addressed in other answers, what many programmers haven't learned yet is how to independently &lt;em&gt;debug&lt;/em&gt; such exceptions during development.</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;NullReferenceExceptionsの&lt;/a&gt;原因とそのような例外を&lt;em&gt;回避/修正&lt;/em&gt;する&lt;em&gt;ための&lt;/em&gt;アプローチは他の回答で扱われていますが、多くのプログラマがまだ学んでいないのは、開発中にそのような例外を個別に&lt;em&gt;デバッグ&lt;/em&gt;する方法です。</target>
        </trans-unit>
        <trans-unit id="448dc745cee8454cb3051219a2b24ea7029e0795" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;new&lt;/code&gt; keyword is used, it only creates a new instance of &lt;code&gt;Book&lt;/code&gt;, but not a new instance of &lt;code&gt;Person&lt;/code&gt;, so the &lt;code&gt;Author&lt;/code&gt; the property is still &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; キーワードが使用されている間、作成されるのは &lt;code&gt;Book&lt;/code&gt; の新しいインスタンスのみで、 &lt;code&gt;Person&lt;/code&gt; の新しいインスタンスは作成されないため、 &lt;code&gt;Author&lt;/code&gt; プロパティは &lt;code&gt;null&lt;/code&gt; のままです。</target>
        </trans-unit>
        <trans-unit id="d52f9ee0d5e0aa5f23d1b3b5d8e4d2e56fca0930" translate="yes" xml:space="preserve">
          <source>Why does this make sense?  Well, suppose we have a struct containing two ints, and an unmanaged pointer equal to null. If we attempt to dereference the second int in the struct, the &lt;code&gt;CLR&lt;/code&gt; will not attempt to access the storage at location zero; it will access the storage at location four. But logically this is a null dereference because we are getting to that address &lt;em&gt;via&lt;/em&gt; the null.</source>
          <target state="translated">これはなぜ意味があるのですか？ 2つの整数を含む構造体と、nullに等しいアンマネージポインターがあるとします。 構造体の2番目のintを逆参照しようとした場合、 &lt;code&gt;CLR&lt;/code&gt; は位置0のストレージにアクセスしようとしません。 ロケーション4のストレージにアクセスします。 しかし、論理的にはnull &lt;em&gt;経由で&lt;/em&gt;そのアドレスに到達しているため、これはnull逆参照です。</target>
        </trans-unit>
        <trans-unit id="e5b3e5b5a3ce438cfd892d68ca821da56bd33f46" translate="yes" xml:space="preserve">
          <source>Why is this wrong?  Because the iterator block does not actually &lt;em&gt;run&lt;/em&gt; until the &lt;code&gt;foreach&lt;/code&gt;!  The call to &lt;code&gt;GetFrobs&lt;/code&gt; simply returns an object which &lt;em&gt;when iterated&lt;/em&gt; will run the iterator block.</source>
          <target state="translated">なぜこれが間違っているのですか？ イテレータブロックは、実際には &lt;code&gt;foreach&lt;/code&gt; まで&lt;em&gt;実行さ&lt;/em&gt;れないためです。 &lt;code&gt;GetFrobs&lt;/code&gt; の呼び出しは、 &lt;em&gt;反復される&lt;/em&gt;と反復子ブロックを実行するオブジェクトを返すだけです。</target>
        </trans-unit>
        <trans-unit id="dd8f068ecfc9cc04c00494e69ae5f6e0960b7ae7" translate="yes" xml:space="preserve">
          <source>Why it occurs?</source>
          <target state="translated">なぜ発生するのか?</target>
        </trans-unit>
        <trans-unit id="cce1faca008b524ebe3411e4a56c2cb194dc1b42" translate="yes" xml:space="preserve">
          <source>Working with databases presents many opportunities for a NullReference because there can be many objects (&lt;code&gt;Command&lt;/code&gt;, &lt;code&gt;Connection&lt;/code&gt;, &lt;code&gt;Transaction&lt;/code&gt;, &lt;code&gt;Dataset&lt;/code&gt;, &lt;code&gt;DataTable&lt;/code&gt;, &lt;code&gt;DataRows&lt;/code&gt;....) in use at once.  &lt;strong&gt;Note:&lt;/strong&gt; It does not matter which data provider you are using -- MySQL, SQL Server, OleDB, etc. -- the &lt;em&gt;concepts&lt;/em&gt; are the same.</source>
          <target state="translated">一度に多数のオブジェクト（ &lt;code&gt;Command&lt;/code&gt; 、 &lt;code&gt;Connection&lt;/code&gt; 、 &lt;code&gt;Transaction&lt;/code&gt; 、 &lt;code&gt;Dataset&lt;/code&gt; 、 &lt;code&gt;DataTable&lt;/code&gt; 、 &lt;code&gt;DataRows&lt;/code&gt; ....）を使用できるため、データベースを操作すると、NullReferenceの多くの機会がもたらされます。 &lt;strong&gt;注：&lt;/strong&gt; MySQL、SQL Server、OleDBなど、使用しているデータプロバイダーは関係ありません。 &lt;em&gt;概念&lt;/em&gt;は同じです。</target>
        </trans-unit>
        <trans-unit id="723856ede778551d9c785472d51c2f7fcbb54d7d" translate="yes" xml:space="preserve">
          <source>You are trying to access an object that isn't created or currently not in memory.</source>
          <target state="translated">作成されていない、または現在メモリにないオブジェクトにアクセスしようとしています。</target>
        </trans-unit>
        <trans-unit id="8aa880592f3584b0eb7955f587d23cf9a9b8e76b" translate="yes" xml:space="preserve">
          <source>You are trying to use a reference variable whose value is &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;.  When the value is &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; for the reference variable, that means it is not actually holding a reference to an instance of any object that exists on the heap.</source>
          <target state="translated">値が &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; の参照変数を使用しようとしています 。 参照変数の値が &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; の場合、それはヒープ上に存在するオブジェクトのインスタンスへの参照を実際には保持していないことを意味します。</target>
        </trans-unit>
        <trans-unit id="4b4d5b042ee1470a88bab9f1d60f9144e6f609fc" translate="yes" xml:space="preserve">
          <source>You are trying to use something that is &lt;code&gt;null&lt;/code&gt; (or &lt;code&gt;Nothing&lt;/code&gt; in VB.NET). This means you either set it to &lt;code&gt;null&lt;/code&gt;, or you never set it to anything at all.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; （またはVB.NETでは &lt;code&gt;Nothing&lt;/code&gt; ）の何かを使用しようとしています。 つまり、これを &lt;code&gt;null&lt;/code&gt; に設定するか、まったく何も設定しません。</target>
        </trans-unit>
        <trans-unit id="a4b2a4f8cb9ff198b895cb45c6d69095f67060ba" translate="yes" xml:space="preserve">
          <source>You are using the object that contains the null value reference. So it's giving a null exception. In the example the string value is null and when checking its length, the exception occurred.</source>
          <target state="translated">NULL値の参照を含むオブジェクトを使用しています。そのため、NULL例外が発生しています。この例では、文字列の値がNULLであり、その長さをチェックすると例外が発生しました。</target>
        </trans-unit>
        <trans-unit id="c6e71d37b17fa53433b0f7d95131ec2c8f8e5dcd" translate="yes" xml:space="preserve">
          <source>You can add a component programmatically and assign the variable at the same time with one line of code: &lt;code&gt;rb = AddComponent&amp;lt;RigidBody&amp;gt;();&lt;/code&gt;</source>
          <target state="translated">プログラムでコンポーネントを追加し、1行のコードで変数を同時に割り当てることができます &lt;code&gt;rb = AddComponent&amp;lt;RigidBody&amp;gt;();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c38e20677037c680c41cdbbd3a874a5b75b4783" translate="yes" xml:space="preserve">
          <source>You can also throw a custom exception, only to catch it in the calling code:</source>
          <target state="translated">また、カスタム例外を投げることもできます。</target>
        </trans-unit>
        <trans-unit id="17ea64ffa695b740770485aaba63974913381c9a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;Locals Window&lt;/code&gt; (&lt;strong&gt;Debug -&amp;gt; Windows -&amp;gt; Locals&lt;/strong&gt;) to examine your objects.</source>
          <target state="translated">&lt;code&gt;Locals Window&lt;/code&gt; （[ &lt;strong&gt;デバッグ]-&amp;gt; [ウィンドウ]-&amp;gt; [ローカル]&lt;/strong&gt; ）を使用して、オブジェクトを調べることもできます。</target>
        </trans-unit>
        <trans-unit id="12a1a3c92ffa52e6b050bf7546290b5e6ce658b2" translate="yes" xml:space="preserve">
          <source>You can fix NullReferenceException in a clean way using Null-conditional Operators in c#6 and write less code to handle null checks.</source>
          <target state="translated">c#6のNull-conditional Operatorsを使えば、NullReferenceExceptionをクリーンな方法で修正することができ、Nullチェックを処理するためのコードを少なくすることができます。</target>
        </trans-unit>
        <trans-unit id="2edd59e412b940b382162755da24e3b3a55a1a98" translate="yes" xml:space="preserve">
          <source>You can simply avoid this by checking if the variable is not null:</source>
          <target state="translated">変数がNULLでないかどうかをチェックすることで、これを単純に回避することができます。</target>
        </trans-unit>
        <trans-unit id="d1588e2df3c8e2e5e50543e8a09e318c3ac852eb" translate="yes" xml:space="preserve">
          <source>You either never assigned something to the variable, never created an instance of the value assigned to the variable, or you set the variable equal to &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; manually, or you called a function that set the variable to &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; for you.</source>
          <target state="translated">変数に何かを割り当てたことがないか、変数に割り当てられた値のインスタンスを作成したことがないか、変数を手動で &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; に設定するか、変数を &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; に設定する関数を呼び出しました。</target>
        </trans-unit>
        <trans-unit id="f66228601ed3724d69b717ec6fe23f27ca71e042" translate="yes" xml:space="preserve">
          <source>You get the same exception for the same reason - &lt;code&gt;myList&lt;/code&gt; was only declared, but no instance created. The remedy is the same:</source>
          <target state="translated">同じ理由で同じ例外が発生します &lt;code&gt;myList&lt;/code&gt; が宣言されただけで、インスタンスは作成されませんでした。 救済策は同じです：</target>
        </trans-unit>
        <trans-unit id="7d96029677307b05bf0beda9a46b585a9c96a9a3" translate="yes" xml:space="preserve">
          <source>You probably forgot the &lt;code&gt;New&lt;/code&gt; operator.</source>
          <target state="translated">あなたはおそらく &lt;code&gt;New&lt;/code&gt; 演算子を忘れました。</target>
        </trans-unit>
        <trans-unit id="9889cfa340b5a188c4545454aa3970b650ff6a92" translate="yes" xml:space="preserve">
          <source>You should also remove any Try/Catch blocks from the relevant code, especially ones where there is nothing in the Catch block. This will cause your code to crash when it tries to use an object which is &lt;code&gt;Nothing&lt;/code&gt;. &lt;strong&gt;This is what you want&lt;/strong&gt; because it will identify the exact &lt;em&gt;location&lt;/em&gt; of the problem, and allow you to identify the object causing it.</source>
          <target state="translated">また、関連するコード、特にCatchブロックに何もないものから、Try / Catchブロックを削除する必要もあります。 これにより、コードが &lt;code&gt;Nothing&lt;/code&gt; であるオブジェクトを使用しようとすると、コードがクラッシュします。 &lt;strong&gt;これは&lt;/strong&gt; 、問題の正確な&lt;em&gt;場所&lt;/em&gt;を特定し、問題の原因となっているオブジェクトを特定できるためです。</target>
        </trans-unit>
        <trans-unit id="7cf85e9877af0174191657bf941763d81f747650" translate="yes" xml:space="preserve">
          <source>You would use very similar to the same way you would use &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, except with the goal of accomplishing exactly the opposite - to not allow &lt;code&gt;null&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">&lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; を使用するのと同じように使用でき &lt;code&gt;null&lt;/code&gt; 、 Nullを許可しないという反対の目的を達成することを除きます 。 ここではいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="1cc0e4045b9e917b4e600760083043c55ca6aa29" translate="yes" xml:space="preserve">
          <source>Your code &lt;em&gt;declared&lt;/em&gt; an object variable, but it did not &lt;em&gt;initialize&lt;/em&gt; it (create an instance or '&lt;em&gt;instantiate&lt;/em&gt;' it)</source>
          <target state="translated">コードでオブジェクト変数を&lt;em&gt;宣言しましたが&lt;/em&gt; 、 &lt;em&gt;初期化&lt;/em&gt;しませんでした（インスタンスを作成するか、インスタンス&lt;em&gt;化し&lt;/em&gt;てください）</target>
        </trans-unit>
        <trans-unit id="1835adb6d4755dbbf56a8c76ede96fd8258bbc9c" translate="yes" xml:space="preserve">
          <source>above line throws error because reference of class myClass is declared but not instantiated or an instance of object is not assigned to referecne of that class.</source>
          <target state="translated">上記の行は、クラスmyClassの参照が宣言されているがインスタンス化されていないか、そのクラスの参照にオブジェクトのインスタンスが代入されていないためにエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="163efa6e9cc8a00507230d1f61d9db3d11ab97db" translate="yes" xml:space="preserve">
          <source>and Contact entity class. Sometimes entity classes are partial classes so that you can extend them in other files too.</source>
          <target state="translated">と Contact エンティティクラスがあります。エンティティクラスは部分クラスになっていることもあるので、他のファイルでも拡張することができます。</target>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="45932d6fa98f39c5cd3f08cd951d8dc70fc5f7de" translate="yes" xml:space="preserve">
          <source>decimal</source>
          <target state="translated">decimal</target>
        </trans-unit>
        <trans-unit id="f7852992c275998df7dbb34bd4a576549f4622aa" translate="yes" xml:space="preserve">
          <source>dereferencing a null &lt;strong&gt;pointer&lt;/strong&gt; produces the same exception as dereferencing a null &lt;strong&gt;reference&lt;/strong&gt;</source>
          <target state="translated">null &lt;strong&gt;ポインターの&lt;/strong&gt;逆参照は、null &lt;strong&gt;参照の&lt;/strong&gt;逆参照と同じ例外を生成し&lt;strong&gt;ます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b2e6f52aa2a81fb92f818a3436c6758ad33c8a3" translate="yes" xml:space="preserve">
          <source>dereferencing an invalid non-null pointer &lt;strong&gt;can&lt;/strong&gt; produce that exception
in some circumstances</source>
          <target state="translated">無効なnull以外のポインタを逆参照すると、状況によってはその例外&lt;strong&gt;が&lt;/strong&gt;発生する&lt;strong&gt;可能&lt;/strong&gt;性があります</target>
        </trans-unit>
        <trans-unit id="b5031a46dd38e909839b52a146a7969402061271" translate="yes" xml:space="preserve">
          <source>disable: The nullable annotation context is disabled. The nullable warning context is disabled. Variables of a reference type are oblivious, just like earlier versions of C#. All nullability warnings are disabled.</source>
          <target state="translated">を無効にします。ヌル可能な注釈コンテキストを無効にします。ヌル可能な警告コンテキストは無効化されます。参照型の変数は、以前のバージョンのC#と同様にobliviousです。すべてのヌル可能性警告は無効化されます。</target>
        </trans-unit>
        <trans-unit id="5452220584f9d82eacc9d4b64b556c642aa95fe3" translate="yes" xml:space="preserve">
          <source>dynamic</source>
          <target state="translated">dynamic</target>
        </trans-unit>
        <trans-unit id="707ee2e80d8a348ed040077b064ae8b11ce87533" translate="yes" xml:space="preserve">
          <source>enable: The nullable annotation context is enabled. The nullable warning context is enabled. Variables of a reference type, string for example, are non-nullable. All nullability warnings are enabled.</source>
          <target state="translated">を有効にします。ヌル可能な注釈コンテキストが有効になります。ヌル可能な警告コンテキストが有効になります。参照型の変数、例えば文字列はヌル可能ではありません。すべてのヌル可能性警告が有効になります。</target>
        </trans-unit>
        <trans-unit id="f93306a0064ddaa9f3c518dfda6d24b1659b5141" translate="yes" xml:space="preserve">
          <source>for example: let say you have a class called myClass and it contains one property prop1.</source>
          <target state="translated">例えば、myClassというクラスがあり、それがprop1というプロパティを含んでいるとします。</target>
        </trans-unit>
        <trans-unit id="4d3e8614703ea126434cc11d59e3c7a70c66d624" translate="yes" xml:space="preserve">
          <source>foreach</source>
          <target state="translated">foreach</target>
        </trans-unit>
        <trans-unit id="23ec53a4c09cf5266253f2e3ee5c91b8b4eb9045" translate="yes" xml:space="preserve">
          <source>in here , if address is null , then you will get NullReferenceException.</source>
          <target state="translated">ここでは、アドレスがnullの場合はNullReferenceExceptionが発生します。</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">に相当します。</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1d02abd73c8fc5445c71c4fbe24bc25707ea3d7a" translate="yes" xml:space="preserve">
          <source>public class Form1
{
    private Customer customer;</source>
          <target state="translated">public class Form1{private Customer Customer.</target>
        </trans-unit>
        <trans-unit id="c133b31de2d5fc69bf6862d425df4a2337f78d3d" translate="yes" xml:space="preserve">
          <source>safeonly: The nullable annotation context is enabled. The nullable warning context is safeonly. Variables of a reference type are nonnullable. All safety nullability warnings are enabled.</source>
          <target state="translated">セーフオンリーであることを示しています。ヌル可能な注釈コンテキストが有効になっています。ヌル可能な警告コンテキストは safeonly です。参照型の変数はヌル可能ではありません。すべての安全なヌル可能性警告が有効になります。</target>
        </trans-unit>
        <trans-unit id="3a061cb7a56d7292f241332c224fcac2f287af0a" translate="yes" xml:space="preserve">
          <source>safeonlywarnings: The nullable annotation context is disabled. The nullable warning context is safeonly.
    Variables of a reference type are oblivious. All safety nullability warnings are enabled.</source>
          <target state="translated">safeonlywarnings.ヌル可能な注釈コンテキストは無効になっています。ヌル可能な警告コンテキストは safeonly です。参照型の変数はobliviousです。すべての安全なヌル可能性警告が有効になっています。</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="2abda58ce57dab947ad0b74eb5487833707a6213" translate="yes" xml:space="preserve">
          <source>the following code will be problematic:</source>
          <target state="translated">以下のコードが問題になります。</target>
        </trans-unit>
        <trans-unit id="43a38bb2effe5dc812d40a39ec117e6b0fd8f1fc" translate="yes" xml:space="preserve">
          <source>warnings: The nullable annotation context is disabled. The nullable warning context is enabled. Variables of a reference type are oblivious. All nullability warnings are enabled.</source>
          <target state="translated">の警告が表示されます。ヌル可能な注釈コンテキストは無効になっています。ヌル可能な警告コンテキストが有効になっています。参照型の変数はobliviousです。すべてのヌル可能性警告が有効になっています。</target>
        </trans-unit>
        <trans-unit id="365054ee499f3b2258d3a22f7fa3f931704bc717" translate="yes" xml:space="preserve">
          <source>where an &lt;strong&gt;&lt;em&gt;unboxing&lt;/em&gt;&lt;/strong&gt; conversion (cast) &lt;em&gt;from&lt;/em&gt;&lt;code&gt;object&lt;/code&gt; (or from one of the classes &lt;code&gt;System.ValueType&lt;/code&gt; or &lt;code&gt;System.Enum&lt;/code&gt;, or from an interface type) &lt;em&gt;to&lt;/em&gt; a value type (other than &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt;) in itself gives the &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; （または &lt;code&gt;System.ValueType&lt;/code&gt; または &lt;code&gt;System.Enum&lt;/code&gt; クラスの1つから、あるいはインターフェイス型から） &lt;em&gt;から&lt;/em&gt;値型（ &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; 以外） &lt;em&gt;への&lt;/em&gt; &lt;strong&gt;&lt;em&gt;ボックス&lt;/em&gt;&lt;/strong&gt;化解除 （キャスト）自体が &lt;code&gt;NullReferenceException&lt;/code&gt; を発生させる場合 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
