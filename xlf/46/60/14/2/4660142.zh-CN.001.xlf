<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4660142">
    <body>
      <group id="4660142">
        <trans-unit id="9396f5058c8dfed94f5b53595720fed9df43bfa6" translate="yes" xml:space="preserve">
          <source>&quot;Button2&quot; resides on a &lt;code&gt;Panel&lt;/code&gt;</source>
          <target state="translated">&amp;ldquo; Button2&amp;rdquo;位于 &lt;code&gt;Panel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db5a5b1d9a6c5f4c860c37395021bbd5362fafa2" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;&lt;strong&gt;&lt;em&gt;NullReferenceException&lt;/em&gt;&lt;/strong&gt;&amp;rsquo; also occurs when we forget to instantiate a reference type.</source>
          <target state="translated">当我们忘记实例化引用类型时，也会发生' &lt;strong&gt;&lt;em&gt;NullReferenceException&lt;/em&gt;&lt;/strong&gt; '。</target>
        </trans-unit>
        <trans-unit id="dcee1b5e3a8c625c5a9735ca8c8ec5d25be46495" translate="yes" xml:space="preserve">
          <source>(Another reason for non-using unsafe code unless you need it, by the way)</source>
          <target state="translated">(另一个不使用不安全代码的原因,除非你需要,否则不使用不安全代码)</target>
        </trans-unit>
        <trans-unit id="673f15918a55d1f2ddf729938db9ca922559f3ca" translate="yes" xml:space="preserve">
          <source>.NET collections (of which there are many varieties - Lists, Dictionary, etc.) must also be instantiated or created.</source>
          <target state="translated">.NET集合(其中有很多种类----列表、字典等)也必须被实例化或创建。</target>
        </trans-unit>
        <trans-unit id="c04d4ae82bc72a4bd980abe754c0c8da8a6d3e11" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/11244949/5407188&quot;&gt;Simon Mourier gave this example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/11244949/5407188&quot;&gt;西蒙&amp;middot;穆里尔（Simon Mourier）举了这个例子&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="96e9ca8abbe2f8b39135700b77c31732f2dac12b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AndAlso&lt;/code&gt; is important. Subsequent tests will not be performed once the first &lt;code&gt;False&lt;/code&gt; condition is encountered. This allows the code to safely 'drill' into the object(s) one 'level' at a time, evaluating &lt;code&gt;myFoo.Bar&lt;/code&gt; only after (and if) &lt;code&gt;myFoo&lt;/code&gt; is determined to be valid. Object chains or paths can get quite long when coding complex objects:</source>
          <target state="translated">&lt;code&gt;AndAlso&lt;/code&gt; 也很重要。 一旦遇到第一个 &lt;code&gt;False&lt;/code&gt; 条件，将不执行后续测试。 这使代码可以一次安全地&amp;ldquo;钻探&amp;rdquo;对象一个&amp;ldquo;级别&amp;rdquo;，仅在（如果确定） &lt;code&gt;myFoo&lt;/code&gt; 有效之后评估 &lt;code&gt;myFoo.Bar&lt;/code&gt; 。 编码复杂对象时，对象链或路径可能会变得很长：</target>
        </trans-unit>
        <trans-unit id="aa6c4cd32e971c86b94f356d10264f19fc10c956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C#&lt;/code&gt; has an &quot;unsafe&quot; mode which is, as the name implies, extremely dangerous because the normal safety mechanisms which provide memory safety and type safety are not enforced. &lt;strong&gt;You should not be writing unsafe code unless you have a thorough and deep understanding of how memory works&lt;/strong&gt;.</source>
          <target state="translated">顾名思义， &lt;code&gt;C#&lt;/code&gt; 具有&amp;ldquo;不安全&amp;rdquo;模式，这是非常危险的，因为没有强制执行提供内存安全和类型安全的常规安全机制。 &lt;strong&gt;除非您对内存的工作原理有透彻和深入的了解，否则不要编写不安全的代码&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bd3d214087af937aaa899e455d518fc953c1f01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C#&lt;/code&gt; supports &quot;iterator blocks&quot; (called &quot;generators&quot; in some other popular languages).  Null dereference exceptions can be particularly tricky to debug in iterator blocks because of deferred execution:</source>
          <target state="translated">&lt;code&gt;C#&lt;/code&gt; 支持&amp;ldquo;迭代器块&amp;rdquo;（在其他一些流行语言中称为&amp;ldquo;生成器&amp;rdquo;）。 由于延迟执行，在迭代器块中调试空解除引用异常可能特别棘手：</target>
        </trans-unit>
        <trans-unit id="b65a828172fbdbfca98814450da810920765da6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fill&lt;/code&gt; is a function returning the number of &lt;code&gt;Rows&lt;/code&gt; affected which can also be tested:</source>
          <target state="translated">&lt;code&gt;Fill&lt;/code&gt; 是一个返回受影响的 &lt;code&gt;Rows&lt;/code&gt; 数的函数，也可以对其进行测试：</target>
        </trans-unit>
        <trans-unit id="29fd8c9bf04ffae44443b4d6b120d8e689bf6af6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FirstOrDefault&lt;/code&gt; returns the first item or the default value, which is &lt;code&gt;Nothing&lt;/code&gt; for reference types and never &lt;code&gt;DBNull&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;FirstOrDefault&lt;/code&gt; 返回第一项或默认值，对于引用类型为 &lt;code&gt;Nothing&lt;/code&gt; ，从不为 &lt;code&gt;DBNull&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dc1f250a72423388fb398e4efb0f2038c0f0e84a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; is implicitly cast to and from &lt;code&gt;T&lt;/code&gt; so you can use it just about anywhere you need it. For example, you can pass a &lt;code&gt;Person&lt;/code&gt; object to a method that takes a &lt;code&gt;NotNull&amp;lt;Person&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; 与 &lt;code&gt;T&lt;/code&gt; 隐式转换，因此您可以在任何需要的地方使用它。 例如，您可以将 &lt;code&gt;Person&lt;/code&gt; 对象传递给采用 &lt;code&gt;NotNull&amp;lt;Person&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="65aa590b67401c4fef80a64a246bc794d6e41210" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WPF&lt;/code&gt; controls are created during the call to &lt;code&gt;InitializeComponent&lt;/code&gt; in the order they appear in the visual tree.  A &lt;code&gt;NullReferenceException&lt;/code&gt; will be raised in the case of early-created controls with event handlers, etc. , that fire during &lt;code&gt;InitializeComponent&lt;/code&gt; which reference late-created controls.</source>
          <target state="translated">&lt;code&gt;WPF&lt;/code&gt; 控件是在调用 &lt;code&gt;InitializeComponent&lt;/code&gt; 的过程中按照它们在可视树中出现的顺序创建的。 对于带有事件处理程序等的早期创建的控件，将引发 &lt;code&gt;NullReferenceException&lt;/code&gt; ，该事件在引用早期创建的控件的 &lt;code&gt;InitializeComponent&lt;/code&gt; 期间触发。</target>
        </trans-unit>
        <trans-unit id="250ae2f1196236ab82456278c60d302569df1d86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; throws when you try to iterate null collection. Usually caused by unexpected &lt;code&gt;null&lt;/code&gt; result from methods that return collections.</source>
          <target state="translated">当您尝试迭代null集合时， &lt;code&gt;foreach&lt;/code&gt; 引发。 通常由返回集合的方法的意外 &lt;code&gt;null&lt;/code&gt; 结果引起。</target>
        </trans-unit>
        <trans-unit id="e6b825efa75e489e263e621391b24d1af984c6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; can have different meanings:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 可以具有不同的含义：</target>
        </trans-unit>
        <trans-unit id="a96f0fc9fadca9ec24ec9a32f5951496d8252794" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;ldquo;Hey wait, that member has no values so it can&amp;rsquo;t perform the task which you are handing it over.&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;ldquo;嘿，等等，该成员没有值，因此它无法执行您要移交给它的任务。&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de7fbf64ea77b998421c892cac8cea0e19d55573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The arrays and collections cannot be initialized this way.&lt;/em&gt; This initialization code will run &lt;em&gt;before&lt;/em&gt; the constructor creates the &lt;code&gt;Form&lt;/code&gt; or the &lt;code&gt;Controls&lt;/code&gt;. As a result:</source>
          <target state="translated">&lt;em&gt;数组和集合不能以这种方式初始化。&lt;/em&gt; 此初始化代码将&lt;em&gt;在&lt;/em&gt;构造函数创建 &lt;code&gt;Form&lt;/code&gt; 或 &lt;code&gt;Controls&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;运行。 结果是：</target>
        </trans-unit>
        <trans-unit id="c46586bc5c89bdef6d4b1e03c01b4dd0ec5d4806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Built-in like Nullable?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;像Nullable一样内置？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75800f606b4d1c6ba12f783ca4570bf7ff6448ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;检查参数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c09c6f450bd3f06e6cd9a53cf34fa6d2204595f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Combine with Extension&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;与扩展结合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c53baf9a2776f02becbdc77ff91727f9331686" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9982a3d97a9090ed22f6a37e2cf0f2ae71f563db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7846c489294df2d5060a36081cb8e8043018b8e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="850a808c9ba0be28dfd19e88b1b1677f0e685ba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example: Array of class objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;示例：类对象数组&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0832c4cbf43ec158d395216191b77095c211750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Missing the &lt;code&gt;New&lt;/code&gt; operator is the #1 cause of &lt;code&gt;NullReference Exceptions&lt;/code&gt;&lt;/strong&gt; seen in the Stack&amp;nbsp; Overflow questions reviewed.</source>
          <target state="translated">&lt;strong&gt;缺少 &lt;code&gt;New&lt;/code&gt; 运算符是导致 &lt;code&gt;NullReference Exceptions&lt;/code&gt; 的＃1原因，&lt;/strong&gt;在所检查的堆栈溢出问题中可见。</target>
        </trans-unit>
        <trans-unit id="65dcf051b0f8d4d6b70a92dd10d98dbbb05e7cdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d3ff5e8673cda37c5affb24969d0778d496d93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that accessing it via &lt;code&gt;a.Value&lt;/code&gt; throws an &lt;code&gt;InvalidOperationException&lt;/code&gt; instead of a &lt;code&gt;NullReferenceException&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; - you should do the check beforehand, i.e. if you have another on-nullable variable &lt;code&gt;int b;&lt;/code&gt; then you should do assignments like &lt;code&gt;if (a.HasValue) { b = a.Value; }&lt;/code&gt; or shorter &lt;code&gt;if (a != null) { b = a; }&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;请注意&lt;/strong&gt; ，如果 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则通过 &lt;code&gt;a.Value&lt;/code&gt; 访问它会引发 &lt;code&gt;InvalidOperationException&lt;/code&gt; 而不是 &lt;code&gt;NullReferenceException&lt;/code&gt; -您应该事先进行检查，即，如果您有另一个on-nullable变量 &lt;code&gt;int b;&lt;/code&gt; 那么您应该像 &lt;code&gt;if (a.HasValue) { b = a.Value; }&lt;/code&gt; }或更短， &lt;code&gt;if (a != null) { b = a; }&lt;/code&gt; } 。</target>
        </trans-unit>
        <trans-unit id="9d2ecfee61125d9d0e8d312294babd37f799e11c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; this applies to any and all control and component references making these illegal where they are:</source>
          <target state="translated">&lt;strong&gt;请注意，&lt;/strong&gt;这适用于所有和所有控件和组件引用，使它们在以下位置非法：</target>
        </trans-unit>
        <trans-unit id="fa53a7cd617380a4fd41905587ebe1ed03bfd709" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Partial Remedy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;部分补救&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b45cb9af41d027f3c66db6de15f935162538c51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plain Code Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;普通代码解决方案&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c266b17f2c6ab7e2c85ed00ba5d7beabc25b959e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reason&lt;/strong&gt;
I am still not sure about the reason. But whenever any of the entity class will extend System.Web.UI.Page this error occurs.</source>
          <target state="translated">&lt;strong&gt;原因&lt;/strong&gt;我仍然不确定原因。 但是，只要任何实体类将扩展System.Web.UI.Page，就会发生此错误。</target>
        </trans-unit>
        <trans-unit id="a268ab5a5be194c793236306a7663da71dfa4d72" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference types (these ones must be checked):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;引用类型（必须检查这些类型）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87d7c3eb34164ea52ebb8bc8dd28ee4033a68905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Related Language Feature&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;相关语言功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f132283beed6a6da06cca0d2093c020e2034387" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remedy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Remedy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00798c0e0efa455834c71c3500c45ed823e69637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR:&lt;/strong&gt; Try using &lt;code&gt;Html.Partial&lt;/code&gt; instead of &lt;code&gt;Renderpage&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;TL; DR：&lt;/strong&gt;尝试使用 &lt;code&gt;Html.Partial&lt;/code&gt; 而不是 &lt;code&gt;Renderpage&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb06fe911bd525f50ffb0ed996518a64e1313f34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is basically is a Null reference exception&lt;/strong&gt;. As &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;Microsoft&lt;/a&gt; states-</source>
          <target state="translated">&lt;strong&gt;这基本上是一个Null引用异常&lt;/strong&gt; 。 如&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;Microsoft所述-&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1aa4d335741197b3563f86a40f2c97a83f320da3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; It is worth mentioning that the term was coined by Bertrand Meyer &lt;a href=&quot;https://www.eiffel.com/values/design-by-contract/&quot;&gt;in connection with his design of the Eiffel programming language&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;值得一提的是，该术语是由Bertrand Meyer &lt;a href=&quot;https://www.eiffel.com/values/design-by-contract/&quot;&gt;与其Eiffel编程语言设计相关的&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="0181926e0a4573b951577d60df9ca7c39553610c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update C#8.0, 2019: Nullable reference types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更新C＃8.0,2019：可引用类型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72b28d75192ac7fb08e2f8d3a79cec1a52ea9e34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Tools&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用工具&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c87f2201b452dcaacc0b8af07815a06349212165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value types (you can simply ignore these ones):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;值类型（您可以简单地忽略这些类型）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6d4f708a4dc9fe6716ce23566f161236c78feea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What can you do about it?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;你能为这个做什么？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8caed790388a2aa0b4f38d928f3144b76a25e1b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;  If Break on Throws is too aggressive and the debugger stops on an NPE in the .NET or 3rd-party library, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/038tzxdw.aspx&quot;&gt;Break on User-Unhandled&lt;/a&gt; can be used to limit the exceptions caught. Additionally, VS2012 introduces &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn457346.aspx&quot;&gt;Just My Code&lt;/a&gt; which I recommend enabling as well.</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt;如果&amp;ldquo;抛出时中断&amp;rdquo;过于激进，并且调试器在.NET或3rd-party库中的NPE上停止，则可以使用&amp;ldquo; &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/038tzxdw.aspx&quot;&gt;用户未处理时中断&amp;rdquo;&lt;/a&gt;来限制捕获的异常。 另外，VS2012引入了&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn457346.aspx&quot;&gt;&amp;ldquo;我的代码&amp;rdquo;&lt;/a&gt; ，我建议也启用它。</target>
        </trans-unit>
        <trans-unit id="cf4e02ba110e4be0ec3bfb627b852463f12d2845" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MsgBox&lt;/code&gt; in the Catch which displays &lt;code&gt;Error while...&lt;/code&gt; will be of little help. This method also leads to &lt;em&gt;very bad&lt;/em&gt; Stack&amp;nbsp; Overflow questions, because you can't describe the actual exception, the object involved or even the line of code where it happens.</source>
          <target state="translated">Catch中的一个 &lt;code&gt;MsgBox&lt;/code&gt; ， &lt;code&gt;Error while...&lt;/code&gt; 时显示错误，将无济于事。 这种方法还会导致&lt;em&gt;非常糟糕的&lt;/em&gt; Stack Overflow问题，因为您无法描述实际的异常，所涉及的对象甚至发生异常的代码行。</target>
        </trans-unit>
        <trans-unit id="ba104c53b06fc122661823449802aea76782c8e0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NullReferenceException&lt;/code&gt; is thrown when we are trying to access Properties of a null object or when a string value becomes empty and we are trying to access string methods.</source>
          <target state="translated">当我们尝试访问null对象的Properties或字符串值变为空并且试图访问字符串方法时，将引发 &lt;code&gt;NullReferenceException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa5b3e9455e644e78a417418f58466e0a5a103cd" translate="yes" xml:space="preserve">
          <source>A NullReferenceException exception is thrown when you try to access a
  member of a type whose value is null.</source>
          <target state="translated">当你尝试访问一个值为空的类型成员时,会抛出一个NullReferenceException异常。</target>
        </trans-unit>
        <trans-unit id="f8ff26f3ebffad79c215bd07bdac08f78eb5f7da" translate="yes" xml:space="preserve">
          <source>A badly implemented Try/Catch can hide where the problem is and result in new ones:</source>
          <target state="translated">一个执行得不好的TryCatch会隐藏问题所在,导致新的问题出现。</target>
        </trans-unit>
        <trans-unit id="6d4ec18cde40fd73c38c9b684b0330cd485bb285" translate="yes" xml:space="preserve">
          <source>A common oversight is a class which uses a collection &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">常见的疏忽是使用集合 &lt;code&gt;Type&lt;/code&gt; 的类 ：</target>
        </trans-unit>
        <trans-unit id="d9cf0a18f606a29539af3e0ce3af33a36d691ebb" translate="yes" xml:space="preserve">
          <source>A more &quot;formal&quot; way of preventing such error conditions &lt;em&gt;while developing&lt;/em&gt; is applying &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;design by contract&lt;/a&gt;&lt;/em&gt; in your code. This means you need to set class &lt;em&gt;invariants&lt;/em&gt;, and/or even function/method &lt;em&gt;preconditions&lt;/em&gt; and &lt;em&gt;postconditions&lt;/em&gt; on your system, while developing.</source>
          <target state="translated">防止此类错误情况&lt;em&gt;发生&lt;/em&gt;的更&amp;ldquo;正式&amp;rdquo;方法是在代码中&lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;按合同&lt;/a&gt;&lt;/em&gt;应用&lt;em&gt;设计&lt;/em&gt; 。 这意味着在开发时，您需要在系统上设置类&lt;em&gt;不变式&lt;/em&gt; ，甚至函数/方法的&lt;em&gt;前提条件&lt;/em&gt;和&lt;em&gt;后置条件&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="eebbb33808aa207e49bada59a5125167df24f614" translate="yes" xml:space="preserve">
          <source>A note on null dereferences in unsafe code</source>
          <target state="translated">关于不安全代码中的空定义的说明</target>
        </trans-unit>
        <trans-unit id="8dafbafccce845b67afeb7b01438fe1945ef8d44" translate="yes" xml:space="preserve">
          <source>A nullable reference type is noted using the same syntax as nullable value types: a &lt;code&gt;?&lt;/code&gt; is appended to the type of the variable.</source>
          <target state="translated">使用与可空值类型相同的语法来记录可空引用类型： 附加到变量的类型。</target>
        </trans-unit>
        <trans-unit id="6c02c614bce01e1bf2b2913bce9723ce07012a79" translate="yes" xml:space="preserve">
          <source>A typo is a problem here: &lt;code&gt;Employees&lt;/code&gt; vs &lt;code&gt;Employee&lt;/code&gt;. There was no &lt;code&gt;DataTable&lt;/code&gt; named &quot;Employee&quot; created, so a &lt;code&gt;NullReferenceException&lt;/code&gt; results trying to access it. Another potential problem is assuming there will be &lt;code&gt;Items&lt;/code&gt; which may not be so when the SQL includes a WHERE clause.</source>
          <target state="translated">错字在这里是一个问题： &lt;code&gt;Employees&lt;/code&gt; vs &lt;code&gt;Employee&lt;/code&gt; 。 没有创建名为&amp;ldquo; Employee&amp;rdquo;的 &lt;code&gt;DataTable&lt;/code&gt; ，因此会导致 &lt;code&gt;NullReferenceException&lt;/code&gt; 尝试访问它。 另一个潜在的问题是，假设在SQL包含WHERE子句时，可能不会有Item。</target>
        </trans-unit>
        <trans-unit id="f6a5c83300e66ad46127b977adb89a522156c686" translate="yes" xml:space="preserve">
          <source>ASP.NET MVC empty view models</source>
          <target state="translated">ASP.NET MVC空视图模型</target>
        </trans-unit>
        <trans-unit id="80c38c96a03773866e5a09fd7dd429a0be9d8b8b" translate="yes" xml:space="preserve">
          <source>ASP.NET Page Life cycle:</source>
          <target state="translated">ASP.NET页面生命周期。</target>
        </trans-unit>
        <trans-unit id="3f5c6dc0c3d2cadb4509844c76624cbfb304e229" translate="yes" xml:space="preserve">
          <source>ASP.NET Session Values</source>
          <target state="translated">ASP.NET会话值</target>
        </trans-unit>
        <trans-unit id="940be3748f3da7281fcd8700b0e3178729d37f82" translate="yes" xml:space="preserve">
          <source>Access Levels in Visual Basic</source>
          <target state="translated">Visual Basic中的访问级别</target>
        </trans-unit>
        <trans-unit id="b85c4bdae0c350f5711f14487cc734ddd712d0bb" translate="yes" xml:space="preserve">
          <source>Add a RigidBody to your object with AddComponent &amp;gt; Physics &amp;gt; Rigidbody</source>
          <target state="translated">使用AddComponent&amp;gt; Physics&amp;gt; Rigidbody将RigidBody添加到您的对象</target>
        </trans-unit>
        <trans-unit id="3c06a5e5b3bffeb1ffe32764c5df1d75e8641b16" translate="yes" xml:space="preserve">
          <source>Adding a case when the class name for entity used in entity framework is same as class name for a web form code-behind file.</source>
          <target state="translated">增加一个实体框架中使用的实体类名称与Web表单代码后面文件的类名称相同的情况。</target>
        </trans-unit>
        <trans-unit id="64da57dde1ffb2a7b141dfc69a64073197586ac7" translate="yes" xml:space="preserve">
          <source>Alternatively, design by contract can be applied using &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Assertion_%28software_development%29&quot;&gt;assertions&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">或者，可以使用&lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Assertion_%28software_development%29&quot;&gt;断言&lt;/a&gt;&lt;/em&gt;来应用按合同设计。</target>
        </trans-unit>
        <trans-unit id="b7effb34e016a409606b0e15fd08ec8c4497e3b4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;(ComboBox5.SelectedItem IsNot Nothing) AndAlso...&lt;/code&gt;</source>
          <target state="translated">或者，您可以使用 &lt;code&gt;(ComboBox5.SelectedItem IsNot Nothing) AndAlso...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5666d3ec19bdd1846f3f244409d303ff8154592b" translate="yes" xml:space="preserve">
          <source>Although I have a feeling it was because Visual Studio was misreading the ampersands and brackets.</source>
          <target state="translated">虽然我有一种感觉,那是因为Visual Studio读错了安培号和括号。</target>
        </trans-unit>
        <trans-unit id="9fd253c7dc5c61cba35ce66730957de70d270eee" translate="yes" xml:space="preserve">
          <source>Always initialize your objects before you try to do anything with them.</source>
          <target state="translated">在你尝试对对象做任何事情之前,一定要先初始化你的对象。</target>
        </trans-unit>
        <trans-unit id="3b6e8a6740e24bceb43df548fef899179aae1d8a" translate="yes" xml:space="preserve">
          <source>Among other things, this code does not anticipate that the user may not have selected something in one or more UI controls.  &lt;code&gt;ListBox1.SelectedItem&lt;/code&gt; may well be &lt;code&gt;Nothing&lt;/code&gt;, so &lt;code&gt;ListBox1.SelectedItem.ToString&lt;/code&gt; will result in an NRE.</source>
          <target state="translated">除其他外，此代码无法预期用户可能未在一个或多个UI控件中选择某些内容。 &lt;code&gt;ListBox1.SelectedItem&lt;/code&gt; 可能为 &lt;code&gt;Nothing&lt;/code&gt; ，因此 &lt;code&gt;ListBox1.SelectedItem.ToString&lt;/code&gt; 将导致NRE。</target>
        </trans-unit>
        <trans-unit id="88a4f159e8121bbcda704144caf67fd92f8461ea" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;Catch&lt;/code&gt; block is the devil's playground. This OP was baffled why he was getting an NRE in the &lt;code&gt;Finally&lt;/code&gt; block. In other situations, an empty &lt;code&gt;Catch&lt;/code&gt; may result in something else much further downstream going haywire and cause you to spend time looking at the wrong things in the wrong place for the problem. (The &quot;silent exception&quot; described above provides the same entertainment value.)</source>
          <target state="translated">一个空的 &lt;code&gt;Catch&lt;/code&gt; 块是魔鬼的游乐场。 这个OP令他为何在Final块中获得NRE感到困惑。 在其他情况下，空的 &lt;code&gt;Catch&lt;/code&gt; 可能会导致下游进一步混乱，并导致您花费时间在错误的地方寻找错误的地方以解决问题。 （上述&amp;ldquo;静默例外&amp;rdquo;提供相同的娱乐价值。）</target>
        </trans-unit>
        <trans-unit id="9157a41acb7ec9a4b1beccee4b4d84c91c8fa2d2" translate="yes" xml:space="preserve">
          <source>An example of this exception being thrown is: When you are trying to check something, that is null.</source>
          <target state="translated">这个异常被抛出的一个例子是:当你试图检查某个东西时,它是空的。</target>
        </trans-unit>
        <trans-unit id="a1ec28efc8675e603132b97526fc40e135d46f85" translate="yes" xml:space="preserve">
          <source>And here is an example of how it could be used:</source>
          <target state="translated">这里举个例子,说明如何使用它。</target>
        </trans-unit>
        <trans-unit id="e727d2eac2d0a071ac7dcfe039aef6ace695286e" translate="yes" xml:space="preserve">
          <source>And it worked.</source>
          <target state="translated">而且成功了。</target>
        </trans-unit>
        <trans-unit id="324e44de5ebb6296d39aa1bfc28925673b0c6b21" translate="yes" xml:space="preserve">
          <source>Another case where &lt;code&gt;NullReferenceExceptions&lt;/code&gt; can happen is the (incorrect) use of the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/as&quot;&gt;&lt;code&gt;as&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;NullReferenceExceptions&lt;/code&gt; 可能发生的另一种情况是（错误）使用&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/as&quot;&gt; &lt;code&gt;as&lt;/code&gt; 运算符&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="faf985078920eb0c5453270c90bdc97bdefa6713" translate="yes" xml:space="preserve">
          <source>Another general case where one might receive this exception involves mocking classes during unit testing. Regardless of the mocking framework being used, you must ensure that all appropriate levels of the class hierarchy are properly mocked. In particular, all properties of &lt;code&gt;HttpContext&lt;/code&gt; which are referenced by the code under test must be mocked.</source>
          <target state="translated">可能会收到此异常的另一种常见情况涉及在单元测试期间模拟类。 无论使用哪种模拟框架，都必须确保正确模拟了类层次结构的所有适当级别。 特别是，必须模拟被测试代码引用的 &lt;code&gt;HttpContext&lt;/code&gt; 的所有属性。</target>
        </trans-unit>
        <trans-unit id="defecdb8e8875605297d57b7667ccb8e2cd0b5be" translate="yes" xml:space="preserve">
          <source>Another scenario is when you cast a null object into a &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;value type&lt;/a&gt;. For example, the code below:</source>
          <target state="translated">另一种情况是将空对象转换为&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;值类型时&lt;/a&gt; 。 例如，下面的代码：</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="66865b7becb2eab1937b4ac3fd0252b0e3a5b1a9" translate="yes" xml:space="preserve">
          <source>Array Elements</source>
          <target state="translated">阵列元素</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="b6fa4a287953008cbde69102b90389d57d42adc5" translate="yes" xml:space="preserve">
          <source>Arrays in Visual Basic</source>
          <target state="translated">Visual Basic中的数组</target>
        </trans-unit>
        <trans-unit id="d1699665973226819efc1a3192672777466c31f6" translate="yes" xml:space="preserve">
          <source>Arrays must also be instantiated:</source>
          <target state="translated">数组也必须被实例化。</target>
        </trans-unit>
        <trans-unit id="38bc53bbadc56c1c1c3af2a66bca49127ec6ded9" translate="yes" xml:space="preserve">
          <source>As before, the &lt;code&gt;ds&lt;/code&gt; Dataset object was declared, but an instance was never created. The &lt;code&gt;DataAdapter&lt;/code&gt; will fill an existing &lt;code&gt;DataSet&lt;/code&gt;, not create one. In this case, since &lt;code&gt;ds&lt;/code&gt; is a local variable, &lt;em&gt;the IDE warns you&lt;/em&gt; that this might happen:</source>
          <target state="translated">和以前一样，声明了 &lt;code&gt;ds&lt;/code&gt; Dataset对象，但是从未创建实例。 &lt;code&gt;DataAdapter&lt;/code&gt; 将填充现有的 &lt;code&gt;DataSet&lt;/code&gt; ，而不创建一个。 在这种情况下，由于 &lt;code&gt;ds&lt;/code&gt; 是局部变量， &lt;em&gt;因此IDE警告您&lt;/em&gt;可能会发生这种情况：</target>
        </trans-unit>
        <trans-unit id="a8225bf15fe959f426e87bc59fb66f54584b8477" translate="yes" xml:space="preserve">
          <source>As before, this is incorrect:</source>
          <target state="translated">如前所述,这是不正确的。</target>
        </trans-unit>
        <trans-unit id="34d0293b6d44a69f8098139a2697ae8c8c463b8c" translate="yes" xml:space="preserve">
          <source>As before, you can test for Nothing, then for a specific value:</source>
          <target state="translated">和之前一样,你可以测试Nothing,然后再测试一个特定的值。</target>
        </trans-unit>
        <trans-unit id="8c8719c108394130c727bec7ba9f10b86c8bcb74" translate="yes" xml:space="preserve">
          <source>As seen in the above code, the statement 
&lt;strong&gt;Student s&lt;/strong&gt; - only declares the variable of type Student, note that the Student class is not instantiated at this point.
Hence, when the statement &lt;strong&gt;s.GetFullName()&lt;/strong&gt; gets executed, it will throw the NullReferenceException.</source>
          <target state="translated">如上面的代码所示，语句&lt;strong&gt;Student s-&lt;/strong&gt;仅声明了Student类型的变量，请注意，此时尚未实例化Student类。 因此，当执行&lt;strong&gt;s.GetFullName（）&lt;/strong&gt;语句时，它将抛出NullReferenceException。</target>
        </trans-unit>
        <trans-unit id="0238c2f1a73f80203ea54ce74e1fa5c52ec85a2b" translate="yes" xml:space="preserve">
          <source>As you can see above as with nullable you would access the underlying value through the &lt;code&gt;Value&lt;/code&gt; property. Alternatively, you can use an explicit or implicit cast, you can see an example with the return value below:</source>
          <target state="translated">正如您在上面看到的具有nullable的那样，您将通过 &lt;code&gt;Value&lt;/code&gt; 属性访问基础值。 另外，您可以使用显式或隐式强制转换，可以在下面看到带有返回值的示例：</target>
        </trans-unit>
        <trans-unit id="55898edce8a3dc771bf65a61dd6c66bcff4e10b3" translate="yes" xml:space="preserve">
          <source>Assume that you have a class named Student.</source>
          <target state="translated">假设你有一个班级叫学生。</target>
        </trans-unit>
        <trans-unit id="be34f295e410696ad2a87bdbe307bddd6ac8d2e7" translate="yes" xml:space="preserve">
          <source>Basic Meaning</source>
          <target state="translated">基本含义</target>
        </trans-unit>
        <trans-unit id="f2896aad58b9a8eecc0ba25ee5c59866bcde93ab" translate="yes" xml:space="preserve">
          <source>Be aware that regardless of the scenario, the cause is always the same in .NET:</source>
          <target state="translated">要注意的是,无论在.NET中,无论什么情况下,原因都是一样的。</target>
        </trans-unit>
        <trans-unit id="4b8773ed0bc20f439c181fd5242b7f12bd9a63f5" translate="yes" xml:space="preserve">
          <source>Both a null pointer and a null reference in &lt;code&gt;C#&lt;/code&gt; are internally represented as the number zero, and so any attempt to dereference it into its corresponding memory storage causes the operating system to produce an error. The .NET runtime then detects this error and turns it into the null dereference exception.</source>
          <target state="translated">&lt;code&gt;C#&lt;/code&gt; 中的空指针和空引用在内部都表示为数字零，因此任何尝试将其取消引用到其相应的内存中的操作都会导致操作系统产生错误。 然后，.NET运行时将检测到此错误，并将其转换为null取消引用异常。</target>
        </trans-unit>
        <trans-unit id="80ab619b17d9355ace0bbedb905733aed5398463" translate="yes" xml:space="preserve">
          <source>Bottom Line</source>
          <target state="translated">底线</target>
        </trans-unit>
        <trans-unit id="21a8752f2df54d656b09cd2a499cb3a3403ec7ca" translate="yes" xml:space="preserve">
          <source>Breakpoints</source>
          <target state="translated">Breakpoints</target>
        </trans-unit>
        <trans-unit id="86d14f9a7de18ff1120d5c17aa3bb8490cf58228" translate="yes" xml:space="preserve">
          <source>But I was able to run the application with no problems with this &quot;error&quot;. I was able to get rid of the error by changing the structure of the &lt;code&gt;foreach&lt;/code&gt; loop to look like this:</source>
          <target state="translated">但是我能够运行该应用程序而不会出现&amp;ldquo;错误&amp;rdquo;问题。 通过将 &lt;code&gt;foreach&lt;/code&gt; 循环的结构更改为如下所示，我可以消除该错误：</target>
        </trans-unit>
        <trans-unit id="342f568362575e92cb6067d8461a39a6a40941c4" translate="yes" xml:space="preserve">
          <source>But if you set &quot;property X must never have a null value&quot; as method precondition, then you can prevent the scenario described before:</source>
          <target state="translated">但如果设置 &quot;属性X绝对不能有一个空值 &quot;作为方法前提条件,那么就可以防止前面描述的情况。</target>
        </trans-unit>
        <trans-unit id="8e174293e71614f4dcd5e8efa21b20f2c2ea09dd" translate="yes" xml:space="preserve">
          <source>By doing that and making PostSharp part of your build process &lt;code&gt;obj&lt;/code&gt; will be checked for null at runtime. See: &lt;a href=&quot;http://www.postsharp.net/blog/post/Validating-parameters-field-and-properties-in-PostSharp-3&quot;&gt;PostSharp null check&lt;/a&gt;</source>
          <target state="translated">通过这样做并将PostSharp纳入构建过程的一部分，将在运行时检查 &lt;code&gt;obj&lt;/code&gt; 是否为null。 请参阅： &lt;a href=&quot;http://www.postsharp.net/blog/post/Validating-parameters-field-and-properties-in-PostSharp-3&quot;&gt;PostSharp空检查&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64c2e10dbbbf9ef720a7c8d02d4aa8e8cf77773e" translate="yes" xml:space="preserve">
          <source>By finding by name I mean some framework allow you to FIndObjects using strings and the code might look like this: &lt;strong&gt;FindObject(&quot;ObjectName&quot;);&lt;/strong&gt;</source>
          <target state="translated">通过名称查找，我的意思是某些框架允许您使用字符串来查找对象，并且代码可能如下所示： &lt;strong&gt;FindObject（&amp;ldquo; ObjectName&amp;rdquo;）;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d2fbdf206c06f82b8ff7b2a9385b7bc273f6c" translate="yes" xml:space="preserve">
          <source>By following the program flow this way, you can find the location where the instance should not be null, and why it isn't properly set.</source>
          <target state="translated">按照这样的程序流程,你可以找到实例不应该为空的位置,以及为什么没有正确设置的原因。</target>
        </trans-unit>
        <trans-unit id="0af3e909e29bebca060f842d0113445956bb71a3" translate="yes" xml:space="preserve">
          <source>By writing a null check like this you prevent the null dereference, but you move the null argument exception to the point of the &lt;em&gt;iteration&lt;/em&gt;, not to the point of the &lt;em&gt;call&lt;/em&gt;, and that is &lt;em&gt;very confusing to debug&lt;/em&gt;.</source>
          <target state="translated">通过编写这样的null检查，可以防止null取消引用，但是可以将null参数异常移到&lt;em&gt;迭代&lt;/em&gt;点，而不是&lt;em&gt;调用&lt;/em&gt;点，这会使&lt;em&gt;调试非常混乱&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="910e894dcb9055a378eccef35ef795771f7bb251" translate="yes" xml:space="preserve">
          <source>C# 6.0 introduced the &quot;null-conditional operator&quot; that helps with this a little. With this feature, you can reference nested objects and if any one of them is &lt;code&gt;null&lt;/code&gt; the whole expression returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">C＃6.0引入了&amp;ldquo;空条件运算符&amp;rdquo;，它对此有所帮助。 使用此功能，您可以引用嵌套对象，如果其中任何一个为 &lt;code&gt;null&lt;/code&gt; ,则整个表达式将返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06971ac0fe2094d0b96705ec2de4ff7f4c00141d" translate="yes" xml:space="preserve">
          <source>C# has a nice shorthand for &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, you can make something nullable by putting a question mark after the type like so &lt;code&gt;int?&lt;/code&gt;.</source>
          <target state="translated">C＃有一个很好的 &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; 速记，您可以通过在问号后面加一个问号使 &lt;code&gt;int?&lt;/code&gt; 变成可空值？ 。</target>
        </trans-unit>
        <trans-unit id="3d4cb34a5ed28713ba6e8d1854e778ef083e674d" translate="yes" xml:space="preserve">
          <source>C#8.0 introduces &lt;strong&gt;nullable reference types&lt;/strong&gt; and &lt;strong&gt;non-nullable reference types&lt;/strong&gt;. So only nullable reference types must be checked to avoid a &lt;strong&gt;NullReferenceException&lt;/strong&gt;.</source>
          <target state="translated">C＃8.0引入了&lt;strong&gt;可为空的引用类型&lt;/strong&gt;和&lt;strong&gt;不可为空的引用类型&lt;/strong&gt; 。 因此，仅必须检查可为空的引用类型，以避免&lt;strong&gt;NullReferenceException&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8dc39f8dd9c9e597efd5512af193d73bcc466778" translate="yes" xml:space="preserve">
          <source>Cast with &lt;code&gt;as&lt;/code&gt;</source>
          <target state="translated">投放 &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da4e05c5dc0d067c4057445c2673b31a895c9b01" translate="yes" xml:space="preserve">
          <source>Changing the order of the declarations in the &lt;code&gt;XAML&lt;/code&gt; (i.e., listing &lt;code&gt;label1&lt;/code&gt; before &lt;code&gt;comboBox1&lt;/code&gt;, ignoring issues of design philosophy, would at least resolve the &lt;code&gt;NullReferenceException&lt;/code&gt; here.</source>
          <target state="translated">更改 &lt;code&gt;XAML&lt;/code&gt; 中声明的顺序（即，在 &lt;code&gt;comboBox1&lt;/code&gt; 之前列出 &lt;code&gt;label1&lt;/code&gt; ，而忽略设计哲学问题）至少会在这里解决 &lt;code&gt;NullReferenceException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f13d71f0e899fe3b305b742c14c426e502ee6355" translate="yes" xml:space="preserve">
          <source>Class Objects / Creating an Instance</source>
          <target state="translated">类对象 创建一个实例</target>
        </trans-unit>
        <trans-unit id="a6748432889326a79c007d1ba17c6c7cd3373670" translate="yes" xml:space="preserve">
          <source>Collection/List/Dictionary</source>
          <target state="translated">Collection/List/Dictionary</target>
        </trans-unit>
        <trans-unit id="ac972fde3be5ca3a4dcab0cc67b75680615eb722" translate="yes" xml:space="preserve">
          <source>Combine &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; with an extension method and you can cover even more situations. Here is an example of what the extension method can look like:</source>
          <target state="translated">将 &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; 与扩展方法结合使用，您可以涵盖更多的情况。 这是扩展方法的示例：</target>
        </trans-unit>
        <trans-unit id="223c2967787ab7e442128765b6827c843685a817" translate="yes" xml:space="preserve">
          <source>Compiler for the above code raises an error that variable &lt;strong&gt;obj&lt;/strong&gt; is unassigned which signifies that our variable has null values or nothing. Compiler for the above code raises an error that variable &lt;strong&gt;obj&lt;/strong&gt; is unassigned which signifies that our variable has null values or nothing.</source>
          <target state="translated">上面的代码的编译器会产生一个错误，指出未分配变量&lt;strong&gt;obj&lt;/strong&gt; ，这表明我们的变量具有空值或什么都没有。 上面的代码的编译器会产生一个错误，指出未分配变量&lt;strong&gt;obj&lt;/strong&gt; ，这表明我们的变量具有空值或什么都没有。</target>
        </trans-unit>
        <trans-unit id="bee75ca77f753e4846b455441733f6641c4bf287" translate="yes" xml:space="preserve">
          <source>Controls</source>
          <target state="translated">Controls</target>
        </trans-unit>
        <trans-unit id="1ca5b6d459cb7e4e8503007684404f6a2c26c9c9" translate="yes" xml:space="preserve">
          <source>DBNull is not the same as Nothing</source>
          <target state="translated">DBNull与Nothing不一样</target>
        </trans-unit>
        <trans-unit id="428b235126d11ccf77cf5d994238ed0919097855" translate="yes" xml:space="preserve">
          <source>Data Provider Objects</source>
          <target state="translated">数据提供者对象</target>
        </trans-unit>
        <trans-unit id="5568339e9f5e145b4c2866450e19d8cc65b1f7d3" translate="yes" xml:space="preserve">
          <source>Debug and let the debugger break... It will directly take you to the variable that is broken... Now your task is to simply fix this.. Using the &lt;strong&gt;new&lt;/strong&gt; keyword in the appropriate place.</source>
          <target state="translated">调试并让调试器中断...它将直接带您到已损坏的变量...现在您的任务是简单地解决此问题。.在适当的位置使用&lt;strong&gt;new&lt;/strong&gt;关键字。</target>
        </trans-unit>
        <trans-unit id="6f0b5050efbdbd9b4e9f63b62af3e9fede37125c" translate="yes" xml:space="preserve">
          <source>Debugger: For developers, we have the big weapon of Debugging with us. If have we face NullReferenceException during the development face we can use the debugger to get to the source of the exception.</source>
          <target state="translated">调试器。对于开发者来说,我们身边有一个大的武器就是调试器。如果我们在开发过程中遇到了NullReferenceException,我们可以通过调试器找到异常的源头。</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="36fd56a44db41a6f009807b50cd27bc9943148b1" translate="yes" xml:space="preserve">
          <source>Debugging showed the model was Null inside MyOtherView. Until I changed it to:</source>
          <target state="translated">调试显示MyOtherView内部的模型为Null。直到我把它改成了。</target>
        </trans-unit>
        <trans-unit id="f2bef4698e9e93b03fbe4d5bae9a889cb96e1075" translate="yes" xml:space="preserve">
          <source>Don't ignore compiler warnings (ever) and use &lt;code&gt;Option Strict On&lt;/code&gt; (always).</source>
          <target state="translated">永远不要忽略编译器警告，而要始终使用 &lt;code&gt;Option Strict On&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a116c71d483a8e062649940a075d035fe0d15e1c" translate="yes" xml:space="preserve">
          <source>Don't use empty Try/Catch blocks - let the code crash so you can a) identify the cause b) identify the location and c) apply a proper remedy.  Try/Catch blocks are not intended to hide exceptions from the person uniquely qualified to fix them - the developer.</source>
          <target state="translated">不要使用空的 TryCatch 块-让代码崩溃,这样你就可以 a)确定原因 b)确定位置 c)应用适当的补救措施。TryCatch 块的目的不是为了向有资格修复异常的人--开发人员--隐藏异常。</target>
        </trans-unit>
        <trans-unit id="d7f04facb7d4fb7422ce98a991d56e72f4d24f7c" translate="yes" xml:space="preserve">
          <source>Edge case #1: concurrent access to a Dictionary</source>
          <target state="translated">边缘情况#1:同时访问一个字典</target>
        </trans-unit>
        <trans-unit id="e3ea50cc0b7f4be81be2362bf41478f7130a1285" translate="yes" xml:space="preserve">
          <source>Edge case #2: unsafe code</source>
          <target state="translated">边缘案例2:不安全代码</target>
        </trans-unit>
        <trans-unit id="6a6853d6e749e4d5b00c4b8d872d66e337db122a" translate="yes" xml:space="preserve">
          <source>Either procedure will result in an NRE, because &lt;code&gt;barList&lt;/code&gt; is only declared, not instantiated. Creating an instance of &lt;code&gt;Foo&lt;/code&gt; will not also create an instance of the internal &lt;code&gt;barList&lt;/code&gt;. It may have been the intent to do this in the constructor:</source>
          <target state="translated">这两个过程都将导致NRE，因为只声明了 &lt;code&gt;barList&lt;/code&gt; ，没有实例化它。 创建 &lt;code&gt;Foo&lt;/code&gt; 的实例也不会创建内部 &lt;code&gt;barList&lt;/code&gt; 的实例。 可能是想在构造函数中执行此操作：</target>
        </trans-unit>
        <trans-unit id="46f567c4dcc5486e4285b45b12d7a9a6e106f7ff" translate="yes" xml:space="preserve">
          <source>Enjoy and have fun making games!</source>
          <target state="translated">尽情享受并享受制作游戏的乐趣吧!</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="2ede17026a66f2bb53f3b6978daa3529c4d3bc25" translate="yes" xml:space="preserve">
          <source>Ex:</source>
          <target state="translated">Ex:</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7b7d48ea7b3b293c238f8dc4cd94aa16d688011e" translate="yes" xml:space="preserve">
          <source>Example 2 &amp;mdash; Beware of the NewRow</source>
          <target state="translated">示例2 &amp;mdash;提防NewRow</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="deec6b3c379dce2b6012e423f46c379377857030" translate="yes" xml:space="preserve">
          <source>Examples and Remedies</source>
          <target state="translated">例子和补救措施</target>
        </trans-unit>
        <trans-unit id="489c7f142f084f70e38f635ba7b9b348e5d129a5" translate="yes" xml:space="preserve">
          <source>Exception handling: One of the important ways of managing this exception. Using simple try-catch-finally blocks we can control this exception and also maintain a log of it. This can be very useful when your application is on production stage.</source>
          <target state="translated">异常处理。管理这个异常的重要方法之一。使用简单的 try-catch-finally 块,我们可以控制这个异常,并且还可以维护它的日志。当你的应用程序处于生产阶段时,这可能是非常有用的。</target>
        </trans-unit>
        <trans-unit id="863e0b11b844698fd5b45fe2becd1c066657e73f" translate="yes" xml:space="preserve">
          <source>Explicit Checking: We should adhere to the tradition of checking the objects, properties, methods, arrays, and collections whether they are null. This can be simply implemented using conditional statements like if-else if-else etc.</source>
          <target state="translated">显式检查。我们应该坚持检查对象、属性、方法、数组、集合是否为空的传统。这可以简单的用条件语句来实现,如if-else if-else等。</target>
        </trans-unit>
        <trans-unit id="109df3f9e4f70aee4ff4534f310fc794f8dc97d8" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; and ignore null values.</source>
          <target state="translated">明确检查 &lt;code&gt;null&lt;/code&gt; 并忽略null值。</target>
        </trans-unit>
        <trans-unit id="31543b579bc99ae672e332aadbdf4f54893ffe8c" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; and provide a default value.</source>
          <target state="translated">明确检查 &lt;code&gt;null&lt;/code&gt; 并提供默认值。</target>
        </trans-unit>
        <trans-unit id="be6cb31f6768070d27ac716dcf02c1e5b5d94512" translate="yes" xml:space="preserve">
          <source>Explicitly check for &lt;code&gt;null&lt;/code&gt; from method calls and throw a custom exception.</source>
          <target state="translated">显式检查方法调用中是否为 &lt;code&gt;null&lt;/code&gt; 并引发自定义异常。</target>
        </trans-unit>
        <trans-unit id="376a5f377acf229980dec162e286875baba55137" translate="yes" xml:space="preserve">
          <source>Finding The Cause</source>
          <target state="translated">寻找原因</target>
        </trans-unit>
        <trans-unit id="036893902b168b7c15417cf8b62f2cd292a4a2cd" translate="yes" xml:space="preserve">
          <source>First, make sure that the correct error is going to be caught - see
&lt;a href=&quot;https://stackoverflow.com/questions/4475464/&quot;&gt;How do I allow breaking on 'System.NullReferenceException' in VS2010?&lt;/a&gt;&lt;em&gt;Note&lt;sup&gt;1&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">首先，确保将捕获正确的错误-请参阅&lt;a href=&quot;https://stackoverflow.com/questions/4475464/&quot;&gt;VS2010中的&amp;ldquo; System.NullReferenceException&amp;rdquo;如何允许中断？&lt;/a&gt; &lt;em&gt;注&lt;sup&gt;1&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a9bb411b345b451f4de56294a2e04b8bb44acd7" translate="yes" xml:space="preserve">
          <source>Floating-point types</source>
          <target state="translated">浮动点类型</target>
        </trans-unit>
        <trans-unit id="c3b57bba0c6478be6c3878f4976f8768bd6104c1" translate="yes" xml:space="preserve">
          <source>For More details : &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators&quot;&gt;Null-conditional Operators&lt;/a&gt;</source>
          <target state="translated">有关更多详细信息： &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators&quot;&gt;空条件运算符&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d625573dda6be4c24b311020c3d5caa8ee0507c" translate="yes" xml:space="preserve">
          <source>For discussion have a look at &lt;a href=&quot;https://stackoverflow.com/questions/17136455/nullreferenceexception-in-dbcontext-savechanges&quot;&gt;NullReferenceException in DbContext.saveChanges()&lt;/a&gt;</source>
          <target state="translated">为了讨论，请查看&lt;a href=&quot;https://stackoverflow.com/questions/17136455/nullreferenceexception-in-dbcontext-savechanges&quot;&gt;DbContext.saveChanges（）中的NullReferenceException&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88fa3152aa1a080052016562134c18cdbc4e0603" translate="yes" xml:space="preserve">
          <source>For example :</source>
          <target state="translated">比如说:</target>
        </trans-unit>
        <trans-unit id="21d6357b4a277981b9a66afc8fcee08849d0a240" translate="yes" xml:space="preserve">
          <source>For example, methods can check the different arguments to see if they are null and throw an &lt;code&gt;ArgumentNullException&lt;/code&gt;, an exception obviously created for this exact purpose.</source>
          <target state="translated">例如，方法可以检查不同的参数以查看它们是否为空，并抛出 &lt;code&gt;ArgumentNullException&lt;/code&gt; ，显然是为此目的而创建的异常。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="ea87f510412c7e56ffdecaf29378fffd0b2ac212" translate="yes" xml:space="preserve">
          <source>For instance,
in the following line the only code that &lt;em&gt;can&lt;/em&gt; cause the exception is if &lt;code&gt;myString&lt;/code&gt; evaluates to null. This can be verified by looking at the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa290869(v=vs.71).aspx&quot;&gt;Watch Window&lt;/a&gt; or running expressions in the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/f177hahy.aspx&quot;&gt;Immediate Window&lt;/a&gt;.</source>
          <target state="translated">例如，在以下行中，唯一导致该异常的代码是 &lt;code&gt;myString&lt;/code&gt; 的评估结果是否为null。 可以通过查看&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa290869(v=vs.71).aspx&quot;&gt;监视窗口&lt;/a&gt;或在&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/f177hahy.aspx&quot;&gt;即时窗口中&lt;/a&gt;运行表达式来验证这一点。</target>
        </trans-unit>
        <trans-unit id="d3ab9060f75e800aa736a6c6d4a9d5f39e13be8b" translate="yes" xml:space="preserve">
          <source>For me the reason was that I had rename the file and old file was still open.</source>
          <target state="translated">对我来说,原因是我重命名了文件,而旧文件还在打开。</target>
        </trans-unit>
        <trans-unit id="ae336d2485d45668cf4b510dc35f9a49b357aa3b" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx&quot;&gt;&lt;code&gt;List(Of T)&lt;/code&gt; Class&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx&quot;&gt; &lt;code&gt;List(Of T)&lt;/code&gt; 类&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cadad1fb936cd59a173ee4ad751226d192504b1" translate="yes" xml:space="preserve">
          <source>For more information, see:</source>
          <target state="translated">欲了解更多信息,请参见:</target>
        </trans-unit>
        <trans-unit id="4b6396c3009607565ca4b596f1d3cfe993427c34" translate="yes" xml:space="preserve">
          <source>For the sake of completeness DataContext class</source>
          <target state="translated">为了完整起见,DataContext类</target>
        </trans-unit>
        <trans-unit id="f241b5f4ab6b5874d32e0e2ef564edcc65cde7d2" translate="yes" xml:space="preserve">
          <source>For this cause, &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264808%28v=vs.110%29.aspx&quot;&gt;Code Contracts&lt;/a&gt;&lt;/em&gt; project exists for .NET applications.</source>
          <target state="translated">因此，存在用于.NET应用程序的&lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264808%28v=vs.110%29.aspx&quot;&gt;Code Contracts&lt;/a&gt;&lt;/em&gt;项目。</target>
        </trans-unit>
        <trans-unit id="6cfbd5392a130ba8fc377b758d8e7cdc4f1a9d51" translate="yes" xml:space="preserve">
          <source>For your reference I made the code above available on GitHub, you can find it at:</source>
          <target state="translated">为了供大家参考,我在GitHub上提供了上面的代码,你可以在以下网址找到它。</target>
        </trans-unit>
        <trans-unit id="c4a1d4b8ee2b3e9ff148b30c5b4c8d7bb468ba9c" translate="yes" xml:space="preserve">
          <source>Function Returning Nothing</source>
          <target state="translated">函数返回无</target>
        </trans-unit>
        <trans-unit id="bda3e991f9ccd7f64923695508d53cbd3f8354a4" translate="yes" xml:space="preserve">
          <source>Further Notes: If you want unity to add a component to your object and you might have forgotten to add one, you can type &lt;code&gt;[RequireComponent(typeof(RigidBody))]&lt;/code&gt; above your class declaration (the space below all of your usings).</source>
          <target state="translated">附加说明：如果要统一向对象添加组件，并且可能忘记添加一个组件，则可以在类声明上方（所有用法下方的空格 &lt;code&gt;[RequireComponent(typeof(RigidBody))]&lt;/code&gt; 键入[RequireComponent（typeof（RigidBody））] 。</target>
        </trans-unit>
        <trans-unit id="6ba86cf22af12011257223c782b9c2388170dce0" translate="yes" xml:space="preserve">
          <source>Furthermore, the reason I didn't have &lt;code&gt;Html.Partial&lt;/code&gt; to begin with was because Visual Studio &lt;strong&gt;sometimes&lt;/strong&gt; throws error-looking squiggly lines under &lt;code&gt;Html.Partial&lt;/code&gt; if it's inside a differently constructed &lt;code&gt;foreach&lt;/code&gt; loop, even though it's not really an error:</source>
          <target state="translated">此外，我之所以没有 &lt;code&gt;Html.Partial&lt;/code&gt; 的原因是因为Visual Studio &lt;strong&gt;有时&lt;/strong&gt;会在 &lt;code&gt;Html.Partial&lt;/code&gt; 下抛出看似扭曲的行，即使它不是在错误构造的 &lt;code&gt;foreach&lt;/code&gt; 循环中，即使它不是在错误中：</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="84ae2f625a61a0ac0cabba1b58ebdefb9ccdd612" translate="yes" xml:space="preserve">
          <source>Generic dictionaries in .NET are not thread-safe and they &lt;em&gt;sometimes&lt;/em&gt; might throw a &lt;code&gt;NullReference&lt;/code&gt; or even (more frequent) a &lt;code&gt;KeyNotFoundException&lt;/code&gt; when you try to access a key from two concurrent threads. The exception is quite misleading in this case.</source>
          <target state="translated">.NET中的通用词典不是线程安全的，当您尝试从两个并发线程访问键时，它们&lt;em&gt;有时&lt;/em&gt;可能会抛出 &lt;code&gt;NullReference&lt;/code&gt; 甚至是（更常见） &lt;code&gt;KeyNotFoundException&lt;/code&gt; 。 在这种情况下，例外情况非常容易引起误解。</target>
        </trans-unit>
        <trans-unit id="5442e2b64fa09764b9f593867e59a97292c84059" translate="yes" xml:space="preserve">
          <source>GitHub</source>
          <target state="translated">GitHub</target>
        </trans-unit>
        <trans-unit id="d0a42f917789ed1adb6c6963e61a12fd3ef2255b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;comboBox1&lt;/code&gt; is created before &lt;code&gt;label1&lt;/code&gt;. If &lt;code&gt;comboBox1_SelectionChanged&lt;/code&gt; attempts to reference `label1, it will not yet have been created.</source>
          <target state="translated">在这里， &lt;code&gt;comboBox1&lt;/code&gt; 在 &lt;code&gt;label1&lt;/code&gt; 之前创建。 如果 &lt;code&gt;comboBox1_SelectionChanged&lt;/code&gt; 尝试引用`label1，则尚未创建。</target>
        </trans-unit>
        <trans-unit id="5bb2ae17924e2d50220fe232232b8dca78bd0287" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Book&lt;/code&gt; and &lt;code&gt;Car&lt;/code&gt; are incompatible types; a &lt;code&gt;Car&lt;/code&gt; cannot be converted/cast to a &lt;code&gt;Book&lt;/code&gt;.  When this cast fails, &lt;code&gt;as&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;.  Using &lt;code&gt;mybook&lt;/code&gt; after this causes a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;Book&lt;/code&gt; 和 &lt;code&gt;Car&lt;/code&gt; 是不兼容的类型； 不能将 &lt;code&gt;Car&lt;/code&gt; 转换/铸造为 &lt;code&gt;Book&lt;/code&gt; 。 如果此转换失败，则 &lt;code&gt;as&lt;/code&gt; 返回 &lt;code&gt;null&lt;/code&gt; 。 之后使用 &lt;code&gt;mybook&lt;/code&gt; 会导致 &lt;code&gt;NullReferenceException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0cfc5e03a074b5ff497538e30726ab43dd9c052" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SelectedDate&lt;/code&gt; is in fact a property - of &lt;code&gt;DateTime&lt;/code&gt; type - of the &lt;code&gt;Calendar&lt;/code&gt; Web Control type, and the binding could perfectly return something null. The implicit ASP.NET Generator will create a piece of code that will be equivalent to the cast code above. And this will raise a &lt;code&gt;NullReferenceException&lt;/code&gt; that is quite difficult to spot, because it lies in ASP.NET generated code which compiles fine...</source>
          <target state="translated">在这里， &lt;code&gt;SelectedDate&lt;/code&gt; 实际上是 &lt;code&gt;Calendar&lt;/code&gt; Web Control类型的 &lt;code&gt;DateTime&lt;/code&gt; 类型的属性，并且绑定可以完美地返回null。 隐式ASP.NET生成器将创建一段与上面的强制转换代码等效的代码。 这将引发一个 &lt;code&gt;NullReferenceException&lt;/code&gt; ，这很难发现，因为它位于ASP.NET生成的代码中，可以很好地编译...</target>
        </trans-unit>
        <trans-unit id="ed1e9256d7edb2bcff5e3eaa417639f1f18c564e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;myWebBrowser&lt;/code&gt; or &lt;code&gt;Document&lt;/code&gt; could be Nothing or the &lt;code&gt;formfld1&lt;/code&gt; element may not exist.</source>
          <target state="translated">在这里， &lt;code&gt;myWebBrowser&lt;/code&gt; 或 &lt;code&gt;Document&lt;/code&gt; 可能为Nothing或 &lt;code&gt;formfld1&lt;/code&gt; 元素可能不存在。</target>
        </trans-unit>
        <trans-unit id="2320c69a11432eba5e88d70d8ffa3f27efc00ca3" translate="yes" xml:space="preserve">
          <source>Hope this helps too!</source>
          <target state="translated">希望这也能帮到你!</target>
        </trans-unit>
        <trans-unit id="0ae3600ced7e6090a5b25d1e38293c3e4c119186" translate="yes" xml:space="preserve">
          <source>How can it be avoided?</source>
          <target state="translated">怎样才能避免呢?</target>
        </trans-unit>
        <trans-unit id="289dd28c102f868db09f817b7b706b35bc135e71" translate="yes" xml:space="preserve">
          <source>How do you find the source of a &lt;code&gt;NullReferenceException&lt;/code&gt;? Apart from looking at the exception itself, which will be thrown exactly at the location where it occurs, the general rules of debugging in Visual Studio apply: place strategic breakpoints and &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/esta7c62.aspx&quot;&gt;inspect your variables&lt;/a&gt;, either by hovering the mouse over their names, opening a (Quick)Watch window or using the various debugging panels like Locals and Autos.</source>
          <target state="translated">您如何找到 &lt;code&gt;NullReferenceException&lt;/code&gt; 的来源？ 除了查看将要引发的异常本身之外，Visual Studio中的调试一般规则也适用：放置战略断点并&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/esta7c62.aspx&quot;&gt;检查变量&lt;/a&gt; ，方法是将鼠标悬停在它们的名称上，然后打开（快速）监视窗口或使用各种调试面板（例如本地和自动）。</target>
        </trans-unit>
        <trans-unit id="c9076ca26af1e797ee780559308ab39c1861f589" translate="yes" xml:space="preserve">
          <source>I have a different perspective to answering this. This sort of answers &lt;strong&gt;&quot;what else can I do to avoid it?&lt;/strong&gt;&quot;</source>
          <target state="translated">我对此有不同的看法。 这种回答&lt;strong&gt;&amp;ldquo;我还能做些什么来避免呢？&lt;/strong&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="4b181a81f82b32a1fdd472eb539bf0016ed99f5f" translate="yes" xml:space="preserve">
          <source>I have some code and when it executes, it throws a &lt;code&gt;NullReferenceException&lt;/code&gt;, saying:</source>
          <target state="translated">我有一些代码，执行时会抛出 &lt;code&gt;NullReferenceException&lt;/code&gt; ，说：</target>
        </trans-unit>
        <trans-unit id="039ba9acfb4e759d3a5ed8951d9aef9d9682bea4" translate="yes" xml:space="preserve">
          <source>I was getting &lt;code&gt;Object reference not set to an instance of an object&lt;/code&gt; when I tried to render a View within a View by sending it a Model, like this:</source>
          <target state="translated">当我尝试通过向其发送模型来在视图中呈现视图时，我 &lt;code&gt;Object reference not set to an instance of an object&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="cdd8f575833c363a288e4e756f1a133957aee9ea" translate="yes" xml:space="preserve">
          <source>I'll be using a RigidBody variable as an example.</source>
          <target state="translated">我将用一个RigidBody变量作为例子。</target>
        </trans-unit>
        <trans-unit id="fd9aa298728dbdb009eb67b0148c8d2d45bb648a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dgvBooks&lt;/code&gt; has &lt;code&gt;AutoGenerateColumns = True&lt;/code&gt;, it will create the columns, but it does not name them, so the above code fails when it references them by name.</source>
          <target state="translated">如果 &lt;code&gt;dgvBooks&lt;/code&gt; 的 &lt;code&gt;AutoGenerateColumns = True&lt;/code&gt; ，它将创建列，但未命名列，因此当按名称引用它们时，上面的代码将失败。</target>
        </trans-unit>
        <trans-unit id="bb92213da41ab10c3a7c561c6d6e69a25df9059f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;whatever&lt;/code&gt; results in &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;MakeFrob&lt;/code&gt; will throw.  Now, you might think that the right thing to do is this:</source>
          <target state="translated">如果 &lt;code&gt;whatever&lt;/code&gt; 结果为 &lt;code&gt;null&lt;/code&gt; ,则 &lt;code&gt;MakeFrob&lt;/code&gt; 将抛出。 现在，您可能会认为正确的做法是：</target>
        </trans-unit>
        <trans-unit id="c31841110ff2a43d84d3c54ced95f988e30ba219" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CheckBox&lt;/code&gt; with &lt;code&gt;chkName&lt;/code&gt; can't be found (or exists in a &lt;code&gt;GroupBox&lt;/code&gt;), then &lt;code&gt;chk&lt;/code&gt; will be Nothing and be attempting to reference any property will result in an exception.</source>
          <target state="translated">如果找不到带有 &lt;code&gt;chkName&lt;/code&gt; 的 &lt;code&gt;CheckBox&lt;/code&gt; （或存在于 &lt;code&gt;GroupBox&lt;/code&gt; 中 ），则 &lt;code&gt;chk&lt;/code&gt; 将为Nothing，并且尝试引用任何属性都将导致异常。</target>
        </trans-unit>
        <trans-unit id="56b8e5facbdd4848585ce4e50ddd17e21345d1f4" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;NullReferenceException&lt;/code&gt; is thrown by &lt;code&gt;unsafe&lt;/code&gt; code, you might look at your pointer variables, and check them for &lt;code&gt;IntPtr.Zero&lt;/code&gt; or something. Which is the same thing (&quot;null pointer exception&quot;), but in unsafe code, variables are often cast to value-types/arrays, etc., and you bang your head against the wall, wondering how a value-type can throw this exception.</source>
          <target state="translated">如果 &lt;code&gt;unsafe&lt;/code&gt; 代码引发了 &lt;code&gt;NullReferenceException&lt;/code&gt; ,则可能会查看指针变量，并检查它们的 &lt;code&gt;IntPtr.Zero&lt;/code&gt; 或其他内容。 这是同一回事（&amp;ldquo;空指针异常&amp;rdquo;），但是在不安全的代码中，变量通常被转换为值类型/数组等，然后您将头撞墙，想知道值类型如何抛出该值例外。</target>
        </trans-unit>
        <trans-unit id="3ba69a96020f6c1697e9f0b564be8a369771f477" translate="yes" xml:space="preserve">
          <source>If it is caused on some &lt;strong&gt;database&lt;/strong&gt; commands because the object isn't present then all you need to do is do a null check and handle it:</source>
          <target state="translated">如果它是由于不存在该对象而在某些&lt;strong&gt;数据库&lt;/strong&gt;命令上引起的，那么您所需要做的就是进行空检查并处理它：</target>
        </trans-unit>
        <trans-unit id="a0fc7e5c19cd4824faca0c76683d3494b34dba43" translate="yes" xml:space="preserve">
          <source>If one is getting this message during saving or compiling the build, just close all the files and then open any file to compile and save.</source>
          <target state="translated">如果在保存或编译过程中收到这个消息,只需关闭所有文件,然后打开任意文件进行编译保存即可。</target>
        </trans-unit>
        <trans-unit id="0b56c362f306a958689a4fcd2922fb1cfb57868c" translate="yes" xml:space="preserve">
          <source>If ref1 or ref2 or ref3 is null, then you'll get a &lt;code&gt;NullReferenceException&lt;/code&gt;. If you want to solve the problem, then find out which one is null by rewriting the expression to its simpler equivalent:</source>
          <target state="translated">如果ref1或ref2或ref3为null，则将获得 &lt;code&gt;NullReferenceException&lt;/code&gt; 。 如果要解决该问题，请通过将表达式重写为更简单的等价项来找出哪个为空：</target>
        </trans-unit>
        <trans-unit id="1e7a62c30a52478b4caee9f5d2f2740eae4bcb26" translate="yes" xml:space="preserve">
          <source>If the exception occurs when referencing a property of &lt;code&gt;@Model&lt;/code&gt; in an &lt;code&gt;ASP.NET MVC View&lt;/code&gt;, you need to understand that the &lt;code&gt;Model&lt;/code&gt; gets set in your action method, when you &lt;code&gt;return&lt;/code&gt; a view. When you return an empty model (or model property) from your controller, the exception occurs when the views access it:</source>
          <target state="translated">如果在 &lt;code&gt;ASP.NET MVC View&lt;/code&gt; 中引用 &lt;code&gt;@Model&lt;/code&gt; 的属性时发生异常，则需要了解在 &lt;code&gt;return&lt;/code&gt; 视图时在操作方法中设置了 &lt;code&gt;Model&lt;/code&gt; 。 当从控制器返回空模型（或模型属性）时，视图访问它时会发生异常：</target>
        </trans-unit>
        <trans-unit id="a383d31e09e21027128bda7cc84f8a8c4c8d65f8" translate="yes" xml:space="preserve">
          <source>If the person does not have a title, this will throw an exception because it is trying to call &lt;code&gt;ToUpper&lt;/code&gt; on a property with a null value.</source>
          <target state="translated">如果此人没有标题，这将引发异常，因为它试图在具有空值的属性上调用 &lt;code&gt;ToUpper&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cf3aeda57ef955ddb285e14c6996f8c139ee9bf" translate="yes" xml:space="preserve">
          <source>If we consider common scenarios where this exception can be thrown, accessing properties withing object at the top.</source>
          <target state="translated">如果我们考虑到常见的情况下会抛出这种异常,访问顶层对象的属性。</target>
        </trans-unit>
        <trans-unit id="bd4df3cabfb26db423d61513abb17ea9d42bbc71" translate="yes" xml:space="preserve">
          <source>If you are debugging with Just My Code enabled, the behavior is slightly different. With Just My Code enabled, the debugger ignores first-chance common language runtime (CLR) exceptions that are thrown outside of My Code and do not pass through My Code</source>
          <target state="translated">如果您在调试时启用了 &quot;我的代码&quot;,那么行为就会略有不同。启用了 &quot;我的代码 &quot;后,调试器会忽略在 &quot;我的代码 &quot;之外抛出的第一次通用语言运行时(CLR)异常,而不通过 &quot;我的代码&quot;。</target>
        </trans-unit>
        <trans-unit id="5d011199f17f1b3224336bf477779ff919919146" translate="yes" xml:space="preserve">
          <source>If you are expecting the type conversion to always succeed (ie. you know what the object should be ahead of time), then you should use a cast:</source>
          <target state="translated">如果你期望类型转换总是成功的(即你提前知道对象应该是什么),那么你应该使用 cast。</target>
        </trans-unit>
        <trans-unit id="db5359f7b5259b8f8194c263074c45fca315ff8a" translate="yes" xml:space="preserve">
          <source>If you are unsure of the type, but you want to &lt;em&gt;try&lt;/em&gt; to use it as a specific type, then use &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">如果不确定类型，但想&lt;em&gt;尝试&lt;/em&gt;将其用作特定类型，请使用：</target>
        </trans-unit>
        <trans-unit id="1c923dbbe26d09b3ec56dc6968714cd47b9bf93d" translate="yes" xml:space="preserve">
          <source>If you are working with unsafe code and you get a null dereference exception, just be aware that the offending pointer need not be null. It can be any location in the lowest page, and this exception will be produced.</source>
          <target state="translated">如果你正在使用不安全的代码,并且得到一个null dereference异常,只需注意,违规的指针不需要是null。它可以是最底层页面中的任何位置,这个异常就会产生。</target>
        </trans-unit>
        <trans-unit id="9eee74fa45beb820853095727a40c22279c9d0bc" translate="yes" xml:space="preserve">
          <source>If you do use a &lt;code&gt;For n&lt;/code&gt; loop, modify the row count or use &lt;code&gt;Exit For&lt;/code&gt; when &lt;code&gt;IsNewRow&lt;/code&gt; is true.</source>
          <target state="translated">如果确实使用 &lt;code&gt;For n&lt;/code&gt; 循环， &lt;code&gt;Exit For&lt;/code&gt; 在 &lt;code&gt;IsNewRow&lt;/code&gt; 为true时修改行数或使用Exit For 。</target>
        </trans-unit>
        <trans-unit id="e09bc8a6a4e58664c4a3a3793f96ba758d2f4e9b" translate="yes" xml:space="preserve">
          <source>If you examine the reference source for &lt;code&gt;LINQ&lt;/code&gt; to Objects you will see that this technique is used throughout. It is slightly more clunky to write, but it makes debugging nullity errors much easier.  &lt;strong&gt;Optimize your code for the convenience of the caller, not the convenience of the author&lt;/strong&gt;.</source>
          <target state="translated">如果检查 &lt;code&gt;LINQ&lt;/code&gt; to Objects的参考源，您会发现在整个过程中都使用了此技术。 编写起来有点笨拙，但是它使调试null错误更加容易。 &lt;strong&gt;为方便调用者而不是为作者方便而优化代码&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e93bb8e62bdb0cbe375e02bcdd4025ed3a5280b6" translate="yes" xml:space="preserve">
          <source>If you expect the reference sometimes to be null, you can check for it being &lt;code&gt;null&lt;/code&gt; before accessing instance members:</source>
          <target state="translated">如果您期望引用有时为空，则可以在访问实例成员之前检查其是否为 &lt;code&gt;null&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="954ae9f52d37b1ad255f61190a8a7c1d85bef3ef" translate="yes" xml:space="preserve">
          <source>If you have not initialized a reference type, and you want to set or read one of its properties, it will throw a &lt;strong&gt;NullReferenceException&lt;/strong&gt;.</source>
          <target state="translated">如果尚未初始化引用类型，并且要设置或读取其属性之一，则它将抛出&lt;strong&gt;NullReferenceException&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9b75db38115a136957814e589aeeb2dac83db23" translate="yes" xml:space="preserve">
          <source>If you want to avoid the child (Person) null reference, you could initialize it in the parent (Book) object's constructor.</source>
          <target state="translated">如果你想避免子对象(Person)空引用,可以在父对象(Book)的构造函数中初始化它。</target>
        </trans-unit>
        <trans-unit id="7672c7bfcdb17d75fe7dfc75005f4c60663395f1" translate="yes" xml:space="preserve">
          <source>If you want to find out where the reference is or isn't set, right-click its name and select &quot;Find All References&quot;. You can then place a breakpoint at every found location and run your program with the debugger attached. Every time the debugger breaks on such a breakpoint, you need to determine whether you expect the reference to be non-null, inspect the variable, and verify that it points to an instance when you expect it to.</source>
          <target state="translated">如果你想知道这个引用在哪里或没有设置,右击它的名字,选择 &quot;查找所有引用&quot;。然后,你可以在每一个找到的位置都放置一个断点,然后在连接调试器的情况下运行你的程序。每当调试器在这样的断点上断点时,你需要确定你期望的引用是否为非空,检查变量,并验证它是否在你期望的时候指向一个实例。</target>
        </trans-unit>
        <trans-unit id="124ed7dc2efaa392800e559d8512faa6fddfc4a6" translate="yes" xml:space="preserve">
          <source>If you're not sure whether the object is null, check it with &lt;code&gt;object == null&lt;/code&gt;.</source>
          <target state="translated">如果不确定对象是否为null，请使用 &lt;code&gt;object == null&lt;/code&gt; 检查。</target>
        </trans-unit>
        <trans-unit id="f9d87c823bab4a6a3c23f4fa35b0ab3165ebc81e" translate="yes" xml:space="preserve">
          <source>Imagine that &lt;code&gt;country&lt;/code&gt; is an object of type &lt;code&gt;Country&lt;/code&gt; that has a property called &lt;code&gt;State&lt;/code&gt; and so on. If &lt;code&gt;country&lt;/code&gt;, &lt;code&gt;State&lt;/code&gt;, &lt;code&gt;County&lt;/code&gt;, or &lt;code&gt;City&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;address will be&lt;/code&gt;null&lt;code&gt;. Therefore you only have to check whether&lt;/code&gt;address&lt;code&gt;is&lt;/code&gt;null`.</source>
          <target state="translated">想象一下， &lt;code&gt;country&lt;/code&gt; 是&amp;ldquo; &lt;code&gt;Country&lt;/code&gt; &amp;rdquo;类型的对象，它具有一个称为&amp;ldquo; &lt;code&gt;State&lt;/code&gt; 的属性，依此类推。 如果 &lt;code&gt;country&lt;/code&gt; ， &lt;code&gt;State&lt;/code&gt; ， &lt;code&gt;County&lt;/code&gt; 或 &lt;code&gt;City&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 则 &lt;code&gt;address will be&lt;/code&gt; 空 &lt;code&gt;. Therefore you only have to check whether&lt;/code&gt; 因此，您只需要检查地址是否 &lt;code&gt;is&lt;/code&gt; 空。</target>
        </trans-unit>
        <trans-unit id="d8dc338b100fb641765e4200d2b3f89eb5c8d59d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C# 5&lt;/code&gt; and below, this can be guarded with:</source>
          <target state="translated">在 &lt;code&gt;C# 5&lt;/code&gt; 及以下版本中，可以通过以下方式进行保护：</target>
        </trans-unit>
        <trans-unit id="d9af0d957316871a93fd8ae5a5c0570ecd645f0d" translate="yes" xml:space="preserve">
          <source>In Visual Studio this is usually easy thanks to the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/sc65sadd.aspx&quot;&gt;Visual Studio Debugger&lt;/a&gt;.</source>
          <target state="translated">在Visual Studio中，这通常很容易，这要归功于&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/sc65sadd.aspx&quot;&gt;Visual Studio调试器&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="442f25764599824025c21fd67a95683d7a1d4d49" translate="yes" xml:space="preserve">
          <source>In comparison to an ArgumentNullException which is typically thrown as a defensive measure if a method expects that what is being passed to it is not null.</source>
          <target state="translated">与ArgumentNullException相比,ArgumentNullException通常是在方法期望传递给它的东西不是null时作为防御措施而抛出。</target>
        </trans-unit>
        <trans-unit id="0d6fbd94de7bcc900b19537b5bb326c45d6c0504" translate="yes" xml:space="preserve">
          <source>In general, you should use a cast or &lt;code&gt;as&lt;/code&gt;, as follows:</source>
          <target state="translated">通常，您应按以下方式使用强制转换或 &lt;code&gt;as&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a745bf8342a8ec9dc29ec2f0e55b1f294b6ff60a" translate="yes" xml:space="preserve">
          <source>In more advanced cases, such as the following, you'll need to use one of the techniques above (Watch or Immediate Windows) to inspect the expressions to determine if &lt;code&gt;str1&lt;/code&gt; was null or if &lt;code&gt;str2&lt;/code&gt; was null.</source>
          <target state="translated">在更高级的情况下，例如以下情况，您将需要使用上述技术之一（&amp;ldquo;监视&amp;rdquo;或&amp;ldquo;即时Windows&amp;rdquo;）来检查表达式以确定 &lt;code&gt;str1&lt;/code&gt; 是否为null或 &lt;code&gt;str2&lt;/code&gt; 为null。</target>
        </trans-unit>
        <trans-unit id="6c2d2f16f8b1cfa8d5861b4766e0faaf22391a45" translate="yes" xml:space="preserve">
          <source>In short, &lt;em&gt;class invariants&lt;/em&gt; ensure that there will be some constraints in your class that will not get violated in normal use (and therefore, the class will &lt;em&gt;not&lt;/em&gt; get in an inconsistent state). &lt;em&gt;Preconditions&lt;/em&gt; mean that data given as input to a function/method must follow some constraints set and &lt;strong&gt;never&lt;/strong&gt; violate them, and &lt;em&gt;postconditions&lt;/em&gt; mean that a function/method output must follow the set constraints again without ever violating them.
Contract conditions should &lt;strong&gt;never&lt;/strong&gt; be violated during execution of a bug-free program, therefore design by contract is checked in practice in debug mode, while being &lt;em&gt;disabled in releases&lt;/em&gt;, to maximize the developed system performance.</source>
          <target state="translated">简而言之， &lt;em&gt;类不变式可&lt;/em&gt;确保您的类中存在一些在正常使用中不会受到违反的约束（因此，该类&lt;em&gt;不会&lt;/em&gt;处于不一致的状态）。 &lt;em&gt;前提条件&lt;/em&gt;意味着作为函数/方法的输入提供的数据必须遵循一定的约束条件，并且&lt;strong&gt;永不&lt;/strong&gt;违反它们； &lt;em&gt;而后置条件&lt;/em&gt;意味着函数/方法的输出必须再次遵循设置的约束条件，而又从未违反它们。 在执行无错误的程序期间，不得违反合同条件，因此，按合同进行的设计实际上是在调试模式下检查的，而&lt;em&gt;在发行版中&lt;/em&gt;被&lt;em&gt;禁用&lt;/em&gt; ，以最大限度地提高开发系统的性能。</target>
        </trans-unit>
        <trans-unit id="ee86d3f393a29644b6be92e8be9ec8a1afe52114" translate="yes" xml:space="preserve">
          <source>In the other direction, a &lt;strong&gt;&lt;em&gt;boxing&lt;/em&gt;&lt;/strong&gt; conversion &lt;em&gt;from&lt;/em&gt; a &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; which has &lt;code&gt;HasValue&lt;/code&gt; equal to &lt;code&gt;false&lt;/code&gt;&lt;em&gt;to&lt;/em&gt; a reference type, can give a &lt;code&gt;null&lt;/code&gt; reference which can then later lead to a &lt;code&gt;NullReferenceException&lt;/code&gt;. The classic example is:</source>
          <target state="translated">在另一个方向上， &lt;em&gt;从&lt;/em&gt; &lt;code&gt;HasValue&lt;/code&gt; 等于 &lt;code&gt;false&lt;/code&gt; 的 &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; &lt;em&gt;到&lt;/em&gt;引用类型的&lt;strong&gt;&lt;em&gt;装箱&lt;/em&gt;&lt;/strong&gt;转换可以提供 &lt;code&gt;null&lt;/code&gt; 引用，该引用随后可以导致 &lt;code&gt;NullReferenceException&lt;/code&gt; 。 经典示例是：</target>
        </trans-unit>
        <trans-unit id="7a5a670646192c2904df37f98794bc286c1f51c1" translate="yes" xml:space="preserve">
          <source>In unsafe mode, you should be aware of two important facts:</source>
          <target state="translated">在不安全模式下,你应该注意两个重要的事实。</target>
        </trans-unit>
        <trans-unit id="3be7faaf917ec1e75bc105ac00cd45db1f27d22a" translate="yes" xml:space="preserve">
          <source>In-built method: System methods such as GetValueOrDefault(),IsNullOrWhiteSpace() and IsNullorEmpty()  checks for nulls and assign the default value if there is a null value.</source>
          <target state="translated">内建方法。系统方法,如GetValueOrDefault()、IsNullOrWhiteSpace()和IsNullorEmpty()等系统方法会检查空值,如果有空值,则会分配默认值。</target>
        </trans-unit>
        <trans-unit id="8cbe1b61604257c69eb792f97e93456c4cc68afc" translate="yes" xml:space="preserve">
          <source>Indirect</source>
          <target state="translated">Indirect</target>
        </trans-unit>
        <trans-unit id="414415dac9332746c5ff97ecdc8a7f74c2f17f06" translate="yes" xml:space="preserve">
          <source>Initialize the settings collection in the form's &lt;code&gt;Load&lt;/code&gt; event handler, if/when needed:</source>
          <target state="translated">如有必要，请在表单的 &lt;code&gt;Load&lt;/code&gt; 事件处理程序中初始化设置集合：</target>
        </trans-unit>
        <trans-unit id="234d47467506fc9f47ee7950fcdb7bb2ae54365b" translate="yes" xml:space="preserve">
          <source>Integral types</source>
          <target state="translated">整数类型</target>
        </trans-unit>
        <trans-unit id="c3341d58f2612c2f24999b64faed81efad614d89" translate="yes" xml:space="preserve">
          <source>Interestingly, none of the answers on this page mention the two edge cases, hope no one minds if I add them:</source>
          <target state="translated">有趣的是,这个页面上的答案都没有提到这两种边缘情况,希望大家不要介意我补充一下。</target>
        </trans-unit>
        <trans-unit id="01bd706ed0b9c186751dc7af37426b554a904934" translate="yes" xml:space="preserve">
          <source>Introduced in &lt;code&gt;C# 8&lt;/code&gt; there null context's and nullable reference types perform static analysis on variables and provides a compiler warning if a value can be potentially null or have been set to null. The nullable reference types allows types to be explicitly allowed to be null.</source>
          <target state="translated">在 &lt;code&gt;C# 8&lt;/code&gt; 引入了null上下文和nullable引用类型，它们对变量执行静态分析，并在值可能为null或已设置为null时提供编译器警告。 可为空的引用类型允许将类型明确允许为null。</target>
        </trans-unit>
        <trans-unit id="cbf6007ad3f8db48b2caa744d94cf086e082dc37" translate="yes" xml:space="preserve">
          <source>It also arises when we forget to instantiate our objects. Using methods, properties, collections etc. which can return or set null values can also be the cause of this exception.</source>
          <target state="translated">当我们忘记实例化我们的对象时,也会出现这种异常。使用方法、属性、集合等可以返回或设置空值的方法、属性、集合等也会导致这种异常。</target>
        </trans-unit>
        <trans-unit id="6f40b22d84245ca604cc84dc6eef8a46a3df02af" translate="yes" xml:space="preserve">
          <source>It is curious that VB does not provide a warning, but the remedy is to &lt;strong&gt;declare&lt;/strong&gt; the containers at the form level, but &lt;strong&gt;initialize&lt;/strong&gt; them in form load event handler when the controls &lt;strong&gt;do&lt;/strong&gt; exist. This can be done in &lt;code&gt;Sub New&lt;/code&gt; as long as your code is after the &lt;code&gt;InitializeComponent&lt;/code&gt; call:</source>
          <target state="translated">奇怪的是，VB没有提供警告，但补救措施是在窗体级别&lt;strong&gt;声明&lt;/strong&gt;容器，但在控件&lt;strong&gt;确实&lt;/strong&gt;存在时在窗体加载事件处理程序中&lt;strong&gt;初始化&lt;/strong&gt;它们。 只要您的代码在 &lt;code&gt;InitializeComponent&lt;/code&gt; 调用之后，就可以在 &lt;code&gt;Sub New&lt;/code&gt; 中完成：</target>
        </trans-unit>
        <trans-unit id="2eef644af3700e5795f998539dd59e2e7c297244" translate="yes" xml:space="preserve">
          <source>It is not possible to reference anything 'downstream' of a &lt;code&gt;null&lt;/code&gt; object.  This also applies to controls:</source>
          <target state="translated">不可能引用任何 &lt;code&gt;null&lt;/code&gt; 对象的&amp;ldquo;下游&amp;rdquo;。 这也适用于控件：</target>
        </trans-unit>
        <trans-unit id="83c9a2a6f0cded3da8a2fd23d1724756e8709640" translate="yes" xml:space="preserve">
          <source>It means that the variable in question is pointed at nothing. I could generate this like so:</source>
          <target state="translated">意思是说,这个变量指向的是什么都不是。我可以这样生成。</target>
        </trans-unit>
        <trans-unit id="725b5851f8a7590790831cee0a9a54440c5e452d" translate="yes" xml:space="preserve">
          <source>It means your code used an object reference variable that was set to null (i.e. it did not reference an actual object instance).</source>
          <target state="translated">这意味着你的代码使用了一个被设置为空的对象引用变量(即它没有引用一个实际的对象实例)。</target>
        </trans-unit>
        <trans-unit id="0c813d120a6e5cc67f6c6bde99d1fd2ca0b51cc2" translate="yes" xml:space="preserve">
          <source>It will throw a &lt;code&gt;NullReferenceException&lt;/code&gt; on the cast. It seems quite obvious in the above sample, but this can happen in more &quot;late-binding&quot; intricate scenarios where the null object has been returned from some code you don't own, and the cast is for example generated by some automatic system.</source>
          <target state="translated">它将在演员表上抛出 &lt;code&gt;NullReferenceException&lt;/code&gt; 。 在上面的示例中，这似乎很明显，但是这可能发生在更复杂的&amp;ldquo;后期绑定&amp;rdquo;场景中，其中空对象是从您不拥有的某些代码中返回的，而强制转换例如是由某些自动系统生成的。</target>
        </trans-unit>
        <trans-unit id="8179843545ce209e8ee908f48e63197ddb2508a8" translate="yes" xml:space="preserve">
          <source>It would be nice if C# had something like the &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; struct above and had a similar shorthand, maybe the exclamation point (!) so that you could write something like: &lt;code&gt;public void WriteName(Person! person)&lt;/code&gt;.</source>
          <target state="translated">如果C＃上面有类似 &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; 结构，并且具有类似的速记（也许是感叹号（！）），那么您可以这样写： &lt;code&gt;public void WriteName(Person! person)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="955b6d8394cf76a1d4fe4f8e7ef177275da55c14" translate="yes" xml:space="preserve">
          <source>It's a great feature, but it gives you less information. It doesn't make it obvious which of the 4 is null.</source>
          <target state="translated">这是一个很好的功能,但它给你的信息比较少。它并不能让你明显地看出这4个中的哪一个是空的。</target>
        </trans-unit>
        <trans-unit id="4bf150ddb62d4d1939db3d1e25f12fdd47b0ee5f" translate="yes" xml:space="preserve">
          <source>It's used to test for null before performing a member access (?.) or index (?[) operation.</source>
          <target state="translated">它用于在执行成员访问(?)或索引(?[)操作之前测试空值。</target>
        </trans-unit>
        <trans-unit id="71c8a217f58ff5fc0e4a7d04b09748b7f1e8da29" translate="yes" xml:space="preserve">
          <source>Jagged Arrays</source>
          <target state="translated">锯齿形阵列</target>
        </trans-unit>
        <trans-unit id="4de379f88b7ef46e6cfa5de6e9908e85f89cf4f0" translate="yes" xml:space="preserve">
          <source>JetBrains' Resharper tool will identify every place in your code that has the possibility of a null reference error, allowing you to put in a null check. This error is the number one source of bugs, IMHO.</source>
          <target state="translated">JetBrains的Resharper工具将识别出代码中每一个可能出现空引用错误的地方,让你可以进行空检查。这个错误是造成BUG的头号源头,IMHO。</target>
        </trans-unit>
        <trans-unit id="b2802386a0546365a801bdc9dc6dc071b11d5be6" translate="yes" xml:space="preserve">
          <source>Key Points</source>
          <target state="translated">关键点</target>
        </trans-unit>
        <trans-unit id="8ee0e49c20d5b975cccff63b65f6a1467d4f272c" translate="yes" xml:space="preserve">
          <source>LINQ &lt;code&gt;FirstOrDefault()&lt;/code&gt; and &lt;code&gt;SingleOrDefault()&lt;/code&gt;</source>
          <target state="translated">LINQ &lt;code&gt;FirstOrDefault()&lt;/code&gt; 和 &lt;code&gt;SingleOrDefault()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99356ca7906555a2f4c7dc97649a8efa6dbd0212" translate="yes" xml:space="preserve">
          <source>Like anything else, &lt;code&gt;null&lt;/code&gt; gets passed around. If it is &lt;code&gt;null&lt;/code&gt;&lt;em&gt;in&lt;/em&gt; method &quot;A&quot;, it could be that method &quot;B&quot; passed a &lt;code&gt;null&lt;/code&gt;&lt;em&gt;to&lt;/em&gt; method &quot;A&quot;.</source>
          <target state="translated">像其他任何东西一样， &lt;code&gt;null&lt;/code&gt; 会被传递出去。 如果&lt;em&gt;在&lt;/em&gt;方法&amp;ldquo; A&amp;rdquo;中为 &lt;code&gt;null&lt;/code&gt; ，则可能是方法&amp;ldquo; B&amp;rdquo; &lt;em&gt;向&lt;/em&gt;方法&amp;ldquo; A&amp;rdquo;传递了 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa96796b70166a01da429a974a3cc400dff498a8" translate="yes" xml:space="preserve">
          <source>Likewise, for arrays you can use &lt;code&gt;?[i]&lt;/code&gt; as follows:</source>
          <target state="translated">同样，对于数组，可以使用 &lt;code&gt;?[i]&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="5fd395238ed01cc167eb08a83b289717b17ed72a" translate="yes" xml:space="preserve">
          <source>Lists and Collection will simply be empty</source>
          <target state="translated">列表和集合将是空的</target>
        </trans-unit>
        <trans-unit id="b89d28bc5880c1090375f320e5a1517ea528fb46" translate="yes" xml:space="preserve">
          <source>Lists and Collections</source>
          <target state="translated">列表和收藏品</target>
        </trans-unit>
        <trans-unit id="8ed2e69395a71ce749a19137034071d7ce924763" translate="yes" xml:space="preserve">
          <source>Literally the easiest way to fix a NullReferenceExeption has two ways.
If you have a GameObject for example with a script attached and a variable named rb (rigidbody) this variable will start null when you start your game.</source>
          <target state="translated">从字面上看,修复NullReferenceExeption最简单的方法有两种。如果你有一个GameObject,比如说你有一个附加脚本的GameObject,并且有一个名为rb(rigidbody)的变量,当你启动游戏的时候,这个变量就会开始空。</target>
        </trans-unit>
        <trans-unit id="c42ff2b214ede29fd88c31705a2e471ec3556484" translate="yes" xml:space="preserve">
          <source>MSDN NullReference Exception</source>
          <target state="translated">MSDN NullReference Exception</target>
        </trans-unit>
        <trans-unit id="7ad8fdfe61e4454ef02db660ac35ba0748c9aa9d" translate="yes" xml:space="preserve">
          <source>MSDN: Best Practices for Exceptions</source>
          <target state="translated">MSDN。例外的最佳做法</target>
        </trans-unit>
        <trans-unit id="1799c9265044c387d0f81f0d8e6ab1b39fd3f4f5" translate="yes" xml:space="preserve">
          <source>MSDN: How to: Use the Try/Catch Block to Catch Exceptions</source>
          <target state="translated">MSDN。How to:使用 TryCatch 块来捕获异常</target>
        </trans-unit>
        <trans-unit id="78736f095b06c11f959a9bd8d826202e6b13baf7" translate="yes" xml:space="preserve">
          <source>Memory is virtualized in &lt;code&gt;Windows&lt;/code&gt;; each process gets a virtual memory space of many &quot;pages&quot; of memory that are tracked by the operating system. Each page of memory has flags set on it which determine how it may be used: read from, written to, executed, and so on.  The &lt;em&gt;lowest&lt;/em&gt; page is marked as &quot;produce an error if ever used in any way&quot;.</source>
          <target state="translated">内存在 &lt;code&gt;Windows&lt;/code&gt; 中虚拟化; 每个进程都会获得由操作系统跟踪的许多&amp;ldquo;页面&amp;rdquo;内存的虚拟内存空间。 内存的每一页上都设置了标志，这些标志确定如何使用它：读取，写入，执行等。 &lt;em&gt;最低的&lt;/em&gt;页面被标记为&amp;ldquo;如果以任何方式使用都会产生错误&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e23cc54bff3a3a5d37dc37dc1662948bf36648f0" translate="yes" xml:space="preserve">
          <source>Methods call you expect to return an instance can return &lt;code&gt;null&lt;/code&gt;, for example when the object being sought cannot be found. You can choose to return a default value when this is the case:</source>
          <target state="translated">您期望返回实例的方法调用可以返回 &lt;code&gt;null&lt;/code&gt; ，例如，在找不到要查找的对象时。 在这种情况下，您可以选择返回默认值：</target>
        </trans-unit>
        <trans-unit id="f2f65c39e9befac556a2ece0db1de4b0c904147b" translate="yes" xml:space="preserve">
          <source>More Specifically</source>
          <target state="translated">更多具体内容</target>
        </trans-unit>
        <trans-unit id="1f2886a5d0eb58ab959b4b21d407f74a59989572" translate="yes" xml:space="preserve">
          <source>More information is in &lt;em&gt;&lt;a href=&quot;https://www.dotnetperls.com/nullreferenceexception&quot;&gt;C# NullReferenceException and Null Parameter&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;em&gt;&lt;a href=&quot;https://www.dotnetperls.com/nullreferenceexception&quot;&gt;C＃NullReferenceException和Null参数&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="73d48e92ee90db3568c1d31a50c956aadebdfbd8" translate="yes" xml:space="preserve">
          <source>More realistic example - select nodes from XML document. Will throw if nodes are not found but initial debugging shows that all properties valid:</source>
          <target state="translated">更现实的例子--从XML文档中选择节点。如果没有找到节点,将抛出,但初始调试显示所有属性有效。</target>
        </trans-unit>
        <trans-unit id="f76899831263fd9799a64690d3ad0afc9100b2a4" translate="yes" xml:space="preserve">
          <source>My.Settings (StringCollection)</source>
          <target state="translated">My.Settings (StringCollection)</target>
        </trans-unit>
        <trans-unit id="41db439be65a63d22d9384237a7b090f77634c41" translate="yes" xml:space="preserve">
          <source>Name the columns manually, or reference by index:</source>
          <target state="translated">手动命名列,或按索引参考。</target>
        </trans-unit>
        <trans-unit id="f73fd087219997abb0b2070a7f8b9006bc9c6c3b" translate="yes" xml:space="preserve">
          <source>Nested Collection Initializers</source>
          <target state="translated">嵌套收集初始化器</target>
        </trans-unit>
        <trans-unit id="c2ffcf7dcaf6a0db61f66aee4b7d2a32b5b706ba" translate="yes" xml:space="preserve">
          <source>Nested Object Initializers</source>
          <target state="translated">嵌套对象初始化器</target>
        </trans-unit>
        <trans-unit id="a9f6f220ca6e10feac65da97285e903dcd7c03df" translate="yes" xml:space="preserve">
          <source>New Operator</source>
          <target state="translated">新操作员</target>
        </trans-unit>
        <trans-unit id="594a0ab4e25b09bd873763aa42a8cfaed596e74c" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;Do not&lt;/strong&gt; use &lt;code&gt;Dim&lt;/code&gt; again in a procedure, including the constructor (&lt;code&gt;Sub New&lt;/code&gt;):</source>
          <target state="translated">注意： &lt;strong&gt;不要&lt;/strong&gt;在过程中再次使用 &lt;code&gt;Dim&lt;/code&gt; ，包括构造函数（ &lt;code&gt;Sub New&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="b0c7d1634f143651ccf0114e6c5ffff2ff4f10cd" translate="yes" xml:space="preserve">
          <source>Note: Beginning with VS 2010, when initializing a local array using a literal and &lt;code&gt;Option Infer&lt;/code&gt;, the &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; and &lt;code&gt;New&lt;/code&gt; elements are optional:</source>
          <target state="translated">注意：从VS 2010开始，使用文字和 &lt;code&gt;Option Infer&lt;/code&gt; 初始化本地数组时， &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; 和 &lt;code&gt;New&lt;/code&gt; 元素是可选的：</target>
        </trans-unit>
        <trans-unit id="378b211edf065e14fb27dcd1e7e1b744600ccaae" translate="yes" xml:space="preserve">
          <source>Now the title variable will be null instead of throwing an exception. C# 6 introduces a shorter syntax for this:</source>
          <target state="translated">现在标题变量将为空,而不是抛出一个异常。C#6为此引入了一个更短的语法。</target>
        </trans-unit>
        <trans-unit id="0e05b2f6e48a9c2172676721b07aa9534ae7f3f2" translate="yes" xml:space="preserve">
          <source>Now you are accessing this prop1 in some other class just like below:</source>
          <target state="translated">现在你在其他类中访问这个道具1,就像下面这样。</target>
        </trans-unit>
        <trans-unit id="baac228f016bc4ccca30fd630c5ff646abbf3f89" translate="yes" xml:space="preserve">
          <source>Now, consider another class where you are trying to retrieve the student's full name.</source>
          <target state="translated">现在,再来考虑另一个班级,你想找回学生的全名。</target>
        </trans-unit>
        <trans-unit id="4850e4da722f36fec8d78291c92be908f1969d5e" translate="yes" xml:space="preserve">
          <source>Now, when I try to print the length of the string &lt;strong&gt;str&lt;/strong&gt;, I do get &lt;em&gt;An unhandled exception of type &amp;lsquo;System.NullReferenceException&amp;rsquo; occurred&lt;/em&gt; message because member &lt;strong&gt;str&lt;/strong&gt; is pointing to null and there can&amp;rsquo;t be any length of null.</source>
          <target state="translated">现在，当我尝试打印字符串&lt;strong&gt;str&lt;/strong&gt;的长度时，我确实得到了&lt;em&gt;一条类型为'System.NullReferenceException'的未处理的异常&lt;/em&gt;消息，因为成员&lt;strong&gt;str&lt;/strong&gt;指向null并且不能有任何长度的null。</target>
        </trans-unit>
        <trans-unit id="eafd17582b015c89f4f72513d53f759c4bde2b05" translate="yes" xml:space="preserve">
          <source>Now, when the NullReferenceException is thrown (or unhandled) the debugger will stop (remember the rule set above?) on the line on which the exception occurred. Sometimes the error will be easy to spot.</source>
          <target state="translated">现在,当NullReferenceException被抛出(或未处理)时,调试器会在异常发生的行上停止(还记得上面设定的规则吗?)。有时,错误会很容易被发现。</target>
        </trans-unit>
        <trans-unit id="318279d9fb722f810e6e3f50b545a9a0404b55c6" translate="yes" xml:space="preserve">
          <source>Null operators: Null Coalescing operator and null conditional operators can also be used in handy while setting values to objects, variables, properties and fields.</source>
          <target state="translated">空运算符。在给对象、变量、属性和字段设置值时,也可以使用空凝聚运算符和空条件运算符。</target>
        </trans-unit>
        <trans-unit id="2eb936c96dfd3a82cf681dcf1e453a56150f03fb" translate="yes" xml:space="preserve">
          <source>NullReference Exception &amp;mdash; Visual Basic</source>
          <target state="translated">NullReference异常&amp;mdash; Visual Basic</target>
        </trans-unit>
        <trans-unit id="108a53e72c1b0456c7d04a8155e32546371f242d" translate="yes" xml:space="preserve">
          <source>NullReferenceException arises due to our fault for not checking the object&amp;rsquo;s value. We often leave the object values unchecked in the code development.</source>
          <target state="translated">由于我们没有检查对象的值而导致的错误，导致NullReferenceException出现。 我们经常在代码开发中不检查对象值。</target>
        </trans-unit>
        <trans-unit id="b5713cc5880d61c8ee4043a97acf6d784d345341" translate="yes" xml:space="preserve">
          <source>NullReferenceException or Object reference not set to an instance of an object occurs when an object of the class you are trying to use is not instantiated.
For example:</source>
          <target state="translated">NullReferenceException或对象引用未被设置为对象的实例时,当你要使用的类的对象没有被实例化时,会发生NullReferenceException。比如说。</target>
        </trans-unit>
        <trans-unit id="498d55bb5d750bf94a55e680251545631183f0ad" translate="yes" xml:space="preserve">
          <source>NullReferenceException won't occur if we are using Value type members.</source>
          <target state="translated">如果我们使用Value类型的成员,就不会出现NullReferenceException。</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">数字类型</target>
        </trans-unit>
        <trans-unit id="3390ab1994cf8aa916e3506c4916e33bb1871966" translate="yes" xml:space="preserve">
          <source>Object Paths / Nested</source>
          <target state="translated">对象路径 嵌套</target>
        </trans-unit>
        <trans-unit id="dfefbee8fa51c19a77377fdc99c6d1e91ac2ebb8" translate="yes" xml:space="preserve">
          <source>Object reference not set to an instance of an object.</source>
          <target state="translated">对象引用未设置为对象的实例。</target>
        </trans-unit>
        <trans-unit id="ffdbed86f65d9327dc3308e8c7e0ebc6a5dd365d" translate="yes" xml:space="preserve">
          <source>Object variables which are &lt;strong&gt;uninitialized&lt;/strong&gt; and hence &lt;strong&gt;point to nothing.&lt;/strong&gt; In this case, if you access properties or methods of such objects, it causes a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;未初始化的&lt;/strong&gt;对象变量，因此&lt;strong&gt;没有指向任何对象。&lt;/strong&gt; 在这种情况下，如果访问此类对象的属性或方法，则将导致 &lt;code&gt;NullReferenceException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f9388be3a14ac2bf1c68c14b6f7c7b0ba00f598" translate="yes" xml:space="preserve">
          <source>Of course, you &lt;em&gt;still&lt;/em&gt; have to check &lt;code&gt;title&lt;/code&gt; for null or use the null condition operator together with the null coalescing operator (&lt;code&gt;??&lt;/code&gt;) to supply a default value:</source>
          <target state="translated">当然，您&lt;em&gt;仍然&lt;/em&gt;必须检查 &lt;code&gt;title&lt;/code&gt; 是否为null或将null条件运算符与null合并运算符（ &lt;code&gt;??&lt;/code&gt; ）一起使用以提供默认值：</target>
        </trans-unit>
        <trans-unit id="fa4b5d0f97e6455028a59f1925e67775d0a3150f" translate="yes" xml:space="preserve">
          <source>On the matter of &lt;strong&gt;&quot;what should I do about it&quot;&lt;/strong&gt;, there can be many answers.</source>
          <target state="translated">关于&lt;strong&gt;&amp;ldquo;我该怎么办&amp;rdquo;&lt;/strong&gt; ，可能会有很多答案。</target>
        </trans-unit>
        <trans-unit id="3d646273973e4205570d72f3076fd5fc36ee3360" translate="yes" xml:space="preserve">
          <source>Once &lt;em&gt;where&lt;/em&gt; the exception is throw has been located, it's usually trivial to reason backwards to find out where the null value was [incorrectly] introduced --</source>
          <target state="translated">一旦定位了引发异常的位置，通常不容易进行倒推以找出[错误地]引入了null值的位置-</target>
        </trans-unit>
        <trans-unit id="2a462199e4fdd6a0af25f3adcac4accc6d33e906" translate="yes" xml:space="preserve">
          <source>Once you know what and where the problem is, it is usually fairly easy to fix and faster than posting a new question.</source>
          <target state="translated">一旦你知道了问题是什么,问题在哪里,通常是相当容易解决的,而且比发布一个新问题要快。</target>
        </trans-unit>
        <trans-unit id="ae6cb7569ada63bc2d3e163016b98bc806afea38" translate="yes" xml:space="preserve">
          <source>One example of this is this simple ASP.NET binding fragment with the Calendar control:</source>
          <target state="translated">其中一个例子就是这个简单的ASP.NET与Calendar控件绑定片段。</target>
        </trans-unit>
        <trans-unit id="79a8436face2b533d827001515951269d4bfb9b3" translate="yes" xml:space="preserve">
          <source>Only reference types, as the name is suggesting, can hold references or point literally to nothing (or 'null'). Whereas value types always contain a value.</source>
          <target state="translated">只有引用类型,就像名字所暗示的那样,可以持有引用,也可以直接指向任何东西(或 &quot;null&quot;)。而值类型总是包含一个值。</target>
        </trans-unit>
        <trans-unit id="025911f6c7d528b21a46faf9fcb9c34232aa12fe" translate="yes" xml:space="preserve">
          <source>Option Infer Statement</source>
          <target state="translated">选项推理声明</target>
        </trans-unit>
        <trans-unit id="f179578c51c822eb1fb66acea0ac9ffb6979808e" translate="yes" xml:space="preserve">
          <source>Or you can always code your own approach using plain old code. For example here is a struct that you can use to catch null references. It's modeled after the same concept as &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">或者，您始终可以使用简单的旧代码编写自己的方法。 例如，这里是一个可用于捕获空引用的结构。 它以与 &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; 相同的概念建模：</target>
        </trans-unit>
        <trans-unit id="1b22ef513641d8af3ca046740205bbee48335bff" translate="yes" xml:space="preserve">
          <source>Or you can even use it when the method just returns &lt;code&gt;T&lt;/code&gt; (in this case &lt;code&gt;Person&lt;/code&gt;) by doing a cast. For example, the following code would just like the code above:</source>
          <target state="translated">或者，甚至在方法通过执行 &lt;code&gt;Person&lt;/code&gt; 仅返回 &lt;code&gt;T&lt;/code&gt; （在这种情况下为Person ）时使用它。 例如，以下代码与上面的代码类似：</target>
        </trans-unit>
        <trans-unit id="c9a30ba5e221a0e082315c528b339ab02883ea86" translate="yes" xml:space="preserve">
          <source>Otherwise, the variable name will be assigned the value of the p.Spouse.FirstName.</source>
          <target state="translated">否则,变量名称将被分配为p.Spouse.FirstName的值。</target>
        </trans-unit>
        <trans-unit id="350349ce41ad9ae3414e0ee6f0cc9d8fdd70adfe" translate="yes" xml:space="preserve">
          <source>Poorly Implemented Try/Catch</source>
          <target state="translated">执行不力的TryCatch</target>
        </trans-unit>
        <trans-unit id="cf56bb150b35de64b7d13c5c15cc44a04165e6c6" translate="yes" xml:space="preserve">
          <source>Possibly, other code prematurely invalidated an object still in use</source>
          <target state="translated">可能是其他代码过早地使一个还在使用中的对象失效了</target>
        </trans-unit>
        <trans-unit id="49dadac90d9e655d655da0a9465c937e3e41e55d" translate="yes" xml:space="preserve">
          <source>Range Variable (Indirect/Deferred)</source>
          <target state="translated">范围变量(间接递延)</target>
        </trans-unit>
        <trans-unit id="7bbbd80923d138130436a31cdb61e2a69e969c03" translate="yes" xml:space="preserve">
          <source>Rather than indirect references by name using the form's &lt;code&gt;Controls&lt;/code&gt; collection, use the control reference:</source>
          <target state="translated">而不是使用表单的 &lt;code&gt;Controls&lt;/code&gt; 集合按名称进行间接引用，而应使用控件引用：</target>
        </trans-unit>
        <trans-unit id="517a0d09eeac328a5dcd1752d817bf8b7bd38630" translate="yes" xml:space="preserve">
          <source>Referencing array elements later will result in an NRE. If you do this in &lt;code&gt;Form_Load&lt;/code&gt;, due to an odd bug, the IDE &lt;em&gt;may not&lt;/em&gt; report the exception when it happens. The exception will pop up &lt;em&gt;later&lt;/em&gt; when your code tries to use the array. This &quot;silent exception&quot; is &lt;a href=&quot;https://stackoverflow.com/a/4934010/1070452&quot;&gt;detailed in this post&lt;/a&gt;. For our purposes, the key is that when something catastrophic happens while creating a form (&lt;code&gt;Sub New&lt;/code&gt; or &lt;code&gt;Form Load&lt;/code&gt; event), exceptions may go unreported, the code exits the procedure and just displays the form.</source>
          <target state="translated">以后引用数组元素将导致NRE。 如果在 &lt;code&gt;Form_Load&lt;/code&gt; 中执行此操作，则由于一个奇怪的错误，IDE &lt;em&gt;可能不会&lt;/em&gt;在发生异常时报告该异常。 当您的代码尝试使用数组时，异常将在&lt;em&gt;以后&lt;/em&gt;弹出。 &lt;a href=&quot;https://stackoverflow.com/a/4934010/1070452&quot;&gt;这篇文章详细介绍了这种&lt;/a&gt; &amp;ldquo;无声例外&amp;rdquo;。 出于我们的目的，关键是当创建表单时发生灾难性事件（ &lt;code&gt;Sub New&lt;/code&gt; 或 &lt;code&gt;Form Load&lt;/code&gt; 事件）时，可能不会报告异常，代码将退出过程并仅显示表单。</target>
        </trans-unit>
        <trans-unit id="d7961680dc43f2fb54210f44d5d5893f415a97ea" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;Exit Function&lt;/code&gt; in the function with &lt;code&gt;Return bList&lt;/code&gt;. Returning an &lt;em&gt;empty&lt;/em&gt;&lt;code&gt;List&lt;/code&gt; is not the same as returning &lt;code&gt;Nothing&lt;/code&gt;. If there is a chance that a returned object can be &lt;code&gt;Nothing&lt;/code&gt;, test before using it:</source>
          <target state="translated">用 &lt;code&gt;Return bList&lt;/code&gt; 替换 &lt;code&gt;Exit Function&lt;/code&gt; 中的Exit Function 。 返回&lt;em&gt;空&lt;/em&gt; &lt;code&gt;List&lt;/code&gt; 与返回 &lt;code&gt;Nothing&lt;/code&gt; 不同 。 如果返回的对象可能是 &lt;code&gt;Nothing&lt;/code&gt; ，请在使用它之前进行测试：</target>
        </trans-unit>
        <trans-unit id="e09009f0be2bc5dc475d39c72cbad2457332d844" translate="yes" xml:space="preserve">
          <source>Scope in Visual Basic</source>
          <target state="translated">Visual Basic中的范围</target>
        </trans-unit>
        <trans-unit id="ec36826e04a6ea83960855360f7576fa1a70dea9" translate="yes" xml:space="preserve">
          <source>See &quot;&lt;a href=&quot;https://stackoverflow.com/questions/19314340/nullreferenceexception-thrown-when-testing-custom-authorizationattribute&quot;&gt;NullReferenceException thrown when testing custom AuthorizationAttribute&lt;/a&gt;&quot; for a somewhat verbose example.</source>
          <target state="translated">请参阅&amp;ldquo; &lt;a href=&quot;https://stackoverflow.com/questions/19314340/nullreferenceexception-thrown-when-testing-custom-authorizationattribute&quot;&gt;测试自定义AuthorizationAttribute时抛出的NullReferenceException&lt;/a&gt; &amp;rdquo;，以获取一些冗长的示例。</target>
        </trans-unit>
        <trans-unit id="dee0432b1dfd3821074c0b47888585c85bdf5bb0" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Data.DataTable(v=vs.110).aspx&quot;&gt;DataTable Class&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/System.Data.DataTable(v=vs.110).aspx&quot;&gt;DataTable类&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">也见。</target>
        </trans-unit>
        <trans-unit id="b81624007a72ba2076c9759224672d60d8e74940" translate="yes" xml:space="preserve">
          <source>Since VB is managing Settings for you, it is reasonable to expect it to initialize the collection. It will, but only if you have previously added an initial entry to the collection (in the Settings editor). Since the collection is (apparently) initialized when an item is added, it remains &lt;code&gt;Nothing&lt;/code&gt; when there are no items in the Settings editor to add.</source>
          <target state="translated">由于VB正在为您管理&amp;ldquo;设置&amp;rdquo;，因此可以期望它初始化集合。 它将，但前提是您先前已在集合中添加了初始条目（在&amp;ldquo;设置&amp;rdquo;编辑器中）。 由于添加时（显然）初始化了集合，因此在&amp;ldquo;设置&amp;rdquo;编辑器中没有要添加的项目时，该集合将保持为空。</target>
        </trans-unit>
        <trans-unit id="5e1ee4902767b648a32002c3f0eac6e8212d4c61" translate="yes" xml:space="preserve">
          <source>Since no other code in your &lt;code&gt;Sub New&lt;/code&gt; or &lt;code&gt;Form Load&lt;/code&gt; event will run after the NRE, &lt;em&gt;a great many other things&lt;/em&gt; can be left uninitialized.</source>
          <target state="translated">由于NRE之后将不会再运行 &lt;code&gt;Sub New&lt;/code&gt; 或 &lt;code&gt;Form Load&lt;/code&gt; 事件中的其他代码，因此&lt;em&gt;许多其他事情&lt;/em&gt;可以保留为未初始化。</target>
        </trans-unit>
        <trans-unit id="169ef3e9a5e6d08f8ec9f775f25ef7ca8fe0ba80" translate="yes" xml:space="preserve">
          <source>Since the problem is an object reference which is &lt;code&gt;Nothing&lt;/code&gt;, the answer is to examine them to find out which one. Then determine why it is not initialized. Hold the mouse over the various variables and Visual Studio (VS) will show their values - the culprit will be &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">由于问题是一个对象引用，为 &lt;code&gt;Nothing&lt;/code&gt; ，答案是检查它们以找出哪个对象。 然后确定为什么不初始化。 将鼠标悬停在各个变量上，Visual Studio（VS）将显示它们的值-罪魁祸首是 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5af1e9a2d60a99283e7a7af80fb60c02d4755e0" translate="yes" xml:space="preserve">
          <source>Since this uses one table, using &lt;code&gt;Tables(0)&lt;/code&gt; will avoid spelling errors.  Examining &lt;code&gt;Rows.Count&lt;/code&gt; can also help:</source>
          <target state="translated">由于它使用一个表，因此使用 &lt;code&gt;Tables(0)&lt;/code&gt; 可以避免拼写错误。 检查 &lt;code&gt;Rows.Count&lt;/code&gt; 还可以帮助：</target>
        </trans-unit>
        <trans-unit id="5fb8e569fb6ed72a6dffcc33b03fceee972649a2" translate="yes" xml:space="preserve">
          <source>So how to tackle this:</source>
          <target state="translated">那么,如何解决这个问题。</target>
        </trans-unit>
        <trans-unit id="0af6f84e1abe20a8c228b77e487571323c47990e" translate="yes" xml:space="preserve">
          <source>So, as a practice we should always use null check, before accessing properties in such objects (specially in generic)</source>
          <target state="translated">所以,作为一种做法,我们应该在访问这些对象(特别是在通用对象中)的属性之前,始终使用空校验。</target>
        </trans-unit>
        <trans-unit id="728a2ccae6943f95d4a0778979a96e78b85be334" translate="yes" xml:space="preserve">
          <source>So, if you're dealing with &lt;strong&gt;value types&lt;/strong&gt;, NullReferenceExceptions can &lt;strong&gt;not&lt;/strong&gt; occur. Though you need to keep alert when dealing with &lt;strong&gt;reference types&lt;/strong&gt;!</source>
          <target state="translated">因此，如果要处理&lt;strong&gt;值类型&lt;/strong&gt; ，则&lt;strong&gt;不会&lt;/strong&gt;发生NullReferenceExceptions。 尽管在处理&lt;strong&gt;引用类型&lt;/strong&gt;时需要保持警惕！</target>
        </trans-unit>
        <trans-unit id="3fef728484bb42f677ee7c22d16e57e13b623b0b" translate="yes" xml:space="preserve">
          <source>Some common scenarios where the exception can be thrown:</source>
          <target state="translated">一些常见的情况下,可以抛出异常情况。</target>
        </trans-unit>
        <trans-unit id="270f67be70dbe22b11e82aa389399daab08d5ed7" translate="yes" xml:space="preserve">
          <source>Something which your code assumed would initialize an object, did not</source>
          <target state="translated">你的代码假设会初始化一个对象,但却没有</target>
        </trans-unit>
        <trans-unit id="d79169ce047a865f22ceedf2f516d3f6a8bd12b3" translate="yes" xml:space="preserve">
          <source>Something you assumed would perform flawlessly to return an initialized object to your code, did not.</source>
          <target state="translated">你以为可以完美无缺地执行的东西,向你的代码中返回一个初始化的对象,却没有。</target>
        </trans-unit>
        <trans-unit id="7b881a3646ad1ece01b3005831c5797e83c52c23" translate="yes" xml:space="preserve">
          <source>Sometimes the boxing happens in another way. For example with this non-generic extension method:</source>
          <target state="translated">有的时候,拳脚相向是以另一种方式发生的。比如说用这种非通用的扩展方法。</target>
        </trans-unit>
        <trans-unit id="c8202db459212644c10dde57d8e4df666ce482d5" translate="yes" xml:space="preserve">
          <source>Special techniques for debugging and fixing null derefs in iterators</source>
          <target state="translated">用于调试和修复迭代器中的null derefs的特殊技术</target>
        </trans-unit>
        <trans-unit id="0fbbe68dcced5d9fa19046eaf6118ab8f81482e2" translate="yes" xml:space="preserve">
          <source>Specifically, in &lt;code&gt;HttpContext.Current.User.Identity.Name&lt;/code&gt;, the &lt;code&gt;HttpContext.Current&lt;/code&gt; could be null, or the &lt;code&gt;User&lt;/code&gt; property could be null, or the &lt;code&gt;Identity&lt;/code&gt; property could be null.</source>
          <target state="translated">具体来说，在 &lt;code&gt;HttpContext.Current.User.Identity.Name&lt;/code&gt; 中 ， &lt;code&gt;HttpContext.Current&lt;/code&gt; 可以为null，或者 &lt;code&gt;User&lt;/code&gt; 属性可以为null，或者 &lt;code&gt;Identity&lt;/code&gt; 属性可以为null。</target>
        </trans-unit>
        <trans-unit id="f5dea8e13e62a3f32c925f340dc736efda53d43f" translate="yes" xml:space="preserve">
          <source>Suppose I have a class and member method in it. I have not instantiated my class but only named my class. Now if I try to use the method, the compiler will throw an error or issue a warning (depending on the compiler).</source>
          <target state="translated">假设我有一个类和成员方法。我没有实例化我的类,只是给我的类命名。现在如果我尝试使用这个方法,编译器会抛出一个错误或发出警告(取决于编译器)。</target>
        </trans-unit>
        <trans-unit id="a9bfffacd695cafe387b5dba29e8a53f54d17c9a" translate="yes" xml:space="preserve">
          <source>Suppose you have a web form Contact.aspx whose codebehind class is Contact and you have an entity name Contact.</source>
          <target state="translated">假设你有一个Web表单Contact.aspx,其代码背后的类是Contact,并且你有一个实体名称为Contact。</target>
        </trans-unit>
        <trans-unit id="a32dcf6bc661323f00cb04b17bca14992a13218c" translate="yes" xml:space="preserve">
          <source>System.NullReferenceException: Object reference not set to an instance
  of an object. at Program.Main()</source>
          <target state="translated">System.NullReferenceException:对象引用未设置为对象的实例。</target>
        </trans-unit>
        <trans-unit id="61b52702efd8978d72bc6dd4556000b0c5302229" translate="yes" xml:space="preserve">
          <source>Take the time required to understand the cause of the exception. Inspect for null expressions. Inspect the previous expressions which could have resulted in such null expressions. Add &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/ktf38f66(v=vs.90)&quot;&gt;breakpoints&lt;/a&gt; and step through the program as appropriate. &lt;em&gt;Use the debugger.&lt;/em&gt;</source>
          <target state="translated">花点时间了解异常原因。 检查空表达式。 检查可能导致这种空表达式的先前表达式。 添加&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/ktf38f66(v=vs.90)&quot;&gt;断点&lt;/a&gt;并根据需要逐步执行该程序。 &lt;em&gt;使用调试器。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96355bac807e2bf7c816f87187a186dfb05609b3" translate="yes" xml:space="preserve">
          <source>That is, make a private helper method that has the iterator block logic, and a public surface method that does the null check and returns the iterator.  Now when &lt;code&gt;GetFrobs&lt;/code&gt; is called, the null check happens immediately, and then &lt;code&gt;GetFrobsForReal&lt;/code&gt; executes when the sequence is iterated.</source>
          <target state="translated">也就是说，制作一个具有迭代器块逻辑的私有帮助器方法，以及一个执行空检查并返回迭代器的公共表面方法。 现在， &lt;code&gt;GetFrobs&lt;/code&gt; 时，将立即执行空检查，然后在迭代序列时执行 &lt;code&gt;GetFrobsForReal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c98e5a07997fb98921d015b9962a6fe887151a12" translate="yes" xml:space="preserve">
          <source>That means if any member which doesn&amp;rsquo;t hold any value and we are making that member to perform certain task then the system will undoubtedly toss a message and say-</source>
          <target state="translated">这意味着，如果有任何成员没有任何价值，而我们正在使该成员执行某些任务，那么系统无疑会抛出一条消息并说：</target>
        </trans-unit>
        <trans-unit id="cd6b57e6915e732c6a3454d47a45928771b568d1" translate="yes" xml:space="preserve">
          <source>That will throw the error because while I've declared the variable &quot;&lt;code&gt;connection&lt;/code&gt;&quot;, it's not pointed to anything. When I try to call the member &quot;&lt;code&gt;Open&lt;/code&gt;&quot;, there's no reference for it to resolve, and it will throw the error.</source>
          <target state="translated">这将引发错误，因为当我声明变量&amp;ldquo; &lt;code&gt;connection&lt;/code&gt; &amp;rdquo;时，它没有指向任何东西。 当我尝试将成员称为&amp;ldquo; &lt;code&gt;Open&lt;/code&gt; &amp;rdquo;时，没有可解决的引用，它将引发错误。</target>
        </trans-unit>
        <trans-unit id="af16544bdee6b293bf4ee765cfb10b13b80b318a" translate="yes" xml:space="preserve">
          <source>That's why dereferencing both a null pointer and a null reference produces the same exception.</source>
          <target state="translated">这就是为什么去掉一个空指针和一个空引用都会产生相同的异常。</target>
        </trans-unit>
        <trans-unit id="832f18980c9adec58ccfc7eafce613c988307af0" translate="yes" xml:space="preserve">
          <source>The .NET runtime will throw a NullReferenceException when you attempt to perform an action on something which hasn't been instantiated i.e. the code above.</source>
          <target state="translated">当你试图对没有被实例化的东西执行一个动作时,例如上面的代码,.NET运行时将抛出一个NullReferenceException。</target>
        </trans-unit>
        <trans-unit id="26534d5f78e239955916af7b305fc5b41ba2ea2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DataAdapter&lt;/code&gt; will provide &lt;code&gt;TableNames&lt;/code&gt; as shown in the previous example, but it does not parse names from the SQL or database table. As a result, &lt;code&gt;ds.Tables(&quot;TICKET_RESERVATION&quot;)&lt;/code&gt; references a non-existent table.</source>
          <target state="translated">&lt;code&gt;DataAdapter&lt;/code&gt; 将提供上一个示例中所示的 &lt;code&gt;TableNames&lt;/code&gt; ，但不会解析SQL或数据库表中的名称。 结果， &lt;code&gt;ds.Tables(&quot;TICKET_RESERVATION&quot;)&lt;/code&gt; 引用了不存在的表。</target>
        </trans-unit>
        <trans-unit id="4e757d5d15663001bb33deeec07e2827ba5bd3a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsDBNull&lt;/code&gt; function is used to test if a &lt;em&gt;value&lt;/em&gt; equals &lt;code&gt;System.DBNull&lt;/code&gt;:  &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/tckcces5(v=vs.90)&quot;&gt;From MSDN:&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;IsDBNull&lt;/code&gt; 函数用于测试&lt;em&gt;值是否&lt;/em&gt;等于 &lt;code&gt;System.DBNull&lt;/code&gt; ： &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/tckcces5(v=vs.90)&quot;&gt;来自MSDN：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b413c4771f93ecdb1da4953c33951691d69e4d43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;New&lt;/code&gt; operator can often be used to create the instance when you declare it:</source>
          <target state="translated">在声明实例时，通常可以使用 &lt;code&gt;New&lt;/code&gt; 运算符来创建实例：</target>
        </trans-unit>
        <trans-unit id="40dbae9f26db30254b9c9f1a9df041f25f4ae4cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NullReference Exception&lt;/code&gt; for &lt;strong&gt;Visual Basic&lt;/strong&gt; is no different from the one in &lt;strong&gt;C#&lt;/strong&gt;. After all, they are both reporting the same exception defined in the .NET Framework which they both use. Causes unique to Visual Basic are rare (perhaps only one).</source>
          <target state="translated">&lt;strong&gt;Visual Basic&lt;/strong&gt;的 &lt;code&gt;NullReference Exception&lt;/code&gt; 与&lt;strong&gt;C＃中的&lt;/strong&gt; 异常相同。 毕竟，它们都报告了它们都使用的.NET Framework中定义的相同异常。 Visual Basic特有的原因很少（也许只有一个）。</target>
        </trans-unit>
        <trans-unit id="20d435cc2ffcce4a30d45f389b288f97cfa9298a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new Person&lt;/code&gt; only creates an instance of &lt;code&gt;Person&lt;/code&gt;, but the &lt;code&gt;Books&lt;/code&gt; collection is still &lt;code&gt;null&lt;/code&gt;. The collection &lt;code&gt;Initializer&lt;/code&gt; syntax does not create a collection
for &lt;code&gt;p1.Books&lt;/code&gt;, it only translates to the &lt;code&gt;p1.Books.Add(...)&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;new Person&lt;/code&gt; 只创建Person的一个实例，但是 &lt;code&gt;Books&lt;/code&gt; 集合仍然为 &lt;code&gt;null&lt;/code&gt; 。 集合 &lt;code&gt;Initializer&lt;/code&gt; 语法不会为 &lt;code&gt;p1.Books&lt;/code&gt; 创建一个集合，它仅转换为 &lt;code&gt;p1.Books.Add(...)&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="e0b42fc2efda212a3943ac23d1a88e3d1f5590dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runtime&lt;/code&gt; throwing a &lt;code&gt;NullReferenceException&lt;/code&gt;&lt;strong&gt;always&lt;/strong&gt; means the same thing: you are trying to use a reference, and the reference is not initialized (or it was &lt;em&gt;once&lt;/em&gt; initialized, but is &lt;em&gt;no longer&lt;/em&gt; initialized).</source>
          <target state="translated">&lt;code&gt;runtime&lt;/code&gt; 抛出 &lt;code&gt;NullReferenceException&lt;/code&gt; &lt;strong&gt;总是&lt;/strong&gt;意味着同一件事：您正在尝试使用引用，并且该引用未初始化（或者&lt;em&gt;曾经&lt;/em&gt;被初始化，但是&lt;em&gt;不再&lt;/em&gt;初始化）。</target>
        </trans-unit>
        <trans-unit id="49a69af3cb15571971e9fd0f2918ddd41cf47307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;somevar&lt;/code&gt; assignment will result in an immediate NRE because Nothing doesn't have a &lt;code&gt;.Text&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;somevar&lt;/code&gt; 分配将立即产生NRE，因为Nothing没有 &lt;code&gt;.Text&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="6d5d5590cc424a0742ec3b68941443b7a51567cc" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Remedy&lt;/strong&gt; is the same, reference the table by index:</source>
          <target state="translated">&lt;strong&gt;补救措施&lt;/strong&gt;是相同的，按索引引用表：</target>
        </trans-unit>
        <trans-unit id="3040c6289873dac88d88f00dfa3143d8958589ea" translate="yes" xml:space="preserve">
          <source>The Array will contain five elements of Nothing</source>
          <target state="translated">阵列将包含5个Nothing元素</target>
        </trans-unit>
        <trans-unit id="27ceb372d3a055414ac4ebce858ea4ad711a0987" translate="yes" xml:space="preserve">
          <source>The DGV has a few quirks seen periodically:</source>
          <target state="translated">DGV有一些怪癖,定期看到的。</target>
        </trans-unit>
        <trans-unit id="c70e919024ee1fab6a7f20fb2647ea7464472447" translate="yes" xml:space="preserve">
          <source>The DataGridView</source>
          <target state="translated">数据网格视图</target>
        </trans-unit>
        <trans-unit id="ef89f949d60a7ce3ba16474314cece6c25c1b417" translate="yes" xml:space="preserve">
          <source>The System.DBNull value indicates that the Object represents missing or non-existent data. DBNull is not the same as Nothing, which indicates that a variable has not yet been initialized.</source>
          <target state="translated">System.DBNull值表示对象表示缺失或不存在数据。DBNull与Nothing不同,后者表示变量尚未被初始化。</target>
        </trans-unit>
        <trans-unit id="3fab983167187e8d3c1de769d9fd8889b4da2253" translate="yes" xml:space="preserve">
          <source>The above code shows simple string which is assigned with a &lt;strong&gt;null&lt;/strong&gt; value.</source>
          <target state="translated">上面的代码显示了一个简单的字符串，该字符串分配了一个&lt;strong&gt;空&lt;/strong&gt;值。</target>
        </trans-unit>
        <trans-unit id="17d03251d7278b73c29dd924064c9cb221dda373" translate="yes" xml:space="preserve">
          <source>The array code may not be out of the woods yet. Any controls which are in a container control (like a &lt;code&gt;GroupBox&lt;/code&gt; or &lt;code&gt;Panel&lt;/code&gt;) will not be found in &lt;code&gt;Me.Controls&lt;/code&gt;; they will be in the Controls collection of that Panel or GroupBox. Nor will a control be returned when the control name is misspelled (&lt;code&gt;&quot;TeStBox2&quot;&lt;/code&gt;). In such cases, &lt;code&gt;Nothing&lt;/code&gt; will again be stored in those array elements and an NRE will result when you attempt to reference it.</source>
          <target state="translated">阵列代码可能还没有走出困境。 在 &lt;code&gt;Me.Controls&lt;/code&gt; 中找不到容器控件中的任何控件（例如 &lt;code&gt;GroupBox&lt;/code&gt; 或 &lt;code&gt;Panel&lt;/code&gt; ）。 它们将位于该Panel或GroupBox的Controls集合中。 拼写错误的控件名称（ &lt;code&gt;&quot;TeStBox2&quot;&lt;/code&gt; ）也不会返回控件。 在这种情况下， &lt;code&gt;Nothing&lt;/code&gt; 也不会再存储在这些数组元素中，并且在您尝试引用它时会产生NRE。</target>
        </trans-unit>
        <trans-unit id="9152dbff2da4b545031d214da21c705228394a13" translate="yes" xml:space="preserve">
          <source>The array has been created, but the &lt;code&gt;Foo&lt;/code&gt; objects in it have not.</source>
          <target state="translated">数组已创建，但其中的 &lt;code&gt;Foo&lt;/code&gt; 对象尚未创建。</target>
        </trans-unit>
        <trans-unit id="503f97cf7bd74b54164bcdafbce1e18337fefeac" translate="yes" xml:space="preserve">
          <source>The code is only testing &lt;code&gt;Items&lt;/code&gt; while both &lt;code&gt;myFoo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; may also be Nothing. The &lt;strong&gt;remedy&lt;/strong&gt; is to test the entire chain or path of objects one at a time:</source>
          <target state="translated">该代码仅用于测试 &lt;code&gt;Items&lt;/code&gt; ,而 &lt;code&gt;myFoo&lt;/code&gt; 和 &lt;code&gt;Bar&lt;/code&gt; 都可能为Nothing。 &lt;strong&gt;补救措施&lt;/strong&gt;是一次测试一个对象的整个链或路径：</target>
        </trans-unit>
        <trans-unit id="463bfd62c8f05004461fb5a31b8995846405c429" translate="yes" xml:space="preserve">
          <source>The constructor for the &lt;code&gt;ArgumentNullException&lt;/code&gt; even takes the name of the parameter and a message as arguments so you can tell the developer exactly what the problem is.</source>
          <target state="translated">&lt;code&gt;ArgumentNullException&lt;/code&gt; 的构造函数甚至将参数的名称和一条消息作为参数，以便您可以确切地告诉开发者问题所在。</target>
        </trans-unit>
        <trans-unit id="3316f1a701fde7c120bf71968a77f55f36491fce" translate="yes" xml:space="preserve">
          <source>The correct fix is:</source>
          <target state="translated">正确的解决方法是:</target>
        </trans-unit>
        <trans-unit id="1294e0c3d65f0d8b731cd2b09629341a194dc6ce" translate="yes" xml:space="preserve">
          <source>The data Type and array size are inferred from the data being assigned. Class/Module level declarations still require &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; with &lt;code&gt;Option Strict&lt;/code&gt;:</source>
          <target state="translated">数据类型和数组大小是从分配的数据推断出来的。 类/模块级别的声明仍然需要带有 &lt;code&gt;Option Strict&lt;/code&gt; 的 &lt;code&gt;As &amp;lt;Type&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0a67859648408e02bf57b5242710673d9d105f41" translate="yes" xml:space="preserve">
          <source>The developer is &lt;strong&gt;using &lt;code&gt;null&lt;/code&gt; intentionally to indicate there is no meaningful value available.&lt;/strong&gt; Note that C# has the concept of nullable datatypes for variables (like database tables can have nullable fields) - you can assign &lt;code&gt;null&lt;/code&gt; to them to indicate there is no value stored in it, for example &lt;code&gt;int? a = null;&lt;/code&gt; where the question mark indicates it is allowed to store null in variable &lt;code&gt;a&lt;/code&gt;. You can check that either with &lt;code&gt;if (a.HasValue) {...}&lt;/code&gt; or with &lt;code&gt;if (a==null) {...}&lt;/code&gt;. Nullable variables, like &lt;code&gt;a&lt;/code&gt; this example, allow to access the value via &lt;code&gt;a.Value&lt;/code&gt; explicitly, or just as normal via &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">开发人员&lt;strong&gt;有意使用 &lt;code&gt;null&lt;/code&gt; 来指示没有可用的有意义的值。&lt;/strong&gt; 请注意，C＃具有变量的可为空的数据类型的概念（例如数据库表可以具有可为空的字段）-您可以为它们分配 &lt;code&gt;null&lt;/code&gt; 来指示其中没有存储任何值，例如 &lt;code&gt;int? a = null;&lt;/code&gt; a = null; 问号表示允许在变量 &lt;code&gt;a&lt;/code&gt; 中存储null 的位置 。 您可以使用 &lt;code&gt;if (a.HasValue) {...}&lt;/code&gt; 或 &lt;code&gt;if (a==null) {...}&lt;/code&gt; 。 像本示例一样，可空变量允许通过 &lt;code&gt;a.Value&lt;/code&gt; 显式地访问值，或者像通常一样通过 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45a964d78da459f6bbd37b8cd232d3a6efef6380" translate="yes" xml:space="preserve">
          <source>The error line &quot;Object reference not set to an instance of an object.
&quot; states that you have not assigned instance object to a object reference and still you are accessing properies/methods of that object.</source>
          <target state="translated">错误行 &quot;Object reference not set to an instance of an object.&quot;说明你没有将实例对象分配给对象引用,而你仍然在访问该对象的 properiesmethods。</target>
        </trans-unit>
        <trans-unit id="a400e3953b7fb9b7c815f1ce88a4ab2b01f595e6" translate="yes" xml:space="preserve">
          <source>The error occurs when both the entity and codebehind class are in same namespace.
To fix this, rename the entity class or the codebehind class for Contact.aspx.</source>
          <target state="translated">当实体类和codebehind类都在同一个命名空间时,就会出现错误。要解决这个问题,请重命名实体类或codebehind类为Contact.aspx。</target>
        </trans-unit>
        <trans-unit id="895203d5cc7b55ecb7ef70317a104cba1837e261" translate="yes" xml:space="preserve">
          <source>The examples (from Stack&amp;nbsp; Overflow posts) do not always show the best way to do something in the first place.</source>
          <target state="translated">这些示例（来自Stack Overflow的帖子）并不总是始终显示最佳的方法。</target>
        </trans-unit>
        <trans-unit id="d1d89f5634b915a9e16a0aaaf5998b7a175005a7" translate="yes" xml:space="preserve">
          <source>The exception error is:</source>
          <target state="translated">异常错误是。</target>
        </trans-unit>
        <trans-unit id="4dabb60bda5cb5e73ecf06dcad355e8e1b245e9c" translate="yes" xml:space="preserve">
          <source>The exception itself says that something is being referred but whose value is not being set. So this denotes that it only occurs while using reference types as Value types are non-nullable.</source>
          <target state="translated">异常本身就表示某物被引用,但其值没有被设置。所以,这表示只有在使用引用类型时才会出现,因为值类型是不可空的。</target>
        </trans-unit>
        <trans-unit id="06815801582cc6befb5ef98b61f02e87744088ac" translate="yes" xml:space="preserve">
          <source>The hardest one .. if the &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;GC&lt;/a&gt;&lt;/strong&gt; collected the object already... This generally occurs if you are trying to find an object using strings... That is, finding it by name of the object then it may happen that the GC might already cleaned it up... This is hard to find and will become quite a problem... A better way to tackle this is do null checks wherever necessary during the development process. This will save you a lot of time.</source>
          <target state="translated">最难的一个..如果&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;GC&lt;/a&gt;&lt;/strong&gt;已经收集了对象...如果您尝试使用字符串查找对象，这通常会发生...也就是说，通过对象的名称查找它，则可能发生GC清理它...这很难找到，并且将成为一个大问题。解决此问题的更好方法是在开发过程中的必要位置进行空检查。 这样可以节省您很多时间。</target>
        </trans-unit>
        <trans-unit id="6fe9c46a1f96250f3a78f255ee7a539166e5eefe" translate="yes" xml:space="preserve">
          <source>The message &lt;em&gt;&quot;Object not set to an instance of Object&quot;&lt;/em&gt; means you are trying to use an object which has not been initialized. This boils down to one of these:</source>
          <target state="translated">消息&lt;em&gt;&amp;ldquo;对象未设置为对象的实例&amp;rdquo;&lt;/em&gt;表示您正在尝试使用尚未初始化的对象。 归结为以下之一：</target>
        </trans-unit>
        <trans-unit id="7e3ca54b85861772b0461d9717c527d72a64967f" translate="yes" xml:space="preserve">
          <source>The nested collection &lt;code&gt;Initializers&lt;/code&gt; behave the same:</source>
          <target state="translated">嵌套集合 &lt;code&gt;Initializers&lt;/code&gt; 的行为相同：</target>
        </trans-unit>
        <trans-unit id="90aa4a0c7a11c901e2c17878dabdd430757e21cc" translate="yes" xml:space="preserve">
          <source>The nullable annotation context and nullable warning context can be set for a project using the &lt;code&gt;Nullable&lt;/code&gt; element in your &lt;code&gt;csproj&lt;/code&gt; file. This element configures how the compiler interprets the nullability of types and what warnings are generated. Valid settings are:</source>
          <target state="translated">可以使用 &lt;code&gt;csproj&lt;/code&gt; 文件中的 &lt;code&gt;Nullable&lt;/code&gt; 元素为项目设置可为空的注释上下文和可为空的警告上下文。 该元素配置编译器如何解释类​​型的可空性以及生成什么警告。 有效设置为：</target>
        </trans-unit>
        <trans-unit id="a10b33de1b42bbbc51b19833cb2f573dc939676f" translate="yes" xml:space="preserve">
          <source>The plain versions &lt;code&gt;First()&lt;/code&gt; and &lt;code&gt;Single()&lt;/code&gt; throw exceptions when there is nothing. The &quot;OrDefault&quot; versions return null in that case. So be aware of that.</source>
          <target state="translated">没有任何内容时，普通版本的 &lt;code&gt;First()&lt;/code&gt; 和 &lt;code&gt;Single()&lt;/code&gt; 会引发异常。 在这种情况下，&amp;ldquo; OrDefault&amp;rdquo;版本返回null。 因此请注意。</target>
        </trans-unit>
        <trans-unit id="ca0d4b830b1ca78cc1cd2b85b0b059562a5a92dc" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;Dim&lt;/code&gt; does not create a CashRegister &lt;em&gt;object&lt;/em&gt;; it only declares a variable named &lt;code&gt;reg&lt;/code&gt; of that Type. &lt;em&gt;Declaring&lt;/em&gt; an object variable and creating an &lt;em&gt;instance&lt;/em&gt; are two different things.</source>
          <target state="translated">问题是 &lt;code&gt;Dim&lt;/code&gt; 不会创建CashRegister &lt;em&gt;对象&lt;/em&gt; 。 它仅声明该类型的名为 &lt;code&gt;reg&lt;/code&gt; 的变量。 &lt;em&gt;声明&lt;/em&gt;对象变量和创建&lt;em&gt;实例&lt;/em&gt;是两件事。</target>
        </trans-unit>
        <trans-unit id="f57a9af331b2b384f5e9bbf25e52891735f99da4" translate="yes" xml:space="preserve">
          <source>The rest of this article goes into more detail and shows mistakes that many programmers often make which can lead to a &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">本文的其余部分将更详细地介绍并显示许多程序员经常犯的错误，这些错误可能导致 &lt;code&gt;NullReferenceException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d27e02a7560754b5c14948489cc1146ab300619d" translate="yes" xml:space="preserve">
          <source>The result is that the name will be null when p is null or when p.Spouse is null.</source>
          <target state="translated">其结果是,当p为空或p.Spouse为空时,名字将为空。</target>
        </trans-unit>
        <trans-unit id="09d1d7d139d2f9ffa7cf279ad2ecc6cf210c00d2" translate="yes" xml:space="preserve">
          <source>The same applies to nested object initializers:</source>
          <target state="translated">嵌套对象的初始化器也是如此。</target>
        </trans-unit>
        <trans-unit id="ed30a1778fd31736e38acd0c7306ed44aa097108" translate="yes" xml:space="preserve">
          <source>The shorthand to providing a default value when a &lt;code&gt;null&lt;/code&gt; is encountered:</source>
          <target state="translated">遇到 &lt;code&gt;null&lt;/code&gt; 时提供默认值的简写：</target>
        </trans-unit>
        <trans-unit id="f4ffd808ec7172797ede1dca01b5953fc219db01" translate="yes" xml:space="preserve">
          <source>Then either &lt;a href=&quot;https://blogs.msdn.microsoft.com/zainnab/2010/11/01/start-debugging-vs-start-without-debugging/&quot;&gt;&lt;em&gt;Start with Debugging (F5)&lt;/em&gt;&lt;/a&gt; or &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/3s68z0b3.aspx&quot;&gt;&lt;em&gt;Attach [the VS Debugger] to Running Process&lt;/em&gt;&lt;/a&gt;. On occasion it may be useful to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.diagnostics.debugger.break(v=vs.110).aspx&quot;&gt;&lt;code&gt;Debugger.Break&lt;/code&gt;&lt;/a&gt;, which will prompt to launch the debugger.</source>
          <target state="translated">然后， &lt;a href=&quot;https://blogs.msdn.microsoft.com/zainnab/2010/11/01/start-debugging-vs-start-without-debugging/&quot;&gt;&lt;em&gt;从调试（F5）开始&lt;/em&gt;&lt;/a&gt;或&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/3s68z0b3.aspx&quot;&gt;&lt;em&gt;将[VS调试器]附加到正在运行的进程&lt;/em&gt;&lt;/a&gt; 。 有时使用&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.diagnostics.debugger.break(v=vs.110).aspx&quot;&gt; &lt;code&gt;Debugger.Break&lt;/code&gt; &lt;/a&gt;可能会有用，它将提示启动调试器。</target>
        </trans-unit>
        <trans-unit id="9cf2c6701fe17f333948c2b1849db6510ba64ad5" translate="yes" xml:space="preserve">
          <source>Then following code will throw a NullReferenceException when you call context.SaveChanges()</source>
          <target state="translated">那么当你调用context.SaveChanges()时,以下代码会抛出一个NullReferenceException</target>
        </trans-unit>
        <trans-unit id="7838ef23cdbcdcb9c6a670f31c478d1f79518c71" translate="yes" xml:space="preserve">
          <source>Then go into your script and type &lt;code&gt;rb = GetComponent&amp;lt;Rigidbody&amp;gt;();&lt;/code&gt;</source>
          <target state="translated">然后进入您的脚本并输入 &lt;code&gt;rb = GetComponent&amp;lt;Rigidbody&amp;gt;();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad41fc4e6ef8e0d250fac274fb58d4f833539aab" translate="yes" xml:space="preserve">
          <source>There are also several libraries that can help. &quot;Resharper&quot; for example can provide you with warnings while you are writing code, especially if you use their attribute: &lt;a href=&quot;https://www.jetbrains.com/resharper/help/Reference__Code_Annotation_Attributes.html#NotNullAttribute&quot;&gt;NotNullAttribute&lt;/a&gt;</source>
          <target state="translated">也有几个库可以提供帮助。 例如，&amp;ldquo; Resharper&amp;rdquo;可以在编写代码时向您提供警告，尤其是在使用其属性的情况下： &lt;a href=&quot;https://www.jetbrains.com/resharper/help/Reference__Code_Annotation_Attributes.html#NotNullAttribute&quot;&gt;NotNullAttribute&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbf732334378829eb2b72400cdd33b94ea5d2586" translate="yes" xml:space="preserve">
          <source>There are many good answers already here. You can also check more detailed description with examples on my &lt;a href=&quot;https://www.mistercode.net/2017/07/09/object-reference-not-set-to-an-instance-of-an-object/&quot;&gt;blog&lt;/a&gt;.</source>
          <target state="translated">这里已经有很多好的答案。 您还可以在我的&lt;a href=&quot;https://www.mistercode.net/2017/07/09/object-reference-not-set-to-an-instance-of-an-object/&quot;&gt;博客&lt;/a&gt;上查看带有示例的更详细的描述。</target>
        </trans-unit>
        <trans-unit id="214fa86f68ca654e757c3e720dc78f2dd2fc2749" translate="yes" xml:space="preserve">
          <source>There are various ways and methods to avoid this renowned exception:</source>
          <target state="translated">有各种方式和方法可以避免这个著名的特例。</target>
        </trans-unit>
        <trans-unit id="be839701a8b58386dc83c43578a529bbcc452e47" translate="yes" xml:space="preserve">
          <source>There is a lot of good answers here explaining what a null reference is and how to debug it. But there is very little on how to prevent the issue or at least make it easier to catch.</source>
          <target state="translated">这里有很多很好的答案,解释了什么是空引用,以及如何调试它。但是关于如何防止问题的发生,或者至少让它更容易被抓住的问题却很少。</target>
        </trans-unit>
        <trans-unit id="7dbc715d0df7bdf0cd07c3dbe5ecb31f64abf37a" translate="yes" xml:space="preserve">
          <source>There is an extra comma in the SQL (after 'mailaddress') which results in an exception at &lt;code&gt;.ExecuteReader&lt;/code&gt;. After the &lt;code&gt;Catch&lt;/code&gt; does nothing, &lt;code&gt;Finally&lt;/code&gt; tries to perform clean up, but since you cannot &lt;code&gt;Close&lt;/code&gt; a null &lt;code&gt;DataReader&lt;/code&gt; object, a brand new &lt;code&gt;NullReferenceException&lt;/code&gt; results.</source>
          <target state="translated">SQL中有一个多余的逗号（在'mailaddress'之后），导致 &lt;code&gt;.ExecuteReader&lt;/code&gt; 处出现异常。 在 &lt;code&gt;Catch&lt;/code&gt; 不执行任何操作之后， &lt;code&gt;Finally&lt;/code&gt; 尝试执行清除操作，但是由于您无法 &lt;code&gt;Close&lt;/code&gt; null的 &lt;code&gt;DataReader&lt;/code&gt; 对象，因此会产生全新的 &lt;code&gt;NullReferenceException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee30cd268c28ea93084f9a9c56e3288e8f18511d" translate="yes" xml:space="preserve">
          <source>There's &quot;Microsoft Code Contracts&quot; where you use syntax like &lt;code&gt;Contract.Requires(obj != null)&lt;/code&gt; which gives you runtime and compile checking: &lt;a href=&quot;http://www.codeproject.com/Articles/103779/Introducing-Code-Contracts&quot;&gt;Introducing Code Contracts&lt;/a&gt;.</source>
          <target state="translated">在&amp;ldquo; Microsoft代码合同&amp;rdquo;中，您使用诸如 &lt;code&gt;Contract.Requires(obj != null)&lt;/code&gt; 类的语法，该语法为您提供运行时和编译检查： &lt;a href=&quot;http://www.codeproject.com/Articles/103779/Introducing-Code-Contracts&quot;&gt;代码合同简介&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="4586f5d6a7aef8d40083704fd4255e79f766656f" translate="yes" xml:space="preserve">
          <source>There's also &quot;PostSharp&quot; which will allow you to just use attributes like this:</source>
          <target state="translated">还有一个 &quot;PostSharp&quot;,可以让你直接使用这样的属性。</target>
        </trans-unit>
        <trans-unit id="35e0b1c03698b5fbfb3417627f45417f72e5c0bb" translate="yes" xml:space="preserve">
          <source>These cases arise because of the special rules the runtime uses when boxing &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; instances.</source>
          <target state="translated">这些情况的出现是由于运行时在对 &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; 实例进行装箱时使用的特殊规则。</target>
        </trans-unit>
        <trans-unit id="7c521d1475010ead5d72d575d5eea6c50ec89923" translate="yes" xml:space="preserve">
          <source>These should be easy to find now that you know what you are looking for:</source>
          <target state="translated">这些应该很容易找到,现在你知道你要找什么了。</target>
        </trans-unit>
        <trans-unit id="4bee35f92a41df1996281dd9bff320d1429a02b9" translate="yes" xml:space="preserve">
          <source>This answer will use Visual Basic terms, syntax, and context. The examples used come from a large number of past Stack&amp;nbsp; Overflow questions. This is to maximize relevance by using the &lt;em&gt;kinds&lt;/em&gt; of situations often seen in posts. A bit more explanation is also provided for those who might need it. An example similar to yours is &lt;em&gt;very&lt;/em&gt; likely listed here.</source>
          <target state="translated">该答案将使用Visual Basic术语，语法和上下文。 使用的示例来自大量过去的Stack Overflow问题。 这是通过使用帖子中经常出现的&lt;em&gt;各种&lt;/em&gt;情况来最大化相关性。 还为可能需要的人提供了更多解释。 此处&lt;em&gt;很&lt;/em&gt;可能列出与您类似的示例。</target>
        </trans-unit>
        <trans-unit id="43191fd8397e396ff48392d8f06628560c113ac6" translate="yes" xml:space="preserve">
          <source>This array has only been declared, not created. There are several ways to initialize an array:</source>
          <target state="translated">这个数组只被声明了,没有创建。有几种方法可以初始化一个数组。</target>
        </trans-unit>
        <trans-unit id="eebc527ad8416d09fe4ecd5b2aa132e7cea81190" translate="yes" xml:space="preserve">
          <source>This can be solved by following the convention to prefix fields with an underscore:</source>
          <target state="translated">这个问题可以按照惯例用下划线作为字段的前缀来解决。</target>
        </trans-unit>
        <trans-unit id="801881e44b7fc86f8a4310a9936bccc2fea2500b" translate="yes" xml:space="preserve">
          <source>This doesn't throw an &lt;code&gt;InvalidCastException&lt;/code&gt; but returns a &lt;code&gt;null&lt;/code&gt; when the cast fails (and when &lt;code&gt;someObject&lt;/code&gt; is itself null). So be aware of that.</source>
          <target state="translated">这不会引发 &lt;code&gt;InvalidCastException&lt;/code&gt; ,而是在强制转换失败时（并且 &lt;code&gt;someObject&lt;/code&gt; 本身为null）返回null。 因此请注意。</target>
        </trans-unit>
        <trans-unit id="8fef908ebbf6aa8923a642c4bd0b4053bc545790" translate="yes" xml:space="preserve">
          <source>This is a case of an object not being created as expected, but also demonstrates the counter usefulness of an empty &lt;code&gt;Catch&lt;/code&gt;.</source>
          <target state="translated">这是一种未按预期方式创建对象的情况，但也证明了空 &lt;code&gt;Catch&lt;/code&gt; 的反作用。</target>
        </trans-unit>
        <trans-unit id="4e0fb87a39ead3f4c4ab6bccc75cb03367823f34" translate="yes" xml:space="preserve">
          <source>This is a case where the IDE will warn you that '&lt;em&gt;not all paths return a value and a &lt;code&gt;NullReferenceException&lt;/code&gt; may result&lt;/em&gt;'. You can suppress the warning, by replacing &lt;code&gt;Exit Function&lt;/code&gt; with &lt;code&gt;Return Nothing&lt;/code&gt;, but that does not solve the problem. Anything which tries to use the return when &lt;code&gt;someCondition = False&lt;/code&gt; will result in an NRE:</source>
          <target state="translated">在这种情况下，IDE会警告您&amp;ldquo; &lt;em&gt;并非所有路径都返回值，并且可能会导致 &lt;code&gt;NullReferenceException&lt;/code&gt; &lt;/em&gt; &amp;rdquo;。 您可以通过将 &lt;code&gt;Exit Function&lt;/code&gt; 替换为 &lt;code&gt;Return Nothing&lt;/code&gt; 来取消警告，但这不能解决问题。 当 &lt;code&gt;someCondition = False&lt;/code&gt; 时，任何尝试使用返回值的东西都将导致NRE：</target>
        </trans-unit>
        <trans-unit id="0b561450c1d02029fb3ee4e5c3a3347ea45692b7" translate="yes" xml:space="preserve">
          <source>This is a fairly common way to get an NRE. In C#, depending on how it is coded, the IDE will report that &lt;code&gt;Controls&lt;/code&gt; does not exist in the current context, or &quot;cannot reference non-static member&quot;. So, to some extent, this is a VB-only situation. It is also complex because it can result in a failure cascade.</source>
          <target state="translated">这是获得NRE的相当普遍的方法。 在C＃中，根据其编码方式，IDE将报告 &lt;code&gt;Controls&lt;/code&gt; 在当前上下文中不存在，或&amp;ldquo;无法引用非静态成员&amp;rdquo;。 因此，在某种程度上，这是仅VB的情况。 它也很复杂，因为它可能导致失败的级联。</target>
        </trans-unit>
        <trans-unit id="187877ad8cb14ddcbabe75238a1bb7a9668c909a" translate="yes" xml:space="preserve">
          <source>This is also sometimes called the safe navigation or Elvis (after its shape) operator. If the expression on the left side of the operator is null, then the right side will not be evaluated, and null is returned instead. That means cases like this:</source>
          <target state="translated">这有时也被称为安全导航或Elvis(以其形状命名)算子。如果操作符左边的表达式为空,那么右边的表达式将不被执行,而是返回null。这意味着像这样的情况。</target>
        </trans-unit>
        <trans-unit id="aa9ada07655b54e9494b58d5ce6297b70d859bb3" translate="yes" xml:space="preserve">
          <source>This is concept-based: there is no code for you to paste into your project. It is intended to help you understand what causes a &lt;code&gt;NullReferenceException&lt;/code&gt; (NRE), how to find it, how to fix it, and how to avoid it. An NRE can be caused many ways so this is unlikely to be your sole encounter.</source>
          <target state="translated">这是基于概念的：没有代码可粘贴到项目中。 它旨在帮助您了解导致 &lt;code&gt;NullReferenceException&lt;/code&gt; （NRE）的原因，如何查找，如何修复它以及如何避免它。 NRE可以通过多种方式引起，因此这不太可能是您唯一遇到的问题。</target>
        </trans-unit>
        <trans-unit id="888280c788011247e567ae3ed361d10e659b622d" translate="yes" xml:space="preserve">
          <source>This is why you get a NullReferenceExeption because the computer does not have data stored in that variable.</source>
          <target state="translated">这就是为什么你会得到一个NullReferenceExeption,因为计算机没有在该变量中存储数据。</target>
        </trans-unit>
        <trans-unit id="21425312feec06d5937e5aa46a43ef71033a5a70" translate="yes" xml:space="preserve">
          <source>This line of code works best under your &lt;code&gt;Start()&lt;/code&gt; or &lt;code&gt;Awake()&lt;/code&gt; functions.</source>
          <target state="translated">此代码行在 &lt;code&gt;Start()&lt;/code&gt; 或 &lt;code&gt;Awake()&lt;/code&gt; 函数下效果最佳。</target>
        </trans-unit>
        <trans-unit id="dc1bf227c2a95d116418fc9c84ba8def88bc060c" translate="yes" xml:space="preserve">
          <source>This means the reference is &lt;code&gt;null&lt;/code&gt;, and you cannot access members (such as methods) through a &lt;code&gt;null&lt;/code&gt; reference. The simplest case:</source>
          <target state="translated">这意味着引用为 &lt;code&gt;null&lt;/code&gt; ，并且您无法通过 &lt;code&gt;null&lt;/code&gt; 引用访问成员（例如方法）。 最简单的情况：</target>
        </trans-unit>
        <trans-unit id="77e6e4ba966d107a04d5daf44a984b939a965789" translate="yes" xml:space="preserve">
          <source>This reduces the number of null checks you have to do in some cases. The syntax is to put a question mark before each dot. Take the following code for example:</source>
          <target state="translated">这样可以减少在某些情况下必须做的空校验的次数。语法是在每个点前加一个问号。以下面的代码为例。</target>
        </trans-unit>
        <trans-unit id="c0315d79171243f81b079786418630b61bc73573" translate="yes" xml:space="preserve">
          <source>This translates to</source>
          <target state="translated">这相当于</target>
        </trans-unit>
        <trans-unit id="bed843e1a4ee572be6dff42169c3a5deee5b21c5" translate="yes" xml:space="preserve">
          <source>This way, you can avoid &lt;code&gt;NullReferenceException&lt;/code&gt; cases that are results of violation of the constraints set. For example, if you use an object property &lt;code&gt;X&lt;/code&gt; in a class and later try to invoke one of its methods and &lt;code&gt;X&lt;/code&gt; has a null value, then this will lead to &lt;code&gt;NullReferenceException&lt;/code&gt;:</source>
          <target state="translated">这样，您可以避免由于违反约束集而导致的 &lt;code&gt;NullReferenceException&lt;/code&gt; 情况。 例如，如果您在类中使用对象属性 &lt;code&gt;X&lt;/code&gt; ，然后稍后尝试调用其方法之一，并且 &lt;code&gt;X&lt;/code&gt; 具有空值，则这将导致 &lt;code&gt;NullReferenceException&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ca62aa267e13467726859928ccd74cc220dd2bbb" translate="yes" xml:space="preserve">
          <source>This will create a &lt;em&gt;local&lt;/em&gt; variable, &lt;code&gt;reg&lt;/code&gt;, which exists only in that context (sub). The &lt;code&gt;reg&lt;/code&gt; variable with module level &lt;code&gt;Scope&lt;/code&gt; which you will use everywhere else remains &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">这将创建一个&lt;em&gt;局部&lt;/em&gt;变量 &lt;code&gt;reg&lt;/code&gt; ，该&lt;em&gt;局部&lt;/em&gt;变量仅在该上下文（子）中存在。 模块级别 &lt;code&gt;Scope&lt;/code&gt; 的 &lt;code&gt;reg&lt;/code&gt; 变量将保持不变。</target>
        </trans-unit>
        <trans-unit id="9886256ed1be06c975b72d5406cf9d7e42cde50b" translate="yes" xml:space="preserve">
          <source>This will do the following: If &lt;code&gt;myIntArray&lt;/code&gt; is null, the expression returns null and you can safely check it. If it contains an array, it will do the same as:
&lt;code&gt;elem = myIntArray[i];&lt;/code&gt; and returns the &lt;code&gt;i&amp;lt;sup&amp;gt;th&amp;lt;/sup&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">这将执行以下操作：如果 &lt;code&gt;myIntArray&lt;/code&gt; 为null，则表达式返回null，您可以安全地对其进行检查。 如果包含数组，则将执行以下操作： &lt;code&gt;elem = myIntArray[i];&lt;/code&gt; 并返回第 &lt;code&gt;i&amp;lt;sup&amp;gt;th&amp;lt;/sup&amp;gt;&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="1db062d19edd3aad36fceee9160e7c1852968c5e" translate="yes" xml:space="preserve">
          <source>This will result in the title variable being &lt;code&gt;null&lt;/code&gt;, and the call to &lt;code&gt;ToUpper&lt;/code&gt; is not made if &lt;code&gt;person.Title&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">这将导致title变量为 &lt;code&gt;null&lt;/code&gt; ，如果 &lt;code&gt;person.Title&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ,则不会调用 &lt;code&gt;ToUpper&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="037853ac976e876cd13f3318e4f680cf26902d26" translate="yes" xml:space="preserve">
          <source>This will throw a &lt;code&gt;NullReferenceException&lt;/code&gt; at the second line because you can't call the instance method &lt;code&gt;ToUpper()&lt;/code&gt; on a &lt;code&gt;string&lt;/code&gt; reference pointing to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">这将在第二行抛出 &lt;code&gt;NullReferenceException&lt;/code&gt; ，因为您不能在指向 &lt;code&gt;null&lt;/code&gt; 的 &lt;code&gt;string&lt;/code&gt; 引用上调用实例方法 &lt;code&gt;ToUpper()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4adf93e86d1600f5a1f1d298afde221268eccfe7" translate="yes" xml:space="preserve">
          <source>Though this check &lt;a href=&quot;https://stackoverflow.com/questions/3021538/debug-assert-appears-in-release-mode&quot;&gt;will not end up in your release build&lt;/a&gt;, causing it to throw the &lt;code&gt;NullReferenceException&lt;/code&gt; again when &lt;code&gt;book == null&lt;/code&gt; at runtime in release mode.</source>
          <target state="translated">尽管此检查&lt;a href=&quot;https://stackoverflow.com/questions/3021538/debug-assert-appears-in-release-mode&quot;&gt;将不会在您的发行版本中结束，&lt;/a&gt;但会导致在发行模式下运行时 &lt;code&gt;book == null&lt;/code&gt; 时再次引发 &lt;code&gt;NullReferenceException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe4569d04b34db2feeacd18b55f433f11ceeaa79" translate="yes" xml:space="preserve">
          <source>To avoid this error:</source>
          <target state="translated">为了避免这种错误。</target>
        </trans-unit>
        <trans-unit id="b862da83d643fa0302757d37468767ad8e9ac824" translate="yes" xml:space="preserve">
          <source>To be clear, &lt;code&gt;Dim&lt;/code&gt; (or &lt;code&gt;Private&lt;/code&gt;) only &lt;em&gt;declares&lt;/em&gt; a variable and its &lt;code&gt;Type&lt;/code&gt;.   The &lt;em&gt;Scope&lt;/em&gt; of the variable - whether it exists for the entire module/class or is local to a procedure - is determined by &lt;em&gt;where&lt;/em&gt; it is declared. &lt;code&gt;Private | Friend | Public&lt;/code&gt; defines the access level, not &lt;em&gt;Scope&lt;/em&gt;.</source>
          <target state="translated">需要明确的是， &lt;code&gt;Dim&lt;/code&gt; （或 &lt;code&gt;Private&lt;/code&gt; ）仅&lt;em&gt;声明&lt;/em&gt;一个变量及其 &lt;code&gt;Type&lt;/code&gt; 。 变量的&lt;em&gt;作用域&lt;/em&gt; -是否存在于整个模块/类中还是过程的局部性-由声明&lt;em&gt;位置&lt;/em&gt;确定。 &lt;code&gt;Private | Friend | Public&lt;/code&gt; 朋友| Public定义访问级别，而不是&lt;em&gt;Scope&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ccb716ef7518f5e4cae9d82dbbb0fdfc28ad185" translate="yes" xml:space="preserve">
          <source>To fix this you have to instantiate (assign object to reference of that class).</source>
          <target state="translated">为了解决这个问题,你必须实例化(将对象分配给该类的引用)。</target>
        </trans-unit>
        <trans-unit id="cfce5bc74512f792b40d3fd4bb577d39ad331d72" translate="yes" xml:space="preserve">
          <source>To fully understand why a NullReferenceException is thrown, it is important to know the difference between &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;value types&lt;/a&gt; and [reference types][3].</source>
          <target state="translated">要完全理解为什么会引发NullReferenceException，了解&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;值类型&lt;/a&gt;和[引用类型] [3]之间的区别非常重要。</target>
        </trans-unit>
        <trans-unit id="442fc389bbb8b0ecba07a137178cc20263b9b7c4" translate="yes" xml:space="preserve">
          <source>To prevent the error, objects that could be null should be tested for null before being used.</source>
          <target state="translated">为了防止错误,应该在使用前对可能为空的对象进行空的测试。</target>
        </trans-unit>
        <trans-unit id="2fc08c6abe8c008843158c3dfc2b4819d97175ce" translate="yes" xml:space="preserve">
          <source>To understand why that is, it helps to understand how .NET produces null dereference exceptions in the first place. (These details apply to .NET running on Windows; other operating systems use similar mechanisms.)</source>
          <target state="translated">为了理解为什么会出现这种情况,首先要了解.NET是如何产生null dereference异常的。(这些细节适用于在Windows上运行的.NET;其他操作系统使用类似的机制。)</target>
        </trans-unit>
        <trans-unit id="1c409f99322562874653d2f8a0ab2c648ed33f45" translate="yes" xml:space="preserve">
          <source>Typically, the &lt;code&gt;Settings&lt;/code&gt; collection will only need to be initialized the first time the application runs. An alternate remedy is to add an initial value to your collection in &lt;strong&gt;Project -&amp;gt; Settings | FooBars&lt;/strong&gt;, save the project, then remove the fake value.</source>
          <target state="translated">通常，仅在应用程序第一次运行时才需要初始化 &lt;code&gt;Settings&lt;/code&gt; 集合。 另一种解决方法是在&amp;ldquo; &lt;strong&gt;项目&amp;rdquo;-&amp;gt;&amp;ldquo;设置&amp;rdquo; |&amp;ldquo;设置&amp;rdquo;中&lt;/strong&gt;为您的集合添加初始值&lt;strong&gt;。&lt;/strong&gt; &lt;strong&gt;FooBars&lt;/strong&gt; ，保存项目，然后删除假值。</target>
        </trans-unit>
        <trans-unit id="516c8eebca6e87f940176b1effe4b60b6c0ea266" translate="yes" xml:space="preserve">
          <source>Typically, the simplest remedy is used.</source>
          <target state="translated">通常情况下,采用最简单的补救方法。</target>
        </trans-unit>
        <trans-unit id="44ae451f7b7bc5e89c459fa403f51f895a24e5e5" translate="yes" xml:space="preserve">
          <source>UI Controls</source>
          <target state="translated">UI控制</target>
        </trans-unit>
        <trans-unit id="0367a9753f91933f52263dc3499b7fad896e44c1" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, trying to use an item from &lt;code&gt;My.Settings&lt;/code&gt; which is a &lt;code&gt;StringCollection&lt;/code&gt; can result in a NullReference the first time you use it. The solution is the same, but not as obvious. Consider:</source>
          <target state="translated">在某些情况下，尝试使用 &lt;code&gt;My.Settings&lt;/code&gt; 中的一个 &lt;code&gt;StringCollection&lt;/code&gt; 项目可能会在您首次使用它时导致NullReference。 解决方案是相同的，但不是很明显。 考虑：</target>
        </trans-unit>
        <trans-unit id="5fd5faf037f6a68b87421df3d131d2dc06cf5ac5" translate="yes" xml:space="preserve">
          <source>Unhandled Exception:</source>
          <target state="translated">未处理的例外情况。</target>
        </trans-unit>
        <trans-unit id="13d1de28b167068f1cf58b6d8b42d1a864bfb7e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Debug.Assert&lt;/code&gt; if a value should never be &lt;code&gt;null&lt;/code&gt;, to catch the problem earlier than the exception occurs.</source>
          <target state="translated">如果值永远不能为 &lt;code&gt;null&lt;/code&gt; ，请使用 &lt;code&gt;Debug.Assert&lt;/code&gt; 来在出现异常之前更早地发现问题。</target>
        </trans-unit>
        <trans-unit id="382f02f764a14908cf7b8365adec70912d5701d9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;GetValueOrDefault()&lt;/code&gt; for &lt;code&gt;nullable&lt;/code&gt; value types to provide a default value when they are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;GetValueOrDefault()&lt;/code&gt; 用于 &lt;code&gt;nullable&lt;/code&gt; 值类型，以在它们为 &lt;code&gt;null&lt;/code&gt; 时提供默认值。</target>
        </trans-unit>
        <trans-unit id="2998b45c318d095c3e4535a7950d83516d58ebb7" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;For/Each&lt;/code&gt; loop and test the &lt;code&gt;IsNewRow&lt;/code&gt; property to determine if it is that last row. This works whether &lt;code&gt;AllowUserToAddRows&lt;/code&gt; is true or not:</source>
          <target state="translated">使用 &lt;code&gt;For/Each&lt;/code&gt; 循环并测试 &lt;code&gt;IsNewRow&lt;/code&gt; 属性以确定它是否是最后一行。 无论 &lt;code&gt;AllowUserToAddRows&lt;/code&gt; 为true，这都可以工作：</target>
        </trans-unit>
        <trans-unit id="1b21080b0c77e9baa935891138a35678155ae048" translate="yes" xml:space="preserve">
          <source>Use null context (available in C# 8):</source>
          <target state="translated">使用空上下文(在C#8中可用)。</target>
        </trans-unit>
        <trans-unit id="3c02b72e67d50c9e6e8df127d3c4c8b5ee96c2af" translate="yes" xml:space="preserve">
          <source>Use the null coalescing operator: &lt;code&gt;??&lt;/code&gt; [C#] or &lt;code&gt;If()&lt;/code&gt; [VB].</source>
          <target state="translated">使用空合并运算符： &lt;code&gt;??&lt;/code&gt; [C＃]或 &lt;code&gt;If()&lt;/code&gt; [VB]。</target>
        </trans-unit>
        <trans-unit id="eceb840fe473d205bb79bbfbe6842b028ab9de50" translate="yes" xml:space="preserve">
          <source>Use the null condition operator: &lt;code&gt;?.&lt;/code&gt; or &lt;code&gt;?[x]&lt;/code&gt; for arrays (available in C# 6 and VB.NET 14):</source>
          <target state="translated">使用空条件运算符： &lt;code&gt;?.&lt;/code&gt; 或 &lt;code&gt;?[x]&lt;/code&gt; 用于数组（在C＃6和VB.NET 14中可用）：</target>
        </trans-unit>
        <trans-unit id="e34781ddb98c0b7bad26d07124e848d7dc5380d0" translate="yes" xml:space="preserve">
          <source>User defined structs</source>
          <target state="translated">用户定义的结构</target>
        </trans-unit>
        <trans-unit id="4c9bf9d75e9c5172e3585c1c3082c6d25bacf2fa" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;List(Of T)&lt;/code&gt; will make it quite difficult to have an element without a valid object:</source>
          <target state="translated">使用 &lt;code&gt;List(Of T)&lt;/code&gt; 会使没有有效对象的元素变得非常困难：</target>
        </trans-unit>
        <trans-unit id="e0cf661777181bb5bf4bab3c932185766cf29b18" translate="yes" xml:space="preserve">
          <source>Validate data before using it (also use &lt;code&gt;Option Strict&lt;/code&gt; and SQL parameters):</source>
          <target state="translated">在使用之前验证数据（也使用 &lt;code&gt;Option Strict&lt;/code&gt; 和SQL参数）：</target>
        </trans-unit>
        <trans-unit id="3b3c5424e9429ade50d2ed4719daf8a5ef46e7c7" translate="yes" xml:space="preserve">
          <source>Value Types and Reference Types</source>
          <target state="translated">值类型和参考类型</target>
        </trans-unit>
        <trans-unit id="b7d9a51e2fb5186d4548644a10a85dfb83b90aff" translate="yes" xml:space="preserve">
          <source>Visual Basic Forms</source>
          <target state="translated">Visual Basic表格</target>
        </trans-unit>
        <trans-unit id="914f780030704154b3755eefa6c85d3acdf3b1c7" translate="yes" xml:space="preserve">
          <source>Visual Basic tries to make the process clear repeatedly using &lt;strong&gt;&lt;code&gt;New&lt;/code&gt;&lt;/strong&gt;: Using the &lt;strong&gt;&lt;code&gt;New&lt;/code&gt;&lt;/strong&gt; Operator creates a &lt;strong&gt;new&lt;/strong&gt; object and calls &lt;strong&gt;&lt;code&gt;Sub New&lt;/code&gt;&lt;/strong&gt; -- the constructor -- where your object can perform any other initialization.</source>
          <target state="translated">Visual Basic尝试使用&lt;strong&gt; &lt;code&gt;New&lt;/code&gt; &lt;/strong&gt;反复使过程更清晰：使用&lt;strong&gt; &lt;code&gt;New&lt;/code&gt; &lt;/strong&gt; Operator创建一个&lt;strong&gt;新&lt;/strong&gt;对象并调用&lt;strong&gt; &lt;code&gt;Sub New&lt;/code&gt; &lt;/strong&gt; （构造函数），您的对象可以在其中执行任何其他初始化。</target>
        </trans-unit>
        <trans-unit id="4356f5b2bed387a822b4773e00b955c30fb15382" translate="yes" xml:space="preserve">
          <source>WPF Control Creation Order and Events</source>
          <target state="translated">WPF控件创建顺序和事件</target>
        </trans-unit>
        <trans-unit id="865749e3cc387179c321ac3469aa809ca6ea641d" translate="yes" xml:space="preserve">
          <source>Ways to Avoid</source>
          <target state="translated">避免的方法</target>
        </trans-unit>
        <trans-unit id="b50ff997c836b3bf135585b592d9922fb8daa6c5" translate="yes" xml:space="preserve">
          <source>We can add data really easily actually in a few ways:</source>
          <target state="translated">实际上,我们可以通过以下几种方式来增加数据。</target>
        </trans-unit>
        <trans-unit id="171db29c0e9a7d26b4e0c78fa029495735b943f5" translate="yes" xml:space="preserve">
          <source>Well, in simple terms:</source>
          <target state="translated">那么,简单来说。</target>
        </trans-unit>
        <trans-unit id="54f0454febe335028ebb7ac67e60ee8639c8bb01" translate="yes" xml:space="preserve">
          <source>What about the second point? Dereferencing &lt;em&gt;any&lt;/em&gt; invalid pointer that falls in the lowest page of virtual memory causes the same operating system error, and thereby the same exception.</source>
          <target state="translated">那第二点呢？ 取消引用落在虚拟内存最低页中的&lt;em&gt;任何&lt;/em&gt;无效指针会导致相同的操作系统错误，从而导致相同的异常。</target>
        </trans-unit>
        <trans-unit id="a57d36dd7547d0d01d63f5a0dca33743ac6b0190" translate="yes" xml:space="preserve">
          <source>What does that mean?</source>
          <target state="translated">那是什么意思?</target>
        </trans-unit>
        <trans-unit id="dfc9e4324fb08b6a8f17d724cf8c6155af43dd1b" translate="yes" xml:space="preserve">
          <source>What does this mean, and what can I do to fix this error?</source>
          <target state="translated">这意味着什么,我该怎么做才能解决这个错误?</target>
        </trans-unit>
        <trans-unit id="682501e35814b10bb49bcce3a8138d93e7237565" translate="yes" xml:space="preserve">
          <source>What is a NullReferenceException, and how do I fix it</source>
          <target state="translated">什么是NullReferenceException,如何修复它?</target>
        </trans-unit>
        <trans-unit id="2b175120120a58af183c09ae1970097e643335ca" translate="yes" xml:space="preserve">
          <source>What is the cause?</source>
          <target state="translated">是什么原因造成的?</target>
        </trans-unit>
        <trans-unit id="4d05bb2729110f107617bc429ecb0bc63e601752" translate="yes" xml:space="preserve">
          <source>When a property of a null object accessed:</source>
          <target state="translated">当访问一个空对象的属性时。</target>
        </trans-unit>
        <trans-unit id="24ee47a5b48927d93ac97774fc77bc2a3836d6a2" translate="yes" xml:space="preserve">
          <source>When a string method of an empty string accessed:</source>
          <target state="translated">当访问一个空字符串方法的字符串时。</target>
        </trans-unit>
        <trans-unit id="0d8ca3f12ffd0492f759832995654e7110254f83" translate="yes" xml:space="preserve">
          <source>When declared as a module/class level variable, as appears to be the case with &lt;code&gt;con&lt;/code&gt;, the compiler can't know if the object was created by an upstream procedure. Do not ignore warnings.</source>
          <target state="translated">当声明为模块/类级别的变量（如 &lt;code&gt;con&lt;/code&gt; 的情况）时，编译器无法知道该对象是否由上游过程创建。 不要忽略警告。</target>
        </trans-unit>
        <trans-unit id="efc21187e8ea71d0502b9553436531ff09010739" translate="yes" xml:space="preserve">
          <source>When it is only appropriate to create the instance later:</source>
          <target state="translated">当它只适合于以后创建实例时。</target>
        </trans-unit>
        <trans-unit id="e320e6e3ad0e90936d129472db697d3b8b8d6e80" translate="yes" xml:space="preserve">
          <source>When working &lt;strong&gt;across different layers&lt;/strong&gt;, for example in an MVC application, a controller needs services to call business operations. In such scenarios &lt;strong&gt;Dependency Injection Container&lt;/strong&gt; can be used to initialize the services to avoid the &lt;strong&gt;NullReferenceException&lt;/strong&gt;. So that means you don't need to worry about checking for null and just call the services from the controller as though they will always to available (and initialized) as either a singleton or a prototype.</source>
          <target state="translated">当&lt;strong&gt;跨不同的层&lt;/strong&gt;工作时（例如在MVC应用程序中），控制器需要服务来调用业务操作。 在这种情况下，可以使用&lt;strong&gt;依赖项注入容器&lt;/strong&gt;来初始化服务以避免&lt;strong&gt;NullReferenceException&lt;/strong&gt; 。 因此，这意味着您不必担心检查null并只需从控制器调用服务，就好像它们将始终作为单例或原型可用（并初始化）一样。</target>
        </trans-unit>
        <trans-unit id="dba90f1005ef6b9743a2d890263f4e1876834da6" translate="yes" xml:space="preserve">
          <source>When you know during development that a method maybe can, but never should return &lt;code&gt;null&lt;/code&gt;, you can use &lt;code&gt;Debug.Assert()&lt;/code&gt; to break as soon as possible when it does occur:</source>
          <target state="translated">当您在开发过程中知道某个方法可以但不能返回 &lt;code&gt;null&lt;/code&gt; 时 ，可以使用 &lt;code&gt;Debug.Assert()&lt;/code&gt; 使其在出现时尽快中断：</target>
        </trans-unit>
        <trans-unit id="1492aaa2d900e272a66ec2ee7932c7c567523b15" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;DataGridView&lt;/code&gt; has &lt;code&gt;AllowUserToAddRows&lt;/code&gt; as &lt;code&gt;True&lt;/code&gt; (the default), the &lt;code&gt;Cells&lt;/code&gt; in the blank/new row at the bottom will all contain &lt;code&gt;Nothing&lt;/code&gt;.  Most attempts to use the contents (for example, &lt;code&gt;ToString&lt;/code&gt;) will result in an NRE.</source>
          <target state="translated">当您的 &lt;code&gt;DataGridView&lt;/code&gt; 的 &lt;code&gt;AllowUserToAddRows&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; （默认值）时，底部空白/新行中的 &lt;code&gt;Cells&lt;/code&gt; 都将包含 &lt;code&gt;Nothing&lt;/code&gt; 。 大多数尝试使用内容的尝试（例如 &lt;code&gt;ToString&lt;/code&gt; ）将导致NRE。</target>
        </trans-unit>
        <trans-unit id="cdb948906225c5be7dabe665fe3268f2aa7f7d1b" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;what&lt;/em&gt; causes a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;NullReferenceExceptions&lt;/a&gt; and approaches to &lt;em&gt;avoid/fix&lt;/em&gt; such an exception have been addressed in other answers, what many programmers haven't learned yet is how to independently &lt;em&gt;debug&lt;/em&gt; such exceptions during development.</source>
          <target state="translated">虽然导致&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.nullreferenceexception(v=vs.110).aspx&quot;&gt;NullReferenceExceptions的&lt;/a&gt;原因以及&lt;em&gt;避免/修复&lt;/em&gt;此类异常的方法已在其他答案中得到了解决，但是许多程序员尚未了解的是如何在开发过程中独立&lt;em&gt;调试&lt;/em&gt;此类异常。</target>
        </trans-unit>
        <trans-unit id="448dc745cee8454cb3051219a2b24ea7029e0795" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;new&lt;/code&gt; keyword is used, it only creates a new instance of &lt;code&gt;Book&lt;/code&gt;, but not a new instance of &lt;code&gt;Person&lt;/code&gt;, so the &lt;code&gt;Author&lt;/code&gt; the property is still &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;new&lt;/code&gt; 关键字时，它仅创建 &lt;code&gt;Book&lt;/code&gt; 的新实例，而不创建 &lt;code&gt;Person&lt;/code&gt; 的新实例，因此 &lt;code&gt;Author&lt;/code&gt; 属性仍然为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d52f9ee0d5e0aa5f23d1b3b5d8e4d2e56fca0930" translate="yes" xml:space="preserve">
          <source>Why does this make sense?  Well, suppose we have a struct containing two ints, and an unmanaged pointer equal to null. If we attempt to dereference the second int in the struct, the &lt;code&gt;CLR&lt;/code&gt; will not attempt to access the storage at location zero; it will access the storage at location four. But logically this is a null dereference because we are getting to that address &lt;em&gt;via&lt;/em&gt; the null.</source>
          <target state="translated">为什么这有意义？ 好吧，假设我们有一个包含两个int的结构，以及一个等于null的非托管指针。 如果我们尝试取消引用结构中的第二个int， &lt;code&gt;CLR&lt;/code&gt; 将不会尝试访问零位置的存储； 它将访问第四位置的存储。 但是从逻辑上讲，这是一个空取消引用，因为我们要&lt;em&gt;通过&lt;/em&gt;空到达该地址。</target>
        </trans-unit>
        <trans-unit id="e5b3e5b5a3ce438cfd892d68ca821da56bd33f46" translate="yes" xml:space="preserve">
          <source>Why is this wrong?  Because the iterator block does not actually &lt;em&gt;run&lt;/em&gt; until the &lt;code&gt;foreach&lt;/code&gt;!  The call to &lt;code&gt;GetFrobs&lt;/code&gt; simply returns an object which &lt;em&gt;when iterated&lt;/em&gt; will run the iterator block.</source>
          <target state="translated">为什么会这样呢？ 因为迭代器块直到 &lt;code&gt;foreach&lt;/code&gt; 才实际&lt;em&gt;运行&lt;/em&gt; ！ 对 &lt;code&gt;GetFrobs&lt;/code&gt; 的调用仅返回一个对象，该对象&lt;em&gt;在进行迭代时&lt;/em&gt;将运行迭代器块。</target>
        </trans-unit>
        <trans-unit id="dd8f068ecfc9cc04c00494e69ae5f6e0960b7ae7" translate="yes" xml:space="preserve">
          <source>Why it occurs?</source>
          <target state="translated">为什么会出现这种情况?</target>
        </trans-unit>
        <trans-unit id="cce1faca008b524ebe3411e4a56c2cb194dc1b42" translate="yes" xml:space="preserve">
          <source>Working with databases presents many opportunities for a NullReference because there can be many objects (&lt;code&gt;Command&lt;/code&gt;, &lt;code&gt;Connection&lt;/code&gt;, &lt;code&gt;Transaction&lt;/code&gt;, &lt;code&gt;Dataset&lt;/code&gt;, &lt;code&gt;DataTable&lt;/code&gt;, &lt;code&gt;DataRows&lt;/code&gt;....) in use at once.  &lt;strong&gt;Note:&lt;/strong&gt; It does not matter which data provider you are using -- MySQL, SQL Server, OleDB, etc. -- the &lt;em&gt;concepts&lt;/em&gt; are the same.</source>
          <target state="translated">使用数据库为NullReference提供了很多机会，因为可以同时使用许多对象（ &lt;code&gt;Command&lt;/code&gt; ， &lt;code&gt;Connection&lt;/code&gt; ， &lt;code&gt;Transaction&lt;/code&gt; ， &lt;code&gt;Dataset&lt;/code&gt; ， &lt;code&gt;DataTable&lt;/code&gt; ， &lt;code&gt;DataRows&lt;/code&gt; ....）。 &lt;strong&gt;注意：&lt;/strong&gt;使用哪个数据提供程序（MySQL，SQL Server，OleDB等）无关紧要， &lt;em&gt;概念&lt;/em&gt;是相同的。</target>
        </trans-unit>
        <trans-unit id="723856ede778551d9c785472d51c2f7fcbb54d7d" translate="yes" xml:space="preserve">
          <source>You are trying to access an object that isn't created or currently not in memory.</source>
          <target state="translated">您正在尝试访问一个未创建或当前不在内存中的对象。</target>
        </trans-unit>
        <trans-unit id="8aa880592f3584b0eb7955f587d23cf9a9b8e76b" translate="yes" xml:space="preserve">
          <source>You are trying to use a reference variable whose value is &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;.  When the value is &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; for the reference variable, that means it is not actually holding a reference to an instance of any object that exists on the heap.</source>
          <target state="translated">您正在尝试使用值为 &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; 的引用变量。 当引用变量的值为 &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; 时 ，这意味着它实际上并不持有对堆上存在的任何对象的实例的引用。</target>
        </trans-unit>
        <trans-unit id="4b4d5b042ee1470a88bab9f1d60f9144e6f609fc" translate="yes" xml:space="preserve">
          <source>You are trying to use something that is &lt;code&gt;null&lt;/code&gt; (or &lt;code&gt;Nothing&lt;/code&gt; in VB.NET). This means you either set it to &lt;code&gt;null&lt;/code&gt;, or you never set it to anything at all.</source>
          <target state="translated">您正在尝试使用 &lt;code&gt;null&lt;/code&gt; （或VB.NET中为 &lt;code&gt;Nothing&lt;/code&gt; ）。 这意味着您要么将其设置为 &lt;code&gt;null&lt;/code&gt; ，要么根本不将其设置为任何东西。</target>
        </trans-unit>
        <trans-unit id="a4b2a4f8cb9ff198b895cb45c6d69095f67060ba" translate="yes" xml:space="preserve">
          <source>You are using the object that contains the null value reference. So it's giving a null exception. In the example the string value is null and when checking its length, the exception occurred.</source>
          <target state="translated">你使用的是包含空值引用的对象。所以它给出了一个null异常。在这个例子中,字符串的值是null,当检查它的长度时,出现了异常。</target>
        </trans-unit>
        <trans-unit id="c6e71d37b17fa53433b0f7d95131ec2c8f8e5dcd" translate="yes" xml:space="preserve">
          <source>You can add a component programmatically and assign the variable at the same time with one line of code: &lt;code&gt;rb = AddComponent&amp;lt;RigidBody&amp;gt;();&lt;/code&gt;</source>
          <target state="translated">您可以通过编程添加组件，并使用一行代码同时分配变量： &lt;code&gt;rb = AddComponent&amp;lt;RigidBody&amp;gt;();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c38e20677037c680c41cdbbd3a874a5b75b4783" translate="yes" xml:space="preserve">
          <source>You can also throw a custom exception, only to catch it in the calling code:</source>
          <target state="translated">你也可以抛出一个自定义异常,只是在调用代码中捕捉到它。</target>
        </trans-unit>
        <trans-unit id="17ea64ffa695b740770485aaba63974913381c9a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;Locals Window&lt;/code&gt; (&lt;strong&gt;Debug -&amp;gt; Windows -&amp;gt; Locals&lt;/strong&gt;) to examine your objects.</source>
          <target state="translated">您还可以使用 &lt;code&gt;Locals Window&lt;/code&gt; （ &lt;strong&gt;Debug-&amp;gt;&lt;/strong&gt; Windows- &lt;strong&gt;&amp;gt; Locals&lt;/strong&gt; ）检查对象。</target>
        </trans-unit>
        <trans-unit id="12a1a3c92ffa52e6b050bf7546290b5e6ce658b2" translate="yes" xml:space="preserve">
          <source>You can fix NullReferenceException in a clean way using Null-conditional Operators in c#6 and write less code to handle null checks.</source>
          <target state="translated">你可以使用c#6中的Null-条件运算符来干净利落地修复NullReferenceException,并且可以写更少的代码来处理null检查。</target>
        </trans-unit>
        <trans-unit id="2edd59e412b940b382162755da24e3b3a55a1a98" translate="yes" xml:space="preserve">
          <source>You can simply avoid this by checking if the variable is not null:</source>
          <target state="translated">你可以简单地通过检查变量是否为空来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="d1588e2df3c8e2e5e50543e8a09e318c3ac852eb" translate="yes" xml:space="preserve">
          <source>You either never assigned something to the variable, never created an instance of the value assigned to the variable, or you set the variable equal to &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; manually, or you called a function that set the variable to &lt;code&gt;Nothing&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt; for you.</source>
          <target state="translated">您要么从未为变量分配任何东西，从未创建分配给该变量的值的实例，要么手动将变量设置为 &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; ，或者调用了一个为您将变量设置为 &lt;code&gt;Nothing&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="f66228601ed3724d69b717ec6fe23f27ca71e042" translate="yes" xml:space="preserve">
          <source>You get the same exception for the same reason - &lt;code&gt;myList&lt;/code&gt; was only declared, but no instance created. The remedy is the same:</source>
          <target state="translated">由于相同的原因，您将获得相同的异常-仅声明了 &lt;code&gt;myList&lt;/code&gt; ，但未创建任何实例。 补救措施是相同的：</target>
        </trans-unit>
        <trans-unit id="7d96029677307b05bf0beda9a46b585a9c96a9a3" translate="yes" xml:space="preserve">
          <source>You probably forgot the &lt;code&gt;New&lt;/code&gt; operator.</source>
          <target state="translated">您可能忘记了 &lt;code&gt;New&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="9889cfa340b5a188c4545454aa3970b650ff6a92" translate="yes" xml:space="preserve">
          <source>You should also remove any Try/Catch blocks from the relevant code, especially ones where there is nothing in the Catch block. This will cause your code to crash when it tries to use an object which is &lt;code&gt;Nothing&lt;/code&gt;. &lt;strong&gt;This is what you want&lt;/strong&gt; because it will identify the exact &lt;em&gt;location&lt;/em&gt; of the problem, and allow you to identify the object causing it.</source>
          <target state="translated">您还应该从相关代码中删除任何Try / Catch块，尤其是在Catch块中没有任何内容的地方。 当它尝试使用 &lt;code&gt;Nothing&lt;/code&gt; 对象时，这将导致您的代码崩溃。 &lt;strong&gt;这就是您想要的，&lt;/strong&gt;因为它将识别出问题的确切&lt;em&gt;位置&lt;/em&gt; ，并允许您识别导致问题的对象。</target>
        </trans-unit>
        <trans-unit id="7cf85e9877af0174191657bf941763d81f747650" translate="yes" xml:space="preserve">
          <source>You would use very similar to the same way you would use &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, except with the goal of accomplishing exactly the opposite - to not allow &lt;code&gt;null&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">您将使用与 &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; 相同的方法，除了以完全相反的目的为目标-不允许 &lt;code&gt;null&lt;/code&gt; 。 这里有些例子：</target>
        </trans-unit>
        <trans-unit id="1cc0e4045b9e917b4e600760083043c55ca6aa29" translate="yes" xml:space="preserve">
          <source>Your code &lt;em&gt;declared&lt;/em&gt; an object variable, but it did not &lt;em&gt;initialize&lt;/em&gt; it (create an instance or '&lt;em&gt;instantiate&lt;/em&gt;' it)</source>
          <target state="translated">您的代码&lt;em&gt;声明&lt;/em&gt;了一个对象变量，但没有&lt;em&gt;初始化&lt;/em&gt;它（创建实例或&amp;ldquo; &lt;em&gt;实例化&lt;/em&gt; &amp;rdquo;它）</target>
        </trans-unit>
        <trans-unit id="1835adb6d4755dbbf56a8c76ede96fd8258bbc9c" translate="yes" xml:space="preserve">
          <source>above line throws error because reference of class myClass is declared but not instantiated or an instance of object is not assigned to referecne of that class.</source>
          <target state="translated">上面这行抛出错误,因为类myClass的引用被声明但没有实例化,或者对象的实例没有被分配到该类的引用。</target>
        </trans-unit>
        <trans-unit id="163efa6e9cc8a00507230d1f61d9db3d11ab97db" translate="yes" xml:space="preserve">
          <source>and Contact entity class. Sometimes entity classes are partial classes so that you can extend them in other files too.</source>
          <target state="translated">和联系实体类。有时实体类是部分类,这样你也可以在其他文件中进行扩展。</target>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="45932d6fa98f39c5cd3f08cd951d8dc70fc5f7de" translate="yes" xml:space="preserve">
          <source>decimal</source>
          <target state="translated">decimal</target>
        </trans-unit>
        <trans-unit id="f7852992c275998df7dbb34bd4a576549f4622aa" translate="yes" xml:space="preserve">
          <source>dereferencing a null &lt;strong&gt;pointer&lt;/strong&gt; produces the same exception as dereferencing a null &lt;strong&gt;reference&lt;/strong&gt;</source>
          <target state="translated">取消引用空&lt;strong&gt;指针&lt;/strong&gt;会产生与取消引用空&lt;strong&gt;引用&lt;/strong&gt;相同的异常</target>
        </trans-unit>
        <trans-unit id="7b2e6f52aa2a81fb92f818a3436c6758ad33c8a3" translate="yes" xml:space="preserve">
          <source>dereferencing an invalid non-null pointer &lt;strong&gt;can&lt;/strong&gt; produce that exception
in some circumstances</source>
          <target state="translated">在某些情况下，取消引用无效的非null指针&lt;strong&gt;可能会&lt;/strong&gt;产生该异常</target>
        </trans-unit>
        <trans-unit id="b5031a46dd38e909839b52a146a7969402061271" translate="yes" xml:space="preserve">
          <source>disable: The nullable annotation context is disabled. The nullable warning context is disabled. Variables of a reference type are oblivious, just like earlier versions of C#. All nullability warnings are disabled.</source>
          <target state="translated">disable。nullable注释上下文被禁用。nullable警告上下文被禁用。引用类型的变量被遗忘,就像C#的早期版本一样。所有nullable警告都被禁用。</target>
        </trans-unit>
        <trans-unit id="5452220584f9d82eacc9d4b64b556c642aa95fe3" translate="yes" xml:space="preserve">
          <source>dynamic</source>
          <target state="translated">dynamic</target>
        </trans-unit>
        <trans-unit id="707ee2e80d8a348ed040077b064ae8b11ce87533" translate="yes" xml:space="preserve">
          <source>enable: The nullable annotation context is enabled. The nullable warning context is enabled. Variables of a reference type, string for example, are non-nullable. All nullability warnings are enabled.</source>
          <target state="translated">启用。启用了可注解上下文。nullable警告上下文被启用。例如,引用类型的变量,例如字符串,是不可空的。所有的nullable警告都被启用。</target>
        </trans-unit>
        <trans-unit id="f93306a0064ddaa9f3c518dfda6d24b1659b5141" translate="yes" xml:space="preserve">
          <source>for example: let say you have a class called myClass and it contains one property prop1.</source>
          <target state="translated">例如:假设你有一个类叫myClass,它包含一个属性prop1。</target>
        </trans-unit>
        <trans-unit id="4d3e8614703ea126434cc11d59e3c7a70c66d624" translate="yes" xml:space="preserve">
          <source>foreach</source>
          <target state="translated">foreach</target>
        </trans-unit>
        <trans-unit id="23ec53a4c09cf5266253f2e3ee5c91b8b4eb9045" translate="yes" xml:space="preserve">
          <source>in here , if address is null , then you will get NullReferenceException.</source>
          <target state="translated">在这里,如果地址为空,那么你会得到NullReferenceException。</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1d02abd73c8fc5445c71c4fbe24bc25707ea3d7a" translate="yes" xml:space="preserve">
          <source>public class Form1
{
    private Customer customer;</source>
          <target state="translated">public class Form1{private Customer customer;</target>
        </trans-unit>
        <trans-unit id="c133b31de2d5fc69bf6862d425df4a2337f78d3d" translate="yes" xml:space="preserve">
          <source>safeonly: The nullable annotation context is enabled. The nullable warning context is safeonly. Variables of a reference type are nonnullable. All safety nullability warnings are enabled.</source>
          <target state="translated">safeonly。nullable注释上下文已启用。nullable警告上下文是 safeonly。引用类型的变量是不可空的。所有安全nullable警告都是启用的。</target>
        </trans-unit>
        <trans-unit id="3a061cb7a56d7292f241332c224fcac2f287af0a" translate="yes" xml:space="preserve">
          <source>safeonlywarnings: The nullable annotation context is disabled. The nullable warning context is safeonly.
    Variables of a reference type are oblivious. All safety nullability warnings are enabled.</source>
          <target state="translated">safeonlywarnings。nullable注解上下文被禁用。nullable警告上下文为safeonly。引用类型的变量被遗忘。所有的安全nullable警告都被启用。</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="2abda58ce57dab947ad0b74eb5487833707a6213" translate="yes" xml:space="preserve">
          <source>the following code will be problematic:</source>
          <target state="translated">下面的代码会有问题:</target>
        </trans-unit>
        <trans-unit id="43a38bb2effe5dc812d40a39ec117e6b0fd8f1fc" translate="yes" xml:space="preserve">
          <source>warnings: The nullable annotation context is disabled. The nullable warning context is enabled. Variables of a reference type are oblivious. All nullability warnings are enabled.</source>
          <target state="translated">警告。nullable注释上下文被禁用。nullable警告上下文被启用。引用类型的变量被遗忘。所有nullable警告都被启用。</target>
        </trans-unit>
        <trans-unit id="365054ee499f3b2258d3a22f7fa3f931704bc717" translate="yes" xml:space="preserve">
          <source>where an &lt;strong&gt;&lt;em&gt;unboxing&lt;/em&gt;&lt;/strong&gt; conversion (cast) &lt;em&gt;from&lt;/em&gt;&lt;code&gt;object&lt;/code&gt; (or from one of the classes &lt;code&gt;System.ValueType&lt;/code&gt; or &lt;code&gt;System.Enum&lt;/code&gt;, or from an interface type) &lt;em&gt;to&lt;/em&gt; a value type (other than &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt;) in itself gives the &lt;code&gt;NullReferenceException&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;从&lt;/em&gt; &lt;code&gt;object&lt;/code&gt; （或从类 &lt;code&gt;System.ValueType&lt;/code&gt; 或 &lt;code&gt;System.Enum&lt;/code&gt; 或从接口类型） &lt;em&gt;到&lt;/em&gt;值类型（除 &lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt; ）的&lt;strong&gt;&lt;em&gt;拆箱&lt;/em&gt;&lt;/strong&gt;转换（ 广播 ）本身给出 &lt;code&gt;NullReferenceException&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
