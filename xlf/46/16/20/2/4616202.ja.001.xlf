<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/4616202">
    <body>
      <group id="4616202">
        <trans-unit id="c4ac02843782bba091676b91d711e2e91dcffe31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;there are better answers above too&lt;/em&gt;. This is how I modified example code you questioned with.</source>
          <target state="translated">&lt;em&gt;上記にも良い答えがあります&lt;/em&gt; 。 これは、質問したサンプルコードを変更した方法です。</target>
        </trans-unit>
        <trans-unit id="957d9136a0bdfeebdb55a85be13d86097ee866f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This solution uses Typescript (you can use the vanilla JS which TS compiles to if needed)</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このソリューションはTypescriptを使用します（必要に応じてTSがコンパイルするバニラJSを使用できます）</target>
        </trans-unit>
        <trans-unit id="f4fff8192428d6c6716c07b07726101f6544fe3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Self-executing anonymous functions and window storage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;自己実行型の無名関数とウィンドウストレージ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4b2dbb7dd3fe023446263ea126c7b75aa47f762" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68eac555eb871081828454cb1b939d4ad2032682" translate="yes" xml:space="preserve">
          <source>All others are just more indirect ways to do the same thing. (Felix's is particularly clever, but requires creating and destroying a temporary function, adding complexity; and either leaves an extra property on the object or [if you &lt;code&gt;delete&lt;/code&gt; that property] &lt;a href=&quot;http://jsperf.com/test-dictionary-mode&quot;&gt;impacts the performance&lt;/a&gt; of subsequent property accesses on that object.)</source>
          <target state="translated">他のすべては同じことをするためのより間接的な方法です。 （Felixは特に賢いですが、一時的な関数を作成して破棄する必要があり、複雑さが増します。さらに、オブジェクトに追加のプロパティを残すか、[そのプロパティを &lt;code&gt;delete&lt;/code&gt; した場合]そのオブジェクトに対する後続のプロパティアクセスの&lt;a href=&quot;http://jsperf.com/test-dictionary-mode&quot;&gt;パフォーマンス&lt;/a&gt;に影響します。）</target>
        </trans-unit>
        <trans-unit id="8eadcb7bea9b4f30141e679e78d203b6fa90cce5" translate="yes" xml:space="preserve">
          <source>All the variables declared within &lt;code&gt;foo&lt;/code&gt; are private to &lt;code&gt;foo&lt;/code&gt;, as you would expect with any function declaration and because they are all in scope, they all have access to each other without needing to refer to &lt;code&gt;this&lt;/code&gt;, just as you would expect with a function.  The difference is that this function returns an object that exposes the private variables and assigns that object to &lt;code&gt;foo&lt;/code&gt;.  In the end, you return just the interface you want to expose as an object with the &lt;code&gt;return {}&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 内で宣言されたすべての変数はfooに対してプライベートです。これは、関数宣言で期待されるとおりです。これらはすべてスコープ内にあるため、関数で期待されるように、これらはすべて &lt;code&gt;this&lt;/code&gt; を参照する必要なく互いにアクセスできます。 違いは、この関数はプライベート変数を公開するオブジェクトを返し、そのオブジェクトを &lt;code&gt;foo&lt;/code&gt; に割り当てることです。 最後に、 &lt;code&gt;return {}&lt;/code&gt; ステートメントを使用して、オブジェクトとして公開するインターフェースだけを返します。</target>
        </trans-unit>
        <trans-unit id="26bb25d9ee5a7962277df483adabebc634b91c8b" translate="yes" xml:space="preserve">
          <source>And it's dry, of course.</source>
          <target state="translated">もちろん乾燥していますしね。</target>
        </trans-unit>
        <trans-unit id="7e1638d3363efdfbe5466eef1db2d2342c31fe3e" translate="yes" xml:space="preserve">
          <source>Another example</source>
          <target state="translated">別の例</target>
        </trans-unit>
        <trans-unit id="ddc284d45ee7ece33b36b3bd1ddb1cd16897bcff" translate="yes" xml:space="preserve">
          <source>Best for &lt;code&gt;config.js&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;config.js&lt;/code&gt; ファイルに最適です。</target>
        </trans-unit>
        <trans-unit id="1e3b1293f28df07e10be54f376ce6236b7fcd0ec" translate="yes" xml:space="preserve">
          <source>But &lt;em&gt;is&lt;/em&gt; there any way to have values in an object literal's properties depend on other properties declared earlier?</source>
          <target state="translated">しかし、オブジェクトリテラルのプロパティの値を、以前に宣言された他のプロパティに依存させる方法&lt;em&gt;は&lt;/em&gt;ありますか？</target>
        </trans-unit>
        <trans-unit id="c980d41b522ee4202df0d52d4e10fa0ce7545909" translate="yes" xml:space="preserve">
          <source>But if you'd prefer to write self-referencing objects like:</source>
          <target state="translated">でも、自己参照オブジェクトのようなものを書きたいのであれば</target>
        </trans-unit>
        <trans-unit id="f7b06add61246d536572b2eae6171784eb4c2ba5" translate="yes" xml:space="preserve">
          <source>By defining self as the object that contains the print function you allow the function to refer to that object. This means you will not have to 'bind' the print function to an object if you need to pass it somewhere else.</source>
          <target state="translated">print関数を含むオブジェクトとしてselfを定義することで、関数がそのオブジェクトを参照できるようになります。これは、print関数をどこか他の場所に渡す必要がある場合に、オブジェクトに「バインド」する必要がないことを意味します。</target>
        </trans-unit>
        <trans-unit id="dd3ec02519ed2fea89ddf00600cbc98ce08963cc" translate="yes" xml:space="preserve">
          <source>By using the self method you guarantee that print will always return the same object regardless of the context in which the function is ran. The code above will run just fine and log 0, 1, 2 and 3 when using the self version of &lt;code&gt;createMyObject()&lt;/code&gt;.</source>
          <target state="translated">selfメソッドを使用することにより、関数が実行されるコンテキストに関係なく、printが常に同じオブジェクトを返すことを保証します。 上記のコードは問題なく実行され、 &lt;code&gt;createMyObject()&lt;/code&gt; のセルフバージョンを使用すると0、1、2、3が記録されます。</target>
        </trans-unit>
        <trans-unit id="fb26bf00b13f18b06c15beeaa5f7dbab1d453031" translate="yes" xml:space="preserve">
          <source>Compare the following</source>
          <target state="translated">以下を比較してみてください。</target>
        </trans-unit>
        <trans-unit id="50bf2c5b2bbbe0ff5a2a3490ab713dd2cf025fb2" translate="yes" xml:space="preserve">
          <source>Creating new function on your object literal and invoking a constructor seems a radical departure from the original problem, and it's unnecessary.</source>
          <target state="translated">オブジェクトリテラルに新しい関数を作成してコンストラクタを呼び出すことは、本来の問題から根本的に逸脱しているように思えますし、必要ありません。</target>
        </trans-unit>
        <trans-unit id="455b7b22e4988bee5bcac315f59a6ea4faa1b993" translate="yes" xml:space="preserve">
          <source>Doesn't require any type of &lt;code&gt;init()&lt;/code&gt; or code outside of the object literal</source>
          <target state="translated">オブジェクトリテラルの外部にあるタイプの &lt;code&gt;init()&lt;/code&gt; またはコードを必要としません</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="cdb0cba21e450ddf5b06bdddae32351284fc26bf" translate="yes" xml:space="preserve">
          <source>For completion, in ES6 we've got classes (supported at the time of writing this only by latest browsers, but available in Babel, TypeScript and other transpilers)</source>
          <target state="translated">補完のために、ES6にはクラスがあります(これを書いている時点では最新のブラウザでしかサポートされていませんが、BabelやTypeScript、その他のトランスパイラでは利用可能です)。</target>
        </trans-unit>
        <trans-unit id="1f3485295e4b1e7cb9ba6ceb99cf99e2f22625b6" translate="yes" xml:space="preserve">
          <source>For my needs, I have an object that relates to an array which will end up being used in a loop, so I only want to calculate some common setup once, so this is what I have:</source>
          <target state="translated">私の必要性のために、私はループで使用されることになる配列に関連するオブジェクトを持っているので、いくつかの共通の設定を一度だけ計算したいので、これは私が持っているものです。</target>
        </trans-unit>
        <trans-unit id="8a968f08a7c89b288bbfb820f790e7ca3e2dfe3a" translate="yes" xml:space="preserve">
          <source>Here in this class, you can combine multiple relative path among themselves, which is not possible with an object literal.</source>
          <target state="translated">このクラスでは、オブジェクトリテラルでは不可能な複数の相対パスを組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="9ec2d0d9acff7bf680bdf88207bb66f57686258a" translate="yes" xml:space="preserve">
          <source>Here were using class expressions to get the nested object literal interface we'd want. This is the next best thing IMHO to being able to reference the properties of an object during creation.</source>
          <target state="translated">ここでは、クラス式を使用して、私たちが望む入れ子になったオブジェクトリテラルインターフェイスを取得していました。これは、作成中にオブジェクトのプロパティを参照できることに次ぐ、IMHOでは最高のものです。</target>
        </trans-unit>
        <trans-unit id="8b5dba4ec7f813bdfa99fd3ee3ddb8c39b942b06" translate="yes" xml:space="preserve">
          <source>Here's a neat ES6 way:</source>
          <target state="translated">ここでは、きちんとしたES6の方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="9f1f60c3c30838336fd75d367547b1473607a50e" translate="yes" xml:space="preserve">
          <source>How about this  solution this will work with nested objects with array as well</source>
          <target state="translated">この解決策はどのようにしたらよいでしょうか?</target>
        </trans-unit>
        <trans-unit id="babd7b153a8656e8062ec7e8ff2f28253d98fa70" translate="yes" xml:space="preserve">
          <source>I use it to do something like this:</source>
          <target state="translated">こんな感じで使っています。</target>
        </trans-unit>
        <trans-unit id="0309037d02224ab0bf93448700cfbfc1c12b62a0" translate="yes" xml:space="preserve">
          <source>I use the following code as alternative, and it works. And the variable can be array too. (@ Fausto R.)</source>
          <target state="translated">以下のコードを代用しています。また、変数は配列にすることもできます。(@ Fausto R.)</target>
        </trans-unit>
        <trans-unit id="16dca6cc79c4f5e5242d75fa01475d6d022aa834" translate="yes" xml:space="preserve">
          <source>I wrote an npm library called &lt;a href=&quot;https://github.com/alex-e-leon/self-referenced-object&quot;&gt;self-referenced-object&lt;/a&gt; that supports that syntax and returns a native object.</source>
          <target state="translated">その構文をサポートし、ネイティブオブジェクトを返す&lt;a href=&quot;https://github.com/alex-e-leon/self-referenced-object&quot;&gt;self-referenced-object&lt;/a&gt;と呼ばれるnpmライブラリを書きました。</target>
        </trans-unit>
        <trans-unit id="942d2e5d80858faebc19574da73f010e668697b9" translate="yes" xml:space="preserve">
          <source>If you need it to all be within one expression, you can do that without the temporary property:</source>
          <target state="translated">すべてを1つの式内に収める必要がある場合は、一時的なプロパティを使用せずにそれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="9f79c229c337f3d4133e35122de3eb8f6a1fb40c" translate="yes" xml:space="preserve">
          <source>If you want to use native JS, the other answers provide good solutions.</source>
          <target state="translated">ネイティブJSを使いたいのであれば、他の回答が良い解決策を提供してくれています。</target>
        </trans-unit>
        <trans-unit id="abeee987c0eeb57bf07435bee075109d41c55371" translate="yes" xml:space="preserve">
          <source>If you would, instead, use &lt;code&gt;this&lt;/code&gt; as illustrated below</source>
          <target state="translated">代わりに、以下に示すように &lt;code&gt;this&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="8f30c71ebfff74ce20b6afb11d381929576a49ac" translate="yes" xml:space="preserve">
          <source>In the arrow getter &lt;code&gt;this&lt;/code&gt; picks up the &lt;a href=&quot;http://eddmann.com/posts/arrow-functions-lexical-this-scoping-in-javascript/&quot;&gt;surrounding lexical scope&lt;/a&gt;.</source>
          <target state="translated">矢印ゲッターでは、 &lt;code&gt;this&lt;/code&gt; は&lt;a href=&quot;http://eddmann.com/posts/arrow-functions-lexical-this-scoping-in-javascript/&quot;&gt;周囲の字句スコープを取得します&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3afbac67183487dfd264526600b9d3d902060219" translate="yes" xml:space="preserve">
          <source>In the current form, this code obviously throws a reference error since &lt;code&gt;this&lt;/code&gt; doesn't refer to &lt;code&gt;foo&lt;/code&gt;. But &lt;em&gt;is&lt;/em&gt; there any way to have values in an object literal's properties depend on other properties declared earlier?</source>
          <target state="translated">現在の形式では、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;foo&lt;/code&gt; を参照しないため、このコードは明らかに参照エラーをスローします。 しかし、オブジェクトリテラルのプロパティの値を、以前に宣言された他のプロパティに依存させる方法&lt;em&gt;は&lt;/em&gt;ありますか？</target>
        </trans-unit>
        <trans-unit id="10ee663ae9e4c2ca67534f7453bd385674db57fd" translate="yes" xml:space="preserve">
          <source>Is an object literal and not a factory function or other object creation mechanic.</source>
          <target state="translated">ファクトリー関数や他のオブジェクト作成メカニックではなく、オブジェクトリテラルです。</target>
        </trans-unit>
        <trans-unit id="d590ed70ff180cdfc5b1afbe01261c62bedf45dc" translate="yes" xml:space="preserve">
          <source>Is there any way to get something like the following to work in JavaScript?</source>
          <target state="translated">以下のようなものをJavaScriptで動作させる方法はありますか?</target>
        </trans-unit>
        <trans-unit id="d415cc7379b6a73a30ccd8cbcec3af3a49572db8" translate="yes" xml:space="preserve">
          <source>It pollutes &lt;code&gt;window&lt;/code&gt; of course, but I can't imagine someone writing a script that requires &lt;code&gt;window.temp&lt;/code&gt; to be persistent. Maybe &lt;code&gt;tempMyApp&lt;/code&gt; if you're paranoid.</source>
          <target state="translated">もちろん &lt;code&gt;window&lt;/code&gt; を汚染しますが、 &lt;code&gt;window.temp&lt;/code&gt; を永続化する必要があるスクリプトを書いている人を想像することはできません。 もしあなたが偏執狂なら、 &lt;code&gt;tempMyApp&lt;/code&gt; かもしれません。</target>
        </trans-unit>
        <trans-unit id="23f8724ebbe6007d7695b69e9d2a68f195f798c0" translate="yes" xml:space="preserve">
          <source>It's also ugly but occasionally useful. An example is when you are using an API with rigid initialization conditions and don't feel like refactoring so the scoping is correct.</source>
          <target state="translated">これもまた醜いものですが、時々役に立つことがあります。例としては、リジッドな初期化条件を持つAPIを使用していて、スコープが正しいようにリファクタリングする気がしない場合があります。</target>
        </trans-unit>
        <trans-unit id="812c5a3a096f31351a3c82ab411d0732bb84371a" translate="yes" xml:space="preserve">
          <source>It's very, very &lt;strong&gt;important&lt;/strong&gt; to remember that if you refer to &lt;code&gt;this&lt;/code&gt; without first so doing, then &lt;code&gt;this&lt;/code&gt; will refer to the outer scope... which will be the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">最初に &lt;code&gt;this&lt;/code&gt; を参照せずにこれを参照する場合、 &lt;code&gt;this&lt;/code&gt; は外側のスコープを参照することを覚えておくことが非常に&lt;strong&gt;重要&lt;/strong&gt;です。これは &lt;code&gt;window&lt;/code&gt; オブジェクトになります。</target>
        </trans-unit>
        <trans-unit id="2b40cc7fe18102f6190f71822b08395e64fa525c" translate="yes" xml:space="preserve">
          <source>Main thing to note is while using this solution, you have exact same interface as you'd have had from an object literal. And the syntax is pretty close to an object literal itself (vs using a function, etc).</source>
          <target state="translated">主な注意点は、このソリューションを使用している間は、オブジェクトリテラルと全く同じインターフェイスを持っているということです。また、構文はオブジェクトリテラル自体にかなり近いです(関数などを使用する場合と比較して)。</target>
        </trans-unit>
        <trans-unit id="dc93317f1b6677fdc696173a70ce76ecefc4d274" translate="yes" xml:space="preserve">
          <source>No. All of the solutions here defer it until after the object is created (in various ways) and then assign the third property. The &lt;em&gt;simplest&lt;/em&gt; way is to just do this:</source>
          <target state="translated">いいえ。ここでのソリューションはすべて、オブジェクトが（さまざまな方法で）作成されるまで延期し、3番目のプロパティを割り当てます。 &lt;em&gt;最も簡単な&lt;/em&gt;方法はこれを行うことです：</target>
        </trans-unit>
        <trans-unit id="84b4d548e5b1d60edecd62e40fd50d83f4005ed9" translate="yes" xml:space="preserve">
          <source>Note that you are actually assigning the return value of &lt;code&gt;init()&lt;/code&gt; to &lt;code&gt;foo&lt;/code&gt;, therefore you have to &lt;code&gt;return this&lt;/code&gt;.</source>
          <target state="translated">実際には &lt;code&gt;init()&lt;/code&gt; の戻り値を &lt;code&gt;foo&lt;/code&gt; に割り当てているため、これを返す必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="155f7d8311f9fb79d0d2caebf1b6d28d03b53f88" translate="yes" xml:space="preserve">
          <source>Now in ES6 you can create lazy cached properties. On first use the property evaluates once to become a normal static property. Result: The second time the math function overhead is skipped.</source>
          <target state="translated">ES6では、遅延キャッシュされたプロパティを作成できるようになりました。最初の使用時には、そのプロパティは一度評価されて通常の静的プロパティになります。結果。2回目の使用では、数学関数のオーバーヘッドがスキップされます。</target>
        </trans-unit>
        <trans-unit id="3c5ddabd0e1c7f49ec1c1ac90f8ae37b46f461bc" translate="yes" xml:space="preserve">
          <source>Or of course, if you need to do this more than once:</source>
          <target state="translated">もちろん、複数回行う必要がある場合も。</target>
        </trans-unit>
        <trans-unit id="f5eb0218bc4ab3654619b0fb3e5bb942240cd001" translate="yes" xml:space="preserve">
          <source>Other approach would be to declare the object first before assigning properties into it:</source>
          <target state="translated">他のアプローチとしては、オブジェクトにプロパティを割り当てる前に、まずオブジェクトを宣言するという方法があります。</target>
        </trans-unit>
        <trans-unit id="5d8e43c940bdd19cb5532d6cedc9d605ee5f692e" translate="yes" xml:space="preserve">
          <source>Self-references in object literals / initializers</source>
          <target state="translated">オブジェクトリテラルのイニシャライザの自己参照</target>
        </trans-unit>
        <trans-unit id="fca790723e99751ca1f1bc4e23d448189b146ab1" translate="yes" xml:space="preserve">
          <source>Sets the value at initialization (not a getter, or derived, etc)</source>
          <target state="translated">初期化時の値を設定します(ゲッターや派生などではありません)。</target>
        </trans-unit>
        <trans-unit id="57f087b9989e1f4123dbf53e152c97112c1d473e" translate="yes" xml:space="preserve">
          <source>Shouldn't have any performance impact (except at initialization)</source>
          <target state="translated">パフォーマンスに影響はないはずです(初期化時を除く)。</target>
        </trans-unit>
        <trans-unit id="5a7e2614943880b27c1df41e5568fc5bf5be54c6" translate="yes" xml:space="preserve">
          <source>Simply instantiate an anonymous function:</source>
          <target state="translated">匿名の関数をインスタンス化するだけです。</target>
        </trans-unit>
        <trans-unit id="a482c165e6cb7e078ddbc63a32526271f7a49561" translate="yes" xml:space="preserve">
          <source>Since I need to set a property for &lt;code&gt;indexOfSelectedTier&lt;/code&gt; and I need to use that value when setting the &lt;code&gt;hasUpperTierSelection&lt;/code&gt; property, I calculate that value first and pass it in as a param to the IIFE</source>
          <target state="translated">&lt;code&gt;indexOfSelectedTier&lt;/code&gt; のプロパティを設定する必要があり、 &lt;code&gt;hasUpperTierSelection&lt;/code&gt; プロパティを設定するときにその値を使用する必要があるため、最初にその値を計算し、パラメーターとしてIIFEに渡します</target>
        </trans-unit>
        <trans-unit id="1ada23bdc87db08aaa20719e959ff820f75c1d00" translate="yes" xml:space="preserve">
          <source>Solution I've proposed</source>
          <target state="translated">私が提案した解決策</target>
        </trans-unit>
        <trans-unit id="c782298d40f251ce5efba8475a45df7b59d6e6f4" translate="yes" xml:space="preserve">
          <source>Solution if object literals would've sufficed</source>
          <target state="translated">オブジェクトリテラルで十分な場合の解決策</target>
        </trans-unit>
        <trans-unit id="62c942cb061d5d573002b3f10f2dd414875a9451" translate="yes" xml:space="preserve">
          <source>Some closure should deal with this;</source>
          <target state="translated">何らかの閉鎖はこれに対処すべきだ</target>
        </trans-unit>
        <trans-unit id="1c10701de3d549b74de32d75bb721fe76fe23ffe" translate="yes" xml:space="preserve">
          <source>That method has proven useful to me when I had to refer to the object that a function was originally declared on. The following is a minimal example of how I used it:</source>
          <target state="translated">そのメソッドは、もともと関数が宣言されているオブジェクトを参照しなければならないときに便利だと証明されています。以下は、私がどのように使用したかの最低限の例です。</target>
        </trans-unit>
        <trans-unit id="19e20cb9164b0d0a783a114136e5dc51873d9ad8" translate="yes" xml:space="preserve">
          <source>The function is then executed at the end with the &lt;code&gt;()&lt;/code&gt; which causes the entire foo object to be evaluated, all the variables within instantiated and the return object added as properties of &lt;code&gt;foo()&lt;/code&gt;.</source>
          <target state="translated">次に、関数は最後に &lt;code&gt;()&lt;/code&gt; を使用して実行されます。これにより、fooオブジェクト全体が評価され、インスタンス化されたすべての変数と、戻りオブジェクトが &lt;code&gt;foo()&lt;/code&gt; のプロパティとして追加されます。</target>
        </trans-unit>
        <trans-unit id="14ebed8ae4974932378aaabde3a364d853a6c1a4" translate="yes" xml:space="preserve">
          <source>The key to all this is &lt;strong&gt;SCOPE&lt;/strong&gt;.</source>
          <target state="translated">これらすべての鍵は&lt;strong&gt;SCOPE&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="be0bfcb8df074688f6c27c382d5ab77ccf97d8e7" translate="yes" xml:space="preserve">
          <source>The magic is in the getter.</source>
          <target state="translated">魔法はゲッターにあります。</target>
        </trans-unit>
        <trans-unit id="aecb727f3ad85ed2a827155f93eee4cdade53c16" translate="yes" xml:space="preserve">
          <source>The obvious, simple answer is missing, so for completeness:</source>
          <target state="translated">明らかな単純な答えが欠けているので、完全性のために。</target>
        </trans-unit>
        <trans-unit id="240fb8682b72da8d2e15a3e267c25d80fd7965c7" translate="yes" xml:space="preserve">
          <source>The order is &lt;a href=&quot;https://stackoverflow.com/a/17438220/728393&quot;&gt;guaranteed&lt;/a&gt; (&lt;code&gt;bar&lt;/code&gt; before &lt;code&gt;baz&lt;/code&gt;).</source>
          <target state="translated">順序は&lt;a href=&quot;https://stackoverflow.com/a/17438220/728393&quot;&gt;保証されます&lt;/a&gt; （ &lt;code&gt;baz&lt;/code&gt; の前の &lt;code&gt;bar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a083113ba4f644ed462a47363ea68427607ce0dc" translate="yes" xml:space="preserve">
          <source>The other answers posted here are better but here's an alternative that:</source>
          <target state="translated">ここに掲載されている他の回答の方が良いのですが、ここでは代替案を紹介します。</target>
        </trans-unit>
        <trans-unit id="1be4015d04d94304a9c1129d49a1dbf1389d6018" translate="yes" xml:space="preserve">
          <source>The simplest solution for computed properties follows (no heap, no functions, no constructor):</source>
          <target state="translated">計算されたプロパティの最も単純な解決策は以下の通りです(ヒープなし、関数なし、コンストラクタなし)。</target>
        </trans-unit>
        <trans-unit id="95e4cca4a7c8d05cad1ebd4c2e5f382197391257" translate="yes" xml:space="preserve">
          <source>Then the following code will log 0, 1, 2 and then give an error</source>
          <target state="translated">すると、次のコードは 0,1,2 をログに記録し、エラーを出します。</target>
        </trans-unit>
        <trans-unit id="3a2d4d9f4924a6aff35e96ab71cd9cf066c5e108" translate="yes" xml:space="preserve">
          <source>There are several ways to accomplish this; this is what I would use:</source>
          <target state="translated">これを達成するにはいくつかの方法がありますが、私が使うのはこれです。</target>
        </trans-unit>
        <trans-unit id="4eeeeb9a258073df9b0bfb718852decef5fa294f" translate="yes" xml:space="preserve">
          <source>This is a syntactic extension introduced by the ECMAScript 5th Edition Specification, the syntax is supported by most modern browsers (including IE9).</source>
          <target state="translated">これは ECMAScript 5th Edition 仕様で導入された構文拡張で、この構文はほとんどの最新ブラウザ(IE9 を含む)でサポートされています。</target>
        </trans-unit>
        <trans-unit id="0f92f2b118a843ab9880da9f8314284aabdfac9d" translate="yes" xml:space="preserve">
          <source>This is almost identical to @slicedtoad's answer, but doesn't use a function.</source>
          <target state="translated">これは@slicedtoadさんの回答とほぼ同じですが、関数を使っていません。</target>
        </trans-unit>
        <trans-unit id="32a94e2e2503049174642659d0ec7926adf1285c" translate="yes" xml:space="preserve">
          <source>This would be some kind of one time initialization of the object.</source>
          <target state="translated">これは、ある種のオブジェクトの一回限りの初期化のようなものでしょう。</target>
        </trans-unit>
        <trans-unit id="9ebec4a239492a8436ba877b518dcf220654fb91" translate="yes" xml:space="preserve">
          <source>Throwing in an option since I didn't see this exact scenario covered.  If you &lt;em&gt;don't&lt;/em&gt; want &lt;code&gt;c&lt;/code&gt; updated when &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; update, then an ES6 IIFE works well.</source>
          <target state="translated">この正確なシナリオがカバーされていなかったので、オプションを投入しました。 &lt;code&gt;a&lt;/code&gt; または &lt;code&gt;b&lt;/code&gt; の更新時に &lt;code&gt;c&lt;/code&gt; を更新したく&lt;em&gt;ない&lt;/em&gt;場合は、ES6 IIFEが適切に機能します。</target>
        </trans-unit>
        <trans-unit id="1fbf4e1cbb018e88ddfd19f4af4935c5d6650cb5" translate="yes" xml:space="preserve">
          <source>Well, the only thing that I can tell you about are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;getter&lt;/a&gt;:</source>
          <target state="translated">まあ、私があなたに話すことができる唯一のことは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;ゲッター&lt;/a&gt;です：</target>
        </trans-unit>
        <trans-unit id="89f02d99000cfdd02a61d533b0a00fe24810857f" translate="yes" xml:space="preserve">
          <source>With that, you can use the object variable name to access the already assigned values.</source>
          <target state="translated">これで、オブジェクト変数名を使って、既に代入されている値にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="29fcff212f0dd19af315366ba19f89316bce3995" translate="yes" xml:space="preserve">
          <source>With this pattern you can instantiate several foo objects according to your need.</source>
          <target state="translated">このパターンでは、必要に応じていくつかの foo オブジェクトをインスタンス化することができます。</target>
        </trans-unit>
        <trans-unit id="fdcf280b6b2994732c06f6bc2d7996502fa52f90" translate="yes" xml:space="preserve">
          <source>You can do it using the module pattern. Just like:</source>
          <target state="translated">モジュールのパターンを使って、それを行うことができます。みたいな感じで。</target>
        </trans-unit>
        <trans-unit id="45cee98b956ac337a8937b66a7b732b18cf4f833" translate="yes" xml:space="preserve">
          <source>You cannot reference a sibling property during object literal initialization.</source>
          <target state="translated">オブジェクト・リテラルの初期化中に兄弟プロパティを参照することはできません。</target>
        </trans-unit>
        <trans-unit id="be9169cb2216e3ca1720e49bc5ab1d173e14d482" translate="yes" xml:space="preserve">
          <source>You could do it like this</source>
          <target state="translated">このようにすることができます。</target>
        </trans-unit>
        <trans-unit id="2ea2cb9d80edd838a8c30cbb3eb156086fb4852c" translate="yes" xml:space="preserve">
          <source>You could do something like:</source>
          <target state="translated">みたいなことができます。</target>
        </trans-unit>
        <trans-unit id="d0256d452b2d0368a6725c64ac4bccc6646f0dce" translate="yes" xml:space="preserve">
          <source>You need to encapsulate the &quot;parent&quot; (parent object) of the property you want to define as it's own instantiated object, and then you can make references to sibling properties using the key word &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">独自のインスタンス化されたオブジェクトとして定義するプロパティの「親」（親オブジェクト）をカプセル化する必要があります。次に、 &lt;code&gt;this&lt;/code&gt; キーワードを使用して兄弟プロパティへの参照を作成できます。</target>
        </trans-unit>
        <trans-unit id="511fba73f4d0c0d156bb1f407eeea34408de463c" translate="yes" xml:space="preserve">
          <source>if your object is written as a function which returns an object, AND you use ES6 object-attribute 'methods', then it's possible:</source>
          <target state="translated">オブジェクトを返す関数として書かれていて、かつ ES6 のオブジェクト属性の 'メソッド' を使用しているのであれば、それは可能です。</target>
        </trans-unit>
        <trans-unit id="ddd0714cab8fe6bc438dcd95c35fb549a65e1dc5" translate="yes" xml:space="preserve">
          <source>just for the sake of thought - place object's properties out of a timeline:</source>
          <target state="translated">念のために-オブジェクトのプロパティをタイムラインの外に配置します。</target>
        </trans-unit>
        <trans-unit id="c7c3b1f8e8a34c26eeb341990a13fcb444306252" translate="yes" xml:space="preserve">
          <source>then where you need to use it:</source>
          <target state="translated">ならば、それを使う必要がある場所に</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
