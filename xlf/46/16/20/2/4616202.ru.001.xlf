<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/4616202">
    <body>
      <group id="4616202">
        <trans-unit id="c4ac02843782bba091676b91d711e2e91dcffe31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;there are better answers above too&lt;/em&gt;. This is how I modified example code you questioned with.</source>
          <target state="translated">&lt;em&gt;выше есть и лучшие ответы&lt;/em&gt; . Вот как я изменил пример кода, который вы опрашивали.</target>
        </trans-unit>
        <trans-unit id="957d9136a0bdfeebdb55a85be13d86097ee866f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This solution uses Typescript (you can use the vanilla JS which TS compiles to if needed)</source>
          <target state="translated">&lt;strong&gt;Примечание. В&lt;/strong&gt; этом решении используется Typescript (вы можете использовать vanilla JS, в которую TS при необходимости компилирует)</target>
        </trans-unit>
        <trans-unit id="f4fff8192428d6c6716c07b07726101f6544fe3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Self-executing anonymous functions and window storage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Самостоятельно выполняющиеся анонимные функции и хранилище окон&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4b2dbb7dd3fe023446263ea126c7b75aa47f762" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68eac555eb871081828454cb1b939d4ad2032682" translate="yes" xml:space="preserve">
          <source>All others are just more indirect ways to do the same thing. (Felix's is particularly clever, but requires creating and destroying a temporary function, adding complexity; and either leaves an extra property on the object or [if you &lt;code&gt;delete&lt;/code&gt; that property] &lt;a href=&quot;http://jsperf.com/test-dictionary-mode&quot;&gt;impacts the performance&lt;/a&gt; of subsequent property accesses on that object.)</source>
          <target state="translated">Все остальные просто косвенные способы сделать то же самое. (Феликс особенно умен, но требует создания и уничтожения временной функции, добавления сложности; либо оставляет дополнительное свойство для объекта, либо [если вы &lt;code&gt;delete&lt;/code&gt; это свойство] &lt;a href=&quot;http://jsperf.com/test-dictionary-mode&quot;&gt;влияет на производительность&lt;/a&gt; последующих обращений к этому объекту.)</target>
        </trans-unit>
        <trans-unit id="8eadcb7bea9b4f30141e679e78d203b6fa90cce5" translate="yes" xml:space="preserve">
          <source>All the variables declared within &lt;code&gt;foo&lt;/code&gt; are private to &lt;code&gt;foo&lt;/code&gt;, as you would expect with any function declaration and because they are all in scope, they all have access to each other without needing to refer to &lt;code&gt;this&lt;/code&gt;, just as you would expect with a function.  The difference is that this function returns an object that exposes the private variables and assigns that object to &lt;code&gt;foo&lt;/code&gt;.  In the end, you return just the interface you want to expose as an object with the &lt;code&gt;return {}&lt;/code&gt; statement.</source>
          <target state="translated">Все переменные, объявленные в &lt;code&gt;foo&lt;/code&gt; , являются частными для &lt;code&gt;foo&lt;/code&gt; , как и следовало ожидать при любом объявлении функции, и поскольку они все находятся в области видимости, все они имеют доступ друг к другу без необходимости ссылаться на &lt;code&gt;this&lt;/code&gt; , как вы ожидаете от функции. Разница в том, что эта функция возвращает объект, который предоставляет приватные переменные и назначает этот объект для &lt;code&gt;foo&lt;/code&gt; . В конце вы возвращаете только интерфейс, который хотите представить как объект, с помощью оператора &lt;code&gt;return {}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26bb25d9ee5a7962277df483adabebc634b91c8b" translate="yes" xml:space="preserve">
          <source>And it's dry, of course.</source>
          <target state="translated">И он сухой,конечно.</target>
        </trans-unit>
        <trans-unit id="7e1638d3363efdfbe5466eef1db2d2342c31fe3e" translate="yes" xml:space="preserve">
          <source>Another example</source>
          <target state="translated">Другой пример</target>
        </trans-unit>
        <trans-unit id="ddc284d45ee7ece33b36b3bd1ddb1cd16897bcff" translate="yes" xml:space="preserve">
          <source>Best for &lt;code&gt;config.js&lt;/code&gt; file.</source>
          <target state="translated">Лучше всего для файла &lt;code&gt;config.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3b1293f28df07e10be54f376ce6236b7fcd0ec" translate="yes" xml:space="preserve">
          <source>But &lt;em&gt;is&lt;/em&gt; there any way to have values in an object literal's properties depend on other properties declared earlier?</source>
          <target state="translated">Но есть ли способ, чтобы значения в свойствах литерала объекта зависели от других свойств, объявленных ранее?</target>
        </trans-unit>
        <trans-unit id="c980d41b522ee4202df0d52d4e10fa0ce7545909" translate="yes" xml:space="preserve">
          <source>But if you'd prefer to write self-referencing objects like:</source>
          <target state="translated">Но если вы предпочитаете писать самостоятельные ссылки на объекты,например:</target>
        </trans-unit>
        <trans-unit id="f7b06add61246d536572b2eae6171784eb4c2ba5" translate="yes" xml:space="preserve">
          <source>By defining self as the object that contains the print function you allow the function to refer to that object. This means you will not have to 'bind' the print function to an object if you need to pass it somewhere else.</source>
          <target state="translated">Определив себя как объект,содержащий функцию печати,вы разрешаете функции ссылаться на этот объект.Это означает,что вам не придётся &quot;привязывать&quot; функцию печати к объекту,если вам нужно будет передать его куда-то ещё.</target>
        </trans-unit>
        <trans-unit id="dd3ec02519ed2fea89ddf00600cbc98ce08963cc" translate="yes" xml:space="preserve">
          <source>By using the self method you guarantee that print will always return the same object regardless of the context in which the function is ran. The code above will run just fine and log 0, 1, 2 and 3 when using the self version of &lt;code&gt;createMyObject()&lt;/code&gt;.</source>
          <target state="translated">Используя метод self, вы гарантируете, что print всегда будет возвращать один и тот же объект независимо от контекста, в котором выполняется функция. Приведенный выше код будет работать нормально и будет записывать 0, 1, 2 и 3 при использовании собственной версии &lt;code&gt;createMyObject()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb26bf00b13f18b06c15beeaa5f7dbab1d453031" translate="yes" xml:space="preserve">
          <source>Compare the following</source>
          <target state="translated">Сравните следующее</target>
        </trans-unit>
        <trans-unit id="50bf2c5b2bbbe0ff5a2a3490ab713dd2cf025fb2" translate="yes" xml:space="preserve">
          <source>Creating new function on your object literal and invoking a constructor seems a radical departure from the original problem, and it's unnecessary.</source>
          <target state="translated">Создание новой функции на вашем объекте буквально и обращение к конструктору кажется радикальным отходом от первоначальной задачи,и это лишнее.</target>
        </trans-unit>
        <trans-unit id="455b7b22e4988bee5bcac315f59a6ea4faa1b993" translate="yes" xml:space="preserve">
          <source>Doesn't require any type of &lt;code&gt;init()&lt;/code&gt; or code outside of the object literal</source>
          <target state="translated">Не требует какого-либо типа &lt;code&gt;init()&lt;/code&gt; или кода вне литерала объекта</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="cdb0cba21e450ddf5b06bdddae32351284fc26bf" translate="yes" xml:space="preserve">
          <source>For completion, in ES6 we've got classes (supported at the time of writing this only by latest browsers, but available in Babel, TypeScript and other transpilers)</source>
          <target state="translated">Для завершения,в ES6 у нас есть классы (поддерживаемые на момент написания статьи только последними браузерами,но доступные в Babel,TypeScript и других транспайлерах).</target>
        </trans-unit>
        <trans-unit id="1f3485295e4b1e7cb9ba6ceb99cf99e2f22625b6" translate="yes" xml:space="preserve">
          <source>For my needs, I have an object that relates to an array which will end up being used in a loop, so I only want to calculate some common setup once, so this is what I have:</source>
          <target state="translated">Для моих нужд у меня есть объект,относящийся к массиву,который в итоге будет использоваться в цикле,поэтому я хочу вычислить некоторые общие настройки только один раз,так что это то,что у меня есть:</target>
        </trans-unit>
        <trans-unit id="8a968f08a7c89b288bbfb820f790e7ca3e2dfe3a" translate="yes" xml:space="preserve">
          <source>Here in this class, you can combine multiple relative path among themselves, which is not possible with an object literal.</source>
          <target state="translated">Здесь,в данном классе,можно совместить несколько относительных путей между собой,что невозможно при использовании объекта буквально.</target>
        </trans-unit>
        <trans-unit id="9ec2d0d9acff7bf680bdf88207bb66f57686258a" translate="yes" xml:space="preserve">
          <source>Here were using class expressions to get the nested object literal interface we'd want. This is the next best thing IMHO to being able to reference the properties of an object during creation.</source>
          <target state="translated">Здесь мы использовали выражения классов,чтобы получить нужный нам вложенный объектный литературный интерфейс.Это следующее,что лучше всего сделать IMHO,чтобы иметь возможность ссылаться на свойства объекта во время его создания.</target>
        </trans-unit>
        <trans-unit id="8b5dba4ec7f813bdfa99fd3ee3ddb8c39b942b06" translate="yes" xml:space="preserve">
          <source>Here's a neat ES6 way:</source>
          <target state="translated">Вот аккуратный способ ES6:</target>
        </trans-unit>
        <trans-unit id="9f1f60c3c30838336fd75d367547b1473607a50e" translate="yes" xml:space="preserve">
          <source>How about this  solution this will work with nested objects with array as well</source>
          <target state="translated">Как насчет этого решения,оно будет работать и с вложенными объектами с массивом</target>
        </trans-unit>
        <trans-unit id="babd7b153a8656e8062ec7e8ff2f28253d98fa70" translate="yes" xml:space="preserve">
          <source>I use it to do something like this:</source>
          <target state="translated">Я использую его,чтобы сделать что-то подобное:</target>
        </trans-unit>
        <trans-unit id="0309037d02224ab0bf93448700cfbfc1c12b62a0" translate="yes" xml:space="preserve">
          <source>I use the following code as alternative, and it works. And the variable can be array too. (@ Fausto R.)</source>
          <target state="translated">В качестве альтернативы я использую следующий код,и он работает.И переменная тоже может быть массивом.(@ Fausto R.)</target>
        </trans-unit>
        <trans-unit id="16dca6cc79c4f5e5242d75fa01475d6d022aa834" translate="yes" xml:space="preserve">
          <source>I wrote an npm library called &lt;a href=&quot;https://github.com/alex-e-leon/self-referenced-object&quot;&gt;self-referenced-object&lt;/a&gt; that supports that syntax and returns a native object.</source>
          <target state="translated">Я написал библиотеку npm под названием &lt;a href=&quot;https://github.com/alex-e-leon/self-referenced-object&quot;&gt;self-referenced-object,&lt;/a&gt; которая поддерживает этот синтаксис и возвращает собственный объект.</target>
        </trans-unit>
        <trans-unit id="942d2e5d80858faebc19574da73f010e668697b9" translate="yes" xml:space="preserve">
          <source>If you need it to all be within one expression, you can do that without the temporary property:</source>
          <target state="translated">Если вам нужно,чтобы все было в пределах одного выражения,вы можете сделать это без временного имущества:</target>
        </trans-unit>
        <trans-unit id="9f79c229c337f3d4133e35122de3eb8f6a1fb40c" translate="yes" xml:space="preserve">
          <source>If you want to use native JS, the other answers provide good solutions.</source>
          <target state="translated">Если вы хотите использовать родной JS,другие ответы предоставляют хорошие решения.</target>
        </trans-unit>
        <trans-unit id="abeee987c0eeb57bf07435bee075109d41c55371" translate="yes" xml:space="preserve">
          <source>If you would, instead, use &lt;code&gt;this&lt;/code&gt; as illustrated below</source>
          <target state="translated">Если вы используете вместо &lt;code&gt;this&lt;/code&gt; как показано ниже</target>
        </trans-unit>
        <trans-unit id="8f30c71ebfff74ce20b6afb11d381929576a49ac" translate="yes" xml:space="preserve">
          <source>In the arrow getter &lt;code&gt;this&lt;/code&gt; picks up the &lt;a href=&quot;http://eddmann.com/posts/arrow-functions-lexical-this-scoping-in-javascript/&quot;&gt;surrounding lexical scope&lt;/a&gt;.</source>
          <target state="translated">В получателе стрелок &lt;code&gt;this&lt;/code&gt; поднимает &lt;a href=&quot;http://eddmann.com/posts/arrow-functions-lexical-this-scoping-in-javascript/&quot;&gt;окружающую лексическую область&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3afbac67183487dfd264526600b9d3d902060219" translate="yes" xml:space="preserve">
          <source>In the current form, this code obviously throws a reference error since &lt;code&gt;this&lt;/code&gt; doesn't refer to &lt;code&gt;foo&lt;/code&gt;. But &lt;em&gt;is&lt;/em&gt; there any way to have values in an object literal's properties depend on other properties declared earlier?</source>
          <target state="translated">В текущей форме этот код явно выдает ошибку ссылки, поскольку &lt;code&gt;this&lt;/code&gt; не относится к &lt;code&gt;foo&lt;/code&gt; . Но есть ли способ, чтобы значения в свойствах литерала объекта зависели от других свойств, объявленных ранее?</target>
        </trans-unit>
        <trans-unit id="10ee663ae9e4c2ca67534f7453bd385674db57fd" translate="yes" xml:space="preserve">
          <source>Is an object literal and not a factory function or other object creation mechanic.</source>
          <target state="translated">Является объектом буквально,а не заводской функцией или другим механиком создания объектов.</target>
        </trans-unit>
        <trans-unit id="d590ed70ff180cdfc5b1afbe01261c62bedf45dc" translate="yes" xml:space="preserve">
          <source>Is there any way to get something like the following to work in JavaScript?</source>
          <target state="translated">Есть ли какой-нибудь способ получить что-то подобное для работы на JavaScript?</target>
        </trans-unit>
        <trans-unit id="d415cc7379b6a73a30ccd8cbcec3af3a49572db8" translate="yes" xml:space="preserve">
          <source>It pollutes &lt;code&gt;window&lt;/code&gt; of course, but I can't imagine someone writing a script that requires &lt;code&gt;window.temp&lt;/code&gt; to be persistent. Maybe &lt;code&gt;tempMyApp&lt;/code&gt; if you're paranoid.</source>
          <target state="translated">Конечно, это загрязняет &lt;code&gt;window&lt;/code&gt; , но я не могу представить, чтобы кто-то писал скрипт, который требует, чтобы &lt;code&gt;window.temp&lt;/code&gt; был постоянным. Может быть, &lt;code&gt;tempMyApp&lt;/code&gt; , если вы параноик.</target>
        </trans-unit>
        <trans-unit id="23f8724ebbe6007d7695b69e9d2a68f195f798c0" translate="yes" xml:space="preserve">
          <source>It's also ugly but occasionally useful. An example is when you are using an API with rigid initialization conditions and don't feel like refactoring so the scoping is correct.</source>
          <target state="translated">Это также уродливо,но иногда полезно.Пример,когда вы используете API с жесткими условиями инициализации и не чувствуете себя рефакторинговым,поэтому область применения правильная.</target>
        </trans-unit>
        <trans-unit id="812c5a3a096f31351a3c82ab411d0732bb84371a" translate="yes" xml:space="preserve">
          <source>It's very, very &lt;strong&gt;important&lt;/strong&gt; to remember that if you refer to &lt;code&gt;this&lt;/code&gt; without first so doing, then &lt;code&gt;this&lt;/code&gt; will refer to the outer scope... which will be the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">Очень, очень &lt;strong&gt;важно&lt;/strong&gt; помнить, что если вы обращаетесь к &lt;code&gt;this&lt;/code&gt; без предварительного уведомления, то &lt;code&gt;this&lt;/code&gt; будет относиться к внешней области видимости ... которая будет объектом &lt;code&gt;window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b40cc7fe18102f6190f71822b08395e64fa525c" translate="yes" xml:space="preserve">
          <source>Main thing to note is while using this solution, you have exact same interface as you'd have had from an object literal. And the syntax is pretty close to an object literal itself (vs using a function, etc).</source>
          <target state="translated">Главное,что при использовании этого решения,вы имеете точно такой же интерфейс,как у вас был бы у объекта буквально.А синтаксис довольно близок к самому объекту-литералу (в сравнении с использованием функции и т.д.).</target>
        </trans-unit>
        <trans-unit id="dc93317f1b6677fdc696173a70ce76ecefc4d274" translate="yes" xml:space="preserve">
          <source>No. All of the solutions here defer it until after the object is created (in various ways) and then assign the third property. The &lt;em&gt;simplest&lt;/em&gt; way is to just do this:</source>
          <target state="translated">Нет. Все решения здесь откладывают его до тех пор, пока объект не будет создан (различными способами), а затем назначат третье свойство. Самый &lt;em&gt;простой&lt;/em&gt; способ - просто сделать это:</target>
        </trans-unit>
        <trans-unit id="84b4d548e5b1d60edecd62e40fd50d83f4005ed9" translate="yes" xml:space="preserve">
          <source>Note that you are actually assigning the return value of &lt;code&gt;init()&lt;/code&gt; to &lt;code&gt;foo&lt;/code&gt;, therefore you have to &lt;code&gt;return this&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что вы фактически присваиваете &lt;code&gt;foo&lt;/code&gt; возвращаемое значение &lt;code&gt;init()&lt;/code&gt; , поэтому вы должны &lt;code&gt;return this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="155f7d8311f9fb79d0d2caebf1b6d28d03b53f88" translate="yes" xml:space="preserve">
          <source>Now in ES6 you can create lazy cached properties. On first use the property evaluates once to become a normal static property. Result: The second time the math function overhead is skipped.</source>
          <target state="translated">Теперь в ES6 можно создавать ленивые кэшированные свойства.При первом использовании свойство вычисляется один раз,чтобы стать обычным статическим свойством.Результат:Во второй раз математическая функция пропускается.</target>
        </trans-unit>
        <trans-unit id="3c5ddabd0e1c7f49ec1c1ac90f8ae37b46f461bc" translate="yes" xml:space="preserve">
          <source>Or of course, if you need to do this more than once:</source>
          <target state="translated">Или,конечно,если тебе нужно сделать это не один раз:</target>
        </trans-unit>
        <trans-unit id="f5eb0218bc4ab3654619b0fb3e5bb942240cd001" translate="yes" xml:space="preserve">
          <source>Other approach would be to declare the object first before assigning properties into it:</source>
          <target state="translated">Другой подход заключается в том,чтобы сначала объявить объект перед присвоением ему свойств:</target>
        </trans-unit>
        <trans-unit id="5d8e43c940bdd19cb5532d6cedc9d605ee5f692e" translate="yes" xml:space="preserve">
          <source>Self-references in object literals / initializers</source>
          <target state="translated">Самонапоминания в инициализаторах объектных букв</target>
        </trans-unit>
        <trans-unit id="fca790723e99751ca1f1bc4e23d448189b146ab1" translate="yes" xml:space="preserve">
          <source>Sets the value at initialization (not a getter, or derived, etc)</source>
          <target state="translated">Устанавливает значение при инициализации (не геттер,не производный и т.д.).</target>
        </trans-unit>
        <trans-unit id="57f087b9989e1f4123dbf53e152c97112c1d473e" translate="yes" xml:space="preserve">
          <source>Shouldn't have any performance impact (except at initialization)</source>
          <target state="translated">не должны оказывать никакого влияния на производительность (кроме как при инициализации)</target>
        </trans-unit>
        <trans-unit id="5a7e2614943880b27c1df41e5568fc5bf5be54c6" translate="yes" xml:space="preserve">
          <source>Simply instantiate an anonymous function:</source>
          <target state="translated">Просто инстанцируйте анонимную функцию:</target>
        </trans-unit>
        <trans-unit id="a482c165e6cb7e078ddbc63a32526271f7a49561" translate="yes" xml:space="preserve">
          <source>Since I need to set a property for &lt;code&gt;indexOfSelectedTier&lt;/code&gt; and I need to use that value when setting the &lt;code&gt;hasUpperTierSelection&lt;/code&gt; property, I calculate that value first and pass it in as a param to the IIFE</source>
          <target state="translated">Так как мне нужно установить свойство для &lt;code&gt;indexOfSelectedTier&lt;/code&gt; и мне нужно использовать это значение при установке свойства &lt;code&gt;hasUpperTierSelection&lt;/code&gt; , я сначала вычисляю это значение и передаю его как параметр в IIFE.</target>
        </trans-unit>
        <trans-unit id="1ada23bdc87db08aaa20719e959ff820f75c1d00" translate="yes" xml:space="preserve">
          <source>Solution I've proposed</source>
          <target state="translated">Решение,которое я предложил</target>
        </trans-unit>
        <trans-unit id="c782298d40f251ce5efba8475a45df7b59d6e6f4" translate="yes" xml:space="preserve">
          <source>Solution if object literals would've sufficed</source>
          <target state="translated">Решение,если буквальных объектов было бы достаточно.</target>
        </trans-unit>
        <trans-unit id="62c942cb061d5d573002b3f10f2dd414875a9451" translate="yes" xml:space="preserve">
          <source>Some closure should deal with this;</source>
          <target state="translated">Некоторое закрытие должно с этим разобраться;</target>
        </trans-unit>
        <trans-unit id="1c10701de3d549b74de32d75bb721fe76fe23ffe" translate="yes" xml:space="preserve">
          <source>That method has proven useful to me when I had to refer to the object that a function was originally declared on. The following is a minimal example of how I used it:</source>
          <target state="translated">Этот метод оказался полезным для меня,когда мне приходилось ссылаться на объект,на котором изначально была объявлена функция.Ниже приведен минимальный пример того,как я его использовал:</target>
        </trans-unit>
        <trans-unit id="19e20cb9164b0d0a783a114136e5dc51873d9ad8" translate="yes" xml:space="preserve">
          <source>The function is then executed at the end with the &lt;code&gt;()&lt;/code&gt; which causes the entire foo object to be evaluated, all the variables within instantiated and the return object added as properties of &lt;code&gt;foo()&lt;/code&gt;.</source>
          <target state="translated">Затем функция выполняется в конце с помощью &lt;code&gt;()&lt;/code&gt; , что вызывает оценку всего объекта foo, создание всех переменных внутри экземпляра и добавление возвращаемого объекта в качестве свойств &lt;code&gt;foo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14ebed8ae4974932378aaabde3a364d853a6c1a4" translate="yes" xml:space="preserve">
          <source>The key to all this is &lt;strong&gt;SCOPE&lt;/strong&gt;.</source>
          <target state="translated">Ключ ко всему этому - &lt;strong&gt;ОБЛАСТЬ ПРИМЕНЕНИЯ&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="be0bfcb8df074688f6c27c382d5ab77ccf97d8e7" translate="yes" xml:space="preserve">
          <source>The magic is in the getter.</source>
          <target state="translated">Волшебство в геттере.</target>
        </trans-unit>
        <trans-unit id="aecb727f3ad85ed2a827155f93eee4cdade53c16" translate="yes" xml:space="preserve">
          <source>The obvious, simple answer is missing, so for completeness:</source>
          <target state="translated">Очевидного,простого ответа не хватает,так что для полноты:</target>
        </trans-unit>
        <trans-unit id="240fb8682b72da8d2e15a3e267c25d80fd7965c7" translate="yes" xml:space="preserve">
          <source>The order is &lt;a href=&quot;https://stackoverflow.com/a/17438220/728393&quot;&gt;guaranteed&lt;/a&gt; (&lt;code&gt;bar&lt;/code&gt; before &lt;code&gt;baz&lt;/code&gt;).</source>
          <target state="translated">Заказ &lt;a href=&quot;https://stackoverflow.com/a/17438220/728393&quot;&gt;гарантирован&lt;/a&gt; ( &lt;code&gt;bar&lt;/code&gt; до &lt;code&gt;baz&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a083113ba4f644ed462a47363ea68427607ce0dc" translate="yes" xml:space="preserve">
          <source>The other answers posted here are better but here's an alternative that:</source>
          <target state="translated">Остальные ответы,размещенные здесь,лучше,но есть альтернатива:</target>
        </trans-unit>
        <trans-unit id="1be4015d04d94304a9c1129d49a1dbf1389d6018" translate="yes" xml:space="preserve">
          <source>The simplest solution for computed properties follows (no heap, no functions, no constructor):</source>
          <target state="translated">Далее следует простейшее решение для вычисляемых свойств (нет кучи,нет функций,нет конструктора):</target>
        </trans-unit>
        <trans-unit id="95e4cca4a7c8d05cad1ebd4c2e5f382197391257" translate="yes" xml:space="preserve">
          <source>Then the following code will log 0, 1, 2 and then give an error</source>
          <target state="translated">Затем следующий код зарегистрирует 0,1,2 и выдаст ошибку.</target>
        </trans-unit>
        <trans-unit id="3a2d4d9f4924a6aff35e96ab71cd9cf066c5e108" translate="yes" xml:space="preserve">
          <source>There are several ways to accomplish this; this is what I would use:</source>
          <target state="translated">Есть несколько способов сделать это;это то,что я бы использовал:</target>
        </trans-unit>
        <trans-unit id="4eeeeb9a258073df9b0bfb718852decef5fa294f" translate="yes" xml:space="preserve">
          <source>This is a syntactic extension introduced by the ECMAScript 5th Edition Specification, the syntax is supported by most modern browsers (including IE9).</source>
          <target state="translated">Это синтаксическое расширение,введенное спецификацией ECMAScript 5th Edition,синтаксис поддерживается большинством современных браузеров (включая IE9).</target>
        </trans-unit>
        <trans-unit id="0f92f2b118a843ab9880da9f8314284aabdfac9d" translate="yes" xml:space="preserve">
          <source>This is almost identical to @slicedtoad's answer, but doesn't use a function.</source>
          <target state="translated">Это почти идентично ответу @slicedtoad,но не использует функцию.</target>
        </trans-unit>
        <trans-unit id="32a94e2e2503049174642659d0ec7926adf1285c" translate="yes" xml:space="preserve">
          <source>This would be some kind of one time initialization of the object.</source>
          <target state="translated">Это будет своего рода однократная инициализация объекта.</target>
        </trans-unit>
        <trans-unit id="9ebec4a239492a8436ba877b518dcf220654fb91" translate="yes" xml:space="preserve">
          <source>Throwing in an option since I didn't see this exact scenario covered.  If you &lt;em&gt;don't&lt;/em&gt; want &lt;code&gt;c&lt;/code&gt; updated when &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; update, then an ES6 IIFE works well.</source>
          <target state="translated">Добавив вариант, так как я не видел этого точного сценария. Если вы &lt;em&gt;не&lt;/em&gt; хотите, чтобы &lt;code&gt;c&lt;/code&gt; обновлялся при обновлении &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; , тогда ES6 IIFE работает хорошо.</target>
        </trans-unit>
        <trans-unit id="1fbf4e1cbb018e88ddfd19f4af4935c5d6650cb5" translate="yes" xml:space="preserve">
          <source>Well, the only thing that I can tell you about are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;getter&lt;/a&gt;:</source>
          <target state="translated">Ну, единственное, о чем я могу рассказать, это &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;геттер&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="89f02d99000cfdd02a61d533b0a00fe24810857f" translate="yes" xml:space="preserve">
          <source>With that, you can use the object variable name to access the already assigned values.</source>
          <target state="translated">При этом вы можете использовать имя объектной переменной для доступа к уже присвоенным значениям.</target>
        </trans-unit>
        <trans-unit id="29fcff212f0dd19af315366ba19f89316bce3995" translate="yes" xml:space="preserve">
          <source>With this pattern you can instantiate several foo objects according to your need.</source>
          <target state="translated">С помощью этого шаблона вы можете инстанцировать несколько объектов Фу в соответствии с вашими потребностями.</target>
        </trans-unit>
        <trans-unit id="fdcf280b6b2994732c06f6bc2d7996502fa52f90" translate="yes" xml:space="preserve">
          <source>You can do it using the module pattern. Just like:</source>
          <target state="translated">Это можно сделать с помощью шаблона модуля.Точно так же:</target>
        </trans-unit>
        <trans-unit id="45cee98b956ac337a8937b66a7b732b18cf4f833" translate="yes" xml:space="preserve">
          <source>You cannot reference a sibling property during object literal initialization.</source>
          <target state="translated">Нельзя ссылаться на свойство брата или сестры во время буквальной инициализации объекта.</target>
        </trans-unit>
        <trans-unit id="be9169cb2216e3ca1720e49bc5ab1d173e14d482" translate="yes" xml:space="preserve">
          <source>You could do it like this</source>
          <target state="translated">Ты можешь сделать это так.</target>
        </trans-unit>
        <trans-unit id="2ea2cb9d80edd838a8c30cbb3eb156086fb4852c" translate="yes" xml:space="preserve">
          <source>You could do something like:</source>
          <target state="translated">Ты можешь сделать что-нибудь вроде:</target>
        </trans-unit>
        <trans-unit id="d0256d452b2d0368a6725c64ac4bccc6646f0dce" translate="yes" xml:space="preserve">
          <source>You need to encapsulate the &quot;parent&quot; (parent object) of the property you want to define as it's own instantiated object, and then you can make references to sibling properties using the key word &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">Вам нужно инкапсулировать &amp;laquo;родительский&amp;raquo; (родительский объект) свойства, которое вы хотите определить как его собственный экземплярный объект, а затем вы можете делать ссылки на свойства-братья, используя ключевое слово &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="511fba73f4d0c0d156bb1f407eeea34408de463c" translate="yes" xml:space="preserve">
          <source>if your object is written as a function which returns an object, AND you use ES6 object-attribute 'methods', then it's possible:</source>
          <target state="translated">Если ваш объект записан как функция,которая возвращает объект,И вы используете ES6 объект-атрибут 'методы',то это возможно:</target>
        </trans-unit>
        <trans-unit id="ddd0714cab8fe6bc438dcd95c35fb549a65e1dc5" translate="yes" xml:space="preserve">
          <source>just for the sake of thought - place object's properties out of a timeline:</source>
          <target state="translated">просто для размышлений-выведите свойства объекта из временной шкалы:</target>
        </trans-unit>
        <trans-unit id="c7c3b1f8e8a34c26eeb341990a13fcb444306252" translate="yes" xml:space="preserve">
          <source>then where you need to use it:</source>
          <target state="translated">тогда,где тебе нужно его использовать:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
