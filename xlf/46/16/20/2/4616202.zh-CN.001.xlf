<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4616202">
    <body>
      <group id="4616202">
        <trans-unit id="c4ac02843782bba091676b91d711e2e91dcffe31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;there are better answers above too&lt;/em&gt;. This is how I modified example code you questioned with.</source>
          <target state="translated">&lt;em&gt;上面也有更好的答案&lt;/em&gt; 。 这就是我修改了您所质疑的示例代码的方式。</target>
        </trans-unit>
        <trans-unit id="957d9136a0bdfeebdb55a85be13d86097ee866f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This solution uses Typescript (you can use the vanilla JS which TS compiles to if needed)</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此解决方案使用Typescript（如果需要，您可以使用TS编译到的原始JS）</target>
        </trans-unit>
        <trans-unit id="f4fff8192428d6c6716c07b07726101f6544fe3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Self-executing anonymous functions and window storage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;自执行匿名功能和窗口存储&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4b2dbb7dd3fe023446263ea126c7b75aa47f762" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68eac555eb871081828454cb1b939d4ad2032682" translate="yes" xml:space="preserve">
          <source>All others are just more indirect ways to do the same thing. (Felix's is particularly clever, but requires creating and destroying a temporary function, adding complexity; and either leaves an extra property on the object or [if you &lt;code&gt;delete&lt;/code&gt; that property] &lt;a href=&quot;http://jsperf.com/test-dictionary-mode&quot;&gt;impacts the performance&lt;/a&gt; of subsequent property accesses on that object.)</source>
          <target state="translated">所有其他方法只是做同一件事的更间接的方法。 （Felix的技巧特别聪明，但是需要创建和销毁一个临时函数，从而增加了复杂性；并且要么在对象上留下额外的属性，要么[如果 &lt;code&gt;delete&lt;/code&gt; 该属性]会&lt;a href=&quot;http://jsperf.com/test-dictionary-mode&quot;&gt;影响&lt;/a&gt;对该对象的后续属性访问的性能 。）</target>
        </trans-unit>
        <trans-unit id="8eadcb7bea9b4f30141e679e78d203b6fa90cce5" translate="yes" xml:space="preserve">
          <source>All the variables declared within &lt;code&gt;foo&lt;/code&gt; are private to &lt;code&gt;foo&lt;/code&gt;, as you would expect with any function declaration and because they are all in scope, they all have access to each other without needing to refer to &lt;code&gt;this&lt;/code&gt;, just as you would expect with a function.  The difference is that this function returns an object that exposes the private variables and assigns that object to &lt;code&gt;foo&lt;/code&gt;.  In the end, you return just the interface you want to expose as an object with the &lt;code&gt;return {}&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 中声明的所有变量都是foo的私有变量，正如您对任何函数声明所期望的那样，并且由于它们都在范围内，因此它们都可以相互访问而无需引用 &lt;code&gt;this&lt;/code&gt; 变量，就像您对函数所期望的那样。 不同之处在于此函数返回一个对象，该对象公开私有变量并将该对象分配给 &lt;code&gt;foo&lt;/code&gt; 。 最后，使用 &lt;code&gt;return {}&lt;/code&gt; 语句仅返回要作为对象公开的接口。</target>
        </trans-unit>
        <trans-unit id="26bb25d9ee5a7962277df483adabebc634b91c8b" translate="yes" xml:space="preserve">
          <source>And it's dry, of course.</source>
          <target state="translated">当然,而且是干的。</target>
        </trans-unit>
        <trans-unit id="7e1638d3363efdfbe5466eef1db2d2342c31fe3e" translate="yes" xml:space="preserve">
          <source>Another example</source>
          <target state="translated">另一个例子</target>
        </trans-unit>
        <trans-unit id="ddc284d45ee7ece33b36b3bd1ddb1cd16897bcff" translate="yes" xml:space="preserve">
          <source>Best for &lt;code&gt;config.js&lt;/code&gt; file.</source>
          <target state="translated">最适合 &lt;code&gt;config.js&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="1e3b1293f28df07e10be54f376ce6236b7fcd0ec" translate="yes" xml:space="preserve">
          <source>But &lt;em&gt;is&lt;/em&gt; there any way to have values in an object literal's properties depend on other properties declared earlier?</source>
          <target state="translated">但是， &lt;em&gt;是否&lt;/em&gt;有任何方法可以使对象文字的属性值取决于先前声明的其他属性？</target>
        </trans-unit>
        <trans-unit id="c980d41b522ee4202df0d52d4e10fa0ce7545909" translate="yes" xml:space="preserve">
          <source>But if you'd prefer to write self-referencing objects like:</source>
          <target state="translated">但如果你更愿意写一些自我引用的对象,比如。</target>
        </trans-unit>
        <trans-unit id="f7b06add61246d536572b2eae6171784eb4c2ba5" translate="yes" xml:space="preserve">
          <source>By defining self as the object that contains the print function you allow the function to refer to that object. This means you will not have to 'bind' the print function to an object if you need to pass it somewhere else.</source>
          <target state="translated">通过将self定义为包含打印函数的对象,你可以让函数引用到该对象。这意味着,如果你需要将打印函数传递到其他地方,就不必将其 &quot;绑定 &quot;到一个对象上。</target>
        </trans-unit>
        <trans-unit id="dd3ec02519ed2fea89ddf00600cbc98ce08963cc" translate="yes" xml:space="preserve">
          <source>By using the self method you guarantee that print will always return the same object regardless of the context in which the function is ran. The code above will run just fine and log 0, 1, 2 and 3 when using the self version of &lt;code&gt;createMyObject()&lt;/code&gt;.</source>
          <target state="translated">通过使用self方法，可以确保print始终返回相同的对象，而不管函数在哪个上下文中运行。 使用 &lt;code&gt;createMyObject()&lt;/code&gt; 的自我版本时，上面的代码可以正常运行并记录0、1、2和3。</target>
        </trans-unit>
        <trans-unit id="fb26bf00b13f18b06c15beeaa5f7dbab1d453031" translate="yes" xml:space="preserve">
          <source>Compare the following</source>
          <target state="translated">以下是比较</target>
        </trans-unit>
        <trans-unit id="50bf2c5b2bbbe0ff5a2a3490ab713dd2cf025fb2" translate="yes" xml:space="preserve">
          <source>Creating new function on your object literal and invoking a constructor seems a radical departure from the original problem, and it's unnecessary.</source>
          <target state="translated">在你的对象字面意义上创建新的函数并调用构造函数,这似乎是对原始问题的一个根本性的偏离,没有必要。</target>
        </trans-unit>
        <trans-unit id="455b7b22e4988bee5bcac315f59a6ea4faa1b993" translate="yes" xml:space="preserve">
          <source>Doesn't require any type of &lt;code&gt;init()&lt;/code&gt; or code outside of the object literal</source>
          <target state="translated">不需要对象文字之外的任何类型的 &lt;code&gt;init()&lt;/code&gt; 或代码</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="cdb0cba21e450ddf5b06bdddae32351284fc26bf" translate="yes" xml:space="preserve">
          <source>For completion, in ES6 we've got classes (supported at the time of writing this only by latest browsers, but available in Babel, TypeScript and other transpilers)</source>
          <target state="translated">为了完成,在ES6中,我们有了类(在写这篇文章时,只有最新的浏览器支持,但在Babel、TypeScript和其他转码器中可以使用</target>
        </trans-unit>
        <trans-unit id="1f3485295e4b1e7cb9ba6ceb99cf99e2f22625b6" translate="yes" xml:space="preserve">
          <source>For my needs, I have an object that relates to an array which will end up being used in a loop, so I only want to calculate some common setup once, so this is what I have:</source>
          <target state="translated">对于我的需求,我有一个对象与一个数组有关,最终会在一个循环中使用,所以我只想计算一次一些常用的设置,所以我有这样的设置。</target>
        </trans-unit>
        <trans-unit id="8a968f08a7c89b288bbfb820f790e7ca3e2dfe3a" translate="yes" xml:space="preserve">
          <source>Here in this class, you can combine multiple relative path among themselves, which is not possible with an object literal.</source>
          <target state="translated">在这个类中,你可以将多个相对路径相互之间进行组合,这在对象字面意义上是不可能的。</target>
        </trans-unit>
        <trans-unit id="9ec2d0d9acff7bf680bdf88207bb66f57686258a" translate="yes" xml:space="preserve">
          <source>Here were using class expressions to get the nested object literal interface we'd want. This is the next best thing IMHO to being able to reference the properties of an object during creation.</source>
          <target state="translated">这里我们使用类表达式来获得我们想要的嵌套对象的直译接口。这是在创建过程中能够引用对象的属性,这在IMHO中是下一个最好的东西。</target>
        </trans-unit>
        <trans-unit id="8b5dba4ec7f813bdfa99fd3ee3ddb8c39b942b06" translate="yes" xml:space="preserve">
          <source>Here's a neat ES6 way:</source>
          <target state="translated">这是个很好的ES6方式。</target>
        </trans-unit>
        <trans-unit id="9f1f60c3c30838336fd75d367547b1473607a50e" translate="yes" xml:space="preserve">
          <source>How about this  solution this will work with nested objects with array as well</source>
          <target state="translated">这个解决方案如何,这也可以和数组的嵌套对象一起使用。</target>
        </trans-unit>
        <trans-unit id="babd7b153a8656e8062ec7e8ff2f28253d98fa70" translate="yes" xml:space="preserve">
          <source>I use it to do something like this:</source>
          <target state="translated">我用它来做这样的事情。</target>
        </trans-unit>
        <trans-unit id="0309037d02224ab0bf93448700cfbfc1c12b62a0" translate="yes" xml:space="preserve">
          <source>I use the following code as alternative, and it works. And the variable can be array too. (@ Fausto R.)</source>
          <target state="translated">我用下面的代码作为替代方案,而且很好用。而且变量也可以是数组。(@Fausto R.)</target>
        </trans-unit>
        <trans-unit id="16dca6cc79c4f5e5242d75fa01475d6d022aa834" translate="yes" xml:space="preserve">
          <source>I wrote an npm library called &lt;a href=&quot;https://github.com/alex-e-leon/self-referenced-object&quot;&gt;self-referenced-object&lt;/a&gt; that supports that syntax and returns a native object.</source>
          <target state="translated">我编写了一个名为&lt;a href=&quot;https://github.com/alex-e-leon/self-referenced-object&quot;&gt;自我引用对象&lt;/a&gt;的npm库，该库支持该语法并返回一个本机对象。</target>
        </trans-unit>
        <trans-unit id="942d2e5d80858faebc19574da73f010e668697b9" translate="yes" xml:space="preserve">
          <source>If you need it to all be within one expression, you can do that without the temporary property:</source>
          <target state="translated">如果你需要它都在一个表达式内,你可以不需要临时属性就可以。</target>
        </trans-unit>
        <trans-unit id="9f79c229c337f3d4133e35122de3eb8f6a1fb40c" translate="yes" xml:space="preserve">
          <source>If you want to use native JS, the other answers provide good solutions.</source>
          <target state="translated">如果你想使用原生JS,其他答案提供了很好的解决方案。</target>
        </trans-unit>
        <trans-unit id="abeee987c0eeb57bf07435bee075109d41c55371" translate="yes" xml:space="preserve">
          <source>If you would, instead, use &lt;code&gt;this&lt;/code&gt; as illustrated below</source>
          <target state="translated">如果可以，请如下所示使用 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f30c71ebfff74ce20b6afb11d381929576a49ac" translate="yes" xml:space="preserve">
          <source>In the arrow getter &lt;code&gt;this&lt;/code&gt; picks up the &lt;a href=&quot;http://eddmann.com/posts/arrow-functions-lexical-this-scoping-in-javascript/&quot;&gt;surrounding lexical scope&lt;/a&gt;.</source>
          <target state="translated">在箭头getter中， &lt;code&gt;this&lt;/code&gt; 拾取了&lt;a href=&quot;http://eddmann.com/posts/arrow-functions-lexical-this-scoping-in-javascript/&quot;&gt;周围的词汇范围&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3afbac67183487dfd264526600b9d3d902060219" translate="yes" xml:space="preserve">
          <source>In the current form, this code obviously throws a reference error since &lt;code&gt;this&lt;/code&gt; doesn't refer to &lt;code&gt;foo&lt;/code&gt;. But &lt;em&gt;is&lt;/em&gt; there any way to have values in an object literal's properties depend on other properties declared earlier?</source>
          <target state="translated">在当前形式下，此代码显然引发了引用错误，因为它没有引用 &lt;code&gt;foo&lt;/code&gt; 。 但是， &lt;em&gt;是否&lt;/em&gt;有任何方法可以使对象文字的属性值取决于先前声明的其他属性？</target>
        </trans-unit>
        <trans-unit id="10ee663ae9e4c2ca67534f7453bd385674db57fd" translate="yes" xml:space="preserve">
          <source>Is an object literal and not a factory function or other object creation mechanic.</source>
          <target state="translated">是一个对象字面意思,而不是工厂函数或其他对象创建机制。</target>
        </trans-unit>
        <trans-unit id="d590ed70ff180cdfc5b1afbe01261c62bedf45dc" translate="yes" xml:space="preserve">
          <source>Is there any way to get something like the following to work in JavaScript?</source>
          <target state="translated">有什么方法可以让下面这样的东西在JavaScript中工作吗?</target>
        </trans-unit>
        <trans-unit id="d415cc7379b6a73a30ccd8cbcec3af3a49572db8" translate="yes" xml:space="preserve">
          <source>It pollutes &lt;code&gt;window&lt;/code&gt; of course, but I can't imagine someone writing a script that requires &lt;code&gt;window.temp&lt;/code&gt; to be persistent. Maybe &lt;code&gt;tempMyApp&lt;/code&gt; if you're paranoid.</source>
          <target state="translated">它当然污染了 &lt;code&gt;window&lt;/code&gt; ，但是我无法想象有人编写需要 &lt;code&gt;window.temp&lt;/code&gt; 持久化的脚本。 如果您偏执，也许是 &lt;code&gt;tempMyApp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23f8724ebbe6007d7695b69e9d2a68f195f798c0" translate="yes" xml:space="preserve">
          <source>It's also ugly but occasionally useful. An example is when you are using an API with rigid initialization conditions and don't feel like refactoring so the scoping is correct.</source>
          <target state="translated">它也很难看,但偶尔也会有用。一个例子是,当你在使用一个具有刚性初始化条件的API,而不觉得重构,所以Scoping是正确的。</target>
        </trans-unit>
        <trans-unit id="812c5a3a096f31351a3c82ab411d0732bb84371a" translate="yes" xml:space="preserve">
          <source>It's very, very &lt;strong&gt;important&lt;/strong&gt; to remember that if you refer to &lt;code&gt;this&lt;/code&gt; without first so doing, then &lt;code&gt;this&lt;/code&gt; will refer to the outer scope... which will be the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">要记住，非常&lt;strong&gt;重要的一点&lt;/strong&gt;是，如果不先这样做就引用它，那么它将引用外部作用域&amp;hellip;&amp;hellip;这将是 &lt;code&gt;window&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="2b40cc7fe18102f6190f71822b08395e64fa525c" translate="yes" xml:space="preserve">
          <source>Main thing to note is while using this solution, you have exact same interface as you'd have had from an object literal. And the syntax is pretty close to an object literal itself (vs using a function, etc).</source>
          <target state="translated">需要注意的是,当你使用这个解决方案时,你会有一个和对象字面符号完全相同的接口。而且语法非常接近于对象字面符号本身(相对于使用函数等)。</target>
        </trans-unit>
        <trans-unit id="dc93317f1b6677fdc696173a70ce76ecefc4d274" translate="yes" xml:space="preserve">
          <source>No. All of the solutions here defer it until after the object is created (in various ways) and then assign the third property. The &lt;em&gt;simplest&lt;/em&gt; way is to just do this:</source>
          <target state="translated">否。这里的所有解决方案都将其推迟到创建对象（以各种方式）然后分配第三个属性之后。 &lt;em&gt;最简单的&lt;/em&gt;方法就是这样做：</target>
        </trans-unit>
        <trans-unit id="84b4d548e5b1d60edecd62e40fd50d83f4005ed9" translate="yes" xml:space="preserve">
          <source>Note that you are actually assigning the return value of &lt;code&gt;init()&lt;/code&gt; to &lt;code&gt;foo&lt;/code&gt;, therefore you have to &lt;code&gt;return this&lt;/code&gt;.</source>
          <target state="translated">请注意，您实际上是将 &lt;code&gt;init()&lt;/code&gt; 的返回值分配给 &lt;code&gt;foo&lt;/code&gt; ，因此必须 &lt;code&gt;return this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="155f7d8311f9fb79d0d2caebf1b6d28d03b53f88" translate="yes" xml:space="preserve">
          <source>Now in ES6 you can create lazy cached properties. On first use the property evaluates once to become a normal static property. Result: The second time the math function overhead is skipped.</source>
          <target state="translated">现在在ES6中,你可以创建懒惰的缓存属性。第一次使用时,该属性会评估一次,成为一个正常的静态属性。结果是。第二次使用时,会跳过数学函数开销。</target>
        </trans-unit>
        <trans-unit id="3c5ddabd0e1c7f49ec1c1ac90f8ae37b46f461bc" translate="yes" xml:space="preserve">
          <source>Or of course, if you need to do this more than once:</source>
          <target state="translated">当然,或者说,如果你需要这样做不止一次。</target>
        </trans-unit>
        <trans-unit id="f5eb0218bc4ab3654619b0fb3e5bb942240cd001" translate="yes" xml:space="preserve">
          <source>Other approach would be to declare the object first before assigning properties into it:</source>
          <target state="translated">其他的方法是先声明对象,然后再将属性分配给它。</target>
        </trans-unit>
        <trans-unit id="5d8e43c940bdd19cb5532d6cedc9d605ee5f692e" translate="yes" xml:space="preserve">
          <source>Self-references in object literals / initializers</source>
          <target state="translated">对象字形初始化器中的自我引用</target>
        </trans-unit>
        <trans-unit id="fca790723e99751ca1f1bc4e23d448189b146ab1" translate="yes" xml:space="preserve">
          <source>Sets the value at initialization (not a getter, or derived, etc)</source>
          <target state="translated">设置初始化时的值(不是getter或派生等)。</target>
        </trans-unit>
        <trans-unit id="57f087b9989e1f4123dbf53e152c97112c1d473e" translate="yes" xml:space="preserve">
          <source>Shouldn't have any performance impact (except at initialization)</source>
          <target state="translated">应该不会对性能产生任何影响(初始化时除外)。</target>
        </trans-unit>
        <trans-unit id="5a7e2614943880b27c1df41e5568fc5bf5be54c6" translate="yes" xml:space="preserve">
          <source>Simply instantiate an anonymous function:</source>
          <target state="translated">简单地实例化一个匿名函数。</target>
        </trans-unit>
        <trans-unit id="a482c165e6cb7e078ddbc63a32526271f7a49561" translate="yes" xml:space="preserve">
          <source>Since I need to set a property for &lt;code&gt;indexOfSelectedTier&lt;/code&gt; and I need to use that value when setting the &lt;code&gt;hasUpperTierSelection&lt;/code&gt; property, I calculate that value first and pass it in as a param to the IIFE</source>
          <target state="translated">由于我需要为 &lt;code&gt;indexOfSelectedTier&lt;/code&gt; 设置一个属性，并且在设置 &lt;code&gt;hasUpperTierSelection&lt;/code&gt; 属性时需要使用该值，因此我首先计算该值并将其作为参数传递给IIFE。</target>
        </trans-unit>
        <trans-unit id="1ada23bdc87db08aaa20719e959ff820f75c1d00" translate="yes" xml:space="preserve">
          <source>Solution I've proposed</source>
          <target state="translated">我提出的解决方案</target>
        </trans-unit>
        <trans-unit id="c782298d40f251ce5efba8475a45df7b59d6e6f4" translate="yes" xml:space="preserve">
          <source>Solution if object literals would've sufficed</source>
          <target state="translated">如果对象字面意思就足够了,就可以解决问题了</target>
        </trans-unit>
        <trans-unit id="62c942cb061d5d573002b3f10f2dd414875a9451" translate="yes" xml:space="preserve">
          <source>Some closure should deal with this;</source>
          <target state="translated">一些封闭应该会处理好这个问题。</target>
        </trans-unit>
        <trans-unit id="1c10701de3d549b74de32d75bb721fe76fe23ffe" translate="yes" xml:space="preserve">
          <source>That method has proven useful to me when I had to refer to the object that a function was originally declared on. The following is a minimal example of how I used it:</source>
          <target state="translated">事实证明,当我不得不引用一个函数最初声明的对象时,这个方法对我很有用。下面是我使用这个方法的一个最简单的例子。</target>
        </trans-unit>
        <trans-unit id="19e20cb9164b0d0a783a114136e5dc51873d9ad8" translate="yes" xml:space="preserve">
          <source>The function is then executed at the end with the &lt;code&gt;()&lt;/code&gt; which causes the entire foo object to be evaluated, all the variables within instantiated and the return object added as properties of &lt;code&gt;foo()&lt;/code&gt;.</source>
          <target state="translated">然后，该函数以 &lt;code&gt;()&lt;/code&gt; 结尾执行，该赋值将对整个foo对象进行求值，实例化其中的所有变量，并将返回对象添加为 &lt;code&gt;foo()&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="14ebed8ae4974932378aaabde3a364d853a6c1a4" translate="yes" xml:space="preserve">
          <source>The key to all this is &lt;strong&gt;SCOPE&lt;/strong&gt;.</source>
          <target state="translated">这一切的关键是&lt;strong&gt;SCOPE&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="be0bfcb8df074688f6c27c382d5ab77ccf97d8e7" translate="yes" xml:space="preserve">
          <source>The magic is in the getter.</source>
          <target state="translated">魔力就在得到者身上。</target>
        </trans-unit>
        <trans-unit id="aecb727f3ad85ed2a827155f93eee4cdade53c16" translate="yes" xml:space="preserve">
          <source>The obvious, simple answer is missing, so for completeness:</source>
          <target state="translated">显而易见,简单的答案是缺失的,所以对于完整性。</target>
        </trans-unit>
        <trans-unit id="240fb8682b72da8d2e15a3e267c25d80fd7965c7" translate="yes" xml:space="preserve">
          <source>The order is &lt;a href=&quot;https://stackoverflow.com/a/17438220/728393&quot;&gt;guaranteed&lt;/a&gt; (&lt;code&gt;bar&lt;/code&gt; before &lt;code&gt;baz&lt;/code&gt;).</source>
          <target state="translated">订单得到&lt;a href=&quot;https://stackoverflow.com/a/17438220/728393&quot;&gt;保证&lt;/a&gt; （ &lt;code&gt;baz&lt;/code&gt; 之前为 &lt;code&gt;bar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a083113ba4f644ed462a47363ea68427607ce0dc" translate="yes" xml:space="preserve">
          <source>The other answers posted here are better but here's an alternative that:</source>
          <target state="translated">这里贴出的其他答案都比较好,但这里有一个替代方案,那就是。</target>
        </trans-unit>
        <trans-unit id="1be4015d04d94304a9c1129d49a1dbf1389d6018" translate="yes" xml:space="preserve">
          <source>The simplest solution for computed properties follows (no heap, no functions, no constructor):</source>
          <target state="translated">最简单的计算属性解决方案如下(无堆、无函数、无构造函数)。</target>
        </trans-unit>
        <trans-unit id="95e4cca4a7c8d05cad1ebd4c2e5f382197391257" translate="yes" xml:space="preserve">
          <source>Then the following code will log 0, 1, 2 and then give an error</source>
          <target state="translated">那么下面的代码会记录0、1、2,然后给出一个错误信息</target>
        </trans-unit>
        <trans-unit id="3a2d4d9f4924a6aff35e96ab71cd9cf066c5e108" translate="yes" xml:space="preserve">
          <source>There are several ways to accomplish this; this is what I would use:</source>
          <target state="translated">有几种方法可以做到这一点;这是我想用的方法。</target>
        </trans-unit>
        <trans-unit id="4eeeeb9a258073df9b0bfb718852decef5fa294f" translate="yes" xml:space="preserve">
          <source>This is a syntactic extension introduced by the ECMAScript 5th Edition Specification, the syntax is supported by most modern browsers (including IE9).</source>
          <target state="translated">这是由ECMAScript第五版规范引入的语法扩展,该语法已被大多数现代浏览器(包括IE9)所支持。</target>
        </trans-unit>
        <trans-unit id="0f92f2b118a843ab9880da9f8314284aabdfac9d" translate="yes" xml:space="preserve">
          <source>This is almost identical to @slicedtoad's answer, but doesn't use a function.</source>
          <target state="translated">这和@slicedtoad的答案几乎是一样的,只是没有使用函数。</target>
        </trans-unit>
        <trans-unit id="32a94e2e2503049174642659d0ec7926adf1285c" translate="yes" xml:space="preserve">
          <source>This would be some kind of one time initialization of the object.</source>
          <target state="translated">这将是某种对象的一次性初始化。</target>
        </trans-unit>
        <trans-unit id="9ebec4a239492a8436ba877b518dcf220654fb91" translate="yes" xml:space="preserve">
          <source>Throwing in an option since I didn't see this exact scenario covered.  If you &lt;em&gt;don't&lt;/em&gt; want &lt;code&gt;c&lt;/code&gt; updated when &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; update, then an ES6 IIFE works well.</source>
          <target state="translated">因为我没有看到这个确切的场景，所以选择了一个选项。 如果您&lt;em&gt;不&lt;/em&gt;希望在更新 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 时更新 &lt;code&gt;c&lt;/code&gt; ，那么ES6 IIFE可以很好地工作。</target>
        </trans-unit>
        <trans-unit id="1fbf4e1cbb018e88ddfd19f4af4935c5d6650cb5" translate="yes" xml:space="preserve">
          <source>Well, the only thing that I can tell you about are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;getter&lt;/a&gt;:</source>
          <target state="translated">好吧，我唯一能告诉你的就是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;吸气剂&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="89f02d99000cfdd02a61d533b0a00fe24810857f" translate="yes" xml:space="preserve">
          <source>With that, you can use the object variable name to access the already assigned values.</source>
          <target state="translated">有了这个,你可以使用对象变量名来访问已经分配的值。</target>
        </trans-unit>
        <trans-unit id="29fcff212f0dd19af315366ba19f89316bce3995" translate="yes" xml:space="preserve">
          <source>With this pattern you can instantiate several foo objects according to your need.</source>
          <target state="translated">通过这种模式,你可以根据自己的需要,实例化多个foo对象。</target>
        </trans-unit>
        <trans-unit id="fdcf280b6b2994732c06f6bc2d7996502fa52f90" translate="yes" xml:space="preserve">
          <source>You can do it using the module pattern. Just like:</source>
          <target state="translated">你可以用模块模式来做。就像。</target>
        </trans-unit>
        <trans-unit id="45cee98b956ac337a8937b66a7b732b18cf4f833" translate="yes" xml:space="preserve">
          <source>You cannot reference a sibling property during object literal initialization.</source>
          <target state="translated">在对象字面上的初始化过程中,不能引用一个兄弟姐妹属性。</target>
        </trans-unit>
        <trans-unit id="be9169cb2216e3ca1720e49bc5ab1d173e14d482" translate="yes" xml:space="preserve">
          <source>You could do it like this</source>
          <target state="translated">你可以这样做</target>
        </trans-unit>
        <trans-unit id="2ea2cb9d80edd838a8c30cbb3eb156086fb4852c" translate="yes" xml:space="preserve">
          <source>You could do something like:</source>
          <target state="translated">你可以做这样的事情:</target>
        </trans-unit>
        <trans-unit id="d0256d452b2d0368a6725c64ac4bccc6646f0dce" translate="yes" xml:space="preserve">
          <source>You need to encapsulate the &quot;parent&quot; (parent object) of the property you want to define as it's own instantiated object, and then you can make references to sibling properties using the key word &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">您需要将要定义的属性的&amp;ldquo;父级&amp;rdquo;（父级对象）封装为自己的实例化对象，然后可以使用关键字 &lt;code&gt;this&lt;/code&gt; 引用同级属性。</target>
        </trans-unit>
        <trans-unit id="511fba73f4d0c0d156bb1f407eeea34408de463c" translate="yes" xml:space="preserve">
          <source>if your object is written as a function which returns an object, AND you use ES6 object-attribute 'methods', then it's possible:</source>
          <target state="translated">如果你的对象被写成一个返回对象的函数,并且你使用了ES6对象-属性 &quot;方法&quot;,那么它是可以的。</target>
        </trans-unit>
        <trans-unit id="ddd0714cab8fe6bc438dcd95c35fb549a65e1dc5" translate="yes" xml:space="preserve">
          <source>just for the sake of thought - place object's properties out of a timeline:</source>
          <target state="translated">只是为了思考--把对象的属性放在时间线之外。</target>
        </trans-unit>
        <trans-unit id="c7c3b1f8e8a34c26eeb341990a13fcb444306252" translate="yes" xml:space="preserve">
          <source>then where you need to use it:</source>
          <target state="translated">然后在你需要使用它的地方。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
