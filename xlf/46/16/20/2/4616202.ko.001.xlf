<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/4616202">
    <body>
      <group id="4616202">
        <trans-unit id="c4ac02843782bba091676b91d711e2e91dcffe31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;there are better answers above too&lt;/em&gt;. This is how I modified example code you questioned with.</source>
          <target state="translated">&lt;em&gt;위에 더 나은 답변이 있습니다&lt;/em&gt; . 이것이 내가 질문 한 예제 코드를 수정 한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="957d9136a0bdfeebdb55a85be13d86097ee866f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This solution uses Typescript (you can use the vanilla JS which TS compiles to if needed)</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 솔루션은 Typescript를 사용합니다 (필요한 경우 TS가 컴파일하는 바닐라 JS를 사용할 수 있음)</target>
        </trans-unit>
        <trans-unit id="f4fff8192428d6c6716c07b07726101f6544fe3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Self-executing anonymous functions and window storage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자체 실행 익명 기능 및 창 저장&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4b2dbb7dd3fe023446263ea126c7b75aa47f762" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68eac555eb871081828454cb1b939d4ad2032682" translate="yes" xml:space="preserve">
          <source>All others are just more indirect ways to do the same thing. (Felix's is particularly clever, but requires creating and destroying a temporary function, adding complexity; and either leaves an extra property on the object or [if you &lt;code&gt;delete&lt;/code&gt; that property] &lt;a href=&quot;http://jsperf.com/test-dictionary-mode&quot;&gt;impacts the performance&lt;/a&gt; of subsequent property accesses on that object.)</source>
          <target state="translated">다른 모든 사람들은 같은 일을하는 간접적 인 방법 일뿐입니다. (Felix는 특히 영리하지만 임시 기능을 생성 및 파괴하여 복잡성을 추가해야하며, 객체에 추가 속성을 남겨 두거나 [해당 속성을 &lt;code&gt;delete&lt;/code&gt; 하면] 해당 객체에 대한 후속 속성 액세스 &lt;a href=&quot;http://jsperf.com/test-dictionary-mode&quot;&gt;의 성능&lt;/a&gt; 에 영향을 미칩니다 .)</target>
        </trans-unit>
        <trans-unit id="8eadcb7bea9b4f30141e679e78d203b6fa90cce5" translate="yes" xml:space="preserve">
          <source>All the variables declared within &lt;code&gt;foo&lt;/code&gt; are private to &lt;code&gt;foo&lt;/code&gt;, as you would expect with any function declaration and because they are all in scope, they all have access to each other without needing to refer to &lt;code&gt;this&lt;/code&gt;, just as you would expect with a function.  The difference is that this function returns an object that exposes the private variables and assigns that object to &lt;code&gt;foo&lt;/code&gt;.  In the end, you return just the interface you want to expose as an object with the &lt;code&gt;return {}&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 내에 선언 된 모든 변수는 함수 선언에서 예상 할 수 있듯이 &lt;code&gt;foo&lt;/code&gt; 전용이며, 범위 내에 있기 때문에 함수에서 예상하는 것처럼 &lt;code&gt;this&lt;/code&gt; 참조하지 않고도 서로 액세스 할 수 있습니다. 차이점은이 함수는 전용 변수를 노출하고 해당 객체를 &lt;code&gt;foo&lt;/code&gt; 에 할당하는 객체를 반환한다는 것입니다. 결국 &lt;code&gt;return {}&lt;/code&gt; 문을 사용하여 객체로 노출하려는 인터페이스 만 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="26bb25d9ee5a7962277df483adabebc634b91c8b" translate="yes" xml:space="preserve">
          <source>And it's dry, of course.</source>
          <target state="translated">그리고 물론 건조합니다.</target>
        </trans-unit>
        <trans-unit id="7e1638d3363efdfbe5466eef1db2d2342c31fe3e" translate="yes" xml:space="preserve">
          <source>Another example</source>
          <target state="translated">다른 예시</target>
        </trans-unit>
        <trans-unit id="ddc284d45ee7ece33b36b3bd1ddb1cd16897bcff" translate="yes" xml:space="preserve">
          <source>Best for &lt;code&gt;config.js&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;config.js&lt;/code&gt; 파일에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="1e3b1293f28df07e10be54f376ce6236b7fcd0ec" translate="yes" xml:space="preserve">
          <source>But &lt;em&gt;is&lt;/em&gt; there any way to have values in an object literal's properties depend on other properties declared earlier?</source>
          <target state="translated">그러나 객체 리터럴의 속성 값을 이전에 선언 된 다른 속성에 의존하는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="c980d41b522ee4202df0d52d4e10fa0ce7545909" translate="yes" xml:space="preserve">
          <source>But if you'd prefer to write self-referencing objects like:</source>
          <target state="translated">그러나 다음과 같은 자체 참조 객체를 작성하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="f7b06add61246d536572b2eae6171784eb4c2ba5" translate="yes" xml:space="preserve">
          <source>By defining self as the object that contains the print function you allow the function to refer to that object. This means you will not have to 'bind' the print function to an object if you need to pass it somewhere else.</source>
          <target state="translated">인쇄 기능이 포함 된 객체로 self를 정의하면 해당 함수가 해당 객체를 참조 할 수 있습니다. 즉, 인쇄 기능을 다른 곳에 전달해야하는 경우 인쇄 기능을 객체에 '바인드'할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd3ec02519ed2fea89ddf00600cbc98ce08963cc" translate="yes" xml:space="preserve">
          <source>By using the self method you guarantee that print will always return the same object regardless of the context in which the function is ran. The code above will run just fine and log 0, 1, 2 and 3 when using the self version of &lt;code&gt;createMyObject()&lt;/code&gt;.</source>
          <target state="translated">자체 방법을 사용하면 함수가 실행되는 컨텍스트에 관계없이 print가 항상 동일한 객체를 반환합니다. 위의 코드는 &lt;code&gt;createMyObject()&lt;/code&gt; 자체 버전을 사용할 때 정상적으로 실행되고 0, 1, 2 및 3을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="fb26bf00b13f18b06c15beeaa5f7dbab1d453031" translate="yes" xml:space="preserve">
          <source>Compare the following</source>
          <target state="translated">다음을 비교하십시오</target>
        </trans-unit>
        <trans-unit id="50bf2c5b2bbbe0ff5a2a3490ab713dd2cf025fb2" translate="yes" xml:space="preserve">
          <source>Creating new function on your object literal and invoking a constructor seems a radical departure from the original problem, and it's unnecessary.</source>
          <target state="translated">객체 리터럴에서 새 함수를 만들고 생성자를 호출하면 원래 문제에서 근본적으로 벗어난 것처럼 보이므로 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="455b7b22e4988bee5bcac315f59a6ea4faa1b993" translate="yes" xml:space="preserve">
          <source>Doesn't require any type of &lt;code&gt;init()&lt;/code&gt; or code outside of the object literal</source>
          <target state="translated">객체 리터럴 외부에서 &lt;code&gt;init()&lt;/code&gt; 또는 코드 유형이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="cdb0cba21e450ddf5b06bdddae32351284fc26bf" translate="yes" xml:space="preserve">
          <source>For completion, in ES6 we've got classes (supported at the time of writing this only by latest browsers, but available in Babel, TypeScript and other transpilers)</source>
          <target state="translated">완성을 위해 ES6에는 클래스가 있습니다 (최신 브라우저에서만이를 작성할 때 지원되지만 Babel, TypeScript 및 기타 트랜스 파일러에서 사용 가능)</target>
        </trans-unit>
        <trans-unit id="1f3485295e4b1e7cb9ba6ceb99cf99e2f22625b6" translate="yes" xml:space="preserve">
          <source>For my needs, I have an object that relates to an array which will end up being used in a loop, so I only want to calculate some common setup once, so this is what I have:</source>
          <target state="translated">내 필요에 따라 루프에서 사용되는 배열과 관련된 객체가 있으므로 일반적인 설정을 한 번만 계산하고 싶으므로 이것이 내가 가진 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a968f08a7c89b288bbfb820f790e7ca3e2dfe3a" translate="yes" xml:space="preserve">
          <source>Here in this class, you can combine multiple relative path among themselves, which is not possible with an object literal.</source>
          <target state="translated">여기서는이 클래스에서 여러 상대 경로를 결합 할 수 있으며 이는 객체 리터럴로는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="9ec2d0d9acff7bf680bdf88207bb66f57686258a" translate="yes" xml:space="preserve">
          <source>Here were using class expressions to get the nested object literal interface we'd want. This is the next best thing IMHO to being able to reference the properties of an object during creation.</source>
          <target state="translated">여기에 클래스 표현식을 사용하여 원하는 중첩 객체 리터럴 인터페이스를 얻었습니다. 이것은 IMHO가 생성하는 동안 객체의 속성을 참조 할 수있는 다음 가장 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8b5dba4ec7f813bdfa99fd3ee3ddb8c39b942b06" translate="yes" xml:space="preserve">
          <source>Here's a neat ES6 way:</source>
          <target state="translated">깔끔한 ES6 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f1f60c3c30838336fd75d367547b1473607a50e" translate="yes" xml:space="preserve">
          <source>How about this  solution this will work with nested objects with array as well</source>
          <target state="translated">이 솔루션은 배열이있는 중첩 된 객체에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="babd7b153a8656e8062ec7e8ff2f28253d98fa70" translate="yes" xml:space="preserve">
          <source>I use it to do something like this:</source>
          <target state="translated">나는 이것을 다음과 같이하기 위해 사용한다 :</target>
        </trans-unit>
        <trans-unit id="0309037d02224ab0bf93448700cfbfc1c12b62a0" translate="yes" xml:space="preserve">
          <source>I use the following code as alternative, and it works. And the variable can be array too. (@ Fausto R.)</source>
          <target state="translated">다음 코드를 대안으로 사용하면 작동합니다. 그리고 변수도 배열이 될 수 있습니다. (@ 파우스 토 R.)</target>
        </trans-unit>
        <trans-unit id="16dca6cc79c4f5e5242d75fa01475d6d022aa834" translate="yes" xml:space="preserve">
          <source>I wrote an npm library called &lt;a href=&quot;https://github.com/alex-e-leon/self-referenced-object&quot;&gt;self-referenced-object&lt;/a&gt; that supports that syntax and returns a native object.</source>
          <target state="translated">해당 구문을 지원하고 기본 객체를 반환하는 &lt;a href=&quot;https://github.com/alex-e-leon/self-referenced-object&quot;&gt;self-referenced-object&lt;/a&gt; 라는 npm 라이브러리를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="942d2e5d80858faebc19574da73f010e668697b9" translate="yes" xml:space="preserve">
          <source>If you need it to all be within one expression, you can do that without the temporary property:</source>
          <target state="translated">모두 하나의 표현식 내에 있어야하는 경우 임시 특성없이이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f79c229c337f3d4133e35122de3eb8f6a1fb40c" translate="yes" xml:space="preserve">
          <source>If you want to use native JS, the other answers provide good solutions.</source>
          <target state="translated">네이티브 JS를 사용하려면 다른 답변이 좋은 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="abeee987c0eeb57bf07435bee075109d41c55371" translate="yes" xml:space="preserve">
          <source>If you would, instead, use &lt;code&gt;this&lt;/code&gt; as illustrated below</source>
          <target state="translated">대신에 아래 그림과 같이 &lt;code&gt;this&lt;/code&gt; 사용 하십시오</target>
        </trans-unit>
        <trans-unit id="8f30c71ebfff74ce20b6afb11d381929576a49ac" translate="yes" xml:space="preserve">
          <source>In the arrow getter &lt;code&gt;this&lt;/code&gt; picks up the &lt;a href=&quot;http://eddmann.com/posts/arrow-functions-lexical-this-scoping-in-javascript/&quot;&gt;surrounding lexical scope&lt;/a&gt;.</source>
          <target state="translated">화살표 게터에서 &lt;a href=&quot;http://eddmann.com/posts/arrow-functions-lexical-this-scoping-in-javascript/&quot;&gt;주변 어휘 범위를&lt;/a&gt; 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3afbac67183487dfd264526600b9d3d902060219" translate="yes" xml:space="preserve">
          <source>In the current form, this code obviously throws a reference error since &lt;code&gt;this&lt;/code&gt; doesn't refer to &lt;code&gt;foo&lt;/code&gt;. But &lt;em&gt;is&lt;/em&gt; there any way to have values in an object literal's properties depend on other properties declared earlier?</source>
          <target state="translated">현재 형식 에서이 코드는 &lt;code&gt;foo&lt;/code&gt; 를 참조하지 않으므로 참조 오류가 발생합니다. 그러나 객체 리터럴의 속성 값을 이전에 선언 된 다른 속성에 의존하는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="10ee663ae9e4c2ca67534f7453bd385674db57fd" translate="yes" xml:space="preserve">
          <source>Is an object literal and not a factory function or other object creation mechanic.</source>
          <target state="translated">팩토리 함수 또는 기타 오브젝트 작성 메커니즘이 아닌 오브젝트 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="d590ed70ff180cdfc5b1afbe01261c62bedf45dc" translate="yes" xml:space="preserve">
          <source>Is there any way to get something like the following to work in JavaScript?</source>
          <target state="translated">JavaScript에서 다음과 같은 작업을 수행하는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="d415cc7379b6a73a30ccd8cbcec3af3a49572db8" translate="yes" xml:space="preserve">
          <source>It pollutes &lt;code&gt;window&lt;/code&gt; of course, but I can't imagine someone writing a script that requires &lt;code&gt;window.temp&lt;/code&gt; to be persistent. Maybe &lt;code&gt;tempMyApp&lt;/code&gt; if you're paranoid.</source>
          <target state="translated">물론 &lt;code&gt;window&lt;/code&gt; 을 오염 시키지만 누군가 &lt;code&gt;window.temp&lt;/code&gt; 를 지속적으로 유지 해야하는 스크립트를 작성하는 것을 상상할 수 없습니다. 당신이 편집증이라면 &lt;code&gt;tempMyApp&lt;/code&gt; 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="23f8724ebbe6007d7695b69e9d2a68f195f798c0" translate="yes" xml:space="preserve">
          <source>It's also ugly but occasionally useful. An example is when you are using an API with rigid initialization conditions and don't feel like refactoring so the scoping is correct.</source>
          <target state="translated">추악하지만 때로는 유용합니다. 예를 들어 엄격한 초기화 조건을 가진 API를 사용하고 리팩토링을 느끼지 않기 때문에 범위가 정확합니다.</target>
        </trans-unit>
        <trans-unit id="812c5a3a096f31351a3c82ab411d0732bb84371a" translate="yes" xml:space="preserve">
          <source>It's very, very &lt;strong&gt;important&lt;/strong&gt; to remember that if you refer to &lt;code&gt;this&lt;/code&gt; without first so doing, then &lt;code&gt;this&lt;/code&gt; will refer to the outer scope... which will be the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 하지 않고 이것을 참조하면 이것이 외부 범위를 참조한다는 것을 기억하는 &lt;strong&gt;것이&lt;/strong&gt; 매우 &lt;strong&gt;중요&lt;/strong&gt; 합니다. 이것은 &lt;code&gt;window&lt;/code&gt; 개체가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2b40cc7fe18102f6190f71822b08395e64fa525c" translate="yes" xml:space="preserve">
          <source>Main thing to note is while using this solution, you have exact same interface as you'd have had from an object literal. And the syntax is pretty close to an object literal itself (vs using a function, etc).</source>
          <target state="translated">주목할 점은이 솔루션을 사용하는 동안 객체 리터럴에서와 동일한 인터페이스를 사용한다는 것입니다. 그리고 구문은 객체 리터럴 자체에 가깝습니다 (함수 사용 등).</target>
        </trans-unit>
        <trans-unit id="dc93317f1b6677fdc696173a70ce76ecefc4d274" translate="yes" xml:space="preserve">
          <source>No. All of the solutions here defer it until after the object is created (in various ways) and then assign the third property. The &lt;em&gt;simplest&lt;/em&gt; way is to just do this:</source>
          <target state="translated">아니요. 여기에있는 모든 솔루션은 객체가 생성 될 때까지 (다양한 방식으로) 지연된 다음 세 번째 속성을 할당합니다. &lt;em&gt;가장 간단한&lt;/em&gt; 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84b4d548e5b1d60edecd62e40fd50d83f4005ed9" translate="yes" xml:space="preserve">
          <source>Note that you are actually assigning the return value of &lt;code&gt;init()&lt;/code&gt; to &lt;code&gt;foo&lt;/code&gt;, therefore you have to &lt;code&gt;return this&lt;/code&gt;.</source>
          <target state="translated">실제로 &lt;code&gt;init()&lt;/code&gt; 의 반환 값을 &lt;code&gt;foo&lt;/code&gt; 에 할당하고 있으므로 &lt;code&gt;return this&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="155f7d8311f9fb79d0d2caebf1b6d28d03b53f88" translate="yes" xml:space="preserve">
          <source>Now in ES6 you can create lazy cached properties. On first use the property evaluates once to become a normal static property. Result: The second time the math function overhead is skipped.</source>
          <target state="translated">이제 ES6에서는 지연 캐시 속성을 생성 할 수 있습니다. 처음 사용할 때이 속성은 한 번 평가되어 일반 정적 속성이됩니다. 결과 : 두 번째로 수학 함수 오버 헤드를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="3c5ddabd0e1c7f49ec1c1ac90f8ae37b46f461bc" translate="yes" xml:space="preserve">
          <source>Or of course, if you need to do this more than once:</source>
          <target state="translated">또는 물론이 작업을 두 번 이상 수행해야하는 경우 :</target>
        </trans-unit>
        <trans-unit id="f5eb0218bc4ab3654619b0fb3e5bb942240cd001" translate="yes" xml:space="preserve">
          <source>Other approach would be to declare the object first before assigning properties into it:</source>
          <target state="translated">다른 접근 방식은 속성을 할당하기 전에 먼저 객체를 선언하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d8e43c940bdd19cb5532d6cedc9d605ee5f692e" translate="yes" xml:space="preserve">
          <source>Self-references in object literals / initializers</source>
          <target state="translated">객체 리터럴 / 이니셜 라이저의 자체 참조</target>
        </trans-unit>
        <trans-unit id="fca790723e99751ca1f1bc4e23d448189b146ab1" translate="yes" xml:space="preserve">
          <source>Sets the value at initialization (not a getter, or derived, etc)</source>
          <target state="translated">초기화시 값을 설정합니다 (게터가 아니거나 파생 된 것 등)</target>
        </trans-unit>
        <trans-unit id="57f087b9989e1f4123dbf53e152c97112c1d473e" translate="yes" xml:space="preserve">
          <source>Shouldn't have any performance impact (except at initialization)</source>
          <target state="translated">성능에 영향을 미치지 않아야 함 (초기화 제외)</target>
        </trans-unit>
        <trans-unit id="5a7e2614943880b27c1df41e5568fc5bf5be54c6" translate="yes" xml:space="preserve">
          <source>Simply instantiate an anonymous function:</source>
          <target state="translated">익명 함수를 간단히 인스턴스화하십시오.</target>
        </trans-unit>
        <trans-unit id="a482c165e6cb7e078ddbc63a32526271f7a49561" translate="yes" xml:space="preserve">
          <source>Since I need to set a property for &lt;code&gt;indexOfSelectedTier&lt;/code&gt; and I need to use that value when setting the &lt;code&gt;hasUpperTierSelection&lt;/code&gt; property, I calculate that value first and pass it in as a param to the IIFE</source>
          <target state="translated">&lt;code&gt;indexOfSelectedTier&lt;/code&gt; 에 대한 속성을 설정해야하고 hasUpperTierSelection 속성을 설정할 때 해당 값을 사용해야하므로 먼저 해당 값을 계산하여 IIFE의 매개 변수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1ada23bdc87db08aaa20719e959ff820f75c1d00" translate="yes" xml:space="preserve">
          <source>Solution I've proposed</source>
          <target state="translated">내가 제안한 솔루션</target>
        </trans-unit>
        <trans-unit id="c782298d40f251ce5efba8475a45df7b59d6e6f4" translate="yes" xml:space="preserve">
          <source>Solution if object literals would've sufficed</source>
          <target state="translated">객체 리터럴이 충분하면 솔루션</target>
        </trans-unit>
        <trans-unit id="62c942cb061d5d573002b3f10f2dd414875a9451" translate="yes" xml:space="preserve">
          <source>Some closure should deal with this;</source>
          <target state="translated">일부 폐쇄는이 문제를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c10701de3d549b74de32d75bb721fe76fe23ffe" translate="yes" xml:space="preserve">
          <source>That method has proven useful to me when I had to refer to the object that a function was originally declared on. The following is a minimal example of how I used it:</source>
          <target state="translated">이 방법은 함수가 원래 선언 된 객체를 참조해야 할 때 유용합니다. 다음은 내가 어떻게 사용했는지에 대한 최소한의 예입니다.</target>
        </trans-unit>
        <trans-unit id="19e20cb9164b0d0a783a114136e5dc51873d9ad8" translate="yes" xml:space="preserve">
          <source>The function is then executed at the end with the &lt;code&gt;()&lt;/code&gt; which causes the entire foo object to be evaluated, all the variables within instantiated and the return object added as properties of &lt;code&gt;foo()&lt;/code&gt;.</source>
          <target state="translated">그런 다음 함수는 &lt;code&gt;()&lt;/code&gt; 로 끝까지 실행되어 전체 foo 객체가 평가되고 인스턴스 내의 모든 변수가 반환되고 반환 객체가 &lt;code&gt;foo()&lt;/code&gt; 속성으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="14ebed8ae4974932378aaabde3a364d853a6c1a4" translate="yes" xml:space="preserve">
          <source>The key to all this is &lt;strong&gt;SCOPE&lt;/strong&gt;.</source>
          <target state="translated">이 모든 &lt;strong&gt;것의&lt;/strong&gt; 핵심은 &lt;strong&gt;SCOPE&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be0bfcb8df074688f6c27c382d5ab77ccf97d8e7" translate="yes" xml:space="preserve">
          <source>The magic is in the getter.</source>
          <target state="translated">마술은 게터에있다.</target>
        </trans-unit>
        <trans-unit id="aecb727f3ad85ed2a827155f93eee4cdade53c16" translate="yes" xml:space="preserve">
          <source>The obvious, simple answer is missing, so for completeness:</source>
          <target state="translated">명확하고 간단한 답변이 누락되었으므로 완전성을 위해 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="240fb8682b72da8d2e15a3e267c25d80fd7965c7" translate="yes" xml:space="preserve">
          <source>The order is &lt;a href=&quot;https://stackoverflow.com/a/17438220/728393&quot;&gt;guaranteed&lt;/a&gt; (&lt;code&gt;bar&lt;/code&gt; before &lt;code&gt;baz&lt;/code&gt;).</source>
          <target state="translated">순서는 &lt;a href=&quot;https://stackoverflow.com/a/17438220/728393&quot;&gt;보장됩니다&lt;/a&gt; ( &lt;code&gt;baz&lt;/code&gt; 앞 &lt;code&gt;bar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a083113ba4f644ed462a47363ea68427607ce0dc" translate="yes" xml:space="preserve">
          <source>The other answers posted here are better but here's an alternative that:</source>
          <target state="translated">여기에 게시 된 다른 답변이 더 좋지만 다음과 같은 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be4015d04d94304a9c1129d49a1dbf1389d6018" translate="yes" xml:space="preserve">
          <source>The simplest solution for computed properties follows (no heap, no functions, no constructor):</source>
          <target state="translated">계산 된 속성에 대한 가장 간단한 솔루션은 다음과 같습니다 (힙 없음, 함수 없음, 생성자 없음).</target>
        </trans-unit>
        <trans-unit id="95e4cca4a7c8d05cad1ebd4c2e5f382197391257" translate="yes" xml:space="preserve">
          <source>Then the following code will log 0, 1, 2 and then give an error</source>
          <target state="translated">그런 다음 다음 코드는 0, 1, 2를 기록한 다음 오류를 발생시킵니다</target>
        </trans-unit>
        <trans-unit id="3a2d4d9f4924a6aff35e96ab71cd9cf066c5e108" translate="yes" xml:space="preserve">
          <source>There are several ways to accomplish this; this is what I would use:</source>
          <target state="translated">이를 달성하는 몇 가지 방법이 있습니다. 이것이 내가 사용하는 것입니다 :</target>
        </trans-unit>
        <trans-unit id="4eeeeb9a258073df9b0bfb718852decef5fa294f" translate="yes" xml:space="preserve">
          <source>This is a syntactic extension introduced by the ECMAScript 5th Edition Specification, the syntax is supported by most modern browsers (including IE9).</source>
          <target state="translated">이것은 ECMAScript 5th Edition Specification에 의해 도입 된 구문 확장이며, 구문은 대부분의 최신 브라우저 (IE9 포함)에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0f92f2b118a843ab9880da9f8314284aabdfac9d" translate="yes" xml:space="preserve">
          <source>This is almost identical to @slicedtoad's answer, but doesn't use a function.</source>
          <target state="translated">이것은 @slicedtoad의 답변과 거의 동일하지만 함수를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32a94e2e2503049174642659d0ec7926adf1285c" translate="yes" xml:space="preserve">
          <source>This would be some kind of one time initialization of the object.</source>
          <target state="translated">이것은 일종의 객체 초기화 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ebec4a239492a8436ba877b518dcf220654fb91" translate="yes" xml:space="preserve">
          <source>Throwing in an option since I didn't see this exact scenario covered.  If you &lt;em&gt;don't&lt;/em&gt; want &lt;code&gt;c&lt;/code&gt; updated when &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; update, then an ES6 IIFE works well.</source>
          <target state="translated">이 정확한 시나리오가 다루어지지 않았기 때문에 옵션을 던졌습니다. &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 업데이트시 &lt;code&gt;c&lt;/code&gt; 를 업데이트 &lt;em&gt;하지 않으&lt;/em&gt; 려면 ES6 IIFE가 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1fbf4e1cbb018e88ddfd19f4af4935c5d6650cb5" translate="yes" xml:space="preserve">
          <source>Well, the only thing that I can tell you about are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;getter&lt;/a&gt;:</source>
          <target state="translated">글쎄, 내가 말할 수있는 유일한 것은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;게터입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89f02d99000cfdd02a61d533b0a00fe24810857f" translate="yes" xml:space="preserve">
          <source>With that, you can use the object variable name to access the already assigned values.</source>
          <target state="translated">이를 통해 객체 변수 이름을 사용하여 이미 할당 된 값에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29fcff212f0dd19af315366ba19f89316bce3995" translate="yes" xml:space="preserve">
          <source>With this pattern you can instantiate several foo objects according to your need.</source>
          <target state="translated">이 패턴을 사용하면 필요에 따라 여러 foo 객체를 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdcf280b6b2994732c06f6bc2d7996502fa52f90" translate="yes" xml:space="preserve">
          <source>You can do it using the module pattern. Just like:</source>
          <target state="translated">모듈 패턴을 사용하여 수행 할 수 있습니다. 처럼:</target>
        </trans-unit>
        <trans-unit id="45cee98b956ac337a8937b66a7b732b18cf4f833" translate="yes" xml:space="preserve">
          <source>You cannot reference a sibling property during object literal initialization.</source>
          <target state="translated">객체 리터럴 초기화 중에 형제 속성을 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="be9169cb2216e3ca1720e49bc5ab1d173e14d482" translate="yes" xml:space="preserve">
          <source>You could do it like this</source>
          <target state="translated">당신은 이렇게 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2ea2cb9d80edd838a8c30cbb3eb156086fb4852c" translate="yes" xml:space="preserve">
          <source>You could do something like:</source>
          <target state="translated">당신은 다음과 같은 것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d0256d452b2d0368a6725c64ac4bccc6646f0dce" translate="yes" xml:space="preserve">
          <source>You need to encapsulate the &quot;parent&quot; (parent object) of the property you want to define as it's own instantiated object, and then you can make references to sibling properties using the key word &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">자신이 인스턴스화 된 객체로 정의하려는 속성의 &quot;부모&quot;(부모 개체)를 캡슐화 한 다음 키워드 &lt;code&gt;this&lt;/code&gt; 를 사용하여 형제 속성에 대한 참조를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="511fba73f4d0c0d156bb1f407eeea34408de463c" translate="yes" xml:space="preserve">
          <source>if your object is written as a function which returns an object, AND you use ES6 object-attribute 'methods', then it's possible:</source>
          <target state="translated">객체가 객체를 반환하는 함수로 작성되었고 ES6 객체 속성 '방법'을 사용하는 경우 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ddd0714cab8fe6bc438dcd95c35fb549a65e1dc5" translate="yes" xml:space="preserve">
          <source>just for the sake of thought - place object's properties out of a timeline:</source>
          <target state="translated">생각을 위해서-타임 라인에서 객체의 속성을 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="c7c3b1f8e8a34c26eeb341990a13fcb444306252" translate="yes" xml:space="preserve">
          <source>then where you need to use it:</source>
          <target state="translated">그런 다음 어디에 사용해야합니까?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
