<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/4616202">
    <body>
      <group id="4616202">
        <trans-unit id="c4ac02843782bba091676b91d711e2e91dcffe31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;there are better answers above too&lt;/em&gt;. This is how I modified example code you questioned with.</source>
          <target state="translated">&lt;em&gt;Hay mejores respuestas arriba tambi&amp;eacute;n&lt;/em&gt; . As&amp;iacute; es como modifiqu&amp;eacute; el c&amp;oacute;digo de ejemplo con el que cuestionaste.</target>
        </trans-unit>
        <trans-unit id="957d9136a0bdfeebdb55a85be13d86097ee866f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This solution uses Typescript (you can use the vanilla JS which TS compiles to if needed)</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Esta soluci&amp;oacute;n usa el Script mecanografiado (puede usar el JS de Vanilla que TS compila si es necesario)</target>
        </trans-unit>
        <trans-unit id="f4fff8192428d6c6716c07b07726101f6544fe3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Self-executing anonymous functions and window storage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Funciones an&amp;oacute;nimas de ejecuci&amp;oacute;n autom&amp;aacute;tica y almacenamiento de ventanas&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4b2dbb7dd3fe023446263ea126c7b75aa47f762" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68eac555eb871081828454cb1b939d4ad2032682" translate="yes" xml:space="preserve">
          <source>All others are just more indirect ways to do the same thing. (Felix's is particularly clever, but requires creating and destroying a temporary function, adding complexity; and either leaves an extra property on the object or [if you &lt;code&gt;delete&lt;/code&gt; that property] &lt;a href=&quot;http://jsperf.com/test-dictionary-mode&quot;&gt;impacts the performance&lt;/a&gt; of subsequent property accesses on that object.)</source>
          <target state="translated">Todos los dem&amp;aacute;s son formas m&amp;aacute;s indirectas de hacer lo mismo. (Felix's es particularmente inteligente, pero requiere crear y destruir una funci&amp;oacute;n temporal, agregar complejidad; y deja una propiedad adicional en el objeto o [si &lt;code&gt;delete&lt;/code&gt; esa propiedad] &lt;a href=&quot;http://jsperf.com/test-dictionary-mode&quot;&gt;afecta el rendimiento&lt;/a&gt; de los accesos de propiedad posteriores en ese objeto).</target>
        </trans-unit>
        <trans-unit id="8eadcb7bea9b4f30141e679e78d203b6fa90cce5" translate="yes" xml:space="preserve">
          <source>All the variables declared within &lt;code&gt;foo&lt;/code&gt; are private to &lt;code&gt;foo&lt;/code&gt;, as you would expect with any function declaration and because they are all in scope, they all have access to each other without needing to refer to &lt;code&gt;this&lt;/code&gt;, just as you would expect with a function.  The difference is that this function returns an object that exposes the private variables and assigns that object to &lt;code&gt;foo&lt;/code&gt;.  In the end, you return just the interface you want to expose as an object with the &lt;code&gt;return {}&lt;/code&gt; statement.</source>
          <target state="translated">Todas las variables declaradas dentro de &lt;code&gt;foo&lt;/code&gt; son privadas para &lt;code&gt;foo&lt;/code&gt; , como cabr&amp;iacute;a esperar con cualquier declaraci&amp;oacute;n de funci&amp;oacute;n y, dado que todas est&amp;aacute;n dentro del alcance, todas tienen acceso entre s&amp;iacute; sin necesidad de referirse a &lt;code&gt;this&lt;/code&gt; , tal como cabr&amp;iacute;a esperar con una funci&amp;oacute;n. La diferencia es que esta funci&amp;oacute;n devuelve un objeto que expone las variables privadas y asigna ese objeto a &lt;code&gt;foo&lt;/code&gt; . Al final, devuelve solo la interfaz que desea exponer como un objeto con la declaraci&amp;oacute;n &lt;code&gt;return {}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26bb25d9ee5a7962277df483adabebc634b91c8b" translate="yes" xml:space="preserve">
          <source>And it's dry, of course.</source>
          <target state="translated">Y está seco,por supuesto.</target>
        </trans-unit>
        <trans-unit id="7e1638d3363efdfbe5466eef1db2d2342c31fe3e" translate="yes" xml:space="preserve">
          <source>Another example</source>
          <target state="translated">Otro ejemplo</target>
        </trans-unit>
        <trans-unit id="ddc284d45ee7ece33b36b3bd1ddb1cd16897bcff" translate="yes" xml:space="preserve">
          <source>Best for &lt;code&gt;config.js&lt;/code&gt; file.</source>
          <target state="translated">Lo mejor para el archivo &lt;code&gt;config.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3b1293f28df07e10be54f376ce6236b7fcd0ec" translate="yes" xml:space="preserve">
          <source>But &lt;em&gt;is&lt;/em&gt; there any way to have values in an object literal's properties depend on other properties declared earlier?</source>
          <target state="translated">Pero, &lt;em&gt;&amp;iquest;&lt;/em&gt; hay alguna forma de hacer que los valores en las propiedades de un objeto literal dependan de otras propiedades declaradas anteriormente?</target>
        </trans-unit>
        <trans-unit id="c980d41b522ee4202df0d52d4e10fa0ce7545909" translate="yes" xml:space="preserve">
          <source>But if you'd prefer to write self-referencing objects like:</source>
          <target state="translated">Pero si prefieres escribir objetos de auto-referencia como:</target>
        </trans-unit>
        <trans-unit id="f7b06add61246d536572b2eae6171784eb4c2ba5" translate="yes" xml:space="preserve">
          <source>By defining self as the object that contains the print function you allow the function to refer to that object. This means you will not have to 'bind' the print function to an object if you need to pass it somewhere else.</source>
          <target state="translated">Al definirse a sí mismo como el objeto que contiene la función de impresión se permite que la función se refiera a ese objeto.Esto significa que no tendrás que &quot;atar&quot; la función de impresión a un objeto si necesitas pasarlo a otro lugar.</target>
        </trans-unit>
        <trans-unit id="dd3ec02519ed2fea89ddf00600cbc98ce08963cc" translate="yes" xml:space="preserve">
          <source>By using the self method you guarantee that print will always return the same object regardless of the context in which the function is ran. The code above will run just fine and log 0, 1, 2 and 3 when using the self version of &lt;code&gt;createMyObject()&lt;/code&gt;.</source>
          <target state="translated">Al utilizar el m&amp;eacute;todo self, garantiza que print siempre devolver&amp;aacute; el mismo objeto, independientemente del contexto en el que se ejecute la funci&amp;oacute;n. El c&amp;oacute;digo anterior se ejecutar&amp;aacute; bien y registrar&amp;aacute; 0, 1, 2 y 3 cuando use la versi&amp;oacute;n propia de &lt;code&gt;createMyObject()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb26bf00b13f18b06c15beeaa5f7dbab1d453031" translate="yes" xml:space="preserve">
          <source>Compare the following</source>
          <target state="translated">Compare lo siguiente</target>
        </trans-unit>
        <trans-unit id="50bf2c5b2bbbe0ff5a2a3490ab713dd2cf025fb2" translate="yes" xml:space="preserve">
          <source>Creating new function on your object literal and invoking a constructor seems a radical departure from the original problem, and it's unnecessary.</source>
          <target state="translated">Crear una nueva función en su objeto literalmente e invocar a un constructor parece una desviación radical del problema original,y es innecesario.</target>
        </trans-unit>
        <trans-unit id="455b7b22e4988bee5bcac315f59a6ea4faa1b993" translate="yes" xml:space="preserve">
          <source>Doesn't require any type of &lt;code&gt;init()&lt;/code&gt; or code outside of the object literal</source>
          <target state="translated">No requiere ning&amp;uacute;n tipo de &lt;code&gt;init()&lt;/code&gt; o c&amp;oacute;digo fuera del objeto literal</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="cdb0cba21e450ddf5b06bdddae32351284fc26bf" translate="yes" xml:space="preserve">
          <source>For completion, in ES6 we've got classes (supported at the time of writing this only by latest browsers, but available in Babel, TypeScript and other transpilers)</source>
          <target state="translated">Para completar,en ES6 tenemos clases (soportadas en el momento de escribir esto sólo por los últimos navegadores,pero disponibles en Babel,TypeScript y otros transpilers)</target>
        </trans-unit>
        <trans-unit id="1f3485295e4b1e7cb9ba6ceb99cf99e2f22625b6" translate="yes" xml:space="preserve">
          <source>For my needs, I have an object that relates to an array which will end up being used in a loop, so I only want to calculate some common setup once, so this is what I have:</source>
          <target state="translated">Para mis necesidades,tengo un objeto que se relaciona con un arreglo que terminará siendo usado en un bucle,así que sólo quiero calcular alguna configuración común una vez,así que esto es lo que tengo:</target>
        </trans-unit>
        <trans-unit id="8a968f08a7c89b288bbfb820f790e7ca3e2dfe3a" translate="yes" xml:space="preserve">
          <source>Here in this class, you can combine multiple relative path among themselves, which is not possible with an object literal.</source>
          <target state="translated">Aquí en esta clase,se pueden combinar múltiples caminos relativos entre sí,lo que no es posible con un objeto literal.</target>
        </trans-unit>
        <trans-unit id="9ec2d0d9acff7bf680bdf88207bb66f57686258a" translate="yes" xml:space="preserve">
          <source>Here were using class expressions to get the nested object literal interface we'd want. This is the next best thing IMHO to being able to reference the properties of an object during creation.</source>
          <target state="translated">Aquí estaban usando expresiones de clase para obtener la interfaz literal de objetos anidados que queríamos.Esta es la siguiente mejor cosa IMHO a ser capaz de hacer referencia a las propiedades de un objeto durante la creación.</target>
        </trans-unit>
        <trans-unit id="8b5dba4ec7f813bdfa99fd3ee3ddb8c39b942b06" translate="yes" xml:space="preserve">
          <source>Here's a neat ES6 way:</source>
          <target state="translated">Aquí hay una forma limpia de ES6:</target>
        </trans-unit>
        <trans-unit id="9f1f60c3c30838336fd75d367547b1473607a50e" translate="yes" xml:space="preserve">
          <source>How about this  solution this will work with nested objects with array as well</source>
          <target state="translated">¿Qué tal si esta solución funciona también con objetos anidados con arreglo a la matriz?</target>
        </trans-unit>
        <trans-unit id="babd7b153a8656e8062ec7e8ff2f28253d98fa70" translate="yes" xml:space="preserve">
          <source>I use it to do something like this:</source>
          <target state="translated">Lo uso para hacer algo como esto:</target>
        </trans-unit>
        <trans-unit id="0309037d02224ab0bf93448700cfbfc1c12b62a0" translate="yes" xml:space="preserve">
          <source>I use the following code as alternative, and it works. And the variable can be array too. (@ Fausto R.)</source>
          <target state="translated">Uso el siguiente código como alternativa,y funciona.Y la variable puede ser un array también.(@ Fausto R.)</target>
        </trans-unit>
        <trans-unit id="16dca6cc79c4f5e5242d75fa01475d6d022aa834" translate="yes" xml:space="preserve">
          <source>I wrote an npm library called &lt;a href=&quot;https://github.com/alex-e-leon/self-referenced-object&quot;&gt;self-referenced-object&lt;/a&gt; that supports that syntax and returns a native object.</source>
          <target state="translated">Escrib&amp;iacute; una biblioteca npm llamada &lt;a href=&quot;https://github.com/alex-e-leon/self-referenced-object&quot;&gt;self-referenced-object&lt;/a&gt; que admite esa sintaxis y devuelve un objeto nativo.</target>
        </trans-unit>
        <trans-unit id="942d2e5d80858faebc19574da73f010e668697b9" translate="yes" xml:space="preserve">
          <source>If you need it to all be within one expression, you can do that without the temporary property:</source>
          <target state="translated">Si necesitas que todo esté dentro de una expresión,puedes hacerlo sin la propiedad temporal:</target>
        </trans-unit>
        <trans-unit id="9f79c229c337f3d4133e35122de3eb8f6a1fb40c" translate="yes" xml:space="preserve">
          <source>If you want to use native JS, the other answers provide good solutions.</source>
          <target state="translated">Si quieres usar el JS nativo,las otras respuestas proporcionan buenas soluciones.</target>
        </trans-unit>
        <trans-unit id="abeee987c0eeb57bf07435bee075109d41c55371" translate="yes" xml:space="preserve">
          <source>If you would, instead, use &lt;code&gt;this&lt;/code&gt; as illustrated below</source>
          <target state="translated">Si, en cambio, usa &lt;code&gt;this&lt;/code&gt; como se ilustra a continuaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="8f30c71ebfff74ce20b6afb11d381929576a49ac" translate="yes" xml:space="preserve">
          <source>In the arrow getter &lt;code&gt;this&lt;/code&gt; picks up the &lt;a href=&quot;http://eddmann.com/posts/arrow-functions-lexical-this-scoping-in-javascript/&quot;&gt;surrounding lexical scope&lt;/a&gt;.</source>
          <target state="translated">En el captador de flecha, &lt;code&gt;this&lt;/code&gt; recoge el &lt;a href=&quot;http://eddmann.com/posts/arrow-functions-lexical-this-scoping-in-javascript/&quot;&gt;alcance l&amp;eacute;xico circundante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3afbac67183487dfd264526600b9d3d902060219" translate="yes" xml:space="preserve">
          <source>In the current form, this code obviously throws a reference error since &lt;code&gt;this&lt;/code&gt; doesn't refer to &lt;code&gt;foo&lt;/code&gt;. But &lt;em&gt;is&lt;/em&gt; there any way to have values in an object literal's properties depend on other properties declared earlier?</source>
          <target state="translated">En la forma actual, este c&amp;oacute;digo obviamente arroja un error de referencia ya que &lt;code&gt;this&lt;/code&gt; no se refiere a &lt;code&gt;foo&lt;/code&gt; . Pero, &lt;em&gt;&amp;iquest;&lt;/em&gt; hay alguna forma de hacer que los valores en las propiedades de un objeto literal dependan de otras propiedades declaradas anteriormente?</target>
        </trans-unit>
        <trans-unit id="10ee663ae9e4c2ca67534f7453bd385674db57fd" translate="yes" xml:space="preserve">
          <source>Is an object literal and not a factory function or other object creation mechanic.</source>
          <target state="translated">Es un objeto literal y no una función de fábrica u otra mecánica de creación de objetos.</target>
        </trans-unit>
        <trans-unit id="d590ed70ff180cdfc5b1afbe01261c62bedf45dc" translate="yes" xml:space="preserve">
          <source>Is there any way to get something like the following to work in JavaScript?</source>
          <target state="translated">¿Hay alguna manera de conseguir que algo como lo siguiente funcione en JavaScript?</target>
        </trans-unit>
        <trans-unit id="d415cc7379b6a73a30ccd8cbcec3af3a49572db8" translate="yes" xml:space="preserve">
          <source>It pollutes &lt;code&gt;window&lt;/code&gt; of course, but I can't imagine someone writing a script that requires &lt;code&gt;window.temp&lt;/code&gt; to be persistent. Maybe &lt;code&gt;tempMyApp&lt;/code&gt; if you're paranoid.</source>
          <target state="translated">Contamina la &lt;code&gt;window&lt;/code&gt; por supuesto, pero no puedo imaginar a alguien escribiendo un script que requiera que &lt;code&gt;window.temp&lt;/code&gt; sea ​​persistente. Quiz&amp;aacute;s &lt;code&gt;tempMyApp&lt;/code&gt; si eres paranoico.</target>
        </trans-unit>
        <trans-unit id="23f8724ebbe6007d7695b69e9d2a68f195f798c0" translate="yes" xml:space="preserve">
          <source>It's also ugly but occasionally useful. An example is when you are using an API with rigid initialization conditions and don't feel like refactoring so the scoping is correct.</source>
          <target state="translated">También es feo pero ocasionalmente útil.Un ejemplo es cuando se utiliza un API con condiciones de inicialización rígidas y no tiene ganas de refactorizar para que el alcance sea correcto.</target>
        </trans-unit>
        <trans-unit id="812c5a3a096f31351a3c82ab411d0732bb84371a" translate="yes" xml:space="preserve">
          <source>It's very, very &lt;strong&gt;important&lt;/strong&gt; to remember that if you refer to &lt;code&gt;this&lt;/code&gt; without first so doing, then &lt;code&gt;this&lt;/code&gt; will refer to the outer scope... which will be the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">Es muy, muy &lt;strong&gt;importante&lt;/strong&gt; recordar que si se refiere a &lt;code&gt;this&lt;/code&gt; sin hacerlo primero, &lt;code&gt;this&lt;/code&gt; se referir&amp;aacute; al alcance externo ... que ser&amp;aacute; el objeto de la &lt;code&gt;window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b40cc7fe18102f6190f71822b08395e64fa525c" translate="yes" xml:space="preserve">
          <source>Main thing to note is while using this solution, you have exact same interface as you'd have had from an object literal. And the syntax is pretty close to an object literal itself (vs using a function, etc).</source>
          <target state="translated">Lo principal a tener en cuenta es que al usar esta solución,tienes exactamente la misma interfaz que tendrías de un objeto literal.Y la sintaxis es bastante parecida a la de un objeto literal en sí mismo (frente a usar una función,etc.).</target>
        </trans-unit>
        <trans-unit id="dc93317f1b6677fdc696173a70ce76ecefc4d274" translate="yes" xml:space="preserve">
          <source>No. All of the solutions here defer it until after the object is created (in various ways) and then assign the third property. The &lt;em&gt;simplest&lt;/em&gt; way is to just do this:</source>
          <target state="translated">No. Todas las soluciones aqu&amp;iacute; difieren hasta que se crea el objeto (de varias maneras) y luego asignan la tercera propiedad. La forma &lt;em&gt;m&amp;aacute;s simple&lt;/em&gt; es simplemente hacer esto:</target>
        </trans-unit>
        <trans-unit id="84b4d548e5b1d60edecd62e40fd50d83f4005ed9" translate="yes" xml:space="preserve">
          <source>Note that you are actually assigning the return value of &lt;code&gt;init()&lt;/code&gt; to &lt;code&gt;foo&lt;/code&gt;, therefore you have to &lt;code&gt;return this&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que en realidad est&amp;aacute; asignando el valor de retorno de &lt;code&gt;init()&lt;/code&gt; a &lt;code&gt;foo&lt;/code&gt; , por lo tanto, debe &lt;code&gt;return this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="155f7d8311f9fb79d0d2caebf1b6d28d03b53f88" translate="yes" xml:space="preserve">
          <source>Now in ES6 you can create lazy cached properties. On first use the property evaluates once to become a normal static property. Result: The second time the math function overhead is skipped.</source>
          <target state="translated">Ahora en ES6 puedes crear propiedades de cacheo perezoso.En el primer uso,la propiedad se evalúa una vez para convertirse en una propiedad estática normal.Resultado:La segunda vez se salta la función matemática &quot;overhead&quot;.</target>
        </trans-unit>
        <trans-unit id="3c5ddabd0e1c7f49ec1c1ac90f8ae37b46f461bc" translate="yes" xml:space="preserve">
          <source>Or of course, if you need to do this more than once:</source>
          <target state="translated">O por supuesto,si necesitas hacer esto más de una vez:</target>
        </trans-unit>
        <trans-unit id="f5eb0218bc4ab3654619b0fb3e5bb942240cd001" translate="yes" xml:space="preserve">
          <source>Other approach would be to declare the object first before assigning properties into it:</source>
          <target state="translated">Otro enfoque sería declarar primero el objeto antes de asignarle propiedades:</target>
        </trans-unit>
        <trans-unit id="5d8e43c940bdd19cb5532d6cedc9d605ee5f692e" translate="yes" xml:space="preserve">
          <source>Self-references in object literals / initializers</source>
          <target state="translated">Las autorreferencias en los iniciadores de los literales de los objetos</target>
        </trans-unit>
        <trans-unit id="fca790723e99751ca1f1bc4e23d448189b146ab1" translate="yes" xml:space="preserve">
          <source>Sets the value at initialization (not a getter, or derived, etc)</source>
          <target state="translated">Establece el valor en la inicialización (no un getter,o derivado,etc.)</target>
        </trans-unit>
        <trans-unit id="57f087b9989e1f4123dbf53e152c97112c1d473e" translate="yes" xml:space="preserve">
          <source>Shouldn't have any performance impact (except at initialization)</source>
          <target state="translated">No debería tener ningún impacto en el rendimiento (excepto en la inicialización)</target>
        </trans-unit>
        <trans-unit id="5a7e2614943880b27c1df41e5568fc5bf5be54c6" translate="yes" xml:space="preserve">
          <source>Simply instantiate an anonymous function:</source>
          <target state="translated">Simplemente instale una función anónima:</target>
        </trans-unit>
        <trans-unit id="a482c165e6cb7e078ddbc63a32526271f7a49561" translate="yes" xml:space="preserve">
          <source>Since I need to set a property for &lt;code&gt;indexOfSelectedTier&lt;/code&gt; and I need to use that value when setting the &lt;code&gt;hasUpperTierSelection&lt;/code&gt; property, I calculate that value first and pass it in as a param to the IIFE</source>
          <target state="translated">Como necesito establecer una propiedad para &lt;code&gt;indexOfSelectedTier&lt;/code&gt; y necesito usar ese valor cuando configuro la propiedad &lt;code&gt;hasUpperTierSelection&lt;/code&gt; , calculo primero ese valor y lo paso como par&amp;aacute;metro al IIFE</target>
        </trans-unit>
        <trans-unit id="1ada23bdc87db08aaa20719e959ff820f75c1d00" translate="yes" xml:space="preserve">
          <source>Solution I've proposed</source>
          <target state="translated">La solución que he propuesto</target>
        </trans-unit>
        <trans-unit id="c782298d40f251ce5efba8475a45df7b59d6e6f4" translate="yes" xml:space="preserve">
          <source>Solution if object literals would've sufficed</source>
          <target state="translated">La solución si los literales de los objetos hubieran sido suficientes</target>
        </trans-unit>
        <trans-unit id="62c942cb061d5d573002b3f10f2dd414875a9451" translate="yes" xml:space="preserve">
          <source>Some closure should deal with this;</source>
          <target state="translated">Algún cierre debería lidiar con esto;</target>
        </trans-unit>
        <trans-unit id="1c10701de3d549b74de32d75bb721fe76fe23ffe" translate="yes" xml:space="preserve">
          <source>That method has proven useful to me when I had to refer to the object that a function was originally declared on. The following is a minimal example of how I used it:</source>
          <target state="translated">Ese método me ha resultado útil cuando he tenido que referirme al objeto sobre el que se declaró originalmente una función.El siguiente es un ejemplo mínimo de cómo lo usé:</target>
        </trans-unit>
        <trans-unit id="19e20cb9164b0d0a783a114136e5dc51873d9ad8" translate="yes" xml:space="preserve">
          <source>The function is then executed at the end with the &lt;code&gt;()&lt;/code&gt; which causes the entire foo object to be evaluated, all the variables within instantiated and the return object added as properties of &lt;code&gt;foo()&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n se ejecuta al final con &lt;code&gt;()&lt;/code&gt; lo que hace que se eval&amp;uacute;e todo el objeto foo, todas las variables dentro de las instancias y el objeto de retorno agregado como propiedades de &lt;code&gt;foo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14ebed8ae4974932378aaabde3a364d853a6c1a4" translate="yes" xml:space="preserve">
          <source>The key to all this is &lt;strong&gt;SCOPE&lt;/strong&gt;.</source>
          <target state="translated">La clave de todo esto es &lt;strong&gt;ALCANCE&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="be0bfcb8df074688f6c27c382d5ab77ccf97d8e7" translate="yes" xml:space="preserve">
          <source>The magic is in the getter.</source>
          <target state="translated">La magia está en el recipiente.</target>
        </trans-unit>
        <trans-unit id="aecb727f3ad85ed2a827155f93eee4cdade53c16" translate="yes" xml:space="preserve">
          <source>The obvious, simple answer is missing, so for completeness:</source>
          <target state="translated">Falta la respuesta obvia y simple,así que para completar:</target>
        </trans-unit>
        <trans-unit id="240fb8682b72da8d2e15a3e267c25d80fd7965c7" translate="yes" xml:space="preserve">
          <source>The order is &lt;a href=&quot;https://stackoverflow.com/a/17438220/728393&quot;&gt;guaranteed&lt;/a&gt; (&lt;code&gt;bar&lt;/code&gt; before &lt;code&gt;baz&lt;/code&gt;).</source>
          <target state="translated">El pedido est&amp;aacute; &lt;a href=&quot;https://stackoverflow.com/a/17438220/728393&quot;&gt;garantizado&lt;/a&gt; ( &lt;code&gt;bar&lt;/code&gt; ra antes de &lt;code&gt;baz&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a083113ba4f644ed462a47363ea68427607ce0dc" translate="yes" xml:space="preserve">
          <source>The other answers posted here are better but here's an alternative that:</source>
          <target state="translated">Las otras respuestas publicadas aquí son mejores pero aquí hay una alternativa que:</target>
        </trans-unit>
        <trans-unit id="1be4015d04d94304a9c1129d49a1dbf1389d6018" translate="yes" xml:space="preserve">
          <source>The simplest solution for computed properties follows (no heap, no functions, no constructor):</source>
          <target state="translated">Sigue la solución más simple para las propiedades calculadas (sin montón,sin funciones,sin constructor):</target>
        </trans-unit>
        <trans-unit id="95e4cca4a7c8d05cad1ebd4c2e5f382197391257" translate="yes" xml:space="preserve">
          <source>Then the following code will log 0, 1, 2 and then give an error</source>
          <target state="translated">Entonces el siguiente código registrará 0,1,2 y luego dará un error</target>
        </trans-unit>
        <trans-unit id="3a2d4d9f4924a6aff35e96ab71cd9cf066c5e108" translate="yes" xml:space="preserve">
          <source>There are several ways to accomplish this; this is what I would use:</source>
          <target state="translated">Hay varias maneras de lograr esto;esto es lo que yo usaría:</target>
        </trans-unit>
        <trans-unit id="4eeeeb9a258073df9b0bfb718852decef5fa294f" translate="yes" xml:space="preserve">
          <source>This is a syntactic extension introduced by the ECMAScript 5th Edition Specification, the syntax is supported by most modern browsers (including IE9).</source>
          <target state="translated">Esta es una extensión sintáctica introducida por la Especificación de la 5ª Edición de ECMAScript,la sintaxis es soportada por la mayoría de los navegadores modernos (incluyendo IE9).</target>
        </trans-unit>
        <trans-unit id="0f92f2b118a843ab9880da9f8314284aabdfac9d" translate="yes" xml:space="preserve">
          <source>This is almost identical to @slicedtoad's answer, but doesn't use a function.</source>
          <target state="translated">Esto es casi idéntico a la respuesta de @slicedtoad,pero no usa una función.</target>
        </trans-unit>
        <trans-unit id="32a94e2e2503049174642659d0ec7926adf1285c" translate="yes" xml:space="preserve">
          <source>This would be some kind of one time initialization of the object.</source>
          <target state="translated">Esto sería una especie de inicialización única del objeto.</target>
        </trans-unit>
        <trans-unit id="9ebec4a239492a8436ba877b518dcf220654fb91" translate="yes" xml:space="preserve">
          <source>Throwing in an option since I didn't see this exact scenario covered.  If you &lt;em&gt;don't&lt;/em&gt; want &lt;code&gt;c&lt;/code&gt; updated when &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; update, then an ES6 IIFE works well.</source>
          <target state="translated">Lanzar una opci&amp;oacute;n ya que no vi este escenario exacto cubierto. Si &lt;em&gt;no&lt;/em&gt; desea actualizar &lt;code&gt;c&lt;/code&gt; cuando se actualiza &lt;code&gt;b&lt;/code&gt; , entonces un ES6 IIFE funciona bien.</target>
        </trans-unit>
        <trans-unit id="1fbf4e1cbb018e88ddfd19f4af4935c5d6650cb5" translate="yes" xml:space="preserve">
          <source>Well, the only thing that I can tell you about are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;getter&lt;/a&gt;:</source>
          <target state="translated">Bueno, lo &amp;uacute;nico de lo que puedo hablar es &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&quot;&gt;getter&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="89f02d99000cfdd02a61d533b0a00fe24810857f" translate="yes" xml:space="preserve">
          <source>With that, you can use the object variable name to access the already assigned values.</source>
          <target state="translated">Con eso,puedes usar el nombre de la variable objeto para acceder a los valores ya asignados.</target>
        </trans-unit>
        <trans-unit id="29fcff212f0dd19af315366ba19f89316bce3995" translate="yes" xml:space="preserve">
          <source>With this pattern you can instantiate several foo objects according to your need.</source>
          <target state="translated">Con este patrón puedes instanciar varios objetos foo de acuerdo a tu necesidad.</target>
        </trans-unit>
        <trans-unit id="fdcf280b6b2994732c06f6bc2d7996502fa52f90" translate="yes" xml:space="preserve">
          <source>You can do it using the module pattern. Just like:</source>
          <target state="translated">Puedes hacerlo usando el patrón del módulo.Al igual que:</target>
        </trans-unit>
        <trans-unit id="45cee98b956ac337a8937b66a7b732b18cf4f833" translate="yes" xml:space="preserve">
          <source>You cannot reference a sibling property during object literal initialization.</source>
          <target state="translated">No se puede hacer referencia a una propiedad de un hermano durante la inicialización literal del objeto.</target>
        </trans-unit>
        <trans-unit id="be9169cb2216e3ca1720e49bc5ab1d173e14d482" translate="yes" xml:space="preserve">
          <source>You could do it like this</source>
          <target state="translated">Podrías hacerlo así</target>
        </trans-unit>
        <trans-unit id="2ea2cb9d80edd838a8c30cbb3eb156086fb4852c" translate="yes" xml:space="preserve">
          <source>You could do something like:</source>
          <target state="translated">Podrías hacer algo como:</target>
        </trans-unit>
        <trans-unit id="d0256d452b2d0368a6725c64ac4bccc6646f0dce" translate="yes" xml:space="preserve">
          <source>You need to encapsulate the &quot;parent&quot; (parent object) of the property you want to define as it's own instantiated object, and then you can make references to sibling properties using the key word &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">Debe encapsular el &quot;padre&quot; (objeto padre) de la propiedad que desea definir como su propio objeto instanciado, y luego puede hacer referencias a las propiedades hermanas utilizando la palabra clave &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="511fba73f4d0c0d156bb1f407eeea34408de463c" translate="yes" xml:space="preserve">
          <source>if your object is written as a function which returns an object, AND you use ES6 object-attribute 'methods', then it's possible:</source>
          <target state="translated">si tu objeto se escribe como una función que devuelve un objeto,Y utilizas los 'métodos' de atributo de objeto ES6,entonces es posible:</target>
        </trans-unit>
        <trans-unit id="ddd0714cab8fe6bc438dcd95c35fb549a65e1dc5" translate="yes" xml:space="preserve">
          <source>just for the sake of thought - place object's properties out of a timeline:</source>
          <target state="translated">sólo por el bien del pensamiento-colocar las propiedades del objeto fuera de una línea de tiempo:</target>
        </trans-unit>
        <trans-unit id="c7c3b1f8e8a34c26eeb341990a13fcb444306252" translate="yes" xml:space="preserve">
          <source>then where you need to use it:</source>
          <target state="translated">...y luego donde necesitas usarla:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
