<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4685450">
    <body>
      <group id="4685450">
        <trans-unit id="83ca03fe1d75fd5700c66a6a6778846449f04e8a" translate="yes" xml:space="preserve">
          <source>(1/3) means Integer division, thats why you can not get decimal value from this division. To solve this problem use:</source>
          <target state="translated">(13)表示整数除法,这就是为什么你不能从这个除法中得到十进制值的原因。为了解决这个问题,请使用</target>
        </trans-unit>
        <trans-unit id="13c829a0c029b2c71efa88015d62a1dd72a6c964" translate="yes" xml:space="preserve">
          <source>1 and 3 are integer contants and so Java does an integer division which's result is 0. If you want to write double constants you have to write &lt;code&gt;1.0&lt;/code&gt; and &lt;code&gt;3.0&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1和3是整数竞争者，因此Java进行整数除法，结果为0。如果要编写双精度常量，则必须编写&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1.0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;3.0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8df4aafa92d4d5d1c73fa0da94152dd40999b4f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1/3&lt;/code&gt; uses integer division as both sides are integers.</source>
          <target state="translated">&lt;code&gt;1/3&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用整数除法，因为两边都是整数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="baaa2c0e143279b27b6dacba2736c772a9f50631" translate="yes" xml:space="preserve">
          <source>A simple working example is enough to prove this</source>
          <target state="translated">一个简单的工作实例就足以证明这一点</target>
        </trans-unit>
        <trans-unit id="1a4542f0a184a792bac13618252f332080fe9d26" translate="yes" xml:space="preserve">
          <source>A small example using Eclipse to show that even an addition of two &lt;code&gt;short&lt;/code&gt;s will not be that easy :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个使用Eclipse的小例子表明，即使加上两个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;short&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也不容易：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c3e4ecd4d1599993fa5cfb874445271c0d3b1d1" translate="yes" xml:space="preserve">
          <source>Also, note that if &lt;em&gt;both&lt;/em&gt; operands (numbers) are given as floats; 3.0 and 1.0, or even just the &lt;em&gt;first&lt;/em&gt;, then floating-point arithmetic is used, giving you &lt;code&gt;0.333...&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另外，请注意，如果&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两个&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;操作数（数字）均以浮点数给出；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3.0和1.0，甚至只是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一个&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，那么浮点运算时，给你&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.333...&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1143ef123ba581b8c839b0f8b8144caa503a97d8" translate="yes" xml:space="preserve">
          <source>An operation on only integers casts the result of the operation to an integer.</source>
          <target state="translated">只对整数进行操作,将操作的结果变成整数。</target>
        </trans-unit>
        <trans-unit id="9223e3823771b04837acdd363cbe975ad8fe3823" translate="yes" xml:space="preserve">
          <source>And an example is always the best way to translate the JLS ;)</source>
          <target state="translated">而一个例子永远是翻译JLS的最好方法;)</target>
        </trans-unit>
        <trans-unit id="22e5f7c582f7be1e686b0e2be36e78dd98f3c769" translate="yes" xml:space="preserve">
          <source>And the mix of both integer and floating value result in floating values as said</source>
          <target state="translated">而整数值和浮动值的混合,会导致浮动值,正如所说的那样</target>
        </trans-unit>
        <trans-unit id="bcbbefc3b17aaa55178f2b37a98feaf58eeb1f57" translate="yes" xml:space="preserve">
          <source>As @Noldorin says, if both operators are integers, then integer division is used.</source>
          <target state="translated">正如@Noldorin所说,如果两个算子都是整数,那么就用整数除法。</target>
        </trans-unit>
        <trans-unit id="5ca4b084d70132b40628c1a9143cfa7ea2dedfd9" translate="yes" xml:space="preserve">
          <source>Because it treats 1 and 3 as integers, therefore rounding the result down to 0, so that it is an integer.</source>
          <target state="translated">因为它把1和3看作是整数,所以把结果四舍五入到0,所以是整数。</target>
        </trans-unit>
        <trans-unit id="bb74650a926444040d1c9d20cd4a5500051c1a91" translate="yes" xml:space="preserve">
          <source>Because you are doing integer division.</source>
          <target state="translated">因为你在做整数除法。</target>
        </trans-unit>
        <trans-unit id="7d9db168fd46b5f8fe90b3a22923d78c7f00525d" translate="yes" xml:space="preserve">
          <source>Do &quot;double g=1.0/3.0;&quot; instead.</source>
          <target state="translated">用 &quot;双G=1.03.0;&quot;来代替。</target>
        </trans-unit>
        <trans-unit id="0d60db3234e5f1f5bedd14078c53a9cc2b4916fd" translate="yes" xml:space="preserve">
          <source>Explicitly cast it as a &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;明确将其转换为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9649ad598ebdf718b10a574595a9779f4122280f" translate="yes" xml:space="preserve">
          <source>I was writing this code:</source>
          <target state="translated">我在写这段代码。</target>
        </trans-unit>
        <trans-unit id="02acf376ecf4e8a1e8780ab95e6458f91b302cb3" translate="yes" xml:space="preserve">
          <source>If an integer operator other than a shift operator has at least one operand of type long, then the operation is carried out using 64-bit precision, and the result of the numerical operator is of type long. If the other operand is not long, it is first widened (&amp;sect;5.1.5) to type long by numeric promotion (&amp;sect;5.6).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果除移位运算符外的整数运算符至少具有一个long类型的操作数，则使用64位精度执行该运算，并且数值运算符的结果为long类型。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果另一个操作数不长，则首先将其扩展（第5.1.5节）以通过数字提升（第5.6节）键入long。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6659ebd94fd13557758032fd513924ea95c18d19" translate="yes" xml:space="preserve">
          <source>If any of the operators is a &lt;code&gt;double&lt;/code&gt; / &lt;code&gt;float&lt;/code&gt;, then floating point arithmetic will take place. But you'll have the same problem if you do that:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果任何一个运算符是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; / &lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，那么将进行浮点运算。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果这样做，您将遇到同样的问题：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a44e7cf64c00b99c313e2186a2ad12f9d35c1859" translate="yes" xml:space="preserve">
          <source>If at least one of the operands to a binary operator is of floating-point type, then the operation is a floating-point operation, even if the other is integral.</source>
          <target state="translated">如果一个二进制运算符的至少一个操作数是浮点类型的,那么该操作就是浮点运算,即使另一个是积分运算。</target>
        </trans-unit>
        <trans-unit id="1912977f1a23feb378ee1cc1c4f7b85f1b3154cc" translate="yes" xml:space="preserve">
          <source>If at least one of the operands to a numerical operator is of type double, then the operation is carried out using 64-bit floating-point arithmetic, and the result of the numerical operator is a value of type double. If the other operand is not a double, it is first widened (&amp;sect;5.1.5) to type double by numeric promotion (&amp;sect;5.6).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果数字运算符的至少一个操作数是double类型的，则使用64位浮点算术执行该运算，并且数字运算符的结果是double类型的值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果另一个操作数不是双精度数，则首先将其扩展（第5.1.5节）以通过数字提升（第5.6节）键入double。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac207176f1ec0d1ea3289e36c937789f122ab63a" translate="yes" xml:space="preserve">
          <source>If you are entering the values in the source code like your question, you can do &lt;code&gt;1.0/3&lt;/code&gt; ; the &lt;code&gt;1.0&lt;/code&gt; is a double.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果要在源代码中输入类似问题的值，则可以执行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1.0/3&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1.0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是双。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2b525e811bebced061ac54941549a25c265305b1" translate="yes" xml:space="preserve">
          <source>If you get the values from elsewhere you can use &lt;code&gt;(double)&lt;/code&gt; to turn the &lt;code&gt;int&lt;/code&gt; into a &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果从其他位置获取值，则可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(double)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c10a02c5e562f1743931b0cd366509bbf63d02ab" translate="yes" xml:space="preserve">
          <source>Int division: Why is the result of 1/3 == 0</source>
          <target state="translated">因数除法。为什么结果是13===0</target>
        </trans-unit>
        <trans-unit id="ca04b4f1a8e2cc2530097763117db9931074bfbf" translate="yes" xml:space="preserve">
          <source>Integer division of course returns the true result of division rounded towards zero. The result of &lt;code&gt;0.333...&lt;/code&gt; is thus rounded down to 0 here. (Note that the processor doesn't actually do any rounding, but you can think of it that way still.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，整数除法会返回除法四舍五入的真实结果。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此处&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.333...&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的结果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;四舍五入为0。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（请注意，处理器实际上不进行任何舍入，但是您仍然可以这样考虑。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6056d6e76d06d0b7afb26f897c2aea54bbf5f4d5" translate="yes" xml:space="preserve">
          <source>Integer division returns integer.</source>
          <target state="translated">整数除法返回整数。</target>
        </trans-unit>
        <trans-unit id="d70689be0d673ab3445c0f4feac5357d190a49ce" translate="yes" xml:space="preserve">
          <source>It varies on the implementation of the language, but Wikipedia has a fairly comprehensive view, and it does talk about &lt;em&gt;coercion&lt;/em&gt; as well, which is a pivotal piece of information in answering your question.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它在语言的实现上有所不同，但是Wikipedia具有相当全面的观点，并且也谈到了&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;强制性&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这是回答问题的关键信息。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7ea08ecb3ff21245e7bb142ddbf5ff505c088de3" translate="yes" xml:space="preserve">
          <source>Make the 1 a float and float division will be used</source>
          <target state="translated">使1成为浮动和浮动除法将被使用。</target>
        </trans-unit>
        <trans-unit id="2fe180da70dacdf0d443850765aa127e70804db5" translate="yes" xml:space="preserve">
          <source>Many others have failed to point out the real issue:</source>
          <target state="translated">其他许多人都没有指出真正的问题。</target>
        </trans-unit>
        <trans-unit id="ce6de639a624113b95619c443727d5aea0411e5c" translate="yes" xml:space="preserve">
          <source>Otherwise, the operation is carried out using 32-bit precision, and the result of the numerical operator is of type int. If either operand is not an int, it is first widened to type int by numeric promotion.</source>
          <target state="translated">否则,使用32位精度进行操作,数值运算器的结果为类型为int。如果任何一个操作项都不是int,则首先通过数值运算器的推广将其拓宽为int类型。</target>
        </trans-unit>
        <trans-unit id="2ba0e99615b1c2f1613afb960553161ad439c871" translate="yes" xml:space="preserve">
          <source>Since both 1 and 3 are ints the result not rounded but it's truncated. So you ignore fractions and take only wholes.</source>
          <target state="translated">因为1和3都是ints,所以结果不是四舍五入,而是被截断了。所以你可以不考虑分数,只取整数。</target>
        </trans-unit>
        <trans-unit id="26ee0116802893428267b1411cf5865b29204217" translate="yes" xml:space="preserve">
          <source>So the promotion is done on the float into double.</source>
          <target state="translated">所以,推广是在浮动成双上完成的。</target>
        </trans-unit>
        <trans-unit id="11f08e7c2d459a55e571efc95d1c2edf5a5b6b75" translate="yes" xml:space="preserve">
          <source>The conversion in JAVA is quite simple but need some understanding. As explain in the JLS for &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.2&quot;&gt;integer operations&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JAVA中的转换非常简单，但是需要一些理解。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如JLS中关于&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;整数运算的说明&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aba50470714af541b304d1e5e82c1355529b6d65" translate="yes" xml:space="preserve">
          <source>The easiest solution is to just do this</source>
          <target state="translated">最简单的解决办法是这样做</target>
        </trans-unit>
        <trans-unit id="3090daf4ca83afab5f975a1f7e0eb26344ed3e8a" translate="yes" xml:space="preserve">
          <source>The reason is that there is an implicit cast done here, this will be execute like</source>
          <target state="translated">原因是这里有一个隐式投币的操作,这将会像</target>
        </trans-unit>
        <trans-unit id="3427b7fbcbd6e06e628aa69019da17abe74c0e38" translate="yes" xml:space="preserve">
          <source>The result 0.33333333 can't be represented as an integer, therefore only the integer part (0) is assigned to the result.</source>
          <target state="translated">结果0.33333333不能表示为整数,因此只给结果分配了整数部分(0)。</target>
        </trans-unit>
        <trans-unit id="3065fa5b0532d0e7ef52e52c4209f5ac5df04424" translate="yes" xml:space="preserve">
          <source>The result is 0.  Why is this, and how do I solve this problem?</source>
          <target state="translated">结果是0,为什么会这样,如何解决这个问题?</target>
        </trans-unit>
        <trans-unit id="4e64f426b0b16a2a23db646072e12487dbf88850" translate="yes" xml:space="preserve">
          <source>The same is true for the &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.4&quot;&gt;floating point operators&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.4&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮点运算符&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也是如此&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="420cc97c08d9c438f98e694692133d3478355dad" translate="yes" xml:space="preserve">
          <source>The two operands (1 and 3) are integers, therefore integer arithmetic (division here) is used. Declaring the result variable as double just causes an implicit conversion to occur &lt;em&gt;after division&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两个操作数（1和3）是整数，因此使用整数算术（此处为除法）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将结果变量声明为double只会导致&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除法后&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;发生隐式转换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="803de18271304fb6e19ec706acf7f3de52210ee6" translate="yes" xml:space="preserve">
          <source>This happens because Java uses the integer division operation for &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; since you entered them as integer constants.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;发生这种情况是因为Java将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;3&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用作整数常数，因为它们&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用整数除法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee937d585a122ea68cde4973bc7f6ef2a27e1adf" translate="yes" xml:space="preserve">
          <source>This is true for binary operators but not for &quot;Assignment Operators&quot; like &lt;code&gt;+=&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于二进制运算符，这是正确的，但对于&lt;/font&gt; &lt;code&gt;+=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样的&amp;ldquo;赋值运算符&amp;rdquo;，则不是这样&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ecc9f98093e956f83e2ab0b3748d0c4f56c49e99" translate="yes" xml:space="preserve">
          <source>This necessarily means that floating point results, that &lt;em&gt;could&lt;/em&gt; be displayed as an integer, will be truncated (lop off the decimal part).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这必然意味着浮点结果（&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显示为整数）将被截断（舍去小数部分）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7f08a97169145dbed19b0b2891d63008699f7f5e" translate="yes" xml:space="preserve">
          <source>This will required a casting with a possible loss of precision.</source>
          <target state="translated">这将需要一个可能失去精度的铸造。</target>
        </trans-unit>
        <trans-unit id="0d8c4f27b990643d95d356ded253b0a6acce4258" translate="yes" xml:space="preserve">
          <source>To avoid this have at least one of your numbers 1 or 3 as a decimal form 1.0 and/or 3.0.</source>
          <target state="translated">为了避免这种情况,至少有一个数字1或3作为小数形式1.0或3.0。</target>
        </trans-unit>
        <trans-unit id="c6f5e7a4d7efd21c714c2f91db7d03636dc2b386" translate="yes" xml:space="preserve">
          <source>To get the result you are looking for, explicitly tell java that the numbers are doubles like so:</source>
          <target state="translated">为了得到你要找的结果,明确告诉java,数字是双数,就像这样。</target>
        </trans-unit>
        <trans-unit id="200267f03d21574410e2a83bbc223379c81ffdc5" translate="yes" xml:space="preserve">
          <source>Try this out:</source>
          <target state="translated">试试这个。</target>
        </trans-unit>
        <trans-unit id="3d561848dfb0d7f3352a95784b002f858486f82d" translate="yes" xml:space="preserve">
          <source>What is &lt;em&gt;casting&lt;/em&gt; (typecasting / type conversion) you ask?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您要求的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（类型转换/类型转换）？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="055d69208ae9f5b6064381d001547001c72d24f4" translate="yes" xml:space="preserve">
          <source>What this does, since you didn't enter 1.0 / 3.0, is let you manually convert it to data type double since Java assumed it was Integer division, and it would do it even if it meant narrowing the conversion. This is what is called a cast operator.</source>
          <target state="translated">这个东西的作用,因为你没有输入1.0 3.0,所以它的作用是让你手动转换为数据类型为双倍,因为Java假设它是整数除法,即使是缩小转换范围,它也会这样做。这就是所谓的 cast 运算子。</target>
        </trans-unit>
        <trans-unit id="a730dbf200cd4355694ac1815494422c542fbc30" translate="yes" xml:space="preserve">
          <source>You need at least one of them to be &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您至少需要其中之一为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="ebd9deca7a1dfee62f7034faa7be6bb751eaf571" translate="yes" xml:space="preserve">
          <source>you should use</source>
          <target state="translated">你应该用</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
