<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/46155">
    <body>
      <group id="46155">
        <trans-unit id="c9900fcc65e0be104350f210414eee5f116eb87e" translate="yes" xml:space="preserve">
          <source>(...) We get a more practical implementation of RFC 2822 if we omit the syntax using double quotes and square brackets. &lt;strong&gt;It will still match 99.99% of all email addresses in actual use today.&lt;/strong&gt;</source>
          <target state="translated">큰 따옴표와 대괄호를 사용하여 구문을 생략하면 RFC 2822를보다 실용적으로 구현할 수 있습니다. &lt;strong&gt;현재 실제 사용중인 모든 이메일 주소의 99.99 %와 일치합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3b5d01380b8c1dcd1ad280a061ed69f2c78d5f4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsfiddle.net/edwinthomas25/z6wev5L0/&quot;&gt;jsFiddle&lt;/a&gt; link</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/edwinthomas25/z6wev5L0/&quot;&gt;jsFiddle&lt;/a&gt; 링크</target>
        </trans-unit>
        <trans-unit id="4f7e3850e125c7d3d2a1bbc2bf2b4ebdd7602be0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Email_address#Examples&quot;&gt;https://en.wikipedia.org/wiki/Email_address#Examples&lt;/a&gt;&lt;a href=&quot;https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte&quot;&gt;https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Email_address#Examples&quot;&gt;https://en.wikipedia.org/wiki/Email_address#Examples&lt;/a&gt;&lt;a href=&quot;https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte&quot;&gt;https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94e288bc4d1208f43d25800c6e81d3a8aaa47e2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(str.length - lastDotPos) &amp;gt; 2&lt;/code&gt;: There should be enough characters after the last dot to form a two-character domain. I'm not sure if the brackets are necessary.</source>
          <target state="translated">&lt;code&gt;(str.length - lastDotPos) &amp;gt; 2&lt;/code&gt; : 마지막 점 뒤에 두 문자 도메인을 형성하기에 충분한 문자가 있어야합니다. 괄호가 필요한지 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7c111c87df1234659dafe02d39a5fdee62a97df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastAtPos &amp;gt; 0&lt;/code&gt;: There should be something (the email username) before the last &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lastAtPos &amp;gt; 0&lt;/code&gt; : 마지막 &lt;code&gt;@&lt;/code&gt; 앞에 무언가 (이메일 사용자 이름)가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="55cff3e34b43920049bec68d26cb1f95f215d6a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastAtPos &amp;lt; lastDotPos&lt;/code&gt;: Last &lt;code&gt;@&lt;/code&gt; should be before last &lt;code&gt;.&lt;/code&gt; since &lt;code&gt;@&lt;/code&gt; cannot be part of server name (as far as I know).</source>
          <target state="translated">&lt;code&gt;lastAtPos &amp;lt; lastDotPos&lt;/code&gt; : Last &lt;code&gt;@&lt;/code&gt; 는 last 앞에 있어야합니다 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;@&lt;/code&gt; 는 서버 이름의 일부가 될 수 없기 때문에 (내가 아는 한).</target>
        </trans-unit>
        <trans-unit id="490240bf90511707d51003d6b0ecd29b5fd5debb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastDotPos &amp;gt; 2&lt;/code&gt;: There should be at least three characters before the last dot, for example &lt;code&gt;a@b.com&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lastDotPos &amp;gt; 2&lt;/code&gt; : 마지막 점 앞에 3 자 이상이 있어야합니다 (예 : &lt;code&gt;a@b.com&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="e95ecb104fc6f6f4f0c446d297e10333260e7b04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;str.indexOf('@@') == -1&lt;/code&gt;: There should be no &lt;code&gt;@@&lt;/code&gt; in the address. Even if &lt;code&gt;@&lt;/code&gt; appears as the last character in email username, it has to be quoted so &lt;code&gt;&quot;&lt;/code&gt; would be between that &lt;code&gt;@&lt;/code&gt; and the last &lt;code&gt;@&lt;/code&gt; in the address.</source>
          <target state="translated">&lt;code&gt;str.indexOf('@@') == -1&lt;/code&gt; : 주소에 &lt;code&gt;@@&lt;/code&gt; 가 없어야합니다. &lt;code&gt;@&lt;/code&gt; 가 이메일 사용자 이름의 마지막 문자로 표시 되더라도 인용 부호를 붙여야합니다. &lt;code&gt;&quot;&lt;/code&gt; 는 주소에서 &lt;code&gt;@&lt;/code&gt; 와 마지막 &lt;code&gt;@&lt;/code&gt; 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2f448975c7d7ce0ade29f009045a250ffef3285" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1- Validation of email format:&lt;/strong&gt; Making sure if the email complies with the format and pattern of emails in RFC 5322 and if the TLD actually exists. A list of all valid TLDs can be found &lt;a href=&quot;http://data.iana.org/TLD/tlds-alpha-by-domain.txt&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;1- 이메일 형식&lt;/strong&gt; 확인 &lt;strong&gt;:&lt;/strong&gt; 이메일이 RFC 5322의 이메일 형식 및 패턴을 준수하는지 그리고 TLD가 실제로 존재하는지 확인하십시오. 유효한 모든 TLD 목록은 &lt;a href=&quot;http://data.iana.org/TLD/tlds-alpha-by-domain.txt&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72aebd76d57cb550e303461fb57ba140a793cfc6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2- Making sure the email actually exists:&lt;/strong&gt; For doing this, &lt;strong&gt;the only option&lt;/strong&gt; is &lt;a href=&quot;https://davidcel.is/posts/stop-validating-email-addresses-with-regex/#just-send-them-an-email-already&quot;&gt;to send the users an email&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;2- 이메일이 실제로 존재하는지 확인 :&lt;/strong&gt; 이를 &lt;strong&gt;위해 유일한 옵션&lt;/strong&gt; 은 &lt;a href=&quot;https://davidcel.is/posts/stop-validating-email-addresses-with-regex/#just-send-them-an-email-already&quot;&gt;사용자에게 이메일을 보내는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="abd92687b99044b4eddf773d671c4667439b4622" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="f633af6eb48c9e0b8af0d18976d74129ba756046" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Show this test : &lt;a href=&quot;https://regex101.com/r/LHJ9gU/1&quot;&gt;https://regex101.com/r/LHJ9gU/1&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 테스트를 보여주십시오 : &lt;a href=&quot;https://regex101.com/r/LHJ9gU/1&quot;&gt;https://regex101.com/r/LHJ9gU/1&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2d5ce6846b7eb2409986c51bc4a515382a776cc6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wikipedia standard mail syntax :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;위키 백과 표준 메일 구문 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="297c8518f856cbda751268ce424749e63f0c28d1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Emphasis mine&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;강조 광산&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="8fe50eb48ca2b3e732cca1bc24539853528194c5" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;valid e-mail address&lt;/strong&gt; is a string that matches the &lt;code&gt;email&lt;/code&gt; production of the following ABNF, the character set for which is Unicode.</source>
          <target state="translated">&lt;strong&gt;유효한 전자 우편 주소&lt;/strong&gt; 는 다음 ABNF의 &lt;code&gt;email&lt;/code&gt; 생성과 일치하는 문자열이며, 문자 세트는 유니 코드입니다.</target>
        </trans-unit>
        <trans-unit id="d8812909686aedb08074742b5f572064a6720486" translate="yes" xml:space="preserve">
          <source>A further change you could make is to allow any two-letter country code top level domain, and only specific generic top level domains. &lt;strong&gt;This regex filters dummy email addresses like &lt;code&gt;asdf@adsf.adsf&lt;/code&gt;&lt;/strong&gt;. You &lt;strong&gt;will need to update it as new top-level domains are added&lt;/strong&gt;.</source>
          <target state="translated">추가로 변경할 수있는 부분은 2 자리 국가 코드 최상위 도메인과 특정 일반 최상위 도메인 만 허용하는 것입니다. &lt;strong&gt;이 정규식은 &lt;code&gt;asdf@adsf.adsf&lt;/code&gt; 와 같은 더미 이메일 주소를 필터링합니다&lt;/strong&gt; . &lt;strong&gt;새로운 최상위 도메인이 추가되면 업데이트해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7923e3b47cb736d7dab4697baaade704b4e85a49" translate="yes" xml:space="preserve">
          <source>A good practice is to validate your data on the client, but double-check the validation on the server. With this in mind, you can simply check whether a string looks like a valid email address on the client and perform the strict check on the server.</source>
          <target state="translated">클라이언트에서 데이터의 유효성을 검사하지만 서버에서 유효성을 다시 확인하는 것이 좋습니다. 이를 염두에두고 문자열이 클라이언트에서 유효한 전자 메일 주소처럼 보이는지 확인하고 서버에서 엄격한 검사를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2671ec3f0126e4d02b72ab3a1bade3235b1b574" translate="yes" xml:space="preserve">
          <source>A solution that does not check the existence of the TLD is incomplete.</source>
          <target state="translated">TLD의 존재를 확인하지 않는 솔루션이 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="2645882e0c71d880bc16972169f19a2b50019df8" translate="yes" xml:space="preserve">
          <source>All email addresses contain an 'at' (i.e. @) symbol. Test that necessary condition:</source>
          <target state="translated">모든 이메일 주소에는 'at'(예 : @) 기호가 있습니다. 필요한 조건을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="3ba11e47b63968b8537457a8e7dcb585e385cc7c" translate="yes" xml:space="preserve">
          <source>Almost all answers to this questions suggest using Regex to validate emails addresses. I think Regex is only good for a rudimentary validation. It seems that the checking validation of email addresses is actually two separate problems:</source>
          <target state="translated">이 질문에 대한 거의 모든 답변은 Regex를 사용하여 이메일 주소를 확인하는 것이 좋습니다. Regex는 기본적인 검증에만 적합하다고 생각합니다. 이메일 주소의 확인 확인은 실제로 두 가지 별도의 문제인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e1a0cf7cfe603c9a4a7d9df75f3f7cc159c581a" translate="yes" xml:space="preserve">
          <source>And you can see the result in &lt;a href=&quot;http://regexr.com/3dnsr&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">그리고 당신은 &lt;a href=&quot;http://regexr.com/3dnsr&quot;&gt;여기에&lt;/a&gt; 결과를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e26b13a81cb76e8dc9e53aad0fcb3cbbd55af273" translate="yes" xml:space="preserve">
          <source>Apparently, that's it:</source>
          <target state="translated">분명히, 그게 전부입니다 :</target>
        </trans-unit>
        <trans-unit id="7be7eff5fcaa57b778137a6635105c0ed343ce92" translate="yes" xml:space="preserve">
          <source>But keep in mind that one should not rely only upon JavaScript validation. JavaScript can easily be disabled. This should be validated on the server side as well.</source>
          <target state="translated">그러나 JavaScript 유효성 검사에만 의존해서는 안됩니다. JavaScript는 쉽게 비활성화 할 수 있습니다. 이것은 서버 측에서도 검증되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b68bf870b6ac941897eabd25f10774762e5c319f" translate="yes" xml:space="preserve">
          <source>But, of course, that's ignoring internationalization.</source>
          <target state="translated">물론 국제화를 무시하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="598cce1cb437a7291b550485e277d93fa9c3231b" translate="yes" xml:space="preserve">
          <source>Correct validation of email address in compliance with the RFCs is not something that can be achieved with a one-liner regular expression. An article with the best solution I've found in PHP is &lt;em&gt;&lt;a href=&quot;http://www.dominicsayers.com/isemail/&quot;&gt;What is a valid email address?&lt;/a&gt;&lt;/em&gt;. Obviously, it has been ported to Java. &lt;strike&gt;I think the function is too complex to be ported and used in JavaScript.&lt;/strike&gt; JavaScript/node.js port: &lt;a href=&quot;https://www.npmjs.com/package/email-addresses&quot;&gt;https://www.npmjs.com/package/email-addresses&lt;/a&gt;.</source>
          <target state="translated">RFC를 준수하는 전자 메일 주소의 올바른 유효성 검사는 한 줄짜리 정규식으로 얻을 수있는 것이 아닙니다. PHP에서 찾은 최고의 솔루션을 가진 기사 &lt;em&gt;&lt;a href=&quot;http://www.dominicsayers.com/isemail/&quot;&gt;는 유효한 이메일 주소&lt;/a&gt;&lt;/em&gt; 는 &lt;em&gt;무엇입니까?&lt;/em&gt; . 분명히, 그것은 자바로 포팅되었습니다. &lt;strike&gt;JavaScript에서 이식 및 사용하기에는 함수가 너무 복잡하다고 생각합니다.&lt;/strike&gt; JavaScript / node.js 포트 : &lt;a href=&quot;https://www.npmjs.com/package/email-addresses&quot;&gt;https://www.npmjs.com/package/email-addresses&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a09d8fe71d819660f00ffa7e97f5581804bd696d" translate="yes" xml:space="preserve">
          <source>Do this:</source>
          <target state="translated">이 작업을 수행:</target>
        </trans-unit>
        <trans-unit id="05c3b1a94746d3fccfe85d46d421da2c58a21981" translate="yes" xml:space="preserve">
          <source>Don't bother with anything more complicated. Even if you could perfectly determine whether an email is RFC-syntactically valid, that wouldn't tell you whether it belongs to the person who supplied it. That's what really matters.</source>
          <target state="translated">더 복잡한 것을 귀찮게하지 마십시오. 전자 메일이 RFC 구문에 유효한지 완벽하게 확인할 수 있더라도 전자 메일을 제공 한 사람의 것인지 여부는 알 수 없습니다. 그것이 정말로 중요한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ed80d0ac1ad5c36583371929851e98f77ee4bd86" translate="yes" xml:space="preserve">
          <source>Else you can use &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt;. Inside rules define:</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; 를 사용할 수 있습니다. 내부 규칙은 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5409b5439879adf5c9d1c5dade0e2314ed41c540" translate="yes" xml:space="preserve">
          <source>Example JavaScript function:</source>
          <target state="translated">JavaScript 함수 예 :</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="8868cfeb157de5566f026a1ba1a73030eace2f77" translate="yes" xml:space="preserve">
          <source>For example, although the address &lt;code&gt;example@example.ccc&lt;/code&gt; will pass the regex, it is not a valid email, because &lt;code&gt;ccc&lt;/code&gt; is not a top-level domain by IANA.</source>
          <target state="translated">예를 들어 주소 &lt;code&gt;example@example.ccc&lt;/code&gt; 는 정규식을 전달하지만 &lt;code&gt;ccc&lt;/code&gt; 는 IANA의 최상위 도메인이 아니기 때문에 올바른 이메일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f64a17670388386ceaa9ed07df87ed6ee552e122" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5 spec&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5 사양에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8b7362a21449731075ab0568d5243407a17a9201" translate="yes" xml:space="preserve">
          <source>HTML5 itself has email validation. If your browser supports HTML5 then you can use the following code.</source>
          <target state="translated">HTML5 자체에는 이메일 유효성 검사가 있습니다. 브라우저가 HTML5를 지원하는 경우 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c5d991566a0444b653b62f3a726e4cbfa2ea911" translate="yes" xml:space="preserve">
          <source>Here is a very good discussion about using regular expressions to validate email addresses; &quot;&lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;&quot;</source>
          <target state="translated">다음은 정규식을 사용하여 전자 메일 주소의 유효성을 검사하는 방법에 대한 매우 유용한 토론입니다. &quot; &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;정규식 확인 이메일 주소 비교&lt;/a&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="d1cdbf2dd912f5611f94b61c4454aa6be4060872" translate="yes" xml:space="preserve">
          <source>Here is the current top expression, that is JavaScript compatible, for reference purposes:</source>
          <target state="translated">다음은 참조 용으로 현재 최상위 표현식 (JavaScript 호환 가능)입니다.</target>
        </trans-unit>
        <trans-unit id="55eaa6630852df71584d8d2c86bd087264a8b11c" translate="yes" xml:space="preserve">
          <source>Here's an &lt;a href=&quot;http://tools.ietf.org/html/rfc22&quot;&gt;RFC22&lt;/a&gt; regular expression for emails:</source>
          <target state="translated">이메일에 대한 &lt;a href=&quot;http://tools.ietf.org/html/rfc22&quot;&gt;RFC22&lt;/a&gt; 정규식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d736275ef39d215814e56f8d44f47eb889f757a2" translate="yes" xml:space="preserve">
          <source>Here's an example of it being used in JavaScript (with the case insensitive flag &lt;code&gt;i&lt;/code&gt; at the end).</source>
          <target state="translated">다음은 JavaScript에서 사용되는 예입니다 (대소 문자를 구분하지 않는 플래그 &lt;code&gt;i&lt;/code&gt; 가 있음).</target>
        </trans-unit>
        <trans-unit id="c9732739a8fa3aa580bff2f06e5dd97f04136a72" translate="yes" xml:space="preserve">
          <source>Here's an example of the above in action:</source>
          <target state="translated">위의 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01c3718f65d977f8cd82fb726cefca178b261fbf" translate="yes" xml:space="preserve">
          <source>Here's the JavaScript function I use to check if a string looks like a valid mail address:</source>
          <target state="translated">문자열이 유효한 메일 주소인지 확인하는 데 사용하는 JavaScript 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4119d32b8e5f26b12cdc6b955694a7dcc855ea3" translate="yes" xml:space="preserve">
          <source>Here's the example of regular expresion that accepts unicode:</source>
          <target state="translated">유니 코드를 허용하는 정규 표현식의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b207348e5f8be6ff4ddfc15b025a7b3adf609d1" translate="yes" xml:space="preserve">
          <source>How to validate an email address in JavaScript</source>
          <target state="translated">JavaScript에서 이메일 주소를 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="0a1508da59f3e193ff6ad730178c89b7035e88ba" translate="yes" xml:space="preserve">
          <source>I have found this to be the best solution:</source>
          <target state="translated">나는 이것이 최선의 해결책이라는 것을 알았다.</target>
        </trans-unit>
        <trans-unit id="bc3f6146702ab3d562c01bfa05025b507e479858" translate="yes" xml:space="preserve">
          <source>I'm really looking forward to solve this problem.
So I modified email validation regular expression above</source>
          <target state="translated">이 문제를 해결하기 위해 정말로 기대하고 있습니다. 그래서 위의 이메일 유효성 검사 정규 표현식을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="a248e3c0f90d17a4614d8a626dbd5b50035fec7a" translate="yes" xml:space="preserve">
          <source>I've put together an example in the fiddle &lt;a href=&quot;http://jsfiddle.net/boldewyn/2b6d5/&quot;&gt;http://jsfiddle.net/boldewyn/2b6d5/&lt;/a&gt;. Combined with feature detection and the bare-bones validation from &lt;a href=&quot;https://stackoverflow.com/a/9204568/324094&quot;&gt;Squirtle's Answer&lt;/a&gt;, it frees you from the regular expression massacre and does not bork on old browsers.</source>
          <target state="translated">바이올린 &lt;a href=&quot;http://jsfiddle.net/boldewyn/2b6d5/&quot;&gt;http://jsfiddle.net/boldewyn/2b6d5/에&lt;/a&gt; 예제를 작성했습니다. &lt;a href=&quot;https://stackoverflow.com/a/9204568/324094&quot;&gt;Squirtle 's Answer의&lt;/a&gt; 기능 탐지 및 베어 본 유효성 검사와 결합하여 정규식 학살에서 벗어날 수 있으며 이전 브라우저에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d188ab7a43c60291a59eaf6d495c2bf08eaa1e06" translate="yes" xml:space="preserve">
          <source>I've slightly modified &lt;a href=&quot;https://stackoverflow.com/a/48800/4832311&quot;&gt;Jaymon's answer&lt;/a&gt; for people who want really simple validation in the form of:</source>
          <target state="translated">나는 다음과 같은 형태로 간단한 검증을 원하는 사람들을 위해 &lt;a href=&quot;https://stackoverflow.com/a/48800/4832311&quot;&gt;Jaymon의 답변&lt;/a&gt; 을 약간 수정 했습니다 .</target>
        </trans-unit>
        <trans-unit id="315db90cf313699f7ac0f7eae75e11e0348020d6" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;em&gt;squirtle&lt;/em&gt;, here is a complex solution, but it does a mighty fine job of validating emails properly:</source>
          <target state="translated">&lt;em&gt;squirtle&lt;/em&gt; 과 달리 여기에 복잡한 솔루션이 있지만 전자 메일을 올바르게 확인하는 데는 훌륭합니다.</target>
        </trans-unit>
        <trans-unit id="1993773f9359f09e2b2ca1d4dfc92ca22cf0598b" translate="yes" xml:space="preserve">
          <source>In modern browsers you can build on top of @Sushil's answer with pure JavaScript and the &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;:</source>
          <target state="translated">최신 브라우저에서는 순수한 JavaScript와 &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM을 사용&lt;/a&gt; 하여 @Sushil의 답변 위에 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc006f7ff05133b272e5b578dbdd5f956c986749" translate="yes" xml:space="preserve">
          <source>In short, however, the only way to be absolutely, positively sure that what the user entered is in fact an email is to actually send an email and see what happens. Other than that it's all just guesses.</source>
          <target state="translated">간단히 말해서, 절대적으로, 사용자가 입력 한 것이 실제로는 이메일이 실제로 이메일을 보내고 어떤 일이 일어나는지 보는 것임을 확실히하는 유일한 방법입니다. 그 외에는 모두 추측 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="347af515eb75a3a68eafcbe4972692356a8313b5" translate="yes" xml:space="preserve">
          <source>Instead of new &lt;code&gt;RegExp&lt;/code&gt;, just try writing the &lt;code&gt;regexp&lt;/code&gt; out like this:</source>
          <target state="translated">새로운 &lt;code&gt;RegExp&lt;/code&gt; 대신 다음과 같이 &lt;code&gt;regexp&lt;/code&gt; 을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9148998183a2fd2d6f858d4387b1b15dbe4f562a" translate="yes" xml:space="preserve">
          <source>Is there a regular expression to validate an email address in JavaScript?</source>
          <target state="translated">JavaScript에서 이메일 주소를 확인하는 정규식이 있습니까?</target>
        </trans-unit>
        <trans-unit id="5c7df193a907d0300211071328cac09439891293" translate="yes" xml:space="preserve">
          <source>It allows the following formats:</source>
          <target state="translated">다음 형식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a99b489816040651aa2d1fd871c66978d3772b83" translate="yes" xml:space="preserve">
          <source>It usually catches the most obvious errors that the user makes and assures that the form is mostly right, which is what JavaScript validation is all about.</source>
          <target state="translated">일반적으로 사용자가 만드는 가장 명백한 오류를 포착하고 양식이 대부분 올바른지 확인합니다. 이것이 JavaScript 유효성 검사의 모든 것입니다.</target>
        </trans-unit>
        <trans-unit id="714d1728ca370ac5f7d7ab12a787c823095501a4" translate="yes" xml:space="preserve">
          <source>It's clearly versatile and allows the all-important international characters, while still enforcing the basic anything@anything.anything format. It will block spaces which are technically allowed by RFC, but they are so rare that I'm happy to do this.</source>
          <target state="translated">그것은 분명히 다재다능하고 가장 중요한 국제 캐릭터를 허용하면서도 기본적인 everything@anything.anything 형식을 시행합니다. RFC에서 기술적으로 허용되는 공간을 차단하지만 너무 희귀하여이 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c6c2d56e6e9e295b27bec153395a14c0aa7220fe" translate="yes" xml:space="preserve">
          <source>It's hard to get an email validator 100% correct. The only real way to get it correct would be to send a test email to the account. That said, there are a few basic checks that can help make sure that you're getting something reasonable.</source>
          <target state="translated">이메일 유효성 검사기를 100 % 정확하게 얻는 것은 어렵습니다. 올바른 방법은 계정에 테스트 이메일을 보내는 것입니다. 즉, 합리적인 것을 얻는 데 도움이되는 몇 가지 기본 점검 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8411e7c9328a36b4cbb59bb9fec5b52faa58933" translate="yes" xml:space="preserve">
          <source>JavaScript can match a regular expression:</source>
          <target state="translated">JavaScript는 정규식과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="462f80793e03276bd6ae7f412a16f5c7dab9a1c7" translate="yes" xml:space="preserve">
          <source>Just for completeness, &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;here you have another RFC 2822 compliant regex&lt;/a&gt;</source>
          <target state="translated">완전성을 위해 &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;여기에 다른 RFC 2822 호환 정규식이 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19a532c8bc61c311f583455c80ffe37067bbc9bb" translate="yes" xml:space="preserve">
          <source>Modified</source>
          <target state="translated">Modified</target>
        </trans-unit>
        <trans-unit id="43b887329c39991ed9342ff2808e53e763031ba1" translate="yes" xml:space="preserve">
          <source>More info: &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;http://www.regular-expressions.info/email.html&lt;/a&gt;</source>
          <target state="translated">추가 정보 : &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;http://www.regular-expressions.info/email.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76276228f6a79582360d144c94d0e6a56cd45f09" translate="yes" xml:space="preserve">
          <source>My knowledge of &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expressions&lt;/a&gt; is not that good. That's why I check the general syntax with a simple regular expression first and check more specific options with other functions afterwards. This may not be not the best technical solution, but this way I'm way more flexible and faster.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;정규 표현에&lt;/a&gt; 대한 나의 지식은 그렇게 좋지 않습니다. 그래서 간단한 정규 표현식으로 일반 구문을 먼저 확인하고 나중에 다른 기능으로 더 구체적인 옵션을 확인합니다. 이것은 최고의 기술 솔루션은 아니지만이 방법으로 더 유연하고 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="55fe3dadfccb59bf35ba0495e729e2f066123820" translate="yes" xml:space="preserve">
          <source>Now since you can only cover 90% of the cases, write something like:</source>
          <target state="translated">이제 사례의 90 % 만 처리 할 수 ​​있으므로 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="83cc9c6ad80b66e95f932227fdb6532df66d4148" translate="yes" xml:space="preserve">
          <source>Often when storing email addresses in the database I make them lowercase and, in practice, regexs can usually be marked case insensitive. In those cases this is slightly shorter:</source>
          <target state="translated">데이터베이스에 이메일 주소를 저장할 때 종종 소문자로 만들고 실제로 정규 표현식은 대소 문자를 구분하지 않습니다. 이 경우 약간 짧습니다.</target>
        </trans-unit>
        <trans-unit id="c0a8060f3b1102da85ef318544468f24221e6515" translate="yes" xml:space="preserve">
          <source>Original</source>
          <target state="translated">Original</target>
        </trans-unit>
        <trans-unit id="a70eee5dd9722ceee12b43905700a9eadb6e7b6e" translate="yes" xml:space="preserve">
          <source>Regex for validating email address</source>
          <target state="translated">이메일 주소 확인을위한 정규식</target>
        </trans-unit>
        <trans-unit id="82f6a0d73051b421407fc4a9df3d93285e7f9585" translate="yes" xml:space="preserve">
          <source>Regex update 2018! try this</source>
          <target state="translated">정규식 업데이트 2018! 이 시도</target>
        </trans-unit>
        <trans-unit id="9696f8b9a85d838f4f9eed88d0e6759d6f674fbf" translate="yes" xml:space="preserve">
          <source>Second, check to make sure that a period comes after the &lt;code&gt;@&lt;/code&gt; sign, and make sure that there are characters between the &lt;code&gt;@&lt;/code&gt;s and periods.</source>
          <target state="translated">둘째, &lt;code&gt;@&lt;/code&gt; 기호 뒤에 마침표가 오는지 확인하고 &lt;code&gt;@&lt;/code&gt; s와 마침표 사이에 문자가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a55492e77609ea34ff33de5ed0aaf5c9ff5c7e90" translate="yes" xml:space="preserve">
          <source>Simply check out if the entered email address is valid or not using HTML.</source>
          <target state="translated">입력 한 이메일 주소가 유효한지 HTML을 사용하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ccbd8edc536e38c01c66151bde97d343991d5964" translate="yes" xml:space="preserve">
          <source>So even when following official standards, there are still trade-offs to be made. &lt;strong&gt;&lt;em&gt;Don't blindly copy regular expressions from online libraries or discussion forums. Always test them on your own data and with your own applications.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">따라서 공식 표준을 준수하더라도 여전히 타협점이 있습니다. &lt;strong&gt;&lt;em&gt;온라인 라이브러리 나 토론 포럼에서 정규 표현식을 맹목적으로 복사하지 마십시오.&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;항상 자신의 데이터와 자체 응용 프로그램에서 테스트하십시오.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1838964c9b448ad5c03e2b47885618f97f813137" translate="yes" xml:space="preserve">
          <source>Some things to improve:</source>
          <target state="translated">개선해야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="1518ae57cfe2ed8a133afc03011cb0263227ca7b" translate="yes" xml:space="preserve">
          <source>Taken from &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&lt;/a&gt; on Oct 1 '10.</source>
          <target state="translated">10 월 1 일 ' &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&lt;/a&gt; 에서 가져온 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6fb1c04bf21f84884bce0fe4918114f74c0cab0" translate="yes" xml:space="preserve">
          <source>Technically some emails can include quotes in the section before the &lt;code&gt;@&lt;/code&gt; symbol with escape characters inside the quotes (so your email user can be obnoxious and contain stuff like &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;&quot;...&quot;&lt;/code&gt; as long as it's written in quotes). NOBODY DOES THIS EVER! It's obsolete. But, it IS included in the true &lt;a href=&quot;https://www.ietf.org/rfc/rfc2822.txt&quot;&gt;RFC 2822&lt;/a&gt; standard, and omitted here.</source>
          <target state="translated">기술적으로 일부 이메일은 따옴표 안에 이스케이프 문자가있는 &lt;code&gt;@&lt;/code&gt; 기호 앞의 섹션에 따옴표를 포함 할 수 있습니다 (따라서 이메일 사용자는 눈에 띄지 않으며 따옴표로 쓰여있는 한 &lt;code&gt;@&lt;/code&gt; 및 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 와 같은 항목을 포함 할 수 있습니다). 아무도이 일을하지 않습니다! 더 이상 사용되지 않습니다. 그러나 이는 실제 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2822.txt&quot;&gt;RFC 2822&lt;/a&gt; 표준에 포함되어 있으며 여기서는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="2c42e1dbf8f30a22743d35f41dec49ad83dcbd78" translate="yes" xml:space="preserve">
          <source>The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.</source>
          <target state="translated">다음 JavaScript 및 Perl 호환 정규식은 위 정의를 구현 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="acf10a9a6c9b7ded0b17a3c178b673c5a6b22d4e" translate="yes" xml:space="preserve">
          <source>The most common errors I've come across are spaces (especially at the beginning and end) and occasionally a double dot.</source>
          <target state="translated">내가 겪는 가장 일반적인 오류는 공백 (특히 시작과 끝)과 때로는 이중 점입니다.</target>
        </trans-unit>
        <trans-unit id="e575176116c75b6cd106b88dfa99d3c160478169" translate="yes" xml:space="preserve">
          <source>The official standard is known as &lt;a href=&quot;https://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt;. It describes the syntax that valid email addresses must adhere to. You can (&lt;strong&gt;but you shouldn't&lt;/strong&gt; &amp;mdash; &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;read on&lt;/a&gt;) implement it with this regular expression:</source>
          <target state="translated">공식 표준은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt; 로 알려져 있습니다. 유효한 이메일 주소를 준수해야하는 구문을 설명합니다. 이 정규 표현식으로 구현할 수는 &lt;strong&gt;있지만&lt;/strong&gt; &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;읽을&lt;/a&gt; &lt;strong&gt;수는 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="941d12bdf6866507609a342766f852faec160c1e" translate="yes" xml:space="preserve">
          <source>The regular expression provided by Microsoft within &lt;a href=&quot;http://en.wikipedia.org/wiki/ASP.NET_MVC_Framework&quot;&gt;ASP.NET MVC&lt;/a&gt; is</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/ASP.NET_MVC_Framework&quot;&gt;ASP.NET MVC&lt;/a&gt; 내에서 Microsoft가 제공하는 정규식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45144d24f561ff5e2946df80fc43f503ab825e60" translate="yes" xml:space="preserve">
          <source>The regular expression:</source>
          <target state="translated">정규식 :</target>
        </trans-unit>
        <trans-unit id="16042eba1725f6c0d572cb3c8443990439ce36bb" translate="yes" xml:space="preserve">
          <source>The world needs simpler code...</source>
          <target state="translated">세상은 더 간단한 코드가 필요합니다 ...</target>
        </trans-unit>
        <trans-unit id="94032b10ee1f8d5a97f30f3c782c842eb909e10a" translate="yes" xml:space="preserve">
          <source>There isn't any need to write a function for validation.</source>
          <target state="translated">유효성 검사를 위해 함수를 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4653e258277090cf523691e460e7e53ec60cf120" translate="yes" xml:space="preserve">
          <source>There's something you have to understand the second you decide to use a regular expression to validate emails: &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;It's probably not a good idea&lt;/a&gt;. Once you have come to terms with that, there are many implementations out there that can get you halfway there, &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;this article sums them up nicely.&lt;/a&gt;</source>
          <target state="translated">이메일을 검증하기 위해 정규식을 사용하기로 결정한 순간을 이해해야 할 &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;것이&lt;/a&gt; 있습니다. 아마 좋은 생각이 아닙니다 . 일단 당신이 그 용어를 알게되면, 거기에 반쯤 갈 수있는 많은 구현 &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;이&lt;/a&gt; 있습니다. 이 기사는 그것들을 훌륭하게 요약합니다.</target>
        </trans-unit>
        <trans-unit id="630e1ebe59de2ebe03b87070aee8483c90aca2e4" translate="yes" xml:space="preserve">
          <source>This is how &lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;node-validator&lt;/a&gt; does it:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;노드 유효성 검사기&lt;/a&gt; 가 수행하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="e923b31f669b92caf8faf75409dfa855b536d9c3" translate="yes" xml:space="preserve">
          <source>This is the correct RFC822 version.</source>
          <target state="translated">이것은 올바른 RFC822 버전입니다.</target>
        </trans-unit>
        <trans-unit id="98135052de405526350db1b89c86c41136ccf880" translate="yes" xml:space="preserve">
          <source>This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of RFC 5322, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &quot;@&quot; character), too vague (after the &quot;@&quot; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">이 요구 사항은 RFC 5322를 &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;고의적으로 위반&lt;/a&gt; 하는 것으로, 동시에 너무 엄격한 ( &quot;@&quot;문자 앞), 너무 모호한 ( &quot;@&quot;문자 뒤), 너무 느슨한 (주석 허용) 전자 메일 주소의 구문을 정의합니다. , 공백 문자 및 대부분의 사용자에게 익숙하지 않은 방식으로 따옴표로 묶은 문자열)을 여기에서 실제로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48569f5e4634aefd2b80beb29b7935143c8e99ad" translate="yes" xml:space="preserve">
          <source>This was stolen from &lt;a href=&quot;http://codesnippets.joyent.com/posts/show/1917&quot;&gt;http://codesnippets.joyent.com/posts/show/1917&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;http://codesnippets.joyent.com/posts/show/1917&quot;&gt;http://codesnippets.joyent.com/posts/show/1917&lt;/a&gt; 에서 도난당했습니다 .</target>
        </trans-unit>
        <trans-unit id="72bc65d3fc80e4c4bca49e2352036074e3d2e1fd" translate="yes" xml:space="preserve">
          <source>To test that, send a validation message.</source>
          <target state="translated">이를 테스트하려면 유효성 검사 메시지를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="280b7af2c0707f401085e67adc9102c8145b601f" translate="yes" xml:space="preserve">
          <source>Use like so:</source>
          <target state="translated">다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d07fe7db1c7da2a64b448acb9bf6362ec1ad00db" translate="yes" xml:space="preserve">
          <source>Use this code inside your validator function:</source>
          <target state="translated">유효성 검사기 함수 내에서이 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57073d762acf8b6ec0f1442441f428af780cc6e5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expressions&lt;/a&gt; is probably the best way. You can see a bunch of tests &lt;a href=&quot;http://jsfiddle.net/ghvj4gy9/embedded/result,js/&quot;&gt;here&lt;/a&gt; (taken from &lt;a href=&quot;https://cs.chromium.org/chromium/src/third_party/blink/web_tests/fast/forms/resources/ValidityState-typeMismatch-email.js?q=ValidityState-typeMismatch-email.js&amp;amp;sq=package:chromium&amp;amp;dr&quot;&gt;chromium&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;정규식을&lt;/a&gt; 사용하는 것이 가장 좋습니다. &lt;a href=&quot;http://jsfiddle.net/ghvj4gy9/embedded/result,js/&quot;&gt;여기&lt;/a&gt; 에서 많은 테스트를 볼 수 있습니다 ( &lt;a href=&quot;https://cs.chromium.org/chromium/src/third_party/blink/web_tests/fast/forms/resources/ValidityState-typeMismatch-email.js?q=ValidityState-typeMismatch-email.js&amp;amp;sq=package:chromium&amp;amp;dr&quot;&gt;크롬&lt;/a&gt; 에서 가져온)</target>
        </trans-unit>
        <trans-unit id="b9e8f0aa49270c5886db87d3f533dcbfba02090e" translate="yes" xml:space="preserve">
          <source>Which I post here in case it's flawed - though it's always been perfect for my needs.</source>
          <target state="translated">결함이있는 경우 여기에 게시합니다-항상 내 요구에 완벽했습니다.</target>
        </trans-unit>
        <trans-unit id="ca6567da36e820bab2c3f907ddc5877f381c711d" translate="yes" xml:space="preserve">
          <source>Why?  &lt;strong&gt;It's based on &lt;a href=&quot;https://www.ietf.org/rfc/rfc2822.txt&quot;&gt;RFC 2822&lt;/a&gt;&lt;/strong&gt;, which is a standard ALL email addresses MUST adhere to.  And I'm not sure why you'd bother with something &quot;simpler&quot;... you're gonna copy and paste it anyway ;)</source>
          <target state="translated">왜? &lt;strong&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2822.txt&quot;&gt;RFC 2822를&lt;/a&gt; 기반으로&lt;/strong&gt; 하며 표준 모든 전자 메일 주소를 준수해야합니다. 그리고 왜 당신이 &quot;간단한&quot;것으로 귀찮게했는지 모르겠습니다 ... 어쨌든 그것을 복사하여 붙여 넣을 것입니다.)</target>
        </trans-unit>
        <trans-unit id="5e1bff561da6219badfcaad8cb451347e48e4246" translate="yes" xml:space="preserve">
          <source>Wow, there are lots of complexity here. If all you want to do is just catch the most obvious syntax errors, I would do something like this:</source>
          <target state="translated">와우, 여기에는 많은 복잡성이 있습니다. 가장 명확한 구문 오류를 잡기 만하면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97b604f9ee54aee64d0bc1a6ff444c9f6b9302b7" translate="yes" xml:space="preserve">
          <source>You can refine it. For instance, 'aaa@' is valid. But overall you get the gist. And don't get carried away... A simple 90% solution is better than 100% solution that does not work.</source>
          <target state="translated">다듬을 수 있습니다. 예를 들어, 'aaa @'는 유효합니다. 그러나 전반적으로 요점을 얻습니다. 그리고 해결하지 마십시오 ... 간단한 90 % 솔루션이 작동하지 않는 100 % 솔루션보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="f3ea2dc3cd08e78009685d0096abc89812a523e9" translate="yes" xml:space="preserve">
          <source>You should not use regular expressions to validate an input string to check if it's an email. It's too complicated and would not cover all the cases.</source>
          <target state="translated">정규식을 사용하여 입력 문자열의 유효성을 검사하여 이메일인지 확인하면 안됩니다. 너무 복잡해서 모든 경우를 다루지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7dd4057835b8dc1717f15922fc3cc2257c048d1e" translate="yes" xml:space="preserve">
          <source>more info &lt;a href=&quot;https://git.io/vhEfc&quot;&gt;https://git.io/vhEfc&lt;/a&gt;</source>
          <target state="translated">더 많은 정보 &lt;a href=&quot;https://git.io/vhEfc&quot;&gt;https://git.io/vhEfc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6e11122ef5af8d566438931e8c2ffc049747762" translate="yes" xml:space="preserve">
          <source>to pass the examples in &lt;a href=&quot;https://en.wikipedia.org/wiki/Email_address#cite_note-20/syntax&quot;&gt;Wikipedia Email Address&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Email_address#cite_note-20/syntax&quot;&gt;Wikipedia Email Address&lt;/a&gt; 의 예제를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d0462cbe40aaaa8c3f944bec1e809689cec9b0a3" translate="yes" xml:space="preserve">
          <source>typscript version complete</source>
          <target state="translated">타이프 스크립트 버전 완료</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
