<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/46155">
    <body>
      <group id="46155">
        <trans-unit id="c9900fcc65e0be104350f210414eee5f116eb87e" translate="yes" xml:space="preserve">
          <source>(...) We get a more practical implementation of RFC 2822 if we omit the syntax using double quotes and square brackets. &lt;strong&gt;It will still match 99.99% of all email addresses in actual use today.&lt;/strong&gt;</source>
          <target state="translated">（...）如果我们省略使用双引号和方括号的语法，则会得到RFC 2822的更实际的实现。 &lt;strong&gt;它仍将匹配今天实际使用的所有电子邮件地址的99.99％。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3b5d01380b8c1dcd1ad280a061ed69f2c78d5f4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsfiddle.net/edwinthomas25/z6wev5L0/&quot;&gt;jsFiddle&lt;/a&gt; link</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/edwinthomas25/z6wev5L0/&quot;&gt;jsFiddle&lt;/a&gt;链接</target>
        </trans-unit>
        <trans-unit id="4f7e3850e125c7d3d2a1bbc2bf2b4ebdd7602be0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Email_address#Examples&quot;&gt;https://en.wikipedia.org/wiki/Email_address#Examples&lt;/a&gt;&lt;a href=&quot;https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte&quot;&gt;https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Email_address#Examples&quot;&gt;https://en.wikipedia.org/wiki/Email_address#Examples&lt;/a&gt;&lt;a href=&quot;https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte&quot;&gt;https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94e288bc4d1208f43d25800c6e81d3a8aaa47e2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(str.length - lastDotPos) &amp;gt; 2&lt;/code&gt;: There should be enough characters after the last dot to form a two-character domain. I'm not sure if the brackets are necessary.</source>
          <target state="translated">&lt;code&gt;(str.length - lastDotPos) &amp;gt; 2&lt;/code&gt; ：最后一个点后应有足够的字符以形成两个字符的域。 我不确定是否需要括号。</target>
        </trans-unit>
        <trans-unit id="c7c111c87df1234659dafe02d39a5fdee62a97df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastAtPos &amp;gt; 0&lt;/code&gt;: There should be something (the email username) before the last &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lastAtPos &amp;gt; 0&lt;/code&gt; ：最后一个 &lt;code&gt;@&lt;/code&gt; 之前应该有一些（电子邮件用户名）。</target>
        </trans-unit>
        <trans-unit id="55cff3e34b43920049bec68d26cb1f95f215d6a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastAtPos &amp;lt; lastDotPos&lt;/code&gt;: Last &lt;code&gt;@&lt;/code&gt; should be before last &lt;code&gt;.&lt;/code&gt; since &lt;code&gt;@&lt;/code&gt; cannot be part of server name (as far as I know).</source>
          <target state="translated">&lt;code&gt;lastAtPos &amp;lt; lastDotPos&lt;/code&gt; ：Last &lt;code&gt;@&lt;/code&gt; 应该在last之前 &lt;code&gt;.&lt;/code&gt; 因为 &lt;code&gt;@&lt;/code&gt; 不能是服务器名称的一部分（据我所知）。</target>
        </trans-unit>
        <trans-unit id="490240bf90511707d51003d6b0ecd29b5fd5debb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastDotPos &amp;gt; 2&lt;/code&gt;: There should be at least three characters before the last dot, for example &lt;code&gt;a@b.com&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lastDotPos &amp;gt; 2&lt;/code&gt; ：最后一个点之前至少应包含三个字符，例如 &lt;code&gt;a@b.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e95ecb104fc6f6f4f0c446d297e10333260e7b04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;str.indexOf('@@') == -1&lt;/code&gt;: There should be no &lt;code&gt;@@&lt;/code&gt; in the address. Even if &lt;code&gt;@&lt;/code&gt; appears as the last character in email username, it has to be quoted so &lt;code&gt;&quot;&lt;/code&gt; would be between that &lt;code&gt;@&lt;/code&gt; and the last &lt;code&gt;@&lt;/code&gt; in the address.</source>
          <target state="translated">&lt;code&gt;str.indexOf('@@') == -1&lt;/code&gt; ：地址中不应有 &lt;code&gt;@@&lt;/code&gt; 。 即使 &lt;code&gt;@&lt;/code&gt; 作为电子邮件用户名中的最后一个字符出现，也必须将其引号引起来， &lt;code&gt;&quot;&lt;/code&gt; 应位于该 &lt;code&gt;@&lt;/code&gt; 和地址中的最后一个 &lt;code&gt;@&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="b2f448975c7d7ce0ade29f009045a250ffef3285" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1- Validation of email format:&lt;/strong&gt; Making sure if the email complies with the format and pattern of emails in RFC 5322 and if the TLD actually exists. A list of all valid TLDs can be found &lt;a href=&quot;http://data.iana.org/TLD/tlds-alpha-by-domain.txt&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;1-电子邮件格式的验证：&lt;/strong&gt;确保电子邮件是否符合RFC 5322中电子邮件的格式和模式，以及TLD是否实际存在。 您可以在&lt;a href=&quot;http://data.iana.org/TLD/tlds-alpha-by-domain.txt&quot;&gt;此处&lt;/a&gt;找到所有有效TLD的列表。</target>
        </trans-unit>
        <trans-unit id="72aebd76d57cb550e303461fb57ba140a793cfc6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2- Making sure the email actually exists:&lt;/strong&gt; For doing this, &lt;strong&gt;the only option&lt;/strong&gt; is &lt;a href=&quot;https://davidcel.is/posts/stop-validating-email-addresses-with-regex/#just-send-them-an-email-already&quot;&gt;to send the users an email&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;2-确保电子邮件确实存在：&lt;/strong&gt;为此， &lt;strong&gt;唯一的选择&lt;/strong&gt;是&lt;a href=&quot;https://davidcel.is/posts/stop-validating-email-addresses-with-regex/#just-send-them-an-email-already&quot;&gt;向用户发送电子邮件&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="abd92687b99044b4eddf773d671c4667439b4622" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="f633af6eb48c9e0b8af0d18976d74129ba756046" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Show this test : &lt;a href=&quot;https://regex101.com/r/LHJ9gU/1&quot;&gt;https://regex101.com/r/LHJ9gU/1&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;显示此测试： &lt;a href=&quot;https://regex101.com/r/LHJ9gU/1&quot;&gt;https&lt;/a&gt; : //regex101.com/r/LHJ9gU/1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2d5ce6846b7eb2409986c51bc4a515382a776cc6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wikipedia standard mail syntax :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Wikipedia标准邮件语法：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="297c8518f856cbda751268ce424749e63f0c28d1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Emphasis mine&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;重点矿&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="8fe50eb48ca2b3e732cca1bc24539853528194c5" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;valid e-mail address&lt;/strong&gt; is a string that matches the &lt;code&gt;email&lt;/code&gt; production of the following ABNF, the character set for which is Unicode.</source>
          <target state="translated">&lt;strong&gt;有效的电子邮件地址&lt;/strong&gt;是与以下ABNF的 &lt;code&gt;email&lt;/code&gt; 产生匹配的字符串，该字符串的字符集为Unicode。</target>
        </trans-unit>
        <trans-unit id="d8812909686aedb08074742b5f572064a6720486" translate="yes" xml:space="preserve">
          <source>A further change you could make is to allow any two-letter country code top level domain, and only specific generic top level domains. &lt;strong&gt;This regex filters dummy email addresses like &lt;code&gt;asdf@adsf.adsf&lt;/code&gt;&lt;/strong&gt;. You &lt;strong&gt;will need to update it as new top-level domains are added&lt;/strong&gt;.</source>
          <target state="translated">您可以做的进一步更改是允许任何两个字母的国家/地区代码顶级域名，仅允许特定的通用顶级域名。 &lt;strong&gt;此正则表达式过滤虚拟电子邮件地址，如 &lt;code&gt;asdf@adsf.adsf&lt;/code&gt; &lt;/strong&gt; 。 &lt;strong&gt;添加新的顶级域后，&lt;/strong&gt;您&lt;strong&gt;将需要对其进行更新&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7923e3b47cb736d7dab4697baaade704b4e85a49" translate="yes" xml:space="preserve">
          <source>A good practice is to validate your data on the client, but double-check the validation on the server. With this in mind, you can simply check whether a string looks like a valid email address on the client and perform the strict check on the server.</source>
          <target state="translated">一个好的做法是在客户端上验证你的数据,但在服务器上重复检查验证。考虑到这一点,你可以简单地在客户端检查一个字符串是否看起来像一个有效的电子邮件地址,然后在服务器上执行严格的检查。</target>
        </trans-unit>
        <trans-unit id="b2671ec3f0126e4d02b72ab3a1bade3235b1b574" translate="yes" xml:space="preserve">
          <source>A solution that does not check the existence of the TLD is incomplete.</source>
          <target state="translated">不检查TLD是否存在的解决方案是不完整的。</target>
        </trans-unit>
        <trans-unit id="2645882e0c71d880bc16972169f19a2b50019df8" translate="yes" xml:space="preserve">
          <source>All email addresses contain an 'at' (i.e. @) symbol. Test that necessary condition:</source>
          <target state="translated">所有的电子邮件地址都包含一个 &quot;at&quot;(即@)符号。测试这个必要条件。</target>
        </trans-unit>
        <trans-unit id="3ba11e47b63968b8537457a8e7dcb585e385cc7c" translate="yes" xml:space="preserve">
          <source>Almost all answers to this questions suggest using Regex to validate emails addresses. I think Regex is only good for a rudimentary validation. It seems that the checking validation of email addresses is actually two separate problems:</source>
          <target state="translated">几乎所有回答这个问题的人都建议使用Regex来验证邮件地址。我认为Regex只适合做一个基本的验证。看来,检查验证邮件地址其实是两个不同的问题。</target>
        </trans-unit>
        <trans-unit id="3e1a0cf7cfe603c9a4a7d9df75f3f7cc159c581a" translate="yes" xml:space="preserve">
          <source>And you can see the result in &lt;a href=&quot;http://regexr.com/3dnsr&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;http://regexr.com/3dnsr&quot;&gt;这里&lt;/a&gt;看到结果。</target>
        </trans-unit>
        <trans-unit id="e26b13a81cb76e8dc9e53aad0fcb3cbbd55af273" translate="yes" xml:space="preserve">
          <source>Apparently, that's it:</source>
          <target state="translated">很显然,就是这样。</target>
        </trans-unit>
        <trans-unit id="7be7eff5fcaa57b778137a6635105c0ed343ce92" translate="yes" xml:space="preserve">
          <source>But keep in mind that one should not rely only upon JavaScript validation. JavaScript can easily be disabled. This should be validated on the server side as well.</source>
          <target state="translated">但请记住,不能只依赖JavaScript验证。JavaScript很容易被禁用。这也应该在服务器端进行验证。</target>
        </trans-unit>
        <trans-unit id="b68bf870b6ac941897eabd25f10774762e5c319f" translate="yes" xml:space="preserve">
          <source>But, of course, that's ignoring internationalization.</source>
          <target state="translated">但是,当然,那是忽略了国际化。</target>
        </trans-unit>
        <trans-unit id="598cce1cb437a7291b550485e277d93fa9c3231b" translate="yes" xml:space="preserve">
          <source>Correct validation of email address in compliance with the RFCs is not something that can be achieved with a one-liner regular expression. An article with the best solution I've found in PHP is &lt;em&gt;&lt;a href=&quot;http://www.dominicsayers.com/isemail/&quot;&gt;What is a valid email address?&lt;/a&gt;&lt;/em&gt;. Obviously, it has been ported to Java. &lt;strike&gt;I think the function is too complex to be ported and used in JavaScript.&lt;/strike&gt; JavaScript/node.js port: &lt;a href=&quot;https://www.npmjs.com/package/email-addresses&quot;&gt;https://www.npmjs.com/package/email-addresses&lt;/a&gt;.</source>
          <target state="translated">使用单行正则表达式无法正确实现符合RFC的电子邮件地址验证。 我在PHP中找到最佳解决方案的文章是&lt;em&gt;&lt;a href=&quot;http://www.dominicsayers.com/isemail/&quot;&gt;什么是有效的电子邮件地址？&lt;/a&gt;&lt;/em&gt; 。 显然，它已被移植到Java。 &lt;strike&gt;我认为该功能过于复杂，无法在JavaScript中移植和使用。&lt;/strike&gt; JavaScript / node.js端口： &lt;a href=&quot;https://www.npmjs.com/package/email-addresses&quot;&gt;https&lt;/a&gt; ://www.npmjs.com/package/email-addresses。</target>
        </trans-unit>
        <trans-unit id="a09d8fe71d819660f00ffa7e97f5581804bd696d" translate="yes" xml:space="preserve">
          <source>Do this:</source>
          <target state="translated">做到这一点。</target>
        </trans-unit>
        <trans-unit id="05c3b1a94746d3fccfe85d46d421da2c58a21981" translate="yes" xml:space="preserve">
          <source>Don't bother with anything more complicated. Even if you could perfectly determine whether an email is RFC-syntactically valid, that wouldn't tell you whether it belongs to the person who supplied it. That's what really matters.</source>
          <target state="translated">不要再纠结于更复杂的事情了。即使你能完美地判断出一封邮件是否是RFC-syntactically valid,但这并不能告诉你它是否属于提供它的人。这才是真正重要的。</target>
        </trans-unit>
        <trans-unit id="ed80d0ac1ad5c36583371929851e98f77ee4bd86" translate="yes" xml:space="preserve">
          <source>Else you can use &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt;. Inside rules define:</source>
          <target state="translated">否则，您可以使用&lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; 。 内部规则定义：</target>
        </trans-unit>
        <trans-unit id="5409b5439879adf5c9d1c5dade0e2314ed41c540" translate="yes" xml:space="preserve">
          <source>Example JavaScript function:</source>
          <target state="translated">JavaScript函数示例。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="8868cfeb157de5566f026a1ba1a73030eace2f77" translate="yes" xml:space="preserve">
          <source>For example, although the address &lt;code&gt;example@example.ccc&lt;/code&gt; will pass the regex, it is not a valid email, because &lt;code&gt;ccc&lt;/code&gt; is not a top-level domain by IANA.</source>
          <target state="translated">例如，尽管地址 &lt;code&gt;example@example.ccc&lt;/code&gt; 将通过正则表达式，但它不是有效的电子邮件，因为 &lt;code&gt;ccc&lt;/code&gt; 不是IANA的顶级域。</target>
        </trans-unit>
        <trans-unit id="f64a17670388386ceaa9ed07df87ed6ee552e122" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5 spec&lt;/a&gt;:</source>
          <target state="translated">根据&lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5规范&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="8b7362a21449731075ab0568d5243407a17a9201" translate="yes" xml:space="preserve">
          <source>HTML5 itself has email validation. If your browser supports HTML5 then you can use the following code.</source>
          <target state="translated">HTML5本身具有电子邮件验证功能。如果你的浏览器支持HTML5,那么你可以使用以下代码。</target>
        </trans-unit>
        <trans-unit id="3c5d991566a0444b653b62f3a726e4cbfa2ea911" translate="yes" xml:space="preserve">
          <source>Here is a very good discussion about using regular expressions to validate email addresses; &quot;&lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;&quot;</source>
          <target state="translated">这是有关使用正则表达式验证电子邮件地址的很好的讨论。 &amp;ldquo; &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;比较验证正则表达式的电子邮件地址&lt;/a&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d1cdbf2dd912f5611f94b61c4454aa6be4060872" translate="yes" xml:space="preserve">
          <source>Here is the current top expression, that is JavaScript compatible, for reference purposes:</source>
          <target state="translated">这里是目前最上面的表达式,也就是兼容JavaScript,供参考。</target>
        </trans-unit>
        <trans-unit id="55eaa6630852df71584d8d2c86bd087264a8b11c" translate="yes" xml:space="preserve">
          <source>Here's an &lt;a href=&quot;http://tools.ietf.org/html/rfc22&quot;&gt;RFC22&lt;/a&gt; regular expression for emails:</source>
          <target state="translated">这是电子邮件的&lt;a href=&quot;http://tools.ietf.org/html/rfc22&quot;&gt;RFC22&lt;/a&gt;正则表达式：</target>
        </trans-unit>
        <trans-unit id="d736275ef39d215814e56f8d44f47eb889f757a2" translate="yes" xml:space="preserve">
          <source>Here's an example of it being used in JavaScript (with the case insensitive flag &lt;code&gt;i&lt;/code&gt; at the end).</source>
          <target state="translated">这是在JavaScript中使用的示例（结尾不区分大小写的标记 &lt;code&gt;i&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c9732739a8fa3aa580bff2f06e5dd97f04136a72" translate="yes" xml:space="preserve">
          <source>Here's an example of the above in action:</source>
          <target state="translated">下面是上面的一个例子。</target>
        </trans-unit>
        <trans-unit id="01c3718f65d977f8cd82fb726cefca178b261fbf" translate="yes" xml:space="preserve">
          <source>Here's the JavaScript function I use to check if a string looks like a valid mail address:</source>
          <target state="translated">下面是我用来检查一个字符串是否为有效邮件地址的JavaScript函数。</target>
        </trans-unit>
        <trans-unit id="a4119d32b8e5f26b12cdc6b955694a7dcc855ea3" translate="yes" xml:space="preserve">
          <source>Here's the example of regular expresion that accepts unicode:</source>
          <target state="translated">下面是接受unicode的正则表达式的例子。</target>
        </trans-unit>
        <trans-unit id="9b207348e5f8be6ff4ddfc15b025a7b3adf609d1" translate="yes" xml:space="preserve">
          <source>How to validate an email address in JavaScript</source>
          <target state="translated">如何在JavaScript中验证电子邮件地址</target>
        </trans-unit>
        <trans-unit id="0a1508da59f3e193ff6ad730178c89b7035e88ba" translate="yes" xml:space="preserve">
          <source>I have found this to be the best solution:</source>
          <target state="translated">我发现这是最好的解决方案。</target>
        </trans-unit>
        <trans-unit id="bc3f6146702ab3d562c01bfa05025b507e479858" translate="yes" xml:space="preserve">
          <source>I'm really looking forward to solve this problem.
So I modified email validation regular expression above</source>
          <target state="translated">我真的很希望能解决这个问题。于是我修改了上面的邮件验证正则表达式</target>
        </trans-unit>
        <trans-unit id="a248e3c0f90d17a4614d8a626dbd5b50035fec7a" translate="yes" xml:space="preserve">
          <source>I've put together an example in the fiddle &lt;a href=&quot;http://jsfiddle.net/boldewyn/2b6d5/&quot;&gt;http://jsfiddle.net/boldewyn/2b6d5/&lt;/a&gt;. Combined with feature detection and the bare-bones validation from &lt;a href=&quot;https://stackoverflow.com/a/9204568/324094&quot;&gt;Squirtle's Answer&lt;/a&gt;, it frees you from the regular expression massacre and does not bork on old browsers.</source>
          <target state="translated">我在小提琴&lt;a href=&quot;http://jsfiddle.net/boldewyn/2b6d5/&quot;&gt;http://jsfiddle.net/boldewyn/2b6d5/中&lt;/a&gt;整理了一个示例。 与功能检测和&lt;a href=&quot;https://stackoverflow.com/a/9204568/324094&quot;&gt;Squirtle's Answer&lt;/a&gt;的准系统验证相结合，它将您从正则表达式大屠杀中解脱出来，并且不会在旧的浏览器上出现问题。</target>
        </trans-unit>
        <trans-unit id="d188ab7a43c60291a59eaf6d495c2bf08eaa1e06" translate="yes" xml:space="preserve">
          <source>I've slightly modified &lt;a href=&quot;https://stackoverflow.com/a/48800/4832311&quot;&gt;Jaymon's answer&lt;/a&gt; for people who want really simple validation in the form of:</source>
          <target state="translated">对于需要真正简单验证的人，我对&lt;a href=&quot;https://stackoverflow.com/a/48800/4832311&quot;&gt;Jaymon的答案&lt;/a&gt;做了一些修改：</target>
        </trans-unit>
        <trans-unit id="315db90cf313699f7ac0f7eae75e11e0348020d6" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;em&gt;squirtle&lt;/em&gt;, here is a complex solution, but it does a mighty fine job of validating emails properly:</source>
          <target state="translated">与&lt;em&gt;squirtle相比&lt;/em&gt; ，这是一个复杂的解决方案，但是在正确验证电子邮件方面做得非常出色：</target>
        </trans-unit>
        <trans-unit id="1993773f9359f09e2b2ca1d4dfc92ca22cf0598b" translate="yes" xml:space="preserve">
          <source>In modern browsers you can build on top of @Sushil's answer with pure JavaScript and the &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;:</source>
          <target state="translated">在现代浏览器中，您可以使用纯JavaScript和&lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;在@Sushil的答案之上构建：</target>
        </trans-unit>
        <trans-unit id="bc006f7ff05133b272e5b578dbdd5f956c986749" translate="yes" xml:space="preserve">
          <source>In short, however, the only way to be absolutely, positively sure that what the user entered is in fact an email is to actually send an email and see what happens. Other than that it's all just guesses.</source>
          <target state="translated">然而,简而言之,唯一可以肯定用户输入的内容是否是电子邮件的唯一方法就是实际发送电子邮件,看看会发生什么。除此之外,这一切都只是猜测。</target>
        </trans-unit>
        <trans-unit id="347af515eb75a3a68eafcbe4972692356a8313b5" translate="yes" xml:space="preserve">
          <source>Instead of new &lt;code&gt;RegExp&lt;/code&gt;, just try writing the &lt;code&gt;regexp&lt;/code&gt; out like this:</source>
          <target state="translated">代替新的 &lt;code&gt;RegExp&lt;/code&gt; ，只需尝试将 &lt;code&gt;regexp&lt;/code&gt; 编写如下：</target>
        </trans-unit>
        <trans-unit id="9148998183a2fd2d6f858d4387b1b15dbe4f562a" translate="yes" xml:space="preserve">
          <source>Is there a regular expression to validate an email address in JavaScript?</source>
          <target state="translated">是否有一个正则表达式可以在JavaScript中验证电子邮件地址?</target>
        </trans-unit>
        <trans-unit id="5c7df193a907d0300211071328cac09439891293" translate="yes" xml:space="preserve">
          <source>It allows the following formats:</source>
          <target state="translated">它允许以下格式:</target>
        </trans-unit>
        <trans-unit id="a99b489816040651aa2d1fd871c66978d3772b83" translate="yes" xml:space="preserve">
          <source>It usually catches the most obvious errors that the user makes and assures that the form is mostly right, which is what JavaScript validation is all about.</source>
          <target state="translated">它通常会捕捉到用户最明显的错误,并保证表单大部分是正确的,这就是JavaScript验证的意义所在。</target>
        </trans-unit>
        <trans-unit id="714d1728ca370ac5f7d7ab12a787c823095501a4" translate="yes" xml:space="preserve">
          <source>It's clearly versatile and allows the all-important international characters, while still enforcing the basic anything@anything.anything format. It will block spaces which are technically allowed by RFC, but they are so rare that I'm happy to do this.</source>
          <target state="translated">它显然是多功能的,允许使用所有重要的国际字符,同时仍然执行基本的anything@anything.anything 格式。它将阻止RFC技术上允许的空格,但它们是如此罕见,所以我很乐意这样做。</target>
        </trans-unit>
        <trans-unit id="c6c2d56e6e9e295b27bec153395a14c0aa7220fe" translate="yes" xml:space="preserve">
          <source>It's hard to get an email validator 100% correct. The only real way to get it correct would be to send a test email to the account. That said, there are a few basic checks that can help make sure that you're getting something reasonable.</source>
          <target state="translated">要让邮件验证器100%正确是很难的。唯一真正让它正确的方法是向账户发送测试邮件。话虽如此,但有一些基本的检查可以帮助确保你得到的东西是合理的。</target>
        </trans-unit>
        <trans-unit id="f8411e7c9328a36b4cbb59bb9fec5b52faa58933" translate="yes" xml:space="preserve">
          <source>JavaScript can match a regular expression:</source>
          <target state="translated">JavaScript可以匹配一个正则表达式。</target>
        </trans-unit>
        <trans-unit id="462f80793e03276bd6ae7f412a16f5c7dab9a1c7" translate="yes" xml:space="preserve">
          <source>Just for completeness, &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;here you have another RFC 2822 compliant regex&lt;/a&gt;</source>
          <target state="translated">为了完整&lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;起见&lt;/a&gt; ， 这里有另一个符合RFC 2822的正则表达式</target>
        </trans-unit>
        <trans-unit id="19a532c8bc61c311f583455c80ffe37067bbc9bb" translate="yes" xml:space="preserve">
          <source>Modified</source>
          <target state="translated">Modified</target>
        </trans-unit>
        <trans-unit id="43b887329c39991ed9342ff2808e53e763031ba1" translate="yes" xml:space="preserve">
          <source>More info: &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;http://www.regular-expressions.info/email.html&lt;/a&gt;</source>
          <target state="translated">更多信息： &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;http&lt;/a&gt; : //www.regular-expressions.info/email.html</target>
        </trans-unit>
        <trans-unit id="76276228f6a79582360d144c94d0e6a56cd45f09" translate="yes" xml:space="preserve">
          <source>My knowledge of &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expressions&lt;/a&gt; is not that good. That's why I check the general syntax with a simple regular expression first and check more specific options with other functions afterwards. This may not be not the best technical solution, but this way I'm way more flexible and faster.</source>
          <target state="translated">我对&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;正则表达式的&lt;/a&gt;了解不是很好。 这就是为什么我首先使用简单的正则表达式检查常规语法，然后再使用其他函数检查更具体的选项的原因。 这可能不是最佳的技术解决方案，但是通过这种方式，我可以变得更加灵活和快捷。</target>
        </trans-unit>
        <trans-unit id="55fe3dadfccb59bf35ba0495e729e2f066123820" translate="yes" xml:space="preserve">
          <source>Now since you can only cover 90% of the cases, write something like:</source>
          <target state="translated">现在,既然你只能覆盖90%的案件,那就写一些类似的东西。</target>
        </trans-unit>
        <trans-unit id="83cc9c6ad80b66e95f932227fdb6532df66d4148" translate="yes" xml:space="preserve">
          <source>Often when storing email addresses in the database I make them lowercase and, in practice, regexs can usually be marked case insensitive. In those cases this is slightly shorter:</source>
          <target state="translated">通常在数据库中存储电子邮件地址时,我通常会将其小写,在实际操作中,通常情况下,regexs可以不区分大小写。在这些情况下,这就稍微短一点。</target>
        </trans-unit>
        <trans-unit id="c0a8060f3b1102da85ef318544468f24221e6515" translate="yes" xml:space="preserve">
          <source>Original</source>
          <target state="translated">Original</target>
        </trans-unit>
        <trans-unit id="a70eee5dd9722ceee12b43905700a9eadb6e7b6e" translate="yes" xml:space="preserve">
          <source>Regex for validating email address</source>
          <target state="translated">用于验证电子邮件地址的验证码</target>
        </trans-unit>
        <trans-unit id="82f6a0d73051b421407fc4a9df3d93285e7f9585" translate="yes" xml:space="preserve">
          <source>Regex update 2018! try this</source>
          <target state="translated">2018年REGEX更新!试试这个</target>
        </trans-unit>
        <trans-unit id="9696f8b9a85d838f4f9eed88d0e6759d6f674fbf" translate="yes" xml:space="preserve">
          <source>Second, check to make sure that a period comes after the &lt;code&gt;@&lt;/code&gt; sign, and make sure that there are characters between the &lt;code&gt;@&lt;/code&gt;s and periods.</source>
          <target state="translated">其次，检查以确保句号在 &lt;code&gt;@&lt;/code&gt; 符号后面，并确保 &lt;code&gt;@&lt;/code&gt; s和句点之间有字符。</target>
        </trans-unit>
        <trans-unit id="a55492e77609ea34ff33de5ed0aaf5c9ff5c7e90" translate="yes" xml:space="preserve">
          <source>Simply check out if the entered email address is valid or not using HTML.</source>
          <target state="translated">只需使用HTML检查输入的电子邮件地址是否有效。</target>
        </trans-unit>
        <trans-unit id="ccbd8edc536e38c01c66151bde97d343991d5964" translate="yes" xml:space="preserve">
          <source>So even when following official standards, there are still trade-offs to be made. &lt;strong&gt;&lt;em&gt;Don't blindly copy regular expressions from online libraries or discussion forums. Always test them on your own data and with your own applications.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">因此，即使遵循官方标准，仍然需要权衡取舍。 &lt;strong&gt;&lt;em&gt;不要盲目地从在线图书馆或论坛中复制正则表达式。&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;始终根据自己的数据和自己的应用程序对其进行测试。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1838964c9b448ad5c03e2b47885618f97f813137" translate="yes" xml:space="preserve">
          <source>Some things to improve:</source>
          <target state="translated">一些需要改进的地方。</target>
        </trans-unit>
        <trans-unit id="1518ae57cfe2ed8a133afc03011cb0263227ca7b" translate="yes" xml:space="preserve">
          <source>Taken from &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&lt;/a&gt; on Oct 1 '10.</source>
          <target state="translated">取自10年10月1日&lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6fb1c04bf21f84884bce0fe4918114f74c0cab0" translate="yes" xml:space="preserve">
          <source>Technically some emails can include quotes in the section before the &lt;code&gt;@&lt;/code&gt; symbol with escape characters inside the quotes (so your email user can be obnoxious and contain stuff like &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;&quot;...&quot;&lt;/code&gt; as long as it's written in quotes). NOBODY DOES THIS EVER! It's obsolete. But, it IS included in the true &lt;a href=&quot;https://www.ietf.org/rfc/rfc2822.txt&quot;&gt;RFC 2822&lt;/a&gt; standard, and omitted here.</source>
          <target state="translated">从技术上讲，某些电子邮件可以在 &lt;code&gt;@&lt;/code&gt; 符号前的部分中包含引号，并在引号内包含转义符（因此，您的电子邮件用户可能很讨厌，并且只要使用引号将其包含 &lt;code&gt;@&lt;/code&gt; 和 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 之类的内容）。 Nobody做到这一点！ 已经过时了。 但是，它包含在真正的&lt;a href=&quot;https://www.ietf.org/rfc/rfc2822.txt&quot;&gt;RFC 2822&lt;/a&gt;标准中，在此省略。</target>
        </trans-unit>
        <trans-unit id="2c42e1dbf8f30a22743d35f41dec49ad83dcbd78" translate="yes" xml:space="preserve">
          <source>The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.</source>
          <target state="translated">下面这个兼容JavaScript和Perl的正则表达式就是上述定义的实现。</target>
        </trans-unit>
        <trans-unit id="acf10a9a6c9b7ded0b17a3c178b673c5a6b22d4e" translate="yes" xml:space="preserve">
          <source>The most common errors I've come across are spaces (especially at the beginning and end) and occasionally a double dot.</source>
          <target state="translated">我遇到的最常见的错误是空格(尤其是开头和结尾),偶尔也会出现双点。</target>
        </trans-unit>
        <trans-unit id="e575176116c75b6cd106b88dfa99d3c160478169" translate="yes" xml:space="preserve">
          <source>The official standard is known as &lt;a href=&quot;https://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt;. It describes the syntax that valid email addresses must adhere to. You can (&lt;strong&gt;but you shouldn't&lt;/strong&gt; &amp;mdash; &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;read on&lt;/a&gt;) implement it with this regular expression:</source>
          <target state="translated">官方标准称为&lt;a href=&quot;https://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt; 。 它描述了有效电子邮件地址必须遵守的语法。 您可以（ &lt;strong&gt;但不应继续&lt;/strong&gt; &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;阅读&lt;/a&gt; ）使用以下正则表达式实现它：</target>
        </trans-unit>
        <trans-unit id="941d12bdf6866507609a342766f852faec160c1e" translate="yes" xml:space="preserve">
          <source>The regular expression provided by Microsoft within &lt;a href=&quot;http://en.wikipedia.org/wiki/ASP.NET_MVC_Framework&quot;&gt;ASP.NET MVC&lt;/a&gt; is</source>
          <target state="translated">Microsoft在&lt;a href=&quot;http://en.wikipedia.org/wiki/ASP.NET_MVC_Framework&quot;&gt;ASP.NET MVC中&lt;/a&gt;提供的正则表达式为</target>
        </trans-unit>
        <trans-unit id="45144d24f561ff5e2946df80fc43f503ab825e60" translate="yes" xml:space="preserve">
          <source>The regular expression:</source>
          <target state="translated">正规的表达方式。</target>
        </trans-unit>
        <trans-unit id="16042eba1725f6c0d572cb3c8443990439ce36bb" translate="yes" xml:space="preserve">
          <source>The world needs simpler code...</source>
          <target state="translated">这个世界需要更简单的代码.....</target>
        </trans-unit>
        <trans-unit id="94032b10ee1f8d5a97f30f3c782c842eb909e10a" translate="yes" xml:space="preserve">
          <source>There isn't any need to write a function for validation.</source>
          <target state="translated">不需要写一个函数进行验证。</target>
        </trans-unit>
        <trans-unit id="4653e258277090cf523691e460e7e53ec60cf120" translate="yes" xml:space="preserve">
          <source>There's something you have to understand the second you decide to use a regular expression to validate emails: &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;It's probably not a good idea&lt;/a&gt;. Once you have come to terms with that, there are many implementations out there that can get you halfway there, &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;this article sums them up nicely.&lt;/a&gt;</source>
          <target state="translated">在决定使用正则表达式验证电子邮件时，您需要了解一些内容： &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;这可能不是一个好主意&lt;/a&gt; 。 一旦您对此有所了解，就有许多实现可以使您半途而废， &lt;a href=&quot;http://www.regular-expressions.info/email.html&quot;&gt;本文对它们进行了很好的总结。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="630e1ebe59de2ebe03b87070aee8483c90aca2e4" translate="yes" xml:space="preserve">
          <source>This is how &lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;node-validator&lt;/a&gt; does it:</source>
          <target state="translated">这是&lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;节点验证器的&lt;/a&gt;操作方式：</target>
        </trans-unit>
        <trans-unit id="e923b31f669b92caf8faf75409dfa855b536d9c3" translate="yes" xml:space="preserve">
          <source>This is the correct RFC822 version.</source>
          <target state="translated">这就是正确的RFC822版本。</target>
        </trans-unit>
        <trans-unit id="98135052de405526350db1b89c86c41136ccf880" translate="yes" xml:space="preserve">
          <source>This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of RFC 5322, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &quot;@&quot; character), too vague (after the &quot;@&quot; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">此要求是对RFC 5322的&lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;故意违反&lt;/a&gt; ，RFC 5322为电子邮件地址定义了一种语法，该语法同时过于严格（在&amp;ldquo; @&amp;rdquo;字符之前），过于模糊（在&amp;ldquo; @&amp;rdquo;字符之后）和过于宽松（允许注释） ，空格字符和带引号的字符串（大多数用户不熟悉的方式）在此处具有实际用途。</target>
        </trans-unit>
        <trans-unit id="48569f5e4634aefd2b80beb29b7935143c8e99ad" translate="yes" xml:space="preserve">
          <source>This was stolen from &lt;a href=&quot;http://codesnippets.joyent.com/posts/show/1917&quot;&gt;http://codesnippets.joyent.com/posts/show/1917&lt;/a&gt;</source>
          <target state="translated">这是从&lt;a href=&quot;http://codesnippets.joyent.com/posts/show/1917&quot;&gt;http://codesnippets.joyent.com/posts/show/1917&lt;/a&gt;被盗的</target>
        </trans-unit>
        <trans-unit id="72bc65d3fc80e4c4bca49e2352036074e3d2e1fd" translate="yes" xml:space="preserve">
          <source>To test that, send a validation message.</source>
          <target state="translated">为了测试这一点,发送一条验证消息。</target>
        </trans-unit>
        <trans-unit id="280b7af2c0707f401085e67adc9102c8145b601f" translate="yes" xml:space="preserve">
          <source>Use like so:</source>
          <target state="translated">像这样使用。</target>
        </trans-unit>
        <trans-unit id="d07fe7db1c7da2a64b448acb9bf6362ec1ad00db" translate="yes" xml:space="preserve">
          <source>Use this code inside your validator function:</source>
          <target state="translated">在你的验证器函数中使用此代码。</target>
        </trans-unit>
        <trans-unit id="57073d762acf8b6ec0f1442441f428af780cc6e5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expressions&lt;/a&gt; is probably the best way. You can see a bunch of tests &lt;a href=&quot;http://jsfiddle.net/ghvj4gy9/embedded/result,js/&quot;&gt;here&lt;/a&gt; (taken from &lt;a href=&quot;https://cs.chromium.org/chromium/src/third_party/blink/web_tests/fast/forms/resources/ValidityState-typeMismatch-email.js?q=ValidityState-typeMismatch-email.js&amp;amp;sq=package:chromium&amp;amp;dr&quot;&gt;chromium&lt;/a&gt;)</source>
          <target state="translated">使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;正则表达式&lt;/a&gt;可能是最好的方法。 您可以&lt;a href=&quot;http://jsfiddle.net/ghvj4gy9/embedded/result,js/&quot;&gt;在此处&lt;/a&gt;看到很多测试（取自&lt;a href=&quot;https://cs.chromium.org/chromium/src/third_party/blink/web_tests/fast/forms/resources/ValidityState-typeMismatch-email.js?q=ValidityState-typeMismatch-email.js&amp;amp;sq=package:chromium&amp;amp;dr&quot;&gt;铬&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="b9e8f0aa49270c5886db87d3f533dcbfba02090e" translate="yes" xml:space="preserve">
          <source>Which I post here in case it's flawed - though it's always been perfect for my needs.</source>
          <target state="translated">我在这里发布,以防万一它有缺陷--虽然它一直都很适合我的需求。</target>
        </trans-unit>
        <trans-unit id="ca6567da36e820bab2c3f907ddc5877f381c711d" translate="yes" xml:space="preserve">
          <source>Why?  &lt;strong&gt;It's based on &lt;a href=&quot;https://www.ietf.org/rfc/rfc2822.txt&quot;&gt;RFC 2822&lt;/a&gt;&lt;/strong&gt;, which is a standard ALL email addresses MUST adhere to.  And I'm not sure why you'd bother with something &quot;simpler&quot;... you're gonna copy and paste it anyway ;)</source>
          <target state="translated">为什么？ &lt;strong&gt;它基于&lt;a href=&quot;https://www.ietf.org/rfc/rfc2822.txt&quot;&gt;RFC 2822&lt;/a&gt;&lt;/strong&gt; ， &lt;strong&gt;RFC 2822&lt;/strong&gt;是必须遵循的标准所有电子邮件地址。 而且我不确定为什么您会麻烦一些&amp;ldquo;简单&amp;rdquo;的东西&amp;hellip;&amp;hellip;无论如何都要复制并粘贴它；）</target>
        </trans-unit>
        <trans-unit id="5e1bff561da6219badfcaad8cb451347e48e4246" translate="yes" xml:space="preserve">
          <source>Wow, there are lots of complexity here. If all you want to do is just catch the most obvious syntax errors, I would do something like this:</source>
          <target state="translated">哇,这里有很多复杂的地方。如果你想做的只是抓住最明显的语法错误,我会这样做。</target>
        </trans-unit>
        <trans-unit id="97b604f9ee54aee64d0bc1a6ff444c9f6b9302b7" translate="yes" xml:space="preserve">
          <source>You can refine it. For instance, 'aaa@' is valid. But overall you get the gist. And don't get carried away... A simple 90% solution is better than 100% solution that does not work.</source>
          <target state="translated">你可以细化一下。比如说,'aa@'是有效的。但总的来说,你已经明白了。也不要得意忘形.....。一个简单的90%的解决方案总比100%的解决方案无效要好。</target>
        </trans-unit>
        <trans-unit id="f3ea2dc3cd08e78009685d0096abc89812a523e9" translate="yes" xml:space="preserve">
          <source>You should not use regular expressions to validate an input string to check if it's an email. It's too complicated and would not cover all the cases.</source>
          <target state="translated">你不应该使用正则表达式来验证一个输入字符串是否是电子邮件。这太复杂了,而且不会涵盖所有的情况。</target>
        </trans-unit>
        <trans-unit id="7dd4057835b8dc1717f15922fc3cc2257c048d1e" translate="yes" xml:space="preserve">
          <source>more info &lt;a href=&quot;https://git.io/vhEfc&quot;&gt;https://git.io/vhEfc&lt;/a&gt;</source>
          <target state="translated">更多信息&lt;a href=&quot;https://git.io/vhEfc&quot;&gt;https://git.io/vhEfc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6e11122ef5af8d566438931e8c2ffc049747762" translate="yes" xml:space="preserve">
          <source>to pass the examples in &lt;a href=&quot;https://en.wikipedia.org/wiki/Email_address#cite_note-20/syntax&quot;&gt;Wikipedia Email Address&lt;/a&gt;.</source>
          <target state="translated">通过&lt;a href=&quot;https://en.wikipedia.org/wiki/Email_address#cite_note-20/syntax&quot;&gt;Wikipedia电子邮件地址中&lt;/a&gt;的示例。</target>
        </trans-unit>
        <trans-unit id="d0462cbe40aaaa8c3f944bec1e809689cec9b0a3" translate="yes" xml:space="preserve">
          <source>typscript version complete</source>
          <target state="translated">打字版完成</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
