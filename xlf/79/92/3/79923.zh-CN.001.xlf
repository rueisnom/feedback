<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/79923">
    <body>
      <group id="79923">
        <trans-unit id="94b77d4c21edabc0121f024c01bcc9ef48259dc3" translate="yes" xml:space="preserve">
          <source>&quot;Static&quot; (AKA statically allocated) variables are not allocated on the stack. Do not assume so - many people do only because &quot;static&quot; sounds a lot like &quot;stack&quot;. They actually exist in neither the stack nor the heap. The are part of what's called the &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_segment&quot;&gt;data segment&lt;/a&gt;.</source>
          <target state="translated">未在堆栈上分配&amp;ldquo;静态&amp;rdquo;（又称静态分配）变量。 不要这么假设-许多人这样做只是因为&amp;ldquo;静态&amp;rdquo;听起来很像&amp;ldquo;堆栈&amp;rdquo;。 它们实际上既不存在于堆栈中，也不存在于堆中。 是所谓的&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_segment&quot;&gt;数据段的一部分&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7b5c0042bc6fdc5e224949119eea46897b85f96" translate="yes" xml:space="preserve">
          <source>&quot;You can use the stack if you know exactly how much data you need to allocate before compile time, and it is not too big. You can use the heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data.&quot;</source>
          <target state="translated">&quot;如果你在编译前确切地知道需要分配多少数据,并且不是太大,你可以使用堆。如果你不清楚运行时需要多少数据,或者需要分配大量的数据,你可以使用堆。&quot;</target>
        </trans-unit>
        <trans-unit id="6b71c1598ca48211c09537cb37ffecd0279e4352" translate="yes" xml:space="preserve">
          <source>(I have moved this answer from another question that was more or less a dupe of this one.)</source>
          <target state="translated">(我把这个答案从另一个或多或少的问题上移到了这个问题上,而这个问题或多或少是这个问题的翻版)。</target>
        </trans-unit>
        <trans-unit id="61257768b7a93e136c9c290d6825931b71bdb701" translate="yes" xml:space="preserve">
          <source>(Relatively) slower access</source>
          <target state="translated">(相对)进入速度较慢</target>
        </trans-unit>
        <trans-unit id="260e2615aff475120193632bb3dec58b387e3862" translate="yes" xml:space="preserve">
          <source>1) Where and what are they (physically in a real computer's memory)?</source>
          <target state="translated">1)它们在哪里,是什么(物理上在真正的计算机内存中)?</target>
        </trans-unit>
        <trans-unit id="fdb1507c9ac6adb1fa6fa6251df8690b83ca6414" translate="yes" xml:space="preserve">
          <source>2) To what extent are they controlled by the OS or language runtime?</source>
          <target state="translated">2)它们在多大程度上受操作系统或语言运行时的控制?</target>
        </trans-unit>
        <trans-unit id="99b4e74430a1011d0a32a5e6a68f89192d5600f4" translate="yes" xml:space="preserve">
          <source>2b) What is their scope?</source>
          <target state="translated">2b)其范围是什么?</target>
        </trans-unit>
        <trans-unit id="9888f38f3e423435fa5b8292adbdd39fb0f72092" translate="yes" xml:space="preserve">
          <source>2c) What determines the size of each of them?</source>
          <target state="translated">2c)是什么决定了它们各自的大小?</target>
        </trans-unit>
        <trans-unit id="019eef749bba4958d2ffca2f9849b67199fb6815" translate="yes" xml:space="preserve">
          <source>2d) What makes one faster?</source>
          <target state="translated">2d)什么使人更快?</target>
        </trans-unit>
        <trans-unit id="e2d2295e136ea1dc3f598156ec945a446432c714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Local Variables&lt;/code&gt; that only need to last as long as the function invocation go in the stack. The heap is used for variables whose lifetime we don't really know up front but we expect them to last a while. In most languages it's critical that we know at compile time how large a variable is if we want to store it on the stack.</source>
          <target state="translated">仅需要持续函数调用的 &lt;code&gt;Local Variables&lt;/code&gt; 就会进入堆栈。 堆用于变量，这些变量的寿命我们并不是很早就知道，但是我们希望它们能持续一段时间。 在大多数语言中，至关重要的一点是，我们要在编译时知道要将变量存储在堆栈中的大小。</target>
        </trans-unit>
        <trans-unit id="db81e688d99a4e08a6e79477826a7c115e20208c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To what extent are they controlled by the OS or language runtime?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;它们在多大程度上受操作系统或语言运行时的控制？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="513a3b3ab4e6ae37babfa4b83b1cb3c51c31881a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What determines the size of each of them?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;什么决定了它们的大小？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d053678e5d47e6f07a8fde4ce00b7cddb559cbb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is their scope?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;他们的范围是什么？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dcfa20263ead7486e0e7d967879203f1a13837a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What makes one faster?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;是什么使速度更快？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9a6c5f939fd49e7bad84b2be8abb7f468b02d07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Both together&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;两者一起&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84a530a09edadff20200961546fdc028c855eefc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heap:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Heap:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85e58808cd94b0b4694342607d9808c4b578db9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Heap&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="917e40efec8d1d189c6f18faaf670f99b1bd7e44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heap&lt;/strong&gt;: No order, processing gonna be slower and values are messed up together with no specific order or index... there are random and there is no relationship between them... so execution and usage time could be vary...</source>
          <target state="translated">&lt;strong&gt;堆&lt;/strong&gt; ：没有顺序，处理会变慢，并且值被弄乱了，没有特定的顺序或索引...是随机的，它们之间没有关系...因此执行和使用时间可能会有所不同...</target>
        </trans-unit>
        <trans-unit id="742792f83b9d6d503d676cd5342ac745b1a51f3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;
Implementation of both the stack and heap is usually down to the runtime / OS. Often games and other applications that are performance critical create their own memory solutions that grab a large chunk of memory from the heap and then dish it out internally to avoid relying on the OS for memory.</source>
          <target state="translated">&lt;strong&gt;实现&lt;/strong&gt;堆栈和堆的实现通常取决于运行时/ OS。 通常，性能至关重要的游戏和其他应用程序会创建自己的内存解决方案，这些解决方案会从堆中获取大量内存，然后在内部进行分配，以避免依赖OS来获取内存。</target>
        </trans-unit>
        <trans-unit id="b0c3414fb835eb86d73b6be57a2a7aebafd2801c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interesting note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;有趣的注意事项：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a0e3df07fea6c0d8b408481568ec08761eb430d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; simply and in short words, they mean &lt;strong&gt;ordered&lt;/strong&gt; and &lt;strong&gt;not ordered&lt;/strong&gt;...!</source>
          <target state="translated">&lt;strong&gt;好吧，&lt;/strong&gt;简单地说，它们的意思是&lt;strong&gt;有序的&lt;/strong&gt;而&lt;strong&gt;不是有序的&lt;/strong&gt; ！</target>
        </trans-unit>
        <trans-unit id="8628c9ba0a73bc55254ac6ceb73adfa8e4eada2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Physical location in memory&lt;/strong&gt;
This is less relevant than you think because of a technology called &lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_memory&quot;&gt;Virtual Memory&lt;/a&gt; which makes your program think that you have access to a certain address where the physical data is somewhere else (even on the hard disc!). The addresses you get for the stack are in increasing order as your call tree gets deeper. The addresses for the heap are un-predictable (i.e implimentation specific) and frankly not important.</source>
          <target state="translated">&lt;strong&gt;内存中的物理位置&lt;/strong&gt;这与您想像的无关紧要，因为一项称为&amp;ldquo; &lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_memory&quot;&gt;虚拟内存&lt;/a&gt; &amp;rdquo;的技术使程序认为您可以访问物理数据在其他地方（甚至在硬盘上！）的某个地址。 随着调用树的不断深入，您为堆栈获取的地址以递增的顺序排列。 堆的地址是不可预测的（即特定于隐含的），并且坦率地说并不重要。</target>
        </trans-unit>
        <trans-unit id="e19a9343f895eca75944e60482202b71e0cbcd58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stack:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Stack:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c741ee79de20716b9e2549b13bac80467d01d08f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stack&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Stack&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7e4ac541ac7066d86d467c49418a1b8c8ab19f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stack&lt;/strong&gt;: In stack items, things get on the top of each-other, means gonna be faster and more efficient to be processed!...</source>
          <target state="translated">堆垛：在堆垛物品中，东西相互叠放，意味着可以更快，更高效地进行处理！...</target>
        </trans-unit>
        <trans-unit id="7e7cfe5d1f60635f341d1ef4579eb83f724c5d41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Heap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;堆&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6709062928227b6319f7deeb9a0847d3a67f3a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Heap&lt;/strong&gt;
The heap is a generic name for where you put the data that you create on the fly. If you don't know how many spaceships your program is going to create, you are likely to use the new (or malloc or equivalent) operator to create each spaceship. This allocation is going to stick around for a while, so it is likely we will free things in a different order than we created them.</source>
          <target state="translated">堆堆是用于将创建的数据动态放置的位置的通用名称。 如果您不知道程序将要创建多少个太空飞船，则很可能使用新的（或malloc或等效的）运算符来创建每个太空飞船。 这种分配将持续一段时间，因此很可能我们将以与创建它们不同的顺序释放事物。</target>
        </trans-unit>
        <trans-unit id="bcb3f513eb6fa7ddc8d6c4dc2b21d182cce677d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Stack&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;堆栈&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a390d755244266caf60a0813cd14b6beb633141e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Stack&lt;/strong&gt;
When you call a function the arguments to that function plus some other overhead is put on the stack. Some info (such as where to go on return) is also stored there.
When you declare a variable inside your function, that variable is also allocated on the stack.</source>
          <target state="translated">&lt;strong&gt;堆栈&lt;/strong&gt;调用函数时，该函数的参数以及其他一些开销将被放入堆栈中。 一些信息（例如返回目的地）也存储在此处。 当您在函数内声明变量时，该变量也分配在堆栈上。</target>
        </trans-unit>
        <trans-unit id="76cc17ae17ebb267fcbd177db1d4f1d292b7ce9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To what extent are they controlled by the OS or language runtime?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;它们在多大程度上受操作系统或语言运行时的控制？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0563b18a23e550f58bac67d459c94a52a3249acd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What determines the size of each of them?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么决定了它们的大小？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c6c7dce19b600ea980045fc6edcd1962f6b5551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a heap?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么是堆？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b97a8d104003b830b171fde9ab6c0f738620e336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a stack?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么是堆栈？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6b73e40eadb8e589a235f27b4b54d80562f2496" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is their scope?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;他们的范围是什么？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="159e5d461f5ea67df5f298bd8e4358250caeb1b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What makes one faster?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;是什么使速度更快？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="78f9413c67586527ba6c81668b7aa287b0c28430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Which is faster &amp;ndash; the stack or the heap? And why?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;哪个更快-堆栈还是堆？&lt;/strong&gt; &lt;strong&gt;又为什么呢？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad882499bf2a5c77de197c8c4907389551e5d253" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stack&lt;/strong&gt;, &lt;strong&gt;heap&lt;/strong&gt; and &lt;strong&gt;data&lt;/strong&gt; of each process in virtual memory:</source>
          <target state="translated">虚拟内存中每个进程的&lt;strong&gt;堆栈&lt;/strong&gt; ， &lt;strong&gt;堆&lt;/strong&gt;和&lt;strong&gt;数据&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="2e2ab5cd39dfbdc8c03b7bbbbd7b88d895cbeb77" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Image source: &lt;a href=&quot;http://vikashazrati.wordpress.com/2007/10/01/quicktip-java-basics-stack-and-heap/&quot;&gt;vikashazrati.wordpress.com&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;图片来源： &lt;a href=&quot;http://vikashazrati.wordpress.com/2007/10/01/quicktip-java-basics-stack-and-heap/&quot;&gt;vikashazrati.wordpress.com&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="66efe8c438bd049d124a2fb9c161181488baa05f" translate="yes" xml:space="preserve">
          <source>A clear demonstration:</source>
          <target state="translated">明确的示范。</target>
        </trans-unit>
        <trans-unit id="01ce9bd8f6baf3c7c49927f90f1d012016d83e18" translate="yes" xml:space="preserve">
          <source>A couple of cents: I think, it will be good to draw memory graphical and more simple:</source>
          <target state="translated">几分钱。我觉得,画出记忆图形化,比较简单,会很好。</target>
        </trans-unit>
        <trans-unit id="a15b908bf3b3ecfd069a0fe5e01ef6e82a56da1d" translate="yes" xml:space="preserve">
          <source>A heap is a general term for anything that can be dynamically allocated.  Depending on which way you look at it, it is constantly changing size.  In modern processors and operating systems the exact way it works is very abstracted anyway, so you don't normally need to worry much about how it works deep down, except that (in languages where it lets you) you mustn't use memory that you haven't allocated yet or memory that you have freed.</source>
          <target state="translated">堆是对任何可以动态分配的东西的总称。根据你从哪种角度来看,它的大小是不断变化的。在现代的处理器和操作系统中,它的确切工作方式是非常抽象的,所以你通常不需要担心它的深层工作原理,只是(在它允许你使用的语言中)你不能使用你还没有分配的内存或你已经释放的内存。</target>
        </trans-unit>
        <trans-unit id="068dd7e9d8ed5b397b0a6eff3ba84c4edc71f672" translate="yes" xml:space="preserve">
          <source>A heap is a general term used for any memory that is allocated dynamically and randomly; i.e. out of order.  The memory is typically allocated by the OS, with the application calling API functions to do this allocation.  There is a fair bit of overhead required in managing dynamically allocated memory, which is usually handled by the runtime code of the programming language or environment used.</source>
          <target state="translated">堆是一个统称,指的是任何动态和随机分配的内存,即不按顺序分配的内存。这些内存通常由操作系统分配,应用程序调用API函数来进行分配。在管理动态分配的内存时,需要有一定的开销,通常由编程语言或环境的运行时代码来处理。</target>
        </trans-unit>
        <trans-unit id="34f5d3ec6b1ce5253cef0356a62d5aa350e32ac5" translate="yes" xml:space="preserve">
          <source>A heap is an untidy collection of things piled up haphazardly.</source>
          <target state="translated">所谓 &quot;堆&quot;,是指杂乱无章地堆积在一起的东西。</target>
        </trans-unit>
        <trans-unit id="ee141ae29a5c83c4f8aa0cade4298cafffd77712" translate="yes" xml:space="preserve">
          <source>A lot of answers are correct as concepts, but we must note that a stack is needed by the hardware (i.e. microprocessor) to allow calling subroutines (CALL in assembly language..). (OOP guys will call it &lt;em&gt;methods&lt;/em&gt;)</source>
          <target state="translated">许多答案在概念上都是正确的，但是我们必须注意，硬件（即微处理器）需要一个堆栈才能允许调用子例程（汇编语言中的CALL ..）。 （OOP家伙会称其为&lt;em&gt;方法&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="c31b57674dbc2b0d1d5439a1c86d854b8d2b25b9" translate="yes" xml:space="preserve">
          <source>A particularly poignant example of why it's important to distinguish between lifetime and scope is that a variable can have local scope but static lifetime - for instance, &quot;someLocalStaticVariable&quot; in the code sample above. Such variables can make our common but informal naming habits very confusing. For instance when we say &quot;&lt;em&gt;local&lt;/em&gt;&quot; we usually mean &quot;&lt;em&gt;locally scoped automatically allocated variable&lt;/em&gt;&quot; and when we say global we usually mean &quot;&lt;em&gt;globally scoped statically allocated variable&lt;/em&gt;&quot;. Unfortunately when it comes to things like &quot;&lt;em&gt;file scoped statically allocated variables&lt;/em&gt;&quot; many people just say... &quot;&lt;em&gt;huh???&lt;/em&gt;&quot;.</source>
          <target state="translated">为什么区分生命周期和作用域很重要的一个特别令人伤心的示例是变量可以具有局部作用域，但具有静态生命周期-例如，上面的代码示例中的&amp;ldquo; someLocalStaticVariable&amp;rdquo;。 这些变量会使我们常见但非正式的命名习惯非常混乱。 例如，当我们说&amp;ldquo; &lt;em&gt;本地&lt;/em&gt; &amp;rdquo;时，我们通常是指&amp;ldquo; &lt;em&gt;本地范围内的自动分配变量&lt;/em&gt; &amp;rdquo;，而当我们说&amp;ldquo; &lt;em&gt;全局&lt;/em&gt; &amp;rdquo;时，我们通常是指&amp;ldquo; &lt;em&gt;全局范围的静态分配变量&lt;/em&gt; &amp;rdquo;。 不幸的是，当涉及到&amp;ldquo; &lt;em&gt;文件范围内的静态分配的变量&lt;/em&gt; &amp;rdquo;之类的事情时，许多人只是在说&amp;hellip;&amp;hellip;。</target>
        </trans-unit>
        <trans-unit id="cc133acebf965ce867ad157a05f353a3707fecd3" translate="yes" xml:space="preserve">
          <source>A stack is a pile of objects, typically one that is neatly arranged.</source>
          <target state="translated">所谓的堆栈,一般是指堆放整齐的物品,一般是指堆放整齐的物品。</target>
        </trans-unit>
        <trans-unit id="9f4c46ea1849c89970aa6079e049594ebbd9a39c" translate="yes" xml:space="preserve">
          <source>A stack is used for static memory allocation and a heap for dynamic memory allocation, both stored in the computer's RAM.</source>
          <target state="translated">栈用于静态内存分配,堆用于动态内存分配,两者都存储在计算机的RAM中。</target>
        </trans-unit>
        <trans-unit id="7d53fc8a81490a3d76add68a85ec8e7f0f02250f" translate="yes" xml:space="preserve">
          <source>A typical C program was laid out flat in memory with
an opportunity to increase by changing the brk() value.
Typically, the HEAP was just below this brk value
and increasing brk increased the amount of available heap.</source>
          <target state="translated">一个典型的C语言程序在内存中平铺,通过改变brk()值来增加机会。通常情况下,HEAP刚好低于这个brk值,增加brk值会增加可用堆的数量。</target>
        </trans-unit>
        <trans-unit id="0eb3c88bb9382983d9131328ce15ca6b37271be5" translate="yes" xml:space="preserve">
          <source>Again, it depends on the language, compiler, operating system and architecture.  A stack is usually pre-allocated, because by definition it must be contiguous memory.  The language compiler or the OS determine its size.  You don't store huge chunks of data on the stack, so it'll be big enough that it should never be fully used, except in cases of unwanted endless recursion (hence, &quot;stack overflow&quot;) or other unusual programming decisions.</source>
          <target state="translated">同样,这取决于语言、编译器、操作系统和体系结构。栈通常是预分配的,因为根据定义,它必须是连续的内存。语言编译器或操作系统决定了它的大小。你不会在堆栈上存储大块的数据,所以它将足够大,除非是在不需要的无尽递归(因此,&quot;堆栈溢出&quot;)或其他不寻常的编程决定的情况下,否则它永远不应该被完全使用。</target>
        </trans-unit>
        <trans-unit id="3c53181b48366809a97c6caadb3cafb768a586d9" translate="yes" xml:space="preserve">
          <source>Allocating and deallocating many small blocks may leave the heap in a state where there are a lot of small free blocks interspersed between the used blocks. A request to allocate a large block may fail because none of the free blocks are large enough to satisfy the allocation request even though the combined size of the free blocks may be large enough. This is called &lt;em&gt;heap fragmentation&lt;/em&gt;.</source>
          <target state="translated">分配和释放许多小块可能会使堆处于这样一种状态，即在已使用的块之间散布着许多小空闲块。 分配大块的请求可能会失败，因为即使空闲块的组合大小可能足够大，也没有一个空闲块足以满足分配请求。 这称为&lt;em&gt;堆碎片&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="038e52e8565cce864ffd7e1b894e6892fe5a1d29" translate="yes" xml:space="preserve">
          <source>Allocating memory on the stack is as simple as moving the stack pointer up.</source>
          <target state="translated">在堆栈上分配内存就像将堆栈指针向上移动一样简单。</target>
        </trans-unit>
        <trans-unit id="361ef44f8aa22b0b13d1393adb5398aff7afdb86" translate="yes" xml:space="preserve">
          <source>Already given in top.</source>
          <target state="translated">已经在上面给了。</target>
        </trans-unit>
        <trans-unit id="d9ac18d3c62e0844f72b69b9833ed0b09f4440d4" translate="yes" xml:space="preserve">
          <source>Also, stack vs. heap is not only a performance consideration; it also tells you a lot about the expected lifetime of objects.</source>
          <target state="translated">另外,堆与堆之间不仅是性能的考虑,它还能告诉你很多关于对象的预期寿命。</target>
        </trans-unit>
        <trans-unit id="1e2d387706b8a4328b31b3009e56251e7ed275fb" translate="yes" xml:space="preserve">
          <source>Although most compilers and interpreters implement this behavior similarly in terms of using stacks, heaps, etc, a compiler may sometimes break these conventions if it wants as long as behavior is correct. For instance, due to optimization a local variable may only exist in a register or be removed entirely, even though most local variables exist in the stack. As has been pointed out in a few comments, you are free to implement a compiler that doesn't even use a stack or a heap, but instead some other storage mechanisms (rarely done, since stacks and heaps are great for this).</source>
          <target state="translated">尽管大多数编译器和解释器在使用堆栈、堆等方面实现了类似的行为,但只要行为正确,编译器有时可能会打破这些约定。例如,由于优化的原因,一个局部变量可能只存在于一个寄存器中或被完全删除,即使大多数局部变量存在于堆中。正如一些评论中所指出的那样,你可以自由地实现一个甚至不使用堆栈或堆的编译器,而是使用一些其他存储机制(很少有人做,因为堆和堆在这方面是很好的)。</target>
        </trans-unit>
        <trans-unit id="eeb33740077a9e43e5825d3e19723b4a66394dcc" translate="yes" xml:space="preserve">
          <source>Arrows - show where grow stack and heap, process stack size have limit, defined in OS, thread stack size limits by parameters in thread create API usually. Heap usually limiting by process maximum virtual memory size, for 32 bit 2-4&amp;nbsp;GB for example.</source>
          <target state="translated">箭头-通常在线程创建API中通过参数显示增长堆栈和堆的位置，进程堆栈大小的限制（在OS中定义），线程堆栈大小的限制。 堆通常受进程最大虚拟内存大小限制，例如32位2-4 GB。</target>
        </trans-unit>
        <trans-unit id="24e9bfdff99d8d81e72e86eb67d28dd9afa0f779" translate="yes" xml:space="preserve">
          <source>As mentioned, heap and stack are general terms, and can be implemented in many ways.  Computer programs typically have a stack called a &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_stack&quot;&gt;call stack&lt;/a&gt; which stores information relevant to the current function such as a pointer to whichever function it was called from, and any local variables.  Because functions call other functions and then return, the stack grows and shrinks to hold information from the functions further down the call stack.  A program doesn't really have runtime control over it; it's determined by the programming language, OS and even the system architecture.</source>
          <target state="translated">如前所述，堆和堆栈是通用术语，可以通过多种方式实现。 计算机程序通常具有称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Call_stack&quot;&gt;调用堆栈的堆栈&lt;/a&gt; ，该堆栈存储与当前功能相关的信息，例如指向从哪个函数调用的指针以及任何局部变量。 由于函数先调用其他函数然后返回，所以堆栈会不断扩大和缩小，以保存来自函数的信息，这些信息将在调用堆栈的更下方。 一个程序实际上并没有对它的运行时控制。 它由编程语言，操作系统甚至系统架构决定。</target>
        </trans-unit>
        <trans-unit id="2df8df4816fd4ed74f3ebc71f597979521860d83" translate="yes" xml:space="preserve">
          <source>As the heap grows new blocks are often allocated from lower addresses towards higher addresses. Thus you can think of the heap as a &lt;em&gt;heap&lt;/em&gt; of memory blocks that grows in size as memory is allocated. If the heap is too small for an allocation the size can often be increased by acquiring more memory from the underlying operating system.</source>
          <target state="translated">随着堆的增长，通常将新块从低地址分配到高地址。 因此，您可以将堆视为存储块的&lt;em&gt;堆&lt;/em&gt; ，随着分配的内存，存储块的大小会增加。 如果堆对于分配而言太小，则通常可以通过从底层操作系统获取更多内存来增加大小。</target>
        </trans-unit>
        <trans-unit id="50556eca9ce5726de27e85d02f2175c0f224c952" translate="yes" xml:space="preserve">
          <source>As the stack is a limited block of memory, you can cause a &lt;em&gt;stack overflow&lt;/em&gt; by calling too many nested functions and/or allocating too much space for local variables. Often the memory area used for the stack is set up in such a way that writing below the bottom (the lowest address) of the stack will trigger a trap or exception in the CPU. This exceptional condition can then be caught by the runtime and converted into some kind of stack overflow exception.</source>
          <target state="translated">由于堆栈是有限的内存块，因此您可能会通过调用过多的嵌套函数和/或为局部变量分配过多的空间而导致&lt;em&gt;堆栈溢出&lt;/em&gt; 。 通常，用于堆栈的存储区的设置方式是，在堆栈底部（最低地址）以下进行写入将触发CPU陷阱或异常。 然后，运行时可以捕获这种异常情况，并将其转换为某种堆栈溢出异常。</target>
        </trans-unit>
        <trans-unit id="b215c6f533c85e53fa09d968e37f28f9d39f9d4b" translate="yes" xml:space="preserve">
          <source>At run-time, if the application needs more heap, it can allocate memory from free memory and if the stack needs memory, it can allocate memory from free memory allocated memory for the application.</source>
          <target state="translated">在运行时,如果应用程序需要更多的堆,它可以从空闲内存中分配内存,如果堆需要内存,它可以从空闲内存中为应用程序分配内存。</target>
        </trans-unit>
        <trans-unit id="54b26119365b1389f21ece7a4adac459e7df78fd" translate="yes" xml:space="preserve">
          <source>Because the different threads share the heap in a multi-threaded application, this also means that there has to be some coordination between the threads so that they don&amp;rsquo;t try to access and manipulate the same piece(s) of memory in the heap at the same time.</source>
          <target state="translated">由于不同的线程在多线程应用程序中共享堆，因此这也意味着线程之间必须进行某种协调，以使它们不会尝试访问和操作堆中相同的内存。同时。</target>
        </trans-unit>
        <trans-unit id="ccbbb8bb2cb5a86ca4310f5e73a45cd3c134e32e" translate="yes" xml:space="preserve">
          <source>Because the stack is small, you would want to use it when you know exactly how much memory you will need for your data, or if you know the size of your data is very small.</source>
          <target state="translated">因为堆栈很小,当你清楚地知道你的数据需要多少内存的时候,或者你知道你的数据大小非常小的时候,你会希望使用它。</target>
        </trans-unit>
        <trans-unit id="85af045b5af1615c35dbbd47456bb468389824a3" translate="yes" xml:space="preserve">
          <source>Because you've allocated the stack before launching the program, you never need to malloc before you can use the stack, so that's a slight advantage there.  In practice, it's very hard to predict what will be fast and what will be slow in modern operating systems that have virtual memory subsystems, because how the pages are implemented and where they are stored is an implementation detail.</source>
          <target state="translated">因为你在启动程序之前就已经分配好了栈,所以你永远不需要在使用栈之前进行malloc,所以这是一个小小的优势。在实践中,很难预测现代操作系统中,在有虚拟内存子系统的现代操作系统中,什么会快,什么会慢,因为页是如何实现的,页的存储位置是一个实现细节。</target>
        </trans-unit>
        <trans-unit id="a1789265dfb7f69ad43a9c93ac040821d26c1139" translate="yes" xml:space="preserve">
          <source>Both the stack and the heap are memory areas allocated from the underlying operating system (often virtual memory that is mapped to physical memory on demand).</source>
          <target state="translated">堆和堆都是从底层操作系统中分配的内存区域(通常是按需映射到物理内存的虚拟内存)。</target>
        </trans-unit>
        <trans-unit id="74ded9b65c26de9b34aafae7449e1393446d30f8" translate="yes" xml:space="preserve">
          <source>Can a function be allocated on the heap instead of a stack?</source>
          <target state="translated">可以在堆上分配一个函数,而不是在堆上分配吗?</target>
        </trans-unit>
        <trans-unit id="5812990e8a5f0104b222e128474fb28611af16f1" translate="yes" xml:space="preserve">
          <source>Can have a stack overflow when too much of the stack is used (mostly from infinite or too deep recursion, very large allocations).</source>
          <target state="translated">当使用了太多的堆栈时,可能会出现堆栈溢出(主要是来自无限或太深的递归,非常大的分配)。</target>
        </trans-unit>
        <trans-unit id="965cae31b330377a8052d9fde41cc56a8629759e" translate="yes" xml:space="preserve">
          <source>Can have allocation failures if too big of a buffer is requested to be allocated.</source>
          <target state="translated">如果请求分配的缓冲区过大,会出现分配失败。</target>
        </trans-unit>
        <trans-unit id="1c8dd66e84903a898b8ce09b004e11d5dd348f81" translate="yes" xml:space="preserve">
          <source>Can have fragmentation when there are a lot of allocations and deallocations.</source>
          <target state="translated">当有很多分配和dealocations时,可能会出现碎片化。</target>
        </trans-unit>
        <trans-unit id="57ed76834f319ea80eb97efad57dfda743be40d9" translate="yes" xml:space="preserve">
          <source>Creating Objects on the Stack and Heap</source>
          <target state="translated">在堆和堆上创建对象</target>
        </trans-unit>
        <trans-unit id="3c85e89113521a7aade115de0029e8e2378f88c7" translate="yes" xml:space="preserve">
          <source>Data created on the stack can be used without pointers.</source>
          <target state="translated">在栈上创建的数据可以不使用指针。</target>
        </trans-unit>
        <trans-unit id="10b6d2f5365d704078f50dcd64eef839102a1ac7" translate="yes" xml:space="preserve">
          <source>Deallocating the stack is pretty simple because you always deallocate in the reverse order in which you allocate. Stack stuff is added as you enter functions, the corresponding data is removed as you exit them. This means that you tend to stay within a small region of the stack unless you call lots of functions that call lots of other functions (or create a recursive solution).</source>
          <target state="translated">堆栈的deallocate是相当简单的,因为你总是按照分配的顺序相反。当你进入函数时,堆栈的东西被添加,相应的数据在你退出函数时被删除。这意味着,除非你调用了很多函数,而这些函数又调用了很多其他的函数(或者创建了一个递归方案),否则你往往会停留在堆栈的一个小区域内。</target>
        </trans-unit>
        <trans-unit id="2e6efb7de0e3b1a967b575cd00a39178bc6cda79" translate="yes" xml:space="preserve">
          <source>Details can be found from &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/161053/which-is-faster-stack-allocation-or-heap-allocation&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">可以从&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/161053/which-is-faster-stack-allocation-or-heap-allocation&quot;&gt;这里&lt;/a&gt;&lt;/strong&gt;找到详细信息。</target>
        </trans-unit>
        <trans-unit id="3454116b814c4a540b1fa2eaa28b022a062afd97" translate="yes" xml:space="preserve">
          <source>Don't have to explicitly de-allocate variables</source>
          <target state="translated">不需要明确地去分配变量</target>
        </trans-unit>
        <trans-unit id="0060cdcb4b02afd4a89a6475ecd1acc3d319f929" translate="yes" xml:space="preserve">
          <source>Due to sequential storage in stack, execution is faster. Storage in heap would have resulted in huge time consumption thus making the whole program execute slower.</source>
          <target state="translated">由于堆中的顺序存储,执行速度更快。在堆中存储会造成巨大的时间消耗,从而使整个程序的执行速度变慢。</target>
        </trans-unit>
        <trans-unit id="f04d90ff7dea8c8dc11581ddfc938b88076014c3" translate="yes" xml:space="preserve">
          <source>Dynamically created variables are stored here, which later requires freeing the allocated memory after use.</source>
          <target state="translated">动态创建的变量存储在这里,以后使用后需要释放分配的内存。</target>
        </trans-unit>
        <trans-unit id="846279cf02a7a28e2eaddba31c218b6c4f28b95f" translate="yes" xml:space="preserve">
          <source>Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation).</source>
          <target state="translated">每个线程得到一个堆,而应用程序通常只有一个堆(尽管为不同类型的分配而拥有多个堆并不罕见)。</target>
        </trans-unit>
        <trans-unit id="5e929f13154e75203839bfc2de286aa0a1a47dcc" translate="yes" xml:space="preserve">
          <source>Even, more detail is given &lt;a href=&quot;http://net-informations.com/faq/net/stack-heap.htm&quot;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html&quot;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">甚至&lt;a href=&quot;http://net-informations.com/faq/net/stack-heap.htm&quot;&gt;&lt;strong&gt;在这里&lt;/strong&gt;&lt;/a&gt;和&lt;a href=&quot;http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html&quot;&gt;&lt;strong&gt;这里&lt;/strong&gt;&lt;/a&gt;都给出&lt;strong&gt;了&lt;/strong&gt;更多细节。</target>
        </trans-unit>
        <trans-unit id="4077dc49f1766565dde4b0c98c71c99d05d1cf12" translate="yes" xml:space="preserve">
          <source>Every time an object is instantiated, a chunk of heap memory is set aside to hold the data (state) of that object. Since objects can contain other objects, some of this data can in fact hold references to those nested objects.</source>
          <target state="translated">每当一个对象被实例化的时候,就会预留出一大块堆内存来持有该对象的数据(状态)。由于对象可以包含其他对象,所以这些数据中的一些数据实际上可以持有对这些嵌套对象的引用。</target>
        </trans-unit>
        <trans-unit id="5211deda8670661ee7d1ce34e2735da4431ad6c2" translate="yes" xml:space="preserve">
          <source>Fibers proposal to the C++ standard library is forthcoming. Also, there're some third-party &lt;a href=&quot;https://stackoverflow.com/questions/1285714/lightweight-portable-c-fibers-mit-license&quot;&gt;libraries&lt;/a&gt;. Green threads are extremely popular in languages like Python and Ruby.</source>
          <target state="translated">即将向C ++标准库提出光纤建议。 另外，还有一些第三方&lt;a href=&quot;https://stackoverflow.com/questions/1285714/lightweight-portable-c-fibers-mit-license&quot;&gt;库&lt;/a&gt; 。 绿色线程在Python和Ruby等语言中非常流行。</target>
        </trans-unit>
        <trans-unit id="6bf6a0d4778960ac1e375eed1f1e9f0d010f59b1" translate="yes" xml:space="preserve">
          <source>Fibers, green threads and coroutines are in many ways similar, which leads to much confusion.  The difference between fibers and green threads is that the former use cooperative multitasking, while the latter may feature either cooperative or preemptive one (or even both). For the distinction between fibers and coroutines, see &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">纤维，生丝和协程在许多方面都相似，这导致很多混乱。 光纤和绿色线程之间的区别在于，前者使用协作式多任务处理，而后者则可以采用协作式或抢占式（或什至两者）。 有关纤维和协程之间的区别，请参见&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf&quot;&gt;此处&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d2ac197a7a104bcd6641f6a118e10124e3a8763" translate="yes" xml:space="preserve">
          <source>For people new to programming, it&amp;rsquo;s probably a good idea to use the stack since it&amp;rsquo;s easier.</source>
          <target state="translated">对于刚接触编程的人来说，使用堆栈可能是个好主意，因为它比较容易。</target>
        </trans-unit>
        <trans-unit id="d9bf6ea4d7dd59b322b7679e48bc374e1b2878a5" translate="yes" xml:space="preserve">
          <source>Fragmentation occurs when memory objects are allocated with small spaces in between that are too small to hold additional memory objects.</source>
          <target state="translated">当分配的内存对象之间的空间太小,无法容纳额外的内存对象时,就会发生碎片化。</target>
        </trans-unit>
        <trans-unit id="e237e4dadd747be21907ecdd643773f2cded6948" translate="yes" xml:space="preserve">
          <source>From WikiAnwser.</source>
          <target state="translated">来自WikiAnwser。</target>
        </trans-unit>
        <trans-unit id="4e3b5b95822a6480a6ed4d32a309c404a4c107f7" translate="yes" xml:space="preserve">
          <source>Function calls are loaded here along with the local variables and function parameters passed.</source>
          <target state="translated">函数调用与本地变量和函数参数一起被加载到这里。</target>
        </trans-unit>
        <trans-unit id="977169a2f56615065497cd1735f54129679d50ec" translate="yes" xml:space="preserve">
          <source>Heap</source>
          <target state="translated">Heap</target>
        </trans-unit>
        <trans-unit id="69c0fce84d3be50b555c1e7c6c0ace50232978e0" translate="yes" xml:space="preserve">
          <source>Heap allocation requires maintaining a full record of what memory is allocated and what isn't, as well as some overhead maintenance to reduce fragmentation, find contiguous memory segments big enough to fit the requested size, and so on.  Memory can be deallocated at any time leaving free space.  Sometimes a memory allocator will perform maintenance tasks such as defragmenting memory by moving allocated memory around, or garbage collecting - identifying at runtime when memory is no longer in scope and deallocating it.</source>
          <target state="translated">堆分配需要维护一个完整的记录,记录哪些内存被分配了,哪些没有被分配,以及一些开销维护,以减少碎片化,找到足够大的连续内存段,以适应所要求的大小,等等。内存可以在任何时候进行dealocated,留下空闲空间。有时候,内存分配器会执行一些维护任务,比如通过移动已分配的内存来进行内存碎片化,或者垃圾回收--在运行时识别出内存不再在范围内,并将其重新分配。</target>
        </trans-unit>
        <trans-unit id="6df8f5905a52242ce08ad912e0566230705e916f" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a super-short summary: The stack is essentially an
  easy-to-access memory that simply manages its items as a - well -
  stack. Only items for which the size is known in advance can go onto
  the stack. This is the case for numbers, strings, booleans.</source>
          <target state="translated">这是一个超简短的摘要：堆栈本质上是一个易于访问的内存，可以将其项目作为一个很好的堆栈来管理。 只有事先知道尺寸的物品才能进入堆栈。 数字，字符串，布尔值就是这种情况。</target>
        </trans-unit>
        <trans-unit id="c4ad91f43c7e132c0c64e796c08f23caf41b0111" translate="yes" xml:space="preserve">
          <source>Here's how the memory is managed</source>
          <target state="translated">下面是内存的管理方式</target>
        </trans-unit>
        <trans-unit id="bf4cd344a404d07f4320ed2b8128bc0699d576ee" translate="yes" xml:space="preserve">
          <source>How the heap is managed is really up to the runtime environment. C uses &lt;code&gt;malloc&lt;/code&gt; and C++ uses &lt;code&gt;new&lt;/code&gt;, but many other languages have garbage collection.</source>
          <target state="translated">堆的管理方式实际上取决于运行时环境。 C使用 &lt;code&gt;malloc&lt;/code&gt; ，C ++使用 &lt;code&gt;new&lt;/code&gt; ，但是许多其他语言具有垃圾回收。</target>
        </trans-unit>
        <trans-unit id="e6d9adabdb8c7c013e5c6cedd3fd35a30646fc45" translate="yes" xml:space="preserve">
          <source>However, it is generally better to consider &quot;&lt;strong&gt;scope&lt;/strong&gt;&quot; and &quot;&lt;strong&gt;lifetime&lt;/strong&gt;&quot; rather than &quot;stack&quot; and &quot;heap&quot;.</source>
          <target state="translated">但是，通常最好考虑&amp;ldquo; &lt;strong&gt;作用域&lt;/strong&gt; &amp;rdquo;和&amp;ldquo; &lt;strong&gt;生存期&lt;/strong&gt; &amp;rdquo;，而不是&amp;ldquo;堆栈&amp;rdquo;和&amp;ldquo;堆&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="aed2fb7f74c3443670e7a902fd753397a138bf75" translate="yes" xml:space="preserve">
          <source>However, the stack is a more low-level feature closely tied to the processor architecture. Growing the heap when there is not enough space isn't too hard since it can be implemented in the library call that handles the heap. However, growing the stack is often impossible as the stack overflow only is discovered when it is too late; and shutting down the thread of execution is the only viable option.</source>
          <target state="translated">然而,堆是一个与处理器架构紧密相连的比较低级的功能。在空间不够的时候增长堆并不是太难,因为它可以在处理堆的库调用中实现。然而,增长堆往往是不可能的,因为只有当堆溢出时才会被发现;而关闭执行线程是唯一可行的选择。</target>
        </trans-unit>
        <trans-unit id="369a9b90a4bdfde4e85ad68cde3ff685aa91dd1f" translate="yes" xml:space="preserve">
          <source>I also create the image below to show how they may look like:</source>
          <target state="translated">我还创造了下面的图片,以显示它们可能的样子。</target>
        </trans-unit>
        <trans-unit id="b6b70f6bfb4b2dfbc4a60602e806084366a63de7" translate="yes" xml:space="preserve">
          <source>I have something to share, although the major points are already covered.</source>
          <target state="translated">虽然主要内容已经讲到了,但我还是有东西要分享。</target>
        </trans-unit>
        <trans-unit id="9c1b11110bea9796fff4f2aa43b42de19c50096d" translate="yes" xml:space="preserve">
          <source>I think many other people have given you mostly correct answers on this matter.</source>
          <target state="translated">在这个问题上,我想很多人都给了你大部分正确的答案。</target>
        </trans-unit>
        <trans-unit id="f84b830b40010139bb2bc50481c768d543c9849a" translate="yes" xml:space="preserve">
          <source>I will provide some simple annotated C code to illustrate all of this. The best way to learn is to run a program under a debugger and watch the behavior. If you prefer to read python, skip to the end of the answer :)</source>
          <target state="translated">我将提供一些简单的C语言注释代码来说明这一切。最好的学习方法是在调试器下运行一个程序并观察其行为。如果你喜欢读python,请跳到答案的最后:)</target>
        </trans-unit>
        <trans-unit id="19be6ca3ce7acb355b8593c36bbe51f806cb3467" translate="yes" xml:space="preserve">
          <source>If a function has parameters, these are pushed onto the stack before the call to the function. The code in the function is then able to navigate up the stack from the current stack pointer to locate these values.</source>
          <target state="translated">如果一个函数有参数,在调用函数之前,这些参数会被推送到堆栈上。然后函数中的代码能够从当前的堆栈指针向上浏览堆栈来定位这些值。</target>
        </trans-unit>
        <trans-unit id="d6fd840c486fd422511fccb949147762c4da1fa6" translate="yes" xml:space="preserve">
          <source>If functions were stored in heap (messy storage pointed by pointer), there would have been no way to return to the caller address back (which stack gives due to sequential storage in memory).</source>
          <target state="translated">如果函数存储在堆中(乱七八糟的存储指针指向的存储),那么就没有办法返回到调用者地址返回(由于内存中的顺序存储,堆给出的是顺序存储)。</target>
        </trans-unit>
        <trans-unit id="582e735b7a23d77b1a919b1c33ed8aa128f12765" translate="yes" xml:space="preserve">
          <source>If the private heap gets too large it will overlap the stack area, as will the stack overlap the heap if it gets too big. Because the stack starts at a higher address and works its way down to lower address, with proper hacking you can get make the stack so large that it will overrun the private heap area and overlap the code area. The trick then is to overlap enough of the code area that you can hook into the code. It's a little tricky to do and you risk a program crash, but it's easy and very effective.</source>
          <target state="translated">如果私有堆变得太大,它就会叠加堆区,如果堆变得太大,也会叠加堆区。因为栈从较高的地址开始到较低的地址,通过适当的黑客攻击,你可以把栈做得很大,以至于它将超过私有堆区域,并重叠代码区域。然后,诀窍就是要重叠到足够多的代码区,让你可以钩住代码。这样做有点棘手,你会有程序崩溃的风险,但很简单,而且非常有效。</target>
        </trans-unit>
        <trans-unit id="8164de7b8275fe6bd6610a9f1a1f510df9d0953d" translate="yes" xml:space="preserve">
          <source>If you fail to do this, your program will have what is known as a memory leak. That is, memory on the heap will still be set aside (and won't be available to other processes). As we will see in the debugging section, there is a tool called &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt; that can help you detect memory leaks.</source>
          <target state="translated">如果不这样做，程序将发生所谓的内存泄漏。 也就是说，堆上的内存仍将被保留（并且其他进程将无法使用）。 正如我们将在调试部分中看到的那样，有一个名为&lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt;的工具可以帮助您检测内存泄漏。</target>
        </trans-unit>
        <trans-unit id="5d14809b020f6dc3b1ca1b516594f7c26711d489" translate="yes" xml:space="preserve">
          <source>Implemented with an actual stack data structure.</source>
          <target state="translated">用实际的堆栈数据结构执行。</target>
        </trans-unit>
        <trans-unit id="0ec9c44eba796de6b3f45bf5b3038e9e98f84fe1" translate="yes" xml:space="preserve">
          <source>In &quot;classic&quot; systems RAM was laid out such that the stack pointer started out at the bottom of memory, the heap pointer started out at the top, and they grew towards each other. If they overlap, you are out of RAM. That doesn't work with modern multi-threaded OSes though. Every thread has to have its own stack, and those can get created dynamicly.</source>
          <target state="translated">在 &quot;经典 &quot;系统中,RAM的布局是这样的:堆栈指针从内存的底部开始,堆指针从顶部开始,它们互相向着对方增长。如果它们重叠在一起,你就没有RAM了。这在现代的多线程操作系统中是行不通的。每个线程都必须有自己的堆栈,而这些堆栈是动态创建的。</target>
        </trans-unit>
        <trans-unit id="9595be1b961175468df336b7cd57107f6d9e6d67" translate="yes" xml:space="preserve">
          <source>In C you can get the benefit of variable length allocation through the use of &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?alloca&quot;&gt;alloca&lt;/a&gt;, which allocates on the stack, as opposed to alloc, which allocates on the heap. This memory won't survive your return statement, but it's useful for a scratch buffer.</source>
          <target state="translated">在C语言中，您可以通过使用&lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?alloca&quot;&gt;alloca&lt;/a&gt;来获得可变长度分配的好处， alloca可以在堆栈上进行分配，而alloc则可以在堆上进行分配。 此内存无法在您的return语句中保留下来，但是对于暂存缓冲区很有用。</target>
        </trans-unit>
        <trans-unit id="4c49c1e042066fcde12cf790d1255e5d4128c6ed" translate="yes" xml:space="preserve">
          <source>In C++ or C, data created on the heap will be pointed to by pointers and allocated with &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt; respectively.</source>
          <target state="translated">在C ++或C中，在堆上创建的数据将由指针指向，并分别使用 &lt;code&gt;new&lt;/code&gt; 或 &lt;code&gt;malloc&lt;/code&gt; 进行分配。</target>
        </trans-unit>
        <trans-unit id="2dddb5409ddfb8bfae0332e6674cb30e4030c766" translate="yes" xml:space="preserve">
          <source>In C++, variables on the heap must be destroyed manually and never fall out of scope. The data is freed with &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;delete[]&lt;/code&gt;, or &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">在C ++中，必须手动销毁堆上的变量，并且切勿超出范围。 使用 &lt;code&gt;delete&lt;/code&gt; ， &lt;code&gt;delete[]&lt;/code&gt; 或 &lt;code&gt;free&lt;/code&gt; 释放数据。</target>
        </trans-unit>
        <trans-unit id="0ab2e606ea24062674776c9630ae58f479fc3332" translate="yes" xml:space="preserve">
          <source>In Detail</source>
          <target state="translated">详细介绍</target>
        </trans-unit>
        <trans-unit id="d070ed182c0710ddbb3f2b533e23ff5a60e665ff" translate="yes" xml:space="preserve">
          <source>In Java, most objects go directly into the heap. In languages like C / C++, structs and classes can often remain on the stack when you're not dealing with pointers.</source>
          <target state="translated">在Java语言中,大多数对象直接进入堆中。在C++等语言中,当你不处理指针时,结构和类往往可以留在堆中。</target>
        </trans-unit>
        <trans-unit id="4f383e35971605d5e60dda592302a0dfbedde224" translate="yes" xml:space="preserve">
          <source>In Short</source>
          <target state="translated">简而言之</target>
        </trans-unit>
        <trans-unit id="5147749ca6668db2a2e89a21934367a8e767227a" translate="yes" xml:space="preserve">
          <source>In a heap, there is no particular order to the way items are placed.  You can reach in and remove items in any order because there is no clear 'top' item.</source>
          <target state="translated">在一个堆中,物品的放置方式没有特定的顺序。你可以按照任何顺序伸手进去并删除项目,因为没有明确的 &quot;顶层 &quot;项目。</target>
        </trans-unit>
        <trans-unit id="c178a8267cc3e47eec2a91c3a323a8fdc32c3e39" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, each thread will have its own stack.</source>
          <target state="translated">在多线程应用中,每个线程都会有自己的堆栈。</target>
        </trans-unit>
        <trans-unit id="aea37718a1d7d897745b71fc7a069d9dac94a163" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, each thread will have its own stack. But, all the different threads will share the heap.</source>
          <target state="translated">在多线程应用程序中,每个线程都会有自己的堆。但是,所有不同的线程都将共享堆。</target>
        </trans-unit>
        <trans-unit id="bed80375d9899ce917d044e4b57acedb6c419964" translate="yes" xml:space="preserve">
          <source>In a multi-threaded environment each thread will have its own completely independent stack but they will share the heap. Concurrent access has to be controlled on the heap and is not possible on the stack.</source>
          <target state="translated">在多线程环境中,每个线程都有自己的完全独立的堆,但它们将共享堆。并发访问必须在堆上控制,而在堆上是不可能的。</target>
        </trans-unit>
        <trans-unit id="2afdc75d76febc6978738ba0407aee2a8e1a2690" translate="yes" xml:space="preserve">
          <source>In a multi-threaded situation each thread will have its own completely independent stack, but they will share the heap. The stack is thread specific and the heap is application specific. The stack is important to consider in exception handling and thread executions.</source>
          <target state="translated">在多线程的情况下,每个线程都会有自己完全独立的堆栈,但它们会共享堆。堆是特定于线程的,而堆是特定于应用程序的。在异常处理和线程执行中,堆栈是重要的考虑因素。</target>
        </trans-unit>
        <trans-unit id="3b5a4a1f69f2a44d7b973472f440395d38db3aef" translate="yes" xml:space="preserve">
          <source>In a stack of items, items sit one on top of the other in the order they were placed there, and you can only remove the top one (without toppling the whole thing over).</source>
          <target state="translated">在一个物品堆里,物品按照放置的顺序一个个放在上面,你只能把最上面的那件东西取下来(不需要把整个东西压倒)。</target>
        </trans-unit>
        <trans-unit id="6de943cc8f12c5ab1e03aa49853e2f81f883c968" translate="yes" xml:space="preserve">
          <source>In any case, the purpose of both fibers, green threads and coroutines is having multiple functions executing concurrently, but &lt;strong&gt;not&lt;/strong&gt; in parallel (see &lt;a href=&quot;https://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&quot;&gt;this SO question&lt;/a&gt; for the distinction) within a single OS-level thread, transferring control back and forth from one another in an organized fashion.</source>
          <target state="translated">无论如何，光纤，绿色线程和协程的目的是在一个OS级线程中同时执行多个功能，而&lt;strong&gt;不是&lt;/strong&gt;并行执行（请参见此&lt;a href=&quot;https://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&quot;&gt;SO问题&lt;/a&gt;以区分它们），从而相互之间来回传递控制以有组织的方式。</target>
        </trans-unit>
        <trans-unit id="6ff0d53ec18f38266dd0067ebeca5dc7b79c4307" translate="yes" xml:space="preserve">
          <source>In computing architectures the heap is an area of dynamically-allocated memory that is managed automatically by the operating system or the memory manager library.</source>
          <target state="translated">在计算架构中,堆是由操作系统或内存管理器库自动管理的动态分配的内存区域。</target>
        </trans-unit>
        <trans-unit id="14147c40afba7195a6e743160146832b550785ac" translate="yes" xml:space="preserve">
          <source>In systems without virtual memory, such as some embedded systems, the same basic layout often applies, except the stack and heap are fixed in size. However, in other embedded systems (such as those based on Microchip PIC microcontrollers), the program stack is a separate block of memory that is not addressable by data movement instructions, and can only be modified or read indirectly through program flow instructions (call, return, etc.). Other architectures, such as Intel Itanium processors, have &lt;a href=&quot;http://blogs.msdn.com/oldnewthing/archive/2005/04/21/410397.aspx&quot;&gt;multiple stacks&lt;/a&gt;. In this sense, the stack is an element of the CPU architecture.</source>
          <target state="translated">在没有虚拟内存的系统（例如某些嵌入式系统）中，通常使用相同的基本布局，只是堆栈和堆的大小固定不变。 但是，在其他嵌入式系统（例如基于Microchip PIC微控制器的系统）中，程序堆栈是单独的存储器块，数据移动指令无法对其进行寻址，并且只能通过程序流指令（调用，返回等）。 其他体系结构（例如Intel Itanium处理器）具有&lt;a href=&quot;http://blogs.msdn.com/oldnewthing/archive/2005/04/21/410397.aspx&quot;&gt;多个堆栈&lt;/a&gt; 。 从这个意义上讲，堆栈是CPU体系结构的元素。</target>
        </trans-unit>
        <trans-unit id="9aec9cb3ea820b87a5cf73897d19e91456e49aff" translate="yes" xml:space="preserve">
          <source>In the 1980s, UNIX propagated like bunnies with big companies rolling their own.
Exxon had one as did dozens of brand names lost to history.
How memory was laid out was at the discretion of the many implementors.</source>
          <target state="translated">在20世纪80年代,UNIX像小兔子一样在大公司的轧制下如雨后春笋般传播。Exxon公司有一个,几十个品牌商也有一个,已经消失在历史上。内存如何布局是由许多实施者自行决定的。</target>
        </trans-unit>
        <trans-unit id="33565c031152b190e31e2e646c439179d7871e3f" translate="yes" xml:space="preserve">
          <source>In the following C# code</source>
          <target state="translated">在下面的C#代码中</target>
        </trans-unit>
        <trans-unit id="630247c43e13b3493c95ccf3dcf571c7304c4c8f" translate="yes" xml:space="preserve">
          <source>Is hardware, and even push/pop are very efficient.</source>
          <target state="translated">是硬件,甚至是pushpop都很有效率。</target>
        </trans-unit>
        <trans-unit id="fbec35b1fe092a0a42603acde06323d190983ce3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s better to use the heap when you know that you will need a lot of memory for your data, or you just are not sure how much memory you will need (like with a dynamic array).</source>
          <target state="translated">当您知道您的数据将需要大量内存，或者您不确定需要多少内存（例如动态数组）时，最好使用堆。</target>
        </trans-unit>
        <trans-unit id="457deb90d7d9b5e518927cf1c37ce9f9c8468ecf" translate="yes" xml:space="preserve">
          <source>Java Memory Model</source>
          <target state="translated">Java 存储器模型</target>
        </trans-unit>
        <trans-unit id="ffbbcf1f84185847b6720632d5f0dd4615871ac7" translate="yes" xml:space="preserve">
          <source>Lifetime refers to when a variable is allocated and deallocated during program execution. Usually we think of &lt;strong&gt;static allocation&lt;/strong&gt; (variable will persist through the entire duration of the program, making it useful for storing the same information across several function calls) versus &lt;strong&gt;automatic allocation&lt;/strong&gt; (variable only persists during a single call to a function, making it useful for storing information that is only used during your function and can be discarded once you are done) versus &lt;strong&gt;dynamic allocation&lt;/strong&gt; (variables whose duration is defined at runtime, instead of compile time like static or automatic).</source>
          <target state="translated">生存期是指在程序执行期间何时分配和释放变量。 通常，我们认为&lt;strong&gt;静态分配&lt;/strong&gt; （变量将在程序的整个过程中持续存在，从而使它在多个函数调用之间存储相同的信息很有用）与&lt;strong&gt;自动分配&lt;/strong&gt; （变量仅在单个调用函数中持续存在，从而使其对存储仅在函数运行期间使用的信息，完成后可以丢弃的信息）与&lt;strong&gt;动态分配&lt;/strong&gt; （其持续时间在运行时定义的变量，而不是静态或自动的编译时）相比。</target>
        </trans-unit>
        <trans-unit id="89eb38e39ee83b4afbd53d56ba3e811dd7e4c25b" translate="yes" xml:space="preserve">
          <source>Limit on stack size (OS-dependent)</source>
          <target state="translated">栈的大小限制(取决于操作系统)</target>
        </trans-unit>
        <trans-unit id="e0b77457d171049e39cb59f6d0cc6e0aa958f4d7" translate="yes" xml:space="preserve">
          <source>Local variables only</source>
          <target state="translated">仅局域变量</target>
        </trans-unit>
        <trans-unit id="a7063db18651eedcd045e8b41c98ba145000f990" translate="yes" xml:space="preserve">
          <source>Making a huge temporary buffer on Windows that you don't use much of is not free. This is because the compiler will generate a stack probe loop that is called every time your function is entered to make sure the stack exists (because Windows uses a single guard page at the end of your stack to detect when it needs to grow the stack. If you access memory more than one page off the end of the stack you will crash). Example:</source>
          <target state="translated">在Windows上做一个你不怎么用的巨大的临时缓冲区是不自由的。这是因为编译器会产生一个堆栈探针循环,每次进入你的函数时都会被调用,以确保堆栈的存在(因为Windows在你的堆栈末尾使用一个单一的守卫页来检测什么时候需要增长堆栈。如果你访问内存时离堆栈末尾超过一页,你就会崩溃)。)例子。</target>
        </trans-unit>
        <trans-unit id="ca52649198f4fcd9db011db1f93bf7a0fbf8fc6f" translate="yes" xml:space="preserve">
          <source>Memory on the heap is allocated, deallocated, and resized regularly during program execution, and this can lead to a problem called fragmentation.</source>
          <target state="translated">在程序执行过程中,堆上的内存会有规律地分配、分配和调整大小,这可能导致一个叫做碎片化的问题。</target>
        </trans-unit>
        <trans-unit id="92fa2b03cecd0df74b8828996b6d8dbd49f2c6f2" translate="yes" xml:space="preserve">
          <source>More can be found &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">在&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management&quot;&gt;这里&lt;/a&gt;&lt;/strong&gt;可以找到更多。</target>
        </trans-unit>
        <trans-unit id="2be48705642c1c2849cd129948c17459949f6ab7" translate="yes" xml:space="preserve">
          <source>More can be found &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_(abstract_data_type)&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">在&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_(abstract_data_type)&quot;&gt;这里&lt;/a&gt;&lt;/strong&gt;可以找到更多。</target>
        </trans-unit>
        <trans-unit id="cd2086a7c7de1d63c092402cee2278afc2a9fcb4" translate="yes" xml:space="preserve">
          <source>More can be found &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">在&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113&quot;&gt;这里&lt;/a&gt;&lt;/strong&gt;可以找到更多。</target>
        </trans-unit>
        <trans-unit id="ff90893ecc13cc33b31a0c7ba89530291adf207c" translate="yes" xml:space="preserve">
          <source>More can be found in &lt;a href=&quot;https://stackoverflow.com/questions/408670/stack-static-and-heap-in-c&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://stackoverflow.com/questions/408670/stack-static-and-heap-in-c&quot;&gt;这里&lt;/a&gt;可以找到更多。</target>
        </trans-unit>
        <trans-unit id="d87631c079431a997cdc54c230389a89f964ee05" translate="yes" xml:space="preserve">
          <source>More information can be found here:</source>
          <target state="translated">更多信息可以在这里找到。</target>
        </trans-unit>
        <trans-unit id="daed2813a5860321bea40be47381eb4727e55905" translate="yes" xml:space="preserve">
          <source>Much faster to allocate in comparison to variables on the heap.</source>
          <target state="translated">与堆上的变量相比,分配起来要快得多。</target>
        </trans-unit>
        <trans-unit id="611a2d27ec35591a9d1a945571bf2c19006fe525" translate="yes" xml:space="preserve">
          <source>Nesting function calls work like a charm. Each new call will allocate function parameters, the return address and space for local variables and these &lt;em&gt;activation records&lt;/em&gt; can be stacked for nested calls and will unwind in the correct way when the functions return.</source>
          <target state="translated">嵌套函数调用的工作方式就像一种魅力。 每个新调用将分配函数参数，返回值和局部变量空间，并且这些&lt;em&gt;激活记录&lt;/em&gt;可以堆叠用于嵌套调用，并在函数返回时以正确的方式展开。</target>
        </trans-unit>
        <trans-unit id="f5f359ca9a7c1ab08f498e157e0409d9d76c46da" translate="yes" xml:space="preserve">
          <source>No guaranteed efficient use of space, memory may become fragmented over time as blocks of memory are allocated, then freed</source>
          <target state="translated">没有保证空间的有效利用,随着时间的推移,内存可能会变得支离破碎,因为内存块会被分配,然后被释放出来</target>
        </trans-unit>
        <trans-unit id="15c9ee58559d66b5b15a6a82aa330160c95db8c1" translate="yes" xml:space="preserve">
          <source>No limit on memory size</source>
          <target state="translated">内存大小没有限制</target>
        </trans-unit>
        <trans-unit id="50b9533f7ca93c1b7165a50cb0b44b0cfb20fb35" translate="yes" xml:space="preserve">
          <source>No, activation records for functions (i.e. local or automatic variables) are allocated on the stack that is used not only to store these variables, but also to keep track of nested function calls.</source>
          <target state="translated">不,函数的激活记录(即本地变量或自动变量)被分配到堆栈上,而堆栈不仅用来存储这些变量,还用来跟踪嵌套的函数调用。</target>
        </trans-unit>
        <trans-unit id="4ab51a7f5c3504c0459c4e33aa2f1830407e1fa5" translate="yes" xml:space="preserve">
          <source>Note that I said &quot;&lt;em&gt;usually&lt;/em&gt; have a separate stack per function&quot;. There're both &lt;em&gt;stackful&lt;/em&gt; and &lt;em&gt;stackless&lt;/em&gt; implementations of couroutines. Most notable stackful C++ implementations are &lt;a href=&quot;http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.html&quot;&gt;Boost.Coroutine&lt;/a&gt; and &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd492418.aspx&quot;&gt;Microsoft PPL&lt;/a&gt;'s &lt;code&gt;async/await&lt;/code&gt;. (However, C++'s &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4134.pdf&quot;&gt;resumable functions&lt;/a&gt; (a.k.a. &quot;&lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;&quot;), which were proposed to C++17, are likely to use stackless coroutines.)</source>
          <target state="translated">请注意，我说的是&amp;ldquo;每个函数&lt;em&gt;通常&lt;/em&gt;有单独的堆栈&amp;rdquo;。 &lt;em&gt;协程&lt;/em&gt;既有&lt;em&gt;堆栈&lt;/em&gt;实现又有&lt;em&gt;堆栈&lt;/em&gt;实现。 最著名的堆栈式C ++实现是&lt;a href=&quot;http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.html&quot;&gt;Boost.Coroutine&lt;/a&gt;和&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd492418.aspx&quot;&gt;Microsoft PPL&lt;/a&gt;的 &lt;code&gt;async/await&lt;/code&gt; 。 （但是，C ++ 17提出的C ++ &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4134.pdf&quot;&gt;可恢复函数&lt;/a&gt; （又名&amp;ldquo; &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; &amp;rdquo;）可能会使用无堆栈协程。）</target>
        </trans-unit>
        <trans-unit id="d2cf9d062fe2a4c663f0c8c2cedd3fc551bc3d7a" translate="yes" xml:space="preserve">
          <source>Note that putting the keyword &quot;static&quot; in the declaration above prevents var2 from having global scope. Nevertheless, the global var1 has static allocation. This is not intuitive! For this reason, I try to never use the word &quot;static&quot; when describing scope, and instead say something like &quot;file&quot; or &quot;file limited&quot; scope. However many people use the phrase &quot;static&quot; or &quot;static scope&quot; to describe a variable that can only be accessed from one code file. In the context of lifetime, &quot;static&quot; &lt;em&gt;always&lt;/em&gt; means the variable is allocated at program start and deallocated when program exits.</source>
          <target state="translated">请注意，在上面的声明中添加关键字&amp;ldquo; static&amp;rdquo;可防止var2具有全局作用域。 但是，全局var1具有静态分配。 这不直观！ 因此，在描述范围时，我尽量不要使用&amp;ldquo;静态&amp;rdquo;一词，而应使用诸如&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;文件受限&amp;rdquo;范围之类的名称。 但是，许多人使用短语&amp;ldquo;静态&amp;rdquo;或&amp;ldquo;静态作用域&amp;rdquo;来描述只能从一个代码文件访问的变量。 就生存期而言，&amp;ldquo;静态&amp;rdquo; &lt;em&gt;始终&lt;/em&gt;表示在程序启动时分配变量，并在程序退出时释放变量。</target>
        </trans-unit>
        <trans-unit id="0871b21874420432475c6d4351849b35d915057f" translate="yes" xml:space="preserve">
          <source>Now come to &lt;strong&gt;your question's answers&lt;/strong&gt;.</source>
          <target state="translated">现在来&lt;strong&gt;回答您的问题&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="74c615a4a42b31624f1cc296011324866cfe8b77" translate="yes" xml:space="preserve">
          <source>Objects (which vary in size as we update them) go on the heap because we don't know at creation time how long they are going to last. In many languages the heap is garbage collected to find objects (such as the cls1 object) that no longer have any references.</source>
          <target state="translated">对象(随着我们更新对象的大小而变化)进入堆中,因为我们在创建时不知道它们会持续多久。在许多语言中,堆是通过垃圾回收来寻找不再有任何引用的对象(如 cls1 对象)。</target>
        </trans-unit>
        <trans-unit id="e4fe13843a3ecc800429114b92b44c8d355d6bed" translate="yes" xml:space="preserve">
          <source>On the stack you save return addresses and call &amp;rarr; push / ret &amp;rarr; pop is managed directly in hardware.</source>
          <target state="translated">在堆栈上，您保存返回地址并调用&amp;rarr;推入/退出&amp;rarr;弹出直接在硬件中进行管理。</target>
        </trans-unit>
        <trans-unit id="29a4742ef363b18a49d8dab9624425d36200ea1e" translate="yes" xml:space="preserve">
          <source>One detail that has been missed, however, is that the &quot;heap&quot; should in fact probably be called the &quot;free store&quot;.  The reason for this distinction is that the original free store was implemented with a data structure known as a &quot;binomial heap.&quot;  For that reason, allocating from early implementations of malloc()/free() was allocation from a heap.  However, in this modern day, most free stores are implemented with very elaborate data structures that are not binomial heaps.</source>
          <target state="translated">但有一个细节被忽略了,那就是 &quot;堆 &quot;实际上可能应该被称为 &quot;自由存储&quot;。之所以有这种区别,是因为最初的free store是用一种被称为 &quot;二叉堆 &quot;的数据结构来实现的。因为这个原因,从malloc()free()的早期实现中分配,就是从堆中分配。然而,在这个现代,大多数的自由存储都是用非常复杂的数据结构实现的,而不是二叉堆。</target>
        </trans-unit>
        <trans-unit id="13d7afdda2ae69ca5bb8408fcc1546f3b6c11363" translate="yes" xml:space="preserve">
          <source>One typical memory block was BSS (a block of zero values)
which was accidentally not zeroed in one manufacturer's offering.
Another was DATA containing initialized values, including strings and numbers.
A third was CODE containing CRT (C runtime), main, functions, and libraries.</source>
          <target state="translated">其中一个典型的内存块是BSS(零值块),在某厂商的产品中意外地没有归零。另一个是DATA,包含初始化的值,包括字符串和数字。第三种是包含CRT(C运行时)、主、函数和库的CODE。</target>
        </trans-unit>
        <trans-unit id="e3d075236948af076fad91d4bb43d9d26eb82acc" translate="yes" xml:space="preserve">
          <source>Others have answered the broad strokes pretty well, so I'll throw in a few details.</source>
          <target state="translated">别的人已经回答得很概括了,我就抛出一些细节。</target>
        </trans-unit>
        <trans-unit id="6f64e795a39ecd2c765903677e991445c7062f09" translate="yes" xml:space="preserve">
          <source>Others have directly answered your question, but when trying to understand the stack and the heap, I think it is helpful to consider the memory layout of a traditional UNIX process (without threads and &lt;code&gt;mmap()&lt;/code&gt;-based allocators). The &lt;a href=&quot;http://www.memorymanagement.org/glossary/b.html#term-brk&quot;&gt;Memory Management Glossary&lt;/a&gt; web page has a diagram of this memory layout.</source>
          <target state="translated">其他人已经直接回答了您的问题，但是当试图了解堆栈和堆时，我认为考虑传统UNIX进程（没有线程和基于 &lt;code&gt;mmap()&lt;/code&gt; 的分配器）的内存布局会有所帮助。 &lt;a href=&quot;http://www.memorymanagement.org/glossary/b.html#term-brk&quot;&gt;内存管理词汇表&lt;/a&gt;网页上有此内存布局的图表。</target>
        </trans-unit>
        <trans-unit id="e33f67dded7084c7a1497e2d2409091903f39904" translate="yes" xml:space="preserve">
          <source>Programming language books explain that value types are created on the &lt;strong&gt;stack&lt;/strong&gt;, and reference types are created on the &lt;strong&gt;heap&lt;/strong&gt;, without explaining what these two things are. I haven't read a clear explanation of this.  I understand what &lt;em&gt;a stack&lt;/em&gt; is. But,</source>
          <target state="translated">编程语言书籍解释了值类型是在&lt;strong&gt;堆栈&lt;/strong&gt;上创建的，而引用类型是在&lt;strong&gt;堆上&lt;/strong&gt;创建的，而没有说明这两个是什么。 我还没有阅读清楚的解释。 我了解&lt;em&gt;堆栈&lt;/em&gt;是什么。 但，</target>
        </trans-unit>
        <trans-unit id="6e6e17f4d2768e59d3304c88f5860bd92caee2a8" translate="yes" xml:space="preserve">
          <source>REF:</source>
          <target state="translated">REF:</target>
        </trans-unit>
        <trans-unit id="b5fef21aad832234d260e32f67bed2552c27b3f3" translate="yes" xml:space="preserve">
          <source>Responsible for memory leaks.</source>
          <target state="translated">负责记忆泄露。</target>
        </trans-unit>
        <trans-unit id="69bf7896b4602d80f099d7c96e91ea211768accd" translate="yes" xml:space="preserve">
          <source>Scope refers to what parts of the code can access a variable. Generally we think of &lt;strong&gt;local scope&lt;/strong&gt; (can only be accessed by the current function) versus &lt;strong&gt;global scope&lt;/strong&gt; (can be accessed anywhere) although scope can get much more complex.</source>
          <target state="translated">范围是指代码的哪些部分可以访问变量。 通常，我们认为&lt;strong&gt;本地范围&lt;/strong&gt; （只能由当前函数访问）与&lt;strong&gt;全局范围&lt;/strong&gt; （可以在任何地方访问）相比，尽管范围会变得更加复杂。</target>
        </trans-unit>
        <trans-unit id="509aa940c1c036efce29c8fe0c9b4b55069f2302" translate="yes" xml:space="preserve">
          <source>Should the function calls had been stored in heap, it would had resulted in 2 messy points:</source>
          <target state="translated">如果函数调用被存储在堆中,会导致2个混乱的点。</target>
        </trans-unit>
        <trans-unit id="a2185ca86acc0c919180d9c04aad21adc109c7e3" translate="yes" xml:space="preserve">
          <source>Simply, the stack is where local variables get created. Also, every time you call a subroutine the program counter (pointer to the next machine instruction) and any important registers, and sometimes the parameters get pushed on the stack. Then any local variables inside the subroutine are pushed onto the stack (and used from there). When the subroutine finishes, that stuff all gets popped back off the stack. The PC and register data gets and put back where it was as it is popped, so your program can go on its merry way.</source>
          <target state="translated">很简单,堆栈是创建本地变量的地方。另外,每次调用子程序时,程序计数器(指向下一条机器指令的指针)和任何重要的寄存器,有时参数也会被推送到堆栈上。然后,子程序内部的任何本地变量都会被推送到堆栈上(并从那里开始使用)。当子程序完成后,这些东西都会被从堆栈中弹出。PC和寄存器的数据会在被弹出的时候被放回原处,这样你的程序就可以继续运行了。</target>
        </trans-unit>
        <trans-unit id="2c86213718746adf4ed3b869ab8ebf53621c0bd5" translate="yes" xml:space="preserve">
          <source>Since some answers went nitpicking, I'm going to contribute my mite.</source>
          <target state="translated">既然有的答案去吹毛求疵了,我就贡献一下我的微薄之力。</target>
        </trans-unit>
        <trans-unit id="9aeb164d237567097685b40284f2116644d171b1" translate="yes" xml:space="preserve">
          <source>Slow access comparatively to Stack.</source>
          <target state="translated">相对于Stack来说,访问速度较慢。</target>
        </trans-unit>
        <trans-unit id="f9fa73fb582337740b2c7cd4692dfd71eaccd2bf" translate="yes" xml:space="preserve">
          <source>Slower to allocate in comparison to variables on the stack.</source>
          <target state="translated">与堆栈上的变量相比,分配速度要慢一些。</target>
        </trans-unit>
        <trans-unit id="84def04a560bda893e52388cc083ef70d321b378" translate="yes" xml:space="preserve">
          <source>So simple way: process heap is general for process and all threads inside, using for memory allocation in common case with something like &lt;strong&gt;malloc()&lt;/strong&gt;.</source>
          <target state="translated">如此简单的方式：进程堆是进程及其内部所有线程的通用对象，通常在诸如&lt;strong&gt;malloc（）之&lt;/strong&gt;类的情况下用于内存分配。</target>
        </trans-unit>
        <trans-unit id="4d6256f41ed90ef56893f4c0e80ba67b5f4b8734" translate="yes" xml:space="preserve">
          <source>So there is always an index to point the specific item, also processing gonna be faster, there is relationship between the items as well!...</source>
          <target state="translated">所以总是有一个索引来指向具体的项目,处理起来也会比较快,项目之间也有关系!......</target>
        </trans-unit>
        <trans-unit id="26e4934add44c2df343844921794ed5d56eccfd7" translate="yes" xml:space="preserve">
          <source>Some of the syntax choices in C/C++ exacerbate this problem - for instance many people think global variables are not &quot;static&quot; because of the syntax shown below.</source>
          <target state="translated">CC++中的一些语法选择加剧了这个问题--比如说,很多人认为全局变量不是 &quot;静态的&quot;,因为下图所示的语法。</target>
        </trans-unit>
        <trans-unit id="95320488ab41410560b78b52dfa9e017b243c84d" translate="yes" xml:space="preserve">
          <source>Some people think of these concepts as C/C++ specific. They are not. For instance, the Python sample below illustrates all three types of allocation (there are some subtle differences possible in interpreted languages that I won't get into here).</source>
          <target state="translated">有些人认为这些概念是CC++特有的。其实不然。例如,下面的 Python 示例说明了所有的三种分配类型 (在解释语言中可能会有一些微妙的差异,我在这里就不多说了)。</target>
        </trans-unit>
        <trans-unit id="8b51efe6289458012b6c8f1356975a43aa34abc0" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://academind.com/learn/javascript/reference-vs-primitive-values/&quot;&gt;Academind&lt;/a&gt;</source>
          <target state="translated">资料来源： &lt;a href=&quot;https://academind.com/learn/javascript/reference-vs-primitive-values/&quot;&gt;Academind&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9c53060f090e60a073e898da17d700ab9341170" translate="yes" xml:space="preserve">
          <source>Space is freed automatically when program goes out of a scope.</source>
          <target state="translated">当程序超出范围时,空间会自动释放。</target>
        </trans-unit>
        <trans-unit id="a04e6278e75e6c001c297db6eeaca0f21b4f1cf9" translate="yes" xml:space="preserve">
          <source>Space is managed efficiently by CPU, memory will not become fragmented</source>
          <target state="translated">空间由CPU有效管理,内存不会变得碎片化</target>
        </trans-unit>
        <trans-unit id="83e5a0d3d2ef19df258412a4d3ef3f9533b0c0c1" translate="yes" xml:space="preserve">
          <source>Stack</source>
          <target state="translated">Stack</target>
        </trans-unit>
        <trans-unit id="2a1e3b0bbb1f0808e4252a6f745c19b958ac4d85" translate="yes" xml:space="preserve">
          <source>Stack allocation is much faster since all it really does is move the stack pointer. Using memory pools, you can get comparable performance out of heap allocation, but that comes with a slight added complexity and its own headaches.</source>
          <target state="translated">堆分配要快得多,因为它真正的作用就是移动堆栈指针。使用内存池,你可以从堆栈分配中获得类似的性能,但这也带来了一点额外的复杂性和自身的头痛。</target>
        </trans-unit>
        <trans-unit id="990b9b0ae5cb9ef33f5882c479501ea9ec73fc18" translate="yes" xml:space="preserve">
          <source>Stack and heap need not be singular. A common situation in which you have more than one stack is if you have more than one thread in a process.  In this case each thread has its own stack. You can also have more than one heap, for example some DLL configurations can result in different DLLs allocating from different heaps, which is why it's generally a bad idea to release memory allocated by a different library.</source>
          <target state="translated">堆和堆不需要是单数。一个常见的情况是,如果一个进程中有多个线程,你有一个以上的堆栈。在这种情况下,每个线程都有自己的堆栈。你也可以有一个以上的堆,例如有些DLL配置会导致不同的DLL从不同的堆中分配内存,这就是为什么一般情况下释放由不同的库分配的内存是个坏主意。</target>
        </trans-unit>
        <trans-unit id="12fa9cb21a886762f171950816a55e2e59c869da" translate="yes" xml:space="preserve">
          <source>Stack is quick memory for store in common case function return pointers and variables, processed as parameters in function call, local function variables.</source>
          <target state="translated">Stack是快速存储器,用于存储常用情况下的函数返回指针和变量,在函数调用中作为参数处理,局部函数变量。</target>
        </trans-unit>
        <trans-unit id="e3f92779f11d4b0f3467f92a53682253210952a8" translate="yes" xml:space="preserve">
          <source>Stack usage is faster as:</source>
          <target state="translated">栈的使用速度较快,因为。</target>
        </trans-unit>
        <trans-unit id="24de6d4cf48238082c51e345becf26e29ec1d2b0" translate="yes" xml:space="preserve">
          <source>Stacks in computing architectures are regions of memory where data is added or removed in a last-in-first-out manner.</source>
          <target state="translated">计算体系结构中的堆栈是指以先进先出的方式添加或删除数据的内存区域。</target>
        </trans-unit>
        <trans-unit id="22877b6a12ccde62a270b7ab1193154412bb82ab" translate="yes" xml:space="preserve">
          <source>Stored in RAM.</source>
          <target state="translated">存储在RAM中。</target>
        </trans-unit>
        <trans-unit id="dc53b0aeba09646ffe4c0adfb1d92487fe376514" translate="yes" xml:space="preserve">
          <source>Stored in computer RAM just like the heap.</source>
          <target state="translated">存储在计算机RAM中,就像堆一样。</target>
        </trans-unit>
        <trans-unit id="5ba923ec538ab00b7c8b1596311059a6d8275c93" translate="yes" xml:space="preserve">
          <source>Stored in computer RAM just like the stack.</source>
          <target state="translated">存储在计算机RAM中,就像堆栈一样。</target>
        </trans-unit>
        <trans-unit id="4cff577d64e66b1b435d415f1b04c55974ebb6a6" translate="yes" xml:space="preserve">
          <source>Stored in sequential memory.</source>
          <target state="translated">存储在顺序存储器中。</target>
        </trans-unit>
        <trans-unit id="8df107699395056ea16ab53263372585c3596bba" translate="yes" xml:space="preserve">
          <source>Stored wherever memory allocation is done, accessed by pointer always.</source>
          <target state="translated">存储在内存分配的地方,由指针永远访问。</target>
        </trans-unit>
        <trans-unit id="89a636351088b12243704905bf43a965507d4b10" translate="yes" xml:space="preserve">
          <source>Stores local data, return addresses, used for parameter passing.</source>
          <target state="translated">存储本地数据,返回地址,用于参数传递。</target>
        </trans-unit>
        <trans-unit id="dbf8af31722360d4cd5768e22244d5f8a401c59d" translate="yes" xml:space="preserve">
          <source>Surprisingly, no one has mentioned that multiple (i.e. not related to the number of running OS-level threads) call stacks are to be found not only in exotic languages (PostScript) or platforms (Intel Itanium), but also in &lt;a href=&quot;http://en.wikipedia.org/wiki/Fiber_(computer_science)&quot;&gt;&lt;em&gt;fibers&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Green_threads&quot;&gt;&lt;em&gt;green threads&lt;/em&gt;&lt;/a&gt; and some implementations of &lt;a href=&quot;http://en.wikipedia.org/wiki/Coroutine&quot;&gt;&lt;em&gt;coroutines&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">令人惊讶的是，没有人提到，不仅在外来语言（PostScript）或平台（Intel Itanium）中，而且在&lt;a href=&quot;http://en.wikipedia.org/wiki/Fiber_(computer_science)&quot;&gt;&lt;em&gt;光纤&lt;/em&gt;&lt;/a&gt; ， &lt;a href=&quot;http://en.wikipedia.org/wiki/Green_threads&quot;&gt;&lt;em&gt;绿色线程中&lt;/em&gt;&lt;/a&gt;都可以找到多个（即与正在运行的OS级线程的数量无关）调用堆栈。和&lt;a href=&quot;http://en.wikipedia.org/wiki/Coroutine&quot;&gt;&lt;em&gt;协程的&lt;/em&gt;&lt;/a&gt;一些实现。</target>
        </trans-unit>
        <trans-unit id="918fc88eb49d9688ce62b0cb92ecf74e2130215f" translate="yes" xml:space="preserve">
          <source>That said, stack-based memory errors are some of the worst I've experienced.  If you use heap memory, and you overstep the bounds of your allocated block, you have a decent chance of triggering a segment fault.  (Not 100%: your block may be incidentally contiguous with another that you have previously allocated.)  But since variables created on the stack are always contiguous with each other, writing out of bounds can change the value of another variable.  I have learned that whenever I feel that my program has stopped obeying the laws of logic, it is probably buffer overflow.</source>
          <target state="translated">话虽如此,但基于堆的内存错误是我经历过的最糟糕的一些。如果你使用了堆内存,并且你超过了你所分配的块的界限,你有相当大的机会触发段故障。(不是100%:你的区块可能会偶然地与你之前分配的另一个区块相邻)。但是,由于在堆栈上创建的变量总是相互毗连的,所以写出界外的变量会改变另一个变量的值。我的体会是,每当我觉得我的程序停止服从逻辑法则时,大概是缓冲区溢出。</target>
        </trans-unit>
        <trans-unit id="77e50870e9d92e46d032efa6ebe4c3cc162d7aa6" translate="yes" xml:space="preserve">
          <source>The CPU has special instructions for &lt;em&gt;pushing&lt;/em&gt; values onto the stack and &lt;em&gt;popping&lt;/em&gt; them back from the stack. Each &lt;em&gt;push&lt;/em&gt; stores the value at the current location of the stack pointer and decreases the stack pointer.  A &lt;em&gt;pop&lt;/em&gt; retrieves the value pointed to by the stack pointer and then increases the stack pointer (don't be confused by the fact that &lt;em&gt;adding&lt;/em&gt; a value to the stack &lt;em&gt;decreases&lt;/em&gt; the stack pointer and &lt;em&gt;removing&lt;/em&gt; a value &lt;em&gt;increases&lt;/em&gt; it. Remember that the stack grows to the bottom). The values stored and retrieved are the values of the CPU registers.</source>
          <target state="translated">CPU具有用于&lt;em&gt;将&lt;/em&gt;值&lt;em&gt;压&lt;/em&gt;入堆栈并从堆栈&lt;em&gt;弹出的&lt;/em&gt;特殊指令。 每次&lt;em&gt;推送&lt;/em&gt;将值存储在堆栈指针的当前位置，并减小堆栈指针。 &lt;em&gt;pop&lt;/em&gt;检索堆栈指针所指向的值，然后增加堆栈指针（不要因向堆栈中&lt;em&gt;添加&lt;/em&gt;一个值会&lt;em&gt;减少&lt;/em&gt;堆栈指针，而&lt;em&gt;删除&lt;/em&gt;一个值会&lt;em&gt;增加&lt;/em&gt;它的事实而感到困惑。请记住，堆栈会增长为底部）。 存储和检索的值是CPU寄存器的值。</target>
        </trans-unit>
        <trans-unit id="acf431b632d416223fea9a3ceddf5add4bc0a95f" translate="yes" xml:space="preserve">
          <source>The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application.</source>
          <target state="translated">在创建线程时,操作系统为每个系统级线程分配堆。通常情况下,操作系统是由语言运行时调用操作系统为应用程序分配堆栈。</target>
        </trans-unit>
        <trans-unit id="38a855cabffd8eca3496aa5a7a4076cf2ab0ee27" translate="yes" xml:space="preserve">
          <source>The advantage of using the stack to store variables, is that memory is managed for you. You don't have to allocate memory by hand, or free it once you don't need it any more. What's more, because the CPU organizes stack memory so efficiently, reading from and writing to stack variables is very fast.</source>
          <target state="translated">使用堆栈来存储变量的好处是,内存是由你来管理的。你不需要手动分配内存,也不需要在不需要的时候释放内存。更重要的是,由于CPU对堆栈内存的组织非常有效,所以对堆栈变量的读写速度非常快。</target>
        </trans-unit>
        <trans-unit id="8a9b474ea07882c9a3be36b7edcb52f7b0126430" translate="yes" xml:space="preserve">
          <source>The advent of virtual memory in UNIX changes many of the constraints.
There is no objective reason why these blocks need be contiguous,
or fixed in size, or ordered a particular way now.
Of course, before UNIX was Multics which didn't suffer from these constraints.
Here is a schematic showing one of the memory layouts of that era.</source>
          <target state="translated">UNIX中虚拟内存的出现,改变了许多约束条件。现在,这些块没有任何客观的理由需要毗连,或固定大小,或以特定的方式排序。当然,在UNIX之前的Multics是不受这些约束的。下面是一个示意图,显示了那个时代的内存布局之一。</target>
        </trans-unit>
        <trans-unit id="ff4d4ca937c7d0d51d422534fe1735405013c379" translate="yes" xml:space="preserve">
          <source>The answer to your question is implementation specific and may vary across compilers and processor architectures. However, here is a simplified explanation.</source>
          <target state="translated">你的问题的答案是特定的实现,可能会因编译器和处理器架构而异。不过,这里是一个简化的解释。</target>
        </trans-unit>
        <trans-unit id="020c36cef487c3028c3b0a5e48330117297c3aa9" translate="yes" xml:space="preserve">
          <source>The call stack is such a low level concept that it doesn't relate to 'scope' in the sense of programming.  If you disassemble some code you'll see relative pointer style references to portions of the stack, but as far as a higher level language is concerned, the language imposes its own rules of scope.  One important aspect of a stack, however, is that once a function returns, anything local to that function is immediately freed from the stack.  That works the way you'd expect it to work given how your programming languages work.  In a heap, it's also difficult to define.  The scope is whatever is exposed by the OS, but your programming language probably adds its rules about what a &quot;scope&quot; is in your application.  The processor architecture and the OS use virtual addressing, which the processor translates to physical addresses and there are page faults, etc.  They keep track of what pages belong to which applications.  You never really need to worry about this, though, because you just use whatever method your programming language uses to allocate and free memory, and check for errors (if the allocation/freeing fails for any reason).</source>
          <target state="translated">调用栈是这样一个低级的概念,它与编程意义上的 &quot;作用域 &quot;无关。如果你拆解一些代码,你会看到相对指针式引用堆栈的部分内容,但就更高层次的语言而言,语言强加了自己的作用域规则。然而,堆栈的一个重要方面是,一旦一个函数返回,任何与该函数相关的局部都会立即从堆栈中释放出来。考虑到编程语言的工作方式,这就像你所期望的那样工作。在堆中,它也很难定义。作用域是操作系统所暴露的任何东西,但你的编程语言可能会在你的应用程序中加入关于什么是 &quot;作用域 &quot;的规则。处理器架构和操作系统使用的是虚拟寻址,处理器将其转化为物理地址,存在页面故障等问题。他们会跟踪哪些页面属于哪个应用程序。不过,你永远不需要担心这个问题,因为你只需要使用你的编程语言使用的任何方法来分配和释放内存,并检查是否有错误(如果 allocationfreeing 因任何原因失败)。</target>
        </trans-unit>
        <trans-unit id="71984997f1c1e6f1262af07953881c1b0a8417ca" translate="yes" xml:space="preserve">
          <source>The difference between stack and heap memory allocation &amp;laquo;  timmurphy.org</source>
          <target state="translated">堆栈和堆内存分配之间的区别&amp;laquo;timmurphy.org</target>
        </trans-unit>
        <trans-unit id="7a5590373ff6649f9475365f1f774384f831b25c" translate="yes" xml:space="preserve">
          <source>The heap</source>
          <target state="translated">堆积物</target>
        </trans-unit>
        <trans-unit id="64692d2958abffc9963293d7cc83b6289b346bca" translate="yes" xml:space="preserve">
          <source>The heap contains a linked list of used and free blocks. New allocations on the heap (by &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt;) are satisfied by creating a suitable block from one of the free blocks. This requires updating list of blocks on the heap. This &lt;em&gt;meta information&lt;/em&gt; about the blocks on the heap is also stored on the heap often in a small area just in front of every block.</source>
          <target state="translated">堆包含已用和可用块的链接列表。 通过从空闲块之一创建合适的块，可以满足堆上的新分配（通过 &lt;code&gt;new&lt;/code&gt; 或 &lt;code&gt;malloc&lt;/code&gt; ）。 这需要更新堆上的块列表。 有关堆上块的&lt;em&gt;元信息&lt;/em&gt;通常也存储在堆上每个块前面的小区域中。</target>
        </trans-unit>
        <trans-unit id="e88ae6b7603411c417abd661b3310c2adee1f47c" translate="yes" xml:space="preserve">
          <source>The heap is a memory for items of which you can&amp;rsquo;t pre-determine the
  exact size and structure. Since objects and arrays can be mutated and
  change at runtime, they have to go into the heap therefore.</source>
          <target state="translated">堆是您无法预先确定其确切大小和结构的项的存储器。 由于对象和数组可以在运行时进行更改和更改，因此它们必须进入堆。</target>
        </trans-unit>
        <trans-unit id="4ca28207330bff52b70007af68c711c32e17159a" translate="yes" xml:space="preserve">
          <source>The heap is a portion of memory that is given to an application by the operating system, typically through a syscall like malloc.  On modern OSes this memory is a set of pages that only the calling process has access to.</source>
          <target state="translated">堆是操作系统提供给应用程序的一部分内存,通常是通过像 malloc 这样的系统调用来实现的。在现代操作系统中,这部分内存是一组只有调用进程才能访问的页面。</target>
        </trans-unit>
        <trans-unit id="71f619e3570fe3e7aac533a912d787b19b6db9a4" translate="yes" xml:space="preserve">
          <source>The heap is a region of your computer's memory that is not managed automatically for you, and is not as tightly managed by the CPU. It is a more free-floating region of memory (and is larger). To allocate memory on the heap, you must use malloc() or calloc(), which are built-in C functions. Once you have allocated memory on the heap, you are responsible for using free() to deallocate that memory once you don't need it any more.</source>
          <target state="translated">堆是你的计算机内存中的一个区域,它不是自动为你管理的,也不像CPU那样对你进行严格的管理。它是一个比较自由浮动的内存区域(而且比较大)。要在堆上分配内存,必须使用malloc()或calloc(),这两个函数都是C语言内置的函数。一旦你在堆上分配了内存,一旦你不再需要内存,你就要负责使用free()来deallocate该内存。</target>
        </trans-unit>
        <trans-unit id="7be7d8e45896d63bdae0ae933b6b0e1b8111b33b" translate="yes" xml:space="preserve">
          <source>The heap is memory set aside for dynamic allocation.  Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time.  This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns.</source>
          <target state="translated">堆是为动态分配留出的内存。与堆不同的是,堆中的块的分配和deallocation没有强制的模式;你可以在任何时候分配一个块,也可以在任何时候释放它。这使得在任何给定的时间里,跟踪堆中的哪些部分被分配或释放的情况变得更加复杂;有许多自定义的堆分配器可以根据不同的使用模式来调整堆的性能。</target>
        </trans-unit>
        <trans-unit id="408b6a604741833882cb371639a20f7a50001b81" translate="yes" xml:space="preserve">
          <source>The heap is simply the memory used by programs to store variables.
Element of the heap (variables) have no dependencies with each other and can always be accessed randomly at any time.</source>
          <target state="translated">堆只是程序用来存储变量的内存。堆中的元素(变量)之间没有相互依赖关系,可以随时随机访问。</target>
        </trans-unit>
        <trans-unit id="18cf12075777cee089f775e186e6f7b937d612e6" translate="yes" xml:space="preserve">
          <source>The heap is the area of memory dynamic memory allocations are made out of (explicit &quot;new&quot; or &quot;allocate&quot; calls). It is a special data structure that can keep track of blocks of memory of varying sizes and their allocation status.</source>
          <target state="translated">堆是内存动态分配内存的区域(显式 &quot;新 &quot;或 &quot;分配 &quot;调用)。它是一种特殊的数据结构,可以记录不同大小的内存块及其分配状态。</target>
        </trans-unit>
        <trans-unit id="3aabde1f5818e4761b37f38a6704fc125ea9920e" translate="yes" xml:space="preserve">
          <source>The most important point is that heap and stack are generic terms for ways in which memory can be allocated.  They can be implemented in many different ways, and the terms apply to the basic concepts.</source>
          <target state="translated">最重要的一点是,堆和堆栈是内存分配方式的通用术语。它们可以以许多不同的方式实现,这些术语适用于基本概念。</target>
        </trans-unit>
        <trans-unit id="bda899c3bb77eaf54a1599448a403c98162d7221" translate="yes" xml:space="preserve">
          <source>The net result is a percentage of the heap space that is not usable for further memory allocations.</source>
          <target state="translated">净结果是不能用于进一步分配内存的堆空间的百分比。</target>
        </trans-unit>
        <trans-unit id="9db69de7d5cb25cb1dab28c5edef62348d01cbca" translate="yes" xml:space="preserve">
          <source>The private heap begins on a 16-byte boundary (for 64-bit programs) or a 8-byte boundary (for 32-bit programs) after the last byte of code in your program, and then increases in value from there. It is also called the default heap.</source>
          <target state="translated">私有堆从程序中最后一个字节的代码之后的16字节边界(对于64位程序)或8字节边界(对于32位程序)开始,然后从那里开始增加。它也被称为默认堆。</target>
        </trans-unit>
        <trans-unit id="c92a151a963f47b45a4e38472c1ddbfa83a05978" translate="yes" xml:space="preserve">
          <source>The public heap resides in it's own memory space outside of your program image space. It is this memory that will be siphoned off onto the hard disk if memory resources get scarce.</source>
          <target state="translated">公共堆是在你的程序映像空间之外的内存空间。如果内存资源稀缺,就会把这些内存抽走到硬盘上。</target>
        </trans-unit>
        <trans-unit id="c2c0a23048e8df047bdd90c519e230882a5ebc7e" translate="yes" xml:space="preserve">
          <source>The simplicity of a stack is that you do not need to maintain a table containing a record of each section of allocated memory; the only state information you need is a single pointer to the end of the stack.  To allocate and de-allocate, you just increment and decrement that single pointer.  Note: a stack can sometimes be implemented to start at the top of a section of memory and extend downwards rather than growing upwards.</source>
          <target state="translated">栈的简单性在于,你不需要维护一个包含每一段分配内存的记录的表;你需要的唯一状态信息是一个指向堆栈末端的单一指针。要分配和取消分配,你只需要增量和减量这个单一指针就可以了。注意:堆栈有时可以实现从内存部分的顶部开始,然后向下延伸,而不是向上增长。</target>
        </trans-unit>
        <trans-unit id="0a5a7df2173b3956056001d4db19a49a57a3b1c3" translate="yes" xml:space="preserve">
          <source>The single STACK was typically an area below HEAP which was a tract of memory
containing nothing of value until the top of the next fixed block of memory.
This next block was often CODE which could be overwritten by stack data
in one of the famous hacks of its era.</source>
          <target state="translated">单个STACK通常是HEAP下面的一个区域,在下一个固定的内存块的顶部之前,它是一个没有任何价值的内存区域。这个下一个区块通常是CODE,它可以被堆栈数据覆盖,这也是其时代著名的黑客之一。</target>
        </trans-unit>
        <trans-unit id="011fc8ced4b02d6e5bbcdaf8c062421d1082656a" translate="yes" xml:space="preserve">
          <source>The size of the stack and the private heap are determined by your compiler runtime options. The public heap is initialized at runtime using a size parameter.</source>
          <target state="translated">堆的大小和私有堆的大小是由你的编译器运行时选项决定的。公共堆在运行时使用一个大小参数初始化。</target>
        </trans-unit>
        <trans-unit id="beb914534381f099cbd641ab522253e8764a0c7c" translate="yes" xml:space="preserve">
          <source>The size of the stack is determined at runtime, and generally does not grow after the program launches.  In a C program, the stack needs to be large enough to hold every variable declared within each function.  The heap will grow dynamically as needed, but the OS is ultimately making the call (it will often grow the heap by more than the value requested by malloc, so that at least some future mallocs won't need to go back to the kernel to get more memory.  This behavior is often customizable)</source>
          <target state="translated">堆栈的大小是在运行时决定的,一般在程序启动后不会增长。在C语言程序中,堆需要足够大,以容纳每个函数中声明的每个变量。堆会根据需要动态地增长,但最终还是由操作系统进行调用(它往往会将堆增长的值超过malloc请求的值,这样至少未来的一些malloc就不需要再回到内核去获取更多的内存。这种行为通常是可以定制的)</target>
        </trans-unit>
        <trans-unit id="16b7e0f64c42733b20a4e51a341eddcfa754d823" translate="yes" xml:space="preserve">
          <source>The size of the stack is set by &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_system&quot;&gt;OS&lt;/a&gt; when a thread is created. The size of the heap is set on application startup, but it can grow as space is needed (the allocator requests more memory from the operating system).</source>
          <target state="translated">创建线程时，堆栈大小由&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_system&quot;&gt;OS&lt;/a&gt;设置。 堆的大小是在应用程序启动时设置的，但是它会随着需要的空间而增长（分配器从操作系统请求更多的内存）。</target>
        </trans-unit>
        <trans-unit id="5cc1aba664ea781e5f0b096e032491b096dd802e" translate="yes" xml:space="preserve">
          <source>The size of the stack is set when a thread is created.  The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).</source>
          <target state="translated">堆的大小是在创建线程时设置的。堆的大小是在应用程序启动时设置的,但会随着空间的需要而增加(分配器向操作系统请求更多的内存)。</target>
        </trans-unit>
        <trans-unit id="864abb86138112e4b6d575123f37974ac0c3d5c5" translate="yes" xml:space="preserve">
          <source>The stack</source>
          <target state="translated">栈道</target>
        </trans-unit>
        <trans-unit id="901c2c85d8f6f1f4b65665c0438d9a9ae1aeb6f6" translate="yes" xml:space="preserve">
          <source>The stack and heap are traditionally located at opposite ends of the process's virtual address space. The stack grows automatically when accessed, up to a size set by the kernel (which can be adjusted with &lt;code&gt;setrlimit(RLIMIT_STACK, ...)&lt;/code&gt;). The heap grows when the memory allocator invokes the &lt;code&gt;brk()&lt;/code&gt; or &lt;code&gt;sbrk()&lt;/code&gt; system call, mapping more pages of physical memory into the process's virtual address space.</source>
          <target state="translated">传统上，堆栈和堆位于进程的虚拟地址空间的相对两端。 堆栈在访问时自动增长，直至达到内核设置的大小（可以使用 &lt;code&gt;setrlimit(RLIMIT_STACK, ...)&lt;/code&gt; 进行调整）。 当内存分配器调用 &lt;code&gt;brk()&lt;/code&gt; 或 &lt;code&gt;sbrk()&lt;/code&gt; 系统调用，将更多的物理内存页面映射到进程的虚拟地址空间时，堆就会增长。</target>
        </trans-unit>
        <trans-unit id="5a39a45e4339d966ed8ccdb706ae6cfcecd17231" translate="yes" xml:space="preserve">
          <source>The stack is a &quot;LIFO&quot; (last in, first out) data structure, that is managed and optimized by the CPU quite closely. Every time a function declares a new variable, it is &quot;pushed&quot; onto the stack. Then every time a function exits, all of the variables pushed onto the stack by that function, are freed (that is to say, they are deleted). Once a stack variable is freed, that region of memory becomes available for other stack variables.</source>
          <target state="translated">栈是一个 &quot;LIFO&quot;(last in,first out)数据结构,由CPU来管理和优化。每当一个函数声明一个新的变量,它就会被 &quot;推送 &quot;到堆栈上。然后每次函数退出时,所有被该函数推送到栈中的变量都会被释放(也就是说,它们被删除)。一旦一个堆栈变量被释放,那么这个区域的内存就可以用于其他堆栈变量。</target>
        </trans-unit>
        <trans-unit id="ed0cdd27974e8f28be5b49910ffd382fca3bd094" translate="yes" xml:space="preserve">
          <source>The stack is a portion of memory that can be manipulated via several key assembly language instructions, such as 'pop' (remove and return a value from the stack) and 'push' (push a value to the stack), but also call (call a subroutine - this pushes the address to return to the stack) and return (return from a subroutine - this pops the address off of the stack and jumps to it).  It's the region of memory below the stack pointer register, which can be set as needed.  The stack is also used for passing arguments to subroutines, and also for preserving the values in registers before calling subroutines.</source>
          <target state="translated">栈是内存的一部分,可以通过几个关键的汇编语言指令进行操作,如 &quot;pop&quot;(从栈中删除并返回一个值)和 &quot;push&quot;(将一个值推送到栈中),也可以通过调用(调用子程序--这将地址推送到栈中返回)和返回(从子程序中返回--这将地址从栈中弹出并跳转到栈中)。它是堆栈指针寄存器下面的内存区域,可以根据需要进行设置。堆栈也用于向子程序传递参数,也用于在调用子程序之前保存寄存器中的值。</target>
        </trans-unit>
        <trans-unit id="8fed4d46c5dcc66fd775586df82611b6cbc4131a" translate="yes" xml:space="preserve">
          <source>The stack is attached to a thread, so when the thread exits the stack is reclaimed.  The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits.</source>
          <target state="translated">堆是附着在线程上的,所以当线程退出时,堆会被回收。堆通常在应用程序启动时由运行时分配,当应用程序(技术上是进程)退出时,堆被回收。</target>
        </trans-unit>
        <trans-unit id="d7d4617ad45d9667a26837a2ef9396a88ed54845" translate="yes" xml:space="preserve">
          <source>The stack is controlled by the programmer, the private heap is managed by the OS, and the public heap is not controlled by anyone because it is an OS service -- you make requests and either they are granted or denied.</source>
          <target state="translated">栈由程序员控制,私有堆由操作系统管理,而公共堆不受任何人控制,因为它是操作系统的服务--你提出请求,要么被授予,要么被拒绝。</target>
        </trans-unit>
        <trans-unit id="776e06a491d0e5871f9e300942fd84b17a6ca19c" translate="yes" xml:space="preserve">
          <source>The stack is faster because all free memory is always contiguous.  No list needs to be maintained of all the segments of free memory, just a single pointer to the current top of the stack.  Compilers usually store this pointer in a special, fast &lt;a href=&quot;http://en.wikipedia.org/wiki/Stack_register&quot;&gt;register&lt;/a&gt; for this purpose.  What's more, subsequent operations on a stack are usually concentrated within very nearby areas of memory, which at a very low level is good for optimization by the processor on-die caches.</source>
          <target state="translated">堆栈速度更快，因为所有可用内存始终是连续的。 不需要维护所有可用内存段的列表，只需一个指向堆栈当前顶部的指针即可。 为此，编译器通常将此指针存储在特殊的快速&lt;a href=&quot;http://en.wikipedia.org/wiki/Stack_register&quot;&gt;寄存器&lt;/a&gt;中。 更重要的是，堆栈上的后续操作通常集中在内存的非常近的区域内，这在非常低的级别上有利于处理器片上缓存的优化。</target>
        </trans-unit>
        <trans-unit id="e94a30b9ac14f61035ae0f43d2216250500958c2" translate="yes" xml:space="preserve">
          <source>The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or deallocation.  Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be - typically - synchronized with &quot;all&quot; other heap accesses in the program.</source>
          <target state="translated">栈的速度更快,因为访问模式使得从栈中分配和分配内存变得很简单(一个指针整数只需递增或递减),而堆在分配或分配时涉及到更多复杂的记账。另外,堆中的每个字节往往被重复使用的频率很高,这意味着它往往会被映射到处理器的缓存中,使得它的速度非常快。对堆的另一个性能打击是,堆作为一个全局资源,通常必须是多线程安全的,也就是说,每个分配和去分配都需要与程序中的 &quot;所有 &quot;其他堆访问同步。</target>
        </trans-unit>
        <trans-unit id="b147220a7a5ad0a7828db4392f30462146e56ffc" translate="yes" xml:space="preserve">
          <source>The stack is important to consider in exception handling and thread executions.</source>
          <target state="translated">栈是异常处理和线程执行中需要考虑的重要因素。</target>
        </trans-unit>
        <trans-unit id="8ef364bf925f140fae82efa1d95fdcfda187e3d2" translate="yes" xml:space="preserve">
          <source>The stack is memory that begins as the highest memory address allocated to your program image, and it then decrease in value from there. It is reserved for called function parameters and for all temporary variables used in functions.</source>
          <target state="translated">栈是内存,从分配给你的程序映像的最高内存地址开始,然后它的值会从这里开始递减。它是为被调用的函数参数和函数中使用的所有临时变量保留的。</target>
        </trans-unit>
        <trans-unit id="f7b4a5b7d8386940ab1623f4ec51157abd70a3d1" translate="yes" xml:space="preserve">
          <source>The stack is much faster than the heap.</source>
          <target state="translated">堆的速度比堆的速度要快得多。</target>
        </trans-unit>
        <trans-unit id="8b386c56b8fca037b071be51c145e3471e513ded" translate="yes" xml:space="preserve">
          <source>The stack is the area of memory where local variables (including method parameters) are stored. When it comes to object variables, these are merely references (pointers) to the actual objects on the heap.</source>
          <target state="translated">堆是存储本地变量(包括方法参数)的内存区域。当涉及到对象变量时,这些变量仅仅是对堆上实际对象的引用(指针)。</target>
        </trans-unit>
        <trans-unit id="29503f92d8ce71011e0d49b669cd0afb652670e0" translate="yes" xml:space="preserve">
          <source>The stack is the memory set aside as scratch space for a thread of execution.  When a function is called, a block is reserved on the top of the stack for local variables and some bookkeeping data.  When that function returns, the block becomes unused and can be used the next time a function is called.  The stack is always reserved in a LIFO (last in first out) order; the most recently reserved block is always the next block to be freed.  This makes it really simple to keep track of the stack; freeing a block from the stack is nothing more than adjusting one pointer.</source>
          <target state="translated">栈是为执行线程预留的内存,作为执行线程的抓取空间。当一个函数被调用时,堆栈顶部会预留一个块,用于存放本地变量和一些记账数据。当该函数返回时,该块就会成为未使用的块,可以在下一次调用函数时使用。栈总是按照LIFO(最后一个先出后进)的顺序保留;最近保留的块总是下一个要释放的块。这使得跟踪堆栈变得非常简单;从堆栈中释放一个块,只需调整一个指针即可。</target>
        </trans-unit>
        <trans-unit id="219301ffd0ca8cbb0f7920be42b12f92f7f93e51" translate="yes" xml:space="preserve">
          <source>The stack often works in close tandem with a special register on the CPU named the &lt;em&gt;stack pointer&lt;/em&gt;. Initially the stack pointer points to the top of the stack (the highest address on the stack).</source>
          <target state="translated">堆栈通常与CPU上一个名为&lt;em&gt;堆栈指针&lt;/em&gt;的特殊寄存器紧密配合使用。 最初，堆栈指针指向堆栈的顶部（堆栈中的最高地址）。</target>
        </trans-unit>
        <trans-unit id="44325c548d04ad0c66e804e28b38a41e97cabb5a" translate="yes" xml:space="preserve">
          <source>There are two heaps: public and private.</source>
          <target state="translated">有两个堆:公共堆和私人堆。</target>
        </trans-unit>
        <trans-unit id="6947fa83d8ffd6b15a325bb26b73b21bd69379ce" translate="yes" xml:space="preserve">
          <source>These images should do a fairly good job of describing the two ways of allocating and freeing memory in a stack and a heap.  Yum!</source>
          <target state="translated">这些图片应该可以相当好地描述堆和堆中的两种内存分配和释放方式。Yum!</target>
        </trans-unit>
        <trans-unit id="98d579f7a93657771058e9e0d89785c656c03025" translate="yes" xml:space="preserve">
          <source>They are all global to the program, but their contents can be private, public, or global.</source>
          <target state="translated">它们都是全局性的程序,但其内容可以是私有的、公开的,也可以是全局性的。</target>
        </trans-unit>
        <trans-unit id="9ef2da64dd7345ced1b7850afdf59a57b13427ca" translate="yes" xml:space="preserve">
          <source>They are not designed to be fast, they are designed to be useful. How the programmer utilizes them determines whether they are &quot;fast&quot; or &quot;slow&quot;</source>
          <target state="translated">它们的设计不是为了快,而是为了有用。程序员如何利用它们,决定了它们是 &quot;快 &quot;还是 &quot;慢&quot;。</target>
        </trans-unit>
        <trans-unit id="d177331b2e0afe564671649c9a49a92fcc2d64f0" translate="yes" xml:space="preserve">
          <source>This article is the source of picture above: &lt;a href=&quot;http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types#Stack%20and%20Heap&quot;&gt;Six important .NET concepts: Stack, heap, value types, reference types, boxing, and unboxing - CodeProject&lt;/a&gt;</source>
          <target state="translated">本文是上述图片的来源： &lt;a href=&quot;http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types#Stack%20and%20Heap&quot;&gt;六个重要的.NET概念：堆栈，堆，值类型，引用类型，装箱和拆箱-CodeProject&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="717f1e13592dff5b361146af2de994b4dd7d6e98" translate="yes" xml:space="preserve">
          <source>This chain of suspended function calls is the stack, because elements in the stack (function calls) depend on each other.</source>
          <target state="translated">这条被暂停的函数调用链就是堆栈,因为堆栈中的元素(函数调用)是相互依赖的。</target>
        </trans-unit>
        <trans-unit id="f0dbb83fd38c86e398ef0d609e84dfa07ea2c5b6" translate="yes" xml:space="preserve">
          <source>This is because of the way that memory is allocated on the stack.</source>
          <target state="translated">这是因为内存在堆栈上的分配方式。</target>
        </trans-unit>
        <trans-unit id="fb3c5c901732960cbf1b7b18121a96994d8cfa9e" translate="yes" xml:space="preserve">
          <source>This is only practical if your memory usage is quite different from the norm - i.e for games where you load a level in one huge operation and can chuck the whole lot away in another huge operation.</source>
          <target state="translated">这只有在你的内存使用量与正常情况大不相同的情况下才实用---即在游戏中,你可以在一个大的操作中加载一个关卡,然后在另一个大的操作中把整个关卡丢掉。</target>
        </trans-unit>
        <trans-unit id="ce81aba3a9e4c22e20ebcec915d127d8ea49a173" translate="yes" xml:space="preserve">
          <source>Thus, the heap is far more complex, because there end up being regions of memory that are unused interleaved with chunks that are - memory gets fragmented. Finding free memory of the size you need is a difficult problem. This is why the heap should be avoided (though it is still often used).</source>
          <target state="translated">因此,堆的情况要复杂得多,因为最终会有一些未使用的内存区域与大块的内存交织在一起,这些大块的内存会被碎片化。找到你所需要的大小的空闲内存是一个困难的问题。这就是为什么应该避免使用堆的原因(尽管它仍然经常被使用)。</target>
        </trans-unit>
        <trans-unit id="3718bea08e5c6c1e1ef5855208635c1660091c56" translate="yes" xml:space="preserve">
          <source>To answer your questions directly:</source>
          <target state="translated">为了直接回答你的问题。</target>
        </trans-unit>
        <trans-unit id="e510eed8b65862876804eb3fc84dd696d12ba373" translate="yes" xml:space="preserve">
          <source>To clarify, &lt;a href=&quot;https://stackoverflow.com/a/13308092/1763801&quot;&gt;this answer&lt;/a&gt; has incorrect information (&lt;a href=&quot;https://stackoverflow.com/a/662454/1763801&quot;&gt;thomas&lt;/a&gt; fixed his answer after comments, cool :) ). Other answers just avoid explaining what static allocation means. So I will explain the three main forms of allocation and how they usually relate to the heap, stack, and data segment below. I also will show some examples in both C/C++ and Python to help people understand.</source>
          <target state="translated">为了澄清， &lt;a href=&quot;https://stackoverflow.com/a/13308092/1763801&quot;&gt;这个答案&lt;/a&gt;有错误的信息（ &lt;a href=&quot;https://stackoverflow.com/a/662454/1763801&quot;&gt;托马斯&lt;/a&gt;在评论后固定了他的答案，很酷:)）。 其他答案只是避免解释静态分配的含义。 因此，我将在下面解释三种主要的分配形式以及它们通常与堆，堆栈和数据段的关系。 我还将在C / C ++和Python中显示一些示例，以帮助人们理解。</target>
        </trans-unit>
        <trans-unit id="aba9caf0dd8ab1b5293cad558ca993a95a150673" translate="yes" xml:space="preserve">
          <source>To what extent are they controlled by the OS or language run-time?</source>
          <target state="translated">它们在多大程度上受操作系统或语言运行时的控制?</target>
        </trans-unit>
        <trans-unit id="0d0079c7ce4541e2501b37e50c9d74ba8c7a5637" translate="yes" xml:space="preserve">
          <source>To what extent are they controlled by the OS or language runtime?</source>
          <target state="translated">它们在多大程度上受操作系统或语言运行时的控制?</target>
        </trans-unit>
        <trans-unit id="38a1226205399953841a1f147c1b73da6efe0983" translate="yes" xml:space="preserve">
          <source>Unlike the stack, the heap does not have size restrictions on variable size (apart from the obvious physical limitations of your computer). Heap memory is slightly slower to be read from and written to, because one has to use pointers to access memory on the heap. We will talk about pointers shortly.</source>
          <target state="translated">与堆不同的是,堆没有大小可变的限制(除了你的计算机有明显的物理限制外)。堆内存的读写速度稍慢,因为必须使用指针来访问堆上的内存。关于指针,我们稍后再谈。</target>
        </trans-unit>
        <trans-unit id="5a0471929b5ff3505424261361762519c6273689" translate="yes" xml:space="preserve">
          <source>Unlike the stack, variables created on the heap are accessible by any function, anywhere in your program. Heap variables are essentially global in scope.</source>
          <target state="translated">与堆栈不同,在堆上创建的变量可以被任何函数在程序的任何地方访问。堆上的变量基本上是全局的。</target>
        </trans-unit>
        <trans-unit id="1c9512b6d7a011bae14a8693bd32c0ef50ceaf32" translate="yes" xml:space="preserve">
          <source>Used on demand to allocate a block of data for use by the program.</source>
          <target state="translated">用于按需分配一个数据块供程序使用。</target>
        </trans-unit>
        <trans-unit id="350c906ec4a09c92d2b1ef4efaf9a024398e8269" translate="yes" xml:space="preserve">
          <source>Usually has a maximum size already determined when your program starts.</source>
          <target state="translated">通常情况下,在程序启动时就已经确定了最大尺寸。</target>
        </trans-unit>
        <trans-unit id="dee4e9274b9716c1313c6fb0868f5a44bbadc5a1" translate="yes" xml:space="preserve">
          <source>Variables allocated on the heap have their memory allocated at run time and accessing this memory is a bit slower, but the heap size is only limited by the size of virtual memory. Elements of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time.</source>
          <target state="translated">在堆上分配的变量在运行时有其内存分配,访问这个内存的速度要慢一些,但堆的大小只受虚拟内存大小的限制。堆中的元素相互之间没有依赖关系,可以随时随机访问。你可以在任何时候分配一个块,也可以在任何时候释放它。这使得跟踪堆中的哪些部分在任何时候被分配或释放的情况变得更加复杂。</target>
        </trans-unit>
        <trans-unit id="33c4c29193773c536fab56f19aa3e378c611f11a" translate="yes" xml:space="preserve">
          <source>Variables allocated on the stack are stored directly to the memory and access to this memory is very fast, and its allocation is dealt with when the program is compiled. When a function or a method calls another function which in turns calls another function, etc., the execution of all those functions remains suspended until the very last function returns its value. The stack is always reserved in a LIFO order, the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack, freeing a block from the stack is nothing more than adjusting one pointer.</source>
          <target state="translated">在栈上分配的变量直接存储到内存中,对这个内存的访问速度非常快,在程序编译时,对它的分配就会进行处理。当一个函数或一个方法调用另一个函数,反过来又调用另一个函数等,所有这些函数的执行都是暂停的,直到最后一个函数返回其值为止。栈总是按LIFO顺序保留,最近保留的块总是下一个要释放的块。这使得跟踪堆栈的过程变得非常简单,从堆栈中释放一个块只是调整一个指针而已。</target>
        </trans-unit>
        <trans-unit id="b757f96ab6cbd88a78e6eb37e901095a0f4982d5" translate="yes" xml:space="preserve">
          <source>Variables can be accessed globally</source>
          <target state="translated">变量可以在全球范围内访问</target>
        </trans-unit>
        <trans-unit id="e1263b2fe0ce0f9a78ac08d33e5cb650a6f890af" translate="yes" xml:space="preserve">
          <source>Variables can be resized using realloc()</source>
          <target state="translated">可以使用realloc()来调整变量的大小。</target>
        </trans-unit>
        <trans-unit id="0acb71d1ea9ad7194e7c46ab11399d5d7dc9cbc1" translate="yes" xml:space="preserve">
          <source>Variables cannot be resized</source>
          <target state="translated">不能调整变量的大小</target>
        </trans-unit>
        <trans-unit id="45bc57bc7c9a39f9e93f0ee2742931507b1a0117" translate="yes" xml:space="preserve">
          <source>Variables created on the stack will go out of scope and are automatically deallocated.</source>
          <target state="translated">在堆栈上创建的变量将超出范围,并自动deocallated。</target>
        </trans-unit>
        <trans-unit id="83322fdd7220f9c3561a31019be7de90f70f1113" translate="yes" xml:space="preserve">
          <source>Very fast access</source>
          <target state="translated">非常快速的通道</target>
        </trans-unit>
        <trans-unit id="81465c90cda3940dcc21c6d0fc345dbf62900490" translate="yes" xml:space="preserve">
          <source>Very fast access.</source>
          <target state="translated">访问速度非常快。</target>
        </trans-unit>
        <trans-unit id="d03f25431e8717de4af8cfb5712d2af28175c6de" translate="yes" xml:space="preserve">
          <source>What and where are the stack and heap</source>
          <target state="translated">什么是堆栈和堆头,在哪里?</target>
        </trans-unit>
        <trans-unit id="e330f4218aa5748683c1aedc4c7ad3739182f7f9" translate="yes" xml:space="preserve">
          <source>What determines the size of each of them?</source>
          <target state="translated">是什么决定了它们各自的大小?</target>
        </trans-unit>
        <trans-unit id="780a2c071a1fa9df58512fef52b5d41ee762fbf5" translate="yes" xml:space="preserve">
          <source>What is their scope?</source>
          <target state="translated">他们的范围是什么?</target>
        </trans-unit>
        <trans-unit id="b72db36173b02e399c3380ebce765f483206c5f5" translate="yes" xml:space="preserve">
          <source>What makes one faster?</source>
          <target state="translated">是什么让一个人的速度更快?</target>
        </trans-unit>
        <trans-unit id="7dd7be24ae5c5f3254644f00a932a8eaf93d7843" translate="yes" xml:space="preserve">
          <source>When a function is called the CPU uses special instructions that push the current &lt;em&gt;instruction pointer&lt;/em&gt;, i.e. the address of the code executing on the stack. The CPU then jumps to the function by setting the 
instruction pointer to the address of the function called. Later, when the function returns, the old instruction pointer is popped from the stack and execution resumes at the code just after the call to the function.</source>
          <target state="translated">当调用一个函数时，CPU使用特殊指令来推动当前&lt;em&gt;指令指针&lt;/em&gt; ，即在堆栈上执行的代码的地址。 然后，CPU通过将指令指针设置为所调用函数的地址来跳转至该函数。 稍后，当函数返回时，旧的指令指针会从堆栈中弹出，并在调用函数后立即在代码处恢复执行。</target>
        </trans-unit>
        <trans-unit id="76bfa98cbe27f31d7e7e3e9a0604cbd18ab53032" translate="yes" xml:space="preserve">
          <source>When a function is entered, the stack pointer is decreased to allocate more space on the stack for local (automatic) variables. If the function has one local 32 bit variable four bytes are set aside on the stack. When the function returns, the stack pointer is moved back to free the allocated area.</source>
          <target state="translated">当输入一个函数时,堆栈指针会减少,以便在堆栈上为本地(自动)变量分配更多的空间。如果函数有一个32位的本地变量,则会在堆栈上预留4个字节。当函数返回时,堆栈指针被移回,以释放分配的空间。</target>
        </trans-unit>
        <trans-unit id="7345937a4022621af869e20017f6923e9e95b153" translate="yes" xml:space="preserve">
          <source>When a function or a method calls another function which in turns calls another function, etc., the execution of all those functions remains suspended until the very last function returns its value.</source>
          <target state="translated">当一个函数或方法调用了另一个函数,而另一个函数反过来又调用了另一个函数等,那么所有这些函数的执行都会被暂停,直到最后一个函数返回其值为止。</target>
        </trans-unit>
        <trans-unit id="17eea20994cf0f8b60ad7500e16ae0d2babaffb7" translate="yes" xml:space="preserve">
          <source>When a used block that is adjacent to a free block is deallocated the new free block may be merged with the adjacent free block to create a larger free block effectively reducing the fragmentation of the heap.</source>
          <target state="translated">当使用过的区块相邻的自由区块被重新分配时,新的自由区块可能会与相邻的自由区块合并,以创建一个更大的自由区块,有效地减少了堆的碎片化。</target>
        </trans-unit>
        <trans-unit id="fc80e3d497340bb1dd2782f548d7a04ed5176215" translate="yes" xml:space="preserve">
          <source>When using fibers, green threads or coroutines, you &lt;em&gt;usually&lt;/em&gt; have a separate stack per function. (Technically, not just a stack but a whole context of execution is per function. Most importantly, CPU registers.) For every thread there're as many stacks as there're concurrently running functions, and the thread is switching between executing each function according to the logic of your program. When a function runs to its end, its stack is destroyed. So, &lt;strong&gt;the number and lifetimes of stacks&lt;/strong&gt; are dynamic and &lt;strong&gt;are not determined by the number of OS-level threads!&lt;/strong&gt;</source>
          <target state="translated">使用纤维，绿线或协程时， &lt;em&gt;通常&lt;/em&gt;每个功能都有单独的堆栈。 （从技术上讲，每个函数不仅是堆栈，而且整个执行上下文是每个函数。最重要的是，CPU寄存器。）对于每个线程，堆栈与同时运行的函数一样多，并且线程在执行每个函数之间切换根据您程序的逻辑。 当函数运行到末尾时，其堆栈将被破坏。 因此， &lt;strong&gt;堆栈的数量和生存期&lt;/strong&gt;是动态的， &lt;strong&gt;而不是由OS级线程的数量决定的！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a476cf0746ec4d2c4a044655c71d195262024622" translate="yes" xml:space="preserve">
          <source>Where and what are they (physically in a real computer's memory)?</source>
          <target state="translated">它们在哪里,又是什么(物理上在真正的电脑内存中)?</target>
        </trans-unit>
        <trans-unit id="1fb0c80cb7c016fa977e4e460c6d36c71cd287e5" translate="yes" xml:space="preserve">
          <source>Without stack &lt;strong&gt;no&lt;/strong&gt; microprocessor can work. (we can't imagine a program, even in assembly language, without subroutines/functions)</source>
          <target state="translated">没有堆栈，微处理器将无法工作。 （我们无法想象没有子例程/函数的程序，即使是汇编语言）</target>
        </trans-unit>
        <trans-unit id="010f37556d32304cf4397c04fe519e09ac87a1e2" translate="yes" xml:space="preserve">
          <source>Without the heap it can. (An assembly language program can work without, as the heap is a OS concept, as malloc, that is a OS/Lib call.</source>
          <target state="translated">没有堆它可以。(汇编语言程序没有堆也可以工作,因为堆是操作系统的概念,就像malloc一样,是OSLib的调用)。</target>
        </trans-unit>
        <trans-unit id="3a9de33c793289bb4824480cb8f4087bf9168010" translate="yes" xml:space="preserve">
          <source>Wow! So many answers and I don't think one of them got it right...</source>
          <target state="translated">哇!这么多的答案,我觉得没有一个人答对了......</target>
        </trans-unit>
        <trans-unit id="b1e7c9f013a3dbd26304d7c5054c48167a4ae117" translate="yes" xml:space="preserve">
          <source>You can do some interesting things with the stack.  For instance, you have functions like &lt;a href=&quot;http://everything2.com/title/alloca%2528%2529&quot;&gt;alloca&lt;/a&gt; (assuming you can get past the copious warnings concerning its use), which is a form of malloc that specifically uses the stack, not the heap, for memory.</source>
          <target state="translated">您可以使用堆栈做一些有趣的事情。 例如，您具有类似&lt;a href=&quot;http://everything2.com/title/alloca%2528%2529&quot;&gt;alloca的&lt;/a&gt;功能（假设您可以绕过有关其用法的大量警告），这是一种malloc的形式，专门使用堆栈而不是堆来进行内存存储。</target>
        </trans-unit>
        <trans-unit id="892eae56f7439ba3dcbb1ea3ea17d754f03b35eb" translate="yes" xml:space="preserve">
          <source>You can use the stack if you know exactly how much data you need to allocate before compile time, and it is not too big. You can use the heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data.</source>
          <target state="translated">如果你知道在编译前需要分配多少数据,并且不是太大,你可以使用堆栈。如果你不清楚运行时需要多少数据,或者需要分配大量的数据,你可以使用堆。</target>
        </trans-unit>
        <trans-unit id="3009d59448498f75aa79426e3fa60a5f198f2ebb" translate="yes" xml:space="preserve">
          <source>You can use the stack to pass parameters.. even if it is slower than using registers (would a microprocessor guru say or a good 1980s BIOS book...)</source>
          <target state="translated">你可以使用栈来传递参数...........即使它比使用寄存器要慢(微处理器大师会说,或者是一本好的80年代的BIOS书......</target>
        </trans-unit>
        <trans-unit id="6406486d2198ac8633b1773b5680854692fc022d" translate="yes" xml:space="preserve">
          <source>You must manage memory (you're in charge of allocating and freeing variables)</source>
          <target state="translated">你必须管理内存(你负责分配和释放变量)</target>
        </trans-unit>
        <trans-unit id="448cd0c4ab29afd1275bb72eaa06d3f1ffbebf2e" translate="yes" xml:space="preserve">
          <source>You would use the heap if you don't know exactly how much data you will need at run time or if you need to allocate a lot of data.</source>
          <target state="translated">如果你不知道自己在运行时需要多少数据,或者需要分配很多数据,你会使用堆。</target>
        </trans-unit>
        <trans-unit id="21f0077be84d0a785692e7530efcb1dfe9e053c8" translate="yes" xml:space="preserve">
          <source>You would use the stack if you know exactly how much data you need to allocate before compile time and it is not too big.</source>
          <target state="translated">如果你知道在编译前需要分配多少数据,而且不会太大,你就会使用堆栈。</target>
        </trans-unit>
        <trans-unit id="2dd752e3a7242d730dc1ffd2af44fb8042a9cd98" translate="yes" xml:space="preserve">
          <source>and here:</source>
          <target state="translated">和这里。</target>
        </trans-unit>
        <trans-unit id="e7cb8b2830bfb6729d691a0e8fc0b7ca5702106b" translate="yes" xml:space="preserve">
          <source>but be aware it may contain some inaccuracies.</source>
          <target state="translated">但要注意可能包含一些不准确的内容。</target>
        </trans-unit>
        <trans-unit id="3e27b62ab595041b7d6fc3295ef65f967e4bb6d4" translate="yes" xml:space="preserve">
          <source>malloc requires entering kernel mode, use lock/semaphore (or other synchronization primitives) executing some code and manage some structures needed to keep track of allocation.</source>
          <target state="translated">malloc需要进入内核模式,使用locksemaphore(或其他同步基元)执行一些代码并管理一些需要跟踪分配的结构。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
