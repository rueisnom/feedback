<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/79923">
    <body>
      <group id="79923">
        <trans-unit id="94b77d4c21edabc0121f024c01bcc9ef48259dc3" translate="yes" xml:space="preserve">
          <source>&quot;Static&quot; (AKA statically allocated) variables are not allocated on the stack. Do not assume so - many people do only because &quot;static&quot; sounds a lot like &quot;stack&quot;. They actually exist in neither the stack nor the heap. The are part of what's called the &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_segment&quot;&gt;data segment&lt;/a&gt;.</source>
          <target state="translated">&amp;laquo;Статические&amp;raquo; (статически распределенные AKA) переменные не размещаются в стеке. Не думайте так - многие люди делают только потому, что &amp;laquo;статический&amp;raquo; очень похож на &amp;laquo;стек&amp;raquo;. Они на самом деле не существуют ни в стеке, ни в куче. Они являются частью того, что называется &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_segment&quot;&gt;сегментом данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7b5c0042bc6fdc5e224949119eea46897b85f96" translate="yes" xml:space="preserve">
          <source>&quot;You can use the stack if you know exactly how much data you need to allocate before compile time, and it is not too big. You can use the heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data.&quot;</source>
          <target state="translated">&quot;Вы можете использовать стек,если точно знаете,сколько данных нужно выделить перед компиляцией,и он не слишком велик.Вы можете использовать кучу данных,если не знаете точно,сколько данных вам понадобится во время компиляции,или если вам нужно выделить много данных&quot;.</target>
        </trans-unit>
        <trans-unit id="6b71c1598ca48211c09537cb37ffecd0279e4352" translate="yes" xml:space="preserve">
          <source>(I have moved this answer from another question that was more or less a dupe of this one.)</source>
          <target state="translated">(Я переместил этот ответ с другого вопроса,который был более или менее дублирующим этот).</target>
        </trans-unit>
        <trans-unit id="61257768b7a93e136c9c290d6825931b71bdb701" translate="yes" xml:space="preserve">
          <source>(Relatively) slower access</source>
          <target state="translated">(относительно)более медленный доступ</target>
        </trans-unit>
        <trans-unit id="260e2615aff475120193632bb3dec58b387e3862" translate="yes" xml:space="preserve">
          <source>1) Where and what are they (physically in a real computer's memory)?</source>
          <target state="translated">1)Где и что они (физически в памяти настоящего компьютера)?</target>
        </trans-unit>
        <trans-unit id="fdb1507c9ac6adb1fa6fa6251df8690b83ca6414" translate="yes" xml:space="preserve">
          <source>2) To what extent are they controlled by the OS or language runtime?</source>
          <target state="translated">2)В какой степени они контролируются операционной системой или языковой средой выполнения?</target>
        </trans-unit>
        <trans-unit id="99b4e74430a1011d0a32a5e6a68f89192d5600f4" translate="yes" xml:space="preserve">
          <source>2b) What is their scope?</source>
          <target state="translated">2b)Каковы их масштабы?</target>
        </trans-unit>
        <trans-unit id="9888f38f3e423435fa5b8292adbdd39fb0f72092" translate="yes" xml:space="preserve">
          <source>2c) What determines the size of each of them?</source>
          <target state="translated">2c)Что определяет размер каждого из них?</target>
        </trans-unit>
        <trans-unit id="019eef749bba4958d2ffca2f9849b67199fb6815" translate="yes" xml:space="preserve">
          <source>2d) What makes one faster?</source>
          <target state="translated">2d)Что делает один быстрее?</target>
        </trans-unit>
        <trans-unit id="e2d2295e136ea1dc3f598156ec945a446432c714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Local Variables&lt;/code&gt; that only need to last as long as the function invocation go in the stack. The heap is used for variables whose lifetime we don't really know up front but we expect them to last a while. In most languages it's critical that we know at compile time how large a variable is if we want to store it on the stack.</source>
          <target state="translated">&lt;code&gt;Local Variables&lt;/code&gt; которые должны длиться до тех пор, пока вызов функции идет в стек. Куча используется для переменных, время жизни которых мы на самом деле не знаем заранее, но мы ожидаем, что они будут длиться некоторое время. В большинстве языков очень важно знать во время компиляции, насколько велика переменная, если мы хотим сохранить ее в стеке.</target>
        </trans-unit>
        <trans-unit id="db81e688d99a4e08a6e79477826a7c115e20208c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To what extent are they controlled by the OS or language runtime?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;В какой степени они контролируются ОС или языковой средой выполнения?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="513a3b3ab4e6ae37babfa4b83b1cb3c51c31881a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What determines the size of each of them?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;От чего зависит размер каждого из них?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d053678e5d47e6f07a8fde4ce00b7cddb559cbb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is their scope?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Какова их сфера применения?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dcfa20263ead7486e0e7d967879203f1a13837a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What makes one faster?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Что делает быстрее?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9a6c5f939fd49e7bad84b2be8abb7f468b02d07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Both together&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Оба вместе&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84a530a09edadff20200961546fdc028c855eefc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heap:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Heap:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85e58808cd94b0b4694342607d9808c4b578db9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Heap&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="917e40efec8d1d189c6f18faaf670f99b1bd7e44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heap&lt;/strong&gt;: No order, processing gonna be slower and values are messed up together with no specific order or index... there are random and there is no relationship between them... so execution and usage time could be vary...</source>
          <target state="translated">&lt;strong&gt;Куча&lt;/strong&gt; : нет порядка, обработка будет медленнее, а значения перепутаны без какого-либо определенного порядка или индекса ... есть случайные и нет никакой связи между ними ... поэтому время выполнения и использования может варьироваться ...</target>
        </trans-unit>
        <trans-unit id="742792f83b9d6d503d676cd5342ac745b1a51f3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;
Implementation of both the stack and heap is usually down to the runtime / OS. Often games and other applications that are performance critical create their own memory solutions that grab a large chunk of memory from the heap and then dish it out internally to avoid relying on the OS for memory.</source>
          <target state="translated">&lt;strong&gt;Реализация&lt;/strong&gt; Реализация как стека, так и кучи обычно зависит от времени выполнения / ОС. Часто игры и другие приложения, критически важные для производительности, создают свои собственные решения для памяти, которые захватывают большой кусок памяти из кучи, а затем распределяют ее изнутри, чтобы избежать зависимости ОС от памяти.</target>
        </trans-unit>
        <trans-unit id="b0c3414fb835eb86d73b6be57a2a7aebafd2801c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interesting note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Интересная заметка:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a0e3df07fea6c0d8b408481568ec08761eb430d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; simply and in short words, they mean &lt;strong&gt;ordered&lt;/strong&gt; and &lt;strong&gt;not ordered&lt;/strong&gt;...!</source>
          <target state="translated">&lt;strong&gt;ОК,&lt;/strong&gt; просто и в двух словах, они означают &lt;strong&gt;упорядоченный,&lt;/strong&gt; а &lt;strong&gt;не заказанный&lt;/strong&gt; ...!</target>
        </trans-unit>
        <trans-unit id="8628c9ba0a73bc55254ac6ceb73adfa8e4eada2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Physical location in memory&lt;/strong&gt;
This is less relevant than you think because of a technology called &lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_memory&quot;&gt;Virtual Memory&lt;/a&gt; which makes your program think that you have access to a certain address where the physical data is somewhere else (even on the hard disc!). The addresses you get for the stack are in increasing order as your call tree gets deeper. The addresses for the heap are un-predictable (i.e implimentation specific) and frankly not important.</source>
          <target state="translated">&lt;strong&gt;Физическое расположение в памяти&lt;/strong&gt; Это менее важно, чем вы думаете, из-за технологии, называемой &lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_memory&quot;&gt;виртуальной памятью,&lt;/a&gt; которая заставляет вашу программу думать, что у вас есть доступ к определенному адресу, где физические данные находятся где-то еще (даже на жестком диске!). Адреса, которые вы получаете для стека, растут по мере того, как дерево вызовов становится глубже. Адреса для кучи непредсказуемы (т. Е. Специфичны для имплиментации) и, честно говоря, не важны.</target>
        </trans-unit>
        <trans-unit id="e19a9343f895eca75944e60482202b71e0cbcd58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stack:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Stack:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c741ee79de20716b9e2549b13bac80467d01d08f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stack&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Stack&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7e4ac541ac7066d86d467c49418a1b8c8ab19f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stack&lt;/strong&gt;: In stack items, things get on the top of each-other, means gonna be faster and more efficient to be processed!...</source>
          <target state="translated">&lt;strong&gt;Стек&lt;/strong&gt; : В элементах стека вещи оказываются друг на друге, что означает, что они будут быстрее и эффективнее обрабатываться! ...</target>
        </trans-unit>
        <trans-unit id="7e7cfe5d1f60635f341d1ef4579eb83f724c5d41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Heap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Куча&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6709062928227b6319f7deeb9a0847d3a67f3a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Heap&lt;/strong&gt;
The heap is a generic name for where you put the data that you create on the fly. If you don't know how many spaceships your program is going to create, you are likely to use the new (or malloc or equivalent) operator to create each spaceship. This allocation is going to stick around for a while, so it is likely we will free things in a different order than we created them.</source>
          <target state="translated">&lt;strong&gt;Куча&lt;/strong&gt; Куча - это общее имя для размещения данных, которые вы создаете на лету. Если вы не знаете, сколько космических кораблей собирается создать ваша программа, вы, вероятно, будете использовать новый (или malloc или эквивалентный) оператор для создания каждого космического корабля. Это распределение останется на некоторое время, поэтому, скорее всего, мы освободим вещи в другом порядке, чем мы их создали.</target>
        </trans-unit>
        <trans-unit id="bcb3f513eb6fa7ddc8d6c4dc2b21d182cce677d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Stack&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Стек&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a390d755244266caf60a0813cd14b6beb633141e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Stack&lt;/strong&gt;
When you call a function the arguments to that function plus some other overhead is put on the stack. Some info (such as where to go on return) is also stored there.
When you declare a variable inside your function, that variable is also allocated on the stack.</source>
          <target state="translated">&lt;strong&gt;Стек&lt;/strong&gt; Когда вы вызываете функцию, в стек помещаются аргументы этой функции и другие накладные расходы. Некоторая информация (например, куда идти по возвращении) также хранится там. Когда вы объявляете переменную внутри вашей функции, эта переменная также размещается в стеке.</target>
        </trans-unit>
        <trans-unit id="76cc17ae17ebb267fcbd177db1d4f1d292b7ce9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To what extent are they controlled by the OS or language runtime?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;В какой степени они контролируются ОС или языковой средой выполнения?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0563b18a23e550f58bac67d459c94a52a3249acd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What determines the size of each of them?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;От чего зависит размер каждого из них?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c6c7dce19b600ea980045fc6edcd1962f6b5551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a heap?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что такое куча?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b97a8d104003b830b171fde9ab6c0f738620e336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a stack?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что такое стек?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6b73e40eadb8e589a235f27b4b54d80562f2496" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is their scope?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Какова их сфера применения?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="159e5d461f5ea67df5f298bd8e4358250caeb1b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What makes one faster?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что делает быстрее?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="78f9413c67586527ba6c81668b7aa287b0c28430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Which is faster &amp;ndash; the stack or the heap? And why?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что быстрее - стек или куча?&lt;/strong&gt; &lt;strong&gt;И почему?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad882499bf2a5c77de197c8c4907389551e5d253" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stack&lt;/strong&gt;, &lt;strong&gt;heap&lt;/strong&gt; and &lt;strong&gt;data&lt;/strong&gt; of each process in virtual memory:</source>
          <target state="translated">&lt;strong&gt;стек&lt;/strong&gt; , &lt;strong&gt;куча&lt;/strong&gt; и &lt;strong&gt;данные&lt;/strong&gt; каждого процесса в виртуальной памяти:</target>
        </trans-unit>
        <trans-unit id="2e2ab5cd39dfbdc8c03b7bbbbd7b88d895cbeb77" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Image source: &lt;a href=&quot;http://vikashazrati.wordpress.com/2007/10/01/quicktip-java-basics-stack-and-heap/&quot;&gt;vikashazrati.wordpress.com&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Источник изображения: &lt;a href=&quot;http://vikashazrati.wordpress.com/2007/10/01/quicktip-java-basics-stack-and-heap/&quot;&gt;vikashazrati.wordpress.com&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="66efe8c438bd049d124a2fb9c161181488baa05f" translate="yes" xml:space="preserve">
          <source>A clear demonstration:</source>
          <target state="translated">Четкая демонстрация:</target>
        </trans-unit>
        <trans-unit id="01ce9bd8f6baf3c7c49927f90f1d012016d83e18" translate="yes" xml:space="preserve">
          <source>A couple of cents: I think, it will be good to draw memory graphical and more simple:</source>
          <target state="translated">Пару центов:Я думаю,будет хорошо рисовать память графически и проще:</target>
        </trans-unit>
        <trans-unit id="a15b908bf3b3ecfd069a0fe5e01ef6e82a56da1d" translate="yes" xml:space="preserve">
          <source>A heap is a general term for anything that can be dynamically allocated.  Depending on which way you look at it, it is constantly changing size.  In modern processors and operating systems the exact way it works is very abstracted anyway, so you don't normally need to worry much about how it works deep down, except that (in languages where it lets you) you mustn't use memory that you haven't allocated yet or memory that you have freed.</source>
          <target state="translated">Куча-это общий термин для всего,что может быть динамически выделено.В зависимости от того,как вы на нее смотрите,она постоянно меняется в размерах.В современных процессорах и операционных системах то,как она работает,все равно очень абстрактно,так что в глубине души вам обычно не нужно сильно беспокоиться о том,как она работает,за исключением того,что (в тех языках,где она позволяет)вы не должны использовать память,которую вы еще не выделили,или память,которую вы освободили.</target>
        </trans-unit>
        <trans-unit id="068dd7e9d8ed5b397b0a6eff3ba84c4edc71f672" translate="yes" xml:space="preserve">
          <source>A heap is a general term used for any memory that is allocated dynamically and randomly; i.e. out of order.  The memory is typically allocated by the OS, with the application calling API functions to do this allocation.  There is a fair bit of overhead required in managing dynamically allocated memory, which is usually handled by the runtime code of the programming language or environment used.</source>
          <target state="translated">Куча-это общий термин,используемый для любой памяти,которая выделяется динамически и случайно,т.е.не по порядку.Память обычно выделяется операционной системой,для этого приложение вызывает функции API.Управление динамически выделяемой памятью требует значительных накладных расходов,которые обычно обрабатываются исполнительным кодом используемого языка программирования или среды.</target>
        </trans-unit>
        <trans-unit id="34f5d3ec6b1ce5253cef0356a62d5aa350e32ac5" translate="yes" xml:space="preserve">
          <source>A heap is an untidy collection of things piled up haphazardly.</source>
          <target state="translated">Куча-это неряшливая коллекция вещей,нагроможденная беспорядочно.</target>
        </trans-unit>
        <trans-unit id="ee141ae29a5c83c4f8aa0cade4298cafffd77712" translate="yes" xml:space="preserve">
          <source>A lot of answers are correct as concepts, but we must note that a stack is needed by the hardware (i.e. microprocessor) to allow calling subroutines (CALL in assembly language..). (OOP guys will call it &lt;em&gt;methods&lt;/em&gt;)</source>
          <target state="translated">Многие ответы верны как понятия, но мы должны отметить, что аппаратному обеспечению необходим стек (то есть микропроцессор), чтобы позволить вызывать подпрограммы (CALL на ассемблере ..). (ООП ребята будут называть это &lt;em&gt;методами&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="c31b57674dbc2b0d1d5439a1c86d854b8d2b25b9" translate="yes" xml:space="preserve">
          <source>A particularly poignant example of why it's important to distinguish between lifetime and scope is that a variable can have local scope but static lifetime - for instance, &quot;someLocalStaticVariable&quot; in the code sample above. Such variables can make our common but informal naming habits very confusing. For instance when we say &quot;&lt;em&gt;local&lt;/em&gt;&quot; we usually mean &quot;&lt;em&gt;locally scoped automatically allocated variable&lt;/em&gt;&quot; and when we say global we usually mean &quot;&lt;em&gt;globally scoped statically allocated variable&lt;/em&gt;&quot;. Unfortunately when it comes to things like &quot;&lt;em&gt;file scoped statically allocated variables&lt;/em&gt;&quot; many people just say... &quot;&lt;em&gt;huh???&lt;/em&gt;&quot;.</source>
          <target state="translated">Особенно яркий пример того, почему важно различать время жизни и область видимости, состоит в том, что переменная может иметь локальную область видимости, но статическое время жизни - например, &amp;laquo;someLocalStaticVariable&amp;raquo; в приведенном выше примере кода. Такие переменные могут сделать наши общие, но неформальные привычки именования очень запутанными. Например, когда мы говорим &amp;laquo; &lt;em&gt;локально&lt;/em&gt; &amp;raquo;, мы обычно имеем в виду &amp;laquo; &lt;em&gt;локально распределенную переменную с автоматическим распределением&lt;/em&gt; &amp;raquo;, а когда мы говорим &amp;laquo;глобально&amp;raquo;, мы обычно имеем в виду &amp;laquo; &lt;em&gt;глобально ограниченную статически распределенную переменную&lt;/em&gt; &amp;raquo;. К сожалению, когда речь заходит о таких вещах, как &amp;laquo; &lt;em&gt;статически распределенные переменные в области видимости файлов&lt;/em&gt; &amp;raquo;, многие люди просто говорят&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="cc133acebf965ce867ad157a05f353a3707fecd3" translate="yes" xml:space="preserve">
          <source>A stack is a pile of objects, typically one that is neatly arranged.</source>
          <target state="translated">Штабель-это куча объектов,обычно аккуратно расположенных.</target>
        </trans-unit>
        <trans-unit id="9f4c46ea1849c89970aa6079e049594ebbd9a39c" translate="yes" xml:space="preserve">
          <source>A stack is used for static memory allocation and a heap for dynamic memory allocation, both stored in the computer's RAM.</source>
          <target state="translated">Стек используется для статического выделения памяти и куча для динамического выделения памяти,обе хранятся в оперативной памяти компьютера.</target>
        </trans-unit>
        <trans-unit id="7d53fc8a81490a3d76add68a85ec8e7f0f02250f" translate="yes" xml:space="preserve">
          <source>A typical C program was laid out flat in memory with
an opportunity to increase by changing the brk() value.
Typically, the HEAP was just below this brk value
and increasing brk increased the amount of available heap.</source>
          <target state="translated">Типичная программа на Си была выложена в плоскую память с возможностью увеличения за счет изменения значения brk().Обычно HEAP был чуть ниже этого значения brk,а увеличение brk увеличивало количество доступной кучи.</target>
        </trans-unit>
        <trans-unit id="0eb3c88bb9382983d9131328ce15ca6b37271be5" translate="yes" xml:space="preserve">
          <source>Again, it depends on the language, compiler, operating system and architecture.  A stack is usually pre-allocated, because by definition it must be contiguous memory.  The language compiler or the OS determine its size.  You don't store huge chunks of data on the stack, so it'll be big enough that it should never be fully used, except in cases of unwanted endless recursion (hence, &quot;stack overflow&quot;) or other unusual programming decisions.</source>
          <target state="translated">Опять же,это зависит от языка,компилятора,операционной системы и архитектуры.Стек обычно является предварительно выделенным,потому что по определению он должен быть сопрягаемой памятью.Размер стека определяется компилятором языка или операционной системой.На стеке не хранятся огромные куски данных,поэтому он будет достаточно большим,чтобы никогда не использоваться полностью,за исключением случаев нежелательной бесконечной рекурсии (отсюда и &quot;переполнение стека&quot;)или других необычных решений при программировании.</target>
        </trans-unit>
        <trans-unit id="3c53181b48366809a97c6caadb3cafb768a586d9" translate="yes" xml:space="preserve">
          <source>Allocating and deallocating many small blocks may leave the heap in a state where there are a lot of small free blocks interspersed between the used blocks. A request to allocate a large block may fail because none of the free blocks are large enough to satisfy the allocation request even though the combined size of the free blocks may be large enough. This is called &lt;em&gt;heap fragmentation&lt;/em&gt;.</source>
          <target state="translated">Выделение и освобождение многих небольших блоков может оставить кучу в состоянии, когда между используемыми блоками расположено множество небольших свободных блоков. Запрос на выделение большого блока может потерпеть неудачу, поскольку ни один из свободных блоков не является достаточно большим, чтобы удовлетворить запрос на выделение, даже если объединенный размер свободных блоков может быть достаточно большим. Это называется &lt;em&gt;фрагментация кучи&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="038e52e8565cce864ffd7e1b894e6892fe5a1d29" translate="yes" xml:space="preserve">
          <source>Allocating memory on the stack is as simple as moving the stack pointer up.</source>
          <target state="translated">Выделение памяти на стеке так же просто,как перемещение указателя стека вверх.</target>
        </trans-unit>
        <trans-unit id="361ef44f8aa22b0b13d1393adb5398aff7afdb86" translate="yes" xml:space="preserve">
          <source>Already given in top.</source>
          <target state="translated">Уже дано сверху.</target>
        </trans-unit>
        <trans-unit id="d9ac18d3c62e0844f72b69b9833ed0b09f4440d4" translate="yes" xml:space="preserve">
          <source>Also, stack vs. heap is not only a performance consideration; it also tells you a lot about the expected lifetime of objects.</source>
          <target state="translated">Кроме того,стек против кучи-это не только показатель производительности,но и много говорит об ожидаемом сроке службы объектов.</target>
        </trans-unit>
        <trans-unit id="1e2d387706b8a4328b31b3009e56251e7ed275fb" translate="yes" xml:space="preserve">
          <source>Although most compilers and interpreters implement this behavior similarly in terms of using stacks, heaps, etc, a compiler may sometimes break these conventions if it wants as long as behavior is correct. For instance, due to optimization a local variable may only exist in a register or be removed entirely, even though most local variables exist in the stack. As has been pointed out in a few comments, you are free to implement a compiler that doesn't even use a stack or a heap, but instead some other storage mechanisms (rarely done, since stacks and heaps are great for this).</source>
          <target state="translated">Хотя большинство компиляторов и интерпретаторов реализуют подобное поведение аналогичным образом с точки зрения использования стеков,кучи и т.д.,компилятор иногда может нарушить эти соглашения,если хочет,чтобы поведение было корректным.Например,благодаря оптимизации локальная переменная может существовать только в регистре или быть полностью удалена,даже если большинство локальных переменных существует в стеке.Как было отмечено в нескольких комментариях,вы вольны реализовать компилятор,который даже не использует стек или кучу,а вместо этого некоторые другие механизмы хранения (это делается редко,так как стеки и кучи для этого отлично подходят).</target>
        </trans-unit>
        <trans-unit id="eeb33740077a9e43e5825d3e19723b4a66394dcc" translate="yes" xml:space="preserve">
          <source>Arrows - show where grow stack and heap, process stack size have limit, defined in OS, thread stack size limits by parameters in thread create API usually. Heap usually limiting by process maximum virtual memory size, for 32 bit 2-4&amp;nbsp;GB for example.</source>
          <target state="translated">Стрелки - показывают, где растут стек и куча, размер стека процесса имеет ограничение, определенное в ОС, ограничения размера стека потока по параметрам в API создания потока обычно. Обычно размер кучи ограничивается максимальным размером виртуальной памяти процесса, например, для 32-разрядных 2-4 ГБ.</target>
        </trans-unit>
        <trans-unit id="24e9bfdff99d8d81e72e86eb67d28dd9afa0f779" translate="yes" xml:space="preserve">
          <source>As mentioned, heap and stack are general terms, and can be implemented in many ways.  Computer programs typically have a stack called a &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_stack&quot;&gt;call stack&lt;/a&gt; which stores information relevant to the current function such as a pointer to whichever function it was called from, and any local variables.  Because functions call other functions and then return, the stack grows and shrinks to hold information from the functions further down the call stack.  A program doesn't really have runtime control over it; it's determined by the programming language, OS and even the system architecture.</source>
          <target state="translated">Как уже упоминалось, куча и стек являются общими терминами и могут быть реализованы многими способами. Компьютерные программы обычно имеют стек, называемый стеком &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_stack&quot;&gt;вызовов,&lt;/a&gt; который хранит информацию, относящуюся к текущей функции, такую ​​как указатель на функцию, из которой она была вызвана, и любые локальные переменные. Поскольку функции вызывают другие функции и затем возвращаются, стек увеличивается и сжимается, чтобы хранить информацию от функций далее в стеке вызовов. Программа на самом деле не имеет контроля над ней; это определяется языком программирования, ОС и даже архитектурой системы.</target>
        </trans-unit>
        <trans-unit id="2df8df4816fd4ed74f3ebc71f597979521860d83" translate="yes" xml:space="preserve">
          <source>As the heap grows new blocks are often allocated from lower addresses towards higher addresses. Thus you can think of the heap as a &lt;em&gt;heap&lt;/em&gt; of memory blocks that grows in size as memory is allocated. If the heap is too small for an allocation the size can often be increased by acquiring more memory from the underlying operating system.</source>
          <target state="translated">По мере роста кучи новые блоки часто распределяются от более низких адресов к более высоким адресам. Таким образом, вы можете думать о куче как о &lt;em&gt;куче&lt;/em&gt; блоков памяти, которые увеличиваются в размере по мере выделения памяти. Если куча слишком мала для выделения, ее размер часто можно увеличить, получая больше памяти из базовой операционной системы.</target>
        </trans-unit>
        <trans-unit id="50556eca9ce5726de27e85d02f2175c0f224c952" translate="yes" xml:space="preserve">
          <source>As the stack is a limited block of memory, you can cause a &lt;em&gt;stack overflow&lt;/em&gt; by calling too many nested functions and/or allocating too much space for local variables. Often the memory area used for the stack is set up in such a way that writing below the bottom (the lowest address) of the stack will trigger a trap or exception in the CPU. This exceptional condition can then be caught by the runtime and converted into some kind of stack overflow exception.</source>
          <target state="translated">Поскольку стек является ограниченным блоком памяти, вы можете вызвать &lt;em&gt;переполнение стека&lt;/em&gt; , вызвав слишком много вложенных функций и / или выделив слишком много места для локальных переменных. Часто область памяти, используемая для стека, настраивается таким образом, что запись ниже дна (самый низкий адрес) стека вызовет ловушку или исключение в ЦП. Это исключительное условие может быть перехвачено средой выполнения и преобразовано в некое исключение переполнения стека.</target>
        </trans-unit>
        <trans-unit id="b215c6f533c85e53fa09d968e37f28f9d39f9d4b" translate="yes" xml:space="preserve">
          <source>At run-time, if the application needs more heap, it can allocate memory from free memory and if the stack needs memory, it can allocate memory from free memory allocated memory for the application.</source>
          <target state="translated">Во время выполнения,если приложению требуется больше кучи памяти,оно может выделить память из свободной памяти,а если стеку нужна память,то оно может выделить память из свободной памяти,выделенной для приложения.</target>
        </trans-unit>
        <trans-unit id="54b26119365b1389f21ece7a4adac459e7df78fd" translate="yes" xml:space="preserve">
          <source>Because the different threads share the heap in a multi-threaded application, this also means that there has to be some coordination between the threads so that they don&amp;rsquo;t try to access and manipulate the same piece(s) of memory in the heap at the same time.</source>
          <target state="translated">Поскольку разные потоки совместно используют кучу в многопоточном приложении, это также означает, что должна быть некоторая координация между потоками, чтобы они не пытались получить доступ и манипулировать одними и теми же частями памяти в куче в в то же время.</target>
        </trans-unit>
        <trans-unit id="ccbbb8bb2cb5a86ca4310f5e73a45cd3c134e32e" translate="yes" xml:space="preserve">
          <source>Because the stack is small, you would want to use it when you know exactly how much memory you will need for your data, or if you know the size of your data is very small.</source>
          <target state="translated">Поскольку стек маленький,вы захотите использовать его,когда точно знаете,какой объем памяти вам понадобится для ваших данных,или если вы знаете,что размер ваших данных очень мал.</target>
        </trans-unit>
        <trans-unit id="85af045b5af1615c35dbbd47456bb468389824a3" translate="yes" xml:space="preserve">
          <source>Because you've allocated the stack before launching the program, you never need to malloc before you can use the stack, so that's a slight advantage there.  In practice, it's very hard to predict what will be fast and what will be slow in modern operating systems that have virtual memory subsystems, because how the pages are implemented and where they are stored is an implementation detail.</source>
          <target state="translated">Поскольку вы выделили стек перед запуском программы,вам никогда не нужно malloc перед тем,как вы сможете использовать стек,так что это небольшое преимущество.На практике очень сложно предсказать,что будет быстрым,а что медленным в современных операционных системах с подсистемами виртуальной памяти,потому что то,как реализуются страницы и где они хранятся,является детализацией реализации.</target>
        </trans-unit>
        <trans-unit id="a1789265dfb7f69ad43a9c93ac040821d26c1139" translate="yes" xml:space="preserve">
          <source>Both the stack and the heap are memory areas allocated from the underlying operating system (often virtual memory that is mapped to physical memory on demand).</source>
          <target state="translated">Как стек,так и куча являются областями памяти,выделенными из базовой операционной системы (часто виртуальная память,которая по требованию привязывается к физической памяти).</target>
        </trans-unit>
        <trans-unit id="74ded9b65c26de9b34aafae7449e1393446d30f8" translate="yes" xml:space="preserve">
          <source>Can a function be allocated on the heap instead of a stack?</source>
          <target state="translated">Может ли функция быть распределена по куче вместо штабеля?</target>
        </trans-unit>
        <trans-unit id="5812990e8a5f0104b222e128474fb28611af16f1" translate="yes" xml:space="preserve">
          <source>Can have a stack overflow when too much of the stack is used (mostly from infinite or too deep recursion, very large allocations).</source>
          <target state="translated">Может произойти переполнение стека,когда используется слишком много стека (в основном из бесконечной или слишком глубокой рекурсии,очень большие распределения).</target>
        </trans-unit>
        <trans-unit id="965cae31b330377a8052d9fde41cc56a8629759e" translate="yes" xml:space="preserve">
          <source>Can have allocation failures if too big of a buffer is requested to be allocated.</source>
          <target state="translated">Может произойти сбой в распределении,если запрашивается выделение слишком большого буфера.</target>
        </trans-unit>
        <trans-unit id="1c8dd66e84903a898b8ce09b004e11d5dd348f81" translate="yes" xml:space="preserve">
          <source>Can have fragmentation when there are a lot of allocations and deallocations.</source>
          <target state="translated">Может иметь фрагментацию при большом количестве распределений и сделок.</target>
        </trans-unit>
        <trans-unit id="57ed76834f319ea80eb97efad57dfda743be40d9" translate="yes" xml:space="preserve">
          <source>Creating Objects on the Stack and Heap</source>
          <target state="translated">Создание Объектов на Стеке и Куче.</target>
        </trans-unit>
        <trans-unit id="3c85e89113521a7aade115de0029e8e2378f88c7" translate="yes" xml:space="preserve">
          <source>Data created on the stack can be used without pointers.</source>
          <target state="translated">Данные,созданные на стеке,могут быть использованы без указателей.</target>
        </trans-unit>
        <trans-unit id="10b6d2f5365d704078f50dcd64eef839102a1ac7" translate="yes" xml:space="preserve">
          <source>Deallocating the stack is pretty simple because you always deallocate in the reverse order in which you allocate. Stack stuff is added as you enter functions, the corresponding data is removed as you exit them. This means that you tend to stay within a small region of the stack unless you call lots of functions that call lots of other functions (or create a recursive solution).</source>
          <target state="translated">Распределение стека довольно просто,потому что вы всегда распределяете в обратном порядке,в котором вы распределяете.Стек добавляется при входе в функции,соответствующие данные удаляются при выходе из них.Это означает,что вы,как правило,остаетесь в пределах небольшого участка стека,если только не вызываете множество функций,вызывающих множество других функций (или не создаете рекурсивное решение).</target>
        </trans-unit>
        <trans-unit id="2e6efb7de0e3b1a967b575cd00a39178bc6cda79" translate="yes" xml:space="preserve">
          <source>Details can be found from &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/161053/which-is-faster-stack-allocation-or-heap-allocation&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">Подробности можно найти &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/161053/which-is-faster-stack-allocation-or-heap-allocation&quot;&gt;здесь&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3454116b814c4a540b1fa2eaa28b022a062afd97" translate="yes" xml:space="preserve">
          <source>Don't have to explicitly de-allocate variables</source>
          <target state="translated">Не нужно явно дезалоцировать переменные.</target>
        </trans-unit>
        <trans-unit id="0060cdcb4b02afd4a89a6475ecd1acc3d319f929" translate="yes" xml:space="preserve">
          <source>Due to sequential storage in stack, execution is faster. Storage in heap would have resulted in huge time consumption thus making the whole program execute slower.</source>
          <target state="translated">Благодаря последовательному хранению в стеке,выполнение происходит быстрее.Хранение в куче привело бы к огромным временным затратам,что заставило бы всю программу выполняться медленнее.</target>
        </trans-unit>
        <trans-unit id="f04d90ff7dea8c8dc11581ddfc938b88076014c3" translate="yes" xml:space="preserve">
          <source>Dynamically created variables are stored here, which later requires freeing the allocated memory after use.</source>
          <target state="translated">Здесь хранятся динамически созданные переменные,что впоследствии требует освобождения выделенной памяти после использования.</target>
        </trans-unit>
        <trans-unit id="846279cf02a7a28e2eaddba31c218b6c4f28b95f" translate="yes" xml:space="preserve">
          <source>Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation).</source>
          <target state="translated">Каждый поток получает стек,в то время как для приложения,как правило,существует только одна куча (хотя нередки случаи,когда для разных типов распределения имеется несколько кучей).</target>
        </trans-unit>
        <trans-unit id="5e929f13154e75203839bfc2de286aa0a1a47dcc" translate="yes" xml:space="preserve">
          <source>Even, more detail is given &lt;a href=&quot;http://net-informations.com/faq/net/stack-heap.htm&quot;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html&quot;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">Даже более подробно &lt;a href=&quot;http://net-informations.com/faq/net/stack-heap.htm&quot;&gt;&lt;strong&gt;здесь&lt;/strong&gt;&lt;/a&gt; и &lt;a href=&quot;http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html&quot;&gt;&lt;strong&gt;здесь&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4077dc49f1766565dde4b0c98c71c99d05d1cf12" translate="yes" xml:space="preserve">
          <source>Every time an object is instantiated, a chunk of heap memory is set aside to hold the data (state) of that object. Since objects can contain other objects, some of this data can in fact hold references to those nested objects.</source>
          <target state="translated">Каждый раз,когда объект инстанцируется,для хранения данных (состояния)этого объекта выделяется кусочек памяти кучи.Поскольку объекты могут содержать другие объекты,некоторые из этих данных могут содержать ссылки на эти вложенные объекты.</target>
        </trans-unit>
        <trans-unit id="5211deda8670661ee7d1ce34e2735da4431ad6c2" translate="yes" xml:space="preserve">
          <source>Fibers proposal to the C++ standard library is forthcoming. Also, there're some third-party &lt;a href=&quot;https://stackoverflow.com/questions/1285714/lightweight-portable-c-fibers-mit-license&quot;&gt;libraries&lt;/a&gt;. Green threads are extremely popular in languages like Python and Ruby.</source>
          <target state="translated">Предложение Fibers к стандартной библиотеке C ++ ожидается. Также есть сторонние &lt;a href=&quot;https://stackoverflow.com/questions/1285714/lightweight-portable-c-fibers-mit-license&quot;&gt;библиотеки&lt;/a&gt; . Зеленые темы чрезвычайно популярны в таких языках, как Python и Ruby.</target>
        </trans-unit>
        <trans-unit id="6bf6a0d4778960ac1e375eed1f1e9f0d010f59b1" translate="yes" xml:space="preserve">
          <source>Fibers, green threads and coroutines are in many ways similar, which leads to much confusion.  The difference between fibers and green threads is that the former use cooperative multitasking, while the latter may feature either cooperative or preemptive one (or even both). For the distinction between fibers and coroutines, see &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Волокна, зеленые нити и сопрограммы во многом похожи, что приводит к путанице. Разница между волокнами и зелеными нитями заключается в том, что первые используют кооперативную многозадачность, в то время как последние могут иметь либо кооперативную, либо вытесняющую (или даже обе). Различия между волокнами и сопрограммами см. &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf&quot;&gt;Здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d2ac197a7a104bcd6641f6a118e10124e3a8763" translate="yes" xml:space="preserve">
          <source>For people new to programming, it&amp;rsquo;s probably a good idea to use the stack since it&amp;rsquo;s easier.</source>
          <target state="translated">Для новичков в программировании, вероятно, будет хорошей идеей использовать стек, поскольку он проще.</target>
        </trans-unit>
        <trans-unit id="d9bf6ea4d7dd59b322b7679e48bc374e1b2878a5" translate="yes" xml:space="preserve">
          <source>Fragmentation occurs when memory objects are allocated with small spaces in between that are too small to hold additional memory objects.</source>
          <target state="translated">Фрагментация возникает,когда объекты памяти выделяются с небольшими промежутками между ними,которые слишком малы,чтобы вместить дополнительные объекты памяти.</target>
        </trans-unit>
        <trans-unit id="e237e4dadd747be21907ecdd643773f2cded6948" translate="yes" xml:space="preserve">
          <source>From WikiAnwser.</source>
          <target state="translated">Из WikiAnwser.</target>
        </trans-unit>
        <trans-unit id="4e3b5b95822a6480a6ed4d32a309c404a4c107f7" translate="yes" xml:space="preserve">
          <source>Function calls are loaded here along with the local variables and function parameters passed.</source>
          <target state="translated">Здесь загружаются вызовы функций вместе с переданными локальными переменными и параметрами функции.</target>
        </trans-unit>
        <trans-unit id="977169a2f56615065497cd1735f54129679d50ec" translate="yes" xml:space="preserve">
          <source>Heap</source>
          <target state="translated">Heap</target>
        </trans-unit>
        <trans-unit id="69c0fce84d3be50b555c1e7c6c0ace50232978e0" translate="yes" xml:space="preserve">
          <source>Heap allocation requires maintaining a full record of what memory is allocated and what isn't, as well as some overhead maintenance to reduce fragmentation, find contiguous memory segments big enough to fit the requested size, and so on.  Memory can be deallocated at any time leaving free space.  Sometimes a memory allocator will perform maintenance tasks such as defragmenting memory by moving allocated memory around, or garbage collecting - identifying at runtime when memory is no longer in scope and deallocating it.</source>
          <target state="translated">Распределение кучи требует ведения полного учета того,какая память выделена,а какая нет,а также некоторого накладного обслуживания,чтобы уменьшить фрагментацию,найти смежные сегменты памяти,достаточно большие,чтобы соответствовать требуемому размеру,и так далее.Память может быть перераспределена в любое время,оставляя свободное место.Иногда аллокатор памяти выполняет такие обслуживающие задачи,как дефрагментация памяти путем перемещения выделенной памяти или сбор мусора-выявление во время выполнения,когда памяти больше нет,и ее разделение.</target>
        </trans-unit>
        <trans-unit id="6df8f5905a52242ce08ad912e0566230705e916f" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a super-short summary: The stack is essentially an
  easy-to-access memory that simply manages its items as a - well -
  stack. Only items for which the size is known in advance can go onto
  the stack. This is the case for numbers, strings, booleans.</source>
          <target state="translated">Вот очень короткое резюме: стек - это, по сути, легкодоступная память, которая просто управляет своими элементами как &amp;laquo;хороший&amp;raquo; стек. В стек могут попадать только предметы, размер которых известен заранее. Это касается чисел, строк, логических значений.</target>
        </trans-unit>
        <trans-unit id="c4ad91f43c7e132c0c64e796c08f23caf41b0111" translate="yes" xml:space="preserve">
          <source>Here's how the memory is managed</source>
          <target state="translated">Вот как управляется память</target>
        </trans-unit>
        <trans-unit id="bf4cd344a404d07f4320ed2b8128bc0699d576ee" translate="yes" xml:space="preserve">
          <source>How the heap is managed is really up to the runtime environment. C uses &lt;code&gt;malloc&lt;/code&gt; and C++ uses &lt;code&gt;new&lt;/code&gt;, but many other languages have garbage collection.</source>
          <target state="translated">Как управлять кучей, действительно зависит от среды выполнения. C использует &lt;code&gt;malloc&lt;/code&gt; , а C ++ использует &lt;code&gt;new&lt;/code&gt; , но многие другие языки имеют сборку мусора.</target>
        </trans-unit>
        <trans-unit id="e6d9adabdb8c7c013e5c6cedd3fd35a30646fc45" translate="yes" xml:space="preserve">
          <source>However, it is generally better to consider &quot;&lt;strong&gt;scope&lt;/strong&gt;&quot; and &quot;&lt;strong&gt;lifetime&lt;/strong&gt;&quot; rather than &quot;stack&quot; and &quot;heap&quot;.</source>
          <target state="translated">Однако, как правило, лучше рассматривать &amp;laquo; &lt;strong&gt;область действия&lt;/strong&gt; &amp;raquo; и &amp;laquo; &lt;strong&gt;время жизни&lt;/strong&gt; &amp;raquo;, а не &amp;laquo;стек&amp;raquo; и &amp;laquo;куча&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="aed2fb7f74c3443670e7a902fd753397a138bf75" translate="yes" xml:space="preserve">
          <source>However, the stack is a more low-level feature closely tied to the processor architecture. Growing the heap when there is not enough space isn't too hard since it can be implemented in the library call that handles the heap. However, growing the stack is often impossible as the stack overflow only is discovered when it is too late; and shutting down the thread of execution is the only viable option.</source>
          <target state="translated">Однако стек является более низкоуровневой функцией,тесно связанной с архитектурой процессора.Растить кучу,когда не хватает места,не так уж и сложно,так как это может быть реализовано в вызове библиотеки,которая обрабатывает кучу.Однако выращивание стека часто оказывается невозможным,так как переполнение стека обнаруживается только тогда,когда уже слишком поздно;и закрытие потока исполнения является единственным приемлемым вариантом.</target>
        </trans-unit>
        <trans-unit id="369a9b90a4bdfde4e85ad68cde3ff685aa91dd1f" translate="yes" xml:space="preserve">
          <source>I also create the image below to show how they may look like:</source>
          <target state="translated">Я также создаю изображение ниже,чтобы показать,как они могут выглядеть:</target>
        </trans-unit>
        <trans-unit id="b6b70f6bfb4b2dfbc4a60602e806084366a63de7" translate="yes" xml:space="preserve">
          <source>I have something to share, although the major points are already covered.</source>
          <target state="translated">Мне есть чем поделиться,хотя основные моменты уже освещены.</target>
        </trans-unit>
        <trans-unit id="9c1b11110bea9796fff4f2aa43b42de19c50096d" translate="yes" xml:space="preserve">
          <source>I think many other people have given you mostly correct answers on this matter.</source>
          <target state="translated">Я думаю,что многие другие люди дали тебе в основном правильные ответы на этот вопрос.</target>
        </trans-unit>
        <trans-unit id="f84b830b40010139bb2bc50481c768d543c9849a" translate="yes" xml:space="preserve">
          <source>I will provide some simple annotated C code to illustrate all of this. The best way to learn is to run a program under a debugger and watch the behavior. If you prefer to read python, skip to the end of the answer :)</source>
          <target state="translated">Я предоставлю несколько простых аннотированных C-кодов,чтобы проиллюстрировать все это.Лучший способ научиться-это запустить программу под отладчиком и наблюдать за ее поведением.Если вы предпочитаете читать python,перейдите к концу ответа :)</target>
        </trans-unit>
        <trans-unit id="19be6ca3ce7acb355b8593c36bbe51f806cb3467" translate="yes" xml:space="preserve">
          <source>If a function has parameters, these are pushed onto the stack before the call to the function. The code in the function is then able to navigate up the stack from the current stack pointer to locate these values.</source>
          <target state="translated">Если какая-либо функция имеет параметры,они заталкиваются в стек перед вызовом функции.Затем код функции может перемещаться вверх по стеку от текущего указателя на стек,чтобы найти эти значения.</target>
        </trans-unit>
        <trans-unit id="d6fd840c486fd422511fccb949147762c4da1fa6" translate="yes" xml:space="preserve">
          <source>If functions were stored in heap (messy storage pointed by pointer), there would have been no way to return to the caller address back (which stack gives due to sequential storage in memory).</source>
          <target state="translated">Если бы функции хранились в куче (грязное хранилище,на которое указывает указатель),то не было бы возможности вернуться по адресу вызывающего абонента (который дает стек за счет последовательного хранения в памяти).</target>
        </trans-unit>
        <trans-unit id="582e735b7a23d77b1a919b1c33ed8aa128f12765" translate="yes" xml:space="preserve">
          <source>If the private heap gets too large it will overlap the stack area, as will the stack overlap the heap if it gets too big. Because the stack starts at a higher address and works its way down to lower address, with proper hacking you can get make the stack so large that it will overrun the private heap area and overlap the code area. The trick then is to overlap enough of the code area that you can hook into the code. It's a little tricky to do and you risk a program crash, but it's easy and very effective.</source>
          <target state="translated">Если личная куча станет слишком большой,то она будет перекрывать область стопки,так же как и куча будет перекрываться,если она станет слишком большой.Так как стек начинается по более высокому адресу и работает по более низкому адресу,то при правильном взломе вы можете сделать стек настолько большим,что он перекроет приватную область кучи и перекроет кодовую область.Тогда хитрость заключается в том,чтобы перекрыть достаточно области кода,к которой можно подключиться.Это немного сложно сделать,и вы рискуете аварийным завершением программы,но это легко и очень эффективно.</target>
        </trans-unit>
        <trans-unit id="8164de7b8275fe6bd6610a9f1a1f510df9d0953d" translate="yes" xml:space="preserve">
          <source>If you fail to do this, your program will have what is known as a memory leak. That is, memory on the heap will still be set aside (and won't be available to other processes). As we will see in the debugging section, there is a tool called &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt; that can help you detect memory leaks.</source>
          <target state="translated">Если вы этого не сделаете, ваша программа будет иметь то, что известно как утечка памяти. То есть память в куче все равно будет выделена (и не будет доступна другим процессам). Как мы увидим в разделе отладки, есть инструмент под названием &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind,&lt;/a&gt; который может помочь вам обнаружить утечки памяти.</target>
        </trans-unit>
        <trans-unit id="5d14809b020f6dc3b1ca1b516594f7c26711d489" translate="yes" xml:space="preserve">
          <source>Implemented with an actual stack data structure.</source>
          <target state="translated">Реализовано с фактической структурой данных стека.</target>
        </trans-unit>
        <trans-unit id="0ec9c44eba796de6b3f45bf5b3038e9e98f84fe1" translate="yes" xml:space="preserve">
          <source>In &quot;classic&quot; systems RAM was laid out such that the stack pointer started out at the bottom of memory, the heap pointer started out at the top, and they grew towards each other. If they overlap, you are out of RAM. That doesn't work with modern multi-threaded OSes though. Every thread has to have its own stack, and those can get created dynamicly.</source>
          <target state="translated">В &quot;классических&quot; системах оперативная память располагалась так,что указатель стека начинался внизу памяти,указатель кучи-сверху,и они росли друг к другу.Если они накладываются друг на друга,то оперативной памяти нет.Но с современными многопоточными операционными системами это не работает.Каждый поток должен иметь свой собственный стек,и они могут создаваться динамически.</target>
        </trans-unit>
        <trans-unit id="9595be1b961175468df336b7cd57107f6d9e6d67" translate="yes" xml:space="preserve">
          <source>In C you can get the benefit of variable length allocation through the use of &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?alloca&quot;&gt;alloca&lt;/a&gt;, which allocates on the stack, as opposed to alloc, which allocates on the heap. This memory won't survive your return statement, but it's useful for a scratch buffer.</source>
          <target state="translated">В C вы можете получить выгоду от распределения переменной длины за счет использования &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?alloca&quot;&gt;alloca&lt;/a&gt; , которая выделяется в стеке, в отличие от alloc, которая выделяется в куче. Эта память не выдержит вашего оператора return, но она полезна для чистого буфера.</target>
        </trans-unit>
        <trans-unit id="4c49c1e042066fcde12cf790d1255e5d4128c6ed" translate="yes" xml:space="preserve">
          <source>In C++ or C, data created on the heap will be pointed to by pointers and allocated with &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt; respectively.</source>
          <target state="translated">В C ++ или C данные, создаваемые в куче, будут указываться указателями и выделяться с помощью &lt;code&gt;new&lt;/code&gt; или &lt;code&gt;malloc&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="2dddb5409ddfb8bfae0332e6674cb30e4030c766" translate="yes" xml:space="preserve">
          <source>In C++, variables on the heap must be destroyed manually and never fall out of scope. The data is freed with &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;delete[]&lt;/code&gt;, or &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">В C ++ переменные в куче должны быть уничтожены вручную и никогда не выпадают из области видимости. Данные освобождаются с помощью &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;delete[]&lt;/code&gt; или &lt;code&gt;free&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ab2e606ea24062674776c9630ae58f479fc3332" translate="yes" xml:space="preserve">
          <source>In Detail</source>
          <target state="translated">Подробно</target>
        </trans-unit>
        <trans-unit id="d070ed182c0710ddbb3f2b533e23ff5a60e665ff" translate="yes" xml:space="preserve">
          <source>In Java, most objects go directly into the heap. In languages like C / C++, structs and classes can often remain on the stack when you're not dealing with pointers.</source>
          <target state="translated">На Java большинство объектов попадает прямо в кучу.В таких языках,как С++,структуры и классы часто могут оставаться на стеке,когда вы не имеете дело с указателями.</target>
        </trans-unit>
        <trans-unit id="4f383e35971605d5e60dda592302a0dfbedde224" translate="yes" xml:space="preserve">
          <source>In Short</source>
          <target state="translated">Вкратце</target>
        </trans-unit>
        <trans-unit id="5147749ca6668db2a2e89a21934367a8e767227a" translate="yes" xml:space="preserve">
          <source>In a heap, there is no particular order to the way items are placed.  You can reach in and remove items in any order because there is no clear 'top' item.</source>
          <target state="translated">В куче нет особого порядка размещения предметов.Вы можете достать и убрать элементы в любом порядке,потому что нет четкого &quot;верхнего&quot; элемента.</target>
        </trans-unit>
        <trans-unit id="c178a8267cc3e47eec2a91c3a323a8fdc32c3e39" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, each thread will have its own stack.</source>
          <target state="translated">В многопоточном приложении каждый поток будет иметь свой собственный стек.</target>
        </trans-unit>
        <trans-unit id="aea37718a1d7d897745b71fc7a069d9dac94a163" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, each thread will have its own stack. But, all the different threads will share the heap.</source>
          <target state="translated">В многопоточном приложении каждый поток будет иметь свой собственный стек.Но все разные потоки будут разделять кучу.</target>
        </trans-unit>
        <trans-unit id="bed80375d9899ce917d044e4b57acedb6c419964" translate="yes" xml:space="preserve">
          <source>In a multi-threaded environment each thread will have its own completely independent stack but they will share the heap. Concurrent access has to be controlled on the heap and is not possible on the stack.</source>
          <target state="translated">В многопоточной среде каждый поток будет иметь свой собственный полностью независимый стек,но они будут разделять кучу.Одновременный доступ должен контролироваться на куче и невозможен на стеке.</target>
        </trans-unit>
        <trans-unit id="2afdc75d76febc6978738ba0407aee2a8e1a2690" translate="yes" xml:space="preserve">
          <source>In a multi-threaded situation each thread will have its own completely independent stack, but they will share the heap. The stack is thread specific and the heap is application specific. The stack is important to consider in exception handling and thread executions.</source>
          <target state="translated">В многопоточной ситуации каждый поток будет иметь свой собственный полностью независимый стек,но они будут делить кучу.Стек является специфическим для потока,а куча-для приложения.Стек важно учитывать при обработке исключений и выполнении потоков.</target>
        </trans-unit>
        <trans-unit id="3b5a4a1f69f2a44d7b973472f440395d38db3aef" translate="yes" xml:space="preserve">
          <source>In a stack of items, items sit one on top of the other in the order they were placed there, and you can only remove the top one (without toppling the whole thing over).</source>
          <target state="translated">В стопке предметов,предметы сидят один поверх другого в том порядке,в котором они были помещены туда,и вы можете удалить только верхний (не опрокидывая всю вещь).</target>
        </trans-unit>
        <trans-unit id="6de943cc8f12c5ab1e03aa49853e2f81f883c968" translate="yes" xml:space="preserve">
          <source>In any case, the purpose of both fibers, green threads and coroutines is having multiple functions executing concurrently, but &lt;strong&gt;not&lt;/strong&gt; in parallel (see &lt;a href=&quot;https://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&quot;&gt;this SO question&lt;/a&gt; for the distinction) within a single OS-level thread, transferring control back and forth from one another in an organized fashion.</source>
          <target state="translated">В любом случае, назначение обоих волокон, зеленых нитей и сопрограмм состоит в том, чтобы несколько функций выполнялись одновременно, но &lt;strong&gt;не&lt;/strong&gt; параллельно (см. &lt;a href=&quot;https://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&quot;&gt;Этот вопрос в&lt;/a&gt; разделе SO ) в пределах одного потока уровня ОС, передавая управление вперед и назад друг от друга. организованно.</target>
        </trans-unit>
        <trans-unit id="6ff0d53ec18f38266dd0067ebeca5dc7b79c4307" translate="yes" xml:space="preserve">
          <source>In computing architectures the heap is an area of dynamically-allocated memory that is managed automatically by the operating system or the memory manager library.</source>
          <target state="translated">В вычислительных архитектурах куча-это область динамически выделяемой памяти,которая автоматически управляется операционной системой или библиотекой менеджера памяти.</target>
        </trans-unit>
        <trans-unit id="14147c40afba7195a6e743160146832b550785ac" translate="yes" xml:space="preserve">
          <source>In systems without virtual memory, such as some embedded systems, the same basic layout often applies, except the stack and heap are fixed in size. However, in other embedded systems (such as those based on Microchip PIC microcontrollers), the program stack is a separate block of memory that is not addressable by data movement instructions, and can only be modified or read indirectly through program flow instructions (call, return, etc.). Other architectures, such as Intel Itanium processors, have &lt;a href=&quot;http://blogs.msdn.com/oldnewthing/archive/2005/04/21/410397.aspx&quot;&gt;multiple stacks&lt;/a&gt;. In this sense, the stack is an element of the CPU architecture.</source>
          <target state="translated">В системах без виртуальной памяти, таких как некоторые встроенные системы, часто применяется одна и та же базовая схема, за исключением того, что размер стека и кучи фиксирован. Однако в других встроенных системах (например, основанных на микроконтроллерах PIC от Microchip) программный стек представляет собой отдельный блок памяти, который не адресуется инструкциями перемещения данных, и может быть изменен или прочитан только косвенно с помощью инструкций потока программы (вызов, возврат и т. д.). Другие архитектуры, такие как процессоры Intel Itanium, имеют &lt;a href=&quot;http://blogs.msdn.com/oldnewthing/archive/2005/04/21/410397.aspx&quot;&gt;несколько стеков&lt;/a&gt; . В этом смысле стек является элементом архитектуры ЦП.</target>
        </trans-unit>
        <trans-unit id="9aec9cb3ea820b87a5cf73897d19e91456e49aff" translate="yes" xml:space="preserve">
          <source>In the 1980s, UNIX propagated like bunnies with big companies rolling their own.
Exxon had one as did dozens of brand names lost to history.
How memory was laid out was at the discretion of the many implementors.</source>
          <target state="translated">В 1980-х годах UNIX распространялся как кролики с крупными компаниями,прокатывающими свои собственные.У Exxon был такой же,как и у десятков брендов,потерянных в истории.То,как была заложена память,оставалось на усмотрение многих исполнителей.</target>
        </trans-unit>
        <trans-unit id="33565c031152b190e31e2e646c439179d7871e3f" translate="yes" xml:space="preserve">
          <source>In the following C# code</source>
          <target state="translated">В следующем C#коде</target>
        </trans-unit>
        <trans-unit id="630247c43e13b3493c95ccf3dcf571c7304c4c8f" translate="yes" xml:space="preserve">
          <source>Is hardware, and even push/pop are very efficient.</source>
          <target state="translated">Аппаратные средства,и даже пушпопы очень эффективны.</target>
        </trans-unit>
        <trans-unit id="fbec35b1fe092a0a42603acde06323d190983ce3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s better to use the heap when you know that you will need a lot of memory for your data, or you just are not sure how much memory you will need (like with a dynamic array).</source>
          <target state="translated">Лучше использовать кучу, когда вы знаете, что вам понадобится много памяти для ваших данных, или вы просто не уверены, сколько памяти вам понадобится (например, с динамическим массивом).</target>
        </trans-unit>
        <trans-unit id="457deb90d7d9b5e518927cf1c37ce9f9c8468ecf" translate="yes" xml:space="preserve">
          <source>Java Memory Model</source>
          <target state="translated">Модель Java-памяти</target>
        </trans-unit>
        <trans-unit id="ffbbcf1f84185847b6720632d5f0dd4615871ac7" translate="yes" xml:space="preserve">
          <source>Lifetime refers to when a variable is allocated and deallocated during program execution. Usually we think of &lt;strong&gt;static allocation&lt;/strong&gt; (variable will persist through the entire duration of the program, making it useful for storing the same information across several function calls) versus &lt;strong&gt;automatic allocation&lt;/strong&gt; (variable only persists during a single call to a function, making it useful for storing information that is only used during your function and can be discarded once you are done) versus &lt;strong&gt;dynamic allocation&lt;/strong&gt; (variables whose duration is defined at runtime, instead of compile time like static or automatic).</source>
          <target state="translated">Время жизни относится к тому, когда переменная выделяется и освобождается во время выполнения программы. Обычно мы думаем о &lt;strong&gt;статическом распределении&lt;/strong&gt; (переменная будет сохраняться в течение всей продолжительности программы, что делает ее полезной для хранения одной и той же информации при нескольких вызовах функций) в сравнении с &lt;strong&gt;автоматическим распределением&lt;/strong&gt; (переменная сохраняется только во время одного вызова функции, что делает ее полезной для хранение информации, которая используется только во время вашей функции и может быть отброшена, когда вы закончите) в сравнении с &lt;strong&gt;динамическим распределением&lt;/strong&gt; (переменные, продолжительность которых определяется во время выполнения, а не во время компиляции, как статические или автоматические).</target>
        </trans-unit>
        <trans-unit id="89eb38e39ee83b4afbd53d56ba3e811dd7e4c25b" translate="yes" xml:space="preserve">
          <source>Limit on stack size (OS-dependent)</source>
          <target state="translated">Ограничение на размер стека (зависит от ОС)</target>
        </trans-unit>
        <trans-unit id="e0b77457d171049e39cb59f6d0cc6e0aa958f4d7" translate="yes" xml:space="preserve">
          <source>Local variables only</source>
          <target state="translated">Только локальные переменные</target>
        </trans-unit>
        <trans-unit id="a7063db18651eedcd045e8b41c98ba145000f990" translate="yes" xml:space="preserve">
          <source>Making a huge temporary buffer on Windows that you don't use much of is not free. This is because the compiler will generate a stack probe loop that is called every time your function is entered to make sure the stack exists (because Windows uses a single guard page at the end of your stack to detect when it needs to grow the stack. If you access memory more than one page off the end of the stack you will crash). Example:</source>
          <target state="translated">Создание огромного временного буфера в Windows,который вы не используете,не является бесплатным.Это происходит потому,что компилятор сгенерирует цикл зондирования стека,который вызывается каждый раз при входе в вашу функцию,чтобы убедиться,что стек существует (потому что Windows использует единственную страницу защиты в конце стека,чтобы определить,когда ей нужно вырастить стек.Если вы получите доступ к памяти более чем на одну страницу в конце стека,то у вас произойдет сбой).Пример:</target>
        </trans-unit>
        <trans-unit id="ca52649198f4fcd9db011db1f93bf7a0fbf8fc6f" translate="yes" xml:space="preserve">
          <source>Memory on the heap is allocated, deallocated, and resized regularly during program execution, and this can lead to a problem called fragmentation.</source>
          <target state="translated">Память на куче регулярно выделяется,перераспределяется и изменяет размер во время выполнения программы,и это может привести к проблеме,называемой фрагментацией.</target>
        </trans-unit>
        <trans-unit id="92fa2b03cecd0df74b8828996b6d8dbd49f2c6f2" translate="yes" xml:space="preserve">
          <source>More can be found &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">Больше можно найти &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management&quot;&gt;здесь&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2be48705642c1c2849cd129948c17459949f6ab7" translate="yes" xml:space="preserve">
          <source>More can be found &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_(abstract_data_type)&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">Больше можно найти &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_(abstract_data_type)&quot;&gt;здесь&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cd2086a7c7de1d63c092402cee2278afc2a9fcb4" translate="yes" xml:space="preserve">
          <source>More can be found &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">Больше можно найти &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113&quot;&gt;здесь&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ff90893ecc13cc33b31a0c7ba89530291adf207c" translate="yes" xml:space="preserve">
          <source>More can be found in &lt;a href=&quot;https://stackoverflow.com/questions/408670/stack-static-and-heap-in-c&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Больше можно найти &lt;a href=&quot;https://stackoverflow.com/questions/408670/stack-static-and-heap-in-c&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d87631c079431a997cdc54c230389a89f964ee05" translate="yes" xml:space="preserve">
          <source>More information can be found here:</source>
          <target state="translated">Дополнительную информацию можно найти здесь:</target>
        </trans-unit>
        <trans-unit id="daed2813a5860321bea40be47381eb4727e55905" translate="yes" xml:space="preserve">
          <source>Much faster to allocate in comparison to variables on the heap.</source>
          <target state="translated">Гораздо быстрее выделять по сравнению с переменными на куче.</target>
        </trans-unit>
        <trans-unit id="611a2d27ec35591a9d1a945571bf2c19006fe525" translate="yes" xml:space="preserve">
          <source>Nesting function calls work like a charm. Each new call will allocate function parameters, the return address and space for local variables and these &lt;em&gt;activation records&lt;/em&gt; can be stacked for nested calls and will unwind in the correct way when the functions return.</source>
          <target state="translated">Вызов функции вложенности работает как шарм. Каждый новый вызов будет выделять параметры функции, адрес возврата и пространство для локальных переменных, и эти &lt;em&gt;записи активации&lt;/em&gt; могут быть сложены для вложенных вызовов и будут корректно разматываться при возврате функций.</target>
        </trans-unit>
        <trans-unit id="f5f359ca9a7c1ab08f498e157e0409d9d76c46da" translate="yes" xml:space="preserve">
          <source>No guaranteed efficient use of space, memory may become fragmented over time as blocks of memory are allocated, then freed</source>
          <target state="translated">Нет гарантированного эффективного использования пространства,память может фрагментироваться с течением времени,так как блоки памяти выделяются,а затем освобождаются</target>
        </trans-unit>
        <trans-unit id="15c9ee58559d66b5b15a6a82aa330160c95db8c1" translate="yes" xml:space="preserve">
          <source>No limit on memory size</source>
          <target state="translated">Нет ограничений на объем памяти</target>
        </trans-unit>
        <trans-unit id="50b9533f7ca93c1b7165a50cb0b44b0cfb20fb35" translate="yes" xml:space="preserve">
          <source>No, activation records for functions (i.e. local or automatic variables) are allocated on the stack that is used not only to store these variables, but also to keep track of nested function calls.</source>
          <target state="translated">Нет,записи активации функций (т.е.локальных или автоматических переменных)выделяются на стеке,который используется не только для хранения этих переменных,но и для отслеживания вложенных вызовов функций.</target>
        </trans-unit>
        <trans-unit id="4ab51a7f5c3504c0459c4e33aa2f1830407e1fa5" translate="yes" xml:space="preserve">
          <source>Note that I said &quot;&lt;em&gt;usually&lt;/em&gt; have a separate stack per function&quot;. There're both &lt;em&gt;stackful&lt;/em&gt; and &lt;em&gt;stackless&lt;/em&gt; implementations of couroutines. Most notable stackful C++ implementations are &lt;a href=&quot;http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.html&quot;&gt;Boost.Coroutine&lt;/a&gt; and &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd492418.aspx&quot;&gt;Microsoft PPL&lt;/a&gt;'s &lt;code&gt;async/await&lt;/code&gt;. (However, C++'s &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4134.pdf&quot;&gt;resumable functions&lt;/a&gt; (a.k.a. &quot;&lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;&quot;), which were proposed to C++17, are likely to use stackless coroutines.)</source>
          <target state="translated">Обратите внимание, что я сказал: &amp;laquo; &lt;em&gt;обычно&lt;/em&gt; для каждой функции используется отдельный стек&amp;raquo; Существуют как &lt;em&gt;стековые, так&lt;/em&gt; и не &lt;em&gt;стековые&lt;/em&gt; реализации программ. Наиболее заметными стековыми реализациями C ++ являются &lt;a href=&quot;http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.html&quot;&gt;Boost.Coroutine&lt;/a&gt; и &lt;code&gt;async/await&lt;/code&gt; &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd492418.aspx&quot;&gt;Microsoft PPL&lt;/a&gt; . (Тем не менее, &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4134.pdf&quot;&gt;возобновляемые функции&lt;/a&gt; C ++ (также называемые &amp;laquo; &lt;code&gt;async&lt;/code&gt; и &lt;code&gt;await&lt;/code&gt; &amp;raquo;), которые были предложены для C ++ 17, могут использовать сопрограммы без стеков.)</target>
        </trans-unit>
        <trans-unit id="d2cf9d062fe2a4c663f0c8c2cedd3fc551bc3d7a" translate="yes" xml:space="preserve">
          <source>Note that putting the keyword &quot;static&quot; in the declaration above prevents var2 from having global scope. Nevertheless, the global var1 has static allocation. This is not intuitive! For this reason, I try to never use the word &quot;static&quot; when describing scope, and instead say something like &quot;file&quot; or &quot;file limited&quot; scope. However many people use the phrase &quot;static&quot; or &quot;static scope&quot; to describe a variable that can only be accessed from one code file. In the context of lifetime, &quot;static&quot; &lt;em&gt;always&lt;/em&gt; means the variable is allocated at program start and deallocated when program exits.</source>
          <target state="translated">Обратите внимание, что добавление ключевого слова &amp;laquo;static&amp;raquo; в объявлении выше предотвращает глобальную область видимости var2. Тем не менее, глобальное var1 имеет статическое размещение. Это не интуитивно понятно! По этой причине я стараюсь никогда не использовать слово &amp;laquo;статический&amp;raquo; при описании области действия, а вместо этого говорю что-то вроде &amp;laquo;файл&amp;raquo; или &amp;laquo;ограниченный файл&amp;raquo; область. Однако многие люди используют фразу &amp;laquo;статический&amp;raquo; или &amp;laquo;статическая область&amp;raquo; для описания переменной, доступ к которой возможен только из одного файла кода. В контексте времени жизни &amp;laquo;статический&amp;raquo; &lt;em&gt;всегда&lt;/em&gt; означает, что переменная выделяется при запуске программы и освобождается при выходе из программы.</target>
        </trans-unit>
        <trans-unit id="0871b21874420432475c6d4351849b35d915057f" translate="yes" xml:space="preserve">
          <source>Now come to &lt;strong&gt;your question's answers&lt;/strong&gt;.</source>
          <target state="translated">Теперь перейдите к &lt;strong&gt;ответам&lt;/strong&gt; на &lt;strong&gt;ваш вопрос&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="74c615a4a42b31624f1cc296011324866cfe8b77" translate="yes" xml:space="preserve">
          <source>Objects (which vary in size as we update them) go on the heap because we don't know at creation time how long they are going to last. In many languages the heap is garbage collected to find objects (such as the cls1 object) that no longer have any references.</source>
          <target state="translated">Объекты (которые варьируются в размерах по мере их обновления)попадают в кучу,потому что мы не знаем во время создания,как долго они прослужат.Во многих языках куча-это мусор,собранный для поиска объектов (таких как объект cls1),на которые больше нет ссылок.</target>
        </trans-unit>
        <trans-unit id="e4fe13843a3ecc800429114b92b44c8d355d6bed" translate="yes" xml:space="preserve">
          <source>On the stack you save return addresses and call &amp;rarr; push / ret &amp;rarr; pop is managed directly in hardware.</source>
          <target state="translated">В стеке вы сохраняете обратные адреса, а вызов &amp;rarr; push / ret &amp;rarr; pop управляется напрямую аппаратно.</target>
        </trans-unit>
        <trans-unit id="29a4742ef363b18a49d8dab9624425d36200ea1e" translate="yes" xml:space="preserve">
          <source>One detail that has been missed, however, is that the &quot;heap&quot; should in fact probably be called the &quot;free store&quot;.  The reason for this distinction is that the original free store was implemented with a data structure known as a &quot;binomial heap.&quot;  For that reason, allocating from early implementations of malloc()/free() was allocation from a heap.  However, in this modern day, most free stores are implemented with very elaborate data structures that are not binomial heaps.</source>
          <target state="translated">Однако одна из деталей,которая была пропущена,заключается в том,что &quot;кучу&quot; на самом деле,вероятно,следует назвать &quot;бесплатным магазином&quot;.Причина такого различия заключается в том,что изначальное свободное хранилище было реализовано со структурой данных,известной как &quot;биномиальная куча&quot;.По этой причине в ранних реализациях malloc()free()выделялась из кучи.Однако в наши дни большинство свободных хранилищ реализовано с очень сложной структурой данных,не являющейся биномиальной кучей.</target>
        </trans-unit>
        <trans-unit id="13d7afdda2ae69ca5bb8408fcc1546f3b6c11363" translate="yes" xml:space="preserve">
          <source>One typical memory block was BSS (a block of zero values)
which was accidentally not zeroed in one manufacturer's offering.
Another was DATA containing initialized values, including strings and numbers.
A third was CODE containing CRT (C runtime), main, functions, and libraries.</source>
          <target state="translated">Одним из типичных блоков памяти был BSS (блок нулевых значений),который случайно не был обнулен в предложении одного производителя.Другим был DATA,содержащий инициализированные значения,включая строки и числа.Третий-CODE,содержащий CRT (время исполнения на C),основной,функции и библиотеки.</target>
        </trans-unit>
        <trans-unit id="e3d075236948af076fad91d4bb43d9d26eb82acc" translate="yes" xml:space="preserve">
          <source>Others have answered the broad strokes pretty well, so I'll throw in a few details.</source>
          <target state="translated">Другие довольно хорошо ответили на широкие мазки,так что я вставлю несколько деталей.</target>
        </trans-unit>
        <trans-unit id="6f64e795a39ecd2c765903677e991445c7062f09" translate="yes" xml:space="preserve">
          <source>Others have directly answered your question, but when trying to understand the stack and the heap, I think it is helpful to consider the memory layout of a traditional UNIX process (without threads and &lt;code&gt;mmap()&lt;/code&gt;-based allocators). The &lt;a href=&quot;http://www.memorymanagement.org/glossary/b.html#term-brk&quot;&gt;Memory Management Glossary&lt;/a&gt; web page has a diagram of this memory layout.</source>
          <target state="translated">Другие прямо ответили на ваш вопрос, но, пытаясь понять стек и кучу, я думаю, что полезно рассмотреть структуру памяти традиционного процесса UNIX (без потоков и распределителей на основе &lt;code&gt;mmap()&lt;/code&gt; ). На веб-странице &lt;a href=&quot;http://www.memorymanagement.org/glossary/b.html#term-brk&quot;&gt;Глоссарий по управлению памятью&lt;/a&gt; приведена схема этого макета памяти.</target>
        </trans-unit>
        <trans-unit id="e33f67dded7084c7a1497e2d2409091903f39904" translate="yes" xml:space="preserve">
          <source>Programming language books explain that value types are created on the &lt;strong&gt;stack&lt;/strong&gt;, and reference types are created on the &lt;strong&gt;heap&lt;/strong&gt;, without explaining what these two things are. I haven't read a clear explanation of this.  I understand what &lt;em&gt;a stack&lt;/em&gt; is. But,</source>
          <target state="translated">Книги по языку программирования объясняют, что типы значений создаются в &lt;strong&gt;стеке&lt;/strong&gt; , а ссылочные типы создаются в &lt;strong&gt;куче&lt;/strong&gt; , без объяснения того, что представляют собой эти две вещи. Я не прочитал четкое объяснение этого. Я понимаю, что &lt;em&gt;такое стек&lt;/em&gt; . Но,</target>
        </trans-unit>
        <trans-unit id="6e6e17f4d2768e59d3304c88f5860bd92caee2a8" translate="yes" xml:space="preserve">
          <source>REF:</source>
          <target state="translated">REF:</target>
        </trans-unit>
        <trans-unit id="b5fef21aad832234d260e32f67bed2552c27b3f3" translate="yes" xml:space="preserve">
          <source>Responsible for memory leaks.</source>
          <target state="translated">Ответственный за утечку памяти.</target>
        </trans-unit>
        <trans-unit id="69bf7896b4602d80f099d7c96e91ea211768accd" translate="yes" xml:space="preserve">
          <source>Scope refers to what parts of the code can access a variable. Generally we think of &lt;strong&gt;local scope&lt;/strong&gt; (can only be accessed by the current function) versus &lt;strong&gt;global scope&lt;/strong&gt; (can be accessed anywhere) although scope can get much more complex.</source>
          <target state="translated">Область действия относится к тому, какие части кода могут обращаться к переменной. Как правило, мы думаем о &lt;strong&gt;локальной области&lt;/strong&gt; (доступ к которой может получить только текущая функция) в сравнении с &lt;strong&gt;глобальной областью действия&lt;/strong&gt; (можно получить доступ в любом месте), хотя область действия может стать намного более сложной.</target>
        </trans-unit>
        <trans-unit id="509aa940c1c036efce29c8fe0c9b4b55069f2302" translate="yes" xml:space="preserve">
          <source>Should the function calls had been stored in heap, it would had resulted in 2 messy points:</source>
          <target state="translated">Если бы вызовы функций хранились в куче,это привело бы к 2 грязным точкам:</target>
        </trans-unit>
        <trans-unit id="a2185ca86acc0c919180d9c04aad21adc109c7e3" translate="yes" xml:space="preserve">
          <source>Simply, the stack is where local variables get created. Also, every time you call a subroutine the program counter (pointer to the next machine instruction) and any important registers, and sometimes the parameters get pushed on the stack. Then any local variables inside the subroutine are pushed onto the stack (and used from there). When the subroutine finishes, that stuff all gets popped back off the stack. The PC and register data gets and put back where it was as it is popped, so your program can go on its merry way.</source>
          <target state="translated">Просто в стеке создаются локальные переменные.Также,каждый раз,когда вы вызываете подпрограммный счетчик программы (указатель на следующую машинную инструкцию)и любые важные регистры,и иногда параметры попадают в стек.Затем любые локальные переменные внутри подпрограмм выталкиваются на стек (и используются оттуда).Когда подпрограмма заканчивает работу,все это выталкивается обратно из стека.PC и регистровые данные попадают и возвращаются обратно в то место,где они были,так что ваша программа может идти своим веселым путем.</target>
        </trans-unit>
        <trans-unit id="2c86213718746adf4ed3b869ab8ebf53621c0bd5" translate="yes" xml:space="preserve">
          <source>Since some answers went nitpicking, I'm going to contribute my mite.</source>
          <target state="translated">Раз уж некоторые ответы пошли наперекосяк,я собираюсь внести свой лепёшку.</target>
        </trans-unit>
        <trans-unit id="9aeb164d237567097685b40284f2116644d171b1" translate="yes" xml:space="preserve">
          <source>Slow access comparatively to Stack.</source>
          <target state="translated">Медленный доступ по сравнению со Стеком.</target>
        </trans-unit>
        <trans-unit id="f9fa73fb582337740b2c7cd4692dfd71eaccd2bf" translate="yes" xml:space="preserve">
          <source>Slower to allocate in comparison to variables on the stack.</source>
          <target state="translated">Медленнее выделять по сравнению с переменными на стеке.</target>
        </trans-unit>
        <trans-unit id="84def04a560bda893e52388cc083ef70d321b378" translate="yes" xml:space="preserve">
          <source>So simple way: process heap is general for process and all threads inside, using for memory allocation in common case with something like &lt;strong&gt;malloc()&lt;/strong&gt;.</source>
          <target state="translated">Таким простым способом: куча процесса является общей для процесса и всех потоков внутри, используя для распределения памяти в общем случае что-то вроде &lt;strong&gt;malloc ()&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4d6256f41ed90ef56893f4c0e80ba67b5f4b8734" translate="yes" xml:space="preserve">
          <source>So there is always an index to point the specific item, also processing gonna be faster, there is relationship between the items as well!...</source>
          <target state="translated">Так что всегда есть указатель на конкретный пункт,также обработка будет быстрее,есть связь между пунктами также!....</target>
        </trans-unit>
        <trans-unit id="26e4934add44c2df343844921794ed5d56eccfd7" translate="yes" xml:space="preserve">
          <source>Some of the syntax choices in C/C++ exacerbate this problem - for instance many people think global variables are not &quot;static&quot; because of the syntax shown below.</source>
          <target state="translated">Некоторые варианты синтаксиса в CC++усугубляют эту проблему-например,многие люди считают,что глобальные переменные не являются &quot;статическими&quot; из-за синтаксиса,показанного ниже.</target>
        </trans-unit>
        <trans-unit id="95320488ab41410560b78b52dfa9e017b243c84d" translate="yes" xml:space="preserve">
          <source>Some people think of these concepts as C/C++ specific. They are not. For instance, the Python sample below illustrates all three types of allocation (there are some subtle differences possible in interpreted languages that I won't get into here).</source>
          <target state="translated">Некоторые люди считают эти понятия специфическими для CC++.Это не так.Например,приведенный ниже пример с Python иллюстрирует все три типа выделения (в интерпретируемых языках возможны некоторые тонкие различия,на которые я здесь не пойду).</target>
        </trans-unit>
        <trans-unit id="8b51efe6289458012b6c8f1356975a43aa34abc0" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://academind.com/learn/javascript/reference-vs-primitive-values/&quot;&gt;Academind&lt;/a&gt;</source>
          <target state="translated">Источник: &lt;a href=&quot;https://academind.com/learn/javascript/reference-vs-primitive-values/&quot;&gt;Академинд&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9c53060f090e60a073e898da17d700ab9341170" translate="yes" xml:space="preserve">
          <source>Space is freed automatically when program goes out of a scope.</source>
          <target state="translated">Пространство освобождается автоматически,когда программа выходит из-под контроля.</target>
        </trans-unit>
        <trans-unit id="a04e6278e75e6c001c297db6eeaca0f21b4f1cf9" translate="yes" xml:space="preserve">
          <source>Space is managed efficiently by CPU, memory will not become fragmented</source>
          <target state="translated">Пространство эффективно управляется процессором,память не фрагментируется.</target>
        </trans-unit>
        <trans-unit id="83e5a0d3d2ef19df258412a4d3ef3f9533b0c0c1" translate="yes" xml:space="preserve">
          <source>Stack</source>
          <target state="translated">Stack</target>
        </trans-unit>
        <trans-unit id="2a1e3b0bbb1f0808e4252a6f745c19b958ac4d85" translate="yes" xml:space="preserve">
          <source>Stack allocation is much faster since all it really does is move the stack pointer. Using memory pools, you can get comparable performance out of heap allocation, but that comes with a slight added complexity and its own headaches.</source>
          <target state="translated">Распределение стека происходит гораздо быстрее,так как все,что он действительно делает,это перемещает указатель стека.Используя пулы памяти,вы можете получить сравнимую производительность из кучи распределения,но это приходит с небольшой дополнительной сложностью и собственной головной болью.</target>
        </trans-unit>
        <trans-unit id="990b9b0ae5cb9ef33f5882c479501ea9ec73fc18" translate="yes" xml:space="preserve">
          <source>Stack and heap need not be singular. A common situation in which you have more than one stack is if you have more than one thread in a process.  In this case each thread has its own stack. You can also have more than one heap, for example some DLL configurations can result in different DLLs allocating from different heaps, which is why it's generally a bad idea to release memory allocated by a different library.</source>
          <target state="translated">Стек и куча не должны быть единичными.Обычная ситуация,в которой у вас более одного стека,это если у вас более одного потока в процессе.В этом случае каждая нить имеет свой собственный стек.Вы также можете иметь более одной кучи,например,некоторые конфигурации DLL могут привести к тому,что различные DLL будут выделяться из разных кучи,поэтому обычно плохая идея освобождать память,выделяемую другой библиотекой.</target>
        </trans-unit>
        <trans-unit id="12fa9cb21a886762f171950816a55e2e59c869da" translate="yes" xml:space="preserve">
          <source>Stack is quick memory for store in common case function return pointers and variables, processed as parameters in function call, local function variables.</source>
          <target state="translated">Стек-это быстрая память для хранения в общем случае указателей и переменных,возвращаемых функцией,обрабатываемых в качестве параметров при вызове функции,переменных локальной функции.</target>
        </trans-unit>
        <trans-unit id="e3f92779f11d4b0f3467f92a53682253210952a8" translate="yes" xml:space="preserve">
          <source>Stack usage is faster as:</source>
          <target state="translated">Использование стека так же быстро,как и:</target>
        </trans-unit>
        <trans-unit id="24de6d4cf48238082c51e345becf26e29ec1d2b0" translate="yes" xml:space="preserve">
          <source>Stacks in computing architectures are regions of memory where data is added or removed in a last-in-first-out manner.</source>
          <target state="translated">Стеки в вычислительных архитектурах-это области памяти,в которые данные добавляются или удаляются последним способом.</target>
        </trans-unit>
        <trans-unit id="22877b6a12ccde62a270b7ab1193154412bb82ab" translate="yes" xml:space="preserve">
          <source>Stored in RAM.</source>
          <target state="translated">Хранится в оперативной памяти.</target>
        </trans-unit>
        <trans-unit id="dc53b0aeba09646ffe4c0adfb1d92487fe376514" translate="yes" xml:space="preserve">
          <source>Stored in computer RAM just like the heap.</source>
          <target state="translated">Хранится в компьютерной оперативной памяти,как и куча.</target>
        </trans-unit>
        <trans-unit id="5ba923ec538ab00b7c8b1596311059a6d8275c93" translate="yes" xml:space="preserve">
          <source>Stored in computer RAM just like the stack.</source>
          <target state="translated">Хранится в компьютерной оперативной памяти,как и в стеке.</target>
        </trans-unit>
        <trans-unit id="4cff577d64e66b1b435d415f1b04c55974ebb6a6" translate="yes" xml:space="preserve">
          <source>Stored in sequential memory.</source>
          <target state="translated">Хранится в последовательной памяти.</target>
        </trans-unit>
        <trans-unit id="8df107699395056ea16ab53263372585c3596bba" translate="yes" xml:space="preserve">
          <source>Stored wherever memory allocation is done, accessed by pointer always.</source>
          <target state="translated">Хранится везде,где производится выделение памяти,всегда доступен по указателю.</target>
        </trans-unit>
        <trans-unit id="89a636351088b12243704905bf43a965507d4b10" translate="yes" xml:space="preserve">
          <source>Stores local data, return addresses, used for parameter passing.</source>
          <target state="translated">Хранит локальные данные,адреса возврата,используемые для передачи параметров.</target>
        </trans-unit>
        <trans-unit id="dbf8af31722360d4cd5768e22244d5f8a401c59d" translate="yes" xml:space="preserve">
          <source>Surprisingly, no one has mentioned that multiple (i.e. not related to the number of running OS-level threads) call stacks are to be found not only in exotic languages (PostScript) or platforms (Intel Itanium), but also in &lt;a href=&quot;http://en.wikipedia.org/wiki/Fiber_(computer_science)&quot;&gt;&lt;em&gt;fibers&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Green_threads&quot;&gt;&lt;em&gt;green threads&lt;/em&gt;&lt;/a&gt; and some implementations of &lt;a href=&quot;http://en.wikipedia.org/wiki/Coroutine&quot;&gt;&lt;em&gt;coroutines&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Удивительно, но никто не упомянул, что несколько (то есть не связанных с количеством запущенных потоков на уровне ОС) стеков вызовов можно найти не только в экзотических языках (PostScript) или платформах (Intel Itanium), но также в &lt;a href=&quot;http://en.wikipedia.org/wiki/Fiber_(computer_science)&quot;&gt;&lt;em&gt;волокнах&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Green_threads&quot;&gt;&lt;em&gt;зеленых потоках.&lt;/em&gt;&lt;/a&gt; и некоторые реализации &lt;a href=&quot;http://en.wikipedia.org/wiki/Coroutine&quot;&gt;&lt;em&gt;сопрограмм&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="918fc88eb49d9688ce62b0cb92ecf74e2130215f" translate="yes" xml:space="preserve">
          <source>That said, stack-based memory errors are some of the worst I've experienced.  If you use heap memory, and you overstep the bounds of your allocated block, you have a decent chance of triggering a segment fault.  (Not 100%: your block may be incidentally contiguous with another that you have previously allocated.)  But since variables created on the stack are always contiguous with each other, writing out of bounds can change the value of another variable.  I have learned that whenever I feel that my program has stopped obeying the laws of logic, it is probably buffer overflow.</source>
          <target state="translated">Тем не менее,ошибки памяти на основе стека-одни из самых худших,которые я испытывал.Если вы используете кучу памяти и переходите границы выделенного блока,у вас есть неплохой шанс спровоцировать ошибку сегмента.(Не на 100%:ваш блок может случайно сопрягаться с другим,который вы ранее выделили).Но так как переменные,созданные на стеке,всегда соприкасаются друг с другом,то запись вне границ может изменить значение другой переменной.Я узнал,что всякий раз,когда я чувствую,что моя программа перестала подчиняться законам логики,это,скорее всего,переполнение буфера.</target>
        </trans-unit>
        <trans-unit id="77e50870e9d92e46d032efa6ebe4c3cc162d7aa6" translate="yes" xml:space="preserve">
          <source>The CPU has special instructions for &lt;em&gt;pushing&lt;/em&gt; values onto the stack and &lt;em&gt;popping&lt;/em&gt; them back from the stack. Each &lt;em&gt;push&lt;/em&gt; stores the value at the current location of the stack pointer and decreases the stack pointer.  A &lt;em&gt;pop&lt;/em&gt; retrieves the value pointed to by the stack pointer and then increases the stack pointer (don't be confused by the fact that &lt;em&gt;adding&lt;/em&gt; a value to the stack &lt;em&gt;decreases&lt;/em&gt; the stack pointer and &lt;em&gt;removing&lt;/em&gt; a value &lt;em&gt;increases&lt;/em&gt; it. Remember that the stack grows to the bottom). The values stored and retrieved are the values of the CPU registers.</source>
          <target state="translated">У процессора есть специальные инструкции для помещения значений в стек и возврата их из стека. Каждое &lt;em&gt;нажатие&lt;/em&gt; сохраняет значение в текущем местоположении указателя стека и уменьшает указатель стека. &lt;em&gt;Pop&lt;/em&gt; извлекает значение, на которое указывает указатель стека, а затем увеличивает указатель стека (не смущайтесь тем фактом, что &lt;em&gt;добавление&lt;/em&gt; значения в стек &lt;em&gt;уменьшает&lt;/em&gt; указатель стека, а &lt;em&gt;удаление&lt;/em&gt; значения &lt;em&gt;увеличивает&lt;/em&gt; его. Помните, что стек увеличивается до дно). Сохраненные и извлеченные значения являются значениями регистров ЦП.</target>
        </trans-unit>
        <trans-unit id="acf431b632d416223fea9a3ceddf5add4bc0a95f" translate="yes" xml:space="preserve">
          <source>The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application.</source>
          <target state="translated">При создании потока операционная система выделяет стек для каждого потока системного уровня.Обычно операционная система вызывается языком исполнения для выделения кучи для приложения.</target>
        </trans-unit>
        <trans-unit id="38a855cabffd8eca3496aa5a7a4076cf2ab0ee27" translate="yes" xml:space="preserve">
          <source>The advantage of using the stack to store variables, is that memory is managed for you. You don't have to allocate memory by hand, or free it once you don't need it any more. What's more, because the CPU organizes stack memory so efficiently, reading from and writing to stack variables is very fast.</source>
          <target state="translated">Преимущество использования стека для хранения переменных заключается в том,что память управляется за вас.Вам не нужно выделять память вручную или освобождать ее,если она вам больше не нужна.Более того,поскольку процессор так эффективно организует стековую память,чтение из нее и запись в стек переменных происходит очень быстро.</target>
        </trans-unit>
        <trans-unit id="8a9b474ea07882c9a3be36b7edcb52f7b0126430" translate="yes" xml:space="preserve">
          <source>The advent of virtual memory in UNIX changes many of the constraints.
There is no objective reason why these blocks need be contiguous,
or fixed in size, or ordered a particular way now.
Of course, before UNIX was Multics which didn't suffer from these constraints.
Here is a schematic showing one of the memory layouts of that era.</source>
          <target state="translated">Появление виртуальной памяти в UNIX меняет многие ограничения.Нет объективных причин,по которым эти блоки должны быть смежными,или фиксированными по размеру,или упорядоченными определенным образом сейчас.Конечно,до появления UNIX было многофункциональное устройство,которое не страдало от этих ограничений.Вот схема,показывающая один из макетов памяти той эпохи.</target>
        </trans-unit>
        <trans-unit id="ff4d4ca937c7d0d51d422534fe1735405013c379" translate="yes" xml:space="preserve">
          <source>The answer to your question is implementation specific and may vary across compilers and processor architectures. However, here is a simplified explanation.</source>
          <target state="translated">Ответ на ваш вопрос специфичен для реализации и может отличаться в разных компиляторах и архитектурах процессоров.Однако,вот упрощенное объяснение.</target>
        </trans-unit>
        <trans-unit id="020c36cef487c3028c3b0a5e48330117297c3aa9" translate="yes" xml:space="preserve">
          <source>The call stack is such a low level concept that it doesn't relate to 'scope' in the sense of programming.  If you disassemble some code you'll see relative pointer style references to portions of the stack, but as far as a higher level language is concerned, the language imposes its own rules of scope.  One important aspect of a stack, however, is that once a function returns, anything local to that function is immediately freed from the stack.  That works the way you'd expect it to work given how your programming languages work.  In a heap, it's also difficult to define.  The scope is whatever is exposed by the OS, but your programming language probably adds its rules about what a &quot;scope&quot; is in your application.  The processor architecture and the OS use virtual addressing, which the processor translates to physical addresses and there are page faults, etc.  They keep track of what pages belong to which applications.  You never really need to worry about this, though, because you just use whatever method your programming language uses to allocate and free memory, and check for errors (if the allocation/freeing fails for any reason).</source>
          <target state="translated">Стек вызовов является настолько низкоуровневой концепцией,что не имеет отношения к &quot;scope&quot; в смысле программирования.Если разобрать какой-нибудь код,то можно увидеть относительные ссылки в стиле указателей на части стека,но что касается языка более высокого уровня,то язык навязывает свои собственные правила области видимости.Однако,одним из важных аспектов стека является то,что после возвращения функции,все,что локально для этой функции,немедленно освобождается от стека.Это работает так,как вы ожидаете,учитывая то,как работают ваши языки программирования.В куче,это также трудно определить.Область действия-это то,что раскрывается операционной системой,но ваш язык программирования,вероятно,добавляет свои правила о том,что такое &quot;область действия&quot; в вашем приложении.Архитектура процессора и операционная система используют виртуальную адресацию,которую процессор переводит на физические адреса,есть ошибки в страницах и т.д.Они отслеживают,какие страницы относятся к каким приложениям.Но вам никогда не нужно беспокоиться об этом,потому что вы просто используете любой метод,используемый вашим языком программирования для выделения и освобождения памяти,и проверяете,нет ли ошибок (если по какой-то причине не удается освободить выделенную память).</target>
        </trans-unit>
        <trans-unit id="71984997f1c1e6f1262af07953881c1b0a8417ca" translate="yes" xml:space="preserve">
          <source>The difference between stack and heap memory allocation &amp;laquo;  timmurphy.org</source>
          <target state="translated">Разница между выделением стека и кучи памяти &amp;laquo;timmurphy.org</target>
        </trans-unit>
        <trans-unit id="7a5590373ff6649f9475365f1f774384f831b25c" translate="yes" xml:space="preserve">
          <source>The heap</source>
          <target state="translated">Куча</target>
        </trans-unit>
        <trans-unit id="64692d2958abffc9963293d7cc83b6289b346bca" translate="yes" xml:space="preserve">
          <source>The heap contains a linked list of used and free blocks. New allocations on the heap (by &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt;) are satisfied by creating a suitable block from one of the free blocks. This requires updating list of blocks on the heap. This &lt;em&gt;meta information&lt;/em&gt; about the blocks on the heap is also stored on the heap often in a small area just in front of every block.</source>
          <target state="translated">Куча содержит связанный список используемых и свободных блоков. Новые выделения в куче ( &lt;code&gt;new&lt;/code&gt; или &lt;code&gt;malloc&lt;/code&gt; ) выполняются путем создания подходящего блока из одного из свободных блоков. Это требует обновления списка блоков в куче. Эта &lt;em&gt;метаинформация&lt;/em&gt; о блоках в куче также хранится в куче, часто в небольшой области перед каждым блоком.</target>
        </trans-unit>
        <trans-unit id="e88ae6b7603411c417abd661b3310c2adee1f47c" translate="yes" xml:space="preserve">
          <source>The heap is a memory for items of which you can&amp;rsquo;t pre-determine the
  exact size and structure. Since objects and arrays can be mutated and
  change at runtime, they have to go into the heap therefore.</source>
          <target state="translated">Куча - это память для предметов, из которых нельзя заранее определить точный размер и структуру. Поскольку объекты и массивы могут быть видоизменены и изменяться во время выполнения, они должны попадать в кучу.</target>
        </trans-unit>
        <trans-unit id="4ca28207330bff52b70007af68c711c32e17159a" translate="yes" xml:space="preserve">
          <source>The heap is a portion of memory that is given to an application by the operating system, typically through a syscall like malloc.  On modern OSes this memory is a set of pages that only the calling process has access to.</source>
          <target state="translated">Куча-это часть памяти,отдаваемой операционной системой приложению,обычно через системный вызов вроде malloc.На современных операционных системах эта память представляет собой набор страниц,к которым имеет доступ только вызывающий процесс.</target>
        </trans-unit>
        <trans-unit id="71f619e3570fe3e7aac533a912d787b19b6db9a4" translate="yes" xml:space="preserve">
          <source>The heap is a region of your computer's memory that is not managed automatically for you, and is not as tightly managed by the CPU. It is a more free-floating region of memory (and is larger). To allocate memory on the heap, you must use malloc() or calloc(), which are built-in C functions. Once you have allocated memory on the heap, you are responsible for using free() to deallocate that memory once you don't need it any more.</source>
          <target state="translated">Куча-это область памяти вашего компьютера,которая не управляется автоматически для вас и не так плотно управляется процессором.Это более свободно плавающая область памяти (и больше).Для выделения памяти на куче необходимо использовать функции malloc()или calloc(),которые являются встроенными функциями на языке Си.После того,как Вы выделили память на куче,Вы отвечаете за использование функции free()для разбора этой памяти,когда она Вам больше не нужна.</target>
        </trans-unit>
        <trans-unit id="7be7d8e45896d63bdae0ae933b6b0e1b8111b33b" translate="yes" xml:space="preserve">
          <source>The heap is memory set aside for dynamic allocation.  Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time.  This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns.</source>
          <target state="translated">Куча-это память,отведенная для динамического распределения.В отличие от стека,нет принудительного шаблона для выделения и раздачи блоков из кучи;вы можете выделить блок в любое время и освободить его в любое время.Это значительно усложняет отслеживание того,какие части кучи выделяются или освобождаются в любой момент времени;существует множество настраиваемых аллокаторов кучи,которые могут настраивать производительность кучи для различных шаблонов использования.</target>
        </trans-unit>
        <trans-unit id="408b6a604741833882cb371639a20f7a50001b81" translate="yes" xml:space="preserve">
          <source>The heap is simply the memory used by programs to store variables.
Element of the heap (variables) have no dependencies with each other and can always be accessed randomly at any time.</source>
          <target state="translated">Куча-это просто память,используемая программами для хранения переменных.Элемент кучи (переменные)не имеет зависимостей друг от друга и всегда может быть доступен случайным образом в любое время.</target>
        </trans-unit>
        <trans-unit id="18cf12075777cee089f775e186e6f7b937d612e6" translate="yes" xml:space="preserve">
          <source>The heap is the area of memory dynamic memory allocations are made out of (explicit &quot;new&quot; or &quot;allocate&quot; calls). It is a special data structure that can keep track of blocks of memory of varying sizes and their allocation status.</source>
          <target state="translated">Куча-это область,из которой производится выделение динамической памяти (явные &quot;новые&quot; или &quot;выделенные&quot; вызовы).Это специальная структура данных,которая может отслеживать блоки памяти различного размера и состояние их выделения.</target>
        </trans-unit>
        <trans-unit id="3aabde1f5818e4761b37f38a6704fc125ea9920e" translate="yes" xml:space="preserve">
          <source>The most important point is that heap and stack are generic terms for ways in which memory can be allocated.  They can be implemented in many different ways, and the terms apply to the basic concepts.</source>
          <target state="translated">Наиболее важным моментом является то,что куча и стек являются общими терминами для способов выделения памяти.Они могут быть реализованы различными способами,и термины применимы к основным понятиям.</target>
        </trans-unit>
        <trans-unit id="bda899c3bb77eaf54a1599448a403c98162d7221" translate="yes" xml:space="preserve">
          <source>The net result is a percentage of the heap space that is not usable for further memory allocations.</source>
          <target state="translated">Чистый результат представляет собой процент от объема кучи памяти,который не может быть использован для дальнейшего выделения памяти.</target>
        </trans-unit>
        <trans-unit id="9db69de7d5cb25cb1dab28c5edef62348d01cbca" translate="yes" xml:space="preserve">
          <source>The private heap begins on a 16-byte boundary (for 64-bit programs) or a 8-byte boundary (for 32-bit programs) after the last byte of code in your program, and then increases in value from there. It is also called the default heap.</source>
          <target state="translated">Приватная куча начинается на границе 16 байт (для 64-битных программ)или 8 байт (для 32-битных программ)после последнего байта кода в вашей программе,а затем увеличивается в значении оттуда.Это также называется &quot;куча по умолчанию&quot;.</target>
        </trans-unit>
        <trans-unit id="c92a151a963f47b45a4e38472c1ddbfa83a05978" translate="yes" xml:space="preserve">
          <source>The public heap resides in it's own memory space outside of your program image space. It is this memory that will be siphoned off onto the hard disk if memory resources get scarce.</source>
          <target state="translated">Общественная куча хранится в собственном пространстве памяти вне пространства образов вашей программы.Именно эта память будет выкачиваться на жесткий диск,если ресурсов памяти станет недостаточно.</target>
        </trans-unit>
        <trans-unit id="c2c0a23048e8df047bdd90c519e230882a5ebc7e" translate="yes" xml:space="preserve">
          <source>The simplicity of a stack is that you do not need to maintain a table containing a record of each section of allocated memory; the only state information you need is a single pointer to the end of the stack.  To allocate and de-allocate, you just increment and decrement that single pointer.  Note: a stack can sometimes be implemented to start at the top of a section of memory and extend downwards rather than growing upwards.</source>
          <target state="translated">Простота стека заключается в том,что вам не нужно вести таблицу,содержащую запись каждой секции выделенной памяти;единственная информация о состоянии,которая вам нужна,это один указатель на конец стека.Для выделения и деаллокации вы просто увеличиваете и уменьшаете этот единственный указатель.Замечание:иногда стек может быть реализован так,чтобы начинаться сверху секции памяти и расширяться вниз,а не расти вверх.</target>
        </trans-unit>
        <trans-unit id="0a5a7df2173b3956056001d4db19a49a57a3b1c3" translate="yes" xml:space="preserve">
          <source>The single STACK was typically an area below HEAP which was a tract of memory
containing nothing of value until the top of the next fixed block of memory.
This next block was often CODE which could be overwritten by stack data
in one of the famous hacks of its era.</source>
          <target state="translated">Одиночный STACK,как правило,представлял собой область ниже HEAP,которая представляла собой участок памяти,не содержащий ничего ценного до вершины следующего фиксированного блока памяти.Следующим блоком часто был CODE,который можно было перезаписать стековыми данными в одном из известных хакеров своей эпохи.</target>
        </trans-unit>
        <trans-unit id="011fc8ced4b02d6e5bbcdaf8c062421d1082656a" translate="yes" xml:space="preserve">
          <source>The size of the stack and the private heap are determined by your compiler runtime options. The public heap is initialized at runtime using a size parameter.</source>
          <target state="translated">Размер стека и приватной кучи определяются опциями времени выполнения компилятора.Публичная куча инициализируется во время выполнения компилятора с помощью параметра размера.</target>
        </trans-unit>
        <trans-unit id="beb914534381f099cbd641ab522253e8764a0c7c" translate="yes" xml:space="preserve">
          <source>The size of the stack is determined at runtime, and generally does not grow after the program launches.  In a C program, the stack needs to be large enough to hold every variable declared within each function.  The heap will grow dynamically as needed, but the OS is ultimately making the call (it will often grow the heap by more than the value requested by malloc, so that at least some future mallocs won't need to go back to the kernel to get more memory.  This behavior is often customizable)</source>
          <target state="translated">Размер стека определяется во время выполнения программы и,как правило,не увеличивается после ее запуска.В программе на языке Си стек должен быть достаточно большим,чтобы вместить каждую переменную,объявленную внутри каждой функции.Куча будет расти динамически по мере необходимости,но в конце концов,операционная система сделает вызов (она часто будет увеличивать кучу больше,чем запрошено malloc,так что,по крайней мере,некоторым будущим злоумышленникам не придется возвращаться в кернел,чтобы получить больше памяти.Такое поведение часто настраивается)</target>
        </trans-unit>
        <trans-unit id="16b7e0f64c42733b20a4e51a341eddcfa754d823" translate="yes" xml:space="preserve">
          <source>The size of the stack is set by &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_system&quot;&gt;OS&lt;/a&gt; when a thread is created. The size of the heap is set on application startup, but it can grow as space is needed (the allocator requests more memory from the operating system).</source>
          <target state="translated">Размер стека устанавливается &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_system&quot;&gt;ОС&lt;/a&gt; при создании потока. Размер кучи устанавливается при запуске приложения, но может увеличиваться по мере необходимости в пространстве (распределитель запрашивает больше памяти у операционной системы).</target>
        </trans-unit>
        <trans-unit id="5cc1aba664ea781e5f0b096e032491b096dd802e" translate="yes" xml:space="preserve">
          <source>The size of the stack is set when a thread is created.  The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).</source>
          <target state="translated">Размер стека устанавливается при создании потока.Размер кучи устанавливается при запуске приложения,но может увеличиваться по мере необходимости (аллокатор запрашивает у операционной системы больше памяти).</target>
        </trans-unit>
        <trans-unit id="864abb86138112e4b6d575123f37974ac0c3d5c5" translate="yes" xml:space="preserve">
          <source>The stack</source>
          <target state="translated">Штабель</target>
        </trans-unit>
        <trans-unit id="901c2c85d8f6f1f4b65665c0438d9a9ae1aeb6f6" translate="yes" xml:space="preserve">
          <source>The stack and heap are traditionally located at opposite ends of the process's virtual address space. The stack grows automatically when accessed, up to a size set by the kernel (which can be adjusted with &lt;code&gt;setrlimit(RLIMIT_STACK, ...)&lt;/code&gt;). The heap grows when the memory allocator invokes the &lt;code&gt;brk()&lt;/code&gt; or &lt;code&gt;sbrk()&lt;/code&gt; system call, mapping more pages of physical memory into the process's virtual address space.</source>
          <target state="translated">Стек и куча традиционно расположены на противоположных концах виртуального адресного пространства процесса. При обращении к стеку размер автоматически увеличивается до размера, установленного ядром (который можно настроить с помощью &lt;code&gt;setrlimit(RLIMIT_STACK, ...)&lt;/code&gt; ). Куча увеличивается, когда распределитель памяти вызывает системный вызов &lt;code&gt;brk()&lt;/code&gt; или &lt;code&gt;sbrk()&lt;/code&gt; , отображая больше страниц физической памяти в виртуальное адресное пространство процесса.</target>
        </trans-unit>
        <trans-unit id="5a39a45e4339d966ed8ccdb706ae6cfcecd17231" translate="yes" xml:space="preserve">
          <source>The stack is a &quot;LIFO&quot; (last in, first out) data structure, that is managed and optimized by the CPU quite closely. Every time a function declares a new variable, it is &quot;pushed&quot; onto the stack. Then every time a function exits, all of the variables pushed onto the stack by that function, are freed (that is to say, they are deleted). Once a stack variable is freed, that region of memory becomes available for other stack variables.</source>
          <target state="translated">Стек представляет собой структуру данных &quot;LIFO&quot; (последняя в списке,первая в списке),которая достаточно тесно управляется и оптимизируется процессором.Каждый раз,когда функция объявляет новую переменную,она &quot;выталкивается&quot; на стек.Затем при каждом выходе из функции все переменные,вытесненные этой функцией на стек,освобождаются (то есть удаляются).Как только переменная стека освобождается,эта область памяти становится доступной для других переменных стека.</target>
        </trans-unit>
        <trans-unit id="ed0cdd27974e8f28be5b49910ffd382fca3bd094" translate="yes" xml:space="preserve">
          <source>The stack is a portion of memory that can be manipulated via several key assembly language instructions, such as 'pop' (remove and return a value from the stack) and 'push' (push a value to the stack), but also call (call a subroutine - this pushes the address to return to the stack) and return (return from a subroutine - this pops the address off of the stack and jumps to it).  It's the region of memory below the stack pointer register, which can be set as needed.  The stack is also used for passing arguments to subroutines, and also for preserving the values in registers before calling subroutines.</source>
          <target state="translated">Стек-это часть памяти,которой можно управлять с помощью нескольких инструкций языка ассемблера ключей,таких как 'pop' (удаление и возврат значения из стека)и 'push' (перемещение значения в стек),а также call (вызов подпрограмм-это выталкивает адрес для возврата в стек)и return (возврат из подпрограмм-это выталкивает адрес из стека и перескакивает на него).Это область памяти под регистром указателя на стек,которая может быть установлена по необходимости.Стек также используется для передачи аргументов в подпрограммы,а также для сохранения значений в регистрах перед вызовом подпрограмм.</target>
        </trans-unit>
        <trans-unit id="8fed4d46c5dcc66fd775586df82611b6cbc4131a" translate="yes" xml:space="preserve">
          <source>The stack is attached to a thread, so when the thread exits the stack is reclaimed.  The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits.</source>
          <target state="translated">Штабель крепится к резьбе,поэтому,когда резьба выходит из штабеля,штабель восстанавливается.Как правило,куча выделяется при запуске приложения по времени выполнения и восстанавливается при выходе приложения (технически процесса).</target>
        </trans-unit>
        <trans-unit id="d7d4617ad45d9667a26837a2ef9396a88ed54845" translate="yes" xml:space="preserve">
          <source>The stack is controlled by the programmer, the private heap is managed by the OS, and the public heap is not controlled by anyone because it is an OS service -- you make requests and either they are granted or denied.</source>
          <target state="translated">Стек контролируется программистом,частная куча управляется операционной системой,а общественная куча не контролируется кем-либо,потому что это сервис операционной системы-вы делаете запросы,и либо они удовлетворяются,либо им отказывают.</target>
        </trans-unit>
        <trans-unit id="776e06a491d0e5871f9e300942fd84b17a6ca19c" translate="yes" xml:space="preserve">
          <source>The stack is faster because all free memory is always contiguous.  No list needs to be maintained of all the segments of free memory, just a single pointer to the current top of the stack.  Compilers usually store this pointer in a special, fast &lt;a href=&quot;http://en.wikipedia.org/wiki/Stack_register&quot;&gt;register&lt;/a&gt; for this purpose.  What's more, subsequent operations on a stack are usually concentrated within very nearby areas of memory, which at a very low level is good for optimization by the processor on-die caches.</source>
          <target state="translated">Стек быстрее, потому что вся свободная память всегда смежна. Не нужно поддерживать список всех сегментов свободной памяти, только один указатель на текущую вершину стека. Для этой цели компиляторы обычно хранят этот указатель в специальном быстром &lt;a href=&quot;http://en.wikipedia.org/wiki/Stack_register&quot;&gt;регистре&lt;/a&gt; . Более того, последующие операции над стеком обычно сосредоточены в очень близких областях памяти, что на очень низком уровне хорошо для оптимизации кэш-памятью процессора.</target>
        </trans-unit>
        <trans-unit id="e94a30b9ac14f61035ae0f43d2216250500958c2" translate="yes" xml:space="preserve">
          <source>The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or deallocation.  Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be - typically - synchronized with &quot;all&quot; other heap accesses in the program.</source>
          <target state="translated">Стек быстрее,потому что шаблон доступа делает тривиальным выделение и разделение памяти из него (указатель просто увеличивается или уменьшается),в то время как куча имеет гораздо более сложную бухгалтерию,связанную с распределением или раздачей.Кроме того,каждый байт в стеке имеет тенденцию очень часто использоваться повторно,что означает,что он имеет тенденцию быть отображен на кэш процессора,что делает его очень быстрым.Еще одним хитом производительности для кучи является то,что куча,будучи в основном глобальным ресурсом,обычно должна быть многопоточной и безопасной,т.е.каждое распределение и распределение должно быть-как правило-синхронизировано с &quot;всеми&quot; другими доступами к куче в программе.</target>
        </trans-unit>
        <trans-unit id="b147220a7a5ad0a7828db4392f30462146e56ffc" translate="yes" xml:space="preserve">
          <source>The stack is important to consider in exception handling and thread executions.</source>
          <target state="translated">Стек важно учитывать при обработке исключений и выполнении потоков.</target>
        </trans-unit>
        <trans-unit id="8ef364bf925f140fae82efa1d95fdcfda187e3d2" translate="yes" xml:space="preserve">
          <source>The stack is memory that begins as the highest memory address allocated to your program image, and it then decrease in value from there. It is reserved for called function parameters and for all temporary variables used in functions.</source>
          <target state="translated">Стек-это память,которая начинается как наибольший адрес памяти,выделенный вашему программному образу,а затем уменьшается оттуда.Он резервируется для вызываемых параметров функции и для всех временных переменных,используемых в функциях.</target>
        </trans-unit>
        <trans-unit id="f7b4a5b7d8386940ab1623f4ec51157abd70a3d1" translate="yes" xml:space="preserve">
          <source>The stack is much faster than the heap.</source>
          <target state="translated">Стек намного быстрее,чем куча.</target>
        </trans-unit>
        <trans-unit id="8b386c56b8fca037b071be51c145e3471e513ded" translate="yes" xml:space="preserve">
          <source>The stack is the area of memory where local variables (including method parameters) are stored. When it comes to object variables, these are merely references (pointers) to the actual objects on the heap.</source>
          <target state="translated">Стек-это область памяти,в которой хранятся локальные переменные (включая параметры метода).Когда речь идет об объектных переменных,это просто ссылки (указатели)на фактические объекты на куче.</target>
        </trans-unit>
        <trans-unit id="29503f92d8ce71011e0d49b669cd0afb652670e0" translate="yes" xml:space="preserve">
          <source>The stack is the memory set aside as scratch space for a thread of execution.  When a function is called, a block is reserved on the top of the stack for local variables and some bookkeeping data.  When that function returns, the block becomes unused and can be used the next time a function is called.  The stack is always reserved in a LIFO (last in first out) order; the most recently reserved block is always the next block to be freed.  This makes it really simple to keep track of the stack; freeing a block from the stack is nothing more than adjusting one pointer.</source>
          <target state="translated">Стек-это память,зарезервированная в качестве пространства для потока выполнения.При вызове функции блок резервируется в верхней части стека для локальных переменных и некоторых бухгалтерских данных.Когда эта функция возвращается,блок становится неиспользуемым и может быть использован при следующем вызове функции.Стек всегда резервируется в порядке LIFO (последний в порядке первого выхода);последним резервируемым блоком всегда является следующий освобождаемый блок.Это делает отслеживание стека действительно простым;освобождение блока из стека является не более чем регулировкой одного указателя.</target>
        </trans-unit>
        <trans-unit id="219301ffd0ca8cbb0f7920be42b12f92f7f93e51" translate="yes" xml:space="preserve">
          <source>The stack often works in close tandem with a special register on the CPU named the &lt;em&gt;stack pointer&lt;/em&gt;. Initially the stack pointer points to the top of the stack (the highest address on the stack).</source>
          <target state="translated">Стек часто работает в тесном тандеме со специальным регистром на процессоре, называемым &lt;em&gt;указателем стека&lt;/em&gt; . Первоначально указатель стека указывает на вершину стека (самый высокий адрес в стеке).</target>
        </trans-unit>
        <trans-unit id="44325c548d04ad0c66e804e28b38a41e97cabb5a" translate="yes" xml:space="preserve">
          <source>There are two heaps: public and private.</source>
          <target state="translated">Есть две кучи:государственная и частная.</target>
        </trans-unit>
        <trans-unit id="6947fa83d8ffd6b15a325bb26b73b21bd69379ce" translate="yes" xml:space="preserve">
          <source>These images should do a fairly good job of describing the two ways of allocating and freeing memory in a stack and a heap.  Yum!</source>
          <target state="translated">Эти образы должны достаточно хорошо описывать два способа выделения и освобождения памяти в стеке и куче.Вкуснятина!</target>
        </trans-unit>
        <trans-unit id="98d579f7a93657771058e9e0d89785c656c03025" translate="yes" xml:space="preserve">
          <source>They are all global to the program, but their contents can be private, public, or global.</source>
          <target state="translated">Все они являются глобальными для программы,но их содержание может быть частным,общественным или глобальным.</target>
        </trans-unit>
        <trans-unit id="9ef2da64dd7345ced1b7850afdf59a57b13427ca" translate="yes" xml:space="preserve">
          <source>They are not designed to be fast, they are designed to be useful. How the programmer utilizes them determines whether they are &quot;fast&quot; or &quot;slow&quot;</source>
          <target state="translated">Они разработаны не для того,чтобы быть быстрыми,а для того,чтобы быть полезными.То,как программист их использует,определяет,&quot;быстрые&quot; они или &quot;медленные&quot;.</target>
        </trans-unit>
        <trans-unit id="d177331b2e0afe564671649c9a49a92fcc2d64f0" translate="yes" xml:space="preserve">
          <source>This article is the source of picture above: &lt;a href=&quot;http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types#Stack%20and%20Heap&quot;&gt;Six important .NET concepts: Stack, heap, value types, reference types, boxing, and unboxing - CodeProject&lt;/a&gt;</source>
          <target state="translated">Эта статья является источником рисунка выше: &lt;a href=&quot;http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types#Stack%20and%20Heap&quot;&gt;шесть важных концепций .NET: стек, куча, типы значений, ссылочные типы, упаковка и распаковка - CodeProject&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="717f1e13592dff5b361146af2de994b4dd7d6e98" translate="yes" xml:space="preserve">
          <source>This chain of suspended function calls is the stack, because elements in the stack (function calls) depend on each other.</source>
          <target state="translated">Эта цепочка вызовов приостановленных функций является стеком,так как элементы в стеке (вызовы функций)зависят друг от друга.</target>
        </trans-unit>
        <trans-unit id="f0dbb83fd38c86e398ef0d609e84dfa07ea2c5b6" translate="yes" xml:space="preserve">
          <source>This is because of the way that memory is allocated on the stack.</source>
          <target state="translated">Это связано с тем,как память распределяется по стеку.</target>
        </trans-unit>
        <trans-unit id="fb3c5c901732960cbf1b7b18121a96994d8cfa9e" translate="yes" xml:space="preserve">
          <source>This is only practical if your memory usage is quite different from the norm - i.e for games where you load a level in one huge operation and can chuck the whole lot away in another huge operation.</source>
          <target state="translated">Это практично только в том случае,если использование памяти сильно отличается от нормы-т.е.для игр,где вы загружаете уровень в одну огромную операцию и можете отбросить всю партию в другую огромную операцию.</target>
        </trans-unit>
        <trans-unit id="ce81aba3a9e4c22e20ebcec915d127d8ea49a173" translate="yes" xml:space="preserve">
          <source>Thus, the heap is far more complex, because there end up being regions of memory that are unused interleaved with chunks that are - memory gets fragmented. Finding free memory of the size you need is a difficult problem. This is why the heap should be avoided (though it is still often used).</source>
          <target state="translated">Таким образом,куча гораздо сложнее,потому что в итоге получаются неиспользуемые области памяти,чередующиеся с кусочками,которые-память фрагментируется.Поиск свободной памяти нужного объема-сложная задача.Поэтому этой кучи следует избегать (хотя она все еще часто используется).</target>
        </trans-unit>
        <trans-unit id="3718bea08e5c6c1e1ef5855208635c1660091c56" translate="yes" xml:space="preserve">
          <source>To answer your questions directly:</source>
          <target state="translated">Чтобы ответить на ваши вопросы напрямую:</target>
        </trans-unit>
        <trans-unit id="e510eed8b65862876804eb3fc84dd696d12ba373" translate="yes" xml:space="preserve">
          <source>To clarify, &lt;a href=&quot;https://stackoverflow.com/a/13308092/1763801&quot;&gt;this answer&lt;/a&gt; has incorrect information (&lt;a href=&quot;https://stackoverflow.com/a/662454/1763801&quot;&gt;thomas&lt;/a&gt; fixed his answer after comments, cool :) ). Other answers just avoid explaining what static allocation means. So I will explain the three main forms of allocation and how they usually relate to the heap, stack, and data segment below. I also will show some examples in both C/C++ and Python to help people understand.</source>
          <target state="translated">Чтобы уточнить, &lt;a href=&quot;https://stackoverflow.com/a/13308092/1763801&quot;&gt;этот ответ&lt;/a&gt; имеет неверную информацию ( &lt;a href=&quot;https://stackoverflow.com/a/662454/1763801&quot;&gt;Томас&lt;/a&gt; исправил свой ответ после комментариев, круто :)). Другие ответы просто не объясняют, что означает статическое распределение. Поэтому ниже я расскажу о трех основных формах распределения и о том, как они обычно связаны с кучей, стеком и сегментом данных. Я также покажу некоторые примеры на C / C ++ и Python, чтобы помочь людям понять.</target>
        </trans-unit>
        <trans-unit id="aba9caf0dd8ab1b5293cad558ca993a95a150673" translate="yes" xml:space="preserve">
          <source>To what extent are they controlled by the OS or language run-time?</source>
          <target state="translated">В какой степени они контролируются операционной системой или языком исполнения?</target>
        </trans-unit>
        <trans-unit id="0d0079c7ce4541e2501b37e50c9d74ba8c7a5637" translate="yes" xml:space="preserve">
          <source>To what extent are they controlled by the OS or language runtime?</source>
          <target state="translated">В какой степени они контролируются операционной системой или языковой средой выполнения?</target>
        </trans-unit>
        <trans-unit id="38a1226205399953841a1f147c1b73da6efe0983" translate="yes" xml:space="preserve">
          <source>Unlike the stack, the heap does not have size restrictions on variable size (apart from the obvious physical limitations of your computer). Heap memory is slightly slower to be read from and written to, because one has to use pointers to access memory on the heap. We will talk about pointers shortly.</source>
          <target state="translated">В отличие от стека,куча не имеет ограничений по размеру (кроме очевидных физических ограничений вашего компьютера).Память кучи немного медленнее считывается из нее и записывается в нее,потому что для доступа к памяти кучи приходится использовать указатели.В ближайшее время мы поговорим об указателях.</target>
        </trans-unit>
        <trans-unit id="5a0471929b5ff3505424261361762519c6273689" translate="yes" xml:space="preserve">
          <source>Unlike the stack, variables created on the heap are accessible by any function, anywhere in your program. Heap variables are essentially global in scope.</source>
          <target state="translated">В отличие от стека,переменные,созданные на куче,доступны любой функцией,в любом месте вашей программы.Переменные кучи,по сути,являются глобальными по масштабу.</target>
        </trans-unit>
        <trans-unit id="1c9512b6d7a011bae14a8693bd32c0ef50ceaf32" translate="yes" xml:space="preserve">
          <source>Used on demand to allocate a block of data for use by the program.</source>
          <target state="translated">Используется по требованию для выделения блока данных для использования программой.</target>
        </trans-unit>
        <trans-unit id="350c906ec4a09c92d2b1ef4efaf9a024398e8269" translate="yes" xml:space="preserve">
          <source>Usually has a maximum size already determined when your program starts.</source>
          <target state="translated">Обычно максимальный размер уже определен при запуске программы.</target>
        </trans-unit>
        <trans-unit id="dee4e9274b9716c1313c6fb0868f5a44bbadc5a1" translate="yes" xml:space="preserve">
          <source>Variables allocated on the heap have their memory allocated at run time and accessing this memory is a bit slower, but the heap size is only limited by the size of virtual memory. Elements of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time.</source>
          <target state="translated">Переменные,выделенные на куче,выделяют свою память во время выполнения,и доступ к этой памяти немного медленнее,но размер кучи ограничен только размером виртуальной памяти.Элементы кучи не имеют зависимостей друг от друга и всегда могут быть доступны случайным образом в любое время.Вы можете выделить блок в любое время и освободить его в любое время.Это значительно усложняет отслеживание того,какие части кучи выделяются или освобождаются в любой момент времени.</target>
        </trans-unit>
        <trans-unit id="33c4c29193773c536fab56f19aa3e378c611f11a" translate="yes" xml:space="preserve">
          <source>Variables allocated on the stack are stored directly to the memory and access to this memory is very fast, and its allocation is dealt with when the program is compiled. When a function or a method calls another function which in turns calls another function, etc., the execution of all those functions remains suspended until the very last function returns its value. The stack is always reserved in a LIFO order, the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack, freeing a block from the stack is nothing more than adjusting one pointer.</source>
          <target state="translated">Переменные,выделенные на стеке,хранятся непосредственно в памяти,и доступ к этой памяти осуществляется очень быстро,а их выделение происходит при компиляции программы.Когда функция или метод вызывает другую функцию,которая,в свою очередь,вызывает другую функцию и т.д.,выполнение всех этих функций остается приостановленным до тех пор,пока самая последняя функция не вернет свое значение.Стек всегда зарезервирован в порядке LIFO,последний зарезервированный блок всегда является следующим освобождаемым блоком.Это делает отслеживание стека действительно простым,освобождение блока из стека является не более чем регулировкой одного указателя.</target>
        </trans-unit>
        <trans-unit id="b757f96ab6cbd88a78e6eb37e901095a0f4982d5" translate="yes" xml:space="preserve">
          <source>Variables can be accessed globally</source>
          <target state="translated">Переменные могут быть доступны в глобальном масштабе</target>
        </trans-unit>
        <trans-unit id="e1263b2fe0ce0f9a78ac08d33e5cb650a6f890af" translate="yes" xml:space="preserve">
          <source>Variables can be resized using realloc()</source>
          <target state="translated">Переменные могут быть изменены с помощью realloc().</target>
        </trans-unit>
        <trans-unit id="0acb71d1ea9ad7194e7c46ab11399d5d7dc9cbc1" translate="yes" xml:space="preserve">
          <source>Variables cannot be resized</source>
          <target state="translated">Переменные не могут быть изменены в размерах</target>
        </trans-unit>
        <trans-unit id="45bc57bc7c9a39f9e93f0ee2742931507b1a0117" translate="yes" xml:space="preserve">
          <source>Variables created on the stack will go out of scope and are automatically deallocated.</source>
          <target state="translated">Переменные,созданные на стеке,выходят за пределы области видимости и автоматически перераспределяются.</target>
        </trans-unit>
        <trans-unit id="83322fdd7220f9c3561a31019be7de90f70f1113" translate="yes" xml:space="preserve">
          <source>Very fast access</source>
          <target state="translated">Очень быстрый доступ</target>
        </trans-unit>
        <trans-unit id="81465c90cda3940dcc21c6d0fc345dbf62900490" translate="yes" xml:space="preserve">
          <source>Very fast access.</source>
          <target state="translated">Очень быстрый доступ.</target>
        </trans-unit>
        <trans-unit id="d03f25431e8717de4af8cfb5712d2af28175c6de" translate="yes" xml:space="preserve">
          <source>What and where are the stack and heap</source>
          <target state="translated">Что и где стопка и куча...</target>
        </trans-unit>
        <trans-unit id="e330f4218aa5748683c1aedc4c7ad3739182f7f9" translate="yes" xml:space="preserve">
          <source>What determines the size of each of them?</source>
          <target state="translated">Что определяет размер каждого из них?</target>
        </trans-unit>
        <trans-unit id="780a2c071a1fa9df58512fef52b5d41ee762fbf5" translate="yes" xml:space="preserve">
          <source>What is their scope?</source>
          <target state="translated">Какова их сфера применения?</target>
        </trans-unit>
        <trans-unit id="b72db36173b02e399c3380ebce765f483206c5f5" translate="yes" xml:space="preserve">
          <source>What makes one faster?</source>
          <target state="translated">Что делает его быстрее?</target>
        </trans-unit>
        <trans-unit id="7dd7be24ae5c5f3254644f00a932a8eaf93d7843" translate="yes" xml:space="preserve">
          <source>When a function is called the CPU uses special instructions that push the current &lt;em&gt;instruction pointer&lt;/em&gt;, i.e. the address of the code executing on the stack. The CPU then jumps to the function by setting the 
instruction pointer to the address of the function called. Later, when the function returns, the old instruction pointer is popped from the stack and execution resumes at the code just after the call to the function.</source>
          <target state="translated">Когда функция вызывается, CPU использует специальные инструкции, которые выдвигают &lt;em&gt;указатель&lt;/em&gt; текущей &lt;em&gt;инструкции&lt;/em&gt; , то есть адрес кода, выполняемого в стеке. Затем процессор переходит к функции, устанавливая указатель инструкции на адрес вызываемой функции. Позже, когда функция возвращается, старый указатель инструкции извлекается из стека, и выполнение возобновляется в коде сразу после вызова функции.</target>
        </trans-unit>
        <trans-unit id="76bfa98cbe27f31d7e7e3e9a0604cbd18ab53032" translate="yes" xml:space="preserve">
          <source>When a function is entered, the stack pointer is decreased to allocate more space on the stack for local (automatic) variables. If the function has one local 32 bit variable four bytes are set aside on the stack. When the function returns, the stack pointer is moved back to free the allocated area.</source>
          <target state="translated">При вводе функции указатель стека уменьшается,чтобы выделить больше места на стеке для локальных (автоматических)переменных.Если функция имеет одну локальную 32-битную переменную,то на стеке выделяются четыре байта.Когда функция возвращается,указатель на стек перемещается обратно,чтобы освободить выделенную область.</target>
        </trans-unit>
        <trans-unit id="7345937a4022621af869e20017f6923e9e95b153" translate="yes" xml:space="preserve">
          <source>When a function or a method calls another function which in turns calls another function, etc., the execution of all those functions remains suspended until the very last function returns its value.</source>
          <target state="translated">Когда функция или метод вызывает другую функцию,которая,в свою очередь,вызывает другую функцию и т.д.,выполнение всех этих функций остается приостановленным до тех пор,пока самая последняя функция не вернет свое значение.</target>
        </trans-unit>
        <trans-unit id="17eea20994cf0f8b60ad7500e16ae0d2babaffb7" translate="yes" xml:space="preserve">
          <source>When a used block that is adjacent to a free block is deallocated the new free block may be merged with the adjacent free block to create a larger free block effectively reducing the fragmentation of the heap.</source>
          <target state="translated">Когда использованный блок,находящийся рядом со свободным блоком,удаляется,новый свободный блок может быть объединен со смежным свободным блоком,чтобы создать более крупный свободный блок,эффективно уменьшающий фрагментацию кучи.</target>
        </trans-unit>
        <trans-unit id="fc80e3d497340bb1dd2782f548d7a04ed5176215" translate="yes" xml:space="preserve">
          <source>When using fibers, green threads or coroutines, you &lt;em&gt;usually&lt;/em&gt; have a separate stack per function. (Technically, not just a stack but a whole context of execution is per function. Most importantly, CPU registers.) For every thread there're as many stacks as there're concurrently running functions, and the thread is switching between executing each function according to the logic of your program. When a function runs to its end, its stack is destroyed. So, &lt;strong&gt;the number and lifetimes of stacks&lt;/strong&gt; are dynamic and &lt;strong&gt;are not determined by the number of OS-level threads!&lt;/strong&gt;</source>
          <target state="translated">При использовании волокон, зеленых нитей или сопрограмм у вас &lt;em&gt;обычно&lt;/em&gt; есть отдельный стек для каждой функции. (Технически, для каждой функции используется не просто стек, а целый контекст выполнения. Самое главное, регистры ЦП.) Для каждого потока имеется столько стеков, сколько имеется одновременно работающих функций, и поток переключается между выполнением каждой функции. в соответствии с логикой вашей программы. Когда функция запускается до конца, ее стек уничтожается. Таким образом, &lt;strong&gt;количество и время жизни стеков&lt;/strong&gt; являются динамическими и &lt;strong&gt;не определяются количеством потоков на уровне ОС!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a476cf0746ec4d2c4a044655c71d195262024622" translate="yes" xml:space="preserve">
          <source>Where and what are they (physically in a real computer's memory)?</source>
          <target state="translated">Где и что они (физически в памяти настоящего компьютера)?</target>
        </trans-unit>
        <trans-unit id="1fb0c80cb7c016fa977e4e460c6d36c71cd287e5" translate="yes" xml:space="preserve">
          <source>Without stack &lt;strong&gt;no&lt;/strong&gt; microprocessor can work. (we can't imagine a program, even in assembly language, without subroutines/functions)</source>
          <target state="translated">Без стека &lt;strong&gt;не&lt;/strong&gt; может работать &lt;strong&gt;ни один&lt;/strong&gt; микропроцессор. (мы не можем представить программу, даже на ассемблере, без подпрограмм / функций)</target>
        </trans-unit>
        <trans-unit id="010f37556d32304cf4397c04fe519e09ac87a1e2" translate="yes" xml:space="preserve">
          <source>Without the heap it can. (An assembly language program can work without, as the heap is a OS concept, as malloc, that is a OS/Lib call.</source>
          <target state="translated">Без кучи она может.(Программа на ассемблерном языке может работать и без него,поскольку куча-это концепция ОС,как malloc,то есть вызов OSLib.</target>
        </trans-unit>
        <trans-unit id="3a9de33c793289bb4824480cb8f4087bf9168010" translate="yes" xml:space="preserve">
          <source>Wow! So many answers and I don't think one of them got it right...</source>
          <target state="translated">Ничего себе! Так много ответов,и я не думаю,что один из них правильно понял...</target>
        </trans-unit>
        <trans-unit id="b1e7c9f013a3dbd26304d7c5054c48167a4ae117" translate="yes" xml:space="preserve">
          <source>You can do some interesting things with the stack.  For instance, you have functions like &lt;a href=&quot;http://everything2.com/title/alloca%2528%2529&quot;&gt;alloca&lt;/a&gt; (assuming you can get past the copious warnings concerning its use), which is a form of malloc that specifically uses the stack, not the heap, for memory.</source>
          <target state="translated">Вы можете делать некоторые интересные вещи со стеком. Например, у вас есть такие функции, как &lt;a href=&quot;http://everything2.com/title/alloca%2528%2529&quot;&gt;alloca&lt;/a&gt; (при условии, что вы можете обойти обильные предупреждения относительно его использования), который является формой malloc, которая специально использует стек, а не кучу памяти.</target>
        </trans-unit>
        <trans-unit id="892eae56f7439ba3dcbb1ea3ea17d754f03b35eb" translate="yes" xml:space="preserve">
          <source>You can use the stack if you know exactly how much data you need to allocate before compile time, and it is not too big. You can use the heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data.</source>
          <target state="translated">Вы можете использовать стек,если точно знаете,сколько данных нужно выделить перед компиляцией,и он не слишком велик.Вы можете использовать кучу данных,если не знаете точно,сколько данных вам понадобится во время компиляции,или если вам нужно выделить много данных.</target>
        </trans-unit>
        <trans-unit id="3009d59448498f75aa79426e3fa60a5f198f2ebb" translate="yes" xml:space="preserve">
          <source>You can use the stack to pass parameters.. even if it is slower than using registers (would a microprocessor guru say or a good 1980s BIOS book...)</source>
          <target state="translated">Вы можете использовать стек для передачи параметров...даже если он медленнее,чем использование регистров (как говорит гуру микропроцессоров или хорошая книга BIOS 80-х годов...).</target>
        </trans-unit>
        <trans-unit id="6406486d2198ac8633b1773b5680854692fc022d" translate="yes" xml:space="preserve">
          <source>You must manage memory (you're in charge of allocating and freeing variables)</source>
          <target state="translated">Вы должны управлять памятью (вы отвечаете за выделение и освобождение переменных).</target>
        </trans-unit>
        <trans-unit id="448cd0c4ab29afd1275bb72eaa06d3f1ffbebf2e" translate="yes" xml:space="preserve">
          <source>You would use the heap if you don't know exactly how much data you will need at run time or if you need to allocate a lot of data.</source>
          <target state="translated">Вы бы использовали кучу данных,если бы не знали точно,сколько данных вам понадобится во время выполнения,или если бы вам нужно было выделить много данных.</target>
        </trans-unit>
        <trans-unit id="21f0077be84d0a785692e7530efcb1dfe9e053c8" translate="yes" xml:space="preserve">
          <source>You would use the stack if you know exactly how much data you need to allocate before compile time and it is not too big.</source>
          <target state="translated">Вы бы использовали стек,если бы точно знали,сколько данных нужно выделить перед компиляцией,и он не слишком велик.</target>
        </trans-unit>
        <trans-unit id="2dd752e3a7242d730dc1ffd2af44fb8042a9cd98" translate="yes" xml:space="preserve">
          <source>and here:</source>
          <target state="translated">и здесь:</target>
        </trans-unit>
        <trans-unit id="e7cb8b2830bfb6729d691a0e8fc0b7ca5702106b" translate="yes" xml:space="preserve">
          <source>but be aware it may contain some inaccuracies.</source>
          <target state="translated">но имейте в виду,что в нем могут быть некоторые неточности.</target>
        </trans-unit>
        <trans-unit id="3e27b62ab595041b7d6fc3295ef65f967e4bb6d4" translate="yes" xml:space="preserve">
          <source>malloc requires entering kernel mode, use lock/semaphore (or other synchronization primitives) executing some code and manage some structures needed to keep track of allocation.</source>
          <target state="translated">malloc требует входа в режим кернела,использования локальной карты (или других примитивов синхронизации),выполняющих некоторый код,и управления некоторыми структурами,необходимыми для отслеживания выделения.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
