<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/79923">
    <body>
      <group id="79923">
        <trans-unit id="94b77d4c21edabc0121f024c01bcc9ef48259dc3" translate="yes" xml:space="preserve">
          <source>&quot;Static&quot; (AKA statically allocated) variables are not allocated on the stack. Do not assume so - many people do only because &quot;static&quot; sounds a lot like &quot;stack&quot;. They actually exist in neither the stack nor the heap. The are part of what's called the &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_segment&quot;&gt;data segment&lt;/a&gt;.</source>
          <target state="translated">Las variables &quot;est&amp;aacute;ticas&quot; (AKA asignadas est&amp;aacute;ticamente) no se asignan en la pila. No asuma que muchas personas lo hacen solo porque &quot;est&amp;aacute;tico&quot; se parece mucho a &quot;apilar&quot;. En realidad no existen ni en la pila ni en el mont&amp;oacute;n. Son parte de lo que se llama &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_segment&quot;&gt;segmento de datos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7b5c0042bc6fdc5e224949119eea46897b85f96" translate="yes" xml:space="preserve">
          <source>&quot;You can use the stack if you know exactly how much data you need to allocate before compile time, and it is not too big. You can use the heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data.&quot;</source>
          <target state="translated">&quot;Puedes usar la pila si sabes exactamente cuántos datos necesitas asignar antes de compilar el tiempo,y no es demasiado grande.Puedes usar la pila si no sabes exactamente cuántos datos necesitarás en tiempo de ejecución o si necesitas asignar muchos datos&quot;.</target>
        </trans-unit>
        <trans-unit id="6b71c1598ca48211c09537cb37ffecd0279e4352" translate="yes" xml:space="preserve">
          <source>(I have moved this answer from another question that was more or less a dupe of this one.)</source>
          <target state="translated">(He movido esta respuesta de otra pregunta que era más o menos un engaño de esta.)</target>
        </trans-unit>
        <trans-unit id="61257768b7a93e136c9c290d6825931b71bdb701" translate="yes" xml:space="preserve">
          <source>(Relatively) slower access</source>
          <target state="translated">Acceso (relativamente)más lento</target>
        </trans-unit>
        <trans-unit id="260e2615aff475120193632bb3dec58b387e3862" translate="yes" xml:space="preserve">
          <source>1) Where and what are they (physically in a real computer's memory)?</source>
          <target state="translated">1)¿Dónde y qué son (físicamente en la memoria de un ordenador real)?</target>
        </trans-unit>
        <trans-unit id="fdb1507c9ac6adb1fa6fa6251df8690b83ca6414" translate="yes" xml:space="preserve">
          <source>2) To what extent are they controlled by the OS or language runtime?</source>
          <target state="translated">2)¿Hasta qué punto están controlados por el sistema operativo o el tiempo de ejecución del lenguaje?</target>
        </trans-unit>
        <trans-unit id="99b4e74430a1011d0a32a5e6a68f89192d5600f4" translate="yes" xml:space="preserve">
          <source>2b) What is their scope?</source>
          <target state="translated">2b)¿Cuál es su alcance?</target>
        </trans-unit>
        <trans-unit id="9888f38f3e423435fa5b8292adbdd39fb0f72092" translate="yes" xml:space="preserve">
          <source>2c) What determines the size of each of them?</source>
          <target state="translated">2c)¿Qué determina el tamaño de cada uno de ellos?</target>
        </trans-unit>
        <trans-unit id="019eef749bba4958d2ffca2f9849b67199fb6815" translate="yes" xml:space="preserve">
          <source>2d) What makes one faster?</source>
          <target state="translated">2d)¿Qué hace que uno sea más rápido?</target>
        </trans-unit>
        <trans-unit id="e2d2295e136ea1dc3f598156ec945a446432c714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Local Variables&lt;/code&gt; that only need to last as long as the function invocation go in the stack. The heap is used for variables whose lifetime we don't really know up front but we expect them to last a while. In most languages it's critical that we know at compile time how large a variable is if we want to store it on the stack.</source>
          <target state="translated">&lt;code&gt;Local Variables&lt;/code&gt; que solo necesitan durar mientras la invocaci&amp;oacute;n de la funci&amp;oacute;n va en la pila. El mont&amp;oacute;n se usa para variables cuya vida &amp;uacute;til realmente no conocemos por adelantado, pero esperamos que duren un tiempo. En la mayor&amp;iacute;a de los idiomas, es fundamental que sepamos en tiempo de compilaci&amp;oacute;n qu&amp;eacute; tan grande es una variable si queremos almacenarla en la pila.</target>
        </trans-unit>
        <trans-unit id="db81e688d99a4e08a6e79477826a7c115e20208c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To what extent are they controlled by the OS or language runtime?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iquest;En qu&amp;eacute; medida est&amp;aacute;n controlados por el sistema operativo o el tiempo de ejecuci&amp;oacute;n del lenguaje?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="513a3b3ab4e6ae37babfa4b83b1cb3c51c31881a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What determines the size of each of them?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iquest;Qu&amp;eacute; determina el tama&amp;ntilde;o de cada uno de ellos?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d053678e5d47e6f07a8fde4ce00b7cddb559cbb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is their scope?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iquest;Cu&amp;aacute;l es su alcance?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dcfa20263ead7486e0e7d967879203f1a13837a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What makes one faster?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iquest;Qu&amp;eacute; lo hace a uno m&amp;aacute;s r&amp;aacute;pido?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9a6c5f939fd49e7bad84b2be8abb7f468b02d07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Both together&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ambos juntos&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84a530a09edadff20200961546fdc028c855eefc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heap:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Heap:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85e58808cd94b0b4694342607d9808c4b578db9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Heap&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="917e40efec8d1d189c6f18faaf670f99b1bd7e44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heap&lt;/strong&gt;: No order, processing gonna be slower and values are messed up together with no specific order or index... there are random and there is no relationship between them... so execution and usage time could be vary...</source>
          <target state="translated">&lt;strong&gt;Mont&amp;oacute;n&lt;/strong&gt; : Sin orden, el procesamiento ser&amp;aacute; m&amp;aacute;s lento y los valores se desordenar&amp;aacute;n sin un orden o &amp;iacute;ndice espec&amp;iacute;fico ... hay al azar y no hay relaci&amp;oacute;n entre ellos ... por lo que el tiempo de ejecuci&amp;oacute;n y uso podr&amp;iacute;a variar ...</target>
        </trans-unit>
        <trans-unit id="742792f83b9d6d503d676cd5342ac745b1a51f3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;
Implementation of both the stack and heap is usually down to the runtime / OS. Often games and other applications that are performance critical create their own memory solutions that grab a large chunk of memory from the heap and then dish it out internally to avoid relying on the OS for memory.</source>
          <target state="translated">&lt;strong&gt;Implementaci&amp;oacute;n La&lt;/strong&gt; implementaci&amp;oacute;n de la pila y el mont&amp;oacute;n generalmente depende del tiempo de ejecuci&amp;oacute;n / SO. A menudo, los juegos y otras aplicaciones que son cr&amp;iacute;ticas para el rendimiento crean sus propias soluciones de memoria que toman una gran cantidad de memoria del mont&amp;oacute;n y luego la distribuyen internamente para evitar depender del sistema operativo para la memoria.</target>
        </trans-unit>
        <trans-unit id="b0c3414fb835eb86d73b6be57a2a7aebafd2801c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interesting note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Nota interesante:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a0e3df07fea6c0d8b408481568ec08761eb430d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; simply and in short words, they mean &lt;strong&gt;ordered&lt;/strong&gt; and &lt;strong&gt;not ordered&lt;/strong&gt;...!</source>
          <target state="translated">&lt;strong&gt;OK,&lt;/strong&gt; simplemente y en pocas palabras, significan &lt;strong&gt;ordenado&lt;/strong&gt; y &lt;strong&gt;no ordenado&lt;/strong&gt; ...!</target>
        </trans-unit>
        <trans-unit id="8628c9ba0a73bc55254ac6ceb73adfa8e4eada2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Physical location in memory&lt;/strong&gt;
This is less relevant than you think because of a technology called &lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_memory&quot;&gt;Virtual Memory&lt;/a&gt; which makes your program think that you have access to a certain address where the physical data is somewhere else (even on the hard disc!). The addresses you get for the stack are in increasing order as your call tree gets deeper. The addresses for the heap are un-predictable (i.e implimentation specific) and frankly not important.</source>
          <target state="translated">&lt;strong&gt;Ubicaci&amp;oacute;n f&amp;iacute;sica en la memoria&lt;/strong&gt; Esto es menos relevante de lo que cree debido a una tecnolog&amp;iacute;a llamada &lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_memory&quot;&gt;Memoria virtual&lt;/a&gt; que hace que su programa piense que tiene acceso a una determinada direcci&amp;oacute;n donde los datos f&amp;iacute;sicos est&amp;aacute;n en otro lugar (&amp;iexcl;incluso en el disco duro!). Las direcciones que obtiene para la pila est&amp;aacute;n en orden creciente a medida que su &amp;aacute;rbol de llamadas se vuelve m&amp;aacute;s profundo. Las direcciones para el mont&amp;oacute;n no son predecibles (es decir, espec&amp;iacute;ficas de la implementaci&amp;oacute;n) y, francamente, no son importantes.</target>
        </trans-unit>
        <trans-unit id="e19a9343f895eca75944e60482202b71e0cbcd58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stack:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Stack:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c741ee79de20716b9e2549b13bac80467d01d08f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stack&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Stack&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7e4ac541ac7066d86d467c49418a1b8c8ab19f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stack&lt;/strong&gt;: In stack items, things get on the top of each-other, means gonna be faster and more efficient to be processed!...</source>
          <target state="translated">&lt;strong&gt;Pila&lt;/strong&gt; : en los elementos de pila, las cosas se ponen una encima de la otra, &amp;iexcl;significa que ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido y m&amp;aacute;s eficiente ser procesado! ...</target>
        </trans-unit>
        <trans-unit id="7e7cfe5d1f60635f341d1ef4579eb83f724c5d41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Heap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El mont&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6709062928227b6319f7deeb9a0847d3a67f3a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Heap&lt;/strong&gt;
The heap is a generic name for where you put the data that you create on the fly. If you don't know how many spaceships your program is going to create, you are likely to use the new (or malloc or equivalent) operator to create each spaceship. This allocation is going to stick around for a while, so it is likely we will free things in a different order than we created them.</source>
          <target state="translated">&lt;strong&gt;El mont&amp;oacute;n&lt;/strong&gt; El mont&amp;oacute;n es un nombre gen&amp;eacute;rico para el lugar donde coloca los datos que crea sobre la marcha. Si no sabe cu&amp;aacute;ntas naves espaciales va a crear su programa, es probable que use el nuevo operador (o malloc o equivalente) para crear cada nave espacial. Esta asignaci&amp;oacute;n se mantendr&amp;aacute; durante un tiempo, por lo que es probable que liberemos las cosas en un orden diferente al que las creamos.</target>
        </trans-unit>
        <trans-unit id="bcb3f513eb6fa7ddc8d6c4dc2b21d182cce677d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Stack&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La pila&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a390d755244266caf60a0813cd14b6beb633141e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Stack&lt;/strong&gt;
When you call a function the arguments to that function plus some other overhead is put on the stack. Some info (such as where to go on return) is also stored there.
When you declare a variable inside your function, that variable is also allocated on the stack.</source>
          <target state="translated">&lt;strong&gt;La pila&lt;/strong&gt; Cuando llama a una funci&amp;oacute;n, los argumentos de esa funci&amp;oacute;n m&amp;aacute;s alguna otra sobrecarga se colocan en la pila. Alguna informaci&amp;oacute;n (como a d&amp;oacute;nde ir al regreso) tambi&amp;eacute;n se almacena all&amp;iacute;. Cuando declara una variable dentro de su funci&amp;oacute;n, esa variable tambi&amp;eacute;n se asigna en la pila.</target>
        </trans-unit>
        <trans-unit id="76cc17ae17ebb267fcbd177db1d4f1d292b7ce9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To what extent are they controlled by the OS or language runtime?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;En qu&amp;eacute; medida est&amp;aacute;n controlados por el sistema operativo o el tiempo de ejecuci&amp;oacute;n del lenguaje?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0563b18a23e550f58bac67d459c94a52a3249acd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What determines the size of each of them?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Qu&amp;eacute; determina el tama&amp;ntilde;o de cada uno de ellos?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c6c7dce19b600ea980045fc6edcd1962f6b5551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a heap?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Qu&amp;eacute; es un mont&amp;oacute;n?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b97a8d104003b830b171fde9ab6c0f738620e336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a stack?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Qu&amp;eacute; es una pila?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6b73e40eadb8e589a235f27b4b54d80562f2496" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is their scope?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Cu&amp;aacute;l es su alcance?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="159e5d461f5ea67df5f298bd8e4358250caeb1b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What makes one faster?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Qu&amp;eacute; lo hace a uno m&amp;aacute;s r&amp;aacute;pido?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="78f9413c67586527ba6c81668b7aa287b0c28430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Which is faster &amp;ndash; the stack or the heap? And why?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Cu&amp;aacute;l es m&amp;aacute;s r&amp;aacute;pido, la pila o el mont&amp;oacute;n?&lt;/strong&gt; &lt;strong&gt;&amp;iquest;Y por qu&amp;eacute;?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad882499bf2a5c77de197c8c4907389551e5d253" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stack&lt;/strong&gt;, &lt;strong&gt;heap&lt;/strong&gt; and &lt;strong&gt;data&lt;/strong&gt; of each process in virtual memory:</source>
          <target state="translated">&lt;strong&gt;pila&lt;/strong&gt; , &lt;strong&gt;mont&amp;oacute;n&lt;/strong&gt; y &lt;strong&gt;datos&lt;/strong&gt; de cada proceso en la memoria virtual:</target>
        </trans-unit>
        <trans-unit id="2e2ab5cd39dfbdc8c03b7bbbbd7b88d895cbeb77" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Image source: &lt;a href=&quot;http://vikashazrati.wordpress.com/2007/10/01/quicktip-java-basics-stack-and-heap/&quot;&gt;vikashazrati.wordpress.com&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Fuente de la imagen: &lt;a href=&quot;http://vikashazrati.wordpress.com/2007/10/01/quicktip-java-basics-stack-and-heap/&quot;&gt;vikashazrati.wordpress.com&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="66efe8c438bd049d124a2fb9c161181488baa05f" translate="yes" xml:space="preserve">
          <source>A clear demonstration:</source>
          <target state="translated">Una clara demostración:</target>
        </trans-unit>
        <trans-unit id="01ce9bd8f6baf3c7c49927f90f1d012016d83e18" translate="yes" xml:space="preserve">
          <source>A couple of cents: I think, it will be good to draw memory graphical and more simple:</source>
          <target state="translated">Un par de centavos:Creo que será bueno dibujar la memoria de forma gráfica y más simple:</target>
        </trans-unit>
        <trans-unit id="a15b908bf3b3ecfd069a0fe5e01ef6e82a56da1d" translate="yes" xml:space="preserve">
          <source>A heap is a general term for anything that can be dynamically allocated.  Depending on which way you look at it, it is constantly changing size.  In modern processors and operating systems the exact way it works is very abstracted anyway, so you don't normally need to worry much about how it works deep down, except that (in languages where it lets you) you mustn't use memory that you haven't allocated yet or memory that you have freed.</source>
          <target state="translated">Un montón es un término general para cualquier cosa que pueda ser asignada dinámicamente.Dependiendo de cómo se mire,cambia de tamaño constantemente.En los procesadores y sistemas operativos modernos la forma exacta en que funciona es muy abstracta de todos modos,por lo que normalmente no necesitas preocuparte mucho sobre cómo funciona en el fondo,excepto que (en los lenguajes en los que te permite)no debes usar memoria que no hayas asignado todavía o memoria que hayas liberado.</target>
        </trans-unit>
        <trans-unit id="068dd7e9d8ed5b397b0a6eff3ba84c4edc71f672" translate="yes" xml:space="preserve">
          <source>A heap is a general term used for any memory that is allocated dynamically and randomly; i.e. out of order.  The memory is typically allocated by the OS, with the application calling API functions to do this allocation.  There is a fair bit of overhead required in managing dynamically allocated memory, which is usually handled by the runtime code of the programming language or environment used.</source>
          <target state="translated">Un montón es un término general utilizado para cualquier memoria que se asigna de forma dinámica y aleatoria,es decir,fuera de orden.La memoria suele ser asignada por el sistema operativo,y la aplicación llama a las funciones de la API para realizar esta asignación.La gestión de la memoria asignada de forma dinámica requiere un cierto grado de sobrecarga,que suele ser manejada por el código de tiempo de ejecución del lenguaje de programación o el entorno utilizado.</target>
        </trans-unit>
        <trans-unit id="34f5d3ec6b1ce5253cef0356a62d5aa350e32ac5" translate="yes" xml:space="preserve">
          <source>A heap is an untidy collection of things piled up haphazardly.</source>
          <target state="translated">Un montón es una colección desordenada de cosas apiladas al azar.</target>
        </trans-unit>
        <trans-unit id="ee141ae29a5c83c4f8aa0cade4298cafffd77712" translate="yes" xml:space="preserve">
          <source>A lot of answers are correct as concepts, but we must note that a stack is needed by the hardware (i.e. microprocessor) to allow calling subroutines (CALL in assembly language..). (OOP guys will call it &lt;em&gt;methods&lt;/em&gt;)</source>
          <target state="translated">Muchas respuestas son correctas como conceptos, pero debemos tener en cuenta que el hardware necesita una pila (es decir, un microprocesador) para permitir llamar a subrutinas (CALL en lenguaje ensamblador ...). (OOP chicos lo llamar&amp;aacute;n &lt;em&gt;m&amp;eacute;todos&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="c31b57674dbc2b0d1d5439a1c86d854b8d2b25b9" translate="yes" xml:space="preserve">
          <source>A particularly poignant example of why it's important to distinguish between lifetime and scope is that a variable can have local scope but static lifetime - for instance, &quot;someLocalStaticVariable&quot; in the code sample above. Such variables can make our common but informal naming habits very confusing. For instance when we say &quot;&lt;em&gt;local&lt;/em&gt;&quot; we usually mean &quot;&lt;em&gt;locally scoped automatically allocated variable&lt;/em&gt;&quot; and when we say global we usually mean &quot;&lt;em&gt;globally scoped statically allocated variable&lt;/em&gt;&quot;. Unfortunately when it comes to things like &quot;&lt;em&gt;file scoped statically allocated variables&lt;/em&gt;&quot; many people just say... &quot;&lt;em&gt;huh???&lt;/em&gt;&quot;.</source>
          <target state="translated">Un ejemplo particularmente conmovedor de por qu&amp;eacute; es importante distinguir entre la vida &amp;uacute;til y el alcance es que una variable puede tener un alcance local pero una vida &amp;uacute;til est&amp;aacute;tica, por ejemplo, &quot;someLocalStaticVariable&quot; en el ejemplo de c&amp;oacute;digo anterior. Dichas variables pueden hacer que nuestros h&amp;aacute;bitos de denominaci&amp;oacute;n comunes pero informales sean muy confusos. Por ejemplo, cuando decimos &quot; &lt;em&gt;local&lt;/em&gt; &quot; usualmente queremos decir &quot; &lt;em&gt;variable asignada localmente con alcance local&lt;/em&gt; &quot; y cuando decimos global generalmente queremos decir &quot; &lt;em&gt;variable asignada est&amp;aacute;ticamente con alcance global&lt;/em&gt; &quot;. Desafortunadamente, cuando se trata de cosas como &quot; &lt;em&gt;variables asignadas est&amp;aacute;ticamente a un archivo&lt;/em&gt; &quot;, muchas personas simplemente dicen ... &quot; &lt;em&gt;&amp;iquest;&lt;/em&gt; &amp;iquest; &lt;em&gt;&amp;iquest;&lt;/em&gt; &amp;iquest; &lt;em&gt;&amp;iquest;&lt;/em&gt; &amp;iquest; &lt;em&gt;&amp;iquest;&lt;/em&gt; &amp;iquest; &lt;em&gt;&amp;iquest;eh ???&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc133acebf965ce867ad157a05f353a3707fecd3" translate="yes" xml:space="preserve">
          <source>A stack is a pile of objects, typically one that is neatly arranged.</source>
          <target state="translated">Una pila es una pila de objetos,típicamente una que está ordenada.</target>
        </trans-unit>
        <trans-unit id="9f4c46ea1849c89970aa6079e049594ebbd9a39c" translate="yes" xml:space="preserve">
          <source>A stack is used for static memory allocation and a heap for dynamic memory allocation, both stored in the computer's RAM.</source>
          <target state="translated">Se utiliza una pila para la asignación de memoria estática y un montón para la asignación de memoria dinámica,ambas almacenadas en la RAM de la computadora.</target>
        </trans-unit>
        <trans-unit id="7d53fc8a81490a3d76add68a85ec8e7f0f02250f" translate="yes" xml:space="preserve">
          <source>A typical C program was laid out flat in memory with
an opportunity to increase by changing the brk() value.
Typically, the HEAP was just below this brk value
and increasing brk increased the amount of available heap.</source>
          <target state="translated">Un programa típico de C fue diseñado plano en la memoria con la oportunidad de aumentarlo cambiando el valor brk().Típicamente,el HEAP estaba justo por debajo de este valor de brk y el aumento de brk incrementaba la cantidad de montón disponible.</target>
        </trans-unit>
        <trans-unit id="0eb3c88bb9382983d9131328ce15ca6b37271be5" translate="yes" xml:space="preserve">
          <source>Again, it depends on the language, compiler, operating system and architecture.  A stack is usually pre-allocated, because by definition it must be contiguous memory.  The language compiler or the OS determine its size.  You don't store huge chunks of data on the stack, so it'll be big enough that it should never be fully used, except in cases of unwanted endless recursion (hence, &quot;stack overflow&quot;) or other unusual programming decisions.</source>
          <target state="translated">De nuevo,depende del lenguaje,el compilador,el sistema operativo y la arquitectura.Una pila suele estar preasignada,porque por definición debe ser una memoria contigua.El compilador del lenguaje o el sistema operativo determinan su tamaño.No se almacenan grandes cantidades de datos en la pila,por lo que será lo suficientemente grande como para que nunca pueda ser utilizada en su totalidad,excepto en casos de recursividad interminable no deseada (por lo tanto,&quot;desbordamiento de la pila&quot;)u otras decisiones de programación inusuales.</target>
        </trans-unit>
        <trans-unit id="3c53181b48366809a97c6caadb3cafb768a586d9" translate="yes" xml:space="preserve">
          <source>Allocating and deallocating many small blocks may leave the heap in a state where there are a lot of small free blocks interspersed between the used blocks. A request to allocate a large block may fail because none of the free blocks are large enough to satisfy the allocation request even though the combined size of the free blocks may be large enough. This is called &lt;em&gt;heap fragmentation&lt;/em&gt;.</source>
          <target state="translated">Asignar y desasignar muchos bloques peque&amp;ntilde;os puede dejar el mont&amp;oacute;n en un estado en el que hay muchos bloques libres peque&amp;ntilde;os intercalados entre los bloques usados. Una solicitud para asignar un bloque grande puede fallar porque ninguno de los bloques libres es lo suficientemente grande como para satisfacer la solicitud de asignaci&amp;oacute;n a pesar de que el tama&amp;ntilde;o combinado de los bloques libres puede ser lo suficientemente grande. Esto se llama &lt;em&gt;fragmentaci&amp;oacute;n del mont&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="038e52e8565cce864ffd7e1b894e6892fe5a1d29" translate="yes" xml:space="preserve">
          <source>Allocating memory on the stack is as simple as moving the stack pointer up.</source>
          <target state="translated">Asignar la memoria en la pila es tan simple como mover el puntero de la pila hacia arriba.</target>
        </trans-unit>
        <trans-unit id="361ef44f8aa22b0b13d1393adb5398aff7afdb86" translate="yes" xml:space="preserve">
          <source>Already given in top.</source>
          <target state="translated">Ya se ha dado en la parte superior.</target>
        </trans-unit>
        <trans-unit id="d9ac18d3c62e0844f72b69b9833ed0b09f4440d4" translate="yes" xml:space="preserve">
          <source>Also, stack vs. heap is not only a performance consideration; it also tells you a lot about the expected lifetime of objects.</source>
          <target state="translated">Además,pila vs.montón no es sólo una consideración de rendimiento;también te dice mucho sobre la vida útil esperada de los objetos.</target>
        </trans-unit>
        <trans-unit id="1e2d387706b8a4328b31b3009e56251e7ed275fb" translate="yes" xml:space="preserve">
          <source>Although most compilers and interpreters implement this behavior similarly in terms of using stacks, heaps, etc, a compiler may sometimes break these conventions if it wants as long as behavior is correct. For instance, due to optimization a local variable may only exist in a register or be removed entirely, even though most local variables exist in the stack. As has been pointed out in a few comments, you are free to implement a compiler that doesn't even use a stack or a heap, but instead some other storage mechanisms (rarely done, since stacks and heaps are great for this).</source>
          <target state="translated">Aunque la mayoría de los compiladores e intérpretes implementan este comportamiento de manera similar en términos de uso de pilas,montones,etc.,un compilador puede a veces romper estas convenciones si quiere siempre y cuando el comportamiento sea correcto.Por ejemplo,debido a la optimización,una variable local puede existir sólo en un registro o ser eliminada por completo,aunque la mayoría de las variables locales existan en la pila.Como se ha señalado en algunos comentarios,es libre de implementar un compilador que ni siquiera utilice una pila o un montón,sino algunos otros mecanismos de almacenamiento (raramente se hace,ya que las pilas y los montones son excelentes para esto).</target>
        </trans-unit>
        <trans-unit id="eeb33740077a9e43e5825d3e19723b4a66394dcc" translate="yes" xml:space="preserve">
          <source>Arrows - show where grow stack and heap, process stack size have limit, defined in OS, thread stack size limits by parameters in thread create API usually. Heap usually limiting by process maximum virtual memory size, for 32 bit 2-4&amp;nbsp;GB for example.</source>
          <target state="translated">Flechas: muestran d&amp;oacute;nde crecen la pila y el mont&amp;oacute;n, el tama&amp;ntilde;o de la pila del proceso tiene un l&amp;iacute;mite, definido en el sistema operativo, los l&amp;iacute;mites del tama&amp;ntilde;o de la pila de subprocesos por par&amp;aacute;metros en la API de creaci&amp;oacute;n de subprocesos generalmente. El almacenamiento din&amp;aacute;mico suele limitar el tama&amp;ntilde;o m&amp;aacute;ximo de memoria virtual del proceso, por ejemplo, para 32 bits de 2 a 4 GB.</target>
        </trans-unit>
        <trans-unit id="24e9bfdff99d8d81e72e86eb67d28dd9afa0f779" translate="yes" xml:space="preserve">
          <source>As mentioned, heap and stack are general terms, and can be implemented in many ways.  Computer programs typically have a stack called a &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_stack&quot;&gt;call stack&lt;/a&gt; which stores information relevant to the current function such as a pointer to whichever function it was called from, and any local variables.  Because functions call other functions and then return, the stack grows and shrinks to hold information from the functions further down the call stack.  A program doesn't really have runtime control over it; it's determined by the programming language, OS and even the system architecture.</source>
          <target state="translated">Como se mencion&amp;oacute;, heap y stack son t&amp;eacute;rminos generales, y se pueden implementar de muchas maneras. Los programas de computadora generalmente tienen una pila llamada pila de llamadas que almacena informaci&amp;oacute;n relevante para la funci&amp;oacute;n actual, como un puntero a la funci&amp;oacute;n desde la que se llam&amp;oacute;, y cualquier variable local. Debido a que las funciones llaman a otras funciones y luego regresan, la pila crece y se contrae para contener informaci&amp;oacute;n de las funciones m&amp;aacute;s abajo en la pila de llamadas. Un programa realmente no tiene control de tiempo de ejecuci&amp;oacute;n sobre &amp;eacute;l; est&amp;aacute; determinado por el lenguaje de programaci&amp;oacute;n, el sistema operativo e incluso la arquitectura del sistema.</target>
        </trans-unit>
        <trans-unit id="2df8df4816fd4ed74f3ebc71f597979521860d83" translate="yes" xml:space="preserve">
          <source>As the heap grows new blocks are often allocated from lower addresses towards higher addresses. Thus you can think of the heap as a &lt;em&gt;heap&lt;/em&gt; of memory blocks that grows in size as memory is allocated. If the heap is too small for an allocation the size can often be increased by acquiring more memory from the underlying operating system.</source>
          <target state="translated">A medida que crece el mont&amp;oacute;n, a menudo se asignan nuevos bloques desde direcciones m&amp;aacute;s bajas hacia direcciones m&amp;aacute;s altas. Por lo tanto, puede pensar en el mont&amp;oacute;n como un &lt;em&gt;mont&amp;oacute;n&lt;/em&gt; de bloques de memoria que crece en tama&amp;ntilde;o a medida que se asigna la memoria. Si el mont&amp;oacute;n es demasiado peque&amp;ntilde;o para una asignaci&amp;oacute;n, el tama&amp;ntilde;o a menudo se puede aumentar adquiriendo m&amp;aacute;s memoria del sistema operativo subyacente.</target>
        </trans-unit>
        <trans-unit id="50556eca9ce5726de27e85d02f2175c0f224c952" translate="yes" xml:space="preserve">
          <source>As the stack is a limited block of memory, you can cause a &lt;em&gt;stack overflow&lt;/em&gt; by calling too many nested functions and/or allocating too much space for local variables. Often the memory area used for the stack is set up in such a way that writing below the bottom (the lowest address) of the stack will trigger a trap or exception in the CPU. This exceptional condition can then be caught by the runtime and converted into some kind of stack overflow exception.</source>
          <target state="translated">Como la pila es un bloque de memoria limitado, puede provocar un &lt;em&gt;desbordamiento de la pila&lt;/em&gt; al invocar demasiadas funciones anidadas y / o asignar demasiado espacio para variables locales. A menudo, el &amp;aacute;rea de memoria utilizada para la pila est&amp;aacute; configurada de tal manera que escribir debajo de la parte inferior (la direcci&amp;oacute;n m&amp;aacute;s baja) de la pila desencadenar&amp;aacute; una trampa o excepci&amp;oacute;n en la CPU. El tiempo de ejecuci&amp;oacute;n puede detectar esta condici&amp;oacute;n excepcional y convertirla en alg&amp;uacute;n tipo de excepci&amp;oacute;n de desbordamiento de pila.</target>
        </trans-unit>
        <trans-unit id="b215c6f533c85e53fa09d968e37f28f9d39f9d4b" translate="yes" xml:space="preserve">
          <source>At run-time, if the application needs more heap, it can allocate memory from free memory and if the stack needs memory, it can allocate memory from free memory allocated memory for the application.</source>
          <target state="translated">En el momento de la ejecución,si la aplicación necesita más cantidad,puede asignar memoria de la memoria libre y si la pila necesita memoria,puede asignar memoria de la memoria libre asignada para la aplicación.</target>
        </trans-unit>
        <trans-unit id="54b26119365b1389f21ece7a4adac459e7df78fd" translate="yes" xml:space="preserve">
          <source>Because the different threads share the heap in a multi-threaded application, this also means that there has to be some coordination between the threads so that they don&amp;rsquo;t try to access and manipulate the same piece(s) of memory in the heap at the same time.</source>
          <target state="translated">Debido a que los diferentes subprocesos comparten el mont&amp;oacute;n en una aplicaci&amp;oacute;n de subprocesos m&amp;uacute;ltiples, esto tambi&amp;eacute;n significa que debe haber cierta coordinaci&amp;oacute;n entre los subprocesos para que no intenten acceder y manipular las mismas piezas de memoria en el mont&amp;oacute;n en al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="ccbbb8bb2cb5a86ca4310f5e73a45cd3c134e32e" translate="yes" xml:space="preserve">
          <source>Because the stack is small, you would want to use it when you know exactly how much memory you will need for your data, or if you know the size of your data is very small.</source>
          <target state="translated">Debido a que la pila es pequeña,querrías usarla cuando sepas exactamente cuánta memoria necesitarás para tus datos,o si sabes que el tamaño de tus datos es muy pequeño.</target>
        </trans-unit>
        <trans-unit id="85af045b5af1615c35dbbd47456bb468389824a3" translate="yes" xml:space="preserve">
          <source>Because you've allocated the stack before launching the program, you never need to malloc before you can use the stack, so that's a slight advantage there.  In practice, it's very hard to predict what will be fast and what will be slow in modern operating systems that have virtual memory subsystems, because how the pages are implemented and where they are stored is an implementation detail.</source>
          <target state="translated">Como has asignado la pila antes de lanzar el programa,nunca necesitas mallocalizar antes de poder usar la pila,así que eso es una ligera ventaja.En la práctica,es muy difícil predecir qué será rápido y qué será lento en los sistemas operativos modernos que tienen subsistemas de memoria virtual,porque cómo se implementan las páginas y dónde se almacenan es un detalle de la implementación.</target>
        </trans-unit>
        <trans-unit id="a1789265dfb7f69ad43a9c93ac040821d26c1139" translate="yes" xml:space="preserve">
          <source>Both the stack and the heap are memory areas allocated from the underlying operating system (often virtual memory that is mapped to physical memory on demand).</source>
          <target state="translated">Tanto la pila como el montón son áreas de memoria asignadas del sistema operativo subyacente (a menudo memoria virtual que se asigna a la memoria física a petición).</target>
        </trans-unit>
        <trans-unit id="74ded9b65c26de9b34aafae7449e1393446d30f8" translate="yes" xml:space="preserve">
          <source>Can a function be allocated on the heap instead of a stack?</source>
          <target state="translated">¿Se puede asignar una función en el montón en lugar de una pila?</target>
        </trans-unit>
        <trans-unit id="5812990e8a5f0104b222e128474fb28611af16f1" translate="yes" xml:space="preserve">
          <source>Can have a stack overflow when too much of the stack is used (mostly from infinite or too deep recursion, very large allocations).</source>
          <target state="translated">Puede tener un desbordamiento de la pila cuando se utiliza demasiada cantidad de la misma (en su mayoría de una recursividad infinita o demasiado profunda,asignaciones muy grandes).</target>
        </trans-unit>
        <trans-unit id="965cae31b330377a8052d9fde41cc56a8629759e" translate="yes" xml:space="preserve">
          <source>Can have allocation failures if too big of a buffer is requested to be allocated.</source>
          <target state="translated">Puede tener fallas de asignación si se solicita la asignación de un buffer demasiado grande.</target>
        </trans-unit>
        <trans-unit id="1c8dd66e84903a898b8ce09b004e11d5dd348f81" translate="yes" xml:space="preserve">
          <source>Can have fragmentation when there are a lot of allocations and deallocations.</source>
          <target state="translated">Puede haber fragmentación cuando hay muchas asignaciones y distribuciones.</target>
        </trans-unit>
        <trans-unit id="57ed76834f319ea80eb97efad57dfda743be40d9" translate="yes" xml:space="preserve">
          <source>Creating Objects on the Stack and Heap</source>
          <target state="translated">Creando objetos en la pila y el montón</target>
        </trans-unit>
        <trans-unit id="3c85e89113521a7aade115de0029e8e2378f88c7" translate="yes" xml:space="preserve">
          <source>Data created on the stack can be used without pointers.</source>
          <target state="translated">Los datos creados en la pila pueden ser usados sin punteros.</target>
        </trans-unit>
        <trans-unit id="10b6d2f5365d704078f50dcd64eef839102a1ac7" translate="yes" xml:space="preserve">
          <source>Deallocating the stack is pretty simple because you always deallocate in the reverse order in which you allocate. Stack stuff is added as you enter functions, the corresponding data is removed as you exit them. This means that you tend to stay within a small region of the stack unless you call lots of functions that call lots of other functions (or create a recursive solution).</source>
          <target state="translated">Repartir la pila es bastante simple porque siempre se reparte en el orden inverso al que se reparte.Las cosas de la pila se añaden a medida que se introducen las funciones,los datos correspondientes se eliminan al salir de ellas.Esto significa que tiendes a quedarte dentro de una pequeña región de la pila a menos que llames a muchas funciones que llamen a muchas otras funciones (o crees una solución recursiva).</target>
        </trans-unit>
        <trans-unit id="2e6efb7de0e3b1a967b575cd00a39178bc6cda79" translate="yes" xml:space="preserve">
          <source>Details can be found from &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/161053/which-is-faster-stack-allocation-or-heap-allocation&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">Los detalles se pueden encontrar desde &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/161053/which-is-faster-stack-allocation-or-heap-allocation&quot;&gt;aqu&amp;iacute;&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3454116b814c4a540b1fa2eaa28b022a062afd97" translate="yes" xml:space="preserve">
          <source>Don't have to explicitly de-allocate variables</source>
          <target state="translated">No tienes que des-asignar explícitamente las variables</target>
        </trans-unit>
        <trans-unit id="0060cdcb4b02afd4a89a6475ecd1acc3d319f929" translate="yes" xml:space="preserve">
          <source>Due to sequential storage in stack, execution is faster. Storage in heap would have resulted in huge time consumption thus making the whole program execute slower.</source>
          <target state="translated">Debido al almacenamiento secuencial en pila,la ejecución es más rápida.El almacenamiento en pila habría resultado en un enorme consumo de tiempo haciendo así que todo el programa se ejecute más lentamente.</target>
        </trans-unit>
        <trans-unit id="f04d90ff7dea8c8dc11581ddfc938b88076014c3" translate="yes" xml:space="preserve">
          <source>Dynamically created variables are stored here, which later requires freeing the allocated memory after use.</source>
          <target state="translated">Aquí se almacenan las variables creadas dinámicamente,lo que posteriormente requiere liberar la memoria asignada después de su uso.</target>
        </trans-unit>
        <trans-unit id="846279cf02a7a28e2eaddba31c218b6c4f28b95f" translate="yes" xml:space="preserve">
          <source>Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation).</source>
          <target state="translated">Cada hilo se apila,mientras que normalmente sólo hay un montón para la aplicación (aunque no es raro tener varios montones para diferentes tipos de asignación).</target>
        </trans-unit>
        <trans-unit id="5e929f13154e75203839bfc2de286aa0a1a47dcc" translate="yes" xml:space="preserve">
          <source>Even, more detail is given &lt;a href=&quot;http://net-informations.com/faq/net/stack-heap.htm&quot;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html&quot;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">Incluso, se dan m&amp;aacute;s detalles &lt;a href=&quot;http://net-informations.com/faq/net/stack-heap.htm&quot;&gt;&lt;strong&gt;aqu&amp;iacute;&lt;/strong&gt;&lt;/a&gt; y &lt;a href=&quot;http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html&quot;&gt;&lt;strong&gt;aqu&amp;iacute;&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4077dc49f1766565dde4b0c98c71c99d05d1cf12" translate="yes" xml:space="preserve">
          <source>Every time an object is instantiated, a chunk of heap memory is set aside to hold the data (state) of that object. Since objects can contain other objects, some of this data can in fact hold references to those nested objects.</source>
          <target state="translated">Cada vez que un objeto se instancializa,se reserva un trozo de memoria para guardar los datos (estado)de ese objeto.Dado que los objetos pueden contener otros objetos,algunos de estos datos pueden de hecho contener referencias a esos objetos anidados.</target>
        </trans-unit>
        <trans-unit id="5211deda8670661ee7d1ce34e2735da4431ad6c2" translate="yes" xml:space="preserve">
          <source>Fibers proposal to the C++ standard library is forthcoming. Also, there're some third-party &lt;a href=&quot;https://stackoverflow.com/questions/1285714/lightweight-portable-c-fibers-mit-license&quot;&gt;libraries&lt;/a&gt;. Green threads are extremely popular in languages like Python and Ruby.</source>
          <target state="translated">La propuesta de fibras para la biblioteca est&amp;aacute;ndar de C ++ est&amp;aacute; pr&amp;oacute;xima. Adem&amp;aacute;s, hay algunas &lt;a href=&quot;https://stackoverflow.com/questions/1285714/lightweight-portable-c-fibers-mit-license&quot;&gt;bibliotecas de&lt;/a&gt; terceros. Los hilos verdes son extremadamente populares en lenguajes como Python y Ruby.</target>
        </trans-unit>
        <trans-unit id="6bf6a0d4778960ac1e375eed1f1e9f0d010f59b1" translate="yes" xml:space="preserve">
          <source>Fibers, green threads and coroutines are in many ways similar, which leads to much confusion.  The difference between fibers and green threads is that the former use cooperative multitasking, while the latter may feature either cooperative or preemptive one (or even both). For the distinction between fibers and coroutines, see &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Las fibras, los hilos verdes y las corutinas son similares en muchos aspectos, lo que genera mucha confusi&amp;oacute;n. La diferencia entre las fibras y los hilos verdes es que los primeros usan la multitarea cooperativa, mientras que los segundos pueden presentar uno cooperativo o preventivo (o incluso ambos). Para la distinci&amp;oacute;n entre fibras y corutinas, vea &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d2ac197a7a104bcd6641f6a118e10124e3a8763" translate="yes" xml:space="preserve">
          <source>For people new to programming, it&amp;rsquo;s probably a good idea to use the stack since it&amp;rsquo;s easier.</source>
          <target state="translated">Para las personas nuevas en la programaci&amp;oacute;n, probablemente sea una buena idea usar la pila, ya que es m&amp;aacute;s f&amp;aacute;cil.</target>
        </trans-unit>
        <trans-unit id="d9bf6ea4d7dd59b322b7679e48bc374e1b2878a5" translate="yes" xml:space="preserve">
          <source>Fragmentation occurs when memory objects are allocated with small spaces in between that are too small to hold additional memory objects.</source>
          <target state="translated">La fragmentación se produce cuando se asignan objetos de memoria con pequeños espacios intermedios demasiado pequeños para albergar objetos de memoria adicionales.</target>
        </trans-unit>
        <trans-unit id="e237e4dadd747be21907ecdd643773f2cded6948" translate="yes" xml:space="preserve">
          <source>From WikiAnwser.</source>
          <target state="translated">De WikiAnwser.</target>
        </trans-unit>
        <trans-unit id="4e3b5b95822a6480a6ed4d32a309c404a4c107f7" translate="yes" xml:space="preserve">
          <source>Function calls are loaded here along with the local variables and function parameters passed.</source>
          <target state="translated">Las llamadas de función se cargan aquí junto con las variables locales y los parámetros de función pasados.</target>
        </trans-unit>
        <trans-unit id="977169a2f56615065497cd1735f54129679d50ec" translate="yes" xml:space="preserve">
          <source>Heap</source>
          <target state="translated">Heap</target>
        </trans-unit>
        <trans-unit id="69c0fce84d3be50b555c1e7c6c0ace50232978e0" translate="yes" xml:space="preserve">
          <source>Heap allocation requires maintaining a full record of what memory is allocated and what isn't, as well as some overhead maintenance to reduce fragmentation, find contiguous memory segments big enough to fit the requested size, and so on.  Memory can be deallocated at any time leaving free space.  Sometimes a memory allocator will perform maintenance tasks such as defragmenting memory by moving allocated memory around, or garbage collecting - identifying at runtime when memory is no longer in scope and deallocating it.</source>
          <target state="translated">La asignación de memoria requiere mantener un registro completo de qué memoria está asignada y cuál no,así como algún mantenimiento de la sobrecarga para reducir la fragmentación,encontrar segmentos de memoria contiguos lo suficientemente grandes para ajustarse al tamaño solicitado,y así sucesivamente.La memoria puede ser reasignada en cualquier momento dejando espacio libre.A veces un asignador de memoria realizará tareas de mantenimiento como desfragmentar la memoria moviendo la memoria asignada de un lado a otro,o recolectar basura-identificando en tiempo de ejecución cuando la memoria ya no está en alcance y desasociándola.</target>
        </trans-unit>
        <trans-unit id="6df8f5905a52242ce08ad912e0566230705e916f" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a super-short summary: The stack is essentially an
  easy-to-access memory that simply manages its items as a - well -
  stack. Only items for which the size is known in advance can go onto
  the stack. This is the case for numbers, strings, booleans.</source>
          <target state="translated">Aqu&amp;iacute; hay un resumen s&amp;uacute;per corto: la pila es esencialmente una memoria de f&amp;aacute;cil acceso que simplemente administra sus elementos como una pila, bueno. Solo los art&amp;iacute;culos cuyo tama&amp;ntilde;o se conoce de antemano pueden ir a la pila. Este es el caso de n&amp;uacute;meros, cadenas, booleanos.</target>
        </trans-unit>
        <trans-unit id="c4ad91f43c7e132c0c64e796c08f23caf41b0111" translate="yes" xml:space="preserve">
          <source>Here's how the memory is managed</source>
          <target state="translated">Así es como se gestiona la memoria</target>
        </trans-unit>
        <trans-unit id="bf4cd344a404d07f4320ed2b8128bc0699d576ee" translate="yes" xml:space="preserve">
          <source>How the heap is managed is really up to the runtime environment. C uses &lt;code&gt;malloc&lt;/code&gt; and C++ uses &lt;code&gt;new&lt;/code&gt;, but many other languages have garbage collection.</source>
          <target state="translated">La forma en que se gestiona el mont&amp;oacute;n depende realmente del entorno de tiempo de ejecuci&amp;oacute;n. C usa &lt;code&gt;malloc&lt;/code&gt; y C ++ usa &lt;code&gt;new&lt;/code&gt; , pero muchos otros lenguajes tienen recolecci&amp;oacute;n de basura.</target>
        </trans-unit>
        <trans-unit id="e6d9adabdb8c7c013e5c6cedd3fd35a30646fc45" translate="yes" xml:space="preserve">
          <source>However, it is generally better to consider &quot;&lt;strong&gt;scope&lt;/strong&gt;&quot; and &quot;&lt;strong&gt;lifetime&lt;/strong&gt;&quot; rather than &quot;stack&quot; and &quot;heap&quot;.</source>
          <target state="translated">Sin embargo, generalmente es mejor considerar &quot; &lt;strong&gt;alcance&lt;/strong&gt; &quot; y &quot; &lt;strong&gt;duraci&amp;oacute;n&lt;/strong&gt; &quot; en lugar de &quot;apilar&quot; y &quot;mont&amp;oacute;n&quot;.</target>
        </trans-unit>
        <trans-unit id="aed2fb7f74c3443670e7a902fd753397a138bf75" translate="yes" xml:space="preserve">
          <source>However, the stack is a more low-level feature closely tied to the processor architecture. Growing the heap when there is not enough space isn't too hard since it can be implemented in the library call that handles the heap. However, growing the stack is often impossible as the stack overflow only is discovered when it is too late; and shutting down the thread of execution is the only viable option.</source>
          <target state="translated">Sin embargo,la pila es una característica de nivel más bajo estrechamente ligada a la arquitectura del procesador.Hacer crecer el montón cuando no hay suficiente espacio no es muy difícil ya que puede implementarse en la llamada de biblioteca que maneja el montón.Sin embargo,hacer crecer la pila suele ser imposible,ya que el desbordamiento de la pila sólo se descubre cuando ya es demasiado tarde;y apagar el hilo de ejecución es la única opción viable.</target>
        </trans-unit>
        <trans-unit id="369a9b90a4bdfde4e85ad68cde3ff685aa91dd1f" translate="yes" xml:space="preserve">
          <source>I also create the image below to show how they may look like:</source>
          <target state="translated">También he creado la siguiente imagen para mostrar cómo pueden ser:</target>
        </trans-unit>
        <trans-unit id="b6b70f6bfb4b2dfbc4a60602e806084366a63de7" translate="yes" xml:space="preserve">
          <source>I have something to share, although the major points are already covered.</source>
          <target state="translated">Tengo algo que compartir,aunque los puntos principales ya están cubiertos.</target>
        </trans-unit>
        <trans-unit id="9c1b11110bea9796fff4f2aa43b42de19c50096d" translate="yes" xml:space="preserve">
          <source>I think many other people have given you mostly correct answers on this matter.</source>
          <target state="translated">Creo que muchas otras personas le han dado respuestas mayormente correctas en este asunto.</target>
        </trans-unit>
        <trans-unit id="f84b830b40010139bb2bc50481c768d543c9849a" translate="yes" xml:space="preserve">
          <source>I will provide some simple annotated C code to illustrate all of this. The best way to learn is to run a program under a debugger and watch the behavior. If you prefer to read python, skip to the end of the answer :)</source>
          <target state="translated">Le proporcionaré un simple código C anotado para ilustrar todo esto.La mejor manera de aprender es ejecutar un programa bajo un depurador y observar el comportamiento.Si prefieres leer pitón,salta al final de la respuesta :)</target>
        </trans-unit>
        <trans-unit id="19be6ca3ce7acb355b8593c36bbe51f806cb3467" translate="yes" xml:space="preserve">
          <source>If a function has parameters, these are pushed onto the stack before the call to the function. The code in the function is then able to navigate up the stack from the current stack pointer to locate these values.</source>
          <target state="translated">Si una función tiene parámetros,estos se empujan a la pila antes de la llamada a la función.El código de la función es entonces capaz de navegar por la pila desde el puntero de la pila actual para localizar estos valores.</target>
        </trans-unit>
        <trans-unit id="d6fd840c486fd422511fccb949147762c4da1fa6" translate="yes" xml:space="preserve">
          <source>If functions were stored in heap (messy storage pointed by pointer), there would have been no way to return to the caller address back (which stack gives due to sequential storage in memory).</source>
          <target state="translated">Si las funciones se hubieran almacenado en heap (almacenamiento desordenado apuntado por un puntero),no habría habido manera de volver a la dirección del llamante (que la pila da debido al almacenamiento secuencial en la memoria).</target>
        </trans-unit>
        <trans-unit id="582e735b7a23d77b1a919b1c33ed8aa128f12765" translate="yes" xml:space="preserve">
          <source>If the private heap gets too large it will overlap the stack area, as will the stack overlap the heap if it gets too big. Because the stack starts at a higher address and works its way down to lower address, with proper hacking you can get make the stack so large that it will overrun the private heap area and overlap the code area. The trick then is to overlap enough of the code area that you can hook into the code. It's a little tricky to do and you risk a program crash, but it's easy and very effective.</source>
          <target state="translated">Si el montón privado se hace demasiado grande,se superpondrá al área de la pila,así como la pila se superpondrá al montón si se hace demasiado grande.Debido a que la pila comienza en una dirección más alta y va bajando hasta una dirección más baja,con un hackeo adecuado puedes hacer que la pila sea tan grande que sobrepase el área del montón privado y se superponga al área de código.El truco entonces es superponer lo suficiente del área de código que puedes enganchar en el código.Es un poco difícil de hacer y te arriesgas a que el programa se caiga,pero es fácil y muy efectivo.</target>
        </trans-unit>
        <trans-unit id="8164de7b8275fe6bd6610a9f1a1f510df9d0953d" translate="yes" xml:space="preserve">
          <source>If you fail to do this, your program will have what is known as a memory leak. That is, memory on the heap will still be set aside (and won't be available to other processes). As we will see in the debugging section, there is a tool called &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt; that can help you detect memory leaks.</source>
          <target state="translated">Si no lo hace, su programa tendr&amp;aacute; lo que se conoce como p&amp;eacute;rdida de memoria. Es decir, la memoria en el mont&amp;oacute;n a&amp;uacute;n se reservar&amp;aacute; (y no estar&amp;aacute; disponible para otros procesos). Como veremos en la secci&amp;oacute;n de depuraci&amp;oacute;n, hay una herramienta llamada &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt; que puede ayudarlo a detectar p&amp;eacute;rdidas de memoria.</target>
        </trans-unit>
        <trans-unit id="5d14809b020f6dc3b1ca1b516594f7c26711d489" translate="yes" xml:space="preserve">
          <source>Implemented with an actual stack data structure.</source>
          <target state="translated">Implementado con una estructura de datos de pila real.</target>
        </trans-unit>
        <trans-unit id="0ec9c44eba796de6b3f45bf5b3038e9e98f84fe1" translate="yes" xml:space="preserve">
          <source>In &quot;classic&quot; systems RAM was laid out such that the stack pointer started out at the bottom of memory, the heap pointer started out at the top, and they grew towards each other. If they overlap, you are out of RAM. That doesn't work with modern multi-threaded OSes though. Every thread has to have its own stack, and those can get created dynamicly.</source>
          <target state="translated">En los sistemas &quot;clásicos&quot; la memoria RAM estaba dispuesta de tal manera que el puntero de pila empezaba en la parte inferior de la memoria,el puntero de pila empezaba en la parte superior,y crecían uno hacia el otro.Si se superponen,te quedas sin memoria RAM.Sin embargo,eso no funciona con los modernos sistemas operativos multi-hilo.Cada hilo tiene que tener su propia pila,y esos pueden ser creados dinámicamente.</target>
        </trans-unit>
        <trans-unit id="9595be1b961175468df336b7cd57107f6d9e6d67" translate="yes" xml:space="preserve">
          <source>In C you can get the benefit of variable length allocation through the use of &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?alloca&quot;&gt;alloca&lt;/a&gt;, which allocates on the stack, as opposed to alloc, which allocates on the heap. This memory won't survive your return statement, but it's useful for a scratch buffer.</source>
          <target state="translated">En C puede obtener el beneficio de la asignaci&amp;oacute;n de longitud variable mediante el uso de &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?alloca&quot;&gt;alloca&lt;/a&gt; , que asigna en la pila, en lugar de alloc, que asigna en el mont&amp;oacute;n. Esta memoria no sobrevivir&amp;aacute; a su declaraci&amp;oacute;n de devoluci&amp;oacute;n, pero es &amp;uacute;til para un b&amp;uacute;fer de memoria virtual.</target>
        </trans-unit>
        <trans-unit id="4c49c1e042066fcde12cf790d1255e5d4128c6ed" translate="yes" xml:space="preserve">
          <source>In C++ or C, data created on the heap will be pointed to by pointers and allocated with &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt; respectively.</source>
          <target state="translated">En C ++ o C, los datos creados en el mont&amp;oacute;n ser&amp;aacute;n se&amp;ntilde;alados por punteros y asignados con &lt;code&gt;new&lt;/code&gt; o &lt;code&gt;malloc&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="2dddb5409ddfb8bfae0332e6674cb30e4030c766" translate="yes" xml:space="preserve">
          <source>In C++, variables on the heap must be destroyed manually and never fall out of scope. The data is freed with &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;delete[]&lt;/code&gt;, or &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">En C ++, las variables en el mont&amp;oacute;n deben destruirse manualmente y nunca quedar fuera de alcance. Los datos se liberan con &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;delete[]&lt;/code&gt; o &lt;code&gt;free&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ab2e606ea24062674776c9630ae58f479fc3332" translate="yes" xml:space="preserve">
          <source>In Detail</source>
          <target state="translated">En detalle</target>
        </trans-unit>
        <trans-unit id="d070ed182c0710ddbb3f2b533e23ff5a60e665ff" translate="yes" xml:space="preserve">
          <source>In Java, most objects go directly into the heap. In languages like C / C++, structs and classes can often remain on the stack when you're not dealing with pointers.</source>
          <target state="translated">En Java,la mayoría de los objetos van directamente al montón.En lenguajes como C C++,las estructuras y clases pueden permanecer en la pila cuando no se trata de punteros.</target>
        </trans-unit>
        <trans-unit id="4f383e35971605d5e60dda592302a0dfbedde224" translate="yes" xml:space="preserve">
          <source>In Short</source>
          <target state="translated">En resumen</target>
        </trans-unit>
        <trans-unit id="5147749ca6668db2a2e89a21934367a8e767227a" translate="yes" xml:space="preserve">
          <source>In a heap, there is no particular order to the way items are placed.  You can reach in and remove items in any order because there is no clear 'top' item.</source>
          <target state="translated">En un montón,no hay un orden particular en la forma en que se colocan los artículos.Puedes meter y sacar los artículos en cualquier orden porque no hay un artículo claro &quot;superior&quot;.</target>
        </trans-unit>
        <trans-unit id="c178a8267cc3e47eec2a91c3a323a8fdc32c3e39" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, each thread will have its own stack.</source>
          <target state="translated">En una aplicación multi-hilo,cada hilo tendrá su propia pila.</target>
        </trans-unit>
        <trans-unit id="aea37718a1d7d897745b71fc7a069d9dac94a163" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, each thread will have its own stack. But, all the different threads will share the heap.</source>
          <target state="translated">En una aplicación multi-hilo,cada hilo tendrá su propia pila.Pero,todos los diferentes hilos compartirán el montón.</target>
        </trans-unit>
        <trans-unit id="bed80375d9899ce917d044e4b57acedb6c419964" translate="yes" xml:space="preserve">
          <source>In a multi-threaded environment each thread will have its own completely independent stack but they will share the heap. Concurrent access has to be controlled on the heap and is not possible on the stack.</source>
          <target state="translated">En un entorno multi-hilo,cada hilo tendrá su propia pila completamente independiente,pero compartirán el montón.El acceso simultáneo tiene que ser controlado en el montón y no es posible en la pila.</target>
        </trans-unit>
        <trans-unit id="2afdc75d76febc6978738ba0407aee2a8e1a2690" translate="yes" xml:space="preserve">
          <source>In a multi-threaded situation each thread will have its own completely independent stack, but they will share the heap. The stack is thread specific and the heap is application specific. The stack is important to consider in exception handling and thread executions.</source>
          <target state="translated">En una situación de múltiples hilos,cada uno de ellos tendrá su propia pila completamente independiente,pero compartirán el montón.La pila es específica para cada hilo y el montón es específico para cada aplicación.Es importante considerar la pila en el manejo de excepciones y en la ejecución de los hilos.</target>
        </trans-unit>
        <trans-unit id="3b5a4a1f69f2a44d7b973472f440395d38db3aef" translate="yes" xml:space="preserve">
          <source>In a stack of items, items sit one on top of the other in the order they were placed there, and you can only remove the top one (without toppling the whole thing over).</source>
          <target state="translated">En una pila de artículos,los artículos se sientan uno encima del otro en el orden en que fueron colocados allí,y sólo se puede quitar el de arriba (sin derribar todo el asunto).</target>
        </trans-unit>
        <trans-unit id="6de943cc8f12c5ab1e03aa49853e2f81f883c968" translate="yes" xml:space="preserve">
          <source>In any case, the purpose of both fibers, green threads and coroutines is having multiple functions executing concurrently, but &lt;strong&gt;not&lt;/strong&gt; in parallel (see &lt;a href=&quot;https://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&quot;&gt;this SO question&lt;/a&gt; for the distinction) within a single OS-level thread, transferring control back and forth from one another in an organized fashion.</source>
          <target state="translated">En cualquier caso, el prop&amp;oacute;sito de ambas fibras, hilos verdes y corutinas es tener m&amp;uacute;ltiples funciones ejecut&amp;aacute;ndose simult&amp;aacute;neamente, pero &lt;strong&gt;no&lt;/strong&gt; en paralelo (vea &lt;a href=&quot;https://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&quot;&gt;esta pregunta SO&lt;/a&gt; para la distinci&amp;oacute;n) dentro de un solo hilo a nivel del sistema operativo, transfiriendo el control de un lado a otro de manera organizada.</target>
        </trans-unit>
        <trans-unit id="6ff0d53ec18f38266dd0067ebeca5dc7b79c4307" translate="yes" xml:space="preserve">
          <source>In computing architectures the heap is an area of dynamically-allocated memory that is managed automatically by the operating system or the memory manager library.</source>
          <target state="translated">En las arquitecturas informáticas,el montón es un área de memoria asignada dinámicamente que es administrada automáticamente por el sistema operativo o la biblioteca del administrador de memoria.</target>
        </trans-unit>
        <trans-unit id="14147c40afba7195a6e743160146832b550785ac" translate="yes" xml:space="preserve">
          <source>In systems without virtual memory, such as some embedded systems, the same basic layout often applies, except the stack and heap are fixed in size. However, in other embedded systems (such as those based on Microchip PIC microcontrollers), the program stack is a separate block of memory that is not addressable by data movement instructions, and can only be modified or read indirectly through program flow instructions (call, return, etc.). Other architectures, such as Intel Itanium processors, have &lt;a href=&quot;http://blogs.msdn.com/oldnewthing/archive/2005/04/21/410397.aspx&quot;&gt;multiple stacks&lt;/a&gt;. In this sense, the stack is an element of the CPU architecture.</source>
          <target state="translated">En sistemas sin memoria virtual, como algunos sistemas integrados, a menudo se aplica el mismo dise&amp;ntilde;o b&amp;aacute;sico, excepto que la pila y el mont&amp;oacute;n son de tama&amp;ntilde;o fijo. Sin embargo, en otros sistemas integrados (como los basados ​​en microcontroladores PIC de Microchip), la pila de programas es un bloque de memoria separado que no es direccionable por las instrucciones de movimiento de datos, y solo puede modificarse o leerse indirectamente a trav&amp;eacute;s de las instrucciones de flujo del programa (llamada, volver, etc.). Otras arquitecturas, como los procesadores Intel Itanium, tienen &lt;a href=&quot;http://blogs.msdn.com/oldnewthing/archive/2005/04/21/410397.aspx&quot;&gt;m&amp;uacute;ltiples pilas&lt;/a&gt; . En este sentido, la pila es un elemento de la arquitectura de la CPU.</target>
        </trans-unit>
        <trans-unit id="9aec9cb3ea820b87a5cf73897d19e91456e49aff" translate="yes" xml:space="preserve">
          <source>In the 1980s, UNIX propagated like bunnies with big companies rolling their own.
Exxon had one as did dozens of brand names lost to history.
How memory was laid out was at the discretion of the many implementors.</source>
          <target state="translated">En la década de 1980,UNIX se propagó como conejos con grandes compañías que hacían rodar las suyas.Exxon tenía una,al igual que docenas de marcas perdidas en la historia.La forma en que la memoria fue establecida fue a discreción de los muchos implementadores.</target>
        </trans-unit>
        <trans-unit id="33565c031152b190e31e2e646c439179d7871e3f" translate="yes" xml:space="preserve">
          <source>In the following C# code</source>
          <target state="translated">En el siguiente código C#</target>
        </trans-unit>
        <trans-unit id="630247c43e13b3493c95ccf3dcf571c7304c4c8f" translate="yes" xml:space="preserve">
          <source>Is hardware, and even push/pop are very efficient.</source>
          <target state="translated">es el hardware,e incluso los pushpop son muy eficientes.</target>
        </trans-unit>
        <trans-unit id="fbec35b1fe092a0a42603acde06323d190983ce3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s better to use the heap when you know that you will need a lot of memory for your data, or you just are not sure how much memory you will need (like with a dynamic array).</source>
          <target state="translated">Es mejor usar el mont&amp;oacute;n cuando sabe que necesitar&amp;aacute; mucha memoria para sus datos, o simplemente no est&amp;aacute; seguro de cu&amp;aacute;nta memoria necesitar&amp;aacute; (como con una matriz din&amp;aacute;mica).</target>
        </trans-unit>
        <trans-unit id="457deb90d7d9b5e518927cf1c37ce9f9c8468ecf" translate="yes" xml:space="preserve">
          <source>Java Memory Model</source>
          <target state="translated">Modelo de memoria Java</target>
        </trans-unit>
        <trans-unit id="ffbbcf1f84185847b6720632d5f0dd4615871ac7" translate="yes" xml:space="preserve">
          <source>Lifetime refers to when a variable is allocated and deallocated during program execution. Usually we think of &lt;strong&gt;static allocation&lt;/strong&gt; (variable will persist through the entire duration of the program, making it useful for storing the same information across several function calls) versus &lt;strong&gt;automatic allocation&lt;/strong&gt; (variable only persists during a single call to a function, making it useful for storing information that is only used during your function and can be discarded once you are done) versus &lt;strong&gt;dynamic allocation&lt;/strong&gt; (variables whose duration is defined at runtime, instead of compile time like static or automatic).</source>
          <target state="translated">La duraci&amp;oacute;n se refiere a cuando una variable se asigna y se desasigna durante la ejecuci&amp;oacute;n del programa. Por lo general, pensamos en &lt;strong&gt;la asignaci&amp;oacute;n est&amp;aacute;tica&lt;/strong&gt; (la variable persistir&amp;aacute; durante toda la duraci&amp;oacute;n del programa, por lo que es &amp;uacute;til para almacenar la misma informaci&amp;oacute;n en varias llamadas de funci&amp;oacute;n) frente a &lt;strong&gt;la asignaci&amp;oacute;n autom&amp;aacute;tica&lt;/strong&gt; (la variable solo persiste durante una sola llamada a una funci&amp;oacute;n, por lo que es &amp;uacute;til para almacenar informaci&amp;oacute;n que solo se usa durante su funci&amp;oacute;n y puede descartarse una vez que haya terminado) versus &lt;strong&gt;asignaci&amp;oacute;n din&amp;aacute;mica&lt;/strong&gt; (variables cuya duraci&amp;oacute;n se define en tiempo de ejecuci&amp;oacute;n, en lugar de tiempo de compilaci&amp;oacute;n como est&amp;aacute;tico o autom&amp;aacute;tico).</target>
        </trans-unit>
        <trans-unit id="89eb38e39ee83b4afbd53d56ba3e811dd7e4c25b" translate="yes" xml:space="preserve">
          <source>Limit on stack size (OS-dependent)</source>
          <target state="translated">Límite del tamaño de la pila (depende del sistema operativo)</target>
        </trans-unit>
        <trans-unit id="e0b77457d171049e39cb59f6d0cc6e0aa958f4d7" translate="yes" xml:space="preserve">
          <source>Local variables only</source>
          <target state="translated">Sólo variables locales</target>
        </trans-unit>
        <trans-unit id="a7063db18651eedcd045e8b41c98ba145000f990" translate="yes" xml:space="preserve">
          <source>Making a huge temporary buffer on Windows that you don't use much of is not free. This is because the compiler will generate a stack probe loop that is called every time your function is entered to make sure the stack exists (because Windows uses a single guard page at the end of your stack to detect when it needs to grow the stack. If you access memory more than one page off the end of the stack you will crash). Example:</source>
          <target state="translated">La creación de un enorme búfer temporal en Windows del que no se usa mucho no es gratuita.Esto se debe a que el compilador generará un bucle de prueba de la pila que se llama cada vez que se introduce la función para asegurarse de que la pila existe (porque Windows usa una sola página de guardia al final de la pila para detectar cuándo necesita hacer crecer la pila.Si accede a la memoria a más de una página del final de la pila,se bloqueará).Ejemplo:</target>
        </trans-unit>
        <trans-unit id="ca52649198f4fcd9db011db1f93bf7a0fbf8fc6f" translate="yes" xml:space="preserve">
          <source>Memory on the heap is allocated, deallocated, and resized regularly during program execution, and this can lead to a problem called fragmentation.</source>
          <target state="translated">La memoria en el montón es asignada,distribuida y redimensionada regularmente durante la ejecución del programa,y esto puede llevar a un problema llamado fragmentación.</target>
        </trans-unit>
        <trans-unit id="92fa2b03cecd0df74b8828996b6d8dbd49f2c6f2" translate="yes" xml:space="preserve">
          <source>More can be found &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">M&amp;aacute;s se puede encontrar &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management&quot;&gt;aqu&amp;iacute;&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2be48705642c1c2849cd129948c17459949f6ab7" translate="yes" xml:space="preserve">
          <source>More can be found &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_(abstract_data_type)&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">M&amp;aacute;s se puede encontrar &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_(abstract_data_type)&quot;&gt;aqu&amp;iacute;&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cd2086a7c7de1d63c092402cee2278afc2a9fcb4" translate="yes" xml:space="preserve">
          <source>More can be found &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">M&amp;aacute;s se puede encontrar &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113&quot;&gt;aqu&amp;iacute;&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ff90893ecc13cc33b31a0c7ba89530291adf207c" translate="yes" xml:space="preserve">
          <source>More can be found in &lt;a href=&quot;https://stackoverflow.com/questions/408670/stack-static-and-heap-in-c&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">M&amp;aacute;s se puede encontrar &lt;a href=&quot;https://stackoverflow.com/questions/408670/stack-static-and-heap-in-c&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d87631c079431a997cdc54c230389a89f964ee05" translate="yes" xml:space="preserve">
          <source>More information can be found here:</source>
          <target state="translated">Más información puede ser encontrada aquí:</target>
        </trans-unit>
        <trans-unit id="daed2813a5860321bea40be47381eb4727e55905" translate="yes" xml:space="preserve">
          <source>Much faster to allocate in comparison to variables on the heap.</source>
          <target state="translated">Mucho más rápido de asignar en comparación con las variables del montón.</target>
        </trans-unit>
        <trans-unit id="611a2d27ec35591a9d1a945571bf2c19006fe525" translate="yes" xml:space="preserve">
          <source>Nesting function calls work like a charm. Each new call will allocate function parameters, the return address and space for local variables and these &lt;em&gt;activation records&lt;/em&gt; can be stacked for nested calls and will unwind in the correct way when the functions return.</source>
          <target state="translated">Las funciones de anidamiento funcionan como un encanto. Cada nueva llamada asignar&amp;aacute; par&amp;aacute;metros de funci&amp;oacute;n, la direcci&amp;oacute;n de retorno y el espacio para variables locales y estos &lt;em&gt;registros de activaci&amp;oacute;n&lt;/em&gt; se pueden apilar para llamadas anidadas y se desenrollar&amp;aacute;n de la manera correcta cuando las funciones regresen.</target>
        </trans-unit>
        <trans-unit id="f5f359ca9a7c1ab08f498e157e0409d9d76c46da" translate="yes" xml:space="preserve">
          <source>No guaranteed efficient use of space, memory may become fragmented over time as blocks of memory are allocated, then freed</source>
          <target state="translated">No se garantiza el uso eficiente del espacio,la memoria puede fragmentarse con el tiempo a medida que se asignan bloques de memoria y luego se liberan</target>
        </trans-unit>
        <trans-unit id="15c9ee58559d66b5b15a6a82aa330160c95db8c1" translate="yes" xml:space="preserve">
          <source>No limit on memory size</source>
          <target state="translated">No hay límite en el tamaño de la memoria</target>
        </trans-unit>
        <trans-unit id="50b9533f7ca93c1b7165a50cb0b44b0cfb20fb35" translate="yes" xml:space="preserve">
          <source>No, activation records for functions (i.e. local or automatic variables) are allocated on the stack that is used not only to store these variables, but also to keep track of nested function calls.</source>
          <target state="translated">No,los registros de activación de las funciones (es decir,las variables locales o automáticas)se asignan en la pila que se utiliza no sólo para almacenar esas variables,sino también para hacer un seguimiento de las llamadas a funciones anidadas.</target>
        </trans-unit>
        <trans-unit id="4ab51a7f5c3504c0459c4e33aa2f1830407e1fa5" translate="yes" xml:space="preserve">
          <source>Note that I said &quot;&lt;em&gt;usually&lt;/em&gt; have a separate stack per function&quot;. There're both &lt;em&gt;stackful&lt;/em&gt; and &lt;em&gt;stackless&lt;/em&gt; implementations of couroutines. Most notable stackful C++ implementations are &lt;a href=&quot;http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.html&quot;&gt;Boost.Coroutine&lt;/a&gt; and &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd492418.aspx&quot;&gt;Microsoft PPL&lt;/a&gt;'s &lt;code&gt;async/await&lt;/code&gt;. (However, C++'s &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4134.pdf&quot;&gt;resumable functions&lt;/a&gt; (a.k.a. &quot;&lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;&quot;), which were proposed to C++17, are likely to use stackless coroutines.)</source>
          <target state="translated">Tenga en cuenta que dije &quot; &lt;em&gt;generalmente&lt;/em&gt; tengo una pila separada por funci&amp;oacute;n&quot;. Hay implementaciones &lt;em&gt;apiladas&lt;/em&gt; y &lt;em&gt;apiladas&lt;/em&gt; de couroutines. Las implementaciones &lt;a href=&quot;http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.html&quot;&gt;apiladas&lt;/a&gt; m&amp;aacute;s notables de C ++ son Boost.Coroutine y &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd492418.aspx&quot;&gt;Microsoft PPL&lt;/a&gt; ' &lt;code&gt;async/await&lt;/code&gt; . (Sin embargo, es probable que las &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4134.pdf&quot;&gt;funciones reanudables de&lt;/a&gt; C ++ (tambi&amp;eacute;n conocidas como &quot; &lt;code&gt;async&lt;/code&gt; y &lt;code&gt;await&lt;/code&gt; &quot;), que se propusieron para C ++ 17, utilicen rutinas sin pila.</target>
        </trans-unit>
        <trans-unit id="d2cf9d062fe2a4c663f0c8c2cedd3fc551bc3d7a" translate="yes" xml:space="preserve">
          <source>Note that putting the keyword &quot;static&quot; in the declaration above prevents var2 from having global scope. Nevertheless, the global var1 has static allocation. This is not intuitive! For this reason, I try to never use the word &quot;static&quot; when describing scope, and instead say something like &quot;file&quot; or &quot;file limited&quot; scope. However many people use the phrase &quot;static&quot; or &quot;static scope&quot; to describe a variable that can only be accessed from one code file. In the context of lifetime, &quot;static&quot; &lt;em&gt;always&lt;/em&gt; means the variable is allocated at program start and deallocated when program exits.</source>
          <target state="translated">Tenga en cuenta que poner la palabra clave &quot;static&quot; en la declaraci&amp;oacute;n anterior evita que var2 tenga un alcance global. Sin embargo, la var1 global tiene asignaci&amp;oacute;n est&amp;aacute;tica. &amp;iexcl;Esto no es intuitivo! Por esta raz&amp;oacute;n, trato de nunca usar la palabra &quot;est&amp;aacute;tica&quot; al describir el alcance, y en su lugar digo algo como &quot;archivo&quot; o &quot;archivo limitado&quot;. Sin embargo, muchas personas usan la frase &quot;est&amp;aacute;tica&quot; o &quot;alcance est&amp;aacute;tico&quot; para describir una variable a la que solo se puede acceder desde un archivo de c&amp;oacute;digo. En el contexto de la vida &amp;uacute;til, &quot;est&amp;aacute;tico&quot; &lt;em&gt;siempre&lt;/em&gt; significa que la variable se asigna al inicio del programa y se desasigna cuando el programa sale.</target>
        </trans-unit>
        <trans-unit id="0871b21874420432475c6d4351849b35d915057f" translate="yes" xml:space="preserve">
          <source>Now come to &lt;strong&gt;your question's answers&lt;/strong&gt;.</source>
          <target state="translated">Ahora ve a &lt;strong&gt;las respuestas de tu pregunta&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="74c615a4a42b31624f1cc296011324866cfe8b77" translate="yes" xml:space="preserve">
          <source>Objects (which vary in size as we update them) go on the heap because we don't know at creation time how long they are going to last. In many languages the heap is garbage collected to find objects (such as the cls1 object) that no longer have any references.</source>
          <target state="translated">Los objetos (que varían en tamaño a medida que los actualizamos)van en el montón porque no sabemos en el momento de la creación cuánto tiempo van a durar.En muchos idiomas el montón es basura recogida para encontrar objetos (como el objeto cls1)que ya no tienen referencias.</target>
        </trans-unit>
        <trans-unit id="e4fe13843a3ecc800429114b92b44c8d355d6bed" translate="yes" xml:space="preserve">
          <source>On the stack you save return addresses and call &amp;rarr; push / ret &amp;rarr; pop is managed directly in hardware.</source>
          <target state="translated">En la pila, guarda las direcciones de retorno y la llamada &amp;rarr; push / ret &amp;rarr; pop se administra directamente en el hardware.</target>
        </trans-unit>
        <trans-unit id="29a4742ef363b18a49d8dab9624425d36200ea1e" translate="yes" xml:space="preserve">
          <source>One detail that has been missed, however, is that the &quot;heap&quot; should in fact probably be called the &quot;free store&quot;.  The reason for this distinction is that the original free store was implemented with a data structure known as a &quot;binomial heap.&quot;  For that reason, allocating from early implementations of malloc()/free() was allocation from a heap.  However, in this modern day, most free stores are implemented with very elaborate data structures that are not binomial heaps.</source>
          <target state="translated">Un detalle que se ha pasado por alto,sin embargo,es que el &quot;montón&quot; probablemente debería llamarse la &quot;tienda gratis&quot;.La razón de esta distinción es que el almacén gratuito original se implementó con una estructura de datos conocida como &quot;montón binomial&quot;.Por esa razón,la asignación de las primeras implementaciones de malloc()free()se hizo desde un montón.Sin embargo,en estos tiempos modernos,la mayoría de los almacenes libres se implementan con estructuras de datos muy elaboradas que no son un montón de binomios.</target>
        </trans-unit>
        <trans-unit id="13d7afdda2ae69ca5bb8408fcc1546f3b6c11363" translate="yes" xml:space="preserve">
          <source>One typical memory block was BSS (a block of zero values)
which was accidentally not zeroed in one manufacturer's offering.
Another was DATA containing initialized values, including strings and numbers.
A third was CODE containing CRT (C runtime), main, functions, and libraries.</source>
          <target state="translated">Un bloque de memoria típico era el BSS (un bloque de valores cero)que accidentalmente no fue puesto a cero en la oferta de un fabricante.Otro era DATA que contenía valores inicializados,incluyendo cadenas y números.Un tercero era el CÓDIGO que contenía CRT (tiempo de ejecución C),principal,funciones y bibliotecas.</target>
        </trans-unit>
        <trans-unit id="e3d075236948af076fad91d4bb43d9d26eb82acc" translate="yes" xml:space="preserve">
          <source>Others have answered the broad strokes pretty well, so I'll throw in a few details.</source>
          <target state="translated">Otros han respondido bastante bien a las líneas generales,así que daré algunos detalles.</target>
        </trans-unit>
        <trans-unit id="6f64e795a39ecd2c765903677e991445c7062f09" translate="yes" xml:space="preserve">
          <source>Others have directly answered your question, but when trying to understand the stack and the heap, I think it is helpful to consider the memory layout of a traditional UNIX process (without threads and &lt;code&gt;mmap()&lt;/code&gt;-based allocators). The &lt;a href=&quot;http://www.memorymanagement.org/glossary/b.html#term-brk&quot;&gt;Memory Management Glossary&lt;/a&gt; web page has a diagram of this memory layout.</source>
          <target state="translated">Otros han respondido directamente a su pregunta, pero al tratar de entender la pila y el mont&amp;oacute;n, creo que es &amp;uacute;til considerar el dise&amp;ntilde;o de memoria de un proceso UNIX tradicional (sin hilos y asignadores basados ​​en &lt;code&gt;mmap()&lt;/code&gt; ). La p&amp;aacute;gina web del &lt;a href=&quot;http://www.memorymanagement.org/glossary/b.html#term-brk&quot;&gt;Glosario de administraci&amp;oacute;n de memoria&lt;/a&gt; tiene un diagrama de este dise&amp;ntilde;o de memoria.</target>
        </trans-unit>
        <trans-unit id="e33f67dded7084c7a1497e2d2409091903f39904" translate="yes" xml:space="preserve">
          <source>Programming language books explain that value types are created on the &lt;strong&gt;stack&lt;/strong&gt;, and reference types are created on the &lt;strong&gt;heap&lt;/strong&gt;, without explaining what these two things are. I haven't read a clear explanation of this.  I understand what &lt;em&gt;a stack&lt;/em&gt; is. But,</source>
          <target state="translated">Los libros de lenguaje de programaci&amp;oacute;n explican que los tipos de valor se crean en la &lt;strong&gt;pila&lt;/strong&gt; , y los tipos de referencia se crean en el &lt;strong&gt;mont&amp;oacute;n&lt;/strong&gt; , sin explicar cu&amp;aacute;les son estas dos cosas. No he le&amp;iacute;do una explicaci&amp;oacute;n clara de esto. Entiendo lo que es &lt;em&gt;una pila&lt;/em&gt; . Pero,</target>
        </trans-unit>
        <trans-unit id="6e6e17f4d2768e59d3304c88f5860bd92caee2a8" translate="yes" xml:space="preserve">
          <source>REF:</source>
          <target state="translated">REF:</target>
        </trans-unit>
        <trans-unit id="b5fef21aad832234d260e32f67bed2552c27b3f3" translate="yes" xml:space="preserve">
          <source>Responsible for memory leaks.</source>
          <target state="translated">Responsable de las fugas de memoria.</target>
        </trans-unit>
        <trans-unit id="69bf7896b4602d80f099d7c96e91ea211768accd" translate="yes" xml:space="preserve">
          <source>Scope refers to what parts of the code can access a variable. Generally we think of &lt;strong&gt;local scope&lt;/strong&gt; (can only be accessed by the current function) versus &lt;strong&gt;global scope&lt;/strong&gt; (can be accessed anywhere) although scope can get much more complex.</source>
          <target state="translated">El alcance se refiere a qu&amp;eacute; partes del c&amp;oacute;digo pueden acceder a una variable. Generalmente pensamos en &lt;strong&gt;el alcance local&lt;/strong&gt; (solo se puede acceder mediante la funci&amp;oacute;n actual) versus &lt;strong&gt;el alcance global&lt;/strong&gt; (se puede acceder desde cualquier lugar) aunque el alcance puede volverse mucho m&amp;aacute;s complejo.</target>
        </trans-unit>
        <trans-unit id="509aa940c1c036efce29c8fe0c9b4b55069f2302" translate="yes" xml:space="preserve">
          <source>Should the function calls had been stored in heap, it would had resulted in 2 messy points:</source>
          <target state="translated">Si las llamadas de función se hubieran almacenado en un montón,habría resultado en 2 puntos desordenados:</target>
        </trans-unit>
        <trans-unit id="a2185ca86acc0c919180d9c04aad21adc109c7e3" translate="yes" xml:space="preserve">
          <source>Simply, the stack is where local variables get created. Also, every time you call a subroutine the program counter (pointer to the next machine instruction) and any important registers, and sometimes the parameters get pushed on the stack. Then any local variables inside the subroutine are pushed onto the stack (and used from there). When the subroutine finishes, that stuff all gets popped back off the stack. The PC and register data gets and put back where it was as it is popped, so your program can go on its merry way.</source>
          <target state="translated">Simplemente,la pila es donde se crean las variables locales.Además,cada vez que se llama a una subrutina el contador del programa (puntero a la siguiente instrucción de máquina)y cualquier registro importante,y a veces los parámetros son empujados en la pila.Entonces cualquier variable local dentro de la subrutina es empujada a la pila (y usada desde allí).Cuando la subrutina termina,todas esas cosas se vuelven a sacar de la pila.El PC y los datos del registro se ponen de nuevo donde estaban cuando salieron,para que su programa pueda seguir su camino.</target>
        </trans-unit>
        <trans-unit id="2c86213718746adf4ed3b869ab8ebf53621c0bd5" translate="yes" xml:space="preserve">
          <source>Since some answers went nitpicking, I'm going to contribute my mite.</source>
          <target state="translated">Ya que algunas respuestas se han vuelto quisquillosas,voy a contribuir con mi parte.</target>
        </trans-unit>
        <trans-unit id="9aeb164d237567097685b40284f2116644d171b1" translate="yes" xml:space="preserve">
          <source>Slow access comparatively to Stack.</source>
          <target state="translated">Acceso lento en comparación con Stack.</target>
        </trans-unit>
        <trans-unit id="f9fa73fb582337740b2c7cd4692dfd71eaccd2bf" translate="yes" xml:space="preserve">
          <source>Slower to allocate in comparison to variables on the stack.</source>
          <target state="translated">Más lento de asignar en comparación con las variables de la pila.</target>
        </trans-unit>
        <trans-unit id="84def04a560bda893e52388cc083ef70d321b378" translate="yes" xml:space="preserve">
          <source>So simple way: process heap is general for process and all threads inside, using for memory allocation in common case with something like &lt;strong&gt;malloc()&lt;/strong&gt;.</source>
          <target state="translated">De manera tan simple: el mont&amp;oacute;n de procesos es general para el proceso y todos los subprocesos dentro, y se usa para la asignaci&amp;oacute;n de memoria en el caso com&amp;uacute;n con algo como &lt;strong&gt;malloc ()&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4d6256f41ed90ef56893f4c0e80ba67b5f4b8734" translate="yes" xml:space="preserve">
          <source>So there is always an index to point the specific item, also processing gonna be faster, there is relationship between the items as well!...</source>
          <target state="translated">Así que siempre hay un índice para apuntar el artículo específico,también el procesamiento va a ser más rápido,¡también hay relación entre los artículos!...</target>
        </trans-unit>
        <trans-unit id="26e4934add44c2df343844921794ed5d56eccfd7" translate="yes" xml:space="preserve">
          <source>Some of the syntax choices in C/C++ exacerbate this problem - for instance many people think global variables are not &quot;static&quot; because of the syntax shown below.</source>
          <target state="translated">Algunas de las opciones de sintaxis en CC++exacerban este problema-por ejemplo,muchas personas piensan que las variables globales no son &quot;estáticas&quot; debido a la sintaxis que se muestra a continuación.</target>
        </trans-unit>
        <trans-unit id="95320488ab41410560b78b52dfa9e017b243c84d" translate="yes" xml:space="preserve">
          <source>Some people think of these concepts as C/C++ specific. They are not. For instance, the Python sample below illustrates all three types of allocation (there are some subtle differences possible in interpreted languages that I won't get into here).</source>
          <target state="translated">Algunas personas piensan que estos conceptos son específicos de CC++.No lo son.Por ejemplo,la muestra de Python que se muestra a continuación ilustra los tres tipos de asignación (hay algunas sutiles diferencias posibles en los lenguajes interpretados que no voy a entrar aquí).</target>
        </trans-unit>
        <trans-unit id="8b51efe6289458012b6c8f1356975a43aa34abc0" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://academind.com/learn/javascript/reference-vs-primitive-values/&quot;&gt;Academind&lt;/a&gt;</source>
          <target state="translated">Fuente: &lt;a href=&quot;https://academind.com/learn/javascript/reference-vs-primitive-values/&quot;&gt;Academind&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9c53060f090e60a073e898da17d700ab9341170" translate="yes" xml:space="preserve">
          <source>Space is freed automatically when program goes out of a scope.</source>
          <target state="translated">El espacio se libera automáticamente cuando el programa se sale del alcance.</target>
        </trans-unit>
        <trans-unit id="a04e6278e75e6c001c297db6eeaca0f21b4f1cf9" translate="yes" xml:space="preserve">
          <source>Space is managed efficiently by CPU, memory will not become fragmented</source>
          <target state="translated">El espacio es administrado eficientemente por la CPU,la memoria no se fragmenta</target>
        </trans-unit>
        <trans-unit id="83e5a0d3d2ef19df258412a4d3ef3f9533b0c0c1" translate="yes" xml:space="preserve">
          <source>Stack</source>
          <target state="translated">Stack</target>
        </trans-unit>
        <trans-unit id="2a1e3b0bbb1f0808e4252a6f745c19b958ac4d85" translate="yes" xml:space="preserve">
          <source>Stack allocation is much faster since all it really does is move the stack pointer. Using memory pools, you can get comparable performance out of heap allocation, but that comes with a slight added complexity and its own headaches.</source>
          <target state="translated">La asignación de la pila es mucho más rápida ya que lo único que hace es mover el puntero de la pila.Usando los fondos de memoria,puedes obtener un rendimiento comparable de la asignación de pila,pero eso viene con una ligera complejidad añadida y sus propios dolores de cabeza.</target>
        </trans-unit>
        <trans-unit id="990b9b0ae5cb9ef33f5882c479501ea9ec73fc18" translate="yes" xml:space="preserve">
          <source>Stack and heap need not be singular. A common situation in which you have more than one stack is if you have more than one thread in a process.  In this case each thread has its own stack. You can also have more than one heap, for example some DLL configurations can result in different DLLs allocating from different heaps, which is why it's generally a bad idea to release memory allocated by a different library.</source>
          <target state="translated">La pila y el montón no tienen por qué ser singulares.Una situación común en la que se tiene más de una pila es si se tiene más de un hilo en un proceso.En este caso cada hilo tiene su propia pila.También puedes tener más de un montón,por ejemplo,algunas configuraciones de DLL pueden dar lugar a que se asignen diferentes DLL de diferentes montones,por lo que generalmente es una mala idea liberar la memoria asignada por una biblioteca diferente.</target>
        </trans-unit>
        <trans-unit id="12fa9cb21a886762f171950816a55e2e59c869da" translate="yes" xml:space="preserve">
          <source>Stack is quick memory for store in common case function return pointers and variables, processed as parameters in function call, local function variables.</source>
          <target state="translated">La pila es una memoria rápida para almacenar en caso común punteros y variables de retorno de la función,procesados como parámetros en la llamada de la función,variables de la función local.</target>
        </trans-unit>
        <trans-unit id="e3f92779f11d4b0f3467f92a53682253210952a8" translate="yes" xml:space="preserve">
          <source>Stack usage is faster as:</source>
          <target state="translated">El uso de la pila es más rápido como:</target>
        </trans-unit>
        <trans-unit id="24de6d4cf48238082c51e345becf26e29ec1d2b0" translate="yes" xml:space="preserve">
          <source>Stacks in computing architectures are regions of memory where data is added or removed in a last-in-first-out manner.</source>
          <target state="translated">Las pilas en las arquitecturas informáticas son regiones de memoria donde los datos se añaden o se quitan de una manera de último en primero en salir.</target>
        </trans-unit>
        <trans-unit id="22877b6a12ccde62a270b7ab1193154412bb82ab" translate="yes" xml:space="preserve">
          <source>Stored in RAM.</source>
          <target state="translated">Guardado en la memoria RAM.</target>
        </trans-unit>
        <trans-unit id="dc53b0aeba09646ffe4c0adfb1d92487fe376514" translate="yes" xml:space="preserve">
          <source>Stored in computer RAM just like the heap.</source>
          <target state="translated">Almacenado en la RAM de la computadora como el montón.</target>
        </trans-unit>
        <trans-unit id="5ba923ec538ab00b7c8b1596311059a6d8275c93" translate="yes" xml:space="preserve">
          <source>Stored in computer RAM just like the stack.</source>
          <target state="translated">Guardado en la memoria RAM de la computadora como la pila.</target>
        </trans-unit>
        <trans-unit id="4cff577d64e66b1b435d415f1b04c55974ebb6a6" translate="yes" xml:space="preserve">
          <source>Stored in sequential memory.</source>
          <target state="translated">Guardado en la memoria secuencial.</target>
        </trans-unit>
        <trans-unit id="8df107699395056ea16ab53263372585c3596bba" translate="yes" xml:space="preserve">
          <source>Stored wherever memory allocation is done, accessed by pointer always.</source>
          <target state="translated">Se almacena dondequiera que se haga la asignación de memoria,a la que se accede siempre con el puntero.</target>
        </trans-unit>
        <trans-unit id="89a636351088b12243704905bf43a965507d4b10" translate="yes" xml:space="preserve">
          <source>Stores local data, return addresses, used for parameter passing.</source>
          <target state="translated">Almacena datos locales,direcciones de retorno,utilizados para el paso de parámetros.</target>
        </trans-unit>
        <trans-unit id="dbf8af31722360d4cd5768e22244d5f8a401c59d" translate="yes" xml:space="preserve">
          <source>Surprisingly, no one has mentioned that multiple (i.e. not related to the number of running OS-level threads) call stacks are to be found not only in exotic languages (PostScript) or platforms (Intel Itanium), but also in &lt;a href=&quot;http://en.wikipedia.org/wiki/Fiber_(computer_science)&quot;&gt;&lt;em&gt;fibers&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Green_threads&quot;&gt;&lt;em&gt;green threads&lt;/em&gt;&lt;/a&gt; and some implementations of &lt;a href=&quot;http://en.wikipedia.org/wiki/Coroutine&quot;&gt;&lt;em&gt;coroutines&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Sorprendentemente, nadie ha mencionado que m&amp;uacute;ltiples pilas de llamadas (es decir, no relacionadas con el n&amp;uacute;mero de subprocesos a nivel del sistema operativo) se encuentran no solo en lenguajes ex&amp;oacute;ticos (PostScript) o plataformas (Intel Itanium), sino tambi&amp;eacute;n en &lt;a href=&quot;http://en.wikipedia.org/wiki/Fiber_(computer_science)&quot;&gt;&lt;em&gt;fibras&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Green_threads&quot;&gt;&lt;em&gt;hilos verdes&lt;/em&gt;&lt;/a&gt; y algunas implementaciones de &lt;a href=&quot;http://en.wikipedia.org/wiki/Coroutine&quot;&gt;&lt;em&gt;corutinas&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="918fc88eb49d9688ce62b0cb92ecf74e2130215f" translate="yes" xml:space="preserve">
          <source>That said, stack-based memory errors are some of the worst I've experienced.  If you use heap memory, and you overstep the bounds of your allocated block, you have a decent chance of triggering a segment fault.  (Not 100%: your block may be incidentally contiguous with another that you have previously allocated.)  But since variables created on the stack are always contiguous with each other, writing out of bounds can change the value of another variable.  I have learned that whenever I feel that my program has stopped obeying the laws of logic, it is probably buffer overflow.</source>
          <target state="translated">Dicho esto,los errores de memoria basados en la pila son de los peores que he experimentado.Si usas la memoria en pila,y sobrepasas los límites de tu bloque asignado,tienes una buena posibilidad de provocar un fallo de segmento.(No al 100%:tu bloque puede ser incidentalmente contiguo a otro que hayas asignado previamente.)Pero como las variables creadas en la pila son siempre contiguas entre sí,escribir fuera de los límites puede cambiar el valor de otra variable.He aprendido que cuando siento que mi programa ha dejado de obedecer las leyes de la lógica,probablemente sea un desbordamiento del búfer.</target>
        </trans-unit>
        <trans-unit id="77e50870e9d92e46d032efa6ebe4c3cc162d7aa6" translate="yes" xml:space="preserve">
          <source>The CPU has special instructions for &lt;em&gt;pushing&lt;/em&gt; values onto the stack and &lt;em&gt;popping&lt;/em&gt; them back from the stack. Each &lt;em&gt;push&lt;/em&gt; stores the value at the current location of the stack pointer and decreases the stack pointer.  A &lt;em&gt;pop&lt;/em&gt; retrieves the value pointed to by the stack pointer and then increases the stack pointer (don't be confused by the fact that &lt;em&gt;adding&lt;/em&gt; a value to the stack &lt;em&gt;decreases&lt;/em&gt; the stack pointer and &lt;em&gt;removing&lt;/em&gt; a value &lt;em&gt;increases&lt;/em&gt; it. Remember that the stack grows to the bottom). The values stored and retrieved are the values of the CPU registers.</source>
          <target state="translated">La CPU tiene instrucciones especiales para &lt;em&gt;insertar&lt;/em&gt; valores en la pila y &lt;em&gt;extraerlos&lt;/em&gt; de la pila. Cada &lt;em&gt;inserci&amp;oacute;n&lt;/em&gt; almacena el valor en la ubicaci&amp;oacute;n actual del puntero de la pila y disminuye el puntero de la pila. Un mensaje &lt;em&gt;emergente&lt;/em&gt; recupera el valor se&amp;ntilde;alado por el puntero de la pila y luego aumenta el puntero de la pila (no se confunda con el hecho de que &lt;em&gt;agregar&lt;/em&gt; un valor a la pila &lt;em&gt;disminuye&lt;/em&gt; el puntero de la pila y &lt;em&gt;eliminar&lt;/em&gt; un valor lo &lt;em&gt;aumenta&lt;/em&gt; . Recuerde que la pila crece hasta El fondo). Los valores almacenados y recuperados son los valores de los registros de la CPU.</target>
        </trans-unit>
        <trans-unit id="acf431b632d416223fea9a3ceddf5add4bc0a95f" translate="yes" xml:space="preserve">
          <source>The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application.</source>
          <target state="translated">El sistema operativo asigna la pila para cada hilo de nivel de sistema cuando se crea el hilo.Típicamente el OS es llamado por el tiempo de ejecución del lenguaje para asignar la pila para la aplicación.</target>
        </trans-unit>
        <trans-unit id="38a855cabffd8eca3496aa5a7a4076cf2ab0ee27" translate="yes" xml:space="preserve">
          <source>The advantage of using the stack to store variables, is that memory is managed for you. You don't have to allocate memory by hand, or free it once you don't need it any more. What's more, because the CPU organizes stack memory so efficiently, reading from and writing to stack variables is very fast.</source>
          <target state="translated">La ventaja de usar la pila para almacenar variables,es que la memoria se gestiona por ti.No tienes que asignar la memoria a mano,o liberarla una vez que ya no la necesitas.Además,como la CPU organiza la memoria de la pila de manera tan eficiente,leer y escribir en las variables de la pila es muy rápido.</target>
        </trans-unit>
        <trans-unit id="8a9b474ea07882c9a3be36b7edcb52f7b0126430" translate="yes" xml:space="preserve">
          <source>The advent of virtual memory in UNIX changes many of the constraints.
There is no objective reason why these blocks need be contiguous,
or fixed in size, or ordered a particular way now.
Of course, before UNIX was Multics which didn't suffer from these constraints.
Here is a schematic showing one of the memory layouts of that era.</source>
          <target state="translated">El advenimiento de la memoria virtual en UNIX cambia muchas de las limitaciones.No hay ninguna razón objetiva por la que estos bloques deban ser contiguos,o de tamaño fijo,u ordenados de una manera particular ahora.Por supuesto,antes de UNIX era Multics el que no sufría estas restricciones.Aquí hay un esquema que muestra uno de los diseños de memoria de esa época.</target>
        </trans-unit>
        <trans-unit id="ff4d4ca937c7d0d51d422534fe1735405013c379" translate="yes" xml:space="preserve">
          <source>The answer to your question is implementation specific and may vary across compilers and processor architectures. However, here is a simplified explanation.</source>
          <target state="translated">La respuesta a su pregunta es específica de la implementación y puede variar según los compiladores y las arquitecturas de los procesadores.Sin embargo,aquí hay una explicación simplificada.</target>
        </trans-unit>
        <trans-unit id="020c36cef487c3028c3b0a5e48330117297c3aa9" translate="yes" xml:space="preserve">
          <source>The call stack is such a low level concept that it doesn't relate to 'scope' in the sense of programming.  If you disassemble some code you'll see relative pointer style references to portions of the stack, but as far as a higher level language is concerned, the language imposes its own rules of scope.  One important aspect of a stack, however, is that once a function returns, anything local to that function is immediately freed from the stack.  That works the way you'd expect it to work given how your programming languages work.  In a heap, it's also difficult to define.  The scope is whatever is exposed by the OS, but your programming language probably adds its rules about what a &quot;scope&quot; is in your application.  The processor architecture and the OS use virtual addressing, which the processor translates to physical addresses and there are page faults, etc.  They keep track of what pages belong to which applications.  You never really need to worry about this, though, because you just use whatever method your programming language uses to allocate and free memory, and check for errors (if the allocation/freeing fails for any reason).</source>
          <target state="translated">La pila de llamadas es un concepto de tan bajo nivel que no se relaciona con el &quot;alcance&quot; en el sentido de la programación.Si desensamblas algún código verás referencias relativas de estilo de puntero a porciones de la pila,pero en lo que respecta a un lenguaje de nivel superior,el lenguaje impone sus propias reglas de alcance.Sin embargo,un aspecto importante de la pila es que una vez que una función regresa,cualquier cosa local a esa función se libera inmediatamente de la pila.Eso funciona de la manera que se esperaría que funcionara dado el modo en que funcionan los lenguajes de programación.En un montón,también es difícil de definir.El &quot;scope&quot; es lo que sea expuesto por el sistema operativo,pero tu lenguaje de programación probablemente agregue sus reglas sobre qué es un &quot;scope&quot; en tu aplicación.La arquitectura del procesador y el SO utilizan direcciones virtuales,que el procesador traduce a direcciones físicas y hay fallos de página,etc.Llevan un registro de qué páginas pertenecen a qué aplicaciones.Sin embargo,nunca hay que preocuparse realmente por esto,porque simplemente se utiliza cualquier método que su lenguaje de programación utilice para asignar y liberar memoria,y comprobar si hay errores (si la asignación-liberación falla por cualquier razón).</target>
        </trans-unit>
        <trans-unit id="71984997f1c1e6f1262af07953881c1b0a8417ca" translate="yes" xml:space="preserve">
          <source>The difference between stack and heap memory allocation &amp;laquo;  timmurphy.org</source>
          <target state="translated">La diferencia entre la asignaci&amp;oacute;n de la pila y la memoria del mont&amp;oacute;n &amp;laquo;timmurphy.org</target>
        </trans-unit>
        <trans-unit id="7a5590373ff6649f9475365f1f774384f831b25c" translate="yes" xml:space="preserve">
          <source>The heap</source>
          <target state="translated">El montón</target>
        </trans-unit>
        <trans-unit id="64692d2958abffc9963293d7cc83b6289b346bca" translate="yes" xml:space="preserve">
          <source>The heap contains a linked list of used and free blocks. New allocations on the heap (by &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt;) are satisfied by creating a suitable block from one of the free blocks. This requires updating list of blocks on the heap. This &lt;em&gt;meta information&lt;/em&gt; about the blocks on the heap is also stored on the heap often in a small area just in front of every block.</source>
          <target state="translated">El mont&amp;oacute;n contiene una lista vinculada de bloques usados ​​y libres. Las nuevas asignaciones en el mont&amp;oacute;n (por &lt;code&gt;new&lt;/code&gt; o &lt;code&gt;malloc&lt;/code&gt; ) se satisfacen creando un bloque adecuado a partir de uno de los bloques libres. Esto requiere actualizar la lista de bloques en el mont&amp;oacute;n. Esta &lt;em&gt;metainformaci&amp;oacute;n&lt;/em&gt; sobre los bloques en el mont&amp;oacute;n tambi&amp;eacute;n se almacena en el mont&amp;oacute;n a menudo en un &amp;aacute;rea peque&amp;ntilde;a justo delante de cada bloque.</target>
        </trans-unit>
        <trans-unit id="e88ae6b7603411c417abd661b3310c2adee1f47c" translate="yes" xml:space="preserve">
          <source>The heap is a memory for items of which you can&amp;rsquo;t pre-determine the
  exact size and structure. Since objects and arrays can be mutated and
  change at runtime, they have to go into the heap therefore.</source>
          <target state="translated">El mont&amp;oacute;n es una memoria para elementos de los que no puede predeterminar el tama&amp;ntilde;o y la estructura exactos. Dado que los objetos y las matrices pueden mutar y cambiar en tiempo de ejecuci&amp;oacute;n, por lo tanto, deben ir al mont&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4ca28207330bff52b70007af68c711c32e17159a" translate="yes" xml:space="preserve">
          <source>The heap is a portion of memory that is given to an application by the operating system, typically through a syscall like malloc.  On modern OSes this memory is a set of pages that only the calling process has access to.</source>
          <target state="translated">El montón es una porción de memoria que el sistema operativo le da a una aplicación,típicamente a través de una llamada de sistema como malloc.En los sistemas operativos modernos esta memoria es un conjunto de páginas a las que sólo tiene acceso el proceso de llamada.</target>
        </trans-unit>
        <trans-unit id="71f619e3570fe3e7aac533a912d787b19b6db9a4" translate="yes" xml:space="preserve">
          <source>The heap is a region of your computer's memory that is not managed automatically for you, and is not as tightly managed by the CPU. It is a more free-floating region of memory (and is larger). To allocate memory on the heap, you must use malloc() or calloc(), which are built-in C functions. Once you have allocated memory on the heap, you are responsible for using free() to deallocate that memory once you don't need it any more.</source>
          <target state="translated">El montón es una región de la memoria de su ordenador que no se gestiona automáticamente para usted,y que no está tan bien gestionada por la CPU.Es una región de memoria que flota más libremente (y es más grande).Para asignar memoria en el heap,debes usar malloc()o calloc(),que son funciones C incorporadas.Una vez que has asignado memoria en el heap,eres responsable de usar free()para repartir esa memoria una vez que ya no la necesites.</target>
        </trans-unit>
        <trans-unit id="7be7d8e45896d63bdae0ae933b6b0e1b8111b33b" translate="yes" xml:space="preserve">
          <source>The heap is memory set aside for dynamic allocation.  Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time.  This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns.</source>
          <target state="translated">El montón es la memoria reservada para la asignación dinámica.A diferencia de la pila,no hay un patrón forzado para la asignación y distribución de los bloques del montón;puedes asignar un bloque en cualquier momento y liberarlo en cualquier momento.Esto hace que sea mucho más complejo llevar la cuenta de qué partes del montón están asignadas o libres en un momento dado;hay muchos asignadores de montón personalizados disponibles para ajustar el rendimiento del montón a los diferentes patrones de uso.</target>
        </trans-unit>
        <trans-unit id="408b6a604741833882cb371639a20f7a50001b81" translate="yes" xml:space="preserve">
          <source>The heap is simply the memory used by programs to store variables.
Element of the heap (variables) have no dependencies with each other and can always be accessed randomly at any time.</source>
          <target state="translated">El montón es simplemente la memoria usada por los programas para almacenar variables.Los elementos del montón (variables)no tienen dependencias entre sí y siempre se puede acceder a ellos de forma aleatoria en cualquier momento.</target>
        </trans-unit>
        <trans-unit id="18cf12075777cee089f775e186e6f7b937d612e6" translate="yes" xml:space="preserve">
          <source>The heap is the area of memory dynamic memory allocations are made out of (explicit &quot;new&quot; or &quot;allocate&quot; calls). It is a special data structure that can keep track of blocks of memory of varying sizes and their allocation status.</source>
          <target state="translated">El montón es el área de memoria de la que se hacen las asignaciones de memoria dinámica (llamadas explícitas &quot;nuevas&quot; o &quot;asignadas&quot;).Es una estructura de datos especial que puede hacer un seguimiento de los bloques de memoria de diversos tamaños y su estado de asignación.</target>
        </trans-unit>
        <trans-unit id="3aabde1f5818e4761b37f38a6704fc125ea9920e" translate="yes" xml:space="preserve">
          <source>The most important point is that heap and stack are generic terms for ways in which memory can be allocated.  They can be implemented in many different ways, and the terms apply to the basic concepts.</source>
          <target state="translated">El punto más importante es que &quot;heap and stack&quot; son términos genéricos para las formas en que se puede asignar la memoria.Pueden aplicarse de muchas maneras diferentes,y los términos se aplican a los conceptos básicos.</target>
        </trans-unit>
        <trans-unit id="bda899c3bb77eaf54a1599448a403c98162d7221" translate="yes" xml:space="preserve">
          <source>The net result is a percentage of the heap space that is not usable for further memory allocations.</source>
          <target state="translated">El resultado neto es un porcentaje del espacio de acumulación que no es utilizable para otras asignaciones de memoria.</target>
        </trans-unit>
        <trans-unit id="9db69de7d5cb25cb1dab28c5edef62348d01cbca" translate="yes" xml:space="preserve">
          <source>The private heap begins on a 16-byte boundary (for 64-bit programs) or a 8-byte boundary (for 32-bit programs) after the last byte of code in your program, and then increases in value from there. It is also called the default heap.</source>
          <target state="translated">La pila privada comienza en un límite de 16 bytes (para programas de 64 bits)o de 8 bytes (para programas de 32 bits)después del último byte de código en su programa,y luego aumenta de valor a partir de ahí.También se llama el montón por defecto.</target>
        </trans-unit>
        <trans-unit id="c92a151a963f47b45a4e38472c1ddbfa83a05978" translate="yes" xml:space="preserve">
          <source>The public heap resides in it's own memory space outside of your program image space. It is this memory that will be siphoned off onto the hard disk if memory resources get scarce.</source>
          <target state="translated">El montón público reside en su propio espacio de memoria fuera del espacio de imagen de su programa.Es esta memoria la que será desviada al disco duro si los recursos de memoria escasean.</target>
        </trans-unit>
        <trans-unit id="c2c0a23048e8df047bdd90c519e230882a5ebc7e" translate="yes" xml:space="preserve">
          <source>The simplicity of a stack is that you do not need to maintain a table containing a record of each section of allocated memory; the only state information you need is a single pointer to the end of the stack.  To allocate and de-allocate, you just increment and decrement that single pointer.  Note: a stack can sometimes be implemented to start at the top of a section of memory and extend downwards rather than growing upwards.</source>
          <target state="translated">La simplicidad de una pila es que no es necesario mantener una tabla que contenga un registro de cada sección de la memoria asignada;la única información de estado que se necesita es un solo puntero al final de la pila.Para asignar y desasignar,sólo hay que incrementar y disminuir ese único puntero.Nota:a veces se puede implementar una pila para que comience en la parte superior de una sección de memoria y se extienda hacia abajo en lugar de crecer hacia arriba.</target>
        </trans-unit>
        <trans-unit id="0a5a7df2173b3956056001d4db19a49a57a3b1c3" translate="yes" xml:space="preserve">
          <source>The single STACK was typically an area below HEAP which was a tract of memory
containing nothing of value until the top of the next fixed block of memory.
This next block was often CODE which could be overwritten by stack data
in one of the famous hacks of its era.</source>
          <target state="translated">El STACK único era típicamente un área debajo de HEAP que era un tracto de memoria que no contenía nada de valor hasta la parte superior del siguiente bloque fijo de memoria.Este bloque siguiente era a menudo un CÓDIGO que podía ser sobrescrito por los datos de la pila en uno de los famosos hacks de su época.</target>
        </trans-unit>
        <trans-unit id="011fc8ced4b02d6e5bbcdaf8c062421d1082656a" translate="yes" xml:space="preserve">
          <source>The size of the stack and the private heap are determined by your compiler runtime options. The public heap is initialized at runtime using a size parameter.</source>
          <target state="translated">El tamaño de la pila y el montón privado se determinan por las opciones de tiempo de ejecución del compilador.El montón público se inicializa en tiempo de ejecución mediante un parámetro de tamaño.</target>
        </trans-unit>
        <trans-unit id="beb914534381f099cbd641ab522253e8764a0c7c" translate="yes" xml:space="preserve">
          <source>The size of the stack is determined at runtime, and generally does not grow after the program launches.  In a C program, the stack needs to be large enough to hold every variable declared within each function.  The heap will grow dynamically as needed, but the OS is ultimately making the call (it will often grow the heap by more than the value requested by malloc, so that at least some future mallocs won't need to go back to the kernel to get more memory.  This behavior is often customizable)</source>
          <target state="translated">El tamaño de la pila se determina en tiempo de ejecución,y generalmente no crece después de que se lanza el programa.En un programa C,la pila tiene que ser lo suficientemente grande como para contener cada variable declarada dentro de cada función.El montón crecerá dinámicamente según sea necesario,pero el sistema operativo es el que finalmente hace la llamada (a menudo hará crecer el montón más que el valor solicitado por el malloc,de modo que al menos algunos mallocs futuros no necesitarán volver al núcleo para obtener más memoria.Este comportamiento es a menudo personalizable)</target>
        </trans-unit>
        <trans-unit id="16b7e0f64c42733b20a4e51a341eddcfa754d823" translate="yes" xml:space="preserve">
          <source>The size of the stack is set by &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_system&quot;&gt;OS&lt;/a&gt; when a thread is created. The size of the heap is set on application startup, but it can grow as space is needed (the allocator requests more memory from the operating system).</source>
          <target state="translated">El sistema &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_system&quot;&gt;operativo&lt;/a&gt; establece el tama&amp;ntilde;o de la pila cuando se crea un subproceso. El tama&amp;ntilde;o del mont&amp;oacute;n se establece en el inicio de la aplicaci&amp;oacute;n, pero puede crecer a medida que se necesita espacio (el asignador solicita m&amp;aacute;s memoria del sistema operativo).</target>
        </trans-unit>
        <trans-unit id="5cc1aba664ea781e5f0b096e032491b096dd802e" translate="yes" xml:space="preserve">
          <source>The size of the stack is set when a thread is created.  The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).</source>
          <target state="translated">El tamaño de la pila se establece cuando se crea un hilo.El tamaño de la pila se establece al iniciar la aplicación,pero puede crecer a medida que se necesite espacio (el asignador solicita más memoria al sistema operativo).</target>
        </trans-unit>
        <trans-unit id="864abb86138112e4b6d575123f37974ac0c3d5c5" translate="yes" xml:space="preserve">
          <source>The stack</source>
          <target state="translated">La pila</target>
        </trans-unit>
        <trans-unit id="901c2c85d8f6f1f4b65665c0438d9a9ae1aeb6f6" translate="yes" xml:space="preserve">
          <source>The stack and heap are traditionally located at opposite ends of the process's virtual address space. The stack grows automatically when accessed, up to a size set by the kernel (which can be adjusted with &lt;code&gt;setrlimit(RLIMIT_STACK, ...)&lt;/code&gt;). The heap grows when the memory allocator invokes the &lt;code&gt;brk()&lt;/code&gt; or &lt;code&gt;sbrk()&lt;/code&gt; system call, mapping more pages of physical memory into the process's virtual address space.</source>
          <target state="translated">La pila y el mont&amp;oacute;n se ubican tradicionalmente en los extremos opuestos del espacio de direcciones virtuales del proceso. La pila crece autom&amp;aacute;ticamente cuando se accede, hasta un tama&amp;ntilde;o establecido por el n&amp;uacute;cleo (que se puede ajustar con &lt;code&gt;setrlimit(RLIMIT_STACK, ...)&lt;/code&gt; ). El mont&amp;oacute;n crece cuando el asignador de memoria invoca la &lt;code&gt;brk()&lt;/code&gt; al sistema brk () o &lt;code&gt;sbrk()&lt;/code&gt; , asignando m&amp;aacute;s p&amp;aacute;ginas de memoria f&amp;iacute;sica al espacio de direcciones virtuales del proceso.</target>
        </trans-unit>
        <trans-unit id="5a39a45e4339d966ed8ccdb706ae6cfcecd17231" translate="yes" xml:space="preserve">
          <source>The stack is a &quot;LIFO&quot; (last in, first out) data structure, that is managed and optimized by the CPU quite closely. Every time a function declares a new variable, it is &quot;pushed&quot; onto the stack. Then every time a function exits, all of the variables pushed onto the stack by that function, are freed (that is to say, they are deleted). Once a stack variable is freed, that region of memory becomes available for other stack variables.</source>
          <target state="translated">La pila es una estructura de datos &quot;LIFO&quot; (último en entrar,primero en salir),que es administrada y optimizada por la CPU muy de cerca.Cada vez que una función declara una nueva variable,es &quot;empujada&quot; a la pila.Luego,cada vez que una función sale,todas las variables empujadas a la pila por esa función se liberan (es decir,se eliminan).Una vez que una variable de la pila se libera,esa región de memoria queda disponible para otras variables de la pila.</target>
        </trans-unit>
        <trans-unit id="ed0cdd27974e8f28be5b49910ffd382fca3bd094" translate="yes" xml:space="preserve">
          <source>The stack is a portion of memory that can be manipulated via several key assembly language instructions, such as 'pop' (remove and return a value from the stack) and 'push' (push a value to the stack), but also call (call a subroutine - this pushes the address to return to the stack) and return (return from a subroutine - this pops the address off of the stack and jumps to it).  It's the region of memory below the stack pointer register, which can be set as needed.  The stack is also used for passing arguments to subroutines, and also for preserving the values in registers before calling subroutines.</source>
          <target state="translated">La pila es una porción de memoria que puede ser manipulada a través de varias instrucciones clave del lenguaje ensamblador,como 'pop' (quitar y devolver un valor de la pila)y 'push' (empujar un valor a la pila),pero también llamar (llamar una subrutina-esto empuja la dirección para volver a la pila)y volver (volver de una subrutina-esto saca la dirección de la pila y salta a ella).Es la región de memoria debajo del registro del puntero de la pila,que se puede configurar según sea necesario.La pila también se utiliza para pasar argumentos a las subrutinas,y también para preservar los valores de los registros antes de llamar a las subrutinas.</target>
        </trans-unit>
        <trans-unit id="8fed4d46c5dcc66fd775586df82611b6cbc4131a" translate="yes" xml:space="preserve">
          <source>The stack is attached to a thread, so when the thread exits the stack is reclaimed.  The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits.</source>
          <target state="translated">La pila está unida a un hilo,así que cuando el hilo sale la pila se recupera.El montón se asigna típicamente al inicio de la aplicación por el tiempo de ejecución,y se recupera cuando la aplicación (proceso técnico)sale.</target>
        </trans-unit>
        <trans-unit id="d7d4617ad45d9667a26837a2ef9396a88ed54845" translate="yes" xml:space="preserve">
          <source>The stack is controlled by the programmer, the private heap is managed by the OS, and the public heap is not controlled by anyone because it is an OS service -- you make requests and either they are granted or denied.</source>
          <target state="translated">La pila es controlada por el programador,el montón privado es manejado por el sistema operativo,y el montón público no es controlado por nadie porque es un servicio del sistema operativo...se hacen peticiones y se conceden o se niegan.</target>
        </trans-unit>
        <trans-unit id="776e06a491d0e5871f9e300942fd84b17a6ca19c" translate="yes" xml:space="preserve">
          <source>The stack is faster because all free memory is always contiguous.  No list needs to be maintained of all the segments of free memory, just a single pointer to the current top of the stack.  Compilers usually store this pointer in a special, fast &lt;a href=&quot;http://en.wikipedia.org/wiki/Stack_register&quot;&gt;register&lt;/a&gt; for this purpose.  What's more, subsequent operations on a stack are usually concentrated within very nearby areas of memory, which at a very low level is good for optimization by the processor on-die caches.</source>
          <target state="translated">La pila es m&amp;aacute;s r&amp;aacute;pida porque toda la memoria libre siempre es contigua. No es necesario mantener una lista de todos los segmentos de memoria libre, solo un puntero a la parte superior actual de la pila. Los compiladores suelen almacenar este puntero en un &lt;a href=&quot;http://en.wikipedia.org/wiki/Stack_register&quot;&gt;registro&lt;/a&gt; especial y r&amp;aacute;pido para este prop&amp;oacute;sito. Adem&amp;aacute;s, las operaciones posteriores en una pila generalmente se concentran en &amp;aacute;reas muy cercanas de memoria, lo que a un nivel muy bajo es bueno para la optimizaci&amp;oacute;n por parte de las memorias cach&amp;eacute; integradas del procesador.</target>
        </trans-unit>
        <trans-unit id="e94a30b9ac14f61035ae0f43d2216250500958c2" translate="yes" xml:space="preserve">
          <source>The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or deallocation.  Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be - typically - synchronized with &quot;all&quot; other heap accesses in the program.</source>
          <target state="translated">La pila es más rápida porque el patrón de acceso hace que sea trivial asignar y reasignar la memoria desde ella (un entero puntero es simplemente incrementado o disminuido),mientras que el montón tiene una contabilidad mucho más compleja involucrada en una asignación o reasignación.Además,cada byte de la pila tiende a ser reutilizado con mucha frecuencia,lo que significa que tiende a ser asignado a la caché del procesador,lo que lo hace muy rápido.Otro golpe de rendimiento para el &quot;heap&quot; es que el &quot;heap&quot;,al ser en su mayor parte un recurso global,normalmente tiene que ser seguro para los multihilos,es decir,cada asignación y redistribución tiene que estar -típicamente-sincronizada con &quot;todos&quot; los demás accesos del &quot;heap&quot; en el programa.</target>
        </trans-unit>
        <trans-unit id="b147220a7a5ad0a7828db4392f30462146e56ffc" translate="yes" xml:space="preserve">
          <source>The stack is important to consider in exception handling and thread executions.</source>
          <target state="translated">Es importante tener en cuenta la pila en el manejo de excepciones y las ejecuciones de hilos.</target>
        </trans-unit>
        <trans-unit id="8ef364bf925f140fae82efa1d95fdcfda187e3d2" translate="yes" xml:space="preserve">
          <source>The stack is memory that begins as the highest memory address allocated to your program image, and it then decrease in value from there. It is reserved for called function parameters and for all temporary variables used in functions.</source>
          <target state="translated">La pila es la memoria que comienza como la dirección de memoria más alta asignada a la imagen de su programa,y luego disminuye de valor a partir de ahí.Está reservada para los parámetros llamados de función y para todas las variables temporales utilizadas en las funciones.</target>
        </trans-unit>
        <trans-unit id="f7b4a5b7d8386940ab1623f4ec51157abd70a3d1" translate="yes" xml:space="preserve">
          <source>The stack is much faster than the heap.</source>
          <target state="translated">La pila es mucho más rápida que el montón.</target>
        </trans-unit>
        <trans-unit id="8b386c56b8fca037b071be51c145e3471e513ded" translate="yes" xml:space="preserve">
          <source>The stack is the area of memory where local variables (including method parameters) are stored. When it comes to object variables, these are merely references (pointers) to the actual objects on the heap.</source>
          <target state="translated">La pila es el área de memoria donde se almacenan las variables locales (incluidos los parámetros del método).Cuando se trata de variables de objetos,éstas son meramente referencias (punteros)a los objetos reales del montón.</target>
        </trans-unit>
        <trans-unit id="29503f92d8ce71011e0d49b669cd0afb652670e0" translate="yes" xml:space="preserve">
          <source>The stack is the memory set aside as scratch space for a thread of execution.  When a function is called, a block is reserved on the top of the stack for local variables and some bookkeeping data.  When that function returns, the block becomes unused and can be used the next time a function is called.  The stack is always reserved in a LIFO (last in first out) order; the most recently reserved block is always the next block to be freed.  This makes it really simple to keep track of the stack; freeing a block from the stack is nothing more than adjusting one pointer.</source>
          <target state="translated">La pila es la memoria reservada como espacio para un hilo de ejecución.Cuando se llama a una función,se reserva un bloque en la parte superior de la pila para las variables locales y algunos datos de contabilidad.Cuando esa función regresa,el bloque queda sin usar y puede ser utilizado la próxima vez que se llame una función.La pila siempre se reserva en un orden LIFO (último en entrar primero en salir);el bloque reservado más recientemente es siempre el siguiente bloque que se libera.Esto hace que sea realmente sencillo llevar un registro de la pila;liberar un bloque de la pila no es más que ajustar un puntero.</target>
        </trans-unit>
        <trans-unit id="219301ffd0ca8cbb0f7920be42b12f92f7f93e51" translate="yes" xml:space="preserve">
          <source>The stack often works in close tandem with a special register on the CPU named the &lt;em&gt;stack pointer&lt;/em&gt;. Initially the stack pointer points to the top of the stack (the highest address on the stack).</source>
          <target state="translated">La pila a menudo funciona en conjunto con un registro especial en la CPU llamado &lt;em&gt;puntero de&lt;/em&gt; la &lt;em&gt;pila&lt;/em&gt; . Inicialmente, el puntero de la pila apunta a la parte superior de la pila (la direcci&amp;oacute;n m&amp;aacute;s alta en la pila).</target>
        </trans-unit>
        <trans-unit id="44325c548d04ad0c66e804e28b38a41e97cabb5a" translate="yes" xml:space="preserve">
          <source>There are two heaps: public and private.</source>
          <target state="translated">Hay dos montones:público y privado.</target>
        </trans-unit>
        <trans-unit id="6947fa83d8ffd6b15a325bb26b73b21bd69379ce" translate="yes" xml:space="preserve">
          <source>These images should do a fairly good job of describing the two ways of allocating and freeing memory in a stack and a heap.  Yum!</source>
          <target state="translated">Estas imágenes deberían hacer un buen trabajo al describir las dos formas de asignar y liberar la memoria en una pila y un montón.¡Qué rico!</target>
        </trans-unit>
        <trans-unit id="98d579f7a93657771058e9e0d89785c656c03025" translate="yes" xml:space="preserve">
          <source>They are all global to the program, but their contents can be private, public, or global.</source>
          <target state="translated">Todos son globales al programa,pero sus contenidos pueden ser privados,públicos o globales.</target>
        </trans-unit>
        <trans-unit id="9ef2da64dd7345ced1b7850afdf59a57b13427ca" translate="yes" xml:space="preserve">
          <source>They are not designed to be fast, they are designed to be useful. How the programmer utilizes them determines whether they are &quot;fast&quot; or &quot;slow&quot;</source>
          <target state="translated">No están diseñados para ser rápidos,están diseñados para ser útiles.La forma en que el programador las utiliza determina si son &quot;rápidas&quot; o &quot;lentas&quot;</target>
        </trans-unit>
        <trans-unit id="d177331b2e0afe564671649c9a49a92fcc2d64f0" translate="yes" xml:space="preserve">
          <source>This article is the source of picture above: &lt;a href=&quot;http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types#Stack%20and%20Heap&quot;&gt;Six important .NET concepts: Stack, heap, value types, reference types, boxing, and unboxing - CodeProject&lt;/a&gt;</source>
          <target state="translated">Este art&amp;iacute;culo es la fuente de la imagen de arriba: &lt;a href=&quot;http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types#Stack%20and%20Heap&quot;&gt;Seis conceptos importantes de .NET: pila, mont&amp;oacute;n, tipos de valores, tipos de referencia, boxeo y unboxing - CodeProject&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="717f1e13592dff5b361146af2de994b4dd7d6e98" translate="yes" xml:space="preserve">
          <source>This chain of suspended function calls is the stack, because elements in the stack (function calls) depend on each other.</source>
          <target state="translated">Esta cadena de llamadas de funciones suspendidas es la pila,porque los elementos de la pila (llamadas de funciones)dependen unos de otros.</target>
        </trans-unit>
        <trans-unit id="f0dbb83fd38c86e398ef0d609e84dfa07ea2c5b6" translate="yes" xml:space="preserve">
          <source>This is because of the way that memory is allocated on the stack.</source>
          <target state="translated">Esto se debe a la forma en que la memoria está asignada en la pila.</target>
        </trans-unit>
        <trans-unit id="fb3c5c901732960cbf1b7b18121a96994d8cfa9e" translate="yes" xml:space="preserve">
          <source>This is only practical if your memory usage is quite different from the norm - i.e for games where you load a level in one huge operation and can chuck the whole lot away in another huge operation.</source>
          <target state="translated">Esto sólo es práctico si su uso de la memoria es muy diferente de la norma,es decir,para los juegos en los que se carga un nivel en una gran operación y se puede tirar todo el lote en otra gran operación.</target>
        </trans-unit>
        <trans-unit id="ce81aba3a9e4c22e20ebcec915d127d8ea49a173" translate="yes" xml:space="preserve">
          <source>Thus, the heap is far more complex, because there end up being regions of memory that are unused interleaved with chunks that are - memory gets fragmented. Finding free memory of the size you need is a difficult problem. This is why the heap should be avoided (though it is still often used).</source>
          <target state="translated">Por lo tanto,el montón es mucho más complejo,porque terminan siendo regiones de la memoria que no se utilizan,intercaladas con trozos que son-la memoria se fragmenta.Encontrar memoria libre del tamaño que se necesita es un problema difícil.Es por eso que el montón debe ser evitado (aunque todavía se utiliza a menudo).</target>
        </trans-unit>
        <trans-unit id="3718bea08e5c6c1e1ef5855208635c1660091c56" translate="yes" xml:space="preserve">
          <source>To answer your questions directly:</source>
          <target state="translated">Para responder a sus preguntas directamente:</target>
        </trans-unit>
        <trans-unit id="e510eed8b65862876804eb3fc84dd696d12ba373" translate="yes" xml:space="preserve">
          <source>To clarify, &lt;a href=&quot;https://stackoverflow.com/a/13308092/1763801&quot;&gt;this answer&lt;/a&gt; has incorrect information (&lt;a href=&quot;https://stackoverflow.com/a/662454/1763801&quot;&gt;thomas&lt;/a&gt; fixed his answer after comments, cool :) ). Other answers just avoid explaining what static allocation means. So I will explain the three main forms of allocation and how they usually relate to the heap, stack, and data segment below. I also will show some examples in both C/C++ and Python to help people understand.</source>
          <target state="translated">Para aclarar, &lt;a href=&quot;https://stackoverflow.com/a/13308092/1763801&quot;&gt;esta respuesta&lt;/a&gt; tiene informaci&amp;oacute;n incorrecta ( &lt;a href=&quot;https://stackoverflow.com/a/662454/1763801&quot;&gt;Thomas&lt;/a&gt; arregl&amp;oacute; su respuesta despu&amp;eacute;s de los comentarios, genial :)). Otras respuestas simplemente evitan explicar qu&amp;eacute; significa la asignaci&amp;oacute;n est&amp;aacute;tica. Entonces, explicar&amp;eacute; las tres formas principales de asignaci&amp;oacute;n y c&amp;oacute;mo se relacionan generalmente con el segmento de mont&amp;oacute;n, pila y datos a continuaci&amp;oacute;n. Tambi&amp;eacute;n mostrar&amp;eacute; algunos ejemplos en C / C ++ y Python para ayudar a las personas a comprender.</target>
        </trans-unit>
        <trans-unit id="aba9caf0dd8ab1b5293cad558ca993a95a150673" translate="yes" xml:space="preserve">
          <source>To what extent are they controlled by the OS or language run-time?</source>
          <target state="translated">¿Hasta qué punto están controlados por el sistema operativo o el tiempo de ejecución del lenguaje?</target>
        </trans-unit>
        <trans-unit id="0d0079c7ce4541e2501b37e50c9d74ba8c7a5637" translate="yes" xml:space="preserve">
          <source>To what extent are they controlled by the OS or language runtime?</source>
          <target state="translated">¿Hasta qué punto están controlados por el sistema operativo o el tiempo de ejecución del lenguaje?</target>
        </trans-unit>
        <trans-unit id="38a1226205399953841a1f147c1b73da6efe0983" translate="yes" xml:space="preserve">
          <source>Unlike the stack, the heap does not have size restrictions on variable size (apart from the obvious physical limitations of your computer). Heap memory is slightly slower to be read from and written to, because one has to use pointers to access memory on the heap. We will talk about pointers shortly.</source>
          <target state="translated">A diferencia de la pila,el montón no tiene restricciones de tamaño en el tamaño variable (aparte de las obvias limitaciones físicas de su ordenador).La memoria del montón es ligeramente más lenta para ser leída y escrita,porque hay que usar punteros para acceder a la memoria del montón.Hablaremos de los punteros en breve.</target>
        </trans-unit>
        <trans-unit id="5a0471929b5ff3505424261361762519c6273689" translate="yes" xml:space="preserve">
          <source>Unlike the stack, variables created on the heap are accessible by any function, anywhere in your program. Heap variables are essentially global in scope.</source>
          <target state="translated">A diferencia de la pila,las variables creadas en el montón son accesibles por cualquier función,en cualquier lugar de su programa.Las variables del montón son esencialmente de alcance global.</target>
        </trans-unit>
        <trans-unit id="1c9512b6d7a011bae14a8693bd32c0ef50ceaf32" translate="yes" xml:space="preserve">
          <source>Used on demand to allocate a block of data for use by the program.</source>
          <target state="translated">Se utiliza a petición para asignar un bloque de datos para su uso por el programa.</target>
        </trans-unit>
        <trans-unit id="350c906ec4a09c92d2b1ef4efaf9a024398e8269" translate="yes" xml:space="preserve">
          <source>Usually has a maximum size already determined when your program starts.</source>
          <target state="translated">Por lo general,tiene un tamaño máximo ya determinado cuando se inicia el programa.</target>
        </trans-unit>
        <trans-unit id="dee4e9274b9716c1313c6fb0868f5a44bbadc5a1" translate="yes" xml:space="preserve">
          <source>Variables allocated on the heap have their memory allocated at run time and accessing this memory is a bit slower, but the heap size is only limited by the size of virtual memory. Elements of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time.</source>
          <target state="translated">Las variables asignadas en el montón tienen su memoria asignada en tiempo de ejecución y el acceso a esta memoria es un poco más lento,pero el tamaño del montón sólo está limitado por el tamaño de la memoria virtual.Los elementos del montón no tienen dependencias entre sí y siempre se puede acceder a ellos de forma aleatoria en cualquier momento.Se puede asignar un bloque en cualquier momento y liberarlo en cualquier momento.Esto hace que sea mucho más complejo llevar la cuenta de qué partes del montón están asignadas o libres en un momento dado.</target>
        </trans-unit>
        <trans-unit id="33c4c29193773c536fab56f19aa3e378c611f11a" translate="yes" xml:space="preserve">
          <source>Variables allocated on the stack are stored directly to the memory and access to this memory is very fast, and its allocation is dealt with when the program is compiled. When a function or a method calls another function which in turns calls another function, etc., the execution of all those functions remains suspended until the very last function returns its value. The stack is always reserved in a LIFO order, the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack, freeing a block from the stack is nothing more than adjusting one pointer.</source>
          <target state="translated">Las variables asignadas en la pila se almacenan directamente en la memoria y el acceso a esta memoria es muy rápido,y su asignación se trata cuando se compila el programa.Cuando una función o un método llama a otra función que a su vez llama a otra función,etc.,la ejecución de todas esas funciones permanece suspendida hasta que la última función devuelve su valor.La pila siempre se reserva en un orden LIFO,el último bloque reservado es siempre el siguiente bloque que se libera.Esto hace que sea realmente sencillo seguir la pila,liberar un bloque de la pila no es más que ajustar un puntero.</target>
        </trans-unit>
        <trans-unit id="b757f96ab6cbd88a78e6eb37e901095a0f4982d5" translate="yes" xml:space="preserve">
          <source>Variables can be accessed globally</source>
          <target state="translated">Se puede acceder a las variables a nivel mundial</target>
        </trans-unit>
        <trans-unit id="e1263b2fe0ce0f9a78ac08d33e5cb650a6f890af" translate="yes" xml:space="preserve">
          <source>Variables can be resized using realloc()</source>
          <target state="translated">Las variables pueden ser redimensionadas usando realloc()</target>
        </trans-unit>
        <trans-unit id="0acb71d1ea9ad7194e7c46ab11399d5d7dc9cbc1" translate="yes" xml:space="preserve">
          <source>Variables cannot be resized</source>
          <target state="translated">Las variables no pueden ser redimensionadas</target>
        </trans-unit>
        <trans-unit id="45bc57bc7c9a39f9e93f0ee2742931507b1a0117" translate="yes" xml:space="preserve">
          <source>Variables created on the stack will go out of scope and are automatically deallocated.</source>
          <target state="translated">Las variables creadas en la pila se saldrán del ámbito de aplicación y serán automáticamente deslocalizadas.</target>
        </trans-unit>
        <trans-unit id="83322fdd7220f9c3561a31019be7de90f70f1113" translate="yes" xml:space="preserve">
          <source>Very fast access</source>
          <target state="translated">Un acceso muy rápido</target>
        </trans-unit>
        <trans-unit id="81465c90cda3940dcc21c6d0fc345dbf62900490" translate="yes" xml:space="preserve">
          <source>Very fast access.</source>
          <target state="translated">Un acceso muy rápido.</target>
        </trans-unit>
        <trans-unit id="d03f25431e8717de4af8cfb5712d2af28175c6de" translate="yes" xml:space="preserve">
          <source>What and where are the stack and heap</source>
          <target state="translated">¿Qué y dónde están la pila y el montón</target>
        </trans-unit>
        <trans-unit id="e330f4218aa5748683c1aedc4c7ad3739182f7f9" translate="yes" xml:space="preserve">
          <source>What determines the size of each of them?</source>
          <target state="translated">¿Qué determina el tamaño de cada uno de ellos?</target>
        </trans-unit>
        <trans-unit id="780a2c071a1fa9df58512fef52b5d41ee762fbf5" translate="yes" xml:space="preserve">
          <source>What is their scope?</source>
          <target state="translated">¿Cuál es su alcance?</target>
        </trans-unit>
        <trans-unit id="b72db36173b02e399c3380ebce765f483206c5f5" translate="yes" xml:space="preserve">
          <source>What makes one faster?</source>
          <target state="translated">¿Qué hace que uno sea más rápido?</target>
        </trans-unit>
        <trans-unit id="7dd7be24ae5c5f3254644f00a932a8eaf93d7843" translate="yes" xml:space="preserve">
          <source>When a function is called the CPU uses special instructions that push the current &lt;em&gt;instruction pointer&lt;/em&gt;, i.e. the address of the code executing on the stack. The CPU then jumps to the function by setting the 
instruction pointer to the address of the function called. Later, when the function returns, the old instruction pointer is popped from the stack and execution resumes at the code just after the call to the function.</source>
          <target state="translated">Cuando se llama a una funci&amp;oacute;n, la CPU utiliza instrucciones especiales que empujan el &lt;em&gt;puntero de instrucci&amp;oacute;n&lt;/em&gt; actual, es decir, la direcci&amp;oacute;n del c&amp;oacute;digo que se ejecuta en la pila. Luego, la CPU salta a la funci&amp;oacute;n configurando el puntero de instrucci&amp;oacute;n a la direcci&amp;oacute;n de la funci&amp;oacute;n llamada. M&amp;aacute;s tarde, cuando la funci&amp;oacute;n regresa, el puntero de instrucci&amp;oacute;n anterior se saca de la pila y la ejecuci&amp;oacute;n se reanuda en el c&amp;oacute;digo justo despu&amp;eacute;s de la llamada a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="76bfa98cbe27f31d7e7e3e9a0604cbd18ab53032" translate="yes" xml:space="preserve">
          <source>When a function is entered, the stack pointer is decreased to allocate more space on the stack for local (automatic) variables. If the function has one local 32 bit variable four bytes are set aside on the stack. When the function returns, the stack pointer is moved back to free the allocated area.</source>
          <target state="translated">Cuando se introduce una función,el puntero de la pila se disminuye para asignar más espacio en la pila para las variables locales (automáticas).Si la función tiene una variable local de 32 bits,se reservan cuatro bytes en la pila.Cuando la función regresa,el puntero de la pila se mueve hacia atrás para liberar el área asignada.</target>
        </trans-unit>
        <trans-unit id="7345937a4022621af869e20017f6923e9e95b153" translate="yes" xml:space="preserve">
          <source>When a function or a method calls another function which in turns calls another function, etc., the execution of all those functions remains suspended until the very last function returns its value.</source>
          <target state="translated">Cuando una función o un método llama a otra función que a su vez llama a otra función,etc.,la ejecución de todas esas funciones permanece suspendida hasta que la última función devuelve su valor.</target>
        </trans-unit>
        <trans-unit id="17eea20994cf0f8b60ad7500e16ae0d2babaffb7" translate="yes" xml:space="preserve">
          <source>When a used block that is adjacent to a free block is deallocated the new free block may be merged with the adjacent free block to create a larger free block effectively reducing the fragmentation of the heap.</source>
          <target state="translated">Cuando un bloque usado que es adyacente a un bloque libre se deslocaliza,el nuevo bloque libre puede fusionarse con el bloque libre adyacente para crear un bloque libre más grande reduciendo efectivamente la fragmentación del montón.</target>
        </trans-unit>
        <trans-unit id="fc80e3d497340bb1dd2782f548d7a04ed5176215" translate="yes" xml:space="preserve">
          <source>When using fibers, green threads or coroutines, you &lt;em&gt;usually&lt;/em&gt; have a separate stack per function. (Technically, not just a stack but a whole context of execution is per function. Most importantly, CPU registers.) For every thread there're as many stacks as there're concurrently running functions, and the thread is switching between executing each function according to the logic of your program. When a function runs to its end, its stack is destroyed. So, &lt;strong&gt;the number and lifetimes of stacks&lt;/strong&gt; are dynamic and &lt;strong&gt;are not determined by the number of OS-level threads!&lt;/strong&gt;</source>
          <target state="translated">Al usar fibras, hilos verdes o corutinas, &lt;em&gt;generalmente&lt;/em&gt; tiene una pila separada por funci&amp;oacute;n. (T&amp;eacute;cnicamente, no solo una pila, sino un contexto completo de ejecuci&amp;oacute;n es por funci&amp;oacute;n. Lo m&amp;aacute;s importante es que la CPU se registra). Para cada hilo hay tantas pilas como funciones que se ejecutan simult&amp;aacute;neamente, y el hilo cambia entre ejecutar cada funci&amp;oacute;n seg&amp;uacute;n la l&amp;oacute;gica de tu programa. Cuando una funci&amp;oacute;n llega a su fin, su pila se destruye. Por lo tanto, &lt;strong&gt;el n&amp;uacute;mero y la vida &amp;uacute;til de las pilas&lt;/strong&gt; son din&amp;aacute;micas y &lt;strong&gt;no est&amp;aacute;n determinadas por el n&amp;uacute;mero de subprocesos a nivel de sistema operativo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a476cf0746ec4d2c4a044655c71d195262024622" translate="yes" xml:space="preserve">
          <source>Where and what are they (physically in a real computer's memory)?</source>
          <target state="translated">¿Dónde y qué son (físicamente en la memoria de un ordenador real)?</target>
        </trans-unit>
        <trans-unit id="1fb0c80cb7c016fa977e4e460c6d36c71cd287e5" translate="yes" xml:space="preserve">
          <source>Without stack &lt;strong&gt;no&lt;/strong&gt; microprocessor can work. (we can't imagine a program, even in assembly language, without subroutines/functions)</source>
          <target state="translated">Sin pila, &lt;strong&gt;ning&amp;uacute;n&lt;/strong&gt; microprocesador puede funcionar. (No podemos imaginar un programa, incluso en lenguaje ensamblador, sin subrutinas / funciones)</target>
        </trans-unit>
        <trans-unit id="010f37556d32304cf4397c04fe519e09ac87a1e2" translate="yes" xml:space="preserve">
          <source>Without the heap it can. (An assembly language program can work without, as the heap is a OS concept, as malloc, that is a OS/Lib call.</source>
          <target state="translated">Sin el montón que puede.(Un programa en lenguaje ensamblador puede funcionar sin,ya que el montón es un concepto de SO,como malloc,que es una llamada OSLib.</target>
        </trans-unit>
        <trans-unit id="3a9de33c793289bb4824480cb8f4087bf9168010" translate="yes" xml:space="preserve">
          <source>Wow! So many answers and I don't think one of them got it right...</source>
          <target state="translated">¡Vaya! Tantas respuestas y no creo que una de ellas haya sido correcta...</target>
        </trans-unit>
        <trans-unit id="b1e7c9f013a3dbd26304d7c5054c48167a4ae117" translate="yes" xml:space="preserve">
          <source>You can do some interesting things with the stack.  For instance, you have functions like &lt;a href=&quot;http://everything2.com/title/alloca%2528%2529&quot;&gt;alloca&lt;/a&gt; (assuming you can get past the copious warnings concerning its use), which is a form of malloc that specifically uses the stack, not the heap, for memory.</source>
          <target state="translated">Puedes hacer algunas cosas interesantes con la pila. Por ejemplo, tiene funciones como &lt;a href=&quot;http://everything2.com/title/alloca%2528%2529&quot;&gt;alloca&lt;/a&gt; (suponiendo que puede superar las abundantes advertencias sobre su uso), que es una forma de malloc que utiliza espec&amp;iacute;ficamente la pila, no el mont&amp;oacute;n, para la memoria.</target>
        </trans-unit>
        <trans-unit id="892eae56f7439ba3dcbb1ea3ea17d754f03b35eb" translate="yes" xml:space="preserve">
          <source>You can use the stack if you know exactly how much data you need to allocate before compile time, and it is not too big. You can use the heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data.</source>
          <target state="translated">Puedes usar la pila si sabes exactamente cuántos datos necesitas asignar antes de compilar el tiempo,y no es demasiado grande.Puedes usar la pila si no sabes exactamente cuántos datos necesitarás en tiempo de ejecución o si necesitas asignar muchos datos.</target>
        </trans-unit>
        <trans-unit id="3009d59448498f75aa79426e3fa60a5f198f2ebb" translate="yes" xml:space="preserve">
          <source>You can use the stack to pass parameters.. even if it is slower than using registers (would a microprocessor guru say or a good 1980s BIOS book...)</source>
          <target state="translated">Puedes usar la pila para pasar parámetros...incluso si es más lento que usar registros (¿diría un gurú de los microprocesadores o un buen libro de la BIOS de los 80...)</target>
        </trans-unit>
        <trans-unit id="6406486d2198ac8633b1773b5680854692fc022d" translate="yes" xml:space="preserve">
          <source>You must manage memory (you're in charge of allocating and freeing variables)</source>
          <target state="translated">Debes administrar la memoria (te encargas de asignar y liberar las variables)</target>
        </trans-unit>
        <trans-unit id="448cd0c4ab29afd1275bb72eaa06d3f1ffbebf2e" translate="yes" xml:space="preserve">
          <source>You would use the heap if you don't know exactly how much data you will need at run time or if you need to allocate a lot of data.</source>
          <target state="translated">Usarías el montón si no sabes exactamente cuántos datos necesitarás en tiempo de ejecución o si necesitas asignar muchos datos.</target>
        </trans-unit>
        <trans-unit id="21f0077be84d0a785692e7530efcb1dfe9e053c8" translate="yes" xml:space="preserve">
          <source>You would use the stack if you know exactly how much data you need to allocate before compile time and it is not too big.</source>
          <target state="translated">Usarías la pila si supieras exactamente cuántos datos necesitas asignar antes del tiempo de compilación y no es demasiado grande.</target>
        </trans-unit>
        <trans-unit id="2dd752e3a7242d730dc1ffd2af44fb8042a9cd98" translate="yes" xml:space="preserve">
          <source>and here:</source>
          <target state="translated">y aquí:</target>
        </trans-unit>
        <trans-unit id="e7cb8b2830bfb6729d691a0e8fc0b7ca5702106b" translate="yes" xml:space="preserve">
          <source>but be aware it may contain some inaccuracies.</source>
          <target state="translated">pero ten en cuenta que puede contener algunas inexactitudes.</target>
        </trans-unit>
        <trans-unit id="3e27b62ab595041b7d6fc3295ef65f967e4bb6d4" translate="yes" xml:space="preserve">
          <source>malloc requires entering kernel mode, use lock/semaphore (or other synchronization primitives) executing some code and manage some structures needed to keep track of allocation.</source>
          <target state="translated">malloc requiere entrar en modo kernel,utilizar locksemaphore (u otras primitivas de sincronización)ejecutando algún código y gestionar algunas estructuras necesarias para hacer un seguimiento de la asignación.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
