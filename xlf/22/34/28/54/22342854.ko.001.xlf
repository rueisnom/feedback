<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/22342854">
    <body>
      <group id="22342854">
        <trans-unit id="f7c8748664ce768e7e3182c81b903ff85a7320c5" translate="yes" xml:space="preserve">
          <source>(The last line means having the given tiles at the same time on the board).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(마지막 줄은 보드에 주어진 타일을 동시에 가지고 있음을 의미합니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42dcce363a0691ffc8b52eaa155b22573fd9214f" translate="yes" xml:space="preserve">
          <source>(There's a possibility to reach the 131072 tile if the 4-tile is randomly generated instead of the 2-tile when needed)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(필요한 경우 4 타일이 2 타일 대신 무작위로 생성되면 131072 타일에 도달 할 가능성이 있습니다)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b25f3cc01e7eaded5356820fc12a8514181d56e" translate="yes" xml:space="preserve">
          <source>2048 Variants and Clones</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2048 변종 및 클론&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88a139cf0ed644e82e3541f84922caa249ed18ea" translate="yes" xml:space="preserve">
          <source>42000</source>
          <target state="translated">42000</target>
        </trans-unit>
        <trans-unit id="355a0cd8af03872d9ce2928c8cb3da7c2fb6cd2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Edit:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Edit:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08f52696de29f7f7ec6dc0a8a919df2a38e9ebaf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The constants can be tweaked..&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참고 : 상수를 조정할 수 있습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8634e4a85ec9ad0d2495ed0458b0ec8c578e8935" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Algorithm&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45ea392fe0c3da367d8c51717f364d940fe4fe60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decision rule&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결정 규칙&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de42b3c305942617c48ca008230c0d5ed84ee53c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; This is a naive algorithm, modelling human conscious thought process, and gets very weak results compared to AI that search all possibilities since it only looks one tile ahead. It was submitted early in the response timeline.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;편집 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이것은 인간의 의식적 사고 과정을 모델링하는 순진한 알고리즘이며 AI보다 AI에 비해 매우 약한 결과를 얻습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;응답 타임 라인 초기에 제출되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b40ea2169b1372cb4d66f254c44144da5482dc88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Evaluation Details&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;평가 내용&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b321d0995c10030e9430af46a596a61260d1dad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Evaluation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Evaluation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fbce973333197ec3e114cf37edcb6ff4502f6e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heuristic scoring algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;휴리스틱 스코어링 알고리즘&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef6c3ec99e2445b2f8e789385112f8add04aca2a" translate="yes" xml:space="preserve">
          <source>A commenter on Hacker News gave &lt;a href=&quot;https://news.ycombinator.com/item?id=7381082&quot;&gt;an interesting formalization&lt;/a&gt; of this idea in terms of graph theory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해커 뉴스 (Hacker News)에 대한 논평자는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래프 이론 측면에서이 아이디어 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=7381082&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 흥미로운 공식화&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 제시했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0fc8abe55206bcc6fee5b9655148f68e7d675bb" translate="yes" xml:space="preserve">
          <source>A few pointers on the missing steps. Here:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;누락 된 단계에 대한 몇 가지 지침. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccab3659df4d866e5c99429991c48026db374125" translate="yes" xml:space="preserve">
          <source>A state is more flexible if it has more freedom of possible transitions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가능한 전환의 자유가 더 많으면 상태가 더 유연합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="884e259396760240aa757f365184412ce12cb6ac" translate="yes" xml:space="preserve">
          <source>AI Algorithm</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI 알고리즘&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="93e084b33c7ba167fbfbc4319e9d4f49b5668176" translate="yes" xml:space="preserve">
          <source>After implementing this algorithm I tried many improvements including using the min or max scores, or a combination of min,max,and avg. I also tried using depth: Instead of trying K runs per move, I tried K moves per move &lt;em&gt;list&lt;/em&gt; of a given length (&quot;up,up,left&quot; for example) and selecting the first move of the best scoring move list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 알고리즘을 구현 한 후 min 또는 max 점수 또는 min, max 및 avg 조합을 사용하여 많은 개선을 시도했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 깊이를 사용하여 시도했습니다. 이동 당 K 런을 시도하는 대신 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지정된 길이 (예 : &quot;위, 위, 왼쪽&quot;)의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;목록&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 당 K 이동을 시도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 최고 점수 이동 목록의 첫 번째 이동을 선택했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ede32df5eb0c24212c925595dd08fa4665c5adef" translate="yes" xml:space="preserve">
          <source>Also, I tried to increase the search depth cut-off from 3 to 5 (I can't increase it more since searching that space exceeds allowed time even with pruning) and added one more heuristic that looks at the values of adjacent tiles and gives more points if they are merge-able, but still I am not able to get 2048.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 검색 깊이 컷오프를 3에서 5로 늘리려 고했습니다 (정리로도 허용 된 시간을 초과하는 공간을 검색하면 더 많이 늘릴 수 없습니다). 인접한 타일의 값을보고 제공하는 휴리스틱을 추가 병합 가능하면 더 많은 포인트를 얻지 만 여전히 2048을 얻을 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a52d36040473cfee0c3dda94c4922ec62a49256f" translate="yes" xml:space="preserve">
          <source>An implementation of the minmax or the Expectiminimax will surely improve the algorithm. Obviously a more
sophisticated decision rule will slow down the algorithm and it will require some time to be implemented.I will try a minimax implementation in the near future. (stay tuned)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;minmax 또는 Expectiminimax를 구현하면 알고리즘이 확실히 향상됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보다 정교한 의사 결정 규칙은 알고리즘 속도를 늦추고 구현하는 데 약간의 시간이 필요합니다. 가까운 시일 내에 minimax 구현을 시도 할 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(계속 지켜봐주십시오)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81a3b22b9764c6db541f97a5b0cf0bc8185c33b4" translate="yes" xml:space="preserve">
          <source>An interesting fact about this algorithm is that while the random-play games are unsurprisingly quite bad, choosing the best (or least bad) move leads to very good game play: A typical AI game can reach 70000 points and last 3000 moves, yet the in-memory random play games from any given position yield an average of 340 additional points in about 40 extra moves before dying. (You can see this for yourself by running the AI and opening the debug console.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 알고리즘에 대한 흥미로운 사실은 랜덤 플레이 게임은 당연히 아주 나쁘지만 최상의 (또는 가장 나쁜) 움직임을 선택하면 매우 좋은 게임 플레이로 이어진다는 것입니다. 특정 위치의 메모리 내 무작위 플레이 게임은 죽기 전에 약 40 회의 추가 움직임으로 평균 340 개의 추가 점수를 얻습니다. AI를 실행하고 디버그 콘솔을 열어서 직접 확인할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9d2a26295c1d0085ec67a73a147f26c2d1f037d" translate="yes" xml:space="preserve">
          <source>And finally, there is a penalty for having too few free tiles, since options can quickly run out when the game board gets too cramped.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로, 게임 보드가 너무 좁아지면 옵션이 빨리 소진 될 수 있기 때문에 무료 타일이 너무 적 으면 패널티가 부과됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdf944fcd7b6a6e2a2ddfb040b0978330ad9950a" translate="yes" xml:space="preserve">
          <source>And that's it! Searching through the game space while optimizing these criteria yields remarkably good performance. One advantage to using a generalized approach like this rather than an explicitly coded move strategy is that the algorithm can often find interesting and unexpected solutions. If you watch it run, it will often make surprising but effective moves, like suddenly switching which wall or corner it's building up against.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 그게 다야! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 기준을 최적화하면서 게임 공간을 검색하면 성능이 크게 향상됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;명시 적으로 코딩 된 이동 전략 대신 이와 같은 일반화 된 접근 방식을 사용하는 한 가지 장점은 알고리즘이 종종 흥미롭고 예기치 않은 솔루션을 찾을 수 있다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 그것을 실행하는 경우, 그것은 벽이나 구석에 갑자기 건물을 전환 같은 놀라운하지만 효과적인 움직임을 만들 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38ffd01cfffffe720859de9ba280dc3a2fa18ebe" translate="yes" xml:space="preserve">
          <source>And the chain to get there has become:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 거기에 도달하는 사슬은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f168395e34c5d5a79b07cf3ea9c0184c6cfec5d9" translate="yes" xml:space="preserve">
          <source>Any insights will be really very helpful, thanks in advance. (This is the link of my blog post for the article: &lt;a href=&quot;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&quot;&gt;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&lt;/a&gt; and the youtube video: &lt;a href=&quot;https://www.youtube.com/watch?v=VnVFilfZ0r4&quot;&gt;https://www.youtube.com/watch?v=VnVFilfZ0r4&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 통찰력은 사전에 정말 도움이 될 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(이 기사에 대한 내 블로그 게시물의 링크는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve -2048-game-with-computer /&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 YouTube 동영상 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=VnVFilfZ0r4&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.youtube.com/watch?v=VnVFilfZ0r4&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccd9e8b01034b267d29c5745b84208f0a085f623" translate="yes" xml:space="preserve">
          <source>As a consequence, this solver is deterministic.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결과적으로이 솔버는 결정적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a7ad671d6cde8daae45c935046a605bf403cdad" translate="yes" xml:space="preserve">
          <source>At 1 moves/s: &lt;strong&gt;609104&lt;/strong&gt; (100 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1 이동 / 초 : &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;609104&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (평균 100 게임)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e5d64f1e0b61c1ef3e52e0d5823d5921bc21a50" translate="yes" xml:space="preserve">
          <source>At 10 moves/s: &lt;strong&gt;589355&lt;/strong&gt; (300 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10 이동 / 초 : &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;589355&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (평균 300 게임)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3c0d6ea43007ca3c28efb394b96f8a3287fcd1" translate="yes" xml:space="preserve">
          <source>At 3-ply (ca. 1500 moves/s): &lt;strong&gt;511759&lt;/strong&gt; (1000 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3 회 (약 1500 회 이동 / 초) : &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;511759&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (평균 1000 게임)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e93088674333bdf43b53fdb34644dc1838dfbd19" translate="yes" xml:space="preserve">
          <source>Below animation shows the last few steps of the game played by the AI agent with the computer player:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래 애니메이션은 AI 에이전트가 컴퓨터 플레이어와 함께 한 게임의 마지막 몇 단계를 보여줍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c12051095dc9a9f3c8c9322ba72366123f527e4" translate="yes" xml:space="preserve">
          <source>Below is the code implementing the solving algorithm. The grid is represented as a 16-length array of Integers. And scoring is done simply by counting the number of empty squares.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 해결 알고리즘을 구현하는 코드입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;격자는 16 길이의 정수 배열로 표시됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 빈 사각형의 수를 세어 간단히 점수를 매 깁니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="85a8f1bded86a0cdaa694a12d8a5a7691488a18a" translate="yes" xml:space="preserve">
          <source>Bit shift operations are used to extract individual rows and columns. A single row or column is a 16-bit quantity, so a table of size 65536 can encode transformations which operate on a single row or column. For example, moves are implemented as 4 lookups into a precomputed &quot;move effect table&quot; which describes how each move affects a single row or column (for example, the &quot;move right&quot; table contains the entry &quot;1122 -&amp;gt; 0023&quot; describing how the row [2,2,4,4] becomes the row [0,0,4,8] when moved to the right).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비트 시프트 연산은 개별 행과 열을 추출하는 데 사용됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단일 행 또는 열은 16 비트 수량이므로 크기가 65536 인 테이블은 단일 행 또는 열에서 작동하는 변환을 인코딩 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 이동은 각 이동이 단일 행 또는 열에 미치는 영향을 설명하는 사전 계산 된 &quot;이동 효과 테이블&quot;에 대한 4 개의 조회로 구현됩니다 (예 : &quot;오른쪽 이동&quot;테이블에는 &quot;1122-&amp;gt; 0023&quot;항목이 포함되어 있습니다. 행 [2,2,4,4]는 오른쪽으로 이동하면 행 [0,0,4,8]이됩니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c42c80d6b77bd2a349eaa2543cf5ddc744fe92ff" translate="yes" xml:space="preserve">
          <source>But, when I actually use this algorithm, I only get around 4000 points before the game terminates. Maximum points AFAIK is slightly more than 20,000 points which is way larger than my current score. Is there a better algorithm than the above?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 실제로이 알고리즘을 사용하면 게임이 끝나기 전에 약 4000 포인트 만 얻습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최대 점수 AFAIK는 현재 점수보다 훨씬 큰 20,000 점을 약간 넘습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위보다 더 나은 알고리즘이 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="d5026d402b84438a420117883e0b28d724275f57" translate="yes" xml:space="preserve">
          <source>Currently, the program achieves about a 90% win rate running in javascript in the browser on my laptop given about 100 milliseconds of thinking time per move, so while not perfect (yet!) it performs pretty well.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;현재이 프로그램은 랩톱 브라우저의 자바 스크립트에서 약 90 %의 승률을 달성하여 이동 당 약 100 밀리 초의 사고 시간을 제공하므로 완벽하지는 않지만 (아직 잘 수행되지는 않습니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="6c38d1c09dfbb8d9afb27b450f505d02e699af0a" translate="yes" xml:space="preserve">
          <source>First I created a JavaScript version which can be &lt;a href=&quot;http://ronzil.github.io/2048-AI/&quot;&gt;seen in action here&lt;/a&gt;. This version can run 100's of runs in decent time. Open the console for extra info. 
(&lt;a href=&quot;https://github.com/ronzil/2048-AI&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;먼저 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ronzil.github.io/2048-AI/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에서 작동&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는 JavaScript 버전을 만들었습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 버전은 적절한 시간에 100 회의 실행을 수행 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;추가 정보를 보려면 콘솔을여십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ronzil/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소스&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb6608935b3258a93b48bed3d51f17ee42bad070" translate="yes" xml:space="preserve">
          <source>For 3-ply:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3 겹의 경우 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afd41cc839be699428bd0fa94a187d2888e8230c" translate="yes" xml:space="preserve">
          <source>Free Space Available</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용 가능한 여유 공간&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f00400337de66f8cbfda3eb6257d6edb7ab4d834" translate="yes" xml:space="preserve">
          <source>Free Tiles</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프리 타일&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="05c3afb6f1373b0671a788c523440a2cdb7b67cf" translate="yes" xml:space="preserve">
          <source>Furthermore, Petr also optimized the heuristic weights using a &quot;meta-optimization&quot; strategy (using an algorithm called &lt;a href=&quot;https://en.wikipedia.org/wiki/CMA-ES&quot;&gt;CMA-ES&lt;/a&gt;), where the weights themselves were adjusted to obtain the highest possible average score.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 Petr는 &quot;메타 최적화&quot;전략을 사용하여 휴리스틱 가중치를 최적화했습니다 ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/CMA-ES&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CMA-ES&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라는 알고리즘 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;). 가중치 자체는 가능한 가장 높은 평균 점수를 얻도록 조정되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a006d33e016b3552046744f9daab00e3a9dea82" translate="yes" xml:space="preserve">
          <source>Here goes the algorithm. Around 80% wins (it seems it is always possible to win with more &quot;professional&quot; AI techniques, I am not sure about this, though.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기 알고리즘이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;약 80 %의 승리 (항상 더 많은 &quot;전문적인&quot;AI 기술로 승리하는 것이 가능할 것 같습니다.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fde7d59da7d0da4eb4e909565d46f8fa0c4121d" translate="yes" xml:space="preserve">
          <source>Here the model and chain is:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모델과 체인은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7f9a58f740830a3a6e0ce355d41b93414963aa63" translate="yes" xml:space="preserve">
          <source>Here we evaluate faces that have the possibility to getting to merge, by evaluating them backwardly, tile 2 become of value 2048, while tile 2048 is evaluated 2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에서는 타일 2를 평가하면 타일 2는 값 2048이되고 타일 2048은 2를 평가하여 병합 할 수있는면을 평가합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea14290a91583ca847b2ae45387c083c3b7f5174" translate="yes" xml:space="preserve">
          <source>Here's a demonstration of the power of this approach. I uncapped the tile values (so it kept going after reaching 2048) and here is the best result after eight trials.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은이 접근법의 힘에 대한 데모입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;타일 ​​값을 풀었습니다 (그래서 2048에 도달 한 후에 계속 진행됨). 여덟 번의 시도 후에 가장 좋은 결과가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f64374fb447322f3ae9648b3c8851f4e3a0a00f" translate="yes" xml:space="preserve">
          <source>Here's a screenshot of a perfectly monotonic grid. I obtained this by running the algorithm with the eval function set to disregard the other heuristics and only consider monotonicity.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 완벽하게 단조로운 격자의 스크린 샷입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 다른 휴리스틱을 무시하고 단 조성을 고려하기 위해 eval 함수로 알고리즘을 실행하여 이것을 얻었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f97f5d39b364919717cbfb83c95dfea658c2d11e" translate="yes" xml:space="preserve">
          <source>Here's a screenshot of a perfectly smooth grid, courtesy of &lt;a href=&quot;http://jennypeng.me/2048/&quot;&gt;this excellent parody fork&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://jennypeng.me/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 우수한 패러디 포크&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 의해 완벽하게 매끄러운 그리드의 스크린 샷 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b03d95f10bf2fb9649d305f295aac7854cae9194" translate="yes" xml:space="preserve">
          <source>Here's the screenshot of the best run:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최고의 실행의 스크린 샷은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ffac2906be85464582876c1fd5b67e5775ca4c9b" translate="yes" xml:space="preserve">
          <source>Heuristics</source>
          <target state="translated">Heuristics</target>
        </trans-unit>
        <trans-unit id="ed8ab7ed11c60bc100175f13e827da35c53e21c1" translate="yes" xml:space="preserve">
          <source>However, I have never observed it obtaining the 65536 tile.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 나는 65536 타일을 얻는 것을 본 적이 없다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="84fd09822e571ef59181c3b714b48c120c88bc2d" translate="yes" xml:space="preserve">
          <source>However, none of these ideas showed any real advantage over the simple first idea. I left the code for these ideas commented out in the C++ code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 이러한 아이디어 중 어느 것도 간단한 첫 번째 아이디어에 비해 실질적인 이점을 보여주지 못했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 아이디어에 대한 코드를 C ++ 코드에 주석 처리했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e64fedf544d393d02c17117048de608b040496d" translate="yes" xml:space="preserve">
          <source>I also tried the corner heuristic, but for some reason it makes the results worse, any intuition why?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 코너 휴리스틱을 시도했지만 어떤 이유로 인해 결과가 더 나빠집니다. 직관적 인 이유는 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bff61911fdd315b14809acd1b0718f81baa37d98" translate="yes" xml:space="preserve">
          <source>I am the author of a 2048 controller that scores better than any other program mentioned in this thread. An efficient implementation of the controller is available on &lt;a href=&quot;https://github.com/aszczepanski/2048&quot;&gt;github&lt;/a&gt;. In &lt;a href=&quot;https://github.com/wjaskowski/mastering-2048&quot;&gt;a separate repo&lt;/a&gt; there is also the code used for training the controller's state evaluation function. The training method is described in the &lt;a href=&quot;http://arxiv.org/abs/1604.05085&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 스레드에서 언급 한 다른 프로그램보다 점수가 높은 2048 컨트롤러의 저자입니다. 컨트롤러의 효율적인 구현은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/aszczepanski/2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;github에서&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가능합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 에서 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/wjaskowski/mastering-2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;별도의 repo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또한 컨트롤러의 상태 평가 기능을 훈련에 사용되는 코드가있다. 훈련 방법은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://arxiv.org/abs/1604.05085&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;논문에&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 설명되어 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b1878005b4715ef7dadf5dbab3530f2387e3d7d" translate="yes" xml:space="preserve">
          <source>I applied convex combination (tried different heuristic weights) of couple of heuristic evaluation functions, mainly from intuition and from the ones discussed above:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 주로 직관과 위에서 논의 된 것들로부터 몇 가지 휴리스틱 평가 기능의 볼록한 조합 (다른 휴리스틱 가중치를 시도)을 적용했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b340ff0771c0044d5631169bb8b9da7b0949767e" translate="yes" xml:space="preserve">
          <source>I became interested in the idea of an AI for this game containing &lt;strong&gt;no hard-coded intelligence&lt;/strong&gt; (i.e no heuristics, scoring functions etc). The AI should &lt;em&gt;&quot;know&quot;&lt;/em&gt; only the game rules, and &lt;em&gt;&quot;figure out&quot;&lt;/em&gt; the game play. This is in contrast to most AIs (like the ones in this thread) where the game play is essentially brute force steered by a scoring function representing human understanding of the game.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하드 코딩 된 인텔리전스&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (휴리스틱, 스코어링 기능 등) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;없는&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 게임의 AI 아이디어에 관심을 갖게되었습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게임 규칙 만 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;알고&quot;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 게임 플레이를 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;피겨&quot;야&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 게임 플레이가 본질적으로 게임에 대한 인간의 이해를 나타내는 스코어링 기능에 의해 조종되는 무차별적인 힘 (이 스레드의 것과 같은)과 대부분의 AI와 대조적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed0a579e8bb5a2fa1f190be9cc3a3984935966dd" translate="yes" xml:space="preserve">
          <source>I believe there's still room for improvement on the heuristics. This algorithm definitely isn't yet &quot;optimal&quot;, but I feel like it's getting pretty close.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;휴리스틱에 여전히 개선의 여지가 있다고 생각합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 알고리즘은 아직 &quot;최적화&quot;되지는 않았지만 꽤 가까워지고 있다고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8ed635115239705d2911e5bd2f5ced5edce99c5" translate="yes" xml:space="preserve">
          <source>I copy here the content of a &lt;a href=&quot;http://diaryofatinker.blogspot.it/2014/03/an-artificial-intelligence-for-2048-game.html&quot;&gt;post on my blog&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://diaryofatinker.blogspot.it/2014/03/an-artificial-intelligence-for-2048-game.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 블로그&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게시물&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 내용을 여기에 복사합니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d84a2a8980a497e88dd0c2f4d14dcecd79505253" translate="yes" xml:space="preserve">
          <source>I developed a 2048 AI using &lt;em&gt;expectimax&lt;/em&gt; optimization, instead of the minimax search used by @ovolve's algorithm. The AI simply performs maximization over all possible moves, followed by expectation over all possible tile spawns (weighted by the probability of the tiles, i.e. 10% for a 4 and 90% for a 2). As far as I'm aware, it is not possible to prune expectimax optimization (except to remove branches that are exceedingly unlikely), and so the algorithm used is a carefully optimized brute force search.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@ovolve 알고리즘에서 사용하는 minimax 검색 대신 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;expectimax&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 최적화를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하여 2048 AI를 개발했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. AI는 모든 가능한 움직임에 대한 최대화를 수행 한 다음 가능한 모든 타일 스폰에 대한 기대 (타일 확률에 따라 가중, 즉 4의 경우 10 %, 2의 경우 90 %)를 수행합니다. 내가 아는 한, 기대 최적화를 제거 할 수는 없으며 (매우 드물게 분기를 제거하는 것을 제외하고) 사용 된 알고리즘은 신중하게 최적화 된 무차별 대입 검색입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a35fdce8c7933d0b2a937ce2170823745b56f98" translate="yes" xml:space="preserve">
          <source>I did add a &quot;Deep Search&quot; mechanism that increased the run number temporarily to 1000000 when any of the runs managed to accidentally reach the next highest tile. This offered a time improvement.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;런 중 하나라도 실수로 다음 타일에 도달했을 때 런 수를 일시적으로 1000000으로 늘린 &quot;딥 검색&quot;메커니즘을 추가했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 시간 향상을 제공했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ba7f2fdb047681e855cdfd6b772b6db5b92aa4ee" translate="yes" xml:space="preserve">
          <source>I find it quite surprising that the algorithm doesn't need to actually foresee good game play in order to chose the moves that produce it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 알고리즘이 그것을 생성하는 움직임을 선택하기 위해 실제로 좋은 게임 플레이를 예측할 필요가 없다는 것이 놀랍습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2224c20bdfc42ec2f0bd05389e5c06114237583f" translate="yes" xml:space="preserve">
          <source>I found a simple yet surprisingly good playing algorithm: To determine the next move for a given board, the AI plays the game in memory using &lt;strong&gt;random moves&lt;/strong&gt; until the game is over. This is done several times while keeping track of the end game score. Then the average end score &lt;em&gt;per starting move&lt;/em&gt; is calculated. The starting move with the highest average end score is chosen as the next move.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단하지만 놀랍게도 좋은 재생 알고리즘을 발견했습니다. 주어진 보드의 다음 움직임을 결정하기 위해 AI는 게임 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 끝날 때까지 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;임의의 움직임을&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하여 메모리에서 게임을 재생합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 최종 게임 점수를 추적하면서 여러 번 수행됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시작 이동 당&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 평균 종료 점수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 계산됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;평균 점수가 가장 높은 시작 동작이 다음 동작으로 선택됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="031425862c087193c510d3992030621083927b33" translate="yes" xml:space="preserve">
          <source>I have 4x4 grid for playing the game.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게임을하기위한 4x4 그리드가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f56414c1f6736cdf7c56bfca13c15f73247b88ce" translate="yes" xml:space="preserve">
          <source>I have recently stumbled upon the game &lt;a href=&quot;http://gabrielecirulli.github.io/2048/&quot;&gt;2048&lt;/a&gt;. You merge similar tiles by moving them in any of the four directions to make &quot;bigger&quot; tiles. After each move, a new tile appears at random empty position with a value of either &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;. The game terminates when all the boxes are filled and there are no moves that can merge tiles, or you create a tile with a value of &lt;code&gt;2048&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 최근에 게임 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://gabrielecirulli.github.io/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2048을&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 우연히 발견했다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비슷한 타일을 네 방향 중 하나로 움직여 &quot;더 큰&quot;타일을 만듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 이동 후, 새로운 타일은 임의의 빈 위치에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 값으로 나타납니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 상자가 채워지고 타일을 병합 할 수있는 동작이 없거나 값이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2048&lt;/code&gt; 인&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 타일을 만들면 게임이 종료됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59f0d82a356c65bde837828cc539c2e8be89a87d" translate="yes" xml:space="preserve">
          <source>I have refined the algorithm and beaten the game! It may fail due to simple bad luck close to the end (you are forced to move down, which you should never do, and a tile appears where your highest should be. Just try to keep the top row filled, so moving left does not break the pattern), but basically you end up having a fixed part and a mobile part to play with. This is your objective:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘을 개선하고 게임을 이겼습니다! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;끝이 가까워지면 운이 나빠져 실패 할 수 있습니다. 패턴을 깨 뜨리십시오), 그러나 기본적으로 고정 부분과 모바일 부분을 가지고 놀게됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 당신의 목표입니다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e043b4a0622bd7bd4f4bff3f75f5289152c44dc3" translate="yes" xml:space="preserve">
          <source>I just tried my minimax implementation with alpha-beta pruning with search-tree depth cutoff at 3 and 5. I was trying to solve the same problem for a 4x4 grid as a project assignment for the &lt;strong&gt;edX course ColumbiaX: CSMM.101x Artificial Intelligence (AI)&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;방금 3과 5에서 검색 트리 깊이 컷오프를 사용하여 알파-베타 가지 치기를 사용하여 미니 맥스 구현을 시도했습니다 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. AI)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f7940b642881ad963c29c8e46d7cecbcc69643e3" translate="yes" xml:space="preserve">
          <source>I think I found an algorithm which works quite well, as I often reach scores over 10000, my personal best being around 16000. My solution does not aim at keeping biggest numbers in a corner, but to keep it in the top row.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;필자는 10000 점 이상의 점수에 도달하는 개인 알고리즘이 16000 정도 인 알고리즘을 발견했습니다. 내 솔루션은 가장 큰 숫자를 모퉁이에 두지 않고 최상위 행에 두는 것을 목표로합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="55f66ed61b2ad8167d89233045ef1fe2708fd931" translate="yes" xml:space="preserve">
          <source>I think it will be better to use Expectimax instead of minimax, but still I want to solve this problem with minimax only and obtain high scores such as 2048 or 4096. I am not sure whether I am missing anything.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;minimax 대신 Expectimax를 사용하는 것이 더 낫다고 생각하지만, minimax로만이 문제를 해결하고 2048 또는 4096과 같은 높은 점수를 얻고 싶습니다. 내가 빠진 것이 있는지 확실하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea165dbbcc05f8b9c0fee4d6f269ceb0aa9da587" translate="yes" xml:space="preserve">
          <source>I thinks it's quite successful for its simplicity. The result it reaches when starting with an empty grid and solving at depth 5 is:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 그것이 간단하기 때문에 꽤 성공적이라고 생각합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;빈 그리드로 시작하여 깊이 5에서 풀 때 도달하는 결과는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1034d585a72bb081cca29625c761242ddf856012" translate="yes" xml:space="preserve">
          <source>I used an exhaustive algorithm that favours empty tiles. It performs pretty quickly for depth 1-4, but on depth 5 it gets rather slow at a around 1 second per move.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 빈 타일을 선호하는 철저한 알고리즘을 사용했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;깊이 1-4에서는 꽤 빨리 수행되지만 깊이 5에서는 이동 당 약 1 초에 다소 느려집니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37173dc2be4bdb4d84b503ac96c838e5e06ad4e3" translate="yes" xml:space="preserve">
          <source>I wrote a 2048 solver in Haskell, mainly because I'm learning this language right now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 주로이 언어를 배우기 때문에 Haskell에서 2048 솔버를 썼습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46c02f631905ee5caf0b222fd7359a47400755dd" translate="yes" xml:space="preserve">
          <source>I'd be interested to hear if anyone has other improvement ideas that maintain the domain-independence of the AI.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인공 지능의 도메인 독립성을 유지하는 다른 개선 아이디어가있는 사람이 있다면 듣고 싶습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a1169010fb1d82ea350ecfb6aa43f3802bb8f9f2" translate="yes" xml:space="preserve">
          <source>I'm the author of the AI program that others have mentioned in this thread. You can view the AI in &lt;a href=&quot;http://ovolve.github.io/2048-AI/&quot;&gt;action&lt;/a&gt; or read the &lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;source&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;저는이 글에서 다른 사람들이 언급 한 AI 프로그램의 저자입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI의 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ovolve.github.io/2048-AI/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제 작동 상태를&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 보거나 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소스를&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 읽을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cff211afed3c58617e7600239f98eba6f99208de" translate="yes" xml:space="preserve">
          <source>If I assign too much weights to the first heuristic function or the second heuristic function, both the cases the scores the AI player gets are low. I played with many possible weight assignments to the heuristic functions and take a convex combination, but very rarely the AI player is able to score 2048. Most of the times it either stops at 1024 or 512.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫 번째 휴리스틱 함수 또는 두 번째 휴리스틱 함수에 너무 많은 가중치를 할당하면 AI 플레이어가 얻는 점수가 모두 낮습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;휴리스틱 함수에 가능한 많은 가중치를 부여하고 볼록한 조합을 취했지만 AI 플레이어가 2048을 득점 할 수있는 경우는 거의 없습니다. 대부분 1024 또는 512에서 멈 춥니 다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3ed4d38edf88c96646888aef4c5aee857217b77c" translate="yes" xml:space="preserve">
          <source>Implementation and Links</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현 및 링크&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="dae216ce28189a3dc03880a06f90efd300da2352" translate="yes" xml:space="preserve">
          <source>In case of T2, four tests in ten generate the 4096 tile with an average score of</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T2의 경우 10 번의 4 번의 테스트로 평균 점수가 4096 인 타일이 생성됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="06f4f3fea3016100595f36b33ff12f794776a418" translate="yes" xml:space="preserve">
          <source>In here we still need to check for stacked values, but in a lesser way that doesn't interrupt the flexibility parameters, so we have the sum of { x in [4,44] }.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서도 여전히 누적 값을 확인해야하지만 유연성 매개 변수를 방해하지 않는 더 적은 방법으로 {x in [4,44]}가됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c2636cc71bb825cadfd8c456577a98d04fe05b8" translate="yes" xml:space="preserve">
          <source>In my case, the computer player is completely random, but still i assumed adversarial settings and implemented the AI player agent as the max player.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;필자의 경우 컴퓨터 플레이어는 완전히 임의적이지만 여전히 적대적인 설정을 가정하고 AI 플레이어 에이전트를 최대 플레이어로 구현했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="23652927c0d25e443786d2f509c213988410f12c" translate="yes" xml:space="preserve">
          <source>Initially, I used two very simple heuristics, granting &quot;bonuses&quot; for open squares and for having large values on the edge. These heuristics performed pretty well, frequently achieving 16384 but never getting to 32768.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;처음에는 매우 간단한 두 가지 휴리스틱을 사용하여 열린 사각형에 &quot;보너스&quot;를 부여하고 가장자리에 큰 값을 지정했습니다. 이 휴리스틱은 꽤 잘 수행되어 16384를 달성하지만 32768에 도달하지는 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1545ea420f5c65b9c9bba94c946b329fa8251dc3" translate="yes" xml:space="preserve">
          <source>Just for fun, I've also &lt;a href=&quot;http://ronzil.github.io/2048AI-AllClones/&quot;&gt;implemented the AI as a bookmarklet&lt;/a&gt;, hooking into the game's controls. This allows the AI to work with the original game and &lt;strong&gt;many of its variants&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재미를 위해서 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ronzil.github.io/2048AI-AllClones/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI를 북마크릿으로 구현&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하여 게임 컨트롤에 연결했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 AI가 오리지널 게임과 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 변형&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 사용할 수있게합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="87ab7e933f551b05ada40bfa9c63b7d3a98505ae" translate="yes" xml:space="preserve">
          <source>Larger tile in the way: Increase the value of a smaller surrounding tile.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;방해가 큰 타일 : 주변 타일이 작을수록 가치가 높아집니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18be8c8127f21459189b5caf81e55e1002781278" translate="yes" xml:space="preserve">
          <source>Later I implemented a scoring tree that took into account the conditional probability of being able to play a move after a given move list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나중에 주어진 이동 목록 다음에 이동을 할 수있는 조건부 확률을 고려한 스코어링 트리를 구현했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d40de2c184332bb133e3c7b3f9b7106a46f6318" translate="yes" xml:space="preserve">
          <source>Later, in order to play around some more I used @nneonneo highly optimized infrastructure and implemented my version in C++. This version allows for up to 100000 runs per move and even 1000000 if you have the patience. Building instructions provided. It runs in the console and also has a remote-control to play the web version.
(&lt;a href=&quot;https://github.com/ronzil/2048-ai-cpp&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나중에 더 많은 것을 즐기기 위해 @nneonneo 고도로 최적화 된 인프라를 사용하고 내 버전을 C ++로 구현했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 버전을 사용하면 이동 당 최대 100000 회의 실행이 가능하며 인내심이있는 경우에는 1000000까지 실행할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;제공된 건물 지침. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;콘솔에서 실행되며 웹 버전을 재생할 수있는 리모컨도 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ronzil/2048-ai-cpp&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소스&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="44c2d6ea8314c3f98974d2ba1a58dd051bb32c6f" translate="yes" xml:space="preserve">
          <source>Many of the other answers use AI with computationally expensive searching of possible futures, heuristics, learning and the such. These are impressive and probably the correct way forward, but I wish to contribute another idea.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 많은 답변들은 AI를 사용하여 미래, 휴리스틱, 학습 등의 계산적으로 비싼 검색을 수행합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것들은 인상적이고 아마도 올바른 길이지만, 나는 다른 아이디어를 제공하고자합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2b46f31c24d9d078dc34aed0d4067c4f769ba53f" translate="yes" xml:space="preserve">
          <source>Model the sort of strategy that good players of the game use.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게임의 훌륭한 플레이어가 사용하는 전략을 모델링하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fd4c07fb20d7d76fbcadaea8ea7ddaaac986f8c7" translate="yes" xml:space="preserve">
          <source>Monotonicity</source>
          <target state="translated">Monotonicity</target>
        </trans-unit>
        <trans-unit id="44fc3fc0ab34b52134a7cd76d9bbcb14829e6e00" translate="yes" xml:space="preserve">
          <source>More spaces makes the state more flexible, we multiply by 128 (which is the median) since a grid filled with 128 faces is an optimal impossible state.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 많은 공간은 상태를 더 유연하게 만듭니다. 128 개의면으로 채워진 그리드는 최적의 불가능한 상태이므로 128 (중앙값)을 곱합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f62f4a60f5f356eabae5d8f3cb887dce903adda" translate="yes" xml:space="preserve">
          <source>My approach encodes the entire board (16 entries) as a single 64-bit integer (where tiles are the nybbles, i.e. 4-bit chunks). On a 64-bit machine, this enables the entire board to be passed around in a single machine register.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 접근 방식은 전체 보드 (16 개 항목)를 단일 64 비트 정수 (타일이 니블, 즉 4 비트 청크)로 인코딩합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;64 비트 시스템에서는 전체 보드를 단일 시스템 레지스터로 전달할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef5c72f488757b3c3972bc8a4c545658ae48db02" translate="yes" xml:space="preserve">
          <source>My attempt uses expectimax like other solutions above, but without bitboards. Nneonneo's solution can check 10millions of moves which is approximately a depth of 4 with 6 tiles left and 4 moves possible (2*6*4)&lt;sup&gt;4&lt;/sup&gt;. In my case, this depth takes too long to explore, I adjust the depth of expectimax search according to the number of free tiles left:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 시도는 위의 다른 솔루션과 마찬가지로 expectimax를 사용하지만 비트 보드는 사용하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nneonneo의 솔루션은 약 6 개의 타일이 남고 4 개의 이동이 가능하며 (2 * 6 * 4) &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 깊이 인 약 4 천만 이동을 확인할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;필자의 경우이 깊이는 탐색하는 데 너무 오래 걸립니다. 남은 무료 타일 수에 따라 expectimax 검색 깊이를 조정합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="57e8410bf6b4571c6670e5f2ee8f617e934c4d80" translate="yes" xml:space="preserve">
          <source>My current algorithm:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 현재 알고리즘 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bea5caec78afaf43f0643aa15a7e4f0a707e1354" translate="yes" xml:space="preserve">
          <source>My implementation of the game slightly differs from the actual game, in that a new tile is always a '2' (rather than 90% 2 and 10% 4). And that the new tile is not random, but always the first available one from the top left. This variant is also known as &lt;a href=&quot;https://jmfork.github.io/2048/&quot;&gt;Det 2048&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새 타일은 항상 '2'(90 % 2 및 10 % 4가 아니라)라는 점에서 게임 구현이 실제 게임과 약간 다릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 새로운 타일은 무작위가 아니지만 항상 왼쪽 상단에서 사용 가능한 첫 번째 타일입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 변형은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://jmfork.github.io/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Det 2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로도 알려져 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d18c870dbfd8a43034e5e38c25648f6a00c617cb" translate="yes" xml:space="preserve">
          <source>Observation:</source>
          <target state="translated">Observation:</target>
        </trans-unit>
        <trans-unit id="1d445de243f043f2a68c63600c349cf26b114c50" translate="yes" xml:space="preserve">
          <source>One, I need to follow a well-defined strategy to reach the goal. So, I thought of writing a program for it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하나, 목표를 달성하기 위해 잘 정의 된 전략을 따라야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서 나는 그것을위한 프로그램을 작성하는 것을 생각했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="640af8b8b4a6b17289c61d8f064089730a066c2e" translate="yes" xml:space="preserve">
          <source>Petr Mor&amp;aacute;vek (@xificurk) took my AI and added two new heuristics. The first heuristic was a penalty for having non-monotonic rows and columns which increased as the ranks increased, ensuring that  non-monotonic rows of small numbers would not strongly affect the score, but non-monotonic rows of large numbers hurt the score substantially. The second heuristic counted the number of potential merges (adjacent equal values) in addition to open spaces. These two heuristics served to push the algorithm towards monotonic boards (which are easier to merge), and towards board positions with lots of merges (encouraging it to align merges where possible for greater effect).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Petr Mor&amp;aacute;vek (@xificurk)은 AI를 가져 와서 새로운 휴리스틱을 추가했습니다. 첫 휴리스틱은 순위가 증가함에 따라 비-단조 행과 열을 갖는 것에 대한 패널티로, 작은 숫자의 비-단조 행이 점수에 큰 영향을 미치지 않을 것이지만, 큰 숫자의 비-단조 행이 점수를 크게 손상시킵니다. 두 번째 휴리스틱은 열린 공간 외에도 잠재적 병합 수 (인접 동일한 값)를 계산했습니다. 이 두 휴리스틱은 알고리즘을 단조로운 보드 (병합이 더 쉬운) 및 많은 병합이있는 보드 위치로 푸시하는 데 도움이되었습니다 (가능한 경우 병합을보다 효과적으로 적용하도록 권장).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="503f6e600737ff2f29cf68701e034324b5731a1b" translate="yes" xml:space="preserve">
          <source>Please see the code below:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래 코드를 참조하십시오 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6df2f58f408bc47f5e66563bfde9ff0172588105" translate="yes" xml:space="preserve">
          <source>Read the squares in the order shown above until the next squares value is greater than the current one. This presents the problem of trying to merge another tile of the same value into this square.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 사각형 값이 현재 값보다 클 때까지 위에 표시된 순서대로 사각형을 읽습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 같은 값의 다른 타일을이 사각형에 병합하려고 할 때 발생하는 문제를 나타냅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="33bfd3ccf12da33384e54b78f3b1b416cd79f5ee" translate="yes" xml:space="preserve">
          <source>Running 10000 runs with a temporary increase to 1000000 near critical positions managed to break this barrier less than 1% of the times achieving a max score of 129892 and the 8192 tile.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10000을 실행하면 임계 위치 근처에서 일시적으로 1000000으로 증가하여 최대 129892와 8192 타일을 달성하는 시간의 1 % 미만으로이 장벽을 무너 뜨 렸습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f53aad58499a66a812ae2a8fadd0d52bc3c90c03" translate="yes" xml:space="preserve">
          <source>Scoring is also done using table lookup. The tables contain heuristic scores computed on all possible rows/columns, and the resultant score for a board is simply the sum of the table values across each row and column.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스코어링은 또한 테이블 조회를 사용하여 수행됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;테이블에는 가능한 모든 행 / 열에 대해 계산 된 휴리스틱 점수가 포함되며 보드의 결과 점수는 각 행과 열의 테이블 값 합계입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f0d0289231f49f701b9b200b4a3eac54cedef68" translate="yes" xml:space="preserve">
          <source>Searching later I found this algorithm might be classified as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Monte-Carlo_tree_search#Pure_Monte_Carlo_game_search&quot;&gt;Pure Monte Carlo Tree Search&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나중에 검색하면이 알고리즘이 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Monte-Carlo_tree_search#Pure_Monte_Carlo_game_search&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pure Monte Carlo Tree Search&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 알고리즘 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;으로 분류 될 수 있음을 알았습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c6dc8c149cc76d5efe765ba938462b2a01c9d89" translate="yes" xml:space="preserve">
          <source>Second pointer, it has had bad luck and its main spot has been taken. It is likely that it will fail, but it can still achieve it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 번째 포인터, 그것은 운이 좋지 않았고 주요 지점이 잡혔습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실패 할 가능성이 있지만 여전히 달성 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f7bd04bc23d0d8eee5b56955d487fc2585d2855f" translate="yes" xml:space="preserve">
          <source>See it in action</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로보기&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b6e3041754015cf5ce95b9217697dd1eafce96ab" translate="yes" xml:space="preserve">
          <source>Several heuristics are used to direct the optimization algorithm towards favorable positions. The precise choice of heuristic has a huge effect on the performance of the algorithm. The various heuristics are weighted and combined into a positional score, which determines how &quot;good&quot; a given board position is. The optimization search will then aim to maximize the average score of all possible board positions. The actual score, as shown by the game, is &lt;em&gt;not&lt;/em&gt; used to calculate the board score, since it is too heavily weighted in favor of merging tiles (when delayed merging could produce a large benefit).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최적화 알고리즘을 유리한 위치로 향하게하는 데 몇 가지 휴리스틱이 사용됩니다. 휴리스틱을 정확하게 선택하면 알고리즘 성능에 큰 영향을 미칩니다. 다양한 휴리스틱이 가중되고 위치 점수로 결합되어 주어진 보드 위치가 얼마나 &quot;좋은&quot;지를 결정합니다. 그런 다음 최적화 검색은 가능한 모든 보드 위치의 평균 점수를 최대화하는 것을 목표로합니다. 게임에 표시된 것처럼 실제 점수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 보드 점수를 계산하는 데 사용 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되지 않습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 지연된 병합이 큰 이점을 가져올 수있는 경우에는 타일 병합에 유리하게 가중치가 너무 높기 때문입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2318e6fc587a3fb272235edad6036fe0432bc136" translate="yes" xml:space="preserve">
          <source>Several linear path could be evaluated at once, the final score will be the maximum score of any path.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여러 선형 경로를 한 번에 평가할 수 있으며 최종 점수는 모든 경로의 최대 점수입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c72dd283f25dc910b0a759e6f55e51f7b00e7039" translate="yes" xml:space="preserve">
          <source>Since the game is a discrete state space, perfect information, turn-based game like chess and checkers, I used the same methods that have been proven to work on those games, namely &lt;a href=&quot;http://www.flyingmachinestudios.com/programming/minimax/&quot;&gt;minimax&lt;/a&gt;&lt;a href=&quot;http://xkcd.com/832/&quot;&gt;search&lt;/a&gt; with &lt;a href=&quot;http://cs.ucla.edu/~rosen/161/notes/alphabeta.html&quot;&gt;alpha-beta pruning&lt;/a&gt;. Since there is already a lot of info on that algorithm out there, I'll just talk about the two main heuristics that I use in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_function&quot;&gt;static evaluation function&lt;/a&gt; and which formalize many of the intuitions that other people have expressed here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게임은 개별 상태 공간, 완벽한 정보, 체스 및 체커와 같은 턴 기반 게임이므로 &lt;/font&gt;&lt;a href=&quot;http://cs.ucla.edu/~rosen/161/notes/alphabeta.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알파 베타 전정을&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용한 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.flyingmachinestudios.com/programming/minimax/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;미니 맥스 &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;http://xkcd.com/832/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;검색&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같은 게임에서 작동하는 것으로 입증 된 동일한 방법을 사용했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이미 그 알고리즘에 대한 많은 정보가 있기 때문에 &lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정적 평가 함수&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 다른 사람들이 여기에서 표현한 많은 직관을 공식화 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하는 두 가지 주요 휴리스틱에 대해 이야기 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하겠습니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e8fae6a7d3630d681d8de0ed1a7709b1c53526c" translate="yes" xml:space="preserve">
          <source>Smoothness</source>
          <target state="translated">Smoothness</target>
        </trans-unit>
        <trans-unit id="54e739c3c9f2519ccb923360ccad36f552ea579c" translate="yes" xml:space="preserve">
          <source>So it will press right, then right again, then (right or top depending on where the 4 has created) then will proceed to complete the chain until it gets:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 오른쪽을 누른 다음 다시 오른쪽을 누른 다음 (4가 생성 된 위치에 따라 오른쪽 또는 위쪽) 다음 체인이 완성 될 때까지 완료합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5257bddfe2fa589fbea354e939d68bfb692b503b" translate="yes" xml:space="preserve">
          <source>So now the model and chain are back to:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 모델과 체인이 다시 돌아 왔습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d7078edb0dd35daa33a7253a4d53d2a945faccd6" translate="yes" xml:space="preserve">
          <source>Source code can be found here: &lt;a href=&quot;https://github.com/popovitsj/2048-haskell&quot;&gt;https://github.com/popovitsj/2048-haskell&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소스 코드는 여기에서 찾을 수 있습니다 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/popovitsj/2048-haskell&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/popovitsj/2048-haskell&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5347810276aac1267928f350b554c90eab90a356" translate="yes" xml:space="preserve">
          <source>Surprisingly, increasing the number of runs does not drastically improve the game play. There seems to be a limit to this strategy at around 80000 points with the 4096 tile and all the smaller ones, very close to the achieving the 8192 tile. Increasing the number of runs from 100 to 100000 increases the &lt;strong&gt;odds&lt;/strong&gt; of getting to this score limit (from 5% to 40%) but not breaking through it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;놀랍게도, 런 수를 늘리더라도 게임 플레이가 크게 향상되지는 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 전략에는 4096 개의 타일과 8192 개의 타일을 달성하는 데 매우 가까운 모든 작은 타일이있는 약 80000 포인트에서 한계가있는 것 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;런 수를 100에서 100000으로 늘리면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 점수 한도 (5 %에서 40 %)에 도달 할 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가능성&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 높아지지만이를 통과하지는 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d074ffd075253a11df5ddc58441a0bc90e0b8963" translate="yes" xml:space="preserve">
          <source>T1 - 121 tests - 8 different paths - r=0.125</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T1-121 테스트-8 가지 경로-r = 0.125&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dc6bff919d7f07511beebccbf002e3261f59cb65" translate="yes" xml:space="preserve">
          <source>T2 - 122 tests - 8-different paths - r=0.25</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T2-122 테스트-8 개의 다른 경로-r = 0.25&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="296be33c2b9427ee450731728dde4547f54e382a" translate="yes" xml:space="preserve">
          <source>T3 - 132 tests - 8-different paths - r=0.5</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T3-132 테스트-8 가지 경로-r = 0.5&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc1b12f4c9d96129539fb80e7cdef31ccdf979f5" translate="yes" xml:space="preserve">
          <source>T4 - 211 tests - 2-different paths - r=0.125</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T4-211 테스트-2 개의 다른 경로-r = 0.125&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e14691f69c083c98b5cb57561d0905750d23ecc3" translate="yes" xml:space="preserve">
          <source>T5 - 274 tests - 2-different paths - r=0.25</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T5-274 테스트-2 가지 경로-r = 0.25&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c4e6556dc89bf3c2350cf0f2df946297023854c7" translate="yes" xml:space="preserve">
          <source>T6 - 211 tests - 2-different paths - r=0.5</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T6-211 테스트-2 개의 다른 경로-r = 0.5&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0c7d1cbd690845a24654fefbd0a09ba800d4230d" translate="yes" xml:space="preserve">
          <source>That the AI achieves the 32768 tile in over a third of its games is a huge milestone; I will be surprised to hear if any human players have achieved 32768 on the official game (i.e. without using tools like savestates or undo). I think the 65536 tile is within reach!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI가 게임의 1/3 이상에서 32768 타일을 달성한다는 것은 큰 이정표입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공식 게임에서 인간 플레이어가 32768을 달성했다면 (즉, savestates 또는 undo와 같은 도구를 사용하지 않음) 나는 놀랄 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;65536 타일이 도달 할 수 있다고 생각합니다!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89cc096445275d0b61d3321d2f66e3dd178f9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O&lt;/code&gt; represent forbidden spaces...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;O&lt;/code&gt; 는&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 금지 구역을 나타내는 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c7dde9a3e75b8eeff3662608ec5b45fcb967f49" translate="yes" xml:space="preserve">
          <source>The AI in its default configuration (max search depth of 8) takes anywhere from 10ms to 200ms to execute a move, depending on the complexity of the board position. In testing, the AI achieves an average move rate of 5-10 moves per second over the course of an entire game. If the search depth is limited to 6 moves, the AI can easily execute 20+ moves per second, which makes for some &lt;a href=&quot;https://www.youtube.com/watch?v=96ab_dK6JM0&quot;&gt;interesting watching&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 구성의 AI (최대 검색 깊이 8)는 보드 위치의 복잡성에 따라 이동을 실행하는 데 10ms에서 200ms까지 걸립니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;테스트에서 AI는 전체 게임을 진행하는 동안 초당 평균 이동 속도가 5-10 회 달성합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;검색 깊이가 6 이동으로 제한되면 AI는 초당 20+ 이동을 쉽게 실행할 수있어 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=96ab_dK6JM0&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재미있는 시청이 가능&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fb5e1a1c14a7f3f4df0734b1b830faeee1bc279" translate="yes" xml:space="preserve">
          <source>The above heuristic alone tends to create structures in which adjacent tiles are decreasing in value, but of course in order to merge, adjacent tiles need to be the same value. Therefore, the smoothness heuristic just measures the value difference between neighboring tiles, trying to minimize this count.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 휴리스틱만으로도 인접한 타일의 가치가 감소하는 구조를 만드는 경향이 있지만 물론 병합하기 위해서는 인접한 타일의 값이 동일해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 매끄러움 휴리스틱은 인접한 타일 간의 값 차이를 측정하여이 수를 최소화하려고합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a1da09880219429d0cbd02709fa5c5c73d1b6f56" translate="yes" xml:space="preserve">
          <source>The algorithm is iterative deepening depth first alpha-beta search. The evaluation function tries to keep the rows and columns monotonic (either all decreasing or increasing) while minimizing the number of tiles on the grid.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 알고리즘은 반복 심도 우선 알파-베타 검색입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;평가 기능은 그리드의 타일 수를 최소화하면서 행과 열을 단조롭게 (모두 감소 또는 증가) 유지하려고합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ef77e56b4c80bec7704196088642b9d80e9917f" translate="yes" xml:space="preserve">
          <source>The assumption on which my algorithm is based is rather simple: if you want to achieve higher score, the board must be kept as tidy as possible. In particular, the optimal setup is given by a linear and monotonic decreasing order of the tile values.
This intuition will give you also the upper bound for a tile value:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 알고리즘의 기반이되는 가정은 다소 간단합니다. 높은 점수를 얻으려면 보드를 최대한 깔끔하게 유지해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히, 최적의 설정은 타일 값의 선형 및 단조 감소 순서로 제공됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 직관은 타일 값의 상한도 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5dce83a7a7a2e8b3f3cbaad9c10d94bf6337d55b" translate="yes" xml:space="preserve">
          <source>The best achieved score is shown here:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최고 점수는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25c8ed43b28e01eb6dd519d1d9bd47b6abbd3671" translate="yes" xml:space="preserve">
          <source>The chosen corner is arbitrary, you basically never press one key (the forbidden move), and if you do, you press the contrary again and try to fix it. For future tiles the model always expects the next random tile to be a 2 and appear on the opposite side to the current model (while the first row is incomplete, on the bottom right corner, once the first row is completed, on the bottom left corner).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;선택한 모서리는 임의적이며 기본적으로 하나의 키 (금지 된 이동)를 누르지 마십시오. 그렇다면 반대를 다시 누르고 수정하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이후 타일의 경우 모델은 항상 다음 임의 타일이 2가 될 것으로 예상하고 현재 모델의 반대쪽에 나타납니다 (첫 번째 행은 불완전한 반면 첫 번째 행이 완료되면 첫 번째 행이 완료되면 왼쪽 하단에 나타남) 모서리).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d9103915dc08d03b8b554e741a0a622c2563f55" translate="yes" xml:space="preserve">
          <source>The code can be found on GiHub at the following link: &lt;a href=&quot;https://github.com/Nicola17/term2048-AI&quot;&gt;https://github.com/Nicola17/term2048-AI&lt;/a&gt;
It is based on &lt;a href=&quot;https://github.com/bfontaine/term2048&quot;&gt;term2048&lt;/a&gt; and it's written in Python. I will implement a more efficient version in C++ as soon as possible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드는 GiHub의 다음 링크에서 찾을 수 있습니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/Nicola17/term2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/Nicola17/term2048-AI &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/bfontaine/term2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;term2048을&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기반으로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하며 Python으로 작성되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가능한 빨리 C ++에서보다 효율적인 버전을 구현할 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30eb0aa61e89069340123d96861286e1d3a860a8" translate="yes" xml:space="preserve">
          <source>The controller uses expectimax search with a state evaluation function learned from scratch (without human 2048 expertise) by a variant of &lt;strong&gt;temporal difference learning&lt;/strong&gt; (a reinforcement learning technique). The state-value  function uses an &lt;strong&gt;n-tuple network&lt;/strong&gt;, which is basically a weighted linear function of patterns observed on the board. It involved more than &lt;strong&gt;1 billion weights&lt;/strong&gt;, in total.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컨트롤러는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간적 차이 학습&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (강화 학습 기술) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 변형에 의해 처음부터 (인간 2048 전문 지식없이) 배운 상태 평가 기능과 함께 expectimax 검색을 사용합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상태 값 함수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 기본적으로 보드에서 관찰되는 패턴의 가중 선형 함수 인 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n- 튜플 네트워크를&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;총 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10 억&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 개 이상의 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가중치&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 포함되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e8ea22403f787ccc54f78cea6ca391603d91a87" translate="yes" xml:space="preserve">
          <source>The decision rule implemented is not quite smart, the code in Python is presented here:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의사 결정 규칙이 현명하지는 않지만 파이썬 코드는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="176b0272d8eef889ba807dbf653b453ecd6067de" translate="yes" xml:space="preserve">
          <source>The effect of these changes are extremely significant. The algorithm went from achieving the 16384 tile around 13% of the time to achieving it over 90% of the time, and the algorithm began to achieve 32768 over 1/3 of the time (whereas the old heuristics never once produced a 32768 tile).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 변경의 효과는 매우 중요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘은 16384 타일을 시간의 약 13 %에서 90 % 이상 달성하는 것으로 전환했으며, 알고리즘은 1/3의 시간 동안 32768을 달성하기 시작했습니다. .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="283d1c0d9684c8a42130b57edb6f6b92f5b86665" translate="yes" xml:space="preserve">
          <source>The expectimax search itself is coded as a recursive search which alternates between &quot;expectation&quot; steps (testing all possible tile spawn locations and values, and weighting their optimized scores by the probability of each possibility), and &quot;maximization&quot; steps (testing all possible moves and selecting the one with the best score). The tree search terminates when it sees a previously-seen position (using a &lt;a href=&quot;http://en.wikipedia.org/wiki/Transposition_table&quot;&gt;transposition table&lt;/a&gt;), when it reaches a predefined depth limit, or when it reaches a board state that is highly unlikely (e.g. it was reached by getting 6 &quot;4&quot; tiles in a row from the starting position). The typical search depth is 4-8 moves.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;expectimax 검색 자체는 &quot;예측&quot;단계 (가능한 모든 타일 스폰 위치 및 값 테스트 및 각 가능성의 확률에 따라 최적화 된 점수 가중치 적용)와 &quot;최대화&quot;단계 (모든 가능한 이동 테스트) 사이를 번갈아 가며 반복되는 검색으로 코딩됩니다. 최고 점수를 가진 사람을 선택). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;트리 검색은 이전에 본 위치 ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Transposition_table&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;조옮김 테이블 사용&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )를 볼 때, 사전 정의 된 깊이 제한에 도달하거나 보드 상태가 매우 높지 않을 때 (예 : 6 &quot;4&quot;타일을 가져 와서 도달 한 경우) 종료됩니다. 시작 위치에서 연속해서). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적인 검색 깊이는 4-8 이동입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42f64f93fcb62fe61d13a7081dbd1385a6c16372" translate="yes" xml:space="preserve">
          <source>The following animation shows the last few steps of the game played where the AI player agent could get 2048 scores, this time adding the absolute value heuristic too:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 애니메이션은 AI 플레이어 에이전트가 2048 점을 얻을 수있는 게임의 마지막 몇 단계를 보여줍니다. 이번에는 절대 값 휴리스틱도 추가합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83682c685d59111d019249a4364f16870be09cd8" translate="yes" xml:space="preserve">
          <source>The following figures show the &lt;strong&gt;game tree&lt;/strong&gt; explored by the player AI agent assuming the computer as adversary for just a single step:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 그림 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 플레이어 AI 에이전트가 컴퓨터를 단 한 단계의 적이라고 가정 한 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게임 트리를&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 보여줍니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94d73024e25245de94e9edbd3aad5a30776360ec" translate="yes" xml:space="preserve">
          <source>The minimum score over all runs was 124024; the maximum score achieved was 794076. The median score is 387222. The AI never failed to obtain the 2048 tile (so it never lost the game even once in 100 games); in fact, it achieved the &lt;strong&gt;8192&lt;/strong&gt; tile at least once in every run!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 경기에서 최소 점수는 124024입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;달성 한 최대 점수는 794076입니다. 평균 점수는 387222입니다. AI는 2048 타일을 얻지 못했습니다 (100 게임에서 한 번이라도 게임을 잃지 않았습니다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;매 실행마다 적어도 한 번 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;8192&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 타일을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;달성했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c3427688b31e68bb54900072b17104508262705" translate="yes" xml:space="preserve">
          <source>The model has changed due to the luck of being closer to the expected model. The model the AI is trying to achieve is</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모델이 예상 모델에 가까워짐에 따라 모델이 변경되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI가 달성하려는 모델은&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1cdcb607ac22bbd92fb5b1889cdd98d3eecdba0a" translate="yes" xml:space="preserve">
          <source>The scores of the boards are computed with the weighted sum of the square of the number of free tiles and the dot product of the 2D grid with this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보드의 점수는 다음과 같이 사용 가능한 타일 수의 제곱과 2D 그리드의 내적의 가중 합계로 계산됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac8ac475f1d47ab38014e0ffd71fab5a7ebbc40c" translate="yes" xml:space="preserve">
          <source>The solution I propose is very simple and easy to implement. Although, it has reached the score of 131040. Several benchmarks of the algorithm performances are presented.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 제안하는 솔루션은 매우 간단하고 구현하기 쉽습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그럼에도 불구하고 점수는 131040입니다. 알고리즘 성능에 대한 여러 벤치 마크가 제공됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd5ada7eeaffca19f06bbf8ec2f5ee7d8e800c9d" translate="yes" xml:space="preserve">
          <source>The tile statistics for 10 moves/s are as follows:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10 이동 / 초의 타일 통계는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0dcd0aa110a697c4c67a6487fafa9f7c0823aa9f" translate="yes" xml:space="preserve">
          <source>The whole approach will likely be more complicated than this but not much more complicated. It could be this mechanical in feel lacking scores, weights, neurones and deep searches of possibilities. The tree of possibilities rairly even needs to be big enough to need any branching at all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전체 접근 방식은 이보다 더 복잡 할 수 있지만 훨씬 더 복잡하지는 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;점수, 무게, 뉴런 및 가능성에 대한 깊은 검색이 부족하다고 느끼는 것이이 기계 일 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가능성의 나무는 아무래도 분기가 전혀 필요하지 않을 정도로 커야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d4d3599a34b6269908c672524220c522c3745c8" translate="yes" xml:space="preserve">
          <source>There is already an AI implementation for this game &lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;here&lt;/a&gt;. Excerpt from README:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 게임에 대한 AI 구현이 이미 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;README에서 발췌 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50c76a9fd12162abedcd5b1269d96e3a48779a24" translate="yes" xml:space="preserve">
          <source>There is also a discussion on &lt;a href=&quot;https://news.ycombinator.com/item?id=7379821&quot;&gt;Hacker News&lt;/a&gt; about this algorithm that you may find useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;유용한 알고리즘에 대한 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=7379821&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해커 뉴스&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 대한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;토론도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e3943b324acda39f3164ad45d89f210e302e253" translate="yes" xml:space="preserve">
          <source>This algorithm is not optimal for winning the game, but it is fairly optimal in terms of performance and amount of code needed:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 알고리즘은 게임에서이기는 데는 적합하지 않지만 성능과 필요한 코드 양 측면에서 상당히 최적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81716cb6c61fa929b1da024c98b8e777682d352a" translate="yes" xml:space="preserve">
          <source>This board representation, along with the table lookup approach for movement and scoring, allows the AI to search a huge number of game states in a short period of time (over 10,000,000 game states per second on one core of my mid-2011 laptop).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 보드 표현은 이동 및 스코어링을위한 테이블 조회 접근 방식과 함께 AI가 짧은 기간 (2011 년 중반 노트북의 한 코어에서 초당 10,000,000 개 이상의 게임 상태)으로 수많은 게임 상태를 검색 할 수있게합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aab4a4bfd97ffe5030c2d295efd283014f0be653" translate="yes" xml:space="preserve">
          <source>This game took 27830 moves over 96 minutes, or an average of 4.8 moves per second.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 게임은 96 분에 걸쳐 27830 번의 이동 또는 초당 평균 4.8 개의 움직임이 필요했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1df55517328accd0f2dc6eb5550bd150b52fbce7" translate="yes" xml:space="preserve">
          <source>This graph illustrates this point: The blue line shows the board score after each move. The red line shows the algorithm's &lt;strong&gt;best&lt;/strong&gt; random-run end game score from that position. In essence, the red values are &quot;pulling&quot; the blue values upwards towards them, as they are the algorithm's best guess. It's interesting to see the red line is just a tiny bit above the blue line at each point, yet the blue line continues to increase more and more.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 그래프는이 점을 보여줍니다. 파란색 선은 각 이동 후 보드 점수를 나타냅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;빨간색 선은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해당 위치에서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘의 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최고의&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 랜덤 런 엔드 게임 점수를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보여줍니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;본질적으로 빨간색 값은 알고리즘의 가장 좋은 추측이므로 파란색 값을 위쪽으로 &quot;풀&quot;합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;빨간색 선이 각 지점에서 파란색 선보다 약간 위에있는 것을 보는 것은 흥미롭지 만 파란색 선은 계속 증가하고 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="15d9cef8b96ce070fccbc886d3f7a52230dd95c2" translate="yes" xml:space="preserve">
          <source>This heuristic tries to ensure that the values of the tiles are all either increasing or decreasing along both the left/right and up/down directions. This heuristic alone captures the intuition that many others have mentioned, that higher valued tiles should be clustered in a corner. It will typically prevent smaller valued tiles from getting orphaned and will keep the board very organized, with smaller tiles cascading in and filling up into the larger tiles.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 휴리스틱은 타일의 값이 모두 왼쪽 / 오른쪽 및 위 / 아래 방향을 따라 증가 또는 감소하는지 확인하려고합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 휴리스틱만으로도 많은 다른 사람들이 언급 한 직관을 포착 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 값이 작은 타일이 고아가되는 것을 방지하고 작은 타일이 계단식으로 배열되어 큰 타일에 채워져 보드가 매우 체계적으로 유지됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4404e8828677c74cccfa38f4bbfe1ae3bcfe6a7" translate="yes" xml:space="preserve">
          <source>This is a constant, used as a base-line and for other uses like testing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 기준선으로 사용되며 테스트와 같은 다른 용도로 사용되는 상수입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="406c95c020f4c2dd5ee8b09f0713c82e19af3169" translate="yes" xml:space="preserve">
          <source>This is a simplified check of the possibility of having merges within that state, without making a look-ahead.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 미리 보지 않고 해당 상태 내에서 병합 될 수있는 가능성에 대한 간단한 점검입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8131c0f0b0c2602cf4850dc23b1938260a7a7a9f" translate="yes" xml:space="preserve">
          <source>This is not a direct answer to OP's question, this is more of the stuffs (experiments) I tried so far to solve the same problem and obtained some results and have some observations that I want to share, I am curious if we can have some further insights from this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 OP의 질문에 대한 직접적인 대답이 아닙니다. 이것은 지금까지 동일한 문제를 해결하기 위해 시도한 몇 가지 결과 (결과)를 얻었으며 공유하고 싶은 관찰 결과를 얻었습니다. 이것으로부터 추가 통찰력.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="715df725c34a80cfb15f7cc31927abca202e48fb" translate="yes" xml:space="preserve">
          <source>This is possible due to domain-independent nature of the AI. Some of the variants are quite distinct, such as the Hexagonal clone.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 도메인의 독립적 인 AI 특성으로 인해 가능합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hexagonal clone과 같은 일부 변종은 매우 다릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2b8637dd6b7d75e139a375a20969b654b1c6a3f0" translate="yes" xml:space="preserve">
          <source>This is the model I chose by default.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 기본적으로 선택한 모델입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2dae92fa8773f5d81d34a41b5ee59edb28a87186" translate="yes" xml:space="preserve">
          <source>Tile needs merging with neighbour but is too small: Merge another neighbour with this one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;타일을 이웃과 병합해야하지만 너무 작습니다. 다른 이웃을이 타일과 병합하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70b105f3079699e06f3a1ca29fc49029280f2f09" translate="yes" xml:space="preserve">
          <source>To assess the score performance of the AI, I ran the AI 100 times (connected to the browser game via remote control). For each tile, here are the proportions of games in which that tile was achieved at least once:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI의 점수 성능을 평가하기 위해 AI를 100 회 실행했습니다 (리모콘을 통해 브라우저 게임에 연결됨). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 타일에 대해 해당 타일을 한 번 이상 달성 한 게임 비율은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="562dbd4dd3fb3dd997d921a85e8dd207938296af" translate="yes" xml:space="preserve">
          <source>To enforce the ordination of the tiles in a monotonic decreasing order, the score si computed as the sum of the linearized values on the board multiplied by the values of a geometric sequence with common ratio r&amp;lt;1 .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단조로운 내림차순으로 타일의 순서를 강제하기 위해, 점수 si는 보드상의 선형화 된 값의 합에 공통 비율 r &amp;lt;1을 갖는 기하학적 시퀀스의 값을 곱한 것으로 계산된다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1880862a60075224c2b8fdd3389edd49e7283e3" translate="yes" xml:space="preserve">
          <source>To resolve this problem, their are 2 ways to move that aren't left or worse up and examining both possibilities may immediately reveal more problems, this forms a list of dependancies, each problem requiring another problem to be solved first. I think I have this chain or in some cases tree of dependancies internally when deciding my next move, particularly when stuck.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 문제를 해결하기 위해 두 가지 방법으로 남거나 나 빠지지 않고 두 가지 가능성을 모두 검사하면 더 많은 문제가 즉시 드러날 수 있습니다. 이는 종속성 목록을 형성하며, 각 문제는 먼저 다른 문제를 해결해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 다음 체인을 결정할 때, 특히 갇힐 때이 체인 또는 일부 경우 내부 의존성 트리를 가지고 있다고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab12b80b60d258a6dfc62b5818e8f4e339ef4aca" translate="yes" xml:space="preserve">
          <source>Two possible ways of organizing the board are shown in the following images:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보드를 구성하는 두 가지 가능한 방법이 다음 이미지에 나와 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ffc914498a4f81efe7ad50334ca89a25026fc42b" translate="yes" xml:space="preserve">
          <source>What I am doing is at any point, I will try to merge the tiles with values &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;, that is, I try to have &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; tiles, as minimum as possible. If I try it this way, all other tiles were automatically getting merged and the strategy seems good.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가하고있는 일은 언제든지, 타일을 값 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 병합 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하려고 시도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. 즉, 가능한 한 최소 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 타일을 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하려고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 방법으로 시도하면 다른 모든 타일이 자동으로 병합되고 전략이 좋아 보입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0fe3580da7385572383dcfbcbfc67535e4972c3" translate="yes" xml:space="preserve">
          <source>What is the optimal algorithm for the game 2048</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게임 2048에 대한 최적의 알고리즘은 무엇입니까&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a2cd96c88d22411489171dc415feea04edc93dc" translate="yes" xml:space="preserve">
          <source>When it manages to reach the 128 it gains a whole row is gained again:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;128에 도달하면 전체 행을 다시 얻습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6cc2b46a0e2f9ee01b185acf82165706e2b0b69b" translate="yes" xml:space="preserve">
          <source>With just 100 runs (i.e in memory games) per move, the AI achieves the 2048 tile 80% of the times and the 4096 tile 50% of the times. Using 10000 runs gets the 2048 tile 100%, 70% for 4096 tile, and about 1% for the 8192 tile.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI는 한 번에 100 번의 런 (메모리 게임)으로 2048 타일을 80 %, 4096 타일을 50 % 달성합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10000 런을 사용하면 2048 타일은 100 %, 4096 타일은 70 %, 8192 타일은 약 1 %가됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3d1302c4890b9aa4694541642695d87a0b4b7ed" translate="yes" xml:space="preserve">
          <source>Yes, that's a 4096 alongside a 2048. =) That means it achieved the elusive 2048 tile three times on the same board.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇습니다. 2048과 함께 4096입니다. =) 같은 보드에서 2048 타일을 3 번 달성했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b44092dddcd4f744019f7228202fb6783f53c989" translate="yes" xml:space="preserve">
          <source>You can try the AI for yourself. The code is available at &lt;a href=&quot;https://github.com/nneonneo/2048-ai&quot;&gt;https://github.com/nneonneo/2048-ai&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI를 직접 사용해 볼 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/nneonneo/2048-ai&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/nneonneo/2048-ai&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 사용할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59ac2882d7af09f5c4e2a1c7e5c5bb0dcad83a76" translate="yes" xml:space="preserve">
          <source>code below or on &lt;a href=&quot;https://caub.github.io/misc/2048&quot;&gt;github&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래 또는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://caub.github.io/misc/2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;github의&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 코드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e9b496a0935b15e72709835275b0a4dd4c2a1c6" translate="yes" xml:space="preserve">
          <source>etc...</source>
          <target state="translated">etc...</target>
        </trans-unit>
        <trans-unit id="d8bd5af9109e98c522a44467b14c0ac230bbc8ca" translate="yes" xml:space="preserve">
          <source>where n is the number of tile on the board.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서 n은 보드의 타일 수입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f550c4f98092fb346941c9ffac4b20ee0d6c58a1" translate="yes" xml:space="preserve">
          <source>which forces to organize tiles descendingly in a sort of snake from the top left tile.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;왼쪽 상단 타일에서 일종의 뱀으로 타일을 내림차순으로 구성합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
