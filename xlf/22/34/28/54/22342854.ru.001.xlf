<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/22342854">
    <body>
      <group id="22342854">
        <trans-unit id="f7c8748664ce768e7e3182c81b903ff85a7320c5" translate="yes" xml:space="preserve">
          <source>(The last line means having the given tiles at the same time on the board).</source>
          <target state="translated">(Последняя строка означает одновременное наличие данных плиток на доске).</target>
        </trans-unit>
        <trans-unit id="42dcce363a0691ffc8b52eaa155b22573fd9214f" translate="yes" xml:space="preserve">
          <source>(There's a possibility to reach the 131072 tile if the 4-tile is randomly generated instead of the 2-tile when needed)</source>
          <target state="translated">(Есть возможность достичь плитки 131072,если 4-х плитка генерируется случайным образом вместо 2-х плиток,когда это необходимо).</target>
        </trans-unit>
        <trans-unit id="1b25f3cc01e7eaded5356820fc12a8514181d56e" translate="yes" xml:space="preserve">
          <source>2048 Variants and Clones</source>
          <target state="translated">2048 Варианты и клоны</target>
        </trans-unit>
        <trans-unit id="88a139cf0ed644e82e3541f84922caa249ed18ea" translate="yes" xml:space="preserve">
          <source>42000</source>
          <target state="translated">42000</target>
        </trans-unit>
        <trans-unit id="355a0cd8af03872d9ce2928c8cb3da7c2fb6cd2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Edit:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Edit:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08f52696de29f7f7ec6dc0a8a919df2a38e9ebaf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The constants can be tweaked..&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примечание: константы могут быть изменены.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8634e4a85ec9ad0d2495ed0458b0ec8c578e8935" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Algorithm&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45ea392fe0c3da367d8c51717f364d940fe4fe60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decision rule&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Правило принятия решения&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de42b3c305942617c48ca008230c0d5ed84ee53c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; This is a naive algorithm, modelling human conscious thought process, and gets very weak results compared to AI that search all possibilities since it only looks one tile ahead. It was submitted early in the response timeline.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;РЕДАКТИРОВАТЬ:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Это наивный алгоритм, моделирующий сознательный мыслительный процесс человека, и дает очень слабые результаты по сравнению с ИИ, который ищет все возможности, так как он смотрит только вперед на одну плитку. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он был представлен в начале срока ответа.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b40ea2169b1372cb4d66f254c44144da5482dc88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Evaluation Details&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Детали оценки&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b321d0995c10030e9430af46a596a61260d1dad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Evaluation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Evaluation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fbce973333197ec3e114cf37edcb6ff4502f6e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heuristic scoring algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эвристический алгоритм оценки&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef6c3ec99e2445b2f8e789385112f8add04aca2a" translate="yes" xml:space="preserve">
          <source>A commenter on Hacker News gave &lt;a href=&quot;https://news.ycombinator.com/item?id=7381082&quot;&gt;an interesting formalization&lt;/a&gt; of this idea in terms of graph theory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Комментатор Hacker News дал &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=7381082&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;интересную формализацию&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; этой идеи с точки зрения теории графов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0fc8abe55206bcc6fee5b9655148f68e7d675bb" translate="yes" xml:space="preserve">
          <source>A few pointers on the missing steps. Here:</source>
          <target state="translated">Несколько указателей на недостающие шаги.Вот:</target>
        </trans-unit>
        <trans-unit id="ccab3659df4d866e5c99429991c48026db374125" translate="yes" xml:space="preserve">
          <source>A state is more flexible if it has more freedom of possible transitions.</source>
          <target state="translated">Государство является более гибким,если оно обладает большей свободой возможных переходов.</target>
        </trans-unit>
        <trans-unit id="884e259396760240aa757f365184412ce12cb6ac" translate="yes" xml:space="preserve">
          <source>AI Algorithm</source>
          <target state="translated">алгоритм искусственного осеменения</target>
        </trans-unit>
        <trans-unit id="93e084b33c7ba167fbfbc4319e9d4f49b5668176" translate="yes" xml:space="preserve">
          <source>After implementing this algorithm I tried many improvements including using the min or max scores, or a combination of min,max,and avg. I also tried using depth: Instead of trying K runs per move, I tried K moves per move &lt;em&gt;list&lt;/em&gt; of a given length (&quot;up,up,left&quot; for example) and selecting the first move of the best scoring move list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;После реализации этого алгоритма я попробовал много улучшений, включая использование минимальных или максимальных оценок или комбинацию минимальных, максимальных и средних значений. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я также попытался использовать глубину: вместо того, чтобы пытаться выполнить K прогонов за ход, я пробовал K ходов за &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;список&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ходов &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;заданной длины (например, &amp;laquo;вверх, вверх, влево&amp;raquo;) и выбирал первый ход из &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;списка&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ходов &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;с лучшим выигрышем.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ede32df5eb0c24212c925595dd08fa4665c5adef" translate="yes" xml:space="preserve">
          <source>Also, I tried to increase the search depth cut-off from 3 to 5 (I can't increase it more since searching that space exceeds allowed time even with pruning) and added one more heuristic that looks at the values of adjacent tiles and gives more points if they are merge-able, but still I am not able to get 2048.</source>
          <target state="translated">Также я попытался увеличить глубину поиска отсечения с 3 до 5 (я не могу увеличить ее больше,так как поиск этого пространства превышает допустимое время даже при обрезке)и добавил еще один эвристический,который смотрит на значения соседних плиток и дает больше очков,если они могут быть слиты,но все равно не могу получить 2048.</target>
        </trans-unit>
        <trans-unit id="a52d36040473cfee0c3dda94c4922ec62a49256f" translate="yes" xml:space="preserve">
          <source>An implementation of the minmax or the Expectiminimax will surely improve the algorithm. Obviously a more
sophisticated decision rule will slow down the algorithm and it will require some time to be implemented.I will try a minimax implementation in the near future. (stay tuned)</source>
          <target state="translated">Реализация minmax или Expectiminimax,несомненно,улучшит алгоритм.Очевидно,что более сложное правило принятия решения замедлит работу алгоритма,и на его реализацию потребуется некоторое время,в ближайшее время я попробую реализовать минимакс.(следите за новостями)</target>
        </trans-unit>
        <trans-unit id="81a3b22b9764c6db541f97a5b0cf0bc8185c33b4" translate="yes" xml:space="preserve">
          <source>An interesting fact about this algorithm is that while the random-play games are unsurprisingly quite bad, choosing the best (or least bad) move leads to very good game play: A typical AI game can reach 70000 points and last 3000 moves, yet the in-memory random play games from any given position yield an average of 340 additional points in about 40 extra moves before dying. (You can see this for yourself by running the AI and opening the debug console.)</source>
          <target state="translated">Интересный факт в этом алгоритме заключается в том,что в то время как случайные игры являются неудивительно довольно плохими,выбор лучшего (или наименее плохого)хода приводит к очень хорошей игровой игре:Типичная ИИ игра может достигать 70000 очков и последних 3000 ходов,но партии со случайной игрой с любой заданной позиции дают в среднем 340 дополнительных очков примерно за 40 дополнительных ходов до смерти.(Вы можете убедиться в этом сами,запустив ИИ и открыв отладочную консоль).</target>
        </trans-unit>
        <trans-unit id="e9d2a26295c1d0085ec67a73a147f26c2d1f037d" translate="yes" xml:space="preserve">
          <source>And finally, there is a penalty for having too few free tiles, since options can quickly run out when the game board gets too cramped.</source>
          <target state="translated">И,наконец,есть наказание за то,что слишком мало бесплатных плиток,так как варианты могут быстро закончиться,когда игровая доска становится слишком тесной.</target>
        </trans-unit>
        <trans-unit id="fdf944fcd7b6a6e2a2ddfb040b0978330ad9950a" translate="yes" xml:space="preserve">
          <source>And that's it! Searching through the game space while optimizing these criteria yields remarkably good performance. One advantage to using a generalized approach like this rather than an explicitly coded move strategy is that the algorithm can often find interesting and unexpected solutions. If you watch it run, it will often make surprising but effective moves, like suddenly switching which wall or corner it's building up against.</source>
          <target state="translated">И всё! Поиск по игровому пространству при оптимизации этих критериев дает удивительно хорошую производительность.Одним из преимуществ использования такого обобщенного подхода,а не явно закодированной стратегии перемещения,является то,что алгоритм часто может находить интересные и неожиданные решения.Если вы посмотрите,как он работает,он часто будет делать неожиданные,но эффективные ходы,например,внезапно переключаться,к какой стене или углу он примыкает.</target>
        </trans-unit>
        <trans-unit id="38ffd01cfffffe720859de9ba280dc3a2fa18ebe" translate="yes" xml:space="preserve">
          <source>And the chain to get there has become:</source>
          <target state="translated">И цепь,чтобы добраться туда,стала:</target>
        </trans-unit>
        <trans-unit id="f168395e34c5d5a79b07cf3ea9c0184c6cfec5d9" translate="yes" xml:space="preserve">
          <source>Any insights will be really very helpful, thanks in advance. (This is the link of my blog post for the article: &lt;a href=&quot;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&quot;&gt;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&lt;/a&gt; and the youtube video: &lt;a href=&quot;https://www.youtube.com/watch?v=VnVFilfZ0r4&quot;&gt;https://www.youtube.com/watch?v=VnVFilfZ0r4&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Любые идеи будут действительно очень полезны, спасибо заранее. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Это ссылка на мой пост в блоге для статьи: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve -2048-игра-с-компьютером /&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и видео на YouTube: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=VnVFilfZ0r4&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.youtube.com/watch?v=VnVFilfZ0r4&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccd9e8b01034b267d29c5745b84208f0a085f623" translate="yes" xml:space="preserve">
          <source>As a consequence, this solver is deterministic.</source>
          <target state="translated">Как следствие,этот решатель детерминирован.</target>
        </trans-unit>
        <trans-unit id="9a7ad671d6cde8daae45c935046a605bf403cdad" translate="yes" xml:space="preserve">
          <source>At 1 moves/s: &lt;strong&gt;609104&lt;/strong&gt; (100 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1 ход / с: &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;609104&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (в среднем на 100 игр)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e5d64f1e0b61c1ef3e52e0d5823d5921bc21a50" translate="yes" xml:space="preserve">
          <source>At 10 moves/s: &lt;strong&gt;589355&lt;/strong&gt; (300 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На 10 ходов / с: &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;589355&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (в среднем 300 игр)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3c0d6ea43007ca3c28efb394b96f8a3287fcd1" translate="yes" xml:space="preserve">
          <source>At 3-ply (ca. 1500 moves/s): &lt;strong&gt;511759&lt;/strong&gt; (1000 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;При 3 слоях (около 1500 ходов / с): &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;511759&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (в среднем 1000 игр)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e93088674333bdf43b53fdb34644dc1838dfbd19" translate="yes" xml:space="preserve">
          <source>Below animation shows the last few steps of the game played by the AI agent with the computer player:</source>
          <target state="translated">Ниже в анимации показаны последние несколько шагов игры,в которую играл агент ИИ с компьютерным проигрывателем:</target>
        </trans-unit>
        <trans-unit id="6c12051095dc9a9f3c8c9322ba72366123f527e4" translate="yes" xml:space="preserve">
          <source>Below is the code implementing the solving algorithm. The grid is represented as a 16-length array of Integers. And scoring is done simply by counting the number of empty squares.</source>
          <target state="translated">Ниже приведен код,реализующий алгоритм решения.Сетка представлена в виде массива Целочислений длиной 16 литров.А скоринг выполняется простым подсчётом количества пустых квадратов.</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="85a8f1bded86a0cdaa694a12d8a5a7691488a18a" translate="yes" xml:space="preserve">
          <source>Bit shift operations are used to extract individual rows and columns. A single row or column is a 16-bit quantity, so a table of size 65536 can encode transformations which operate on a single row or column. For example, moves are implemented as 4 lookups into a precomputed &quot;move effect table&quot; which describes how each move affects a single row or column (for example, the &quot;move right&quot; table contains the entry &quot;1122 -&amp;gt; 0023&quot; describing how the row [2,2,4,4] becomes the row [0,0,4,8] when moved to the right).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Операции сдвига битов используются для извлечения отдельных строк и столбцов. Одна строка или столбец - это 16-разрядная величина, поэтому таблица размером 65536 может кодировать преобразования, которые работают с одной строкой или столбцом. Например, перемещения реализованы как 4 поиска в предварительно вычисленной &amp;laquo;таблице эффектов перемещения&amp;raquo;, которая описывает, как каждое перемещение влияет на одну строку или столбец (например, таблица &amp;laquo;перемещение вправо&amp;raquo; содержит запись &amp;laquo;1122 -&amp;gt; 0023&amp;raquo;, описывающую, как строка [2,2,4,4] становится строкой [0,0,4,8] при перемещении вправо).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c42c80d6b77bd2a349eaa2543cf5ddc744fe92ff" translate="yes" xml:space="preserve">
          <source>But, when I actually use this algorithm, I only get around 4000 points before the game terminates. Maximum points AFAIK is slightly more than 20,000 points which is way larger than my current score. Is there a better algorithm than the above?</source>
          <target state="translated">Но,когда я на самом деле использую этот алгоритм,я получаю только около 4000 очков до окончания игры.Максимальное количество очков AFAIK чуть больше 20 000,что намного больше моего текущего счета.Есть ли лучший алгоритм,чем выше?</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="d5026d402b84438a420117883e0b28d724275f57" translate="yes" xml:space="preserve">
          <source>Currently, the program achieves about a 90% win rate running in javascript in the browser on my laptop given about 100 milliseconds of thinking time per move, so while not perfect (yet!) it performs pretty well.</source>
          <target state="translated">В настоящее время программа достигает примерно 90% выигрыша при работе на javascript в браузере на моем ноутбуке,учитывая около 100 миллисекунд времени на обдумывание одного хода,так что,хотя и не идеально (пока!),она работает довольно хорошо.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="6c38d1c09dfbb8d9afb27b450f505d02e699af0a" translate="yes" xml:space="preserve">
          <source>First I created a JavaScript version which can be &lt;a href=&quot;http://ronzil.github.io/2048-AI/&quot;&gt;seen in action here&lt;/a&gt;. This version can run 100's of runs in decent time. Open the console for extra info. 
(&lt;a href=&quot;https://github.com/ronzil/2048-AI&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сначала я создал версию JavaScript, которую можно &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ronzil.github.io/2048-AI/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;увидеть в действии здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эта версия может запустить 100 прогонов в достойное время. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Откройте консоль для дополнительной информации. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ronzil/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;источник&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb6608935b3258a93b48bed3d51f17ee42bad070" translate="yes" xml:space="preserve">
          <source>For 3-ply:</source>
          <target state="translated">За 3-слойный:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="afd41cc839be699428bd0fa94a187d2888e8230c" translate="yes" xml:space="preserve">
          <source>Free Space Available</source>
          <target state="translated">Свободное место</target>
        </trans-unit>
        <trans-unit id="f00400337de66f8cbfda3eb6257d6edb7ab4d834" translate="yes" xml:space="preserve">
          <source>Free Tiles</source>
          <target state="translated">Бесплатная плитка</target>
        </trans-unit>
        <trans-unit id="05c3afb6f1373b0671a788c523440a2cdb7b67cf" translate="yes" xml:space="preserve">
          <source>Furthermore, Petr also optimized the heuristic weights using a &quot;meta-optimization&quot; strategy (using an algorithm called &lt;a href=&quot;https://en.wikipedia.org/wiki/CMA-ES&quot;&gt;CMA-ES&lt;/a&gt;), where the weights themselves were adjusted to obtain the highest possible average score.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, Петр также оптимизировал эвристические веса, используя стратегию &amp;laquo;мета-оптимизации&amp;raquo; (используя алгоритм, называемый &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/CMA-ES&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CMA-ES&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), где сами веса были скорректированы для получения максимально возможного среднего балла.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a006d33e016b3552046744f9daab00e3a9dea82" translate="yes" xml:space="preserve">
          <source>Here goes the algorithm. Around 80% wins (it seems it is always possible to win with more &quot;professional&quot; AI techniques, I am not sure about this, though.)</source>
          <target state="translated">Вот алгоритм.Около 80% побед (кажется,что всегда можно выиграть с более &quot;профессиональными&quot; методами ИИ,впрочем,я в этом не уверен).</target>
        </trans-unit>
        <trans-unit id="9fde7d59da7d0da4eb4e909565d46f8fa0c4121d" translate="yes" xml:space="preserve">
          <source>Here the model and chain is:</source>
          <target state="translated">Вот модель и цепь:</target>
        </trans-unit>
        <trans-unit id="7f9a58f740830a3a6e0ce355d41b93414963aa63" translate="yes" xml:space="preserve">
          <source>Here we evaluate faces that have the possibility to getting to merge, by evaluating them backwardly, tile 2 become of value 2048, while tile 2048 is evaluated 2.</source>
          <target state="translated">Здесь мы оцениваем лица,которые имеют возможность слиться,оценивая их в обратном порядке,плитка 2 приобретает значение 2048,а плитка 2048-2.</target>
        </trans-unit>
        <trans-unit id="ea14290a91583ca847b2ae45387c083c3b7f5174" translate="yes" xml:space="preserve">
          <source>Here's a demonstration of the power of this approach. I uncapped the tile values (so it kept going after reaching 2048) and here is the best result after eight trials.</source>
          <target state="translated">Вот демонстрация силы этого подхода.Я снял ограничения с плитки (так что она продолжала работать после достижения 2048 года)и вот лучший результат после восьми испытаний.</target>
        </trans-unit>
        <trans-unit id="4f64374fb447322f3ae9648b3c8851f4e3a0a00f" translate="yes" xml:space="preserve">
          <source>Here's a screenshot of a perfectly monotonic grid. I obtained this by running the algorithm with the eval function set to disregard the other heuristics and only consider monotonicity.</source>
          <target state="translated">Вот скриншот идеально монотонной сетки.Я получил его,запустив алгоритм с оценочной функцией,чтобы не обращать внимания на другие эвристики и учитывать только монотонность.</target>
        </trans-unit>
        <trans-unit id="f97f5d39b364919717cbfb83c95dfea658c2d11e" translate="yes" xml:space="preserve">
          <source>Here's a screenshot of a perfectly smooth grid, courtesy of &lt;a href=&quot;http://jennypeng.me/2048/&quot;&gt;this excellent parody fork&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот скриншот совершенно гладкой сетки, любезно предоставленной &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://jennypeng.me/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;этой отличной пародийной вилкой&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b03d95f10bf2fb9649d305f295aac7854cae9194" translate="yes" xml:space="preserve">
          <source>Here's the screenshot of the best run:</source>
          <target state="translated">Вот скриншот лучшего пробега:</target>
        </trans-unit>
        <trans-unit id="ffac2906be85464582876c1fd5b67e5775ca4c9b" translate="yes" xml:space="preserve">
          <source>Heuristics</source>
          <target state="translated">Heuristics</target>
        </trans-unit>
        <trans-unit id="ed8ab7ed11c60bc100175f13e827da35c53e21c1" translate="yes" xml:space="preserve">
          <source>However, I have never observed it obtaining the 65536 tile.</source>
          <target state="translated">Однако,я никогда не видел,чтобы он получал плитку 65536.</target>
        </trans-unit>
        <trans-unit id="84fd09822e571ef59181c3b714b48c120c88bc2d" translate="yes" xml:space="preserve">
          <source>However, none of these ideas showed any real advantage over the simple first idea. I left the code for these ideas commented out in the C++ code.</source>
          <target state="translated">Однако ни одна из этих идей не показала никакого реального преимущества перед простой первой идеей.Я оставил код для этих идей,прокомментированных в Си++.</target>
        </trans-unit>
        <trans-unit id="5e64fedf544d393d02c17117048de608b040496d" translate="yes" xml:space="preserve">
          <source>I also tried the corner heuristic, but for some reason it makes the results worse, any intuition why?</source>
          <target state="translated">Я тоже пробовал угловой эвризм,но по каким-то причинам это делает результаты хуже,любая интуиция почему?</target>
        </trans-unit>
        <trans-unit id="bff61911fdd315b14809acd1b0718f81baa37d98" translate="yes" xml:space="preserve">
          <source>I am the author of a 2048 controller that scores better than any other program mentioned in this thread. An efficient implementation of the controller is available on &lt;a href=&quot;https://github.com/aszczepanski/2048&quot;&gt;github&lt;/a&gt;. In &lt;a href=&quot;https://github.com/wjaskowski/mastering-2048&quot;&gt;a separate repo&lt;/a&gt; there is also the code used for training the controller's state evaluation function. The training method is described in the &lt;a href=&quot;http://arxiv.org/abs/1604.05085&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я являюсь автором контроллера 2048, который показывает лучшие результаты, чем любая другая программа, упомянутая в этой теме Эффективная реализация контроллера доступна на &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/aszczepanski/2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;github&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . В &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/wjaskowski/mastering-2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;отдельном репо&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; также есть код, используемый для обучения функции оценки состояния контроллера. Метод обучения описан в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://arxiv.org/abs/1604.05085&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;статье&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b1878005b4715ef7dadf5dbab3530f2387e3d7d" translate="yes" xml:space="preserve">
          <source>I applied convex combination (tried different heuristic weights) of couple of heuristic evaluation functions, mainly from intuition and from the ones discussed above:</source>
          <target state="translated">Я применил выпуклую комбинацию (попробовал различные эвристические веса)пары эвристических оценочных функций,в основном из интуиции и из рассмотренных выше:</target>
        </trans-unit>
        <trans-unit id="b340ff0771c0044d5631169bb8b9da7b0949767e" translate="yes" xml:space="preserve">
          <source>I became interested in the idea of an AI for this game containing &lt;strong&gt;no hard-coded intelligence&lt;/strong&gt; (i.e no heuristics, scoring functions etc). The AI should &lt;em&gt;&quot;know&quot;&lt;/em&gt; only the game rules, and &lt;em&gt;&quot;figure out&quot;&lt;/em&gt; the game play. This is in contrast to most AIs (like the ones in this thread) where the game play is essentially brute force steered by a scoring function representing human understanding of the game.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я заинтересовался идеей искусственного интеллекта для этой игры, не содержащей &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;жестко запрограммированного интеллекта&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (т.е. без эвристики, функций подсчета очков и т. Д.). ИИ должен &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;знать&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; только правила игры и &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;разбираться&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в игре. Это в отличие от большинства ИИ (таких как в этой теме), в которых игровой процесс по сути является грубой силой, управляемой функцией подсчета очков, представляющей понимание игры человеком.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed0a579e8bb5a2fa1f190be9cc3a3984935966dd" translate="yes" xml:space="preserve">
          <source>I believe there's still room for improvement on the heuristics. This algorithm definitely isn't yet &quot;optimal&quot;, but I feel like it's getting pretty close.</source>
          <target state="translated">Я думаю,что еще есть место для улучшения эвристики.Этот алгоритм,безусловно,еще не &quot;оптимален&quot;,но мне кажется,что он приближается.</target>
        </trans-unit>
        <trans-unit id="f8ed635115239705d2911e5bd2f5ced5edce99c5" translate="yes" xml:space="preserve">
          <source>I copy here the content of a &lt;a href=&quot;http://diaryofatinker.blogspot.it/2014/03/an-artificial-intelligence-for-2048-game.html&quot;&gt;post on my blog&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я копирую здесь содержание &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://diaryofatinker.blogspot.it/2014/03/an-artificial-intelligence-for-2048-game.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;поста в моем блоге&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d84a2a8980a497e88dd0c2f4d14dcecd79505253" translate="yes" xml:space="preserve">
          <source>I developed a 2048 AI using &lt;em&gt;expectimax&lt;/em&gt; optimization, instead of the minimax search used by @ovolve's algorithm. The AI simply performs maximization over all possible moves, followed by expectation over all possible tile spawns (weighted by the probability of the tiles, i.e. 10% for a 4 and 90% for a 2). As far as I'm aware, it is not possible to prune expectimax optimization (except to remove branches that are exceedingly unlikely), and so the algorithm used is a carefully optimized brute force search.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я разработал AI 2048, используя &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;оптимизацию &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;expectimax&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вместо поиска минимакса, используемого алгоритмом @ ovolve. ИИ просто выполняет максимизацию всех возможных ходов, после чего следует ожидание всех возможных появлений тайлов (взвешенных по вероятности тайлов, то есть 10% для 4 и 90% для 2). Насколько мне известно, невозможно сократить оптимизацию expectimax (кроме удаления крайне маловероятных ветвей), и поэтому используемый алгоритм представляет собой тщательно оптимизированный поиск методом перебора.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a35fdce8c7933d0b2a937ce2170823745b56f98" translate="yes" xml:space="preserve">
          <source>I did add a &quot;Deep Search&quot; mechanism that increased the run number temporarily to 1000000 when any of the runs managed to accidentally reach the next highest tile. This offered a time improvement.</source>
          <target state="translated">Я добавил механизм &quot;Глубокого поиска&quot;,который временно увеличил номер пробега до 1000000,когда любой из прогонов случайно добрался до следующей самой высокой плитки.Это позволило улучшить время.</target>
        </trans-unit>
        <trans-unit id="ba7f2fdb047681e855cdfd6b772b6db5b92aa4ee" translate="yes" xml:space="preserve">
          <source>I find it quite surprising that the algorithm doesn't need to actually foresee good game play in order to chose the moves that produce it.</source>
          <target state="translated">Я нахожу довольно удивительным,что алгоритм не должен на самом деле предвидеть хорошую игру для того,чтобы выбрать ходы,которые ее производят.</target>
        </trans-unit>
        <trans-unit id="2224c20bdfc42ec2f0bd05389e5c06114237583f" translate="yes" xml:space="preserve">
          <source>I found a simple yet surprisingly good playing algorithm: To determine the next move for a given board, the AI plays the game in memory using &lt;strong&gt;random moves&lt;/strong&gt; until the game is over. This is done several times while keeping track of the end game score. Then the average end score &lt;em&gt;per starting move&lt;/em&gt; is calculated. The starting move with the highest average end score is chosen as the next move.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я нашел простой, но удивительно хороший игровой алгоритм: чтобы определить следующий ход для данной доски, ИИ играет в память в игре, используя &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;случайные ходы,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; пока игра не закончится. Это делается несколько раз, сохраняя счет в конце игры. Затем &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;рассчитывается &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;средний конечный балл &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;за начальный ход&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Начальный ход с наибольшим средним результатом выбирается следующим ходом.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="031425862c087193c510d3992030621083927b33" translate="yes" xml:space="preserve">
          <source>I have 4x4 grid for playing the game.</source>
          <target state="translated">У меня есть сетка 4x4 для игры.</target>
        </trans-unit>
        <trans-unit id="f56414c1f6736cdf7c56bfca13c15f73247b88ce" translate="yes" xml:space="preserve">
          <source>I have recently stumbled upon the game &lt;a href=&quot;http://gabrielecirulli.github.io/2048/&quot;&gt;2048&lt;/a&gt;. You merge similar tiles by moving them in any of the four directions to make &quot;bigger&quot; tiles. After each move, a new tile appears at random empty position with a value of either &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;. The game terminates when all the boxes are filled and there are no moves that can merge tiles, or you create a tile with a value of &lt;code&gt;2048&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я недавно наткнулся на игру &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://gabrielecirulli.github.io/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы объединяете подобные плитки, перемещая их в любом из четырех направлений, чтобы сделать плитки &amp;laquo;большего размера&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;После каждого хода новая плитка появляется в случайной пустой позиции со значением &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Игра заканчивается, когда все поля заполнены, и нет ходов, которые могут объединить плитки, или вы создаете плитку со значением &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2048&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59f0d82a356c65bde837828cc539c2e8be89a87d" translate="yes" xml:space="preserve">
          <source>I have refined the algorithm and beaten the game! It may fail due to simple bad luck close to the end (you are forced to move down, which you should never do, and a tile appears where your highest should be. Just try to keep the top row filled, so moving left does not break the pattern), but basically you end up having a fixed part and a mobile part to play with. This is your objective:</source>
          <target state="translated">Я усовершенствовал алгоритм и побил игру! Она может потерпеть неудачу из-за простой неудачи близко к концу (вы вынуждены двигаться вниз,что вы никогда не должны делать,и плитка появляется там,где ваша самая высокая должна быть.Просто постарайтесь держать верхний ряд заполненным,так что перемещение влево не нарушает шаблон),но в основном вы в конечном итоге имеете фиксированную часть и подвижную часть,чтобы играть с.Это ваша цель:</target>
        </trans-unit>
        <trans-unit id="e043b4a0622bd7bd4f4bff3f75f5289152c44dc3" translate="yes" xml:space="preserve">
          <source>I just tried my minimax implementation with alpha-beta pruning with search-tree depth cutoff at 3 and 5. I was trying to solve the same problem for a 4x4 grid as a project assignment for the &lt;strong&gt;edX course ColumbiaX: CSMM.101x Artificial Intelligence (AI)&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я только что попробовал свою минимаксную реализацию с альфа-бета-отсечкой с ограничением глубины дерева поиска в 3 и 5. Я пытался решить ту же проблему для сетки 4x4, что и проектное задание для &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;курса edX ColumbiaX: CSMM.101x Artificial Intelligence ( AI)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f7940b642881ad963c29c8e46d7cecbcc69643e3" translate="yes" xml:space="preserve">
          <source>I think I found an algorithm which works quite well, as I often reach scores over 10000, my personal best being around 16000. My solution does not aim at keeping biggest numbers in a corner, but to keep it in the top row.</source>
          <target state="translated">Я думаю,что нашел алгоритм,который работает довольно хорошо,так как я часто достигаю баллов более 10000,мой личный рекорд-около 16000.Мое решение заключается не в том,чтобы держать самые большие цифры в углу,а в том,чтобы держать их в верхнем ряду.</target>
        </trans-unit>
        <trans-unit id="55f66ed61b2ad8167d89233045ef1fe2708fd931" translate="yes" xml:space="preserve">
          <source>I think it will be better to use Expectimax instead of minimax, but still I want to solve this problem with minimax only and obtain high scores such as 2048 or 4096. I am not sure whether I am missing anything.</source>
          <target state="translated">Я думаю,что будет лучше использовать Expectimax вместо минимакса,но все же я хочу решить эту проблему только с минимаксом и получить высокие баллы,такие как 2048 или 4096.Я не уверен,пропустил ли я что-нибудь.</target>
        </trans-unit>
        <trans-unit id="ea165dbbcc05f8b9c0fee4d6f269ceb0aa9da587" translate="yes" xml:space="preserve">
          <source>I thinks it's quite successful for its simplicity. The result it reaches when starting with an empty grid and solving at depth 5 is:</source>
          <target state="translated">Я думаю,что он довольно успешен за свою простоту.Результат достигается,когда начинаешь с пустой сетки и решаешь на глубине 5:</target>
        </trans-unit>
        <trans-unit id="1034d585a72bb081cca29625c761242ddf856012" translate="yes" xml:space="preserve">
          <source>I used an exhaustive algorithm that favours empty tiles. It performs pretty quickly for depth 1-4, but on depth 5 it gets rather slow at a around 1 second per move.</source>
          <target state="translated">Я использовал исчерпывающий алгоритм,который предпочитает пустые плитки.Он довольно быстро работает на глубине 1-4,но на глубине 5 он становится довольно медленным примерно на 1 секунду за ход.</target>
        </trans-unit>
        <trans-unit id="37173dc2be4bdb4d84b503ac96c838e5e06ad4e3" translate="yes" xml:space="preserve">
          <source>I wrote a 2048 solver in Haskell, mainly because I'm learning this language right now.</source>
          <target state="translated">Я написал решатель 2048 года в Хаскеле,в основном потому,что я учу этот язык прямо сейчас.</target>
        </trans-unit>
        <trans-unit id="46c02f631905ee5caf0b222fd7359a47400755dd" translate="yes" xml:space="preserve">
          <source>I'd be interested to hear if anyone has other improvement ideas that maintain the domain-independence of the AI.</source>
          <target state="translated">Мне было бы интересно узнать,есть ли у кого-нибудь другие идеи по улучшению,поддерживающие независимость ИИ от домена.</target>
        </trans-unit>
        <trans-unit id="a1169010fb1d82ea350ecfb6aa43f3802bb8f9f2" translate="yes" xml:space="preserve">
          <source>I'm the author of the AI program that others have mentioned in this thread. You can view the AI in &lt;a href=&quot;http://ovolve.github.io/2048-AI/&quot;&gt;action&lt;/a&gt; or read the &lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;source&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я являюсь автором программы AI, которую другие упоминали в этой теме. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете посмотреть ИИ в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ovolve.github.io/2048-AI/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;действии&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или прочитать &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;источник&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cff211afed3c58617e7600239f98eba6f99208de" translate="yes" xml:space="preserve">
          <source>If I assign too much weights to the first heuristic function or the second heuristic function, both the cases the scores the AI player gets are low. I played with many possible weight assignments to the heuristic functions and take a convex combination, but very rarely the AI player is able to score 2048. Most of the times it either stops at 1024 or 512.</source>
          <target state="translated">Если я назначаю слишком много весов первой эвристической функции или второй эвристической функции,то в обоих случаях результаты,которые получает ИИ-игрок,будут низкими.Я играл со многими возможными назначениями весов эвристическим функциям и принимал выпуклую комбинацию,но очень редко ИИ-игрок может набрать 2048 очков.В большинстве случаев он останавливается на 1024 или 512.</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3ed4d38edf88c96646888aef4c5aee857217b77c" translate="yes" xml:space="preserve">
          <source>Implementation and Links</source>
          <target state="translated">Реализация и ссылки</target>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="dae216ce28189a3dc03880a06f90efd300da2352" translate="yes" xml:space="preserve">
          <source>In case of T2, four tests in ten generate the 4096 tile with an average score of</source>
          <target state="translated">В случае Т2 четыре теста из десяти генерируют плитку 4096 со средней оценкой</target>
        </trans-unit>
        <trans-unit id="06f4f3fea3016100595f36b33ff12f794776a418" translate="yes" xml:space="preserve">
          <source>In here we still need to check for stacked values, but in a lesser way that doesn't interrupt the flexibility parameters, so we have the sum of { x in [4,44] }.</source>
          <target state="translated">Здесь еще нужно проверить на стековые значения,но в меньшей степени,что не прерывает параметры гибкости,поэтому у нас есть сумма{x в [4,44]}.</target>
        </trans-unit>
        <trans-unit id="3c2636cc71bb825cadfd8c456577a98d04fe05b8" translate="yes" xml:space="preserve">
          <source>In my case, the computer player is completely random, but still i assumed adversarial settings and implemented the AI player agent as the max player.</source>
          <target state="translated">В моем случае компьютерный проигрыватель полностью случайный,но все же я предположил враждебные настройки и реализовал агента ИИ проигрывателя в качестве максимального проигрывателя.</target>
        </trans-unit>
        <trans-unit id="23652927c0d25e443786d2f509c213988410f12c" translate="yes" xml:space="preserve">
          <source>Initially, I used two very simple heuristics, granting &quot;bonuses&quot; for open squares and for having large values on the edge. These heuristics performed pretty well, frequently achieving 16384 but never getting to 32768.</source>
          <target state="translated">Изначально я использовал две очень простые эвристики,дающие &quot;бонусы&quot; за открытые квадраты и за то,что у меня большие значения по краю.Эти эвристики работали довольно хорошо,часто достигая 16384,но никогда не доходя до 32768.</target>
        </trans-unit>
        <trans-unit id="1545ea420f5c65b9c9bba94c946b329fa8251dc3" translate="yes" xml:space="preserve">
          <source>Just for fun, I've also &lt;a href=&quot;http://ronzil.github.io/2048AI-AllClones/&quot;&gt;implemented the AI as a bookmarklet&lt;/a&gt;, hooking into the game's controls. This allows the AI to work with the original game and &lt;strong&gt;many of its variants&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ради интереса, я также &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ronzil.github.io/2048AI-AllClones/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;реализовал AI как букмарклет&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , подключив его к элементам управления игры. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это позволяет ИИ работать с оригинальной игрой и &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;многими ее вариантами&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="87ab7e933f551b05ada40bfa9c63b7d3a98505ae" translate="yes" xml:space="preserve">
          <source>Larger tile in the way: Increase the value of a smaller surrounding tile.</source>
          <target state="translated">Большая плитка на пути:Увеличить значение меньшей плитки вокруг.</target>
        </trans-unit>
        <trans-unit id="18be8c8127f21459189b5caf81e55e1002781278" translate="yes" xml:space="preserve">
          <source>Later I implemented a scoring tree that took into account the conditional probability of being able to play a move after a given move list.</source>
          <target state="translated">Позже я реализовал дерево подсчета очков,учитывающее условную вероятность того,что можно будет сыграть ход после заданного списка ходов.</target>
        </trans-unit>
        <trans-unit id="5d40de2c184332bb133e3c7b3f9b7106a46f6318" translate="yes" xml:space="preserve">
          <source>Later, in order to play around some more I used @nneonneo highly optimized infrastructure and implemented my version in C++. This version allows for up to 100000 runs per move and even 1000000 if you have the patience. Building instructions provided. It runs in the console and also has a remote-control to play the web version.
(&lt;a href=&quot;https://github.com/ronzil/2048-ai-cpp&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Позже, чтобы поиграться, я использовал высокооптимизированную инфраструктуру @nneonneo и реализовал свою версию на C ++. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эта версия допускает до 100000 пробежек за ход и даже 1000000, если у вас есть терпение. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Инструкция по сборке предоставляется. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он работает в консоли, а также имеет пульт дистанционного управления для воспроизведения веб-версии. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ronzil/2048-ai-cpp&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;источник&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="44c2d6ea8314c3f98974d2ba1a58dd051bb32c6f" translate="yes" xml:space="preserve">
          <source>Many of the other answers use AI with computationally expensive searching of possible futures, heuristics, learning and the such. These are impressive and probably the correct way forward, but I wish to contribute another idea.</source>
          <target state="translated">Во многих других ответах используется ИИ с вычислительно-дорогим поиском возможных фьючерсов,эвристикой,обучением и тому подобным.Это впечатляет и,возможно,правильный путь вперед,но я хочу внести свой вклад в другую идею.</target>
        </trans-unit>
        <trans-unit id="2b46f31c24d9d078dc34aed0d4067c4f769ba53f" translate="yes" xml:space="preserve">
          <source>Model the sort of strategy that good players of the game use.</source>
          <target state="translated">Модель стратегии,которую используют хорошие игроки игры.</target>
        </trans-unit>
        <trans-unit id="fd4c07fb20d7d76fbcadaea8ea7ddaaac986f8c7" translate="yes" xml:space="preserve">
          <source>Monotonicity</source>
          <target state="translated">Monotonicity</target>
        </trans-unit>
        <trans-unit id="44fc3fc0ab34b52134a7cd76d9bbcb14829e6e00" translate="yes" xml:space="preserve">
          <source>More spaces makes the state more flexible, we multiply by 128 (which is the median) since a grid filled with 128 faces is an optimal impossible state.</source>
          <target state="translated">Больше пространства делает состояние более гибким,мы умножаем на 128 (что является медианой),так как решетка,заполненная 128 гранями,является оптимальным невозможным состоянием.</target>
        </trans-unit>
        <trans-unit id="1f62f4a60f5f356eabae5d8f3cb887dce903adda" translate="yes" xml:space="preserve">
          <source>My approach encodes the entire board (16 entries) as a single 64-bit integer (where tiles are the nybbles, i.e. 4-bit chunks). On a 64-bit machine, this enables the entire board to be passed around in a single machine register.</source>
          <target state="translated">Мой подход кодирует всю доску (16 записей)как одно 64-битное целое число (где плитки-это гиблы,т.е.4-битные куски).На 64-битной машине это позволяет передавать всю плату в одном машинном регистре.</target>
        </trans-unit>
        <trans-unit id="ef5c72f488757b3c3972bc8a4c545658ae48db02" translate="yes" xml:space="preserve">
          <source>My attempt uses expectimax like other solutions above, but without bitboards. Nneonneo's solution can check 10millions of moves which is approximately a depth of 4 with 6 tiles left and 4 moves possible (2*6*4)&lt;sup&gt;4&lt;/sup&gt;. In my case, this depth takes too long to explore, I adjust the depth of expectimax search according to the number of free tiles left:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Моя попытка использует expectimax, как и другие решения выше, но без битбордов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Решение Nneonneo может проверить 10 миллионов ходов, что составляет примерно 4 глубины, при этом осталось 6 плиток и 4 возможных хода (2 * 6 * 4) &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В моем случае эта глубина требует слишком много времени для изучения, я настраиваю глубину поиска expectimax в соответствии с количеством оставшихся свободных плиток:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="57e8410bf6b4571c6670e5f2ee8f617e934c4d80" translate="yes" xml:space="preserve">
          <source>My current algorithm:</source>
          <target state="translated">Мой текущий алгоритм:</target>
        </trans-unit>
        <trans-unit id="bea5caec78afaf43f0643aa15a7e4f0a707e1354" translate="yes" xml:space="preserve">
          <source>My implementation of the game slightly differs from the actual game, in that a new tile is always a '2' (rather than 90% 2 and 10% 4). And that the new tile is not random, but always the first available one from the top left. This variant is also known as &lt;a href=&quot;https://jmfork.github.io/2048/&quot;&gt;Det 2048&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Моя реализация игры немного отличается от реальной игры тем, что новая плитка всегда равна 2 (а не 90% 2 и 10% 4). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И что новая плитка не случайная, а всегда первая доступная вверху слева. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот вариант также известен как &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://jmfork.github.io/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Det 2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d18c870dbfd8a43034e5e38c25648f6a00c617cb" translate="yes" xml:space="preserve">
          <source>Observation:</source>
          <target state="translated">Observation:</target>
        </trans-unit>
        <trans-unit id="1d445de243f043f2a68c63600c349cf26b114c50" translate="yes" xml:space="preserve">
          <source>One, I need to follow a well-defined strategy to reach the goal. So, I thought of writing a program for it.</source>
          <target state="translated">Во-первых,мне нужно следовать четко определенной стратегии для достижения цели.Поэтому я подумал о том,чтобы написать программу для нее.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="640af8b8b4a6b17289c61d8f064089730a066c2e" translate="yes" xml:space="preserve">
          <source>Petr Mor&amp;aacute;vek (@xificurk) took my AI and added two new heuristics. The first heuristic was a penalty for having non-monotonic rows and columns which increased as the ranks increased, ensuring that  non-monotonic rows of small numbers would not strongly affect the score, but non-monotonic rows of large numbers hurt the score substantially. The second heuristic counted the number of potential merges (adjacent equal values) in addition to open spaces. These two heuristics served to push the algorithm towards monotonic boards (which are easier to merge), and towards board positions with lots of merges (encouraging it to align merges where possible for greater effect).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Петр Моровек (@xificurk) взял мой ИИ и добавил две новые эвристики. Первой эвристикой было наказание за наличие немонотонных рядов и столбцов, которые увеличивались по мере увеличения рангов, гарантируя, что немонотонные ряды небольших чисел не будут сильно влиять на счет, но немонотонные ряды больших чисел существенно ухудшают счет. Вторая эвристика подсчитала количество потенциальных слияний (смежных равных значений) в дополнение к открытым пространствам. Эти две эвристики служат для продвижения алгоритма к монотонным платам (которые легче объединить) и к позициям досок с большим количеством слияний (поощряя его выравнивать слияния, где это возможно, для большего эффекта).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="503f6e600737ff2f29cf68701e034324b5731a1b" translate="yes" xml:space="preserve">
          <source>Please see the code below:</source>
          <target state="translated">Пожалуйста,смотрите код ниже:</target>
        </trans-unit>
        <trans-unit id="6df2f58f408bc47f5e66563bfde9ff0172588105" translate="yes" xml:space="preserve">
          <source>Read the squares in the order shown above until the next squares value is greater than the current one. This presents the problem of trying to merge another tile of the same value into this square.</source>
          <target state="translated">Читайте клетки в порядке,указанном выше,до тех пор,пока следующие клетки не станут больше текущего значения.Это создает проблему при попытке слить другую плитку того же значения в эту клетку.</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="33bfd3ccf12da33384e54b78f3b1b416cd79f5ee" translate="yes" xml:space="preserve">
          <source>Running 10000 runs with a temporary increase to 1000000 near critical positions managed to break this barrier less than 1% of the times achieving a max score of 129892 and the 8192 tile.</source>
          <target state="translated">При пробеге 10000 пробежек с временным увеличением до 1000000 вблизи критических позиций удалось преодолеть этот барьер менее чем в 1% раз,достигнув максимального балла 129892 и 8192 плитки.</target>
        </trans-unit>
        <trans-unit id="f53aad58499a66a812ae2a8fadd0d52bc3c90c03" translate="yes" xml:space="preserve">
          <source>Scoring is also done using table lookup. The tables contain heuristic scores computed on all possible rows/columns, and the resultant score for a board is simply the sum of the table values across each row and column.</source>
          <target state="translated">Скоринг также осуществляется с помощью табличного поиска.Таблицы содержат эвристические оценки,вычисленные по всем возможным столбцам,а итоговая оценка для доски-это просто сумма значений таблицы по каждой строке и столбцу.</target>
        </trans-unit>
        <trans-unit id="6f0d0289231f49f701b9b200b4a3eac54cedef68" translate="yes" xml:space="preserve">
          <source>Searching later I found this algorithm might be classified as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Monte-Carlo_tree_search#Pure_Monte_Carlo_game_search&quot;&gt;Pure Monte Carlo Tree Search&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Позже я обнаружил, что этот алгоритм может быть классифицирован как &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;алгоритм &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Monte-Carlo_tree_search#Pure_Monte_Carlo_game_search&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;поиска дерева Монте-Карло&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c6dc8c149cc76d5efe765ba938462b2a01c9d89" translate="yes" xml:space="preserve">
          <source>Second pointer, it has had bad luck and its main spot has been taken. It is likely that it will fail, but it can still achieve it:</source>
          <target state="translated">Второй указатель,ему не повезло,и его основное место занято.Скорее всего,он потерпит неудачу,но все равно сможет ее достичь:</target>
        </trans-unit>
        <trans-unit id="f7bd04bc23d0d8eee5b56955d487fc2585d2855f" translate="yes" xml:space="preserve">
          <source>See it in action</source>
          <target state="translated">Увидеть это в действии</target>
        </trans-unit>
        <trans-unit id="b6e3041754015cf5ce95b9217697dd1eafce96ab" translate="yes" xml:space="preserve">
          <source>Several heuristics are used to direct the optimization algorithm towards favorable positions. The precise choice of heuristic has a huge effect on the performance of the algorithm. The various heuristics are weighted and combined into a positional score, which determines how &quot;good&quot; a given board position is. The optimization search will then aim to maximize the average score of all possible board positions. The actual score, as shown by the game, is &lt;em&gt;not&lt;/em&gt; used to calculate the board score, since it is too heavily weighted in favor of merging tiles (when delayed merging could produce a large benefit).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Несколько эвристик используются для направления алгоритма оптимизации к выгодным позициям. Точный выбор эвристики оказывает огромное влияние на производительность алгоритма. Различные эвристики взвешиваются и объединяются в позиционную оценку, которая определяет, насколько &amp;laquo;хороша&amp;raquo; данная позиция доски. Поиск оптимизации будет нацелен на максимизацию средней оценки всех возможных позиций на доске. Фактическая оценка, показанная в игре, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; используется для расчета оценки на доске, поскольку она слишком сильно взвешена в пользу объединения плиток (когда отложенное объединение может принести большую выгоду).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2318e6fc587a3fb272235edad6036fe0432bc136" translate="yes" xml:space="preserve">
          <source>Several linear path could be evaluated at once, the final score will be the maximum score of any path.</source>
          <target state="translated">Несколько линейных путей могут быть оценены сразу,итоговая оценка будет максимальной для любого пути.</target>
        </trans-unit>
        <trans-unit id="c72dd283f25dc910b0a759e6f55e51f7b00e7039" translate="yes" xml:space="preserve">
          <source>Since the game is a discrete state space, perfect information, turn-based game like chess and checkers, I used the same methods that have been proven to work on those games, namely &lt;a href=&quot;http://www.flyingmachinestudios.com/programming/minimax/&quot;&gt;minimax&lt;/a&gt;&lt;a href=&quot;http://xkcd.com/832/&quot;&gt;search&lt;/a&gt; with &lt;a href=&quot;http://cs.ucla.edu/~rosen/161/notes/alphabeta.html&quot;&gt;alpha-beta pruning&lt;/a&gt;. Since there is already a lot of info on that algorithm out there, I'll just talk about the two main heuristics that I use in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_function&quot;&gt;static evaluation function&lt;/a&gt; and which formalize many of the intuitions that other people have expressed here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку игра представляет собой дискретное пространство состояний, отличную информацию, пошаговую игру, такую ​​как шахматы и шашки, я использовал те же методы, которые, как было доказано, работали в этих играх, а именно &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.flyingmachinestudios.com/programming/minimax/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;минимаксный &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;http://xkcd.com/832/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;поиск&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://cs.ucla.edu/~rosen/161/notes/alphabeta.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;альфа-бета-отсечкой&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку там уже много информации об этом алгоритме, я просто расскажу о двух основных эвристиках, которые я использую в функции &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;статической оценки&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и которые формализуют многие из интуиций, которые здесь выражают другие люди.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e8fae6a7d3630d681d8de0ed1a7709b1c53526c" translate="yes" xml:space="preserve">
          <source>Smoothness</source>
          <target state="translated">Smoothness</target>
        </trans-unit>
        <trans-unit id="54e739c3c9f2519ccb923360ccad36f552ea579c" translate="yes" xml:space="preserve">
          <source>So it will press right, then right again, then (right or top depending on where the 4 has created) then will proceed to complete the chain until it gets:</source>
          <target state="translated">Таким образом,он будет нажимать вправо,затем снова вправо,затем (вправо или вверх,в зависимости от того,где 4 создал),затем будет продолжать завершать цепочку до тех пор,пока он не получит:</target>
        </trans-unit>
        <trans-unit id="5257bddfe2fa589fbea354e939d68bfb692b503b" translate="yes" xml:space="preserve">
          <source>So now the model and chain are back to:</source>
          <target state="translated">Итак,теперь модель и цепь вернулись:</target>
        </trans-unit>
        <trans-unit id="d7078edb0dd35daa33a7253a4d53d2a945faccd6" translate="yes" xml:space="preserve">
          <source>Source code can be found here: &lt;a href=&quot;https://github.com/popovitsj/2048-haskell&quot;&gt;https://github.com/popovitsj/2048-haskell&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Исходный код можно найти здесь: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/popovitsj/2048-haskell&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/popovitsj/2048-haskell&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5347810276aac1267928f350b554c90eab90a356" translate="yes" xml:space="preserve">
          <source>Surprisingly, increasing the number of runs does not drastically improve the game play. There seems to be a limit to this strategy at around 80000 points with the 4096 tile and all the smaller ones, very close to the achieving the 8192 tile. Increasing the number of runs from 100 to 100000 increases the &lt;strong&gt;odds&lt;/strong&gt; of getting to this score limit (from 5% to 40%) but not breaking through it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Удивительно, но увеличение количества запусков кардинально не улучшает игровой процесс. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кажется, что у этой стратегии есть предел в 80000 пунктов с тайлом 4096 и всеми меньшими, очень близкими к достижению тайла 8192. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Увеличение количества пробежек со 100 до 100000 увеличивает &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вероятность&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; достижения этого лимита (с 5% до 40%), но не пробит его.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d074ffd075253a11df5ddc58441a0bc90e0b8963" translate="yes" xml:space="preserve">
          <source>T1 - 121 tests - 8 different paths - r=0.125</source>
          <target state="translated">T1-121 тесты-8 различных путей-r=0.125</target>
        </trans-unit>
        <trans-unit id="dc6bff919d7f07511beebccbf002e3261f59cb65" translate="yes" xml:space="preserve">
          <source>T2 - 122 tests - 8-different paths - r=0.25</source>
          <target state="translated">T2-122 теста-8-дифференцированных путей-r=0.25</target>
        </trans-unit>
        <trans-unit id="296be33c2b9427ee450731728dde4547f54e382a" translate="yes" xml:space="preserve">
          <source>T3 - 132 tests - 8-different paths - r=0.5</source>
          <target state="translated">T3-132 теста-8-дифференцированных путей-r=0.5</target>
        </trans-unit>
        <trans-unit id="cc1b12f4c9d96129539fb80e7cdef31ccdf979f5" translate="yes" xml:space="preserve">
          <source>T4 - 211 tests - 2-different paths - r=0.125</source>
          <target state="translated">T4-211 тестов-2-дифференцированные пути-r=0.125</target>
        </trans-unit>
        <trans-unit id="e14691f69c083c98b5cb57561d0905750d23ecc3" translate="yes" xml:space="preserve">
          <source>T5 - 274 tests - 2-different paths - r=0.25</source>
          <target state="translated">T5-274 тесты-2-различные пути-r=0.25</target>
        </trans-unit>
        <trans-unit id="c4e6556dc89bf3c2350cf0f2df946297023854c7" translate="yes" xml:space="preserve">
          <source>T6 - 211 tests - 2-different paths - r=0.5</source>
          <target state="translated">T6-211 тестов-2-дифференцированные пути-r=0.5</target>
        </trans-unit>
        <trans-unit id="0c7d1cbd690845a24654fefbd0a09ba800d4230d" translate="yes" xml:space="preserve">
          <source>That the AI achieves the 32768 tile in over a third of its games is a huge milestone; I will be surprised to hear if any human players have achieved 32768 on the official game (i.e. without using tools like savestates or undo). I think the 65536 tile is within reach!</source>
          <target state="translated">То,что ИИ достигает 32768 плитки в более чем трети своих игр является огромной вехой;я буду удивлен,если какие-либо человеческие игроки достигли 32768 на официальной игре (т.е.без использования таких инструментов,как savestates или отмена).Я думаю,что плитка 65536 находится в пределах досягаемости!</target>
        </trans-unit>
        <trans-unit id="89cc096445275d0b61d3321d2f66e3dd178f9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O&lt;/code&gt; represent forbidden spaces...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;O&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; представляют запрещенные места ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c7dde9a3e75b8eeff3662608ec5b45fcb967f49" translate="yes" xml:space="preserve">
          <source>The AI in its default configuration (max search depth of 8) takes anywhere from 10ms to 200ms to execute a move, depending on the complexity of the board position. In testing, the AI achieves an average move rate of 5-10 moves per second over the course of an entire game. If the search depth is limited to 6 moves, the AI can easily execute 20+ moves per second, which makes for some &lt;a href=&quot;https://www.youtube.com/watch?v=96ab_dK6JM0&quot;&gt;interesting watching&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ИИ в конфигурации по умолчанию (максимальная глубина поиска 8) занимает от 10 мс до 200 мс, чтобы выполнить ход, в зависимости от сложности положения доски. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;При тестировании ИИ достигает средней скорости перемещения 5-10 ходов в секунду в течение всей игры. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если глубина поиска ограничена 6 ходами, ИИ может легко выполнить более 20 ходов в секунду, что делает его &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=96ab_dK6JM0&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;интересным для просмотра&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fb5e1a1c14a7f3f4df0734b1b830faeee1bc279" translate="yes" xml:space="preserve">
          <source>The above heuristic alone tends to create structures in which adjacent tiles are decreasing in value, but of course in order to merge, adjacent tiles need to be the same value. Therefore, the smoothness heuristic just measures the value difference between neighboring tiles, trying to minimize this count.</source>
          <target state="translated">Один только вышеприведенный эвристический подход имеет тенденцию создавать структуры,в которых соседние плитки уменьшаются в цене,но,конечно,для слияния,соседние плитки должны иметь одинаковое значение.Поэтому эвристика гладкости просто измеряет разницу значений между соседними плитками,стараясь минимизировать это значение.</target>
        </trans-unit>
        <trans-unit id="a1da09880219429d0cbd02709fa5c5c73d1b6f56" translate="yes" xml:space="preserve">
          <source>The algorithm is iterative deepening depth first alpha-beta search. The evaluation function tries to keep the rows and columns monotonic (either all decreasing or increasing) while minimizing the number of tiles on the grid.</source>
          <target state="translated">Алгоритм является итеративным углублением глубины первого альфа-бета-поиска.Функция оценки пытается сохранить строки и столбцы монотонными (все уменьшающимися или увеличивающимися),одновременно минимизируя количество плиток на сетке.</target>
        </trans-unit>
        <trans-unit id="1ef77e56b4c80bec7704196088642b9d80e9917f" translate="yes" xml:space="preserve">
          <source>The assumption on which my algorithm is based is rather simple: if you want to achieve higher score, the board must be kept as tidy as possible. In particular, the optimal setup is given by a linear and monotonic decreasing order of the tile values.
This intuition will give you also the upper bound for a tile value:</source>
          <target state="translated">Предположение,на котором основан мой алгоритм,довольно простое:если вы хотите получить более высокий балл,доска должна быть как можно аккуратнее.В частности,оптимальную настройку дает линейный и монотонный убывающий порядок значений плитки.Эта интуиция также даст вам верхнюю границу для значения плитки:</target>
        </trans-unit>
        <trans-unit id="5dce83a7a7a2e8b3f3cbaad9c10d94bf6337d55b" translate="yes" xml:space="preserve">
          <source>The best achieved score is shown here:</source>
          <target state="translated">Лучший достигнутый результат показан здесь:</target>
        </trans-unit>
        <trans-unit id="25c8ed43b28e01eb6dd519d1d9bd47b6abbd3671" translate="yes" xml:space="preserve">
          <source>The chosen corner is arbitrary, you basically never press one key (the forbidden move), and if you do, you press the contrary again and try to fix it. For future tiles the model always expects the next random tile to be a 2 and appear on the opposite side to the current model (while the first row is incomplete, on the bottom right corner, once the first row is completed, on the bottom left corner).</source>
          <target state="translated">Выбранный угол произвольный,вы практически никогда не нажимаете одну клавишу (запрещенное движение),а если нажимаете,то снова нажимаете наоборот и пытаетесь его исправить.Для будущих плиток модель всегда ожидает,что следующая случайная плитка будет равна 2 и появится на противоположной стороне от текущей модели (пока первая строка не закончена,в правом нижнем углу,когда первая строка закончена,в левом нижнем углу).</target>
        </trans-unit>
        <trans-unit id="0d9103915dc08d03b8b554e741a0a622c2563f55" translate="yes" xml:space="preserve">
          <source>The code can be found on GiHub at the following link: &lt;a href=&quot;https://github.com/Nicola17/term2048-AI&quot;&gt;https://github.com/Nicola17/term2048-AI&lt;/a&gt;
It is based on &lt;a href=&quot;https://github.com/bfontaine/term2048&quot;&gt;term2048&lt;/a&gt; and it's written in Python. I will implement a more efficient version in C++ as soon as possible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Код можно найти на GiHub по следующей ссылке: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/Nicola17/term2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/Nicola17/term2048-AI.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Он основан на &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/bfontaine/term2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;term2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и написан на Python. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я буду реализовывать более эффективную версию в C ++ как можно скорее.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30eb0aa61e89069340123d96861286e1d3a860a8" translate="yes" xml:space="preserve">
          <source>The controller uses expectimax search with a state evaluation function learned from scratch (without human 2048 expertise) by a variant of &lt;strong&gt;temporal difference learning&lt;/strong&gt; (a reinforcement learning technique). The state-value  function uses an &lt;strong&gt;n-tuple network&lt;/strong&gt;, which is basically a weighted linear function of patterns observed on the board. It involved more than &lt;strong&gt;1 billion weights&lt;/strong&gt;, in total.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Контроллер использует поиск expectimax с функцией оценки состояния, изученной с нуля (без опыта человека 2048) с помощью варианта &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обучения&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; во &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;временной разнице&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (метод &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обучения&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с подкреплением). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Функция состояния-значения использует &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сеть&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n-кортежами&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , которая в основном представляет собой взвешенную линейную функцию шаблонов, наблюдаемых на плате. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Всего &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;задействовано более &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1 миллиарда весов&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e8ea22403f787ccc54f78cea6ca391603d91a87" translate="yes" xml:space="preserve">
          <source>The decision rule implemented is not quite smart, the code in Python is presented here:</source>
          <target state="translated">Реализованное правило принятия решения не совсем умно,код на Python представлен здесь:</target>
        </trans-unit>
        <trans-unit id="176b0272d8eef889ba807dbf653b453ecd6067de" translate="yes" xml:space="preserve">
          <source>The effect of these changes are extremely significant. The algorithm went from achieving the 16384 tile around 13% of the time to achieving it over 90% of the time, and the algorithm began to achieve 32768 over 1/3 of the time (whereas the old heuristics never once produced a 32768 tile).</source>
          <target state="translated">Эффект от этих изменений чрезвычайно значителен.Алгоритм прошел путь от достижения плитки 16384 около 13% времени до достижения более 90% времени,и алгоритм начал достигать 32768 за 13 лет (в то время как старая эвристика ни разу не производила плитку 32768).</target>
        </trans-unit>
        <trans-unit id="283d1c0d9684c8a42130b57edb6f6b92f5b86665" translate="yes" xml:space="preserve">
          <source>The expectimax search itself is coded as a recursive search which alternates between &quot;expectation&quot; steps (testing all possible tile spawn locations and values, and weighting their optimized scores by the probability of each possibility), and &quot;maximization&quot; steps (testing all possible moves and selecting the one with the best score). The tree search terminates when it sees a previously-seen position (using a &lt;a href=&quot;http://en.wikipedia.org/wiki/Transposition_table&quot;&gt;transposition table&lt;/a&gt;), when it reaches a predefined depth limit, or when it reaches a board state that is highly unlikely (e.g. it was reached by getting 6 &quot;4&quot; tiles in a row from the starting position). The typical search depth is 4-8 moves.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сам поиск expectimax кодируется как рекурсивный поиск, который чередуется между шагами &amp;laquo;ожидания&amp;raquo; (тестирование всех возможных мест и значений появления тайлов и взвешивание их оптимизированных оценок по вероятности каждой возможности) и шагами &amp;laquo;максимизации&amp;raquo; (тестирование всех возможных ходов). и выбрать тот, который набрал лучший результат). Поиск по дереву завершается, когда он видит ранее увиденную позицию (используя &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Transposition_table&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;таблицу транспонирования&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), когда он достигает предопределенного предела глубины или когда он достигает состояния доски, которое крайне маловероятно (например, оно было достигнуто путем получения 6 &quot;4&quot; тайлов в ряд от стартовой позиции). Типичная глубина поиска составляет 4-8 ходов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42f64f93fcb62fe61d13a7081dbd1385a6c16372" translate="yes" xml:space="preserve">
          <source>The following animation shows the last few steps of the game played where the AI player agent could get 2048 scores, this time adding the absolute value heuristic too:</source>
          <target state="translated">Следующая анимация показывает последние несколько этапов игры,где агент ИИ игрока мог получить 2048 очков,на этот раз добавив абсолютную ценность эвристики тоже:</target>
        </trans-unit>
        <trans-unit id="83682c685d59111d019249a4364f16870be09cd8" translate="yes" xml:space="preserve">
          <source>The following figures show the &lt;strong&gt;game tree&lt;/strong&gt; explored by the player AI agent assuming the computer as adversary for just a single step:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На следующих рисунках показано &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;игровое дерево,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; исследуемое агентом ИИ игрока, который за один шаг рассматривал компьютер как противника:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94d73024e25245de94e9edbd3aad5a30776360ec" translate="yes" xml:space="preserve">
          <source>The minimum score over all runs was 124024; the maximum score achieved was 794076. The median score is 387222. The AI never failed to obtain the 2048 tile (so it never lost the game even once in 100 games); in fact, it achieved the &lt;strong&gt;8192&lt;/strong&gt; tile at least once in every run!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Минимальная оценка по всем пробегам была 124024; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;максимальный результат - 794076. Медиана 387222. ИИ никогда не удавалось получить тайл 2048 (поэтому он никогда не проигрывал ни разу в 100 играх); &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;на самом деле, он получил &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;плитку &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;8192&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; хотя бы раз в каждом заезде!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c3427688b31e68bb54900072b17104508262705" translate="yes" xml:space="preserve">
          <source>The model has changed due to the luck of being closer to the expected model. The model the AI is trying to achieve is</source>
          <target state="translated">Модель изменилась в связи с удачей быть ближе к ожидаемой модели.Модель,которую пытается достичь ИИ</target>
        </trans-unit>
        <trans-unit id="1cdcb607ac22bbd92fb5b1889cdd98d3eecdba0a" translate="yes" xml:space="preserve">
          <source>The scores of the boards are computed with the weighted sum of the square of the number of free tiles and the dot product of the 2D grid with this:</source>
          <target state="translated">Оценки досок вычисляются с учетом взвешенной суммы квадрата количества свободных плиток и точечного изделия 2D сетки:</target>
        </trans-unit>
        <trans-unit id="ac8ac475f1d47ab38014e0ffd71fab5a7ebbc40c" translate="yes" xml:space="preserve">
          <source>The solution I propose is very simple and easy to implement. Although, it has reached the score of 131040. Several benchmarks of the algorithm performances are presented.</source>
          <target state="translated">Решение,которое я предлагаю,очень простое и легкое в реализации.Тем не менее,оно достигло отметки 131040.Представлено несколько эталонов производительности алгоритма.</target>
        </trans-unit>
        <trans-unit id="cd5ada7eeaffca19f06bbf8ec2f5ee7d8e800c9d" translate="yes" xml:space="preserve">
          <source>The tile statistics for 10 moves/s are as follows:</source>
          <target state="translated">Статистика по плиткам для 10 движений выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="0dcd0aa110a697c4c67a6487fafa9f7c0823aa9f" translate="yes" xml:space="preserve">
          <source>The whole approach will likely be more complicated than this but not much more complicated. It could be this mechanical in feel lacking scores, weights, neurones and deep searches of possibilities. The tree of possibilities rairly even needs to be big enough to need any branching at all.</source>
          <target state="translated">Весь подход,скорее всего,будет более сложным,чем этот,но не намного более сложным.Это может быть этот механический в ощущении отсутствия баллов,веса,нейронов и глубокого поиска возможностей.Дерево возможностей должно быть даже необузданно большим,чтобы вообще нуждаться в ветвях.</target>
        </trans-unit>
        <trans-unit id="6d4d3599a34b6269908c672524220c522c3745c8" translate="yes" xml:space="preserve">
          <source>There is already an AI implementation for this game &lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;here&lt;/a&gt;. Excerpt from README:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Существует уже реализация ИИ для этой игры &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Выдержка из README:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50c76a9fd12162abedcd5b1269d96e3a48779a24" translate="yes" xml:space="preserve">
          <source>There is also a discussion on &lt;a href=&quot;https://news.ycombinator.com/item?id=7379821&quot;&gt;Hacker News&lt;/a&gt; about this algorithm that you may find useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=7379821&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hacker News&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; также обсуждается &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;этот алгоритм, который может оказаться полезным.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e3943b324acda39f3164ad45d89f210e302e253" translate="yes" xml:space="preserve">
          <source>This algorithm is not optimal for winning the game, but it is fairly optimal in terms of performance and amount of code needed:</source>
          <target state="translated">Этот алгоритм не является оптимальным для победы в игре,но он достаточно оптимален с точки зрения производительности и количества необходимого кода:</target>
        </trans-unit>
        <trans-unit id="81716cb6c61fa929b1da024c98b8e777682d352a" translate="yes" xml:space="preserve">
          <source>This board representation, along with the table lookup approach for movement and scoring, allows the AI to search a huge number of game states in a short period of time (over 10,000,000 game states per second on one core of my mid-2011 laptop).</source>
          <target state="translated">Такое настольное представление,наряду с настольным поиском движения и очков,позволяет ИИ за короткий промежуток времени (более 10 000 000 игровых состояний в секунду на одном ядре моего ноутбука середины 2011 года)искать огромное количество игровых состояний.</target>
        </trans-unit>
        <trans-unit id="aab4a4bfd97ffe5030c2d295efd283014f0be653" translate="yes" xml:space="preserve">
          <source>This game took 27830 moves over 96 minutes, or an average of 4.8 moves per second.</source>
          <target state="translated">Эта партия заняла 27830 ходов за 96 минут,или в среднем 4,8 хода в секунду.</target>
        </trans-unit>
        <trans-unit id="1df55517328accd0f2dc6eb5550bd150b52fbce7" translate="yes" xml:space="preserve">
          <source>This graph illustrates this point: The blue line shows the board score after each move. The red line shows the algorithm's &lt;strong&gt;best&lt;/strong&gt; random-run end game score from that position. In essence, the red values are &quot;pulling&quot; the blue values upwards towards them, as they are the algorithm's best guess. It's interesting to see the red line is just a tiny bit above the blue line at each point, yet the blue line continues to increase more and more.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот график иллюстрирует эту точку: синяя линия показывает счет доски после каждого хода. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Красная линия показывает &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;лучший&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; результат алгоритма в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;произвольном порядке в конце игры с этой позиции. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По сути, красные значения &amp;laquo;тянут&amp;raquo; синие значения вверх к ним, поскольку они являются наилучшим предположением алгоритма. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Интересно, что красная линия чуть-чуть выше синей линии в каждой точке, но синяя линия продолжает увеличиваться все больше и больше.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="15d9cef8b96ce070fccbc886d3f7a52230dd95c2" translate="yes" xml:space="preserve">
          <source>This heuristic tries to ensure that the values of the tiles are all either increasing or decreasing along both the left/right and up/down directions. This heuristic alone captures the intuition that many others have mentioned, that higher valued tiles should be clustered in a corner. It will typically prevent smaller valued tiles from getting orphaned and will keep the board very organized, with smaller tiles cascading in and filling up into the larger tiles.</source>
          <target state="translated">Этот эвристический метод пытается обеспечить,чтобы все значения плиток либо увеличивались,либо уменьшались как по левому правому,так и по восходящему направлению.Одна только эта эвристика захватывает интуицию,о которой упоминали многие другие,что плитки,имеющие более высокую ценность,должны быть сгруппированы в угол.Это,как правило,предотвратит осиротевание небольших ценных плиток и будет держать доску очень организованной,с меньшими плитками,каскадирующими и заполняющими в большие плитки.</target>
        </trans-unit>
        <trans-unit id="f4404e8828677c74cccfa38f4bbfe1ae3bcfe6a7" translate="yes" xml:space="preserve">
          <source>This is a constant, used as a base-line and for other uses like testing.</source>
          <target state="translated">Это константа,используемая в качестве базовой линии и для других целей,таких как тестирование.</target>
        </trans-unit>
        <trans-unit id="406c95c020f4c2dd5ee8b09f0713c82e19af3169" translate="yes" xml:space="preserve">
          <source>This is a simplified check of the possibility of having merges within that state, without making a look-ahead.</source>
          <target state="translated">Это упрощенная проверка возможности слияний в пределах этого состояния,без предварительного просмотра.</target>
        </trans-unit>
        <trans-unit id="8131c0f0b0c2602cf4850dc23b1938260a7a7a9f" translate="yes" xml:space="preserve">
          <source>This is not a direct answer to OP's question, this is more of the stuffs (experiments) I tried so far to solve the same problem and obtained some results and have some observations that I want to share, I am curious if we can have some further insights from this.</source>
          <target state="translated">Это не прямой ответ на вопрос об ОП,это скорее вещи (эксперименты),которые я пытался решить до сих пор,и получил некоторые результаты,и есть некоторые наблюдения,которыми я хочу поделиться,мне любопытно,если мы можем иметь некоторые дополнительные выводы из этого.</target>
        </trans-unit>
        <trans-unit id="715df725c34a80cfb15f7cc31927abca202e48fb" translate="yes" xml:space="preserve">
          <source>This is possible due to domain-independent nature of the AI. Some of the variants are quite distinct, such as the Hexagonal clone.</source>
          <target state="translated">Это возможно благодаря доменно-независимой природе ИИ.Некоторые из вариантов довольно специфичны,например,клон гексагональный.</target>
        </trans-unit>
        <trans-unit id="2b8637dd6b7d75e139a375a20969b654b1c6a3f0" translate="yes" xml:space="preserve">
          <source>This is the model I chose by default.</source>
          <target state="translated">Это модель,которую я выбрал по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2dae92fa8773f5d81d34a41b5ee59edb28a87186" translate="yes" xml:space="preserve">
          <source>Tile needs merging with neighbour but is too small: Merge another neighbour with this one.</source>
          <target state="translated">Плитка должна сливаться с соседом,но слишком маленькая:сливайте с этим соседом другого.</target>
        </trans-unit>
        <trans-unit id="70b105f3079699e06f3a1ca29fc49029280f2f09" translate="yes" xml:space="preserve">
          <source>To assess the score performance of the AI, I ran the AI 100 times (connected to the browser game via remote control). For each tile, here are the proportions of games in which that tile was achieved at least once:</source>
          <target state="translated">Чтобы оценить эффективность работы ИИ,я прогонял ИИ 100 раз (подключался к браузерной игре через пульт дистанционного управления).Для каждой плитки приведены пропорции игр,в которых эта плитка была достигнута хотя бы один раз:</target>
        </trans-unit>
        <trans-unit id="562dbd4dd3fb3dd997d921a85e8dd207938296af" translate="yes" xml:space="preserve">
          <source>To enforce the ordination of the tiles in a monotonic decreasing order, the score si computed as the sum of the linearized values on the board multiplied by the values of a geometric sequence with common ratio r&amp;lt;1 .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы обеспечить порядок расположения плиток в монотонном порядке убывания, показатель si вычисляется как сумма линеаризованных значений на доске, умноженная на значения геометрической последовательности с общим отношением r &amp;lt;1.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1880862a60075224c2b8fdd3389edd49e7283e3" translate="yes" xml:space="preserve">
          <source>To resolve this problem, their are 2 ways to move that aren't left or worse up and examining both possibilities may immediately reveal more problems, this forms a list of dependancies, each problem requiring another problem to be solved first. I think I have this chain or in some cases tree of dependancies internally when deciding my next move, particularly when stuck.</source>
          <target state="translated">Для решения этой проблемы,их 2 способа перемещения,которые не остались или еще хуже вверх,и изучение обеих возможностей может сразу же выявить больше проблем,это формирует список зависимостей,каждая проблема требует,чтобы другая проблема была решена в первую очередь.Я думаю,что у меня есть эта цепочка или,в некоторых случаях,дерево зависимостей внутри при принятии решения о следующем переезде,особенно,когда я застрял.</target>
        </trans-unit>
        <trans-unit id="ab12b80b60d258a6dfc62b5818e8f4e339ef4aca" translate="yes" xml:space="preserve">
          <source>Two possible ways of organizing the board are shown in the following images:</source>
          <target state="translated">Два возможных способа организации доски представлены на следующих рисунках:</target>
        </trans-unit>
        <trans-unit id="ffc914498a4f81efe7ad50334ca89a25026fc42b" translate="yes" xml:space="preserve">
          <source>What I am doing is at any point, I will try to merge the tiles with values &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;, that is, I try to have &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; tiles, as minimum as possible. If I try it this way, all other tiles were automatically getting merged and the strategy seems good.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;То, что я делаю, в любой момент, я попытаюсь объединить плитки со значениями &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , то есть я стараюсь иметь &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; плитки, как можно меньше. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если я попробую это так, все остальные плитки будут автоматически объединены, и стратегия кажется хорошей.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0fe3580da7385572383dcfbcbfc67535e4972c3" translate="yes" xml:space="preserve">
          <source>What is the optimal algorithm for the game 2048</source>
          <target state="translated">Какой оптимальный алгоритм для игры 2048 г.</target>
        </trans-unit>
        <trans-unit id="7a2cd96c88d22411489171dc415feea04edc93dc" translate="yes" xml:space="preserve">
          <source>When it manages to reach the 128 it gains a whole row is gained again:</source>
          <target state="translated">Когда ему удается достичь 128,он снова выигрывает целый ряд:</target>
        </trans-unit>
        <trans-unit id="6cc2b46a0e2f9ee01b185acf82165706e2b0b69b" translate="yes" xml:space="preserve">
          <source>With just 100 runs (i.e in memory games) per move, the AI achieves the 2048 tile 80% of the times and the 4096 tile 50% of the times. Using 10000 runs gets the 2048 tile 100%, 70% for 4096 tile, and about 1% for the 8192 tile.</source>
          <target state="translated">Имея всего 100 запусков (т.е.в играх на память)за ход,ИИ достигает 2048 плитки в 80% случаев,а 4096 плитки в 50% случаев.Используя 10000 прогонов,ИИ достигает 2048 прогонов на 100%,70%-4096 прогонов и около 1%-8192 прогона.</target>
        </trans-unit>
        <trans-unit id="c3d1302c4890b9aa4694541642695d87a0b4b7ed" translate="yes" xml:space="preserve">
          <source>Yes, that's a 4096 alongside a 2048. =) That means it achieved the elusive 2048 tile three times on the same board.</source>
          <target state="translated">Да,это 4096 вместе с 2048.=)Это означает,что она трижды достигала неуловимой 2048 плитки на одной доске.</target>
        </trans-unit>
        <trans-unit id="b44092dddcd4f744019f7228202fb6783f53c989" translate="yes" xml:space="preserve">
          <source>You can try the AI for yourself. The code is available at &lt;a href=&quot;https://github.com/nneonneo/2048-ai&quot;&gt;https://github.com/nneonneo/2048-ai&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете попробовать ИИ для себя. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Код доступен по адресу &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/nneonneo/2048-ai&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/nneonneo/2048-ai&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59ac2882d7af09f5c4e2a1c7e5c5bb0dcad83a76" translate="yes" xml:space="preserve">
          <source>code below or on &lt;a href=&quot;https://caub.github.io/misc/2048&quot;&gt;github&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;код ниже или на &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://caub.github.io/misc/2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;github&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e9b496a0935b15e72709835275b0a4dd4c2a1c6" translate="yes" xml:space="preserve">
          <source>etc...</source>
          <target state="translated">etc...</target>
        </trans-unit>
        <trans-unit id="d8bd5af9109e98c522a44467b14c0ac230bbc8ca" translate="yes" xml:space="preserve">
          <source>where n is the number of tile on the board.</source>
          <target state="translated">где n-номер плитки на доске.</target>
        </trans-unit>
        <trans-unit id="f550c4f98092fb346941c9ffac4b20ee0d6c58a1" translate="yes" xml:space="preserve">
          <source>which forces to organize tiles descendingly in a sort of snake from the top left tile.</source>
          <target state="translated">которая заставляет организовать плитку в виде змеи,спускающейся с верхней левой плитки.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
