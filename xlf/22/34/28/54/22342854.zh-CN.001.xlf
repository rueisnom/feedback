<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/22342854">
    <body>
      <group id="22342854">
        <trans-unit id="f7c8748664ce768e7e3182c81b903ff85a7320c5" translate="yes" xml:space="preserve">
          <source>(The last line means having the given tiles at the same time on the board).</source>
          <target state="translated">最后一行的意思是在棋盘上同时有给定的瓷砖)。</target>
        </trans-unit>
        <trans-unit id="42dcce363a0691ffc8b52eaa155b22573fd9214f" translate="yes" xml:space="preserve">
          <source>(There's a possibility to reach the 131072 tile if the 4-tile is randomly generated instead of the 2-tile when needed)</source>
          <target state="translated">(有可能在需要的时候,如果随机生成的4分彩而不是2分彩,就有可能达到131072的瓦片)</target>
        </trans-unit>
        <trans-unit id="1b25f3cc01e7eaded5356820fc12a8514181d56e" translate="yes" xml:space="preserve">
          <source>2048 Variants and Clones</source>
          <target state="translated">2048种变体和克隆</target>
        </trans-unit>
        <trans-unit id="88a139cf0ed644e82e3541f84922caa249ed18ea" translate="yes" xml:space="preserve">
          <source>42000</source>
          <target state="translated">42000</target>
        </trans-unit>
        <trans-unit id="355a0cd8af03872d9ce2928c8cb3da7c2fb6cd2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Edit:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Edit:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08f52696de29f7f7ec6dc0a8a919df2a38e9ebaf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The constants can be tweaked..&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意：常量可以调整。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8634e4a85ec9ad0d2495ed0458b0ec8c578e8935" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Algorithm&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45ea392fe0c3da367d8c51717f364d940fe4fe60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decision rule&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;决策规则&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de42b3c305942617c48ca008230c0d5ed84ee53c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; This is a naive algorithm, modelling human conscious thought process, and gets very weak results compared to AI that search all possibilities since it only looks one tile ahead. It was submitted early in the response timeline.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编辑：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一种幼稚的算法，可对人类意识的思维过程进行建模，与AI相比，它搜索所有可能性的结果非常微弱，因为AI只能向前看。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它在响应时间表的早期提交。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b40ea2169b1372cb4d66f254c44144da5482dc88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Evaluation Details&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;评估细节&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b321d0995c10030e9430af46a596a61260d1dad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Evaluation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Evaluation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fbce973333197ec3e114cf37edcb6ff4502f6e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heuristic scoring algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;启发式评分算法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef6c3ec99e2445b2f8e789385112f8add04aca2a" translate="yes" xml:space="preserve">
          <source>A commenter on Hacker News gave &lt;a href=&quot;https://news.ycombinator.com/item?id=7381082&quot;&gt;an interesting formalization&lt;/a&gt; of this idea in terms of graph theory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;黑客新闻的评论者&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从图论的角度对该概念&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=7381082&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;了有趣的形式化&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0fc8abe55206bcc6fee5b9655148f68e7d675bb" translate="yes" xml:space="preserve">
          <source>A few pointers on the missing steps. Here:</source>
          <target state="translated">关于缺失步骤的几点提示。在这里。</target>
        </trans-unit>
        <trans-unit id="ccab3659df4d866e5c99429991c48026db374125" translate="yes" xml:space="preserve">
          <source>A state is more flexible if it has more freedom of possible transitions.</source>
          <target state="translated">如果一个状态有更多的可能的过渡自由度,那么这个状态就更灵活。</target>
        </trans-unit>
        <trans-unit id="884e259396760240aa757f365184412ce12cb6ac" translate="yes" xml:space="preserve">
          <source>AI Algorithm</source>
          <target state="translated">人工智能算法</target>
        </trans-unit>
        <trans-unit id="93e084b33c7ba167fbfbc4319e9d4f49b5668176" translate="yes" xml:space="preserve">
          <source>After implementing this algorithm I tried many improvements including using the min or max scores, or a combination of min,max,and avg. I also tried using depth: Instead of trying K runs per move, I tried K moves per move &lt;em&gt;list&lt;/em&gt; of a given length (&quot;up,up,left&quot; for example) and selecting the first move of the best scoring move list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实施此算法后，我尝试了许多改进，包括使用最小或最大得分，或最小，最大和平均值的组合。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我使用深度也试过：不是每移动试图ķ运行，我想每个举动K移到&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;列表&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的给定长度的（&amp;ldquo;向上，向上，左&amp;rdquo;为例），并选择最好的得分移动列表的第一招。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ede32df5eb0c24212c925595dd08fa4665c5adef" translate="yes" xml:space="preserve">
          <source>Also, I tried to increase the search depth cut-off from 3 to 5 (I can't increase it more since searching that space exceeds allowed time even with pruning) and added one more heuristic that looks at the values of adjacent tiles and gives more points if they are merge-able, but still I am not able to get 2048.</source>
          <target state="translated">另外,我试着把搜索深度截止点从3增加到5(我不能再增加了,因为即使是修剪,搜索这个空间也超过了允许的时间),并增加了一个启发式,看相邻瓷砖的值,如果它们是可合并的,就会给更多的分数,但我仍然无法得到2048。</target>
        </trans-unit>
        <trans-unit id="a52d36040473cfee0c3dda94c4922ec62a49256f" translate="yes" xml:space="preserve">
          <source>An implementation of the minmax or the Expectiminimax will surely improve the algorithm. Obviously a more
sophisticated decision rule will slow down the algorithm and it will require some time to be implemented.I will try a minimax implementation in the near future. (stay tuned)</source>
          <target state="translated">如果实现minmax或Expectiminimax,肯定会改善算法。显然,更复杂的决策规则会拖慢算法的速度,而且需要一些时间来实现。(敬请关注)</target>
        </trans-unit>
        <trans-unit id="81a3b22b9764c6db541f97a5b0cf0bc8185c33b4" translate="yes" xml:space="preserve">
          <source>An interesting fact about this algorithm is that while the random-play games are unsurprisingly quite bad, choosing the best (or least bad) move leads to very good game play: A typical AI game can reach 70000 points and last 3000 moves, yet the in-memory random play games from any given position yield an average of 340 additional points in about 40 extra moves before dying. (You can see this for yourself by running the AI and opening the debug console.)</source>
          <target state="translated">关于这种算法的一个有趣的事实是,虽然随机博弈的游戏不难理解,但选择最好的(或最不坏的)棋子会带来非常好的游戏效果。一个典型的AI游戏可以达到70000点,并持续3000步,然而从任何给定位置的内存中的随机博弈游戏在死亡前平均多走40步左右就能获得340点的额外积分。(你可以通过运行AI,打开调试控制台,就可以看到这一点)。</target>
        </trans-unit>
        <trans-unit id="e9d2a26295c1d0085ec67a73a147f26c2d1f037d" translate="yes" xml:space="preserve">
          <source>And finally, there is a penalty for having too few free tiles, since options can quickly run out when the game board gets too cramped.</source>
          <target state="translated">最后,空闲牌太少也是有惩罚的,因为当游戏板变得太过拥挤时,选项会很快用完。</target>
        </trans-unit>
        <trans-unit id="fdf944fcd7b6a6e2a2ddfb040b0978330ad9950a" translate="yes" xml:space="preserve">
          <source>And that's it! Searching through the game space while optimizing these criteria yields remarkably good performance. One advantage to using a generalized approach like this rather than an explicitly coded move strategy is that the algorithm can often find interesting and unexpected solutions. If you watch it run, it will often make surprising but effective moves, like suddenly switching which wall or corner it's building up against.</source>
          <target state="translated">就这么简单! 在优化这些标准的同时,通过对博弈空间进行搜索,可以获得非常好的性能。使用这样的泛化方法而不是明文规定的走法策略的一个好处是,算法经常可以找到有趣的、意想不到的解决方案。如果你观察它的运行,它经常会做出一些出人意料但又有效的动作,比如突然切换到哪个墙或墙角上。</target>
        </trans-unit>
        <trans-unit id="38ffd01cfffffe720859de9ba280dc3a2fa18ebe" translate="yes" xml:space="preserve">
          <source>And the chain to get there has become:</source>
          <target state="translated">和链,以达到的目的已经成为。</target>
        </trans-unit>
        <trans-unit id="f168395e34c5d5a79b07cf3ea9c0184c6cfec5d9" translate="yes" xml:space="preserve">
          <source>Any insights will be really very helpful, thanks in advance. (This is the link of my blog post for the article: &lt;a href=&quot;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&quot;&gt;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&lt;/a&gt; and the youtube video: &lt;a href=&quot;https://www.youtube.com/watch?v=VnVFilfZ0r4&quot;&gt;https://www.youtube.com/watch?v=VnVFilfZ0r4&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何见解都会非常有帮助，在此先感谢您。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（这是我博客文章的链接：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve -2048-game-with-computer /&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和youtube视频：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=VnVFilfZ0r4&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//www.youtube.com/watch?v=VnVFilfZ0r4&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccd9e8b01034b267d29c5745b84208f0a085f623" translate="yes" xml:space="preserve">
          <source>As a consequence, this solver is deterministic.</source>
          <target state="translated">因此,这个求解器是确定性的。</target>
        </trans-unit>
        <trans-unit id="9a7ad671d6cde8daae45c935046a605bf403cdad" translate="yes" xml:space="preserve">
          <source>At 1 moves/s: &lt;strong&gt;609104&lt;/strong&gt; (100 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每秒移动1次：&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;609104&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（平均100场比赛）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e5d64f1e0b61c1ef3e52e0d5823d5921bc21a50" translate="yes" xml:space="preserve">
          <source>At 10 moves/s: &lt;strong&gt;589355&lt;/strong&gt; (300 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每秒10次移动：&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;589355&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（平均300场比赛）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3c0d6ea43007ca3c28efb394b96f8a3287fcd1" translate="yes" xml:space="preserve">
          <source>At 3-ply (ca. 1500 moves/s): &lt;strong&gt;511759&lt;/strong&gt; (1000 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3层时（每秒1500次移动）：&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;511759&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（平均每1000场比赛）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e93088674333bdf43b53fdb34644dc1838dfbd19" translate="yes" xml:space="preserve">
          <source>Below animation shows the last few steps of the game played by the AI agent with the computer player:</source>
          <target state="translated">下面的动画显示的是AI代理与电脑玩家进行游戏的最后几步的动画。</target>
        </trans-unit>
        <trans-unit id="6c12051095dc9a9f3c8c9322ba72366123f527e4" translate="yes" xml:space="preserve">
          <source>Below is the code implementing the solving algorithm. The grid is represented as a 16-length array of Integers. And scoring is done simply by counting the number of empty squares.</source>
          <target state="translated">下面是实现求解算法的代码。网格被表示为一个由16个整数组成的数组。并简单地通过计算空方格的数量来进行计分。</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="85a8f1bded86a0cdaa694a12d8a5a7691488a18a" translate="yes" xml:space="preserve">
          <source>Bit shift operations are used to extract individual rows and columns. A single row or column is a 16-bit quantity, so a table of size 65536 can encode transformations which operate on a single row or column. For example, moves are implemented as 4 lookups into a precomputed &quot;move effect table&quot; which describes how each move affects a single row or column (for example, the &quot;move right&quot; table contains the entry &quot;1122 -&amp;gt; 0023&quot; describing how the row [2,2,4,4] becomes the row [0,0,4,8] when moved to the right).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;位移操作用于提取单独的行和列。单个行或列是16位数量，因此大小为65536的表可以编码对单个行或列进行操作的转换。例如，将移动作为4个查询实现到预先计算的&amp;ldquo;移动效果表&amp;rdquo;中，该表描述了每个移动如何影响单个行或一列（例如，&amp;ldquo;向右移动&amp;rdquo;表包含条目&amp;ldquo; 1122-&amp;gt; 0023&amp;rdquo;，该条目描述了当向右移动时，行[2,2,4,4]变为行[0,0,4,8]。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c42c80d6b77bd2a349eaa2543cf5ddc744fe92ff" translate="yes" xml:space="preserve">
          <source>But, when I actually use this algorithm, I only get around 4000 points before the game terminates. Maximum points AFAIK is slightly more than 20,000 points which is way larger than my current score. Is there a better algorithm than the above?</source>
          <target state="translated">但是,当我真正使用这种算法时,我只在游戏结束前得到4000分左右。最高分AFAIK是20000分,比我现在的分数要大得多。有没有比上面的算法更好的算法?</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="d5026d402b84438a420117883e0b28d724275f57" translate="yes" xml:space="preserve">
          <source>Currently, the program achieves about a 90% win rate running in javascript in the browser on my laptop given about 100 milliseconds of thinking time per move, so while not perfect (yet!) it performs pretty well.</source>
          <target state="translated">目前,该程序在我的笔记本电脑上以javascript在浏览器中运行时的胜率约为90%,每次移动的思考时间约为100毫秒,所以虽然还不是很完美(还没有!),但它的表现相当不错。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="6c38d1c09dfbb8d9afb27b450f505d02e699af0a" translate="yes" xml:space="preserve">
          <source>First I created a JavaScript version which can be &lt;a href=&quot;http://ronzil.github.io/2048-AI/&quot;&gt;seen in action here&lt;/a&gt;. This version can run 100's of runs in decent time. Open the console for extra info. 
(&lt;a href=&quot;https://github.com/ronzil/2048-AI&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先，我创建了一个JavaScript版本，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ronzil.github.io/2048-AI/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;看到&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该版本可以在适当的时间内运行100多次。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;打开控制台以获取更多信息。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ronzil/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来源&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb6608935b3258a93b48bed3d51f17ee42bad070" translate="yes" xml:space="preserve">
          <source>For 3-ply:</source>
          <target state="translated">用于3层。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="afd41cc839be699428bd0fa94a187d2888e8230c" translate="yes" xml:space="preserve">
          <source>Free Space Available</source>
          <target state="translated">可用的自由空间</target>
        </trans-unit>
        <trans-unit id="f00400337de66f8cbfda3eb6257d6edb7ab4d834" translate="yes" xml:space="preserve">
          <source>Free Tiles</source>
          <target state="translated">免费瓷砖</target>
        </trans-unit>
        <trans-unit id="05c3afb6f1373b0671a788c523440a2cdb7b67cf" translate="yes" xml:space="preserve">
          <source>Furthermore, Petr also optimized the heuristic weights using a &quot;meta-optimization&quot; strategy (using an algorithm called &lt;a href=&quot;https://en.wikipedia.org/wiki/CMA-ES&quot;&gt;CMA-ES&lt;/a&gt;), where the weights themselves were adjusted to obtain the highest possible average score.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此外，Petr还使用&amp;ldquo;元优化&amp;rdquo;策略（使用称为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/CMA-ES&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CMA-ES&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的算法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对启发式权重进行了优化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，其中权重本身进行了调整以获得最高的平均分数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a006d33e016b3552046744f9daab00e3a9dea82" translate="yes" xml:space="preserve">
          <source>Here goes the algorithm. Around 80% wins (it seems it is always possible to win with more &quot;professional&quot; AI techniques, I am not sure about this, though.)</source>
          <target state="translated">算法是这样的。胜率在80%左右(看来用更 &quot;专业 &quot;的AI技术,似乎总能赢,不过我不太清楚这一点)。</target>
        </trans-unit>
        <trans-unit id="9fde7d59da7d0da4eb4e909565d46f8fa0c4121d" translate="yes" xml:space="preserve">
          <source>Here the model and chain is:</source>
          <target state="translated">这里的模式和链条是。</target>
        </trans-unit>
        <trans-unit id="7f9a58f740830a3a6e0ce355d41b93414963aa63" translate="yes" xml:space="preserve">
          <source>Here we evaluate faces that have the possibility to getting to merge, by evaluating them backwardly, tile 2 become of value 2048, while tile 2048 is evaluated 2.</source>
          <target state="translated">这里我们评估有可能得到合并的面,通过向后评估,瓦片2的值为2048,而瓦片2048被评估为2。</target>
        </trans-unit>
        <trans-unit id="ea14290a91583ca847b2ae45387c083c3b7f5174" translate="yes" xml:space="preserve">
          <source>Here's a demonstration of the power of this approach. I uncapped the tile values (so it kept going after reaching 2048) and here is the best result after eight trials.</source>
          <target state="translated">下面是这个方法的威力展示。我取消了瓦片值的上限(所以在达到2048之后,它就一直保持着),这里是八次试验之后的最佳结果。</target>
        </trans-unit>
        <trans-unit id="4f64374fb447322f3ae9648b3c8851f4e3a0a00f" translate="yes" xml:space="preserve">
          <source>Here's a screenshot of a perfectly monotonic grid. I obtained this by running the algorithm with the eval function set to disregard the other heuristics and only consider monotonicity.</source>
          <target state="translated">这里是一个完全单调的网格的截图。我是通过运行算法的eval函数设置来忽略其他启发式,只考虑单调性,从而得到的。</target>
        </trans-unit>
        <trans-unit id="f97f5d39b364919717cbfb83c95dfea658c2d11e" translate="yes" xml:space="preserve">
          <source>Here's a screenshot of a perfectly smooth grid, courtesy of &lt;a href=&quot;http://jennypeng.me/2048/&quot;&gt;this excellent parody fork&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个完美平滑的网格的屏幕截图，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://jennypeng.me/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这得益于出色的模仿叉&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b03d95f10bf2fb9649d305f295aac7854cae9194" translate="yes" xml:space="preserve">
          <source>Here's the screenshot of the best run:</source>
          <target state="translated">下面是极品跑的截图。</target>
        </trans-unit>
        <trans-unit id="ffac2906be85464582876c1fd5b67e5775ca4c9b" translate="yes" xml:space="preserve">
          <source>Heuristics</source>
          <target state="translated">Heuristics</target>
        </trans-unit>
        <trans-unit id="ed8ab7ed11c60bc100175f13e827da35c53e21c1" translate="yes" xml:space="preserve">
          <source>However, I have never observed it obtaining the 65536 tile.</source>
          <target state="translated">然而,我从来没有观察到它获得65536瓷砖。</target>
        </trans-unit>
        <trans-unit id="84fd09822e571ef59181c3b714b48c120c88bc2d" translate="yes" xml:space="preserve">
          <source>However, none of these ideas showed any real advantage over the simple first idea. I left the code for these ideas commented out in the C++ code.</source>
          <target state="translated">然而,这些想法都没有显示出比第一个简单的想法有任何真正的优势。我把这些想法的代码留在C++代码中注释出来。</target>
        </trans-unit>
        <trans-unit id="5e64fedf544d393d02c17117048de608b040496d" translate="yes" xml:space="preserve">
          <source>I also tried the corner heuristic, but for some reason it makes the results worse, any intuition why?</source>
          <target state="translated">我也试过转角启发式,但不知道为什么会让效果变差,有什么直觉的原因吗?</target>
        </trans-unit>
        <trans-unit id="bff61911fdd315b14809acd1b0718f81baa37d98" translate="yes" xml:space="preserve">
          <source>I am the author of a 2048 controller that scores better than any other program mentioned in this thread. An efficient implementation of the controller is available on &lt;a href=&quot;https://github.com/aszczepanski/2048&quot;&gt;github&lt;/a&gt;. In &lt;a href=&quot;https://github.com/wjaskowski/mastering-2048&quot;&gt;a separate repo&lt;/a&gt; there is also the code used for training the controller's state evaluation function. The training method is described in the &lt;a href=&quot;http://arxiv.org/abs/1604.05085&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我是2048控制器的作者，该控制器的得分比该线程中提到的任何其他程序都要好。可以在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/aszczepanski/2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;github&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上找到控制器的有效实现&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/wjaskowski/mastering-2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;单独的仓库中&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，还存在用于训练控制器状态评估功能的代码。该训练方法中描述&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://arxiv.org/abs/1604.05085&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;纸&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b1878005b4715ef7dadf5dbab3530f2387e3d7d" translate="yes" xml:space="preserve">
          <source>I applied convex combination (tried different heuristic weights) of couple of heuristic evaluation functions, mainly from intuition and from the ones discussed above:</source>
          <target state="translated">我应用了几个启发式评价函数的凸组合(尝试了不同的启发式权重),主要来自于直觉和上面讨论过的函数。</target>
        </trans-unit>
        <trans-unit id="b340ff0771c0044d5631169bb8b9da7b0949767e" translate="yes" xml:space="preserve">
          <source>I became interested in the idea of an AI for this game containing &lt;strong&gt;no hard-coded intelligence&lt;/strong&gt; (i.e no heuristics, scoring functions etc). The AI should &lt;em&gt;&quot;know&quot;&lt;/em&gt; only the game rules, and &lt;em&gt;&quot;figure out&quot;&lt;/em&gt; the game play. This is in contrast to most AIs (like the ones in this thread) where the game play is essentially brute force steered by a scoring function representing human understanding of the game.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我对此游戏的AI构想产生了兴趣，其中&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包含&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;硬编码的智能&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（即，没有启发式，计分功能等）。 AI应该&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;知道&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;游戏规则，并&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;确定&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;游戏玩法。这与大多数AI（如该线程中的AI）相反，后者的游戏本质上是由代表人类对游戏理解的计分功能操纵的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed0a579e8bb5a2fa1f190be9cc3a3984935966dd" translate="yes" xml:space="preserve">
          <source>I believe there's still room for improvement on the heuristics. This algorithm definitely isn't yet &quot;optimal&quot;, but I feel like it's getting pretty close.</source>
          <target state="translated">我相信在启发式算法上还有改进的空间。这个算法肯定还不是 &quot;最优的&quot;,但我觉得已经很接近了。</target>
        </trans-unit>
        <trans-unit id="f8ed635115239705d2911e5bd2f5ced5edce99c5" translate="yes" xml:space="preserve">
          <source>I copy here the content of a &lt;a href=&quot;http://diaryofatinker.blogspot.it/2014/03/an-artificial-intelligence-for-2048-game.html&quot;&gt;post on my blog&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我在这里复制&lt;/font&gt;&lt;a href=&quot;http://diaryofatinker.blogspot.it/2014/03/an-artificial-intelligence-for-2048-game.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;博客文章&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的内容&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d84a2a8980a497e88dd0c2f4d14dcecd79505253" translate="yes" xml:space="preserve">
          <source>I developed a 2048 AI using &lt;em&gt;expectimax&lt;/em&gt; optimization, instead of the minimax search used by @ovolve's algorithm. The AI simply performs maximization over all possible moves, followed by expectation over all possible tile spawns (weighted by the probability of the tiles, i.e. 10% for a 4 and 90% for a 2). As far as I'm aware, it is not possible to prune expectimax optimization (except to remove branches that are exceedingly unlikely), and so the algorithm used is a carefully optimized brute force search.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我使用&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Expectimax&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;开发了2048 AI &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，而不是&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@ovolve&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用的&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;minimax&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;搜索。 AI会简单地对所有可能的移动执行最大化，然后对所有可能的图块生成进行期望（通过图块的概率加权，即4的概率为10％，2的概率为90％）。据我所知，不可能修剪Expectimax优化（除去删除极不可能的分支），因此使用的算法是经过仔细优化的蛮力搜索。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a35fdce8c7933d0b2a937ce2170823745b56f98" translate="yes" xml:space="preserve">
          <source>I did add a &quot;Deep Search&quot; mechanism that increased the run number temporarily to 1000000 when any of the runs managed to accidentally reach the next highest tile. This offered a time improvement.</source>
          <target state="translated">我确实添加了一个 &quot;深度搜索 &quot;机制,当任何一个运行的玩家不小心到达下一个最高的瓦片时,会将运行数暂时增加到1000000。这提供了一个时间上的改善。</target>
        </trans-unit>
        <trans-unit id="ba7f2fdb047681e855cdfd6b772b6db5b92aa4ee" translate="yes" xml:space="preserve">
          <source>I find it quite surprising that the algorithm doesn't need to actually foresee good game play in order to chose the moves that produce it.</source>
          <target state="translated">我觉得很奇怪的是,算法不需要实际预测到好的游戏玩法,就可以选择产生算法的招式。</target>
        </trans-unit>
        <trans-unit id="2224c20bdfc42ec2f0bd05389e5c06114237583f" translate="yes" xml:space="preserve">
          <source>I found a simple yet surprisingly good playing algorithm: To determine the next move for a given board, the AI plays the game in memory using &lt;strong&gt;random moves&lt;/strong&gt; until the game is over. This is done several times while keeping track of the end game score. Then the average end score &lt;em&gt;per starting move&lt;/em&gt; is calculated. The starting move with the highest average end score is chosen as the next move.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我发现了一个简单但出乎意料的出色玩法：要确定给定棋盘的下一招，AI会使用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;随机招数&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在内存中玩游戏，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;直到游戏结束。在跟踪最终比赛分数的同时，完成了几次。然后&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;计算&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个开始动作&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的平均终点得分&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。选择平均终点得分最高的起点作为下一步。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="031425862c087193c510d3992030621083927b33" translate="yes" xml:space="preserve">
          <source>I have 4x4 grid for playing the game.</source>
          <target state="translated">我有4X4格子,用于玩游戏。</target>
        </trans-unit>
        <trans-unit id="f56414c1f6736cdf7c56bfca13c15f73247b88ce" translate="yes" xml:space="preserve">
          <source>I have recently stumbled upon the game &lt;a href=&quot;http://gabrielecirulli.github.io/2048/&quot;&gt;2048&lt;/a&gt;. You merge similar tiles by moving them in any of the four directions to make &quot;bigger&quot; tiles. After each move, a new tile appears at random empty position with a value of either &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;. The game terminates when all the boxes are filled and there are no moves that can merge tiles, or you create a tile with a value of &lt;code&gt;2048&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我最近偶然发现了&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://gabrielecirulli.github.io/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;游戏&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以通过在四个方向上任意移动相似的图块来合并它们，以制作&amp;ldquo;更大&amp;rdquo;的图块。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每次移动后，新的图块将出现在随机的空白位置，值为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当所有盒子都装满并且没有可以合并磁贴的移动，或者您创建的值为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;2048&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;磁贴时，游戏终止&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59f0d82a356c65bde837828cc539c2e8be89a87d" translate="yes" xml:space="preserve">
          <source>I have refined the algorithm and beaten the game! It may fail due to simple bad luck close to the end (you are forced to move down, which you should never do, and a tile appears where your highest should be. Just try to keep the top row filled, so moving left does not break the pattern), but basically you end up having a fixed part and a mobile part to play with. This is your objective:</source>
          <target state="translated">我已经完善了这个算法,并且打败了这个游戏! 它可能会因为简单的运气不好而失败(你被迫往下移动,这是你永远不应该做的,在你最高的地方出现了一个瓦片,你的最高的地方应该是。尽量把最高的那一排填满就好了,所以向左移动不会打破格局),但基本上你最终会有一个固定的部分和一个移动的部分来玩。这就是你的目标。</target>
        </trans-unit>
        <trans-unit id="e043b4a0622bd7bd4f4bff3f75f5289152c44dc3" translate="yes" xml:space="preserve">
          <source>I just tried my minimax implementation with alpha-beta pruning with search-tree depth cutoff at 3 and 5. I was trying to solve the same problem for a 4x4 grid as a project assignment for the &lt;strong&gt;edX course ColumbiaX: CSMM.101x Artificial Intelligence (AI)&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我刚刚尝试了在3和5时使用带有搜索树深度截止的alpha-beta修剪的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;minimax实现。 AI）&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f7940b642881ad963c29c8e46d7cecbcc69643e3" translate="yes" xml:space="preserve">
          <source>I think I found an algorithm which works quite well, as I often reach scores over 10000, my personal best being around 16000. My solution does not aim at keeping biggest numbers in a corner, but to keep it in the top row.</source>
          <target state="translated">我想我找到了一种算法,效果相当不错,因为我的分数经常能达到10000分以上,我个人最好的是16000分左右。我的解决方案并不是为了把最大的数字放在一个角落里,而是把它放在最上面一排。</target>
        </trans-unit>
        <trans-unit id="55f66ed61b2ad8167d89233045ef1fe2708fd931" translate="yes" xml:space="preserve">
          <source>I think it will be better to use Expectimax instead of minimax, but still I want to solve this problem with minimax only and obtain high scores such as 2048 or 4096. I am not sure whether I am missing anything.</source>
          <target state="translated">我觉得用Expectimax来代替minimumax会更好,但我还是想只用minimumax来解决这个问题,获得2048或4096这样的高分。我不确定自己是否有什么遗漏。</target>
        </trans-unit>
        <trans-unit id="ea165dbbcc05f8b9c0fee4d6f269ceb0aa9da587" translate="yes" xml:space="preserve">
          <source>I thinks it's quite successful for its simplicity. The result it reaches when starting with an empty grid and solving at depth 5 is:</source>
          <target state="translated">我认为它的简单性是相当成功的。它从一个空网格开始,在深度5处求解时,所得到的结果是:</target>
        </trans-unit>
        <trans-unit id="1034d585a72bb081cca29625c761242ddf856012" translate="yes" xml:space="preserve">
          <source>I used an exhaustive algorithm that favours empty tiles. It performs pretty quickly for depth 1-4, but on depth 5 it gets rather slow at a around 1 second per move.</source>
          <target state="translated">我使用了一个偏向于空牌的穷尽算法。在深度1-4的情况下,它的执行速度相当快,但在深度5的情况下,它的速度变得相当慢,每走一步大约1秒。</target>
        </trans-unit>
        <trans-unit id="37173dc2be4bdb4d84b503ac96c838e5e06ad4e3" translate="yes" xml:space="preserve">
          <source>I wrote a 2048 solver in Haskell, mainly because I'm learning this language right now.</source>
          <target state="translated">我用Haskell写了一个2048求解器,主要是因为我现在正在学习这门语言。</target>
        </trans-unit>
        <trans-unit id="46c02f631905ee5caf0b222fd7359a47400755dd" translate="yes" xml:space="preserve">
          <source>I'd be interested to hear if anyone has other improvement ideas that maintain the domain-independence of the AI.</source>
          <target state="translated">我很想知道,如果有谁有其他的改进思路,能保持人工智能的领域独立性,我会很感兴趣。</target>
        </trans-unit>
        <trans-unit id="a1169010fb1d82ea350ecfb6aa43f3802bb8f9f2" translate="yes" xml:space="preserve">
          <source>I'm the author of the AI program that others have mentioned in this thread. You can view the AI in &lt;a href=&quot;http://ovolve.github.io/2048-AI/&quot;&gt;action&lt;/a&gt; or read the &lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;source&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我是该线程中其他人提到的AI程序的作者。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以查看AI &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ovolve.github.io/2048-AI/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行动&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或阅读&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;源&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cff211afed3c58617e7600239f98eba6f99208de" translate="yes" xml:space="preserve">
          <source>If I assign too much weights to the first heuristic function or the second heuristic function, both the cases the scores the AI player gets are low. I played with many possible weight assignments to the heuristic functions and take a convex combination, but very rarely the AI player is able to score 2048. Most of the times it either stops at 1024 or 512.</source>
          <target state="translated">如果我给第一个启发式函数或第二个启发式函数分配过多的权重,这两种情况下,AI玩家得到的分数都很低。我玩了很多可能的权重分配给启发式函数,并采取了凸形组合,但很少有AI玩家能够得到2048分。大多数时候不是停在1024分,就是512分。</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3ed4d38edf88c96646888aef4c5aee857217b77c" translate="yes" xml:space="preserve">
          <source>Implementation and Links</source>
          <target state="translated">执行和联系</target>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="dae216ce28189a3dc03880a06f90efd300da2352" translate="yes" xml:space="preserve">
          <source>In case of T2, four tests in ten generate the 4096 tile with an average score of</source>
          <target state="translated">在T2的情况下,10个测试中,有4个测试产生了4096张牌,平均得分为</target>
        </trans-unit>
        <trans-unit id="06f4f3fea3016100595f36b33ff12f794776a418" translate="yes" xml:space="preserve">
          <source>In here we still need to check for stacked values, but in a lesser way that doesn't interrupt the flexibility parameters, so we have the sum of { x in [4,44] }.</source>
          <target state="translated">在这里,我们仍然需要对堆叠值进行检查,但以较少的方式不中断弹性参数,所以我们有{x在[4,44]}中的总和。</target>
        </trans-unit>
        <trans-unit id="3c2636cc71bb825cadfd8c456577a98d04fe05b8" translate="yes" xml:space="preserve">
          <source>In my case, the computer player is completely random, but still i assumed adversarial settings and implemented the AI player agent as the max player.</source>
          <target state="translated">在我的案例中,电脑玩家完全是随机的,但我仍然假设了对抗性设置,并实现了AI玩家代理作为最大玩家。</target>
        </trans-unit>
        <trans-unit id="23652927c0d25e443786d2f509c213988410f12c" translate="yes" xml:space="preserve">
          <source>Initially, I used two very simple heuristics, granting &quot;bonuses&quot; for open squares and for having large values on the edge. These heuristics performed pretty well, frequently achieving 16384 but never getting to 32768.</source>
          <target state="translated">最初,我使用了两个非常简单的启发式算法,对开放的方块和边缘上的大值给予 &quot;奖励&quot;。这两种启发式方法的表现相当不错,经常达到16384,但从未达到32768。</target>
        </trans-unit>
        <trans-unit id="1545ea420f5c65b9c9bba94c946b329fa8251dc3" translate="yes" xml:space="preserve">
          <source>Just for fun, I've also &lt;a href=&quot;http://ronzil.github.io/2048AI-AllClones/&quot;&gt;implemented the AI as a bookmarklet&lt;/a&gt;, hooking into the game's controls. This allows the AI to work with the original game and &lt;strong&gt;many of its variants&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是为了好玩，我还将&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ronzil.github.io/2048AI-AllClones/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI作为书签实现了&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，与游戏的控件挂钩。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这使AI可以与原始游戏及其&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;许多变体一起使用&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="87ab7e933f551b05ada40bfa9c63b7d3a98505ae" translate="yes" xml:space="preserve">
          <source>Larger tile in the way: Increase the value of a smaller surrounding tile.</source>
          <target state="translated">较大的瓷砖在途中。增加周围较小的瓷砖的价值。</target>
        </trans-unit>
        <trans-unit id="18be8c8127f21459189b5caf81e55e1002781278" translate="yes" xml:space="preserve">
          <source>Later I implemented a scoring tree that took into account the conditional probability of being able to play a move after a given move list.</source>
          <target state="translated">后来我实施了一个计分树,考虑到在给定的招式列表后,有条件的概率可以出招。</target>
        </trans-unit>
        <trans-unit id="5d40de2c184332bb133e3c7b3f9b7106a46f6318" translate="yes" xml:space="preserve">
          <source>Later, in order to play around some more I used @nneonneo highly optimized infrastructure and implemented my version in C++. This version allows for up to 100000 runs per move and even 1000000 if you have the patience. Building instructions provided. It runs in the console and also has a remote-control to play the web version.
(&lt;a href=&quot;https://github.com/ronzil/2048-ai-cpp&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;后来，为了玩得更多，我使用了@nneonneo高度优化的基础结构，并使用C ++实现了我的版本。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您有足够的耐心，此版本最多可允许单次运行100000次，甚至100万次。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供了建筑说明。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它运行在控制台中，还具有用于播放Web版本的遥控器。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ronzil/2048-ai-cpp&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来源&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="44c2d6ea8314c3f98974d2ba1a58dd051bb32c6f" translate="yes" xml:space="preserve">
          <source>Many of the other answers use AI with computationally expensive searching of possible futures, heuristics, learning and the such. These are impressive and probably the correct way forward, but I wish to contribute another idea.</source>
          <target state="translated">许多其他的答案都使用了人工智能,并使用了计算成本高的人工智能搜索可能的未来、启发式学习和学习等。这些都令人印象深刻,可能是正确的方法,但我想贡献另一个想法。</target>
        </trans-unit>
        <trans-unit id="2b46f31c24d9d078dc34aed0d4067c4f769ba53f" translate="yes" xml:space="preserve">
          <source>Model the sort of strategy that good players of the game use.</source>
          <target state="translated">优秀的游戏玩家所使用的那种策略模型。</target>
        </trans-unit>
        <trans-unit id="fd4c07fb20d7d76fbcadaea8ea7ddaaac986f8c7" translate="yes" xml:space="preserve">
          <source>Monotonicity</source>
          <target state="translated">Monotonicity</target>
        </trans-unit>
        <trans-unit id="44fc3fc0ab34b52134a7cd76d9bbcb14829e6e00" translate="yes" xml:space="preserve">
          <source>More spaces makes the state more flexible, we multiply by 128 (which is the median) since a grid filled with 128 faces is an optimal impossible state.</source>
          <target state="translated">更多的空间使状态更加灵活,我们乘以128(也就是中位数),因为充满128个面的网格是一个最优的不可能状态。</target>
        </trans-unit>
        <trans-unit id="1f62f4a60f5f356eabae5d8f3cb887dce903adda" translate="yes" xml:space="preserve">
          <source>My approach encodes the entire board (16 entries) as a single 64-bit integer (where tiles are the nybbles, i.e. 4-bit chunks). On a 64-bit machine, this enables the entire board to be passed around in a single machine register.</source>
          <target state="translated">我的方法是将整个电路板(16个条目)编码为一个64位的整数(其中tiles是nybbles,即4位块)。在64位的机器上,这使得整个电路板可以在一个机器寄存器中传递。</target>
        </trans-unit>
        <trans-unit id="ef5c72f488757b3c3972bc8a4c545658ae48db02" translate="yes" xml:space="preserve">
          <source>My attempt uses expectimax like other solutions above, but without bitboards. Nneonneo's solution can check 10millions of moves which is approximately a depth of 4 with 6 tiles left and 4 moves possible (2*6*4)&lt;sup&gt;4&lt;/sup&gt;. In my case, this depth takes too long to explore, I adjust the depth of expectimax search according to the number of free tiles left:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的尝试像上面的其他解决方案一样使用Expectimax，但是没有位板。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nneonneo的解决方案可以检查1000万次移动，这大约是深度4，剩下6个图块，并且可以进行4个移动（2 * 6 * 4）&lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;就我而言，这个深度需要花费太长时间来探索，我会根据剩余的可用磁贴数量来调整Expectimax搜索的深度：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="57e8410bf6b4571c6670e5f2ee8f617e934c4d80" translate="yes" xml:space="preserve">
          <source>My current algorithm:</source>
          <target state="translated">我目前的算法。</target>
        </trans-unit>
        <trans-unit id="bea5caec78afaf43f0643aa15a7e4f0a707e1354" translate="yes" xml:space="preserve">
          <source>My implementation of the game slightly differs from the actual game, in that a new tile is always a '2' (rather than 90% 2 and 10% 4). And that the new tile is not random, but always the first available one from the top left. This variant is also known as &lt;a href=&quot;https://jmfork.github.io/2048/&quot;&gt;Det 2048&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我对游戏的实现与实际游戏略有不同，因为新的图块始终为&amp;ldquo; 2&amp;rdquo;（而不是90％2和10％4）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且新的图块不是随机的，而是始终是左上角的第一个可用图块。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此变体也称为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://jmfork.github.io/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Det 2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d18c870dbfd8a43034e5e38c25648f6a00c617cb" translate="yes" xml:space="preserve">
          <source>Observation:</source>
          <target state="translated">Observation:</target>
        </trans-unit>
        <trans-unit id="1d445de243f043f2a68c63600c349cf26b114c50" translate="yes" xml:space="preserve">
          <source>One, I need to follow a well-defined strategy to reach the goal. So, I thought of writing a program for it.</source>
          <target state="translated">其一,我需要按照一个明确的策略来实现目标。于是,我想到了为它写一个计划。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="640af8b8b4a6b17289c61d8f064089730a066c2e" translate="yes" xml:space="preserve">
          <source>Petr Mor&amp;aacute;vek (@xificurk) took my AI and added two new heuristics. The first heuristic was a penalty for having non-monotonic rows and columns which increased as the ranks increased, ensuring that  non-monotonic rows of small numbers would not strongly affect the score, but non-monotonic rows of large numbers hurt the score substantially. The second heuristic counted the number of potential merges (adjacent equal values) in addition to open spaces. These two heuristics served to push the algorithm towards monotonic boards (which are easier to merge), and towards board positions with lots of merges (encouraging it to align merges where possible for greater effect).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PetrMor&amp;aacute;vek（@xificurk）采用了我的AI，并添加了两个新的启发式方法。第一种启发式方法是对具有非单调的行和列的行列进行惩罚，该行和列随等级的增加而增加，以确保数量较少的非单调行不会严重影响得分，但数量较大的非单调行会严重损害得分。第二个启发式方法计算了除开放空间外的潜在合并数（相邻的相等值）。这两种启发式算法将算法推向单调板（更易于合并），并推向具有大量合并的板位置（鼓励它在可能的情况下对齐合并以产生更大的效果）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="503f6e600737ff2f29cf68701e034324b5731a1b" translate="yes" xml:space="preserve">
          <source>Please see the code below:</source>
          <target state="translated">请看下面的代码。</target>
        </trans-unit>
        <trans-unit id="6df2f58f408bc47f5e66563bfde9ff0172588105" translate="yes" xml:space="preserve">
          <source>Read the squares in the order shown above until the next squares value is greater than the current one. This presents the problem of trying to merge another tile of the same value into this square.</source>
          <target state="translated">按照上面的顺序读取方块,直到下一个方块的值大于当前方块。这就出现了一个问题,那就是试图将相同值的另一个方块合并到这个方块中。</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="33bfd3ccf12da33384e54b78f3b1b416cd79f5ee" translate="yes" xml:space="preserve">
          <source>Running 10000 runs with a temporary increase to 1000000 near critical positions managed to break this barrier less than 1% of the times achieving a max score of 129892 and the 8192 tile.</source>
          <target state="translated">在临界位置附近临时增加到1000000运行10000的情况下,成功突破这一关卡的次数不足1%,达到了12892的最高分和8192的瓷砖。</target>
        </trans-unit>
        <trans-unit id="f53aad58499a66a812ae2a8fadd0d52bc3c90c03" translate="yes" xml:space="preserve">
          <source>Scoring is also done using table lookup. The tables contain heuristic scores computed on all possible rows/columns, and the resultant score for a board is simply the sum of the table values across each row and column.</source>
          <target state="translated">分数也是通过表格查询来进行的。表中包含了对所有可能的行和列的启发式评分,而一个板的结果就是每一行和每一列的表值之和。</target>
        </trans-unit>
        <trans-unit id="6f0d0289231f49f701b9b200b4a3eac54cedef68" translate="yes" xml:space="preserve">
          <source>Searching later I found this algorithm might be classified as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Monte-Carlo_tree_search#Pure_Monte_Carlo_game_search&quot;&gt;Pure Monte Carlo Tree Search&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;稍后搜索，我发现该算法可能被归类为&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Monte-Carlo_tree_search#Pure_Monte_Carlo_game_search&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;纯蒙特卡洛树搜索&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c6dc8c149cc76d5efe765ba938462b2a01c9d89" translate="yes" xml:space="preserve">
          <source>Second pointer, it has had bad luck and its main spot has been taken. It is likely that it will fail, but it can still achieve it:</source>
          <target state="translated">第二个指针,它的运气不好,主要的点位已经被拿下了。很可能会失败,但还是可以实现的。</target>
        </trans-unit>
        <trans-unit id="f7bd04bc23d0d8eee5b56955d487fc2585d2855f" translate="yes" xml:space="preserve">
          <source>See it in action</source>
          <target state="translated">看看它的行动</target>
        </trans-unit>
        <trans-unit id="b6e3041754015cf5ce95b9217697dd1eafce96ab" translate="yes" xml:space="preserve">
          <source>Several heuristics are used to direct the optimization algorithm towards favorable positions. The precise choice of heuristic has a huge effect on the performance of the algorithm. The various heuristics are weighted and combined into a positional score, which determines how &quot;good&quot; a given board position is. The optimization search will then aim to maximize the average score of all possible board positions. The actual score, as shown by the game, is &lt;em&gt;not&lt;/em&gt; used to calculate the board score, since it is too heavily weighted in favor of merging tiles (when delayed merging could produce a large benefit).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用几种启发式方法将优化算法引向有利位置。启发式算法的精确选择对算法的性能有很大的影响。权衡各种启发式方法并将其组合到位置分数中，该分数确定给定板位置的&amp;ldquo;好&amp;rdquo;程度。然后，优化搜索将旨在使所有可能的董事会职位的平均分数最大化。如游戏所示，实际得分&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用于计算棋盘得分，因为它过于偏重而无法合并砖块（延迟合并可能会产生很大的收益）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2318e6fc587a3fb272235edad6036fe0432bc136" translate="yes" xml:space="preserve">
          <source>Several linear path could be evaluated at once, the final score will be the maximum score of any path.</source>
          <target state="translated">多条线性路径可以同时进行评价,最终得分将是任何路径的最高分。</target>
        </trans-unit>
        <trans-unit id="c72dd283f25dc910b0a759e6f55e51f7b00e7039" translate="yes" xml:space="preserve">
          <source>Since the game is a discrete state space, perfect information, turn-based game like chess and checkers, I used the same methods that have been proven to work on those games, namely &lt;a href=&quot;http://www.flyingmachinestudios.com/programming/minimax/&quot;&gt;minimax&lt;/a&gt;&lt;a href=&quot;http://xkcd.com/832/&quot;&gt;search&lt;/a&gt; with &lt;a href=&quot;http://cs.ucla.edu/~rosen/161/notes/alphabeta.html&quot;&gt;alpha-beta pruning&lt;/a&gt;. Since there is already a lot of info on that algorithm out there, I'll just talk about the two main heuristics that I use in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_function&quot;&gt;static evaluation function&lt;/a&gt; and which formalize many of the intuitions that other people have expressed here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于该游戏是离散的状态空间，完美的信息，基于回合的游戏（如国际象棋和西洋跳棋），因此我使用了已被证明可用于这些游戏的相同方法，即&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;带有&lt;/font&gt;&lt;a href=&quot;http://cs.ucla.edu/~rosen/161/notes/alphabeta.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;alpha-beta修剪的&lt;/font&gt;&lt;/a&gt;&lt;/font&gt;&lt;a href=&quot;http://www.flyingmachinestudios.com/programming/minimax/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;minimax &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;http://xkcd.com/832/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;搜索&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于已经有很多关于该算法的信息，因此，我将仅讨论在&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;静态评估函数中&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用的两种主要启发式方法，这些启发式方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将其他人在这里表达的许多直觉形式化。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e8fae6a7d3630d681d8de0ed1a7709b1c53526c" translate="yes" xml:space="preserve">
          <source>Smoothness</source>
          <target state="translated">Smoothness</target>
        </trans-unit>
        <trans-unit id="54e739c3c9f2519ccb923360ccad36f552ea579c" translate="yes" xml:space="preserve">
          <source>So it will press right, then right again, then (right or top depending on where the 4 has created) then will proceed to complete the chain until it gets:</source>
          <target state="translated">因此,它将按右,然后再按右,然后(右或顶部根据4创建的地方),然后将继续完成链,直到它得到。</target>
        </trans-unit>
        <trans-unit id="5257bddfe2fa589fbea354e939d68bfb692b503b" translate="yes" xml:space="preserve">
          <source>So now the model and chain are back to:</source>
          <target state="translated">所以现在模式和链条又回到了。</target>
        </trans-unit>
        <trans-unit id="d7078edb0dd35daa33a7253a4d53d2a945faccd6" translate="yes" xml:space="preserve">
          <source>Source code can be found here: &lt;a href=&quot;https://github.com/popovitsj/2048-haskell&quot;&gt;https://github.com/popovitsj/2048-haskell&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以在这里找到源代码：&lt;/font&gt;&lt;a href=&quot;https://github.com/popovitsj/2048-haskell&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//github.com/popovitsj/2048-haskell&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5347810276aac1267928f350b554c90eab90a356" translate="yes" xml:space="preserve">
          <source>Surprisingly, increasing the number of runs does not drastically improve the game play. There seems to be a limit to this strategy at around 80000 points with the 4096 tile and all the smaller ones, very close to the achieving the 8192 tile. Increasing the number of runs from 100 to 100000 increases the &lt;strong&gt;odds&lt;/strong&gt; of getting to this score limit (from 5% to 40%) but not breaking through it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;令人惊讶的是，增加运行次数并不能大大改善游戏玩法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于4096个图块和所有较小的图块，此策略似乎在80000点附近存在限制，非常接近实现8192个图块。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将跑步次数从100增加到100000，增加了&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;达到此分数限制（从5％到40％）但没有突破&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;几率&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d074ffd075253a11df5ddc58441a0bc90e0b8963" translate="yes" xml:space="preserve">
          <source>T1 - 121 tests - 8 different paths - r=0.125</source>
          <target state="translated">T1-121项测试-8条不同路径-r=0.125</target>
        </trans-unit>
        <trans-unit id="dc6bff919d7f07511beebccbf002e3261f59cb65" translate="yes" xml:space="preserve">
          <source>T2 - 122 tests - 8-different paths - r=0.25</source>
          <target state="translated">T2-122次测试-8种不同路径-r=0.25</target>
        </trans-unit>
        <trans-unit id="296be33c2b9427ee450731728dde4547f54e382a" translate="yes" xml:space="preserve">
          <source>T3 - 132 tests - 8-different paths - r=0.5</source>
          <target state="translated">T3-132次测试-8个不同路径-r=0.5</target>
        </trans-unit>
        <trans-unit id="cc1b12f4c9d96129539fb80e7cdef31ccdf979f5" translate="yes" xml:space="preserve">
          <source>T4 - 211 tests - 2-different paths - r=0.125</source>
          <target state="translated">T4-211测试--------2-不同路径-----r=0.125</target>
        </trans-unit>
        <trans-unit id="e14691f69c083c98b5cb57561d0905750d23ecc3" translate="yes" xml:space="preserve">
          <source>T5 - 274 tests - 2-different paths - r=0.25</source>
          <target state="translated">T5-274项测试------2-不同路径-----r=0.25</target>
        </trans-unit>
        <trans-unit id="c4e6556dc89bf3c2350cf0f2df946297023854c7" translate="yes" xml:space="preserve">
          <source>T6 - 211 tests - 2-different paths - r=0.5</source>
          <target state="translated">T6-211测试--------2-不同路径-----r=0.5</target>
        </trans-unit>
        <trans-unit id="0c7d1cbd690845a24654fefbd0a09ba800d4230d" translate="yes" xml:space="preserve">
          <source>That the AI achieves the 32768 tile in over a third of its games is a huge milestone; I will be surprised to hear if any human players have achieved 32768 on the official game (i.e. without using tools like savestates or undo). I think the 65536 tile is within reach!</source>
          <target state="translated">人工智能在超过三分之一的游戏中达到32768瓦,这是一个巨大的里程碑;如果有人类玩家在官方游戏中达到了32768瓦,我会很惊讶(也就是说,没有使用savestates或撤消等工具)。我想65536的瓦片是指日可待的!</target>
        </trans-unit>
        <trans-unit id="89cc096445275d0b61d3321d2f66e3dd178f9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O&lt;/code&gt; represent forbidden spaces...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代表禁止的空间...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c7dde9a3e75b8eeff3662608ec5b45fcb967f49" translate="yes" xml:space="preserve">
          <source>The AI in its default configuration (max search depth of 8) takes anywhere from 10ms to 200ms to execute a move, depending on the complexity of the board position. In testing, the AI achieves an average move rate of 5-10 moves per second over the course of an entire game. If the search depth is limited to 6 moves, the AI can easily execute 20+ moves per second, which makes for some &lt;a href=&quot;https://www.youtube.com/watch?v=96ab_dK6JM0&quot;&gt;interesting watching&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI的默认配置（最大搜索深度为8）从10ms到200ms的任何时间执行一次移动，具体取决于电路板位置的复杂程度。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在测试中，人工智能在整个游戏过程中的平均移动速率为每秒5-10次移动。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果将搜索深度限制为6个动作，则AI可以轻松地每秒执行20个以上的动作，这使您可以进行一些&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=96ab_dK6JM0&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有趣的观看&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fb5e1a1c14a7f3f4df0734b1b830faeee1bc279" translate="yes" xml:space="preserve">
          <source>The above heuristic alone tends to create structures in which adjacent tiles are decreasing in value, but of course in order to merge, adjacent tiles need to be the same value. Therefore, the smoothness heuristic just measures the value difference between neighboring tiles, trying to minimize this count.</source>
          <target state="translated">单单用上述启发式就会产生相邻瓦片价值递减的结构,当然,为了合并,相邻瓦片需要相同的价值。因此,平滑性启发式只是测量相邻瓦片之间的值差,试图将这个数值最小化。</target>
        </trans-unit>
        <trans-unit id="a1da09880219429d0cbd02709fa5c5c73d1b6f56" translate="yes" xml:space="preserve">
          <source>The algorithm is iterative deepening depth first alpha-beta search. The evaluation function tries to keep the rows and columns monotonic (either all decreasing or increasing) while minimizing the number of tiles on the grid.</source>
          <target state="translated">该算法是迭代深化深度先进行α-β搜索。评价函数试图保持行和列的单调性(全部递减或递增),同时尽量减少网格上的瓦片数。</target>
        </trans-unit>
        <trans-unit id="1ef77e56b4c80bec7704196088642b9d80e9917f" translate="yes" xml:space="preserve">
          <source>The assumption on which my algorithm is based is rather simple: if you want to achieve higher score, the board must be kept as tidy as possible. In particular, the optimal setup is given by a linear and monotonic decreasing order of the tile values.
This intuition will give you also the upper bound for a tile value:</source>
          <target state="translated">我的算法所依据的假设相当简单:如果想获得更高的分数,就必须尽可能地保持棋盘的整齐。具体来说,最优的设置是由瓦片值的线性和单调的递减顺序给出的。这个直觉也会给你一个瓦片值的上界。</target>
        </trans-unit>
        <trans-unit id="5dce83a7a7a2e8b3f3cbaad9c10d94bf6337d55b" translate="yes" xml:space="preserve">
          <source>The best achieved score is shown here:</source>
          <target state="translated">这里显示的是最好的成绩。</target>
        </trans-unit>
        <trans-unit id="25c8ed43b28e01eb6dd519d1d9bd47b6abbd3671" translate="yes" xml:space="preserve">
          <source>The chosen corner is arbitrary, you basically never press one key (the forbidden move), and if you do, you press the contrary again and try to fix it. For future tiles the model always expects the next random tile to be a 2 and appear on the opposite side to the current model (while the first row is incomplete, on the bottom right corner, once the first row is completed, on the bottom left corner).</source>
          <target state="translated">所选的角是任意的,你基本上永远不会按一个键(禁止的动作),如果按了,就再按一次相反的键,然后再试着修复。对于未来的瓷砖,模型总是期望下一个随机瓷砖是2,并出现在当前模型的反面(当第一排未完成时,在右下角,一旦第一排完成后,在左下角)。</target>
        </trans-unit>
        <trans-unit id="0d9103915dc08d03b8b554e741a0a622c2563f55" translate="yes" xml:space="preserve">
          <source>The code can be found on GiHub at the following link: &lt;a href=&quot;https://github.com/Nicola17/term2048-AI&quot;&gt;https://github.com/Nicola17/term2048-AI&lt;/a&gt;
It is based on &lt;a href=&quot;https://github.com/bfontaine/term2048&quot;&gt;term2048&lt;/a&gt; and it's written in Python. I will implement a more efficient version in C++ as soon as possible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以在以下链接的GiHub上找到该代码：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/Nicola17/term2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//github.com/Nicola17/term2048-AI&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 它基于&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/bfontaine/term2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;term2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并用Python编写。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我将尽快在C ++中实现一个更有效的版本。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30eb0aa61e89069340123d96861286e1d3a860a8" translate="yes" xml:space="preserve">
          <source>The controller uses expectimax search with a state evaluation function learned from scratch (without human 2048 expertise) by a variant of &lt;strong&gt;temporal difference learning&lt;/strong&gt; (a reinforcement learning technique). The state-value  function uses an &lt;strong&gt;n-tuple network&lt;/strong&gt;, which is basically a weighted linear function of patterns observed on the board. It involved more than &lt;strong&gt;1 billion weights&lt;/strong&gt;, in total.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;控制器使用带有状态评估功能的Expectimax搜索功能，该功能通过&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;临时差异学习&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（一种强化学习技术）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从零开始学习（无需2048位专家&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;状态值函数使用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n元组网络&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，该&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;网络&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基本上是板上观察到的图案的加权线性函数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总共&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;涉及超过&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10亿个重量&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e8ea22403f787ccc54f78cea6ca391603d91a87" translate="yes" xml:space="preserve">
          <source>The decision rule implemented is not quite smart, the code in Python is presented here:</source>
          <target state="translated">决策规则的实现不是很聪明,这里用Python的代码介绍一下。</target>
        </trans-unit>
        <trans-unit id="176b0272d8eef889ba807dbf653b453ecd6067de" translate="yes" xml:space="preserve">
          <source>The effect of these changes are extremely significant. The algorithm went from achieving the 16384 tile around 13% of the time to achieving it over 90% of the time, and the algorithm began to achieve 32768 over 1/3 of the time (whereas the old heuristics never once produced a 32768 tile).</source>
          <target state="translated">这些变化的效果是非常显著的。算法从13%左右的时间内实现16384的瓦片,到90%以上的时间内实现,算法开始实现32768的时间超过13个(而旧的启发式算法从未产生过一次32768的瓦片)。</target>
        </trans-unit>
        <trans-unit id="283d1c0d9684c8a42130b57edb6f6b92f5b86665" translate="yes" xml:space="preserve">
          <source>The expectimax search itself is coded as a recursive search which alternates between &quot;expectation&quot; steps (testing all possible tile spawn locations and values, and weighting their optimized scores by the probability of each possibility), and &quot;maximization&quot; steps (testing all possible moves and selecting the one with the best score). The tree search terminates when it sees a previously-seen position (using a &lt;a href=&quot;http://en.wikipedia.org/wiki/Transposition_table&quot;&gt;transposition table&lt;/a&gt;), when it reaches a predefined depth limit, or when it reaches a board state that is highly unlikely (e.g. it was reached by getting 6 &quot;4&quot; tiles in a row from the starting position). The typical search depth is 4-8 moves.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Expectimax搜索本身被编码为递归搜索，它在&amp;ldquo;期望&amp;rdquo;步骤（测试所有可能的瓦片生成位置和值，并通过每种可能性的概率加权其优化得分）和&amp;ldquo;最大化&amp;rdquo;步骤（测试所有可能的移动）之间交替并选择得分最高的那个）。当树搜索看到先前看到的位置（使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Transposition_table&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转置表&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），达到预定义的深度限制或达到极不可能的板状态（例如通过获取6个&amp;ldquo; 4&amp;rdquo;图块达到的状态）时，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;树搜索终止&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从起始位置连续）。典型的搜索深度是4-8步。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42f64f93fcb62fe61d13a7081dbd1385a6c16372" translate="yes" xml:space="preserve">
          <source>The following animation shows the last few steps of the game played where the AI player agent could get 2048 scores, this time adding the absolute value heuristic too:</source>
          <target state="translated">下面的动画显示了游戏的最后几步玩法,AI玩家代理可以获得2048分的地方,这一次也加入了绝对值启发式的绝对值。</target>
        </trans-unit>
        <trans-unit id="83682c685d59111d019249a4364f16870be09cd8" translate="yes" xml:space="preserve">
          <source>The following figures show the &lt;strong&gt;game tree&lt;/strong&gt; explored by the player AI agent assuming the computer as adversary for just a single step:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下图显示了&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;玩家AI代理探索&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;游戏树&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，假设计算机只是一个步骤，它就是对手：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94d73024e25245de94e9edbd3aad5a30776360ec" translate="yes" xml:space="preserve">
          <source>The minimum score over all runs was 124024; the maximum score achieved was 794076. The median score is 387222. The AI never failed to obtain the 2048 tile (so it never lost the game even once in 100 games); in fact, it achieved the &lt;strong&gt;8192&lt;/strong&gt; tile at least once in every run!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最低分数为124024；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AI的最高得分是794076。中位数是387222。AI从未失败过获得2048个图块（因此，即使每100场游戏中有一次它也不会输掉游戏）；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在每次运行中至少&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;获得了&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;8192个磁&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;贴！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c3427688b31e68bb54900072b17104508262705" translate="yes" xml:space="preserve">
          <source>The model has changed due to the luck of being closer to the expected model. The model the AI is trying to achieve is</source>
          <target state="translated">由于运气好,更接近于预期的模型,所以模型发生了变化。人工智能所要实现的模型是</target>
        </trans-unit>
        <trans-unit id="1cdcb607ac22bbd92fb5b1889cdd98d3eecdba0a" translate="yes" xml:space="preserve">
          <source>The scores of the boards are computed with the weighted sum of the square of the number of free tiles and the dot product of the 2D grid with this:</source>
          <target state="translated">板子的分数是用自由瓷砖的平方数和二维网格的点积的加权和与此计算的。</target>
        </trans-unit>
        <trans-unit id="ac8ac475f1d47ab38014e0ffd71fab5a7ebbc40c" translate="yes" xml:space="preserve">
          <source>The solution I propose is very simple and easy to implement. Although, it has reached the score of 131040. Several benchmarks of the algorithm performances are presented.</source>
          <target state="translated">我提出的方案很简单,也很容易实现。虽然,它已经达到了131040分。提出了几种算法性能的基准。</target>
        </trans-unit>
        <trans-unit id="cd5ada7eeaffca19f06bbf8ec2f5ee7d8e800c9d" translate="yes" xml:space="preserve">
          <source>The tile statistics for 10 moves/s are as follows:</source>
          <target state="translated">10次搬家的瓦片统计如下。</target>
        </trans-unit>
        <trans-unit id="0dcd0aa110a697c4c67a6487fafa9f7c0823aa9f" translate="yes" xml:space="preserve">
          <source>The whole approach will likely be more complicated than this but not much more complicated. It could be this mechanical in feel lacking scores, weights, neurones and deep searches of possibilities. The tree of possibilities rairly even needs to be big enough to need any branching at all.</source>
          <target state="translated">整个方法很可能会比这更复杂,但也不会太复杂。它可能是这种机械在感觉上缺乏分数、权重、神经元和深层搜索的可能性。可能性的树Rirly甚至需要足够大,根本不需要任何分支。</target>
        </trans-unit>
        <trans-unit id="6d4d3599a34b6269908c672524220c522c3745c8" translate="yes" xml:space="preserve">
          <source>There is already an AI implementation for this game &lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;here&lt;/a&gt;. Excerpt from README:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;已经有一个AI实现这个游戏&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自述摘录：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50c76a9fd12162abedcd5b1269d96e3a48779a24" translate="yes" xml:space="preserve">
          <source>There is also a discussion on &lt;a href=&quot;https://news.ycombinator.com/item?id=7379821&quot;&gt;Hacker News&lt;/a&gt; about this algorithm that you may find useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=7379821&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hacker News上也&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关于此算法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的讨论&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您可能会发现它很有用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e3943b324acda39f3164ad45d89f210e302e253" translate="yes" xml:space="preserve">
          <source>This algorithm is not optimal for winning the game, but it is fairly optimal in terms of performance and amount of code needed:</source>
          <target state="translated">这种算法并不是最佳的赢家,但从性能和所需的代码量来看,这种算法是相当理想的。</target>
        </trans-unit>
        <trans-unit id="81716cb6c61fa929b1da024c98b8e777682d352a" translate="yes" xml:space="preserve">
          <source>This board representation, along with the table lookup approach for movement and scoring, allows the AI to search a huge number of game states in a short period of time (over 10,000,000 game states per second on one core of my mid-2011 laptop).</source>
          <target state="translated">这种棋盘的表现形式,再加上移动和计分的表格查询方式,使得人工智能可以在短时间内搜索到大量的游戏状态(在我2011年中的笔记本电脑的一个核心上,每秒超过1万个游戏状态)。</target>
        </trans-unit>
        <trans-unit id="aab4a4bfd97ffe5030c2d295efd283014f0be653" translate="yes" xml:space="preserve">
          <source>This game took 27830 moves over 96 minutes, or an average of 4.8 moves per second.</source>
          <target state="translated">这场比赛用时278330分钟,即平均每秒4.8步。</target>
        </trans-unit>
        <trans-unit id="1df55517328accd0f2dc6eb5550bd150b52fbce7" translate="yes" xml:space="preserve">
          <source>This graph illustrates this point: The blue line shows the board score after each move. The red line shows the algorithm's &lt;strong&gt;best&lt;/strong&gt; random-run end game score from that position. In essence, the red values are &quot;pulling&quot; the blue values upwards towards them, as they are the algorithm's best guess. It's interesting to see the red line is just a tiny bit above the blue line at each point, yet the blue line continues to increase more and more.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该图说明了这一点：蓝线表示每次移动后的棋盘得分。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;红线显示&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从该位置开始&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最佳&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;随机运行结束游戏得分。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本质上，红色值是将蓝色值向上&amp;ldquo;拉&amp;rdquo;向它们，因为它们是算法的最佳猜测。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有趣的是，红线在每个点上都仅比蓝线高一点，但是蓝线仍在不断增加。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="15d9cef8b96ce070fccbc886d3f7a52230dd95c2" translate="yes" xml:space="preserve">
          <source>This heuristic tries to ensure that the values of the tiles are all either increasing or decreasing along both the left/right and up/down directions. This heuristic alone captures the intuition that many others have mentioned, that higher valued tiles should be clustered in a corner. It will typically prevent smaller valued tiles from getting orphaned and will keep the board very organized, with smaller tiles cascading in and filling up into the larger tiles.</source>
          <target state="translated">这个启发式试图确保瓦片的值都是沿左下和右上方向增加或减少。仅仅这个启发式就抓住了许多其他人提到的直觉,即价值较高的瓷砖应该集中在一个角落里。这通常可以防止价值较小的瓦片被遗弃,并且可以使棋盘非常有条理,较小的瓦片层层叠加,填入较大的瓦片中。</target>
        </trans-unit>
        <trans-unit id="f4404e8828677c74cccfa38f4bbfe1ae3bcfe6a7" translate="yes" xml:space="preserve">
          <source>This is a constant, used as a base-line and for other uses like testing.</source>
          <target state="translated">这是一个常数,用作基线,也用于其他用途,如测试。</target>
        </trans-unit>
        <trans-unit id="406c95c020f4c2dd5ee8b09f0713c82e19af3169" translate="yes" xml:space="preserve">
          <source>This is a simplified check of the possibility of having merges within that state, without making a look-ahead.</source>
          <target state="translated">这是对该状态内有无合并的可能性的简化检查,不做瞻前顾后。</target>
        </trans-unit>
        <trans-unit id="8131c0f0b0c2602cf4850dc23b1938260a7a7a9f" translate="yes" xml:space="preserve">
          <source>This is not a direct answer to OP's question, this is more of the stuffs (experiments) I tried so far to solve the same problem and obtained some results and have some observations that I want to share, I am curious if we can have some further insights from this.</source>
          <target state="translated">这不是直接回答OP的问题,这更多的是我到目前为止尝试解决同样问题的东西(实验),得到了一些结果,也有一些观察,想和大家分享一下,我很好奇,能否从中得到一些进一步的启示。</target>
        </trans-unit>
        <trans-unit id="715df725c34a80cfb15f7cc31927abca202e48fb" translate="yes" xml:space="preserve">
          <source>This is possible due to domain-independent nature of the AI. Some of the variants are quite distinct, such as the Hexagonal clone.</source>
          <target state="translated">这可能是由于人工智能的域无关性所致。有些变体是相当明显的,比如六边形克隆。</target>
        </trans-unit>
        <trans-unit id="2b8637dd6b7d75e139a375a20969b654b1c6a3f0" translate="yes" xml:space="preserve">
          <source>This is the model I chose by default.</source>
          <target state="translated">这是我默认选择的模式。</target>
        </trans-unit>
        <trans-unit id="2dae92fa8773f5d81d34a41b5ee59edb28a87186" translate="yes" xml:space="preserve">
          <source>Tile needs merging with neighbour but is too small: Merge another neighbour with this one.</source>
          <target state="translated">瓷砖需要与邻居合并,但面积太小:将另一个邻居与这个邻居合并。</target>
        </trans-unit>
        <trans-unit id="70b105f3079699e06f3a1ca29fc49029280f2f09" translate="yes" xml:space="preserve">
          <source>To assess the score performance of the AI, I ran the AI 100 times (connected to the browser game via remote control). For each tile, here are the proportions of games in which that tile was achieved at least once:</source>
          <target state="translated">为了评估AI的得分性能,我运行了100次(通过遥控器连接到浏览器游戏)。对于每一个瓦片,这里是该瓦片至少达到一次的游戏比例。</target>
        </trans-unit>
        <trans-unit id="562dbd4dd3fb3dd997d921a85e8dd207938296af" translate="yes" xml:space="preserve">
          <source>To enforce the ordination of the tiles in a monotonic decreasing order, the score si computed as the sum of the linearized values on the board multiplied by the values of a geometric sequence with common ratio r&amp;lt;1 .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了以单调递减的顺序执行图块的排序，将分数si计算为板上线性化值的总和乘以公共比率r &amp;lt;1的几何序列的值。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1880862a60075224c2b8fdd3389edd49e7283e3" translate="yes" xml:space="preserve">
          <source>To resolve this problem, their are 2 ways to move that aren't left or worse up and examining both possibilities may immediately reveal more problems, this forms a list of dependancies, each problem requiring another problem to be solved first. I think I have this chain or in some cases tree of dependancies internally when deciding my next move, particularly when stuck.</source>
          <target state="translated">为了解决这个问题,他们有2种移动的方式,不是左上右下,就是更糟糕的向上,考察这两种可能性,可能马上就会发现更多的问题,这就形成了一个依赖性的列表,每一个问题都需要先解决另一个问题。我认为我在决定下一步的行动时,尤其是在卡住的时候,我认为我有这个链子,或者说在某些情况下,内部的依赖性树。</target>
        </trans-unit>
        <trans-unit id="ab12b80b60d258a6dfc62b5818e8f4e339ef4aca" translate="yes" xml:space="preserve">
          <source>Two possible ways of organizing the board are shown in the following images:</source>
          <target state="translated">板书的两种可能的组织方式如下图所示。</target>
        </trans-unit>
        <trans-unit id="ffc914498a4f81efe7ad50334ca89a25026fc42b" translate="yes" xml:space="preserve">
          <source>What I am doing is at any point, I will try to merge the tiles with values &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;, that is, I try to have &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; tiles, as minimum as possible. If I try it this way, all other tiles were automatically getting merged and the strategy seems good.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我正在做的是在任何时候，我都将尝试合并值&lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的图块&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，也就是说，我尝试将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;图块尽量减少。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果以这种方式尝试，所有其他磁贴将自动合并，并且该策略看起来不错。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0fe3580da7385572383dcfbcbfc67535e4972c3" translate="yes" xml:space="preserve">
          <source>What is the optimal algorithm for the game 2048</source>
          <target state="translated">2048游戏的最佳算法是什么?</target>
        </trans-unit>
        <trans-unit id="7a2cd96c88d22411489171dc415feea04edc93dc" translate="yes" xml:space="preserve">
          <source>When it manages to reach the 128 it gains a whole row is gained again:</source>
          <target state="translated">当它管理到128时,它又获得了一整行的收益。</target>
        </trans-unit>
        <trans-unit id="6cc2b46a0e2f9ee01b185acf82165706e2b0b69b" translate="yes" xml:space="preserve">
          <source>With just 100 runs (i.e in memory games) per move, the AI achieves the 2048 tile 80% of the times and the 4096 tile 50% of the times. Using 10000 runs gets the 2048 tile 100%, 70% for 4096 tile, and about 1% for the 8192 tile.</source>
          <target state="translated">每一步棋只需要100次运行(即在内存游戏中),AI就能达到2048张牌的80%,4096张牌的50%。使用10000次运行可以获得2048张牌的100%,4096张牌的70%,8192张牌的1%左右。</target>
        </trans-unit>
        <trans-unit id="c3d1302c4890b9aa4694541642695d87a0b4b7ed" translate="yes" xml:space="preserve">
          <source>Yes, that's a 4096 alongside a 2048. =) That means it achieved the elusive 2048 tile three times on the same board.</source>
          <target state="translated">是的,那是4096和2048旁边的4096。)这意味着,它在同一块板子上实现了三次难以捉摸的2048瓦。</target>
        </trans-unit>
        <trans-unit id="b44092dddcd4f744019f7228202fb6783f53c989" translate="yes" xml:space="preserve">
          <source>You can try the AI for yourself. The code is available at &lt;a href=&quot;https://github.com/nneonneo/2048-ai&quot;&gt;https://github.com/nneonneo/2048-ai&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以自己尝试AI。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该代码可从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/nneonneo/2048-ai&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/nneonneo/2048-ai获得&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59ac2882d7af09f5c4e2a1c7e5c5bb0dcad83a76" translate="yes" xml:space="preserve">
          <source>code below or on &lt;a href=&quot;https://caub.github.io/misc/2048&quot;&gt;github&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下面或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://caub.github.io/misc/2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;github&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上的代码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e9b496a0935b15e72709835275b0a4dd4c2a1c6" translate="yes" xml:space="preserve">
          <source>etc...</source>
          <target state="translated">etc...</target>
        </trans-unit>
        <trans-unit id="d8bd5af9109e98c522a44467b14c0ac230bbc8ca" translate="yes" xml:space="preserve">
          <source>where n is the number of tile on the board.</source>
          <target state="translated">其中n为棋盘上的瓷砖数量。</target>
        </trans-unit>
        <trans-unit id="f550c4f98092fb346941c9ffac4b20ee0d6c58a1" translate="yes" xml:space="preserve">
          <source>which forces to organize tiles descendingly in a sort of snake from the top left tile.</source>
          <target state="translated">这迫使组织瓷砖从左上方的瓷砖,以一种蛇形的方式依次递减。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
