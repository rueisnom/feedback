<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/22342854">
    <body>
      <group id="22342854">
        <trans-unit id="f7c8748664ce768e7e3182c81b903ff85a7320c5" translate="yes" xml:space="preserve">
          <source>(The last line means having the given tiles at the same time on the board).</source>
          <target state="translated">(La última línea significa tener las fichas dadas al mismo tiempo en el tablero).</target>
        </trans-unit>
        <trans-unit id="42dcce363a0691ffc8b52eaa155b22573fd9214f" translate="yes" xml:space="preserve">
          <source>(There's a possibility to reach the 131072 tile if the 4-tile is randomly generated instead of the 2-tile when needed)</source>
          <target state="translated">(Existe la posibilidad de alcanzar el azulejo 131072 si el azulejo 4 se genera al azar en lugar del azulejo 2 cuando sea necesario)</target>
        </trans-unit>
        <trans-unit id="1b25f3cc01e7eaded5356820fc12a8514181d56e" translate="yes" xml:space="preserve">
          <source>2048 Variants and Clones</source>
          <target state="translated">2048 Variantes y clones</target>
        </trans-unit>
        <trans-unit id="88a139cf0ed644e82e3541f84922caa249ed18ea" translate="yes" xml:space="preserve">
          <source>42000</source>
          <target state="translated">42000</target>
        </trans-unit>
        <trans-unit id="355a0cd8af03872d9ce2928c8cb3da7c2fb6cd2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Edit:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Edit:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08f52696de29f7f7ec6dc0a8a919df2a38e9ebaf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The constants can be tweaked..&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nota: Las constantes se pueden ajustar.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8634e4a85ec9ad0d2495ed0458b0ec8c578e8935" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Algorithm&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45ea392fe0c3da367d8c51717f364d940fe4fe60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decision rule&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Regla de decisi&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de42b3c305942617c48ca008230c0d5ed84ee53c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; This is a naive algorithm, modelling human conscious thought process, and gets very weak results compared to AI that search all possibilities since it only looks one tile ahead. It was submitted early in the response timeline.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;EDITAR:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; este es un algoritmo ingenuo, que modela el proceso de pensamiento consciente humano, y obtiene resultados muy d&amp;eacute;biles en comparaci&amp;oacute;n con la IA que busca todas las posibilidades, ya que solo mira un mosaico por delante. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Fue presentado temprano en la l&amp;iacute;nea de tiempo de respuesta.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b40ea2169b1372cb4d66f254c44144da5482dc88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Evaluation Details&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Detalles de evaluaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b321d0995c10030e9430af46a596a61260d1dad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Evaluation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Evaluation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fbce973333197ec3e114cf37edcb6ff4502f6e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heuristic scoring algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo de puntuaci&amp;oacute;n heur&amp;iacute;stica&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef6c3ec99e2445b2f8e789385112f8add04aca2a" translate="yes" xml:space="preserve">
          <source>A commenter on Hacker News gave &lt;a href=&quot;https://news.ycombinator.com/item?id=7381082&quot;&gt;an interesting formalization&lt;/a&gt; of this idea in terms of graph theory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un comentarista en Hacker News dio &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=7381082&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;una interesante formalizaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de esta idea en t&amp;eacute;rminos de teor&amp;iacute;a de grafos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0fc8abe55206bcc6fee5b9655148f68e7d675bb" translate="yes" xml:space="preserve">
          <source>A few pointers on the missing steps. Here:</source>
          <target state="translated">Algunos consejos sobre los pasos que faltan.Aquí:</target>
        </trans-unit>
        <trans-unit id="ccab3659df4d866e5c99429991c48026db374125" translate="yes" xml:space="preserve">
          <source>A state is more flexible if it has more freedom of possible transitions.</source>
          <target state="translated">Un estado es más flexible si tiene más libertad para las posibles transiciones.</target>
        </trans-unit>
        <trans-unit id="884e259396760240aa757f365184412ce12cb6ac" translate="yes" xml:space="preserve">
          <source>AI Algorithm</source>
          <target state="translated">Algoritmo de IA</target>
        </trans-unit>
        <trans-unit id="93e084b33c7ba167fbfbc4319e9d4f49b5668176" translate="yes" xml:space="preserve">
          <source>After implementing this algorithm I tried many improvements including using the min or max scores, or a combination of min,max,and avg. I also tried using depth: Instead of trying K runs per move, I tried K moves per move &lt;em&gt;list&lt;/em&gt; of a given length (&quot;up,up,left&quot; for example) and selecting the first move of the best scoring move list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Despu&amp;eacute;s de implementar este algoritmo prob&amp;eacute; muchas mejoras, incluido el uso de las puntuaciones m&amp;iacute;nimas o m&amp;aacute;ximas, o una combinaci&amp;oacute;n de m&amp;iacute;n., M&amp;aacute;x. Y prom. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n intent&amp;eacute; usar la profundidad: en lugar de intentar K carreras por movimiento, prob&amp;eacute; K movimientos por &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lista&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;movimientos &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;de una longitud determinada (&quot;arriba, arriba, izquierda&quot;, por ejemplo) y seleccion&amp;eacute; el primer movimiento de la lista de movimientos con mejor puntuaci&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ede32df5eb0c24212c925595dd08fa4665c5adef" translate="yes" xml:space="preserve">
          <source>Also, I tried to increase the search depth cut-off from 3 to 5 (I can't increase it more since searching that space exceeds allowed time even with pruning) and added one more heuristic that looks at the values of adjacent tiles and gives more points if they are merge-able, but still I am not able to get 2048.</source>
          <target state="translated">También intenté aumentar el límite de profundidad de búsqueda de 3 a 5 (no puedo aumentarlo más ya que la búsqueda de ese espacio excede el tiempo permitido incluso con la poda)y añadí una heurística más que mira los valores de los azulejos adyacentes y da más puntos si son fusionables,pero aún así no puedo obtener 2048.</target>
        </trans-unit>
        <trans-unit id="a52d36040473cfee0c3dda94c4922ec62a49256f" translate="yes" xml:space="preserve">
          <source>An implementation of the minmax or the Expectiminimax will surely improve the algorithm. Obviously a more
sophisticated decision rule will slow down the algorithm and it will require some time to be implemented.I will try a minimax implementation in the near future. (stay tuned)</source>
          <target state="translated">Una implementación de la minmax o la Expectiminimax seguramente mejorará el algoritmo.Obviamente una regla de decisión más sofisticada ralentizará el algoritmo y requerirá algún tiempo para ser implementada.Intentaré una implementación del minmax en un futuro próximo.(manténgase en sintonía)</target>
        </trans-unit>
        <trans-unit id="81a3b22b9764c6db541f97a5b0cf0bc8185c33b4" translate="yes" xml:space="preserve">
          <source>An interesting fact about this algorithm is that while the random-play games are unsurprisingly quite bad, choosing the best (or least bad) move leads to very good game play: A typical AI game can reach 70000 points and last 3000 moves, yet the in-memory random play games from any given position yield an average of 340 additional points in about 40 extra moves before dying. (You can see this for yourself by running the AI and opening the debug console.)</source>
          <target state="translated">Un hecho interesante de este algoritmo es que,aunque los juegos de azar son,como es lógico,bastante malos,la elección del mejor (o menos malo)movimiento conduce a un juego muy bueno:Un típico juego de IA puede alcanzar los 70000 puntos y durar 3000 movimientos,sin embargo los juegos aleatorios en memoria desde cualquier posición dan un promedio de 340 puntos adicionales en unos 40 movimientos extra antes de morir.(Puedes ver esto por ti mismo ejecutando la IA y abriendo la consola de depuración).</target>
        </trans-unit>
        <trans-unit id="e9d2a26295c1d0085ec67a73a147f26c2d1f037d" translate="yes" xml:space="preserve">
          <source>And finally, there is a penalty for having too few free tiles, since options can quickly run out when the game board gets too cramped.</source>
          <target state="translated">Y por último,hay una penalización por tener pocas fichas libres,ya que las opciones se pueden agotar rápidamente cuando el tablero de juego se vuelve demasiado estrecho.</target>
        </trans-unit>
        <trans-unit id="fdf944fcd7b6a6e2a2ddfb040b0978330ad9950a" translate="yes" xml:space="preserve">
          <source>And that's it! Searching through the game space while optimizing these criteria yields remarkably good performance. One advantage to using a generalized approach like this rather than an explicitly coded move strategy is that the algorithm can often find interesting and unexpected solutions. If you watch it run, it will often make surprising but effective moves, like suddenly switching which wall or corner it's building up against.</source>
          <target state="translated">¡Y eso es todo! Buscar en el espacio del juego mientras se optimizan estos criterios produce un rendimiento notablemente bueno.Una ventaja de usar un enfoque generalizado como este en lugar de una estrategia de movimiento explícitamente codificada es que el algoritmo puede encontrar a menudo soluciones interesantes e inesperadas.Si lo ves correr,a menudo hará movimientos sorprendentes pero efectivos,como cambiar repentinamente contra qué pared o esquina se está construyendo.</target>
        </trans-unit>
        <trans-unit id="38ffd01cfffffe720859de9ba280dc3a2fa18ebe" translate="yes" xml:space="preserve">
          <source>And the chain to get there has become:</source>
          <target state="translated">Y la cadena para llegar allí se ha convertido:</target>
        </trans-unit>
        <trans-unit id="f168395e34c5d5a79b07cf3ea9c0184c6cfec5d9" translate="yes" xml:space="preserve">
          <source>Any insights will be really very helpful, thanks in advance. (This is the link of my blog post for the article: &lt;a href=&quot;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&quot;&gt;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&lt;/a&gt; and the youtube video: &lt;a href=&quot;https://www.youtube.com/watch?v=VnVFilfZ0r4&quot;&gt;https://www.youtube.com/watch?v=VnVFilfZ0r4&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cualquier idea ser&amp;aacute; realmente muy &amp;uacute;til, gracias de antemano. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Este es el enlace de mi entrada de blog para el art&amp;iacute;culo: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve -2048-game-with-computer /&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y el video de youtube: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=VnVFilfZ0r4&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.youtube.com/watch?v=VnVFilfZ0r4&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccd9e8b01034b267d29c5745b84208f0a085f623" translate="yes" xml:space="preserve">
          <source>As a consequence, this solver is deterministic.</source>
          <target state="translated">Como consecuencia,este solucionador es determinista.</target>
        </trans-unit>
        <trans-unit id="9a7ad671d6cde8daae45c935046a605bf403cdad" translate="yes" xml:space="preserve">
          <source>At 1 moves/s: &lt;strong&gt;609104&lt;/strong&gt; (100 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A 1 movimientos / s: &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;609104&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (promedio de 100 juegos)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e5d64f1e0b61c1ef3e52e0d5823d5921bc21a50" translate="yes" xml:space="preserve">
          <source>At 10 moves/s: &lt;strong&gt;589355&lt;/strong&gt; (300 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A 10 movimientos / s: &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;589355&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (promedio de 300 juegos)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3c0d6ea43007ca3c28efb394b96f8a3287fcd1" translate="yes" xml:space="preserve">
          <source>At 3-ply (ca. 1500 moves/s): &lt;strong&gt;511759&lt;/strong&gt; (1000 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A 3 capas (ca. 1500 movimientos / s): &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;511759&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (promedio de 1000 juegos)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e93088674333bdf43b53fdb34644dc1838dfbd19" translate="yes" xml:space="preserve">
          <source>Below animation shows the last few steps of the game played by the AI agent with the computer player:</source>
          <target state="translated">La siguiente animación muestra los últimos pasos del juego jugado por el agente de la IA con el jugador de la computadora:</target>
        </trans-unit>
        <trans-unit id="6c12051095dc9a9f3c8c9322ba72366123f527e4" translate="yes" xml:space="preserve">
          <source>Below is the code implementing the solving algorithm. The grid is represented as a 16-length array of Integers. And scoring is done simply by counting the number of empty squares.</source>
          <target state="translated">A continuación se muestra el código que implementa el algoritmo de resolución.La cuadrícula se representa como un conjunto de 16 longitudes de números enteros.Y la puntuación se hace simplemente contando el número de cuadrados vacíos.</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="85a8f1bded86a0cdaa694a12d8a5a7691488a18a" translate="yes" xml:space="preserve">
          <source>Bit shift operations are used to extract individual rows and columns. A single row or column is a 16-bit quantity, so a table of size 65536 can encode transformations which operate on a single row or column. For example, moves are implemented as 4 lookups into a precomputed &quot;move effect table&quot; which describes how each move affects a single row or column (for example, the &quot;move right&quot; table contains the entry &quot;1122 -&amp;gt; 0023&quot; describing how the row [2,2,4,4] becomes the row [0,0,4,8] when moved to the right).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las operaciones de desplazamiento de bits se utilizan para extraer filas y columnas individuales. Una sola fila o columna es una cantidad de 16 bits, por lo que una tabla de tama&amp;ntilde;o 65536 puede codificar transformaciones que operan en una sola fila o columna. Por ejemplo, los movimientos se implementan como 4 b&amp;uacute;squedas en una &quot;tabla de efectos de movimiento&quot; calculada previamente que describe c&amp;oacute;mo cada movimiento afecta a una sola fila o columna (por ejemplo, la tabla &quot;mover a la derecha&quot; contiene la entrada &quot;1122 -&amp;gt; 0023&quot; que describe c&amp;oacute;mo fila [2,2,4,4] se convierte en la fila [0,0,4,8] cuando se mueve hacia la derecha).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c42c80d6b77bd2a349eaa2543cf5ddc744fe92ff" translate="yes" xml:space="preserve">
          <source>But, when I actually use this algorithm, I only get around 4000 points before the game terminates. Maximum points AFAIK is slightly more than 20,000 points which is way larger than my current score. Is there a better algorithm than the above?</source>
          <target state="translated">Pero cuando uso este algoritmo,sólo consigo unos 4000 puntos antes de que termine el juego.El máximo de puntos AFAIK es ligeramente superior a 20.000 puntos,lo que es mucho mayor que mi puntuación actual.¿Hay algún algoritmo mejor que el anterior?</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="d5026d402b84438a420117883e0b28d724275f57" translate="yes" xml:space="preserve">
          <source>Currently, the program achieves about a 90% win rate running in javascript in the browser on my laptop given about 100 milliseconds of thinking time per move, so while not perfect (yet!) it performs pretty well.</source>
          <target state="translated">Actualmente,el programa alcanza una tasa de ganancia del 90% corriendo en javascript en el navegador de mi portátil dados unos 100 milisegundos de tiempo de pensamiento por movimiento,así que aunque no es perfecto (¡todavía!)funciona bastante bien.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="6c38d1c09dfbb8d9afb27b450f505d02e699af0a" translate="yes" xml:space="preserve">
          <source>First I created a JavaScript version which can be &lt;a href=&quot;http://ronzil.github.io/2048-AI/&quot;&gt;seen in action here&lt;/a&gt;. This version can run 100's of runs in decent time. Open the console for extra info. 
(&lt;a href=&quot;https://github.com/ronzil/2048-AI&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Primero cre&amp;eacute; una versi&amp;oacute;n de JavaScript que se puede &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ronzil.github.io/2048-AI/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ver en acci&amp;oacute;n aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta versi&amp;oacute;n puede ejecutar cientos de ejecuciones en tiempo decente. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Abre la consola para obtener informaci&amp;oacute;n adicional. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ronzil/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;fuente&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb6608935b3258a93b48bed3d51f17ee42bad070" translate="yes" xml:space="preserve">
          <source>For 3-ply:</source>
          <target state="translated">Para las tres capas:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="afd41cc839be699428bd0fa94a187d2888e8230c" translate="yes" xml:space="preserve">
          <source>Free Space Available</source>
          <target state="translated">Espacio libre disponible</target>
        </trans-unit>
        <trans-unit id="f00400337de66f8cbfda3eb6257d6edb7ab4d834" translate="yes" xml:space="preserve">
          <source>Free Tiles</source>
          <target state="translated">Azulejos gratis</target>
        </trans-unit>
        <trans-unit id="05c3afb6f1373b0671a788c523440a2cdb7b67cf" translate="yes" xml:space="preserve">
          <source>Furthermore, Petr also optimized the heuristic weights using a &quot;meta-optimization&quot; strategy (using an algorithm called &lt;a href=&quot;https://en.wikipedia.org/wiki/CMA-ES&quot;&gt;CMA-ES&lt;/a&gt;), where the weights themselves were adjusted to obtain the highest possible average score.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adem&amp;aacute;s, Petr tambi&amp;eacute;n optimiz&amp;oacute; los pesos heur&amp;iacute;sticos usando una estrategia de &quot;metaoptimizaci&amp;oacute;n&quot; (usando un algoritmo llamado &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/CMA-ES&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CMA-ES&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), donde los pesos mismos se ajustaron para obtener el puntaje promedio m&amp;aacute;s alto posible.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a006d33e016b3552046744f9daab00e3a9dea82" translate="yes" xml:space="preserve">
          <source>Here goes the algorithm. Around 80% wins (it seems it is always possible to win with more &quot;professional&quot; AI techniques, I am not sure about this, though.)</source>
          <target state="translated">Aquí va el algoritmo.Alrededor del 80% gana (parece que siempre es posible ganar con técnicas de IA más &quot;profesionales&quot;,aunque no estoy seguro de esto.)</target>
        </trans-unit>
        <trans-unit id="9fde7d59da7d0da4eb4e909565d46f8fa0c4121d" translate="yes" xml:space="preserve">
          <source>Here the model and chain is:</source>
          <target state="translated">Aquí está el modelo y la cadena:</target>
        </trans-unit>
        <trans-unit id="7f9a58f740830a3a6e0ce355d41b93414963aa63" translate="yes" xml:space="preserve">
          <source>Here we evaluate faces that have the possibility to getting to merge, by evaluating them backwardly, tile 2 become of value 2048, while tile 2048 is evaluated 2.</source>
          <target state="translated">Aquí evaluamos las caras que tienen la posibilidad de llegar a fusionarse,al evaluarlas al revés,la baldosa 2 pasa a tener un valor de 2048,mientras que la baldosa 2048 se evalúa 2.</target>
        </trans-unit>
        <trans-unit id="ea14290a91583ca847b2ae45387c083c3b7f5174" translate="yes" xml:space="preserve">
          <source>Here's a demonstration of the power of this approach. I uncapped the tile values (so it kept going after reaching 2048) and here is the best result after eight trials.</source>
          <target state="translated">Aquí hay una demostración del poder de este enfoque.Destapé los valores de los azulejos (así que siguió adelante después de llegar a 2048)y aquí está el mejor resultado después de ocho pruebas.</target>
        </trans-unit>
        <trans-unit id="4f64374fb447322f3ae9648b3c8851f4e3a0a00f" translate="yes" xml:space="preserve">
          <source>Here's a screenshot of a perfectly monotonic grid. I obtained this by running the algorithm with the eval function set to disregard the other heuristics and only consider monotonicity.</source>
          <target state="translated">Aquí hay una captura de pantalla de una red perfectamente monótona.La obtuve ejecutando el algoritmo con la función de evaluación configurada para ignorar los otros heurísticos y sólo considerar la monotonicidad.</target>
        </trans-unit>
        <trans-unit id="f97f5d39b364919717cbfb83c95dfea658c2d11e" translate="yes" xml:space="preserve">
          <source>Here's a screenshot of a perfectly smooth grid, courtesy of &lt;a href=&quot;http://jennypeng.me/2048/&quot;&gt;this excellent parody fork&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; hay una captura de pantalla de una cuadr&amp;iacute;cula perfectamente suave, cortes&amp;iacute;a de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://jennypeng.me/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;este excelente tenedor de parodia&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b03d95f10bf2fb9649d305f295aac7854cae9194" translate="yes" xml:space="preserve">
          <source>Here's the screenshot of the best run:</source>
          <target state="translated">Aquí está la captura de pantalla de la mejor carrera:</target>
        </trans-unit>
        <trans-unit id="ffac2906be85464582876c1fd5b67e5775ca4c9b" translate="yes" xml:space="preserve">
          <source>Heuristics</source>
          <target state="translated">Heuristics</target>
        </trans-unit>
        <trans-unit id="ed8ab7ed11c60bc100175f13e827da35c53e21c1" translate="yes" xml:space="preserve">
          <source>However, I have never observed it obtaining the 65536 tile.</source>
          <target state="translated">Sin embargo,nunca lo he observado obtener el azulejo 65536.</target>
        </trans-unit>
        <trans-unit id="84fd09822e571ef59181c3b714b48c120c88bc2d" translate="yes" xml:space="preserve">
          <source>However, none of these ideas showed any real advantage over the simple first idea. I left the code for these ideas commented out in the C++ code.</source>
          <target state="translated">Sin embargo,ninguna de estas ideas mostraron ninguna ventaja real sobre la simple primera idea.Dejé el código de estas ideas comentadas en el código C++.</target>
        </trans-unit>
        <trans-unit id="5e64fedf544d393d02c17117048de608b040496d" translate="yes" xml:space="preserve">
          <source>I also tried the corner heuristic, but for some reason it makes the results worse, any intuition why?</source>
          <target state="translated">También intenté el heurístico de la esquina,pero por alguna razón empeora los resultados,¿alguna intuición por qué?</target>
        </trans-unit>
        <trans-unit id="bff61911fdd315b14809acd1b0718f81baa37d98" translate="yes" xml:space="preserve">
          <source>I am the author of a 2048 controller that scores better than any other program mentioned in this thread. An efficient implementation of the controller is available on &lt;a href=&quot;https://github.com/aszczepanski/2048&quot;&gt;github&lt;/a&gt;. In &lt;a href=&quot;https://github.com/wjaskowski/mastering-2048&quot;&gt;a separate repo&lt;/a&gt; there is also the code used for training the controller's state evaluation function. The training method is described in the &lt;a href=&quot;http://arxiv.org/abs/1604.05085&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Soy el autor de un controlador 2048 que obtiene mejores puntajes que cualquier otro programa mencionado en este hilo. Una implementaci&amp;oacute;n eficiente del controlador est&amp;aacute; disponible en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/aszczepanski/2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;github&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . En &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/wjaskowski/mastering-2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;un repositorio separado&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tambi&amp;eacute;n est&amp;aacute; el c&amp;oacute;digo utilizado para entrenar la funci&amp;oacute;n de evaluaci&amp;oacute;n de estado del controlador. El m&amp;eacute;todo de entrenamiento se describe en el &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://arxiv.org/abs/1604.05085&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;documento&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b1878005b4715ef7dadf5dbab3530f2387e3d7d" translate="yes" xml:space="preserve">
          <source>I applied convex combination (tried different heuristic weights) of couple of heuristic evaluation functions, mainly from intuition and from the ones discussed above:</source>
          <target state="translated">Apliqué una combinación convexa (intenté diferentes pesos heurísticos)de un par de funciones de evaluación heurística,principalmente a partir de la intuición y de las mencionadas anteriormente:</target>
        </trans-unit>
        <trans-unit id="b340ff0771c0044d5631169bb8b9da7b0949767e" translate="yes" xml:space="preserve">
          <source>I became interested in the idea of an AI for this game containing &lt;strong&gt;no hard-coded intelligence&lt;/strong&gt; (i.e no heuristics, scoring functions etc). The AI should &lt;em&gt;&quot;know&quot;&lt;/em&gt; only the game rules, and &lt;em&gt;&quot;figure out&quot;&lt;/em&gt; the game play. This is in contrast to most AIs (like the ones in this thread) where the game play is essentially brute force steered by a scoring function representing human understanding of the game.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Me interes&amp;oacute; la idea de una IA para este juego que &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; contenga &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;inteligencia codificada&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (es decir, no heur&amp;iacute;stica, funciones de puntuaci&amp;oacute;n, etc.). La IA debe &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;conocer&quot;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; solo las reglas del juego y &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;descubrir&quot;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; el juego. Esto contrasta con la mayor&amp;iacute;a de las IA (como las de este hilo) donde el juego es esencialmente fuerza bruta dirigida por una funci&amp;oacute;n de puntuaci&amp;oacute;n que representa la comprensi&amp;oacute;n humana del juego.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed0a579e8bb5a2fa1f190be9cc3a3984935966dd" translate="yes" xml:space="preserve">
          <source>I believe there's still room for improvement on the heuristics. This algorithm definitely isn't yet &quot;optimal&quot;, but I feel like it's getting pretty close.</source>
          <target state="translated">Creo que todavía se puede mejorar la heurística.Este algoritmo definitivamente no es aún &quot;óptimo&quot;,pero siento que se está acercando bastante.</target>
        </trans-unit>
        <trans-unit id="f8ed635115239705d2911e5bd2f5ced5edce99c5" translate="yes" xml:space="preserve">
          <source>I copy here the content of a &lt;a href=&quot;http://diaryofatinker.blogspot.it/2014/03/an-artificial-intelligence-for-2048-game.html&quot;&gt;post on my blog&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Copio aqu&amp;iacute; el contenido de una &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://diaryofatinker.blogspot.it/2014/03/an-artificial-intelligence-for-2048-game.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;publicaci&amp;oacute;n en mi blog&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d84a2a8980a497e88dd0c2f4d14dcecd79505253" translate="yes" xml:space="preserve">
          <source>I developed a 2048 AI using &lt;em&gt;expectimax&lt;/em&gt; optimization, instead of the minimax search used by @ovolve's algorithm. The AI simply performs maximization over all possible moves, followed by expectation over all possible tile spawns (weighted by the probability of the tiles, i.e. 10% for a 4 and 90% for a 2). As far as I'm aware, it is not possible to prune expectimax optimization (except to remove branches that are exceedingly unlikely), and so the algorithm used is a carefully optimized brute force search.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desarroll&amp;eacute; una IA de 2048 usando la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;optimizaci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;waitimax&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , en lugar de la b&amp;uacute;squeda de minimax utilizada por el algoritmo de @ ovolve. La IA simplemente realiza la maximizaci&amp;oacute;n sobre todos los movimientos posibles, seguida de la expectativa sobre todos los engendros de fichas posibles (ponderado por la probabilidad de las fichas, es decir, 10% para un 4 y 90% para un 2). Hasta donde yo s&amp;eacute;, no es posible podar la optimizaci&amp;oacute;n de waitimax (excepto para eliminar ramas que son extremadamente improbables), por lo que el algoritmo utilizado es una b&amp;uacute;squeda de fuerza bruta cuidadosamente optimizada.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a35fdce8c7933d0b2a937ce2170823745b56f98" translate="yes" xml:space="preserve">
          <source>I did add a &quot;Deep Search&quot; mechanism that increased the run number temporarily to 1000000 when any of the runs managed to accidentally reach the next highest tile. This offered a time improvement.</source>
          <target state="translated">Añadí un mecanismo de &quot;Búsqueda Profunda&quot; que aumentó el número de ejecuciones temporalmente a 1000000 cuando cualquiera de las ejecuciones lograba alcanzar accidentalmente el siguiente azulejo más alto.Esto ofrecía una mejora de tiempo.</target>
        </trans-unit>
        <trans-unit id="ba7f2fdb047681e855cdfd6b772b6db5b92aa4ee" translate="yes" xml:space="preserve">
          <source>I find it quite surprising that the algorithm doesn't need to actually foresee good game play in order to chose the moves that produce it.</source>
          <target state="translated">Encuentro bastante sorprendente que el algoritmo no necesite prever un buen juego para elegir los movimientos que lo producen.</target>
        </trans-unit>
        <trans-unit id="2224c20bdfc42ec2f0bd05389e5c06114237583f" translate="yes" xml:space="preserve">
          <source>I found a simple yet surprisingly good playing algorithm: To determine the next move for a given board, the AI plays the game in memory using &lt;strong&gt;random moves&lt;/strong&gt; until the game is over. This is done several times while keeping track of the end game score. Then the average end score &lt;em&gt;per starting move&lt;/em&gt; is calculated. The starting move with the highest average end score is chosen as the next move.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Encontr&amp;eacute; un algoritmo de juego simple pero sorprendentemente bueno: para determinar el pr&amp;oacute;ximo movimiento para un tablero dado, la IA juega el juego en la memoria usando &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;movimientos aleatorios&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; hasta que el juego termina. Esto se hace varias veces mientras se realiza un seguimiento de la puntuaci&amp;oacute;n final del juego. Luego se calcula el puntaje final promedio &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;por movimiento inicial&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . El movimiento inicial con el puntaje final promedio m&amp;aacute;s alto se elige como el siguiente movimiento.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="031425862c087193c510d3992030621083927b33" translate="yes" xml:space="preserve">
          <source>I have 4x4 grid for playing the game.</source>
          <target state="translated">Tengo una cuadrícula de 4x4 para jugar el juego.</target>
        </trans-unit>
        <trans-unit id="f56414c1f6736cdf7c56bfca13c15f73247b88ce" translate="yes" xml:space="preserve">
          <source>I have recently stumbled upon the game &lt;a href=&quot;http://gabrielecirulli.github.io/2048/&quot;&gt;2048&lt;/a&gt;. You merge similar tiles by moving them in any of the four directions to make &quot;bigger&quot; tiles. After each move, a new tile appears at random empty position with a value of either &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;. The game terminates when all the boxes are filled and there are no moves that can merge tiles, or you create a tile with a value of &lt;code&gt;2048&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Recientemente me top&amp;eacute; con el juego &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://gabrielecirulli.github.io/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Combinas fichas similares movi&amp;eacute;ndolas en cualquiera de las cuatro direcciones para hacer fichas &quot;m&amp;aacute;s grandes&quot;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Despu&amp;eacute;s de cada movimiento, aparece una nueva ficha en una posici&amp;oacute;n vac&amp;iacute;a aleatoria con un valor de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El juego termina cuando todas las casillas est&amp;aacute;n llenas y no hay movimientos que puedan fusionar fichas, o se crea una ficha con un valor de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2048&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59f0d82a356c65bde837828cc539c2e8be89a87d" translate="yes" xml:space="preserve">
          <source>I have refined the algorithm and beaten the game! It may fail due to simple bad luck close to the end (you are forced to move down, which you should never do, and a tile appears where your highest should be. Just try to keep the top row filled, so moving left does not break the pattern), but basically you end up having a fixed part and a mobile part to play with. This is your objective:</source>
          <target state="translated">¡He refinado el algoritmo y he vencido al juego! Puede fallar debido a la simple mala suerte cerca del final (te ves obligado a moverte hacia abajo,lo que nunca debes hacer,y aparece un azulejo donde debería estar tu más alto.Intenta mantener la fila superior llena,para que al moverte a la izquierda no se rompa el patrón),pero básicamente acabas teniendo una parte fija y una parte móvil con la que jugar.Este es tu objetivo:</target>
        </trans-unit>
        <trans-unit id="e043b4a0622bd7bd4f4bff3f75f5289152c44dc3" translate="yes" xml:space="preserve">
          <source>I just tried my minimax implementation with alpha-beta pruning with search-tree depth cutoff at 3 and 5. I was trying to solve the same problem for a 4x4 grid as a project assignment for the &lt;strong&gt;edX course ColumbiaX: CSMM.101x Artificial Intelligence (AI)&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Acabo de probar mi implementaci&amp;oacute;n de minimax con poda alfa-beta con un corte de profundidad de &amp;aacute;rbol de b&amp;uacute;squeda en 3 y 5. Estaba tratando de resolver el mismo problema para una cuadr&amp;iacute;cula 4x4 como una asignaci&amp;oacute;n de proyecto para el &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;curso edX ColumbiaX: CSMM.101x Inteligencia Artificial ( AI)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f7940b642881ad963c29c8e46d7cecbcc69643e3" translate="yes" xml:space="preserve">
          <source>I think I found an algorithm which works quite well, as I often reach scores over 10000, my personal best being around 16000. My solution does not aim at keeping biggest numbers in a corner, but to keep it in the top row.</source>
          <target state="translated">Creo que encontré un algoritmo que funciona bastante bien,ya que a menudo alcanzo puntuaciones por encima de 10000,siendo mi mejor marca personal alrededor de 16000.Mi solución no tiene como objetivo mantener los números más grandes en una esquina,sino mantenerlos en la primera fila.</target>
        </trans-unit>
        <trans-unit id="55f66ed61b2ad8167d89233045ef1fe2708fd931" translate="yes" xml:space="preserve">
          <source>I think it will be better to use Expectimax instead of minimax, but still I want to solve this problem with minimax only and obtain high scores such as 2048 or 4096. I am not sure whether I am missing anything.</source>
          <target state="translated">Creo que será mejor usar Expectimax en lugar de minimax,pero aún así quiero resolver este problema sólo con minimax y obtener puntuaciones altas como 2048 o 4096.No estoy seguro de que me falte algo.</target>
        </trans-unit>
        <trans-unit id="ea165dbbcc05f8b9c0fee4d6f269ceb0aa9da587" translate="yes" xml:space="preserve">
          <source>I thinks it's quite successful for its simplicity. The result it reaches when starting with an empty grid and solving at depth 5 is:</source>
          <target state="translated">Creo que es bastante exitoso por su simplicidad.El resultado que alcanza cuando comienza con una cuadrícula vacía y resuelve a profundidad 5 es:</target>
        </trans-unit>
        <trans-unit id="1034d585a72bb081cca29625c761242ddf856012" translate="yes" xml:space="preserve">
          <source>I used an exhaustive algorithm that favours empty tiles. It performs pretty quickly for depth 1-4, but on depth 5 it gets rather slow at a around 1 second per move.</source>
          <target state="translated">Utilicé un exhaustivo algoritmo que favorece a las baldosas vacías.Funciona bastante rápido para la profundidad 1-4,pero en la profundidad 5 se vuelve más bien lento a un segundo por movimiento.</target>
        </trans-unit>
        <trans-unit id="37173dc2be4bdb4d84b503ac96c838e5e06ad4e3" translate="yes" xml:space="preserve">
          <source>I wrote a 2048 solver in Haskell, mainly because I'm learning this language right now.</source>
          <target state="translated">Escribí un solucionador de 2048 en Haskell,principalmente porque estoy aprendiendo este idioma ahora mismo.</target>
        </trans-unit>
        <trans-unit id="46c02f631905ee5caf0b222fd7359a47400755dd" translate="yes" xml:space="preserve">
          <source>I'd be interested to hear if anyone has other improvement ideas that maintain the domain-independence of the AI.</source>
          <target state="translated">Me interesaría saber si alguien tiene otras ideas de mejora que mantengan la independencia del dominio de la IA.</target>
        </trans-unit>
        <trans-unit id="a1169010fb1d82ea350ecfb6aa43f3802bb8f9f2" translate="yes" xml:space="preserve">
          <source>I'm the author of the AI program that others have mentioned in this thread. You can view the AI in &lt;a href=&quot;http://ovolve.github.io/2048-AI/&quot;&gt;action&lt;/a&gt; or read the &lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;source&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Soy el autor del programa de IA que otros han mencionado en este hilo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede ver la IA en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ovolve.github.io/2048-AI/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;acci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o leer la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;fuente&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cff211afed3c58617e7600239f98eba6f99208de" translate="yes" xml:space="preserve">
          <source>If I assign too much weights to the first heuristic function or the second heuristic function, both the cases the scores the AI player gets are low. I played with many possible weight assignments to the heuristic functions and take a convex combination, but very rarely the AI player is able to score 2048. Most of the times it either stops at 1024 or 512.</source>
          <target state="translated">Si asigno demasiados pesos a la primera función heurística o a la segunda,en ambos casos las puntuaciones que obtiene el jugador de la IA son bajas.Jugué con muchas posibles asignaciones de peso a las funciones heurísticas y tomé una combinación convexa,pero muy raramente el jugador de la IA es capaz de anotar 2048.La mayoría de las veces se detiene en 1024 o 512.</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3ed4d38edf88c96646888aef4c5aee857217b77c" translate="yes" xml:space="preserve">
          <source>Implementation and Links</source>
          <target state="translated">Aplicación y enlaces</target>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="dae216ce28189a3dc03880a06f90efd300da2352" translate="yes" xml:space="preserve">
          <source>In case of T2, four tests in ten generate the 4096 tile with an average score of</source>
          <target state="translated">En el caso del T2,cuatro pruebas de cada diez generan el azulejo 4096 con una puntuación media de</target>
        </trans-unit>
        <trans-unit id="06f4f3fea3016100595f36b33ff12f794776a418" translate="yes" xml:space="preserve">
          <source>In here we still need to check for stacked values, but in a lesser way that doesn't interrupt the flexibility parameters, so we have the sum of { x in [4,44] }.</source>
          <target state="translated">Aquí todavía tenemos que comprobar los valores apilados,pero de una manera menor que no interrumpe los parámetros de flexibilidad,por lo que tenemos la suma de{x en [4,44]}.</target>
        </trans-unit>
        <trans-unit id="3c2636cc71bb825cadfd8c456577a98d04fe05b8" translate="yes" xml:space="preserve">
          <source>In my case, the computer player is completely random, but still i assumed adversarial settings and implemented the AI player agent as the max player.</source>
          <target state="translated">En mi caso,el reproductor de la computadora es completamente aleatorio,pero aún así asumí los ajustes de adversario e implementé el agente reproductor de la IA como el reproductor máximo.</target>
        </trans-unit>
        <trans-unit id="23652927c0d25e443786d2f509c213988410f12c" translate="yes" xml:space="preserve">
          <source>Initially, I used two very simple heuristics, granting &quot;bonuses&quot; for open squares and for having large values on the edge. These heuristics performed pretty well, frequently achieving 16384 but never getting to 32768.</source>
          <target state="translated">Inicialmente,usé dos heurísticas muy simples,concediendo &quot;bonificaciones&quot; por los cuadrados abiertos y por tener grandes valores en el borde.Estos heurísticos funcionaron bastante bien,frecuentemente alcanzando 16384 pero nunca llegando a 32768.</target>
        </trans-unit>
        <trans-unit id="1545ea420f5c65b9c9bba94c946b329fa8251dc3" translate="yes" xml:space="preserve">
          <source>Just for fun, I've also &lt;a href=&quot;http://ronzil.github.io/2048AI-AllClones/&quot;&gt;implemented the AI as a bookmarklet&lt;/a&gt;, hooking into the game's controls. This allows the AI to work with the original game and &lt;strong&gt;many of its variants&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Solo por diversi&amp;oacute;n, tambi&amp;eacute;n &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ronzil.github.io/2048AI-AllClones/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;implement&amp;eacute; la IA como un marcador&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , enganch&amp;aacute;ndome a los controles del juego. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto permite que la IA funcione con el juego original y &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;muchas de sus variantes&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="87ab7e933f551b05ada40bfa9c63b7d3a98505ae" translate="yes" xml:space="preserve">
          <source>Larger tile in the way: Increase the value of a smaller surrounding tile.</source>
          <target state="translated">Un azulejo más grande en el camino:Aumentar el valor de un azulejo más pequeño que lo rodea.</target>
        </trans-unit>
        <trans-unit id="18be8c8127f21459189b5caf81e55e1002781278" translate="yes" xml:space="preserve">
          <source>Later I implemented a scoring tree that took into account the conditional probability of being able to play a move after a given move list.</source>
          <target state="translated">Más tarde implementé un árbol de puntuación que tenía en cuenta la probabilidad condicional de poder jugar una jugada después de una lista de movimientos dada.</target>
        </trans-unit>
        <trans-unit id="5d40de2c184332bb133e3c7b3f9b7106a46f6318" translate="yes" xml:space="preserve">
          <source>Later, in order to play around some more I used @nneonneo highly optimized infrastructure and implemented my version in C++. This version allows for up to 100000 runs per move and even 1000000 if you have the patience. Building instructions provided. It runs in the console and also has a remote-control to play the web version.
(&lt;a href=&quot;https://github.com/ronzil/2048-ai-cpp&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;M&amp;aacute;s tarde, para jugar un poco m&amp;aacute;s, utilic&amp;eacute; la infraestructura altamente optimizada de @nneonneo e implement&amp;eacute; mi versi&amp;oacute;n en C ++. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta versi&amp;oacute;n permite hasta 100000 carreras por movimiento e incluso 1000000 si tienes paciencia. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Instrucciones de construcci&amp;oacute;n proporcionadas. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se ejecuta en la consola y tambi&amp;eacute;n tiene un control remoto para reproducir la versi&amp;oacute;n web. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ronzil/2048-ai-cpp&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;fuente&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="44c2d6ea8314c3f98974d2ba1a58dd051bb32c6f" translate="yes" xml:space="preserve">
          <source>Many of the other answers use AI with computationally expensive searching of possible futures, heuristics, learning and the such. These are impressive and probably the correct way forward, but I wish to contribute another idea.</source>
          <target state="translated">Muchas de las otras respuestas utilizan la IA con una búsqueda computacional costosa de posibles futuros,heurística,aprendizaje y cosas así.Estos son impresionantes y probablemente el camino correcto a seguir,pero deseo contribuir con otra idea.</target>
        </trans-unit>
        <trans-unit id="2b46f31c24d9d078dc34aed0d4067c4f769ba53f" translate="yes" xml:space="preserve">
          <source>Model the sort of strategy that good players of the game use.</source>
          <target state="translated">Modelar el tipo de estrategia que usan los buenos jugadores del juego.</target>
        </trans-unit>
        <trans-unit id="fd4c07fb20d7d76fbcadaea8ea7ddaaac986f8c7" translate="yes" xml:space="preserve">
          <source>Monotonicity</source>
          <target state="translated">Monotonicity</target>
        </trans-unit>
        <trans-unit id="44fc3fc0ab34b52134a7cd76d9bbcb14829e6e00" translate="yes" xml:space="preserve">
          <source>More spaces makes the state more flexible, we multiply by 128 (which is the median) since a grid filled with 128 faces is an optimal impossible state.</source>
          <target state="translated">Más espacios hace que el estado sea más flexible,multiplicamos por 128 (que es la mediana)ya que una cuadrícula llena de 128 caras es un estado óptimo imposible.</target>
        </trans-unit>
        <trans-unit id="1f62f4a60f5f356eabae5d8f3cb887dce903adda" translate="yes" xml:space="preserve">
          <source>My approach encodes the entire board (16 entries) as a single 64-bit integer (where tiles are the nybbles, i.e. 4-bit chunks). On a 64-bit machine, this enables the entire board to be passed around in a single machine register.</source>
          <target state="translated">Mi enfoque codifica todo el tablero (16 entradas)como un único entero de 64 bits (donde los azulejos son los nibbles,es decir,trozos de 4 bits).En una máquina de 64 bits,esto permite que todo el tablero se pase en un solo registro de máquina.</target>
        </trans-unit>
        <trans-unit id="ef5c72f488757b3c3972bc8a4c545658ae48db02" translate="yes" xml:space="preserve">
          <source>My attempt uses expectimax like other solutions above, but without bitboards. Nneonneo's solution can check 10millions of moves which is approximately a depth of 4 with 6 tiles left and 4 moves possible (2*6*4)&lt;sup&gt;4&lt;/sup&gt;. In my case, this depth takes too long to explore, I adjust the depth of expectimax search according to the number of free tiles left:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mi intento usa expectimax como otras soluciones anteriores, pero sin bitboards. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La soluci&amp;oacute;n de Nneonneo puede controlar 10 millones de movimientos, que es aproximadamente una profundidad de 4 con 6 fichas restantes y 4 movimientos posibles (2 * 6 * 4) &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En mi caso, esta profundidad toma demasiado tiempo para explorarla, ajusto la profundidad de la b&amp;uacute;squeda expectimax de acuerdo con el n&amp;uacute;mero de mosaicos libres restantes:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="57e8410bf6b4571c6670e5f2ee8f617e934c4d80" translate="yes" xml:space="preserve">
          <source>My current algorithm:</source>
          <target state="translated">Mi algoritmo actual:</target>
        </trans-unit>
        <trans-unit id="bea5caec78afaf43f0643aa15a7e4f0a707e1354" translate="yes" xml:space="preserve">
          <source>My implementation of the game slightly differs from the actual game, in that a new tile is always a '2' (rather than 90% 2 and 10% 4). And that the new tile is not random, but always the first available one from the top left. This variant is also known as &lt;a href=&quot;https://jmfork.github.io/2048/&quot;&gt;Det 2048&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mi implementaci&amp;oacute;n del juego difiere ligeramente del juego real, ya que un nuevo mosaico siempre es un '2' (en lugar de 90% 2 y 10% 4). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y que el nuevo mosaico no es aleatorio, sino siempre el primero disponible desde la parte superior izquierda. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta variante tambi&amp;eacute;n se conoce como &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://jmfork.github.io/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Det 2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d18c870dbfd8a43034e5e38c25648f6a00c617cb" translate="yes" xml:space="preserve">
          <source>Observation:</source>
          <target state="translated">Observation:</target>
        </trans-unit>
        <trans-unit id="1d445de243f043f2a68c63600c349cf26b114c50" translate="yes" xml:space="preserve">
          <source>One, I need to follow a well-defined strategy to reach the goal. So, I thought of writing a program for it.</source>
          <target state="translated">Uno,necesito seguir una estrategia bien definida para alcanzar la meta.Así que pensé en escribir un programa para ello.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="640af8b8b4a6b17289c61d8f064089730a066c2e" translate="yes" xml:space="preserve">
          <source>Petr Mor&amp;aacute;vek (@xificurk) took my AI and added two new heuristics. The first heuristic was a penalty for having non-monotonic rows and columns which increased as the ranks increased, ensuring that  non-monotonic rows of small numbers would not strongly affect the score, but non-monotonic rows of large numbers hurt the score substantially. The second heuristic counted the number of potential merges (adjacent equal values) in addition to open spaces. These two heuristics served to push the algorithm towards monotonic boards (which are easier to merge), and towards board positions with lots of merges (encouraging it to align merges where possible for greater effect).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Petr Mor&amp;aacute;vek (@xificurk) tom&amp;oacute; mi IA y agreg&amp;oacute; dos nuevas heur&amp;iacute;sticas. La primera heur&amp;iacute;stica fue una penalizaci&amp;oacute;n por tener filas y columnas no mon&amp;oacute;tonas que aumentaron a medida que aumentaban los rangos, asegurando que las filas no mon&amp;oacute;tonas de n&amp;uacute;meros peque&amp;ntilde;os no afectar&amp;iacute;an fuertemente el puntaje, pero las filas no mon&amp;oacute;tonas de n&amp;uacute;meros grandes da&amp;ntilde;an sustancialmente el puntaje. La segunda heur&amp;iacute;stica cont&amp;oacute; el n&amp;uacute;mero de posibles fusiones (valores iguales adyacentes) adem&amp;aacute;s de los espacios abiertos. Estas dos heur&amp;iacute;sticas sirvieron para empujar el algoritmo hacia tableros monot&amp;oacute;nicos (que son m&amp;aacute;s f&amp;aacute;ciles de fusionar) y hacia posiciones de tablero con muchas fusiones (alent&amp;aacute;ndolo a alinear fusiones donde sea posible para un mayor efecto).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="503f6e600737ff2f29cf68701e034324b5731a1b" translate="yes" xml:space="preserve">
          <source>Please see the code below:</source>
          <target state="translated">Por favor,vea el código de abajo:</target>
        </trans-unit>
        <trans-unit id="6df2f58f408bc47f5e66563bfde9ff0172588105" translate="yes" xml:space="preserve">
          <source>Read the squares in the order shown above until the next squares value is greater than the current one. This presents the problem of trying to merge another tile of the same value into this square.</source>
          <target state="translated">Lee los cuadrados en el orden mostrado arriba hasta que el siguiente valor de los cuadrados sea mayor que el actual.Esto presenta el problema de tratar de fusionar otro azulejo del mismo valor en este cuadrado.</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="33bfd3ccf12da33384e54b78f3b1b416cd79f5ee" translate="yes" xml:space="preserve">
          <source>Running 10000 runs with a temporary increase to 1000000 near critical positions managed to break this barrier less than 1% of the times achieving a max score of 129892 and the 8192 tile.</source>
          <target state="translated">Corriendo 10.000 carreras con un aumento temporal a 10.000 cerca de las posiciones críticas lograron romper esta barrera menos del 1% de las veces logrando un puntaje máximo de 129892 y el azulejo 8192.</target>
        </trans-unit>
        <trans-unit id="f53aad58499a66a812ae2a8fadd0d52bc3c90c03" translate="yes" xml:space="preserve">
          <source>Scoring is also done using table lookup. The tables contain heuristic scores computed on all possible rows/columns, and the resultant score for a board is simply the sum of the table values across each row and column.</source>
          <target state="translated">La puntuación también se realiza mediante la búsqueda en la tabla.Las tablas contienen puntuaciones heurísticas calculadas en todas las filas y columnas posibles,y la puntuación resultante para una tabla es simplemente la suma de los valores de la tabla en cada fila y columna.</target>
        </trans-unit>
        <trans-unit id="6f0d0289231f49f701b9b200b4a3eac54cedef68" translate="yes" xml:space="preserve">
          <source>Searching later I found this algorithm might be classified as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Monte-Carlo_tree_search#Pure_Monte_Carlo_game_search&quot;&gt;Pure Monte Carlo Tree Search&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Al buscar m&amp;aacute;s tarde, encontr&amp;eacute; que este algoritmo podr&amp;iacute;a clasificarse como un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;algoritmo de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Monte-Carlo_tree_search#Pure_Monte_Carlo_game_search&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;b&amp;uacute;squeda de &amp;aacute;rbol Pure Monte Carlo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c6dc8c149cc76d5efe765ba938462b2a01c9d89" translate="yes" xml:space="preserve">
          <source>Second pointer, it has had bad luck and its main spot has been taken. It is likely that it will fail, but it can still achieve it:</source>
          <target state="translated">El segundo puntero,ha tenido mala suerte y su lugar principal ha sido ocupado.Es probable que falle,pero aún puede lograrlo:</target>
        </trans-unit>
        <trans-unit id="f7bd04bc23d0d8eee5b56955d487fc2585d2855f" translate="yes" xml:space="preserve">
          <source>See it in action</source>
          <target state="translated">Véalo en acción</target>
        </trans-unit>
        <trans-unit id="b6e3041754015cf5ce95b9217697dd1eafce96ab" translate="yes" xml:space="preserve">
          <source>Several heuristics are used to direct the optimization algorithm towards favorable positions. The precise choice of heuristic has a huge effect on the performance of the algorithm. The various heuristics are weighted and combined into a positional score, which determines how &quot;good&quot; a given board position is. The optimization search will then aim to maximize the average score of all possible board positions. The actual score, as shown by the game, is &lt;em&gt;not&lt;/em&gt; used to calculate the board score, since it is too heavily weighted in favor of merging tiles (when delayed merging could produce a large benefit).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se utilizan varias heur&amp;iacute;sticas para dirigir el algoritmo de optimizaci&amp;oacute;n hacia posiciones favorables. La elecci&amp;oacute;n precisa de heur&amp;iacute;stica tiene un gran efecto en el rendimiento del algoritmo. Las diversas heur&amp;iacute;sticas se ponderan y se combinan en una puntuaci&amp;oacute;n posicional, que determina cu&amp;aacute;n &quot;buena&quot; es una posici&amp;oacute;n de tablero determinada. La b&amp;uacute;squeda de optimizaci&amp;oacute;n tendr&amp;aacute; como objetivo maximizar el puntaje promedio de todas las posibles posiciones en el tablero. La puntuaci&amp;oacute;n real, como se muestra en el juego, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no se&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; utiliza para calcular la puntuaci&amp;oacute;n del tablero, ya que est&amp;aacute; demasiado ponderada a favor de fusionar fichas (cuando la fusi&amp;oacute;n demorada podr&amp;iacute;a producir un gran beneficio).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2318e6fc587a3fb272235edad6036fe0432bc136" translate="yes" xml:space="preserve">
          <source>Several linear path could be evaluated at once, the final score will be the maximum score of any path.</source>
          <target state="translated">Se podrían evaluar varios caminos lineales a la vez,la puntuación final será la máxima puntuación de cualquier camino.</target>
        </trans-unit>
        <trans-unit id="c72dd283f25dc910b0a759e6f55e51f7b00e7039" translate="yes" xml:space="preserve">
          <source>Since the game is a discrete state space, perfect information, turn-based game like chess and checkers, I used the same methods that have been proven to work on those games, namely &lt;a href=&quot;http://www.flyingmachinestudios.com/programming/minimax/&quot;&gt;minimax&lt;/a&gt;&lt;a href=&quot;http://xkcd.com/832/&quot;&gt;search&lt;/a&gt; with &lt;a href=&quot;http://cs.ucla.edu/~rosen/161/notes/alphabeta.html&quot;&gt;alpha-beta pruning&lt;/a&gt;. Since there is already a lot of info on that algorithm out there, I'll just talk about the two main heuristics that I use in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_function&quot;&gt;static evaluation function&lt;/a&gt; and which formalize many of the intuitions that other people have expressed here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dado que el juego es un espacio de estado discreto, informaci&amp;oacute;n perfecta, juego por turnos como el ajedrez y las damas, utilic&amp;eacute; los mismos m&amp;eacute;todos que han demostrado que funcionan en esos juegos, a saber, la &lt;/font&gt;&lt;a href=&quot;http://xkcd.com/832/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;b&amp;uacute;squeda &lt;/font&gt;&lt;/a&gt;&lt;/font&gt;&lt;a href=&quot;http://www.flyingmachinestudios.com/programming/minimax/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;minimax&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con &lt;/font&gt;&lt;a href=&quot;http://cs.ucla.edu/~rosen/161/notes/alphabeta.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;poda alfa-beta&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como ya hay mucha informaci&amp;oacute;n sobre ese algoritmo, hablar&amp;eacute; sobre las dos heur&amp;iacute;sticas principales que uso en la &lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n de evaluaci&amp;oacute;n est&amp;aacute;tica&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y que formalizan muchas de las intuiciones que otras personas han expresado aqu&amp;iacute;.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e8fae6a7d3630d681d8de0ed1a7709b1c53526c" translate="yes" xml:space="preserve">
          <source>Smoothness</source>
          <target state="translated">Smoothness</target>
        </trans-unit>
        <trans-unit id="54e739c3c9f2519ccb923360ccad36f552ea579c" translate="yes" xml:space="preserve">
          <source>So it will press right, then right again, then (right or top depending on where the 4 has created) then will proceed to complete the chain until it gets:</source>
          <target state="translated">Así que presionará a la derecha,luego a la derecha de nuevo,y luego (a la derecha o arriba dependiendo de donde se haya creado el 4)entonces procederá a completar la cadena hasta que llegue:</target>
        </trans-unit>
        <trans-unit id="5257bddfe2fa589fbea354e939d68bfb692b503b" translate="yes" xml:space="preserve">
          <source>So now the model and chain are back to:</source>
          <target state="translated">Así que ahora el modelo y la cadena han vuelto a:</target>
        </trans-unit>
        <trans-unit id="d7078edb0dd35daa33a7253a4d53d2a945faccd6" translate="yes" xml:space="preserve">
          <source>Source code can be found here: &lt;a href=&quot;https://github.com/popovitsj/2048-haskell&quot;&gt;https://github.com/popovitsj/2048-haskell&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El c&amp;oacute;digo fuente se puede encontrar aqu&amp;iacute;: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/popovitsj/2048-haskell&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/popovitsj/2048-haskell&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5347810276aac1267928f350b554c90eab90a356" translate="yes" xml:space="preserve">
          <source>Surprisingly, increasing the number of runs does not drastically improve the game play. There seems to be a limit to this strategy at around 80000 points with the 4096 tile and all the smaller ones, very close to the achieving the 8192 tile. Increasing the number of runs from 100 to 100000 increases the &lt;strong&gt;odds&lt;/strong&gt; of getting to this score limit (from 5% to 40%) but not breaking through it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sorprendentemente, aumentar el n&amp;uacute;mero de carreras no mejora dr&amp;aacute;sticamente el juego. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Parece que hay un l&amp;iacute;mite para esta estrategia en alrededor de 80000 puntos con el mosaico 4096 y todos los m&amp;aacute;s peque&amp;ntilde;os, muy cerca del logro del mosaico 8192. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aumentar el n&amp;uacute;mero de carreras de 100 a 100000 aumenta las &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;probabilidades&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de llegar a este l&amp;iacute;mite de puntuaci&amp;oacute;n (del 5% al ​​40%) pero no romperlo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d074ffd075253a11df5ddc58441a0bc90e0b8963" translate="yes" xml:space="preserve">
          <source>T1 - 121 tests - 8 different paths - r=0.125</source>
          <target state="translated">T1-121 pruebas-8 caminos diferentes-r=0.125</target>
        </trans-unit>
        <trans-unit id="dc6bff919d7f07511beebccbf002e3261f59cb65" translate="yes" xml:space="preserve">
          <source>T2 - 122 tests - 8-different paths - r=0.25</source>
          <target state="translated">T2-122 pruebas-8 caminos diferentes-r=0.25</target>
        </trans-unit>
        <trans-unit id="296be33c2b9427ee450731728dde4547f54e382a" translate="yes" xml:space="preserve">
          <source>T3 - 132 tests - 8-different paths - r=0.5</source>
          <target state="translated">T3-132 pruebas-8 caminos diferentes-r=0.5</target>
        </trans-unit>
        <trans-unit id="cc1b12f4c9d96129539fb80e7cdef31ccdf979f5" translate="yes" xml:space="preserve">
          <source>T4 - 211 tests - 2-different paths - r=0.125</source>
          <target state="translated">T4-211 pruebas-2 caminos diferentes-r=0.125</target>
        </trans-unit>
        <trans-unit id="e14691f69c083c98b5cb57561d0905750d23ecc3" translate="yes" xml:space="preserve">
          <source>T5 - 274 tests - 2-different paths - r=0.25</source>
          <target state="translated">T5-274 pruebas-2 caminos diferentes-r=0,25</target>
        </trans-unit>
        <trans-unit id="c4e6556dc89bf3c2350cf0f2df946297023854c7" translate="yes" xml:space="preserve">
          <source>T6 - 211 tests - 2-different paths - r=0.5</source>
          <target state="translated">T6-211 pruebas-2 caminos diferentes-r=0.5</target>
        </trans-unit>
        <trans-unit id="0c7d1cbd690845a24654fefbd0a09ba800d4230d" translate="yes" xml:space="preserve">
          <source>That the AI achieves the 32768 tile in over a third of its games is a huge milestone; I will be surprised to hear if any human players have achieved 32768 on the official game (i.e. without using tools like savestates or undo). I think the 65536 tile is within reach!</source>
          <target state="translated">El hecho de que la IA consiga el azulejo 32768 en más de un tercio de sus juegos es un gran hito;me sorprendería saber si algún jugador humano ha conseguido 32768 en el juego oficial (es decir,sin usar herramientas como &quot;savestates&quot; o &quot;undo&quot;).Creo que el azulejo 65536 está al alcance de la mano!</target>
        </trans-unit>
        <trans-unit id="89cc096445275d0b61d3321d2f66e3dd178f9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O&lt;/code&gt; represent forbidden spaces...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; representan espacios prohibidos ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c7dde9a3e75b8eeff3662608ec5b45fcb967f49" translate="yes" xml:space="preserve">
          <source>The AI in its default configuration (max search depth of 8) takes anywhere from 10ms to 200ms to execute a move, depending on the complexity of the board position. In testing, the AI achieves an average move rate of 5-10 moves per second over the course of an entire game. If the search depth is limited to 6 moves, the AI can easily execute 20+ moves per second, which makes for some &lt;a href=&quot;https://www.youtube.com/watch?v=96ab_dK6JM0&quot;&gt;interesting watching&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La IA en su configuraci&amp;oacute;n predeterminada (profundidad de b&amp;uacute;squeda m&amp;aacute;xima de 8) tarda entre 10 ms y 200 ms para ejecutar un movimiento, dependiendo de la complejidad de la posici&amp;oacute;n del tablero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En las pruebas, la IA logra una velocidad de movimiento promedio de 5-10 movimientos por segundo en el transcurso de un juego completo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si la profundidad de b&amp;uacute;squeda se limita a 6 movimientos, la IA puede ejecutar f&amp;aacute;cilmente m&amp;aacute;s de 20 movimientos por segundo, lo que lo convierte en una &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=96ab_dK6JM0&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;observaci&amp;oacute;n interesante&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fb5e1a1c14a7f3f4df0734b1b830faeee1bc279" translate="yes" xml:space="preserve">
          <source>The above heuristic alone tends to create structures in which adjacent tiles are decreasing in value, but of course in order to merge, adjacent tiles need to be the same value. Therefore, the smoothness heuristic just measures the value difference between neighboring tiles, trying to minimize this count.</source>
          <target state="translated">La heurística anterior por sí sola tiende a crear estructuras en las que los azulejos adyacentes están disminuyendo de valor,pero por supuesto para fusionarse,los azulejos adyacentes deben tener el mismo valor.Por lo tanto,la heurística de la suavidad sólo mide la diferencia de valor entre las baldosas vecinas,tratando de minimizar este conteo.</target>
        </trans-unit>
        <trans-unit id="a1da09880219429d0cbd02709fa5c5c73d1b6f56" translate="yes" xml:space="preserve">
          <source>The algorithm is iterative deepening depth first alpha-beta search. The evaluation function tries to keep the rows and columns monotonic (either all decreasing or increasing) while minimizing the number of tiles on the grid.</source>
          <target state="translated">El algoritmo es la primera búsqueda alfa-beta de profundidad iterativa.La función de evaluación trata de mantener las filas y columnas monótonas (ya sea que todas disminuyan o aumenten)mientras se minimiza el número de fichas en la cuadrícula.</target>
        </trans-unit>
        <trans-unit id="1ef77e56b4c80bec7704196088642b9d80e9917f" translate="yes" xml:space="preserve">
          <source>The assumption on which my algorithm is based is rather simple: if you want to achieve higher score, the board must be kept as tidy as possible. In particular, the optimal setup is given by a linear and monotonic decreasing order of the tile values.
This intuition will give you also the upper bound for a tile value:</source>
          <target state="translated">El supuesto en el que se basa mi algoritmo es bastante simple:si se quiere conseguir una puntuación más alta,el tablero debe mantenerse lo más ordenado posible.En particular,la configuración óptima viene dada por un orden decreciente lineal y monótono de los valores de los azulejos.Esta intuición te dará también el límite superior para un valor de azulejo:</target>
        </trans-unit>
        <trans-unit id="5dce83a7a7a2e8b3f3cbaad9c10d94bf6337d55b" translate="yes" xml:space="preserve">
          <source>The best achieved score is shown here:</source>
          <target state="translated">La mejor puntuación obtenida se muestra aquí:</target>
        </trans-unit>
        <trans-unit id="25c8ed43b28e01eb6dd519d1d9bd47b6abbd3671" translate="yes" xml:space="preserve">
          <source>The chosen corner is arbitrary, you basically never press one key (the forbidden move), and if you do, you press the contrary again and try to fix it. For future tiles the model always expects the next random tile to be a 2 and appear on the opposite side to the current model (while the first row is incomplete, on the bottom right corner, once the first row is completed, on the bottom left corner).</source>
          <target state="translated">La esquina elegida es arbitraria,básicamente no se pulsa una tecla (el movimiento prohibido),y si lo hace,se vuelve a pulsar lo contrario y se intenta arreglarlo.Para los futuros azulejos el modelo siempre espera que el siguiente azulejo aleatorio sea un 2 y aparezca en el lado opuesto al modelo actual (mientras que la primera fila está incompleta,en la esquina inferior derecha,una vez completada la primera fila,en la esquina inferior izquierda).</target>
        </trans-unit>
        <trans-unit id="0d9103915dc08d03b8b554e741a0a622c2563f55" translate="yes" xml:space="preserve">
          <source>The code can be found on GiHub at the following link: &lt;a href=&quot;https://github.com/Nicola17/term2048-AI&quot;&gt;https://github.com/Nicola17/term2048-AI&lt;/a&gt;
It is based on &lt;a href=&quot;https://github.com/bfontaine/term2048&quot;&gt;term2048&lt;/a&gt; and it's written in Python. I will implement a more efficient version in C++ as soon as possible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El c&amp;oacute;digo se puede encontrar en GiHub en el siguiente enlace: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/Nicola17/term2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/Nicola17/term2048-AI&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Est&amp;aacute; basado en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/bfontaine/term2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;term2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y est&amp;aacute; escrito en Python. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Implementar&amp;eacute; una versi&amp;oacute;n m&amp;aacute;s eficiente en C ++ lo antes posible.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30eb0aa61e89069340123d96861286e1d3a860a8" translate="yes" xml:space="preserve">
          <source>The controller uses expectimax search with a state evaluation function learned from scratch (without human 2048 expertise) by a variant of &lt;strong&gt;temporal difference learning&lt;/strong&gt; (a reinforcement learning technique). The state-value  function uses an &lt;strong&gt;n-tuple network&lt;/strong&gt;, which is basically a weighted linear function of patterns observed on the board. It involved more than &lt;strong&gt;1 billion weights&lt;/strong&gt;, in total.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El controlador utiliza la b&amp;uacute;squeda expectimax con una funci&amp;oacute;n de evaluaci&amp;oacute;n de estado aprendida desde cero (sin experiencia humana en 2048) mediante una variante de &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aprendizaje de diferencia temporal&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (una t&amp;eacute;cnica de aprendizaje de refuerzo). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La funci&amp;oacute;n de valor de estado usa una &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;red n-tupla&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , que es b&amp;aacute;sicamente una funci&amp;oacute;n lineal ponderada de patrones observados en el tablero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Implic&amp;oacute; m&amp;aacute;s de &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mil millones de pesos&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , en total.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e8ea22403f787ccc54f78cea6ca391603d91a87" translate="yes" xml:space="preserve">
          <source>The decision rule implemented is not quite smart, the code in Python is presented here:</source>
          <target state="translated">La regla de decisión implementada no es muy inteligente,el código en Python se presenta aquí:</target>
        </trans-unit>
        <trans-unit id="176b0272d8eef889ba807dbf653b453ecd6067de" translate="yes" xml:space="preserve">
          <source>The effect of these changes are extremely significant. The algorithm went from achieving the 16384 tile around 13% of the time to achieving it over 90% of the time, and the algorithm began to achieve 32768 over 1/3 of the time (whereas the old heuristics never once produced a 32768 tile).</source>
          <target state="translated">El efecto de estos cambios es extremadamente significativo.El algoritmo pasó de lograr el azulejo de 16384 alrededor del 13% de las veces a lograrlo en más del 90% de las veces,y el algoritmo comenzó a lograr 32768 en 13 de las veces (mientras que la antigua heurística nunca produjo ni una sola vez un azulejo de 32768).</target>
        </trans-unit>
        <trans-unit id="283d1c0d9684c8a42130b57edb6f6b92f5b86665" translate="yes" xml:space="preserve">
          <source>The expectimax search itself is coded as a recursive search which alternates between &quot;expectation&quot; steps (testing all possible tile spawn locations and values, and weighting their optimized scores by the probability of each possibility), and &quot;maximization&quot; steps (testing all possible moves and selecting the one with the best score). The tree search terminates when it sees a previously-seen position (using a &lt;a href=&quot;http://en.wikipedia.org/wiki/Transposition_table&quot;&gt;transposition table&lt;/a&gt;), when it reaches a predefined depth limit, or when it reaches a board state that is highly unlikely (e.g. it was reached by getting 6 &quot;4&quot; tiles in a row from the starting position). The typical search depth is 4-8 moves.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La b&amp;uacute;squeda expectimax en s&amp;iacute; misma se codifica como una b&amp;uacute;squeda recursiva que alterna entre los pasos de &quot;expectativa&quot; (probar todas las ubicaciones y valores posibles de baldosas y ponderar sus puntajes optimizados por la probabilidad de cada posibilidad), y los pasos de &quot;maximizaci&amp;oacute;n&quot; (probar todos los movimientos posibles y seleccionando el que tenga la mejor puntuaci&amp;oacute;n). La b&amp;uacute;squeda de &amp;aacute;rbol finaliza cuando ve una posici&amp;oacute;n vista previamente (usando una &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Transposition_table&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tabla de transposici&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), cuando alcanza un l&amp;iacute;mite de profundidad predefinido o cuando alcanza un estado de tablero que es altamente improbable (por ejemplo, se alcanz&amp;oacute; al obtener 6 &quot;4&quot; fichas en una fila desde la posici&amp;oacute;n inicial). La profundidad de b&amp;uacute;squeda t&amp;iacute;pica es de 4-8 movimientos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42f64f93fcb62fe61d13a7081dbd1385a6c16372" translate="yes" xml:space="preserve">
          <source>The following animation shows the last few steps of the game played where the AI player agent could get 2048 scores, this time adding the absolute value heuristic too:</source>
          <target state="translated">La siguiente animación muestra los últimos pasos del juego jugado en los que el agente de la IA pudo obtener 2048 puntos,esta vez añadiendo también el valor absoluto heurístico:</target>
        </trans-unit>
        <trans-unit id="83682c685d59111d019249a4364f16870be09cd8" translate="yes" xml:space="preserve">
          <source>The following figures show the &lt;strong&gt;game tree&lt;/strong&gt; explored by the player AI agent assuming the computer as adversary for just a single step:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las siguientes figuras muestran el &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;aacute;rbol&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; del &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;juego&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; explorado por el agente de inteligencia artificial del jugador asumiendo que la computadora es adversaria por un solo paso:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94d73024e25245de94e9edbd3aad5a30776360ec" translate="yes" xml:space="preserve">
          <source>The minimum score over all runs was 124024; the maximum score achieved was 794076. The median score is 387222. The AI never failed to obtain the 2048 tile (so it never lost the game even once in 100 games); in fact, it achieved the &lt;strong&gt;8192&lt;/strong&gt; tile at least once in every run!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El puntaje m&amp;iacute;nimo en todas las carreras fue de 124024; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el puntaje m&amp;aacute;ximo alcanzado fue 794076. El puntaje promedio es 387222. La IA nunca fall&amp;oacute; en obtener el mosaico de 2048 (por lo que nunca perdi&amp;oacute; el juego ni una sola vez en 100 juegos); &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;De hecho, &amp;iexcl;logr&amp;oacute; el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mosaico &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;8192&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; al menos una vez en cada carrera!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c3427688b31e68bb54900072b17104508262705" translate="yes" xml:space="preserve">
          <source>The model has changed due to the luck of being closer to the expected model. The model the AI is trying to achieve is</source>
          <target state="translated">El modelo ha cambiado debido a la suerte de estar más cerca del modelo esperado.El modelo que la IA está tratando de lograr es</target>
        </trans-unit>
        <trans-unit id="1cdcb607ac22bbd92fb5b1889cdd98d3eecdba0a" translate="yes" xml:space="preserve">
          <source>The scores of the boards are computed with the weighted sum of the square of the number of free tiles and the dot product of the 2D grid with this:</source>
          <target state="translated">Las puntuaciones de los tableros se calculan con la suma ponderada del cuadrado del número de baldosas libres y el punto producto de la cuadrícula 2D con esto:</target>
        </trans-unit>
        <trans-unit id="ac8ac475f1d47ab38014e0ffd71fab5a7ebbc40c" translate="yes" xml:space="preserve">
          <source>The solution I propose is very simple and easy to implement. Although, it has reached the score of 131040. Several benchmarks of the algorithm performances are presented.</source>
          <target state="translated">La solución que propongo es muy simple y fácil de implementar.Aunque,ha alcanzado la puntuación de 131040.Se presentan varios puntos de referencia de las prestaciones del algoritmo.</target>
        </trans-unit>
        <trans-unit id="cd5ada7eeaffca19f06bbf8ec2f5ee7d8e800c9d" translate="yes" xml:space="preserve">
          <source>The tile statistics for 10 moves/s are as follows:</source>
          <target state="translated">Las estadísticas de los azulejos de 10 movimientos son las siguientes:</target>
        </trans-unit>
        <trans-unit id="0dcd0aa110a697c4c67a6487fafa9f7c0823aa9f" translate="yes" xml:space="preserve">
          <source>The whole approach will likely be more complicated than this but not much more complicated. It could be this mechanical in feel lacking scores, weights, neurones and deep searches of possibilities. The tree of possibilities rairly even needs to be big enough to need any branching at all.</source>
          <target state="translated">Todo el enfoque será probablemente más complicado que esto,pero no mucho más complicado.Podría ser esta mecánica en la sensación de carecer de puntuaciones,pesos,neuronas y búsquedas profundas de posibilidades.El árbol de posibilidades incluso necesita ser lo suficientemente grande para necesitar cualquier ramificación.</target>
        </trans-unit>
        <trans-unit id="6d4d3599a34b6269908c672524220c522c3745c8" translate="yes" xml:space="preserve">
          <source>There is already an AI implementation for this game &lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;here&lt;/a&gt;. Excerpt from README:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ya hay una implementaci&amp;oacute;n de IA para este juego &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Extracto de README:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50c76a9fd12162abedcd5b1269d96e3a48779a24" translate="yes" xml:space="preserve">
          <source>There is also a discussion on &lt;a href=&quot;https://news.ycombinator.com/item?id=7379821&quot;&gt;Hacker News&lt;/a&gt; about this algorithm that you may find useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n hay una discusi&amp;oacute;n en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=7379821&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hacker News&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sobre este algoritmo que puede resultarle &amp;uacute;til.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e3943b324acda39f3164ad45d89f210e302e253" translate="yes" xml:space="preserve">
          <source>This algorithm is not optimal for winning the game, but it is fairly optimal in terms of performance and amount of code needed:</source>
          <target state="translated">Este algoritmo no es óptimo para ganar el juego,pero es bastante óptimo en términos de rendimiento y cantidad de código necesario:</target>
        </trans-unit>
        <trans-unit id="81716cb6c61fa929b1da024c98b8e777682d352a" translate="yes" xml:space="preserve">
          <source>This board representation, along with the table lookup approach for movement and scoring, allows the AI to search a huge number of game states in a short period of time (over 10,000,000 game states per second on one core of my mid-2011 laptop).</source>
          <target state="translated">Esta representación en el tablero,junto con el enfoque de búsqueda en la mesa para el movimiento y la puntuación,permite a la IA buscar un gran número de estados de juego en un corto período de tiempo (más de 10.000.000 de estados de juego por segundo en un núcleo de mi portátil de mediados de 2011).</target>
        </trans-unit>
        <trans-unit id="aab4a4bfd97ffe5030c2d295efd283014f0be653" translate="yes" xml:space="preserve">
          <source>This game took 27830 moves over 96 minutes, or an average of 4.8 moves per second.</source>
          <target state="translated">Este juego tomó 27830 movimientos en 96 minutos,o un promedio de 4.8 movimientos por segundo.</target>
        </trans-unit>
        <trans-unit id="1df55517328accd0f2dc6eb5550bd150b52fbce7" translate="yes" xml:space="preserve">
          <source>This graph illustrates this point: The blue line shows the board score after each move. The red line shows the algorithm's &lt;strong&gt;best&lt;/strong&gt; random-run end game score from that position. In essence, the red values are &quot;pulling&quot; the blue values upwards towards them, as they are the algorithm's best guess. It's interesting to see the red line is just a tiny bit above the blue line at each point, yet the blue line continues to increase more and more.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Este gr&amp;aacute;fico ilustra este punto: la l&amp;iacute;nea azul muestra el puntaje del tablero despu&amp;eacute;s de cada movimiento. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La l&amp;iacute;nea roja muestra la &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mejor&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; puntuaci&amp;oacute;n final del juego aleatorio &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;del algoritmo &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;desde esa posici&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En esencia, los valores rojos est&amp;aacute;n &quot;tirando&quot; de los valores azules hacia ellos, ya que son la mejor suposici&amp;oacute;n del algoritmo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es interesante ver que la l&amp;iacute;nea roja est&amp;aacute; un poquito por encima de la l&amp;iacute;nea azul en cada punto, sin embargo, la l&amp;iacute;nea azul contin&amp;uacute;a aumentando m&amp;aacute;s y m&amp;aacute;s.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="15d9cef8b96ce070fccbc886d3f7a52230dd95c2" translate="yes" xml:space="preserve">
          <source>This heuristic tries to ensure that the values of the tiles are all either increasing or decreasing along both the left/right and up/down directions. This heuristic alone captures the intuition that many others have mentioned, that higher valued tiles should be clustered in a corner. It will typically prevent smaller valued tiles from getting orphaned and will keep the board very organized, with smaller tiles cascading in and filling up into the larger tiles.</source>
          <target state="translated">Esta heurística trata de asegurar que los valores de los azulejos estén todos aumentando o disminuyendo tanto en la dirección de la izquierda como en la de arriba.Esta heurística por sí sola captura la intuición que muchos otros han mencionado,que los azulejos de mayor valor deben ser agrupados en una esquina.Normalmente evitará que los azulejos más pequeños queden huérfanos y mantendrá el tablero muy organizado,con los azulejos más pequeños cayendo en cascada y llenándose en los más grandes.</target>
        </trans-unit>
        <trans-unit id="f4404e8828677c74cccfa38f4bbfe1ae3bcfe6a7" translate="yes" xml:space="preserve">
          <source>This is a constant, used as a base-line and for other uses like testing.</source>
          <target state="translated">Esta es una constante,usada como línea de base y para otros usos como pruebas.</target>
        </trans-unit>
        <trans-unit id="406c95c020f4c2dd5ee8b09f0713c82e19af3169" translate="yes" xml:space="preserve">
          <source>This is a simplified check of the possibility of having merges within that state, without making a look-ahead.</source>
          <target state="translated">Se trata de una comprobación simplificada de la posibilidad de tener fusiones dentro de ese estado,sin hacer una mirada hacia adelante.</target>
        </trans-unit>
        <trans-unit id="8131c0f0b0c2602cf4850dc23b1938260a7a7a9f" translate="yes" xml:space="preserve">
          <source>This is not a direct answer to OP's question, this is more of the stuffs (experiments) I tried so far to solve the same problem and obtained some results and have some observations that I want to share, I am curious if we can have some further insights from this.</source>
          <target state="translated">Esta no es una respuesta directa a la pregunta de OP,esto es más de las cosas (experimentos)que he intentado hasta ahora para resolver el mismo problema y he obtenido algunos resultados y tengo algunas observaciones que quiero compartir,tengo curiosidad por si podemos tener algunas ideas más de esto.</target>
        </trans-unit>
        <trans-unit id="715df725c34a80cfb15f7cc31927abca202e48fb" translate="yes" xml:space="preserve">
          <source>This is possible due to domain-independent nature of the AI. Some of the variants are quite distinct, such as the Hexagonal clone.</source>
          <target state="translated">Esto es posible debido a la naturaleza independiente del dominio de la IA.Algunas de las variantes son bastante distintas,como el clon hexagonal.</target>
        </trans-unit>
        <trans-unit id="2b8637dd6b7d75e139a375a20969b654b1c6a3f0" translate="yes" xml:space="preserve">
          <source>This is the model I chose by default.</source>
          <target state="translated">Este es el modelo que elegí por defecto.</target>
        </trans-unit>
        <trans-unit id="2dae92fa8773f5d81d34a41b5ee59edb28a87186" translate="yes" xml:space="preserve">
          <source>Tile needs merging with neighbour but is too small: Merge another neighbour with this one.</source>
          <target state="translated">El azulejo necesita fusionarse con el vecino pero es demasiado pequeño:fusionar otro vecino con este.</target>
        </trans-unit>
        <trans-unit id="70b105f3079699e06f3a1ca29fc49029280f2f09" translate="yes" xml:space="preserve">
          <source>To assess the score performance of the AI, I ran the AI 100 times (connected to the browser game via remote control). For each tile, here are the proportions of games in which that tile was achieved at least once:</source>
          <target state="translated">Para evaluar el rendimiento de la IA,corrí la IA 100 veces (conectada al juego del navegador por control remoto).Para cada ficha,aquí están las proporciones de los juegos en los que esa ficha se logró al menos una vez:</target>
        </trans-unit>
        <trans-unit id="562dbd4dd3fb3dd997d921a85e8dd207938296af" translate="yes" xml:space="preserve">
          <source>To enforce the ordination of the tiles in a monotonic decreasing order, the score si computed as the sum of the linearized values on the board multiplied by the values of a geometric sequence with common ratio r&amp;lt;1 .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para imponer la ordenaci&amp;oacute;n de las fichas en un orden decreciente mon&amp;oacute;tono, la puntuaci&amp;oacute;n se calcula como la suma de los valores linealizados en el tablero multiplicado por los valores de una secuencia geom&amp;eacute;trica con una relaci&amp;oacute;n com&amp;uacute;n r &amp;lt;1.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1880862a60075224c2b8fdd3389edd49e7283e3" translate="yes" xml:space="preserve">
          <source>To resolve this problem, their are 2 ways to move that aren't left or worse up and examining both possibilities may immediately reveal more problems, this forms a list of dependancies, each problem requiring another problem to be solved first. I think I have this chain or in some cases tree of dependancies internally when deciding my next move, particularly when stuck.</source>
          <target state="translated">Para resolver este problema,hay dos maneras de moverse que no se dejan o que son peores para arriba y examinando ambas posibilidades puede revelar inmediatamente más problemas,esto forma una lista de dependencias,cada problema requiere otro problema para ser resuelto primero.Creo que tengo esta cadena o en algunos casos árbol de dependencias internamente al decidir mi próximo movimiento,particularmente cuando estoy atascado.</target>
        </trans-unit>
        <trans-unit id="ab12b80b60d258a6dfc62b5818e8f4e339ef4aca" translate="yes" xml:space="preserve">
          <source>Two possible ways of organizing the board are shown in the following images:</source>
          <target state="translated">En las siguientes imágenes se muestran dos posibles formas de organizar el tablero:</target>
        </trans-unit>
        <trans-unit id="ffc914498a4f81efe7ad50334ca89a25026fc42b" translate="yes" xml:space="preserve">
          <source>What I am doing is at any point, I will try to merge the tiles with values &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;, that is, I try to have &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; tiles, as minimum as possible. If I try it this way, all other tiles were automatically getting merged and the strategy seems good.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo que estoy haciendo es en cualquier momento, intentar&amp;eacute; fusionar los mosaicos con los valores &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , es decir, tratar&amp;eacute; de tener &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; mosaicos, lo m&amp;iacute;nimo posible. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si lo intento de esta manera, todos los otros mosaicos se fusionan autom&amp;aacute;ticamente y la estrategia parece buena.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0fe3580da7385572383dcfbcbfc67535e4972c3" translate="yes" xml:space="preserve">
          <source>What is the optimal algorithm for the game 2048</source>
          <target state="translated">¿Cuál es el algoritmo óptimo para el juego 2048</target>
        </trans-unit>
        <trans-unit id="7a2cd96c88d22411489171dc415feea04edc93dc" translate="yes" xml:space="preserve">
          <source>When it manages to reach the 128 it gains a whole row is gained again:</source>
          <target state="translated">Cuando logra llegar a los 128 gana una fila entera se gana de nuevo:</target>
        </trans-unit>
        <trans-unit id="6cc2b46a0e2f9ee01b185acf82165706e2b0b69b" translate="yes" xml:space="preserve">
          <source>With just 100 runs (i.e in memory games) per move, the AI achieves the 2048 tile 80% of the times and the 4096 tile 50% of the times. Using 10000 runs gets the 2048 tile 100%, 70% for 4096 tile, and about 1% for the 8192 tile.</source>
          <target state="translated">Con sólo 100 carreras (es decir,en juegos de memoria)por movimiento,la IA logra la ficha 2048 el 80% de las veces y la ficha 4096 el 50% de las veces.Usando 10000 ejecuciones se consigue la ficha de 2048 al 100%,el 70% para la ficha de 4096,y alrededor del 1% para la ficha de 8192.</target>
        </trans-unit>
        <trans-unit id="c3d1302c4890b9aa4694541642695d87a0b4b7ed" translate="yes" xml:space="preserve">
          <source>Yes, that's a 4096 alongside a 2048. =) That means it achieved the elusive 2048 tile three times on the same board.</source>
          <target state="translated">Sí,eso es un 4096 junto a un 2048.=)Eso significa que logró la elusiva baldosa de 2048 tres veces en el mismo tablero.</target>
        </trans-unit>
        <trans-unit id="b44092dddcd4f744019f7228202fb6783f53c989" translate="yes" xml:space="preserve">
          <source>You can try the AI for yourself. The code is available at &lt;a href=&quot;https://github.com/nneonneo/2048-ai&quot;&gt;https://github.com/nneonneo/2048-ai&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puedes probar la IA por ti mismo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El c&amp;oacute;digo est&amp;aacute; disponible en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/nneonneo/2048-ai&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/nneonneo/2048-ai&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59ac2882d7af09f5c4e2a1c7e5c5bb0dcad83a76" translate="yes" xml:space="preserve">
          <source>code below or on &lt;a href=&quot;https://caub.github.io/misc/2048&quot;&gt;github&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;c&amp;oacute;digo a continuaci&amp;oacute;n o en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://caub.github.io/misc/2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;github&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e9b496a0935b15e72709835275b0a4dd4c2a1c6" translate="yes" xml:space="preserve">
          <source>etc...</source>
          <target state="translated">etc...</target>
        </trans-unit>
        <trans-unit id="d8bd5af9109e98c522a44467b14c0ac230bbc8ca" translate="yes" xml:space="preserve">
          <source>where n is the number of tile on the board.</source>
          <target state="translated">donde n es el número de azulejos en el tablero.</target>
        </trans-unit>
        <trans-unit id="f550c4f98092fb346941c9ffac4b20ee0d6c58a1" translate="yes" xml:space="preserve">
          <source>which forces to organize tiles descendingly in a sort of snake from the top left tile.</source>
          <target state="translated">que obliga a organizar los azulejos descendiendo en una especie de serpiente desde el azulejo superior izquierdo.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
