<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/22342854">
    <body>
      <group id="22342854">
        <trans-unit id="f7c8748664ce768e7e3182c81b903ff85a7320c5" translate="yes" xml:space="preserve">
          <source>(The last line means having the given tiles at the same time on the board).</source>
          <target state="translated">最後の行は、与えられた牌を同時に盤上に置くことを意味する)。</target>
        </trans-unit>
        <trans-unit id="42dcce363a0691ffc8b52eaa155b22573fd9214f" translate="yes" xml:space="preserve">
          <source>(There's a possibility to reach the 131072 tile if the 4-tile is randomly generated instead of the 2-tile when needed)</source>
          <target state="translated">(必要に応じて2牌ではなく4牌をランダムに発生させれば131072牌に到達する可能性がある)</target>
        </trans-unit>
        <trans-unit id="1b25f3cc01e7eaded5356820fc12a8514181d56e" translate="yes" xml:space="preserve">
          <source>2048 Variants and Clones</source>
          <target state="translated">2048のバリアントとクローン</target>
        </trans-unit>
        <trans-unit id="88a139cf0ed644e82e3541f84922caa249ed18ea" translate="yes" xml:space="preserve">
          <source>42000</source>
          <target state="translated">42000</target>
        </trans-unit>
        <trans-unit id="355a0cd8af03872d9ce2928c8cb3da7c2fb6cd2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Edit:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Edit:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08f52696de29f7f7ec6dc0a8a919df2a38e9ebaf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The constants can be tweaked..&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注：定数は微調整できます。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8634e4a85ec9ad0d2495ed0458b0ec8c578e8935" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Algorithm&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45ea392fe0c3da367d8c51717f364d940fe4fe60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decision rule&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;決定ルール&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de42b3c305942617c48ca008230c0d5ed84ee53c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; This is a naive algorithm, modelling human conscious thought process, and gets very weak results compared to AI that search all possibilities since it only looks one tile ahead. It was submitted early in the response timeline.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;編集：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは単純なアルゴリズムであり、人間の意識的な思考プロセスをモデル化しており、AIと比較して非常に弱い結果を取得します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;回答のタイムラインの早い段階で提出されました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b40ea2169b1372cb4d66f254c44144da5482dc88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Evaluation Details&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;評価の詳細&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b321d0995c10030e9430af46a596a61260d1dad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Evaluation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Evaluation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fbce973333197ec3e114cf37edcb6ff4502f6e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Heuristic scoring algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ヒューリスティックスコアリングアルゴリズム&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef6c3ec99e2445b2f8e789385112f8add04aca2a" translate="yes" xml:space="preserve">
          <source>A commenter on Hacker News gave &lt;a href=&quot;https://news.ycombinator.com/item?id=7381082&quot;&gt;an interesting formalization&lt;/a&gt; of this idea in terms of graph theory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hacker Newsのコメンターは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、グラフ理論の観点からこのアイデアを&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=7381082&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;興味深い形式化し&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;まし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;た&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0fc8abe55206bcc6fee5b9655148f68e7d675bb" translate="yes" xml:space="preserve">
          <source>A few pointers on the missing steps. Here:</source>
          <target state="translated">不足しているステップについてのいくつかの指摘。これを</target>
        </trans-unit>
        <trans-unit id="ccab3659df4d866e5c99429991c48026db374125" translate="yes" xml:space="preserve">
          <source>A state is more flexible if it has more freedom of possible transitions.</source>
          <target state="translated">状態は、可能な遷移の自由度が高いほど柔軟性が高い。</target>
        </trans-unit>
        <trans-unit id="884e259396760240aa757f365184412ce12cb6ac" translate="yes" xml:space="preserve">
          <source>AI Algorithm</source>
          <target state="translated">AIアルゴリズム</target>
        </trans-unit>
        <trans-unit id="93e084b33c7ba167fbfbc4319e9d4f49b5668176" translate="yes" xml:space="preserve">
          <source>After implementing this algorithm I tried many improvements including using the min or max scores, or a combination of min,max,and avg. I also tried using depth: Instead of trying K runs per move, I tried K moves per move &lt;em&gt;list&lt;/em&gt; of a given length (&quot;up,up,left&quot; for example) and selecting the first move of the best scoring move list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このアルゴリズムを実装した後、最小または最大スコア、または最小、最大、および平均の組み合わせの使用を含む多くの改善を試みました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;深度も使用してみました。移動ごとにKランを試行する代わりに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、所定の長さ（「上、上、左」など）の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リスト&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ごとにK移動を試行し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、最高スコアの移動リストの最初の移動を選択しました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ede32df5eb0c24212c925595dd08fa4665c5adef" translate="yes" xml:space="preserve">
          <source>Also, I tried to increase the search depth cut-off from 3 to 5 (I can't increase it more since searching that space exceeds allowed time even with pruning) and added one more heuristic that looks at the values of adjacent tiles and gives more points if they are merge-able, but still I am not able to get 2048.</source>
          <target state="translated">また、検索の深さのカットオフを3から5に増やしてみました(これ以上増やすことはできません)が、隣接するタイルの値を見て、マージ可能なタイルであればより多くのポイントを与えるヒューリスティックをもう1つ追加してみましたが、それでも2048を得ることができません。</target>
        </trans-unit>
        <trans-unit id="a52d36040473cfee0c3dda94c4922ec62a49256f" translate="yes" xml:space="preserve">
          <source>An implementation of the minmax or the Expectiminimax will surely improve the algorithm. Obviously a more
sophisticated decision rule will slow down the algorithm and it will require some time to be implemented.I will try a minimax implementation in the near future. (stay tuned)</source>
          <target state="translated">minmaxまたはExpectiminimaxの実装は確かにアルゴリズムを改善するでしょう。明らかに、より洗練された決定規則はアルゴリズムを遅くし、それが実装されるのに時間がかかるでしょう。(期待しています)</target>
        </trans-unit>
        <trans-unit id="81a3b22b9764c6db541f97a5b0cf0bc8185c33b4" translate="yes" xml:space="preserve">
          <source>An interesting fact about this algorithm is that while the random-play games are unsurprisingly quite bad, choosing the best (or least bad) move leads to very good game play: A typical AI game can reach 70000 points and last 3000 moves, yet the in-memory random play games from any given position yield an average of 340 additional points in about 40 extra moves before dying. (You can see this for yourself by running the AI and opening the debug console.)</source>
          <target state="translated">このアルゴリズムについての興味深い事実は、ランダムプレイのゲームは当然のことながら非常に悪いのですが、最高の(または最低の)手を選択すると非常に良いゲームプレイになるということです。典型的なAIゲームは70000ポイントに達し、最後の3000手に達することができますが、任意の位置からのインメモリランダムプレイゲームは、死ぬ前に約40手の余分な手で平均340ポイントの追加ポイントをもたらします。(これは、AIを実行してデバッグコンソールを開くことで確認することができます)。</target>
        </trans-unit>
        <trans-unit id="e9d2a26295c1d0085ec67a73a147f26c2d1f037d" translate="yes" xml:space="preserve">
          <source>And finally, there is a penalty for having too few free tiles, since options can quickly run out when the game board gets too cramped.</source>
          <target state="translated">そして最後に、ゲームボードがあまりにも窮屈になるとオプションがすぐになくなることができるので、あまりにも少ない無料のタイルを持っているためのペナルティがあります。</target>
        </trans-unit>
        <trans-unit id="fdf944fcd7b6a6e2a2ddfb040b0978330ad9950a" translate="yes" xml:space="preserve">
          <source>And that's it! Searching through the game space while optimizing these criteria yields remarkably good performance. One advantage to using a generalized approach like this rather than an explicitly coded move strategy is that the algorithm can often find interesting and unexpected solutions. If you watch it run, it will often make surprising but effective moves, like suddenly switching which wall or corner it's building up against.</source>
          <target state="translated">そして、それだけです! これらの基準を最適化しながら対局空間を探索すると、非常に良いパフォーマンスが得られます。明示的にコード化された手筋ではなく、このような一般化されたアプローチを使用することの利点の一つは、アルゴリズムが興味深く予想外の解決策を見つけることができることです。アルゴリズムが実行されているのを見ていると、壁や角に向かって構築している壁や角を突然切り替えるような、驚くような、しかし効果的な動きをすることがよくあります。</target>
        </trans-unit>
        <trans-unit id="38ffd01cfffffe720859de9ba280dc3a2fa18ebe" translate="yes" xml:space="preserve">
          <source>And the chain to get there has become:</source>
          <target state="translated">そして、そこにたどり着くまでの連鎖が</target>
        </trans-unit>
        <trans-unit id="f168395e34c5d5a79b07cf3ea9c0184c6cfec5d9" translate="yes" xml:space="preserve">
          <source>Any insights will be really very helpful, thanks in advance. (This is the link of my blog post for the article: &lt;a href=&quot;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&quot;&gt;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&lt;/a&gt; and the youtube video: &lt;a href=&quot;https://www.youtube.com/watch?v=VnVFilfZ0r4&quot;&gt;https://www.youtube.com/watch?v=VnVFilfZ0r4&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;事前のおかげで、どんな洞察も本当にとても役に立ちます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（これは記事の私のブログ投稿のリンクです：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve-2048-game-with-computer/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//sandipanweb.wordpress.com/2017/03/06/using-minimax-with-alpha-beta-pruning-and-heuristic-evaluation-to-solve -2048-game-with-computer /&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;およびyoutubeビデオ：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=VnVFilfZ0r4&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//www.youtube.com/watch? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;v=VnVFilfZ0r4&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccd9e8b01034b267d29c5745b84208f0a085f623" translate="yes" xml:space="preserve">
          <source>As a consequence, this solver is deterministic.</source>
          <target state="translated">結果として、このソルバーは決定論的である。</target>
        </trans-unit>
        <trans-unit id="9a7ad671d6cde8daae45c935046a605bf403cdad" translate="yes" xml:space="preserve">
          <source>At 1 moves/s: &lt;strong&gt;609104&lt;/strong&gt; (100 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1移動/秒：&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;609104&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（平均100ゲーム）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e5d64f1e0b61c1ef3e52e0d5823d5921bc21a50" translate="yes" xml:space="preserve">
          <source>At 10 moves/s: &lt;strong&gt;589355&lt;/strong&gt; (300 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10ムーブ/秒：&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;589355&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（平均300ゲーム）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c3c0d6ea43007ca3c28efb394b96f8a3287fcd1" translate="yes" xml:space="preserve">
          <source>At 3-ply (ca. 1500 moves/s): &lt;strong&gt;511759&lt;/strong&gt; (1000 games average)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3プライで（約1500ムーブ/秒）：&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;511759&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（平均1000ゲーム）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e93088674333bdf43b53fdb34644dc1838dfbd19" translate="yes" xml:space="preserve">
          <source>Below animation shows the last few steps of the game played by the AI agent with the computer player:</source>
          <target state="translated">下のアニメーションは、AIエージェントがコンピュータのプレイヤーと一緒にプレイするゲームの最後の数ステップを示しています。</target>
        </trans-unit>
        <trans-unit id="6c12051095dc9a9f3c8c9322ba72366123f527e4" translate="yes" xml:space="preserve">
          <source>Below is the code implementing the solving algorithm. The grid is represented as a 16-length array of Integers. And scoring is done simply by counting the number of empty squares.</source>
          <target state="translated">以下は解法アルゴリズムを実装したコードです。グリッドは 16 個の整数の配列として表現されます.そして,空のマスの数を数えることで採点が行われます.</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="85a8f1bded86a0cdaa694a12d8a5a7691488a18a" translate="yes" xml:space="preserve">
          <source>Bit shift operations are used to extract individual rows and columns. A single row or column is a 16-bit quantity, so a table of size 65536 can encode transformations which operate on a single row or column. For example, moves are implemented as 4 lookups into a precomputed &quot;move effect table&quot; which describes how each move affects a single row or column (for example, the &quot;move right&quot; table contains the entry &quot;1122 -&amp;gt; 0023&quot; describing how the row [2,2,4,4] becomes the row [0,0,4,8] when moved to the right).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ビットシフト操作は、個々の行と列を抽出するために使用されます。単一の行または列は16ビットの数量であるため、サイズが65536のテーブルは、単一の行または列を操作する変換をエンコードできます。たとえば、移動は、各移動が単一の行または列にどのように影響するかを説明する事前計算された「移動効果テーブル」への4つのルックアップとして実装されます（たとえば、「右移動」テーブルには、「1122-&amp;gt; 0023」というエントリが含まれています。行[2,2,4,4]は、右に移動すると行[0,0,4,8]になります）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c42c80d6b77bd2a349eaa2543cf5ddc744fe92ff" translate="yes" xml:space="preserve">
          <source>But, when I actually use this algorithm, I only get around 4000 points before the game terminates. Maximum points AFAIK is slightly more than 20,000 points which is way larger than my current score. Is there a better algorithm than the above?</source>
          <target state="translated">しかし、実際にこのアルゴリズムを使ってみると、ゲームが終了するまでに4000点くらいしか取れません。AFAIKの最大ポイントは、現在の私のスコアよりもはるかに大きい20,000ポイントをわずかに超えています。上記のアルゴリズムよりも良いアルゴリズムはありますか?</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="d5026d402b84438a420117883e0b28d724275f57" translate="yes" xml:space="preserve">
          <source>Currently, the program achieves about a 90% win rate running in javascript in the browser on my laptop given about 100 milliseconds of thinking time per move, so while not perfect (yet!) it performs pretty well.</source>
          <target state="translated">現在、このプログラムは、私のラップトップ上のブラウザでjavascriptを使って実行した場合、約90%の勝率を達成しています(1回の動きにつき約100ミリ秒の思考時間を与えられます)。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="6c38d1c09dfbb8d9afb27b450f505d02e699af0a" translate="yes" xml:space="preserve">
          <source>First I created a JavaScript version which can be &lt;a href=&quot;http://ronzil.github.io/2048-AI/&quot;&gt;seen in action here&lt;/a&gt;. This version can run 100's of runs in decent time. Open the console for extra info. 
(&lt;a href=&quot;https://github.com/ronzil/2048-AI&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;まず、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ronzil.github.io/2048-AI/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで実際に動作&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;するJavaScriptバージョンを作成しました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このバージョンでは、何百回もの実行を適切な時間で実行できます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;追加情報については、コンソールを開いてください。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ronzil/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ソース&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb6608935b3258a93b48bed3d51f17ee42bad070" translate="yes" xml:space="preserve">
          <source>For 3-ply:</source>
          <target state="translated">3プライ用。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="afd41cc839be699428bd0fa94a187d2888e8230c" translate="yes" xml:space="preserve">
          <source>Free Space Available</source>
          <target state="translated">空きスペース</target>
        </trans-unit>
        <trans-unit id="f00400337de66f8cbfda3eb6257d6edb7ab4d834" translate="yes" xml:space="preserve">
          <source>Free Tiles</source>
          <target state="translated">無料のタイル</target>
        </trans-unit>
        <trans-unit id="05c3afb6f1373b0671a788c523440a2cdb7b67cf" translate="yes" xml:space="preserve">
          <source>Furthermore, Petr also optimized the heuristic weights using a &quot;meta-optimization&quot; strategy (using an algorithm called &lt;a href=&quot;https://en.wikipedia.org/wiki/CMA-ES&quot;&gt;CMA-ES&lt;/a&gt;), where the weights themselves were adjusted to obtain the highest possible average score.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;さらに、Petrは、「メタ最適化」戦略（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/CMA-ES&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CMA-ES&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と呼ばれるアルゴリズムを使用）を使用してヒューリスティックな重みも最適化しました。この&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合、重み自体が調整され、可能な限り高い平均スコアが得られました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a006d33e016b3552046744f9daab00e3a9dea82" translate="yes" xml:space="preserve">
          <source>Here goes the algorithm. Around 80% wins (it seems it is always possible to win with more &quot;professional&quot; AI techniques, I am not sure about this, though.)</source>
          <target state="translated">アルゴリズムはこうだ。80%前後の勝率(もっと「プロ」のAI技術を使えば必ず勝てそうな気がしますが、これはよくわかりません。)</target>
        </trans-unit>
        <trans-unit id="9fde7d59da7d0da4eb4e909565d46f8fa0c4121d" translate="yes" xml:space="preserve">
          <source>Here the model and chain is:</source>
          <target state="translated">ここにモデルとチェーンがあります。</target>
        </trans-unit>
        <trans-unit id="7f9a58f740830a3a6e0ce355d41b93414963aa63" translate="yes" xml:space="preserve">
          <source>Here we evaluate faces that have the possibility to getting to merge, by evaluating them backwardly, tile 2 become of value 2048, while tile 2048 is evaluated 2.</source>
          <target state="translated">ここでは、合体する可能性のある面を逆算して評価することで、タイル2は2048の値となり、タイル2048は2の評価となります。</target>
        </trans-unit>
        <trans-unit id="ea14290a91583ca847b2ae45387c083c3b7f5174" translate="yes" xml:space="preserve">
          <source>Here's a demonstration of the power of this approach. I uncapped the tile values (so it kept going after reaching 2048) and here is the best result after eight trials.</source>
          <target state="translated">このアプローチの威力を実証してみましょう。タイルの値をアンキャップして(そうすれば2048に達した後も続けられる)、8回の試行の後の最良の結果がこれです。</target>
        </trans-unit>
        <trans-unit id="4f64374fb447322f3ae9648b3c8851f4e3a0a00f" translate="yes" xml:space="preserve">
          <source>Here's a screenshot of a perfectly monotonic grid. I obtained this by running the algorithm with the eval function set to disregard the other heuristics and only consider monotonicity.</source>
          <target state="translated">これは完全に単調なグリッドのスクリーンショットです。他のヒューリスティックを無視して、単調性のみを考慮するようにeval関数を設定してアルゴリズムを実行することで、このような結果が得られました。</target>
        </trans-unit>
        <trans-unit id="f97f5d39b364919717cbfb83c95dfea658c2d11e" translate="yes" xml:space="preserve">
          <source>Here's a screenshot of a perfectly smooth grid, courtesy of &lt;a href=&quot;http://jennypeng.me/2048/&quot;&gt;this excellent parody fork&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://jennypeng.me/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この優れたパロディフォークの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;おかげで、完全に滑らかなグリッドのスクリーンショットです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b03d95f10bf2fb9649d305f295aac7854cae9194" translate="yes" xml:space="preserve">
          <source>Here's the screenshot of the best run:</source>
          <target state="translated">ベストランのスクリーンショットです。</target>
        </trans-unit>
        <trans-unit id="ffac2906be85464582876c1fd5b67e5775ca4c9b" translate="yes" xml:space="preserve">
          <source>Heuristics</source>
          <target state="translated">Heuristics</target>
        </trans-unit>
        <trans-unit id="ed8ab7ed11c60bc100175f13e827da35c53e21c1" translate="yes" xml:space="preserve">
          <source>However, I have never observed it obtaining the 65536 tile.</source>
          <target state="translated">しかし、65536牌を取得しているのを見たことがありません。</target>
        </trans-unit>
        <trans-unit id="84fd09822e571ef59181c3b714b48c120c88bc2d" translate="yes" xml:space="preserve">
          <source>However, none of these ideas showed any real advantage over the simple first idea. I left the code for these ideas commented out in the C++ code.</source>
          <target state="translated">しかし、これらのアイデアはどれも単純な最初のアイデアに比べて、実際には何のメリットもありませんでした。私はこれらのアイデアのためのコードをC++のコードでコメントアウトしたままにしておきました。</target>
        </trans-unit>
        <trans-unit id="5e64fedf544d393d02c17117048de608b040496d" translate="yes" xml:space="preserve">
          <source>I also tried the corner heuristic, but for some reason it makes the results worse, any intuition why?</source>
          <target state="translated">私はまた、コーナーヒューリスティックを試してみましたが、いくつかの理由で、それは結果が悪くなりますが、何か直感的な理由は?</target>
        </trans-unit>
        <trans-unit id="bff61911fdd315b14809acd1b0718f81baa37d98" translate="yes" xml:space="preserve">
          <source>I am the author of a 2048 controller that scores better than any other program mentioned in this thread. An efficient implementation of the controller is available on &lt;a href=&quot;https://github.com/aszczepanski/2048&quot;&gt;github&lt;/a&gt;. In &lt;a href=&quot;https://github.com/wjaskowski/mastering-2048&quot;&gt;a separate repo&lt;/a&gt; there is also the code used for training the controller's state evaluation function. The training method is described in the &lt;a href=&quot;http://arxiv.org/abs/1604.05085&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私は、このスレッドで言及されている他のどのプログラムよりも優れたスコアを示す2048コントローラーの作成者です。コントローラの効率的な実装は&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/aszczepanski/2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;github&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で利用できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/wjaskowski/mastering-2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;別レポ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コントローラの状態の評価関数を訓練するために使用されるコードもあります。訓練方法は&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://arxiv.org/abs/1604.05085&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;論文に&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;記載されてい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b1878005b4715ef7dadf5dbab3530f2387e3d7d" translate="yes" xml:space="preserve">
          <source>I applied convex combination (tried different heuristic weights) of couple of heuristic evaluation functions, mainly from intuition and from the ones discussed above:</source>
          <target state="translated">主に直感と上述のヒューリスティック評価関数の組み合わせから、いくつかのヒューリスティック評価関数の凸型組み合わせ(ヒューリスティックな重みを変えてみた)を適用した。</target>
        </trans-unit>
        <trans-unit id="b340ff0771c0044d5631169bb8b9da7b0949767e" translate="yes" xml:space="preserve">
          <source>I became interested in the idea of an AI for this game containing &lt;strong&gt;no hard-coded intelligence&lt;/strong&gt; (i.e no heuristics, scoring functions etc). The AI should &lt;em&gt;&quot;know&quot;&lt;/em&gt; only the game rules, and &lt;em&gt;&quot;figure out&quot;&lt;/em&gt; the game play. This is in contrast to most AIs (like the ones in this thread) where the game play is essentially brute force steered by a scoring function representing human understanding of the game.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハードコードされたインテリジェンス&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（つまり、ヒューリスティックス、スコアリング関数など）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を含ま&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ない&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このゲームのAIのアイデアに興味を持ちました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。 AIは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲームルールのみ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「認識&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;」し&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ゲームプレイ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「把握」する&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。これは、ほとんどのAI（このスレッドのAIなど）とは対照的です。AIは、基本的に、ゲームの人間によるゲームの理解を表すスコアリング関数によって力ずくで操作されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed0a579e8bb5a2fa1f190be9cc3a3984935966dd" translate="yes" xml:space="preserve">
          <source>I believe there's still room for improvement on the heuristics. This algorithm definitely isn't yet &quot;optimal&quot;, but I feel like it's getting pretty close.</source>
          <target state="translated">ヒューリスティックスにはまだ改善の余地があると思います。このアルゴリズムは確かにまだ「最適」ではありませんが、かなり近づいているように感じます。</target>
        </trans-unit>
        <trans-unit id="f8ed635115239705d2911e5bd2f5ced5edce99c5" translate="yes" xml:space="preserve">
          <source>I copy here the content of a &lt;a href=&quot;http://diaryofatinker.blogspot.it/2014/03/an-artificial-intelligence-for-2048-game.html&quot;&gt;post on my blog&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://diaryofatinker.blogspot.it/2014/03/an-artificial-intelligence-for-2048-game.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブログの投稿&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の内容をここにコピーします&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d84a2a8980a497e88dd0c2f4d14dcecd79505253" translate="yes" xml:space="preserve">
          <source>I developed a 2048 AI using &lt;em&gt;expectimax&lt;/em&gt; optimization, instead of the minimax search used by @ovolve's algorithm. The AI simply performs maximization over all possible moves, followed by expectation over all possible tile spawns (weighted by the probability of the tiles, i.e. 10% for a 4 and 90% for a 2). As far as I'm aware, it is not possible to prune expectimax optimization (except to remove branches that are exceedingly unlikely), and so the algorithm used is a carefully optimized brute force search.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@ovolveのアルゴリズムで使用されるミニマックス検索の代わりに、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;expectimax&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最適化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用して2048 AIを開発しました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。 AIは、可能なすべての動きに対して最大化を実行し、次にすべての可能なタイルスポーンに対する期待値を実行します（タイルの確率によって重み付けされます。つまり、4の場合は10％、2の場合は90％）。私の知る限り、expectimaxの最適化を排除することはできません（非常に可能性が低い分岐を削除する場合を除く）。そのため、使用されるアルゴリズムは慎重に最適化されたブルートフォース検索です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a35fdce8c7933d0b2a937ce2170823745b56f98" translate="yes" xml:space="preserve">
          <source>I did add a &quot;Deep Search&quot; mechanism that increased the run number temporarily to 1000000 when any of the runs managed to accidentally reach the next highest tile. This offered a time improvement.</source>
          <target state="translated">私は「ディープサーチ」のメカニズムを追加しました。これにより、時間の短縮につながりました。</target>
        </trans-unit>
        <trans-unit id="ba7f2fdb047681e855cdfd6b772b6db5b92aa4ee" translate="yes" xml:space="preserve">
          <source>I find it quite surprising that the algorithm doesn't need to actually foresee good game play in order to chose the moves that produce it.</source>
          <target state="translated">アルゴリズムが、それを生み出す手を選択するために、実際に良いゲームプレイを予見する必要がないというのは、非常に驚くべきことだと思います。</target>
        </trans-unit>
        <trans-unit id="2224c20bdfc42ec2f0bd05389e5c06114237583f" translate="yes" xml:space="preserve">
          <source>I found a simple yet surprisingly good playing algorithm: To determine the next move for a given board, the AI plays the game in memory using &lt;strong&gt;random moves&lt;/strong&gt; until the game is over. This is done several times while keeping track of the end game score. Then the average end score &lt;em&gt;per starting move&lt;/em&gt; is calculated. The starting move with the highest average end score is chosen as the next move.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シンプルでありながら驚くほど優れたプレーアルゴリズムを見つけました。特定のボードの次の動きを判別するために、AI &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はゲームが終わるまで&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ランダムな動き&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用してメモリ内でゲームをプレイ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します。これは、ゲーム終了時のスコアを追跡しながら数回行われます。次に、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;開始移動ごと&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の平均終了スコア&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が計算されます。最も高い平均エンドスコアを持つ最初の手が次の手として選択されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="031425862c087193c510d3992030621083927b33" translate="yes" xml:space="preserve">
          <source>I have 4x4 grid for playing the game.</source>
          <target state="translated">私はゲームをプレイするために4x4のグリッドを持っています。</target>
        </trans-unit>
        <trans-unit id="f56414c1f6736cdf7c56bfca13c15f73247b88ce" translate="yes" xml:space="preserve">
          <source>I have recently stumbled upon the game &lt;a href=&quot;http://gabrielecirulli.github.io/2048/&quot;&gt;2048&lt;/a&gt;. You merge similar tiles by moving them in any of the four directions to make &quot;bigger&quot; tiles. After each move, a new tile appears at random empty position with a value of either &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;. The game terminates when all the boxes are filled and there are no moves that can merge tiles, or you create a tile with a value of &lt;code&gt;2048&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私は最近&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://gabrielecirulli.github.io/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2048年&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のゲームに遭遇しました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;類似のタイルを4つの方向のいずれかに移動して結合し、「より大きな」タイルを作成します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;各移動の後、新しいタイルが&lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のいずれかの値を持つランダムな空の位置に表示され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべてのボックスが満たされ、タイルをマージできる動きがないか、値が&lt;/font&gt;&lt;/font&gt; &lt;code&gt;2048&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;タイルを作成すると、ゲームは終了します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59f0d82a356c65bde837828cc539c2e8be89a87d" translate="yes" xml:space="preserve">
          <source>I have refined the algorithm and beaten the game! It may fail due to simple bad luck close to the end (you are forced to move down, which you should never do, and a tile appears where your highest should be. Just try to keep the top row filled, so moving left does not break the pattern), but basically you end up having a fixed part and a mobile part to play with. This is your objective:</source>
          <target state="translated">私はアルゴリズムを洗練させ、ゲームを倒しました それは終わりに近い単純な不運のために失敗する可能性があります(あなたは決してすべきではない下に移動することを余儀なくされ、あなたの最高位があるはずの場所にタイルが表示されます。ただ、左に移動してもパターンを壊さないように、上の行を埋めるようにしてください)が、基本的には固定部分と遊ぶためのモバイル部分を持っていることになってしまいます。これはあなたの目的です。</target>
        </trans-unit>
        <trans-unit id="e043b4a0622bd7bd4f4bff3f75f5289152c44dc3" translate="yes" xml:space="preserve">
          <source>I just tried my minimax implementation with alpha-beta pruning with search-tree depth cutoff at 3 and 5. I was trying to solve the same problem for a 4x4 grid as a project assignment for the &lt;strong&gt;edX course ColumbiaX: CSMM.101x Artificial Intelligence (AI)&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私はミニマックスの実装で、アルファベータプルーニングを使用して、3と5で検索ツリーの深さをカットオフしてみ&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ました。4x4&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;グリッドで、&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;edXコースのColumbiaXの&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プロジェクト割り当てと同じ問題を解決しようとし&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ました：CSMM.101x Artificial Intelligence（ AI）&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f7940b642881ad963c29c8e46d7cecbcc69643e3" translate="yes" xml:space="preserve">
          <source>I think I found an algorithm which works quite well, as I often reach scores over 10000, my personal best being around 16000. My solution does not aim at keeping biggest numbers in a corner, but to keep it in the top row.</source>
          <target state="translated">私はしばしば10000以上のスコアに到達するように、私は非常にうまく機能するアルゴリズムを見つけたと思います、個人的なベストは約16000です。私の解決策は、最大の数字を隅に置いておくことを目的としているのではなく、それを最上段に置いておくことです。</target>
        </trans-unit>
        <trans-unit id="55f66ed61b2ad8167d89233045ef1fe2708fd931" translate="yes" xml:space="preserve">
          <source>I think it will be better to use Expectimax instead of minimax, but still I want to solve this problem with minimax only and obtain high scores such as 2048 or 4096. I am not sure whether I am missing anything.</source>
          <target state="translated">minimaxではなくExpectimaxを使った方が良いと思いますが、それでもminimaxだけで解いて、2048や4096などの高得点を得たいと思っています。私に足りないものがあるのかどうかはわかりません。</target>
        </trans-unit>
        <trans-unit id="ea165dbbcc05f8b9c0fee4d6f269ceb0aa9da587" translate="yes" xml:space="preserve">
          <source>I thinks it's quite successful for its simplicity. The result it reaches when starting with an empty grid and solving at depth 5 is:</source>
          <target state="translated">そのシンプルさの割にはかなり成功していると思います。空のグリッドから始めて、深さ5で解いたときの結果です。</target>
        </trans-unit>
        <trans-unit id="1034d585a72bb081cca29625c761242ddf856012" translate="yes" xml:space="preserve">
          <source>I used an exhaustive algorithm that favours empty tiles. It performs pretty quickly for depth 1-4, but on depth 5 it gets rather slow at a around 1 second per move.</source>
          <target state="translated">私は、空の牌を優先する徹底的なアルゴリズムを使用しました。深度1〜4ではかなり速く実行されますが、深度5では1手あたり1秒程度でかなり遅くなります。</target>
        </trans-unit>
        <trans-unit id="37173dc2be4bdb4d84b503ac96c838e5e06ad4e3" translate="yes" xml:space="preserve">
          <source>I wrote a 2048 solver in Haskell, mainly because I'm learning this language right now.</source>
          <target state="translated">Haskellで2048ソルバーを書いたのは、主に今この言語を勉強しているからです。</target>
        </trans-unit>
        <trans-unit id="46c02f631905ee5caf0b222fd7359a47400755dd" translate="yes" xml:space="preserve">
          <source>I'd be interested to hear if anyone has other improvement ideas that maintain the domain-independence of the AI.</source>
          <target state="translated">他にもAIのドメイン非依存性を維持する改善案があれば教えて欲しいですね。</target>
        </trans-unit>
        <trans-unit id="a1169010fb1d82ea350ecfb6aa43f3802bb8f9f2" translate="yes" xml:space="preserve">
          <source>I'm the author of the AI program that others have mentioned in this thread. You can view the AI in &lt;a href=&quot;http://ovolve.github.io/2048-AI/&quot;&gt;action&lt;/a&gt; or read the &lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;source&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私は他の人がこのスレッドで言及したAIプログラムの作者です。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ovolve.github.io/2048-AI/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;動作中&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のAIを表示し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たり、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ソースを&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;読んだり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cff211afed3c58617e7600239f98eba6f99208de" translate="yes" xml:space="preserve">
          <source>If I assign too much weights to the first heuristic function or the second heuristic function, both the cases the scores the AI player gets are low. I played with many possible weight assignments to the heuristic functions and take a convex combination, but very rarely the AI player is able to score 2048. Most of the times it either stops at 1024 or 512.</source>
          <target state="translated">1つ目のヒューリスティック関数や2つ目のヒューリスティック関数に重みをかけすぎると、どちらの場合もAIプレイヤーの得点が低くなってしまいます。ヒューリスティック関数に多くのウェイトを割り当てて、凸の組み合わせで遊んでみましたが、AIプレイヤーが2048点を取れることはほとんどありませんでした。ほとんどの場合、1024か512で止まってしまいます。</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3ed4d38edf88c96646888aef4c5aee857217b77c" translate="yes" xml:space="preserve">
          <source>Implementation and Links</source>
          <target state="translated">実装とリンク</target>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="dae216ce28189a3dc03880a06f90efd300da2352" translate="yes" xml:space="preserve">
          <source>In case of T2, four tests in ten generate the 4096 tile with an average score of</source>
          <target state="translated">T2の場合、10回に4回のテストで平均スコアが4096の牌が生成されます。</target>
        </trans-unit>
        <trans-unit id="06f4f3fea3016100595f36b33ff12f794776a418" translate="yes" xml:space="preserve">
          <source>In here we still need to check for stacked values, but in a lesser way that doesn't interrupt the flexibility parameters, so we have the sum of { x in [4,44] }.</source>
          <target state="translated">ここでは、スタックされた値をチェックする必要がありますが、より少ない方法で柔軟性パラメータを中断しないので、{x in [4,44]}の合計が得られます。</target>
        </trans-unit>
        <trans-unit id="3c2636cc71bb825cadfd8c456577a98d04fe05b8" translate="yes" xml:space="preserve">
          <source>In my case, the computer player is completely random, but still i assumed adversarial settings and implemented the AI player agent as the max player.</source>
          <target state="translated">私の場合、コンピュータのプレイヤーは完全にランダムですが、それでも敵対的な設定を想定して、AIプレイヤーエージェントをMAXプレイヤーとして実装しました。</target>
        </trans-unit>
        <trans-unit id="23652927c0d25e443786d2f509c213988410f12c" translate="yes" xml:space="preserve">
          <source>Initially, I used two very simple heuristics, granting &quot;bonuses&quot; for open squares and for having large values on the edge. These heuristics performed pretty well, frequently achieving 16384 but never getting to 32768.</source>
          <target state="translated">最初は 2 つの非常にシンプルなヒューリスティックを使いました。これらのヒューリスティックは非常にうまく機能しており、頻繁に16384を達成することができたが、32768に到達することはなかった。</target>
        </trans-unit>
        <trans-unit id="1545ea420f5c65b9c9bba94c946b329fa8251dc3" translate="yes" xml:space="preserve">
          <source>Just for fun, I've also &lt;a href=&quot;http://ronzil.github.io/2048AI-AllClones/&quot;&gt;implemented the AI as a bookmarklet&lt;/a&gt;, hooking into the game's controls. This allows the AI to work with the original game and &lt;strong&gt;many of its variants&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;面白くする&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ronzil.github.io/2048AI-AllClones/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ために、AIをブックマークレットとして実装&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;し、ゲームのコントロールにフックしました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これにより、AIは元のゲームと&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのバリエーションの多く&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と連携することができます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="87ab7e933f551b05ada40bfa9c63b7d3a98505ae" translate="yes" xml:space="preserve">
          <source>Larger tile in the way: Increase the value of a smaller surrounding tile.</source>
          <target state="translated">邪魔になる大きめのタイル。小さめの周囲のタイルの価値を高める。</target>
        </trans-unit>
        <trans-unit id="18be8c8127f21459189b5caf81e55e1002781278" translate="yes" xml:space="preserve">
          <source>Later I implemented a scoring tree that took into account the conditional probability of being able to play a move after a given move list.</source>
          <target state="translated">その後、私は、与えられた手のリストの後に手を打つことができる条件付き確率を考慮したスコアリングツリーを実装しました。</target>
        </trans-unit>
        <trans-unit id="5d40de2c184332bb133e3c7b3f9b7106a46f6318" translate="yes" xml:space="preserve">
          <source>Later, in order to play around some more I used @nneonneo highly optimized infrastructure and implemented my version in C++. This version allows for up to 100000 runs per move and even 1000000 if you have the patience. Building instructions provided. It runs in the console and also has a remote-control to play the web version.
(&lt;a href=&quot;https://github.com/ronzil/2048-ai-cpp&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その後、さらにいくつかを試すために、@ nneonneoの高度に最適化されたインフラストラクチャを使用し、自分のバージョンをC ++に実装しました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このバージョンでは、1回の移動で最大100000回実行でき、忍耐力がある場合は1000000回まで実行できます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供される構築手順。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンソールで実行され、Webバージョンを再生するためのリモコンも備えています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ronzil/2048-ai-cpp&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ソース&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="44c2d6ea8314c3f98974d2ba1a58dd051bb32c6f" translate="yes" xml:space="preserve">
          <source>Many of the other answers use AI with computationally expensive searching of possible futures, heuristics, learning and the such. These are impressive and probably the correct way forward, but I wish to contribute another idea.</source>
          <target state="translated">他の回答の多くは、計算コストのかかる可能性のある未来の検索、ヒューリスティック、学習などのAIを使用しています。これらは印象的であり、おそらく正しい方法だと思いますが、私はもう一つのアイデアを投稿したいと思います。</target>
        </trans-unit>
        <trans-unit id="2b46f31c24d9d078dc34aed0d4067c4f769ba53f" translate="yes" xml:space="preserve">
          <source>Model the sort of strategy that good players of the game use.</source>
          <target state="translated">ゲームの良いプレーヤーが使用する戦略の種類をモデル化します。</target>
        </trans-unit>
        <trans-unit id="fd4c07fb20d7d76fbcadaea8ea7ddaaac986f8c7" translate="yes" xml:space="preserve">
          <source>Monotonicity</source>
          <target state="translated">Monotonicity</target>
        </trans-unit>
        <trans-unit id="44fc3fc0ab34b52134a7cd76d9bbcb14829e6e00" translate="yes" xml:space="preserve">
          <source>More spaces makes the state more flexible, we multiply by 128 (which is the median) since a grid filled with 128 faces is an optimal impossible state.</source>
          <target state="translated">128面で埋め尽くされたグリッドは最適な不可能な状態であるため、128を掛け合わせます(中央値)。</target>
        </trans-unit>
        <trans-unit id="1f62f4a60f5f356eabae5d8f3cb887dce903adda" translate="yes" xml:space="preserve">
          <source>My approach encodes the entire board (16 entries) as a single 64-bit integer (where tiles are the nybbles, i.e. 4-bit chunks). On a 64-bit machine, this enables the entire board to be passed around in a single machine register.</source>
          <target state="translated">私のアプローチでは、ボード全体(16エントリ)を単一の64ビット整数(タイルはナイブル、つまり4ビットのチャンク)としてエンコードします。64ビットマシンでは、これによりボード全体を1つのマシンレジスタに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="ef5c72f488757b3c3972bc8a4c545658ae48db02" translate="yes" xml:space="preserve">
          <source>My attempt uses expectimax like other solutions above, but without bitboards. Nneonneo's solution can check 10millions of moves which is approximately a depth of 4 with 6 tiles left and 4 moves possible (2*6*4)&lt;sup&gt;4&lt;/sup&gt;. In my case, this depth takes too long to explore, I adjust the depth of expectimax search according to the number of free tiles left:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私の試みでは、上記の他のソリューションと同様にexpectimaxを使用していますが、ビットボードは使用していません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nneonneoのソリューションは、10ミリオンの動きをチェックできます。これは、約4の深さで、残りの6タイルと4動きが可能です（2 * 6 * 4）&lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私の場合、この深さを探索するには時間がかかりすぎるので、残っている空きタイルの数に応じてexpectimax検索の深さを調整します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="57e8410bf6b4571c6670e5f2ee8f617e934c4d80" translate="yes" xml:space="preserve">
          <source>My current algorithm:</source>
          <target state="translated">私の現在のアルゴリズム</target>
        </trans-unit>
        <trans-unit id="bea5caec78afaf43f0643aa15a7e4f0a707e1354" translate="yes" xml:space="preserve">
          <source>My implementation of the game slightly differs from the actual game, in that a new tile is always a '2' (rather than 90% 2 and 10% 4). And that the new tile is not random, but always the first available one from the top left. This variant is also known as &lt;a href=&quot;https://jmfork.github.io/2048/&quot;&gt;Det 2048&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私のゲームの実装は実際のゲームとは少し異なります。つまり、新しいタイルは常に「2」です（90％2および10％4ではありません）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして、新しいタイルはランダムではありませんが、常に左上から最初に利用可能なタイルです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このバリアントは、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://jmfork.github.io/2048/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Det 2048&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とも呼ばれ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d18c870dbfd8a43034e5e38c25648f6a00c617cb" translate="yes" xml:space="preserve">
          <source>Observation:</source>
          <target state="translated">Observation:</target>
        </trans-unit>
        <trans-unit id="1d445de243f043f2a68c63600c349cf26b114c50" translate="yes" xml:space="preserve">
          <source>One, I need to follow a well-defined strategy to reach the goal. So, I thought of writing a program for it.</source>
          <target state="translated">一つは、目標を達成するためには、明確に定められた戦略に従わなければならないということです。そこで、そのためのプログラムを書こうと考えました。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="640af8b8b4a6b17289c61d8f064089730a066c2e" translate="yes" xml:space="preserve">
          <source>Petr Mor&amp;aacute;vek (@xificurk) took my AI and added two new heuristics. The first heuristic was a penalty for having non-monotonic rows and columns which increased as the ranks increased, ensuring that  non-monotonic rows of small numbers would not strongly affect the score, but non-monotonic rows of large numbers hurt the score substantially. The second heuristic counted the number of potential merges (adjacent equal values) in addition to open spaces. These two heuristics served to push the algorithm towards monotonic boards (which are easier to merge), and towards board positions with lots of merges (encouraging it to align merges where possible for greater effect).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PetrMor&amp;aacute;vek（@xificurk）が私のAIを採用し、2つの新しいヒューリスティックを追加しました。最初のヒューリスティックは、ランクが増加するにつれて増加する非単調な行と列を持つペナルティであり、小さい数の非単調な行がスコアに強く影響しないことを保証しますが、大きい数の非単調な行はスコアに大きな影響を与えます。 2番目のヒューリスティックは、オープンスペースに加えて、潜在的なマージ（隣接する等しい値）の数をカウントしました。これらの2つのヒューリスティックは、アルゴリズムを単調なボード（マージがより簡単）に向けて、および多数のマージを含むボードの位置に向けて（効果を高めるために可能な限りマージを揃えることを推奨）機能しました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="503f6e600737ff2f29cf68701e034324b5731a1b" translate="yes" xml:space="preserve">
          <source>Please see the code below:</source>
          <target state="translated">下記のコードをご確認ください。</target>
        </trans-unit>
        <trans-unit id="6df2f58f408bc47f5e66563bfde9ff0172588105" translate="yes" xml:space="preserve">
          <source>Read the squares in the order shown above until the next squares value is greater than the current one. This presents the problem of trying to merge another tile of the same value into this square.</source>
          <target state="translated">次のマスの値が現在のマスの値よりも大きくなるまで、上の順番で読みます。この場合、同じ値の別のタイルをこのマスに結合しようとすると、問題が発生します。</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="33bfd3ccf12da33384e54b78f3b1b416cd79f5ee" translate="yes" xml:space="preserve">
          <source>Running 10000 runs with a temporary increase to 1000000 near critical positions managed to break this barrier less than 1% of the times achieving a max score of 129892 and the 8192 tile.</source>
          <target state="translated">重要な位置の近くで1000000への一時的な増加との10000の操業を実行することは129892および8192タイルの最大スコアを達成する回の1%以下この障壁を壊すことをどうにかして。</target>
        </trans-unit>
        <trans-unit id="f53aad58499a66a812ae2a8fadd0d52bc3c90c03" translate="yes" xml:space="preserve">
          <source>Scoring is also done using table lookup. The tables contain heuristic scores computed on all possible rows/columns, and the resultant score for a board is simply the sum of the table values across each row and column.</source>
          <target state="translated">スコアリングはテーブルルックアップを用いても行われる.テーブルには、可能なすべての行列に対して計算されたヒューリスティックなスコアが含まれており、結果として得られるボードのスコアは、各行と列のテーブル値の合計です。</target>
        </trans-unit>
        <trans-unit id="6f0d0289231f49f701b9b200b4a3eac54cedef68" translate="yes" xml:space="preserve">
          <source>Searching later I found this algorithm might be classified as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Monte-Carlo_tree_search#Pure_Monte_Carlo_game_search&quot;&gt;Pure Monte Carlo Tree Search&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;後で検索すると、このアルゴリズムは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Monte-Carlo_tree_search#Pure_Monte_Carlo_game_search&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;純粋なモンテカルロツリー検索&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アルゴリズムに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分類される可能性があることがわかりました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c6dc8c149cc76d5efe765ba938462b2a01c9d89" translate="yes" xml:space="preserve">
          <source>Second pointer, it has had bad luck and its main spot has been taken. It is likely that it will fail, but it can still achieve it:</source>
          <target state="translated">2番目のポインター、それは運が悪く、本命スポットを取られてしまいました。失敗する可能性が高いですが、達成することができます。</target>
        </trans-unit>
        <trans-unit id="f7bd04bc23d0d8eee5b56955d487fc2585d2855f" translate="yes" xml:space="preserve">
          <source>See it in action</source>
          <target state="translated">アクションで見る</target>
        </trans-unit>
        <trans-unit id="b6e3041754015cf5ce95b9217697dd1eafce96ab" translate="yes" xml:space="preserve">
          <source>Several heuristics are used to direct the optimization algorithm towards favorable positions. The precise choice of heuristic has a huge effect on the performance of the algorithm. The various heuristics are weighted and combined into a positional score, which determines how &quot;good&quot; a given board position is. The optimization search will then aim to maximize the average score of all possible board positions. The actual score, as shown by the game, is &lt;em&gt;not&lt;/em&gt; used to calculate the board score, since it is too heavily weighted in favor of merging tiles (when delayed merging could produce a large benefit).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最適化アルゴリズムを有利な位置に向けるために、いくつかのヒューリスティックが使用されます。ヒューリスティックの正確な選択は、アルゴリズムのパフォーマンスに大きな影響を与えます。さまざまなヒューリスティックが重み付けされ、位置スコアに結合されます。これにより、特定のボードポジションの「良さ」が決まります。次に、最適化検索は、可能なすべてのボード位置の平均スコアを最大化することを目指します。実際のスコアは、ゲームによって示されるように&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ボードスコアの計算には使用され&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ません。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、タイルをマージするために重み付けが高すぎるためです（マージの遅延により大きなメリットが得られる場合）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2318e6fc587a3fb272235edad6036fe0432bc136" translate="yes" xml:space="preserve">
          <source>Several linear path could be evaluated at once, the final score will be the maximum score of any path.</source>
          <target state="translated">複数の線形パスを一度に評価することができ、最終的なスコアは任意のパスの最大スコアとなります。</target>
        </trans-unit>
        <trans-unit id="c72dd283f25dc910b0a759e6f55e51f7b00e7039" translate="yes" xml:space="preserve">
          <source>Since the game is a discrete state space, perfect information, turn-based game like chess and checkers, I used the same methods that have been proven to work on those games, namely &lt;a href=&quot;http://www.flyingmachinestudios.com/programming/minimax/&quot;&gt;minimax&lt;/a&gt;&lt;a href=&quot;http://xkcd.com/832/&quot;&gt;search&lt;/a&gt; with &lt;a href=&quot;http://cs.ucla.edu/~rosen/161/notes/alphabeta.html&quot;&gt;alpha-beta pruning&lt;/a&gt;. Since there is already a lot of info on that algorithm out there, I'll just talk about the two main heuristics that I use in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_function&quot;&gt;static evaluation function&lt;/a&gt; and which formalize many of the intuitions that other people have expressed here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲームは離散状態空間、完全な情報、チェスやチェッカーなどのターンベースのゲームなので、これらのゲームで機能することが証明されているのと同じ方法、つまり&lt;/font&gt;&lt;a href=&quot;http://cs.ucla.edu/~rosen/161/notes/alphabeta.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アルファベータ剪定&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;による&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.flyingmachinestudios.com/programming/minimax/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ミニマックス&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;http://xkcd.com/832/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;検索を使用&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのアルゴリズムについてはすでに多くの情報があるので、&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;静的評価関数で&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用する2つの主なヒューリスティックについて説明&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します。これは、他の人々がここで表現した直観の多くを形式化しています。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e8fae6a7d3630d681d8de0ed1a7709b1c53526c" translate="yes" xml:space="preserve">
          <source>Smoothness</source>
          <target state="translated">Smoothness</target>
        </trans-unit>
        <trans-unit id="54e739c3c9f2519ccb923360ccad36f552ea579c" translate="yes" xml:space="preserve">
          <source>So it will press right, then right again, then (right or top depending on where the 4 has created) then will proceed to complete the chain until it gets:</source>
          <target state="translated">だからそれは右を押して、もう一度右を押して、その後(4が作成した場所に応じて右またはトップ)、それが取得するまでチェーンを完了するために進みます。</target>
        </trans-unit>
        <trans-unit id="5257bddfe2fa589fbea354e939d68bfb692b503b" translate="yes" xml:space="preserve">
          <source>So now the model and chain are back to:</source>
          <target state="translated">これでモデルとチェーンは元に戻りましたね。</target>
        </trans-unit>
        <trans-unit id="d7078edb0dd35daa33a7253a4d53d2a945faccd6" translate="yes" xml:space="preserve">
          <source>Source code can be found here: &lt;a href=&quot;https://github.com/popovitsj/2048-haskell&quot;&gt;https://github.com/popovitsj/2048-haskell&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ソースコードはここにあります：&lt;/font&gt;&lt;a href=&quot;https://github.com/popovitsj/2048-haskell&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//github.com/popovitsj/2048-haskell&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5347810276aac1267928f350b554c90eab90a356" translate="yes" xml:space="preserve">
          <source>Surprisingly, increasing the number of runs does not drastically improve the game play. There seems to be a limit to this strategy at around 80000 points with the 4096 tile and all the smaller ones, very close to the achieving the 8192 tile. Increasing the number of runs from 100 to 100000 increases the &lt;strong&gt;odds&lt;/strong&gt; of getting to this score limit (from 5% to 40%) but not breaking through it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;驚いたことに、実行回数を増やしても、ゲームプレイは大幅には改善されません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この戦略には、4096タイルとすべての小さいタイルで約80000ポイントの制限があり、8192タイルの達成に非常に近いようです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実行数を100から100000に増やすと、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このスコア制限（5％から40％）に到達する&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;確率&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;高くなりますが、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それを突破することはありません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d074ffd075253a11df5ddc58441a0bc90e0b8963" translate="yes" xml:space="preserve">
          <source>T1 - 121 tests - 8 different paths - r=0.125</source>
          <target state="translated">T1-121のテスト-8つの異なるパス-r=0.125</target>
        </trans-unit>
        <trans-unit id="dc6bff919d7f07511beebccbf002e3261f59cb65" translate="yes" xml:space="preserve">
          <source>T2 - 122 tests - 8-different paths - r=0.25</source>
          <target state="translated">T2-122のテスト-8つの異なるパス-r=0.25</target>
        </trans-unit>
        <trans-unit id="296be33c2b9427ee450731728dde4547f54e382a" translate="yes" xml:space="preserve">
          <source>T3 - 132 tests - 8-different paths - r=0.5</source>
          <target state="translated">T3-132回の試験-8つの異なるパス-r=0.5</target>
        </trans-unit>
        <trans-unit id="cc1b12f4c9d96129539fb80e7cdef31ccdf979f5" translate="yes" xml:space="preserve">
          <source>T4 - 211 tests - 2-different paths - r=0.125</source>
          <target state="translated">T4-211のテスト-2つの異なるパス-r=0.125</target>
        </trans-unit>
        <trans-unit id="e14691f69c083c98b5cb57561d0905750d23ecc3" translate="yes" xml:space="preserve">
          <source>T5 - 274 tests - 2-different paths - r=0.25</source>
          <target state="translated">T5-274回の試験-2つの異なるパス-r=0.25</target>
        </trans-unit>
        <trans-unit id="c4e6556dc89bf3c2350cf0f2df946297023854c7" translate="yes" xml:space="preserve">
          <source>T6 - 211 tests - 2-different paths - r=0.5</source>
          <target state="translated">T6-211回の検定-2つの異なるパス-r=0.5</target>
        </trans-unit>
        <trans-unit id="0c7d1cbd690845a24654fefbd0a09ba800d4230d" translate="yes" xml:space="preserve">
          <source>That the AI achieves the 32768 tile in over a third of its games is a huge milestone; I will be surprised to hear if any human players have achieved 32768 on the official game (i.e. without using tools like savestates or undo). I think the 65536 tile is within reach!</source>
          <target state="translated">AIが3分の1以上のゲームで32768を達成したというのは大きな節目である。65536牌は手の届くところにあると思います</target>
        </trans-unit>
        <trans-unit id="89cc096445275d0b61d3321d2f66e3dd178f9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O&lt;/code&gt; represent forbidden spaces...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;O&lt;/code&gt; は、&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;禁じられた空間を表現し...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c7dde9a3e75b8eeff3662608ec5b45fcb967f49" translate="yes" xml:space="preserve">
          <source>The AI in its default configuration (max search depth of 8) takes anywhere from 10ms to 200ms to execute a move, depending on the complexity of the board position. In testing, the AI achieves an average move rate of 5-10 moves per second over the course of an entire game. If the search depth is limited to 6 moves, the AI can easily execute 20+ moves per second, which makes for some &lt;a href=&quot;https://www.youtube.com/watch?v=96ab_dK6JM0&quot;&gt;interesting watching&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;デフォルトの構成（最大検索深度8）のAIは、ボード位置の複雑さに応じて、移動を実行するのに10ミリ秒から200ミリ秒かかります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;テストでは、AIはゲーム全体で1秒あたり5〜10回の平均移動速度を達成します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;検索深度が6移動に制限されている場合、AIは1秒あたり20以上の移動を簡単に実行できるため、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=96ab_dK6JM0&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;興味深いウォッチングが可能になり&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fb5e1a1c14a7f3f4df0734b1b830faeee1bc279" translate="yes" xml:space="preserve">
          <source>The above heuristic alone tends to create structures in which adjacent tiles are decreasing in value, but of course in order to merge, adjacent tiles need to be the same value. Therefore, the smoothness heuristic just measures the value difference between neighboring tiles, trying to minimize this count.</source>
          <target state="translated">上記のヒューリスティックだけでは、隣接するタイルの値が減少している構造を作る傾向がありますが、もちろんマージするためには、隣接するタイルは同じ値である必要があります。したがって、平滑性ヒューリスティックは、隣接するタイル間の値の差を測定するだけで、このカウントを最小化しようとします。</target>
        </trans-unit>
        <trans-unit id="a1da09880219429d0cbd02709fa5c5c73d1b6f56" translate="yes" xml:space="preserve">
          <source>The algorithm is iterative deepening depth first alpha-beta search. The evaluation function tries to keep the rows and columns monotonic (either all decreasing or increasing) while minimizing the number of tiles on the grid.</source>
          <target state="translated">アルゴリズムは反復的深化深化第一アルファベータ探索である。評価関数は、グリッド上のタイルの数を最小化しながら、行と列を単調(すべて減少または増加のいずれか)に維持しようとします。</target>
        </trans-unit>
        <trans-unit id="1ef77e56b4c80bec7704196088642b9d80e9917f" translate="yes" xml:space="preserve">
          <source>The assumption on which my algorithm is based is rather simple: if you want to achieve higher score, the board must be kept as tidy as possible. In particular, the optimal setup is given by a linear and monotonic decreasing order of the tile values.
This intuition will give you also the upper bound for a tile value:</source>
          <target state="translated">私のアルゴリズムがベースとしている前提は単純です:より高いスコアを達成したければ、ボードは可能な限り整頓されていなければなりません。特に、最適な設定は、タイルの値が線形で単調に減少する順序によって与えられます。この直感は、タイルの値の上限も与えてくれます。</target>
        </trans-unit>
        <trans-unit id="5dce83a7a7a2e8b3f3cbaad9c10d94bf6337d55b" translate="yes" xml:space="preserve">
          <source>The best achieved score is shown here:</source>
          <target state="translated">ここでは、最高の達成スコアを表示しています。</target>
        </trans-unit>
        <trans-unit id="25c8ed43b28e01eb6dd519d1d9bd47b6abbd3671" translate="yes" xml:space="preserve">
          <source>The chosen corner is arbitrary, you basically never press one key (the forbidden move), and if you do, you press the contrary again and try to fix it. For future tiles the model always expects the next random tile to be a 2 and appear on the opposite side to the current model (while the first row is incomplete, on the bottom right corner, once the first row is completed, on the bottom left corner).</source>
          <target state="translated">選ばれた角は任意で、基本的に1キー(禁手)は絶対に押さないし、押されたらまた逆を押して修正しようとする。将来の牌については、モデルは常に次のランダムな牌が2であることを期待し、現在のモデルとは反対側に現れる(1列目が不完全な間は右下の角に、1列目が不完全な間は左下の角に、1列目が不完全な間は左下の角に、1列目が不完全な間は右下の角に、1列目が不完全な間は左下の角に)。</target>
        </trans-unit>
        <trans-unit id="0d9103915dc08d03b8b554e741a0a622c2563f55" translate="yes" xml:space="preserve">
          <source>The code can be found on GiHub at the following link: &lt;a href=&quot;https://github.com/Nicola17/term2048-AI&quot;&gt;https://github.com/Nicola17/term2048-AI&lt;/a&gt;
It is based on &lt;a href=&quot;https://github.com/bfontaine/term2048&quot;&gt;term2048&lt;/a&gt; and it's written in Python. I will implement a more efficient version in C++ as soon as possible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コードは、次のリンクのGiHubにあります&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/Nicola17/term2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。https&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//github.com/Nicola17/term2048-AI&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; これは、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/bfontaine/term2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;term2048に&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基づいて&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;おり、Pythonで書かれています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;できるだけ早くC ++でより効率的なバージョンを実装します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30eb0aa61e89069340123d96861286e1d3a860a8" translate="yes" xml:space="preserve">
          <source>The controller uses expectimax search with a state evaluation function learned from scratch (without human 2048 expertise) by a variant of &lt;strong&gt;temporal difference learning&lt;/strong&gt; (a reinforcement learning technique). The state-value  function uses an &lt;strong&gt;n-tuple network&lt;/strong&gt;, which is basically a weighted linear function of patterns observed on the board. It involved more than &lt;strong&gt;1 billion weights&lt;/strong&gt;, in total.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コントローラーは、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;時間差学習&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（強化学習手法）の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;バリアントによってゼロから（人間2048の専門知識なしで）学習した状態評価関数を使用して、expectimax検索を使用し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;状態値関数は&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;nタプルネットワークを&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用し&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これは基本的に、ボード上で観察されるパターンの重み付き線形関数です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;合計で&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10億を&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;超える&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ウェイト&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が含まれていました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e8ea22403f787ccc54f78cea6ca391603d91a87" translate="yes" xml:space="preserve">
          <source>The decision rule implemented is not quite smart, the code in Python is presented here:</source>
          <target state="translated">実装されている決定ルールはかなりスマートではありませんが、Pythonでのコードを紹介します。</target>
        </trans-unit>
        <trans-unit id="176b0272d8eef889ba807dbf653b453ecd6067de" translate="yes" xml:space="preserve">
          <source>The effect of these changes are extremely significant. The algorithm went from achieving the 16384 tile around 13% of the time to achieving it over 90% of the time, and the algorithm began to achieve 32768 over 1/3 of the time (whereas the old heuristics never once produced a 32768 tile).</source>
          <target state="translated">これらの変更の効果は非常に大きい。アルゴリズムは時間の約13%の16384タイルを達成することから、時間の90%以上のそれを達成するようになり、アルゴリズムは時間の13以上の32768を達成し始めました(古いヒューリスティックスは一度も32768タイルを生成したことがないのに対し)。</target>
        </trans-unit>
        <trans-unit id="283d1c0d9684c8a42130b57edb6f6b92f5b86665" translate="yes" xml:space="preserve">
          <source>The expectimax search itself is coded as a recursive search which alternates between &quot;expectation&quot; steps (testing all possible tile spawn locations and values, and weighting their optimized scores by the probability of each possibility), and &quot;maximization&quot; steps (testing all possible moves and selecting the one with the best score). The tree search terminates when it sees a previously-seen position (using a &lt;a href=&quot;http://en.wikipedia.org/wiki/Transposition_table&quot;&gt;transposition table&lt;/a&gt;), when it reaches a predefined depth limit, or when it reaches a board state that is highly unlikely (e.g. it was reached by getting 6 &quot;4&quot; tiles in a row from the starting position). The typical search depth is 4-8 moves.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;expectimax検索自体は、「期待」ステップ（可能なすべてのタイルスポーンの場所と値をテストし、最適化されたスコアに各可能性の確率で重み付け）と「最大化」ステップ（すべての可能な動きをテスト）を交互に繰り返す再帰的検索としてコード化されます。そして、最高のスコアを持つものを選択します）。ツリー検索は、以前に表示された位置（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Transposition_table&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;転置テーブル&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）を確認したとき、事前定義された深さ制限に達したとき、または可能性が非常に低いボード状態に到達したときに終了します（たとえば、6 &quot;4&quot;タイルを取得して到達した場合）開始位置から続けて）。典型的な探索の深さは4-8手です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42f64f93fcb62fe61d13a7081dbd1385a6c16372" translate="yes" xml:space="preserve">
          <source>The following animation shows the last few steps of the game played where the AI player agent could get 2048 scores, this time adding the absolute value heuristic too:</source>
          <target state="translated">次のアニメーションは、AIプレイヤーのエージェントが2048点を獲得することができたゲームの最後の数ステップを示していますが、今回はヒューリスティックな絶対値も追加されています。</target>
        </trans-unit>
        <trans-unit id="83682c685d59111d019249a4364f16870be09cd8" translate="yes" xml:space="preserve">
          <source>The following figures show the &lt;strong&gt;game tree&lt;/strong&gt; explored by the player AI agent assuming the computer as adversary for just a single step:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次の図は、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プレーヤーのAIエージェントが、コンピュータを1つのステップで敵対的であると想定して探索し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;た&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲームツリーを&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;示して&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;います。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94d73024e25245de94e9edbd3aad5a30776360ec" translate="yes" xml:space="preserve">
          <source>The minimum score over all runs was 124024; the maximum score achieved was 794076. The median score is 387222. The AI never failed to obtain the 2048 tile (so it never lost the game even once in 100 games); in fact, it achieved the &lt;strong&gt;8192&lt;/strong&gt; tile at least once in every run!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべての実行での最小スコアは124024でした。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;達成された最大スコアは794076でした。スコアの中央値は387222です。AIが2048タイルの取得に失敗することはありませんでした（したがって、100ゲームに1回でもゲームが失われることはありません）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべての実行で少なくとも&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;8192&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;タイルを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;達成しました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c3427688b31e68bb54900072b17104508262705" translate="yes" xml:space="preserve">
          <source>The model has changed due to the luck of being closer to the expected model. The model the AI is trying to achieve is</source>
          <target state="translated">想定していたモデルに近づくという運の良さでモデルが変わった。AIが実現しようとしているモデルは</target>
        </trans-unit>
        <trans-unit id="1cdcb607ac22bbd92fb5b1889cdd98d3eecdba0a" translate="yes" xml:space="preserve">
          <source>The scores of the boards are computed with the weighted sum of the square of the number of free tiles and the dot product of the 2D grid with this:</source>
          <target state="translated">盤面の得点は、自由牌の数の二乗と、これを用いた二次元グリッドのドット積の加重和で計算される。</target>
        </trans-unit>
        <trans-unit id="ac8ac475f1d47ab38014e0ffd71fab5a7ebbc40c" translate="yes" xml:space="preserve">
          <source>The solution I propose is very simple and easy to implement. Although, it has reached the score of 131040. Several benchmarks of the algorithm performances are presented.</source>
          <target state="translated">私が提案するソリューションは非常にシンプルで簡単に実装できます。しかし、それは131040のスコアに達している。アルゴリズムの性能のいくつかのベンチマークが提示されています。</target>
        </trans-unit>
        <trans-unit id="cd5ada7eeaffca19f06bbf8ec2f5ee7d8e800c9d" translate="yes" xml:space="preserve">
          <source>The tile statistics for 10 moves/s are as follows:</source>
          <target state="translated">10手の牌の統計は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="0dcd0aa110a697c4c67a6487fafa9f7c0823aa9f" translate="yes" xml:space="preserve">
          <source>The whole approach will likely be more complicated than this but not much more complicated. It could be this mechanical in feel lacking scores, weights, neurones and deep searches of possibilities. The tree of possibilities rairly even needs to be big enough to need any branching at all.</source>
          <target state="translated">全体のアプローチは、おそらくこれよりも複雑になりますが、あまり複雑ではないでしょう。それは、スコア、重み、ニューロン、可能性の深い検索を欠いている感じでは、この機械的な可能性があります。可能性の木は、rairlyでさえ、すべてで任意の分岐を必要とするのに十分な大きさである必要があります。</target>
        </trans-unit>
        <trans-unit id="6d4d3599a34b6269908c672524220c522c3745c8" translate="yes" xml:space="preserve">
          <source>There is already an AI implementation for this game &lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;here&lt;/a&gt;. Excerpt from README:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このゲームのAI実装はすでに&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ovolve/2048-AI&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここにあります&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;READMEからの抜粋：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50c76a9fd12162abedcd5b1269d96e3a48779a24" translate="yes" xml:space="preserve">
          <source>There is also a discussion on &lt;a href=&quot;https://news.ycombinator.com/item?id=7379821&quot;&gt;Hacker News&lt;/a&gt; about this algorithm that you may find useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、このアルゴリズムについて有用な&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ディスカッションが&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=7379821&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hacker Newsに&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e3943b324acda39f3164ad45d89f210e302e253" translate="yes" xml:space="preserve">
          <source>This algorithm is not optimal for winning the game, but it is fairly optimal in terms of performance and amount of code needed:</source>
          <target state="translated">このアルゴリズムは、ゲームに勝つためには最適ではありませんが、性能と必要なコード量の点ではかなり最適です。</target>
        </trans-unit>
        <trans-unit id="81716cb6c61fa929b1da024c98b8e777682d352a" translate="yes" xml:space="preserve">
          <source>This board representation, along with the table lookup approach for movement and scoring, allows the AI to search a huge number of game states in a short period of time (over 10,000,000 game states per second on one core of my mid-2011 laptop).</source>
          <target state="translated">このボード表現は、移動とスコアリングのためのテーブルルックアップアプローチと一緒に、AIが短時間で膨大な数のゲームステートを検索することを可能にします(私の2011年半ばのラップトップの1つのコアで1秒間に1,000,000,000以上のゲームステートを検索します)。</target>
        </trans-unit>
        <trans-unit id="aab4a4bfd97ffe5030c2d295efd283014f0be653" translate="yes" xml:space="preserve">
          <source>This game took 27830 moves over 96 minutes, or an average of 4.8 moves per second.</source>
          <target state="translated">この対局は96分27830手、1秒間に平均4.8手をかけて行われました。</target>
        </trans-unit>
        <trans-unit id="1df55517328accd0f2dc6eb5550bd150b52fbce7" translate="yes" xml:space="preserve">
          <source>This graph illustrates this point: The blue line shows the board score after each move. The red line shows the algorithm's &lt;strong&gt;best&lt;/strong&gt; random-run end game score from that position. In essence, the red values are &quot;pulling&quot; the blue values upwards towards them, as they are the algorithm's best guess. It's interesting to see the red line is just a tiny bit above the blue line at each point, yet the blue line continues to increase more and more.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このグラフはこの点を示しています。青い線は、各移動後のボードのスコアを示しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;赤い線は、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その位置から&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のアルゴリズムの&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最高の&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ランダムラン終了ゲームのスコアを示しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本質的に、赤の値は青の値を上向きに「引き」、アルゴリズムの最良の推測であるためです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;赤い線が各点で青い線のほんの少し上にあるのは興味深いことですが、青い線はどんどん増え続けています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="15d9cef8b96ce070fccbc886d3f7a52230dd95c2" translate="yes" xml:space="preserve">
          <source>This heuristic tries to ensure that the values of the tiles are all either increasing or decreasing along both the left/right and up/down directions. This heuristic alone captures the intuition that many others have mentioned, that higher valued tiles should be clustered in a corner. It will typically prevent smaller valued tiles from getting orphaned and will keep the board very organized, with smaller tiles cascading in and filling up into the larger tiles.</source>
          <target state="translated">このヒューリスティックは、タイルの値が右下がりと右下がりの両方の方向に沿って増加または減少していることを確認しようとします。このヒューリスティックな方法だけで、他の多くの人が言及しているように、より価値の高い牌は隅に集まるべきだという直感を捉えています。これは、一般的に、より小さな価値のある牌が孤児になるのを防ぎ、より小さな牌が連鎖して大きな牌の中に埋まっていくことで、盤面を非常に整理した状態に保つことができます。</target>
        </trans-unit>
        <trans-unit id="f4404e8828677c74cccfa38f4bbfe1ae3bcfe6a7" translate="yes" xml:space="preserve">
          <source>This is a constant, used as a base-line and for other uses like testing.</source>
          <target state="translated">これは定数で、ベースラインとして使用され、テストのような他の用途にも使用されます。</target>
        </trans-unit>
        <trans-unit id="406c95c020f4c2dd5ee8b09f0713c82e19af3169" translate="yes" xml:space="preserve">
          <source>This is a simplified check of the possibility of having merges within that state, without making a look-ahead.</source>
          <target state="translated">先読みをせずに、その状態の中でマージがある可能性を簡易的にチェックしています。</target>
        </trans-unit>
        <trans-unit id="8131c0f0b0c2602cf4850dc23b1938260a7a7a9f" translate="yes" xml:space="preserve">
          <source>This is not a direct answer to OP's question, this is more of the stuffs (experiments) I tried so far to solve the same problem and obtained some results and have some observations that I want to share, I am curious if we can have some further insights from this.</source>
          <target state="translated">これはOPの質問への直接の答えではありませんが、これは私が同じ問題を解決するためにこれまでに試したもの(実験)の多くであり、いくつかの結果を得て、私は共有したいと思ういくつかの観察を持っている、私は好奇心を持っている我々はこれからいくつかのさらなる洞察力を持つことができれば。</target>
        </trans-unit>
        <trans-unit id="715df725c34a80cfb15f7cc31927abca202e48fb" translate="yes" xml:space="preserve">
          <source>This is possible due to domain-independent nature of the AI. Some of the variants are quite distinct, such as the Hexagonal clone.</source>
          <target state="translated">これは、AIのドメイン非依存性に起因する可能性がある。変種の中には、ヘキサゴナルクローンのようにかなり特徴的なものもあります。</target>
        </trans-unit>
        <trans-unit id="2b8637dd6b7d75e139a375a20969b654b1c6a3f0" translate="yes" xml:space="preserve">
          <source>This is the model I chose by default.</source>
          <target state="translated">デフォルトで選んだモデルです。</target>
        </trans-unit>
        <trans-unit id="2dae92fa8773f5d81d34a41b5ee59edb28a87186" translate="yes" xml:space="preserve">
          <source>Tile needs merging with neighbour but is too small: Merge another neighbour with this one.</source>
          <target state="translated">タイルは隣人との結合が必要だが小さすぎる:別の隣人とこのタイルを結合します。</target>
        </trans-unit>
        <trans-unit id="70b105f3079699e06f3a1ca29fc49029280f2f09" translate="yes" xml:space="preserve">
          <source>To assess the score performance of the AI, I ran the AI 100 times (connected to the browser game via remote control). For each tile, here are the proportions of games in which that tile was achieved at least once:</source>
          <target state="translated">AIのスコア性能を評価するために、AIを100回実行してみました(リモコンでブラウザゲームに接続)。各タイルについて、そのタイルが1回以上達成されたゲームの割合は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="562dbd4dd3fb3dd997d921a85e8dd207938296af" translate="yes" xml:space="preserve">
          <source>To enforce the ordination of the tiles in a monotonic decreasing order, the score si computed as the sum of the linearized values on the board multiplied by the values of a geometric sequence with common ratio r&amp;lt;1 .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;タイルの順序を単調な減少順に強制するために、スコアsiは、ボード上の線形化された値の合計に共通の比率r &amp;lt;1の幾何学的シーケンスの値を掛けたものとして計算されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1880862a60075224c2b8fdd3389edd49e7283e3" translate="yes" xml:space="preserve">
          <source>To resolve this problem, their are 2 ways to move that aren't left or worse up and examining both possibilities may immediately reveal more problems, this forms a list of dependancies, each problem requiring another problem to be solved first. I think I have this chain or in some cases tree of dependancies internally when deciding my next move, particularly when stuck.</source>
          <target state="translated">この問題を解決するために、彼らは左または悪いアップしていない移動する2つの方法があり、両方の可能性を検討すると、すぐに多くの問題を明らかにする可能性があります、これは依存関係のリストを形成し、それぞれの問題は、最初に解決するために別の問題を必要とする別の問題。私は、私の次の動きを決定するときに、特に立ち往生したとき、私は内部的にこのチェーンまたはいくつかのケースでは依存関係のツリーを持っていると思います。</target>
        </trans-unit>
        <trans-unit id="ab12b80b60d258a6dfc62b5818e8f4e339ef4aca" translate="yes" xml:space="preserve">
          <source>Two possible ways of organizing the board are shown in the following images:</source>
          <target state="translated">ボードの整理方法として考えられるのは、以下の画像のような2つです。</target>
        </trans-unit>
        <trans-unit id="ffc914498a4f81efe7ad50334ca89a25026fc42b" translate="yes" xml:space="preserve">
          <source>What I am doing is at any point, I will try to merge the tiles with values &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;, that is, I try to have &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; tiles, as minimum as possible. If I try it this way, all other tiles were automatically getting merged and the strategy seems good.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私がやっていることは、いつでも、タイルを値&lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にマージしようとする&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことです。つまり、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;4&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;タイルを最小限&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にしようとして&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;います。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この方法で試してみると、他のすべてのタイルが自動的にマージされていて、戦略は良いようです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0fe3580da7385572383dcfbcbfc67535e4972c3" translate="yes" xml:space="preserve">
          <source>What is the optimal algorithm for the game 2048</source>
          <target state="translated">2048年ゲームの最適アルゴリズムは?</target>
        </trans-unit>
        <trans-unit id="7a2cd96c88d22411489171dc415feea04edc93dc" translate="yes" xml:space="preserve">
          <source>When it manages to reach the 128 it gains a whole row is gained again:</source>
          <target state="translated">それが128に達することを管理するとき、それは全体の行が再び得られます。</target>
        </trans-unit>
        <trans-unit id="6cc2b46a0e2f9ee01b185acf82165706e2b0b69b" translate="yes" xml:space="preserve">
          <source>With just 100 runs (i.e in memory games) per move, the AI achieves the 2048 tile 80% of the times and the 4096 tile 50% of the times. Using 10000 runs gets the 2048 tile 100%, 70% for 4096 tile, and about 1% for the 8192 tile.</source>
          <target state="translated">1手あたり100回(メモリーゲームの場合)の実行で、AIは2048タイルの80%、4096タイルの50%を達成します。10000回の実行で2048タイルが100%、4096タイルが70%、8192タイルが約1%となります。</target>
        </trans-unit>
        <trans-unit id="c3d1302c4890b9aa4694541642695d87a0b4b7ed" translate="yes" xml:space="preserve">
          <source>Yes, that's a 4096 alongside a 2048. =) That means it achieved the elusive 2048 tile three times on the same board.</source>
          <target state="translated">そう、2048と並んで4096です。)つまり、同じ盤面で3回も2048を達成したということだ。</target>
        </trans-unit>
        <trans-unit id="b44092dddcd4f744019f7228202fb6783f53c989" translate="yes" xml:space="preserve">
          <source>You can try the AI for yourself. The code is available at &lt;a href=&quot;https://github.com/nneonneo/2048-ai&quot;&gt;https://github.com/nneonneo/2048-ai&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AIを自分で試すことができます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コードは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/nneonneo/2048-ai&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/nneonneo/2048-ai&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で入手でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59ac2882d7af09f5c4e2a1c7e5c5bb0dcad83a76" translate="yes" xml:space="preserve">
          <source>code below or on &lt;a href=&quot;https://caub.github.io/misc/2048&quot;&gt;github&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下または&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://caub.github.io/misc/2048&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;githubの&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コード&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e9b496a0935b15e72709835275b0a4dd4c2a1c6" translate="yes" xml:space="preserve">
          <source>etc...</source>
          <target state="translated">etc...</target>
        </trans-unit>
        <trans-unit id="d8bd5af9109e98c522a44467b14c0ac230bbc8ca" translate="yes" xml:space="preserve">
          <source>where n is the number of tile on the board.</source>
          <target state="translated">ここで、nは盤面上のタイルの数である。</target>
        </trans-unit>
        <trans-unit id="f550c4f98092fb346941c9ffac4b20ee0d6c58a1" translate="yes" xml:space="preserve">
          <source>which forces to organize tiles descendingly in a sort of snake from the top left tile.</source>
          <target state="translated">これは、左上のタイルから蛇のように下降していくタイルを強制的に整理するものです。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
