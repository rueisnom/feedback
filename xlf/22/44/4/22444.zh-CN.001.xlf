<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/22444">
    <body>
      <group id="22444">
        <trans-unit id="dec62beea796b93e961fd26843e4f12545dcd801" translate="yes" xml:space="preserve">
          <source>(Project name:\s+[A-Z]:(?:\\w+)+.[a-zA-Z]+\s+J[0-9]{7})(?=:)</source>
          <target state="translated">(项目名称:\s+[A-Z]:(?)+.[a-zA-ZA-Z]+s+J[0-9]{7})(?=:)</target>
        </trans-unit>
        <trans-unit id="d74358649090f184688e9436caba0929745dfa76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\S&lt;/code&gt; means &amp;ldquo;everything except a whitespace and this is exactly what you want.</source>
          <target state="translated">&lt;code&gt;\S&lt;/code&gt; 表示&amp;ldquo;除空格以外的所有内容，这正是您想要的。</target>
        </trans-unit>
        <trans-unit id="1a22048ad80c3f36c944b4c6969e1305292d5ede" translate="yes" xml:space="preserve">
          <source>Adding (?:\\w+)+.[a-zA-Z]+ will be more restrictive instead of .*</source>
          <target state="translated">添加(?:\w+)+.[a-zA-Z-Z]+将更具限制性,而不是.*。</target>
        </trans-unit>
        <trans-unit id="f96cb3981f13999823660dd7e13db3854f62fd42" translate="yes" xml:space="preserve">
          <source>Available for download at their site:
&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;http://www.ultrapico.com/Expresso.htm&lt;/a&gt;</source>
          <target state="translated">可在其站点上下载： &lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;http&lt;/a&gt; : //www.ultrapico.com/Expresso.htm</target>
        </trans-unit>
        <trans-unit id="0819a57fa2ce95f4f7ef948ace1c68f4119a4053" translate="yes" xml:space="preserve">
          <source>Express download:
&lt;a href=&quot;http://www.ultrapico.com/ExpressoDownload.htm&quot;&gt;http://www.ultrapico.com/ExpressoDownload.htm&lt;/a&gt;</source>
          <target state="translated">快速下载： &lt;a href=&quot;http://www.ultrapico.com/ExpressoDownload.htm&quot;&gt;http&lt;/a&gt; : //www.ultrapico.com/ExpressoDownload.htm</target>
        </trans-unit>
        <trans-unit id="b4d4474f901ea72bb6048b19bc68daf660d2062c" translate="yes" xml:space="preserve">
          <source>For example, when building your regex using the UI, and choosing &quot;*&quot;, you have the ability to check the checkbox &quot;As few as possible&quot; and see the resulting regex, as well as test its behavior, even if you were unfamiliar with non-greedy expressions before.</source>
          <target state="translated">例如,当使用UI构建你的regex时,选择 &quot;*&quot;时,你可以勾选 &quot;尽可能少的&quot;,看到生成的regex,也可以测试它的行为,即使你之前不熟悉非greedy表达式,也可以测试它的行为。</target>
        </trans-unit>
        <trans-unit id="c6dc17ec3338126b029bb4467dc4a5b0c733e160" translate="yes" xml:space="preserve">
          <source>Here's the regex I've been playing with</source>
          <target state="translated">这是我一直在玩的gex格式</target>
        </trans-unit>
        <trans-unit id="25b7ae5bda2bb5646615f024476878fbc1e11ba9" translate="yes" xml:space="preserve">
          <source>Here's what I used. &lt;code&gt;s&lt;/code&gt; contains your original string. This code is .NET specific, but most flavors of regex will have something similar.</source>
          <target state="translated">这是我用的。 &lt;code&gt;s&lt;/code&gt; 包含您的原始字符串。 这段代码是.NET特有的，但是大多数正则表达式都具有类似的功能。</target>
        </trans-unit>
        <trans-unit id="fa0d0e5f0dcd95cd2394c04d0dd750558e07c207" translate="yes" xml:space="preserve">
          <source>How do I make the regex stop at the first occurrence of &lt;code&gt;J[0-9]{7}&lt;/code&gt;?</source>
          <target state="translated">如何使正则表达式在 &lt;code&gt;J[0-9]{7}&lt;/code&gt; 的首次出现时停止？</target>
        </trans-unit>
        <trans-unit id="2476709c17310e52137aa1cc47d9521a8ec9af1f" translate="yes" xml:space="preserve">
          <source>However, consider using a negative character class instead:</source>
          <target state="translated">不过,可以考虑用负面角色类来代替。</target>
        </trans-unit>
        <trans-unit id="e8182e7a74ca90848e396968128840af8ff50330" translate="yes" xml:space="preserve">
          <source>I have this gigantic ugly string and I'm trying to extract pieces from it using regex. In this case, I want to grab everything after &quot;Project Name&quot; up to the part where it says &quot;J0000011:&quot; (the 11 is going to be a different number every time).</source>
          <target state="translated">我有一个巨大的丑陋的字符串,我试图用regex提取其中的部分。在这种情况下,我想抓取 &quot;项目名称 &quot;之后的所有内容,直到它写着 &quot;J0000011:&quot;的那部分(11每次都是不同的数字)。</target>
        </trans-unit>
        <trans-unit id="3ffdb82847dbfa2d59c1f0a1cbce7cec5863bca1" translate="yes" xml:space="preserve">
          <source>I would also recommend you experiment with regular expressions using &quot;Expresso&quot; - it's a utility a great (and free) utility for regex editing and testing.</source>
          <target state="translated">我也建议你使用 &quot;Expresso &quot;来尝试使用正则表达式--这是一个用于regex编辑和测试的一个很好的(也是免费的)工具。</target>
        </trans-unit>
        <trans-unit id="6846de25786ac85bdcf55d989f13d12d704b9c5e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;.*&lt;/code&gt; non-greedy by adding '&lt;code&gt;?&lt;/code&gt;' after it:</source>
          <target state="translated">通过添加' &lt;code&gt;?&lt;/code&gt; 使 &lt;code&gt;.*&lt;/code&gt; 不贪心。 '之后：</target>
        </trans-unit>
        <trans-unit id="4614b7d813b6577e56143c1d13fdce32e59ecd47" translate="yes" xml:space="preserve">
          <source>My regex is matching too much. How do I make it stop</source>
          <target state="translated">我的regex匹配太多。我该怎么做才能让它停止呢?</target>
        </trans-unit>
        <trans-unit id="a37930a0a0dbd048cb64cfd2f01bee038a3c4efb" translate="yes" xml:space="preserve">
          <source>One of its upsides is that its UI exposes a lot of regex functionality that people unexprienced with regex might not be familiar with, in a way that it would be easy for them to learn these new concepts.</source>
          <target state="translated">它的一个优点是,它的用户界面暴露了很多不熟悉regex的人可能不熟悉的regex功能,让他们很容易学习这些新概念。</target>
        </trans-unit>
        <trans-unit id="8b1564b92aeae9365fa6d7b721259bac515f612a" translate="yes" xml:space="preserve">
          <source>The problem is that it doesn't stop until it hits the &lt;strong&gt;J0000020:&lt;/strong&gt; at the end.</source>
          <target state="translated">问题在于，它直到击中&lt;strong&gt;J0000020&lt;/strong&gt;才停止。</target>
        </trans-unit>
        <trans-unit id="7ee02ddff9a21ceb84aa0fdbdf0b08ea2d88858d" translate="yes" xml:space="preserve">
          <source>This will work for you.</source>
          <target state="translated">这对你来说会有效果的。</target>
        </trans-unit>
        <trans-unit id="b50caa0655c0017769d1e76767cc9307fa184451" translate="yes" xml:space="preserve">
          <source>Using non-greedy quantifiers here is probably the best solution, also because it is more efficient than the greedy alternative: Greedy matches generally go as far as they can (here, until the end of the text!) and then trace back character after character to try and match the part coming afterwards.</source>
          <target state="translated">在这里使用非贪婪的量化器可能是最好的解决方案,这也是因为它比贪婪的替代方案更有效率。贪婪的匹配一般都是尽可能多地进行匹配(在这里,直到文本的结尾!),然后回溯一个又一个字符,试图匹配后面的部分。</target>
        </trans-unit>
        <trans-unit id="b26ab1ae34128cc80aad47f0821d813cf120cb31" translate="yes" xml:space="preserve">
          <source>Well, &lt;code&gt;&quot;.*&quot;&lt;/code&gt; is a greedy selector. You make it non-greedy by using &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; When using the latter construct, the regex engine will, at every step it matches text into the &lt;code&gt;&quot;.&quot;&lt;/code&gt; attempt to match whatever make come after the &lt;code&gt;&quot;.*?&quot;&lt;/code&gt;. This means that if for instance nothing comes after the &lt;code&gt;&quot;.*?&quot;&lt;/code&gt;, then it matches nothing.</source>
          <target state="translated">好吧， &lt;code&gt;&quot;.*&quot;&lt;/code&gt; 是一个贪婪的选择器。 您通过使用 &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; 使其变得非贪婪。 使用后一种构造时，正则表达式引擎将在每一步将文本匹配到 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 尝试匹配 &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; 之后的任何品牌。 。 这意味着，例如，如果 &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; 之后没有任何内容 ，那么它什么都不匹配。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
