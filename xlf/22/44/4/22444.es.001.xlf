<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/22444">
    <body>
      <group id="22444">
        <trans-unit id="dec62beea796b93e961fd26843e4f12545dcd801" translate="yes" xml:space="preserve">
          <source>(Project name:\s+[A-Z]:(?:\\w+)+.[a-zA-Z]+\s+J[0-9]{7})(?=:)</source>
          <target state="translated">(Nombre del proyecto:\s+[A-Z]:(?:\w+)+.[a-zA-Z]+\s+J[0-9]{7})(?=:)</target>
        </trans-unit>
        <trans-unit id="d74358649090f184688e9436caba0929745dfa76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\S&lt;/code&gt; means &amp;ldquo;everything except a whitespace and this is exactly what you want.</source>
          <target state="translated">&lt;code&gt;\S&lt;/code&gt; significa &quot;todo excepto un espacio en blanco y esto es exactamente lo que quieres.</target>
        </trans-unit>
        <trans-unit id="1a22048ad80c3f36c944b4c6969e1305292d5ede" translate="yes" xml:space="preserve">
          <source>Adding (?:\\w+)+.[a-zA-Z]+ will be more restrictive instead of .*</source>
          <target state="translated">Añadiendo (?:\w+)+.[a-zA-Z]+será más restrictivo en lugar de .*</target>
        </trans-unit>
        <trans-unit id="f96cb3981f13999823660dd7e13db3854f62fd42" translate="yes" xml:space="preserve">
          <source>Available for download at their site:
&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;http://www.ultrapico.com/Expresso.htm&lt;/a&gt;</source>
          <target state="translated">Disponible para descargar en su sitio: &lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;http://www.ultrapico.com/Expresso.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0819a57fa2ce95f4f7ef948ace1c68f4119a4053" translate="yes" xml:space="preserve">
          <source>Express download:
&lt;a href=&quot;http://www.ultrapico.com/ExpressoDownload.htm&quot;&gt;http://www.ultrapico.com/ExpressoDownload.htm&lt;/a&gt;</source>
          <target state="translated">Descarga expr&amp;eacute;s: &lt;a href=&quot;http://www.ultrapico.com/ExpressoDownload.htm&quot;&gt;http://www.ultrapico.com/ExpressoDownload.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4d4474f901ea72bb6048b19bc68daf660d2062c" translate="yes" xml:space="preserve">
          <source>For example, when building your regex using the UI, and choosing &quot;*&quot;, you have the ability to check the checkbox &quot;As few as possible&quot; and see the resulting regex, as well as test its behavior, even if you were unfamiliar with non-greedy expressions before.</source>
          <target state="translated">Por ejemplo,cuando construyes tu regex usando la interfaz de usuario,y eligiendo &quot;*&quot;,tienes la posibilidad de marcar la casilla &quot;El menor número posible&quot; y ver el regex resultante,así como probar su comportamiento,incluso si antes no estabas familiarizado con las expresiones no gordas.</target>
        </trans-unit>
        <trans-unit id="c6dc17ec3338126b029bb4467dc4a5b0c733e160" translate="yes" xml:space="preserve">
          <source>Here's the regex I've been playing with</source>
          <target state="translated">Aquí está el regex con el que he estado jugando...</target>
        </trans-unit>
        <trans-unit id="25b7ae5bda2bb5646615f024476878fbc1e11ba9" translate="yes" xml:space="preserve">
          <source>Here's what I used. &lt;code&gt;s&lt;/code&gt; contains your original string. This code is .NET specific, but most flavors of regex will have something similar.</source>
          <target state="translated">Esto es lo que us&amp;eacute;. &lt;code&gt;s&lt;/code&gt; contiene su cadena original. Este c&amp;oacute;digo es espec&amp;iacute;fico de .NET, pero la mayor&amp;iacute;a de los sabores de expresiones regulares tendr&amp;aacute;n algo similar.</target>
        </trans-unit>
        <trans-unit id="fa0d0e5f0dcd95cd2394c04d0dd750558e07c207" translate="yes" xml:space="preserve">
          <source>How do I make the regex stop at the first occurrence of &lt;code&gt;J[0-9]{7}&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo hago que la expresi&amp;oacute;n regular se detenga en la primera aparici&amp;oacute;n de &lt;code&gt;J[0-9]{7}&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="2476709c17310e52137aa1cc47d9521a8ec9af1f" translate="yes" xml:space="preserve">
          <source>However, consider using a negative character class instead:</source>
          <target state="translated">Sin embargo,considere la posibilidad de utilizar una clase de carácter negativo en su lugar:</target>
        </trans-unit>
        <trans-unit id="e8182e7a74ca90848e396968128840af8ff50330" translate="yes" xml:space="preserve">
          <source>I have this gigantic ugly string and I'm trying to extract pieces from it using regex. In this case, I want to grab everything after &quot;Project Name&quot; up to the part where it says &quot;J0000011:&quot; (the 11 is going to be a different number every time).</source>
          <target state="translated">Tengo esta gigantesca y fea cuerda y estoy tratando de extraer piezas de ella usando regex.En este caso,quiero agarrar todo lo que hay después de &quot;Nombre del proyecto&quot; hasta la parte donde dice &quot;J0000011:&quot; (el 11 va a ser un número diferente cada vez).</target>
        </trans-unit>
        <trans-unit id="3ffdb82847dbfa2d59c1f0a1cbce7cec5863bca1" translate="yes" xml:space="preserve">
          <source>I would also recommend you experiment with regular expressions using &quot;Expresso&quot; - it's a utility a great (and free) utility for regex editing and testing.</source>
          <target state="translated">También te recomendaría que experimentes con expresiones regulares usando &quot;Expresso&quot;-es una utilidad una gran (y gratuita)utilidad para la edición y prueba de regex.</target>
        </trans-unit>
        <trans-unit id="6846de25786ac85bdcf55d989f13d12d704b9c5e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;.*&lt;/code&gt; non-greedy by adding '&lt;code&gt;?&lt;/code&gt;' after it:</source>
          <target state="translated">Make &lt;code&gt;.*&lt;/code&gt; No codicioso agregando ' &lt;code&gt;?&lt;/code&gt; ' despu&amp;eacute;s de:</target>
        </trans-unit>
        <trans-unit id="4614b7d813b6577e56143c1d13fdce32e59ecd47" translate="yes" xml:space="preserve">
          <source>My regex is matching too much. How do I make it stop</source>
          <target state="translated">Mi regex es demasiado compatible.¿Cómo hago para que se detenga</target>
        </trans-unit>
        <trans-unit id="a37930a0a0dbd048cb64cfd2f01bee038a3c4efb" translate="yes" xml:space="preserve">
          <source>One of its upsides is that its UI exposes a lot of regex functionality that people unexprienced with regex might not be familiar with, in a way that it would be easy for them to learn these new concepts.</source>
          <target state="translated">Una de sus ventajas es que su interfaz de usuario expone una gran cantidad de funcionalidad de regex con la que la gente no experimentada con regex podría no estar familiarizada,de manera que les sería fácil aprender estos nuevos conceptos.</target>
        </trans-unit>
        <trans-unit id="8b1564b92aeae9365fa6d7b721259bac515f612a" translate="yes" xml:space="preserve">
          <source>The problem is that it doesn't stop until it hits the &lt;strong&gt;J0000020:&lt;/strong&gt; at the end.</source>
          <target state="translated">El problema es que no se detiene hasta que llega al &lt;strong&gt;J0000020:&lt;/strong&gt; al final.</target>
        </trans-unit>
        <trans-unit id="7ee02ddff9a21ceb84aa0fdbdf0b08ea2d88858d" translate="yes" xml:space="preserve">
          <source>This will work for you.</source>
          <target state="translated">Esto funcionará para ti.</target>
        </trans-unit>
        <trans-unit id="b50caa0655c0017769d1e76767cc9307fa184451" translate="yes" xml:space="preserve">
          <source>Using non-greedy quantifiers here is probably the best solution, also because it is more efficient than the greedy alternative: Greedy matches generally go as far as they can (here, until the end of the text!) and then trace back character after character to try and match the part coming afterwards.</source>
          <target state="translated">El uso de cuantificadores no codiciosos aquí es probablemente la mejor solución,también porque es más eficiente que la alternativa codiciosa:Las parejas codiciosas generalmente van tan lejos como pueden (aquí,hasta el final del texto!)y luego remontan carácter tras carácter para tratar de coincidir con la parte que viene después.</target>
        </trans-unit>
        <trans-unit id="b26ab1ae34128cc80aad47f0821d813cf120cb31" translate="yes" xml:space="preserve">
          <source>Well, &lt;code&gt;&quot;.*&quot;&lt;/code&gt; is a greedy selector. You make it non-greedy by using &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; When using the latter construct, the regex engine will, at every step it matches text into the &lt;code&gt;&quot;.&quot;&lt;/code&gt; attempt to match whatever make come after the &lt;code&gt;&quot;.*?&quot;&lt;/code&gt;. This means that if for instance nothing comes after the &lt;code&gt;&quot;.*?&quot;&lt;/code&gt;, then it matches nothing.</source>
          <target state="translated">Bueno, &lt;code&gt;&quot;.*&quot;&lt;/code&gt; Es un selector codicioso. Lo haces no codicioso usando &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; Cuando se utiliza la &amp;uacute;ltima construcci&amp;oacute;n, el motor regex, en cada paso, hace coincidir el texto con el &lt;code&gt;&quot;.&quot;&lt;/code&gt; intenta hacer coincidir cualquier marca que venga despu&amp;eacute;s del &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; . Esto significa que si, por ejemplo, nada viene despu&amp;eacute;s de &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; , entonces no coincide con nada.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
