<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/22444">
    <body>
      <group id="22444">
        <trans-unit id="dec62beea796b93e961fd26843e4f12545dcd801" translate="yes" xml:space="preserve">
          <source>(Project name:\s+[A-Z]:(?:\\w+)+.[a-zA-Z]+\s+J[0-9]{7})(?=:)</source>
          <target state="translated">(프로젝트 이름 : \ s + [AZ] : (? : \\ w +) +. [a-zA-Z] + \ s + J [0-9] {7}) (? = :)</target>
        </trans-unit>
        <trans-unit id="d74358649090f184688e9436caba0929745dfa76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\S&lt;/code&gt; means &amp;ldquo;everything except a whitespace and this is exactly what you want.</source>
          <target state="translated">&lt;code&gt;\S&lt;/code&gt; 는&amp;ldquo;공백을 제외한 모든 것을 의미하며 이것이 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a22048ad80c3f36c944b4c6969e1305292d5ede" translate="yes" xml:space="preserve">
          <source>Adding (?:\\w+)+.[a-zA-Z]+ will be more restrictive instead of .*</source>
          <target state="translated">(? : \\ w +) +. [a-zA-Z] +를 추가하면. * 대신 더 제한적입니다. *</target>
        </trans-unit>
        <trans-unit id="f96cb3981f13999823660dd7e13db3854f62fd42" translate="yes" xml:space="preserve">
          <source>Available for download at their site:
&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;http://www.ultrapico.com/Expresso.htm&lt;/a&gt;</source>
          <target state="translated">해당 사이트에서 다운로드 할 수 있습니다 : &lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;http://www.ultrapico.com/Expresso.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0819a57fa2ce95f4f7ef948ace1c68f4119a4053" translate="yes" xml:space="preserve">
          <source>Express download:
&lt;a href=&quot;http://www.ultrapico.com/ExpressoDownload.htm&quot;&gt;http://www.ultrapico.com/ExpressoDownload.htm&lt;/a&gt;</source>
          <target state="translated">빠른 다운로드 : &lt;a href=&quot;http://www.ultrapico.com/ExpressoDownload.htm&quot;&gt;http://www.ultrapico.com/ExpressoDownload.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4d4474f901ea72bb6048b19bc68daf660d2062c" translate="yes" xml:space="preserve">
          <source>For example, when building your regex using the UI, and choosing &quot;*&quot;, you have the ability to check the checkbox &quot;As few as possible&quot; and see the resulting regex, as well as test its behavior, even if you were unfamiliar with non-greedy expressions before.</source>
          <target state="translated">예를 들어, UI를 사용하여 정규 표현식을 작성하고 &quot;*&quot;를 선택하면 &quot;가능한 한 적은&quot;확인란을 선택하고 결과 정규 표현식을 확인하고 익숙하지 않은 경우에도 해당 동작을 테스트 할 수 있습니다. 욕심없는 표현.</target>
        </trans-unit>
        <trans-unit id="c6dc17ec3338126b029bb4467dc4a5b0c733e160" translate="yes" xml:space="preserve">
          <source>Here's the regex I've been playing with</source>
          <target state="translated">내가 놀고있는 정규식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25b7ae5bda2bb5646615f024476878fbc1e11ba9" translate="yes" xml:space="preserve">
          <source>Here's what I used. &lt;code&gt;s&lt;/code&gt; contains your original string. This code is .NET specific, but most flavors of regex will have something similar.</source>
          <target state="translated">여기 내가 사용한 것이 있습니다. &lt;code&gt;s&lt;/code&gt; 는 원래 문자열을 포함합니다. 이 코드는 .NET 전용이지만 대부분의 정규 표현식에는 비슷한 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0d0e5f0dcd95cd2394c04d0dd750558e07c207" translate="yes" xml:space="preserve">
          <source>How do I make the regex stop at the first occurrence of &lt;code&gt;J[0-9]{7}&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;J[0-9]{7}&lt;/code&gt; 이 처음 나타날 때 정규 표현식을 중지하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2476709c17310e52137aa1cc47d9521a8ec9af1f" translate="yes" xml:space="preserve">
          <source>However, consider using a negative character class instead:</source>
          <target state="translated">그러나 대신 부정적인 문자 클래스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e8182e7a74ca90848e396968128840af8ff50330" translate="yes" xml:space="preserve">
          <source>I have this gigantic ugly string and I'm trying to extract pieces from it using regex. In this case, I want to grab everything after &quot;Project Name&quot; up to the part where it says &quot;J0000011:&quot; (the 11 is going to be a different number every time).</source>
          <target state="translated">나는이 거대한 못생긴 끈을 가지고 있으며 정규 표현식을 사용하여 조각을 추출하려고합니다. 이 경우 &quot;Project Name&quot;다음의 모든 항목을 &quot;J0000011 :&quot;(11은 매번 다른 숫자가 됨) 부분으로 가져갑니다.</target>
        </trans-unit>
        <trans-unit id="3ffdb82847dbfa2d59c1f0a1cbce7cec5863bca1" translate="yes" xml:space="preserve">
          <source>I would also recommend you experiment with regular expressions using &quot;Expresso&quot; - it's a utility a great (and free) utility for regex editing and testing.</source>
          <target state="translated">또한 &quot;Expresso&quot;를 사용하여 정규 표현식을 실험 해 보는 것이 좋습니다. 정규식 편집 및 테스트를위한 훌륭한 (무료) 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="6846de25786ac85bdcf55d989f13d12d704b9c5e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;.*&lt;/code&gt; non-greedy by adding '&lt;code&gt;?&lt;/code&gt;' after it:</source>
          <target state="translated">' &lt;code&gt;?&lt;/code&gt; 를 추가하여 &lt;code&gt;.*&lt;/code&gt; 를 욕심하지 않게 만드십시오 . '후 :</target>
        </trans-unit>
        <trans-unit id="4614b7d813b6577e56143c1d13fdce32e59ecd47" translate="yes" xml:space="preserve">
          <source>My regex is matching too much. How do I make it stop</source>
          <target state="translated">정규식이 너무 일치합니다. 어떻게 멈추게합니까</target>
        </trans-unit>
        <trans-unit id="a37930a0a0dbd048cb64cfd2f01bee038a3c4efb" translate="yes" xml:space="preserve">
          <source>One of its upsides is that its UI exposes a lot of regex functionality that people unexprienced with regex might not be familiar with, in a way that it would be easy for them to learn these new concepts.</source>
          <target state="translated">그 단점 중 하나는 UI에 정규식에 익숙하지 않은 사람들이 익숙하지 않은 많은 정규식 기능을 노출하여 새로운 개념을 쉽게 익힐 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8b1564b92aeae9365fa6d7b721259bac515f612a" translate="yes" xml:space="preserve">
          <source>The problem is that it doesn't stop until it hits the &lt;strong&gt;J0000020:&lt;/strong&gt; at the end.</source>
          <target state="translated">문제는 &lt;strong&gt;J0000020에 도달&lt;/strong&gt; 할 때까지 멈추지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ee02ddff9a21ceb84aa0fdbdf0b08ea2d88858d" translate="yes" xml:space="preserve">
          <source>This will work for you.</source>
          <target state="translated">이것은 당신을 위해 일할 것입니다.</target>
        </trans-unit>
        <trans-unit id="b50caa0655c0017769d1e76767cc9307fa184451" translate="yes" xml:space="preserve">
          <source>Using non-greedy quantifiers here is probably the best solution, also because it is more efficient than the greedy alternative: Greedy matches generally go as far as they can (here, until the end of the text!) and then trace back character after character to try and match the part coming afterwards.</source>
          <target state="translated">욕심 많은 대안을 사용하는 것이 욕심 많은 대안보다 효율적이기 때문에 여기에 욕심없는 정량자를 사용하는 것이 가장 좋은 해결책 일 것입니다. 나중에 오는 부분을 시도하고 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="b26ab1ae34128cc80aad47f0821d813cf120cb31" translate="yes" xml:space="preserve">
          <source>Well, &lt;code&gt;&quot;.*&quot;&lt;/code&gt; is a greedy selector. You make it non-greedy by using &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; When using the latter construct, the regex engine will, at every step it matches text into the &lt;code&gt;&quot;.&quot;&lt;/code&gt; attempt to match whatever make come after the &lt;code&gt;&quot;.*?&quot;&lt;/code&gt;. This means that if for instance nothing comes after the &lt;code&gt;&quot;.*?&quot;&lt;/code&gt;, then it matches nothing.</source>
          <target state="translated">&lt;code&gt;&quot;.*&quot;&lt;/code&gt; 는 탐욕스러운 선택기입니다. &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; 를 사용하여 탐욕스럽지 않게 만듭니다 . 후자의 구성을 사용할 때 정규식 엔진은 모든 단계에서 텍스트를 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 에 일치시킵니다 . &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; 뒤에 나오는 내용과 일치 시키려고합니다 . . 이것은 예를 들어 &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; 뒤에 아무것도 나오지 않는다는 것을 의미합니다 . 그런 다음 아무것도 일치하지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
