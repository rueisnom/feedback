<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/22444">
    <body>
      <group id="22444">
        <trans-unit id="dec62beea796b93e961fd26843e4f12545dcd801" translate="yes" xml:space="preserve">
          <source>(Project name:\s+[A-Z]:(?:\\w+)+.[a-zA-Z]+\s+J[0-9]{7})(?=:)</source>
          <target state="translated">(Название проекта:\s+[A-Z]:(?:\w+)+.[a-zA-Z]+\s+J[0-9]{7})(?=:)</target>
        </trans-unit>
        <trans-unit id="d74358649090f184688e9436caba0929745dfa76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\S&lt;/code&gt; means &amp;ldquo;everything except a whitespace and this is exactly what you want.</source>
          <target state="translated">&lt;code&gt;\S&lt;/code&gt; означает &amp;laquo;все, кроме пробелов, и это именно то, что вы хотите.</target>
        </trans-unit>
        <trans-unit id="1a22048ad80c3f36c944b4c6969e1305292d5ede" translate="yes" xml:space="preserve">
          <source>Adding (?:\\w+)+.[a-zA-Z]+ will be more restrictive instead of .*</source>
          <target state="translated">Добавление (?:\w+)+.[a-zA-Z]+будет более ограничительным вместо .*.</target>
        </trans-unit>
        <trans-unit id="f96cb3981f13999823660dd7e13db3854f62fd42" translate="yes" xml:space="preserve">
          <source>Available for download at their site:
&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;http://www.ultrapico.com/Expresso.htm&lt;/a&gt;</source>
          <target state="translated">Доступно для скачивания на их сайте: &lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;http://www.ultrapico.com/Expresso.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0819a57fa2ce95f4f7ef948ace1c68f4119a4053" translate="yes" xml:space="preserve">
          <source>Express download:
&lt;a href=&quot;http://www.ultrapico.com/ExpressoDownload.htm&quot;&gt;http://www.ultrapico.com/ExpressoDownload.htm&lt;/a&gt;</source>
          <target state="translated">Экспресс-загрузка: &lt;a href=&quot;http://www.ultrapico.com/ExpressoDownload.htm&quot;&gt;http://www.ultrapico.com/ExpressoDownload.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4d4474f901ea72bb6048b19bc68daf660d2062c" translate="yes" xml:space="preserve">
          <source>For example, when building your regex using the UI, and choosing &quot;*&quot;, you have the ability to check the checkbox &quot;As few as possible&quot; and see the resulting regex, as well as test its behavior, even if you were unfamiliar with non-greedy expressions before.</source>
          <target state="translated">Например,при построении своего регекса с помощью пользовательского интерфейса и выборе &quot;*&quot;,у вас есть возможность отметить галочкой &quot;Как можно меньше&quot; и увидеть полученный регекс,а также проверить его поведение,даже если раньше вы были незнакомы с не жадными выражениями.</target>
        </trans-unit>
        <trans-unit id="c6dc17ec3338126b029bb4467dc4a5b0c733e160" translate="yes" xml:space="preserve">
          <source>Here's the regex I've been playing with</source>
          <target state="translated">Вот регекс,с которым я играл...</target>
        </trans-unit>
        <trans-unit id="25b7ae5bda2bb5646615f024476878fbc1e11ba9" translate="yes" xml:space="preserve">
          <source>Here's what I used. &lt;code&gt;s&lt;/code&gt; contains your original string. This code is .NET specific, but most flavors of regex will have something similar.</source>
          <target state="translated">Вот что я использовал. &lt;code&gt;s&lt;/code&gt; содержит вашу оригинальную строку. Этот код специфичен для .NET, но большинство разновидностей регулярных выражений будут иметь что-то похожее.</target>
        </trans-unit>
        <trans-unit id="fa0d0e5f0dcd95cd2394c04d0dd750558e07c207" translate="yes" xml:space="preserve">
          <source>How do I make the regex stop at the first occurrence of &lt;code&gt;J[0-9]{7}&lt;/code&gt;?</source>
          <target state="translated">Как мне сделать остановку регулярного выражения при первом появлении &lt;code&gt;J[0-9]{7}&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="2476709c17310e52137aa1cc47d9521a8ec9af1f" translate="yes" xml:space="preserve">
          <source>However, consider using a negative character class instead:</source>
          <target state="translated">Тем не менее,подумайте об использовании отрицательного класса символов вместо него:</target>
        </trans-unit>
        <trans-unit id="e8182e7a74ca90848e396968128840af8ff50330" translate="yes" xml:space="preserve">
          <source>I have this gigantic ugly string and I'm trying to extract pieces from it using regex. In this case, I want to grab everything after &quot;Project Name&quot; up to the part where it says &quot;J0000011:&quot; (the 11 is going to be a different number every time).</source>
          <target state="translated">У меня есть эта гигантская уродливая струна,и я пытаюсь извлечь из нее кусочки с помощью регекса.В данном случае,я хочу захватить всё после &quot;Project Name&quot; до той части,где написано &quot;J0000011:&quot; (11 будет каждый раз другим номером).</target>
        </trans-unit>
        <trans-unit id="3ffdb82847dbfa2d59c1f0a1cbce7cec5863bca1" translate="yes" xml:space="preserve">
          <source>I would also recommend you experiment with regular expressions using &quot;Expresso&quot; - it's a utility a great (and free) utility for regex editing and testing.</source>
          <target state="translated">Также рекомендую поэкспериментировать с регулярными выражениями,используя &quot;Expresso&quot;-это утилита-отличная (и бесплатная)утилита для редактирования и тестирования регексов.</target>
        </trans-unit>
        <trans-unit id="6846de25786ac85bdcf55d989f13d12d704b9c5e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;.*&lt;/code&gt; non-greedy by adding '&lt;code&gt;?&lt;/code&gt;' after it:</source>
          <target state="translated">Сделать &lt;code&gt;.*&lt;/code&gt; Не жадным, добавив ' &lt;code&gt;?&lt;/code&gt; ' после этого:</target>
        </trans-unit>
        <trans-unit id="4614b7d813b6577e56143c1d13fdce32e59ecd47" translate="yes" xml:space="preserve">
          <source>My regex is matching too much. How do I make it stop</source>
          <target state="translated">Мой регекс слишком совпадает.Как мне остановить его</target>
        </trans-unit>
        <trans-unit id="a37930a0a0dbd048cb64cfd2f01bee038a3c4efb" translate="yes" xml:space="preserve">
          <source>One of its upsides is that its UI exposes a lot of regex functionality that people unexprienced with regex might not be familiar with, in a way that it would be easy for them to learn these new concepts.</source>
          <target state="translated">Одна из его плюсов заключается в том,что его пользовательский интерфейс раскрывает множество функциональных возможностей регекса,с которыми люди,не знакомые с регексом,могут быть не знакомы,таким образом,что им будет легко освоить эти новые концепции.</target>
        </trans-unit>
        <trans-unit id="8b1564b92aeae9365fa6d7b721259bac515f612a" translate="yes" xml:space="preserve">
          <source>The problem is that it doesn't stop until it hits the &lt;strong&gt;J0000020:&lt;/strong&gt; at the end.</source>
          <target state="translated">Проблема в том, что он не останавливается, пока не достигнет &lt;strong&gt;J0000020:&lt;/strong&gt; в конце.</target>
        </trans-unit>
        <trans-unit id="7ee02ddff9a21ceb84aa0fdbdf0b08ea2d88858d" translate="yes" xml:space="preserve">
          <source>This will work for you.</source>
          <target state="translated">Это сработает.</target>
        </trans-unit>
        <trans-unit id="b50caa0655c0017769d1e76767cc9307fa184451" translate="yes" xml:space="preserve">
          <source>Using non-greedy quantifiers here is probably the best solution, also because it is more efficient than the greedy alternative: Greedy matches generally go as far as they can (here, until the end of the text!) and then trace back character after character to try and match the part coming afterwards.</source>
          <target state="translated">Использование не жадных квантификаторов здесь,вероятно,является лучшим решением,также потому,что это более эффективно,чем жадная альтернатива:Жадные совпадения,как правило,идут настолько далеко,насколько это возможно (здесь,до конца текста!),а затем прослеживаются символы за символами,чтобы попытаться найти совпадение с той частью,которая придет после этого.</target>
        </trans-unit>
        <trans-unit id="b26ab1ae34128cc80aad47f0821d813cf120cb31" translate="yes" xml:space="preserve">
          <source>Well, &lt;code&gt;&quot;.*&quot;&lt;/code&gt; is a greedy selector. You make it non-greedy by using &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; When using the latter construct, the regex engine will, at every step it matches text into the &lt;code&gt;&quot;.&quot;&lt;/code&gt; attempt to match whatever make come after the &lt;code&gt;&quot;.*?&quot;&lt;/code&gt;. This means that if for instance nothing comes after the &lt;code&gt;&quot;.*?&quot;&lt;/code&gt;, then it matches nothing.</source>
          <target state="translated">Ну, &lt;code&gt;&quot;.*&quot;&lt;/code&gt; - жадный селектор. Вы делаете его не жадным, используя &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; При использовании последней конструкции механизм регулярных выражений будет на каждом шаге сопоставлять текст с &lt;code&gt;&quot;.&quot;&lt;/code&gt; попытаться подобрать любую марку после &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; , Это означает, что если, например, после &lt;code&gt;&quot;.*?&quot;&lt;/code&gt; Ничего не идет , то это ничего не соответствует.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
