<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/228783">
    <body>
      <group id="228783">
        <trans-unit id="41d61cdb9c9d1e49d9f1bf4dc317e040c0c1bc35" translate="yes" xml:space="preserve">
          <source>&amp;mdash; Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.</source>
          <target state="translated">&amp;mdash;每个以下划线开头的名称都保留给实现，以用作全局名称空间中的名称。</target>
        </trans-unit>
        <trans-unit id="eec70b10182a3ee0325a4055d4443aa4c7d68d9a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; Each name that contains a double underscore _ _ or begins with an underscore followed by an uppercase letter (2.12) is reserved to the implementation for any use.</source>
          <target state="translated">&amp;mdash;包含双下划线_ _或以下划线后跟大写字母（2.12）开头的每个名称都保留给实现以供任何使用。</target>
        </trans-unit>
        <trans-unit id="72761832b57d839918312f2cc43d27dcf8f4ca2f" translate="yes" xml:space="preserve">
          <source>(I use macros because they are the more code-polluting of C/C++ symbols, but it could be anything from variable name to class name)</source>
          <target state="translated">(我用宏,因为它们是CC++符号中代码污染较多的一种,但从变量名到类名,都可以是变量名和类名)。</target>
        </trans-unit>
        <trans-unit id="1a1b118aa980272ec9387d9dc726a9ba2f02831f" translate="yes" xml:space="preserve">
          <source>17.4.3.1.2 Global names [lib.global.names]</source>
          <target state="translated">17.4.3.1.2 全局名称[lib.global.names]</target>
        </trans-unit>
        <trans-unit id="430567a063d1ce32e693fce199132ea7e7cff053" translate="yes" xml:space="preserve">
          <source>7.1.3 Reserved identifiers</source>
          <target state="translated">7.1.3 保留的标识符</target>
        </trans-unit>
        <trans-unit id="8de052ab20b9419c96afdf62ff914a376e0c210e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;
&lt;li&gt;never start a symbol with an underscore&lt;/li&gt;
&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8113dfc669d55a1b53dcb2560964b7b05fe9ccbf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;
When naming a symbol, you will avoid collision with compiler/OS/standard libraries if you:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;命名符号时，如果满足以下条件，将避免与编译器/ OS /标准库冲突：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1dbf37d738c961e41925d96f6105682a1b33ecb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;17.6.3.3.2 Global names [global.names]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;17.6.3.3.2全局名称[global.names]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7ed5b0f26da84e7ddaaf8a99ac425cd2fc9e37b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;17.6.3.3.5 User-defined literal suffixes [usrlit.suffix]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;17.6.3.3.5用户定义的文字后缀[usrlit.suffix]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dd1640bfec1fda2c51f13b0cac38b87763e8a088" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;never name a symbol with two consecutive underscores inside.
&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;切勿在其中使用两个连续的下划线来命名符号。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac256d28ba3a8a5ec5ad2b9aa3b3d25a3343705c" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;154)&lt;/sup&gt; The list of reserved identifiers with external linkage includes &lt;code&gt;errno&lt;/code&gt;, &lt;code&gt;math_errhandling&lt;/code&gt;, &lt;code&gt;setjmp&lt;/code&gt;, and &lt;code&gt;va_end&lt;/code&gt;.</source>
          <target state="translated">&lt;sup&gt;154）&lt;/sup&gt;具有外部链接的保留标识符的列表包括 &lt;code&gt;errno&lt;/code&gt; ， &lt;code&gt;math_errhandling&lt;/code&gt; ， &lt;code&gt;setjmp&lt;/code&gt; 和 &lt;code&gt;va_end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44b321dd20eb7be3e29503f13596198d7607e3c7" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;165)&lt;/sup&gt; Such names are also reserved in namespace &lt;code&gt;::std&lt;/code&gt; (17.4.3.1).</source>
          <target state="translated">&lt;sup&gt;165）&lt;/sup&gt;这样的名称也在名称空间 &lt;code&gt;::std&lt;/code&gt; （17.4.3.1）中保留。</target>
        </trans-unit>
        <trans-unit id="a2c6e4e7bc5af94b177c67a843dc7885d2ab713e" translate="yes" xml:space="preserve">
          <source>After doing research on this article I no longer end my identifiers with &lt;code&gt;_t&lt;/code&gt;
as this is reserved by the POSIX standard.</source>
          <target state="translated">在对本文进行研究之后，我不再用 &lt;code&gt;_t&lt;/code&gt; 结尾标识符，因为这是POSIX标准保留的。</target>
        </trans-unit>
        <trans-unit id="0cfffc2d2cbce99350fe15ff038d744c0063911d" translate="yes" xml:space="preserve">
          <source>All identifiers that begin with an underscore and either an uppercase letter or another
  underscore are always reserved for any use.</source>
          <target state="translated">所有以下划线和大写字母或另一个下划线开头的标识符都是保留的。</target>
        </trans-unit>
        <trans-unit id="d4eb3ca899ad98e32df1c992d9a34dee9a45c090" translate="yes" xml:space="preserve">
          <source>All identifiers that begin with an underscore are always reserved for use as identifiers
  with file scope in both the ordinary and tag name spaces.</source>
          <target state="translated">所有以下划线开头的标识符总是保留作为标识符使用,在普通和标记名空格中都有文件范围。</target>
        </trans-unit>
        <trans-unit id="f760fa262fccd567fd8b370c801ad3a62acc6e2a" translate="yes" xml:space="preserve">
          <source>All identifiers with external linkage in any of the following subclauses (including the
  future library directions) are always reserved for use as identifiers with external
  linkage.&lt;sup&gt;154&lt;/sup&gt;</source>
          <target state="translated">在以下任何条款（包括将来的库说明）中，所有具有外部链接的标识符始终保留为具有外部链接的标识符。 &lt;sup&gt;154&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0777b058fbe578c3a9f273e95ddb7d0f8edf1887" translate="yes" xml:space="preserve">
          <source>Also, everything in the &lt;code&gt;std&lt;/code&gt; namespace is reserved. (You are allowed to add template specializations, though.)</source>
          <target state="translated">同样， &lt;code&gt;std&lt;/code&gt; 名称空间中的所有内容均保留。 （不过，您可以添加模板专长。）</target>
        </trans-unit>
        <trans-unit id="a90f3fd49183247ac5bd19ef7c65157b5cd737a7" translate="yes" xml:space="preserve">
          <source>As for the other part of the question, it's common to put the underscore at the &lt;em&gt;end&lt;/em&gt; of the variable name to not clash with anything internal.</source>
          <target state="translated">至于问题的另一部分，通常将下划线放在变量名的&lt;em&gt;末尾&lt;/em&gt; ，以免与内部任何内容发生冲突。</target>
        </trans-unit>
        <trans-unit id="ce3df41f37249eda7ba798a33efe462dce8a8d25" translate="yes" xml:space="preserve">
          <source>Because C++ is based on the C standard (1.1/2, C++03) and C99 is a normative reference (1.2/1, C++03) these also apply, from the 1999 C Standard:</source>
          <target state="translated">因为C++是基于C标准(1.12,C++03),而C99是规范性参考(1.21,C++03),所以这些也适用,从1999年的C标准开始。</target>
        </trans-unit>
        <trans-unit id="1bd6e4b10225da14c712ab0db802339c5a5681b1" translate="yes" xml:space="preserve">
          <source>Because I did not want to deal with cases, and wanted a simple rule, I have designed a &lt;strong&gt;personal&lt;/strong&gt; one that is both simple and correct:</source>
          <target state="translated">因为我不想处理案件，而是想要一个简单的规则，所以我设计了一个既简单又正确的&lt;strong&gt;个人&lt;/strong&gt;规则：</target>
        </trans-unit>
        <trans-unit id="b7db5228b5551fc3bcc509295600e8473f9bedcd" translate="yes" xml:space="preserve">
          <source>But also:</source>
          <target state="translated">但也。</target>
        </trans-unit>
        <trans-unit id="44b8b90a73a264dd17818bbd20e868d857e5e0ff" translate="yes" xml:space="preserve">
          <source>C# (or possibly just .NET) seems to recommend using just an underscore, as in &lt;code&gt;_foo&lt;/code&gt;. Is this allowed by the C++ standard?</source>
          <target state="translated">C＃（或者可能只是.NET）似乎建议仅使用下划线，例如 &lt;code&gt;_foo&lt;/code&gt; 。 C ++标准允许吗？</target>
        </trans-unit>
        <trans-unit id="ae6b14e6f3fa5c5a0e89a9707a22461ae803d41b" translate="yes" xml:space="preserve">
          <source>Certain sets of names and function signatures are always reserved to the implementation:</source>
          <target state="translated">某些集合名称和函数签名总是保留给实施者。</target>
        </trans-unit>
        <trans-unit id="ee2ffa09e4a16b4f725ffa799c8f0da25eb0b391" translate="yes" xml:space="preserve">
          <source>CesarB provided the following link to the &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_02.html&quot;&gt;POSIX 2004&lt;/a&gt; reserved symbols and notes 'that many other reserved prefixes and suffixes ... can be found there'.  The
&lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html&quot;&gt;POSIX 2008&lt;/a&gt; reserved symbols are defined here.  The restrictions are somewhat more nuanced than those above.</source>
          <target state="translated">CesarB提供了指向&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_02.html&quot;&gt;POSIX 2004&lt;/a&gt;保留符号的以下链接，并指出&amp;ldquo;在此可以找到许多其他保留的前缀和后缀...&amp;rdquo;。 此处定义了&lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html&quot;&gt;POSIX 2008&lt;/a&gt;保留符号。 这些限制比上述限制更加细微。</target>
        </trans-unit>
        <trans-unit id="3923bccb875191f26bb58e24ca4ac2c69b2a104d" translate="yes" xml:space="preserve">
          <source>Each header declares or defines all identifiers listed in its associated subclause, and
  optionally declares or defines identifiers listed in its associated future library directions subclause and identifiers which are always reserved either for any use or for use as file scope identifiers.</source>
          <target state="translated">每个头声明或定义了在其相关的子词条中列出的所有标识符,并有选择地声明或定义了在其相关的未来库方向子词条中列出的标识符,以及始终保留的标识符,这些标识符要么用于任何用途,要么作为文件范围标识符使用。</target>
        </trans-unit>
        <trans-unit id="32cc50dd8168882a2f32f9dae904b27630be414d" translate="yes" xml:space="preserve">
          <source>Each identifier with file scope listed in any of the following subclauses (including the
  future library directions) is reserved for use as a macro name and as an identifier with
  file scope in the same name space if any of its associated headers is included.</source>
          <target state="translated">以下任何一个子条款(包括未来的库方向)中列出的每个具有文件范围的标识符都被保留作为宏名使用,如果包含了任何一个相关的标题,则作为同一名称空间中具有文件范围的标识符。</target>
        </trans-unit>
        <trans-unit id="901f8b7c9dba5bacb86bcba61fc4d4438ae005a6" translate="yes" xml:space="preserve">
          <source>Each macro name in any of the following subclauses (including the future library
  directions) is reserved for use as specified if any of its associated headers is included;
  unless explicitly stated otherwise (see 7.1.4).</source>
          <target state="translated">以下任何一个子条款中的每一个宏名称(包括未来的库方向),如果包含了任何一个相关的标题,则按规定使用;除非另有说明(见7.1.4)。</target>
        </trans-unit>
        <trans-unit id="5e28b1cf21e0f4ab90d7899db4bfb417554d78e6" translate="yes" xml:space="preserve">
          <source>Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.&lt;sup&gt;165&lt;/sup&gt;</source>
          <target state="translated">每个以下划线开头的名称都保留给实现，以用作全局名称空间中的名称。 &lt;sup&gt;165&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c54165923968aa1d4d000f735a45d1548f013998" translate="yes" xml:space="preserve">
          <source>Each name that contains a double underscore (&lt;code&gt;__&lt;/code&gt;) or begins with an underscore followed by an uppercase letter (2.11) is reserved to the implementation for any use.</source>
          <target state="translated">每个包含双下划线（ &lt;code&gt;__&lt;/code&gt; ）或以下划线后跟大写字母（2.11）开头的名称都保留给实现以供任何使用。</target>
        </trans-unit>
        <trans-unit id="15db9f28c2ba4e968bc63a40692535fbeac68334" translate="yes" xml:space="preserve">
          <source>Extracts from C++0x draft</source>
          <target state="translated">C++0x草案的摘录</target>
        </trans-unit>
        <trans-unit id="8c87f81e583e2fe6e538544663334a72a903d362" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/565w213d.aspx&quot;&gt;MSDN&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/565w213d.aspx&quot;&gt;MSDN&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="937b036ce701434e6914f371a780b8f5a84dbf84" translate="yes" xml:space="preserve">
          <source>From the 2003 C++ Standard:</source>
          <target state="translated">来自2003年的C++标准。</target>
        </trans-unit>
        <trans-unit id="ff44ac2555b7f2fffd8b5d2b8e42bdd5c8d5522d" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf&quot;&gt;n3242.pdf&lt;/a&gt; file (I expect the final standard text to be similar):</source>
          <target state="translated">从&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf&quot;&gt;n3242.pdf&lt;/a&gt;文件中（我希望最终的标准文本类似）：</target>
        </trans-unit>
        <trans-unit id="de9a905703d4049bf0a7102ef6e1dddb7daa8395" translate="yes" xml:space="preserve">
          <source>I do this even inside classes and namespaces because I then only have to remember one rule (compared to &quot;at the end of the name in global scope, and the beginning of the name everywhere else&quot;).</source>
          <target state="translated">我即使在类和命名空间内也是这样做的,因为这样我只需要记住一条规则(相比之下,&quot;在全局范围内的名称末尾,其他地方的名称开头&quot;)。</target>
        </trans-unit>
        <trans-unit id="8f446e24cf801f1b1ed4e8f8947ff09b7d06e4ea" translate="yes" xml:space="preserve">
          <source>If the program removes (with &lt;code&gt;#undef&lt;/code&gt;) any macro definition of an identifier in the first
  group listed above, the behavior is undefined.</source>
          <target state="translated">如果程序删除（使用 &lt;code&gt;#undef&lt;/code&gt; ）上面列出的第一组中标识符的任何宏定义，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="564b4470885aa0c8412a9f0bebef1e57667cf48d" translate="yes" xml:space="preserve">
          <source>It's common in C++ to name member variables with some kind of prefix to denote the fact that they're member variables, rather than local variables or parameters. If you've come from an MFC background, you'll probably use &lt;code&gt;m_foo&lt;/code&gt;. I've also seen &lt;code&gt;myFoo&lt;/code&gt; occasionally.</source>
          <target state="translated">在C ++中，通常使用某种前缀来命名成员变量，以表示它们是成员变量，而不是局部变量或参数。 如果您来自MFC背景，则可能会使用 &lt;code&gt;m_foo&lt;/code&gt; 。 我也偶尔见过 &lt;code&gt;myFoo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c495821ff0a7896702e146a03177c71926761e4" translate="yes" xml:space="preserve">
          <source>Literal suffix identifiers that do not start with an underscore are reserved for future standardization.</source>
          <target state="translated">不以下划线开头的后缀标识符的字面意思是留给未来的标准化。</target>
        </trans-unit>
        <trans-unit id="c5f79f225dc531a2cb68d0a6f8442fdea0acb9e0" translate="yes" xml:space="preserve">
          <source>Names beginning with &lt;code&gt;PRI&lt;/code&gt; or &lt;code&gt;SCN&lt;/code&gt; followed by any lowercase letter or &lt;code&gt;X&lt;/code&gt; are reserved</source>
          <target state="translated">保留以 &lt;code&gt;PRI&lt;/code&gt; 或 &lt;code&gt;SCN&lt;/code&gt; 开头的名称，后跟任何小写字母或 &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1f9b2d843cc79f0b346fb9fa79aa08e6d854a9c" translate="yes" xml:space="preserve">
          <source>Names beginning with &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;mem&lt;/code&gt;, or &lt;code&gt;wcs&lt;/code&gt; followed by a lowercase letter are reserved</source>
          <target state="translated">以 &lt;code&gt;str&lt;/code&gt; ， &lt;code&gt;mem&lt;/code&gt; 或 &lt;code&gt;wcs&lt;/code&gt; 开头，后跟小写字母的名称被保留</target>
        </trans-unit>
        <trans-unit id="8a9ca1c20f63ab6f7459560b2507aa9a213008b9" translate="yes" xml:space="preserve">
          <source>Names beginning with a capital &lt;code&gt;E&lt;/code&gt; followed a digit or uppercase letter:</source>
          <target state="translated">以大写 &lt;code&gt;E&lt;/code&gt; 开头的名称后跟数字或大写字母：</target>
        </trans-unit>
        <trans-unit id="67cc9b8e180311279b63d11aa4ba78ec5d8059ea" translate="yes" xml:space="preserve">
          <source>Names of all existing mathematics functions suffixed with &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt; are reserved</source>
          <target state="translated">保留所有以 &lt;code&gt;f&lt;/code&gt; 或 &lt;code&gt;l&lt;/code&gt; 结尾的现有数学函数的名称</target>
        </trans-unit>
        <trans-unit id="53be8d3b3fb3bd83bcb0e235d46282a241c04386" translate="yes" xml:space="preserve">
          <source>Names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by an uppercase letter</source>
          <target state="translated">以 &lt;code&gt;LC_&lt;/code&gt; 开头的名称，后跟一个大写字母</target>
        </trans-unit>
        <trans-unit id="876647522430b0cdcc0bfc139c24beb2d59373a9" translate="yes" xml:space="preserve">
          <source>Names that begin with &lt;code&gt;SIG&lt;/code&gt; followed by an uppercase letter are reserved</source>
          <target state="translated">保留以 &lt;code&gt;SIG&lt;/code&gt; 开头且后跟大写字母的名称</target>
        </trans-unit>
        <trans-unit id="756e441a441946f9be0c785f7b3eddb2a7f4ad75" translate="yes" xml:space="preserve">
          <source>Names that begin with &lt;code&gt;SIG_&lt;/code&gt; followed by an uppercase letter are reserved</source>
          <target state="translated">保留以 &lt;code&gt;SIG_&lt;/code&gt; 开头，大写字母的名称</target>
        </trans-unit>
        <trans-unit id="398c3910df0fb7d1b60318851d964bd268e9f94b" translate="yes" xml:space="preserve">
          <source>Names that begin with either &lt;code&gt;is&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; followed by a lowercase letter</source>
          <target state="translated">以 &lt;code&gt;is&lt;/code&gt; 或 &lt;code&gt;to&lt;/code&gt; 开头的小写字母</target>
        </trans-unit>
        <trans-unit id="d3cc124567eedbd8c51c895f973b1647f118248d" translate="yes" xml:space="preserve">
          <source>Names that end with &lt;code&gt;_t&lt;/code&gt; are reserved</source>
          <target state="translated">以 &lt;code&gt;_t&lt;/code&gt; 结尾的名称被保留</target>
        </trans-unit>
        <trans-unit id="c5fafa8c4713eb477e70f2efb716810cdf54bd87" translate="yes" xml:space="preserve">
          <source>No other identifiers are reserved. If the program declares or defines an identifier in a
  context in which it is reserved (other than as allowed by 7.1.4), or defines a reserved
  identifier as a macro name, the behavior is undefined.</source>
          <target state="translated">没有其他标识符被保留。如果程序在保留标识符的上下文中声明或定义了一个标识符(7.1.4所允许的除外),或者将保留的标识符定义为宏名,则该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="9f78bca7225e2187fb323aa2cf9d575380d8502a" translate="yes" xml:space="preserve">
          <source>Of course, putting your code in an unique namespace helps to avoid collision, too (but won't protect against evil macros)</source>
          <target state="translated">当然,把你的代码放在一个独特的命名空间中也有助于避免碰撞(但不能防止邪恶的宏)。</target>
        </trans-unit>
        <trans-unit id="1ad068bc9971ca20864c2eb0fc465ad0c7584644" translate="yes" xml:space="preserve">
          <source>Other restrictions might apply. For example, the POSIX standard reserves a lot of identifiers that are likely to show up in normal code:</source>
          <target state="translated">其他的限制可能适用。例如,POSIX标准保留了很多可能出现在正常代码中的标识符。</target>
        </trans-unit>
        <trans-unit id="01d0fd33cdbcb609d8be36e9a56d08842dcf18ad" translate="yes" xml:space="preserve">
          <source>Personal rule</source>
          <target state="translated">个人规则</target>
        </trans-unit>
        <trans-unit id="7cf698f8e2cedd53c4a11faeac4083eb8f5a3559" translate="yes" xml:space="preserve">
          <source>Personally I just don't start identifiers with underscores. New addition to my rule: Don't use double underscores anywhere, which is easy as I rarely use underscore.</source>
          <target state="translated">就我个人而言,我只是不以下划线开头的标识符。在我的规则中增加了新的内容。不要在任何地方使用双下划线,这很简单,因为我很少使用下划线。</target>
        </trans-unit>
        <trans-unit id="74b6a50ceb23949ea544fe1f1a0cbca5ff569377" translate="yes" xml:space="preserve">
          <source>Reserved in any scope, including for use as &lt;a href=&quot;https://stackoverflow.com/questions/4297933/c-implementation#4297974&quot;&gt;implementation&lt;/a&gt; macros:</source>
          <target state="translated">在任何范围内都保留，包括用作&lt;a href=&quot;https://stackoverflow.com/questions/4297933/c-implementation#4297974&quot;&gt;实现&lt;/a&gt;宏：</target>
        </trans-unit>
        <trans-unit id="3839d25c0b5de1eabb18cbbd529d20611c5b2ab4" translate="yes" xml:space="preserve">
          <source>Reserved in the global namespace:</source>
          <target state="translated">在全局命名空间中保留。</target>
        </trans-unit>
        <trans-unit id="aefa38a747cacc68f54b53c33078d9a6ae8997ad" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/questions/224397/why-do-people-use-double-underscore-so-much-in-c&quot;&gt;this question&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://stackoverflow.com/questions/224397/why-do-people-use-double-underscore-so-much-in-c&quot;&gt;此问题&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="76b15ddd9bbae2a42a5c96bc2b644d8162ba90e8" translate="yes" xml:space="preserve">
          <source>Some examples</source>
          <target state="translated">一些例子</target>
        </trans-unit>
        <trans-unit id="6ccc40c82e00e0fbca158a964f9e0dd261465fc5" translate="yes" xml:space="preserve">
          <source>The rule about any identifier ending with &lt;code&gt;_t&lt;/code&gt; surprised me a lot. I think that is a POSIX standard (not sure yet) looking for clarification and official chapter and verse. This is from the &lt;a href=&quot;http://www.gnu.org/software/libtool/manual/libc/Reserved-Names.html&quot;&gt;GNU libtool manual&lt;/a&gt;, listing reserved names.</source>
          <target state="translated">关于以 &lt;code&gt;_t&lt;/code&gt; 结尾的任何标识符的规则使我感到非常惊讶。 我认为这是POSIX标准（尚不确定），需要澄清和官方章节。 这来自&lt;a href=&quot;http://www.gnu.org/software/libtool/manual/libc/Reserved-Names.html&quot;&gt;GNU libtool手册&lt;/a&gt; ，其中列出了保留名称。</target>
        </trans-unit>
        <trans-unit id="1f03c8a67f91ce23f733acc2ed3436d64f92d530" translate="yes" xml:space="preserve">
          <source>The rules (which did not change in C++11):</source>
          <target state="translated">规则(在C++11中没有改变)。</target>
        </trans-unit>
        <trans-unit id="5d74020c7943c3abc5d91256210f30804c1b1061" translate="yes" xml:space="preserve">
          <source>The rules to avoid collision of names are both in the C++ standard (see Stroustrup book) and mentioned by C++ gurus (Sutter, etc.).</source>
          <target state="translated">避免名称碰撞的规则在C++标准中都有(见Stroustrup书),也有C++大师(Sutter等)提到过。</target>
        </trans-unit>
        <trans-unit id="abb2a1596df891975f9bd6cc72ee242045f322cc" translate="yes" xml:space="preserve">
          <source>This is apparently taken from section 17.4.3.1.2 of the C++ standard, but I can't find an original source for the full standard online.</source>
          <target state="translated">这显然来自C++标准的第17.4.3.1.2节,但我在网上找不到完整的标准原文。</target>
        </trans-unit>
        <trans-unit id="bff46e1b5aff90bcf6586238acea50ba47e9003a" translate="yes" xml:space="preserve">
          <source>This last clause is confusing, unless you consider that a name starting with one underscore and followed by a lowercase letter would be Ok if</source>
          <target state="translated">最后这句话让人感到困惑,除非你考虑到一个以一个下划线开头,后面是小写字母的名字,如果</target>
        </trans-unit>
        <trans-unit id="f67d15f83ed68e83b650f17c3e46b6e2eaa2342b" translate="yes" xml:space="preserve">
          <source>This means that you can use a single underscore as a member variable prefix, as long as it's followed by a lower-case letter.</source>
          <target state="translated">这意味着你可以使用单个下划线作为成员变量的前缀,只要后面有一个小写字母就可以了。</target>
        </trans-unit>
        <trans-unit id="8c3ec51488fd4e3881b52fa5198d5df5b460f288" translate="yes" xml:space="preserve">
          <source>Underscore prefixes are common in C code -- a single underscore means &quot;private&quot;, and double underscores are usually reserved for use by the compiler.</source>
          <target state="translated">下划线前缀在C代码中很常见----单下划线表示 &quot;私有&quot;,双下划线通常是留给编译器使用的。</target>
        </trans-unit>
        <trans-unit id="00ba615e433b04a49b715f686f3c7ecb756868b4" translate="yes" xml:space="preserve">
          <source>Use of two sequential underscore characters ( __ ) at the beginning of an identifier, or a single leading underscore followed by a capital letter, is reserved for C++ implementations in all scopes. You should avoid using one leading underscore followed by a lowercase letter for names with file scope because of possible conflicts with current or future reserved identifiers.</source>
          <target state="translated">在一个标识符的开头使用两个连续的下划线字符(__),或者在所有的作用域中使用一个大写字母后的单个前导下划线,是为C++实现保留的。对于有文件作用域的名称,应该避免使用一个前导下划线后加小写字母,因为可能会与当前或未来的预留标识符冲突。</target>
        </trans-unit>
        <trans-unit id="cafb52d2427ef3e764d75cc4a0d02a6f2ce6c5f8" translate="yes" xml:space="preserve">
          <source>What are the rules about using an underscore in a C++ identifier</source>
          <target state="translated">在C++标识符中使用下划线有什么规则?</target>
        </trans-unit>
        <trans-unit id="bc82e7705ecacd940f0284f78094a1f488e9240c" translate="yes" xml:space="preserve">
          <source>While using these names for your own purposes right now might not cause a problem, they do raise the possibility of conflict with future versions of that standard.</source>
          <target state="translated">虽然现在为自己的目的使用这些名称可能不会引起问题,但它们确实会引起与该标准未来版本的冲突。</target>
        </trans-unit>
        <trans-unit id="c5e2b579738459b3a534e9eee49e63e71398d927" translate="yes" xml:space="preserve">
          <source>Yes, underscores may be used anywhere in an identifier. I believe the rules are: any of a-z, A-Z, _ in the first character and those + 0-9 for following characters.</source>
          <target state="translated">是的,下划线可以在标识符的任何地方使用。我相信规则是:第一个字符中的a-z、A-Z、_中的任何一个,后面的字符+0-9为下划线。</target>
        </trans-unit>
        <trans-unit id="3524fe68bd665b18037ec2b91f39ea233bcddeff" translate="yes" xml:space="preserve">
          <source>defined in the global namespace...</source>
          <target state="translated">全局命名空间中定义的.....</target>
        </trans-unit>
        <trans-unit id="cbe4f1bf930270da1013a574639c378f46ea7eb6" translate="yes" xml:space="preserve">
          <source>for additional format specifier macros</source>
          <target state="translated">更多的格式指定器宏</target>
        </trans-unit>
        <trans-unit id="d1ffd005913b272aecef7eca405ba38d204c1423" translate="yes" xml:space="preserve">
          <source>for additional signal actions.</source>
          <target state="translated">额外的信号行动。</target>
        </trans-unit>
        <trans-unit id="e7eb8088643a246afd5e5877b28f76f2d9fae71a" translate="yes" xml:space="preserve">
          <source>for additional signal names.</source>
          <target state="translated">以了解更多的信号名称。</target>
        </trans-unit>
        <trans-unit id="1f35767e6fd5f2f484bf3bc52bea5f6394638397" translate="yes" xml:space="preserve">
          <source>for additional string and array functions.</source>
          <target state="translated">用于额外的字符串和数组函数。</target>
        </trans-unit>
        <trans-unit id="a970c94fa50c842c066c4cf6a3e2e8cd49bea2b2" translate="yes" xml:space="preserve">
          <source>for additional type names.</source>
          <target state="translated">以了解更多的类型名称。</target>
        </trans-unit>
        <trans-unit id="7c6b6625ea4ed3c1296a08e5dcdb42d06c15bbd4" translate="yes" xml:space="preserve">
          <source>for corresponding functions that operate on float and long double arguments, respectively.</source>
          <target state="translated">对于分别操作浮点和长双参数的相应函数。</target>
        </trans-unit>
        <trans-unit id="418f44dd61b84b583bf21de5375c9e60e260acfa" translate="yes" xml:space="preserve">
          <source>identifiers beginning with an underscore</source>
          <target state="translated">下划线开头的标识符</target>
        </trans-unit>
        <trans-unit id="d4ab2ef9be0eef371126d2a11d047dbb6f5b2681" translate="yes" xml:space="preserve">
          <source>identifiers beginning with an underscore followed immediately by an uppercase letter</source>
          <target state="translated">识别码以下划线后加大写字母开头的识别码</target>
        </trans-unit>
        <trans-unit id="ba7418871c901ba8e6a177f348bf0f753c0e4364" translate="yes" xml:space="preserve">
          <source>identifiers containing adjacent underscores (or &quot;double underscore&quot;)</source>
          <target state="translated">下划线标识符</target>
        </trans-unit>
        <trans-unit id="f7beaeda3ce73aef06674e6d116cd9c5641d680e" translate="yes" xml:space="preserve">
          <source>may be used for additional character testing and conversion functions.</source>
          <target state="translated">可用于额外的字符测试和转换功能。</target>
        </trans-unit>
        <trans-unit id="d2722be763842585a40ed07b059ad9701cea8ea4" translate="yes" xml:space="preserve">
          <source>may be used for additional error code names.</source>
          <target state="translated">可用于额外的错误代码名称。</target>
        </trans-unit>
        <trans-unit id="1a2bae39937a1970dc9cd1bccd55355c8998319b" translate="yes" xml:space="preserve">
          <source>may be used for additional macros specifying locale attributes.</source>
          <target state="translated">可用于指定本地属性的附加宏。</target>
        </trans-unit>
        <trans-unit id="557f255516719ea16f8f4a0aae1166054e2c9b43" translate="yes" xml:space="preserve">
          <source>not</source>
          <target state="translated">not</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
