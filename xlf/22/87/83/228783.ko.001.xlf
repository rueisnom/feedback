<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/228783">
    <body>
      <group id="228783">
        <trans-unit id="41d61cdb9c9d1e49d9f1bf4dc317e040c0c1bc35" translate="yes" xml:space="preserve">
          <source>&amp;mdash; Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.</source>
          <target state="translated">&amp;mdash; 밑줄로 시작하는 각 이름은 전역 네임 스페이스에서 이름으로 사용하기 위해 구현에 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="eec70b10182a3ee0325a4055d4443aa4c7d68d9a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; Each name that contains a double underscore _ _ or begins with an underscore followed by an uppercase letter (2.12) is reserved to the implementation for any use.</source>
          <target state="translated">&amp;mdash; 이중 밑줄 _ _을 포함하거나 밑줄로 시작하고 대문자 (2.12)로 시작하는 각 이름은 사용을 위해 구현에 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="72761832b57d839918312f2cc43d27dcf8f4ca2f" translate="yes" xml:space="preserve">
          <source>(I use macros because they are the more code-polluting of C/C++ symbols, but it could be anything from variable name to class name)</source>
          <target state="translated">(매크로는 C / C ++ 기호의 코드 오염이 많기 때문에 매크로를 사용하지만 변수 이름에서 클래스 이름에 이르기까지 다양 할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="1a1b118aa980272ec9387d9dc726a9ba2f02831f" translate="yes" xml:space="preserve">
          <source>17.4.3.1.2 Global names [lib.global.names]</source>
          <target state="translated">17.4.3.1.2 전역 이름 [lib.global.names]</target>
        </trans-unit>
        <trans-unit id="430567a063d1ce32e693fce199132ea7e7cff053" translate="yes" xml:space="preserve">
          <source>7.1.3 Reserved identifiers</source>
          <target state="translated">7.1.3 예약 식별자</target>
        </trans-unit>
        <trans-unit id="8de052ab20b9419c96afdf62ff914a376e0c210e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;
&lt;li&gt;never start a symbol with an underscore&lt;/li&gt;
&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8113dfc669d55a1b53dcb2560964b7b05fe9ccbf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;
When naming a symbol, you will avoid collision with compiler/OS/standard libraries if you:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;심볼 이름을 지정할 때 다음과 같은 경우 컴파일러 / OS / 표준 라이브러리와의 충돌을 피할 수 있습니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1dbf37d738c961e41925d96f6105682a1b33ecb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;17.6.3.3.2 Global names [global.names]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;17.6.3.3.2 전역 이름 [global.names]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7ed5b0f26da84e7ddaaf8a99ac425cd2fc9e37b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;17.6.3.3.5 User-defined literal suffixes [usrlit.suffix]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;17.6.3.3.5 사용자 정의 리터럴 접미사 [usrlit.suffix]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dd1640bfec1fda2c51f13b0cac38b87763e8a088" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;never name a symbol with two consecutive underscores inside.
&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;안에 두 개의 연속 밑줄이있는 기호의 이름을 지정하지 마십시오.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac256d28ba3a8a5ec5ad2b9aa3b3d25a3343705c" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;154)&lt;/sup&gt; The list of reserved identifiers with external linkage includes &lt;code&gt;errno&lt;/code&gt;, &lt;code&gt;math_errhandling&lt;/code&gt;, &lt;code&gt;setjmp&lt;/code&gt;, and &lt;code&gt;va_end&lt;/code&gt;.</source>
          <target state="translated">&lt;sup&gt;154)&lt;/sup&gt; 외부 연결이있는 예약 식별자 목록에는 &lt;code&gt;errno&lt;/code&gt; , &lt;code&gt;math_errhandling&lt;/code&gt; , &lt;code&gt;setjmp&lt;/code&gt; 및 &lt;code&gt;va_end&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b321dd20eb7be3e29503f13596198d7607e3c7" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;165)&lt;/sup&gt; Such names are also reserved in namespace &lt;code&gt;::std&lt;/code&gt; (17.4.3.1).</source>
          <target state="translated">&lt;sup&gt;165)&lt;/sup&gt; 이러한 이름은 네임 스페이스 &lt;code&gt;::std&lt;/code&gt; (17.4.3.1)에도 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c6e4e7bc5af94b177c67a843dc7885d2ab713e" translate="yes" xml:space="preserve">
          <source>After doing research on this article I no longer end my identifiers with &lt;code&gt;_t&lt;/code&gt;
as this is reserved by the POSIX standard.</source>
          <target state="translated">이 기사에 대한 연구를 한 후에는 POSIX 표준에 의해 예약되어 있으므로 더 이상 식별자를 &lt;code&gt;_t&lt;/code&gt; 로 끝내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cfffc2d2cbce99350fe15ff038d744c0063911d" translate="yes" xml:space="preserve">
          <source>All identifiers that begin with an underscore and either an uppercase letter or another
  underscore are always reserved for any use.</source>
          <target state="translated">밑줄과 대문자 또는 다른 밑줄로 시작하는 모든 식별자는 항상 사용하도록 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4eb3ca899ad98e32df1c992d9a34dee9a45c090" translate="yes" xml:space="preserve">
          <source>All identifiers that begin with an underscore are always reserved for use as identifiers
  with file scope in both the ordinary and tag name spaces.</source>
          <target state="translated">밑줄로 시작하는 모든 식별자는 항상 일반 네임 스페이스와 태그 네임 스페이스 모두에서 파일 범위를 가진 식별자로 사용되도록 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f760fa262fccd567fd8b370c801ad3a62acc6e2a" translate="yes" xml:space="preserve">
          <source>All identifiers with external linkage in any of the following subclauses (including the
  future library directions) are always reserved for use as identifiers with external
  linkage.&lt;sup&gt;154&lt;/sup&gt;</source>
          <target state="translated">다음 하위 조항 중 하나에서 외부 연계가있는 모든 식별자 (향후 라이브러리 지시 사항 포함)는 항상 외부 연계가있는 식별자로 사용되도록 예약되어 있습니다. &lt;sup&gt;154&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0777b058fbe578c3a9f273e95ddb7d0f8edf1887" translate="yes" xml:space="preserve">
          <source>Also, everything in the &lt;code&gt;std&lt;/code&gt; namespace is reserved. (You are allowed to add template specializations, though.)</source>
          <target state="translated">또한 &lt;code&gt;std&lt;/code&gt; 네임 스페이스의 모든 것이 예약되어 있습니다. (그러나 템플릿 전문화를 추가 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a90f3fd49183247ac5bd19ef7c65157b5cd737a7" translate="yes" xml:space="preserve">
          <source>As for the other part of the question, it's common to put the underscore at the &lt;em&gt;end&lt;/em&gt; of the variable name to not clash with anything internal.</source>
          <target state="translated">질문의 다른 부분은 변수 이름의 &lt;em&gt;끝에&lt;/em&gt; 밑줄을 두어 내부와 충돌하지 않는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="ce3df41f37249eda7ba798a33efe462dce8a8d25" translate="yes" xml:space="preserve">
          <source>Because C++ is based on the C standard (1.1/2, C++03) and C99 is a normative reference (1.2/1, C++03) these also apply, from the 1999 C Standard:</source>
          <target state="translated">C ++는 C 표준 (1.1 / 2, C ++ 03)을 기반으로하고 C99는 표준 참조 (1.2 / 1, C ++ 03)이므로 1999 C 표준에서 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bd6e4b10225da14c712ab0db802339c5a5681b1" translate="yes" xml:space="preserve">
          <source>Because I did not want to deal with cases, and wanted a simple rule, I have designed a &lt;strong&gt;personal&lt;/strong&gt; one that is both simple and correct:</source>
          <target state="translated">나는 사건을 다루고 싶지 않고 간단한 규칙을 원했기 때문에 간단하고 정확한 &lt;strong&gt;개인&lt;/strong&gt; 을 설계했습니다.</target>
        </trans-unit>
        <trans-unit id="b7db5228b5551fc3bcc509295600e8473f9bedcd" translate="yes" xml:space="preserve">
          <source>But also:</source>
          <target state="translated">또한 :</target>
        </trans-unit>
        <trans-unit id="44b8b90a73a264dd17818bbd20e868d857e5e0ff" translate="yes" xml:space="preserve">
          <source>C# (or possibly just .NET) seems to recommend using just an underscore, as in &lt;code&gt;_foo&lt;/code&gt;. Is this allowed by the C++ standard?</source>
          <target state="translated">C # (또는 아마도 .NET)은 &lt;code&gt;_foo&lt;/code&gt; 에서처럼 밑줄 만 사용하는 것이 좋습니다. 이것이 C ++ 표준에서 허용됩니까?</target>
        </trans-unit>
        <trans-unit id="ae6b14e6f3fa5c5a0e89a9707a22461ae803d41b" translate="yes" xml:space="preserve">
          <source>Certain sets of names and function signatures are always reserved to the implementation:</source>
          <target state="translated">특정 이름 및 함수 서명 세트는 항상 구현에 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee2ffa09e4a16b4f725ffa799c8f0da25eb0b391" translate="yes" xml:space="preserve">
          <source>CesarB provided the following link to the &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_02.html&quot;&gt;POSIX 2004&lt;/a&gt; reserved symbols and notes 'that many other reserved prefixes and suffixes ... can be found there'.  The
&lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html&quot;&gt;POSIX 2008&lt;/a&gt; reserved symbols are defined here.  The restrictions are somewhat more nuanced than those above.</source>
          <target state="translated">CesarB는 &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_02.html&quot;&gt;POSIX 2004&lt;/a&gt; 예약 기호에 대한 다음 링크를 제공했으며 '다른 많은 예약 된 접두사 및 접미사를 찾을 수 있습니다.' &lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html&quot;&gt;POSIX 2008&lt;/a&gt; 예약 기호가 여기에 정의되어 있습니다. 제한은 위의 제한보다 약간 미묘합니다.</target>
        </trans-unit>
        <trans-unit id="3923bccb875191f26bb58e24ca4ac2c69b2a104d" translate="yes" xml:space="preserve">
          <source>Each header declares or defines all identifiers listed in its associated subclause, and
  optionally declares or defines identifiers listed in its associated future library directions subclause and identifiers which are always reserved either for any use or for use as file scope identifiers.</source>
          <target state="translated">각 헤더는 관련 하위 조항에 나열된 모든 식별자를 선언 또는 정의하며, 선택적으로 관련 미래 라이브러리 지침 하위 조항 및 식별자에 항상 나열된 모든 식별자 또는 파일 범위 식별자로 사용하도록 예약 된 식별자를 선언하거나 정의합니다.</target>
        </trans-unit>
        <trans-unit id="32cc50dd8168882a2f32f9dae904b27630be414d" translate="yes" xml:space="preserve">
          <source>Each identifier with file scope listed in any of the following subclauses (including the
  future library directions) is reserved for use as a macro name and as an identifier with
  file scope in the same name space if any of its associated headers is included.</source>
          <target state="translated">다음 하위 조항 중 하나에 나열된 파일 범위를 가진 각 식별자 (향후 라이브러리 지시 사항 포함)는 매크로 이름으로 사용되며 연관된 헤더가 포함 된 경우 동일한 네임 스페이스에서 파일 범위를 가진 식별자로 사용하도록 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="901f8b7c9dba5bacb86bcba61fc4d4438ae005a6" translate="yes" xml:space="preserve">
          <source>Each macro name in any of the following subclauses (including the future library
  directions) is reserved for use as specified if any of its associated headers is included;
  unless explicitly stated otherwise (see 7.1.4).</source>
          <target state="translated">다음 하위 조항 (향후 라이브러리 지시 사항 포함)의 각 매크로 이름은 연관된 헤더가 포함 된 경우 지정된대로 사용하도록 예약되어 있습니다. 달리 명시되지 않는 한 (7.1.4 참조)</target>
        </trans-unit>
        <trans-unit id="5e28b1cf21e0f4ab90d7899db4bfb417554d78e6" translate="yes" xml:space="preserve">
          <source>Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.&lt;sup&gt;165&lt;/sup&gt;</source>
          <target state="translated">밑줄로 시작하는 각 이름은 전역 네임 스페이스에서 이름으로 사용하기 위해 구현에 예약되어 있습니다. &lt;sup&gt;165&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c54165923968aa1d4d000f735a45d1548f013998" translate="yes" xml:space="preserve">
          <source>Each name that contains a double underscore (&lt;code&gt;__&lt;/code&gt;) or begins with an underscore followed by an uppercase letter (2.11) is reserved to the implementation for any use.</source>
          <target state="translated">이중 밑줄 ( &lt;code&gt;__&lt;/code&gt; )을 포함하거나 밑줄로 시작하고 대문자 (2.11)로 시작하는 각 이름은 사용을 위해 구현에 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="15db9f28c2ba4e968bc63a40692535fbeac68334" translate="yes" xml:space="preserve">
          <source>Extracts from C++0x draft</source>
          <target state="translated">C ++ 0x 초안에서 추출</target>
        </trans-unit>
        <trans-unit id="8c87f81e583e2fe6e538544663334a72a903d362" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/565w213d.aspx&quot;&gt;MSDN&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/565w213d.aspx&quot;&gt;MSDN에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="937b036ce701434e6914f371a780b8f5a84dbf84" translate="yes" xml:space="preserve">
          <source>From the 2003 C++ Standard:</source>
          <target state="translated">2003 C ++ 표준에서 :</target>
        </trans-unit>
        <trans-unit id="ff44ac2555b7f2fffd8b5d2b8e42bdd5c8d5522d" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf&quot;&gt;n3242.pdf&lt;/a&gt; file (I expect the final standard text to be similar):</source>
          <target state="translated">&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf&quot;&gt;n3242.pdf&lt;/a&gt; 파일에서 (최종 표준 텍스트가 유사 할 것으로 예상) :</target>
        </trans-unit>
        <trans-unit id="de9a905703d4049bf0a7102ef6e1dddb7daa8395" translate="yes" xml:space="preserve">
          <source>I do this even inside classes and namespaces because I then only have to remember one rule (compared to &quot;at the end of the name in global scope, and the beginning of the name everywhere else&quot;).</source>
          <target state="translated">클래스와 네임 스페이스에서도이 작업을 수행합니다. &quot;글로벌 범위의 이름 끝과 다른 곳의 이름 시작&quot;과 비교할 때 하나의 규칙 만 기억하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8f446e24cf801f1b1ed4e8f8947ff09b7d06e4ea" translate="yes" xml:space="preserve">
          <source>If the program removes (with &lt;code&gt;#undef&lt;/code&gt;) any macro definition of an identifier in the first
  group listed above, the behavior is undefined.</source>
          <target state="translated">프로그램이 위에 나열된 첫 번째 그룹에서 식별자의 매크로 정의를 &lt;code&gt;#undef&lt;/code&gt; 와 함께 제거하면 ( #undef 사용 ) 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="564b4470885aa0c8412a9f0bebef1e57667cf48d" translate="yes" xml:space="preserve">
          <source>It's common in C++ to name member variables with some kind of prefix to denote the fact that they're member variables, rather than local variables or parameters. If you've come from an MFC background, you'll probably use &lt;code&gt;m_foo&lt;/code&gt;. I've also seen &lt;code&gt;myFoo&lt;/code&gt; occasionally.</source>
          <target state="translated">C ++에서는 지역 변수 또는 매개 변수가 아닌 구성원 변수라는 사실을 나타 내기 위해 접두어로 구성원 변수의 이름을 지정하는 것이 일반적입니다. MFC 배경에서 온 경우 아마도 &lt;code&gt;m_foo&lt;/code&gt; 사용 합니다 . 나는 또한 때때로 &lt;code&gt;myFoo&lt;/code&gt; 를 보았다.</target>
        </trans-unit>
        <trans-unit id="9c495821ff0a7896702e146a03177c71926761e4" translate="yes" xml:space="preserve">
          <source>Literal suffix identifiers that do not start with an underscore are reserved for future standardization.</source>
          <target state="translated">밑줄로 시작하지 않는 리터럴 접미어 식별자는 향후 표준화를 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5f79f225dc531a2cb68d0a6f8442fdea0acb9e0" translate="yes" xml:space="preserve">
          <source>Names beginning with &lt;code&gt;PRI&lt;/code&gt; or &lt;code&gt;SCN&lt;/code&gt; followed by any lowercase letter or &lt;code&gt;X&lt;/code&gt; are reserved</source>
          <target state="translated">&lt;code&gt;PRI&lt;/code&gt; 또는 &lt;code&gt;SCN&lt;/code&gt; 으로 시작하고 그 뒤에 소문자 또는 &lt;code&gt;X&lt;/code&gt; 가 오는 이름은 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f9b2d843cc79f0b346fb9fa79aa08e6d854a9c" translate="yes" xml:space="preserve">
          <source>Names beginning with &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;mem&lt;/code&gt;, or &lt;code&gt;wcs&lt;/code&gt; followed by a lowercase letter are reserved</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; , &lt;code&gt;mem&lt;/code&gt; 또는 &lt;code&gt;wcs&lt;/code&gt; 로 시작하고 소문자가 오는 이름은 예약되어 있습니다</target>
        </trans-unit>
        <trans-unit id="8a9ca1c20f63ab6f7459560b2507aa9a213008b9" translate="yes" xml:space="preserve">
          <source>Names beginning with a capital &lt;code&gt;E&lt;/code&gt; followed a digit or uppercase letter:</source>
          <target state="translated">대문자 &lt;code&gt;E&lt;/code&gt; 로 시작하는 이름은 숫자 나 대문자 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="67cc9b8e180311279b63d11aa4ba78ec5d8059ea" translate="yes" xml:space="preserve">
          <source>Names of all existing mathematics functions suffixed with &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt; are reserved</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 또는 &lt;code&gt;l&lt;/code&gt; 접미사가있는 모든 기존 수학 함수의 이름이 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="53be8d3b3fb3bd83bcb0e235d46282a241c04386" translate="yes" xml:space="preserve">
          <source>Names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by an uppercase letter</source>
          <target state="translated">&lt;code&gt;LC_&lt;/code&gt; 로 시작하고 대문자가 오는 이름</target>
        </trans-unit>
        <trans-unit id="876647522430b0cdcc0bfc139c24beb2d59373a9" translate="yes" xml:space="preserve">
          <source>Names that begin with &lt;code&gt;SIG&lt;/code&gt; followed by an uppercase letter are reserved</source>
          <target state="translated">&lt;code&gt;SIG&lt;/code&gt; 로 시작하고 대문자가 오는 이름은 예약되어 있습니다</target>
        </trans-unit>
        <trans-unit id="756e441a441946f9be0c785f7b3eddb2a7f4ad75" translate="yes" xml:space="preserve">
          <source>Names that begin with &lt;code&gt;SIG_&lt;/code&gt; followed by an uppercase letter are reserved</source>
          <target state="translated">&lt;code&gt;SIG_&lt;/code&gt; 로 시작하고 대문자가 오는 이름은 예약되어 있습니다</target>
        </trans-unit>
        <trans-unit id="398c3910df0fb7d1b60318851d964bd268e9f94b" translate="yes" xml:space="preserve">
          <source>Names that begin with either &lt;code&gt;is&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; followed by a lowercase letter</source>
          <target state="translated">소문자 &lt;code&gt;to&lt;/code&gt; 시작하거나 뒤에 오는 이름</target>
        </trans-unit>
        <trans-unit id="d3cc124567eedbd8c51c895f973b1647f118248d" translate="yes" xml:space="preserve">
          <source>Names that end with &lt;code&gt;_t&lt;/code&gt; are reserved</source>
          <target state="translated">&lt;code&gt;_t&lt;/code&gt; 로 끝나는 이름은 예약되어 있습니다</target>
        </trans-unit>
        <trans-unit id="c5fafa8c4713eb477e70f2efb716810cdf54bd87" translate="yes" xml:space="preserve">
          <source>No other identifiers are reserved. If the program declares or defines an identifier in a
  context in which it is reserved (other than as allowed by 7.1.4), or defines a reserved
  identifier as a macro name, the behavior is undefined.</source>
          <target state="translated">다른 식별자는 예약되어 있지 않습니다. 프로그램이 예약 된 컨텍스트에서 식별자를 선언 또는 정의하거나 (7.1.4에서 허용하지 않은 경우) 예약 된 식별자를 매크로 이름으로 정의하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f78bca7225e2187fb323aa2cf9d575380d8502a" translate="yes" xml:space="preserve">
          <source>Of course, putting your code in an unique namespace helps to avoid collision, too (but won't protect against evil macros)</source>
          <target state="translated">물론 고유 한 네임 스페이스에 코드를 넣으면 충돌을 피하는 데 도움이됩니다 (그러나 악의적 인 매크로로부터 보호하지는 않음)</target>
        </trans-unit>
        <trans-unit id="1ad068bc9971ca20864c2eb0fc465ad0c7584644" translate="yes" xml:space="preserve">
          <source>Other restrictions might apply. For example, the POSIX standard reserves a lot of identifiers that are likely to show up in normal code:</source>
          <target state="translated">다른 제한 사항이 적용될 수 있습니다. 예를 들어 POSIX 표준은 일반 코드에 표시 될 수있는 많은 식별자를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="01d0fd33cdbcb609d8be36e9a56d08842dcf18ad" translate="yes" xml:space="preserve">
          <source>Personal rule</source>
          <target state="translated">개인 규칙</target>
        </trans-unit>
        <trans-unit id="7cf698f8e2cedd53c4a11faeac4083eb8f5a3559" translate="yes" xml:space="preserve">
          <source>Personally I just don't start identifiers with underscores. New addition to my rule: Don't use double underscores anywhere, which is easy as I rarely use underscore.</source>
          <target state="translated">개인적으로 나는 단지 밑줄로 식별자를 시작하지 않습니다. 내 규칙에 새로운 추가 사항 : 밑줄을 거의 사용하지 않으므로 쉽게 이중 밑줄을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="74b6a50ceb23949ea544fe1f1a0cbca5ff569377" translate="yes" xml:space="preserve">
          <source>Reserved in any scope, including for use as &lt;a href=&quot;https://stackoverflow.com/questions/4297933/c-implementation#4297974&quot;&gt;implementation&lt;/a&gt; macros:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4297933/c-implementation#4297974&quot;&gt;구현&lt;/a&gt; 매크로로 사용하는 것을 포함하여 모든 범위에서 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="3839d25c0b5de1eabb18cbbd529d20611c5b2ab4" translate="yes" xml:space="preserve">
          <source>Reserved in the global namespace:</source>
          <target state="translated">글로벌 네임 스페이스에 예약 됨 :</target>
        </trans-unit>
        <trans-unit id="aefa38a747cacc68f54b53c33078d9a6ae8997ad" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/questions/224397/why-do-people-use-double-underscore-so-much-in-c&quot;&gt;this question&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/224397/why-do-people-use-double-underscore-so-much-in-c&quot;&gt;이 질문&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="76b15ddd9bbae2a42a5c96bc2b644d8162ba90e8" translate="yes" xml:space="preserve">
          <source>Some examples</source>
          <target state="translated">몇 가지 예</target>
        </trans-unit>
        <trans-unit id="6ccc40c82e00e0fbca158a964f9e0dd261465fc5" translate="yes" xml:space="preserve">
          <source>The rule about any identifier ending with &lt;code&gt;_t&lt;/code&gt; surprised me a lot. I think that is a POSIX standard (not sure yet) looking for clarification and official chapter and verse. This is from the &lt;a href=&quot;http://www.gnu.org/software/libtool/manual/libc/Reserved-Names.html&quot;&gt;GNU libtool manual&lt;/a&gt;, listing reserved names.</source>
          <target state="translated">&lt;code&gt;_t&lt;/code&gt; 로 끝나는 식별자에 대한 규칙은 나를 놀라게했습니다. 나는 그것이 명확하고 공식적인 장과 구절을 찾고있는 POSIX 표준 (아직 확실하지 않다)이라고 생각한다. 이것은 예약 된 이름을 나열한 &lt;a href=&quot;http://www.gnu.org/software/libtool/manual/libc/Reserved-Names.html&quot;&gt;GNU libtool 매뉴얼&lt;/a&gt; 에서 가져온 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f03c8a67f91ce23f733acc2ed3436d64f92d530" translate="yes" xml:space="preserve">
          <source>The rules (which did not change in C++11):</source>
          <target state="translated">규칙 (C ++ 11에서는 변경되지 않음) :</target>
        </trans-unit>
        <trans-unit id="5d74020c7943c3abc5d91256210f30804c1b1061" translate="yes" xml:space="preserve">
          <source>The rules to avoid collision of names are both in the C++ standard (see Stroustrup book) and mentioned by C++ gurus (Sutter, etc.).</source>
          <target state="translated">이름 충돌을 피하는 규칙은 C ++ 표준 (Stroustrup 책 참조)과 C ++ 전문가 (Sutter 등)가 언급 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="abb2a1596df891975f9bd6cc72ee242045f322cc" translate="yes" xml:space="preserve">
          <source>This is apparently taken from section 17.4.3.1.2 of the C++ standard, but I can't find an original source for the full standard online.</source>
          <target state="translated">이것은 분명히 C ++ 표준의 17.4.3.1.2 섹션에서 가져 왔지만 온라인으로 전체 표준의 원본을 찾을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="bff46e1b5aff90bcf6586238acea50ba47e9003a" translate="yes" xml:space="preserve">
          <source>This last clause is confusing, unless you consider that a name starting with one underscore and followed by a lowercase letter would be Ok if</source>
          <target state="translated">하나의 밑줄로 시작하고 그 뒤에 소문자가 오는 이름을 고려하지 않는 한이 마지막 절은 혼동됩니다.</target>
        </trans-unit>
        <trans-unit id="f67d15f83ed68e83b650f17c3e46b6e2eaa2342b" translate="yes" xml:space="preserve">
          <source>This means that you can use a single underscore as a member variable prefix, as long as it's followed by a lower-case letter.</source>
          <target state="translated">즉, 소문자가 오는 한 단일 밑줄을 멤버 변수 접두어로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c3ec51488fd4e3881b52fa5198d5df5b460f288" translate="yes" xml:space="preserve">
          <source>Underscore prefixes are common in C code -- a single underscore means &quot;private&quot;, and double underscores are usually reserved for use by the compiler.</source>
          <target state="translated">밑줄 접두사는 C 코드에서 일반적입니다. 단일 밑줄은 &quot;비공개&quot;를 의미하며 이중 밑줄은 일반적으로 컴파일러에서 사용하도록 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="00ba615e433b04a49b715f686f3c7ecb756868b4" translate="yes" xml:space="preserve">
          <source>Use of two sequential underscore characters ( __ ) at the beginning of an identifier, or a single leading underscore followed by a capital letter, is reserved for C++ implementations in all scopes. You should avoid using one leading underscore followed by a lowercase letter for names with file scope because of possible conflicts with current or future reserved identifiers.</source>
          <target state="translated">식별자의 시작 부분에 두 개의 순차적 밑줄 문자 (__) 또는 대문자로 뒤 따르는 단일 밑줄 문자를 사용하면 모든 범위에서 C ++ 구현을 위해 예약됩니다. 현재 또는 미래의 예약 식별자와 충돌 할 수 있으므로 파일 범위 이름의 경우 밑줄 하나와 밑줄을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cafb52d2427ef3e764d75cc4a0d02a6f2ce6c5f8" translate="yes" xml:space="preserve">
          <source>What are the rules about using an underscore in a C++ identifier</source>
          <target state="translated">C ++ 식별자에서 밑줄 사용에 대한 규칙은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="bc82e7705ecacd940f0284f78094a1f488e9240c" translate="yes" xml:space="preserve">
          <source>While using these names for your own purposes right now might not cause a problem, they do raise the possibility of conflict with future versions of that standard.</source>
          <target state="translated">현재이 이름을 자신의 목적으로 사용하면 문제가 발생하지 않을 수 있지만 향후 해당 표준 버전과 충돌 할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5e2b579738459b3a534e9eee49e63e71398d927" translate="yes" xml:space="preserve">
          <source>Yes, underscores may be used anywhere in an identifier. I believe the rules are: any of a-z, A-Z, _ in the first character and those + 0-9 for following characters.</source>
          <target state="translated">그렇습니다. 밑줄은 식별자의 어느 곳에서나 사용할 수 있습니다. 규칙은 첫 번째 문자의 az, AZ, _ 및 다음 문자의 + 0-9 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="3524fe68bd665b18037ec2b91f39ea233bcddeff" translate="yes" xml:space="preserve">
          <source>defined in the global namespace...</source>
          <target state="translated">글로벌 네임 스페이스에 정의 된 ...</target>
        </trans-unit>
        <trans-unit id="cbe4f1bf930270da1013a574639c378f46ea7eb6" translate="yes" xml:space="preserve">
          <source>for additional format specifier macros</source>
          <target state="translated">추가 형식 지정자 매크로</target>
        </trans-unit>
        <trans-unit id="d1ffd005913b272aecef7eca405ba38d204c1423" translate="yes" xml:space="preserve">
          <source>for additional signal actions.</source>
          <target state="translated">추가 신호 동작.</target>
        </trans-unit>
        <trans-unit id="e7eb8088643a246afd5e5877b28f76f2d9fae71a" translate="yes" xml:space="preserve">
          <source>for additional signal names.</source>
          <target state="translated">추가 신호 이름.</target>
        </trans-unit>
        <trans-unit id="1f35767e6fd5f2f484bf3bc52bea5f6394638397" translate="yes" xml:space="preserve">
          <source>for additional string and array functions.</source>
          <target state="translated">추가 문자열 및 배열 함수</target>
        </trans-unit>
        <trans-unit id="a970c94fa50c842c066c4cf6a3e2e8cd49bea2b2" translate="yes" xml:space="preserve">
          <source>for additional type names.</source>
          <target state="translated">추가 유형 이름.</target>
        </trans-unit>
        <trans-unit id="7c6b6625ea4ed3c1296a08e5dcdb42d06c15bbd4" translate="yes" xml:space="preserve">
          <source>for corresponding functions that operate on float and long double arguments, respectively.</source>
          <target state="translated">float 및 long double 인수에서 각각 작동하는 해당 함수의 경우</target>
        </trans-unit>
        <trans-unit id="418f44dd61b84b583bf21de5375c9e60e260acfa" translate="yes" xml:space="preserve">
          <source>identifiers beginning with an underscore</source>
          <target state="translated">밑줄로 시작하는 식별자</target>
        </trans-unit>
        <trans-unit id="d4ab2ef9be0eef371126d2a11d047dbb6f5b2681" translate="yes" xml:space="preserve">
          <source>identifiers beginning with an underscore followed immediately by an uppercase letter</source>
          <target state="translated">밑줄로 시작하고 바로 대문자가 나오는 식별자</target>
        </trans-unit>
        <trans-unit id="ba7418871c901ba8e6a177f348bf0f753c0e4364" translate="yes" xml:space="preserve">
          <source>identifiers containing adjacent underscores (or &quot;double underscore&quot;)</source>
          <target state="translated">인접한 밑줄 (또는 &quot;이중 밑줄&quot;)을 포함하는 식별자</target>
        </trans-unit>
        <trans-unit id="f7beaeda3ce73aef06674e6d116cd9c5641d680e" translate="yes" xml:space="preserve">
          <source>may be used for additional character testing and conversion functions.</source>
          <target state="translated">추가 문자 테스트 및 변환 기능에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2722be763842585a40ed07b059ad9701cea8ea4" translate="yes" xml:space="preserve">
          <source>may be used for additional error code names.</source>
          <target state="translated">추가 오류 코드 이름에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a2bae39937a1970dc9cd1bccd55355c8998319b" translate="yes" xml:space="preserve">
          <source>may be used for additional macros specifying locale attributes.</source>
          <target state="translated">로케일 속성을 지정하는 추가 매크로에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="557f255516719ea16f8f4a0aae1166054e2c9b43" translate="yes" xml:space="preserve">
          <source>not</source>
          <target state="translated">not</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
