<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/229551">
    <body>
      <group id="229551">
        <trans-unit id="4f1e5ad8e7700bae29e22e576f2507b97f40977b" translate="yes" xml:space="preserve">
          <source>(doContain was in F. Houri's answer)</source>
          <target state="translated">鳳里さんの答えにはdoContainが入っていました</target>
        </trans-unit>
        <trans-unit id="be46e7b4cc6448f6be65eeb4435bb7e64f03aa9b" translate="yes" xml:space="preserve">
          <source>... Or if the submitted string could be empty, as pointed out by @Sjlver, the function would become:</source>
          <target state="translated">...あるいは、@Sjlverさんが指摘されているように、投稿された文字列が空であれば、関数は次のようになります。</target>
        </trans-unit>
        <trans-unit id="c06ad1dc1636e6130aa84e6c9e61de55b0897567" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://sourceforge.net/projects/oobash/&quot;&gt;oobash is available at Sourceforge.net&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://sourceforge.net/projects/oobash/&quot;&gt;oobashはSourceforge.netから入手できます&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce59810a221d4d0241a88280897a301d251468e2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/229606/65706&quot;&gt;This Stack&amp;nbsp;Overflow answer&lt;/a&gt; was the only one to trap space and dash characters:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/229606/65706&quot;&gt;このスタックオーバーフローの回答&lt;/a&gt;は、スペースとダッシュ文字をトラップする唯一のものでした。</target>
        </trans-unit>
        <trans-unit id="9fb69b7c237477248ede5faa5a0a99e8b936ec35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;${var/search/replace}&lt;/code&gt; is &lt;code&gt;$var&lt;/code&gt; with the first instance of &lt;code&gt;search&lt;/code&gt; replaced by &lt;code&gt;replace&lt;/code&gt;, if it is found (it doesn't change &lt;code&gt;$var&lt;/code&gt;).  If you try to replace &lt;code&gt;foo&lt;/code&gt; by nothing, and the string has changed, then obviously &lt;code&gt;foo&lt;/code&gt; was found.</source>
          <target state="translated">&lt;code&gt;${var/search/replace}&lt;/code&gt; は &lt;code&gt;$var&lt;/code&gt; であり、 &lt;code&gt;search&lt;/code&gt; の最初のインスタンスが見つかった場合は &lt;code&gt;replace&lt;/code&gt; で置き換えられます（ &lt;code&gt;$var&lt;/code&gt; は変更されません）。 &lt;code&gt;foo&lt;/code&gt; を何も置き換えないで、文字列が変更されている場合、明らかに &lt;code&gt;foo&lt;/code&gt; が見つかりました。</target>
        </trans-unit>
        <trans-unit id="02440597a8dc4eaf07061ed8c380ac0fa3ddde8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;grep -q&lt;/code&gt; is useful for this purpose.</source>
          <target state="translated">&lt;code&gt;grep -q&lt;/code&gt; はこの目的に役立ちます。</target>
        </trans-unit>
        <trans-unit id="d8d22cc104a692c502f9dcdf46a40697fc074e64" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;or&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;or&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="262c08d242e194a475503f3ddae85beb67be35ff" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;
&lt;pre&gt;&lt;code&gt;stringContain() { [ -z &quot;${2##*$1*}&quot; ] &amp;amp;&amp;amp; { [ -z &quot;$1&quot; ] || [ -n &quot;$2&quot; ];};}&lt;/code&gt;&lt;/pre&gt;
&lt;/s&gt;</source>
          <target state="translated">&lt;pre&gt; &lt;code&gt;stringContain() { [ -z &quot;${2##*$1*}&quot; ] &amp;amp;&amp;amp; { [ -z &quot;$1&quot; ] || [ -n &quot;$2&quot; ];};}&lt;/code&gt; [-n &quot;$ 2&quot;];};} &lt;/pre&gt;</target>
        </trans-unit>
        <trans-unit id="010c661d1fb43bba739b7cb040acac1b0434dd71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Another one:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;別のもの：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e3eede4bc55320f6db8f76fe2ab07e608226347" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notice:&lt;/strong&gt; you have to escape or double enclose quotes and/or double quotes:</source>
          <target state="translated">&lt;strong&gt;通知：&lt;/strong&gt;引用符や二重引用符をエスケープするか二重に囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="0f3676b065262a3cc3d142bcdc9330a1a1f7db25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The shortest more common syntax:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最も一般的で短い構文：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c537bf98dd31a0d977b5e80b6892d90404de004" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The shortest possible answer is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;可能な限り短い答えは：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c92a1433ba81b43f70d5e9f842f0c77688d59e5" translate="yes" xml:space="preserve">
          <source>And for giggles:</source>
          <target state="translated">笑いのためにも</target>
        </trans-unit>
        <trans-unit id="db13aef56248e44390bbd0abc778ddd42c214b59" translate="yes" xml:space="preserve">
          <source>And inverting the tests to make them potentially quicker:</source>
          <target state="translated">そして、テストを反転させることで、潜在的に早くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d1b74e82a5dba2d97da82dac574c858f6a98c7a1" translate="yes" xml:space="preserve">
          <source>And the negative test is:</source>
          <target state="translated">そして、陰性検査は</target>
        </trans-unit>
        <trans-unit id="c34ae6d493f798f32ec735f490380d6c1d09875f" translate="yes" xml:space="preserve">
          <source>Anyway, there is my</source>
          <target state="translated">とにかく、私の</target>
        </trans-unit>
        <trans-unit id="e037fe1c774746b6a7099771a2a494322f2d80ac" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash/25535717#25535717&quot;&gt;Paul mentioned&lt;/a&gt; in his performance comparison:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash/25535717#25535717&quot;&gt;Paulが&lt;/a&gt;パフォーマンスの比較で述べたように、</target>
        </trans-unit>
        <trans-unit id="922bc54a5a579a76f1ece57e7f74e66fb4c277d4" translate="yes" xml:space="preserve">
          <source>As asked by @EeroAaltonen here is a version of the same demo, tested under the same shells:</source>
          <target state="translated">EeroAaltonenさんに尋ねられたので、同じシェルでテストした同じデモのバージョンをご紹介します。</target>
        </trans-unit>
        <trans-unit id="d2fb3ddde2e624498a3eb014e47f69832abcf38b" translate="yes" xml:space="preserve">
          <source>As there are already a lot of answers using Bash-specific features, there is a way working under poorer-featured shells, like &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBox&lt;/a&gt;:</source>
          <target state="translated">Bash固有の機能を使用した回答はすでにたくさんあるので、 &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBoxの&lt;/a&gt;ように、機能の不十分なシェルで作業する方法があります。</target>
        </trans-unit>
        <trans-unit id="225ed72f87a3d280bec08850c3e075fe50f53eab" translate="yes" xml:space="preserve">
          <source>As these Stack Overflow answers tell mostly about &lt;a href=&quot;https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt;, I've posted a &lt;strong&gt;&lt;em&gt;case independent&lt;/em&gt;&lt;/strong&gt; Bash function at the very bottom of this post...</source>
          <target state="translated">これらのスタックオーバーフローの回答は主に&lt;a href=&quot;https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt;について説明しているため、この記事の一番下に、 &lt;strong&gt;&lt;em&gt;ケースに依存しない&lt;/em&gt;&lt;/strong&gt; Bash関数を掲載しました...</target>
        </trans-unit>
        <trans-unit id="effe3ac2d370fbcd7d8e7bc4ff5ef45545205b4e" translate="yes" xml:space="preserve">
          <source>Bash 4+ examples. Note: not using quotes will cause issues when words contain spaces, etc. Always quote in Bash, IMO.</source>
          <target state="translated">Bash 4+の例。注意:引用符を使わないと、単語にスペースなどが含まれている場合に問題が発生します。Bash では常に引用符を使うようにしましょう。</target>
        </trans-unit>
        <trans-unit id="51f5714425544a933fff954cc61323ebb4c26d1f" translate="yes" xml:space="preserve">
          <source>Case independent (Bash only!)</source>
          <target state="translated">ケースに依存しない(Bashのみ</target>
        </trans-unit>
        <trans-unit id="695ef898e510e9ef840415d2a34e4e257f942169" translate="yes" xml:space="preserve">
          <source>Check:</source>
          <target state="translated">Check:</target>
        </trans-unit>
        <trans-unit id="7ddb85b199646d03ea7e873a475814fb11dfb2d1" translate="yes" xml:space="preserve">
          <source>Compatible answer</source>
          <target state="translated">互換性のある回答</target>
        </trans-unit>
        <trans-unit id="892bca9e97ffe70e549cfc884ffd13d8cc625429" translate="yes" xml:space="preserve">
          <source>Edit, Logic:</source>
          <target state="translated">編集、ロジック。</target>
        </trans-unit>
        <trans-unit id="ebccf9f9cb0a1762288f48f17418ac002bad85c9" translate="yes" xml:space="preserve">
          <source>Enjoy.</source>
          <target state="translated">Enjoy.</target>
        </trans-unit>
        <trans-unit id="69097a723cd31efec844d7fde911b59ecc09ca5b" translate="yes" xml:space="preserve">
          <source>Exact word match:</source>
          <target state="translated">正確に一致しています。</target>
        </trans-unit>
        <trans-unit id="173a6c3a5ac2733cbcc2e6f244340ba2e75ae32b" translate="yes" xml:space="preserve">
          <source>Example 1, check for 'yes' in string (case insensitive):</source>
          <target state="translated">例1、文字列の中に 'yes' が含まれているかどうかをチェックします(大文字小文字を区別しません)。</target>
        </trans-unit>
        <trans-unit id="d399f190be27d51e61e03a7adfd5446fe06aa865" translate="yes" xml:space="preserve">
          <source>Example 2, check for 'yes' in string (case insensitive):</source>
          <target state="translated">例2、文字列の中に'yes'が含まれているかどうかをチェックします(大文字小文字を区別しません)。</target>
        </trans-unit>
        <trans-unit id="d0f92ea135d3a68b9d36e1b7c5ff92aedbe92b60" translate="yes" xml:space="preserve">
          <source>Example 3, check for 'yes' in string (case sensitive):</source>
          <target state="translated">例3、文字列の中に'yes'があるかどうかをチェックします(大文字と小文字は区別されます)。</target>
        </trans-unit>
        <trans-unit id="7d89a69eb0be5ce9662a1e5ff3c3dee06988aeed" translate="yes" xml:space="preserve">
          <source>Example 4, check for 'yes' in string (case sensitive):</source>
          <target state="translated">例4、文字列の中に'yes'があるかどうかをチェックします(大文字と小文字は区別されます)。</target>
        </trans-unit>
        <trans-unit id="f44971a13cdd8d8fe806ae9cac62cb0b90c325ab" translate="yes" xml:space="preserve">
          <source>Example 5, exact match (case sensitive):</source>
          <target state="translated">例5、完全一致(大文字と小文字を区別します)。</target>
        </trans-unit>
        <trans-unit id="369d42c68ee6bd8bd1ed0652f935cbe68927c9ec" translate="yes" xml:space="preserve">
          <source>Example 6, exact match (case insensitive):</source>
          <target state="translated">例6、完全一致(大文字小文字を区別しない)。</target>
        </trans-unit>
        <trans-unit id="2acc5561d3d49a5ff155a5e1884e89b38d34b821" translate="yes" xml:space="preserve">
          <source>Example 7, exact match:</source>
          <target state="translated">例7、完全一致。</target>
        </trans-unit>
        <trans-unit id="d23a962229404e7fe44cb89a6f75a71ff8769d50" translate="yes" xml:space="preserve">
          <source>Example 8, wildcard match .ext (case insensitive):</source>
          <target state="translated">例 8、ワイルドカードマッチ .ext (大文字小文字を区別しない)。</target>
        </trans-unit>
        <trans-unit id="6c731b6e35967aa40e1b21f8de19b6b266661f6e" translate="yes" xml:space="preserve">
          <source>Extension of the question answered here &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-posix-sh/8811800#8811800&quot;&gt;How do you tell if a string contains another string in POSIX sh?&lt;/a&gt;&lt;/em&gt;:</source>
          <target state="translated">ここで回答された質問の拡張&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-posix-sh/8811800#8811800&quot;&gt;文字列にPOSIX shの別の文字列が含まれて&lt;/a&gt;&lt;/em&gt;いる&lt;em&gt;かどうかはどのようにしてわかりますか&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="9f15d9822c28e13a629d8ac86ffc2b38d93253d1" translate="yes" xml:space="preserve">
          <source>Final (simple) function:</source>
          <target state="translated">最終的な(単純な)関数。</target>
        </trans-unit>
        <trans-unit id="afaf351cc8bc671c1122f18b02bf08d5d65f2db8" translate="yes" xml:space="preserve">
          <source>For testing strings without care of case, simply convert each string to lower case:</source>
          <target state="translated">大文字小文字を気にせずに文字列をテストするには、各文字列を小文字に変換するだけです。</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="57f1c7ae6f1c5a8b52ab15e232adac5a21829a75" translate="yes" xml:space="preserve">
          <source>Here are some examples Bash 4+:</source>
          <target state="translated">ここではBash 4+の例を紹介します。</target>
        </trans-unit>
        <trans-unit id="17aca0cf466b23a9d66f040adc39824d44c21641" translate="yes" xml:space="preserve">
          <source>How about this:</source>
          <target state="translated">これはどうでしょうか。</target>
        </trans-unit>
        <trans-unit id="fe270742d9797d2162bcd53a31c8951a0343607f" translate="yes" xml:space="preserve">
          <source>How can I test if it contains another string?</source>
          <target state="translated">他の文字列が含まれているかどうかをテストするにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="95dd20dcbf621be2e40ab607cb036e828fed7b08" translate="yes" xml:space="preserve">
          <source>How to check if a string contains a substring in Bash</source>
          <target state="translated">Bashで文字列に部分文字列が含まれているかどうかを調べる方法</target>
        </trans-unit>
        <trans-unit id="0c9aea63107871cfc94fc2a05cb9f2fb490b0e8c" translate="yes" xml:space="preserve">
          <source>I am not sure about using an if statement, but you can get a similar effect with a case statement:</source>
          <target state="translated">if文を使うのはよくわかりませんが、case文を使っても似たような効果が得られます。</target>
        </trans-unit>
        <trans-unit id="1f86fcfc46f06e0f0c48d474a10e6b55a456ac60" translate="yes" xml:space="preserve">
          <source>I found to need this functionality quite frequently, so I'm using a home-made shell function in my &lt;code&gt;.bashrc&lt;/code&gt; like this which allows me to reuse it as often as I need to, with an easy to remember name:</source>
          <target state="translated">私はこの機能が非常に頻繁に必要であることがわかったので、 &lt;code&gt;.bashrc&lt;/code&gt; で次のように自家製のシェル関数を使用しています。これにより、覚えやすい名前で、必要なだけ何度でも再利用できます。</target>
        </trans-unit>
        <trans-unit id="d1d79a08de42ed131c01dda0dbb4fb3eae14dbec" translate="yes" xml:space="preserve">
          <source>I have a string in Bash:</source>
          <target state="translated">Bashに文字列を入れています。</target>
        </trans-unit>
        <trans-unit id="07e16ea28e587d61093b00c18c91b1281d4512cd" translate="yes" xml:space="preserve">
          <source>I like sed.</source>
          <target state="translated">私はセドが好きです。</target>
        </trans-unit>
        <trans-unit id="887df2307714e62c0d246755651999ed46dbc24a" translate="yes" xml:space="preserve">
          <source>I suppose this style is a bit more classic -- less dependent upon features of Bash shell.</source>
          <target state="translated">このスタイルはもう少し古典的で、Bash シェルの機能に依存しないものだと思います。</target>
        </trans-unit>
        <trans-unit id="515be8566de141dd75b98a24220f28e58a239995" translate="yes" xml:space="preserve">
          <source>I use this function (one dependency not included but obvious). It passes the tests shown below. If the function returns a value &amp;gt; 0 then the string was found. You could just as easily return 1 or 0 instead.</source>
          <target state="translated">私はこの関数を使用しています（1つの依存関係は含まれていませんが、明白です）。 以下に示すテストに合格しています。 関数が0より大きい値を返す場合、文字列が見つかりました。 代わりに、簡単に1または0を返すこともできます。</target>
        </trans-unit>
        <trans-unit id="c19277bc9bb01cd6d21acaa75d6533222356ab57" translate="yes" xml:space="preserve">
          <source>If new string differs from old string, substring exists</source>
          <target state="translated">新しい文字列が古い文字列と異なる場合、部分文字列が存在する</target>
        </trans-unit>
        <trans-unit id="d3009b74b0f6a442bffc337ae96e4330ba6f9762" translate="yes" xml:space="preserve">
          <source>If the PATH environment variable includes my two &lt;code&gt;bin&lt;/code&gt; directories, don't append them,</source>
          <target state="translated">PATH環境変数に2つの &lt;code&gt;bin&lt;/code&gt; ディレクトリが含まれている場合は、追加しないでください。</target>
        </trans-unit>
        <trans-unit id="c315deddf56b21d7db8499456996014f50b45b77" translate="yes" xml:space="preserve">
          <source>If you prefer the regex approach:</source>
          <target state="translated">正規表現のアプローチがお好きな方は、以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="e5b71f64cdea7e0b117ad16cf755ff6c5f6b2ab8" translate="yes" xml:space="preserve">
          <source>In practice, this could give:</source>
          <target state="translated">実際には、これは与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="7e57ac036ebdeacb1061d4eecf5e8b6aecfab0ea" translate="yes" xml:space="preserve">
          <source>Into one function</source>
          <target state="translated">一つの機能に</target>
        </trans-unit>
        <trans-unit id="9bbb0f8d52003342f824db72225299e6771a9b66" translate="yes" xml:space="preserve">
          <source>It is an OO-style string library for Bash 4. It has support for German umlauts. It is written in Bash.</source>
          <target state="translated">Bash 4 用の OO スタイルの文字列ライブラリです。ドイツ語の umlauts をサポートしています。Bash で書かれています。</target>
        </trans-unit>
        <trans-unit id="5b60559fd8e2d2e8e3af93f7c4acc4a9ffbf1885" translate="yes" xml:space="preserve">
          <source>Just do:</source>
          <target state="translated">そうしてくれ</target>
        </trans-unit>
        <trans-unit id="7bb95adb8a3d6249e7b57b2475b84299f5b08786" translate="yes" xml:space="preserve">
          <source>Look at the &lt;em&gt;contains&lt;/em&gt; example:</source>
          <target state="translated">&lt;em&gt;含む&lt;/em&gt;例を見てください：</target>
        </trans-unit>
        <trans-unit id="f661652d101aa2c3462857563d32b3d28b1cd297" translate="yes" xml:space="preserve">
          <source>Many functions are available: &lt;code&gt;-base64Decode&lt;/code&gt;, &lt;code&gt;-base64Encode&lt;/code&gt;, &lt;code&gt;-capitalize&lt;/code&gt;, &lt;code&gt;-center&lt;/code&gt;, &lt;code&gt;-charAt&lt;/code&gt;, &lt;code&gt;-concat&lt;/code&gt;, &lt;code&gt;-contains&lt;/code&gt;, &lt;code&gt;-count&lt;/code&gt;, &lt;code&gt;-endsWith&lt;/code&gt;, &lt;code&gt;-equals&lt;/code&gt;, &lt;code&gt;-equalsIgnoreCase&lt;/code&gt;, &lt;code&gt;-reverse&lt;/code&gt;, &lt;code&gt;-hashCode&lt;/code&gt;, &lt;code&gt;-indexOf&lt;/code&gt;, &lt;code&gt;-isAlnum&lt;/code&gt;, &lt;code&gt;-isAlpha&lt;/code&gt;, &lt;code&gt;-isAscii&lt;/code&gt;, &lt;code&gt;-isDigit&lt;/code&gt;, &lt;code&gt;-isEmpty&lt;/code&gt;, &lt;code&gt;-isHexDigit&lt;/code&gt;, &lt;code&gt;-isLowerCase&lt;/code&gt;, &lt;code&gt;-isSpace&lt;/code&gt;, &lt;code&gt;-isPrintable&lt;/code&gt;, &lt;code&gt;-isUpperCase&lt;/code&gt;, &lt;code&gt;-isVisible&lt;/code&gt;, &lt;code&gt;-lastIndexOf&lt;/code&gt;, &lt;code&gt;-length&lt;/code&gt;, &lt;code&gt;-matches&lt;/code&gt;, &lt;code&gt;-replaceAll&lt;/code&gt;, &lt;code&gt;-replaceFirst&lt;/code&gt;, &lt;code&gt;-startsWith&lt;/code&gt;, &lt;code&gt;-substring&lt;/code&gt;, &lt;code&gt;-swapCase&lt;/code&gt;, &lt;code&gt;-toLowerCase&lt;/code&gt;, &lt;code&gt;-toString&lt;/code&gt;, &lt;code&gt;-toUpperCase&lt;/code&gt;, &lt;code&gt;-trim&lt;/code&gt;, and &lt;code&gt;-zfill&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-base64Encode&lt;/code&gt; 、 &lt;code&gt;-capitalize&lt;/code&gt; 、 &lt;code&gt;-center&lt;/code&gt; 、 &lt;code&gt;-charAt&lt;/code&gt; 、 &lt;code&gt;-concat&lt;/code&gt; 、 &lt;code&gt;-count&lt;/code&gt; 、 &lt;code&gt;-endsWith&lt;/code&gt; 、 &lt;code&gt;-equals&lt;/code&gt; 、 &lt;code&gt;-equalsIgnoreCase&lt;/code&gt; 、 &lt;code&gt;-reverse&lt;/code&gt; 、 &lt;code&gt;-hashCode&lt;/code&gt; 、 &lt;code&gt;-indexOf&lt;/code&gt; 、 &lt;code&gt;-isAlnum&lt;/code&gt; 、 -indexOf 、 -isAlnum 、 &lt;code&gt;-isAlpha&lt;/code&gt; 、 -isAscii 、 &lt;code&gt;-isAscii&lt;/code&gt; 、 &lt;code&gt;-isDigit&lt;/code&gt; 、 &lt;code&gt;-isEmpty&lt;/code&gt; 、 &lt;code&gt;-isHexDigit&lt;/code&gt; 、 &lt;code&gt;-isLowerCase&lt;/code&gt; 、 &lt;code&gt;-isSpace&lt;/code&gt; 、 &lt;code&gt;-isPrintable&lt;/code&gt; 、 &lt;code&gt;-isUpperCase&lt;/code&gt; 、 &lt;code&gt;-isVisible&lt;/code&gt; 、 &lt;code&gt;-lastIndexOf&lt;/code&gt; 、 &lt;code&gt;-length&lt;/code&gt; 、 &lt;code&gt;-replaceAll&lt;/code&gt; 、 &lt;code&gt;-replaceFirst&lt;/code&gt; 、 &lt;code&gt;-startsWith&lt;/code&gt; 、 &lt;code&gt;-substring&lt;/code&gt; 、 &lt;code&gt;-swapCase&lt;/code&gt; 、 &lt;code&gt;-toLowerCase&lt;/code&gt; 、 &lt;code&gt;-toString&lt;/code&gt; 、 &lt;code&gt;-toUpperCase&lt;/code&gt; 、 &lt;code&gt;-trim&lt;/code&gt; 、および &lt;code&gt;-zfill&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80853e0e01cb527403d3a8a5100dca4f383e74e3" translate="yes" xml:space="preserve">
          <source>My &lt;em&gt;.bash_profile&lt;/em&gt; file and how I used grep:</source>
          <target state="translated">私の&lt;em&gt;.bash_profile&lt;/em&gt;ファイルとgrepの使用方法：</target>
        </trans-unit>
        <trans-unit id="d205cbd6783332a212c5ae92d73c77178c2d2f28" translate="yes" xml:space="preserve">
          <source>Not Found</source>
          <target state="translated">見つかりません</target>
        </trans-unit>
        <trans-unit id="3c1d5fa77fb597e0fbcc6936cdb4f26b5cf47e3d" translate="yes" xml:space="preserve">
          <source>Note that spaces in the needle string need to be placed between double quotes, and the &lt;code&gt;*&lt;/code&gt; wildcards should be outside.</source>
          <target state="translated">ニードル文字列のスペースは二重引用符で囲み、 &lt;code&gt;*&lt;/code&gt; ワイルドカードは外側に置く必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4da9c60d264b84bda32ecbbc64de2e6e09d8a062" translate="yes" xml:space="preserve">
          <source>Note that the &lt;strong&gt;&lt;em&gt;double hash&lt;/em&gt;&lt;/strong&gt; is &lt;strong&gt;obligatory&lt;/strong&gt; with some shells (&lt;code&gt;ash&lt;/code&gt;). Above will evaluate &lt;code&gt;[ stringvalue ]&lt;/code&gt; when the substring is not found. It returns no error. When the substring is found the result is empty and it evaluates &lt;code&gt;[  ]&lt;/code&gt;. This will throw error code 1 since the string is completely substituted (due to &lt;code&gt;*&lt;/code&gt;).</source>
          <target state="translated">一部のシェル（ &lt;code&gt;ash&lt;/code&gt; ）では&lt;strong&gt;&lt;em&gt;二重ハッシュ&lt;/em&gt;&lt;/strong&gt;が&lt;strong&gt;必須&lt;/strong&gt;であることに注意してください。 上記は、部分文字列が見つからない場合に &lt;code&gt;[ stringvalue ]&lt;/code&gt; を評価します。 エラーは返されません。 部分文字列が見つかると、結果は空になり、 &lt;code&gt;[ ]&lt;/code&gt; と評価されます 。 文字列は完全に置換されているため（ &lt;code&gt;*&lt;/code&gt; のため）、エラーコード1がスローされます。</target>
        </trans-unit>
        <trans-unit id="a7e22cef61d6a4559056d343b2d7b27b372c45fc" translate="yes" xml:space="preserve">
          <source>Note the &lt;em&gt;single&lt;/em&gt; equal sign!</source>
          <target state="translated">&lt;em&gt;単一の&lt;/em&gt;等号に注意してください！</target>
        </trans-unit>
        <trans-unit id="e5bda8dadbc43cc07ddf173eff1b450e3877f436" translate="yes" xml:space="preserve">
          <source>Note: In a tight loop this code will be &lt;em&gt;much&lt;/em&gt; slower than using internal Bash shell features, as one (or two) separate processes will be created and connected via pipes.</source>
          <target state="translated">注：タイトなループでは、1つ（または2つ）の別個のプロセスが作成され、パイプを介して接続される&lt;em&gt;ため、&lt;/em&gt;このコードは内部のBashシェル機能を使用するよりも&lt;em&gt;はるかに&lt;/em&gt;遅くなります。</target>
        </trans-unit>
        <trans-unit id="6700c09499ea6d07de8131986b08b9ac36f15543" translate="yes" xml:space="preserve">
          <source>Now that you are thinking of &lt;code&gt;if&lt;/code&gt; as testing the exit status of the command that follows it (complete with semi-colon), why not reconsider the source of the string you are testing?</source>
          <target state="translated">次のコマンドの終了ステータス（セミコロンで終了）をテストするとしたら、テストしている文字列のソースを再検討してみませんか？</target>
        </trans-unit>
        <trans-unit id="30162b854d9ed3fea419e8ddeecc844d99147437" translate="yes" xml:space="preserve">
          <source>One is:</source>
          <target state="translated">一つは</target>
        </trans-unit>
        <trans-unit id="e05dc4137c6b3ed21b3a2ff06b745c595be9b611" translate="yes" xml:space="preserve">
          <source>Original source: &lt;a href=&quot;http://unstableme.blogspot.com/2008/06/bash-search-letter-in-string-awk.html&quot;&gt;http://unstableme.blogspot.com/2008/06/bash-search-letter-in-string-awk.html&lt;/a&gt;</source>
          <target state="translated">元のソース： &lt;a href=&quot;http://unstableme.blogspot.com/2008/06/bash-search-letter-in-string-awk.html&quot;&gt;http&lt;/a&gt; : //unstableme.blogspot.com/2008/06/bash-search-letter-in-string-awk.html</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="73a40ef8e0ce62a8dee7a6a70e61bcc146e2af40" translate="yes" xml:space="preserve">
          <source>Piping out to 100000 greps is predictably painful! The old rule about using external utilities without need holds true.</source>
          <target state="translated">100,000grepsへのパイプアウトは予想通り痛い! 外部ユーティリティを必要とせずに使うことについての古いルールは真実です。</target>
        </trans-unit>
        <trans-unit id="2ca0522ba097286571c8040abe6d273b0f7a1e2f" translate="yes" xml:space="preserve">
          <source>Repeated tests using this frame:</source>
          <target state="translated">このフレームを使ってテストを繰り返す。</target>
        </trans-unit>
        <trans-unit id="188631a0ea8375d052603fde6af8d85039a770eb" translate="yes" xml:space="preserve">
          <source>Replacing TEST each time:</source>
          <target state="translated">毎回TESTを入れ替えています。</target>
        </trans-unit>
        <trans-unit id="cde8d71a70567d48dd01952e68d8fa1e0ed18bca" translate="yes" xml:space="preserve">
          <source>Simple function</source>
          <target state="translated">シンプルな機能</target>
        </trans-unit>
        <trans-unit id="6e5b7558085cb3e2c945526fe4ee73eb84ae3fc5" translate="yes" xml:space="preserve">
          <source>Since the &lt;a href=&quot;http://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-unix-shell-scripting&quot;&gt;POSIX&lt;/a&gt;/BusyBox question is closed without providing the right answer (IMHO), I'll post an answer here.</source>
          <target state="translated">&lt;a href=&quot;http://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-unix-shell-scripting&quot;&gt;POSIX&lt;/a&gt; / BusyBoxの質問は正しい答え（IMHO）を提供せずに閉じられているので、ここに答えを投稿します。</target>
        </trans-unit>
        <trans-unit id="db21feedbc9aa9ba75ff56cb343c6107d036834f" translate="yes" xml:space="preserve">
          <source>So the simple substitution option predictably wins whether in an extended test or a case. The case is portable.</source>
          <target state="translated">そのため、拡張テストでもケースでも、単純な置換オプションが予測的に勝利します。ケースはポータブルです。</target>
        </trans-unit>
        <trans-unit id="610d30b5678cf5afa169f222a35e0e5a2f15994d" translate="yes" xml:space="preserve">
          <source>So there are lots of useful solutions to the question - but which is fastest / uses the fewest resources?</source>
          <target state="translated">このように、この質問に対する有用な解決策はたくさんあります。</target>
        </trans-unit>
        <trans-unit id="88466c04ba8da871f4aa89c1461c2cb8c6606f22" translate="yes" xml:space="preserve">
          <source>That looks a bit clumsy.</source>
          <target state="translated">ちょっと不器用な感じがしますね。</target>
        </trans-unit>
        <trans-unit id="f1f9e6eca6a5bd9062b5288ce4a8ba81996af93d" translate="yes" xml:space="preserve">
          <source>That's all folks!</source>
          <target state="translated">以上です。</target>
        </trans-unit>
        <trans-unit id="e94f8bcac040276040cde0ffbd04e3b118465f08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; argument is pure POSIX paranoia, used to protected against input strings similar to options, such as &lt;code&gt;--abc&lt;/code&gt; or &lt;code&gt;-a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 引数は純粋なPOSIXパラノイアであり、 &lt;code&gt;-a&lt;/code&gt; &lt;code&gt;--abc&lt;/code&gt; や-aなどのオプションと同様の入力文字列から保護するために使用されます。</target>
        </trans-unit>
        <trans-unit id="2c034229c41ed9e6cfb54be9dd4719cecca93984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; option makes grep not output anything, as we only want the return code. &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; makes the shell expand the next word and use it as the input to the command, a one-line version of the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; here document (I'm not sure whether this is standard or a Bashism).</source>
          <target state="translated">&lt;code&gt;-q&lt;/code&gt; オプションを指定すると、戻りコードのみが必要になるため、grepは何も出力しません。 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; は、シェルに次の単語を展開させ、コマンドへの入力として使用します。これは、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; hereドキュメントの1行バージョンです（これが標準かBashismかはわかりません）。</target>
        </trans-unit>
        <trans-unit id="a0fef26f00222171da27eb68674f5fd70f3a4eae" translate="yes" xml:space="preserve">
          <source>The accepted answer is best, but since there's more than one way to do it, here's another solution:</source>
          <target state="translated">受け入れられている答えがベストですが、方法は1つではないので、ここに別の解決策があります。</target>
        </trans-unit>
        <trans-unit id="02c3c3cff15d5e1a96b4ad601f5c6a24f8352f7a" translate="yes" xml:space="preserve">
          <source>The generic &lt;strong&gt;needle haystack&lt;/strong&gt; example is following with &lt;strong&gt;variables&lt;/strong&gt;</source>
          <target state="translated">一般的な&lt;strong&gt;針の干し草の&lt;/strong&gt;例は、 &lt;strong&gt;変数を使用&lt;/strong&gt;してい&lt;strong&gt;ます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc948761ae41726ed6a10afbab205d011d47f760" translate="yes" xml:space="preserve">
          <source>The same using &lt;code&gt;awk&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;awk&lt;/code&gt; を使用して同じ：</target>
        </trans-unit>
        <trans-unit id="8538e476443c2ada4cd268740d743e6097cf0423" translate="yes" xml:space="preserve">
          <source>Then now:</source>
          <target state="translated">ならば今だ。</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="a098d19baf23b8d9b125d553c65e0bf6487bd982" translate="yes" xml:space="preserve">
          <source>This also works:</source>
          <target state="translated">これも効きます。</target>
        </trans-unit>
        <trans-unit id="46b21bfb29653168fbd8431bba0e1e02b99786fd" translate="yes" xml:space="preserve">
          <source>This is POSIX compliant like the 'case &quot;$string&quot; in' &lt;a href=&quot;https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash/229585#229585&quot;&gt;the answer provided by Marcus&lt;/a&gt;, but it is slightly easier to read than the case statement answer. Also note that this will be much much slower than using a case statement. As Paul pointed out, don't use it in a loop.</source>
          <target state="translated">これは&lt;a href=&quot;https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash/229585#229585&quot;&gt;、Marcus&lt;/a&gt;が提供する回答の 「case &quot;$ string&quot;」のようにPOSIXに準拠していますが、caseステートメントの回答よりも少し読みやすくなっています。 これは、caseステートメントを使用するよりもはるかに遅くなることにも注意してください。 Paulが指摘したように、ループで使用しないでください。</target>
        </trans-unit>
        <trans-unit id="5eda6ee2b7d1314431b986cd70865bc997958646" translate="yes" xml:space="preserve">
          <source>This is the same answer as &lt;a href=&quot;https://stackoverflow.com/a/229585/11267590&quot;&gt;https://stackoverflow.com/a/229585/11267590&lt;/a&gt;. But simple style and also POSIX Compliant.</source>
          <target state="translated">これは&lt;a href=&quot;https://stackoverflow.com/a/229585/11267590&quot;&gt;https://stackoverflow.com/a/229585/11267590&lt;/a&gt;と同じ答えです。 しかし、シンプルなスタイルであり、POSIXにも準拠しています。</target>
        </trans-unit>
        <trans-unit id="3c71adde6ff5a2b53a2bd5f5238fef6b700223df" translate="yes" xml:space="preserve">
          <source>This solution works with special characters:</source>
          <target state="translated">このソリューションは特殊文字で動作します。</target>
        </trans-unit>
        <trans-unit id="5609110098faeccbc8b6bf29a6d459916681df00" translate="yes" xml:space="preserve">
          <source>This was tested under Bash, &lt;a href=&quot;https://en.wikipedia.org/wiki/Almquist_shell#dash:_Ubuntu,_Debian_and_POSIX_compliance_of_Linux_distributions&quot;&gt;Dash&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/KornShell&quot;&gt;KornShell&lt;/a&gt; (&lt;code&gt;ksh&lt;/code&gt;) and &lt;a href=&quot;https://en.wikipedia.org/wiki/Almquist_shell&quot;&gt;ash&lt;/a&gt; (BusyBox), and the result is always:</source>
          <target state="translated">これはBash、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Almquist_shell#dash:_Ubuntu,_Debian_and_POSIX_compliance_of_Linux_distributions&quot;&gt;Dash&lt;/a&gt; 、 &lt;a href=&quot;https://en.wikipedia.org/wiki/KornShell&quot;&gt;KornShell&lt;/a&gt; （ &lt;code&gt;ksh&lt;/code&gt; ）および&lt;a href=&quot;https://en.wikipedia.org/wiki/Almquist_shell&quot;&gt;ash&lt;/a&gt; （BusyBox）でテストされ、結果は常に次のようになります。</target>
        </trans-unit>
        <trans-unit id="9fa7eb0eb358606d0fa272801482e54b9c8746b9" translate="yes" xml:space="preserve">
          <source>This was tested under BusyBox, Dash, and, of course Bash:</source>
          <target state="translated">これは BusyBox,Dash,そしてもちろん Bash でテストされました。</target>
        </trans-unit>
        <trans-unit id="81d4dbcf36e813617ba9dc3910f860a5f8c27d84" translate="yes" xml:space="preserve">
          <source>This will find any occurance of a or b or c</source>
          <target state="translated">これは、aまたはbまたはcのいずれかの発生を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="fc870ce71b68cd6792a1af728d9889ac153b2151" translate="yes" xml:space="preserve">
          <source>To test if &lt;code&gt;$string1&lt;/code&gt; (say, &lt;em&gt;abc&lt;/em&gt;) is contained in &lt;code&gt;$string2&lt;/code&gt; (say, &lt;em&gt;123abcABC&lt;/em&gt;) I just need to run &lt;code&gt;stringinstring &quot;$string1&quot; &quot;$string2&quot;&lt;/code&gt; and check for the return value, for example</source>
          <target state="translated">&lt;code&gt;$string1&lt;/code&gt; （たとえば、 &lt;em&gt;abc&lt;/em&gt; ）が &lt;code&gt;$string2&lt;/code&gt; （たとえば、 &lt;em&gt;123abcABC&lt;/em&gt; ）に含まれているかどうかをテストするには、 &lt;em&gt;stringinstring&lt;/em&gt; &lt;code&gt;stringinstring &quot;$string1&quot; &quot;$string2&quot;&lt;/code&gt; を実行して戻り値を確認するだけです。たとえば、</target>
        </trans-unit>
        <trans-unit id="17dbdba5e46698f4cd72a491059a73ff4075149d" translate="yes" xml:space="preserve">
          <source>Try oobash.</source>
          <target state="translated">ウーバッシュを試してみてください。</target>
        </trans-unit>
        <trans-unit id="d71f52abe159007463b06bb92456907642c43f7f" translate="yes" xml:space="preserve">
          <source>Use sed to remove instance of substring from string</source>
          <target state="translated">文字列から部分文字列のインスタンスを削除するために sed を使用します。</target>
        </trans-unit>
        <trans-unit id="c605311e1464cae876e8029c0ad56bb778346f4f" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;??&lt;/code&gt; is my unknown operator. Do I use echo and &lt;code&gt;grep&lt;/code&gt;?</source>
          <target state="translated">どこ &lt;code&gt;??&lt;/code&gt; 私の知らないオペレーターです。 echoと &lt;code&gt;grep&lt;/code&gt; を使用しますか？</target>
        </trans-unit>
        <trans-unit id="302d6a318e71d51fce0a3cc0368397d02ea16822" translate="yes" xml:space="preserve">
          <source>With empty strings:</source>
          <target state="translated">空の文字列で</target>
        </trans-unit>
        <trans-unit id="f044eacb833ca35d71be5f2f649e48ae05ba2fae" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://stackoverflow.com/a/229585/3755692&quot;&gt;Marcus's answer (* wildcards)&lt;/a&gt; outside a case statement, too, if you use double brackets:</source>
          <target state="translated">二重括弧を使用すれば、 &lt;a href=&quot;https://stackoverflow.com/a/229585/3755692&quot;&gt;Marcusの回答（*ワイルドカード）を&lt;/a&gt; caseステートメントの外でも使用できます。</target>
        </trans-unit>
        <trans-unit id="80487628e20ecfac243c2e07db31e814d74556d1" translate="yes" xml:space="preserve">
          <source>You should remember that shell scripting is less of a language and more of a collection of commands. Instinctively you think that this &quot;language&quot; requires you to follow an &lt;code&gt;if&lt;/code&gt; with a &lt;code&gt;[&lt;/code&gt; or a &lt;code&gt;[[&lt;/code&gt;. Both of those are just commands that return an exit status indicating success or failure (just like every other command). For that reason I'd use &lt;code&gt;grep&lt;/code&gt;, and not the &lt;code&gt;[&lt;/code&gt; command.</source>
          <target state="translated">シェルスクリプトは言語ではなく、コマンドの集まりであることに注意してください。 本能的には、この「言語」では、 &lt;code&gt;if&lt;/code&gt; または &lt;code&gt;[[&lt;/code&gt; を使用する必要があります。 これらは両方とも、（他のすべてのコマンドと同様に）成功または失敗を示す終了ステータスを返すコマンドです。 そのため、 &lt;code&gt;[&lt;/code&gt; コマンドではなく &lt;code&gt;grep&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="bb0646ea089ef817b14359d9d5c5f4d27cb59fdf" translate="yes" xml:space="preserve">
          <source>or as suggested by &lt;a href=&quot;https://stackoverflow.com/posts/comments/86532588&quot;&gt;Adrian G&amp;uuml;nter's comment&lt;/a&gt;, avoiding &lt;code&gt;-o&lt;/code&gt; switches:</source>
          <target state="translated">または &lt;code&gt;-o&lt;/code&gt; スイッチを避けて、 &lt;a href=&quot;https://stackoverflow.com/posts/comments/86532588&quot;&gt;AdrianG&amp;uuml;nterのコメント&lt;/a&gt;で示唆されているように：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
