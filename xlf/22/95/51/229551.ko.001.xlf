<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/229551">
    <body>
      <group id="229551">
        <trans-unit id="4f1e5ad8e7700bae29e22e576f2507b97f40977b" translate="yes" xml:space="preserve">
          <source>(doContain was in F. Houri's answer)</source>
          <target state="translated">(do는 F. Houri의 답변에 포함되었습니다)</target>
        </trans-unit>
        <trans-unit id="be46e7b4cc6448f6be65eeb4435bb7e64f03aa9b" translate="yes" xml:space="preserve">
          <source>... Or if the submitted string could be empty, as pointed out by @Sjlver, the function would become:</source>
          <target state="translated">... 또는 @Sjlver가 지적한 것처럼 제출 된 문자열이 비어 있으면 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c06ad1dc1636e6130aa84e6c9e61de55b0897567" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://sourceforge.net/projects/oobash/&quot;&gt;oobash is available at Sourceforge.net&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://sourceforge.net/projects/oobash/&quot;&gt;oobash는 Sourceforge.net에서 사용 가능&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ce59810a221d4d0241a88280897a301d251468e2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/229606/65706&quot;&gt;This Stack&amp;nbsp;Overflow answer&lt;/a&gt; was the only one to trap space and dash characters:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/229606/65706&quot;&gt;이 스택 오버플로 응답&lt;/a&gt; 은 공간과 대시 문자를 잡는 유일한 방법이었습니다.</target>
        </trans-unit>
        <trans-unit id="9fb69b7c237477248ede5faa5a0a99e8b936ec35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;${var/search/replace}&lt;/code&gt; is &lt;code&gt;$var&lt;/code&gt; with the first instance of &lt;code&gt;search&lt;/code&gt; replaced by &lt;code&gt;replace&lt;/code&gt;, if it is found (it doesn't change &lt;code&gt;$var&lt;/code&gt;).  If you try to replace &lt;code&gt;foo&lt;/code&gt; by nothing, and the string has changed, then obviously &lt;code&gt;foo&lt;/code&gt; was found.</source>
          <target state="translated">&lt;code&gt;${var/search/replace}&lt;/code&gt; 는 검색 의 첫 번째 인스턴스가 발견되면 &lt;code&gt;replace&lt;/code&gt; 로 대체 된 &lt;code&gt;$var&lt;/code&gt; 입니다 ( $ var 는 변경되지 않음). &lt;code&gt;foo&lt;/code&gt; 를 아무것도 바꾸지 않고 문자열이 변경되면 분명히 &lt;code&gt;foo&lt;/code&gt; 가 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="02440597a8dc4eaf07061ed8c380ac0fa3ddde8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;grep -q&lt;/code&gt; is useful for this purpose.</source>
          <target state="translated">&lt;code&gt;grep -q&lt;/code&gt; 는이 목적에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d8d22cc104a692c502f9dcdf46a40697fc074e64" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;or&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;or&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="262c08d242e194a475503f3ddae85beb67be35ff" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;
&lt;pre&gt;&lt;code&gt;stringContain() { [ -z &quot;${2##*$1*}&quot; ] &amp;amp;&amp;amp; { [ -z &quot;$1&quot; ] || [ -n &quot;$2&quot; ];};}&lt;/code&gt;&lt;/pre&gt;
&lt;/s&gt;</source>
          <target state="translated">&lt;pre&gt; &lt;code&gt;stringContain() { [ -z &quot;${2##*$1*}&quot; ] &amp;amp;&amp;amp; { [ -z &quot;$1&quot; ] || [ -n &quot;$2&quot; ];};}&lt;/code&gt; [-n &quot;$ 2&quot;];};} &lt;/pre&gt;</target>
        </trans-unit>
        <trans-unit id="010c661d1fb43bba739b7cb040acac1b0434dd71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Another one:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다른 것:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e3eede4bc55320f6db8f76fe2ab07e608226347" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notice:&lt;/strong&gt; you have to escape or double enclose quotes and/or double quotes:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 따옴표 및 / 또는 큰 따옴표를 이스케이프하거나 큰 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="0f3676b065262a3cc3d142bcdc9330a1a1f7db25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The shortest more common syntax:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가장 짧은 가장 일반적인 구문 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c537bf98dd31a0d977b5e80b6892d90404de004" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The shortest possible answer is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가능한 가장 짧은 대답은 다음과 같습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c92a1433ba81b43f70d5e9f842f0c77688d59e5" translate="yes" xml:space="preserve">
          <source>And for giggles:</source>
          <target state="translated">그리고 낄낄 거림 :</target>
        </trans-unit>
        <trans-unit id="db13aef56248e44390bbd0abc778ddd42c214b59" translate="yes" xml:space="preserve">
          <source>And inverting the tests to make them potentially quicker:</source>
          <target state="translated">그리고 테스트를 뒤집어 잠재적으로 더 빨리 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1b74e82a5dba2d97da82dac574c858f6a98c7a1" translate="yes" xml:space="preserve">
          <source>And the negative test is:</source>
          <target state="translated">그리고 부정적인 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c34ae6d493f798f32ec735f490380d6c1d09875f" translate="yes" xml:space="preserve">
          <source>Anyway, there is my</source>
          <target state="translated">어쨌든 내</target>
        </trans-unit>
        <trans-unit id="e037fe1c774746b6a7099771a2a494322f2d80ac" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash/25535717#25535717&quot;&gt;Paul mentioned&lt;/a&gt; in his performance comparison:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash/25535717#25535717&quot;&gt;Paul&lt;/a&gt; 이 그의 성능 비교에서 언급 한 것처럼 :</target>
        </trans-unit>
        <trans-unit id="922bc54a5a579a76f1ece57e7f74e66fb4c277d4" translate="yes" xml:space="preserve">
          <source>As asked by @EeroAaltonen here is a version of the same demo, tested under the same shells:</source>
          <target state="translated">@EeroAaltonen의 요청에 따라 동일한 쉘에서 테스트 한 동일한 데모 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2fb3ddde2e624498a3eb014e47f69832abcf38b" translate="yes" xml:space="preserve">
          <source>As there are already a lot of answers using Bash-specific features, there is a way working under poorer-featured shells, like &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBox&lt;/a&gt;:</source>
          <target state="translated">Bash 관련 기능을 사용하는 답변이 이미 많으 &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;므로 BusyBox&lt;/a&gt; 와 같이 기능이 불량한 쉘에서 작동하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="225ed72f87a3d280bec08850c3e075fe50f53eab" translate="yes" xml:space="preserve">
          <source>As these Stack Overflow answers tell mostly about &lt;a href=&quot;https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt;, I've posted a &lt;strong&gt;&lt;em&gt;case independent&lt;/em&gt;&lt;/strong&gt; Bash function at the very bottom of this post...</source>
          <target state="translated">이 스택 오버플로 답변이 대부분 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; 에 대해 알려주 듯이이 게시물 맨 아래에 &lt;strong&gt;&lt;em&gt;사례 독립적&lt;/em&gt;&lt;/strong&gt; Bash 함수를 게시했습니다 ...</target>
        </trans-unit>
        <trans-unit id="effe3ac2d370fbcd7d8e7bc4ff5ef45545205b4e" translate="yes" xml:space="preserve">
          <source>Bash 4+ examples. Note: not using quotes will cause issues when words contain spaces, etc. Always quote in Bash, IMO.</source>
          <target state="translated">배쉬 4+ 예제. 참고 : 따옴표를 사용하지 않으면 단어에 공백 등이 포함 된 경우 문제가 발생할 수 있습니다. 항상 Bash, IMO로 인용하십시오.</target>
        </trans-unit>
        <trans-unit id="51f5714425544a933fff954cc61323ebb4c26d1f" translate="yes" xml:space="preserve">
          <source>Case independent (Bash only!)</source>
          <target state="translated">대소 문자 구분 (Bash 만 해당)</target>
        </trans-unit>
        <trans-unit id="695ef898e510e9ef840415d2a34e4e257f942169" translate="yes" xml:space="preserve">
          <source>Check:</source>
          <target state="translated">Check:</target>
        </trans-unit>
        <trans-unit id="7ddb85b199646d03ea7e873a475814fb11dfb2d1" translate="yes" xml:space="preserve">
          <source>Compatible answer</source>
          <target state="translated">호환되는 답변</target>
        </trans-unit>
        <trans-unit id="892bca9e97ffe70e549cfc884ffd13d8cc625429" translate="yes" xml:space="preserve">
          <source>Edit, Logic:</source>
          <target state="translated">편집, 논리 :</target>
        </trans-unit>
        <trans-unit id="ebccf9f9cb0a1762288f48f17418ac002bad85c9" translate="yes" xml:space="preserve">
          <source>Enjoy.</source>
          <target state="translated">Enjoy.</target>
        </trans-unit>
        <trans-unit id="69097a723cd31efec844d7fde911b59ecc09ca5b" translate="yes" xml:space="preserve">
          <source>Exact word match:</source>
          <target state="translated">정확한 단어 일치 :</target>
        </trans-unit>
        <trans-unit id="173a6c3a5ac2733cbcc2e6f244340ba2e75ae32b" translate="yes" xml:space="preserve">
          <source>Example 1, check for 'yes' in string (case insensitive):</source>
          <target state="translated">예제 1, 문자열에서 'yes'를 확인하십시오 (대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="d399f190be27d51e61e03a7adfd5446fe06aa865" translate="yes" xml:space="preserve">
          <source>Example 2, check for 'yes' in string (case insensitive):</source>
          <target state="translated">예제 2, 문자열에서 'yes'를 확인하십시오 (대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="d0f92ea135d3a68b9d36e1b7c5ff92aedbe92b60" translate="yes" xml:space="preserve">
          <source>Example 3, check for 'yes' in string (case sensitive):</source>
          <target state="translated">예제 3, 문자열에서 'yes'를 확인하십시오 (대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="7d89a69eb0be5ce9662a1e5ff3c3dee06988aeed" translate="yes" xml:space="preserve">
          <source>Example 4, check for 'yes' in string (case sensitive):</source>
          <target state="translated">예제 4, 문자열에서 'yes'를 확인하십시오 (대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="f44971a13cdd8d8fe806ae9cac62cb0b90c325ab" translate="yes" xml:space="preserve">
          <source>Example 5, exact match (case sensitive):</source>
          <target state="translated">예 5, 정확히 일치 (대소 문자 구분) :</target>
        </trans-unit>
        <trans-unit id="369d42c68ee6bd8bd1ed0652f935cbe68927c9ec" translate="yes" xml:space="preserve">
          <source>Example 6, exact match (case insensitive):</source>
          <target state="translated">예 6, 정확히 일치 (대소 문자 구분) :</target>
        </trans-unit>
        <trans-unit id="2acc5561d3d49a5ff155a5e1884e89b38d34b821" translate="yes" xml:space="preserve">
          <source>Example 7, exact match:</source>
          <target state="translated">예제 7, 정확히 일치하는 내용 :</target>
        </trans-unit>
        <trans-unit id="d23a962229404e7fe44cb89a6f75a71ff8769d50" translate="yes" xml:space="preserve">
          <source>Example 8, wildcard match .ext (case insensitive):</source>
          <target state="translated">예 8, 와일드 카드 일치 .ext (대소 문자 구분) :</target>
        </trans-unit>
        <trans-unit id="6c731b6e35967aa40e1b21f8de19b6b266661f6e" translate="yes" xml:space="preserve">
          <source>Extension of the question answered here &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-posix-sh/8811800#8811800&quot;&gt;How do you tell if a string contains another string in POSIX sh?&lt;/a&gt;&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-posix-sh/8811800#8811800&quot;&gt;POSIX sh에서 문자열에 다른 문자열이 포함되어 있는지 어떻게 알 수 있습니까?&lt;/a&gt;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="9f15d9822c28e13a629d8ac86ffc2b38d93253d1" translate="yes" xml:space="preserve">
          <source>Final (simple) function:</source>
          <target state="translated">최종 (간단한) 기능 :</target>
        </trans-unit>
        <trans-unit id="afaf351cc8bc671c1122f18b02bf08d5d65f2db8" translate="yes" xml:space="preserve">
          <source>For testing strings without care of case, simply convert each string to lower case:</source>
          <target state="translated">대소 문자를 구분하지 않고 문자열을 테스트하려면 각 문자열을 소문자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="57f1c7ae6f1c5a8b52ab15e232adac5a21829a75" translate="yes" xml:space="preserve">
          <source>Here are some examples Bash 4+:</source>
          <target state="translated">Bash 4+의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17aca0cf466b23a9d66f040adc39824d44c21641" translate="yes" xml:space="preserve">
          <source>How about this:</source>
          <target state="translated">이것은 어떤가요:</target>
        </trans-unit>
        <trans-unit id="fe270742d9797d2162bcd53a31c8951a0343607f" translate="yes" xml:space="preserve">
          <source>How can I test if it contains another string?</source>
          <target state="translated">다른 문자열이 포함되어 있는지 어떻게 테스트 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="95dd20dcbf621be2e40ab607cb036e828fed7b08" translate="yes" xml:space="preserve">
          <source>How to check if a string contains a substring in Bash</source>
          <target state="translated">Bash에서 문자열에 하위 문자열이 포함되어 있는지 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="0c9aea63107871cfc94fc2a05cb9f2fb490b0e8c" translate="yes" xml:space="preserve">
          <source>I am not sure about using an if statement, but you can get a similar effect with a case statement:</source>
          <target state="translated">if 문을 사용할지는 확실하지 않지만 case 문을 사용하면 비슷한 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f86fcfc46f06e0f0c48d474a10e6b55a456ac60" translate="yes" xml:space="preserve">
          <source>I found to need this functionality quite frequently, so I'm using a home-made shell function in my &lt;code&gt;.bashrc&lt;/code&gt; like this which allows me to reuse it as often as I need to, with an easy to remember name:</source>
          <target state="translated">이 기능이 자주 필요하다는 것을 알았습니다. 따라서 &lt;code&gt;.bashrc&lt;/code&gt; 에서 집에서 만든 쉘 함수를 사용하여 기억하기 쉬운 이름으로 필요할 때마다 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1d79a08de42ed131c01dda0dbb4fb3eae14dbec" translate="yes" xml:space="preserve">
          <source>I have a string in Bash:</source>
          <target state="translated">Bash에 문자열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e16ea28e587d61093b00c18c91b1281d4512cd" translate="yes" xml:space="preserve">
          <source>I like sed.</source>
          <target state="translated">나는 sed를 좋아한다.</target>
        </trans-unit>
        <trans-unit id="887df2307714e62c0d246755651999ed46dbc24a" translate="yes" xml:space="preserve">
          <source>I suppose this style is a bit more classic -- less dependent upon features of Bash shell.</source>
          <target state="translated">이 스타일은 조금 더 고전적이며 Bash 쉘의 기능에 덜 의존적이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="515be8566de141dd75b98a24220f28e58a239995" translate="yes" xml:space="preserve">
          <source>I use this function (one dependency not included but obvious). It passes the tests shown below. If the function returns a value &amp;gt; 0 then the string was found. You could just as easily return 1 or 0 instead.</source>
          <target state="translated">나는이 기능을 사용한다 (하나의 의존성은 포함되어 있지 않지만 명백하다). 아래에 표시된 테스트를 통과합니다. 함수가 0보다 큰 값을 반환하면 문자열이 발견 된 것입니다. 대신 1 또는 0을 쉽게 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c19277bc9bb01cd6d21acaa75d6533222356ab57" translate="yes" xml:space="preserve">
          <source>If new string differs from old string, substring exists</source>
          <target state="translated">새 문자열이 이전 문자열과 다른 경우 하위 문자열이 존재합니다</target>
        </trans-unit>
        <trans-unit id="d3009b74b0f6a442bffc337ae96e4330ba6f9762" translate="yes" xml:space="preserve">
          <source>If the PATH environment variable includes my two &lt;code&gt;bin&lt;/code&gt; directories, don't append them,</source>
          <target state="translated">PATH 환경 변수에 두 개의 &lt;code&gt;bin&lt;/code&gt; 디렉토리가 포함되어 있으면 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c315deddf56b21d7db8499456996014f50b45b77" translate="yes" xml:space="preserve">
          <source>If you prefer the regex approach:</source>
          <target state="translated">정규식 접근 방식을 선호하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e5b71f64cdea7e0b117ad16cf755ff6c5f6b2ab8" translate="yes" xml:space="preserve">
          <source>In practice, this could give:</source>
          <target state="translated">실제로 이것은 다음을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e57ac036ebdeacb1061d4eecf5e8b6aecfab0ea" translate="yes" xml:space="preserve">
          <source>Into one function</source>
          <target state="translated">하나의 기능으로</target>
        </trans-unit>
        <trans-unit id="9bbb0f8d52003342f824db72225299e6771a9b66" translate="yes" xml:space="preserve">
          <source>It is an OO-style string library for Bash 4. It has support for German umlauts. It is written in Bash.</source>
          <target state="translated">Bash 4를위한 OO 스타일 문자열 라이브러리입니다. 독일 움라우트를 지원합니다. Bash로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="5b60559fd8e2d2e8e3af93f7c4acc4a9ffbf1885" translate="yes" xml:space="preserve">
          <source>Just do:</source>
          <target state="translated">그냥 해:</target>
        </trans-unit>
        <trans-unit id="7bb95adb8a3d6249e7b57b2475b84299f5b08786" translate="yes" xml:space="preserve">
          <source>Look at the &lt;em&gt;contains&lt;/em&gt; example:</source>
          <target state="translated">&lt;em&gt;포함&lt;/em&gt; 예제를보십시오.</target>
        </trans-unit>
        <trans-unit id="f661652d101aa2c3462857563d32b3d28b1cd297" translate="yes" xml:space="preserve">
          <source>Many functions are available: &lt;code&gt;-base64Decode&lt;/code&gt;, &lt;code&gt;-base64Encode&lt;/code&gt;, &lt;code&gt;-capitalize&lt;/code&gt;, &lt;code&gt;-center&lt;/code&gt;, &lt;code&gt;-charAt&lt;/code&gt;, &lt;code&gt;-concat&lt;/code&gt;, &lt;code&gt;-contains&lt;/code&gt;, &lt;code&gt;-count&lt;/code&gt;, &lt;code&gt;-endsWith&lt;/code&gt;, &lt;code&gt;-equals&lt;/code&gt;, &lt;code&gt;-equalsIgnoreCase&lt;/code&gt;, &lt;code&gt;-reverse&lt;/code&gt;, &lt;code&gt;-hashCode&lt;/code&gt;, &lt;code&gt;-indexOf&lt;/code&gt;, &lt;code&gt;-isAlnum&lt;/code&gt;, &lt;code&gt;-isAlpha&lt;/code&gt;, &lt;code&gt;-isAscii&lt;/code&gt;, &lt;code&gt;-isDigit&lt;/code&gt;, &lt;code&gt;-isEmpty&lt;/code&gt;, &lt;code&gt;-isHexDigit&lt;/code&gt;, &lt;code&gt;-isLowerCase&lt;/code&gt;, &lt;code&gt;-isSpace&lt;/code&gt;, &lt;code&gt;-isPrintable&lt;/code&gt;, &lt;code&gt;-isUpperCase&lt;/code&gt;, &lt;code&gt;-isVisible&lt;/code&gt;, &lt;code&gt;-lastIndexOf&lt;/code&gt;, &lt;code&gt;-length&lt;/code&gt;, &lt;code&gt;-matches&lt;/code&gt;, &lt;code&gt;-replaceAll&lt;/code&gt;, &lt;code&gt;-replaceFirst&lt;/code&gt;, &lt;code&gt;-startsWith&lt;/code&gt;, &lt;code&gt;-substring&lt;/code&gt;, &lt;code&gt;-swapCase&lt;/code&gt;, &lt;code&gt;-toLowerCase&lt;/code&gt;, &lt;code&gt;-toString&lt;/code&gt;, &lt;code&gt;-toUpperCase&lt;/code&gt;, &lt;code&gt;-trim&lt;/code&gt;, and &lt;code&gt;-zfill&lt;/code&gt;.</source>
          <target state="translated">많은 기능을 사용할 수 있습니다 : &lt;code&gt;-base64Decode&lt;/code&gt; , -base64Encode , &lt;code&gt;-base64Encode&lt;/code&gt; , &lt;code&gt;-center&lt;/code&gt; , &lt;code&gt;-charAt&lt;/code&gt; , &lt;code&gt;-concat&lt;/code&gt; , &lt;code&gt;-contains&lt;/code&gt; , &lt;code&gt;-count&lt;/code&gt; , &lt;code&gt;-endsWith&lt;/code&gt; , &lt;code&gt;-equals&lt;/code&gt; , &lt;code&gt;-equalsIgnoreCase&lt;/code&gt; , &lt;code&gt;-reverse&lt;/code&gt; , &lt;code&gt;-hashCode&lt;/code&gt; , &lt;code&gt;-indexOf&lt;/code&gt; , &lt;code&gt;-isAlnum&lt;/code&gt; , &lt;code&gt;-isAlpha&lt;/code&gt; , &lt;code&gt;-isAscii&lt;/code&gt; , -isDigit , -isEmpty , &lt;code&gt;-isDigit&lt;/code&gt; , &lt;code&gt;-isEmpty&lt;/code&gt; , &lt;code&gt;-isHexDigit&lt;/code&gt; , &lt;code&gt;-isLowerCase&lt;/code&gt; , &lt;code&gt;-isSpace&lt;/code&gt; , &lt;code&gt;-isPrintable&lt;/code&gt; , &lt;code&gt;-isUpperCase&lt;/code&gt; , &lt;code&gt;-isVisible&lt;/code&gt; , &lt;code&gt;-lastIndexOf&lt;/code&gt; , &lt;code&gt;-replaceFirst&lt;/code&gt; , &lt;code&gt;-substring&lt;/code&gt; , &lt;code&gt;-swapCase&lt;/code&gt; , &lt;code&gt;-toLowerCase&lt;/code&gt; , &lt;code&gt;-toString&lt;/code&gt; , &lt;code&gt;-toUpperCase&lt;/code&gt; , &lt;code&gt;-trim&lt;/code&gt; 및 &lt;code&gt;-zfill&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80853e0e01cb527403d3a8a5100dca4f383e74e3" translate="yes" xml:space="preserve">
          <source>My &lt;em&gt;.bash_profile&lt;/em&gt; file and how I used grep:</source>
          <target state="translated">내 &lt;em&gt;.bash_profile&lt;/em&gt; 파일 및 grep 사용 방법 :</target>
        </trans-unit>
        <trans-unit id="d205cbd6783332a212c5ae92d73c77178c2d2f28" translate="yes" xml:space="preserve">
          <source>Not Found</source>
          <target state="translated">찾을 수 없음</target>
        </trans-unit>
        <trans-unit id="3c1d5fa77fb597e0fbcc6936cdb4f26b5cf47e3d" translate="yes" xml:space="preserve">
          <source>Note that spaces in the needle string need to be placed between double quotes, and the &lt;code&gt;*&lt;/code&gt; wildcards should be outside.</source>
          <target state="translated">needle string의 공백은 큰 따옴표로 묶어야하며 &lt;code&gt;*&lt;/code&gt; 와일드 카드는 외부에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4da9c60d264b84bda32ecbbc64de2e6e09d8a062" translate="yes" xml:space="preserve">
          <source>Note that the &lt;strong&gt;&lt;em&gt;double hash&lt;/em&gt;&lt;/strong&gt; is &lt;strong&gt;obligatory&lt;/strong&gt; with some shells (&lt;code&gt;ash&lt;/code&gt;). Above will evaluate &lt;code&gt;[ stringvalue ]&lt;/code&gt; when the substring is not found. It returns no error. When the substring is found the result is empty and it evaluates &lt;code&gt;[  ]&lt;/code&gt;. This will throw error code 1 since the string is completely substituted (due to &lt;code&gt;*&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;이중&lt;/em&gt;&lt;/strong&gt; 쉘은 일부 쉘 ( &lt;code&gt;ash&lt;/code&gt; )에서는 &lt;strong&gt;필수&lt;/strong&gt; 입니다. 하위 문자열을 찾을 수 없으면 위의 문자열 값을 평가합니다. 오류가 없습니다. 부분 문자열이 발견되면 결과는 비어 있으며 &lt;code&gt;[ ]&lt;/code&gt; 평가됩니다. 문자열이 완전히 대체되기 때문에 ( &lt;code&gt;*&lt;/code&gt; 때문에) 오류 코드 1이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7e22cef61d6a4559056d343b2d7b27b372c45fc" translate="yes" xml:space="preserve">
          <source>Note the &lt;em&gt;single&lt;/em&gt; equal sign!</source>
          <target state="translated">&lt;em&gt;단일&lt;/em&gt; 등호를 참고하십시오!</target>
        </trans-unit>
        <trans-unit id="e5bda8dadbc43cc07ddf173eff1b450e3877f436" translate="yes" xml:space="preserve">
          <source>Note: In a tight loop this code will be &lt;em&gt;much&lt;/em&gt; slower than using internal Bash shell features, as one (or two) separate processes will be created and connected via pipes.</source>
          <target state="translated">참고 : 긴밀한 루프에서이 코드는 내부 Bash 셸 기능을 사용하는 것보다 &lt;em&gt;훨씬&lt;/em&gt; 느립니다. 파이프를 통해 하나 또는 두 개의 개별 프로세스가 만들어지고 연결되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6700c09499ea6d07de8131986b08b9ac36f15543" translate="yes" xml:space="preserve">
          <source>Now that you are thinking of &lt;code&gt;if&lt;/code&gt; as testing the exit status of the command that follows it (complete with semi-colon), why not reconsider the source of the string you are testing?</source>
          <target state="translated">이제 명령 뒤에 나오는 명령의 종료 상태 (세미콜론으로 완료)를 테스트 할 때 테스트중인 문자열의 소스를 다시 고려해보십시오.</target>
        </trans-unit>
        <trans-unit id="30162b854d9ed3fea419e8ddeecc844d99147437" translate="yes" xml:space="preserve">
          <source>One is:</source>
          <target state="translated">하나는:</target>
        </trans-unit>
        <trans-unit id="e05dc4137c6b3ed21b3a2ff06b745c595be9b611" translate="yes" xml:space="preserve">
          <source>Original source: &lt;a href=&quot;http://unstableme.blogspot.com/2008/06/bash-search-letter-in-string-awk.html&quot;&gt;http://unstableme.blogspot.com/2008/06/bash-search-letter-in-string-awk.html&lt;/a&gt;</source>
          <target state="translated">원본 출처 : &lt;a href=&quot;http://unstableme.blogspot.com/2008/06/bash-search-letter-in-string-awk.html&quot;&gt;http://unstableme.blogspot.com/2008/06/bash-search-letter-in-string-awk.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="73a40ef8e0ce62a8dee7a6a70e61bcc146e2af40" translate="yes" xml:space="preserve">
          <source>Piping out to 100000 greps is predictably painful! The old rule about using external utilities without need holds true.</source>
          <target state="translated">100 만 그렙까지 배관하는 것은 예상치 못한 고통입니다! 필요없이 외부 유틸리티를 사용하는 것에 대한 기존의 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ca0522ba097286571c8040abe6d273b0f7a1e2f" translate="yes" xml:space="preserve">
          <source>Repeated tests using this frame:</source>
          <target state="translated">이 프레임을 사용하여 반복 테스트 :</target>
        </trans-unit>
        <trans-unit id="188631a0ea8375d052603fde6af8d85039a770eb" translate="yes" xml:space="preserve">
          <source>Replacing TEST each time:</source>
          <target state="translated">매번 테스트 교체 :</target>
        </trans-unit>
        <trans-unit id="cde8d71a70567d48dd01952e68d8fa1e0ed18bca" translate="yes" xml:space="preserve">
          <source>Simple function</source>
          <target state="translated">간단한 기능</target>
        </trans-unit>
        <trans-unit id="6e5b7558085cb3e2c945526fe4ee73eb84ae3fc5" translate="yes" xml:space="preserve">
          <source>Since the &lt;a href=&quot;http://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-unix-shell-scripting&quot;&gt;POSIX&lt;/a&gt;/BusyBox question is closed without providing the right answer (IMHO), I'll post an answer here.</source>
          <target state="translated">&lt;a href=&quot;http://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-unix-shell-scripting&quot;&gt;POSIX&lt;/a&gt; / BusyBox 질문은 정답 (IMHO)을 제공하지 않고 마감되었으므로 여기에 답변을 게시하겠습니다.</target>
        </trans-unit>
        <trans-unit id="db21feedbc9aa9ba75ff56cb343c6107d036834f" translate="yes" xml:space="preserve">
          <source>So the simple substitution option predictably wins whether in an extended test or a case. The case is portable.</source>
          <target state="translated">따라서 간단한 대체 옵션은 연장 된 테스트 또는 사례에서 예측 가능합니다. 휴대용 케이스입니다.</target>
        </trans-unit>
        <trans-unit id="610d30b5678cf5afa169f222a35e0e5a2f15994d" translate="yes" xml:space="preserve">
          <source>So there are lots of useful solutions to the question - but which is fastest / uses the fewest resources?</source>
          <target state="translated">따라서이 질문에 대한 유용한 솔루션이 많이 있지만 가장 빠르거나 가장 적은 리소스를 사용하는 솔루션은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="88466c04ba8da871f4aa89c1461c2cb8c6606f22" translate="yes" xml:space="preserve">
          <source>That looks a bit clumsy.</source>
          <target state="translated">약간 서투른 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1f9e6eca6a5bd9062b5288ce4a8ba81996af93d" translate="yes" xml:space="preserve">
          <source>That's all folks!</source>
          <target state="translated">그게 다야!</target>
        </trans-unit>
        <trans-unit id="e94f8bcac040276040cde0ffbd04e3b118465f08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; argument is pure POSIX paranoia, used to protected against input strings similar to options, such as &lt;code&gt;--abc&lt;/code&gt; or &lt;code&gt;-a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 인수는 순수 POSIX 편집증이며 &lt;code&gt;--abc&lt;/code&gt; 또는 &lt;code&gt;-a&lt;/code&gt; 와 같은 옵션과 유사한 입력 문자열로부터 보호하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c034229c41ed9e6cfb54be9dd4719cecca93984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; option makes grep not output anything, as we only want the return code. &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; makes the shell expand the next word and use it as the input to the command, a one-line version of the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; here document (I'm not sure whether this is standard or a Bashism).</source>
          <target state="translated">&lt;code&gt;-q&lt;/code&gt; 옵션은 grep이 리턴 코드 만 원하므로 아무것도 출력하지 않도록합니다. &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 쉘은 다음 단어를 확장 시켜서 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; here 문서의 한 줄 버전 인 명령에 대한 입력으로 사용합니다 (이것이 표준인지 Bashism인지 확실하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="a0fef26f00222171da27eb68674f5fd70f3a4eae" translate="yes" xml:space="preserve">
          <source>The accepted answer is best, but since there's more than one way to do it, here's another solution:</source>
          <target state="translated">허용되는 답변이 가장 좋지만, 여러 가지 방법이 있으므로 여기에 다른 해결책이 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c3c3cff15d5e1a96b4ad601f5c6a24f8352f7a" translate="yes" xml:space="preserve">
          <source>The generic &lt;strong&gt;needle haystack&lt;/strong&gt; example is following with &lt;strong&gt;variables&lt;/strong&gt;</source>
          <target state="translated">일반적인 &lt;strong&gt;바늘 건초 더미&lt;/strong&gt; 예제는 &lt;strong&gt;변수를&lt;/strong&gt; &lt;strong&gt;따릅니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc948761ae41726ed6a10afbab205d011d47f760" translate="yes" xml:space="preserve">
          <source>The same using &lt;code&gt;awk&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;awk&lt;/code&gt; 를 사용하는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8538e476443c2ada4cd268740d743e6097cf0423" translate="yes" xml:space="preserve">
          <source>Then now:</source>
          <target state="translated">그런 다음 :</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="a098d19baf23b8d9b125d553c65e0bf6487bd982" translate="yes" xml:space="preserve">
          <source>This also works:</source>
          <target state="translated">이것은 또한 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="46b21bfb29653168fbd8431bba0e1e02b99786fd" translate="yes" xml:space="preserve">
          <source>This is POSIX compliant like the 'case &quot;$string&quot; in' &lt;a href=&quot;https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash/229585#229585&quot;&gt;the answer provided by Marcus&lt;/a&gt;, but it is slightly easier to read than the case statement answer. Also note that this will be much much slower than using a case statement. As Paul pointed out, don't use it in a loop.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash/229585#229585&quot;&gt;Marcus가 제공 한 답변&lt;/a&gt; 의 'case &quot;$ string&quot;과 같은 POSIX 호환이지만 case statement 답변보다 읽기 쉽습니다. 또한 case 문을 사용하는 것보다 훨씬 느릴 것입니다. Paul이 지적했듯이 루프에서 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5eda6ee2b7d1314431b986cd70865bc997958646" translate="yes" xml:space="preserve">
          <source>This is the same answer as &lt;a href=&quot;https://stackoverflow.com/a/229585/11267590&quot;&gt;https://stackoverflow.com/a/229585/11267590&lt;/a&gt;. But simple style and also POSIX Compliant.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://stackoverflow.com/a/229585/11267590&quot;&gt;https://stackoverflow.com/a/229585/11267590&lt;/a&gt; 과 같은 답변입니다. 그러나 간단한 스타일과 POSIX 호환.</target>
        </trans-unit>
        <trans-unit id="3c71adde6ff5a2b53a2bd5f5238fef6b700223df" translate="yes" xml:space="preserve">
          <source>This solution works with special characters:</source>
          <target state="translated">이 솔루션은 특수 문자와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5609110098faeccbc8b6bf29a6d459916681df00" translate="yes" xml:space="preserve">
          <source>This was tested under Bash, &lt;a href=&quot;https://en.wikipedia.org/wiki/Almquist_shell#dash:_Ubuntu,_Debian_and_POSIX_compliance_of_Linux_distributions&quot;&gt;Dash&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/KornShell&quot;&gt;KornShell&lt;/a&gt; (&lt;code&gt;ksh&lt;/code&gt;) and &lt;a href=&quot;https://en.wikipedia.org/wiki/Almquist_shell&quot;&gt;ash&lt;/a&gt; (BusyBox), and the result is always:</source>
          <target state="translated">이것은 Bash, &lt;a href=&quot;https://en.wikipedia.org/wiki/Almquist_shell#dash:_Ubuntu,_Debian_and_POSIX_compliance_of_Linux_distributions&quot;&gt;Dash&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/KornShell&quot;&gt;KornShell&lt;/a&gt; ( &lt;code&gt;ksh&lt;/code&gt; ) 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Almquist_shell&quot;&gt;ash&lt;/a&gt; (BusyBox)에서 테스트되었으며 결과는 항상 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9fa7eb0eb358606d0fa272801482e54b9c8746b9" translate="yes" xml:space="preserve">
          <source>This was tested under BusyBox, Dash, and, of course Bash:</source>
          <target state="translated">이것은 BusyBox, Dash 및 Bash에서 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="81d4dbcf36e813617ba9dc3910f860a5f8c27d84" translate="yes" xml:space="preserve">
          <source>This will find any occurance of a or b or c</source>
          <target state="translated">이것은 a 또는 b 또는 c의 발생을 찾을 것입니다</target>
        </trans-unit>
        <trans-unit id="fc870ce71b68cd6792a1af728d9889ac153b2151" translate="yes" xml:space="preserve">
          <source>To test if &lt;code&gt;$string1&lt;/code&gt; (say, &lt;em&gt;abc&lt;/em&gt;) is contained in &lt;code&gt;$string2&lt;/code&gt; (say, &lt;em&gt;123abcABC&lt;/em&gt;) I just need to run &lt;code&gt;stringinstring &quot;$string1&quot; &quot;$string2&quot;&lt;/code&gt; and check for the return value, for example</source>
          <target state="translated">&lt;code&gt;$string1&lt;/code&gt; (예 : &lt;em&gt;abc&lt;/em&gt; )이 &lt;code&gt;$string2&lt;/code&gt; (예 : &lt;em&gt;123abcABC&lt;/em&gt; )에 포함되어 있는지 테스트하려면 &lt;code&gt;stringinstring &quot;$string1&quot; &quot;$string2&quot;&lt;/code&gt; 를 실행하고 반환 값을 확인하면됩니다.</target>
        </trans-unit>
        <trans-unit id="17dbdba5e46698f4cd72a491059a73ff4075149d" translate="yes" xml:space="preserve">
          <source>Try oobash.</source>
          <target state="translated">oobash를 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="d71f52abe159007463b06bb92456907642c43f7f" translate="yes" xml:space="preserve">
          <source>Use sed to remove instance of substring from string</source>
          <target state="translated">sed를 사용하여 문자열에서 부분 문자열 인스턴스 제거</target>
        </trans-unit>
        <trans-unit id="c605311e1464cae876e8029c0ad56bb778346f4f" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;??&lt;/code&gt; is my unknown operator. Do I use echo and &lt;code&gt;grep&lt;/code&gt;?</source>
          <target state="translated">어디 &lt;code&gt;??&lt;/code&gt; 알 수없는 연산자입니다. echo와 &lt;code&gt;grep&lt;/code&gt; 을 사용 합니까?</target>
        </trans-unit>
        <trans-unit id="302d6a318e71d51fce0a3cc0368397d02ea16822" translate="yes" xml:space="preserve">
          <source>With empty strings:</source>
          <target state="translated">빈 문자열로 :</target>
        </trans-unit>
        <trans-unit id="f044eacb833ca35d71be5f2f649e48ae05ba2fae" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://stackoverflow.com/a/229585/3755692&quot;&gt;Marcus's answer (* wildcards)&lt;/a&gt; outside a case statement, too, if you use double brackets:</source>
          <target state="translated">이중 괄호를 사용하는 경우 &lt;a href=&quot;https://stackoverflow.com/a/229585/3755692&quot;&gt;Marcus의 답변 (* 와일드 카드)을&lt;/a&gt; case 문 외부에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80487628e20ecfac243c2e07db31e814d74556d1" translate="yes" xml:space="preserve">
          <source>You should remember that shell scripting is less of a language and more of a collection of commands. Instinctively you think that this &quot;language&quot; requires you to follow an &lt;code&gt;if&lt;/code&gt; with a &lt;code&gt;[&lt;/code&gt; or a &lt;code&gt;[[&lt;/code&gt;. Both of those are just commands that return an exit status indicating success or failure (just like every other command). For that reason I'd use &lt;code&gt;grep&lt;/code&gt;, and not the &lt;code&gt;[&lt;/code&gt; command.</source>
          <target state="translated">쉘 스크립팅은 언어가 아니며 명령 모음에 가깝습니다. 본능적으로이 &quot;언어&quot;는 &lt;code&gt;[&lt;/code&gt; 또는 &lt;code&gt;[[&lt;/code&gt; . 둘 다 다른 명령과 마찬가지로 성공 또는 실패를 나타내는 종료 상태를 리턴하는 명령 일뿐입니다. 따라서 &lt;code&gt;grep&lt;/code&gt; 을 사용하고 &lt;code&gt;[&lt;/code&gt; 명령은 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb0646ea089ef817b14359d9d5c5f4d27cb59fdf" translate="yes" xml:space="preserve">
          <source>or as suggested by &lt;a href=&quot;https://stackoverflow.com/posts/comments/86532588&quot;&gt;Adrian G&amp;uuml;nter's comment&lt;/a&gt;, avoiding &lt;code&gt;-o&lt;/code&gt; switches:</source>
          <target state="translated">또는 &lt;code&gt;-o&lt;/code&gt; 스위치를 피하면서 &lt;a href=&quot;https://stackoverflow.com/posts/comments/86532588&quot;&gt;Adrian G&amp;uuml;nter의 의견&lt;/a&gt; 에서 제안한대로 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
