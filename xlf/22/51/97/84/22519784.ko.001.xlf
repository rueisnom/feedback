<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/22519784">
    <body>
      <group id="22519784">
        <trans-unit id="0d1876b42ec40b07f0901b79d802642cbf3db6a6" translate="yes" xml:space="preserve">
          <source>(I recommend visiting &lt;a href=&quot;http://exploringjs.com/es6/ch_promises.html&quot;&gt;this beautiful source&lt;/a&gt;)</source>
          <target state="translated">( &lt;a href=&quot;http://exploringjs.com/es6/ch_promises.html&quot;&gt;이 아름다운 출처를&lt;/a&gt; 방문 하는 것이 좋습니다)</target>
        </trans-unit>
        <trans-unit id="1a9687b9fb765f1427325e76179dc016f46e0b7f" translate="yes" xml:space="preserve">
          <source>(The callback method is assumed to have two parameters as error and result)</source>
          <target state="translated">(콜백 메소드에는 오류 및 결과로 두 개의 매개 변수가 있다고 가정합니다)</target>
        </trans-unit>
        <trans-unit id="140ce27c605a99fd16b6f49c4709b30c0c0d5027" translate="yes" xml:space="preserve">
          <source>1. DOM load or other one time event:</source>
          <target state="translated">1. DOM로드 또는 다른 일회성 이벤트 :</target>
        </trans-unit>
        <trans-unit id="f3feb3b9a4fadb33bdde8b9e238c456eef319374" translate="yes" xml:space="preserve">
          <source>2. Plain callback:</source>
          <target state="translated">2. 일반 콜백 :</target>
        </trans-unit>
        <trans-unit id="b1f5dbf968434049e3d06c3fbc7b91c1c4a0074d" translate="yes" xml:space="preserve">
          <source>3. Node style callback (&quot;nodeback&quot;):</source>
          <target state="translated">3. 노드 스타일 콜백 ( &quot;nodeback&quot;) :</target>
        </trans-unit>
        <trans-unit id="e7d557519bf0bcedc91d45c78a25a683446c57c3" translate="yes" xml:space="preserve">
          <source>4. A whole library with node style callbacks:</source>
          <target state="translated">4. 노드 스타일 콜백이있는 전체 라이브러리 :</target>
        </trans-unit>
        <trans-unit id="508de91fce54d4813e92f47075de1963072ce810" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Promise&lt;/code&gt; can also be used on any platform that is based on Node.js like &lt;code&gt;react-native&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 는 &lt;code&gt;react-native&lt;/code&gt; 와 같은 Node.js를 기반으로하는 모든 플랫폼에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84481bb62537dcfe7b3728bba8f136ab65eb7d6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;es6-promisify&lt;/code&gt; converts callback-based functions to Promise-based functions.</source>
          <target state="translated">&lt;code&gt;es6-promisify&lt;/code&gt; 는 콜백 기반 함수를 Promise 기반 함수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6f191c2698c6eb0413bd6c2ca6e36474db531dfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/strong&gt; Javascript Async API code:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/strong&gt; 자바 스크립트 비동기 API 코드 :</target>
        </trans-unit>
        <trans-unit id="80f9f35a621c81865657b103d29cba17b5659e48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After Converting It&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;변환 후&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="020585adb8b12b4604a596236a3c07cee48318bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before converting a function as promise In Node.JS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Node.JS에서 약속으로 함수를 변환하기 전에&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="414958c0d8b719ec718c5694f1d7b1580ed56a22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bonus&lt;/strong&gt;: An &lt;strong&gt;hybrid&lt;/strong&gt; method</source>
          <target state="translated">&lt;strong&gt;보너스&lt;/strong&gt; : &lt;strong&gt;하이브리드&lt;/strong&gt; 방식</target>
        </trans-unit>
        <trans-unit id="46a4b2b972ff5677800784ab71c3a5efe0cda580" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incase you need to handle multiple request&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;여러 요청을 처리해야 할 경우&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89cf9925ff498ed29e9ef6df1f841c7bc121a96e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plain&lt;/strong&gt; Javascript Async API code:</source>
          <target state="translated">&lt;strong&gt;일반&lt;/strong&gt; 자바 스크립트 비동기 API 코드 :</target>
        </trans-unit>
        <trans-unit id="b8fb2f83aee2cbeff4ac6fcb5ea50cce08e5c218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fulfilled&lt;/strong&gt; meaning that the computation completed successfully.</source>
          <target state="translated">계산이 성공적으로 완료 &lt;strong&gt;되었음을&lt;/strong&gt; 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3030d3b7a04661fbb4185df915ebeef20d9e0313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rejected&lt;/strong&gt; meaning that the computation failed.</source>
          <target state="translated">계산이 실패했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="72577fd58c67ec9eaf27588179094e92bcbf92f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;toPromise&lt;/strong&gt; and &lt;strong&gt;checkErr&lt;/strong&gt; function is own by &lt;a href=&quot;https://github.com/jituanlin/berserk&quot;&gt;berserk&lt;/a&gt; library, it's a functional programming library fork by &lt;strong&gt;ramda.js&lt;/strong&gt;(create by me).</source>
          <target state="translated">&lt;strong&gt;toPromise&lt;/strong&gt; 및 &lt;strong&gt;checkErr&lt;/strong&gt; 함수는 &lt;a href=&quot;https://github.com/jituanlin/berserk&quot;&gt;berserk&lt;/a&gt; 라이브러리가 소유하고 있으며 &lt;strong&gt;ramda.js&lt;/strong&gt; 가 &lt;strong&gt;작성한&lt;/strong&gt; 함수형 프로그래밍 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="052ca2463678fe184067a71a1401d5432b9b5051" translate="yes" xml:space="preserve">
          <source>A simple and basic example to &lt;code&gt;Promise&lt;/code&gt; (with &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/KISS_principle&quot;&gt;KISS&lt;/a&gt;&lt;/strong&gt; way):</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 하는 간단하고 기본적인 예 ( &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/KISS_principle&quot;&gt;KISS&lt;/a&gt;&lt;/strong&gt; 방식) :</target>
        </trans-unit>
        <trans-unit id="898fb7e7d5157e7e25e187704ed0a723cf907352" translate="yes" xml:space="preserve">
          <source>Also &lt;code&gt;Promise&lt;/code&gt; can be used with together &lt;code&gt;async\await&lt;/code&gt; in &lt;code&gt;ES7&lt;/code&gt; to make the program flow wait for a &lt;code&gt;fullfiled&lt;/code&gt; result like the following:</source>
          <target state="translated">또한 &lt;code&gt;Promise&lt;/code&gt; 를 &lt;code&gt;ES7&lt;/code&gt; 에서 &lt;code&gt;async\await&lt;/code&gt; 와 함께 사용하여 프로그램 흐름이 다음과 같이 전체 파일 결과를 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd27fac479cc277d48e4015dbeacffe3abede6d" translate="yes" xml:space="preserve">
          <source>Another usage with the same code by using &lt;code&gt;.then()&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;.then()&lt;/code&gt; 메소드를 사용하여 동일한 코드를 사용하는 다른 사용법</target>
        </trans-unit>
        <trans-unit id="351a78942173c1488ea5b8410ba43599ea818e0b" translate="yes" xml:space="preserve">
          <source>Below is the implementation of how a function (callback API) can be converted to a promise.</source>
          <target state="translated">다음은 함수 (콜백 API)를 약속으로 변환하는 방법의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="514203e2cc91acaadcf199840c46daba11328bda" translate="yes" xml:space="preserve">
          <source>For more concise, above example used ramda.js. Ramda.js is a excellent library for functional programming. In above code, we used it's &lt;strong&gt;apply&lt;/strong&gt;(like javascript &lt;code&gt;function.prototype.apply&lt;/code&gt;) and append(like javascript &lt;code&gt;function.prototype.push&lt;/code&gt; ).
So, we could convert the a callback style function to promise style function now:</source>
          <target state="translated">더 간결하게 위의 예에서는 ramda.js를 사용했습니다. Ramda.js는 함수형 프로그래밍을위한 훌륭한 라이브러리입니다. 위의 코드에서 우리는 &lt;strong&gt;적용&lt;/strong&gt; (예 : javascript &lt;code&gt;function.prototype.apply&lt;/code&gt; ) 및 append (예 : javascript &lt;code&gt;function.prototype.push&lt;/code&gt; )를 사용했습니다. 따라서 콜백 스타일 함수를 약속 스타일 함수로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6662fe5ac4576166dd3de6947b82e3f376690ab5" translate="yes" xml:space="preserve">
          <source>Hope this answer is useful for you.</source>
          <target state="translated">이 답변이 도움이 되길 바랍니다.</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">도움이 되었기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="fc2b0555407985e3cf1a7bf797cd8ce59b3f79ef" translate="yes" xml:space="preserve">
          <source>How do I convert an existing callback API to promises</source>
          <target state="translated">기존 콜백 API를 약속으로 변환하는 방법</target>
        </trans-unit>
        <trans-unit id="aebcd473bebc1c7b9af086175f1414ed1903517d" translate="yes" xml:space="preserve">
          <source>How do I work with the API in promises, how do I &quot;promisify&quot; it?</source>
          <target state="translated">약속에서 API로 어떻게 작업합니까? 어떻게 &quot;약속&quot;합니까?</target>
        </trans-unit>
        <trans-unit id="8e090d332d9dabde6e435eafdb66e7b93d430d7f" translate="yes" xml:space="preserve">
          <source>How to use:</source>
          <target state="translated">사용하는 방법:</target>
        </trans-unit>
        <trans-unit id="16be5ebd5a0d9ad662aa3417d90669b397fb2dc8" translate="yes" xml:space="preserve">
          <source>I don't think the &lt;code&gt;window.onload&lt;/code&gt; suggestion by @Benjamin will work all the time, as it doesn't detect whether it is called after the load. I have been bitten by that many times. Here is a version which should always work:</source>
          <target state="translated">@Benjamin의 &lt;code&gt;window.onload&lt;/code&gt; 제안은로드 후 호출되는지 여부를 감지하지 못하므로 항상 작동한다고 생각하지 않습니다. 나는 여러 번 물렸다. 항상 작동해야하는 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a7b10b9a6a317e290183bc2492d3ef2f0b36225" translate="yes" xml:space="preserve">
          <source>I want to work with promises but I have a callback API in a format like:</source>
          <target state="translated">약속으로 작업하고 싶지만 다음과 같은 형식의 콜백 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9555e1100fbd9b659e01a560f310bc7fc97ad2a" translate="yes" xml:space="preserve">
          <source>In Node.js 8 you can &lt;strong&gt;promisify&lt;/strong&gt; object methods &lt;em&gt;on the fly&lt;/em&gt; using this npm module:</source>
          <target state="translated">Node.js 8에서는 다음 npm 모듈을 사용하여 객체 메소드 &lt;em&gt;를 즉시&lt;/em&gt; &lt;strong&gt;약속&lt;/strong&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f389ff5218c8149d6f054388ef888a498d71c48b" translate="yes" xml:space="preserve">
          <source>In an actual &lt;code&gt;onload&lt;/code&gt; case, you should use &lt;code&gt;addEventListener&lt;/code&gt; rather than &lt;code&gt;onX&lt;/code&gt;.</source>
          <target state="translated">실제 &lt;code&gt;onload&lt;/code&gt; 경우에는 &lt;code&gt;onX&lt;/code&gt; 대신 &lt;code&gt;addEventListener&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3d7d39449853b6cb72a5406424fa776ecc5dc4d" translate="yes" xml:space="preserve">
          <source>In general, you should not promisify things manually too much, most promise libraries that were designed with Node in mind as well as native promises in Node 8+ have a built in method for promisifying nodebacks. For example</source>
          <target state="translated">일반적으로 수동으로 약속을 너무 많이 약속해서는 안됩니다. Node 8+의 기본 약속뿐만 아니라 Node를 염두에두고 설계된 대부분의 promise 라이브러리에는 노드 백을 약속하는 기본 제공 방법이 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="80e7e7b533a635b062f1db604c77ceaaf914b3bb" translate="yes" xml:space="preserve">
          <source>In release candidate for Node.js 8.0.0, there's a new utility, &lt;code&gt;util.promisify&lt;/code&gt; (I've written about &lt;a href=&quot;https://brunoscopelliti.com/new-util-promisify-in-nodejs/&quot;&gt;util.promisify&lt;/a&gt;), that encapsulates the capacity of promisifying whatever function.</source>
          <target state="translated">Node.js 8.0.0의 릴리스 후보에는 새로운 유틸리티 인 &lt;code&gt;util.promisify&lt;/code&gt; (나는 &lt;a href=&quot;https://brunoscopelliti.com/new-util-promisify-in-nodejs/&quot;&gt;util.promisify&lt;/a&gt; 에 대해 작성 했습니다 )가 있습니다.이 유틸리티는 모든 기능을 약속하는 기능을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="1bdd556ef766673d3e75492cf664385618665ae6" translate="yes" xml:space="preserve">
          <source>In this exemple, the Promise has no reason to fail, so &lt;code&gt;reject()&lt;/code&gt; is never called.</source>
          <target state="translated">이 예에서 Promise는 실패 할 이유가 없으므로 &lt;code&gt;reject()&lt;/code&gt; 는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="deaff6ec2dfe20cd74c5a8b632dbf4649b8d9eb2" translate="yes" xml:space="preserve">
          <source>It is like 5 years late, but I wanted to post here my promesify version which takes functions from callbacks API and turns them into promises</source>
          <target state="translated">5 년 늦었지만 콜백 API에서 함수를 가져 와서 약속으로 바꾸는 promesify 버전을 여기에 게시하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="a1b7fc56ae1991014e6d0d15ec706dc9dd7f995a" translate="yes" xml:space="preserve">
          <source>It is not much different from the approaches suggested in the other answers, but has the advantage of being a core method, and not requiring additional dependencies.</source>
          <target state="translated">그것은 다른 답변에서 제안 된 접근 방식과 크게 다르지 않지만 핵심 방법이며 추가 종속성이 필요하지 않다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c8b120c5e6add5e38e8e197012d63c38130787" translate="yes" xml:space="preserve">
          <source>It uses &lt;strong&gt;util.promisify&lt;/strong&gt; and &lt;strong&gt;Proxies&lt;/strong&gt; so that your objects stay unchanged. &lt;strong&gt;Memoization&lt;/strong&gt; is also done with the use of WeakMaps). Here are some examples:</source>
          <target state="translated">객체가 변경되지 않도록 &lt;strong&gt;util.promisify&lt;/strong&gt; 및 &lt;strong&gt;프록시를&lt;/strong&gt; 사용합니다. &lt;strong&gt;메모&lt;/strong&gt; 는 &lt;strong&gt;WeakMaps를&lt;/strong&gt; 사용하여 수행됩니다). 여기 예시들이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b8b3a751be7e5776568231e30b4e9eedc323a0c4" translate="yes" xml:space="preserve">
          <source>My Cloud 9 code link: &lt;a href=&quot;https://ide.c9.io/adx2803/native-promises-in-node&quot;&gt;https://ide.c9.io/adx2803/native-promises-in-node&lt;/a&gt;</source>
          <target state="translated">My Cloud 9 코드 링크 : &lt;a href=&quot;https://ide.c9.io/adx2803/native-promises-in-node&quot;&gt;https://ide.c9.io/adx2803/native-promises-in-node&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f190e2d292229f60f0e3bedc4e97b0bd3130a80" translate="yes" xml:space="preserve">
          <source>My promisify version of a &lt;code&gt;callback&lt;/code&gt; function is the &lt;code&gt;P&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; 함수의 유망한 버전은 &lt;code&gt;P&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="97e12285a628806af2f0a9122c3fa2222474d2bb" translate="yes" xml:space="preserve">
          <source>Node style callbacks (nodebacks) have a particular format where the callbacks is always the last argument and its first parameter is an error. Let's first promisify one manually:</source>
          <target state="translated">노드 스타일 콜백 (노드 백)은 콜백이 항상 마지막 인수이고 첫 번째 매개 변수가 오류 인 특정 형식을 갖습니다. 먼저 하나를 수동으로 약속합시다.</target>
        </trans-unit>
        <trans-unit id="66dcd2df1165f224d8c67f681352cefc8c8436ee" translate="yes" xml:space="preserve">
          <source>Node.js 8.0.0 includes a new &lt;code&gt;util.promisify()&lt;/code&gt; API that allows standard Node.js callback style APIs to be wrapped in a function that returns a Promise. An example use of &lt;code&gt;util.promisify()&lt;/code&gt; is shown below.</source>
          <target state="translated">Node.js 8.0.0에는 표준 Node.js 콜백 스타일 API를 Promise를 반환하는 함수로 래핑 할 수있는 새로운 &lt;code&gt;util.promisify()&lt;/code&gt; API가 포함되어 있습니다. &lt;code&gt;util.promisify()&lt;/code&gt; 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f02a74e3155ce4267ad4d6499415dfc35ee3418e" translate="yes" xml:space="preserve">
          <source>Note: Here we exploit the fact that a jQuery deferred's &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; methods are &quot;detachable&quot;; ie. they are bound to the &lt;em&gt;instance&lt;/em&gt; of a jQuery.Deferred(). Not all libs offer this feature.</source>
          <target state="translated">참고 : 여기서는 jQuery 지연된 &lt;code&gt;resolve&lt;/code&gt; 및 &lt;code&gt;reject&lt;/code&gt; 메소드가 &quot;분리 가능&quot;하다는 사실을 이용합니다. 즉. 그것들은 jQuery.Deferred ()의 &lt;em&gt;인스턴스&lt;/em&gt; 에 바인딩됩니다. 모든 라이브러리가이 기능을 제공하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="3ddfe332a10af66808ac4e1dd4aefb53b8829e86" translate="yes" xml:space="preserve">
          <source>Of course, when you are in a &lt;code&gt;.then&lt;/code&gt; handler you do not need to promisify things. Returning a promise from a &lt;code&gt;.then&lt;/code&gt; handler will resolve or reject with that promise's value. Throwing from a &lt;code&gt;.then&lt;/code&gt; handler is also good practice and will reject the promise - this is the famous promise throw safety.</source>
          <target state="translated">물론, 당신이 &lt;code&gt;.then&lt;/code&gt; 핸들러에있을 때 당신은 일을 약속 할 필요가 없습니다. &lt;code&gt;.then&lt;/code&gt; 핸들러에서 약속을 반환하면 해당 약속의 값으로 해결되거나 거부됩니다. &lt;code&gt;.then&lt;/code&gt; 핸들러에서 던지는 것도 좋은 습관이며 약속을 거부합니다. 이것은 유명한 약속 던지기 안전입니다.</target>
        </trans-unit>
        <trans-unit id="8849f34c85d8450573581f94f47aaf726a7cae55" translate="yes" xml:space="preserve">
          <source>Or with &lt;em&gt;native promises&lt;/em&gt; in &lt;strong&gt;Node&lt;/strong&gt;:</source>
          <target state="translated">또는 &lt;strong&gt;Node의&lt;/strong&gt; &lt;em&gt;기본 약속&lt;/em&gt; 으로 :</target>
        </trans-unit>
        <trans-unit id="1c9aefba335c0791682fea70998fa03d4f5a6fbd" translate="yes" xml:space="preserve">
          <source>Or with a jQuery like API, hooking on an event happening once:</source>
          <target state="translated">또는 API와 같은 jQuery를 사용하여 한 번 발생하는 이벤트에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="db8250f72c11679d6255938f7af4ed9dfacae51f" translate="yes" xml:space="preserve">
          <source>Promise returning functions &lt;a href=&quot;https://stackoverflow.com/q/21887856/1048572&quot;&gt;&lt;em&gt;should never throw&lt;/em&gt;&lt;/a&gt;, they should return rejections instead. Throwing from a promise returning function will force you to use both a &lt;code&gt;} catch {&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; a &lt;code&gt;.catch&lt;/code&gt;. People using promisified APIs do not expect promises to throw. If you're not sure how async APIs work in JS - please &lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;see this answer&lt;/a&gt; first.</source>
          <target state="translated">약속 반환 함수 &lt;a href=&quot;https://stackoverflow.com/q/21887856/1048572&quot;&gt;&lt;em&gt;는 절대 던져서&lt;/em&gt;&lt;/a&gt; 는 안되며 거부를 반환해야합니다. 약속 반환 함수에서 던지면 &lt;code&gt;} catch {&lt;/code&gt; &lt;em&gt;와&lt;/em&gt; &lt;code&gt;.catch&lt;/code&gt; 를 모두 사용해야합니다. 약속 된 API를 사용하는 사람들은 약속을 던질 것으로 기대하지 않습니다. JS에서 비동기 API가 어떻게 작동하는지 잘 모르겠 으면 먼저이 &lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;답변을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63104f36ddfde5f398242d3c9a325847a623a94b" translate="yes" xml:space="preserve">
          <source>Promises have state, they start as pending and can settle to:</source>
          <target state="translated">약속에는 상태가 있으며 보류 중으로 시작하여 다음과 같이 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce024d8f1a277d9758eb3a0ab31acae8de6e3f74" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;https://www.npmjs.com/package/es6-promisify&quot;&gt;https://www.npmjs.com/package/es6-promisify&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;https://www.npmjs.com/package/es6-promisify&quot;&gt;https://www.npmjs.com/package/es6-promisify&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e7e9cd4e0335b59625886d2b1031ad2d04ca20cc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://nodejs.org/en/blog/release/v8.0.0/#improved-support-for-promises&quot;&gt;Improved support for Promises&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://nodejs.org/en/blog/release/v8.0.0/#improved-support-for-promises&quot;&gt;약속에 대한 향상된 지원&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="2b6e0801d895ee9944b96f9f5484f8dc41409db1" translate="yes" xml:space="preserve">
          <source>So, creating promises generally means specifying when they settle - that means when they move to the fulfilled or rejected phase to indicate the data is available (and can be accessed with &lt;code&gt;.then&lt;/code&gt;).</source>
          <target state="translated">따라서 약속을 만드는 것은 일반적으로 약속 시간을 지정하는 것을 의미합니다. 즉 데이터가 사용 가능하고 &lt;code&gt;.then&lt;/code&gt; 으로 액세스 할 수 있음을 나타 내기 위해 이행 또는 거부 단계로 이동할 때를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6711c27913da3ae89356ef0a6b2afab3ec3bdcd1" translate="yes" xml:space="preserve">
          <source>So, you could write a function for convert a function with this style like this:</source>
          <target state="translated">따라서 다음과 같이이 스타일로 함수를 변환하는 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5777c6a10b1074ef2c4e1b68827869d3f5033d63" translate="yes" xml:space="preserve">
          <source>Take a look to this very simple version here:
&lt;a href=&quot;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&quot;&gt;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&lt;/a&gt;</source>
          <target state="translated">이 매우 간단한 버전을 여기에서보십시오 : &lt;a href=&quot;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&quot;&gt;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f0d977dad38e296f6bfd90deb048f970c9c67117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;P&lt;/code&gt; function requires that the callback signature must be &lt;code&gt;callback(error,result)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 함수는 콜백 서명이 &lt;code&gt;callback(error,result)&lt;/code&gt; 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8bc89607696b2f1a8d66eba2d06c29841e319a2b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback style&lt;/strong&gt; function always like this(almost all function in node.js is this style):</source>
          <target state="translated">&lt;strong&gt;콜백 스타일&lt;/strong&gt; 함수는 항상 다음과 같습니다 (node.js의 거의 모든 함수는이 스타일입니다).</target>
        </trans-unit>
        <trans-unit id="8706b3f162f6603cc7e79182f266ec63f74a9b68" translate="yes" xml:space="preserve">
          <source>The Q library by kriskowal includes callback-to-promise functions.
A method like this:</source>
          <target state="translated">kriskowal의 Q 라이브러리에는 콜백 후 약속 기능이 포함되어 있습니다. 이와 같은 방법 :</target>
        </trans-unit>
        <trans-unit id="de72601b86517effe9b85b6d0c7e1c3ffa7debc4" translate="yes" xml:space="preserve">
          <source>The above method can respond result for old fashion callback and Promise usages.</source>
          <target state="translated">위의 방법은 구식 콜백 및 Promise 사용에 대한 결과에 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b11001c47aa205e4eaec3068ce28d129ef621ccb" translate="yes" xml:space="preserve">
          <source>Then use it</source>
          <target state="translated">그런 다음 사용하십시오</target>
        </trans-unit>
        <trans-unit id="17163e759ecdf79e9fb7b2df64ccf7697a1281a0" translate="yes" xml:space="preserve">
          <source>Then you've a &lt;code&gt;readFile&lt;/code&gt; method that returns a native &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">그런 다음 기본 &lt;code&gt;Promise&lt;/code&gt; 를 반환하는 &lt;code&gt;readFile&lt;/code&gt; 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="464aeaf407d5847f41b0ae64bf603fe11017cfba" translate="yes" xml:space="preserve">
          <source>There is no golden rule here, you promisify them one by one. However, some promise implementations allow you to do this in bulk, for example in Bluebird, converting a nodeback API to a promise API is as simple as:</source>
          <target state="translated">여기에는 황금률이 ​​없으며 하나씩 약속합니다. 그러나 일부 약속 구현을 사용하면 예를 들어 Bluebird에서 노드 백 API를 약속 API로 변환하는 것이 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="4d9ffb6a97e5e5bbcbe53f0f5a4919cdce804d49" translate="yes" xml:space="preserve">
          <source>These APIs are rather common since well&amp;hellip; callbacks are common in JS. Let's look at the common case of having &lt;code&gt;onSuccess&lt;/code&gt; and &lt;code&gt;onFail&lt;/code&gt;:</source>
          <target state="translated">이 API는 꽤 일반적이기 때문에&amp;hellip; 콜백은 JS에서 일반적입니다. &lt;code&gt;onSuccess&lt;/code&gt; 및 &lt;code&gt;onFail&lt;/code&gt; 이 발생하는 일반적인 경우를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a24d348893666157b62e242280f51475221a232e" translate="yes" xml:space="preserve">
          <source>This style has same feature:</source>
          <target state="translated">이 스타일은 동일한 기능을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7e7fbc811015943c1c30e7ceeea8b05c76a8ee58" translate="yes" xml:space="preserve">
          <source>To:</source>
          <target state="translated">To:</target>
        </trans-unit>
        <trans-unit id="7358246eac812cc9c89d7fe9ba9ce83f6e63c900" translate="yes" xml:space="preserve">
          <source>Today, I can use &lt;code&gt;Promise&lt;/code&gt; in &lt;code&gt;Node.js&lt;/code&gt; as a plain Javascript method.</source>
          <target state="translated">현재 &lt;code&gt;Node.js&lt;/code&gt; 의 &lt;code&gt;Promise&lt;/code&gt; 를 일반 자바 스크립트 메소드로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b6075ef4725d1671138cf91e362129ef1c76b1a" translate="yes" xml:space="preserve">
          <source>Under node v7.6+ which has built in promises and async:</source>
          <target state="translated">약속과 비동기가 내장 된 노드 v7.6 이상에서 :</target>
        </trans-unit>
        <trans-unit id="21cdff4e0d1a00d84e4023f3878afafea6747c66" translate="yes" xml:space="preserve">
          <source>When you have a few functions that take a callback and you want them to return a promise instead you can use this function to do the conversion.</source>
          <target state="translated">콜백을받는 함수가 몇 개 있는데 약속을 반환하기를 원할 경우이 함수를 사용하여 변환을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="285d8f9ff235163a0941b27c17f4866a6ef7151a" translate="yes" xml:space="preserve">
          <source>With deferreds you can do the following (let's use Q for this example, although Q now supports the new syntax &lt;a href=&quot;https://stackoverflow.com/q/28687566/1048572&quot;&gt;which you should prefer&lt;/a&gt;):</source>
          <target state="translated">지연을 사용하면 다음을 수행 할 수 있습니다 (이 예제에서는 Q를 사용하십시오. Q &lt;a href=&quot;https://stackoverflow.com/q/28687566/1048572&quot;&gt;는 선호&lt;/a&gt; 하는 새로운 구문 을 지원하지만).</target>
        </trans-unit>
        <trans-unit id="8785ace419b008c966fd0632a15344a1dab8462e" translate="yes" xml:space="preserve">
          <source>With functions:</source>
          <target state="translated">기능으로 :</target>
        </trans-unit>
        <trans-unit id="efbd1e67d4d2386e9c2e0b20948b87efe04745ba" translate="yes" xml:space="preserve">
          <source>With libraries that support deferred (Let's use $q for this example here, but we'll also use jQuery later):</source>
          <target state="translated">지연을 지원하는 라이브러리를 사용하는 경우 (이 예제에서는 $ q를 사용하지만 나중에 jQuery도 사용합니다) :</target>
        </trans-unit>
        <trans-unit id="ac2912b9a51ee83c0aa361b7d8c6a138cc67a690" translate="yes" xml:space="preserve">
          <source>With libraries that support deferred (Let's use jQuery for this example here, but we've also used $q above):</source>
          <target state="translated">지연을 지원하는 라이브러리를 사용하는 경우 (이 예제에서는 jQuery를 사용하지만 위의 $ q도 사용했습니다) :</target>
        </trans-unit>
        <trans-unit id="cf5f80ccb0fa7a7fe6a4bd35f8df2b4bc17ad4d4" translate="yes" xml:space="preserve">
          <source>With modern promise implementations that support the &lt;code&gt;Promise&lt;/code&gt; constructor like native ES6 promises:</source>
          <target state="translated">기본 ES6 약속과 같은 &lt;code&gt;Promise&lt;/code&gt; 생성자를 지원하는 최신 약속 구현을 통해 :</target>
        </trans-unit>
        <trans-unit id="85e6d2a844dfdb833a5d8fa9fa8380f9779e47b0" translate="yes" xml:space="preserve">
          <source>With objects:</source>
          <target state="translated">객체로 :</target>
        </trans-unit>
        <trans-unit id="31e3cfe8ea7886a445fda00bc753060e6ca9897b" translate="yes" xml:space="preserve">
          <source>With plain old vanilla javaScript, here's a solution to promisify an api callback.</source>
          <target state="translated">평범한 오래된 바닐라 자바 ​​스크립트를 사용하면 API 콜백을 약속하는 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d7f4649ff6f2e5528a53a85b385845fcbb3e72" translate="yes" xml:space="preserve">
          <source>You can do something like this</source>
          <target state="translated">이런 식으로 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6d25b1105a2067210eeece1f22921f5c5a068521" translate="yes" xml:space="preserve">
          <source>You can even use native &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; to bind some context:</source>
          <target state="translated">네이티브 &lt;code&gt;call&lt;/code&gt; 사용하고 일부 컨텍스트를 바인딩하기 위해 &lt;code&gt;apply&lt;/code&gt; 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc679a70c9e897fc95d295324256f7f747aa41bb" translate="yes" xml:space="preserve">
          <source>You can use &lt;strong&gt;native Promise&lt;/strong&gt; in ES6, for exemple dealing with setTimeout:</source>
          <target state="translated">setTimeout을 처리하기 위해 ES6에서 &lt;strong&gt;기본 Promise&lt;/strong&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae6dd4f7460eb8ce6d2c469fb04285bb015e4e5" translate="yes" xml:space="preserve">
          <source>You can use JavaScript native promises with Node JS.</source>
          <target state="translated">Node JS에서 JavaScript 기본 약속을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afeed28ed3fcc2af7c3878d7174d83dc8d43031f" translate="yes" xml:space="preserve">
          <source>You would then use the resulting promise like so:</source>
          <target state="translated">그런 다음 결과 약속을 다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e9d60add30f8bb5929f99ac40d5160bfb71c32e0" translate="yes" xml:space="preserve">
          <source>can be converted with Q.ninvoke</source>
          <target state="translated">Q.ninvoke로 변환 가능</target>
        </trans-unit>
        <trans-unit id="34a54cfdcaffa6edf5464329ad895cf08064577b" translate="yes" xml:space="preserve">
          <source>jQuery also offers a &lt;code&gt;$.Deferred(fn)&lt;/code&gt; form, which has the advantage of allowing us to write an expression that emulates very closely the &lt;code&gt;new Promise(fn)&lt;/code&gt; form, as follows:</source>
          <target state="translated">jQuery는 또한 &lt;code&gt;$.Deferred(fn)&lt;/code&gt; 양식을 제공하는데, 이는 다음과 같이 &lt;code&gt;new Promise(fn)&lt;/code&gt; 양식을 매우 가깝게 에뮬레이트하는 표현식을 작성할 수있는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="90242f4c42d3b05c33b76121e4b05821eb670484" translate="yes" xml:space="preserve">
          <source>the callback function always accept the error object as it's first argument.</source>
          <target state="translated">콜백 함수는 항상 첫 번째 인수이므로 오류 객체를 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="30148ebd2697af745f0c69fac10a2a42bac156b6" translate="yes" xml:space="preserve">
          <source>the callback function is passed by last argument.</source>
          <target state="translated">콜백 함수는 마지막 인수에 의해 전달됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
