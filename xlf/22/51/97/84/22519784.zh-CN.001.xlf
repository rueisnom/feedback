<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/22519784">
    <body>
      <group id="22519784">
        <trans-unit id="0d1876b42ec40b07f0901b79d802642cbf3db6a6" translate="yes" xml:space="preserve">
          <source>(I recommend visiting &lt;a href=&quot;http://exploringjs.com/es6/ch_promises.html&quot;&gt;this beautiful source&lt;/a&gt;)</source>
          <target state="translated">（我建议访问&lt;a href=&quot;http://exploringjs.com/es6/ch_promises.html&quot;&gt;这个美丽的资源&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="1a9687b9fb765f1427325e76179dc016f46e0b7f" translate="yes" xml:space="preserve">
          <source>(The callback method is assumed to have two parameters as error and result)</source>
          <target state="translated">(回调方法假定有两个参数为错误和结果)</target>
        </trans-unit>
        <trans-unit id="140ce27c605a99fd16b6f49c4709b30c0c0d5027" translate="yes" xml:space="preserve">
          <source>1. DOM load or other one time event:</source>
          <target state="translated">1.DOM加载或其他一次性事件。</target>
        </trans-unit>
        <trans-unit id="f3feb3b9a4fadb33bdde8b9e238c456eef319374" translate="yes" xml:space="preserve">
          <source>2. Plain callback:</source>
          <target state="translated">2.普通的回调。</target>
        </trans-unit>
        <trans-unit id="b1f5dbf968434049e3d06c3fbc7b91c1c4a0074d" translate="yes" xml:space="preserve">
          <source>3. Node style callback (&quot;nodeback&quot;):</source>
          <target state="translated">3.节点样式回调(&quot;nodeback&quot;)。</target>
        </trans-unit>
        <trans-unit id="e7d557519bf0bcedc91d45c78a25a683446c57c3" translate="yes" xml:space="preserve">
          <source>4. A whole library with node style callbacks:</source>
          <target state="translated">4.全库的节点式回调。</target>
        </trans-unit>
        <trans-unit id="508de91fce54d4813e92f47075de1963072ce810" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Promise&lt;/code&gt; can also be used on any platform that is based on Node.js like &lt;code&gt;react-native&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 也可以在任何基于Node.js的平台上使用，例如 &lt;code&gt;react-native&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84481bb62537dcfe7b3728bba8f136ab65eb7d6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;es6-promisify&lt;/code&gt; converts callback-based functions to Promise-based functions.</source>
          <target state="translated">&lt;code&gt;es6-promisify&lt;/code&gt; 将基于回调的函数转换为基于Promise的函数。</target>
        </trans-unit>
        <trans-unit id="6f191c2698c6eb0413bd6c2ca6e36474db531dfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/strong&gt; Javascript Async API code:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/strong&gt; Javascript异步API代码：</target>
        </trans-unit>
        <trans-unit id="80f9f35a621c81865657b103d29cba17b5659e48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After Converting It&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;转换后&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="020585adb8b12b4604a596236a3c07cee48318bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before converting a function as promise In Node.JS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在Node.JS中将函数转换为Promise之前&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="414958c0d8b719ec718c5694f1d7b1580ed56a22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bonus&lt;/strong&gt;: An &lt;strong&gt;hybrid&lt;/strong&gt; method</source>
          <target state="translated">&lt;strong&gt;奖励&lt;/strong&gt; ：一种&lt;strong&gt;混合&lt;/strong&gt;方法</target>
        </trans-unit>
        <trans-unit id="46a4b2b972ff5677800784ab71c3a5efe0cda580" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incase you need to handle multiple request&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果您需要处理多个请求&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89cf9925ff498ed29e9ef6df1f841c7bc121a96e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plain&lt;/strong&gt; Javascript Async API code:</source>
          <target state="translated">&lt;strong&gt;普通&lt;/strong&gt; Javascript异步API代码：</target>
        </trans-unit>
        <trans-unit id="b8fb2f83aee2cbeff4ac6fcb5ea50cce08e5c218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fulfilled&lt;/strong&gt; meaning that the computation completed successfully.</source>
          <target state="translated">&lt;strong&gt;完成&lt;/strong&gt;意味着计算成功完成。</target>
        </trans-unit>
        <trans-unit id="3030d3b7a04661fbb4185df915ebeef20d9e0313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rejected&lt;/strong&gt; meaning that the computation failed.</source>
          <target state="translated">&lt;strong&gt;拒绝&lt;/strong&gt;表示计算失败。</target>
        </trans-unit>
        <trans-unit id="72577fd58c67ec9eaf27588179094e92bcbf92f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;toPromise&lt;/strong&gt; and &lt;strong&gt;checkErr&lt;/strong&gt; function is own by &lt;a href=&quot;https://github.com/jituanlin/berserk&quot;&gt;berserk&lt;/a&gt; library, it's a functional programming library fork by &lt;strong&gt;ramda.js&lt;/strong&gt;(create by me).</source>
          <target state="translated">&lt;strong&gt;toPromise&lt;/strong&gt;和&lt;strong&gt;checkErr&lt;/strong&gt;函数由&lt;strong&gt;berserk&lt;/strong&gt;库拥有，它是&lt;strong&gt;ramda.js&lt;/strong&gt; （由我创建）的功能性编程库fork。</target>
        </trans-unit>
        <trans-unit id="052ca2463678fe184067a71a1401d5432b9b5051" translate="yes" xml:space="preserve">
          <source>A simple and basic example to &lt;code&gt;Promise&lt;/code&gt; (with &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/KISS_principle&quot;&gt;KISS&lt;/a&gt;&lt;/strong&gt; way):</source>
          <target state="translated">一个简单而基本的 &lt;code&gt;Promise&lt;/code&gt; 示例（采用&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/KISS_principle&quot;&gt;KISS&lt;/a&gt;&lt;/strong&gt;方式）：</target>
        </trans-unit>
        <trans-unit id="898fb7e7d5157e7e25e187704ed0a723cf907352" translate="yes" xml:space="preserve">
          <source>Also &lt;code&gt;Promise&lt;/code&gt; can be used with together &lt;code&gt;async\await&lt;/code&gt; in &lt;code&gt;ES7&lt;/code&gt; to make the program flow wait for a &lt;code&gt;fullfiled&lt;/code&gt; result like the following:</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 也可以与 &lt;code&gt;ES7&lt;/code&gt; 中的 &lt;code&gt;async\await&lt;/code&gt; 一起使用，以使程序流等待 &lt;code&gt;fullfiled&lt;/code&gt; 结果，如下所示：</target>
        </trans-unit>
        <trans-unit id="2cd27fac479cc277d48e4015dbeacffe3abede6d" translate="yes" xml:space="preserve">
          <source>Another usage with the same code by using &lt;code&gt;.then()&lt;/code&gt; method</source>
          <target state="translated">通过 &lt;code&gt;.then()&lt;/code&gt; 方法使用同一代码的另一种用法</target>
        </trans-unit>
        <trans-unit id="351a78942173c1488ea5b8410ba43599ea818e0b" translate="yes" xml:space="preserve">
          <source>Below is the implementation of how a function (callback API) can be converted to a promise.</source>
          <target state="translated">下面是一个函数(回调API)如何转换为承诺的实现。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="514203e2cc91acaadcf199840c46daba11328bda" translate="yes" xml:space="preserve">
          <source>For more concise, above example used ramda.js. Ramda.js is a excellent library for functional programming. In above code, we used it's &lt;strong&gt;apply&lt;/strong&gt;(like javascript &lt;code&gt;function.prototype.apply&lt;/code&gt;) and append(like javascript &lt;code&gt;function.prototype.push&lt;/code&gt; ).
So, we could convert the a callback style function to promise style function now:</source>
          <target state="translated">为了更简洁，上面的示例使用了ramda.js。 Ramda.js是用于函数式编程的出色库。 在上面的代码中，我们使用了&lt;strong&gt;apply&lt;/strong&gt; （例如javascript &lt;code&gt;function.prototype.apply&lt;/code&gt; ）和append（例如javascript &lt;code&gt;function.prototype.push&lt;/code&gt; ）。 因此，我们现在可以将回调样式函数转换为Promise样式函数：</target>
        </trans-unit>
        <trans-unit id="6662fe5ac4576166dd3de6947b82e3f376690ab5" translate="yes" xml:space="preserve">
          <source>Hope this answer is useful for you.</source>
          <target state="translated">希望这个答案对你有帮助。</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">希望这对你有帮助。</target>
        </trans-unit>
        <trans-unit id="fc2b0555407985e3cf1a7bf797cd8ce59b3f79ef" translate="yes" xml:space="preserve">
          <source>How do I convert an existing callback API to promises</source>
          <target state="translated">如何将现有的回调API转换为承诺?</target>
        </trans-unit>
        <trans-unit id="aebcd473bebc1c7b9af086175f1414ed1903517d" translate="yes" xml:space="preserve">
          <source>How do I work with the API in promises, how do I &quot;promisify&quot; it?</source>
          <target state="translated">在承诺中,如何与API进行合作,如何 &quot;承诺&quot;?</target>
        </trans-unit>
        <trans-unit id="8e090d332d9dabde6e435eafdb66e7b93d430d7f" translate="yes" xml:space="preserve">
          <source>How to use:</source>
          <target state="translated">如何使用。</target>
        </trans-unit>
        <trans-unit id="16be5ebd5a0d9ad662aa3417d90669b397fb2dc8" translate="yes" xml:space="preserve">
          <source>I don't think the &lt;code&gt;window.onload&lt;/code&gt; suggestion by @Benjamin will work all the time, as it doesn't detect whether it is called after the load. I have been bitten by that many times. Here is a version which should always work:</source>
          <target state="translated">我认为@Benjamin的 &lt;code&gt;window.onload&lt;/code&gt; 建议不会一直有效，因为它无法检测到加载后是否被调用。 我被很多次咬伤了。 这是一个应该始终有效的版本：</target>
        </trans-unit>
        <trans-unit id="8a7b10b9a6a317e290183bc2492d3ef2f0b36225" translate="yes" xml:space="preserve">
          <source>I want to work with promises but I have a callback API in a format like:</source>
          <target state="translated">我想用承诺来工作,但我有一个回调API的格式是这样的。</target>
        </trans-unit>
        <trans-unit id="a9555e1100fbd9b659e01a560f310bc7fc97ad2a" translate="yes" xml:space="preserve">
          <source>In Node.js 8 you can &lt;strong&gt;promisify&lt;/strong&gt; object methods &lt;em&gt;on the fly&lt;/em&gt; using this npm module:</source>
          <target state="translated">在Node.js 8中，您可以使用以下npm模块&lt;em&gt;即时&lt;/em&gt; &lt;strong&gt;实现&lt;/strong&gt;对象方法：</target>
        </trans-unit>
        <trans-unit id="f389ff5218c8149d6f054388ef888a498d71c48b" translate="yes" xml:space="preserve">
          <source>In an actual &lt;code&gt;onload&lt;/code&gt; case, you should use &lt;code&gt;addEventListener&lt;/code&gt; rather than &lt;code&gt;onX&lt;/code&gt;.</source>
          <target state="translated">在实际的 &lt;code&gt;onload&lt;/code&gt; 情况下，应该使用 &lt;code&gt;addEventListener&lt;/code&gt; 而不是 &lt;code&gt;onX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3d7d39449853b6cb72a5406424fa776ecc5dc4d" translate="yes" xml:space="preserve">
          <source>In general, you should not promisify things manually too much, most promise libraries that were designed with Node in mind as well as native promises in Node 8+ have a built in method for promisifying nodebacks. For example</source>
          <target state="translated">一般来说,你不应该过多地手动许诺,大多数在Node设计时考虑到Node的承诺库以及Node 8+中的原生承诺库都有一个内置的nodeback承诺方法。举例来说</target>
        </trans-unit>
        <trans-unit id="80e7e7b533a635b062f1db604c77ceaaf914b3bb" translate="yes" xml:space="preserve">
          <source>In release candidate for Node.js 8.0.0, there's a new utility, &lt;code&gt;util.promisify&lt;/code&gt; (I've written about &lt;a href=&quot;https://brunoscopelliti.com/new-util-promisify-in-nodejs/&quot;&gt;util.promisify&lt;/a&gt;), that encapsulates the capacity of promisifying whatever function.</source>
          <target state="translated">在Node.js 8.0.0的候选发布版本中，有一个新的实用程序 &lt;code&gt;util.promisify&lt;/code&gt; （我已经写过&lt;a href=&quot;https://brunoscopelliti.com/new-util-promisify-in-nodejs/&quot;&gt;util.promisify&lt;/a&gt; ），它封装了使任何功能混杂的功能。</target>
        </trans-unit>
        <trans-unit id="1bdd556ef766673d3e75492cf664385618665ae6" translate="yes" xml:space="preserve">
          <source>In this exemple, the Promise has no reason to fail, so &lt;code&gt;reject()&lt;/code&gt; is never called.</source>
          <target state="translated">在此示例中，Promise没有理由失败，因此永远不会调用 &lt;code&gt;reject()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="deaff6ec2dfe20cd74c5a8b632dbf4649b8d9eb2" translate="yes" xml:space="preserve">
          <source>It is like 5 years late, but I wanted to post here my promesify version which takes functions from callbacks API and turns them into promises</source>
          <target state="translated">虽然已经迟了5年了,但我想在这里贴出我的promesify版本,它从回调API中提取函数并将其转化为承诺。</target>
        </trans-unit>
        <trans-unit id="a1b7fc56ae1991014e6d0d15ec706dc9dd7f995a" translate="yes" xml:space="preserve">
          <source>It is not much different from the approaches suggested in the other answers, but has the advantage of being a core method, and not requiring additional dependencies.</source>
          <target state="translated">它与其他答案中提出的方法没有太大的区别,但它的优点是作为一种核心方法,不需要额外的依赖性。</target>
        </trans-unit>
        <trans-unit id="c5c8b120c5e6add5e38e8e197012d63c38130787" translate="yes" xml:space="preserve">
          <source>It uses &lt;strong&gt;util.promisify&lt;/strong&gt; and &lt;strong&gt;Proxies&lt;/strong&gt; so that your objects stay unchanged. &lt;strong&gt;Memoization&lt;/strong&gt; is also done with the use of WeakMaps). Here are some examples:</source>
          <target state="translated">它使用&lt;strong&gt;util.promisify&lt;/strong&gt;和&lt;strong&gt;Proxies，&lt;/strong&gt;以便您的对象保持不变。 &lt;strong&gt;记忆&lt;/strong&gt;也可以通过使用WeakMaps完成。 这里有些例子：</target>
        </trans-unit>
        <trans-unit id="b8b3a751be7e5776568231e30b4e9eedc323a0c4" translate="yes" xml:space="preserve">
          <source>My Cloud 9 code link: &lt;a href=&quot;https://ide.c9.io/adx2803/native-promises-in-node&quot;&gt;https://ide.c9.io/adx2803/native-promises-in-node&lt;/a&gt;</source>
          <target state="translated">我的Cloud 9代码链接： &lt;a href=&quot;https://ide.c9.io/adx2803/native-promises-in-node&quot;&gt;https&lt;/a&gt; : //ide.c9.io/adx2803/native-promises-in-node</target>
        </trans-unit>
        <trans-unit id="5f190e2d292229f60f0e3bedc4e97b0bd3130a80" translate="yes" xml:space="preserve">
          <source>My promisify version of a &lt;code&gt;callback&lt;/code&gt; function is the &lt;code&gt;P&lt;/code&gt; function:</source>
          <target state="translated">我的 &lt;code&gt;callback&lt;/code&gt; 函数的承诺版本是 &lt;code&gt;P&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="97e12285a628806af2f0a9122c3fa2222474d2bb" translate="yes" xml:space="preserve">
          <source>Node style callbacks (nodebacks) have a particular format where the callbacks is always the last argument and its first parameter is an error. Let's first promisify one manually:</source>
          <target state="translated">节点样式的回调(nodebacks)有一个特殊的格式,其中回调的参数总是最后一个参数,它的第一个参数是错误。我们先来手动许诺一个。</target>
        </trans-unit>
        <trans-unit id="66dcd2df1165f224d8c67f681352cefc8c8436ee" translate="yes" xml:space="preserve">
          <source>Node.js 8.0.0 includes a new &lt;code&gt;util.promisify()&lt;/code&gt; API that allows standard Node.js callback style APIs to be wrapped in a function that returns a Promise. An example use of &lt;code&gt;util.promisify()&lt;/code&gt; is shown below.</source>
          <target state="translated">Node.js 8.0.0包含一个新的 &lt;code&gt;util.promisify()&lt;/code&gt; API，该API允许将标准Node.js回调样式API封装在返回Promise的函数中。 &lt;code&gt;util.promisify()&lt;/code&gt; 的使用示例如下所示。</target>
        </trans-unit>
        <trans-unit id="f02a74e3155ce4267ad4d6499415dfc35ee3418e" translate="yes" xml:space="preserve">
          <source>Note: Here we exploit the fact that a jQuery deferred's &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; methods are &quot;detachable&quot;; ie. they are bound to the &lt;em&gt;instance&lt;/em&gt; of a jQuery.Deferred(). Not all libs offer this feature.</source>
          <target state="translated">注意：这里我们利用了一个事实，即jQuery deferred的 &lt;code&gt;resolve&lt;/code&gt; 和 &lt;code&gt;reject&lt;/code&gt; 方法是&amp;ldquo;可分离的&amp;rdquo;。 即。 它们绑定到jQuery.Deferred（）的&lt;em&gt;实例&lt;/em&gt; 。 并非所有库都提供此功能。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="3ddfe332a10af66808ac4e1dd4aefb53b8829e86" translate="yes" xml:space="preserve">
          <source>Of course, when you are in a &lt;code&gt;.then&lt;/code&gt; handler you do not need to promisify things. Returning a promise from a &lt;code&gt;.then&lt;/code&gt; handler will resolve or reject with that promise's value. Throwing from a &lt;code&gt;.then&lt;/code&gt; handler is also good practice and will reject the promise - this is the famous promise throw safety.</source>
          <target state="translated">当然，当您使用.then处理程序时，您不需要使内容繁琐。 从 &lt;code&gt;.then&lt;/code&gt; 处理程序返回一个诺言将解决或拒绝该诺言的值。 从 &lt;code&gt;.then&lt;/code&gt; 处理程序中抛出也是很好的做法，并且会拒绝诺言-这是著名的诺言抛出安全性。</target>
        </trans-unit>
        <trans-unit id="8849f34c85d8450573581f94f47aaf726a7cae55" translate="yes" xml:space="preserve">
          <source>Or with &lt;em&gt;native promises&lt;/em&gt; in &lt;strong&gt;Node&lt;/strong&gt;:</source>
          <target state="translated">或在&lt;strong&gt;Node中&lt;/strong&gt;具有&lt;em&gt;本机承诺&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="1c9aefba335c0791682fea70998fa03d4f5a6fbd" translate="yes" xml:space="preserve">
          <source>Or with a jQuery like API, hooking on an event happening once:</source>
          <target state="translated">或者用一个类似于jQuery的API,勾选一个事件发生一次。</target>
        </trans-unit>
        <trans-unit id="db8250f72c11679d6255938f7af4ed9dfacae51f" translate="yes" xml:space="preserve">
          <source>Promise returning functions &lt;a href=&quot;https://stackoverflow.com/q/21887856/1048572&quot;&gt;&lt;em&gt;should never throw&lt;/em&gt;&lt;/a&gt;, they should return rejections instead. Throwing from a promise returning function will force you to use both a &lt;code&gt;} catch {&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; a &lt;code&gt;.catch&lt;/code&gt;. People using promisified APIs do not expect promises to throw. If you're not sure how async APIs work in JS - please &lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;see this answer&lt;/a&gt; first.</source>
          <target state="translated">承诺返回函数&lt;a href=&quot;https://stackoverflow.com/q/21887856/1048572&quot;&gt;&lt;em&gt;绝不应该抛出&lt;/em&gt;&lt;/a&gt; ，而应该返回拒绝。 从promise返回函数抛出将迫使您同时使用 &lt;code&gt;} catch {&lt;/code&gt; &lt;em&gt;和&lt;/em&gt; &lt;code&gt;.catch&lt;/code&gt; 。 使用承诺的API的人们不希望兑现承诺。 如果您不确定JS中异步API的工作方式-请首先&lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;查看此答案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="63104f36ddfde5f398242d3c9a325847a623a94b" translate="yes" xml:space="preserve">
          <source>Promises have state, they start as pending and can settle to:</source>
          <target state="translated">承诺是有状态的,它们开始时是待定的,可以解决到。</target>
        </trans-unit>
        <trans-unit id="ce024d8f1a277d9758eb3a0ab31acae8de6e3f74" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;https://www.npmjs.com/package/es6-promisify&quot;&gt;https://www.npmjs.com/package/es6-promisify&lt;/a&gt;</source>
          <target state="translated">参考： &lt;a href=&quot;https://www.npmjs.com/package/es6-promisify&quot;&gt;https&lt;/a&gt; : //www.npmjs.com/package/es6-promisify</target>
        </trans-unit>
        <trans-unit id="e7e9cd4e0335b59625886d2b1031ad2d04ca20cc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://nodejs.org/en/blog/release/v8.0.0/#improved-support-for-promises&quot;&gt;Improved support for Promises&lt;/a&gt;</source>
          <target state="translated">请参阅&lt;a href=&quot;https://nodejs.org/en/blog/release/v8.0.0/#improved-support-for-promises&quot;&gt;改进的对承诺的支持&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b6e0801d895ee9944b96f9f5484f8dc41409db1" translate="yes" xml:space="preserve">
          <source>So, creating promises generally means specifying when they settle - that means when they move to the fulfilled or rejected phase to indicate the data is available (and can be accessed with &lt;code&gt;.then&lt;/code&gt;).</source>
          <target state="translated">因此，创建承诺通常意味着指定何时结算-即何时进入承诺阶段或拒绝阶段以指示数据可用（并且可以通过 &lt;code&gt;.then&lt;/code&gt; 访问）。</target>
        </trans-unit>
        <trans-unit id="6711c27913da3ae89356ef0a6b2afab3ec3bdcd1" translate="yes" xml:space="preserve">
          <source>So, you could write a function for convert a function with this style like this:</source>
          <target state="translated">所以,你可以用这种风格写一个转换函数的函数,就像这样。</target>
        </trans-unit>
        <trans-unit id="5777c6a10b1074ef2c4e1b68827869d3f5033d63" translate="yes" xml:space="preserve">
          <source>Take a look to this very simple version here:
&lt;a href=&quot;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&quot;&gt;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&lt;/a&gt;</source>
          <target state="translated">在这里看看这个非常简单的版本： &lt;a href=&quot;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&quot;&gt;https&lt;/a&gt; : //gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a</target>
        </trans-unit>
        <trans-unit id="f0d977dad38e296f6bfd90deb048f970c9c67117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;P&lt;/code&gt; function requires that the callback signature must be &lt;code&gt;callback(error,result)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 函数要求回调签名必须为 &lt;code&gt;callback(error,result)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bc89607696b2f1a8d66eba2d06c29841e319a2b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback style&lt;/strong&gt; function always like this(almost all function in node.js is this style):</source>
          <target state="translated">&lt;strong&gt;回调样式&lt;/strong&gt;函数总是这样（node.js中的几乎所有函数都是这种样式）：</target>
        </trans-unit>
        <trans-unit id="8706b3f162f6603cc7e79182f266ec63f74a9b68" translate="yes" xml:space="preserve">
          <source>The Q library by kriskowal includes callback-to-promise functions.
A method like this:</source>
          <target state="translated">kriskowal的Q库包括回调到承诺函数。像这样的方法。</target>
        </trans-unit>
        <trans-unit id="de72601b86517effe9b85b6d0c7e1c3ffa7debc4" translate="yes" xml:space="preserve">
          <source>The above method can respond result for old fashion callback and Promise usages.</source>
          <target state="translated">上述方法可以对老式回调和Promise的使用进行响应结果。</target>
        </trans-unit>
        <trans-unit id="b11001c47aa205e4eaec3068ce28d129ef621ccb" translate="yes" xml:space="preserve">
          <source>Then use it</source>
          <target state="translated">那就用它吧</target>
        </trans-unit>
        <trans-unit id="17163e759ecdf79e9fb7b2df64ccf7697a1281a0" translate="yes" xml:space="preserve">
          <source>Then you've a &lt;code&gt;readFile&lt;/code&gt; method that returns a native &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">然后，您有一个 &lt;code&gt;readFile&lt;/code&gt; 方法，该方法返回一个本地 &lt;code&gt;Promise&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="464aeaf407d5847f41b0ae64bf603fe11017cfba" translate="yes" xml:space="preserve">
          <source>There is no golden rule here, you promisify them one by one. However, some promise implementations allow you to do this in bulk, for example in Bluebird, converting a nodeback API to a promise API is as simple as:</source>
          <target state="translated">这里没有金科玉律,你把它们一个个许诺化。然而,有些承诺实现允许你批量地做这件事,例如在Bluebird中,将nodeback API转换为承诺API很简单。</target>
        </trans-unit>
        <trans-unit id="4d9ffb6a97e5e5bbcbe53f0f5a4919cdce804d49" translate="yes" xml:space="preserve">
          <source>These APIs are rather common since well&amp;hellip; callbacks are common in JS. Let's look at the common case of having &lt;code&gt;onSuccess&lt;/code&gt; and &lt;code&gt;onFail&lt;/code&gt;:</source>
          <target state="translated">这些API相当常见，因为&amp;hellip;&amp;hellip;在JS中回调很常见。 让我们看一下具有 &lt;code&gt;onSuccess&lt;/code&gt; 和 &lt;code&gt;onFail&lt;/code&gt; 的常见情况：</target>
        </trans-unit>
        <trans-unit id="a24d348893666157b62e242280f51475221a232e" translate="yes" xml:space="preserve">
          <source>This style has same feature:</source>
          <target state="translated">这种风格具有相同的特点。</target>
        </trans-unit>
        <trans-unit id="7e7fbc811015943c1c30e7ceeea8b05c76a8ee58" translate="yes" xml:space="preserve">
          <source>To:</source>
          <target state="translated">To:</target>
        </trans-unit>
        <trans-unit id="7358246eac812cc9c89d7fe9ba9ce83f6e63c900" translate="yes" xml:space="preserve">
          <source>Today, I can use &lt;code&gt;Promise&lt;/code&gt; in &lt;code&gt;Node.js&lt;/code&gt; as a plain Javascript method.</source>
          <target state="translated">今天，我可以将 &lt;code&gt;Node.js&lt;/code&gt; 中的 &lt;code&gt;Promise&lt;/code&gt; 用作纯Javascript方法。</target>
        </trans-unit>
        <trans-unit id="8b6075ef4725d1671138cf91e362129ef1c76b1a" translate="yes" xml:space="preserve">
          <source>Under node v7.6+ which has built in promises and async:</source>
          <target state="translated">在node v7.6以上版本下,内置了诺言和Async。</target>
        </trans-unit>
        <trans-unit id="21cdff4e0d1a00d84e4023f3878afafea6747c66" translate="yes" xml:space="preserve">
          <source>When you have a few functions that take a callback and you want them to return a promise instead you can use this function to do the conversion.</source>
          <target state="translated">当你有几个函数采取回调,而你想让它们返回一个承诺,你可以用这个函数来完成转换。</target>
        </trans-unit>
        <trans-unit id="285d8f9ff235163a0941b27c17f4866a6ef7151a" translate="yes" xml:space="preserve">
          <source>With deferreds you can do the following (let's use Q for this example, although Q now supports the new syntax &lt;a href=&quot;https://stackoverflow.com/q/28687566/1048572&quot;&gt;which you should prefer&lt;/a&gt;):</source>
          <target state="translated">使用deferred，您可以执行以下操作（在本示例中，请使用Q，尽管Q现在支持&lt;a href=&quot;https://stackoverflow.com/q/28687566/1048572&quot;&gt;您应该使用&lt;/a&gt;的新语法）：</target>
        </trans-unit>
        <trans-unit id="8785ace419b008c966fd0632a15344a1dab8462e" translate="yes" xml:space="preserve">
          <source>With functions:</source>
          <target state="translated">有了功能。</target>
        </trans-unit>
        <trans-unit id="efbd1e67d4d2386e9c2e0b20948b87efe04745ba" translate="yes" xml:space="preserve">
          <source>With libraries that support deferred (Let's use $q for this example here, but we'll also use jQuery later):</source>
          <target state="translated">用支持递延的库(这里我们用$q来做这个例子,但我们以后也会用jQuery)。</target>
        </trans-unit>
        <trans-unit id="ac2912b9a51ee83c0aa361b7d8c6a138cc67a690" translate="yes" xml:space="preserve">
          <source>With libraries that support deferred (Let's use jQuery for this example here, but we've also used $q above):</source>
          <target state="translated">用支持递延的库(这里我们用jQuery来做这个例子,但我们上面也用过$q)。</target>
        </trans-unit>
        <trans-unit id="cf5f80ccb0fa7a7fe6a4bd35f8df2b4bc17ad4d4" translate="yes" xml:space="preserve">
          <source>With modern promise implementations that support the &lt;code&gt;Promise&lt;/code&gt; constructor like native ES6 promises:</source>
          <target state="translated">使用支持 &lt;code&gt;Promise&lt;/code&gt; 构造函数的现代Promise实现（例如本机ES6 Promise） ：</target>
        </trans-unit>
        <trans-unit id="85e6d2a844dfdb833a5d8fa9fa8380f9779e47b0" translate="yes" xml:space="preserve">
          <source>With objects:</source>
          <target state="translated">有了对象。</target>
        </trans-unit>
        <trans-unit id="31e3cfe8ea7886a445fda00bc753060e6ca9897b" translate="yes" xml:space="preserve">
          <source>With plain old vanilla javaScript, here's a solution to promisify an api callback.</source>
          <target state="translated">用普通的vanilla javaScript,这里有一个解决方案来承诺api回调。</target>
        </trans-unit>
        <trans-unit id="25d7f4649ff6f2e5528a53a85b385845fcbb3e72" translate="yes" xml:space="preserve">
          <source>You can do something like this</source>
          <target state="translated">你可以做这样的事情</target>
        </trans-unit>
        <trans-unit id="6d25b1105a2067210eeece1f22921f5c5a068521" translate="yes" xml:space="preserve">
          <source>You can even use native &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; to bind some context:</source>
          <target state="translated">您甚至可以使用本机 &lt;code&gt;call&lt;/code&gt; 并 &lt;code&gt;apply&lt;/code&gt; 绑定某些上下文：</target>
        </trans-unit>
        <trans-unit id="dc679a70c9e897fc95d295324256f7f747aa41bb" translate="yes" xml:space="preserve">
          <source>You can use &lt;strong&gt;native Promise&lt;/strong&gt; in ES6, for exemple dealing with setTimeout:</source>
          <target state="translated">您可以在ES6中使用&lt;strong&gt;本地Promise&lt;/strong&gt; ，例如处理setTimeout：</target>
        </trans-unit>
        <trans-unit id="dae6dd4f7460eb8ce6d2c469fb04285bb015e4e5" translate="yes" xml:space="preserve">
          <source>You can use JavaScript native promises with Node JS.</source>
          <target state="translated">你可以使用Node JS的JavaScript原生承诺。</target>
        </trans-unit>
        <trans-unit id="afeed28ed3fcc2af7c3878d7174d83dc8d43031f" translate="yes" xml:space="preserve">
          <source>You would then use the resulting promise like so:</source>
          <target state="translated">然后,你就会像这样使用结果的承诺。</target>
        </trans-unit>
        <trans-unit id="e9d60add30f8bb5929f99ac40d5160bfb71c32e0" translate="yes" xml:space="preserve">
          <source>can be converted with Q.ninvoke</source>
          <target state="translated">可以用Q.ninvoke进行转换。</target>
        </trans-unit>
        <trans-unit id="34a54cfdcaffa6edf5464329ad895cf08064577b" translate="yes" xml:space="preserve">
          <source>jQuery also offers a &lt;code&gt;$.Deferred(fn)&lt;/code&gt; form, which has the advantage of allowing us to write an expression that emulates very closely the &lt;code&gt;new Promise(fn)&lt;/code&gt; form, as follows:</source>
          <target state="translated">jQuery还提供了 &lt;code&gt;$.Deferred(fn)&lt;/code&gt; 形式，它的优点是允许我们编写一个非常接近 &lt;code&gt;new Promise(fn)&lt;/code&gt; 形式的表达式，如下所示：</target>
        </trans-unit>
        <trans-unit id="90242f4c42d3b05c33b76121e4b05821eb670484" translate="yes" xml:space="preserve">
          <source>the callback function always accept the error object as it's first argument.</source>
          <target state="translated">回调函数总是接受错误对象作为它的第一个参数。</target>
        </trans-unit>
        <trans-unit id="30148ebd2697af745f0c69fac10a2a42bac156b6" translate="yes" xml:space="preserve">
          <source>the callback function is passed by last argument.</source>
          <target state="translated">回调函数由最后一个参数传递。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
