<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/22519784">
    <body>
      <group id="22519784">
        <trans-unit id="0d1876b42ec40b07f0901b79d802642cbf3db6a6" translate="yes" xml:space="preserve">
          <source>(I recommend visiting &lt;a href=&quot;http://exploringjs.com/es6/ch_promises.html&quot;&gt;this beautiful source&lt;/a&gt;)</source>
          <target state="translated">(Я рекомендую посетить &lt;a href=&quot;http://exploringjs.com/es6/ch_promises.html&quot;&gt;этот прекрасный источник&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1a9687b9fb765f1427325e76179dc016f46e0b7f" translate="yes" xml:space="preserve">
          <source>(The callback method is assumed to have two parameters as error and result)</source>
          <target state="translated">(Предполагается,что метод обратного вызова имеет два параметра:ошибка и результат).</target>
        </trans-unit>
        <trans-unit id="140ce27c605a99fd16b6f49c4709b30c0c0d5027" translate="yes" xml:space="preserve">
          <source>1. DOM load or other one time event:</source>
          <target state="translated">1.Загрузка флэш-накопителя или другое одноразовое событие:</target>
        </trans-unit>
        <trans-unit id="f3feb3b9a4fadb33bdde8b9e238c456eef319374" translate="yes" xml:space="preserve">
          <source>2. Plain callback:</source>
          <target state="translated">2.Простой обратный звонок:</target>
        </trans-unit>
        <trans-unit id="b1f5dbf968434049e3d06c3fbc7b91c1c4a0074d" translate="yes" xml:space="preserve">
          <source>3. Node style callback (&quot;nodeback&quot;):</source>
          <target state="translated">3.Обратный вызов в стиле узла (&quot;кивок&quot;):</target>
        </trans-unit>
        <trans-unit id="e7d557519bf0bcedc91d45c78a25a683446c57c3" translate="yes" xml:space="preserve">
          <source>4. A whole library with node style callbacks:</source>
          <target state="translated">4.Целая библиотека с обратными вызовами в стиле узла:</target>
        </trans-unit>
        <trans-unit id="508de91fce54d4813e92f47075de1963072ce810" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Promise&lt;/code&gt; can also be used on any platform that is based on Node.js like &lt;code&gt;react-native&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; также может быть использован на любой платформе, основанной на Node.js, например &lt;code&gt;react-native&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84481bb62537dcfe7b3728bba8f136ab65eb7d6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;es6-promisify&lt;/code&gt; converts callback-based functions to Promise-based functions.</source>
          <target state="translated">&lt;code&gt;es6-promisify&lt;/code&gt; преобразует функции на основе обратного вызова в функции на основе Promise.</target>
        </trans-unit>
        <trans-unit id="6f191c2698c6eb0413bd6c2ca6e36474db531dfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/strong&gt; Javascript Async API code:</source>
          <target state="translated">Код API &lt;strong&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/strong&gt; Javascript Async:</target>
        </trans-unit>
        <trans-unit id="80f9f35a621c81865657b103d29cba17b5659e48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After Converting It&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;После преобразования&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="020585adb8b12b4604a596236a3c07cee48318bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before converting a function as promise In Node.JS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Перед преобразованием функции в качестве обещания в Node.JS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="414958c0d8b719ec718c5694f1d7b1580ed56a22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bonus&lt;/strong&gt;: An &lt;strong&gt;hybrid&lt;/strong&gt; method</source>
          <target state="translated">&lt;strong&gt;Бонус&lt;/strong&gt; : &lt;strong&gt;гибридный&lt;/strong&gt; метод</target>
        </trans-unit>
        <trans-unit id="46a4b2b972ff5677800784ab71c3a5efe0cda580" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incase you need to handle multiple request&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Incase вам нужно обработать несколько запросов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89cf9925ff498ed29e9ef6df1f841c7bc121a96e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plain&lt;/strong&gt; Javascript Async API code:</source>
          <target state="translated">&lt;strong&gt;Простой&lt;/strong&gt; Javascript Async API-код:</target>
        </trans-unit>
        <trans-unit id="b8fb2f83aee2cbeff4ac6fcb5ea50cce08e5c218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fulfilled&lt;/strong&gt; meaning that the computation completed successfully.</source>
          <target state="translated">&lt;strong&gt;выполнив это&lt;/strong&gt; означает, что вычисление завершено успешно.</target>
        </trans-unit>
        <trans-unit id="3030d3b7a04661fbb4185df915ebeef20d9e0313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rejected&lt;/strong&gt; meaning that the computation failed.</source>
          <target state="translated">&lt;strong&gt;отклонено&lt;/strong&gt; означает, что вычисление не удалось.</target>
        </trans-unit>
        <trans-unit id="72577fd58c67ec9eaf27588179094e92bcbf92f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;toPromise&lt;/strong&gt; and &lt;strong&gt;checkErr&lt;/strong&gt; function is own by &lt;a href=&quot;https://github.com/jituanlin/berserk&quot;&gt;berserk&lt;/a&gt; library, it's a functional programming library fork by &lt;strong&gt;ramda.js&lt;/strong&gt;(create by me).</source>
          <target state="translated">&lt;strong&gt;Функции toPromise&lt;/strong&gt; и &lt;strong&gt;checkErr&lt;/strong&gt; принадлежат библиотеке &lt;a href=&quot;https://github.com/jituanlin/berserk&quot;&gt;berserk&lt;/a&gt; , это функциональная вилка библиотеки программирования от &lt;strong&gt;ramda.js&lt;/strong&gt; ( &lt;strong&gt;созданная&lt;/strong&gt; мной).</target>
        </trans-unit>
        <trans-unit id="052ca2463678fe184067a71a1401d5432b9b5051" translate="yes" xml:space="preserve">
          <source>A simple and basic example to &lt;code&gt;Promise&lt;/code&gt; (with &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/KISS_principle&quot;&gt;KISS&lt;/a&gt;&lt;/strong&gt; way):</source>
          <target state="translated">Простой и простой пример для &lt;code&gt;Promise&lt;/code&gt; (с &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/KISS_principle&quot;&gt;KISS&lt;/a&gt;&lt;/strong&gt; way):</target>
        </trans-unit>
        <trans-unit id="898fb7e7d5157e7e25e187704ed0a723cf907352" translate="yes" xml:space="preserve">
          <source>Also &lt;code&gt;Promise&lt;/code&gt; can be used with together &lt;code&gt;async\await&lt;/code&gt; in &lt;code&gt;ES7&lt;/code&gt; to make the program flow wait for a &lt;code&gt;fullfiled&lt;/code&gt; result like the following:</source>
          <target state="translated">Кроме того, &lt;code&gt;Promise&lt;/code&gt; может использоваться вместе с &lt;code&gt;async\await&lt;/code&gt; в &lt;code&gt;ES7&lt;/code&gt; , чтобы заставить поток программы ожидать &lt;code&gt;fullfiled&lt;/code&gt; результата, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="2cd27fac479cc277d48e4015dbeacffe3abede6d" translate="yes" xml:space="preserve">
          <source>Another usage with the same code by using &lt;code&gt;.then()&lt;/code&gt; method</source>
          <target state="translated">Другое использование с тем же кодом с использованием метода &lt;code&gt;.then()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="351a78942173c1488ea5b8410ba43599ea818e0b" translate="yes" xml:space="preserve">
          <source>Below is the implementation of how a function (callback API) can be converted to a promise.</source>
          <target state="translated">Ниже приведена реализация того,как функция (API обратного вызова)может быть преобразована в обещание.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="514203e2cc91acaadcf199840c46daba11328bda" translate="yes" xml:space="preserve">
          <source>For more concise, above example used ramda.js. Ramda.js is a excellent library for functional programming. In above code, we used it's &lt;strong&gt;apply&lt;/strong&gt;(like javascript &lt;code&gt;function.prototype.apply&lt;/code&gt;) and append(like javascript &lt;code&gt;function.prototype.push&lt;/code&gt; ).
So, we could convert the a callback style function to promise style function now:</source>
          <target state="translated">Для краткости в приведенном выше примере используется ramda.js. Ramda.js - отличная библиотека для функционального программирования. В приведенном выше коде мы использовали его &lt;strong&gt;apply&lt;/strong&gt; (например, javascript &lt;code&gt;function.prototype.apply&lt;/code&gt; ) и append (например, javascript &lt;code&gt;function.prototype.push&lt;/code&gt; ). Итак, теперь мы можем преобразовать функцию стиля обратного вызова в функцию обещания стиля:</target>
        </trans-unit>
        <trans-unit id="6662fe5ac4576166dd3de6947b82e3f376690ab5" translate="yes" xml:space="preserve">
          <source>Hope this answer is useful for you.</source>
          <target state="translated">Надеюсь,этот ответ будет вам полезен.</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">Надеюсь,это поможет.</target>
        </trans-unit>
        <trans-unit id="fc2b0555407985e3cf1a7bf797cd8ce59b3f79ef" translate="yes" xml:space="preserve">
          <source>How do I convert an existing callback API to promises</source>
          <target state="translated">Как преобразовать существующий API обратного вызова в обещания.</target>
        </trans-unit>
        <trans-unit id="aebcd473bebc1c7b9af086175f1414ed1903517d" translate="yes" xml:space="preserve">
          <source>How do I work with the API in promises, how do I &quot;promisify&quot; it?</source>
          <target state="translated">Как работать с API в обещаниях,как &quot;обещать&quot; его?</target>
        </trans-unit>
        <trans-unit id="8e090d332d9dabde6e435eafdb66e7b93d430d7f" translate="yes" xml:space="preserve">
          <source>How to use:</source>
          <target state="translated">Как пользоваться:</target>
        </trans-unit>
        <trans-unit id="16be5ebd5a0d9ad662aa3417d90669b397fb2dc8" translate="yes" xml:space="preserve">
          <source>I don't think the &lt;code&gt;window.onload&lt;/code&gt; suggestion by @Benjamin will work all the time, as it doesn't detect whether it is called after the load. I have been bitten by that many times. Here is a version which should always work:</source>
          <target state="translated">Я не думаю, что предложение &lt;code&gt;window.onload&lt;/code&gt; от @Benjamin будет работать постоянно, так как оно не определяет, вызывается ли оно после загрузки. Я был укушен этим много раз. Вот версия, которая всегда должна работать:</target>
        </trans-unit>
        <trans-unit id="8a7b10b9a6a317e290183bc2492d3ef2f0b36225" translate="yes" xml:space="preserve">
          <source>I want to work with promises but I have a callback API in a format like:</source>
          <target state="translated">Я хочу работать с обещаниями,но у меня есть API обратного вызова в таком формате:</target>
        </trans-unit>
        <trans-unit id="a9555e1100fbd9b659e01a560f310bc7fc97ad2a" translate="yes" xml:space="preserve">
          <source>In Node.js 8 you can &lt;strong&gt;promisify&lt;/strong&gt; object methods &lt;em&gt;on the fly&lt;/em&gt; using this npm module:</source>
          <target state="translated">В Node.js 8 вы можете &lt;strong&gt;обещать&lt;/strong&gt; методы объекта &lt;em&gt;на лету,&lt;/em&gt; используя этот модуль npm:</target>
        </trans-unit>
        <trans-unit id="f389ff5218c8149d6f054388ef888a498d71c48b" translate="yes" xml:space="preserve">
          <source>In an actual &lt;code&gt;onload&lt;/code&gt; case, you should use &lt;code&gt;addEventListener&lt;/code&gt; rather than &lt;code&gt;onX&lt;/code&gt;.</source>
          <target state="translated">В реальном случае &lt;code&gt;addEventListener&lt;/code&gt; вы должны использовать addEventListener, а не &lt;code&gt;onX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3d7d39449853b6cb72a5406424fa776ecc5dc4d" translate="yes" xml:space="preserve">
          <source>In general, you should not promisify things manually too much, most promise libraries that were designed with Node in mind as well as native promises in Node 8+ have a built in method for promisifying nodebacks. For example</source>
          <target state="translated">В общем,не стоит слишком много обещать вручную,большинство обещающих библиотек,которые были разработаны с учетом Node,а также родные обещания в Node 8+имеют встроенный метод обещания нодовых возвратов.Например</target>
        </trans-unit>
        <trans-unit id="80e7e7b533a635b062f1db604c77ceaaf914b3bb" translate="yes" xml:space="preserve">
          <source>In release candidate for Node.js 8.0.0, there's a new utility, &lt;code&gt;util.promisify&lt;/code&gt; (I've written about &lt;a href=&quot;https://brunoscopelliti.com/new-util-promisify-in-nodejs/&quot;&gt;util.promisify&lt;/a&gt;), that encapsulates the capacity of promisifying whatever function.</source>
          <target state="translated">В выпуске кандидата на Node.js 8.0.0 есть новая утилита &lt;code&gt;util.promisify&lt;/code&gt; (я писал о &lt;a href=&quot;https://brunoscopelliti.com/new-util-promisify-in-nodejs/&quot;&gt;util.promisify&lt;/a&gt; ), которая заключает в себе способность обещать любую функцию.</target>
        </trans-unit>
        <trans-unit id="1bdd556ef766673d3e75492cf664385618665ae6" translate="yes" xml:space="preserve">
          <source>In this exemple, the Promise has no reason to fail, so &lt;code&gt;reject()&lt;/code&gt; is never called.</source>
          <target state="translated">В этом примере Promise не имеет причин для сбоя, поэтому &lt;code&gt;reject()&lt;/code&gt; никогда не вызывается.</target>
        </trans-unit>
        <trans-unit id="deaff6ec2dfe20cd74c5a8b632dbf4649b8d9eb2" translate="yes" xml:space="preserve">
          <source>It is like 5 years late, but I wanted to post here my promesify version which takes functions from callbacks API and turns them into promises</source>
          <target state="translated">Это как будто на 5 лет позже,но я хотел поместить здесь свою обещающую версию,которая берет функции из API обратных вызовов и превращает их в обещания.</target>
        </trans-unit>
        <trans-unit id="a1b7fc56ae1991014e6d0d15ec706dc9dd7f995a" translate="yes" xml:space="preserve">
          <source>It is not much different from the approaches suggested in the other answers, but has the advantage of being a core method, and not requiring additional dependencies.</source>
          <target state="translated">Он не сильно отличается от подходов,предложенных в других ответах,но имеет то преимущество,что является основным методом и не требует дополнительных зависимостей.</target>
        </trans-unit>
        <trans-unit id="c5c8b120c5e6add5e38e8e197012d63c38130787" translate="yes" xml:space="preserve">
          <source>It uses &lt;strong&gt;util.promisify&lt;/strong&gt; and &lt;strong&gt;Proxies&lt;/strong&gt; so that your objects stay unchanged. &lt;strong&gt;Memoization&lt;/strong&gt; is also done with the use of WeakMaps). Here are some examples:</source>
          <target state="translated">Он использует &lt;strong&gt;util.promisify&lt;/strong&gt; и &lt;strong&gt;Proxies,&lt;/strong&gt; чтобы ваши объекты оставались неизменными. &lt;strong&gt;Мемоизация&lt;/strong&gt; также выполняется с использованием WeakMaps). Вот некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="b8b3a751be7e5776568231e30b4e9eedc323a0c4" translate="yes" xml:space="preserve">
          <source>My Cloud 9 code link: &lt;a href=&quot;https://ide.c9.io/adx2803/native-promises-in-node&quot;&gt;https://ide.c9.io/adx2803/native-promises-in-node&lt;/a&gt;</source>
          <target state="translated">Ссылка на код моего облака 9: &lt;a href=&quot;https://ide.c9.io/adx2803/native-promises-in-node&quot;&gt;https://ide.c9.io/adx2803/native-promises-in-node&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f190e2d292229f60f0e3bedc4e97b0bd3130a80" translate="yes" xml:space="preserve">
          <source>My promisify version of a &lt;code&gt;callback&lt;/code&gt; function is the &lt;code&gt;P&lt;/code&gt; function:</source>
          <target state="translated">Моя многообещающая версия функции &lt;code&gt;callback&lt;/code&gt; - это функция &lt;code&gt;P&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="97e12285a628806af2f0a9122c3fa2222474d2bb" translate="yes" xml:space="preserve">
          <source>Node style callbacks (nodebacks) have a particular format where the callbacks is always the last argument and its first parameter is an error. Let's first promisify one manually:</source>
          <target state="translated">Обратные вызовы в стиле узла (node style callbacks)имеют определенный формат,где обратный вызов всегда является последним аргументом,а его первый параметр-ошибкой.Сначала обещаем вручную:</target>
        </trans-unit>
        <trans-unit id="66dcd2df1165f224d8c67f681352cefc8c8436ee" translate="yes" xml:space="preserve">
          <source>Node.js 8.0.0 includes a new &lt;code&gt;util.promisify()&lt;/code&gt; API that allows standard Node.js callback style APIs to be wrapped in a function that returns a Promise. An example use of &lt;code&gt;util.promisify()&lt;/code&gt; is shown below.</source>
          <target state="translated">Node.js 8.0.0 включает новый API &lt;code&gt;util.promisify()&lt;/code&gt; который позволяет обернуть стандартные API стиля обратного вызова Node.js в функцию, которая возвращает Promise. Пример использования &lt;code&gt;util.promisify()&lt;/code&gt; показан ниже.</target>
        </trans-unit>
        <trans-unit id="f02a74e3155ce4267ad4d6499415dfc35ee3418e" translate="yes" xml:space="preserve">
          <source>Note: Here we exploit the fact that a jQuery deferred's &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; methods are &quot;detachable&quot;; ie. they are bound to the &lt;em&gt;instance&lt;/em&gt; of a jQuery.Deferred(). Not all libs offer this feature.</source>
          <target state="translated">Примечание: здесь мы используем тот факт, что jQuery откладывает методы &lt;code&gt;resolve&lt;/code&gt; и &lt;code&gt;reject&lt;/code&gt; &amp;laquo;отсоединяемые&amp;raquo;; то есть. они связаны с &lt;em&gt;экземпляром&lt;/em&gt; jQuery.Deferred (). Не все библиотеки предлагают эту функцию.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="3ddfe332a10af66808ac4e1dd4aefb53b8829e86" translate="yes" xml:space="preserve">
          <source>Of course, when you are in a &lt;code&gt;.then&lt;/code&gt; handler you do not need to promisify things. Returning a promise from a &lt;code&gt;.then&lt;/code&gt; handler will resolve or reject with that promise's value. Throwing from a &lt;code&gt;.then&lt;/code&gt; handler is also good practice and will reject the promise - this is the famous promise throw safety.</source>
          <target state="translated">Конечно, когда вы находитесь в обработчике &lt;code&gt;.then&lt;/code&gt; , вам не нужно ничего обещать. Возвращение обещания от обработчика &lt;code&gt;.then&lt;/code&gt; разрешит или отклонит значение этого обещания. Бросок из обработчика &lt;code&gt;.then&lt;/code&gt; также является хорошей практикой и отвергнет обещание - это известная безопасность броска обещания.</target>
        </trans-unit>
        <trans-unit id="8849f34c85d8450573581f94f47aaf726a7cae55" translate="yes" xml:space="preserve">
          <source>Or with &lt;em&gt;native promises&lt;/em&gt; in &lt;strong&gt;Node&lt;/strong&gt;:</source>
          <target state="translated">Или с &lt;em&gt;нативными обещаниями&lt;/em&gt; в &lt;strong&gt;Node&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="1c9aefba335c0791682fea70998fa03d4f5a6fbd" translate="yes" xml:space="preserve">
          <source>Or with a jQuery like API, hooking on an event happening once:</source>
          <target state="translated">Или с таким jQuery как API,с привязкой к событию,происходящему один раз:</target>
        </trans-unit>
        <trans-unit id="db8250f72c11679d6255938f7af4ed9dfacae51f" translate="yes" xml:space="preserve">
          <source>Promise returning functions &lt;a href=&quot;https://stackoverflow.com/q/21887856/1048572&quot;&gt;&lt;em&gt;should never throw&lt;/em&gt;&lt;/a&gt;, they should return rejections instead. Throwing from a promise returning function will force you to use both a &lt;code&gt;} catch {&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; a &lt;code&gt;.catch&lt;/code&gt;. People using promisified APIs do not expect promises to throw. If you're not sure how async APIs work in JS - please &lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;see this answer&lt;/a&gt; first.</source>
          <target state="translated">Функции возврата обещаний &lt;a href=&quot;https://stackoverflow.com/q/21887856/1048572&quot;&gt;&lt;em&gt;никогда&lt;/em&gt;&lt;/a&gt; не должны выдаваться, вместо этого они должны возвращать отклонения. Функция возврата из обещания заставит вас использовать и &lt;code&gt;} catch {&lt;/code&gt; &lt;em&gt;и&lt;/em&gt; &lt;code&gt;.catch&lt;/code&gt; . Люди, использующие обещанные API-интерфейсы, не ожидают обещаний. Если вы не уверены, как работают асинхронные API в JS - сначала &lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;посмотрите этот ответ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63104f36ddfde5f398242d3c9a325847a623a94b" translate="yes" xml:space="preserve">
          <source>Promises have state, they start as pending and can settle to:</source>
          <target state="translated">У обещаний есть состояние,они начинаются как отложенные и могут устроиться:</target>
        </trans-unit>
        <trans-unit id="ce024d8f1a277d9758eb3a0ab31acae8de6e3f74" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;https://www.npmjs.com/package/es6-promisify&quot;&gt;https://www.npmjs.com/package/es6-promisify&lt;/a&gt;</source>
          <target state="translated">Ссылка: &lt;a href=&quot;https://www.npmjs.com/package/es6-promisify&quot;&gt;https://www.npmjs.com/package/es6-promisify&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e7e9cd4e0335b59625886d2b1031ad2d04ca20cc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://nodejs.org/en/blog/release/v8.0.0/#improved-support-for-promises&quot;&gt;Improved support for Promises&lt;/a&gt;</source>
          <target state="translated">См. &lt;a href=&quot;https://nodejs.org/en/blog/release/v8.0.0/#improved-support-for-promises&quot;&gt;Улучшенная поддержка для обещаний&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b6e0801d895ee9944b96f9f5484f8dc41409db1" translate="yes" xml:space="preserve">
          <source>So, creating promises generally means specifying when they settle - that means when they move to the fulfilled or rejected phase to indicate the data is available (and can be accessed with &lt;code&gt;.then&lt;/code&gt;).</source>
          <target state="translated">Таким образом, создание обещаний обычно означает указание того, когда они выполняются, то есть когда они переходят к выполненной или отклоненной фазе, чтобы указать, что данные доступны (и могут быть доступны с помощью &lt;code&gt;.then&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6711c27913da3ae89356ef0a6b2afab3ec3bdcd1" translate="yes" xml:space="preserve">
          <source>So, you could write a function for convert a function with this style like this:</source>
          <target state="translated">Итак,вы можете написать функцию для преобразования функции в таком стиле:</target>
        </trans-unit>
        <trans-unit id="5777c6a10b1074ef2c4e1b68827869d3f5033d63" translate="yes" xml:space="preserve">
          <source>Take a look to this very simple version here:
&lt;a href=&quot;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&quot;&gt;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&lt;/a&gt;</source>
          <target state="translated">Взгляните на эту очень простую версию здесь: &lt;a href=&quot;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&quot;&gt;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f0d977dad38e296f6bfd90deb048f970c9c67117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;P&lt;/code&gt; function requires that the callback signature must be &lt;code&gt;callback(error,result)&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;P&lt;/code&gt; требует, чтобы сигнатура &lt;code&gt;callback(error,result)&lt;/code&gt; была обратным вызовом (ошибка, результат) .</target>
        </trans-unit>
        <trans-unit id="8bc89607696b2f1a8d66eba2d06c29841e319a2b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback style&lt;/strong&gt; function always like this(almost all function in node.js is this style):</source>
          <target state="translated">Функция &lt;strong&gt;стиля обратного вызова&lt;/strong&gt; всегда такая (почти все функции в node.js - это стиль):</target>
        </trans-unit>
        <trans-unit id="8706b3f162f6603cc7e79182f266ec63f74a9b68" translate="yes" xml:space="preserve">
          <source>The Q library by kriskowal includes callback-to-promise functions.
A method like this:</source>
          <target state="translated">Библиотека Q по kriskowal включает функции обратного вызова.Такой метод:</target>
        </trans-unit>
        <trans-unit id="de72601b86517effe9b85b6d0c7e1c3ffa7debc4" translate="yes" xml:space="preserve">
          <source>The above method can respond result for old fashion callback and Promise usages.</source>
          <target state="translated">Вышеуказанный метод может ответить на результат для старого обратного вызова моды и обещает использование.</target>
        </trans-unit>
        <trans-unit id="b11001c47aa205e4eaec3068ce28d129ef621ccb" translate="yes" xml:space="preserve">
          <source>Then use it</source>
          <target state="translated">Тогда используйте его</target>
        </trans-unit>
        <trans-unit id="17163e759ecdf79e9fb7b2df64ccf7697a1281a0" translate="yes" xml:space="preserve">
          <source>Then you've a &lt;code&gt;readFile&lt;/code&gt; method that returns a native &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">Затем у вас есть метод &lt;code&gt;readFile&lt;/code&gt; , который возвращает нативный &lt;code&gt;Promise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="464aeaf407d5847f41b0ae64bf603fe11017cfba" translate="yes" xml:space="preserve">
          <source>There is no golden rule here, you promisify them one by one. However, some promise implementations allow you to do this in bulk, for example in Bluebird, converting a nodeback API to a promise API is as simple as:</source>
          <target state="translated">Здесь нет золотого правила,ты обещаешь им одно за другим.Однако,некоторые обещающие реализации позволяют делать это массово,например,в Bluebird,преобразование API узла обратной связи в обещающий API так же просто,как и в случае с Bluebird:</target>
        </trans-unit>
        <trans-unit id="4d9ffb6a97e5e5bbcbe53f0f5a4919cdce804d49" translate="yes" xml:space="preserve">
          <source>These APIs are rather common since well&amp;hellip; callbacks are common in JS. Let's look at the common case of having &lt;code&gt;onSuccess&lt;/code&gt; and &lt;code&gt;onFail&lt;/code&gt;:</source>
          <target state="translated">Эти API довольно распространены, так как ... обратные вызовы распространены в JS. Давайте посмотрим на общий случай наличия &lt;code&gt;onSuccess&lt;/code&gt; и &lt;code&gt;onFail&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a24d348893666157b62e242280f51475221a232e" translate="yes" xml:space="preserve">
          <source>This style has same feature:</source>
          <target state="translated">Этот стиль имеет ту же особенность:</target>
        </trans-unit>
        <trans-unit id="7e7fbc811015943c1c30e7ceeea8b05c76a8ee58" translate="yes" xml:space="preserve">
          <source>To:</source>
          <target state="translated">To:</target>
        </trans-unit>
        <trans-unit id="7358246eac812cc9c89d7fe9ba9ce83f6e63c900" translate="yes" xml:space="preserve">
          <source>Today, I can use &lt;code&gt;Promise&lt;/code&gt; in &lt;code&gt;Node.js&lt;/code&gt; as a plain Javascript method.</source>
          <target state="translated">Сегодня я могу использовать &lt;code&gt;Promise&lt;/code&gt; в &lt;code&gt;Node.js&lt;/code&gt; как простой метод Javascript.</target>
        </trans-unit>
        <trans-unit id="8b6075ef4725d1671138cf91e362129ef1c76b1a" translate="yes" xml:space="preserve">
          <source>Under node v7.6+ which has built in promises and async:</source>
          <target state="translated">Под узлом v7.6+,который встроен в обещания и асинхронизацию:</target>
        </trans-unit>
        <trans-unit id="21cdff4e0d1a00d84e4023f3878afafea6747c66" translate="yes" xml:space="preserve">
          <source>When you have a few functions that take a callback and you want them to return a promise instead you can use this function to do the conversion.</source>
          <target state="translated">Когда у вас есть несколько функций,которые принимают обратный вызов,и вы хотите,чтобы они вернули обещание,а не вы можете использовать эту функцию для выполнения преобразования.</target>
        </trans-unit>
        <trans-unit id="285d8f9ff235163a0941b27c17f4866a6ef7151a" translate="yes" xml:space="preserve">
          <source>With deferreds you can do the following (let's use Q for this example, although Q now supports the new syntax &lt;a href=&quot;https://stackoverflow.com/q/28687566/1048572&quot;&gt;which you should prefer&lt;/a&gt;):</source>
          <target state="translated">С deferreds вы можете сделать следующее (давайте используем Q для этого примера, хотя Q теперь поддерживает новый синтаксис, &lt;a href=&quot;https://stackoverflow.com/q/28687566/1048572&quot;&gt;который вы должны предпочесть&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="8785ace419b008c966fd0632a15344a1dab8462e" translate="yes" xml:space="preserve">
          <source>With functions:</source>
          <target state="translated">С функциями:</target>
        </trans-unit>
        <trans-unit id="efbd1e67d4d2386e9c2e0b20948b87efe04745ba" translate="yes" xml:space="preserve">
          <source>With libraries that support deferred (Let's use $q for this example here, but we'll also use jQuery later):</source>
          <target state="translated">С библиотеками,поддерживающими отсрочку (давайте используем $q для этого примера здесь,но мы также используем jQuery позже):</target>
        </trans-unit>
        <trans-unit id="ac2912b9a51ee83c0aa361b7d8c6a138cc67a690" translate="yes" xml:space="preserve">
          <source>With libraries that support deferred (Let's use jQuery for this example here, but we've also used $q above):</source>
          <target state="translated">С библиотеками,поддерживающими отсрочку (давайте используем jQuery для этого примера здесь,но мы также использовали $q выше):</target>
        </trans-unit>
        <trans-unit id="cf5f80ccb0fa7a7fe6a4bd35f8df2b4bc17ad4d4" translate="yes" xml:space="preserve">
          <source>With modern promise implementations that support the &lt;code&gt;Promise&lt;/code&gt; constructor like native ES6 promises:</source>
          <target state="translated">С современными реализациями обещаний, которые поддерживают конструктор &lt;code&gt;Promise&lt;/code&gt; , как родные обещания ES6:</target>
        </trans-unit>
        <trans-unit id="85e6d2a844dfdb833a5d8fa9fa8380f9779e47b0" translate="yes" xml:space="preserve">
          <source>With objects:</source>
          <target state="translated">С объектами:</target>
        </trans-unit>
        <trans-unit id="31e3cfe8ea7886a445fda00bc753060e6ca9897b" translate="yes" xml:space="preserve">
          <source>With plain old vanilla javaScript, here's a solution to promisify an api callback.</source>
          <target state="translated">С простым старым ванильным javaScript,вот решение,чтобы обещать api обратный вызов.</target>
        </trans-unit>
        <trans-unit id="25d7f4649ff6f2e5528a53a85b385845fcbb3e72" translate="yes" xml:space="preserve">
          <source>You can do something like this</source>
          <target state="translated">Ты можешь сделать что-нибудь подобное</target>
        </trans-unit>
        <trans-unit id="6d25b1105a2067210eeece1f22921f5c5a068521" translate="yes" xml:space="preserve">
          <source>You can even use native &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; to bind some context:</source>
          <target state="translated">Вы даже можете использовать собственный &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; для привязки некоторый контекст:</target>
        </trans-unit>
        <trans-unit id="dc679a70c9e897fc95d295324256f7f747aa41bb" translate="yes" xml:space="preserve">
          <source>You can use &lt;strong&gt;native Promise&lt;/strong&gt; in ES6, for exemple dealing with setTimeout:</source>
          <target state="translated">Вы можете использовать &lt;strong&gt;встроенный Promise&lt;/strong&gt; в ES6, например, для работы с setTimeout:</target>
        </trans-unit>
        <trans-unit id="dae6dd4f7460eb8ce6d2c469fb04285bb015e4e5" translate="yes" xml:space="preserve">
          <source>You can use JavaScript native promises with Node JS.</source>
          <target state="translated">Вы можете использовать JavaScript нативных обещаний с Node JS.</target>
        </trans-unit>
        <trans-unit id="afeed28ed3fcc2af7c3878d7174d83dc8d43031f" translate="yes" xml:space="preserve">
          <source>You would then use the resulting promise like so:</source>
          <target state="translated">Тогда вы бы использовали полученное обещание как таковое:</target>
        </trans-unit>
        <trans-unit id="e9d60add30f8bb5929f99ac40d5160bfb71c32e0" translate="yes" xml:space="preserve">
          <source>can be converted with Q.ninvoke</source>
          <target state="translated">может быть преобразован с помощью Q.ninvoke</target>
        </trans-unit>
        <trans-unit id="34a54cfdcaffa6edf5464329ad895cf08064577b" translate="yes" xml:space="preserve">
          <source>jQuery also offers a &lt;code&gt;$.Deferred(fn)&lt;/code&gt; form, which has the advantage of allowing us to write an expression that emulates very closely the &lt;code&gt;new Promise(fn)&lt;/code&gt; form, as follows:</source>
          <target state="translated">jQuery также предлагает форму &lt;code&gt;$.Deferred(fn)&lt;/code&gt; , которая имеет преимущество в том, что позволяет нам написать выражение, которое очень близко имитирует &lt;code&gt;new Promise(fn)&lt;/code&gt; форму Promise (fn) , следующим образом:</target>
        </trans-unit>
        <trans-unit id="90242f4c42d3b05c33b76121e4b05821eb670484" translate="yes" xml:space="preserve">
          <source>the callback function always accept the error object as it's first argument.</source>
          <target state="translated">функция обратного вызова всегда принимает объект ошибки в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="30148ebd2697af745f0c69fac10a2a42bac156b6" translate="yes" xml:space="preserve">
          <source>the callback function is passed by last argument.</source>
          <target state="translated">функция обратного вызова передается последним аргументом.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
