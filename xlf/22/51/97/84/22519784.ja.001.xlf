<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/22519784">
    <body>
      <group id="22519784">
        <trans-unit id="0d1876b42ec40b07f0901b79d802642cbf3db6a6" translate="yes" xml:space="preserve">
          <source>(I recommend visiting &lt;a href=&quot;http://exploringjs.com/es6/ch_promises.html&quot;&gt;this beautiful source&lt;/a&gt;)</source>
          <target state="translated">（私は&lt;a href=&quot;http://exploringjs.com/es6/ch_promises.html&quot;&gt;この美しい情報源を&lt;/a&gt;訪れることをお勧めします ）</target>
        </trans-unit>
        <trans-unit id="1a9687b9fb765f1427325e76179dc016f46e0b7f" translate="yes" xml:space="preserve">
          <source>(The callback method is assumed to have two parameters as error and result)</source>
          <target state="translated">(コールバックメソッドはエラーと結果の2つのパラメータを持つと仮定しています)</target>
        </trans-unit>
        <trans-unit id="140ce27c605a99fd16b6f49c4709b30c0c0d5027" translate="yes" xml:space="preserve">
          <source>1. DOM load or other one time event:</source>
          <target state="translated">1.DOM ロードまたはその他の 1 回限りのイベント。</target>
        </trans-unit>
        <trans-unit id="f3feb3b9a4fadb33bdde8b9e238c456eef319374" translate="yes" xml:space="preserve">
          <source>2. Plain callback:</source>
          <target state="translated">2.プレーンなコールバック。</target>
        </trans-unit>
        <trans-unit id="b1f5dbf968434049e3d06c3fbc7b91c1c4a0074d" translate="yes" xml:space="preserve">
          <source>3. Node style callback (&quot;nodeback&quot;):</source>
          <target state="translated">3.ノードスタイルのコールバック(&quot;nodeback&quot;)。</target>
        </trans-unit>
        <trans-unit id="e7d557519bf0bcedc91d45c78a25a683446c57c3" translate="yes" xml:space="preserve">
          <source>4. A whole library with node style callbacks:</source>
          <target state="translated">4.ノードスタイルのコールバックを持つライブラリ全体。</target>
        </trans-unit>
        <trans-unit id="508de91fce54d4813e92f47075de1963072ce810" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Promise&lt;/code&gt; can also be used on any platform that is based on Node.js like &lt;code&gt;react-native&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; は、 &lt;code&gt;react-native&lt;/code&gt; のようなNode.jsに基づいたプラットフォームでも使用できます。</target>
        </trans-unit>
        <trans-unit id="84481bb62537dcfe7b3728bba8f136ab65eb7d6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;es6-promisify&lt;/code&gt; converts callback-based functions to Promise-based functions.</source>
          <target state="translated">&lt;code&gt;es6-promisify&lt;/code&gt; は、コールバックベースの関数をPromiseベースの関数に変換します。</target>
        </trans-unit>
        <trans-unit id="6f191c2698c6eb0413bd6c2ca6e36474db531dfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/strong&gt; Javascript Async API code:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/strong&gt; Javascript Async APIコード：</target>
        </trans-unit>
        <trans-unit id="80f9f35a621c81865657b103d29cba17b5659e48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After Converting It&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;変換後&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="020585adb8b12b4604a596236a3c07cee48318bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before converting a function as promise In Node.JS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Node.JSでpromiseとして関数を変換する前&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="414958c0d8b719ec718c5694f1d7b1580ed56a22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bonus&lt;/strong&gt;: An &lt;strong&gt;hybrid&lt;/strong&gt; method</source>
          <target state="translated">&lt;strong&gt;ボーナス&lt;/strong&gt; ： &lt;strong&gt;ハイブリッド&lt;/strong&gt;方式</target>
        </trans-unit>
        <trans-unit id="46a4b2b972ff5677800784ab71c3a5efe0cda580" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incase you need to handle multiple request&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;複数のリクエストを処理する必要がある場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89cf9925ff498ed29e9ef6df1f841c7bc121a96e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plain&lt;/strong&gt; Javascript Async API code:</source>
          <target state="translated">&lt;strong&gt;プレーン&lt;/strong&gt; Javascript非同期APIコード：</target>
        </trans-unit>
        <trans-unit id="b8fb2f83aee2cbeff4ac6fcb5ea50cce08e5c218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fulfilled&lt;/strong&gt; meaning that the computation completed successfully.</source>
          <target state="translated">&lt;strong&gt;満たされた&lt;/strong&gt;という意味は、計算が正常に完了したことです。</target>
        </trans-unit>
        <trans-unit id="3030d3b7a04661fbb4185df915ebeef20d9e0313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rejected&lt;/strong&gt; meaning that the computation failed.</source>
          <target state="translated">&lt;strong&gt;拒否&lt;/strong&gt;は、計算が失敗したことを意味します。</target>
        </trans-unit>
        <trans-unit id="72577fd58c67ec9eaf27588179094e92bcbf92f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;toPromise&lt;/strong&gt; and &lt;strong&gt;checkErr&lt;/strong&gt; function is own by &lt;a href=&quot;https://github.com/jituanlin/berserk&quot;&gt;berserk&lt;/a&gt; library, it's a functional programming library fork by &lt;strong&gt;ramda.js&lt;/strong&gt;(create by me).</source>
          <target state="translated">&lt;strong&gt;toPromise&lt;/strong&gt;と&lt;strong&gt;checkErr&lt;/strong&gt;関数は&lt;a href=&quot;https://github.com/jituanlin/berserk&quot;&gt;berserk&lt;/a&gt;ライブラリが所有しており、 &lt;strong&gt;ramda.js&lt;/strong&gt; （私が作成）が作成した関数型プログラミングライブラリフォークです。</target>
        </trans-unit>
        <trans-unit id="052ca2463678fe184067a71a1401d5432b9b5051" translate="yes" xml:space="preserve">
          <source>A simple and basic example to &lt;code&gt;Promise&lt;/code&gt; (with &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/KISS_principle&quot;&gt;KISS&lt;/a&gt;&lt;/strong&gt; way):</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; のシンプルで基本的な例（ &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/KISS_principle&quot;&gt;KISSを使用&lt;/a&gt;&lt;/strong&gt; ）：</target>
        </trans-unit>
        <trans-unit id="898fb7e7d5157e7e25e187704ed0a723cf907352" translate="yes" xml:space="preserve">
          <source>Also &lt;code&gt;Promise&lt;/code&gt; can be used with together &lt;code&gt;async\await&lt;/code&gt; in &lt;code&gt;ES7&lt;/code&gt; to make the program flow wait for a &lt;code&gt;fullfiled&lt;/code&gt; result like the following:</source>
          <target state="translated">また、 &lt;code&gt;Promise&lt;/code&gt; を &lt;code&gt;ES7&lt;/code&gt; で &lt;code&gt;async\await&lt;/code&gt; と一緒に使用して、プログラムフローに次のような &lt;code&gt;fullfiled&lt;/code&gt; 結果を待機させることができます。</target>
        </trans-unit>
        <trans-unit id="2cd27fac479cc277d48e4015dbeacffe3abede6d" translate="yes" xml:space="preserve">
          <source>Another usage with the same code by using &lt;code&gt;.then()&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;.then()&lt;/code&gt; メソッドを使用した同じコードでの別の使用法</target>
        </trans-unit>
        <trans-unit id="351a78942173c1488ea5b8410ba43599ea818e0b" translate="yes" xml:space="preserve">
          <source>Below is the implementation of how a function (callback API) can be converted to a promise.</source>
          <target state="translated">以下は、関数(コールバックAPI)をプロミスに変換する方法の実装です。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="514203e2cc91acaadcf199840c46daba11328bda" translate="yes" xml:space="preserve">
          <source>For more concise, above example used ramda.js. Ramda.js is a excellent library for functional programming. In above code, we used it's &lt;strong&gt;apply&lt;/strong&gt;(like javascript &lt;code&gt;function.prototype.apply&lt;/code&gt;) and append(like javascript &lt;code&gt;function.prototype.push&lt;/code&gt; ).
So, we could convert the a callback style function to promise style function now:</source>
          <target state="translated">より簡潔にするために、上記の例ではramda.jsを使用しました。 Ramda.jsは、関数型プログラミングのための優れたライブラリです。 上記のコードでは、 &lt;strong&gt;apply&lt;/strong&gt; （javascript &lt;code&gt;function.prototype.apply&lt;/code&gt; など ）とappend（javascript &lt;code&gt;function.prototype.push&lt;/code&gt; など ）を使用しました。 したがって、コールバックスタイル関数をpromiseスタイル関数に変換できます。</target>
        </trans-unit>
        <trans-unit id="6662fe5ac4576166dd3de6947b82e3f376690ab5" translate="yes" xml:space="preserve">
          <source>Hope this answer is useful for you.</source>
          <target state="translated">この回答がお役に立てれば幸いです。</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">これが助けになることを願っています。</target>
        </trans-unit>
        <trans-unit id="fc2b0555407985e3cf1a7bf797cd8ce59b3f79ef" translate="yes" xml:space="preserve">
          <source>How do I convert an existing callback API to promises</source>
          <target state="translated">既存のコールバック API をプロミスに変換する方法</target>
        </trans-unit>
        <trans-unit id="aebcd473bebc1c7b9af086175f1414ed1903517d" translate="yes" xml:space="preserve">
          <source>How do I work with the API in promises, how do I &quot;promisify&quot; it?</source>
          <target state="translated">プロミスでAPIと連携するにはどうすればいいのか、どうやって「プロミス化」すればいいのか。</target>
        </trans-unit>
        <trans-unit id="8e090d332d9dabde6e435eafdb66e7b93d430d7f" translate="yes" xml:space="preserve">
          <source>How to use:</source>
          <target state="translated">どのように使用するか。</target>
        </trans-unit>
        <trans-unit id="16be5ebd5a0d9ad662aa3417d90669b397fb2dc8" translate="yes" xml:space="preserve">
          <source>I don't think the &lt;code&gt;window.onload&lt;/code&gt; suggestion by @Benjamin will work all the time, as it doesn't detect whether it is called after the load. I have been bitten by that many times. Here is a version which should always work:</source>
          <target state="translated">ロード後に呼び出されるかどうかを検出しないため、@ Benjaminによる &lt;code&gt;window.onload&lt;/code&gt; の提案が常に機能するとは思いません。 何度も噛まれました。 これは常に動作するはずのバージョンです：</target>
        </trans-unit>
        <trans-unit id="8a7b10b9a6a317e290183bc2492d3ef2f0b36225" translate="yes" xml:space="preserve">
          <source>I want to work with promises but I have a callback API in a format like:</source>
          <target state="translated">プロミスを使った作業をしたいのですが、コールバックAPIをこんな感じの形式にしています。</target>
        </trans-unit>
        <trans-unit id="a9555e1100fbd9b659e01a560f310bc7fc97ad2a" translate="yes" xml:space="preserve">
          <source>In Node.js 8 you can &lt;strong&gt;promisify&lt;/strong&gt; object methods &lt;em&gt;on the fly&lt;/em&gt; using this npm module:</source>
          <target state="translated">Node.js 8 &lt;em&gt;では、&lt;/em&gt;このnpmモジュールを使用&lt;em&gt;して、その場で&lt;/em&gt;オブジェクトメソッド&lt;em&gt;を&lt;/em&gt; &lt;strong&gt;約束&lt;/strong&gt;できます。</target>
        </trans-unit>
        <trans-unit id="f389ff5218c8149d6f054388ef888a498d71c48b" translate="yes" xml:space="preserve">
          <source>In an actual &lt;code&gt;onload&lt;/code&gt; case, you should use &lt;code&gt;addEventListener&lt;/code&gt; rather than &lt;code&gt;onX&lt;/code&gt;.</source>
          <target state="translated">実際の &lt;code&gt;onload&lt;/code&gt; の場合、 &lt;code&gt;onX&lt;/code&gt; ではなく &lt;code&gt;addEventListener&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d3d7d39449853b6cb72a5406424fa776ecc5dc4d" translate="yes" xml:space="preserve">
          <source>In general, you should not promisify things manually too much, most promise libraries that were designed with Node in mind as well as native promises in Node 8+ have a built in method for promisifying nodebacks. For example</source>
          <target state="translated">一般的には、あまり手動でプロミスするべきではありません。 Node を念頭に置いて設計されたほとんどのプロミスライブラリや、Node 8+のネイティブプロミスは、ノードバックをプロミスするためのメソッドを内蔵しています。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="80e7e7b533a635b062f1db604c77ceaaf914b3bb" translate="yes" xml:space="preserve">
          <source>In release candidate for Node.js 8.0.0, there's a new utility, &lt;code&gt;util.promisify&lt;/code&gt; (I've written about &lt;a href=&quot;https://brunoscopelliti.com/new-util-promisify-in-nodejs/&quot;&gt;util.promisify&lt;/a&gt;), that encapsulates the capacity of promisifying whatever function.</source>
          <target state="translated">Node.js 8.0.0のリリース候補には、あらゆる機能を約束する機能をカプセル化する新しいユーティリティ &lt;code&gt;util.promisify&lt;/code&gt; （ &lt;a href=&quot;https://brunoscopelliti.com/new-util-promisify-in-nodejs/&quot;&gt;util.promisify&lt;/a&gt;について書いた ）があります。</target>
        </trans-unit>
        <trans-unit id="1bdd556ef766673d3e75492cf664385618665ae6" translate="yes" xml:space="preserve">
          <source>In this exemple, the Promise has no reason to fail, so &lt;code&gt;reject()&lt;/code&gt; is never called.</source>
          <target state="translated">この例では、Promiseに失敗する理由がないため、 &lt;code&gt;reject()&lt;/code&gt; が呼び出されることはありません。</target>
        </trans-unit>
        <trans-unit id="deaff6ec2dfe20cd74c5a8b632dbf4649b8d9eb2" translate="yes" xml:space="preserve">
          <source>It is like 5 years late, but I wanted to post here my promesify version which takes functions from callbacks API and turns them into promises</source>
          <target state="translated">5年ほど遅れてしまいましたが、コールバックAPIから関数を取り出してプロミスに変換するプロミス化バージョンをここに投稿したいと思いました。</target>
        </trans-unit>
        <trans-unit id="a1b7fc56ae1991014e6d0d15ec706dc9dd7f995a" translate="yes" xml:space="preserve">
          <source>It is not much different from the approaches suggested in the other answers, but has the advantage of being a core method, and not requiring additional dependencies.</source>
          <target state="translated">他の回答で提案されているアプローチと大差はありませんが、コアメソッドであり、追加の依存関係を必要としないという利点があります。</target>
        </trans-unit>
        <trans-unit id="c5c8b120c5e6add5e38e8e197012d63c38130787" translate="yes" xml:space="preserve">
          <source>It uses &lt;strong&gt;util.promisify&lt;/strong&gt; and &lt;strong&gt;Proxies&lt;/strong&gt; so that your objects stay unchanged. &lt;strong&gt;Memoization&lt;/strong&gt; is also done with the use of WeakMaps). Here are some examples:</source>
          <target state="translated">オブジェクトが変更されないように、 &lt;strong&gt;util.promisify&lt;/strong&gt;と&lt;strong&gt;プロキシを&lt;/strong&gt;使用します。 &lt;strong&gt;メモ化&lt;/strong&gt;は、WeakMapsを使用して行われます。 ここではいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="b8b3a751be7e5776568231e30b4e9eedc323a0c4" translate="yes" xml:space="preserve">
          <source>My Cloud 9 code link: &lt;a href=&quot;https://ide.c9.io/adx2803/native-promises-in-node&quot;&gt;https://ide.c9.io/adx2803/native-promises-in-node&lt;/a&gt;</source>
          <target state="translated">My Cloud 9コードリンク： &lt;a href=&quot;https://ide.c9.io/adx2803/native-promises-in-node&quot;&gt;https&lt;/a&gt; : //ide.c9.io/adx2803/native-promises-in-node</target>
        </trans-unit>
        <trans-unit id="5f190e2d292229f60f0e3bedc4e97b0bd3130a80" translate="yes" xml:space="preserve">
          <source>My promisify version of a &lt;code&gt;callback&lt;/code&gt; function is the &lt;code&gt;P&lt;/code&gt; function:</source>
          <target state="translated">私の約束する &lt;code&gt;callback&lt;/code&gt; 関数のバージョンは &lt;code&gt;P&lt;/code&gt; 関数です：</target>
        </trans-unit>
        <trans-unit id="97e12285a628806af2f0a9122c3fa2222474d2bb" translate="yes" xml:space="preserve">
          <source>Node style callbacks (nodebacks) have a particular format where the callbacks is always the last argument and its first parameter is an error. Let's first promisify one manually:</source>
          <target state="translated">ノードスタイルのコールバック(nodebacks)には、コールバックが常に最後の引数であり、その最初のパラメータがエラーであるという特定のフォーマットがあります。最初に手動で1つを宣言してみましょう。</target>
        </trans-unit>
        <trans-unit id="66dcd2df1165f224d8c67f681352cefc8c8436ee" translate="yes" xml:space="preserve">
          <source>Node.js 8.0.0 includes a new &lt;code&gt;util.promisify()&lt;/code&gt; API that allows standard Node.js callback style APIs to be wrapped in a function that returns a Promise. An example use of &lt;code&gt;util.promisify()&lt;/code&gt; is shown below.</source>
          <target state="translated">Node.js 8.0.0には、標準のNode.jsコールバックスタイルAPIをPromiseを返す関数でラップできる新しい &lt;code&gt;util.promisify()&lt;/code&gt; APIが含まれています。 &lt;code&gt;util.promisify()&lt;/code&gt; の使用例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="f02a74e3155ce4267ad4d6499415dfc35ee3418e" translate="yes" xml:space="preserve">
          <source>Note: Here we exploit the fact that a jQuery deferred's &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; methods are &quot;detachable&quot;; ie. they are bound to the &lt;em&gt;instance&lt;/em&gt; of a jQuery.Deferred(). Not all libs offer this feature.</source>
          <target state="translated">注：ここでは、jQuery遅延オブジェクトの &lt;code&gt;resolve&lt;/code&gt; メソッドと &lt;code&gt;reject&lt;/code&gt; メソッドが「分離可能」であるという事実を利用しています。 すなわち。 それらはjQuery.Deferred（）の&lt;em&gt;インスタンス&lt;/em&gt;にバインドされてい&lt;em&gt;ます&lt;/em&gt; 。 すべてのライブラリがこの機能を提供するわけではありません。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="3ddfe332a10af66808ac4e1dd4aefb53b8829e86" translate="yes" xml:space="preserve">
          <source>Of course, when you are in a &lt;code&gt;.then&lt;/code&gt; handler you do not need to promisify things. Returning a promise from a &lt;code&gt;.then&lt;/code&gt; handler will resolve or reject with that promise's value. Throwing from a &lt;code&gt;.then&lt;/code&gt; handler is also good practice and will reject the promise - this is the famous promise throw safety.</source>
          <target state="translated">もちろん、 &lt;code&gt;.then&lt;/code&gt; ハンドラーにいるときは、約束をする必要はありません。 &lt;code&gt;.then&lt;/code&gt; ハンドラーからpromiseを返すと、promiseの値で解決または拒否されます。 &lt;code&gt;.then&lt;/code&gt; ハンドラーからのスローも良い習慣であり、約束を拒否します-これは有名な約束のスローの安全です。</target>
        </trans-unit>
        <trans-unit id="8849f34c85d8450573581f94f47aaf726a7cae55" translate="yes" xml:space="preserve">
          <source>Or with &lt;em&gt;native promises&lt;/em&gt; in &lt;strong&gt;Node&lt;/strong&gt;:</source>
          <target state="translated">または、 &lt;strong&gt;Node&lt;/strong&gt;で&lt;em&gt;ネイティブのpromiseを使用&lt;/em&gt;します。</target>
        </trans-unit>
        <trans-unit id="1c9aefba335c0791682fea70998fa03d4f5a6fbd" translate="yes" xml:space="preserve">
          <source>Or with a jQuery like API, hooking on an event happening once:</source>
          <target state="translated">もしくはjQueryのようなAPIを使って、一度発生したイベントをフックする。</target>
        </trans-unit>
        <trans-unit id="db8250f72c11679d6255938f7af4ed9dfacae51f" translate="yes" xml:space="preserve">
          <source>Promise returning functions &lt;a href=&quot;https://stackoverflow.com/q/21887856/1048572&quot;&gt;&lt;em&gt;should never throw&lt;/em&gt;&lt;/a&gt;, they should return rejections instead. Throwing from a promise returning function will force you to use both a &lt;code&gt;} catch {&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; a &lt;code&gt;.catch&lt;/code&gt;. People using promisified APIs do not expect promises to throw. If you're not sure how async APIs work in JS - please &lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;see this answer&lt;/a&gt; first.</source>
          <target state="translated">Promiseを返す関数&lt;a href=&quot;https://stackoverflow.com/q/21887856/1048572&quot;&gt;&lt;em&gt;はスローしない&lt;/em&gt;&lt;/a&gt;でください。代わりに拒否を返します。 promiseの &lt;code&gt;.catch&lt;/code&gt; &lt;em&gt;と&lt;/em&gt; 、 &lt;code&gt;} catch {&lt;/code&gt; &lt;em&gt;と&lt;/em&gt; .catchの両方を使用する必要があります。 約束されたAPIを使用している人々は、約束がスローされることを期待していません。 JSで非同期APIがどのように機能するかわからない場合&lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;は、&lt;/a&gt;まずこの回答を参照してください。</target>
        </trans-unit>
        <trans-unit id="63104f36ddfde5f398242d3c9a325847a623a94b" translate="yes" xml:space="preserve">
          <source>Promises have state, they start as pending and can settle to:</source>
          <target state="translated">約束は状態を持っていて、彼らは保留として開始され、解決することができます。</target>
        </trans-unit>
        <trans-unit id="ce024d8f1a277d9758eb3a0ab31acae8de6e3f74" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;https://www.npmjs.com/package/es6-promisify&quot;&gt;https://www.npmjs.com/package/es6-promisify&lt;/a&gt;</source>
          <target state="translated">参照： &lt;a href=&quot;https://www.npmjs.com/package/es6-promisify&quot;&gt;https&lt;/a&gt; : //www.npmjs.com/package/es6-promisify</target>
        </trans-unit>
        <trans-unit id="e7e9cd4e0335b59625886d2b1031ad2d04ca20cc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://nodejs.org/en/blog/release/v8.0.0/#improved-support-for-promises&quot;&gt;Improved support for Promises&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://nodejs.org/en/blog/release/v8.0.0/#improved-support-for-promises&quot;&gt;Promiseのサポートの改善を&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="2b6e0801d895ee9944b96f9f5484f8dc41409db1" translate="yes" xml:space="preserve">
          <source>So, creating promises generally means specifying when they settle - that means when they move to the fulfilled or rejected phase to indicate the data is available (and can be accessed with &lt;code&gt;.then&lt;/code&gt;).</source>
          <target state="translated">したがって、Promiseを作成することは、通常、いつ決着するかを指定することを意味します。つまり、データが利用可能である（そして &lt;code&gt;.then&lt;/code&gt; でアクセスできる）ことを示すために、履行段階または却下段階に移行するときを意味します。</target>
        </trans-unit>
        <trans-unit id="6711c27913da3ae89356ef0a6b2afab3ec3bdcd1" translate="yes" xml:space="preserve">
          <source>So, you could write a function for convert a function with this style like this:</source>
          <target state="translated">ということで、このようなスタイルで変換用の関数を書くことができます。</target>
        </trans-unit>
        <trans-unit id="5777c6a10b1074ef2c4e1b68827869d3f5033d63" translate="yes" xml:space="preserve">
          <source>Take a look to this very simple version here:
&lt;a href=&quot;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&quot;&gt;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&lt;/a&gt;</source>
          <target state="translated">こちらの非常にシンプルなバージョンを&lt;a href=&quot;https://gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a&quot;&gt;ご覧ください&lt;/a&gt; ： https : //gist.github.com/jdtorregrosas/aeee96dd07558a5d18db1ff02f31e21a</target>
        </trans-unit>
        <trans-unit id="f0d977dad38e296f6bfd90deb048f970c9c67117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;P&lt;/code&gt; function requires that the callback signature must be &lt;code&gt;callback(error,result)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 関数では、コールバック署名が &lt;code&gt;callback(error,result)&lt;/code&gt; 必要があります 。</target>
        </trans-unit>
        <trans-unit id="8bc89607696b2f1a8d66eba2d06c29841e319a2b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback style&lt;/strong&gt; function always like this(almost all function in node.js is this style):</source>
          <target state="translated">&lt;strong&gt;コールバックスタイル&lt;/strong&gt;関数は常に次のようになります（node.jsのほとんどすべての関数はこのスタイルです）：</target>
        </trans-unit>
        <trans-unit id="8706b3f162f6603cc7e79182f266ec63f74a9b68" translate="yes" xml:space="preserve">
          <source>The Q library by kriskowal includes callback-to-promise functions.
A method like this:</source>
          <target state="translated">kriskowalによるQライブラリには、コールバック・トゥ・プロミス関数が含まれています。このようなメソッドです。</target>
        </trans-unit>
        <trans-unit id="de72601b86517effe9b85b6d0c7e1c3ffa7debc4" translate="yes" xml:space="preserve">
          <source>The above method can respond result for old fashion callback and Promise usages.</source>
          <target state="translated">上記のメソッドは、昔ながらのコールバックやプロミスでも結果を返すことができます。</target>
        </trans-unit>
        <trans-unit id="b11001c47aa205e4eaec3068ce28d129ef621ccb" translate="yes" xml:space="preserve">
          <source>Then use it</source>
          <target state="translated">その後、それを使用します。</target>
        </trans-unit>
        <trans-unit id="17163e759ecdf79e9fb7b2df64ccf7697a1281a0" translate="yes" xml:space="preserve">
          <source>Then you've a &lt;code&gt;readFile&lt;/code&gt; method that returns a native &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">次に、ネイティブの &lt;code&gt;Promise&lt;/code&gt; を返す &lt;code&gt;readFile&lt;/code&gt; メソッドがあります。</target>
        </trans-unit>
        <trans-unit id="464aeaf407d5847f41b0ae64bf603fe11017cfba" translate="yes" xml:space="preserve">
          <source>There is no golden rule here, you promisify them one by one. However, some promise implementations allow you to do this in bulk, for example in Bluebird, converting a nodeback API to a promise API is as simple as:</source>
          <target state="translated">ここには黄金のルールはなく、一つずつプロミスしていくことになります。しかし、いくつかのプロミス実装では、これを一括で行うことができます。例えば Bluebird では、ノードバック API をプロミス API に変換するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="4d9ffb6a97e5e5bbcbe53f0f5a4919cdce804d49" translate="yes" xml:space="preserve">
          <source>These APIs are rather common since well&amp;hellip; callbacks are common in JS. Let's look at the common case of having &lt;code&gt;onSuccess&lt;/code&gt; and &lt;code&gt;onFail&lt;/code&gt;:</source>
          <target state="translated">よくあるので、これらのAPIはかなり一般的です...コールバックはJSで一般的です。 &lt;code&gt;onSuccess&lt;/code&gt; と &lt;code&gt;onFail&lt;/code&gt; を持つ一般的なケースを見てみましょう：</target>
        </trans-unit>
        <trans-unit id="a24d348893666157b62e242280f51475221a232e" translate="yes" xml:space="preserve">
          <source>This style has same feature:</source>
          <target state="translated">このスタイルも同じ特徴を持っています。</target>
        </trans-unit>
        <trans-unit id="7e7fbc811015943c1c30e7ceeea8b05c76a8ee58" translate="yes" xml:space="preserve">
          <source>To:</source>
          <target state="translated">To:</target>
        </trans-unit>
        <trans-unit id="7358246eac812cc9c89d7fe9ba9ce83f6e63c900" translate="yes" xml:space="preserve">
          <source>Today, I can use &lt;code&gt;Promise&lt;/code&gt; in &lt;code&gt;Node.js&lt;/code&gt; as a plain Javascript method.</source>
          <target state="translated">今日、 &lt;code&gt;Node.js&lt;/code&gt; の &lt;code&gt;Promise&lt;/code&gt; をプレーンなJavaScriptメソッドとして使用できます。</target>
        </trans-unit>
        <trans-unit id="8b6075ef4725d1671138cf91e362129ef1c76b1a" translate="yes" xml:space="preserve">
          <source>Under node v7.6+ which has built in promises and async:</source>
          <target state="translated">プロミスとasyncが組み込まれたnode v7.6+以下。</target>
        </trans-unit>
        <trans-unit id="21cdff4e0d1a00d84e4023f3878afafea6747c66" translate="yes" xml:space="preserve">
          <source>When you have a few functions that take a callback and you want them to return a promise instead you can use this function to do the conversion.</source>
          <target state="translated">コールバックを取る関数をいくつか持っていて、代わりにプロミスを返したい場合は、この関数を使って変換を行うことができます。</target>
        </trans-unit>
        <trans-unit id="285d8f9ff235163a0941b27c17f4866a6ef7151a" translate="yes" xml:space="preserve">
          <source>With deferreds you can do the following (let's use Q for this example, although Q now supports the new syntax &lt;a href=&quot;https://stackoverflow.com/q/28687566/1048572&quot;&gt;which you should prefer&lt;/a&gt;):</source>
          <target state="translated">遅延オブジェクトを使用すると、次のことができます（この例ではQを使用しましょう。ただし、Q &lt;a href=&quot;https://stackoverflow.com/q/28687566/1048572&quot;&gt;は優先される&lt;/a&gt;新しい構文をサポートしています ）。</target>
        </trans-unit>
        <trans-unit id="8785ace419b008c966fd0632a15344a1dab8462e" translate="yes" xml:space="preserve">
          <source>With functions:</source>
          <target state="translated">機能付き。</target>
        </trans-unit>
        <trans-unit id="efbd1e67d4d2386e9c2e0b20948b87efe04745ba" translate="yes" xml:space="preserve">
          <source>With libraries that support deferred (Let's use $q for this example here, but we'll also use jQuery later):</source>
          <target state="translated">deferredをサポートしているライブラリを使って(ここでは$qを使ってみますが、後ほどjQueryも使ってみます)。</target>
        </trans-unit>
        <trans-unit id="ac2912b9a51ee83c0aa361b7d8c6a138cc67a690" translate="yes" xml:space="preserve">
          <source>With libraries that support deferred (Let's use jQuery for this example here, but we've also used $q above):</source>
          <target state="translated">deferredをサポートしているライブラリを使って(ここではjQueryを使ってみましょうが、上記の$qも使っています)。</target>
        </trans-unit>
        <trans-unit id="cf5f80ccb0fa7a7fe6a4bd35f8df2b4bc17ad4d4" translate="yes" xml:space="preserve">
          <source>With modern promise implementations that support the &lt;code&gt;Promise&lt;/code&gt; constructor like native ES6 promises:</source>
          <target state="translated">ネイティブES6 &lt;code&gt;Promise&lt;/code&gt; ようなPromiseコンストラクターをサポートする最新のpromise実装では、次のようになります。</target>
        </trans-unit>
        <trans-unit id="85e6d2a844dfdb833a5d8fa9fa8380f9779e47b0" translate="yes" xml:space="preserve">
          <source>With objects:</source>
          <target state="translated">オブジェクトと一緒に。</target>
        </trans-unit>
        <trans-unit id="31e3cfe8ea7886a445fda00bc753060e6ca9897b" translate="yes" xml:space="preserve">
          <source>With plain old vanilla javaScript, here's a solution to promisify an api callback.</source>
          <target state="translated">古くからあるバニラのjavaScriptを使って、APIコールバックをプロミスする方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="25d7f4649ff6f2e5528a53a85b385845fcbb3e72" translate="yes" xml:space="preserve">
          <source>You can do something like this</source>
          <target state="translated">このようなことができます。</target>
        </trans-unit>
        <trans-unit id="6d25b1105a2067210eeece1f22921f5c5a068521" translate="yes" xml:space="preserve">
          <source>You can even use native &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; to bind some context:</source>
          <target state="translated">ネイティブ &lt;code&gt;call&lt;/code&gt; を使用して、いくつかのコンテキストをバインドすることもできます。</target>
        </trans-unit>
        <trans-unit id="dc679a70c9e897fc95d295324256f7f747aa41bb" translate="yes" xml:space="preserve">
          <source>You can use &lt;strong&gt;native Promise&lt;/strong&gt; in ES6, for exemple dealing with setTimeout:</source>
          <target state="translated">たとえば、setTimeoutを処理する場合は、ES6の&lt;strong&gt;ネイティブPromise&lt;/strong&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="dae6dd4f7460eb8ce6d2c469fb04285bb015e4e5" translate="yes" xml:space="preserve">
          <source>You can use JavaScript native promises with Node JS.</source>
          <target state="translated">Node JSでJavaScriptのネイティブプロミスを使うことができます。</target>
        </trans-unit>
        <trans-unit id="afeed28ed3fcc2af7c3878d7174d83dc8d43031f" translate="yes" xml:space="preserve">
          <source>You would then use the resulting promise like so:</source>
          <target state="translated">そして、結果として得られるプロミスをこのように使用します。</target>
        </trans-unit>
        <trans-unit id="e9d60add30f8bb5929f99ac40d5160bfb71c32e0" translate="yes" xml:space="preserve">
          <source>can be converted with Q.ninvoke</source>
          <target state="translated">は Q.ninvoke で変換できます。</target>
        </trans-unit>
        <trans-unit id="34a54cfdcaffa6edf5464329ad895cf08064577b" translate="yes" xml:space="preserve">
          <source>jQuery also offers a &lt;code&gt;$.Deferred(fn)&lt;/code&gt; form, which has the advantage of allowing us to write an expression that emulates very closely the &lt;code&gt;new Promise(fn)&lt;/code&gt; form, as follows:</source>
          <target state="translated">jQueryは &lt;code&gt;$.Deferred(fn)&lt;/code&gt; フォームも提供します。これには、次のように、 &lt;code&gt;new Promise(fn)&lt;/code&gt; フォームを非常に厳密にエミュレートする式を記述できるという利点があります。</target>
        </trans-unit>
        <trans-unit id="90242f4c42d3b05c33b76121e4b05821eb670484" translate="yes" xml:space="preserve">
          <source>the callback function always accept the error object as it's first argument.</source>
          <target state="translated">コールバック関数は常にエラーオブジェクトを第一引数として受け入れます。</target>
        </trans-unit>
        <trans-unit id="30148ebd2697af745f0c69fac10a2a42bac156b6" translate="yes" xml:space="preserve">
          <source>the callback function is passed by last argument.</source>
          <target state="translated">コールバック関数は最後の引数で渡されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
