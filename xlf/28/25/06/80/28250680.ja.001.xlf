<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/28250680">
    <body>
      <group id="28250680">
        <trans-unit id="886001de61d616fd7504793554e90b0ead0d7946" translate="yes" xml:space="preserve">
          <source>(Note: a more complex and complete version of this solution has been tested, but not this example version, so it could have a bug.)</source>
          <target state="translated">(注意:このソリューションのより複雑で完全なバージョンはテストされていますが、この例のバージョンではテストされていないので、バグがある可能性があります)。</target>
        </trans-unit>
        <trans-unit id="8c36a0c010728fc244e1f43aab8c1da795455c65" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/q/844536/1048572&quot;&gt;Mutable state is ugly&lt;/a&gt;, and &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil&quot;&gt;global variables are evil&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/844536/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可変&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;状態は醜く&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;グローバル変数は悪&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="446787ac4bf8edd63cd98d9810d37f90a8ce33c1" translate="yes" xml:space="preserve">
          <source>A less harsh spin on &quot;Mutable contextual state&quot;</source>
          <target state="translated">&quot;Mutable contextual state &quot;のあまり厳しくないスピン</target>
        </trans-unit>
        <trans-unit id="61650d4ab35176fac8853a022c21d3f429ac0a74" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;https://html5hive.org/how-to-chain-javascript-promises/&quot;&gt;how-to-chain-javascript-promises&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;よると&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://html5hive.org/how-to-chain-javascript-promises/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どのようにツーチェーンのjavascript-約束&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb4e646963a08495dd8a836cba56eac6efaa78a1" translate="yes" xml:space="preserve">
          <source>Alternatively, you can employ &lt;code&gt;Promise.all&lt;/code&gt; to produce the promise for the array:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;して配列のpromiseを作成する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;こともできます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94665e6ad2dc97bb0515d1739a70f85937dae7b8" translate="yes" xml:space="preserve">
          <source>And then, there are also many other &lt;a href=&quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS#synchronous-to-asynchronous-javascript-compilers-cps&quot;&gt;compile-to-JS languages&lt;/a&gt;
that are dedicated to easing asynchronous programming. They usually use a syntax similar to &lt;code&gt;await&lt;/code&gt;, (e.g. &lt;a href=&quot;http://maxtaco.github.io/coffee-script/&quot;&gt;Iced CoffeeScript&lt;/a&gt;), but there are also others that feature a Haskell-like &lt;code&gt;do&lt;/code&gt;-notation (e.g. &lt;a href=&quot;http://lattejs.com/&quot;&gt;LatteJs&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/monadic&quot;&gt;monadic&lt;/a&gt;, &lt;a href=&quot;http://www.purescript.org/&quot;&gt;PureScript&lt;/a&gt; or &lt;a href=&quot;http://lispyscript.com/&quot;&gt;LispyScript&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 非同期プログラミングの緩和に特化した&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他の多くの&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS#synchronous-to-asynchronous-javascript-compilers-cps&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;compile-to-JS言語&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もあります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;await&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;似た構文&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（例：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://maxtaco.github.io/coffee-script/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Iced CoffeeScript&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が、Haskellのような&lt;/font&gt;&lt;/font&gt; &lt;code&gt;do&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表記（例：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://lattejs.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LatteJs&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.npmjs.com/package/monadic&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;モナディック&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.purescript.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PureScript&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://lispyscript.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LispyScript&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;備えた構文&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;も&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b117394e70cda9ad8f1592c22985ada9cd1467db" translate="yes" xml:space="preserve">
          <source>And you might not only use arrays, but arbitrarily complex objects. For example, with &lt;a href=&quot;http://underscorejs.org/#extend&quot;&gt;&lt;code&gt;_.extend&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign&lt;/code&gt;&lt;/a&gt; in a different helper function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、配列だけでなく、任意の複雑なオブジェクトを使用する場合もあります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、別のヘルパー関数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://underscorejs.org/#extend&quot;&gt; &lt;code&gt;_.extend&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用すると&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次のよう&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;になります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6cd0e648be626f2f5734fc06177a48a905ba581d" translate="yes" xml:space="preserve">
          <source>Another answer, using &lt;code&gt;babel-node&lt;/code&gt; version &amp;lt;6</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もう1つの答えは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;babel-node&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;バージョン&amp;lt;6を使用することです&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="917cd1d01022379cee10d9edbb40647574476354" translate="yes" xml:space="preserve">
          <source>Another answer, using sequential executor &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シーケンシャルエグゼキュー&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ターnsynjs&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用した別の答え&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e8aab5e31173c31302ab6dcea021b1848ed8a3ee" translate="yes" xml:space="preserve">
          <source>Assigning promises-for-later-needed-values to variables and then getting their value via synchronous inspection. The example uses bluebird's &lt;code&gt;.value()&lt;/code&gt; method but many libraries provide similar method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;後で必要になる値を変数に割り当ててから、同期検査で値を取得します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この例では、bluebirdの&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.value()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドを使用していますが、多くのライブラリが同様のメソッドを提供しています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="050feb2cbdeb309a67b27f7cdff96683ad234fa3" translate="yes" xml:space="preserve">
          <source>Before destructuring became available with ES6, a nifty helper method called &lt;code&gt;.spread()&lt;/code&gt; was pro&amp;shy;vi&amp;shy;ded by many promise libraries (&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;Q&lt;/a&gt;, &lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;Bluebird&lt;/a&gt;, &lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;when&lt;/a&gt;, &amp;hellip;). It takes a function with multiple parameters - one for each array element - to be used as &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES6で&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.spread()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が可能になる前は、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.spread（）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と呼ばれる気の利いたヘルパーメソッド&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が多くのpromiseライブラリ（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Q&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bluebird&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;when&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&amp;hellip;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;によって提供されていました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;として使用される複数のパラメーター（配列要素ごとに1つ）を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;持つ関数を受け取ります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1fbe958b0857725f5a84c804d4ae85da21ceb1d" translate="yes" xml:space="preserve">
          <source>Bluebird also features a dedicated &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.join.html&quot;&gt;&lt;code&gt;join&lt;/code&gt; function&lt;/a&gt; to replace that &lt;code&gt;Promise.all&lt;/code&gt;+&lt;code&gt;spread&lt;/code&gt; combination with a simpler (and more efficient) construct:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bluebirdは、&lt;/font&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; + &lt;/font&gt; &lt;code&gt;spread&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;組み合わせをよりシンプルな（そしてより効率的な）構成&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に置き換える&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;専用の&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.join.html&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;も備えています&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="064bf726f394fe19c0ef56ee0e3f8168e8f3bf8c" translate="yes" xml:space="preserve">
          <source>Break the chain</source>
          <target state="translated">鎖を断ち切る</target>
        </trans-unit>
        <trans-unit id="f446dfc8ca31cb54d0b1dae43079076f607503d6" translate="yes" xml:space="preserve">
          <source>ECMAScript 5</source>
          <target state="translated">ECMAScript 5</target>
        </trans-unit>
        <trans-unit id="b02b03612b472d412029a9017657b2e96f26db53" translate="yes" xml:space="preserve">
          <source>ECMAScript 6</source>
          <target state="translated">ECMAScript 6</target>
        </trans-unit>
        <trans-unit id="8eecaf932c06e6aadd977797e815790995527161" translate="yes" xml:space="preserve">
          <source>ECMAScript 8</source>
          <target state="translated">ECMAScript 8</target>
        </trans-unit>
        <trans-unit id="ec3cb3a8bb975f9d73ec9e15cd1211b669541cdd" translate="yes" xml:space="preserve">
          <source>ECMAScript Harmony</source>
          <target state="translated">ECMAScript ハーモニー</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="2568555d5b3660982a930ffff01c1764f5cb7a9c" translate="yes" xml:space="preserve">
          <source>Explicit pass-through</source>
          <target state="translated">明示的なパススルー</target>
        </trans-unit>
        <trans-unit id="66a027cb165ddbb392556662ee9b3307626866a1" translate="yes" xml:space="preserve">
          <source>For more complex cases I often use these guy small promise utilities without dependencies tested and typed. p-map has been useful several times. I think he covered most use cases:</source>
          <target state="translated">より複雑なケースでは、私はしばしばこのような小さなプロミスユーティリティを使用しています。ほとんどのユースケースをカバーしていると思います。</target>
        </trans-unit>
        <trans-unit id="5d57f2f84b3ffe6a5b6f65ea9aed650138de72a5" translate="yes" xml:space="preserve">
          <source>Global variables are bad, so this solution uses a locally scoped variable which causes no harm.  It is only accessible within the function.</source>
          <target state="translated">グローバル変数は良くないので、この解決策では害のないローカルにスコープされた変数を使用します。これは関数内でのみアクセス可能です。</target>
        </trans-unit>
        <trans-unit id="24ca8b33236bc0d0ef50e2dd43fb66e04162b483" translate="yes" xml:space="preserve">
          <source>Here is a complete example:</source>
          <target state="translated">ここに完全な例があります。</target>
        </trans-unit>
        <trans-unit id="a7f4dfdc3b0e4865ba4c2f88fa68113cce0ed915" translate="yes" xml:space="preserve">
          <source>Here, that little arrow &lt;code&gt;b =&amp;gt; [resultA, b]&lt;/code&gt; is the function that closes over &lt;code&gt;resultA&lt;/code&gt;, and passes an array of both results to the next step. Which uses parameter destructuring syntax to break it up in single variables again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで、小さな矢印&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b =&amp;gt; [resultA, b]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;resultA&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を閉じて&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、両方の結果の配列を次のステップに渡す&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、パラメータ分解構文を使用して、単一の変数に再度分割します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b545f5f84c287a347a609ffd6cd3f0acc3d440ef" translate="yes" xml:space="preserve">
          <source>How do I access previous promise results in a .then() chain</source>
          <target state="translated">.then()チェーンで以前のプロミスの結果にアクセスするには</target>
        </trans-unit>
        <trans-unit id="02900e741b676e32f46da3689f6188c4289e7586" translate="yes" xml:space="preserve">
          <source>However, if you want/need to be backwards-compatible you cannot use those without a transpiler. Both generator functions and async functions are supported by the current tooling, see for example the documentation of Babel on &lt;a href=&quot;http://babeljs.io/learn-es2015/#ecmascript-2015-features-generators&quot;&gt;generators&lt;/a&gt; and &lt;a href=&quot;http://babeljs.io/docs/plugins/syntax-async-functions&quot;&gt;async functions&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、下位互換性を維持する必要がある場合は、トランスパイラーなしでは使用できません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ジェネレーター関数と非同期関数の両方が現在のツールでサポートされてい&lt;/font&gt;&lt;a href=&quot;http://babeljs.io/docs/plugins/syntax-async-functions&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://babeljs.io/learn-es2015/#ecmascript-2015-features-generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ジェネレーター&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非同期関数&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に関するBabelのドキュメントを参照してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d891f22fbf83c3adb5977c46bcbe5452c18a9d0d" translate="yes" xml:space="preserve">
          <source>I am not going to use this pattern in my own code since I'm not a big fan of using global variables. However, in a pinch it will work.</source>
          <target state="translated">私はグローバル変数を使うのがあまり好きではないので、このパターンを自分のコードで使うつもりはありません。しかし、ピンチの時にはうまくいくでしょう。</target>
        </trans-unit>
        <trans-unit id="68345dc8d3438db6294a505941bbc502c5478c3d" translate="yes" xml:space="preserve">
          <source>I have restructured my code to &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;promises&lt;/a&gt;, and built a wonderful long &lt;strong&gt;flat promise chain&lt;/strong&gt;, consisting of multiple &lt;code&gt;.then()&lt;/code&gt; callbacks. In the end I want to return some composite value, and need to access multiple &lt;strong&gt;intermediate promise results&lt;/strong&gt;. However the resolution values from the middle of the sequence are not in scope in the last callback, how do I access them?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私はに私のコードを再構築してきた&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;約束&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、そして素晴らしい長い建て&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フラット約束チェーンを&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;複数からなる、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コールバック。最後に、いくつかの複合値を返し、複数の&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中間Promise結果&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にアクセスする必要があり&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。ただし、シーケンスの中央からの解決値は、最後のコールバックのスコープ内にありません。それらにアクセスするにはどうすればよいですか？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="134d28e92e3dba4bc6b603007f8ab403b5304a73" translate="yes" xml:space="preserve">
          <source>I think you can use hash of RSVP.</source>
          <target state="translated">RSVPのハッシュは使えると思います。</target>
        </trans-unit>
        <trans-unit id="e39203fa696fcdd915ba3edc88b86f9842cb98fa" translate="yes" xml:space="preserve">
          <source>In cases I do need to reference a promises is when creation and resolution happen at independent/not-related places. So instead an artificial association and probably an event listener just to resolve the &quot;distant&quot; promise, I prefer to expose the promise as a Deferred, which the following code implements it in valid es5</source>
          <target state="translated">私がプロミスを参照する必要がある場合は、作成と解決が独立した関係のない場所で行われる場合です。そのため、人工的なアソシエーションや、おそらく &quot;遠い &quot;プロミスを解決するためのイベントリスナーの代わりに、私はプロミスをDeferredとして公開することを好んでいます。</target>
        </trans-unit>
        <trans-unit id="24d5ca2482aca47f7ad53f979d066f321ca7b78a" translate="yes" xml:space="preserve">
          <source>In theory, you can always avoid more than two levels of nesting (by making all closures explicit), in practise use as many as are reasonable.</source>
          <target state="translated">理論的には、(すべてのクロージャを明示的にすることで)常に2つ以上のレベルの入れ子を避けることができますが、実際には合理的な数だけ使用します。</target>
        </trans-unit>
        <trans-unit id="d3bf1dc059b68a3d8ddb78e7995e2ab7c5c7d020" translate="yes" xml:space="preserve">
          <source>Instead of many variables one might also use an (initially empty) object, on which the results are stored as dynamically created properties.</source>
          <target state="translated">多くの変数の代わりに、(最初は空の)オブジェクトを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="8f9b6a3354ddc0bb248f6e94d258722ec015fcb3" translate="yes" xml:space="preserve">
          <source>Instead of the parameter destructuring in the callback after &lt;code&gt;Promise.all&lt;/code&gt; that only became avail&amp;shy;able with ES6, in ES5 the &lt;code&gt;then&lt;/code&gt; call would be replaced by a nifty helper method that was provided by many promise libraries (&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;Q&lt;/a&gt;, &lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;Bluebird&lt;/a&gt;, &lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;when&lt;/a&gt;, &amp;hellip;): &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES6でのみ使用可能になっ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;た&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Promise.all&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;後のコールバックでのパラメーターの構造化の代わりに、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES5では、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;then&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;呼び出しは多くのpromiseライブラリ（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Q&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bluebird&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いつ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&amp;hellip;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;によって提供される気の利いたヘルパーメソッドに置き換えられ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d951045f06a6f96d2459f58d21879f6988c4a16" translate="yes" xml:space="preserve">
          <source>Intermediate promises are not prevented from accessing the state of the results object, but this does not introduce some scary scenario where one of the promises in the chain will go rogue and sabotage your results.  The responsibility of setting the values in each step of the promise is confined to this function and the overall result will either be correct or incorrect...it will not be some bug that will crop up years later in production (unless you intend it to!)</source>
          <target state="translated">中間プロミスは結果オブジェクトの状態にアクセスすることを妨げられませんが、これはチェーン内のプロミスの1つが悪党になって結果を妨害するような恐ろしいシナリオを導入するものではありません。プロミスの各ステップで値を設定する責任はこの関数に限定されており、全体的な結果は正しいか正しくないかのどちらかになります。</target>
        </trans-unit>
        <trans-unit id="012957063b5658b4b53260c2fa3837d67c7176c3" translate="yes" xml:space="preserve">
          <source>Mutable contextual state</source>
          <target state="translated">変異可能な文脈状態</target>
        </trans-unit>
        <trans-unit id="a7d298a254d44b48b6337a699fa090dd4e71111a" translate="yes" xml:space="preserve">
          <source>Mutable state is ugly, but this does not mutate state in an ugly manner.  The ugly mutable state traditionally refers to modifying the state of function arguments or global variables, but this approach simply modifies the state of a locally scoped variable that exists for the sole purpose of aggregating promise results...a variable that will die a simple death once the promise resolves.</source>
          <target state="translated">変異可能な状態は醜いですが、これは醜い方法で状態を変異させるものではありません。醜い変異可能な状態とは、伝統的に関数引数やグローバル変数の状態を変更することを指しますが、このアプローチは単に、約束の結果を集約することだけを目的として存在するローカルにスコープされた変数の状態を変更するだけです。</target>
        </trans-unit>
        <trans-unit id="e8449a4b6842da8a1dba6281ce394242d5e45321" translate="yes" xml:space="preserve">
          <source>Nesting (and) closures</source>
          <target state="translated">ネスティング(および)クロージャ</target>
        </trans-unit>
        <trans-unit id="c40ee383e2e4ca5e287bcee0f67b57f30dfbadf6" translate="yes" xml:space="preserve">
          <source>Node 7.4 now supports async/await calls with the harmony flag.</source>
          <target state="translated">Node 7.4 は harmony フラグを使った asyncawait 呼び出しをサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="412034bba97d4a4ab3e0a443ec0f5a846d142e98" translate="yes" xml:space="preserve">
          <source>Of course, that closure needed here can be further simplified by some helper functions, e.g.</source>
          <target state="translated">もちろん、ここで必要とされるクロージャは、ヘルパー関数、例えば</target>
        </trans-unit>
        <trans-unit id="aae9058adf8a1b510c202b122b2328aaf3580d28" translate="yes" xml:space="preserve">
          <source>Of course, this is building an indentation pyramid. If indentation is getting too large, you still can apply the old tools to counter the &lt;a href=&quot;http://callbackhell.com/&quot;&gt;pyramid of doom&lt;/a&gt;: modularize, use extra named functions, and flatten the promise chain as soon as you don't need a variable any more.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、これはインデントピラミッドを構築しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデントが大きくなりすぎても、古いツールを適用して&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://callbackhell.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、運命&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ピラミッド&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に対抗できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。モジュール化し、追加の名前付き関数を使用し、変数が不要になったらすぐにプロミスチェーンをフラット化します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10a3c56a26dc06509d2fd474a39da19d101d6694" translate="yes" xml:space="preserve">
          <source>Of course, this problem was recognized by the language designers as well. They did a lot of work and the &lt;a href=&quot;http://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async functions proposal&lt;/a&gt; finally made it into</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、この問題は言語設計者にも認識されています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;彼らは多くの仕事をし、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://tc39.github.io/ecmascript-asyncawait/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非同期関数の提案は&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ついにそれを作りました&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dff95b253f71a37696b949a20c5ca47263763ec1" translate="yes" xml:space="preserve">
          <source>One must choose the scope for those shared variables correctly. It needs to be local to the executed function to prevent race conditions between multiple parallel invocations, as would be the case if, for example, state was stored on an instance.</source>
          <target state="translated">これらの共有変数のスコープを正しく選択しなければなりません。例えば、インスタンスに状態が格納されている場合のように、複数回の並列呼び出しの間の競合を防ぐために、実行される関数のローカルなものである必要があります。</target>
        </trans-unit>
        <trans-unit id="c1f929f8e70b71568c730fcf1ca04cc7fd34b3af" translate="yes" xml:space="preserve">
          <source>Similar to nesting the callbacks, this technique relies on closures. Yet, the chain stays flat - instead of passing only the latest result, some state object is passed for every step. These state objects accumulate the results of the previous actions, handing down all values that will be needed later again plus the result of the current task.</source>
          <target state="translated">コールバックのネストと同様に、このテクニックはクロージャに依存しています。しかし、チェーンはフラットなままで、最新の結果だけを渡すのではなく、ステップごとにステートオブジェクトが渡されます。これらのステートオブジェクトは前のアクションの結果を蓄積し、後で再び必要となるすべての値と現在のタスクの結果を渡します。</target>
        </trans-unit>
        <trans-unit id="6aafb455fdb78b42aaa8e751fa4281daec51a6e7" translate="yes" xml:space="preserve">
          <source>Simple as can be!</source>
          <target state="translated">シンプルなんだよ!</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="740ffbb9952d0db97b17599b914cae9f45ab58ec" translate="yes" xml:space="preserve">
          <source>Something like as below :</source>
          <target state="translated">以下のようなものです。</target>
        </trans-unit>
        <trans-unit id="9d4e83066087dd1079c656c148313dafa0d0a48a" translate="yes" xml:space="preserve">
          <source>Synchronous inspection</source>
          <target state="translated">同期検査</target>
        </trans-unit>
        <trans-unit id="7552eee459001ff5a9e0fbf19a139de19a6e647d" translate="yes" xml:space="preserve">
          <source>The Bluebird library encourages the use of an object that is passed along, using &lt;a href=&quot;http://bluebirdjs.com/docs/api/bind.html&quot;&gt;their &lt;code&gt;bind()&lt;/code&gt; method&lt;/a&gt; to assign a context object to a promise chain. It will be accessible from each callback function via the otherwise unusable &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;&lt;code&gt;this&lt;/code&gt; keyword&lt;/a&gt;. While object properties are more prone to undetected typos than variables, the pattern is quite clever:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブルーバードライブラリを使用して、渡されたオブジェクトの使用奨励&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/bind.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その&lt;/font&gt;&lt;/font&gt; &lt;code&gt;bind()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドを&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;約束鎖にコンテキストオブジェクトを割り当てることを。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それ以外の場合は使用できない&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;キーワードを&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;介して、各コールバック関数からアクセスできます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクトのプロパティは変数よりも検出されないタイプミスの傾向がありますが、パターンは非常に巧妙です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9da2cb01b9445e3b82cef2fa35434f5be10a373b" translate="yes" xml:space="preserve">
          <source>The scope of the variables does not prevent to access them before they are initialized. This is especially likely for complex promise constructions (loops, branching, excptions) where race conditions might happen. Passing state explicitly, a &lt;a href=&quot;http://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;declarative design&lt;/a&gt; that promises encourage, forces a cleaner coding style which can prevent this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;変数のスコープは、初期化される前に変数にアクセスすることを妨げません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、競合状態が発生する可能性のある複雑なプロミス構造（ループ、分岐、例外）で特に発生しやすくなります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;状態を明示的に渡すと、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;励ましを約束&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;宣言型の設計&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;により、これを防ぐことができるよりクリーンなコーディングスタイルが強制されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef9dea0231e47298d8f39b636223237575303e9c" translate="yes" xml:space="preserve">
          <source>The trivial (but inelegant and rather errorprone) solution is to just use higher-scope variables (to which all callbacks in the chain have access) and write result values to them when you get them:</source>
          <target state="translated">つまらない (しかし、非効率でエラーが発生しやすい)解決策は、より高いスコープの変数 (チェーン内のすべてのコールバックがアクセスできる変数)を使用して、結果の値を取得したときにその変数に書き込むことです。</target>
        </trans-unit>
        <trans-unit id="03ebf8b9502bb380b80a7eb42cece7ab3209b46b" translate="yes" xml:space="preserve">
          <source>Then, run &lt;code&gt;babel-node example.js&lt;/code&gt; and voila!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次に、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;babel-node example.js&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とvoilaを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実行し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab34eafdad2b4ee95e473c31dd3db173f98501d2" translate="yes" xml:space="preserve">
          <source>There are dedicated libraries (like &lt;a href=&quot;https://github.com/tj/co&quot;&gt;co&lt;/a&gt; or &lt;a href=&quot;http://taskjs.org/&quot;&gt;task.js&lt;/a&gt;), but also many promise libraries have helper functions (&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#generators&quot;&gt;Q&lt;/a&gt;, &lt;a href=&quot;http://bluebirdjs.com/docs/api/generators.html&quot;&gt;Bluebird&lt;/a&gt;, &lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#es6-generators&quot;&gt;when&lt;/a&gt;, &amp;hellip;) that do &lt;a href=&quot;https://stackoverflow.com/a/23554399/1048572&quot;&gt;this async step-by-step execution&lt;/a&gt; for you when you give them a generator function that yields promises.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;専用ライブラリ（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/tj/co&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;co&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;や&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://taskjs.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;task.jsなど&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）がありますが、多くのpromiseライブラリにはヘルパー関数（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Q&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/generators.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bluebird&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#es6-generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;when&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&amp;hellip;）があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ジェネレーター関数を与えると、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/23554399/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この非同期の段階的な実行が行わ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;れます。約束をもたらす。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8a230a40501497f4bfe4e1796388f0ed6d16b20" translate="yes" xml:space="preserve">
          <source>This approach can be easily simulated in promise libraries that do not support .bind (although in a somewhat more verbose way and cannot be used in an expression):</source>
          <target state="translated">このアプローチは、.bindをサポートしていないプロミスライブラリで簡単にシミュレートすることができます(多少冗長な方法ではありますが、式の中では使用できません)。</target>
        </trans-unit>
        <trans-unit id="144ef4fefc003675e5f3e9aa894c364f1a909c60" translate="yes" xml:space="preserve">
          <source>This can be used for as many values as you like:</source>
          <target state="translated">これは、何度でも値を指定することができます。</target>
        </trans-unit>
        <trans-unit id="c73428b0fed4a12cd913cd5733b9a56cd877068d" translate="yes" xml:space="preserve">
          <source>This days, I also hava meet some questions like you. At last, I find a good solution with the quesition, it's simple and good to read. I hope this can help you.</source>
          <target state="translated">この頃、私はまた、あなたのようないくつかの質問に出会いました。最後に、私はquesitionとの良い解決策を見つけました、それは簡単で、読んで良いです。私はこれが助けることができることを望みます。</target>
        </trans-unit>
        <trans-unit id="acfafaf8cb92b754b040f10b093a0b4d1cefb53f" translate="yes" xml:space="preserve">
          <source>This did work in Node.js since version 4.0, also a few browsers (or their dev editions) did support generator syntax relatively early.</source>
          <target state="translated">これはNode.jsのバージョン4.0以降では動作していましたが、いくつかのブラウザ(またはその開発版)では比較的早い時期にジェネレータの構文をサポートしていました。</target>
        </trans-unit>
        <trans-unit id="9985024202145ce805f87cbe5538067d97b19841" translate="yes" xml:space="preserve">
          <source>This does not introduce a race condition scenario that would arise from parallel invocation because a new instance of the results variable is created for every invocation of the getExample function.</source>
          <target state="translated">これにより、getExample関数を呼び出すたびに結果変数の新しいインスタンスが生成されるため、並列呼び出しで発生するような競合状態のシナリオが発生しません。</target>
        </trans-unit>
        <trans-unit id="46c1b4574441bc055943b5b04c15465abdec3bff" translate="yes" xml:space="preserve">
          <source>This pattern doesn't work across function boundaries, modularising the functions is harder as their declarations must not leave the shared scope</source>
          <target state="translated">このパターンは関数の境界を越えては動作しないので、関数のモジュール化は難しくなります。</target>
        </trans-unit>
        <trans-unit id="e5580ff94ef22be48cff7200bd303fbf66ceabd3" translate="yes" xml:space="preserve">
          <source>This solution can be invoked as follows:</source>
          <target state="translated">この解決策は、次のようにして呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="e43a3e4618b96cad7d4ab03f023073c45d9f6bd6" translate="yes" xml:space="preserve">
          <source>This solution has several drawbacks:</source>
          <target state="translated">この解決策にはいくつかの欠点があります。</target>
        </trans-unit>
        <trans-unit id="da3dd2f8f239743397e37a9839f3048b1aa2620f" translate="yes" xml:space="preserve">
          <source>This will result in a very straightforward control flow, clear composition of functionalities and therefore easy modularisation.</source>
          <target state="translated">これにより、制御フローが非常にわかりやすくなり、機能の構成が明確になるため、モジュール化が容易になります。</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">これを試してみてください。</target>
        </trans-unit>
        <trans-unit id="2057318d110eca92034720c6472bfc3e1bd381c0" translate="yes" xml:space="preserve">
          <source>Update: added working example</source>
          <target state="translated">更新:作業例の追加</target>
        </trans-unit>
        <trans-unit id="e944e3513336c73f5a43135573f6d4fe61b114c7" translate="yes" xml:space="preserve">
          <source>User is a promisified Mongoose model.</source>
          <target state="translated">ユーザーはプロミスされたMongooseモデルです。</target>
        </trans-unit>
        <trans-unit id="03057780495560c1cec710f98e709cc23defb382" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;async - await&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &lt;code&gt;async - await&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-待機&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eee874fe8aaa9db187a682e750fc3f3d02aa63e8" translate="yes" xml:space="preserve">
          <source>Using a locally scoped object to collect the intermediate results in a promise chain is a reasonable approach to the question you posed. Consider the following snippet:</source>
          <target state="translated">プロミスチェーンの中間結果を収集するためにローカルスコープされたオブジェクトを使用することは、あなたが提起した質問に対する合理的なアプローチです。次のスニペットを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="223bff812bcb6fe8adc3710c5c73399c9f4fc29b" translate="yes" xml:space="preserve">
          <source>Using closures for maintaining the scope of variables (in our case, the success callback function parameters) is the natural JavaScript solution. With promises, we can arbitrarily &lt;a href=&quot;https://stackoverflow.com/a/22000931/1048572&quot;&gt;nest and flatten&lt;/a&gt;&lt;code&gt;.then()&lt;/code&gt; callbacks - they are semantically equivalent, except for the scope of the inner one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;変数のスコープ（この場合、成功コールバック関数のパラメーター）を維持するためにクロージャーを使用することは、自然なJavaScriptソリューションです。&lt;/font&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/22000931/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用すると、&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.then（）&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コールバックを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任意に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ネストおよびフラット化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。これらは、内部のスコープを除いて、意味的には同等です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63a90d8bcee39e3e934d7225c50fb780b32e01d5" translate="yes" xml:space="preserve">
          <source>What I learn about promises is to use it only as return values &lt;strong&gt;avoid referencing them&lt;/strong&gt; if possible. async/await syntax is particularly practical for that. Today all latest browsers and node support it: &lt;a href=&quot;https://caniuse.com/#feat=async-functions&quot;&gt;https://caniuse.com/#feat=async-functions&lt;/a&gt; , is a simple behavior and the code is like reading synchronous code, forget about callbacks...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私がプロミスについて知っていることは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、可能であれば&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それらを参照することを避け&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、戻り値としてのみそれを使用する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのためには、非同期/待機構文が特に実用的です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;今日、すべての最新のブラウザーとノードがそれをサポートしています：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://caniuse.com/#feat=async-functions&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//caniuse.com/#feat=async-functions&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は単純な動作で、コードは同期コードを読み取るようなもので、コールバックを忘れます...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8bfce48cbd196a61b1b247b32e5d1c51102f28ea" translate="yes" xml:space="preserve">
          <source>When using bluebird, you can use &lt;code&gt;.bind&lt;/code&gt; method to share variables in promise chain:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bluebirdを使用する場合、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.bind&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;してpromiseチェーンで変数を共有&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0aee9dff13129530d7d2bee00bb7f9b72fa1522" translate="yes" xml:space="preserve">
          <source>When you need to access the intermediate values in your chain, you should split your chain apart in those single pieces that you need. Instead of attaching one callback and somehow trying to use its parameter multiple times, attach multiple callbacks to the same promise - wherever you need the result value. Don't forget, a &lt;a href=&quot;https://stackoverflow.com/a/22540276/1048572&quot;&gt;promise just represents (proxies) a future value&lt;/a&gt;! Next to deriving one promise from the other in a linear chain, use the promise combinators that are given to you by your library to build the result value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;チェーンの中間値にアクセスする必要がある場合は、チェーンを必要な単一のピースに分割する必要があります。 1つのコールバックをアタッチし、どういうわけかそのパラメーターを複数回使用しようとする代わりに、複数のコールバックを同じプロミス（結果の値が必要な場所）にアタッチします。忘れないでください。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/22540276/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;約束は未来の価値（プロキシ）を表すだけです&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;！線形チェーンで1つのプロミスを別のプロミスから導出することの次に、ライブラリから提供されるプロミスコンビネーターを使用して、結果の値を構築します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4f21d072723ef8937089cfff3fff2bd8c2ed4b3" translate="yes" xml:space="preserve">
          <source>While this pattern guarantees a flat chain and explicit state objects can improve clarity, it will become tedious for a long chain. Especially when you need the state only sporadically, you still have to pass it through every step. With this fixed interface, the single callbacks in the chain are rather tightly coupled and inflexible to change. It makes factoring out single steps harder, and callbacks cannot be supplied directly from other modules - they always need to be wrapped in boilerplate code that cares about the state. Abstract helper functions like the above can ease the pain a bit, but it will always be present.</source>
          <target state="translated">このパターンはフラットチェーンを保証し、明示的なステートオブジェクトは明快さを向上させることができますが、長いチェーンの場合は面倒になります。特に、状態が散発的にしか必要としない場合には、それでもすべてのステップで状態を渡さなければなりません。この固定インターフェースでは、チェーン内の単一のコールバックは、むしろ緊密に結合されており、変更に柔軟性がありません。また、コールバックは他のモジュールから直接供給することができず、常に状態を気にする定型的なコードでラップする必要があります。上記のような抽象的なヘルパー関数を使えば、少しは痛みを和らげることができますが、それは常に存在することになります。</target>
        </trans-unit>
        <trans-unit id="1b9eacffa6333b9b56f47e8a6b4d99a89cd316d9" translate="yes" xml:space="preserve">
          <source>While we were waiting for ES8, we already did use a very similar kind of syntax. ES6 came with &lt;a href=&quot;http://davidwalsh.name/es6-generators&quot;&gt;generator functions&lt;/a&gt;, which allow to break the execution apart in pieces at arbitrarily placed &lt;code&gt;yield&lt;/code&gt; keywords. Those slices can be run after each other, independently, even asynchronously - and that's just what we do when we want to wait for a promise resolution before running the next step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES8を待っている間、すでに非常によく似た種類の構文を使用していました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES6には&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://davidwalsh.name/es6-generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ジェネレータ関数&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が付属し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ており、任意に配置された&lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;キーワード&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で実行をバラバラに分解でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これらのスライスは、独立して、非同期でも、お互いに順番に実行できます。これは、次のステップを実行する前にpromiseの解決を待機したい場合に実行します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d663118fbfd1bf9fa6e25101948dd5f5db080d28" translate="yes" xml:space="preserve">
          <source>You can also use helper functions for this kind of &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;partial application&lt;/a&gt;, like &lt;code&gt;_.partial&lt;/code&gt; from &lt;a href=&quot;http://underscorejs.org/#partial&quot;&gt;Underscore&lt;/a&gt;/&lt;a href=&quot;https://lodash.com/docs#partial&quot;&gt;lodash&lt;/a&gt; or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;native &lt;code&gt;.bind()&lt;/code&gt; method&lt;/a&gt;, to further decrease indentation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、この種のヘルパー関数を使用することができ&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、部分的アプリケーション&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のように、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;_.partial&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://underscorejs.org/#partial&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アンダー&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; / &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://lodash.com/docs#partial&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lodash&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ネイティブ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.bind()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッド&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はさらに減少のインデントに、：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="504ef302e3dad1d0b3f2452e253c7576fe3cfd47" translate="yes" xml:space="preserve">
          <source>You can put intermediate values in scope in any later 'then' function explicitly, by using 'bind'. It is a nice solution that doesn't require changing how Promises work, and only requires a line or two of code to propagate the values just like errors are already propagated.</source>
          <target state="translated">bind' を使用することで、後の 'then' 関数で明示的に中間値をスコープに入れることができます。これは、Promise の仕組みを変更する必要がなく、エラーが既に伝播されているのと同じように値を伝播させるためのコードを一行か二行必要とするだけで済む、素晴らしい解決策です。</target>
        </trans-unit>
        <trans-unit id="e100ea30d9c7be0d59c6c2207e286e7716ba132e" translate="yes" xml:space="preserve">
          <source>You don't need a single &lt;code&gt;then&lt;/code&gt; invocation or callback function any more, as in an asynchronous function (that returns a promise when being called) you can simply wait for promises to resolve directly. It also features arbitrary control structures like conditions, loops and try-catch-clauses, but for the sake of convenience we don't need them here:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;呼び出されたときにプロミスを返す非同期関数のように、プロミスが直接解決されるのを待つだけで&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;よいので、単一の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;then&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;呼び出しやコールバック関数はもう&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要ありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、条件、ループ、try-catch-clausesなどの任意の制御構造も備えていますが、便宜上、ここでは必要ありません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d87de37b1d789f1d1fe1124c674c1df85f72fe40" translate="yes" xml:space="preserve">
          <source>and run the file with:</source>
          <target state="translated">でファイルを実行します。</target>
        </trans-unit>
        <trans-unit id="48d22e4b889c8e81b57a132d3e6fa7ddb0ede8f6" translate="yes" xml:space="preserve">
          <source>easy way :D</source>
          <target state="translated">易しい方法 :D</target>
        </trans-unit>
        <trans-unit id="969d4c74db0b220c26ebcbab6fb30ae35bd28194" translate="yes" xml:space="preserve">
          <source>ok, let's look at the code:</source>
          <target state="translated">よし、コードを見てみよう。</target>
        </trans-unit>
        <trans-unit id="ca09a36d45885d74388e59c155d88008b4a03340" translate="yes" xml:space="preserve">
          <source>please check this link for further information:</source>
          <target state="translated">詳細はこちらのリンクをご確認ください。</target>
        </trans-unit>
        <trans-unit id="a5222aa7ce87a66abef69219caaf401b2c3230a9" translate="yes" xml:space="preserve">
          <source>transpiled form a typescript project of mine:</source>
          <target state="translated">私のタイプスクリプトプロジェクトをトランスパイルしたものです。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
