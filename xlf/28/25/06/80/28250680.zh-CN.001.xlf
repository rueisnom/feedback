<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/28250680">
    <body>
      <group id="28250680">
        <trans-unit id="886001de61d616fd7504793554e90b0ead0d7946" translate="yes" xml:space="preserve">
          <source>(Note: a more complex and complete version of this solution has been tested, but not this example version, so it could have a bug.)</source>
          <target state="translated">(注:本方案的一个更复杂、更完整的版本已经测试过了,但不是这个示例版本,所以可能会有bug)。</target>
        </trans-unit>
        <trans-unit id="8c36a0c010728fc244e1f43aab8c1da795455c65" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/q/844536/1048572&quot;&gt;Mutable state is ugly&lt;/a&gt;, and &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil&quot;&gt;global variables are evil&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/844536/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可变状态是丑陋的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;全局变量是邪恶的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="446787ac4bf8edd63cd98d9810d37f90a8ce33c1" translate="yes" xml:space="preserve">
          <source>A less harsh spin on &quot;Mutable contextual state&quot;</source>
          <target state="translated">对 &quot;Mutable contextual state &quot;不那么刻薄了</target>
        </trans-unit>
        <trans-unit id="61650d4ab35176fac8853a022c21d3f429ac0a74" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;https://html5hive.org/how-to-chain-javascript-promises/&quot;&gt;how-to-chain-javascript-promises&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://html5hive.org/how-to-chain-javascript-promises/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如何链接javascript-promises&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb4e646963a08495dd8a836cba56eac6efaa78a1" translate="yes" xml:space="preserve">
          <source>Alternatively, you can employ &lt;code&gt;Promise.all&lt;/code&gt; to produce the promise for the array:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或者，您可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为数组生成promise：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94665e6ad2dc97bb0515d1739a70f85937dae7b8" translate="yes" xml:space="preserve">
          <source>And then, there are also many other &lt;a href=&quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS#synchronous-to-asynchronous-javascript-compilers-cps&quot;&gt;compile-to-JS languages&lt;/a&gt;
that are dedicated to easing asynchronous programming. They usually use a syntax similar to &lt;code&gt;await&lt;/code&gt;, (e.g. &lt;a href=&quot;http://maxtaco.github.io/coffee-script/&quot;&gt;Iced CoffeeScript&lt;/a&gt;), but there are also others that feature a Haskell-like &lt;code&gt;do&lt;/code&gt;-notation (e.g. &lt;a href=&quot;http://lattejs.com/&quot;&gt;LatteJs&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/monadic&quot;&gt;monadic&lt;/a&gt;, &lt;a href=&quot;http://www.purescript.org/&quot;&gt;PureScript&lt;/a&gt; or &lt;a href=&quot;http://lispyscript.com/&quot;&gt;LispyScript&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，还有许多其他&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 专门用于简化异步编程的可&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS#synchronous-to-asynchronous-javascript-compilers-cps&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译为JS的语言&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他们通常使用类似语法&lt;/font&gt;&lt;/font&gt; &lt;code&gt;await&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（例如&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://maxtaco.github.io/coffee-script/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;冰的CoffeeScript&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），但也有其他人配备了哈斯克尔样&lt;/font&gt;&lt;/font&gt; &lt;code&gt;do&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -notation（如&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://lattejs.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LatteJs&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.npmjs.com/package/monadic&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一元&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.purescript.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PureScript&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://lispyscript.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LispyScript&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b117394e70cda9ad8f1592c22985ada9cd1467db" translate="yes" xml:space="preserve">
          <source>And you might not only use arrays, but arbitrarily complex objects. For example, with &lt;a href=&quot;http://underscorejs.org/#extend&quot;&gt;&lt;code&gt;_.extend&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign&lt;/code&gt;&lt;/a&gt; in a different helper function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且，您不仅可以使用数组，还可以使用任意复杂的对象。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://underscorejs.org/#extend&quot;&gt; &lt;code&gt;_.extend&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在另一个帮助器函数中：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6cd0e648be626f2f5734fc06177a48a905ba581d" translate="yes" xml:space="preserve">
          <source>Another answer, using &lt;code&gt;babel-node&lt;/code&gt; version &amp;lt;6</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一个答案，使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;babel-node&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;版本&amp;lt;6&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="917cd1d01022379cee10d9edbb40647574476354" translate="yes" xml:space="preserve">
          <source>Another answer, using sequential executor &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一个答案，使用顺序执行程序&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;nsynjs&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e8aab5e31173c31302ab6dcea021b1848ed8a3ee" translate="yes" xml:space="preserve">
          <source>Assigning promises-for-later-needed-values to variables and then getting their value via synchronous inspection. The example uses bluebird's &lt;code&gt;.value()&lt;/code&gt; method but many libraries provide similar method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为变量分配可满足的承诺值，然后通过同步检查获取其值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该示例使用bluebird的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.value()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法，但是许多库提供了类似的方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="050feb2cbdeb309a67b27f7cdff96683ad234fa3" translate="yes" xml:space="preserve">
          <source>Before destructuring became available with ES6, a nifty helper method called &lt;code&gt;.spread()&lt;/code&gt; was pro&amp;shy;vi&amp;shy;ded by many promise libraries (&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;Q&lt;/a&gt;, &lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;Bluebird&lt;/a&gt;, &lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;when&lt;/a&gt;, &amp;hellip;). It takes a function with multiple parameters - one for each array element - to be used as &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在ES6进行销毁之前&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，许多promise库（&lt;/font&gt;&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Q&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bluebird&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;when&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&amp;hellip;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供了&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一种名为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.spread()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的漂亮辅助方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它需要一个具有多个参数的函数-每个数组元素一个-用作&lt;/font&gt; &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1fbe958b0857725f5a84c804d4ae85da21ceb1d" translate="yes" xml:space="preserve">
          <source>Bluebird also features a dedicated &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.join.html&quot;&gt;&lt;code&gt;join&lt;/code&gt; function&lt;/a&gt; to replace that &lt;code&gt;Promise.all&lt;/code&gt;+&lt;code&gt;spread&lt;/code&gt; combination with a simpler (and more efficient) construct:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;蓝鸟还设有一个专门的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.join.html&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;功能&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，以取代&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; + &lt;/font&gt;&lt;/font&gt; &lt;code&gt;spread&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有更简单的（和更有效）构建组合：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="064bf726f394fe19c0ef56ee0e3f8168e8f3bf8c" translate="yes" xml:space="preserve">
          <source>Break the chain</source>
          <target state="translated">断链</target>
        </trans-unit>
        <trans-unit id="f446dfc8ca31cb54d0b1dae43079076f607503d6" translate="yes" xml:space="preserve">
          <source>ECMAScript 5</source>
          <target state="translated">ECMAScript 5</target>
        </trans-unit>
        <trans-unit id="b02b03612b472d412029a9017657b2e96f26db53" translate="yes" xml:space="preserve">
          <source>ECMAScript 6</source>
          <target state="translated">ECMAScript 6</target>
        </trans-unit>
        <trans-unit id="8eecaf932c06e6aadd977797e815790995527161" translate="yes" xml:space="preserve">
          <source>ECMAScript 8</source>
          <target state="translated">ECMAScript 8</target>
        </trans-unit>
        <trans-unit id="ec3cb3a8bb975f9d73ec9e15cd1211b669541cdd" translate="yes" xml:space="preserve">
          <source>ECMAScript Harmony</source>
          <target state="translated">ECMAScript Harmony</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="2568555d5b3660982a930ffff01c1764f5cb7a9c" translate="yes" xml:space="preserve">
          <source>Explicit pass-through</source>
          <target state="translated">明确传递</target>
        </trans-unit>
        <trans-unit id="66a027cb165ddbb392556662ee9b3307626866a1" translate="yes" xml:space="preserve">
          <source>For more complex cases I often use these guy small promise utilities without dependencies tested and typed. p-map has been useful several times. I think he covered most use cases:</source>
          <target state="translated">对于更复杂的案例,我经常使用这些家伙的小承诺实用程序,没有依赖性的测试和类型化。我认为他涵盖了大部分用例。</target>
        </trans-unit>
        <trans-unit id="5d57f2f84b3ffe6a5b6f65ea9aed650138de72a5" translate="yes" xml:space="preserve">
          <source>Global variables are bad, so this solution uses a locally scoped variable which causes no harm.  It is only accessible within the function.</source>
          <target state="translated">全局变量是不好的,所以这个方案使用了一个本地范围的变量,它不会造成伤害。它只能在函数内部访问。</target>
        </trans-unit>
        <trans-unit id="24ca8b33236bc0d0ef50e2dd43fb66e04162b483" translate="yes" xml:space="preserve">
          <source>Here is a complete example:</source>
          <target state="translated">下面是一个完整的例子。</target>
        </trans-unit>
        <trans-unit id="a7f4dfdc3b0e4865ba4c2f88fa68113cce0ed915" translate="yes" xml:space="preserve">
          <source>Here, that little arrow &lt;code&gt;b =&amp;gt; [resultA, b]&lt;/code&gt; is the function that closes over &lt;code&gt;resultA&lt;/code&gt;, and passes an array of both results to the next step. Which uses parameter destructuring syntax to break it up in single variables again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里，小箭头&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b =&amp;gt; [resultA, b]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是关闭&lt;/font&gt;&lt;/font&gt; &lt;code&gt;resultA&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的函数，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并将两个结果的数组传递到下一步。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它使用参数解构语法将其再次分解为单个变量。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b545f5f84c287a347a609ffd6cd3f0acc3d440ef" translate="yes" xml:space="preserve">
          <source>How do I access previous promise results in a .then() chain</source>
          <target state="translated">如何在.then()链中访问之前的承诺结果?</target>
        </trans-unit>
        <trans-unit id="02900e741b676e32f46da3689f6188c4289e7586" translate="yes" xml:space="preserve">
          <source>However, if you want/need to be backwards-compatible you cannot use those without a transpiler. Both generator functions and async functions are supported by the current tooling, see for example the documentation of Babel on &lt;a href=&quot;http://babeljs.io/learn-es2015/#ecmascript-2015-features-generators&quot;&gt;generators&lt;/a&gt; and &lt;a href=&quot;http://babeljs.io/docs/plugins/syntax-async-functions&quot;&gt;async functions&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果您希望/需要向后兼容，那么在没有编译器的情况下不能使用它们。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当前工具支持生成器功能和异步功能，例如，请参见Babel有关&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://babeljs.io/learn-es2015/#ecmascript-2015-features-generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;生成器&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://babeljs.io/docs/plugins/syntax-async-functions&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;异步功能&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的文档&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d891f22fbf83c3adb5977c46bcbe5452c18a9d0d" translate="yes" xml:space="preserve">
          <source>I am not going to use this pattern in my own code since I'm not a big fan of using global variables. However, in a pinch it will work.</source>
          <target state="translated">我不打算在自己的代码中使用这种模式,因为我不太喜欢使用全局变量。不过,在紧要关头,它还是可以用的。</target>
        </trans-unit>
        <trans-unit id="68345dc8d3438db6294a505941bbc502c5478c3d" translate="yes" xml:space="preserve">
          <source>I have restructured my code to &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;promises&lt;/a&gt;, and built a wonderful long &lt;strong&gt;flat promise chain&lt;/strong&gt;, consisting of multiple &lt;code&gt;.then()&lt;/code&gt; callbacks. In the end I want to return some composite value, and need to access multiple &lt;strong&gt;intermediate promise results&lt;/strong&gt;. However the resolution values from the middle of the sequence are not in scope in the last callback, how do I access them?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我已经将我的代码重组为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Promise&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并构建了一个精彩的，长而&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;平坦的Promise链&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，其中包括多个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;回调。最后，我想返回一些复合值，并且需要访问多个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中间promise结果&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。但是，序列中间的分辨率值不在上次回调的范围内，如何访问它们？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="134d28e92e3dba4bc6b603007f8ab403b5304a73" translate="yes" xml:space="preserve">
          <source>I think you can use hash of RSVP.</source>
          <target state="translated">我想你可以用哈希的RSVP。</target>
        </trans-unit>
        <trans-unit id="e39203fa696fcdd915ba3edc88b86f9842cb98fa" translate="yes" xml:space="preserve">
          <source>In cases I do need to reference a promises is when creation and resolution happen at independent/not-related places. So instead an artificial association and probably an event listener just to resolve the &quot;distant&quot; promise, I prefer to expose the promise as a Deferred, which the following code implements it in valid es5</source>
          <target state="translated">在我需要引用一个承诺的情况下,当创建和解析发生在独立的非相关的地方时,我需要引用一个承诺。因此,我更喜欢用一个人工关联和事件监听器来解决 &quot;遥远的 &quot;承诺,而不是用一个人为的关联和事件监听器来解决 &quot;遥远的 &quot;承诺,我更喜欢用一个Deferred来表达这个承诺,下面的代码在有效的es5中实现了这个承诺</target>
        </trans-unit>
        <trans-unit id="24d5ca2482aca47f7ad53f979d066f321ca7b78a" translate="yes" xml:space="preserve">
          <source>In theory, you can always avoid more than two levels of nesting (by making all closures explicit), in practise use as many as are reasonable.</source>
          <target state="translated">在理论上,你总是可以避免两层以上的嵌套(通过明确所有的闭合),在实际操作中,尽可能多地使用合理的嵌套。</target>
        </trans-unit>
        <trans-unit id="d3bf1dc059b68a3d8ddb78e7995e2ab7c5c7d020" translate="yes" xml:space="preserve">
          <source>Instead of many variables one might also use an (initially empty) object, on which the results are stored as dynamically created properties.</source>
          <target state="translated">也可以使用一个(最初是空的)对象来代替许多变量,结果作为动态创建的属性存储在上面。</target>
        </trans-unit>
        <trans-unit id="8f9b6a3354ddc0bb248f6e94d258722ec015fcb3" translate="yes" xml:space="preserve">
          <source>Instead of the parameter destructuring in the callback after &lt;code&gt;Promise.all&lt;/code&gt; that only became avail&amp;shy;able with ES6, in ES5 the &lt;code&gt;then&lt;/code&gt; call would be replaced by a nifty helper method that was provided by many promise libraries (&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;Q&lt;/a&gt;, &lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;Bluebird&lt;/a&gt;, &lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;when&lt;/a&gt;, &amp;hellip;): &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相反，在回调后的参数解构的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只有变得可用ES6，在ES5的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;then&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;呼叫将被通过，是由许多承诺库提供一个极好的辅助方法代替（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Q&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;蓝鸟&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，...） &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d951045f06a6f96d2459f58d21879f6988c4a16" translate="yes" xml:space="preserve">
          <source>Intermediate promises are not prevented from accessing the state of the results object, but this does not introduce some scary scenario where one of the promises in the chain will go rogue and sabotage your results.  The responsibility of setting the values in each step of the promise is confined to this function and the overall result will either be correct or incorrect...it will not be some bug that will crop up years later in production (unless you intend it to!)</source>
          <target state="translated">中间承诺不会被阻止访问结果对象的状态,但这并不会引入一些可怕的场景,即链中的某个承诺会叛变,破坏你的结果。在承诺的每一步中设置值的责任仅限于此函数,整体结果要么是正确的,要么是不正确的..........它不会是一些多年后在生产中出现的bug(除非你有意如此!)。</target>
        </trans-unit>
        <trans-unit id="012957063b5658b4b53260c2fa3837d67c7176c3" translate="yes" xml:space="preserve">
          <source>Mutable contextual state</source>
          <target state="translated">可变的上下文状态</target>
        </trans-unit>
        <trans-unit id="a7d298a254d44b48b6337a699fa090dd4e71111a" translate="yes" xml:space="preserve">
          <source>Mutable state is ugly, but this does not mutate state in an ugly manner.  The ugly mutable state traditionally refers to modifying the state of function arguments or global variables, but this approach simply modifies the state of a locally scoped variable that exists for the sole purpose of aggregating promise results...a variable that will die a simple death once the promise resolves.</source>
          <target state="translated">可变状态是丑陋的,但这并不是以丑陋的方式突变状态。丑陋的可突变状态传统上是指修改函数参数或全局变量的状态,但这种方式只是修改了一个局部范围内的变量的状态,而这个变量的存在仅仅是为了聚合承诺结果而存在的...........这个变量一旦承诺解析,就会简单的死亡。</target>
        </trans-unit>
        <trans-unit id="e8449a4b6842da8a1dba6281ce394242d5e45321" translate="yes" xml:space="preserve">
          <source>Nesting (and) closures</source>
          <target state="translated">嵌套(和)关闭</target>
        </trans-unit>
        <trans-unit id="c40ee383e2e4ca5e287bcee0f67b57f30dfbadf6" translate="yes" xml:space="preserve">
          <source>Node 7.4 now supports async/await calls with the harmony flag.</source>
          <target state="translated">Node 7.4现在支持带和谐标志的Asyncawait调用。</target>
        </trans-unit>
        <trans-unit id="412034bba97d4a4ab3e0a443ec0f5a846d142e98" translate="yes" xml:space="preserve">
          <source>Of course, that closure needed here can be further simplified by some helper functions, e.g.</source>
          <target state="translated">当然,这里所需要的闭合可以通过一些辅助函数进一步简化,比如说</target>
        </trans-unit>
        <trans-unit id="aae9058adf8a1b510c202b122b2328aaf3580d28" translate="yes" xml:space="preserve">
          <source>Of course, this is building an indentation pyramid. If indentation is getting too large, you still can apply the old tools to counter the &lt;a href=&quot;http://callbackhell.com/&quot;&gt;pyramid of doom&lt;/a&gt;: modularize, use extra named functions, and flatten the promise chain as soon as you don't need a variable any more.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，这是在构建压痕金字塔。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果缩进变得太大，您仍然可以使用旧工具来反击&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://callbackhell.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;厄运&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;金字塔&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：模块化，使用额外的命名函数以及在不再需要变量时立即平整承诺链。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10a3c56a26dc06509d2fd474a39da19d101d6694" translate="yes" xml:space="preserve">
          <source>Of course, this problem was recognized by the language designers as well. They did a lot of work and the &lt;a href=&quot;http://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async functions proposal&lt;/a&gt; finally made it into</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，语言设计者也意识到了这个问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他们做了很多工作，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://tc39.github.io/ecmascript-asyncawait/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;异步函数提案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最终使它成为了&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dff95b253f71a37696b949a20c5ca47263763ec1" translate="yes" xml:space="preserve">
          <source>One must choose the scope for those shared variables correctly. It needs to be local to the executed function to prevent race conditions between multiple parallel invocations, as would be the case if, for example, state was stored on an instance.</source>
          <target state="translated">必须正确选择这些共享变量的作用域。它需要在执行的函数中是本地的,以防止多次并行调用之间的竞赛情况,例如,如果状态存储在一个实例上,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="c1f929f8e70b71568c730fcf1ca04cc7fd34b3af" translate="yes" xml:space="preserve">
          <source>Similar to nesting the callbacks, this technique relies on closures. Yet, the chain stays flat - instead of passing only the latest result, some state object is passed for every step. These state objects accumulate the results of the previous actions, handing down all values that will be needed later again plus the result of the current task.</source>
          <target state="translated">与嵌套回调类似,这种技术依赖于闭包。然而,该链保持平坦的状态--不是只传递最新的结果,而是每一步都传递一些状态对象。这些状态对象积累了前一个动作的结果,将所有稍后需要的值再加上当前任务的结果传递下去。</target>
        </trans-unit>
        <trans-unit id="6aafb455fdb78b42aaa8e751fa4281daec51a6e7" translate="yes" xml:space="preserve">
          <source>Simple as can be!</source>
          <target state="translated">简单得很!</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="740ffbb9952d0db97b17599b914cae9f45ab58ec" translate="yes" xml:space="preserve">
          <source>Something like as below :</source>
          <target state="translated">像下面这样的东西。</target>
        </trans-unit>
        <trans-unit id="9d4e83066087dd1079c656c148313dafa0d0a48a" translate="yes" xml:space="preserve">
          <source>Synchronous inspection</source>
          <target state="translated">同步检查</target>
        </trans-unit>
        <trans-unit id="7552eee459001ff5a9e0fbf19a139de19a6e647d" translate="yes" xml:space="preserve">
          <source>The Bluebird library encourages the use of an object that is passed along, using &lt;a href=&quot;http://bluebirdjs.com/docs/api/bind.html&quot;&gt;their &lt;code&gt;bind()&lt;/code&gt; method&lt;/a&gt; to assign a context object to a promise chain. It will be accessible from each callback function via the otherwise unusable &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;&lt;code&gt;this&lt;/code&gt; keyword&lt;/a&gt;. While object properties are more prone to undetected typos than variables, the pattern is quite clever:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;蓝鸟库鼓励使用传递的对象，并使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/bind.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其&lt;/font&gt;&lt;/font&gt; &lt;code&gt;bind()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将上下文对象分配给承诺链。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个回调函数都可以通过否则无法使用的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字进行访问&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尽管对象属性比变量更容易出现错别字，但这种模式非常聪明：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9da2cb01b9445e3b82cef2fa35434f5be10a373b" translate="yes" xml:space="preserve">
          <source>The scope of the variables does not prevent to access them before they are initialized. This is especially likely for complex promise constructions (loops, branching, excptions) where race conditions might happen. Passing state explicitly, a &lt;a href=&quot;http://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;declarative design&lt;/a&gt; that promises encourage, forces a cleaner coding style which can prevent this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量的范围不会阻止对其进行初始化之前对其的访问。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这对于可能发生竞争条件的复杂的承诺构造（循环，分支，排他）尤其可能。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显式地通过状态，一个&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;承诺鼓励&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;声明性设计&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;迫使采用一种更干净的编码样式，可以防止这种情况的发生。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef9dea0231e47298d8f39b636223237575303e9c" translate="yes" xml:space="preserve">
          <source>The trivial (but inelegant and rather errorprone) solution is to just use higher-scope variables (to which all callbacks in the chain have access) and write result values to them when you get them:</source>
          <target state="translated">最简单的方法(但很不容易出错)就是使用更高的范围变量(链中所有的回调都可以访问),并在得到结果值时将结果值写到它们。</target>
        </trans-unit>
        <trans-unit id="03ebf8b9502bb380b80a7eb42cece7ab3209b46b" translate="yes" xml:space="preserve">
          <source>Then, run &lt;code&gt;babel-node example.js&lt;/code&gt; and voila!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，运行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;babel-node example.js&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，瞧！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab34eafdad2b4ee95e473c31dd3db173f98501d2" translate="yes" xml:space="preserve">
          <source>There are dedicated libraries (like &lt;a href=&quot;https://github.com/tj/co&quot;&gt;co&lt;/a&gt; or &lt;a href=&quot;http://taskjs.org/&quot;&gt;task.js&lt;/a&gt;), but also many promise libraries have helper functions (&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#generators&quot;&gt;Q&lt;/a&gt;, &lt;a href=&quot;http://bluebirdjs.com/docs/api/generators.html&quot;&gt;Bluebird&lt;/a&gt;, &lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#es6-generators&quot;&gt;when&lt;/a&gt;, &amp;hellip;) that do &lt;a href=&quot;https://stackoverflow.com/a/23554399/1048572&quot;&gt;this async step-by-step execution&lt;/a&gt; for you when you give them a generator function that yields promises.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有专用的库（例如&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/tj/co&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;co&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://taskjs.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;task.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），但是还有许多&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Promise&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;库具有辅助函数（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Q&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/generators.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bluebird&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#es6-generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;when&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;hellip;），&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您为它们提供生成器函数时，它们会为您&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/23554399/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;执行异步逐步执行&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;产生希望。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8a230a40501497f4bfe4e1796388f0ed6d16b20" translate="yes" xml:space="preserve">
          <source>This approach can be easily simulated in promise libraries that do not support .bind (although in a somewhat more verbose way and cannot be used in an expression):</source>
          <target state="translated">这种方法可以很容易地在不支持.bind的承诺库中模拟(虽然方式有些粗略,不能在表达式中使用)。</target>
        </trans-unit>
        <trans-unit id="144ef4fefc003675e5f3e9aa894c364f1a909c60" translate="yes" xml:space="preserve">
          <source>This can be used for as many values as you like:</source>
          <target state="translated">这可以用在你想用多少值就用多少值。</target>
        </trans-unit>
        <trans-unit id="c73428b0fed4a12cd913cd5733b9a56cd877068d" translate="yes" xml:space="preserve">
          <source>This days, I also hava meet some questions like you. At last, I find a good solution with the quesition, it's simple and good to read. I hope this can help you.</source>
          <target state="translated">这几天,我也遇到了一些和你一样的问题。终于,我找到了一个很好的解决办法,很简单,也很好读。希望能帮到你。</target>
        </trans-unit>
        <trans-unit id="acfafaf8cb92b754b040f10b093a0b4d1cefb53f" translate="yes" xml:space="preserve">
          <source>This did work in Node.js since version 4.0, also a few browsers (or their dev editions) did support generator syntax relatively early.</source>
          <target state="translated">这在Node.js的4.0版本开始,也有一些浏览器(或其开发版本)相对较早地支持生成器语法。</target>
        </trans-unit>
        <trans-unit id="9985024202145ce805f87cbe5538067d97b19841" translate="yes" xml:space="preserve">
          <source>This does not introduce a race condition scenario that would arise from parallel invocation because a new instance of the results variable is created for every invocation of the getExample function.</source>
          <target state="translated">这并没有引入并行调用会产生的竞赛条件,因为每次调用getExample函数都会创建一个新的结果变量实例。</target>
        </trans-unit>
        <trans-unit id="46c1b4574441bc055943b5b04c15465abdec3bff" translate="yes" xml:space="preserve">
          <source>This pattern doesn't work across function boundaries, modularising the functions is harder as their declarations must not leave the shared scope</source>
          <target state="translated">这种模式并不能跨越函数边界,将函数模块化就更难了,因为它们的声明不能离开共享的范围。</target>
        </trans-unit>
        <trans-unit id="e5580ff94ef22be48cff7200bd303fbf66ceabd3" translate="yes" xml:space="preserve">
          <source>This solution can be invoked as follows:</source>
          <target state="translated">这个解决方案可以通过以下方式调用:</target>
        </trans-unit>
        <trans-unit id="e43a3e4618b96cad7d4ab03f023073c45d9f6bd6" translate="yes" xml:space="preserve">
          <source>This solution has several drawbacks:</source>
          <target state="translated">这个方案有几个缺点。</target>
        </trans-unit>
        <trans-unit id="da3dd2f8f239743397e37a9839f3048b1aa2620f" translate="yes" xml:space="preserve">
          <source>This will result in a very straightforward control flow, clear composition of functionalities and therefore easy modularisation.</source>
          <target state="translated">这样一来,控制流程就会非常简单明了,功能构成清晰,从而便于模块化。</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">试试这个。</target>
        </trans-unit>
        <trans-unit id="2057318d110eca92034720c6472bfc3e1bd381c0" translate="yes" xml:space="preserve">
          <source>Update: added working example</source>
          <target state="translated">更新:新增工作实例</target>
        </trans-unit>
        <trans-unit id="e944e3513336c73f5a43135573f6d4fe61b114c7" translate="yes" xml:space="preserve">
          <source>User is a promisified Mongoose model.</source>
          <target state="translated">用户是一个有承诺的Mongoose模型。</target>
        </trans-unit>
        <trans-unit id="03057780495560c1cec710f98e709cc23defb382" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;async - await&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;async - await&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eee874fe8aaa9db187a682e750fc3f3d02aa63e8" translate="yes" xml:space="preserve">
          <source>Using a locally scoped object to collect the intermediate results in a promise chain is a reasonable approach to the question you posed. Consider the following snippet:</source>
          <target state="translated">使用本地范围对象来收集承诺链中的中间结果是一个合理的方法,可以解决你提出的问题。考虑一下下面的片段。</target>
        </trans-unit>
        <trans-unit id="223bff812bcb6fe8adc3710c5c73399c9f4fc29b" translate="yes" xml:space="preserve">
          <source>Using closures for maintaining the scope of variables (in our case, the success callback function parameters) is the natural JavaScript solution. With promises, we can arbitrarily &lt;a href=&quot;https://stackoverflow.com/a/22000931/1048572&quot;&gt;nest and flatten&lt;/a&gt;&lt;code&gt;.then()&lt;/code&gt; callbacks - they are semantically equivalent, except for the scope of the inner one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用闭包来维护变量的范围（在我们的示例中为成功回调函数参数）是自然的JavaScript解决方案。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有了promises，我们可以随意&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/22000931/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;嵌套和展平&lt;/font&gt;&lt;/font&gt;&lt;/a&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;回调-它们在语义上是等效的，但内部回调的范围除外。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63a90d8bcee39e3e934d7225c50fb780b32e01d5" translate="yes" xml:space="preserve">
          <source>What I learn about promises is to use it only as return values &lt;strong&gt;avoid referencing them&lt;/strong&gt; if possible. async/await syntax is particularly practical for that. Today all latest browsers and node support it: &lt;a href=&quot;https://caniuse.com/#feat=async-functions&quot;&gt;https://caniuse.com/#feat=async-functions&lt;/a&gt; , is a simple behavior and the code is like reading synchronous code, forget about callbacks...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我了解到的Promise是仅将其用作返回值，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尽可能&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;避免引用它们&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;异步/等待语法对此特别实用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如今，所有最新的浏览器和节点都支持它：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://caniuse.com/#feat=async-functions&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//caniuse.com/#feat=async-functions&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这是一种简单的行为，其代码就像读取同步代码一样，而无需考虑回调...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8bfce48cbd196a61b1b247b32e5d1c51102f28ea" translate="yes" xml:space="preserve">
          <source>When using bluebird, you can use &lt;code&gt;.bind&lt;/code&gt; method to share variables in promise chain:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用bluebird时，可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.bind&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法在promise链中共享变量：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0aee9dff13129530d7d2bee00bb7f9b72fa1522" translate="yes" xml:space="preserve">
          <source>When you need to access the intermediate values in your chain, you should split your chain apart in those single pieces that you need. Instead of attaching one callback and somehow trying to use its parameter multiple times, attach multiple callbacks to the same promise - wherever you need the result value. Don't forget, a &lt;a href=&quot;https://stackoverflow.com/a/22540276/1048572&quot;&gt;promise just represents (proxies) a future value&lt;/a&gt;! Next to deriving one promise from the other in a linear chain, use the promise combinators that are given to you by your library to build the result value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当需要访问链中的中间值时，应将链分成所需的单个部分。不必附加一个回调并以某种方式尝试多次使用其参数，而是将多个回调附加到同一promise-无论何时需要结果值。不要忘记，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/22540276/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;承诺只是代表（代理）未来的价值&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;！除了从线性链中的另一个承诺中推导一个承诺之外，还使用库提供给您的承诺组合器来构建结果值。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4f21d072723ef8937089cfff3fff2bd8c2ed4b3" translate="yes" xml:space="preserve">
          <source>While this pattern guarantees a flat chain and explicit state objects can improve clarity, it will become tedious for a long chain. Especially when you need the state only sporadically, you still have to pass it through every step. With this fixed interface, the single callbacks in the chain are rather tightly coupled and inflexible to change. It makes factoring out single steps harder, and callbacks cannot be supplied directly from other modules - they always need to be wrapped in boilerplate code that cares about the state. Abstract helper functions like the above can ease the pain a bit, but it will always be present.</source>
          <target state="translated">虽然这种模式保证了扁平化的链,显式状态对象可以提高清晰度,但对于长链来说,会变得乏味。尤其是当你只是零星地需要状态的时候,你还是要每一步都要通过它。在这种固定的接口下,链中的单次回调是相当紧密耦合的,而且变化不灵活。这使得单步回调变得更加困难,而且回调不能直接从其他模块中提供--它们总是需要被包裹在关心状态的ilerplate代码中。像上面这样的抽象帮助函数可以稍微缓解一下痛苦,但它总是会存在的。</target>
        </trans-unit>
        <trans-unit id="1b9eacffa6333b9b56f47e8a6b4d99a89cd316d9" translate="yes" xml:space="preserve">
          <source>While we were waiting for ES8, we already did use a very similar kind of syntax. ES6 came with &lt;a href=&quot;http://davidwalsh.name/es6-generators&quot;&gt;generator functions&lt;/a&gt;, which allow to break the execution apart in pieces at arbitrarily placed &lt;code&gt;yield&lt;/code&gt; keywords. Those slices can be run after each other, independently, even asynchronously - and that's just what we do when we want to wait for a promise resolution before running the next step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在等待ES8时，我们已经使用了非常相似的语法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES6带有&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://davidwalsh.name/es6-generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;生成器函数&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，该&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;允许在任意放置的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;处将执行分段&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这些切片可以相互独立，甚至异步地运行-这就是我们要在执行下一步之前等待promise解析时所要做的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d663118fbfd1bf9fa6e25101948dd5f5db080d28" translate="yes" xml:space="preserve">
          <source>You can also use helper functions for this kind of &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;partial application&lt;/a&gt;, like &lt;code&gt;_.partial&lt;/code&gt; from &lt;a href=&quot;http://underscorejs.org/#partial&quot;&gt;Underscore&lt;/a&gt;/&lt;a href=&quot;https://lodash.com/docs#partial&quot;&gt;lodash&lt;/a&gt; or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;native &lt;code&gt;.bind()&lt;/code&gt; method&lt;/a&gt;, to further decrease indentation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您还可以使用辅助功能对于这种&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;局部的应用&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，像&lt;/font&gt;&lt;/font&gt; &lt;code&gt;_.partial&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://underscorejs.org/#partial&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下划线&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; / &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://lodash.com/docs#partial&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lodash&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本地&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.bind()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，以进一步降低缩进：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="504ef302e3dad1d0b3f2452e253c7576fe3cfd47" translate="yes" xml:space="preserve">
          <source>You can put intermediate values in scope in any later 'then' function explicitly, by using 'bind'. It is a nice solution that doesn't require changing how Promises work, and only requires a line or two of code to propagate the values just like errors are already propagated.</source>
          <target state="translated">你可以通过使用'bind'将中间值显式地放在后面的 'then' 函数中。这是一个很好的解决方案,不需要改变Promises的工作方式,只需要一两行代码就能像传播错误一样传播这些值。</target>
        </trans-unit>
        <trans-unit id="e100ea30d9c7be0d59c6c2207e286e7716ba132e" translate="yes" xml:space="preserve">
          <source>You don't need a single &lt;code&gt;then&lt;/code&gt; invocation or callback function any more, as in an asynchronous function (that returns a promise when being called) you can simply wait for promises to resolve directly. It also features arbitrary control structures like conditions, loops and try-catch-clauses, but for the sake of convenience we don't need them here:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;你并不需要一个单一的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;then&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用或回调函数更多，比如在异步函数（即返回一个承诺被调用时），你可以简单地等待承诺以直接解决。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它还具有诸如条件，循环和try-catch-clauses之类的任意控制结构，但是为了方便起见，我们在这里不需要它们：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d87de37b1d789f1d1fe1124c674c1df85f72fe40" translate="yes" xml:space="preserve">
          <source>and run the file with:</source>
          <target state="translated">并运行该文件与:</target>
        </trans-unit>
        <trans-unit id="48d22e4b889c8e81b57a132d3e6fa7ddb0ede8f6" translate="yes" xml:space="preserve">
          <source>easy way :D</source>
          <target state="translated">简单的方法:D</target>
        </trans-unit>
        <trans-unit id="969d4c74db0b220c26ebcbab6fb30ae35bd28194" translate="yes" xml:space="preserve">
          <source>ok, let's look at the code:</source>
          <target state="translated">好了,我们来看看代码。</target>
        </trans-unit>
        <trans-unit id="ca09a36d45885d74388e59c155d88008b4a03340" translate="yes" xml:space="preserve">
          <source>please check this link for further information:</source>
          <target state="translated">请查看此链接以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="a5222aa7ce87a66abef69219caaf401b2c3230a9" translate="yes" xml:space="preserve">
          <source>transpiled form a typescript project of mine:</source>
          <target state="translated">移植到我的一个项目中。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
