<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/28250680">
    <body>
      <group id="28250680">
        <trans-unit id="886001de61d616fd7504793554e90b0ead0d7946" translate="yes" xml:space="preserve">
          <source>(Note: a more complex and complete version of this solution has been tested, but not this example version, so it could have a bug.)</source>
          <target state="translated">(Замечание:более сложная и полная версия этого решения была протестирована,но не эта версия примера,так что она может иметь ошибку).</target>
        </trans-unit>
        <trans-unit id="8c36a0c010728fc244e1f43aab8c1da795455c65" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/q/844536/1048572&quot;&gt;Mutable state is ugly&lt;/a&gt;, and &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil&quot;&gt;global variables are evil&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/844536/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Изменчивое состояние ужасно&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , а &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;глобальные переменные - зло&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="446787ac4bf8edd63cd98d9810d37f90a8ce33c1" translate="yes" xml:space="preserve">
          <source>A less harsh spin on &quot;Mutable contextual state&quot;</source>
          <target state="translated">Менее резкий поворот к &quot;Мутабельному контекстуальному состоянию&quot;.</target>
        </trans-unit>
        <trans-unit id="61650d4ab35176fac8853a022c21d3f429ac0a74" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;https://html5hive.org/how-to-chain-javascript-promises/&quot;&gt;how-to-chain-javascript-promises&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В соответствии с &lt;/font&gt;&lt;a href=&quot;https://html5hive.org/how-to-chain-javascript-promises/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обещаниями&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; о &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;том, как цепочка Javascript&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb4e646963a08495dd8a836cba56eac6efaa78a1" translate="yes" xml:space="preserve">
          <source>Alternatively, you can employ &lt;code&gt;Promise.all&lt;/code&gt; to produce the promise for the array:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, вы можете использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для создания обещания для массива:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94665e6ad2dc97bb0515d1739a70f85937dae7b8" translate="yes" xml:space="preserve">
          <source>And then, there are also many other &lt;a href=&quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS#synchronous-to-asynchronous-javascript-compilers-cps&quot;&gt;compile-to-JS languages&lt;/a&gt;
that are dedicated to easing asynchronous programming. They usually use a syntax similar to &lt;code&gt;await&lt;/code&gt;, (e.g. &lt;a href=&quot;http://maxtaco.github.io/coffee-script/&quot;&gt;Iced CoffeeScript&lt;/a&gt;), but there are also others that feature a Haskell-like &lt;code&gt;do&lt;/code&gt;-notation (e.g. &lt;a href=&quot;http://lattejs.com/&quot;&gt;LatteJs&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/monadic&quot;&gt;monadic&lt;/a&gt;, &lt;a href=&quot;http://www.purescript.org/&quot;&gt;PureScript&lt;/a&gt; or &lt;a href=&quot;http://lispyscript.com/&quot;&gt;LispyScript&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И затем, есть также много других &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS#synchronous-to-asynchronous-javascript-compilers-cps&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;языков компиляции в JS&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , которые предназначены для облегчения асинхронного программирования. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обычно они используют синтаксис, похожий на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;await&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (например, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://maxtaco.github.io/coffee-script/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Iced CoffeeScript&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), но есть и другие, которые имеют Haskell-подобное &lt;/font&gt;&lt;/font&gt; &lt;code&gt;do&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -notation (например, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://lattejs.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LatteJs&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.npmjs.com/package/monadic&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;monadic&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.purescript.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PureScript&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://lispyscript.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LispyScript&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b117394e70cda9ad8f1592c22985ada9cd1467db" translate="yes" xml:space="preserve">
          <source>And you might not only use arrays, but arbitrarily complex objects. For example, with &lt;a href=&quot;http://underscorejs.org/#extend&quot;&gt;&lt;code&gt;_.extend&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign&lt;/code&gt;&lt;/a&gt; in a different helper function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И вы можете использовать не только массивы, но и произвольно сложные объекты. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://underscorejs.org/#extend&quot;&gt; &lt;code&gt;_.extend&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в другой вспомогательной функции:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6cd0e648be626f2f5734fc06177a48a905ba581d" translate="yes" xml:space="preserve">
          <source>Another answer, using &lt;code&gt;babel-node&lt;/code&gt; version &amp;lt;6</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другой ответ, используя &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;версию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;babel-node&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;lt;6&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="917cd1d01022379cee10d9edbb40647574476354" translate="yes" xml:space="preserve">
          <source>Another answer, using sequential executor &lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;nsynjs&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другой ответ, используя последовательного исполнителя &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/amaksr/nsynjs&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;nsynjs&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e8aab5e31173c31302ab6dcea021b1848ed8a3ee" translate="yes" xml:space="preserve">
          <source>Assigning promises-for-later-needed-values to variables and then getting their value via synchronous inspection. The example uses bluebird's &lt;code&gt;.value()&lt;/code&gt; method but many libraries provide similar method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Присваивание переменным обещаний для последующих необходимых значений и последующее получение их значений посредством синхронной проверки. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В примере используется &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метод &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.value()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; от &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bluebird,&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; но многие библиотеки предоставляют аналогичный метод.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="050feb2cbdeb309a67b27f7cdff96683ad234fa3" translate="yes" xml:space="preserve">
          <source>Before destructuring became available with ES6, a nifty helper method called &lt;code&gt;.spread()&lt;/code&gt; was pro&amp;shy;vi&amp;shy;ded by many promise libraries (&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;Q&lt;/a&gt;, &lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;Bluebird&lt;/a&gt;, &lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;when&lt;/a&gt;, &amp;hellip;). It takes a function with multiple parameters - one for each array element - to be used as &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;До того, как деструктуризация стала доступной в ES6, во &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;многих библиотеках обещаний ( &lt;/font&gt;&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Q&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bluebird&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;когда&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&amp;hellip;) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;был предоставлен &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;отличный вспомогательный метод с именем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.spread()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Требуется функция с несколькими параметрами - по одному для каждого элемента массива - для использования в качестве &lt;/font&gt; &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1fbe958b0857725f5a84c804d4ae85da21ceb1d" translate="yes" xml:space="preserve">
          <source>Bluebird also features a dedicated &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.join.html&quot;&gt;&lt;code&gt;join&lt;/code&gt; function&lt;/a&gt; to replace that &lt;code&gt;Promise.all&lt;/code&gt;+&lt;code&gt;spread&lt;/code&gt; combination with a simpler (and more efficient) construct:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bluebird также имеет специальную &lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.join.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функцию &lt;/font&gt;&lt;/a&gt;&lt;/font&gt; &lt;code&gt;join&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; которая заменяет эту &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; + &lt;/font&gt;&lt;/font&gt; &lt;code&gt;spread&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на более простую (и более эффективную) конструкцию:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="064bf726f394fe19c0ef56ee0e3f8168e8f3bf8c" translate="yes" xml:space="preserve">
          <source>Break the chain</source>
          <target state="translated">Разорвать цепь</target>
        </trans-unit>
        <trans-unit id="f446dfc8ca31cb54d0b1dae43079076f607503d6" translate="yes" xml:space="preserve">
          <source>ECMAScript 5</source>
          <target state="translated">ECMAScript 5</target>
        </trans-unit>
        <trans-unit id="b02b03612b472d412029a9017657b2e96f26db53" translate="yes" xml:space="preserve">
          <source>ECMAScript 6</source>
          <target state="translated">ECMAScript 6</target>
        </trans-unit>
        <trans-unit id="8eecaf932c06e6aadd977797e815790995527161" translate="yes" xml:space="preserve">
          <source>ECMAScript 8</source>
          <target state="translated">ECMAScript 8</target>
        </trans-unit>
        <trans-unit id="ec3cb3a8bb975f9d73ec9e15cd1211b669541cdd" translate="yes" xml:space="preserve">
          <source>ECMAScript Harmony</source>
          <target state="translated">ECMAScript Гармония</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="2568555d5b3660982a930ffff01c1764f5cb7a9c" translate="yes" xml:space="preserve">
          <source>Explicit pass-through</source>
          <target state="translated">Явный проход</target>
        </trans-unit>
        <trans-unit id="66a027cb165ddbb392556662ee9b3307626866a1" translate="yes" xml:space="preserve">
          <source>For more complex cases I often use these guy small promise utilities without dependencies tested and typed. p-map has been useful several times. I think he covered most use cases:</source>
          <target state="translated">Для более сложных случаев я часто использую эти парни маленькие обещающие утилиты без зависимостей,проверенные и набранные.p-map был полезен несколько раз.Думаю,он охватил большинство случаев использования:</target>
        </trans-unit>
        <trans-unit id="5d57f2f84b3ffe6a5b6f65ea9aed650138de72a5" translate="yes" xml:space="preserve">
          <source>Global variables are bad, so this solution uses a locally scoped variable which causes no harm.  It is only accessible within the function.</source>
          <target state="translated">Глобальные переменные плохи,поэтому данное решение использует локальную переменную,которая не причиняет вреда.Она доступна только внутри функции.</target>
        </trans-unit>
        <trans-unit id="24ca8b33236bc0d0ef50e2dd43fb66e04162b483" translate="yes" xml:space="preserve">
          <source>Here is a complete example:</source>
          <target state="translated">Вот полный пример:</target>
        </trans-unit>
        <trans-unit id="a7f4dfdc3b0e4865ba4c2f88fa68113cce0ed915" translate="yes" xml:space="preserve">
          <source>Here, that little arrow &lt;code&gt;b =&amp;gt; [resultA, b]&lt;/code&gt; is the function that closes over &lt;code&gt;resultA&lt;/code&gt;, and passes an array of both results to the next step. Which uses parameter destructuring syntax to break it up in single variables again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Здесь эта маленькая стрелка &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b =&amp;gt; [resultA, b]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это функция, которая закрывает результат &lt;/font&gt;&lt;/font&gt; &lt;code&gt;resultA&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и передает массив обоих результатов на следующий шаг. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Который использует синтаксис деструктурирования параметров, чтобы снова разбить его на отдельные переменные.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b545f5f84c287a347a609ffd6cd3f0acc3d440ef" translate="yes" xml:space="preserve">
          <source>How do I access previous promise results in a .then() chain</source>
          <target state="translated">Как получить доступ к результатам предыдущего обещания в цепочке .then().</target>
        </trans-unit>
        <trans-unit id="02900e741b676e32f46da3689f6188c4289e7586" translate="yes" xml:space="preserve">
          <source>However, if you want/need to be backwards-compatible you cannot use those without a transpiler. Both generator functions and async functions are supported by the current tooling, see for example the documentation of Babel on &lt;a href=&quot;http://babeljs.io/learn-es2015/#ecmascript-2015-features-generators&quot;&gt;generators&lt;/a&gt; and &lt;a href=&quot;http://babeljs.io/docs/plugins/syntax-async-functions&quot;&gt;async functions&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако, если вы хотите / должны быть обратно совместимыми, вы не можете использовать их без транспилятора. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обе функции генератора и асинхронные функции поддерживаются текущим инструментарием, см., Например, документацию Babel о &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://babeljs.io/learn-es2015/#ecmascript-2015-features-generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;генераторах&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://babeljs.io/docs/plugins/syntax-async-functions&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;асинхронных функциях&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d891f22fbf83c3adb5977c46bcbe5452c18a9d0d" translate="yes" xml:space="preserve">
          <source>I am not going to use this pattern in my own code since I'm not a big fan of using global variables. However, in a pinch it will work.</source>
          <target state="translated">Я не собираюсь использовать этот паттерн в своем собственном коде,так как я не большой поклонник использования глобальных переменных.Однако,в крайнем случае это сработает.</target>
        </trans-unit>
        <trans-unit id="68345dc8d3438db6294a505941bbc502c5478c3d" translate="yes" xml:space="preserve">
          <source>I have restructured my code to &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;promises&lt;/a&gt;, and built a wonderful long &lt;strong&gt;flat promise chain&lt;/strong&gt;, consisting of multiple &lt;code&gt;.then()&lt;/code&gt; callbacks. In the end I want to return some composite value, and need to access multiple &lt;strong&gt;intermediate promise results&lt;/strong&gt;. However the resolution values from the middle of the sequence are not in scope in the last callback, how do I access them?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я реструктурировал свой код к &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обещаниям&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и создал замечательную &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;цепочку&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; длинных &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;плоских обещаний&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , состоящую из нескольких &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обратных вызовов &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . В конце я хочу вернуть несколько составных значений и получить доступ к нескольким &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;промежуточным результатам обещаний&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Однако значения разрешения в середине последовательности не входят в область действия последнего обратного вызова. Как получить к ним доступ?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="134d28e92e3dba4bc6b603007f8ab403b5304a73" translate="yes" xml:space="preserve">
          <source>I think you can use hash of RSVP.</source>
          <target state="translated">Я думаю,ты можешь использовать гашиш RSVP.</target>
        </trans-unit>
        <trans-unit id="e39203fa696fcdd915ba3edc88b86f9842cb98fa" translate="yes" xml:space="preserve">
          <source>In cases I do need to reference a promises is when creation and resolution happen at independent/not-related places. So instead an artificial association and probably an event listener just to resolve the &quot;distant&quot; promise, I prefer to expose the promise as a Deferred, which the following code implements it in valid es5</source>
          <target state="translated">В случаях,когда мне действительно нужно сослаться на обещания,это когда создание и урегулирование происходит в местах,не связанных с независимостью.Поэтому вместо искусственной ассоциации и,возможно,слушателя событий только для того,чтобы разрешить &quot;далекое&quot; обещание,я предпочитаю выставлять обещание как Отсроченное,который следующий код реализует его в действительных es5</target>
        </trans-unit>
        <trans-unit id="24d5ca2482aca47f7ad53f979d066f321ca7b78a" translate="yes" xml:space="preserve">
          <source>In theory, you can always avoid more than two levels of nesting (by making all closures explicit), in practise use as many as are reasonable.</source>
          <target state="translated">В теории,вы всегда можете избежать более чем двух уровней гнездования (делая все замыкания явными),на практике использовать столько,сколько разумно.</target>
        </trans-unit>
        <trans-unit id="d3bf1dc059b68a3d8ddb78e7995e2ab7c5c7d020" translate="yes" xml:space="preserve">
          <source>Instead of many variables one might also use an (initially empty) object, on which the results are stored as dynamically created properties.</source>
          <target state="translated">Вместо многих переменных можно также использовать (изначально пустой)объект,на котором результаты хранятся в виде динамически создаваемых свойств.</target>
        </trans-unit>
        <trans-unit id="8f9b6a3354ddc0bb248f6e94d258722ec015fcb3" translate="yes" xml:space="preserve">
          <source>Instead of the parameter destructuring in the callback after &lt;code&gt;Promise.all&lt;/code&gt; that only became avail&amp;shy;able with ES6, in ES5 the &lt;code&gt;then&lt;/code&gt; call would be replaced by a nifty helper method that was provided by many promise libraries (&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;Q&lt;/a&gt;, &lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;Bluebird&lt;/a&gt;, &lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;when&lt;/a&gt;, &amp;hellip;): &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вместо деструктуризации параметра в функции &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обратного вызова после &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что только стал доступен с ES6, в ES5 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;then&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вызов будет заменен изящным вспомогательным методом , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;который был предоставлен многими библиотеками обещания ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Q&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/spread.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bluebird&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;когда&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , ...): &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.spread(function(resultA, resultB) { &amp;hellip;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d951045f06a6f96d2459f58d21879f6988c4a16" translate="yes" xml:space="preserve">
          <source>Intermediate promises are not prevented from accessing the state of the results object, but this does not introduce some scary scenario where one of the promises in the chain will go rogue and sabotage your results.  The responsibility of setting the values in each step of the promise is confined to this function and the overall result will either be correct or incorrect...it will not be some bug that will crop up years later in production (unless you intend it to!)</source>
          <target state="translated">Промежуточные обещания не препятствуют доступу к состоянию объекта результатов,но это не вводит некий страшный сценарий,при котором одно из обещаний в цепочке пойдет вразнос и саботирует ваши результаты.Ответственность за установку значений на каждом шаге обещания ограничивается этой функцией,и общий результат будет либо правильным,либо неправильным...это не будет какой-то ошибкой,которая появится через несколько лет в производстве (если только вы этого не намерены!).</target>
        </trans-unit>
        <trans-unit id="012957063b5658b4b53260c2fa3837d67c7176c3" translate="yes" xml:space="preserve">
          <source>Mutable contextual state</source>
          <target state="translated">Мутируемое контекстуальное состояние</target>
        </trans-unit>
        <trans-unit id="a7d298a254d44b48b6337a699fa090dd4e71111a" translate="yes" xml:space="preserve">
          <source>Mutable state is ugly, but this does not mutate state in an ugly manner.  The ugly mutable state traditionally refers to modifying the state of function arguments or global variables, but this approach simply modifies the state of a locally scoped variable that exists for the sole purpose of aggregating promise results...a variable that will die a simple death once the promise resolves.</source>
          <target state="translated">Мутирующее состояние уродливо,но это не мутирует состояние уродливо.Уродливое мутирующее состояние традиционно относится к модификации состояния аргументов функции или глобальных переменных,но при таком подходе просто модифицируется состояние локально охваченной переменной,которая существует только для того,чтобы свести воедино результаты обещания...переменная,которая умрет простой смертью после того,как обещание разрешится.</target>
        </trans-unit>
        <trans-unit id="e8449a4b6842da8a1dba6281ce394242d5e45321" translate="yes" xml:space="preserve">
          <source>Nesting (and) closures</source>
          <target state="translated">Закрытие гнезд (и)</target>
        </trans-unit>
        <trans-unit id="c40ee383e2e4ca5e287bcee0f67b57f30dfbadf6" translate="yes" xml:space="preserve">
          <source>Node 7.4 now supports async/await calls with the harmony flag.</source>
          <target state="translated">Узел 7.4 теперь поддерживает асинкаваинтные вызовы с флагом гармонии.</target>
        </trans-unit>
        <trans-unit id="412034bba97d4a4ab3e0a443ec0f5a846d142e98" translate="yes" xml:space="preserve">
          <source>Of course, that closure needed here can be further simplified by some helper functions, e.g.</source>
          <target state="translated">Естественно,что нужное здесь закрытие может быть еще более упрощено некоторыми вспомогательными функциями,например.</target>
        </trans-unit>
        <trans-unit id="aae9058adf8a1b510c202b122b2328aaf3580d28" translate="yes" xml:space="preserve">
          <source>Of course, this is building an indentation pyramid. If indentation is getting too large, you still can apply the old tools to counter the &lt;a href=&quot;http://callbackhell.com/&quot;&gt;pyramid of doom&lt;/a&gt;: modularize, use extra named functions, and flatten the promise chain as soon as you don't need a variable any more.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конечно, это строительство пирамиды отступов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если отступ становится слишком большим, вы все равно можете применить старые инструменты для противодействия &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://callbackhell.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;пирамиде doom&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : modularize, использовать дополнительные именованные функции и сгладить цепочку обещаний, как только вам больше не понадобится переменная.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10a3c56a26dc06509d2fd474a39da19d101d6694" translate="yes" xml:space="preserve">
          <source>Of course, this problem was recognized by the language designers as well. They did a lot of work and the &lt;a href=&quot;http://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async functions proposal&lt;/a&gt; finally made it into</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конечно, эта проблема была признана дизайнерами языков. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Они проделали большую работу, и предложение об &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://tc39.github.io/ecmascript-asyncawait/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;асинхронных функциях&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; наконец-то превратилось в&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dff95b253f71a37696b949a20c5ca47263763ec1" translate="yes" xml:space="preserve">
          <source>One must choose the scope for those shared variables correctly. It needs to be local to the executed function to prevent race conditions between multiple parallel invocations, as would be the case if, for example, state was stored on an instance.</source>
          <target state="translated">Необходимо правильно выбрать область видимости для этих общих переменных.Она должна быть локальной для выполняемой функции,чтобы предотвратить условия гонки между несколькими параллельными вызовами,как это было бы,например,в случае,если бы состояние хранилось на экземпляре.</target>
        </trans-unit>
        <trans-unit id="c1f929f8e70b71568c730fcf1ca04cc7fd34b3af" translate="yes" xml:space="preserve">
          <source>Similar to nesting the callbacks, this technique relies on closures. Yet, the chain stays flat - instead of passing only the latest result, some state object is passed for every step. These state objects accumulate the results of the previous actions, handing down all values that will be needed later again plus the result of the current task.</source>
          <target state="translated">Подобно гнездованию обратных вызовов,эта техника основана на замыкании.При этом цепь остается плоской-вместо того,чтобы передать только последний результат,на каждый шаг передается некий объект состояния.Эти объекты состояния накапливают результаты предыдущих действий,передавая все значения,которые понадобятся позже,плюс результат текущей задачи.</target>
        </trans-unit>
        <trans-unit id="6aafb455fdb78b42aaa8e751fa4281daec51a6e7" translate="yes" xml:space="preserve">
          <source>Simple as can be!</source>
          <target state="translated">Все просто,как может быть!</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="740ffbb9952d0db97b17599b914cae9f45ab58ec" translate="yes" xml:space="preserve">
          <source>Something like as below :</source>
          <target state="translated">Что-то вроде ниже :</target>
        </trans-unit>
        <trans-unit id="9d4e83066087dd1079c656c148313dafa0d0a48a" translate="yes" xml:space="preserve">
          <source>Synchronous inspection</source>
          <target state="translated">Синхронный осмотр</target>
        </trans-unit>
        <trans-unit id="7552eee459001ff5a9e0fbf19a139de19a6e647d" translate="yes" xml:space="preserve">
          <source>The Bluebird library encourages the use of an object that is passed along, using &lt;a href=&quot;http://bluebirdjs.com/docs/api/bind.html&quot;&gt;their &lt;code&gt;bind()&lt;/code&gt; method&lt;/a&gt; to assign a context object to a promise chain. It will be accessible from each callback function via the otherwise unusable &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;&lt;code&gt;this&lt;/code&gt; keyword&lt;/a&gt;. While object properties are more prone to undetected typos than variables, the pattern is quite clever:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Библиотека Bluebird поощряет использование передаваемого объекта, используя &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/bind.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;их &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метод &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bind()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для назначения объекта контекста цепочке обещаний. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он будет доступен из каждой функции обратного вызова через неиспользуемое &lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ключевое слово &lt;/font&gt;&lt;/a&gt;&lt;/font&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В то время как свойства объекта более подвержены необнаруженным опечаткам, чем переменным, шаблон довольно умный:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9da2cb01b9445e3b82cef2fa35434f5be10a373b" translate="yes" xml:space="preserve">
          <source>The scope of the variables does not prevent to access them before they are initialized. This is especially likely for complex promise constructions (loops, branching, excptions) where race conditions might happen. Passing state explicitly, a &lt;a href=&quot;http://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;declarative design&lt;/a&gt; that promises encourage, forces a cleaner coding style which can prevent this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Область видимости переменных не препятствует доступу к ним до их инициализации. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это особенно вероятно для сложных конструкций обещаний (циклы, ветвления, исключения), где могут возникнуть условия гонки. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Явно передавая состояние, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;декларативный дизайн,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; который обещает поощрить, заставляет более чистый стиль кодирования, который может предотвратить это.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef9dea0231e47298d8f39b636223237575303e9c" translate="yes" xml:space="preserve">
          <source>The trivial (but inelegant and rather errorprone) solution is to just use higher-scope variables (to which all callbacks in the chain have access) and write result values to them when you get them:</source>
          <target state="translated">Тривиальное (но невыразительное и скорее склонное к ошибкам)решение заключается в том,чтобы просто использовать переменные более высокого диапазона (к которым имеют доступ все обратные вызовы в цепочке)и записывать в них значения результатов,когда вы их получаете:</target>
        </trans-unit>
        <trans-unit id="03ebf8b9502bb380b80a7eb42cece7ab3209b46b" translate="yes" xml:space="preserve">
          <source>Then, run &lt;code&gt;babel-node example.js&lt;/code&gt; and voila!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем запустите &lt;/font&gt;&lt;/font&gt; &lt;code&gt;babel-node example.js&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и вуаля!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab34eafdad2b4ee95e473c31dd3db173f98501d2" translate="yes" xml:space="preserve">
          <source>There are dedicated libraries (like &lt;a href=&quot;https://github.com/tj/co&quot;&gt;co&lt;/a&gt; or &lt;a href=&quot;http://taskjs.org/&quot;&gt;task.js&lt;/a&gt;), but also many promise libraries have helper functions (&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#generators&quot;&gt;Q&lt;/a&gt;, &lt;a href=&quot;http://bluebirdjs.com/docs/api/generators.html&quot;&gt;Bluebird&lt;/a&gt;, &lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#es6-generators&quot;&gt;when&lt;/a&gt;, &amp;hellip;) that do &lt;a href=&quot;https://stackoverflow.com/a/23554399/1048572&quot;&gt;this async step-by-step execution&lt;/a&gt; for you when you give them a generator function that yields promises.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Существуют выделенные библиотеки (например, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/tj/co&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;co&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://taskjs.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;task.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), но также во многих библиотеках обещаний есть вспомогательные функции ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/kriskowal/q/wiki/API-Reference#generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Q&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bluebirdjs.com/docs/api/generators.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bluebird&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/cujojs/when/blob/master/docs/api.md#es6-generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;когда&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ...), которые выполняют &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/23554399/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;это асинхронное пошаговое выполнение&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для вас, когда вы даете им функцию генератора, которая дает обещания.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8a230a40501497f4bfe4e1796388f0ed6d16b20" translate="yes" xml:space="preserve">
          <source>This approach can be easily simulated in promise libraries that do not support .bind (although in a somewhat more verbose way and cannot be used in an expression):</source>
          <target state="translated">Этот подход может быть легко смоделирован в многообещающих библиотеках,которые не поддерживают .bind (хотя и в несколько более многословном виде и не могут быть использованы в выражении):</target>
        </trans-unit>
        <trans-unit id="144ef4fefc003675e5f3e9aa894c364f1a909c60" translate="yes" xml:space="preserve">
          <source>This can be used for as many values as you like:</source>
          <target state="translated">Это может быть использовано для стольких значений,сколько вам нравится:</target>
        </trans-unit>
        <trans-unit id="c73428b0fed4a12cd913cd5733b9a56cd877068d" translate="yes" xml:space="preserve">
          <source>This days, I also hava meet some questions like you. At last, I find a good solution with the quesition, it's simple and good to read. I hope this can help you.</source>
          <target state="translated">В эти дни я также встречаюсь с такими вопросами,как ты.Наконец,я нахожу хорошее решение с квестом,это просто и хорошо читать.Надеюсь,это вам поможет.</target>
        </trans-unit>
        <trans-unit id="acfafaf8cb92b754b040f10b093a0b4d1cefb53f" translate="yes" xml:space="preserve">
          <source>This did work in Node.js since version 4.0, also a few browsers (or their dev editions) did support generator syntax relatively early.</source>
          <target state="translated">Это работало в Node.js с версии 4.0,также несколько браузеров (или их dev-версий)поддерживали синтаксис генератора относительно рано.</target>
        </trans-unit>
        <trans-unit id="9985024202145ce805f87cbe5538067d97b19841" translate="yes" xml:space="preserve">
          <source>This does not introduce a race condition scenario that would arise from parallel invocation because a new instance of the results variable is created for every invocation of the getExample function.</source>
          <target state="translated">Это не вводит сценарий состояния гонки,которое возникло бы при параллельном вызове,так как для каждого вызова функции getExample создается новый экземпляр переменной результатов.</target>
        </trans-unit>
        <trans-unit id="46c1b4574441bc055943b5b04c15465abdec3bff" translate="yes" xml:space="preserve">
          <source>This pattern doesn't work across function boundaries, modularising the functions is harder as their declarations must not leave the shared scope</source>
          <target state="translated">Этот шаблон не работает через границы функций,модуляризация функций более сложна,так как их объявления не должны выходить из общей области применения</target>
        </trans-unit>
        <trans-unit id="e5580ff94ef22be48cff7200bd303fbf66ceabd3" translate="yes" xml:space="preserve">
          <source>This solution can be invoked as follows:</source>
          <target state="translated">Это решение может быть вызвано следующим образом:</target>
        </trans-unit>
        <trans-unit id="e43a3e4618b96cad7d4ab03f023073c45d9f6bd6" translate="yes" xml:space="preserve">
          <source>This solution has several drawbacks:</source>
          <target state="translated">У этого решения есть несколько недостатков:</target>
        </trans-unit>
        <trans-unit id="da3dd2f8f239743397e37a9839f3048b1aa2620f" translate="yes" xml:space="preserve">
          <source>This will result in a very straightforward control flow, clear composition of functionalities and therefore easy modularisation.</source>
          <target state="translated">Это приведет к очень простому управлению потоком,четкому составу функций и,следовательно,легкой модуляризации.</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">Попробуй это:</target>
        </trans-unit>
        <trans-unit id="2057318d110eca92034720c6472bfc3e1bd381c0" translate="yes" xml:space="preserve">
          <source>Update: added working example</source>
          <target state="translated">Обновление:добавлен рабочий пример</target>
        </trans-unit>
        <trans-unit id="e944e3513336c73f5a43135573f6d4fe61b114c7" translate="yes" xml:space="preserve">
          <source>User is a promisified Mongoose model.</source>
          <target state="translated">Пользователь-обещанная модель Mongoose.</target>
        </trans-unit>
        <trans-unit id="03057780495560c1cec710f98e709cc23defb382" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;async - await&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Использование &lt;/font&gt;&lt;/font&gt; &lt;code&gt;async - await&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eee874fe8aaa9db187a682e750fc3f3d02aa63e8" translate="yes" xml:space="preserve">
          <source>Using a locally scoped object to collect the intermediate results in a promise chain is a reasonable approach to the question you posed. Consider the following snippet:</source>
          <target state="translated">Использование локального объекта для сбора промежуточных результатов в цепочке обещаний является разумным подходом к заданному вопросу.Рассмотрим следующий отрывок:</target>
        </trans-unit>
        <trans-unit id="223bff812bcb6fe8adc3710c5c73399c9f4fc29b" translate="yes" xml:space="preserve">
          <source>Using closures for maintaining the scope of variables (in our case, the success callback function parameters) is the natural JavaScript solution. With promises, we can arbitrarily &lt;a href=&quot;https://stackoverflow.com/a/22000931/1048572&quot;&gt;nest and flatten&lt;/a&gt;&lt;code&gt;.then()&lt;/code&gt; callbacks - they are semantically equivalent, except for the scope of the inner one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Использование замыканий для поддержки области видимости переменных (в нашем случае, параметров функции обратного вызова success) является естественным решением JavaScript. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С помощью обещаний мы можем произвольно &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/22000931/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вкладывать и выравнивать&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; обратные вызовы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - они семантически эквивалентны, за исключением области действия внутреннего.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63a90d8bcee39e3e934d7225c50fb780b32e01d5" translate="yes" xml:space="preserve">
          <source>What I learn about promises is to use it only as return values &lt;strong&gt;avoid referencing them&lt;/strong&gt; if possible. async/await syntax is particularly practical for that. Today all latest browsers and node support it: &lt;a href=&quot;https://caniuse.com/#feat=async-functions&quot;&gt;https://caniuse.com/#feat=async-functions&lt;/a&gt; , is a simple behavior and the code is like reading synchronous code, forget about callbacks...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что я узнаю об обещаниях - это использовать их только в качестве возвращаемых значений, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;избегая ссылок на них,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; если это возможно &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Синтаксис async / await особенно полезен для этого. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сегодня все последние браузеры и узлы поддерживают это: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://caniuse.com/#feat=async-functions&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://caniuse.com/#feat=async-functions&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , это простое поведение, а код похож на чтение синхронного кода, забудьте про обратные вызовы ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8bfce48cbd196a61b1b247b32e5d1c51102f28ea" translate="yes" xml:space="preserve">
          <source>When using bluebird, you can use &lt;code&gt;.bind&lt;/code&gt; method to share variables in promise chain:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;При использовании bluebird вы можете использовать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метод &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.bind&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для совместного использования переменных в цепочке обещаний:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0aee9dff13129530d7d2bee00bb7f9b72fa1522" translate="yes" xml:space="preserve">
          <source>When you need to access the intermediate values in your chain, you should split your chain apart in those single pieces that you need. Instead of attaching one callback and somehow trying to use its parameter multiple times, attach multiple callbacks to the same promise - wherever you need the result value. Don't forget, a &lt;a href=&quot;https://stackoverflow.com/a/22540276/1048572&quot;&gt;promise just represents (proxies) a future value&lt;/a&gt;! Next to deriving one promise from the other in a linear chain, use the promise combinators that are given to you by your library to build the result value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда вам нужно получить доступ к промежуточным значениям в вашей цепочке, вы должны разбить вашу цепочку на части, которые вам нужны. Вместо того, чтобы прикреплять один обратный вызов и каким-то образом пытаться использовать его параметр несколько раз, прикрепите несколько обратных вызовов к одному и тому же обещанию - везде, где вам нужно значение результата. Не забывайте, что &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/22540276/1048572&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обещание просто представляет (прокси) будущую ценность&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ! Далее, чтобы получить одно обещание от другого в линейной цепочке, используйте комбинаторы обещаний, которые вам дает ваша библиотека, для построения значения результата.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4f21d072723ef8937089cfff3fff2bd8c2ed4b3" translate="yes" xml:space="preserve">
          <source>While this pattern guarantees a flat chain and explicit state objects can improve clarity, it will become tedious for a long chain. Especially when you need the state only sporadically, you still have to pass it through every step. With this fixed interface, the single callbacks in the chain are rather tightly coupled and inflexible to change. It makes factoring out single steps harder, and callbacks cannot be supplied directly from other modules - they always need to be wrapped in boilerplate code that cares about the state. Abstract helper functions like the above can ease the pain a bit, but it will always be present.</source>
          <target state="translated">В то время как эта модель гарантирует плоскую цепь,а явное состояние объектов может улучшить ясность,она станет утомительной для длинной цепи.Особенно,когда состояние требуется лишь спорадически,вам все равно придется проходить его через каждый шаг.Благодаря этому фиксированному интерфейсу,единичные обратные вызовы в цепочке достаточно плотно связаны и негибки для изменения.Это усложняет факторинг отдельных шагов,а обратные вызовы не могут поступать напрямую из других модулей-они всегда должны быть завернуты в код шаблона,который заботится о состоянии.Абстрактные вспомогательные функции,такие как выше,могут немного облегчить боль,но она всегда будет присутствовать.</target>
        </trans-unit>
        <trans-unit id="1b9eacffa6333b9b56f47e8a6b4d99a89cd316d9" translate="yes" xml:space="preserve">
          <source>While we were waiting for ES8, we already did use a very similar kind of syntax. ES6 came with &lt;a href=&quot;http://davidwalsh.name/es6-generators&quot;&gt;generator functions&lt;/a&gt;, which allow to break the execution apart in pieces at arbitrarily placed &lt;code&gt;yield&lt;/code&gt; keywords. Those slices can be run after each other, independently, even asynchronously - and that's just what we do when we want to wait for a promise resolution before running the next step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Пока мы ждали ES8, мы уже использовали очень похожий синтаксис. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES6 поставляется с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://davidwalsh.name/es6-generators&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функциями генератора&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , которые позволяют разбить выполнение на части при произвольно размещенных &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ключевых слов &lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эти фрагменты можно запускать друг за другом, независимо, даже асинхронно - и это именно то, что мы делаем, когда хотим дождаться разрешения обещания перед выполнением следующего шага.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d663118fbfd1bf9fa6e25101948dd5f5db080d28" translate="yes" xml:space="preserve">
          <source>You can also use helper functions for this kind of &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;partial application&lt;/a&gt;, like &lt;code&gt;_.partial&lt;/code&gt; from &lt;a href=&quot;http://underscorejs.org/#partial&quot;&gt;Underscore&lt;/a&gt;/&lt;a href=&quot;https://lodash.com/docs#partial&quot;&gt;lodash&lt;/a&gt; or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;native &lt;code&gt;.bind()&lt;/code&gt; method&lt;/a&gt;, to further decrease indentation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы также можете использовать вспомогательные функции для этого вида &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;частичного приложения&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , например &lt;/font&gt;&lt;/font&gt; &lt;code&gt;_.partial&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://underscorejs.org/#partial&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Underscore&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; / &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://lodash.com/docs#partial&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lodash&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;собственный &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метод &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.bind()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , для дальнейшего уменьшения отступа:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="504ef302e3dad1d0b3f2452e253c7576fe3cfd47" translate="yes" xml:space="preserve">
          <source>You can put intermediate values in scope in any later 'then' function explicitly, by using 'bind'. It is a nice solution that doesn't require changing how Promises work, and only requires a line or two of code to propagate the values just like errors are already propagated.</source>
          <target state="translated">Промежуточные значения можно явно помещать в область видимости в любой последующей функции 'then',используя 'bind'.Это хорошее решение,не требующее изменения работы Promises,а лишь требующее пару строк кода для распространения значений,точно так же,как ошибки уже распространены.</target>
        </trans-unit>
        <trans-unit id="e100ea30d9c7be0d59c6c2207e286e7716ba132e" translate="yes" xml:space="preserve">
          <source>You don't need a single &lt;code&gt;then&lt;/code&gt; invocation or callback function any more, as in an asynchronous function (that returns a promise when being called) you can simply wait for promises to resolve directly. It also features arbitrary control structures like conditions, loops and try-catch-clauses, but for the sake of convenience we don't need them here:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вам больше не нужна ни одна, а &lt;/font&gt;&lt;/font&gt; &lt;code&gt;then&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; функция вызова или обратного вызова, поскольку в асинхронной функции (которая возвращает обещание при вызове) вы можете просто дождаться разрешения обещаний, которое будет выполнено напрямую. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он также имеет произвольные управляющие структуры, такие как условия, циклы и предложения try-catch, но для удобства они нам здесь не нужны:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d87de37b1d789f1d1fe1124c674c1df85f72fe40" translate="yes" xml:space="preserve">
          <source>and run the file with:</source>
          <target state="translated">и запустить файл:</target>
        </trans-unit>
        <trans-unit id="48d22e4b889c8e81b57a132d3e6fa7ddb0ede8f6" translate="yes" xml:space="preserve">
          <source>easy way :D</source>
          <target state="translated">простой способ :D</target>
        </trans-unit>
        <trans-unit id="969d4c74db0b220c26ebcbab6fb30ae35bd28194" translate="yes" xml:space="preserve">
          <source>ok, let's look at the code:</source>
          <target state="translated">Хорошо,давайте посмотрим на код:</target>
        </trans-unit>
        <trans-unit id="ca09a36d45885d74388e59c155d88008b4a03340" translate="yes" xml:space="preserve">
          <source>please check this link for further information:</source>
          <target state="translated">Пожалуйста,пройдите по этой ссылке для получения дополнительной информации:</target>
        </trans-unit>
        <trans-unit id="a5222aa7ce87a66abef69219caaf401b2c3230a9" translate="yes" xml:space="preserve">
          <source>transpiled form a typescript project of mine:</source>
          <target state="translated">транспонированный из моего типографского проекта:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
