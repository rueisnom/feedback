<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/285793">
    <body>
      <group id="285793">
        <trans-unit id="ece08654998b41655e46f33e0f20babd54865886" translate="yes" xml:space="preserve">
          <source>'serialVersionUID' is a 64 bit number used to uniquely identify a class during deserialization process. When you serialize an object, serialVersionUID of the class also written to the file. Whenever you deserialize this object, java run time extract this serialVersionUID value from the serialized data and compare the same value associate with the class. If both do not match, then 'java.io.InvalidClassException' will be thrown.</source>
          <target state="translated">'serialVersionUID'是一个64位的数字,在反序列化过程中用来唯一标识一个类。当你对一个对象进行序列化时,类的serialVersionUID也会被写入文件中。每当你对这个对象进行反序列化时,java运行时间会从序列化的数据中提取这个serialVersionUID值,并与类关联的相同值进行比较。如果两者不匹配,则会抛出'java.io.InvalidClassException'。</target>
        </trans-unit>
        <trans-unit id="42edaf9723e5c4f748fc70bd7e1ff25ff4ee0521" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=45&quot;&gt;This article&lt;/a&gt; has some good points on the topic.</source>
          <target state="translated">&lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=45&quot;&gt;本文&lt;/a&gt;对此主题有一些好处。</target>
        </trans-unit>
        <trans-unit id="9c5d59d7913642ce893724ffc9429ca21bfe2c44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SerialVersionUID&lt;/code&gt; is a unique identifier for each class, &lt;code&gt;JVM&lt;/code&gt; uses it to compare the versions of the class ensuring that the same class was used during Serialization is loaded during Deserialization.</source>
          <target state="translated">&lt;code&gt;SerialVersionUID&lt;/code&gt; 是每个类的唯一标识符， &lt;code&gt;JVM&lt;/code&gt; 使用它来比较该类的版本，以确保在反序列化期间加载序列化期间使用的同一类。</target>
        </trans-unit>
        <trans-unit id="152df86e7d736482ad28fd298d1e6b599b88146a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SerialVersionUID&lt;/code&gt; is used to version serialized data. You can only de-serialize a class if it's &lt;code&gt;SerialVersionUID&lt;/code&gt; matches with the serialized instance. When we don't declare &lt;code&gt;SerialVersionUID&lt;/code&gt; in our class, Java runtime generates it for us but its not recommended. It's recommended to declare &lt;code&gt;SerialVersionUID&lt;/code&gt; as &lt;code&gt;private static final long&lt;/code&gt; variable to avoid default mechanism.</source>
          <target state="translated">&lt;code&gt;SerialVersionUID&lt;/code&gt; 用于对序列化数据进行版本控制。 如果类的 &lt;code&gt;SerialVersionUID&lt;/code&gt; 与序列化的实例匹配，则只能对它进行反序列化。 当我们不在类中声明 &lt;code&gt;SerialVersionUID&lt;/code&gt; 时，Java运行时会为我们生成它，但不建议这样做。 建议将 &lt;code&gt;SerialVersionUID&lt;/code&gt; 声明为 &lt;code&gt;private static final long&lt;/code&gt; 变量，以避免使用默认机制。</target>
        </trans-unit>
        <trans-unit id="ee68f99f789b144946181e1611c0252582d08cac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serialVersionUID&lt;/code&gt; facilitates versioning of serialized data. Its value is stored with the data when serializing. When de-serializing, the same version is checked to see how the serialized data matches the current code.</source>
          <target state="translated">&lt;code&gt;serialVersionUID&lt;/code&gt; 有助于序列化数据的版本控制。 序列化时，其值与数据一起存储。 反序列化时，将检查相同版本以查看序列化数据如何与当前代码匹配。</target>
        </trans-unit>
        <trans-unit id="caf82cc19ceaeb5cc908ee5778f22c14c5f204e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;There are some rules for serialization&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;有一些序列化规则&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="3809a6cba5b10c0cfa01db3b1df7b55838f75ba0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Where we need serialVersionID:&lt;/em&gt;&lt;/strong&gt;
During the deserialization to verify that sender and receiver are compatible with respect to serialization. If the receiver loaded the class with a different &lt;code&gt;serialVersionID&lt;/code&gt; then deserialization will end with &lt;code&gt;InvalidClassCastException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;我们需要serialVersionID的地方：&lt;/em&gt;&lt;/strong&gt;在反序列化过程中，验证发送者和接收者在序列化方面是否兼容。 如果接收方使用不同的 &lt;code&gt;serialVersionID&lt;/code&gt; 加载了该类，则反序列化将以 &lt;code&gt;InvalidClassCastException&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="1d97b707c46087aba1ebb616cb1580f6fcc1274c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deserialization&lt;/strong&gt;: At the time of deserialization, receiver side JVM will compare the unique ID associated with the Object with local class Unique ID i.e. JVM will also create a Unique ID based on the corresponding .class file which is present in the receiver system. If both unique ID matched then only deserialization will be performed. Otherwise we will get Runtime Exception saying InvalidClassException. This unique Identifier is nothing but SerialVersionUID</source>
          <target state="translated">&lt;strong&gt;反序列化&lt;/strong&gt; ：反序列化时，接收方JVM会将与对象关联的唯一ID与本地类Unique ID进行比较，即JVM还将基于接收方系统中存在的相应.class文件创建唯一ID。 如果两个唯一的ID都匹配，则将仅执行反序列化。 否则，我们将获得Runtime Exception，显示InvalidClassException。 这个唯一的标识符不过是SerialVersionUID</target>
        </trans-unit>
        <trans-unit id="3611972f0d9f9281ab9d85aadd31fd689c683b66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Serialization&lt;/strong&gt; : At the time of serialization, with every object sender side JVM will save a Unique Identifier. JVM is responsible to generate that unique ID based on the corresponding .class file which is present in the sender system.</source>
          <target state="translated">&lt;strong&gt;序列化&lt;/strong&gt; ： &lt;strong&gt;在进行序列&lt;/strong&gt;化时，每个对象发送方JVM都会保存一个唯一标识符。 JVM负责根据发送方系统中存在的相应.class文件生成该唯一ID。</target>
        </trans-unit>
        <trans-unit id="31c4af730de1ec78e966df4a893d337e4ba48a74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Serialization&lt;/strong&gt; allows to convert an object to a stream, for sending that object over the network OR Save to file OR save into DB for letter usage.</source>
          <target state="translated">&lt;strong&gt;序列化&lt;/strong&gt;允许将对象转换为流，以便通过网络发送该对象，或者保存到文件或保存到DB以供使用。</target>
        </trans-unit>
        <trans-unit id="18b104d3665872daa5a5d62b3dfa2e04e0257aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html&quot;&gt;javadocs for &lt;code&gt;Serializable&lt;/code&gt;&lt;/a&gt; say&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html&quot;&gt;用于 &lt;code&gt;Serializable&lt;/code&gt; &lt;/a&gt;的javadocs说&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="8e10ad6fb571714fdcf9a3637d45c19079faf5d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Therefore, you must declare serialVersionUID because it give us more control&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;因此，您必须声明serialVersionUID，因为它可以提供更多控制权&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b2511b1f1436c52f14967962e20cf606bc903d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why use &lt;code&gt;SerialVersionUID&lt;/code&gt; inside &lt;code&gt;Serializable&lt;/code&gt; class in Java?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为什么要在Java的 &lt;code&gt;Serializable&lt;/code&gt; 类中使用 &lt;code&gt;SerialVersionUID&lt;/code&gt; ？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="906fd73871d1746cd0dbcce791e6b9af3918c01b" translate="yes" xml:space="preserve">
          <source>A Simple Explanation:</source>
          <target state="translated">一个简单的解释。</target>
        </trans-unit>
        <trans-unit id="66821acf6e7624406be47725b2e7ce84257cd34d" translate="yes" xml:space="preserve">
          <source>A serializable class can declare its own &lt;code&gt;serialVersionUID&lt;/code&gt; explicitly by declaring a field named &lt;code&gt;serialVersionUID&lt;/code&gt; that must be static, final, and of type long.</source>
          <target state="translated">可序列化的类可以通过声明一个名为 &lt;code&gt;serialVersionUID&lt;/code&gt; 的字段来显式声明其自己的 &lt;code&gt;serialVersionUID&lt;/code&gt; ，该字段必须是静态的，最终的且类型为long。</target>
        </trans-unit>
        <trans-unit id="556d6d8a3cc094128082980ca2daa51184075bf6" translate="yes" xml:space="preserve">
          <source>All primitive types are serializable.</source>
          <target state="translated">所有的基元类型都是可序列化的。</target>
        </trans-unit>
        <trans-unit id="d43fa2e365573ac0634d4f96ed28d42f8662274d" translate="yes" xml:space="preserve">
          <source>An object is serializable (itself implements the Serializable interface) even if its superclass is not. However, the first superclass in the hierarchy of the serializable class, that does not implements Serializable interface, MUST have a no-arg constructor. If this is violated, readObject() will produce a java.io.InvalidClassException in runtime</source>
          <target state="translated">一个对象是可序列化的(本身就实现了Serializable接口),即使它的超类不是可序列化的。但是,在可序列化类的层次结构中,不实现Serializable接口的第一个超类必须有一个no-arg构造函数。如果违反了这一点,readObject()将在运行时产生一个java.io.InvalidClassException。</target>
        </trans-unit>
        <trans-unit id="54df990ab20da4ab5e0367e31d19258eae93b03c" translate="yes" xml:space="preserve">
          <source>An object is serializable only if its class or its superclass implements the Serializable interface</source>
          <target state="translated">只有当一个对象的类或超类实现了Serializable接口时,该对象才是可序列化的。</target>
        </trans-unit>
        <trans-unit id="120beec47d411d244e0c08a4eeab6eafbb379de8" translate="yes" xml:space="preserve">
          <source>And execute the Reader class. Not to execute the Writer class and you will get the exception.</source>
          <target state="translated">并执行Reader类。不执行Writer类,你会得到异常。</target>
        </trans-unit>
        <trans-unit id="4e349787e0377c85e41bb4d42d6bd546a8bc2877" translate="yes" xml:space="preserve">
          <source>And if you are backwards-compatible with your data like in the first use case mentioned, you also probably want to maintain the id yourself. This in order to get readable ids and have greater control over when and how they change.</source>
          <target state="translated">而且,如果你的数据像前面提到的第一个用例中的数据是向后兼容的,你可能也想自己维护id。这样做的目的是为了获得可读的id,并且可以更好地控制它们的变化时间和变化方式。</target>
        </trans-unit>
        <trans-unit id="024a99db1a896209169c95029b3ce0b2e534afa2" translate="yes" xml:space="preserve">
          <source>Are you serializing data?</source>
          <target state="translated">你是在对数据进行序列化吗?</target>
        </trans-unit>
        <trans-unit id="990a8adcbdfa167776667defea795dc3025b128a" translate="yes" xml:space="preserve">
          <source>As for an example where the missing serialVersionUID might cause a problem:</source>
          <target state="translated">至于缺少serialVersionUID可能导致问题的例子。</target>
        </trans-unit>
        <trans-unit id="5617b7140b809d418d5e0a3baee83574e9a69131" translate="yes" xml:space="preserve">
          <source>Basically, if you don't update the version correctly when you update a class you need to write/read, you will get an error when you try to read old data.</source>
          <target state="translated">基本上,如果你在更新需要writeread的类时没有正确更新版本,那么当你尝试读取旧数据时就会得到一个错误。</target>
        </trans-unit>
        <trans-unit id="55c6075806e02d97bac769299a54d457a38e7da7" translate="yes" xml:space="preserve">
          <source>But in case if serialVersionUID is not specified by programmer then while doing Serialization\DeSerialization  of any object, Java runtime uses its own algorithm to calculate it. This serialVersionUID calculation algorithm varies from one JRE to another. It is also possible that the environment where the object is serialized is using one JRE (ex: SUN JVM) and the environment where deserialzation happens is using Linux Jvm(zing). In such cases serialVersionUID associated with serialized object will be different than the serialVersionUID of class calculated at deserialzation environment. In turn deserialization will not be successful. So to avoid such situations/issues programmer must always specify serialVersionUID of Serializable class.</source>
          <target state="translated">但是如果serialVersionUID没有被程序员指定,那么在对任何对象进行Serialization/DeSerialization的时候,Java运行时使用自己的算法来计算。这个serialVersionUID的计算算法在不同的JRE中是不同的。也有可能对象被序列化的环境是使用一个JRE(例如:SUN JVM),而解序列化的环境是使用Linux Jvm(zing)。在这种情况下,与序列化对象关联的serialVersionUID将与deserialzation环境下计算出的类的serialVersionUID不同。反过来,反过来,反串化也会不成功。所以为了避免这种情况的发生,程序员必须始终指定Serializable类的serialVersionUID。</target>
        </trans-unit>
        <trans-unit id="457b19bd79bfb1a9a50bc7b4969edb6b2b5a1036" translate="yes" xml:space="preserve">
          <source>But storing serialized data for such a long time span is not very common. It is far more common to use the serialization mechanism to temporarily write data to for instance a cache or send it over the network to another program with the same version of the relevant parts of the codebase.</source>
          <target state="translated">但存储如此长的时间跨度的序列化数据并不常见。使用序列化机制将数据临时写入缓存或通过网络将其发送到另一个具有相同版本的相关部分的代码库的程序中,使用序列化机制将数据临时写入缓存或通过网络发送到另一个具有相同版本的相关部分的程序中,这种情况要常见得多。</target>
        </trans-unit>
        <trans-unit id="8003df6d5412c6d8396be6f1aef4f95fe379408b" translate="yes" xml:space="preserve">
          <source>But there is a backside to the auto-generated id strategy. Namely that the generated ids for the same class might differ between compilers (as mentioned by Jon Skeet above). So if you communicate serialized data between code compiled with different compilers, it is recommended to maintain the ids manually anyway.</source>
          <target state="translated">但是,自动生成id策略也有其背后的原因。也就是说,同一个类的生成的id可能会在不同的编译器之间产生不同的id(正如Jon Skeet在上面提到的那样)。因此,如果你在不同编译器编译的代码之间通信序列化数据,建议无论如何都要手动维护id。</target>
        </trans-unit>
        <trans-unit id="7ced4cd1b424dc1e6c6a97cd9e87f8103ee0a11a" translate="yes" xml:space="preserve">
          <source>Code : &lt;a href=&quot;http://www.grepcode.com/file/repository.jboss.org/nexus/content/repositories/releases/org.jboss/javassist/3.5.GA/javassist/SerialVersionUID.java#SerialVersionUID&quot;&gt; javassist.SerialVersionUID&lt;/a&gt;</source>
          <target state="translated">代码： &lt;a href=&quot;http://www.grepcode.com/file/repository.jboss.org/nexus/content/repositories/releases/org.jboss/javassist/3.5.GA/javassist/SerialVersionUID.java#SerialVersionUID&quot;&gt;javassist.SerialVersionUID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e5e4a12dcab3bcdfbbaf20c3c92f7572e7246b3" translate="yes" xml:space="preserve">
          <source>Consider a situation - in the future you need to edit or change your class and in that case when you modify it, JVM will assign it a new UID (Suppose #444).
Now when you try to deserialize the employee object, JVM will compare serialized object's (Employee object) version ID(#333) with that of the class i.e #444(Since it was changed). On comparison JVM will find both version UID are different and hence Deserialization will fail.
Hence if serialVersionID for each class is defined by programmer itself. It will be same even if the class is evolved in future and hence JVM will always find that class is compatible with serialized object even though the class is changed. For more Info you can refer chapter 14 of HEAD FIRST JAVA.</source>
          <target state="translated">考虑一个情况--将来你需要编辑或修改你的类,在这种情况下,当你修改类时,JVM会给它分配一个新的UID(假设#444)。现在,当你尝试反序列化雇员对象时,JVM会将序列化对象(Employee对象)的版本ID(#333)与类的版本ID(即#444(因为它被修改了)进行比较。)比较后JVM会发现两个版本ID都不一样,因此Deserialization将失败。因此,如果每个类的serialVersionID是由程序员自己定义的。即使将来这个类被进化了,它也是一样的,因此,即使类被改变了,JVM也会发现该类与序列化对象是兼容的。更多信息可以参考《HEAD FIRST JAVA》第14章。</target>
        </trans-unit>
        <trans-unit id="902d3e9c0ce16116737e84feb71557afde91dc0f" translate="yes" xml:space="preserve">
          <source>Create Serialize Object</source>
          <target state="translated">创建序列化对象</target>
        </trans-unit>
        <trans-unit id="a2c7e5486a3f344d56945a7b650dedf412ef8c59" translate="yes" xml:space="preserve">
          <source>Deserialize the object</source>
          <target state="translated">反序列化对象</target>
        </trans-unit>
        <trans-unit id="8f2b733e756af21d1abfdca922137f6588c4d570" translate="yes" xml:space="preserve">
          <source>Do you intend to go into production?</source>
          <target state="translated">你打算投入生产吗?</target>
        </trans-unit>
        <trans-unit id="5e81f5fe3485373a7732e86888657bf7a3c0c5c1" translate="yes" xml:space="preserve">
          <source>Don't bother, the default calculation is really good and suffice for 99,9999% of the cases. And if you run into problems, you can - as already stated - introduce UID's as the need arrise (which is highly unlikely)</source>
          <target state="translated">不用麻烦了,默认的计算方法真的很好,可以满足99,999999%的情况。如果你遇到问题,你可以----如前所述----引入UID's,因为需要的时候就会出现(这是很不可能的)。</target>
        </trans-unit>
        <trans-unit id="74c2664cf2e007e8a6e348e6437ca8eb3c97da2b" translate="yes" xml:space="preserve">
          <source>During &lt;code&gt;serialization&lt;/code&gt;, Java runtime creates a version number for a class, so that it can de-serialize it later. This version number is known as &lt;code&gt;SerialVersionUID&lt;/code&gt; in Java.</source>
          <target state="translated">在 &lt;code&gt;serialization&lt;/code&gt; ，Java运行时会为一个类创建一个版本号，以便以后可以反序列化它。 此版本号在Java中称为 &lt;code&gt;SerialVersionUID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c63d27dfd00d72f5fa3a4a275d1170052a3bb2f1" translate="yes" xml:space="preserve">
          <source>Each time an object is serialized the object is stamped with a version ID number for the object's class.This ID is called &lt;a href=&quot;https://stackoverflow.com/q/285793/1387612&quot;&gt;serialVersionUID&lt;/a&gt; and it is computed based on information about the class structure. Suppose you made an Employee class and it has version id #333 (assigned by JVM),Now when you will serialize the object of that class (Suppose Employee object), JVM will assign UID to it as #333.</source>
          <target state="translated">每次对对象进行序列化时，都会在该对象上标记该对象的类的版本ID号。此ID称为&lt;a href=&quot;https://stackoverflow.com/q/285793/1387612&quot;&gt;serialVersionUID&lt;/a&gt; ，它是基于有关类结构的信息计算的。 假设您创建了一个Employee类，并且它的版本ID为＃333（由JVM分配），现在，当您要序列化该类的对象（假设Employee对象）时，JVM将为其分配UID为＃333。</target>
        </trans-unit>
        <trans-unit id="331fe5b32b63711ced0f4688764ea82b15eb25d9" translate="yes" xml:space="preserve">
          <source>Eclipse issues warnings when a &lt;code&gt;serialVersionUID&lt;/code&gt; is missing.</source>
          <target state="translated">当缺少 &lt;code&gt;serialVersionUID&lt;/code&gt; 时，Eclipse会发出警告。</target>
        </trans-unit>
        <trans-unit id="e0c7125d853c45b42db053d4899fe4ccc120bba6" translate="yes" xml:space="preserve">
          <source>Field data represents some information stored in the class.
Class implements the &lt;code&gt;Serializable&lt;/code&gt; interface, 
so eclipse automatically offered  to declare the &lt;code&gt;serialVersionUID&lt;/code&gt; field. Lets start with value 1 set there.</source>
          <target state="translated">字段数据代表存储在类中的一些信息。 类实现了 &lt;code&gt;Serializable&lt;/code&gt; 接口，因此会自动提供eclipse来声明 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段。 让我们从此处设置的值1开始。</target>
        </trans-unit>
        <trans-unit id="9255cfa2633d6dd855930279962514319145eb54" translate="yes" xml:space="preserve">
          <source>First I need to explain what serialization is.</source>
          <target state="translated">首先,我需要解释一下什么是序列化。</target>
        </trans-unit>
        <trans-unit id="fe5f947543d44552ac4a1c1ce2bff62f622221de" translate="yes" xml:space="preserve">
          <source>Firstly to answer your question, when we don't declare SerialVersionUID in our class, Java runtime generates it for us, but that process is sensitive to many class meta data including number of fields, type of fields, access modifier of fields, interface implemented by class etc. Therefore it is recommended to declare it ourselves and Eclipse is warning you about the same.</source>
          <target state="translated">首先回答你的问题,当我们不在类中声明SerialVersionUID时,Java运行时会为我们生成SerialVersionUID,但这个过程对很多类的元数据很敏感,包括字段的数量、字段的类型、字段的访问修改器、类实现的接口等。因此,建议我们自己声明,Eclipse也在此提醒大家。</target>
        </trans-unit>
        <trans-unit id="04de54a57ab3959800eb0f2842888d4560a529c7" translate="yes" xml:space="preserve">
          <source>For all other cases, I use</source>
          <target state="translated">对于所有其他情况,我使用</target>
        </trans-unit>
        <trans-unit id="fd012c69d903deb492c73342fac8be0cf73138e4" translate="yes" xml:space="preserve">
          <source>Here is a nice explanation based on the scenario,</source>
          <target state="translated">下面是根据剧情进行的精彩讲解。</target>
        </trans-unit>
        <trans-unit id="03bf07f9d1a8bddc0829166a5de4a331ab54be58" translate="yes" xml:space="preserve">
          <source>I can't pass up this opportunity to plug Josh Bloch's book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;Effective Java&lt;/a&gt; (2nd Edition).  Chapter 11 is an indispensible resource on Java serialization.</source>
          <target state="translated">我不能错过这个机会来插上乔什&amp;middot;布洛赫（Josh Bloch）的书《 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;有效的Java》&lt;/a&gt; （第二版）。 第11章是Java序列化必不可少的资源。</target>
        </trans-unit>
        <trans-unit id="1731a106e7d9ee245acefeb0e9a165e8688028b6" translate="yes" xml:space="preserve">
          <source>I generally use &lt;code&gt;serialVersionUID&lt;/code&gt; in one context:  When I know it will be leaving the context of the Java VM.</source>
          <target state="translated">我通常在一种上下文中使用 &lt;code&gt;serialVersionUID&lt;/code&gt; ：当我知道它将离开Java VM的上下文时。</target>
        </trans-unit>
        <trans-unit id="1d30080cfbbac6f31768acf23476d4f58cc248ff" translate="yes" xml:space="preserve">
          <source>I often see people extending JFrame or such, when they really only need to delegate to this. (This also helps for auto-completing in a IDE, since JFrame has hundreds of methods, which you don't need when you want to call your custom ones on your class.)</source>
          <target state="translated">我经常看到有人在扩展JFrame之类的东西,当他们真的只需要委托给这个东西的时候。(这对IDE中的自动完成也有帮助,因为JFrame有几百个方法,当你想在类上调用你的自定义方法时,你不需要这些方法)。</target>
        </trans-unit>
        <trans-unit id="4528b507df7e1b4debb62b589fdb1fbf11ea6c69" translate="yes" xml:space="preserve">
          <source>I would know this when I to use &lt;code&gt;ObjectInputStream&lt;/code&gt; and &lt;code&gt;ObjectOutputStream&lt;/code&gt; for my application or if I know a library/framework I use will use it.  The serialVersionID ensures different Java VMs of varying versions or vendors will inter-operate correctly or if it is stored and retrieved outside the VM for example &lt;code&gt;HttpSession&lt;/code&gt; the session data can remain even during a restart and upgrade of the application server.</source>
          <target state="translated">当我为应用程序使用 &lt;code&gt;ObjectInputStream&lt;/code&gt; 和 &lt;code&gt;ObjectOutputStream&lt;/code&gt; 时 ，或者如果我知道我使用的库/框架将使用它时，我就会知道这一点。 serialVersionID确保不同版本的不同Java VM或供应商可以正确互操作，或者确保在JavaHttp VM外部存储和检索Java Java，即使重新启动和升级应用程序服务器，会话数据也可以保留。</target>
        </trans-unit>
        <trans-unit id="4aebc60c47be3376f3219f82f5a1bf8f6060cdc5" translate="yes" xml:space="preserve">
          <source>I'm working on this Java EE application that is composed of a Web module that uses an &lt;code&gt;EJB&lt;/code&gt; module. The web module calls the &lt;code&gt;EJB&lt;/code&gt; module remotely and passes a &lt;code&gt;POJO&lt;/code&gt; that implements &lt;code&gt;Serializable&lt;/code&gt; as an argument.</source>
          <target state="translated">我正在研究由使用 &lt;code&gt;EJB&lt;/code&gt; 模块的Web模块组成的Java EE应用程序。 该Web模块远程调用 &lt;code&gt;EJB&lt;/code&gt; 模块，并传递一个实现 &lt;code&gt;Serializable&lt;/code&gt; 作为参数的 &lt;code&gt;POJO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbb6c65af6ba4f01642221360b8825a38d164609" translate="yes" xml:space="preserve">
          <source>If a serializable class do not explicitly declare a serialVersionUID, then serialization runtime will calculate  serialVersionUID value for that class based on various aspects of the class like fields, methods etc.,, You can refer this &lt;a href=&quot;https://self-learning-java-tutorial.blogspot.com/2014/09/serialversionuid.html&quot;&gt;link&lt;/a&gt; for demo application.</source>
          <target state="translated">如果可序列化的类未明确声明serialVersionUID，则序列化运行时将基于类的各个方面（例如字段，方法等）为该类计算serialVersionUID值，您可以参考此&lt;a href=&quot;https://self-learning-java-tutorial.blogspot.com/2014/09/serialversionuid.html&quot;&gt;链接&lt;/a&gt;以进行演示应用程序。</target>
        </trans-unit>
        <trans-unit id="79176b9cada3ecc6f3cdbdbe22c62b8fa2c5bd9b" translate="yes" xml:space="preserve">
          <source>If a serializable class does not explicitly declare a &lt;code&gt;serialVersionUID&lt;/code&gt;, then the serialization runtime will calculate a default &lt;code&gt;serialVersionUID&lt;/code&gt; value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is &lt;em&gt;strongly recommended&lt;/em&gt; that all serializable classes explicitly declare &lt;code&gt;serialVersionUID&lt;/code&gt; values, since the default &lt;code&gt;serialVersionUID&lt;/code&gt; computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected &lt;code&gt;InvalidClassExceptions&lt;/code&gt; during deserialization. Therefore, to guarantee a consistent &lt;code&gt;serialVersionUID&lt;/code&gt; value across different java compiler implementations, a serializable class must declare an explicit &lt;code&gt;serialVersionUID&lt;/code&gt; value. It is also strongly advised that explicit &lt;code&gt;serialVersionUID&lt;/code&gt; declarations use the private modifier where possible, since such declarations apply only to the immediately declaring class &lt;code&gt;serialVersionUID&lt;/code&gt; fields are not useful as inherited members.</source>
          <target state="translated">如果可序列化的类未明确声明 &lt;code&gt;serialVersionUID&lt;/code&gt; ，则序列化运行时将根据该类的各个方面为该类计算默认的 &lt;code&gt;serialVersionUID&lt;/code&gt; 值，如Java（TM）对象序列化规范中所述。 但是， &lt;em&gt;强烈建议&lt;/em&gt;所有可序列化的类显式声明 &lt;code&gt;serialVersionUID&lt;/code&gt; 值，因为默认的 &lt;code&gt;serialVersionUID&lt;/code&gt; 计算对类详细信息高度敏感，而类详细信息可能会根据编译器的实现而有所不同，因此可能在反序列化期间导致意外的 &lt;code&gt;InvalidClassExceptions&lt;/code&gt; 。 因此，为了保证不同Java编译器实现之间的 &lt;code&gt;serialVersionUID&lt;/code&gt; 值一致，可序列化的类必须声明一个显式的 &lt;code&gt;serialVersionUID&lt;/code&gt; 值。 还强烈建议显式 &lt;code&gt;serialVersionUID&lt;/code&gt; 声明在可能的情况下使用private修饰符，因为此类声明仅适用于立即声明的类 &lt;code&gt;serialVersionUID&lt;/code&gt; 字段作为继承成员不起作用。</target>
        </trans-unit>
        <trans-unit id="ac07961b643911ddcb2c896810537f0afd622445" translate="yes" xml:space="preserve">
          <source>If so, set &lt;code&gt;serialVersionUID=1L&lt;/code&gt;.</source>
          <target state="translated">如果是这样，请设置 &lt;code&gt;serialVersionUID=1L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4c50d35d2b9efc3203d7444d68cd27712448b2f" translate="yes" xml:space="preserve">
          <source>If the class is serializable you can also declare your own serialVersionUID explicitly  by declaring a field named &quot;serialVersionUID&quot; that must be static, final, and of type long. Most IDE's like Eclipse help you generate that long string.</source>
          <target state="translated">如果类是可序列化的,你也可以通过声明一个名为 &quot;serialVersionUID &quot;的字段来显式地声明你自己的serialVersionUID,这个字段必须是静态的、最终的、类型为长的。大多数IDE(如Eclipse)可以帮助你生成这个长字符串。</target>
        </trans-unit>
        <trans-unit id="0908a1a1336c6604f42496dbb63562f68b64f6fe" translate="yes" xml:space="preserve">
          <source>If you are just testing something with unimportant/fake data, then don't worry about it (unless you are testing serialization directly).</source>
          <target state="translated">如果你只是在测试一些不重要的fake数据的东西,那就不用担心(除非你是直接测试序列化)。</target>
        </trans-unit>
        <trans-unit id="8a69924d7d5897fafcf895033701a64bf405b8cf" translate="yes" xml:space="preserve">
          <source>If you do forget to update the field, you might end up with two different versions of a class with different structure but with the same &lt;code&gt;serialVersionUID&lt;/code&gt;. If this happens, the default mechanism (&lt;code&gt;in.defaultReadObject()&lt;/code&gt;) will not detect any difference, and try to de-serialize incompatible data. Now you might end up with a cryptic runtime error or silent failure (null fields). These types of errors might be hard to find.</source>
          <target state="translated">如果您忘记更新该字段，则可能会遇到具有不同结构但具有相同 &lt;code&gt;serialVersionUID&lt;/code&gt; 的类的两个不同版本。 如果发生这种情况，默认机制（ &lt;code&gt;in.defaultReadObject()&lt;/code&gt; ）将不会检测到任何差异，并尝试对不兼容的数据进行反序列化。 现在，您可能会遇到神秘的运行时错误或静默故障（空字段）。 这些类型的错误可能很难找到。</target>
        </trans-unit>
        <trans-unit id="951eb1700ec9d7b7fe70f87bfe0e3fabca70f057" translate="yes" xml:space="preserve">
          <source>If you don't want that warning to come, use this:</source>
          <target state="translated">如果你不想让那个警告来了,就用这个。</target>
        </trans-unit>
        <trans-unit id="759c21d48ab7d563cb615b405b767a40ee3165b5" translate="yes" xml:space="preserve">
          <source>If you get this warning on a class you don't ever think about serializing, and that you didn't declare yourself &lt;code&gt;implements Serializable&lt;/code&gt;, it is often because you inherited from a superclass, which implements Serializable. Often then it would be better to delegate to such a object instead of using inheritance.</source>
          <target state="translated">如果在类上收到此警告，则永远不要考虑进行序列化，并且也没有声明自己 &lt;code&gt;implements Serializable&lt;/code&gt; ，这通常是因为您从实现了Serializable的超类继承而来。 通常，最好委托给这样的对象，而不是使用继承。</target>
        </trans-unit>
        <trans-unit id="a4a72dc9110f96c64679ef74b8fdb11f2882cfd8" translate="yes" xml:space="preserve">
          <source>If you ignore them for now, and find later that you need to change the class in some way but maintain compatibility w/ old version of the class, you can use the JDK tool &lt;strong&gt;serialver&lt;/strong&gt; to generate the &lt;code&gt;serialVersionUID&lt;/code&gt; on the &lt;em&gt;old&lt;/em&gt; class, and explicitly set that on the new class.  (Depending on your changes you may need to also implement custom serialization by adding &lt;code&gt;writeObject&lt;/code&gt; and &lt;code&gt;readObject&lt;/code&gt; methods - see &lt;code&gt;Serializable&lt;/code&gt; javadoc or aforementioned chapter 11.)</source>
          <target state="translated">如果您现在暂时忽略它们，然后在以后发现需要以某种方式更改该类但保持与该类的旧版本的兼容性，则可以使用JDK工具&lt;strong&gt;serialver&lt;/strong&gt;在&lt;em&gt;旧&lt;/em&gt;类上生成 &lt;code&gt;serialVersionUID&lt;/code&gt; ，并进行显式设置在新班上。 （根据您的更改，您可能还需要通过添加 &lt;code&gt;writeObject&lt;/code&gt; 和 &lt;code&gt;readObject&lt;/code&gt; 方法来实现自定义序列化-请参见 &lt;code&gt;Serializable&lt;/code&gt; javadoc或前面提到的第11章。）</target>
        </trans-unit>
        <trans-unit id="a5fe6571b7d4d90271296db8f6745f9d44b41fb5" translate="yes" xml:space="preserve">
          <source>If you want to amend a huge number of classes which had no serialVersionUID set in the first place while maintain the compatibility with the old classes, tools like IntelliJ Idea, Eclipse fall short as they generate random numbers and does not work on a bunch of files in one go. I come up the following bash script(I'm sorry for Windows users, consider buy a Mac or convert to Linux) to make amending serialVersionUID issue with ease:</source>
          <target state="translated">如果你想修改大量没有设置serialVersionUID的类,而又要保持与旧类的兼容性,像IntelliJ Idea、Eclipse这样的工具就很难做到,因为它们会产生随机数字,而且不能一次性地对一堆文件进行修改。我想出了下面这个bash脚本(抱歉,Windows用户可以考虑买个Mac或者改成Linux),可以轻松修改serialVersionUID问题。</target>
        </trans-unit>
        <trans-unit id="47e78ed2014802b0c9a3a92e7fdf1eafb51b07c7" translate="yes" xml:space="preserve">
          <source>If you want to version your data, you normally start with a &lt;code&gt;serialVersionUID&lt;/code&gt; of 0, and bump it with every structural change to your class which alters the serialized data (adding or removing non-transient fields).</source>
          <target state="translated">如果要对数据进行版本控制，通常以 &lt;code&gt;serialVersionUID&lt;/code&gt; 0开头，然后对类进行每次结构更改，以改变序列化的数据（添加或删除非瞬态字段），然后对其进行修改。</target>
        </trans-unit>
        <trans-unit id="92d52d748e3a903cd8cfe5335e2f7600d6a4d99c" translate="yes" xml:space="preserve">
          <source>If you will never need to serialize your objects to byte array and send/store them, then you don't need to worry about it. If you do, then you must consider your serialVersionUID since the deserializer of the object will match it to the version of object its classloader has. Read more about it in the Java Language Specification.</source>
          <target state="translated">如果你永远不需要将对象序列化为字节数组并发送存储,那么你就不需要担心这个问题。如果你需要,那么你必须考虑你的serialVersionUID,因为对象的反序列化器会把它和它的classloader所拥有的对象版本相匹配。请在Java语言规范中阅读更多关于它的内容。</target>
        </trans-unit>
        <trans-unit id="43fdca2264665fac30b5995e1d2da647337a6fbf" translate="yes" xml:space="preserve">
          <source>If you're actually using serialization, it only matters if you plan on storing and retrieving objects using serialization directly.  The &lt;code&gt;serialVersionUID&lt;/code&gt; represents your class version, and you should increment it if the current version of your class is not backwards compatible with its previous version.</source>
          <target state="translated">如果您实际上正在使用序列化，则仅在计划直接使用序列化存储和检索对象时才重要。 &lt;code&gt;serialVersionUID&lt;/code&gt; 代表您的类版本，如果您的类的当前版本与它的先前版本不向后兼容，则应该递增它。</target>
        </trans-unit>
        <trans-unit id="9128ba1afb3e0f24bb0e62ed32e59ef238f14973" translate="yes" xml:space="preserve">
          <source>If you're serializing just because you have to serialize for the implementation's sake (who cares if you serialize for an &lt;code&gt;HTTPSession&lt;/code&gt;, for instance...if it's stored or not, you probably don't care about &lt;code&gt;de-serializing&lt;/code&gt; a form object), then you can ignore this.</source>
          <target state="translated">如果您只是为了实现的需要而进行序列化（例如，谁在乎是否为 &lt;code&gt;HTTPSession&lt;/code&gt; 进行序列化，...是否存储了 &lt;code&gt;de-serializing&lt;/code&gt; ，则可能不关心对序列对象进行反序列化 ）而进行序列化 ，那么您可以忽略此。</target>
        </trans-unit>
        <trans-unit id="be310d22adb7eb6ed4cdc4f31b81e366e345fd16" translate="yes" xml:space="preserve">
          <source>In case you didn't know, there are a lot of other warnings you can enable in this section (or even have some reported as errors), many are very useful:</source>
          <target state="translated">以防你不知道,在这一节中还有很多其他的警告可以启用(甚至有的还会被报告为错误),很多都是非常有用的。</target>
        </trans-unit>
        <trans-unit id="8b137380d829b068c0e1561e7670589d03744bf7" translate="yes" xml:space="preserve">
          <source>In this case you are not interested in maintaining backwards compatibility. You are only concerned with making sure that the code bases which are communicating indeed have the same versions of relevant classes. In order to facilitate such a check, you must maintain the &lt;code&gt;serialVersionUID&lt;/code&gt; just like before and not forget to update it when making changes to your classes.</source>
          <target state="translated">在这种情况下，您对保持向后兼容性不感兴趣。 您只关心确保正在通信的代码库确实具有相同版本的相关类。 为了便于进行此类检查，您必须像以前一样维护 &lt;code&gt;serialVersionUID&lt;/code&gt; ，并且在对类进行更改时不要忘记对其进行更新。</target>
        </trans-unit>
        <trans-unit id="61679231af4ad410dbfa2dd92c43eea9061a90d9" translate="yes" xml:space="preserve">
          <source>Is this the first version?</source>
          <target state="translated">这是第一个版本吗?</target>
        </trans-unit>
        <trans-unit id="2a229b4a574a575150819f17c367c9fd921fd37d" translate="yes" xml:space="preserve">
          <source>Is this the second, third, etc. prod version?</source>
          <target state="translated">这是第二版、第三版等等的prod版吗?</target>
        </trans-unit>
        <trans-unit id="a2d78a74baa97f72bc98472f33a22bf2ab946a4e" translate="yes" xml:space="preserve">
          <source>It would be nice if CheckStyle could verify that the serialVersionUID on a class that implements Serializable has a good value, i.e. that it matches what the serial version id  generator would produce.  If you have a project with lots of serializable DTOs, for example, remembering to delete the existing serialVersionUID and regenerate it is a pain, and currently the only way (that I know of) to verify this is to regenerate for each class and compare to the old one.  This is very very painful.</source>
          <target state="translated">如果CheckStyle能够验证实现Serializable的类上的serialVersionUID有一个好的值,也就是说,它与序列版本ID生成器生成的序列版本ID相匹配,那就更好了。如果你有一个有很多可序列化的DTO的项目,比如说,记得删除现有的serialVersionUID并重新生成它是一件很痛苦的事情,目前唯一的验证方法(据我所知)就是为每个类重新生成并与旧的类进行比较。这样做是非常非常痛苦的。</target>
        </trans-unit>
        <trans-unit id="45452c347dba4596f7fc6f779b60255c33b9b741" translate="yes" xml:space="preserve">
          <source>Least obvious - Sometimes you change the idea you put in some field's meaning. For example when you are 12 years old you mean &quot;bicycle&quot; under &quot;bike&quot;, but when you are 18 you mean &quot;motorcycle&quot; - if your friends will invite you to &quot;bike ride across city&quot; and you will be the only one who came on bicycle, you will undestand how important it is to keep same meaning across fields :-)</source>
          <target state="translated">最不明显的--有时候你会改变你在某些领域的意思的想法。例如,当你12岁的时候,你的意思是 &quot;自行车 &quot;下的 &quot;自行车&quot;,但当你18岁的时候,你的意思是 &quot;摩托车&quot;--如果你的朋友邀请你去 &quot;骑自行车穿越城市&quot;,而你是唯一一个骑自行车来的人,你就会明白,在不同的领域保持相同的意思是多么重要的事情:-)</target>
        </trans-unit>
        <trans-unit id="92b2158c9da67c9bc8cebe83d5a434148a52fd77" translate="yes" xml:space="preserve">
          <source>Less obvious - When you deserialize object, fields that where not present in string will be kept as NULL. If you have removed field from your object, older versions will keep this field as allways-NULL that can lead to misbehavior if older versions rely on data in this field (anyway you have created it for something, not just for fun :-) )</source>
          <target state="translated">不太明显-当你反序列化对象时,字符串中不存在的字段将被保留为NULL。如果你从你的对象中删除了字段,旧版本会把这个字段保留为always-NULL,如果旧版本依赖这个字段中的数据,可能会导致错误的行为(无论如何,你创建这个字段是为了什么,而不是为了好玩)。</target>
        </trans-unit>
        <trans-unit id="f39b41b433bf1ccbaddc2f3409f68a365496127f" translate="yes" xml:space="preserve">
          <source>Let's try this with an example.</source>
          <target state="translated">我们用一个例子来试一试。</target>
        </trans-unit>
        <trans-unit id="18e32355c6b6633308045dc45a2607e31ca575a8" translate="yes" xml:space="preserve">
          <source>Most obvious - if you add some fields to your object, older versions will not be able to use them because they do not have these fields in their object structure.</source>
          <target state="translated">最明显的是--如果你在对象中添加一些字段,旧版本将无法使用这些字段,因为它们在对象结构中没有这些字段。</target>
        </trans-unit>
        <trans-unit id="669226aa9f0c15ca8184278e717e0a11aea7ad79" translate="yes" xml:space="preserve">
          <source>Most of the time, you will probably not use serialization directly.  If this is the case, generate a default &lt;code&gt;SerialVersionUID&lt;/code&gt; by clicking the quick fix option and don't worry about it.</source>
          <target state="translated">大多数时候，您可能不会直接使用序列化。 如果是这种情况， &lt;code&gt;SerialVersionUID&lt;/code&gt; 通过单击快速修复选项来生成默认的SerialVersionUID ，不用担心。</target>
        </trans-unit>
        <trans-unit id="03db456b4b5f92dd61b1356634c41f730702aac1" translate="yes" xml:space="preserve">
          <source>NOTE: Now change the serialVersionUID of the Employee class and save:</source>
          <target state="translated">注意:现在更改Employee类的serialVersionUID并保存。</target>
        </trans-unit>
        <trans-unit id="dfaed926e28cd77167b75a9487c6069d6863f33d" translate="yes" xml:space="preserve">
          <source>Now you need to worry about &lt;code&gt;serialVersionUID&lt;/code&gt;, and should look into it in depth.</source>
          <target state="translated">现在，您需要担心 &lt;code&gt;serialVersionUID&lt;/code&gt; ，并应该对其进行深入研究。</target>
        </trans-unit>
        <trans-unit id="82faeed0157b5916b620f337d6af90d923051ddd" translate="yes" xml:space="preserve">
          <source>One case where the warning (or the serialVersionUID) is unavoidable is when you extend from AbstractAction, normally in a anonymous class, only adding the actionPerformed-method. I think there shouldn't be a warning in this case (since you normally can't reliable serialize and deserialize such anonymous classes anyway accross different versions of your class), but I'm not sure how the compiler could recognize this.</source>
          <target state="translated">有一种情况下,警告(或serialVersionUID)是不可避免的,那就是当你从AbstractAction扩展,通常是在一个匿名类中,只添加了actionPerformed-method。我认为在这种情况下不应该有警告(因为通常情况下,你不能可靠地对这种匿名类进行序列化和反序列化,无论如何也不能对不同版本的类进行序列化),但我不确定编译器如何识别这种情况。</target>
        </trans-unit>
        <trans-unit id="e369a1bf1e8a1cf49b05c9badf1d38385d36fce2" translate="yes" xml:space="preserve">
          <source>Original question has asked for 'why is it important' and 'example' where this &lt;code&gt;Serial Version ID&lt;/code&gt; would be useful. Well I have found one.</source>
          <target state="translated">最初的问题要求&amp;ldquo;为什么如此重要&amp;rdquo;和&amp;ldquo;示例&amp;rdquo;，在此示例中此 &lt;code&gt;Serial Version ID&lt;/code&gt; 会有用。 好吧，我找到了一个。</target>
        </trans-unit>
        <trans-unit id="fc9f0a13cf25ff497bc08bf7b647cdd500b7bf4a" translate="yes" xml:space="preserve">
          <source>Per Josh, the automatically-generated UID is generated based on a class name, implemented interfaces, and all public and protected members.  Changing any of these in any way will change the &lt;code&gt;serialVersionUID&lt;/code&gt;.  So you don't need to mess with them only if you are certain that no more than one version of the class will ever be serialized (either across processes or retrieved from storage at a later time).</source>
          <target state="translated">Per Josh会根据类名称，已实现的接口以及所有公共成员和受保护成员来生成自动生成的UID。 以任何方式更改其中任何一个都将更改 &lt;code&gt;serialVersionUID&lt;/code&gt; 。 因此，仅在确定不会对一个以上版本的类进行序列化（跨进程或在以后的时间从存储中检索）时，您才无需弄乱它们。</target>
        </trans-unit>
        <trans-unit id="2b4f26b8feb8f937d7254f3894358897952b1658" translate="yes" xml:space="preserve">
          <source>Potential Programming Problems: Null pointer access</source>
          <target state="translated">潜在的编程问题。空指针访问</target>
        </trans-unit>
        <trans-unit id="8d7e6c1f080cc867a97ebca251cf8c9fb3e16838" translate="yes" xml:space="preserve">
          <source>Potential Programming Problems: Possible accidental boolean assignment</source>
          <target state="translated">潜在的编程问题。可能出现的意外布林分配</target>
        </trans-unit>
        <trans-unit id="8b5ec26f30c3fea832b7f1abbafeeb9897906405" translate="yes" xml:space="preserve">
          <source>Read more: &lt;a href=&quot;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&quot;&gt;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&lt;/a&gt;</source>
          <target state="translated">了解更多： &lt;a href=&quot;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&quot;&gt;http&lt;/a&gt; : //javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ</target>
        </trans-unit>
        <trans-unit id="39f3eac3245d6e2e25325a60e97f8a037e33f3f7" translate="yes" xml:space="preserve">
          <source>Say you create a &lt;code&gt;Car&lt;/code&gt; class, instantiate it, and write it out to an object stream. The flattened car object sits in the file system for some time. Meanwhile, if the &lt;code&gt;Car&lt;/code&gt; class is modified by adding a new field. Later on, when you try to read (i.e. deserialize) the flattened &lt;code&gt;Car&lt;/code&gt; object, you get the &lt;code&gt;java.io.InvalidClassException&lt;/code&gt; &amp;ndash; because all serializable classes are automatically given a unique identifier. This exception is thrown when the identifier of the class is not equal to the identifier of the flattened object. If you really think about it, the exception is thrown because of the addition of the new field. You can avoid this exception being thrown by controlling the versioning yourself by declaring an explicit serialVersionUID. There is also a small performance benefit in explicitly declaring your &lt;code&gt;serialVersionUID&lt;/code&gt; (because does not have to be calculated). So, it is best practice to add your own serialVersionUID to your Serializable classes as soon as you create them as shown below:</source>
          <target state="translated">假设您创建一个 &lt;code&gt;Car&lt;/code&gt; 类，实例化它，并将其写到对象流中。 展平的汽车对象在文件系统中放置了一段时间。 同时，如果通过添加新字段来修改 &lt;code&gt;Car&lt;/code&gt; 类。 稍后，当您尝试读取（即反序列化）展平的 &lt;code&gt;Car&lt;/code&gt; 对象时，将获得 &lt;code&gt;java.io.InvalidClassException&lt;/code&gt; -因为所有可序列化的类都会自动获得唯一的标识符。 当类的标识符不等于展平对象的标识符时，抛出此异常。 如果您确实考虑过，则会由于添加了新字段而引发异常。 您可以通过声明显式的serialVersionUID来控制版本，从而避免抛出此异常。 显式声明您的 &lt;code&gt;serialVersionUID&lt;/code&gt; 也有一个小的性能好处（因为不必计算）。 因此，最佳实践是在创建它们后立即将自己的serialVersionUID添加到Serializable类，如下所示：</target>
        </trans-unit>
        <trans-unit id="af175b945f0af8e71b073d6998feff95f90842dc" translate="yes" xml:space="preserve">
          <source>SerialVersionUID is used for version control of object. you can specify serialVersionUID in your class file also. Consequence of not specifying serialVersionUID is that when you add or modify any field in class then already serialized class will not be able to recover because serialVersionUID generated for new class and for old serialized object will be different. Java serialization process relies on correct serialVersionUID for recovering state of serialized object and throws java.io.InvalidClassException in case of serialVersionUID mismatch</source>
          <target state="translated">SerialVersionUID用于对象的版本控制,你也可以在类文件中指定serialVersionUID。不指定serialVersionUID的后果是,当你在类中添加或修改任何字段时,已经序列化的类将无法恢复,因为新类和旧的序列化对象产生的serialVersionUID是不同的。Java的序列化过程依赖于正确的serialVersionUID来恢复被序列化对象的状态,如果serialVersionUID不匹配,会抛出java.io.InvalidClassException</target>
        </trans-unit>
        <trans-unit id="4b024388f4cf31c84b0ead4ab2043ad63c5546da" translate="yes" xml:space="preserve">
          <source>Serialization is basically writing class data to a file/stream/etc.  De-serialization is reading that data back to a class.</source>
          <target state="translated">序列化基本上就是把类的数据写到一个文件管理器中。去序列化就是把这些数据读回类。</target>
        </trans-unit>
        <trans-unit id="a90d236667d7a7c96b56a65a967fafb3c11e3d17" translate="yes" xml:space="preserve">
          <source>Serialization:
We often work with important objects whose state (data in the variables of the object) is so important that we can not risk to lose it due to power/system failures (or) network failures in case of sending the object state to other machine. The solution for this problem is named &quot;Persistence&quot; which simply means persisting (holding/saving) the data. Serialization is one of many other ways to achieve persistence (by saving data to disk/memory). When saving the state of the object, it is important to create an identity for the object, to be able to properly read it back (de-serialization). This unique identification is ID is SerialVersionUID.</source>
          <target state="translated">串行化。我们经常处理一些重要的对象,这些对象的状态(对象的变量中的数据)是非常重要的,以至于当我们将对象的状态发送给其他机器时,我们不能因为电源系统故障(或)网络故障而失去它。解决这个问题的方法被命名为 &quot;持久化&quot;,简单来说就是将数据持久化(保存)。串行化是实现持久化(通过将数据保存到diskmemory)的其他许多方法之一。在保存对象的状态时,为了能够正确地读回对象(去序列化),必须为对象建立一个唯一的标识。这个唯一的标识就是ID是SerialVersionUID。</target>
        </trans-unit>
        <trans-unit id="786e6158fbc48d9b91849b94859cb9fb38b4788a" translate="yes" xml:space="preserve">
          <source>So to help this usecase, the Java platform offers you a choice of not setting the &lt;code&gt;serialVersionUID&lt;/code&gt; manually. Instead, a hash of the class structure will be generated at compile-time and used as id. This mechanism will make sure that you never have different class structures with the same id, and so you will not get these hard-to-trace runtime serialization failures mentioned above.</source>
          <target state="translated">因此，为了帮助解决该用例，Java平台为您提供了不手动设置 &lt;code&gt;serialVersionUID&lt;/code&gt; 的选择。 相反，将在编译时生成类结构的哈希并将其用作id。 这种机制将确保您永远不会拥有具有相同id的不同类结构，因此不会遇到上述难以跟踪的运行时序列化失败的情况。</target>
        </trans-unit>
        <trans-unit id="50858191cffe74b141faf092db8130f8aa64446f" translate="yes" xml:space="preserve">
          <source>So we conclude that to make Serialization/Deserialization process successful the serialVersionUID of serialized object must be equivalent to the serialVersionUID of the class. In case if programmer specifies the serialVersionUID value explicitly in the program then the same value will be associated with the serialized object and the class, irrespective of the serialization and deserialzation platform(for ex. serialization might be done on platform like windows by using sun or MS JVM and Deserialization might be on different platform Linux using Zing JVM).</source>
          <target state="translated">因此我们得出结论,为了使SerializationDeserialization过程成功,序列化对象的serialVersionUID必须与类的serialVersionUID相等。如果程序员在程序中明确指定了serialVersionUID的值,那么无论序列化和解序列化平台如何,序列化对象和类的值都是相同的(例如:序列化可能是在windows平台上使用sun或MS JVM,而解序列化可能是在不同平台的Linux上使用Zing JVM)。</target>
        </trans-unit>
        <trans-unit id="24bcc5bfeaec8f6116cfc0a18304cb69edac70ac" translate="yes" xml:space="preserve">
          <source>So, instead of</source>
          <target state="translated">所以,与其说是</target>
        </trans-unit>
        <trans-unit id="538886bb8c0fa8986dc37e9dc9a75511ddd40509" translate="yes" xml:space="preserve">
          <source>Specifying one gives more control, though JVM does generate one if you don't specify. The value generated can differ between different compilers. Furthermore, sometimes you just want for some reason to forbid deserialization of old serialized objects [&lt;code&gt;backward incompatibility&lt;/code&gt;], and in this case you just have to change the serialVersionUID.</source>
          <target state="translated">指定一个可以提供更多控制权，但是如果您未指定的话，JVM会生成一个控制权。 生成的值在不同的编译器之间可能有所不同。 此外，有时您只是出于某种原因要禁止对旧的序列化对象进行反序列化[ &lt;code&gt;backward incompatibility&lt;/code&gt; ]，在这种情况下，您只需要更改serialVersionUID。</target>
        </trans-unit>
        <trans-unit id="92c72fe26fb9d9097b9d0d0fcb80b3ee120d57ea" translate="yes" xml:space="preserve">
          <source>Static fields (with static modifier) are not serialized.</source>
          <target state="translated">静态字段(带静态修改器)不被序列化。</target>
        </trans-unit>
        <trans-unit id="d7e2b2c0be6f1557cd2bd472fca064db6f1767b9" translate="yes" xml:space="preserve">
          <source>The built-in de-serialization mechanism (&lt;code&gt;in.defaultReadObject()&lt;/code&gt;) will refuse to de-serialize from old versions of the data. But if you want to you can define your own &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/guide/serialization/spec/input.html#2971&quot;&gt;readObject()&lt;/a&gt;-function which can read back old data. This custom code can then check the &lt;code&gt;serialVersionUID&lt;/code&gt; in order to know which version the data is in and decide how to de-serialize it. This versioning technique is useful if you store serialized data which survives several versions of your code.</source>
          <target state="translated">内置的反序列化机制（ &lt;code&gt;in.defaultReadObject()&lt;/code&gt; ）将拒绝从旧版本的数据中反序列化。 但是，如果您愿意，可以定义自己的&lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/guide/serialization/spec/input.html#2971&quot;&gt;readObject（）&lt;/a&gt;函数，该函数可以读回旧数据。 然后，此自定义代码可以检查 &lt;code&gt;serialVersionUID&lt;/code&gt; ，以了解数据所在的版本并决定如何对其进行反序列化。 如果您存储序列化的数据（在多个版本的代码中都可以保留），则此版本控制技术很有用。</target>
        </trans-unit>
        <trans-unit id="e243771f8f2c8fb470fa0bee8b336e82b28f4fd9" translate="yes" xml:space="preserve">
          <source>The call to the &lt;code&gt;EJB&lt;/code&gt; was failing with the Exception below because I hadn't declared its &lt;code&gt;serialVersionUID&lt;/code&gt;:</source>
          <target state="translated">对 &lt;code&gt;EJB&lt;/code&gt; 的调用因以下异常而失败，因为我尚未声明其 &lt;code&gt;serialVersionUID&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="05cab8052e138b165623cdfaf9a111dbdf55093e" translate="yes" xml:space="preserve">
          <source>The docs for &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html&quot;&gt;&lt;code&gt;java.io.Serializable&lt;/code&gt;&lt;/a&gt; are probably about as good an explanation as you'll get:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html&quot;&gt; &lt;code&gt;java.io.Serializable&lt;/code&gt; &lt;/a&gt;的文档可能对您的解释差不多：</target>
        </trans-unit>
        <trans-unit id="5f1a9e80a8a62dc5fed2428c8ee1933622e0baed" translate="yes" xml:space="preserve">
          <source>The serializable class Foo does not declare a static final
  serialVersionUID field of type long</source>
          <target state="translated">可序列化类Foo没有声明一个静态的最终serialVersionUID字段,该字段的类型为long</target>
        </trans-unit>
        <trans-unit id="8d3646af1ce2f3da7f74099102cfd890330046cf" translate="yes" xml:space="preserve">
          <source>The serialization runtime associates with each serializable class a version number, called a &lt;code&gt;serialVersionUID&lt;/code&gt;, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different &lt;code&gt;serialVersionUID&lt;/code&gt; than that of the corresponding sender's class, then deserialization will result in an 
  &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InvalidClassException.html&quot;&gt;&lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/a&gt;. A serializable class can declare its own &lt;code&gt;serialVersionUID&lt;/code&gt; explicitly by declaring a field named &lt;code&gt;serialVersionUID&lt;/code&gt; that must be static, final, and of type &lt;code&gt;long&lt;/code&gt;:</source>
          <target state="translated">序列化运行时与每个可序列化的类关联一个版本号，称为 &lt;code&gt;serialVersionUID&lt;/code&gt; ，在反序列化期间使用该版本号来验证序列化对象的发送者和接收者是否已加载了该对象的与序列化兼容的类。 如果接收者已为该对象加载了一个与相应发送者类具有不同的 &lt;code&gt;serialVersionUID&lt;/code&gt; 的类，则反序列化将导致&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InvalidClassException.html&quot;&gt; &lt;code&gt;InvalidClassException&lt;/code&gt; &lt;/a&gt; 。 可序列化的类可以通过声明一个名为 &lt;code&gt;serialVersionUID&lt;/code&gt; 的字段来显式声明其自己的 &lt;code&gt;serialVersionUID&lt;/code&gt; ，该字段必须是静态的，最终的且类型为 &lt;code&gt;long&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9d73388301e50851d95c48f1857d574425566028" translate="yes" xml:space="preserve">
          <source>The serialization runtime comes up with a number called Serial version for each serializable class. This number is called serialVersionUID. Now there is some Math behind this number and it comes out based on the fields/methods that are defined in the class. For the same class the same version is generated every time. This number is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender's class, then deserialization will result in an InvalidClassException.</source>
          <target state="translated">序列化运行时为每一个可序列化类都会产生一个名为Serial version的数字。这个数字被称为serialVersionUID。现在这个数字背后有一些数学运算,它是根据类中定义的fieldmethods得出的。对于同一个类,每次都会生成相同的版本。这个数字在反序列化过程中用来验证序列化对象的发送方和接收方是否已经为该对象加载了与序列化兼容的类。如果接收方加载的对象的类的serialVersionUID与相应的发送方的类的serialVersionUID不同,那么反序列化将导致一个InvalidClassException。</target>
        </trans-unit>
        <trans-unit id="e1820339c9471fdde6c6876cce75b62eb78d6e1e" translate="yes" xml:space="preserve">
          <source>This .lst includes the list of java files to add the serialVersionUID in the following format:</source>
          <target state="translated">这个.lst包含了要添加serialVersionUID的java文件列表,格式如下。</target>
        </trans-unit>
        <trans-unit id="df238493e0e777844116509927cb606c7ebeaf41" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;POJO's&lt;/code&gt; class was packaged inside the EJB jar and inside it's own jar in the WEB-INF/lib of the web module. They're actually the same class, but when I package the EJB module I unpack this POJO's jar to pack it together with the EJB module.</source>
          <target state="translated">这个 &lt;code&gt;POJO's&lt;/code&gt; 类包装在EJB jar中，并且包装在Web模块的WEB-INF / lib中自己的jar中。 它们实际上是同一类，但是当我打包EJB模块时，我解包了这个POJO的jar，将其与EJB模块打包在一起。</target>
        </trans-unit>
        <trans-unit id="eda370108a690dac70b6b7f258be620a2ea98537" translate="yes" xml:space="preserve">
          <source>This question is very well documented in Effective Java by Joshua Bloch. A very good book and a must read. I will outline some of the reasons below :</source>
          <target state="translated">这个问题在Joshua Bloch写的《Effective Java》一书中有很好的记载。这是一本非常好的书,也是一本必读的书。我将在下文中概述一些原因。</target>
        </trans-unit>
        <trans-unit id="e6c3eaa61a8392ceb99402b7ec2b883a685250df" translate="yes" xml:space="preserve">
          <source>This script uses the JDK serialVer tool under hood. So make sure your $JAVA_HOME/bin is in the PATH.</source>
          <target state="translated">这个脚本在引擎盖下使用了JDK的serialVer工具。所以要确保你的$JAVA_HOMEbin在PATH中。</target>
        </trans-unit>
        <trans-unit id="dbfd0fd5f5dc0716357b84d3ad13563ed41cd74d" translate="yes" xml:space="preserve">
          <source>To tell the long story short this field is used to check if serialized data can be deserialized correctly. Serialization and deserialization are often made by different copies of program - for example server converts object to string and client converts received string to object. This field tells that both operates with same idea about what this object is. This field helps when:</source>
          <target state="translated">长话短说,这个字段用来检查序列化的数据是否可以正确地反序列化。序列化和反序列化通常是由不同的程序副本来完成的--例如,服务器将对象转换为字符串,客户端将接收到的字符串转换为对象。这个字段告诉我们,这两个操作都是以相同的想法来操作这个对象。这个字段有助于在以下情况下的操作。</target>
        </trans-unit>
        <trans-unit id="dd3e2784d9ca1e76f345e2c02320bcee304f69db" translate="yes" xml:space="preserve">
          <source>To understand the significance of field serialVersionUID, one should understand how Serialization/Deserialization works.</source>
          <target state="translated">要理解字段serialVersionUID的意义,就应该了解SerializationDeserialization的工作原理。</target>
        </trans-unit>
        <trans-unit id="37e77042a8574f7bc74e7c4eac7f95cdb9c58c3e" translate="yes" xml:space="preserve">
          <source>Transient fields (with transient modifier) are NOT serialized, (i.e., not saved or restored). A class that implements Serializable must mark transient fields of classes that do not support serialization (e.g., a file stream).</source>
          <target state="translated">瞬时字段(带瞬时修改器)不被序列化,(即不保存或恢复)。实现了Serializable的类必须标记不支持序列化的类的瞬态字段(例如,文件流)。</target>
        </trans-unit>
        <trans-unit id="6933e4b126085de9a1c38f4952dbf4a40e9a5eb8" translate="yes" xml:space="preserve">
          <source>Unnecessary code: Local variable is never read</source>
          <target state="translated">不需要的代码。本地变量从未被读取</target>
        </trans-unit>
        <trans-unit id="f4dc52549539b19698124f7e90a02424ea54ba1a" translate="yes" xml:space="preserve">
          <source>Unnecessary code: Redundant null check</source>
          <target state="translated">不需要的代码。冗余的无效检查</target>
        </trans-unit>
        <trans-unit id="c7210433dda8b7ce92a18a3075ff6bf0ef7ad0e4" translate="yes" xml:space="preserve">
          <source>Unnecessary code: Unnecessary cast or 'instanceof'</source>
          <target state="translated">不必要的代码。不必要的 cast 或 'instanceof'</target>
        </trans-unit>
        <trans-unit id="fd9d198118f237407393e2591aad4500758c788d" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;serialVersionUID&lt;/code&gt; and why is it important?  Please show an example where missing &lt;code&gt;serialVersionUID&lt;/code&gt; will cause a problem.</source>
          <target state="translated">什么是 &lt;code&gt;serialVersionUID&lt;/code&gt; ，为什么重要？ 请显示一个示例，其中缺少 &lt;code&gt;serialVersionUID&lt;/code&gt; 会导致问题。</target>
        </trans-unit>
        <trans-unit id="a4ea858c614f1d33ff483134e363a7793202d993" translate="yes" xml:space="preserve">
          <source>What is SerialVersionUID?
Answer : - Lets say there are two persons, one from HQ and another from ODC, both are going to perform serialization and deserialization respectively. In this case to authenticate that the receiver who is in ODC is the authenticated person, JVM creates a Unique ID which is known as SerialVersionUID.</source>
          <target state="translated">什么是SerialVersionUID?答案:-假设有两个人,一个来自总部,另一个来自ODC,两个人都要分别进行序列化和反序列化。在这种情况下,为了验证在ODC中的接收者就是被验证的人,JVM会创建一个唯一的ID,这个ID被称为SerialVersionUID。</target>
        </trans-unit>
        <trans-unit id="950af41ee22eb0cc9a288d545197579a5b5fd3a5" translate="yes" xml:space="preserve">
          <source>What is a &lt;strong&gt;serialVersionUID&lt;/strong&gt; and why should I use it?</source>
          <target state="translated">什么是&lt;strong&gt;serialVersionUID&lt;/strong&gt; ，为什么要使用它？</target>
        </trans-unit>
        <trans-unit id="8f076480c7cb5030ccf2dd924c9ba10624283650" translate="yes" xml:space="preserve">
          <source>What is a serialVersionUID and why should I use it</source>
          <target state="translated">什么是serialVersionUID,为什么要使用它?</target>
        </trans-unit>
        <trans-unit id="0a65d9aec5e04f6f465638e6617262c10a1f5e64" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Object&lt;/code&gt; is serialized, Java Runtime associates the serial version number aka, the &lt;code&gt;serialVersionID&lt;/code&gt;.</source>
          <target state="translated">序列化 &lt;code&gt;Object&lt;/code&gt; 时，Java Runtime会将序列号也称为 &lt;code&gt;serialVersionID&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="143a994f6ea5500278ddcbc04f354fc10ddaf1e7" translate="yes" xml:space="preserve">
          <source>When a Serializable class object is serialized Java Runtime associates a serial version no.(called as serialVersionUID) with this serialized object. At the time when you deserialize this serialized object Java Runtime matches the serialVersionUID of serialized object with the serialVersionUID of the class. If both are equal then only it proceeds with the further process of deserialization else throws InvalidClassException.</source>
          <target state="translated">当一个可序列化的类对象被序列化时,Java Runtime会将一个序列化对象的序列版本号(称为serialVersionUID)与这个序列化对象关联起来。当你对这个序列化对象进行反序列化时,Java Runtime会将序列化对象的serialVersionUID与类的serialVersionUID进行匹配。如果两者相等,那么它才会继续进行进一步的反序列化过程,否则会抛出InvalidClassException。</target>
        </trans-unit>
        <trans-unit id="dc0a24660bcec6abbb26821fa0ecf2e40563a013" translate="yes" xml:space="preserve">
          <source>When is it important?</source>
          <target state="translated">什么时候重要了?</target>
        </trans-unit>
        <trans-unit id="9af86a025d44d1c589a0e09607b2c8ff0ff76c70" translate="yes" xml:space="preserve">
          <source>When you declare a class as &lt;code&gt;Serializable&lt;/code&gt; by implementing marker interface &lt;code&gt;java.io.Serializable&lt;/code&gt;, Java runtime persist instance of that class into disk by using default Serialization mechanism, provided you have not customized the process using &lt;code&gt;Externalizable&lt;/code&gt; interface.</source>
          <target state="translated">当通过实现标记接口 &lt;code&gt;java.io.Serializable&lt;/code&gt; 将一个类声明为 &lt;code&gt;Serializable&lt;/code&gt; 时，如果您尚未使用 &lt;code&gt;Externalizable&lt;/code&gt; 接口自定义该过程，则Java运行时将使用默认的Serialization机制将该类的实例持久化到磁盘中。</target>
        </trans-unit>
        <trans-unit id="a4261f44712ba672b21eab3784b5b8b8c48aba87" translate="yes" xml:space="preserve">
          <source>Why SerialVersionUID?</source>
          <target state="translated">为什么是SerialVersionUID?</target>
        </trans-unit>
        <trans-unit id="e4dc0a485759072334d504ace695ec1b74eb1c80" translate="yes" xml:space="preserve">
          <source>Window &amp;gt; Preferences &amp;gt; Java &amp;gt; Compiler &amp;gt; Errors / Warnings &amp;gt; Potential Programming Problems</source>
          <target state="translated">窗口&amp;gt;首选项&amp;gt; Java&amp;gt;编译器&amp;gt;错误/警告&amp;gt;潜在的编程问题</target>
        </trans-unit>
        <trans-unit id="70a5098988a4dce007a61987c0714121468c081c" translate="yes" xml:space="preserve">
          <source>You can tell Eclipse to ignore these serialVersionUID  warnings:</source>
          <target state="translated">你可以告诉Eclipse忽略这些serialVersionUID警告。</target>
        </trans-unit>
        <trans-unit id="ea3b691c24335342398ff9d3ac09e0eb6716601e" translate="yes" xml:space="preserve">
          <source>and in the relevant methods call &lt;code&gt;myList.foo()&lt;/code&gt; instead of &lt;code&gt;this.foo()&lt;/code&gt; (or &lt;code&gt;super.foo()&lt;/code&gt;). (This does not fit in all cases, but still quite often.)</source>
          <target state="translated">并在相关方法中调用 &lt;code&gt;myList.foo()&lt;/code&gt; 而不是 &lt;code&gt;this.foo()&lt;/code&gt; （或 &lt;code&gt;super.foo()&lt;/code&gt; ）。 （这并不适合所有情况，但仍然很常见。）</target>
        </trans-unit>
        <trans-unit id="7316c9b112287ddcea6abbf02e4c8446c3f27278" translate="yes" xml:space="preserve">
          <source>and many more.</source>
          <target state="translated">以及更多。</target>
        </trans-unit>
        <trans-unit id="eadcd9bd2a09c75aef04954e6799e50278ee124a" translate="yes" xml:space="preserve">
          <source>do</source>
          <target state="translated">do</target>
        </trans-unit>
        <trans-unit id="64c412067ed17ca88baea5c0927d455ab8360d0e" translate="yes" xml:space="preserve">
          <source>see also &lt;a href=&quot;http://javarevisited.blogspot.in/2014/05/why-use-serialversionuid-inside-serializable-class-in-java.html&quot;&gt;Why use SerialVersionUID inside Serializable class in Java&lt;/a&gt;</source>
          <target state="translated">另请参见&lt;a href=&quot;http://javarevisited.blogspot.in/2014/05/why-use-serialversionuid-inside-serializable-class-in-java.html&quot;&gt;为什么在Java的Serializable类内使用SerialVersionUID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2e648a183996542247521bad401174b3bcab9d2" translate="yes" xml:space="preserve">
          <source>since most of the time the default &lt;code&gt;serialVersionUID&lt;/code&gt; is sufficient.  This includes &lt;code&gt;Exception&lt;/code&gt;, &lt;code&gt;HttpServlet&lt;/code&gt;.</source>
          <target state="translated">因为大多数情况下，默认的 &lt;code&gt;serialVersionUID&lt;/code&gt; 就足够了。 这包括 &lt;code&gt;Exception&lt;/code&gt; ， &lt;code&gt;HttpServlet&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f4e5827f62a8e420e92778b85454e12110334a0" translate="yes" xml:space="preserve">
          <source>the default serialVersionUID computation is highly sensitive to class
  details that may vary depending on compiler implementations, and can
  thus result in unexpected &lt;code&gt;InvalidClassException&lt;/code&gt;s during
  deserialization.</source>
          <target state="translated">默认的serialVersionUID计算对类详细信息高度敏感，类详细信息可能会根据编译器的实现而有所不同，因此可能会在反序列化期间导致意外的 &lt;code&gt;InvalidClassException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d086671c4b1df573da3a6c283b2da7789b180c73" translate="yes" xml:space="preserve">
          <source>you have many different copies of your program in different places (like 1 server and 100 clients). If you will change your object, alter your version number and forget to update one this clients, it will know that he is not capable of deserialization</source>
          <target state="translated">你在不同的地方有许多不同的程序副本(比如1个服务器和100个客户端)。如果你会改变你的对象,改变你的版本号,并忘记更新一个客户端,它就会知道他不能进行反序列化。</target>
        </trans-unit>
        <trans-unit id="4458b0ad6a09175946b64bee0e58807911feb856" translate="yes" xml:space="preserve">
          <source>you have stored your data in some file and later on you try to open it with updated version of your program with modified object - you will know that this file is not compatible if you keep your version right</source>
          <target state="translated">你将数据存储在一些文件中,后来你尝试用更新后的程序版本打开它,并修改了对象,你就会知道,如果你的版本是正确的,那么这个文件是不兼容的。</target>
        </trans-unit>
        <trans-unit id="df86e582309ff9c8660c860f4050c0b8e4479141" translate="yes" xml:space="preserve">
          <source>you save the this script, say add_serialVersionUID.sh to you ~/bin. Then you run it in the root directory of your Maven or Gradle project like:</source>
          <target state="translated">你把这个脚本保存到你的~bin中,比如add_serialVersionUID.sh。然后在你的Maven或Gradle项目的根目录下运行它。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
