<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/285793">
    <body>
      <group id="285793">
        <trans-unit id="ece08654998b41655e46f33e0f20babd54865886" translate="yes" xml:space="preserve">
          <source>'serialVersionUID' is a 64 bit number used to uniquely identify a class during deserialization process. When you serialize an object, serialVersionUID of the class also written to the file. Whenever you deserialize this object, java run time extract this serialVersionUID value from the serialized data and compare the same value associate with the class. If both do not match, then 'java.io.InvalidClassException' will be thrown.</source>
          <target state="translated">El 'serialVersionUID' es un número de 64 bits utilizado para identificar de forma única una clase durante el proceso de deserialización.Cuando se serializa un objeto,el serialVersionUID de la clase también se escribe en el archivo.Siempre que deserialice este objeto,el tiempo de ejecución de Java extrae este valor serialVersionUID de los datos serializados y compara el mismo valor asociado a la clase.Si ambos no coinciden,entonces se lanzará 'java.io.InvalidClassException'.</target>
        </trans-unit>
        <trans-unit id="42edaf9723e5c4f748fc70bd7e1ff25ff4ee0521" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=45&quot;&gt;This article&lt;/a&gt; has some good points on the topic.</source>
          <target state="translated">&lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=45&quot;&gt;Este art&amp;iacute;culo&lt;/a&gt; tiene algunos buenos puntos sobre el tema.</target>
        </trans-unit>
        <trans-unit id="9c5d59d7913642ce893724ffc9429ca21bfe2c44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SerialVersionUID&lt;/code&gt; is a unique identifier for each class, &lt;code&gt;JVM&lt;/code&gt; uses it to compare the versions of the class ensuring that the same class was used during Serialization is loaded during Deserialization.</source>
          <target state="translated">&lt;code&gt;SerialVersionUID&lt;/code&gt; es un identificador &amp;uacute;nico para cada clase, &lt;code&gt;JVM&lt;/code&gt; lo utiliza para comparar las versiones de la clase asegurando que la misma clase se us&amp;oacute; durante la serializaci&amp;oacute;n se carga durante la deserializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="152df86e7d736482ad28fd298d1e6b599b88146a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SerialVersionUID&lt;/code&gt; is used to version serialized data. You can only de-serialize a class if it's &lt;code&gt;SerialVersionUID&lt;/code&gt; matches with the serialized instance. When we don't declare &lt;code&gt;SerialVersionUID&lt;/code&gt; in our class, Java runtime generates it for us but its not recommended. It's recommended to declare &lt;code&gt;SerialVersionUID&lt;/code&gt; as &lt;code&gt;private static final long&lt;/code&gt; variable to avoid default mechanism.</source>
          <target state="translated">&lt;code&gt;SerialVersionUID&lt;/code&gt; se utiliza para versionar datos serializados. Solo puede des-serializar una clase si su &lt;code&gt;SerialVersionUID&lt;/code&gt; coincide con la instancia serializada. Cuando no declaramos &lt;code&gt;SerialVersionUID&lt;/code&gt; en nuestra clase, el tiempo de ejecuci&amp;oacute;n de Java lo genera para nosotros, pero no se recomienda. Se recomienda declarar &lt;code&gt;SerialVersionUID&lt;/code&gt; como variable &lt;code&gt;private static final long&lt;/code&gt; para evitar el mecanismo predeterminado.</target>
        </trans-unit>
        <trans-unit id="ee68f99f789b144946181e1611c0252582d08cac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serialVersionUID&lt;/code&gt; facilitates versioning of serialized data. Its value is stored with the data when serializing. When de-serializing, the same version is checked to see how the serialized data matches the current code.</source>
          <target state="translated">&lt;code&gt;serialVersionUID&lt;/code&gt; facilita el control de versiones de datos serializados. Su valor se almacena con los datos cuando se serializa. Al des serializar, se verifica la misma versi&amp;oacute;n para ver c&amp;oacute;mo los datos serializados coinciden con el c&amp;oacute;digo actual.</target>
        </trans-unit>
        <trans-unit id="caf82cc19ceaeb5cc908ee5778f22c14c5f204e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;There are some rules for serialization&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Hay algunas reglas para la serializaci&amp;oacute;n&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3809a6cba5b10c0cfa01db3b1df7b55838f75ba0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Where we need serialVersionID:&lt;/em&gt;&lt;/strong&gt;
During the deserialization to verify that sender and receiver are compatible with respect to serialization. If the receiver loaded the class with a different &lt;code&gt;serialVersionID&lt;/code&gt; then deserialization will end with &lt;code&gt;InvalidClassCastException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Donde necesitamos serialVersionID:&lt;/em&gt;&lt;/strong&gt; durante la deserializaci&amp;oacute;n para verificar que el remitente y el receptor son compatibles con respecto a la serializaci&amp;oacute;n. Si el receptor carg&amp;oacute; la clase con un &lt;code&gt;serialVersionID&lt;/code&gt; diferente, la deserializaci&amp;oacute;n finalizar&amp;aacute; con &lt;code&gt;InvalidClassCastException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d97b707c46087aba1ebb616cb1580f6fcc1274c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deserialization&lt;/strong&gt;: At the time of deserialization, receiver side JVM will compare the unique ID associated with the Object with local class Unique ID i.e. JVM will also create a Unique ID based on the corresponding .class file which is present in the receiver system. If both unique ID matched then only deserialization will be performed. Otherwise we will get Runtime Exception saying InvalidClassException. This unique Identifier is nothing but SerialVersionUID</source>
          <target state="translated">&lt;strong&gt;Deserializaci&amp;oacute;n&lt;/strong&gt; : en el momento de la deserializaci&amp;oacute;n, JVM del lado del receptor comparar&amp;aacute; la ID &amp;uacute;nica asociada con el Objeto con la ID &amp;uacute;nica de clase local, es decir, JVM tambi&amp;eacute;n crear&amp;aacute; una ID &amp;uacute;nica basada en el archivo .class correspondiente que est&amp;aacute; presente en el sistema receptor. Si ambas ID &amp;uacute;nicas coinciden, solo se realizar&amp;aacute; la deserializaci&amp;oacute;n. De lo contrario, obtendremos Runtime Exception diciendo InvalidClassException. Este identificador &amp;uacute;nico no es m&amp;aacute;s que SerialVersionUID</target>
        </trans-unit>
        <trans-unit id="3611972f0d9f9281ab9d85aadd31fd689c683b66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Serialization&lt;/strong&gt; : At the time of serialization, with every object sender side JVM will save a Unique Identifier. JVM is responsible to generate that unique ID based on the corresponding .class file which is present in the sender system.</source>
          <target state="translated">&lt;strong&gt;Serializaci&amp;oacute;n&lt;/strong&gt; : en el momento de la serializaci&amp;oacute;n, con cada objeto remitente, JVM guardar&amp;aacute; un identificador &amp;uacute;nico. JVM es responsable de generar esa ID &amp;uacute;nica basada en el archivo .class correspondiente que est&amp;aacute; presente en el sistema emisor.</target>
        </trans-unit>
        <trans-unit id="31c4af730de1ec78e966df4a893d337e4ba48a74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Serialization&lt;/strong&gt; allows to convert an object to a stream, for sending that object over the network OR Save to file OR save into DB for letter usage.</source>
          <target state="translated">&lt;strong&gt;La serializaci&amp;oacute;n&lt;/strong&gt; permite convertir un objeto en una secuencia, para enviar ese objeto a trav&amp;eacute;s de la red O Guardar en archivo O guardar en DB para uso de letras.</target>
        </trans-unit>
        <trans-unit id="18b104d3665872daa5a5d62b3dfa2e04e0257aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html&quot;&gt;javadocs for &lt;code&gt;Serializable&lt;/code&gt;&lt;/a&gt; say&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Los &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html&quot;&gt;javadocs para &lt;code&gt;Serializable&lt;/code&gt; &lt;/a&gt; dicen&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="8e10ad6fb571714fdcf9a3637d45c19079faf5d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Therefore, you must declare serialVersionUID because it give us more control&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Por lo tanto, debe declarar serialVersionUID porque nos da m&amp;aacute;s control&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1b2511b1f1436c52f14967962e20cf606bc903d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why use &lt;code&gt;SerialVersionUID&lt;/code&gt; inside &lt;code&gt;Serializable&lt;/code&gt; class in Java?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Por qu&amp;eacute; usar &lt;code&gt;SerialVersionUID&lt;/code&gt; dentro de la clase &lt;code&gt;Serializable&lt;/code&gt; en Java?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="906fd73871d1746cd0dbcce791e6b9af3918c01b" translate="yes" xml:space="preserve">
          <source>A Simple Explanation:</source>
          <target state="translated">Una simple explicación:</target>
        </trans-unit>
        <trans-unit id="66821acf6e7624406be47725b2e7ce84257cd34d" translate="yes" xml:space="preserve">
          <source>A serializable class can declare its own &lt;code&gt;serialVersionUID&lt;/code&gt; explicitly by declaring a field named &lt;code&gt;serialVersionUID&lt;/code&gt; that must be static, final, and of type long.</source>
          <target state="translated">Una clase serializable puede declarar su propio &lt;code&gt;serialVersionUID&lt;/code&gt; expl&amp;iacute;citamente declarando un campo llamado &lt;code&gt;serialVersionUID&lt;/code&gt; que debe ser est&amp;aacute;tico, final y de tipo largo.</target>
        </trans-unit>
        <trans-unit id="556d6d8a3cc094128082980ca2daa51184075bf6" translate="yes" xml:space="preserve">
          <source>All primitive types are serializable.</source>
          <target state="translated">Todos los tipos primitivos son serializables.</target>
        </trans-unit>
        <trans-unit id="d43fa2e365573ac0634d4f96ed28d42f8662274d" translate="yes" xml:space="preserve">
          <source>An object is serializable (itself implements the Serializable interface) even if its superclass is not. However, the first superclass in the hierarchy of the serializable class, that does not implements Serializable interface, MUST have a no-arg constructor. If this is violated, readObject() will produce a java.io.InvalidClassException in runtime</source>
          <target state="translated">Un objeto es serializable (él mismo implementa la interfaz serializable)aunque su superclase no lo sea.Sin embargo,la primera superclase en la jerarquía de la clase serializable,que no implementa la interfaz serializable,DEBE tener un constructor no grande.Si esto es violado,readObject()producirá un java.io.InvalidClassException en tiempo de ejecución</target>
        </trans-unit>
        <trans-unit id="54df990ab20da4ab5e0367e31d19258eae93b03c" translate="yes" xml:space="preserve">
          <source>An object is serializable only if its class or its superclass implements the Serializable interface</source>
          <target state="translated">Un objeto es serializable sólo si su clase o su superclase implementa la interfaz serializable</target>
        </trans-unit>
        <trans-unit id="120beec47d411d244e0c08a4eeab6eafbb379de8" translate="yes" xml:space="preserve">
          <source>And execute the Reader class. Not to execute the Writer class and you will get the exception.</source>
          <target state="translated">Y ejecutar la clase de lectura.No ejecutar la clase de Escritor y obtendrás la excepción.</target>
        </trans-unit>
        <trans-unit id="4e349787e0377c85e41bb4d42d6bd546a8bc2877" translate="yes" xml:space="preserve">
          <source>And if you are backwards-compatible with your data like in the first use case mentioned, you also probably want to maintain the id yourself. This in order to get readable ids and have greater control over when and how they change.</source>
          <target state="translated">Y si eres compatible con tus datos como en el primer caso de uso mencionado,probablemente también quieras mantener la identificación tú mismo.Esto con el fin de obtener identificaciones legibles y tener un mayor control sobre cuándo y cómo cambian.</target>
        </trans-unit>
        <trans-unit id="024a99db1a896209169c95029b3ce0b2e534afa2" translate="yes" xml:space="preserve">
          <source>Are you serializing data?</source>
          <target state="translated">¿Estás serializando datos?</target>
        </trans-unit>
        <trans-unit id="990a8adcbdfa167776667defea795dc3025b128a" translate="yes" xml:space="preserve">
          <source>As for an example where the missing serialVersionUID might cause a problem:</source>
          <target state="translated">En cuanto a un ejemplo en el que la versión en serie desaparecida podría causar un problema:</target>
        </trans-unit>
        <trans-unit id="5617b7140b809d418d5e0a3baee83574e9a69131" translate="yes" xml:space="preserve">
          <source>Basically, if you don't update the version correctly when you update a class you need to write/read, you will get an error when you try to read old data.</source>
          <target state="translated">Básicamente,si no actualizas la versión correctamente cuando actualizas una clase que necesitas leer por escrito,obtendrás un error cuando intentes leer datos antiguos.</target>
        </trans-unit>
        <trans-unit id="55c6075806e02d97bac769299a54d457a38e7da7" translate="yes" xml:space="preserve">
          <source>But in case if serialVersionUID is not specified by programmer then while doing Serialization\DeSerialization  of any object, Java runtime uses its own algorithm to calculate it. This serialVersionUID calculation algorithm varies from one JRE to another. It is also possible that the environment where the object is serialized is using one JRE (ex: SUN JVM) and the environment where deserialzation happens is using Linux Jvm(zing). In such cases serialVersionUID associated with serialized object will be different than the serialVersionUID of class calculated at deserialzation environment. In turn deserialization will not be successful. So to avoid such situations/issues programmer must always specify serialVersionUID of Serializable class.</source>
          <target state="translated">Pero si el programador no especifica el serialVersionUID,al hacer la serialización de cualquier objeto,el tiempo de ejecución de Java usa su propio algoritmo para calcularlo.Este algoritmo de cálculo de serialVersionUID varía de un JRE a otro.También es posible que el entorno donde el objeto es serializado esté usando un JRE (ej:SUN JVM)y el entorno donde la deserialización ocurre esté usando Linux Jvm(zing).En estos casos el serialVersionUID asociado al objeto serializado será diferente al serialVersionUID de la clase calculada en el entorno de deserialización.A su vez,la deserialización no tendrá éxito.Por lo tanto,para evitar tales situaciones,el programador debe siempre especificar el serialVersionUID de la clase Serializable.</target>
        </trans-unit>
        <trans-unit id="457b19bd79bfb1a9a50bc7b4969edb6b2b5a1036" translate="yes" xml:space="preserve">
          <source>But storing serialized data for such a long time span is not very common. It is far more common to use the serialization mechanism to temporarily write data to for instance a cache or send it over the network to another program with the same version of the relevant parts of the codebase.</source>
          <target state="translated">Pero almacenar datos seriados durante un período tan largo no es muy común.Es mucho más común utilizar el mecanismo de serialización para escribir temporalmente datos en,por ejemplo,una caché o enviarlos a través de la red a otro programa con la misma versión de las partes relevantes de la base de código.</target>
        </trans-unit>
        <trans-unit id="8003df6d5412c6d8396be6f1aef4f95fe379408b" translate="yes" xml:space="preserve">
          <source>But there is a backside to the auto-generated id strategy. Namely that the generated ids for the same class might differ between compilers (as mentioned by Jon Skeet above). So if you communicate serialized data between code compiled with different compilers, it is recommended to maintain the ids manually anyway.</source>
          <target state="translated">Pero hay una parte trasera de la estrategia de identificación autogenerada.A saber,que los ids generados para la misma clase pueden diferir entre los compiladores (como mencionó Jon Skeet arriba).Por lo tanto,si se comunican datos serializados entre códigos compilados con diferentes compiladores,se recomienda mantener los ids manualmente de todos modos.</target>
        </trans-unit>
        <trans-unit id="7ced4cd1b424dc1e6c6a97cd9e87f8103ee0a11a" translate="yes" xml:space="preserve">
          <source>Code : &lt;a href=&quot;http://www.grepcode.com/file/repository.jboss.org/nexus/content/repositories/releases/org.jboss/javassist/3.5.GA/javassist/SerialVersionUID.java#SerialVersionUID&quot;&gt; javassist.SerialVersionUID&lt;/a&gt;</source>
          <target state="translated">C&amp;oacute;digo: &lt;a href=&quot;http://www.grepcode.com/file/repository.jboss.org/nexus/content/repositories/releases/org.jboss/javassist/3.5.GA/javassist/SerialVersionUID.java#SerialVersionUID&quot;&gt;javassist.SerialVersionUID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e5e4a12dcab3bcdfbbaf20c3c92f7572e7246b3" translate="yes" xml:space="preserve">
          <source>Consider a situation - in the future you need to edit or change your class and in that case when you modify it, JVM will assign it a new UID (Suppose #444).
Now when you try to deserialize the employee object, JVM will compare serialized object's (Employee object) version ID(#333) with that of the class i.e #444(Since it was changed). On comparison JVM will find both version UID are different and hence Deserialization will fail.
Hence if serialVersionID for each class is defined by programmer itself. It will be same even if the class is evolved in future and hence JVM will always find that class is compatible with serialized object even though the class is changed. For more Info you can refer chapter 14 of HEAD FIRST JAVA.</source>
          <target state="translated">Considera una situación-en el futuro necesitas editar o cambiar tu clase y en ese caso cuando la modifiques,la JVM le asignará un nuevo UID (Supongamos #444).Ahora,cuando intente deserializar el objeto empleado,la JVM comparará el ID de la versión del objeto serializado (objeto empleado)(#333)con el de la clase,es decir,el #444(Desde que fue modificado).En la comparación,la JVM encontrará que ambos ID de versión son diferentes y por lo tanto la deserialización fallará.Por lo tanto,si serialVersionID para cada clase es definido por el propio programador.Será lo mismo incluso si la clase es evolucionada en el futuro y por lo tanto la JVM siempre encontrará que la clase es compatible con el objeto serializado aunque la clase sea cambiada.Para más información puedes consultar el capítulo 14 de HEAD FIRST JAVA.</target>
        </trans-unit>
        <trans-unit id="902d3e9c0ce16116737e84feb71557afde91dc0f" translate="yes" xml:space="preserve">
          <source>Create Serialize Object</source>
          <target state="translated">Crear un objeto en serie</target>
        </trans-unit>
        <trans-unit id="a2c7e5486a3f344d56945a7b650dedf412ef8c59" translate="yes" xml:space="preserve">
          <source>Deserialize the object</source>
          <target state="translated">Deserializar el objeto</target>
        </trans-unit>
        <trans-unit id="8f2b733e756af21d1abfdca922137f6588c4d570" translate="yes" xml:space="preserve">
          <source>Do you intend to go into production?</source>
          <target state="translated">¿Tiene intención de entrar en producción?</target>
        </trans-unit>
        <trans-unit id="5e81f5fe3485373a7732e86888657bf7a3c0c5c1" translate="yes" xml:space="preserve">
          <source>Don't bother, the default calculation is really good and suffice for 99,9999% of the cases. And if you run into problems, you can - as already stated - introduce UID's as the need arrise (which is highly unlikely)</source>
          <target state="translated">No te molestes,el cálculo por defecto es muy bueno y es suficiente para el 99,9999% de los casos.Y si tienes problemas,puedes-como ya se ha dicho-introducir UID's como la necesidad de arrise (lo cual es muy poco probable)</target>
        </trans-unit>
        <trans-unit id="74c2664cf2e007e8a6e348e6437ca8eb3c97da2b" translate="yes" xml:space="preserve">
          <source>During &lt;code&gt;serialization&lt;/code&gt;, Java runtime creates a version number for a class, so that it can de-serialize it later. This version number is known as &lt;code&gt;SerialVersionUID&lt;/code&gt; in Java.</source>
          <target state="translated">Durante la &lt;code&gt;serialization&lt;/code&gt; , el tiempo de ejecuci&amp;oacute;n de Java crea un n&amp;uacute;mero de versi&amp;oacute;n para una clase, de modo que pueda deserializarlo m&amp;aacute;s tarde. Este n&amp;uacute;mero de versi&amp;oacute;n se conoce como &lt;code&gt;SerialVersionUID&lt;/code&gt; en Java.</target>
        </trans-unit>
        <trans-unit id="c63d27dfd00d72f5fa3a4a275d1170052a3bb2f1" translate="yes" xml:space="preserve">
          <source>Each time an object is serialized the object is stamped with a version ID number for the object's class.This ID is called &lt;a href=&quot;https://stackoverflow.com/q/285793/1387612&quot;&gt;serialVersionUID&lt;/a&gt; and it is computed based on information about the class structure. Suppose you made an Employee class and it has version id #333 (assigned by JVM),Now when you will serialize the object of that class (Suppose Employee object), JVM will assign UID to it as #333.</source>
          <target state="translated">Cada vez que se serializa un objeto, se marca con un n&amp;uacute;mero de ID de versi&amp;oacute;n para la clase del objeto. Este ID se llama &lt;a href=&quot;https://stackoverflow.com/q/285793/1387612&quot;&gt;serialVersionUID&lt;/a&gt; y se calcula en funci&amp;oacute;n de la informaci&amp;oacute;n sobre la estructura de la clase. Suponga que cre&amp;oacute; una clase Employee y tiene el ID de versi&amp;oacute;n # 333 (asignado por JVM). Ahora, cuando serialice el objeto de esa clase (Suponga que el objeto Employee), JVM le asignar&amp;aacute; UID como # 333.</target>
        </trans-unit>
        <trans-unit id="331fe5b32b63711ced0f4688764ea82b15eb25d9" translate="yes" xml:space="preserve">
          <source>Eclipse issues warnings when a &lt;code&gt;serialVersionUID&lt;/code&gt; is missing.</source>
          <target state="translated">Eclipse emite advertencias cuando falta un &lt;code&gt;serialVersionUID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c7125d853c45b42db053d4899fe4ccc120bba6" translate="yes" xml:space="preserve">
          <source>Field data represents some information stored in the class.
Class implements the &lt;code&gt;Serializable&lt;/code&gt; interface, 
so eclipse automatically offered  to declare the &lt;code&gt;serialVersionUID&lt;/code&gt; field. Lets start with value 1 set there.</source>
          <target state="translated">Los datos de campo representan cierta informaci&amp;oacute;n almacenada en la clase. La clase implementa la interfaz &lt;code&gt;Serializable&lt;/code&gt; , por lo que eclipse se ofrece autom&amp;aacute;ticamente para declarar el campo &lt;code&gt;serialVersionUID&lt;/code&gt; . Comencemos con el valor 1 establecido all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="9255cfa2633d6dd855930279962514319145eb54" translate="yes" xml:space="preserve">
          <source>First I need to explain what serialization is.</source>
          <target state="translated">Primero tengo que explicar qué es la serialización.</target>
        </trans-unit>
        <trans-unit id="fe5f947543d44552ac4a1c1ce2bff62f622221de" translate="yes" xml:space="preserve">
          <source>Firstly to answer your question, when we don't declare SerialVersionUID in our class, Java runtime generates it for us, but that process is sensitive to many class meta data including number of fields, type of fields, access modifier of fields, interface implemented by class etc. Therefore it is recommended to declare it ourselves and Eclipse is warning you about the same.</source>
          <target state="translated">En primer lugar para responder a su pregunta,cuando no declaramos SerialVersionUID en nuestra clase,el tiempo de ejecución de Java lo genera para nosotros,pero ese proceso es sensible a muchos metadatos de la clase incluyendo el número de campos,el tipo de campos,el modificador de acceso de los campos,la interfaz implementada por la clase,etc.Por lo tanto se recomienda declararlo nosotros mismos y Eclipse les advierte sobre lo mismo.</target>
        </trans-unit>
        <trans-unit id="04de54a57ab3959800eb0f2842888d4560a529c7" translate="yes" xml:space="preserve">
          <source>For all other cases, I use</source>
          <target state="translated">Para todos los demás casos,utilizo</target>
        </trans-unit>
        <trans-unit id="fd012c69d903deb492c73342fac8be0cf73138e4" translate="yes" xml:space="preserve">
          <source>Here is a nice explanation based on the scenario,</source>
          <target state="translated">Aquí hay una bonita explicación basada en el escenario,</target>
        </trans-unit>
        <trans-unit id="03bf07f9d1a8bddc0829166a5de4a331ab54be58" translate="yes" xml:space="preserve">
          <source>I can't pass up this opportunity to plug Josh Bloch's book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;Effective Java&lt;/a&gt; (2nd Edition).  Chapter 11 is an indispensible resource on Java serialization.</source>
          <target state="translated">No puedo dejar pasar esta oportunidad de conectar el libro de Josh Bloch &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;Effective Java&lt;/a&gt; (2nd Edition). El Cap&amp;iacute;tulo 11 es un recurso indispensable en la serializaci&amp;oacute;n de Java.</target>
        </trans-unit>
        <trans-unit id="1731a106e7d9ee245acefeb0e9a165e8688028b6" translate="yes" xml:space="preserve">
          <source>I generally use &lt;code&gt;serialVersionUID&lt;/code&gt; in one context:  When I know it will be leaving the context of the Java VM.</source>
          <target state="translated">Generalmente uso &lt;code&gt;serialVersionUID&lt;/code&gt; en un contexto: cuando s&amp;eacute; que dejar&amp;aacute; el contexto de la m&amp;aacute;quina virtual Java.</target>
        </trans-unit>
        <trans-unit id="1d30080cfbbac6f31768acf23476d4f58cc248ff" translate="yes" xml:space="preserve">
          <source>I often see people extending JFrame or such, when they really only need to delegate to this. (This also helps for auto-completing in a IDE, since JFrame has hundreds of methods, which you don't need when you want to call your custom ones on your class.)</source>
          <target state="translated">A menudo veo a gente extendiendo JFrame o algo así,cuando en realidad sólo necesitan delegar en esto.(Esto también ayuda para la autocompletación en un IDE,ya que JFrame tiene cientos de métodos,que no necesitas cuando quieres llamar a los personalizados en tu clase).</target>
        </trans-unit>
        <trans-unit id="4528b507df7e1b4debb62b589fdb1fbf11ea6c69" translate="yes" xml:space="preserve">
          <source>I would know this when I to use &lt;code&gt;ObjectInputStream&lt;/code&gt; and &lt;code&gt;ObjectOutputStream&lt;/code&gt; for my application or if I know a library/framework I use will use it.  The serialVersionID ensures different Java VMs of varying versions or vendors will inter-operate correctly or if it is stored and retrieved outside the VM for example &lt;code&gt;HttpSession&lt;/code&gt; the session data can remain even during a restart and upgrade of the application server.</source>
          <target state="translated">Lo sabr&amp;iacute;a cuando use &lt;code&gt;ObjectInputStream&lt;/code&gt; y &lt;code&gt;ObjectOutputStream&lt;/code&gt; para mi aplicaci&amp;oacute;n o si conozco una biblioteca / marco que utilizo lo usar&amp;eacute; . SerialVersionID garantiza que las m&amp;aacute;quinas virtuales Java diferentes de diferentes versiones o proveedores interact&amp;uacute;en correctamente o, si se almacenan y recuperan fuera de la m&amp;aacute;quina virtual, por ejemplo, &lt;code&gt;HttpSession&lt;/code&gt; , los datos de la sesi&amp;oacute;n pueden permanecer incluso durante un reinicio y actualizaci&amp;oacute;n del servidor de aplicaciones.</target>
        </trans-unit>
        <trans-unit id="4aebc60c47be3376f3219f82f5a1bf8f6060cdc5" translate="yes" xml:space="preserve">
          <source>I'm working on this Java EE application that is composed of a Web module that uses an &lt;code&gt;EJB&lt;/code&gt; module. The web module calls the &lt;code&gt;EJB&lt;/code&gt; module remotely and passes a &lt;code&gt;POJO&lt;/code&gt; that implements &lt;code&gt;Serializable&lt;/code&gt; as an argument.</source>
          <target state="translated">Estoy trabajando en esta aplicaci&amp;oacute;n Java EE que se compone de un m&amp;oacute;dulo web que usa un m&amp;oacute;dulo &lt;code&gt;EJB&lt;/code&gt; . El m&amp;oacute;dulo web llama al m&amp;oacute;dulo &lt;code&gt;EJB&lt;/code&gt; de forma remota y pasa un &lt;code&gt;POJO&lt;/code&gt; que implementa &lt;code&gt;Serializable&lt;/code&gt; como argumento.</target>
        </trans-unit>
        <trans-unit id="fbb6c65af6ba4f01642221360b8825a38d164609" translate="yes" xml:space="preserve">
          <source>If a serializable class do not explicitly declare a serialVersionUID, then serialization runtime will calculate  serialVersionUID value for that class based on various aspects of the class like fields, methods etc.,, You can refer this &lt;a href=&quot;https://self-learning-java-tutorial.blogspot.com/2014/09/serialversionuid.html&quot;&gt;link&lt;/a&gt; for demo application.</source>
          <target state="translated">Si una clase serializable no declara expl&amp;iacute;citamente un serialVersionUID, el tiempo de ejecuci&amp;oacute;n de serializaci&amp;oacute;n calcular&amp;aacute; el valor serialVersionUID para esa clase en funci&amp;oacute;n de varios aspectos de la clase, como campos, m&amp;eacute;todos, etc., puede consultar este &lt;a href=&quot;https://self-learning-java-tutorial.blogspot.com/2014/09/serialversionuid.html&quot;&gt;enlace&lt;/a&gt; para la aplicaci&amp;oacute;n de demostraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="79176b9cada3ecc6f3cdbdbe22c62b8fa2c5bd9b" translate="yes" xml:space="preserve">
          <source>If a serializable class does not explicitly declare a &lt;code&gt;serialVersionUID&lt;/code&gt;, then the serialization runtime will calculate a default &lt;code&gt;serialVersionUID&lt;/code&gt; value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is &lt;em&gt;strongly recommended&lt;/em&gt; that all serializable classes explicitly declare &lt;code&gt;serialVersionUID&lt;/code&gt; values, since the default &lt;code&gt;serialVersionUID&lt;/code&gt; computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected &lt;code&gt;InvalidClassExceptions&lt;/code&gt; during deserialization. Therefore, to guarantee a consistent &lt;code&gt;serialVersionUID&lt;/code&gt; value across different java compiler implementations, a serializable class must declare an explicit &lt;code&gt;serialVersionUID&lt;/code&gt; value. It is also strongly advised that explicit &lt;code&gt;serialVersionUID&lt;/code&gt; declarations use the private modifier where possible, since such declarations apply only to the immediately declaring class &lt;code&gt;serialVersionUID&lt;/code&gt; fields are not useful as inherited members.</source>
          <target state="translated">Si una clase serializable no declara expl&amp;iacute;citamente un &lt;code&gt;serialVersionUID&lt;/code&gt; , el tiempo de ejecuci&amp;oacute;n de serializaci&amp;oacute;n calcular&amp;aacute; un valor predeterminado &lt;code&gt;serialVersionUID&lt;/code&gt; para esa clase en funci&amp;oacute;n de varios aspectos de la clase, como se describe en la Especificaci&amp;oacute;n de serializaci&amp;oacute;n de objetos Java (TM). Sin embargo, se &lt;em&gt;recomienda encarecidamente&lt;/em&gt; que todas las clases serializables declaren expl&amp;iacute;citamente los valores &lt;code&gt;serialVersionUID&lt;/code&gt; , ya que el c&amp;aacute;lculo predeterminado &lt;code&gt;serialVersionUID&lt;/code&gt; es muy sensible a los detalles de la clase que pueden variar dependiendo de las implementaciones del compilador y, por lo tanto, pueden dar como resultado &lt;code&gt;InvalidClassExceptions&lt;/code&gt; inesperadas durante la deserializaci&amp;oacute;n. Por lo tanto, para garantizar un valor de &lt;code&gt;serialVersionUID&lt;/code&gt; consistente en diferentes implementaciones del compilador de Java, una clase serializable debe declarar un valor de &lt;code&gt;serialVersionUID&lt;/code&gt; expl&amp;iacute;cito. Tambi&amp;eacute;n se recomienda encarecidamente que las declaraciones expl&amp;iacute;citas &lt;code&gt;serialVersionUID&lt;/code&gt; utilicen el modificador privado siempre que sea posible, ya que dichas declaraciones se aplican solo a la clase de declaraci&amp;oacute;n inmediata &lt;code&gt;serialVersionUID&lt;/code&gt; campos serialVersionUID no son &amp;uacute;tiles como miembros heredados.</target>
        </trans-unit>
        <trans-unit id="ac07961b643911ddcb2c896810537f0afd622445" translate="yes" xml:space="preserve">
          <source>If so, set &lt;code&gt;serialVersionUID=1L&lt;/code&gt;.</source>
          <target state="translated">Si es as&amp;iacute;, configure &lt;code&gt;serialVersionUID=1L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c50d35d2b9efc3203d7444d68cd27712448b2f" translate="yes" xml:space="preserve">
          <source>If the class is serializable you can also declare your own serialVersionUID explicitly  by declaring a field named &quot;serialVersionUID&quot; that must be static, final, and of type long. Most IDE's like Eclipse help you generate that long string.</source>
          <target state="translated">Si la clase es serializable también puedes declarar tu propio serialVersionUID explícitamente declarando un campo llamado &quot;serialVersionUID&quot; que debe ser estático,final y de tipo largo.La mayoría de los IDE como Eclipse te ayudan a generar esa larga cadena.</target>
        </trans-unit>
        <trans-unit id="0908a1a1336c6604f42496dbb63562f68b64f6fe" translate="yes" xml:space="preserve">
          <source>If you are just testing something with unimportant/fake data, then don't worry about it (unless you are testing serialization directly).</source>
          <target state="translated">Si sólo estás probando algo con datos falsos sin importancia,entonces no te preocupes (a menos que estés probando la serialización directamente).</target>
        </trans-unit>
        <trans-unit id="8a69924d7d5897fafcf895033701a64bf405b8cf" translate="yes" xml:space="preserve">
          <source>If you do forget to update the field, you might end up with two different versions of a class with different structure but with the same &lt;code&gt;serialVersionUID&lt;/code&gt;. If this happens, the default mechanism (&lt;code&gt;in.defaultReadObject()&lt;/code&gt;) will not detect any difference, and try to de-serialize incompatible data. Now you might end up with a cryptic runtime error or silent failure (null fields). These types of errors might be hard to find.</source>
          <target state="translated">Si olvida actualizar el campo, puede terminar con dos versiones diferentes de una clase con una estructura diferente pero con el mismo &lt;code&gt;serialVersionUID&lt;/code&gt; . Si esto sucede, el mecanismo predeterminado ( &lt;code&gt;in.defaultReadObject()&lt;/code&gt; ) no detectar&amp;aacute; ninguna diferencia e intentar&amp;aacute; deserializar los datos incompatibles. Ahora puede terminar con un error de tiempo de ejecuci&amp;oacute;n cr&amp;iacute;ptico o una falla silenciosa (campos nulos). Este tipo de errores puede ser dif&amp;iacute;cil de encontrar.</target>
        </trans-unit>
        <trans-unit id="951eb1700ec9d7b7fe70f87bfe0e3fabca70f057" translate="yes" xml:space="preserve">
          <source>If you don't want that warning to come, use this:</source>
          <target state="translated">Si no quieres que llegue esa advertencia,usa esto:</target>
        </trans-unit>
        <trans-unit id="759c21d48ab7d563cb615b405b767a40ee3165b5" translate="yes" xml:space="preserve">
          <source>If you get this warning on a class you don't ever think about serializing, and that you didn't declare yourself &lt;code&gt;implements Serializable&lt;/code&gt;, it is often because you inherited from a superclass, which implements Serializable. Often then it would be better to delegate to such a object instead of using inheritance.</source>
          <target state="translated">Si recibe esta advertencia en una clase en la que nunca piensa en serializar, y que no se declar&amp;oacute; &lt;code&gt;implements Serializable&lt;/code&gt; , a menudo es porque hered&amp;oacute; de una superclase, que implementa Serializable. A menudo, entonces ser&amp;iacute;a mejor delegar a dicho objeto en lugar de usar la herencia.</target>
        </trans-unit>
        <trans-unit id="a4a72dc9110f96c64679ef74b8fdb11f2882cfd8" translate="yes" xml:space="preserve">
          <source>If you ignore them for now, and find later that you need to change the class in some way but maintain compatibility w/ old version of the class, you can use the JDK tool &lt;strong&gt;serialver&lt;/strong&gt; to generate the &lt;code&gt;serialVersionUID&lt;/code&gt; on the &lt;em&gt;old&lt;/em&gt; class, and explicitly set that on the new class.  (Depending on your changes you may need to also implement custom serialization by adding &lt;code&gt;writeObject&lt;/code&gt; and &lt;code&gt;readObject&lt;/code&gt; methods - see &lt;code&gt;Serializable&lt;/code&gt; javadoc or aforementioned chapter 11.)</source>
          <target state="translated">Si los ignora por ahora y luego descubre que necesita cambiar la clase de alguna manera pero mantener la compatibilidad con la versi&amp;oacute;n anterior de la clase, puede usar el &lt;strong&gt;serialver de la&lt;/strong&gt; herramienta JDK para generar el &lt;code&gt;serialVersionUID&lt;/code&gt; en la clase anterior y establecer expl&amp;iacute;citamente eso en la nueva clase. (Dependiendo de sus cambios, es posible que tambi&amp;eacute;n necesite implementar una serializaci&amp;oacute;n personalizada agregando m&amp;eacute;todos &lt;code&gt;writeObject&lt;/code&gt; y &lt;code&gt;readObject&lt;/code&gt; ; consulte Javadoc &lt;code&gt;Serializable&lt;/code&gt; o el cap&amp;iacute;tulo 11 mencionado anteriormente).</target>
        </trans-unit>
        <trans-unit id="a5fe6571b7d4d90271296db8f6745f9d44b41fb5" translate="yes" xml:space="preserve">
          <source>If you want to amend a huge number of classes which had no serialVersionUID set in the first place while maintain the compatibility with the old classes, tools like IntelliJ Idea, Eclipse fall short as they generate random numbers and does not work on a bunch of files in one go. I come up the following bash script(I'm sorry for Windows users, consider buy a Mac or convert to Linux) to make amending serialVersionUID issue with ease:</source>
          <target state="translated">Si quieres modificar un gran número de clases que no tenían el serialVersionUID establecido en primer lugar mientras mantienes la compatibilidad con las clases antiguas,herramientas como IntelliJ Idea,Eclipse se quedan cortas ya que generan números aleatorios y no funcionan en un montón de archivos de una sola vez.He creado el siguiente script bash (lo siento por los usuarios de Windows,consideren la posibilidad de comprar un Mac o convertirlo a Linux)para hacer que la modificación del serialVersionUID sea fácil:</target>
        </trans-unit>
        <trans-unit id="47e78ed2014802b0c9a3a92e7fdf1eafb51b07c7" translate="yes" xml:space="preserve">
          <source>If you want to version your data, you normally start with a &lt;code&gt;serialVersionUID&lt;/code&gt; of 0, and bump it with every structural change to your class which alters the serialized data (adding or removing non-transient fields).</source>
          <target state="translated">Si desea versionar sus datos, normalmente comienza con un &lt;code&gt;serialVersionUID&lt;/code&gt; de 0, y lo agrega con cada cambio estructural a su clase que altera los datos serializados (agregando o eliminando campos no transitorios).</target>
        </trans-unit>
        <trans-unit id="92d52d748e3a903cd8cfe5335e2f7600d6a4d99c" translate="yes" xml:space="preserve">
          <source>If you will never need to serialize your objects to byte array and send/store them, then you don't need to worry about it. If you do, then you must consider your serialVersionUID since the deserializer of the object will match it to the version of object its classloader has. Read more about it in the Java Language Specification.</source>
          <target state="translated">Si nunca necesitarás serializar tus objetos a una matriz de bytes y enviarlos a un almacén,entonces no tienes que preocuparte por ello.Si lo haces,entonces debes considerar tu serialVersionUID ya que el deserializador del objeto lo hará coincidir con la versión del objeto que tiene su cargador de clase.Lee más sobre esto en la Especificación del Lenguaje Java.</target>
        </trans-unit>
        <trans-unit id="43fdca2264665fac30b5995e1d2da647337a6fbf" translate="yes" xml:space="preserve">
          <source>If you're actually using serialization, it only matters if you plan on storing and retrieving objects using serialization directly.  The &lt;code&gt;serialVersionUID&lt;/code&gt; represents your class version, and you should increment it if the current version of your class is not backwards compatible with its previous version.</source>
          <target state="translated">Si realmente est&amp;aacute; utilizando la serializaci&amp;oacute;n, solo importa si planea almacenar y recuperar objetos utilizando la serializaci&amp;oacute;n directamente. &lt;code&gt;serialVersionUID&lt;/code&gt; representa la versi&amp;oacute;n de su clase, y debe aumentarla si la versi&amp;oacute;n actual de su clase no es compatible con su versi&amp;oacute;n anterior.</target>
        </trans-unit>
        <trans-unit id="9128ba1afb3e0f24bb0e62ed32e59ef238f14973" translate="yes" xml:space="preserve">
          <source>If you're serializing just because you have to serialize for the implementation's sake (who cares if you serialize for an &lt;code&gt;HTTPSession&lt;/code&gt;, for instance...if it's stored or not, you probably don't care about &lt;code&gt;de-serializing&lt;/code&gt; a form object), then you can ignore this.</source>
          <target state="translated">Si est&amp;aacute; serializando solo porque tiene que serializar por el bien de la implementaci&amp;oacute;n (a qui&amp;eacute;n le importa si serializa una &lt;code&gt;HTTPSession&lt;/code&gt; , por ejemplo ... si est&amp;aacute; almacenada o no, probablemente no le importe &lt;code&gt;de-serializing&lt;/code&gt; un objeto de formulario) , entonces puedes ignorar esto.</target>
        </trans-unit>
        <trans-unit id="be310d22adb7eb6ed4cdc4f31b81e366e345fd16" translate="yes" xml:space="preserve">
          <source>In case you didn't know, there are a lot of other warnings you can enable in this section (or even have some reported as errors), many are very useful:</source>
          <target state="translated">En caso de que no lo supieras,hay muchas otras advertencias que puedes habilitar en esta sección (o incluso tener algunas reportadas como errores),muchas son muy útiles:</target>
        </trans-unit>
        <trans-unit id="8b137380d829b068c0e1561e7670589d03744bf7" translate="yes" xml:space="preserve">
          <source>In this case you are not interested in maintaining backwards compatibility. You are only concerned with making sure that the code bases which are communicating indeed have the same versions of relevant classes. In order to facilitate such a check, you must maintain the &lt;code&gt;serialVersionUID&lt;/code&gt; just like before and not forget to update it when making changes to your classes.</source>
          <target state="translated">En este caso, no est&amp;aacute; interesado en mantener la compatibilidad con versiones anteriores. Solo le interesa asegurarse de que las bases de c&amp;oacute;digo que se comunican tienen las mismas versiones de clases relevantes. Para facilitar dicha verificaci&amp;oacute;n, debe mantener el &lt;code&gt;serialVersionUID&lt;/code&gt; como antes y no olvidar actualizarlo cuando realice cambios en sus clases.</target>
        </trans-unit>
        <trans-unit id="61679231af4ad410dbfa2dd92c43eea9061a90d9" translate="yes" xml:space="preserve">
          <source>Is this the first version?</source>
          <target state="translated">¿Esta es la primera versión?</target>
        </trans-unit>
        <trans-unit id="2a229b4a574a575150819f17c367c9fd921fd37d" translate="yes" xml:space="preserve">
          <source>Is this the second, third, etc. prod version?</source>
          <target state="translated">¿Esta es la segunda,tercera,etc.versión del producto?</target>
        </trans-unit>
        <trans-unit id="a2d78a74baa97f72bc98472f33a22bf2ab946a4e" translate="yes" xml:space="preserve">
          <source>It would be nice if CheckStyle could verify that the serialVersionUID on a class that implements Serializable has a good value, i.e. that it matches what the serial version id  generator would produce.  If you have a project with lots of serializable DTOs, for example, remembering to delete the existing serialVersionUID and regenerate it is a pain, and currently the only way (that I know of) to verify this is to regenerate for each class and compare to the old one.  This is very very painful.</source>
          <target state="translated">Sería bueno que CheckStyle pudiera verificar que el serialVersionUID en una clase que implementa Serializable tiene un buen valor,es decir,que coincide con lo que el generador de ID de versión serial produciría.Si tienes un proyecto con muchos DTOs serializables,por ejemplo,acordarte de borrar el serialVersionUID existente y regenerarlo es una molestia,y actualmente la única manera (que yo sepa)de verificarlo es regenerar para cada clase y compararlo con el antiguo.Esto es muy,muy doloroso.</target>
        </trans-unit>
        <trans-unit id="45452c347dba4596f7fc6f779b60255c33b9b741" translate="yes" xml:space="preserve">
          <source>Least obvious - Sometimes you change the idea you put in some field's meaning. For example when you are 12 years old you mean &quot;bicycle&quot; under &quot;bike&quot;, but when you are 18 you mean &quot;motorcycle&quot; - if your friends will invite you to &quot;bike ride across city&quot; and you will be the only one who came on bicycle, you will undestand how important it is to keep same meaning across fields :-)</source>
          <target state="translated">Menos obvio-A veces cambias la idea que le das al significado de algún campo.Por ejemplo,cuando tienes 12 años quieres decir &quot;bicicleta&quot; bajo &quot;bici&quot;,pero cuando tienes 18 quieres decir &quot;motocicleta&quot;-si tus amigos te invitan a &quot;pasear en bici por la ciudad&quot; y eres el único que vino en bici,entenderás lo importante que es mantener el mismo significado a través de los campos :-)</target>
        </trans-unit>
        <trans-unit id="92b2158c9da67c9bc8cebe83d5a434148a52fd77" translate="yes" xml:space="preserve">
          <source>Less obvious - When you deserialize object, fields that where not present in string will be kept as NULL. If you have removed field from your object, older versions will keep this field as allways-NULL that can lead to misbehavior if older versions rely on data in this field (anyway you have created it for something, not just for fun :-) )</source>
          <target state="translated">Menos obvio-Cuando deserializas un objeto,los campos que no están presentes en la cadena se mantienen como NULL.Si ha eliminado el campo de su objeto,las versiones antiguas mantendrán este campo como NULLL que puede llevar a un mal comportamiento si las versiones antiguas se basan en los datos de este campo (de todas formas lo ha creado para algo,no sólo por diversión :-))</target>
        </trans-unit>
        <trans-unit id="f39b41b433bf1ccbaddc2f3409f68a365496127f" translate="yes" xml:space="preserve">
          <source>Let's try this with an example.</source>
          <target state="translated">Intentemos esto con un ejemplo.</target>
        </trans-unit>
        <trans-unit id="18e32355c6b6633308045dc45a2607e31ca575a8" translate="yes" xml:space="preserve">
          <source>Most obvious - if you add some fields to your object, older versions will not be able to use them because they do not have these fields in their object structure.</source>
          <target state="translated">Lo más obvio es que si se añaden algunos campos a su objeto,las versiones anteriores no podrán utilizarlos porque no tienen estos campos en su estructura de objeto.</target>
        </trans-unit>
        <trans-unit id="669226aa9f0c15ca8184278e717e0a11aea7ad79" translate="yes" xml:space="preserve">
          <source>Most of the time, you will probably not use serialization directly.  If this is the case, generate a default &lt;code&gt;SerialVersionUID&lt;/code&gt; by clicking the quick fix option and don't worry about it.</source>
          <target state="translated">La mayor&amp;iacute;a de las veces, probablemente no utilizar&amp;aacute; la serializaci&amp;oacute;n directamente. Si este es el caso, genere un &lt;code&gt;SerialVersionUID&lt;/code&gt; predeterminado haciendo clic en la opci&amp;oacute;n de soluci&amp;oacute;n r&amp;aacute;pida y no se preocupe.</target>
        </trans-unit>
        <trans-unit id="03db456b4b5f92dd61b1356634c41f730702aac1" translate="yes" xml:space="preserve">
          <source>NOTE: Now change the serialVersionUID of the Employee class and save:</source>
          <target state="translated">NOTA:Ahora cambia el serialVersionUID de la clase de Empleados y guarda:</target>
        </trans-unit>
        <trans-unit id="dfaed926e28cd77167b75a9487c6069d6863f33d" translate="yes" xml:space="preserve">
          <source>Now you need to worry about &lt;code&gt;serialVersionUID&lt;/code&gt;, and should look into it in depth.</source>
          <target state="translated">Ahora debe preocuparse por &lt;code&gt;serialVersionUID&lt;/code&gt; y debe analizarlo en profundidad.</target>
        </trans-unit>
        <trans-unit id="82faeed0157b5916b620f337d6af90d923051ddd" translate="yes" xml:space="preserve">
          <source>One case where the warning (or the serialVersionUID) is unavoidable is when you extend from AbstractAction, normally in a anonymous class, only adding the actionPerformed-method. I think there shouldn't be a warning in this case (since you normally can't reliable serialize and deserialize such anonymous classes anyway accross different versions of your class), but I'm not sure how the compiler could recognize this.</source>
          <target state="translated">Un caso en el que la advertencia (o la versión en serie)es inevitable es cuando se extiende desde AbstractAction,normalmente en una clase anónima,sólo añadiendo el método actionPerformed.Creo que no debería haber un warning en este caso (ya que normalmente no se puede serializar y deserializar de forma fiable tales clases anónimas de todos modos a través de diferentes versiones de su clase),pero no estoy seguro de cómo el compilador podría reconocer esto.</target>
        </trans-unit>
        <trans-unit id="e369a1bf1e8a1cf49b05c9badf1d38385d36fce2" translate="yes" xml:space="preserve">
          <source>Original question has asked for 'why is it important' and 'example' where this &lt;code&gt;Serial Version ID&lt;/code&gt; would be useful. Well I have found one.</source>
          <target state="translated">La pregunta original ha preguntado &quot;por qu&amp;eacute; es importante&quot; y &quot;ejemplo&quot; donde esta &lt;code&gt;Serial Version ID&lt;/code&gt; ser&amp;iacute;a &amp;uacute;til. Pues he encontrado uno.</target>
        </trans-unit>
        <trans-unit id="fc9f0a13cf25ff497bc08bf7b647cdd500b7bf4a" translate="yes" xml:space="preserve">
          <source>Per Josh, the automatically-generated UID is generated based on a class name, implemented interfaces, and all public and protected members.  Changing any of these in any way will change the &lt;code&gt;serialVersionUID&lt;/code&gt;.  So you don't need to mess with them only if you are certain that no more than one version of the class will ever be serialized (either across processes or retrieved from storage at a later time).</source>
          <target state="translated">Seg&amp;uacute;n Josh, el UID generado autom&amp;aacute;ticamente se genera en funci&amp;oacute;n de un nombre de clase, interfaces implementadas y todos los miembros p&amp;uacute;blicos y protegidos. Cambiar cualquiera de estos de cualquier manera cambiar&amp;aacute; el &lt;code&gt;serialVersionUID&lt;/code&gt; . Por lo tanto, no necesita meterse con ellos solo si est&amp;aacute; seguro de que no se serializar&amp;aacute; m&amp;aacute;s de una versi&amp;oacute;n de la clase (ya sea a trav&amp;eacute;s de procesos o recuperada del almacenamiento en un momento posterior).</target>
        </trans-unit>
        <trans-unit id="2b4f26b8feb8f937d7254f3894358897952b1658" translate="yes" xml:space="preserve">
          <source>Potential Programming Problems: Null pointer access</source>
          <target state="translated">Posibles problemas de programación:Acceso de puntero nulo</target>
        </trans-unit>
        <trans-unit id="8d7e6c1f080cc867a97ebca251cf8c9fb3e16838" translate="yes" xml:space="preserve">
          <source>Potential Programming Problems: Possible accidental boolean assignment</source>
          <target state="translated">Posibles problemas de programación:Posible asignación booleana accidental</target>
        </trans-unit>
        <trans-unit id="8b5ec26f30c3fea832b7f1abbafeeb9897906405" translate="yes" xml:space="preserve">
          <source>Read more: &lt;a href=&quot;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&quot;&gt;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&lt;/a&gt;</source>
          <target state="translated">Leer m&amp;aacute;s: &lt;a href=&quot;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&quot;&gt;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39f3eac3245d6e2e25325a60e97f8a037e33f3f7" translate="yes" xml:space="preserve">
          <source>Say you create a &lt;code&gt;Car&lt;/code&gt; class, instantiate it, and write it out to an object stream. The flattened car object sits in the file system for some time. Meanwhile, if the &lt;code&gt;Car&lt;/code&gt; class is modified by adding a new field. Later on, when you try to read (i.e. deserialize) the flattened &lt;code&gt;Car&lt;/code&gt; object, you get the &lt;code&gt;java.io.InvalidClassException&lt;/code&gt; &amp;ndash; because all serializable classes are automatically given a unique identifier. This exception is thrown when the identifier of the class is not equal to the identifier of the flattened object. If you really think about it, the exception is thrown because of the addition of the new field. You can avoid this exception being thrown by controlling the versioning yourself by declaring an explicit serialVersionUID. There is also a small performance benefit in explicitly declaring your &lt;code&gt;serialVersionUID&lt;/code&gt; (because does not have to be calculated). So, it is best practice to add your own serialVersionUID to your Serializable classes as soon as you create them as shown below:</source>
          <target state="translated">Supongamos que crea una clase &lt;code&gt;Car&lt;/code&gt; , la instancia y la escribe en una secuencia de objetos. El objeto aplanado del autom&amp;oacute;vil permanece en el sistema de archivos durante un tiempo. Mientras tanto, si la clase &lt;code&gt;Car&lt;/code&gt; se modifica agregando un nuevo campo. M&amp;aacute;s adelante, cuando intentas leer (es decir, deserializar) el objeto &lt;code&gt;Car&lt;/code&gt; aplanado, obtienes la &lt;code&gt;java.io.InvalidClassException&lt;/code&gt; , porque todas las clases serializables reciben autom&amp;aacute;ticamente un identificador &amp;uacute;nico. Esta excepci&amp;oacute;n se produce cuando el identificador de la clase no es igual al identificador del objeto aplanado. Si realmente lo piensa, la excepci&amp;oacute;n se produce debido a la adici&amp;oacute;n del nuevo campo. Puede evitar esta excepci&amp;oacute;n controlando la versi&amp;oacute;n usted mismo declarando un serialVersionUID expl&amp;iacute;cito. Tambi&amp;eacute;n hay un peque&amp;ntilde;o beneficio de rendimiento al declarar expl&amp;iacute;citamente su &lt;code&gt;serialVersionUID&lt;/code&gt; (porque no tiene que calcularse). Por lo tanto, es una buena pr&amp;aacute;ctica agregar su propio serialVersionUID a sus clases serializables tan pronto como las cree, como se muestra a continuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="af175b945f0af8e71b073d6998feff95f90842dc" translate="yes" xml:space="preserve">
          <source>SerialVersionUID is used for version control of object. you can specify serialVersionUID in your class file also. Consequence of not specifying serialVersionUID is that when you add or modify any field in class then already serialized class will not be able to recover because serialVersionUID generated for new class and for old serialized object will be different. Java serialization process relies on correct serialVersionUID for recovering state of serialized object and throws java.io.InvalidClassException in case of serialVersionUID mismatch</source>
          <target state="translated">SerialVersionUID se utiliza para el control de versiones del objeto.puedes especificar serialVersionUID en tu archivo de clase también.La consecuencia de no especificar serialVersionUID es que cuando añades o modificas cualquier campo de la clase,la clase ya serializada no podrá recuperarse porque el serialVersionUID generado para la nueva clase y para el antiguo objeto serializado será diferente.El proceso de serialización de Java se basa en el serialVersionUID correcto para recuperar el estado del objeto serializado y lanza java.io.InvalidClassException en caso de desajuste del serialVersionUID</target>
        </trans-unit>
        <trans-unit id="4b024388f4cf31c84b0ead4ab2043ad63c5546da" translate="yes" xml:space="preserve">
          <source>Serialization is basically writing class data to a file/stream/etc.  De-serialization is reading that data back to a class.</source>
          <target state="translated">La serialización es básicamente escribir datos de clase a un filestreametc.La des-serialización es leer esos datos de vuelta a una clase.</target>
        </trans-unit>
        <trans-unit id="a90d236667d7a7c96b56a65a967fafb3c11e3d17" translate="yes" xml:space="preserve">
          <source>Serialization:
We often work with important objects whose state (data in the variables of the object) is so important that we can not risk to lose it due to power/system failures (or) network failures in case of sending the object state to other machine. The solution for this problem is named &quot;Persistence&quot; which simply means persisting (holding/saving) the data. Serialization is one of many other ways to achieve persistence (by saving data to disk/memory). When saving the state of the object, it is important to create an identity for the object, to be able to properly read it back (de-serialization). This unique identification is ID is SerialVersionUID.</source>
          <target state="translated">Serialización:A menudo trabajamos con objetos importantes cuyo estado (datos en las variables del objeto)es tan importante que no podemos arriesgarnos a perderlo por fallos del sistema de potencia (o)fallos de la red en caso de enviar el estado del objeto a otra máquina.La solución a este problema se denomina &quot;Persistencia&quot;,que significa simplemente persistir (guardar los datos).La serialización es una de las muchas maneras de lograr la persistencia (guardando los datos en la memoria del disco).Al guardar el estado del objeto,es importante crear una identidad para el objeto,para poder leerlo correctamente de nuevo (des-serialización).Esta identificación única es ID es SerialVersionUID.</target>
        </trans-unit>
        <trans-unit id="786e6158fbc48d9b91849b94859cb9fb38b4788a" translate="yes" xml:space="preserve">
          <source>So to help this usecase, the Java platform offers you a choice of not setting the &lt;code&gt;serialVersionUID&lt;/code&gt; manually. Instead, a hash of the class structure will be generated at compile-time and used as id. This mechanism will make sure that you never have different class structures with the same id, and so you will not get these hard-to-trace runtime serialization failures mentioned above.</source>
          <target state="translated">Entonces, para ayudar a este caso de uso, la plataforma Java le ofrece la opci&amp;oacute;n de no configurar el &lt;code&gt;serialVersionUID&lt;/code&gt; manualmente. En cambio, se generar&amp;aacute; un hash de la estructura de clase en tiempo de compilaci&amp;oacute;n y se usar&amp;aacute; como id. Este mecanismo se asegurar&amp;aacute; de que nunca tenga estructuras de clase diferentes con la misma identificaci&amp;oacute;n, por lo que no obtendr&amp;aacute; estos fallos de serializaci&amp;oacute;n de tiempo de ejecuci&amp;oacute;n dif&amp;iacute;ciles de rastrear mencionados anteriormente.</target>
        </trans-unit>
        <trans-unit id="50858191cffe74b141faf092db8130f8aa64446f" translate="yes" xml:space="preserve">
          <source>So we conclude that to make Serialization/Deserialization process successful the serialVersionUID of serialized object must be equivalent to the serialVersionUID of the class. In case if programmer specifies the serialVersionUID value explicitly in the program then the same value will be associated with the serialized object and the class, irrespective of the serialization and deserialzation platform(for ex. serialization might be done on platform like windows by using sun or MS JVM and Deserialization might be on different platform Linux using Zing JVM).</source>
          <target state="translated">Así que concluimos que para que el proceso de serialización-deserialización tenga éxito,el serialVersionUID del objeto serializado debe ser equivalente al serialVersionUID de la clase.En caso de que el programador especifique el valor del serialVersionUID explícitamente en el programa,el mismo valor se asociará al objeto serializado y a la clase,independientemente de la plataforma de serialización y deserialización (por ejemplo,la serialización puede realizarse en una plataforma como Windows utilizando Sun o la JVM de MS y la deserialización puede realizarse en una plataforma diferente de Linux utilizando la JVM de Zing).</target>
        </trans-unit>
        <trans-unit id="24bcc5bfeaec8f6116cfc0a18304cb69edac70ac" translate="yes" xml:space="preserve">
          <source>So, instead of</source>
          <target state="translated">Así que,en lugar de</target>
        </trans-unit>
        <trans-unit id="538886bb8c0fa8986dc37e9dc9a75511ddd40509" translate="yes" xml:space="preserve">
          <source>Specifying one gives more control, though JVM does generate one if you don't specify. The value generated can differ between different compilers. Furthermore, sometimes you just want for some reason to forbid deserialization of old serialized objects [&lt;code&gt;backward incompatibility&lt;/code&gt;], and in this case you just have to change the serialVersionUID.</source>
          <target state="translated">Especificar uno da m&amp;aacute;s control, aunque JVM genera uno si no lo especifica. El valor generado puede diferir entre diferentes compiladores. Adem&amp;aacute;s, a veces solo desea por alguna raz&amp;oacute;n prohibir la deserializaci&amp;oacute;n de objetos serializados antiguos [ &lt;code&gt;backward incompatibility&lt;/code&gt; ], y en este caso solo tiene que cambiar el serialVersionUID.</target>
        </trans-unit>
        <trans-unit id="92c72fe26fb9d9097b9d0d0fcb80b3ee120d57ea" translate="yes" xml:space="preserve">
          <source>Static fields (with static modifier) are not serialized.</source>
          <target state="translated">Los campos estáticos (con modificador estático)no se serializan.</target>
        </trans-unit>
        <trans-unit id="d7e2b2c0be6f1557cd2bd472fca064db6f1767b9" translate="yes" xml:space="preserve">
          <source>The built-in de-serialization mechanism (&lt;code&gt;in.defaultReadObject()&lt;/code&gt;) will refuse to de-serialize from old versions of the data. But if you want to you can define your own &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/guide/serialization/spec/input.html#2971&quot;&gt;readObject()&lt;/a&gt;-function which can read back old data. This custom code can then check the &lt;code&gt;serialVersionUID&lt;/code&gt; in order to know which version the data is in and decide how to de-serialize it. This versioning technique is useful if you store serialized data which survives several versions of your code.</source>
          <target state="translated">El mecanismo de &lt;code&gt;in.defaultReadObject()&lt;/code&gt; ( in.defaultReadObject () ) se negar&amp;aacute; a deserializar las versiones anteriores de los datos. Pero si lo desea, puede definir su propia funci&amp;oacute;n &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/guide/serialization/spec/input.html#2971&quot;&gt;readObject ()&lt;/a&gt; que puede leer datos antiguos. Este c&amp;oacute;digo personalizado puede verificar el &lt;code&gt;serialVersionUID&lt;/code&gt; para saber en qu&amp;eacute; versi&amp;oacute;n est&amp;aacute;n los datos y decidir c&amp;oacute;mo deserializarlos . Esta t&amp;eacute;cnica de control de versiones es &amp;uacute;til si almacena datos serializados que sobreviven a varias versiones de su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="e243771f8f2c8fb470fa0bee8b336e82b28f4fd9" translate="yes" xml:space="preserve">
          <source>The call to the &lt;code&gt;EJB&lt;/code&gt; was failing with the Exception below because I hadn't declared its &lt;code&gt;serialVersionUID&lt;/code&gt;:</source>
          <target state="translated">La llamada al &lt;code&gt;EJB&lt;/code&gt; estaba fallando con la excepci&amp;oacute;n a continuaci&amp;oacute;n porque no hab&amp;iacute;a declarado su &lt;code&gt;serialVersionUID&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05cab8052e138b165623cdfaf9a111dbdf55093e" translate="yes" xml:space="preserve">
          <source>The docs for &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html&quot;&gt;&lt;code&gt;java.io.Serializable&lt;/code&gt;&lt;/a&gt; are probably about as good an explanation as you'll get:</source>
          <target state="translated">Los documentos para &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html&quot;&gt; &lt;code&gt;java.io.Serializable&lt;/code&gt; &lt;/a&gt; son probablemente una explicaci&amp;oacute;n tan buena como la que obtendr&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="5f1a9e80a8a62dc5fed2428c8ee1933622e0baed" translate="yes" xml:space="preserve">
          <source>The serializable class Foo does not declare a static final
  serialVersionUID field of type long</source>
          <target state="translated">La clase serializable Foo no declara un campo estático final serialVersionUID de tipo largo</target>
        </trans-unit>
        <trans-unit id="8d3646af1ce2f3da7f74099102cfd890330046cf" translate="yes" xml:space="preserve">
          <source>The serialization runtime associates with each serializable class a version number, called a &lt;code&gt;serialVersionUID&lt;/code&gt;, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different &lt;code&gt;serialVersionUID&lt;/code&gt; than that of the corresponding sender's class, then deserialization will result in an 
  &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InvalidClassException.html&quot;&gt;&lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/a&gt;. A serializable class can declare its own &lt;code&gt;serialVersionUID&lt;/code&gt; explicitly by declaring a field named &lt;code&gt;serialVersionUID&lt;/code&gt; that must be static, final, and of type &lt;code&gt;long&lt;/code&gt;:</source>
          <target state="translated">El tiempo de ejecuci&amp;oacute;n de serializaci&amp;oacute;n asocia a cada clase serializable un n&amp;uacute;mero de versi&amp;oacute;n, llamado &lt;code&gt;serialVersionUID&lt;/code&gt; , que se utiliza durante la deserializaci&amp;oacute;n para verificar que el emisor y el receptor de un objeto serializado hayan cargado clases para ese objeto que sean compatibles con respecto a la serializaci&amp;oacute;n. Si el receptor ha cargado una clase para el objeto que tiene un &lt;code&gt;serialVersionUID&lt;/code&gt; diferente al de la clase del remitente correspondiente, la deserializaci&amp;oacute;n dar&amp;aacute; como resultado una &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InvalidClassException.html&quot;&gt; &lt;code&gt;InvalidClassException&lt;/code&gt; &lt;/a&gt; . Una clase serializable puede declarar su propio &lt;code&gt;serialVersionUID&lt;/code&gt; expl&amp;iacute;citamente declarando un campo llamado &lt;code&gt;serialVersionUID&lt;/code&gt; que debe ser est&amp;aacute;tico, final y de tipo &lt;code&gt;long&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9d73388301e50851d95c48f1857d574425566028" translate="yes" xml:space="preserve">
          <source>The serialization runtime comes up with a number called Serial version for each serializable class. This number is called serialVersionUID. Now there is some Math behind this number and it comes out based on the fields/methods that are defined in the class. For the same class the same version is generated every time. This number is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender's class, then deserialization will result in an InvalidClassException.</source>
          <target state="translated">El tiempo de ejecución de la serialización aparece con un número llamado Versión serial para cada clase serializable.Este número se llama serialVersionUID.Ahora hay algo de matemáticas detrás de este número y sale basado en los métodos de campos que están definidos en la clase.Para la misma clase se genera la misma versión cada vez.Este número se utiliza durante la deserialización para verificar que el emisor y el receptor de un objeto serializado han cargado clases para ese objeto que son compatibles con respecto a la serialización.Si el receptor ha cargado una clase para el objeto que tiene un serialVersionUID diferente al de la clase del emisor correspondiente,entonces la deserialización resultará en una InvalidClassException.</target>
        </trans-unit>
        <trans-unit id="e1820339c9471fdde6c6876cce75b62eb78d6e1e" translate="yes" xml:space="preserve">
          <source>This .lst includes the list of java files to add the serialVersionUID in the following format:</source>
          <target state="translated">Este .lst incluye la lista de archivos java para agregar el serialVersionUID en el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="df238493e0e777844116509927cb606c7ebeaf41" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;POJO's&lt;/code&gt; class was packaged inside the EJB jar and inside it's own jar in the WEB-INF/lib of the web module. They're actually the same class, but when I package the EJB module I unpack this POJO's jar to pack it together with the EJB module.</source>
          <target state="translated">Esta clase &lt;code&gt;POJO's&lt;/code&gt; fue empaquetada dentro del jar EJB y dentro de su propio jar en el WEB-INF / lib del m&amp;oacute;dulo web. En realidad son de la misma clase, pero cuando empaquete el m&amp;oacute;dulo EJB, desempaquete el jar de POJO para empacarlo junto con el m&amp;oacute;dulo EJB.</target>
        </trans-unit>
        <trans-unit id="eda370108a690dac70b6b7f258be620a2ea98537" translate="yes" xml:space="preserve">
          <source>This question is very well documented in Effective Java by Joshua Bloch. A very good book and a must read. I will outline some of the reasons below :</source>
          <target state="translated">Esta cuestión está muy bien documentada en Effective Java por Joshua Bloch.Un libro muy bueno y de lectura obligada.A continuación expondré algunas de las razones:</target>
        </trans-unit>
        <trans-unit id="e6c3eaa61a8392ceb99402b7ec2b883a685250df" translate="yes" xml:space="preserve">
          <source>This script uses the JDK serialVer tool under hood. So make sure your $JAVA_HOME/bin is in the PATH.</source>
          <target state="translated">Este guión utiliza la herramienta JDK serialVer bajo el capó.Así que asegúrate de que tu $JAVA_HOMEbin está en el PATH.</target>
        </trans-unit>
        <trans-unit id="dbfd0fd5f5dc0716357b84d3ad13563ed41cd74d" translate="yes" xml:space="preserve">
          <source>To tell the long story short this field is used to check if serialized data can be deserialized correctly. Serialization and deserialization are often made by different copies of program - for example server converts object to string and client converts received string to object. This field tells that both operates with same idea about what this object is. This field helps when:</source>
          <target state="translated">En resumen,este campo se utiliza para comprobar si los datos serializados pueden ser deserializados correctamente.La serialización y la deserialización se realizan a menudo mediante diferentes copias del programa,por ejemplo,el servidor convierte el objeto en cadena y el cliente convierte la cadena recibida en objeto.Este campo indica que ambos operan con la misma idea sobre qué es este objeto.Este campo ayuda cuando:</target>
        </trans-unit>
        <trans-unit id="dd3e2784d9ca1e76f345e2c02320bcee304f69db" translate="yes" xml:space="preserve">
          <source>To understand the significance of field serialVersionUID, one should understand how Serialization/Deserialization works.</source>
          <target state="translated">Para entender el significado del campo serialVersionUID,uno debe entender cómo funciona la SerializaciónDeserialización.</target>
        </trans-unit>
        <trans-unit id="37e77042a8574f7bc74e7c4eac7f95cdb9c58c3e" translate="yes" xml:space="preserve">
          <source>Transient fields (with transient modifier) are NOT serialized, (i.e., not saved or restored). A class that implements Serializable must mark transient fields of classes that do not support serialization (e.g., a file stream).</source>
          <target state="translated">Los campos transitorios (con modificador transitorio)NO se serializan,(es decir,no se guardan ni se restauran).Una clase que implementa Serializable debe marcar los campos transitorios de las clases que no admiten serialización (por ejemplo,un flujo de archivos).</target>
        </trans-unit>
        <trans-unit id="6933e4b126085de9a1c38f4952dbf4a40e9a5eb8" translate="yes" xml:space="preserve">
          <source>Unnecessary code: Local variable is never read</source>
          <target state="translated">Un código innecesario:La variable local nunca se lee</target>
        </trans-unit>
        <trans-unit id="f4dc52549539b19698124f7e90a02424ea54ba1a" translate="yes" xml:space="preserve">
          <source>Unnecessary code: Redundant null check</source>
          <target state="translated">Un código innecesario:Chequeo nulo redundante</target>
        </trans-unit>
        <trans-unit id="c7210433dda8b7ce92a18a3075ff6bf0ef7ad0e4" translate="yes" xml:space="preserve">
          <source>Unnecessary code: Unnecessary cast or 'instanceof'</source>
          <target state="translated">Un código innecesario:Lanzamiento innecesario o &quot;instancia de</target>
        </trans-unit>
        <trans-unit id="fd9d198118f237407393e2591aad4500758c788d" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;serialVersionUID&lt;/code&gt; and why is it important?  Please show an example where missing &lt;code&gt;serialVersionUID&lt;/code&gt; will cause a problem.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; es &lt;code&gt;serialVersionUID&lt;/code&gt; y por qu&amp;eacute; es importante? &lt;code&gt;serialVersionUID&lt;/code&gt; un ejemplo donde la falta de serialVersionUID causar&amp;aacute; un problema.</target>
        </trans-unit>
        <trans-unit id="a4ea858c614f1d33ff483134e363a7793202d993" translate="yes" xml:space="preserve">
          <source>What is SerialVersionUID?
Answer : - Lets say there are two persons, one from HQ and another from ODC, both are going to perform serialization and deserialization respectively. In this case to authenticate that the receiver who is in ODC is the authenticated person, JVM creates a Unique ID which is known as SerialVersionUID.</source>
          <target state="translated">¿Qué es SerialVersionUID? Respuesta:-Digamos que hay dos personas,una del Cuartel General y otra de la ODC,ambas van a realizar la serialización y la deserialización respectivamente.En este caso para autentificar que el receptor que está en ODC es la persona autentificada,la JVM crea un ID único que se conoce como SerialVersionUID.</target>
        </trans-unit>
        <trans-unit id="950af41ee22eb0cc9a288d545197579a5b5fd3a5" translate="yes" xml:space="preserve">
          <source>What is a &lt;strong&gt;serialVersionUID&lt;/strong&gt; and why should I use it?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; es un &lt;strong&gt;serialVersionUID&lt;/strong&gt; y por qu&amp;eacute; deber&amp;iacute;a usarlo?</target>
        </trans-unit>
        <trans-unit id="8f076480c7cb5030ccf2dd924c9ba10624283650" translate="yes" xml:space="preserve">
          <source>What is a serialVersionUID and why should I use it</source>
          <target state="translated">¿Qué es una versión en serie y por qué debería usarla?</target>
        </trans-unit>
        <trans-unit id="0a65d9aec5e04f6f465638e6617262c10a1f5e64" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Object&lt;/code&gt; is serialized, Java Runtime associates the serial version number aka, the &lt;code&gt;serialVersionID&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;Object&lt;/code&gt; se serializa, Java Runtime asocia el n&amp;uacute;mero de versi&amp;oacute;n de serie, tambi&amp;eacute;n conocido como &lt;code&gt;serialVersionID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="143a994f6ea5500278ddcbc04f354fc10ddaf1e7" translate="yes" xml:space="preserve">
          <source>When a Serializable class object is serialized Java Runtime associates a serial version no.(called as serialVersionUID) with this serialized object. At the time when you deserialize this serialized object Java Runtime matches the serialVersionUID of serialized object with the serialVersionUID of the class. If both are equal then only it proceeds with the further process of deserialization else throws InvalidClassException.</source>
          <target state="translated">Cuando un objeto de clase serializable es serializado,Java Runtime asocia un número de versión serial (llamado serialVersionUID)con este objeto serializado.En el momento en que deserializa este objeto serializado,Java Runtime asocia el serialVersionUID del objeto serializado con el serialVersionUID de la clase.Si ambos son iguales,entonces sólo procede con el proceso posterior de deserialización,si no,lanza InvalidClassException.</target>
        </trans-unit>
        <trans-unit id="dc0a24660bcec6abbb26821fa0ecf2e40563a013" translate="yes" xml:space="preserve">
          <source>When is it important?</source>
          <target state="translated">¿Cuándo es importante?</target>
        </trans-unit>
        <trans-unit id="9af86a025d44d1c589a0e09607b2c8ff0ff76c70" translate="yes" xml:space="preserve">
          <source>When you declare a class as &lt;code&gt;Serializable&lt;/code&gt; by implementing marker interface &lt;code&gt;java.io.Serializable&lt;/code&gt;, Java runtime persist instance of that class into disk by using default Serialization mechanism, provided you have not customized the process using &lt;code&gt;Externalizable&lt;/code&gt; interface.</source>
          <target state="translated">Cuando declara una clase como &lt;code&gt;Serializable&lt;/code&gt; mediante la implementaci&amp;oacute;n de la interfaz de marcador &lt;code&gt;java.io.Serializable&lt;/code&gt; , el tiempo de ejecuci&amp;oacute;n de Java persiste la instancia de esa clase en el disco utilizando el mecanismo de serializaci&amp;oacute;n predeterminado, siempre que no haya personalizado el proceso utilizando la interfaz &lt;code&gt;Externalizable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4261f44712ba672b21eab3784b5b8b8c48aba87" translate="yes" xml:space="preserve">
          <source>Why SerialVersionUID?</source>
          <target state="translated">¿Por qué SerialVersionUID?</target>
        </trans-unit>
        <trans-unit id="e4dc0a485759072334d504ace695ec1b74eb1c80" translate="yes" xml:space="preserve">
          <source>Window &amp;gt; Preferences &amp;gt; Java &amp;gt; Compiler &amp;gt; Errors / Warnings &amp;gt; Potential Programming Problems</source>
          <target state="translated">Ventana&amp;gt; Preferencias&amp;gt; Java&amp;gt; Compilador&amp;gt; Errores / advertencias&amp;gt; Posibles problemas de programaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="70a5098988a4dce007a61987c0714121468c081c" translate="yes" xml:space="preserve">
          <source>You can tell Eclipse to ignore these serialVersionUID  warnings:</source>
          <target state="translated">Puedes decirle a Eclipse que ignore estas advertencias de serialVersionUID:</target>
        </trans-unit>
        <trans-unit id="ea3b691c24335342398ff9d3ac09e0eb6716601e" translate="yes" xml:space="preserve">
          <source>and in the relevant methods call &lt;code&gt;myList.foo()&lt;/code&gt; instead of &lt;code&gt;this.foo()&lt;/code&gt; (or &lt;code&gt;super.foo()&lt;/code&gt;). (This does not fit in all cases, but still quite often.)</source>
          <target state="translated">y en los m&amp;eacute;todos relevantes, llame a &lt;code&gt;myList.foo()&lt;/code&gt; lugar de &lt;code&gt;this.foo()&lt;/code&gt; (o &lt;code&gt;super.foo()&lt;/code&gt; ). (Esto no encaja en todos los casos, pero a&amp;uacute;n con bastante frecuencia).</target>
        </trans-unit>
        <trans-unit id="7316c9b112287ddcea6abbf02e4c8446c3f27278" translate="yes" xml:space="preserve">
          <source>and many more.</source>
          <target state="translated">y muchos más.</target>
        </trans-unit>
        <trans-unit id="eadcd9bd2a09c75aef04954e6799e50278ee124a" translate="yes" xml:space="preserve">
          <source>do</source>
          <target state="translated">do</target>
        </trans-unit>
        <trans-unit id="64c412067ed17ca88baea5c0927d455ab8360d0e" translate="yes" xml:space="preserve">
          <source>see also &lt;a href=&quot;http://javarevisited.blogspot.in/2014/05/why-use-serialversionuid-inside-serializable-class-in-java.html&quot;&gt;Why use SerialVersionUID inside Serializable class in Java&lt;/a&gt;</source>
          <target state="translated">vea tambi&amp;eacute;n &lt;a href=&quot;http://javarevisited.blogspot.in/2014/05/why-use-serialversionuid-inside-serializable-class-in-java.html&quot;&gt;&amp;iquest;Por qu&amp;eacute; usar SerialVersionUID dentro de la clase Serializable en Java?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2e648a183996542247521bad401174b3bcab9d2" translate="yes" xml:space="preserve">
          <source>since most of the time the default &lt;code&gt;serialVersionUID&lt;/code&gt; is sufficient.  This includes &lt;code&gt;Exception&lt;/code&gt;, &lt;code&gt;HttpServlet&lt;/code&gt;.</source>
          <target state="translated">ya que la mayor&amp;iacute;a de las veces el &lt;code&gt;serialVersionUID&lt;/code&gt; predeterminado es suficiente. Esto incluye &lt;code&gt;Exception&lt;/code&gt; , &lt;code&gt;HttpServlet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f4e5827f62a8e420e92778b85454e12110334a0" translate="yes" xml:space="preserve">
          <source>the default serialVersionUID computation is highly sensitive to class
  details that may vary depending on compiler implementations, and can
  thus result in unexpected &lt;code&gt;InvalidClassException&lt;/code&gt;s during
  deserialization.</source>
          <target state="translated">el c&amp;aacute;lculo de serialVersionUID predeterminado es muy sensible a los detalles de la clase que pueden variar seg&amp;uacute;n las implementaciones del compilador y, por lo tanto, pueden dar como resultado &lt;code&gt;InvalidClassException&lt;/code&gt; inesperados durante la deserializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d086671c4b1df573da3a6c283b2da7789b180c73" translate="yes" xml:space="preserve">
          <source>you have many different copies of your program in different places (like 1 server and 100 clients). If you will change your object, alter your version number and forget to update one this clients, it will know that he is not capable of deserialization</source>
          <target state="translated">tienes muchas copias diferentes de tu programa en diferentes lugares (como 1 servidor y 100 clientes).Si usted cambia su objeto,altera su número de versión y se olvida de actualizar uno de estos clientes,sabrá que no es capaz de deserialización</target>
        </trans-unit>
        <trans-unit id="4458b0ad6a09175946b64bee0e58807911feb856" translate="yes" xml:space="preserve">
          <source>you have stored your data in some file and later on you try to open it with updated version of your program with modified object - you will know that this file is not compatible if you keep your version right</source>
          <target state="translated">has almacenado tus datos en algún archivo y más tarde intentas abrirlo con la versión actualizada de tu programa con el objeto modificado-sabrás que este archivo no es compatible si mantienes tu versión correcta</target>
        </trans-unit>
        <trans-unit id="df86e582309ff9c8660c860f4050c0b8e4479141" translate="yes" xml:space="preserve">
          <source>you save the this script, say add_serialVersionUID.sh to you ~/bin. Then you run it in the root directory of your Maven or Gradle project like:</source>
          <target state="translated">Si guardas este script,di add_serialVersionUID.sh a ti ~bin.Luego lo ejecutas en el directorio raíz de tu proyecto Maven o Gradle como:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
