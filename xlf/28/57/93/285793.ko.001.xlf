<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/285793">
    <body>
      <group id="285793">
        <trans-unit id="ece08654998b41655e46f33e0f20babd54865886" translate="yes" xml:space="preserve">
          <source>'serialVersionUID' is a 64 bit number used to uniquely identify a class during deserialization process. When you serialize an object, serialVersionUID of the class also written to the file. Whenever you deserialize this object, java run time extract this serialVersionUID value from the serialized data and compare the same value associate with the class. If both do not match, then 'java.io.InvalidClassException' will be thrown.</source>
          <target state="translated">'serialVersionUID'는 역 직렬화 프로세스 동안 클래스를 고유하게 식별하는 데 사용되는 64 비트 숫자입니다. 객체를 직렬화하면 클래스의 serialVersionUID도 파일에 기록됩니다. 이 객체를 직렬화 해제 할 때마다 java 런타임은 직렬화 된 데이터에서이 serialVersionUID 값을 추출하고 클래스와 연관된 동일한 값을 비교합니다. 둘 다 일치하지 않으면 'java.io.InvalidClassException'이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="42edaf9723e5c4f748fc70bd7e1ff25ff4ee0521" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=45&quot;&gt;This article&lt;/a&gt; has some good points on the topic.</source>
          <target state="translated">&lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=45&quot;&gt;이 기사&lt;/a&gt; 에는 주제에 대한 몇 가지 좋은 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5d59d7913642ce893724ffc9429ca21bfe2c44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SerialVersionUID&lt;/code&gt; is a unique identifier for each class, &lt;code&gt;JVM&lt;/code&gt; uses it to compare the versions of the class ensuring that the same class was used during Serialization is loaded during Deserialization.</source>
          <target state="translated">&lt;code&gt;SerialVersionUID&lt;/code&gt; 는 각 클래스의 고유 식별자이며, &lt;code&gt;JVM&lt;/code&gt; 은 직렬화 중에 사용 된 동일한 클래스가 직렬화 해제 중에로드되도록 클래스의 버전을 비교하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="152df86e7d736482ad28fd298d1e6b599b88146a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SerialVersionUID&lt;/code&gt; is used to version serialized data. You can only de-serialize a class if it's &lt;code&gt;SerialVersionUID&lt;/code&gt; matches with the serialized instance. When we don't declare &lt;code&gt;SerialVersionUID&lt;/code&gt; in our class, Java runtime generates it for us but its not recommended. It's recommended to declare &lt;code&gt;SerialVersionUID&lt;/code&gt; as &lt;code&gt;private static final long&lt;/code&gt; variable to avoid default mechanism.</source>
          <target state="translated">&lt;code&gt;SerialVersionUID&lt;/code&gt; 는 직렬화 된 데이터를 버전 화하는 데 사용됩니다. &lt;code&gt;SerialVersionUID&lt;/code&gt; 가 직렬화 된 인스턴스와 일치하는 경우에만 클래스를 직렬화 해제 할 수 있습니다. 클래스에서 &lt;code&gt;SerialVersionUID&lt;/code&gt; 를 선언하지 않으면 Java 런타임이이를 생성하지만 권장하지는 않습니다. 기본 메커니즘을 피하려면 &lt;code&gt;SerialVersionUID&lt;/code&gt; 를 &lt;code&gt;private static final long&lt;/code&gt; 변수로 선언하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ee68f99f789b144946181e1611c0252582d08cac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serialVersionUID&lt;/code&gt; facilitates versioning of serialized data. Its value is stored with the data when serializing. When de-serializing, the same version is checked to see how the serialized data matches the current code.</source>
          <target state="translated">&lt;code&gt;serialVersionUID&lt;/code&gt; 는 직렬화 된 데이터의 버전 관리를 용이하게합니다. 직렬화 할 때 값이 데이터와 함께 저장됩니다. 직렬화 해제시 직렬화 된 데이터가 현재 코드와 어떻게 일치하는지 확인하기 위해 동일한 버전이 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="caf82cc19ceaeb5cc908ee5778f22c14c5f204e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;There are some rules for serialization&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;직렬화에는 몇 가지 규칙이 있습니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3809a6cba5b10c0cfa01db3b1df7b55838f75ba0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Where we need serialVersionID:&lt;/em&gt;&lt;/strong&gt;
During the deserialization to verify that sender and receiver are compatible with respect to serialization. If the receiver loaded the class with a different &lt;code&gt;serialVersionID&lt;/code&gt; then deserialization will end with &lt;code&gt;InvalidClassCastException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;serialVersionID가 필요한 경우 :&lt;/em&gt;&lt;/strong&gt; 직렬화 해제 중 송신자와 수신자가 직렬화와 호환되는지 확인하십시오. 수신자가 다른 &lt;code&gt;serialVersionID&lt;/code&gt; 로 클래스를로드하면 직렬화 해제는 &lt;code&gt;InvalidClassCastException&lt;/code&gt; 으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1d97b707c46087aba1ebb616cb1580f6fcc1274c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deserialization&lt;/strong&gt;: At the time of deserialization, receiver side JVM will compare the unique ID associated with the Object with local class Unique ID i.e. JVM will also create a Unique ID based on the corresponding .class file which is present in the receiver system. If both unique ID matched then only deserialization will be performed. Otherwise we will get Runtime Exception saying InvalidClassException. This unique Identifier is nothing but SerialVersionUID</source>
          <target state="translated">&lt;strong&gt;역 직렬화&lt;/strong&gt; : 역 직렬화시 수신자 측 JVM은 오브젝트와 연관된 고유 ID를 로컬 클래스 고유 ID와 비교합니다. 즉 JVM은 수신자 시스템에있는 해당 .class 파일을 기반으로 고유 ID를 작성합니다. 두 고유 ID가 일치하면 역 직렬화 만 수행됩니다. 그렇지 않으면 InvalidClassException이라는 런타임 예외가 발생합니다. 이 고유 식별자는 SerialVersionUID에 지나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3611972f0d9f9281ab9d85aadd31fd689c683b66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Serialization&lt;/strong&gt; : At the time of serialization, with every object sender side JVM will save a Unique Identifier. JVM is responsible to generate that unique ID based on the corresponding .class file which is present in the sender system.</source>
          <target state="translated">&lt;strong&gt;직렬화&lt;/strong&gt; : &lt;strong&gt;직렬화&lt;/strong&gt; 시 모든 오브젝트 송신자 측 JVM이 고유 식별자를 저장합니다. JVM은 발신자 시스템에있는 해당 .class 파일을 기반으로 고유 한 ID를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="31c4af730de1ec78e966df4a893d337e4ba48a74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Serialization&lt;/strong&gt; allows to convert an object to a stream, for sending that object over the network OR Save to file OR save into DB for letter usage.</source>
          <target state="translated">&lt;strong&gt;직렬화를&lt;/strong&gt; 사용하면 네트워크를 통해 해당 오브젝트를 전송하거나 파일에 저장하거나 문자 사용을 위해 DB에 저장할 수 있도록 오브젝트를 스트림으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18b104d3665872daa5a5d62b3dfa2e04e0257aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html&quot;&gt;javadocs for &lt;code&gt;Serializable&lt;/code&gt;&lt;/a&gt; say&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html&quot;&gt; &lt;code&gt;Serializable&lt;/code&gt; 을 위한 javadocs는&lt;/a&gt; 말한다&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="8e10ad6fb571714fdcf9a3637d45c19079faf5d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Therefore, you must declare serialVersionUID because it give us more control&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;따라서 serialVersionUID는 더 많은 제어권을 부여하므로 선언해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1b2511b1f1436c52f14967962e20cf606bc903d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why use &lt;code&gt;SerialVersionUID&lt;/code&gt; inside &lt;code&gt;Serializable&lt;/code&gt; class in Java?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java의 &lt;code&gt;Serializable&lt;/code&gt; 클래스 내에서 &lt;code&gt;SerialVersionUID&lt;/code&gt; 를 사용하는 이유는 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="906fd73871d1746cd0dbcce791e6b9af3918c01b" translate="yes" xml:space="preserve">
          <source>A Simple Explanation:</source>
          <target state="translated">간단한 설명 :</target>
        </trans-unit>
        <trans-unit id="66821acf6e7624406be47725b2e7ce84257cd34d" translate="yes" xml:space="preserve">
          <source>A serializable class can declare its own &lt;code&gt;serialVersionUID&lt;/code&gt; explicitly by declaring a field named &lt;code&gt;serialVersionUID&lt;/code&gt; that must be static, final, and of type long.</source>
          <target state="translated">직렬화 가능 클래스는 static, final 및 long 유형이어야하는 &lt;code&gt;serialVersionUID&lt;/code&gt; 라는 필드를 선언하여 고유 한 &lt;code&gt;serialVersionUID&lt;/code&gt; 를 명시 적으로 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="556d6d8a3cc094128082980ca2daa51184075bf6" translate="yes" xml:space="preserve">
          <source>All primitive types are serializable.</source>
          <target state="translated">모든 기본 유형은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d43fa2e365573ac0634d4f96ed28d42f8662274d" translate="yes" xml:space="preserve">
          <source>An object is serializable (itself implements the Serializable interface) even if its superclass is not. However, the first superclass in the hierarchy of the serializable class, that does not implements Serializable interface, MUST have a no-arg constructor. If this is violated, readObject() will produce a java.io.InvalidClassException in runtime</source>
          <target state="translated">수퍼 클래스가 아닌 경우에도 객체는 직렬화 가능합니다 (직접 직렬화 가능 인터페이스를 구현합니다). 그러나, 직렬화 가능 인터페이스를 구현하지 않는 직렬화 가능 클래스의 계층 구조에서 첫 번째 수퍼 클래스는 인수가없는 생성자를 가져야합니다. 이것이 위반되면, readObject ()는 런타임에 java.io.InvalidClassException을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="54df990ab20da4ab5e0367e31d19258eae93b03c" translate="yes" xml:space="preserve">
          <source>An object is serializable only if its class or its superclass implements the Serializable interface</source>
          <target state="translated">클래스 또는 수퍼 클래스가 Serializable 인터페이스를 구현하는 경우에만 객체를 직렬화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="120beec47d411d244e0c08a4eeab6eafbb379de8" translate="yes" xml:space="preserve">
          <source>And execute the Reader class. Not to execute the Writer class and you will get the exception.</source>
          <target state="translated">그리고 Reader 클래스를 실행하십시오. Writer 클래스를 실행하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4e349787e0377c85e41bb4d42d6bd546a8bc2877" translate="yes" xml:space="preserve">
          <source>And if you are backwards-compatible with your data like in the first use case mentioned, you also probably want to maintain the id yourself. This in order to get readable ids and have greater control over when and how they change.</source>
          <target state="translated">그리고 언급 한 첫 번째 사용 사례와 같이 데이터와 역 호환이 가능하면 ID를 직접 유지하고 싶을 것입니다. 이는 읽을 수있는 ID를 얻고 변경시기와 방법을보다 잘 제어 할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="024a99db1a896209169c95029b3ce0b2e534afa2" translate="yes" xml:space="preserve">
          <source>Are you serializing data?</source>
          <target state="translated">데이터를 직렬화하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="990a8adcbdfa167776667defea795dc3025b128a" translate="yes" xml:space="preserve">
          <source>As for an example where the missing serialVersionUID might cause a problem:</source>
          <target state="translated">누락 된 serialVersionUID가 문제를 일으킬 수있는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5617b7140b809d418d5e0a3baee83574e9a69131" translate="yes" xml:space="preserve">
          <source>Basically, if you don't update the version correctly when you update a class you need to write/read, you will get an error when you try to read old data.</source>
          <target state="translated">기본적으로, 쓰기 / 읽기가 필요한 클래스를 업데이트 할 때 버전을 올바르게 업데이트하지 않으면 오래된 데이터를 읽으려고 할 때 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="55c6075806e02d97bac769299a54d457a38e7da7" translate="yes" xml:space="preserve">
          <source>But in case if serialVersionUID is not specified by programmer then while doing Serialization\DeSerialization  of any object, Java runtime uses its own algorithm to calculate it. This serialVersionUID calculation algorithm varies from one JRE to another. It is also possible that the environment where the object is serialized is using one JRE (ex: SUN JVM) and the environment where deserialzation happens is using Linux Jvm(zing). In such cases serialVersionUID associated with serialized object will be different than the serialVersionUID of class calculated at deserialzation environment. In turn deserialization will not be successful. So to avoid such situations/issues programmer must always specify serialVersionUID of Serializable class.</source>
          <target state="translated">그러나 프로그래머가 serialVersionUID를 지정하지 않은 경우 객체의 Serialization \ DeSerialization을 수행하는 동안 Java 런타임은 자체 알고리즘을 사용하여 계산합니다. 이 serialVersionUID 계산 알고리즘은 JRE마다 다릅니다. 객체가 직렬화되는 환경에서 하나의 JRE (예 : SUN JVM)를 사용하고 deserialization이 발생하는 환경은 Linux Jvm (zing)을 사용하는 것이 가능합니다. 이러한 경우 직렬화 된 객체와 연관된 serialVersionUID는 deserialization 환경에서 계산 된 클래스의 serialVersionUID와 다릅니다. 차례로 역 직렬화가 성공하지 못합니다. 따라서 이러한 상황 / 문제를 피하려면 프로그래머는 항상 Serializable 클래스의 serialVersionUID를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="457b19bd79bfb1a9a50bc7b4969edb6b2b5a1036" translate="yes" xml:space="preserve">
          <source>But storing serialized data for such a long time span is not very common. It is far more common to use the serialization mechanism to temporarily write data to for instance a cache or send it over the network to another program with the same version of the relevant parts of the codebase.</source>
          <target state="translated">그러나 이러한 긴 시간 동안 직렬화 된 데이터를 저장하는 것은 그리 일반적이지 않습니다. 직렬화 메커니즘을 사용하여 데이터를 일시적으로 캐시에 쓰거나 네트워크를 통해 동일한 버전의 코드베이스 관련 부분을 가진 다른 프로그램으로 보내는 것이 훨씬 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="8003df6d5412c6d8396be6f1aef4f95fe379408b" translate="yes" xml:space="preserve">
          <source>But there is a backside to the auto-generated id strategy. Namely that the generated ids for the same class might differ between compilers (as mentioned by Jon Skeet above). So if you communicate serialized data between code compiled with different compilers, it is recommended to maintain the ids manually anyway.</source>
          <target state="translated">그러나 자동 생성 된 id 전략에는 단점이 있습니다. 즉, 동일한 클래스에 대해 생성 된 ID는 컴파일러마다 다를 수 있습니다 (위의 Jon Skeet에서 언급 한대로). 따라서 다른 컴파일러로 컴파일 된 코드간에 직렬화 된 데이터를 통신하는 경우 어쨌든 ID를 수동으로 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7ced4cd1b424dc1e6c6a97cd9e87f8103ee0a11a" translate="yes" xml:space="preserve">
          <source>Code : &lt;a href=&quot;http://www.grepcode.com/file/repository.jboss.org/nexus/content/repositories/releases/org.jboss/javassist/3.5.GA/javassist/SerialVersionUID.java#SerialVersionUID&quot;&gt; javassist.SerialVersionUID&lt;/a&gt;</source>
          <target state="translated">코드 : &lt;a href=&quot;http://www.grepcode.com/file/repository.jboss.org/nexus/content/repositories/releases/org.jboss/javassist/3.5.GA/javassist/SerialVersionUID.java#SerialVersionUID&quot;&gt;javassist.SerialVersionUID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e5e4a12dcab3bcdfbbaf20c3c92f7572e7246b3" translate="yes" xml:space="preserve">
          <source>Consider a situation - in the future you need to edit or change your class and in that case when you modify it, JVM will assign it a new UID (Suppose #444).
Now when you try to deserialize the employee object, JVM will compare serialized object's (Employee object) version ID(#333) with that of the class i.e #444(Since it was changed). On comparison JVM will find both version UID are different and hence Deserialization will fail.
Hence if serialVersionID for each class is defined by programmer itself. It will be same even if the class is evolved in future and hence JVM will always find that class is compatible with serialized object even though the class is changed. For more Info you can refer chapter 14 of HEAD FIRST JAVA.</source>
          <target state="translated">상황을 고려하십시오-나중에 클래스를 편집하거나 변경해야하며,이 경우 클래스를 수정하면 JVM에 새 UID (공급 번호 444)가 지정됩니다. 이제 직원 객체를 직렬화 해제하려고하면 JVM은 직렬화 된 객체의 (직원 개체) 버전 ID (# 333)를 클래스의 # 444 (변경된 이후)와 비교합니다. 비교하면 JVM은 두 버전의 UID가 다르므로 역 직렬화가 실패합니다. 따라서 각 클래스의 serialVersionID가 프로그래머 자체에 의해 정의되는 경우. 나중에 클래스가 발전하더라도 동일하므로 JVM은 클래스가 변경 되어도 클래스가 직렬화 된 객체와 호환된다는 것을 항상 알게 될 것입니다. 자세한 정보는 HEAD FIRST JAVA의 14 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="902d3e9c0ce16116737e84feb71557afde91dc0f" translate="yes" xml:space="preserve">
          <source>Create Serialize Object</source>
          <target state="translated">직렬화 객체 생성</target>
        </trans-unit>
        <trans-unit id="a2c7e5486a3f344d56945a7b650dedf412ef8c59" translate="yes" xml:space="preserve">
          <source>Deserialize the object</source>
          <target state="translated">객체를 역 직렬화</target>
        </trans-unit>
        <trans-unit id="8f2b733e756af21d1abfdca922137f6588c4d570" translate="yes" xml:space="preserve">
          <source>Do you intend to go into production?</source>
          <target state="translated">생산을 시작 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="5e81f5fe3485373a7732e86888657bf7a3c0c5c1" translate="yes" xml:space="preserve">
          <source>Don't bother, the default calculation is really good and suffice for 99,9999% of the cases. And if you run into problems, you can - as already stated - introduce UID's as the need arrise (which is highly unlikely)</source>
          <target state="translated">걱정하지 마십시오. 기본 계산은 실제로 훌륭하고 99,9999 %의 경우 충분합니다. 그리고 문제가 발생하면 이미 언급했듯이 필요에 따라 UID를 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74c2664cf2e007e8a6e348e6437ca8eb3c97da2b" translate="yes" xml:space="preserve">
          <source>During &lt;code&gt;serialization&lt;/code&gt;, Java runtime creates a version number for a class, so that it can de-serialize it later. This version number is known as &lt;code&gt;SerialVersionUID&lt;/code&gt; in Java.</source>
          <target state="translated">&lt;code&gt;serialization&lt;/code&gt; 중 Java 런타임은 클래스의 버전 번호를 작성하여 나중에 직렬화 해제 할 수 있습니다. 이 버전 번호는 Java에서 &lt;code&gt;SerialVersionUID&lt;/code&gt; 로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63d27dfd00d72f5fa3a4a275d1170052a3bb2f1" translate="yes" xml:space="preserve">
          <source>Each time an object is serialized the object is stamped with a version ID number for the object's class.This ID is called &lt;a href=&quot;https://stackoverflow.com/q/285793/1387612&quot;&gt;serialVersionUID&lt;/a&gt; and it is computed based on information about the class structure. Suppose you made an Employee class and it has version id #333 (assigned by JVM),Now when you will serialize the object of that class (Suppose Employee object), JVM will assign UID to it as #333.</source>
          <target state="translated">객체가 직렬화 될 때마다 객체 클래스의 버전 ID 번호로 스탬프됩니다.이 ID는 &lt;a href=&quot;https://stackoverflow.com/q/285793/1387612&quot;&gt;serialVersionUID&lt;/a&gt; 라고하며 클래스 구조에 대한 정보를 기반으로 계산됩니다. Employee 클래스를 만들고 버전 ID가 # 333 (JVM에 의해 할당 됨)을 가지고 있다고 가정합니다. 이제 해당 클래스의 객체를 직렬화 할 때 (Employee 객체 제공) JVM은 UID를 # 333으로 할당합니다.</target>
        </trans-unit>
        <trans-unit id="331fe5b32b63711ced0f4688764ea82b15eb25d9" translate="yes" xml:space="preserve">
          <source>Eclipse issues warnings when a &lt;code&gt;serialVersionUID&lt;/code&gt; is missing.</source>
          <target state="translated">&lt;code&gt;serialVersionUID&lt;/code&gt; 가 누락되면 Eclipse가 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="e0c7125d853c45b42db053d4899fe4ccc120bba6" translate="yes" xml:space="preserve">
          <source>Field data represents some information stored in the class.
Class implements the &lt;code&gt;Serializable&lt;/code&gt; interface, 
so eclipse automatically offered  to declare the &lt;code&gt;serialVersionUID&lt;/code&gt; field. Lets start with value 1 set there.</source>
          <target state="translated">필드 데이터는 클래스에 저장된 일부 정보를 나타냅니다. 클래스는 &lt;code&gt;Serializable&lt;/code&gt; 인터페이스를 구현하므로 &lt;code&gt;serialVersionUID&lt;/code&gt; 필드를 선언하기 위해 Eclipse가 자동으로 제공됩니다. 값 1을 설정하여 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="9255cfa2633d6dd855930279962514319145eb54" translate="yes" xml:space="preserve">
          <source>First I need to explain what serialization is.</source>
          <target state="translated">먼저 직렬화가 무엇인지 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe5f947543d44552ac4a1c1ce2bff62f622221de" translate="yes" xml:space="preserve">
          <source>Firstly to answer your question, when we don't declare SerialVersionUID in our class, Java runtime generates it for us, but that process is sensitive to many class meta data including number of fields, type of fields, access modifier of fields, interface implemented by class etc. Therefore it is recommended to declare it ourselves and Eclipse is warning you about the same.</source>
          <target state="translated">먼저 클래스에 SerialVersionUID를 선언하지 않으면 Java 런타임이 우리를 위해 생성하지만 프로세스는 필드 수, 필드 유형, 필드 액세스 수정 자, 인터페이스 구현을 포함한 많은 클래스 메타 데이터에 민감합니다. 따라서 클래스 자체에 따라 선언하는 것이 좋습니다. Eclipse는 이에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="04de54a57ab3959800eb0f2842888d4560a529c7" translate="yes" xml:space="preserve">
          <source>For all other cases, I use</source>
          <target state="translated">다른 모든 경우에는</target>
        </trans-unit>
        <trans-unit id="fd012c69d903deb492c73342fac8be0cf73138e4" translate="yes" xml:space="preserve">
          <source>Here is a nice explanation based on the scenario,</source>
          <target state="translated">시나리오를 기반으로 한 좋은 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="03bf07f9d1a8bddc0829166a5de4a331ab54be58" translate="yes" xml:space="preserve">
          <source>I can't pass up this opportunity to plug Josh Bloch's book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;Effective Java&lt;/a&gt; (2nd Edition).  Chapter 11 is an indispensible resource on Java serialization.</source>
          <target state="translated">Josh Bloch의 책 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;Effective Java&lt;/a&gt; (2nd Edition)를 연결하는 기회를 전달할 수 없습니다. 11 장은 Java 직렬화에 없어서는 안될 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="1731a106e7d9ee245acefeb0e9a165e8688028b6" translate="yes" xml:space="preserve">
          <source>I generally use &lt;code&gt;serialVersionUID&lt;/code&gt; in one context:  When I know it will be leaving the context of the Java VM.</source>
          <target state="translated">나는 일반적으로 하나의 컨텍스트에서 &lt;code&gt;serialVersionUID&lt;/code&gt; 를 사용합니다. 알면 Java VM의 컨텍스트를 떠날 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d30080cfbbac6f31768acf23476d4f58cc248ff" translate="yes" xml:space="preserve">
          <source>I often see people extending JFrame or such, when they really only need to delegate to this. (This also helps for auto-completing in a IDE, since JFrame has hundreds of methods, which you don't need when you want to call your custom ones on your class.)</source>
          <target state="translated">나는 사람들이 JFrame이나 그와 같은 것을 확장 해야하는 경우가 종종 있습니다. (JFrame에는 수백 가지 메소드가 있으므로 클래스에서 사용자 정의 메소드를 호출하려고 할 때 필요하지 않으므로 IDE에서 자동 완성에도 도움이됩니다.)</target>
        </trans-unit>
        <trans-unit id="4528b507df7e1b4debb62b589fdb1fbf11ea6c69" translate="yes" xml:space="preserve">
          <source>I would know this when I to use &lt;code&gt;ObjectInputStream&lt;/code&gt; and &lt;code&gt;ObjectOutputStream&lt;/code&gt; for my application or if I know a library/framework I use will use it.  The serialVersionID ensures different Java VMs of varying versions or vendors will inter-operate correctly or if it is stored and retrieved outside the VM for example &lt;code&gt;HttpSession&lt;/code&gt; the session data can remain even during a restart and upgrade of the application server.</source>
          <target state="translated">내 응용 프로그램에 &lt;code&gt;ObjectInputStream&lt;/code&gt; 및 &lt;code&gt;ObjectOutputStream&lt;/code&gt; 을 사용할 때 또는 내가 사용하는 라이브러리 / 프레임 워크를 사용하면 이것을 사용할 것입니다. serialVersionID는 다양한 버전의 다양한 Java VM 또는 공급 업체가 올바르게 상호 운용되도록하거나 &lt;code&gt;HttpSession&lt;/code&gt; 과 같은 VM 외부에서 저장 및 검색되는 경우 응용 프로그램 서버를 다시 시작하고 업그레이드하는 동안에도 세션 데이터를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aebc60c47be3376f3219f82f5a1bf8f6060cdc5" translate="yes" xml:space="preserve">
          <source>I'm working on this Java EE application that is composed of a Web module that uses an &lt;code&gt;EJB&lt;/code&gt; module. The web module calls the &lt;code&gt;EJB&lt;/code&gt; module remotely and passes a &lt;code&gt;POJO&lt;/code&gt; that implements &lt;code&gt;Serializable&lt;/code&gt; as an argument.</source>
          <target state="translated">&lt;code&gt;EJB&lt;/code&gt; 모듈을 사용하는 웹 모듈로 구성된이 Java EE 애플리케이션을 작업 중입니다. 웹 모듈은 &lt;code&gt;EJB&lt;/code&gt; 모듈을 원격으로 호출하고 &lt;code&gt;Serializable&lt;/code&gt; 을 인수로 구현하는 &lt;code&gt;POJO&lt;/code&gt; 를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="fbb6c65af6ba4f01642221360b8825a38d164609" translate="yes" xml:space="preserve">
          <source>If a serializable class do not explicitly declare a serialVersionUID, then serialization runtime will calculate  serialVersionUID value for that class based on various aspects of the class like fields, methods etc.,, You can refer this &lt;a href=&quot;https://self-learning-java-tutorial.blogspot.com/2014/09/serialversionuid.html&quot;&gt;link&lt;/a&gt; for demo application.</source>
          <target state="translated">직렬화 가능 클래스가 serialVersionUID를 명시 적으로 선언하지 않으면 직렬화 런타임은 필드, 메소드 등과 같은 클래스의 다양한 측면을 기반으로 해당 클래스의 serialVersionUID 값을 계산합니다. 데모 애플리케이션에 대해이 &lt;a href=&quot;https://self-learning-java-tutorial.blogspot.com/2014/09/serialversionuid.html&quot;&gt;링크&lt;/a&gt; 를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79176b9cada3ecc6f3cdbdbe22c62b8fa2c5bd9b" translate="yes" xml:space="preserve">
          <source>If a serializable class does not explicitly declare a &lt;code&gt;serialVersionUID&lt;/code&gt;, then the serialization runtime will calculate a default &lt;code&gt;serialVersionUID&lt;/code&gt; value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is &lt;em&gt;strongly recommended&lt;/em&gt; that all serializable classes explicitly declare &lt;code&gt;serialVersionUID&lt;/code&gt; values, since the default &lt;code&gt;serialVersionUID&lt;/code&gt; computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected &lt;code&gt;InvalidClassExceptions&lt;/code&gt; during deserialization. Therefore, to guarantee a consistent &lt;code&gt;serialVersionUID&lt;/code&gt; value across different java compiler implementations, a serializable class must declare an explicit &lt;code&gt;serialVersionUID&lt;/code&gt; value. It is also strongly advised that explicit &lt;code&gt;serialVersionUID&lt;/code&gt; declarations use the private modifier where possible, since such declarations apply only to the immediately declaring class &lt;code&gt;serialVersionUID&lt;/code&gt; fields are not useful as inherited members.</source>
          <target state="translated">직렬화 가능 클래스가 &lt;code&gt;serialVersionUID&lt;/code&gt; 를 명시 적으로 선언하지 않는 경우, 직렬화 런타임은 Java (TM) 객체 직렬화 스펙에 설명 된대로 클래스의 다양한 측면을 기반으로 해당 클래스의 기본 &lt;code&gt;serialVersionUID&lt;/code&gt; 값을 계산합니다. 그러나 기본 &lt;code&gt;serialVersionUID&lt;/code&gt; 계산은 컴파일러 구현에 따라 달라질 수있는 클래스 세부 정보에 매우 민감하므로 역 직렬화 중에 예기치 않은 &lt;code&gt;InvalidClassExceptions&lt;/code&gt; 가 발생할 수 있으므로 모든 serializable 클래스는 &lt;code&gt;serialVersionUID&lt;/code&gt; 값을 명시 적으로 선언 &lt;em&gt;하는 것이 좋습니다&lt;/em&gt; . 따라서 다른 Java 컴파일러 구현에서 일관된 &lt;code&gt;serialVersionUID&lt;/code&gt; 값을 보장하려면 직렬화 가능 클래스가 명시 적 &lt;code&gt;serialVersionUID&lt;/code&gt; 값을 선언해야합니다. 명시 적 &lt;code&gt;serialVersionUID&lt;/code&gt; 선언은 가능한 경우 전용 수정자를 사용하는 것이 좋습니다. 이러한 선언은 즉시 선언하는 클래스 &lt;code&gt;serialVersionUID&lt;/code&gt; 필드에만 적용되므로 상속 된 멤버로 유용하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ac07961b643911ddcb2c896810537f0afd622445" translate="yes" xml:space="preserve">
          <source>If so, set &lt;code&gt;serialVersionUID=1L&lt;/code&gt;.</source>
          <target state="translated">그렇다면 &lt;code&gt;serialVersionUID=1L&lt;/code&gt; 을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e4c50d35d2b9efc3203d7444d68cd27712448b2f" translate="yes" xml:space="preserve">
          <source>If the class is serializable you can also declare your own serialVersionUID explicitly  by declaring a field named &quot;serialVersionUID&quot; that must be static, final, and of type long. Most IDE's like Eclipse help you generate that long string.</source>
          <target state="translated">클래스를 직렬화 할 수있는 경우 정적, 최종 및 long 유형이어야하는 &quot;serialVersionUID&quot;라는 필드를 선언하여 고유 한 serialVersionUID를 명시 적으로 선언 할 수도 있습니다. Eclipse와 같은 대부분의 IDE는 긴 문자열을 생성하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="0908a1a1336c6604f42496dbb63562f68b64f6fe" translate="yes" xml:space="preserve">
          <source>If you are just testing something with unimportant/fake data, then don't worry about it (unless you are testing serialization directly).</source>
          <target state="translated">중요하지 않은 / 가짜 데이터로 무언가를 테스트하는 경우 직렬화를 직접 테스트하지 않는 한 걱정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="8a69924d7d5897fafcf895033701a64bf405b8cf" translate="yes" xml:space="preserve">
          <source>If you do forget to update the field, you might end up with two different versions of a class with different structure but with the same &lt;code&gt;serialVersionUID&lt;/code&gt;. If this happens, the default mechanism (&lt;code&gt;in.defaultReadObject()&lt;/code&gt;) will not detect any difference, and try to de-serialize incompatible data. Now you might end up with a cryptic runtime error or silent failure (null fields). These types of errors might be hard to find.</source>
          <target state="translated">필드를 업데이트하는 것을 잊어 버린 경우 구조는 다르지만 &lt;code&gt;serialVersionUID&lt;/code&gt; 는 동일한 두 가지 버전의 클래스로 끝날 수 있습니다. 이 경우 기본 메커니즘 ( &lt;code&gt;in.defaultReadObject()&lt;/code&gt; )은 차이를 감지하지 않으며 호환되지 않는 데이터를 직렬화 해제하려고합니다. 이제 암호 런타임 오류 또는 자동 실패 (널 필드)가 발생할 수 있습니다. 이러한 유형의 오류는 찾기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="951eb1700ec9d7b7fe70f87bfe0e3fabca70f057" translate="yes" xml:space="preserve">
          <source>If you don't want that warning to come, use this:</source>
          <target state="translated">경고가 표시되지 않게하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="759c21d48ab7d563cb615b405b767a40ee3165b5" translate="yes" xml:space="preserve">
          <source>If you get this warning on a class you don't ever think about serializing, and that you didn't declare yourself &lt;code&gt;implements Serializable&lt;/code&gt;, it is often because you inherited from a superclass, which implements Serializable. Often then it would be better to delegate to such a object instead of using inheritance.</source>
          <target state="translated">클래스에 대해이 경고가 표시되면 직렬화에 대해 생각하지 않고 &lt;code&gt;implements Serializable&lt;/code&gt; 하지 않는다고 선언 한 경우 Serializable을 구현하는 수퍼 클래스에서 상속했기 때문입니다. 종종 상속을 사용하는 대신 그러한 객체에 위임하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a4a72dc9110f96c64679ef74b8fdb11f2882cfd8" translate="yes" xml:space="preserve">
          <source>If you ignore them for now, and find later that you need to change the class in some way but maintain compatibility w/ old version of the class, you can use the JDK tool &lt;strong&gt;serialver&lt;/strong&gt; to generate the &lt;code&gt;serialVersionUID&lt;/code&gt; on the &lt;em&gt;old&lt;/em&gt; class, and explicitly set that on the new class.  (Depending on your changes you may need to also implement custom serialization by adding &lt;code&gt;writeObject&lt;/code&gt; and &lt;code&gt;readObject&lt;/code&gt; methods - see &lt;code&gt;Serializable&lt;/code&gt; javadoc or aforementioned chapter 11.)</source>
          <target state="translated">지금은 무시하고 나중에 클래스를 변경해야하지만 이전 버전과의 호환성을 유지해야한다는 것을 나중에 발견하면 JDK 도구 &lt;strong&gt;serialver&lt;/strong&gt; 를 사용하여 &lt;em&gt;이전&lt;/em&gt; 클래스에서 &lt;code&gt;serialVersionUID&lt;/code&gt; 를 생성하고 명시 적으로 설정할 수 있습니다 새로운 수업에서. (변경 사항에 따라 &lt;code&gt;writeObject&lt;/code&gt; 및 &lt;code&gt;readObject&lt;/code&gt; 메소드를 추가하여 사용자 정의 직렬화를 구현해야 할 수도 있습니다. &lt;code&gt;Serializable&lt;/code&gt; javadoc 또는 11 장을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="a5fe6571b7d4d90271296db8f6745f9d44b41fb5" translate="yes" xml:space="preserve">
          <source>If you want to amend a huge number of classes which had no serialVersionUID set in the first place while maintain the compatibility with the old classes, tools like IntelliJ Idea, Eclipse fall short as they generate random numbers and does not work on a bunch of files in one go. I come up the following bash script(I'm sorry for Windows users, consider buy a Mac or convert to Linux) to make amending serialVersionUID issue with ease:</source>
          <target state="translated">이전 버전의 IntelliJ Idea와 같은 도구와의 호환성을 유지하면서 serialVersionUID가 설정되지 않은 많은 수의 클래스를 수정하려는 경우 Eclipse는 임의의 숫자를 생성하고 많은 파일에서 작동하지 않으므로 빠릅니다. 한 번에. serialVersionUID 문제를 쉽게 수정하기 위해 다음 bash 스크립트 (Windows 사용자에게는 죄송합니다 .Mac을 구입하거나 Linux로 변환하십시오)를 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="47e78ed2014802b0c9a3a92e7fdf1eafb51b07c7" translate="yes" xml:space="preserve">
          <source>If you want to version your data, you normally start with a &lt;code&gt;serialVersionUID&lt;/code&gt; of 0, and bump it with every structural change to your class which alters the serialized data (adding or removing non-transient fields).</source>
          <target state="translated">데이터 버전을 지정하려면 일반적으로 &lt;code&gt;serialVersionUID&lt;/code&gt; 를 0으로 시작하고 클래스의 모든 구조적 변경으로 인해 직렬화 된 데이터를 변경하는 (비 일시적 필드 추가 또는 제거) 범프를 범핑합니다.</target>
        </trans-unit>
        <trans-unit id="92d52d748e3a903cd8cfe5335e2f7600d6a4d99c" translate="yes" xml:space="preserve">
          <source>If you will never need to serialize your objects to byte array and send/store them, then you don't need to worry about it. If you do, then you must consider your serialVersionUID since the deserializer of the object will match it to the version of object its classloader has. Read more about it in the Java Language Specification.</source>
          <target state="translated">객체를 바이트 배열로 직렬화하고 보내거나 저장할 필요가 없다면 걱정할 필요가 없습니다. 그렇게하면 객체의 deserializer가 클래스 로더에있는 객체의 버전과 일치하므로 serialVersionUID를 고려해야합니다. 이에 대한 자세한 내용은 Java 언어 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="43fdca2264665fac30b5995e1d2da647337a6fbf" translate="yes" xml:space="preserve">
          <source>If you're actually using serialization, it only matters if you plan on storing and retrieving objects using serialization directly.  The &lt;code&gt;serialVersionUID&lt;/code&gt; represents your class version, and you should increment it if the current version of your class is not backwards compatible with its previous version.</source>
          <target state="translated">실제로 직렬화를 사용하는 경우 직렬화를 사용하여 객체를 직접 저장하고 검색하려는 경우에만 중요합니다. &lt;code&gt;serialVersionUID&lt;/code&gt; 는 클래스 버전을 나타내며 현재 버전의 클래스가 이전 버전과 호환되지 않는 경우이를 증가시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="9128ba1afb3e0f24bb0e62ed32e59ef238f14973" translate="yes" xml:space="preserve">
          <source>If you're serializing just because you have to serialize for the implementation's sake (who cares if you serialize for an &lt;code&gt;HTTPSession&lt;/code&gt;, for instance...if it's stored or not, you probably don't care about &lt;code&gt;de-serializing&lt;/code&gt; a form object), then you can ignore this.</source>
          <target state="translated">구현을 위해 직렬화해야하기 때문에 직렬화하는 경우 (예 : &lt;code&gt;HTTPSession&lt;/code&gt; 을 직렬화하는지 관심이있는 사람 ... 예 : 저장 여부에 관계없이 양식 객체의 &lt;code&gt;de-serializing&lt;/code&gt; 를 해제 하지 않아도됩니다) 을 무시하면됩니다.</target>
        </trans-unit>
        <trans-unit id="be310d22adb7eb6ed4cdc4f31b81e366e345fd16" translate="yes" xml:space="preserve">
          <source>In case you didn't know, there are a lot of other warnings you can enable in this section (or even have some reported as errors), many are very useful:</source>
          <target state="translated">모르는 경우이 섹션에서 활성화 할 수있는 다른 많은 경고가 있거나 오류로보고 된 경우가 많으며, 그 중 많은 것이 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8b137380d829b068c0e1561e7670589d03744bf7" translate="yes" xml:space="preserve">
          <source>In this case you are not interested in maintaining backwards compatibility. You are only concerned with making sure that the code bases which are communicating indeed have the same versions of relevant classes. In order to facilitate such a check, you must maintain the &lt;code&gt;serialVersionUID&lt;/code&gt; just like before and not forget to update it when making changes to your classes.</source>
          <target state="translated">이 경우 이전 버전과의 호환성 유지에 관심이 없습니다. 실제로 통신하는 코드베이스가 동일한 버전의 관련 클래스를 갖는지 확인하는 데에만 관심이 있습니다. 이러한 검사를 용이하게하려면 이전과 마찬가지로 &lt;code&gt;serialVersionUID&lt;/code&gt; 를 유지 관리하고 클래스를 변경할 때 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="61679231af4ad410dbfa2dd92c43eea9061a90d9" translate="yes" xml:space="preserve">
          <source>Is this the first version?</source>
          <target state="translated">이것이 첫 번째 버전입니까?</target>
        </trans-unit>
        <trans-unit id="2a229b4a574a575150819f17c367c9fd921fd37d" translate="yes" xml:space="preserve">
          <source>Is this the second, third, etc. prod version?</source>
          <target state="translated">이것이 두 번째, 세 번째 등의 자극적 인 버전입니까?</target>
        </trans-unit>
        <trans-unit id="a2d78a74baa97f72bc98472f33a22bf2ab946a4e" translate="yes" xml:space="preserve">
          <source>It would be nice if CheckStyle could verify that the serialVersionUID on a class that implements Serializable has a good value, i.e. that it matches what the serial version id  generator would produce.  If you have a project with lots of serializable DTOs, for example, remembering to delete the existing serialVersionUID and regenerate it is a pain, and currently the only way (that I know of) to verify this is to regenerate for each class and compare to the old one.  This is very very painful.</source>
          <target state="translated">CheckStyle이 Serializable을 구현하는 클래스의 serialVersionUID가 올바른 값인지, 즉 직렬 버전 ID 생성기가 생성하는 것과 일치하는지 확인할 수 있으면 좋을 것입니다. 예를 들어, 직렬화 가능한 DTO가 많은 프로젝트가있는 경우 기존 serialVersionUID를 삭제하고 재생성하는 것을 기억하는 것은 고통스럽고 현재이를 확인하는 유일한 방법은 (각각의 클래스마다 재생성하고 비교하는 것입니다) 오래된 것. 이것은 매우 고통 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="45452c347dba4596f7fc6f779b60255c33b9b741" translate="yes" xml:space="preserve">
          <source>Least obvious - Sometimes you change the idea you put in some field's meaning. For example when you are 12 years old you mean &quot;bicycle&quot; under &quot;bike&quot;, but when you are 18 you mean &quot;motorcycle&quot; - if your friends will invite you to &quot;bike ride across city&quot; and you will be the only one who came on bicycle, you will undestand how important it is to keep same meaning across fields :-)</source>
          <target state="translated">가장 눈에 띄지 않음-때로는 필드의 의미에 대한 아이디어를 변경합니다. 예를 들어, 12 세인 경우 &quot;자전거&quot;아래에서 &quot;자전거&quot;를 의미하지만 18 세인 경우 &quot;오토바이&quot;를 의미합니다. 친구가 &quot;도시를 가로 질러 자전거 타기&quot;에 초대하면 유일한 사람이됩니다. 자전거에 와서, 당신은 여러 분야에서 동일한 의미를 유지하는 것이 얼마나 중요한지 이해할 것입니다 :-)</target>
        </trans-unit>
        <trans-unit id="92b2158c9da67c9bc8cebe83d5a434148a52fd77" translate="yes" xml:space="preserve">
          <source>Less obvious - When you deserialize object, fields that where not present in string will be kept as NULL. If you have removed field from your object, older versions will keep this field as allways-NULL that can lead to misbehavior if older versions rely on data in this field (anyway you have created it for something, not just for fun :-) )</source>
          <target state="translated">덜 명확함-객체를 직렬화 해제 할 때 문자열에없는 필드는 NULL로 유지됩니다. 객체에서 필드를 제거한 경우 이전 버전은이 필드를 allways-NULL로 유지하여 이전 버전 이이 필드의 데이터에 의존하는 경우 오작동을 일으킬 수 있습니다 (어쨌든 재미를 위해서가 아니라 무언가를 위해 만들었습니다 :)</target>
        </trans-unit>
        <trans-unit id="f39b41b433bf1ccbaddc2f3409f68a365496127f" translate="yes" xml:space="preserve">
          <source>Let's try this with an example.</source>
          <target state="translated">예를 들어 이것을 시도해 봅시다.</target>
        </trans-unit>
        <trans-unit id="18e32355c6b6633308045dc45a2607e31ca575a8" translate="yes" xml:space="preserve">
          <source>Most obvious - if you add some fields to your object, older versions will not be able to use them because they do not have these fields in their object structure.</source>
          <target state="translated">가장 명백한-객체에 일부 필드를 추가하면 객체 구조에 이러한 필드가 없기 때문에 이전 버전에서는 해당 필드를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="669226aa9f0c15ca8184278e717e0a11aea7ad79" translate="yes" xml:space="preserve">
          <source>Most of the time, you will probably not use serialization directly.  If this is the case, generate a default &lt;code&gt;SerialVersionUID&lt;/code&gt; by clicking the quick fix option and don't worry about it.</source>
          <target state="translated">대부분의 경우 직렬화를 직접 사용하지 않을 것입니다. 이 경우 빠른 수정 옵션을 클릭하여 기본 &lt;code&gt;SerialVersionUID&lt;/code&gt; 를 생성하고 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="03db456b4b5f92dd61b1356634c41f730702aac1" translate="yes" xml:space="preserve">
          <source>NOTE: Now change the serialVersionUID of the Employee class and save:</source>
          <target state="translated">참고 : 이제 Employee 클래스의 serialVersionUID를 변경하고 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="dfaed926e28cd77167b75a9487c6069d6863f33d" translate="yes" xml:space="preserve">
          <source>Now you need to worry about &lt;code&gt;serialVersionUID&lt;/code&gt;, and should look into it in depth.</source>
          <target state="translated">이제 &lt;code&gt;serialVersionUID&lt;/code&gt; 에 대해 걱정할 필요가 있고 깊이 살펴 봐야합니다.</target>
        </trans-unit>
        <trans-unit id="82faeed0157b5916b620f337d6af90d923051ddd" translate="yes" xml:space="preserve">
          <source>One case where the warning (or the serialVersionUID) is unavoidable is when you extend from AbstractAction, normally in a anonymous class, only adding the actionPerformed-method. I think there shouldn't be a warning in this case (since you normally can't reliable serialize and deserialize such anonymous classes anyway accross different versions of your class), but I'm not sure how the compiler could recognize this.</source>
          <target state="translated">경고 (또는 serialVersionUID)를 피할 수없는 경우는 일반적으로 익명 클래스에서 AbstractAction에서 확장하고 actionPerformed-method 만 추가하는 경우입니다. 이 경우 경고가 없어야한다고 생각합니다 (일반적으로 클래스의 다른 버전에 따라 익명 클래스를 안정적으로 직렬화하고 역 직렬화를 해제 할 수 없기 때문에).하지만 컴파일러가 이것을 어떻게 인식 할 수 있는지 잘 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="e369a1bf1e8a1cf49b05c9badf1d38385d36fce2" translate="yes" xml:space="preserve">
          <source>Original question has asked for 'why is it important' and 'example' where this &lt;code&gt;Serial Version ID&lt;/code&gt; would be useful. Well I have found one.</source>
          <target state="translated">이 &lt;code&gt;Serial Version ID&lt;/code&gt; 가 유용한 '중요 이유'와 '예'에 대한 원래 질문이있었습니다. 글쎄, 나는 하나를 발견했다.</target>
        </trans-unit>
        <trans-unit id="fc9f0a13cf25ff497bc08bf7b647cdd500b7bf4a" translate="yes" xml:space="preserve">
          <source>Per Josh, the automatically-generated UID is generated based on a class name, implemented interfaces, and all public and protected members.  Changing any of these in any way will change the &lt;code&gt;serialVersionUID&lt;/code&gt;.  So you don't need to mess with them only if you are certain that no more than one version of the class will ever be serialized (either across processes or retrieved from storage at a later time).</source>
          <target state="translated">Josh에 따라 자동 생성 된 UID는 클래스 이름, 구현 된 인터페이스 및 모든 공개 및 보호 된 멤버를 기반으로 생성됩니다. 어떤 식 으로든 변경하면 &lt;code&gt;serialVersionUID&lt;/code&gt; 가 변경됩니다. 따라서 하나 이상의 버전의 클래스가 직렬화 될 것이라고 확신하는 경우에만 프로세스와 충돌하거나 나중에 스토리지에서 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b4f26b8feb8f937d7254f3894358897952b1658" translate="yes" xml:space="preserve">
          <source>Potential Programming Problems: Null pointer access</source>
          <target state="translated">잠재적 인 프로그래밍 문제 : 널 포인터 액세스</target>
        </trans-unit>
        <trans-unit id="8d7e6c1f080cc867a97ebca251cf8c9fb3e16838" translate="yes" xml:space="preserve">
          <source>Potential Programming Problems: Possible accidental boolean assignment</source>
          <target state="translated">잠재적 인 프로그래밍 문제 : 우연한 부울 할당 가능성</target>
        </trans-unit>
        <trans-unit id="8b5ec26f30c3fea832b7f1abbafeeb9897906405" translate="yes" xml:space="preserve">
          <source>Read more: &lt;a href=&quot;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&quot;&gt;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&lt;/a&gt;</source>
          <target state="translated">더 읽기 : &lt;a href=&quot;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&quot;&gt;http://javarevisited.blogspot.com/2011/04/top-10-java-serialization-interview.html#ixzz3VQxnpOPZ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39f3eac3245d6e2e25325a60e97f8a037e33f3f7" translate="yes" xml:space="preserve">
          <source>Say you create a &lt;code&gt;Car&lt;/code&gt; class, instantiate it, and write it out to an object stream. The flattened car object sits in the file system for some time. Meanwhile, if the &lt;code&gt;Car&lt;/code&gt; class is modified by adding a new field. Later on, when you try to read (i.e. deserialize) the flattened &lt;code&gt;Car&lt;/code&gt; object, you get the &lt;code&gt;java.io.InvalidClassException&lt;/code&gt; &amp;ndash; because all serializable classes are automatically given a unique identifier. This exception is thrown when the identifier of the class is not equal to the identifier of the flattened object. If you really think about it, the exception is thrown because of the addition of the new field. You can avoid this exception being thrown by controlling the versioning yourself by declaring an explicit serialVersionUID. There is also a small performance benefit in explicitly declaring your &lt;code&gt;serialVersionUID&lt;/code&gt; (because does not have to be calculated). So, it is best practice to add your own serialVersionUID to your Serializable classes as soon as you create them as shown below:</source>
          <target state="translated">&lt;code&gt;Car&lt;/code&gt; 클래스를 생성하고 인스턴스화 한 다음 객체 스트림에 작성한다고 가정 해 봅시다. 납작한 자동차 개체는 파일 시스템에 일정 시간 동안 앉아 있습니다. 한편, 새 필드를 추가하여 &lt;code&gt;Car&lt;/code&gt; 클래스를 수정 한 경우 나중에, 평탄화 된 &lt;code&gt;Car&lt;/code&gt; 객체를 읽으려고 할 때 (즉, 직렬화 해제) &lt;code&gt;java.io.InvalidClassException&lt;/code&gt; 이 발생합니다. 모든 직렬화 가능 클래스에는 자동으로 고유 식별자가 부여되기 때문입니다. 이 예외는 클래스의 식별자가 평탄화 된 객체의 식별자와 같지 않을 때 발생합니다. 실제로 생각하면 새 필드가 추가되어 예외가 발생합니다. 명시 적 serialVersionUID를 선언하여 버전 관리를 직접 제어하여이 예외가 발생하지 않도록 할 수 있습니다. &lt;code&gt;serialVersionUID&lt;/code&gt; 를 명시 적으로 선언하면 약간의 성능 이점도 있습니다 (계산할 필요가 없기 때문). 따라서 아래와 같이 SerialVersionUID를 생성하자마자 SerialVersionUID를 Serializable 클래스에 추가하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="af175b945f0af8e71b073d6998feff95f90842dc" translate="yes" xml:space="preserve">
          <source>SerialVersionUID is used for version control of object. you can specify serialVersionUID in your class file also. Consequence of not specifying serialVersionUID is that when you add or modify any field in class then already serialized class will not be able to recover because serialVersionUID generated for new class and for old serialized object will be different. Java serialization process relies on correct serialVersionUID for recovering state of serialized object and throws java.io.InvalidClassException in case of serialVersionUID mismatch</source>
          <target state="translated">SerialVersionUID는 객체의 버전 제어에 사용됩니다. 클래스 파일에서 serialVersionUID를 지정할 수도 있습니다. serialVersionUID를 지정하지 않으면 클래스에서 필드를 추가하거나 수정할 때 새 클래스와 이전의 직렬화 된 객체에 대해 생성 된 serialVersionUID가 다르기 때문에 이미 직렬화 된 클래스를 복구 할 수 없습니다. Java 직렬화 프로세스는 직렬화 된 오브젝트의 상태를 복구하기 위해 올바른 serialVersionUID를 사용하고 serialVersionUID가 일치하지 않는 경우 java.io.InvalidClassException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="4b024388f4cf31c84b0ead4ab2043ad63c5546da" translate="yes" xml:space="preserve">
          <source>Serialization is basically writing class data to a file/stream/etc.  De-serialization is reading that data back to a class.</source>
          <target state="translated">직렬화는 기본적으로 클래스 데이터를 파일 / 스트림 등에 작성합니다. 역 직렬화는 해당 데이터를 클래스로 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a90d236667d7a7c96b56a65a967fafb3c11e3d17" translate="yes" xml:space="preserve">
          <source>Serialization:
We often work with important objects whose state (data in the variables of the object) is so important that we can not risk to lose it due to power/system failures (or) network failures in case of sending the object state to other machine. The solution for this problem is named &quot;Persistence&quot; which simply means persisting (holding/saving) the data. Serialization is one of many other ways to achieve persistence (by saving data to disk/memory). When saving the state of the object, it is important to create an identity for the object, to be able to properly read it back (de-serialization). This unique identification is ID is SerialVersionUID.</source>
          <target state="translated">직렬화 : 우리는 종종 상태 (객체의 변수에있는 데이터)가 매우 중요한 중요한 객체를 다루며, 객체 상태를 다른 사람에게 보낼 때 전원 / 시스템 장애 (또는 네트워크 장애)로 인해 데이터를 잃을 위험이 없습니다. 기계. 이 문제에 대한 해결책은 &quot;지속성&quot;이라고하며 이는 단순히 데이터를 유지 (보유 / 저장)한다는 의미입니다. 직렬화는 데이터를 디스크 / 메모리에 저장하여 지속성을 달성하는 다른 많은 방법 중 하나입니다. 객체의 상태를 저장할 때 객체를 올바르게 읽을 수 있도록 객체의 ID를 생성하는 것이 중요합니다 (직렬화 해제). 이 고유 ID는 ID가 SerialVersionUID입니다.</target>
        </trans-unit>
        <trans-unit id="786e6158fbc48d9b91849b94859cb9fb38b4788a" translate="yes" xml:space="preserve">
          <source>So to help this usecase, the Java platform offers you a choice of not setting the &lt;code&gt;serialVersionUID&lt;/code&gt; manually. Instead, a hash of the class structure will be generated at compile-time and used as id. This mechanism will make sure that you never have different class structures with the same id, and so you will not get these hard-to-trace runtime serialization failures mentioned above.</source>
          <target state="translated">따라서이 사용 사례를 돕기 위해 Java 플랫폼은 &lt;code&gt;serialVersionUID&lt;/code&gt; 를 수동으로 설정하지 않도록 선택할 수 있습니다. 대신 클래스 구조의 해시가 컴파일 타임에 생성되어 id로 사용됩니다. 이 메커니즘은 동일한 ID를 가진 다른 클래스 구조를 갖지 않도록하기 때문에 위에서 언급 한 추적하기 어려운 런타임 직렬화 실패를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="50858191cffe74b141faf092db8130f8aa64446f" translate="yes" xml:space="preserve">
          <source>So we conclude that to make Serialization/Deserialization process successful the serialVersionUID of serialized object must be equivalent to the serialVersionUID of the class. In case if programmer specifies the serialVersionUID value explicitly in the program then the same value will be associated with the serialized object and the class, irrespective of the serialization and deserialzation platform(for ex. serialization might be done on platform like windows by using sun or MS JVM and Deserialization might be on different platform Linux using Zing JVM).</source>
          <target state="translated">따라서 직렬화 / 직렬화 프로세스를 성공적으로 수행하려면 직렬화 된 객체의 serialVersionUID가 클래스의 serialVersionUID와 동일해야합니다. 프로그래머가 프로그램에서 serialVersionUID 값을 명시 적으로 지정하는 경우 직렬화 및 deserialzation 플랫폼에 관계없이 직렬화 된 객체 및 클래스와 동일한 값이 연결됩니다 (예 : sun 또는 Windows를 사용하여 Windows와 같은 플랫폼에서 직렬화가 수행 될 수 있음) MS JVM 및 역 직렬화는 Zing JVM을 사용하는 다른 플랫폼 Linux에있을 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="24bcc5bfeaec8f6116cfc0a18304cb69edac70ac" translate="yes" xml:space="preserve">
          <source>So, instead of</source>
          <target state="translated">그래서 대신</target>
        </trans-unit>
        <trans-unit id="538886bb8c0fa8986dc37e9dc9a75511ddd40509" translate="yes" xml:space="preserve">
          <source>Specifying one gives more control, though JVM does generate one if you don't specify. The value generated can differ between different compilers. Furthermore, sometimes you just want for some reason to forbid deserialization of old serialized objects [&lt;code&gt;backward incompatibility&lt;/code&gt;], and in this case you just have to change the serialVersionUID.</source>
          <target state="translated">하나를 지정하면 더 많은 제어가 가능하지만 지정하지 않으면 JVM이 하나를 생성합니다. 생성 된 값은 컴파일러마다 다를 수 있습니다. 또한 어떤 이유로 인해 이전 직렬화 &lt;code&gt;backward incompatibility&lt;/code&gt; 객체의 역 직렬화 (이전 버전과의 비 호환성) 를 금지하는 이유가있을 수 있습니다.이 경우 serialVersionUID 만 변경하면됩니다.</target>
        </trans-unit>
        <trans-unit id="92c72fe26fb9d9097b9d0d0fcb80b3ee120d57ea" translate="yes" xml:space="preserve">
          <source>Static fields (with static modifier) are not serialized.</source>
          <target state="translated">정적 필드 (정적 수정 자 포함)는 직렬화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7e2b2c0be6f1557cd2bd472fca064db6f1767b9" translate="yes" xml:space="preserve">
          <source>The built-in de-serialization mechanism (&lt;code&gt;in.defaultReadObject()&lt;/code&gt;) will refuse to de-serialize from old versions of the data. But if you want to you can define your own &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/guide/serialization/spec/input.html#2971&quot;&gt;readObject()&lt;/a&gt;-function which can read back old data. This custom code can then check the &lt;code&gt;serialVersionUID&lt;/code&gt; in order to know which version the data is in and decide how to de-serialize it. This versioning technique is useful if you store serialized data which survives several versions of your code.</source>
          <target state="translated">내장 된 역 직렬화 메커니즘 ( &lt;code&gt;in.defaultReadObject()&lt;/code&gt; )은 이전 버전의 데이터에서 역 직렬화를 거부합니다. 그러나 원하는 경우 이전 데이터를 다시 읽을 수있는 자체 &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/guide/serialization/spec/input.html#2971&quot;&gt;readObject ()&lt;/a&gt; 함수를 정의 할 수 있습니다. 그런 다음이 사용자 정의 코드는 &lt;code&gt;serialVersionUID&lt;/code&gt; 를 확인하여 데이터의 버전을 파악하고 직렬화 해제 방법을 결정할 수 있습니다. 이 버전 관리 기술은 여러 버전의 코드에서 유지되는 직렬화 된 데이터를 저장하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e243771f8f2c8fb470fa0bee8b336e82b28f4fd9" translate="yes" xml:space="preserve">
          <source>The call to the &lt;code&gt;EJB&lt;/code&gt; was failing with the Exception below because I hadn't declared its &lt;code&gt;serialVersionUID&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;serialVersionUID&lt;/code&gt; 를 선언하지 않았기 때문에 아래의 예외와 함께 &lt;code&gt;EJB&lt;/code&gt; 호출에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="05cab8052e138b165623cdfaf9a111dbdf55093e" translate="yes" xml:space="preserve">
          <source>The docs for &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html&quot;&gt;&lt;code&gt;java.io.Serializable&lt;/code&gt;&lt;/a&gt; are probably about as good an explanation as you'll get:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html&quot;&gt; &lt;code&gt;java.io.Serializable&lt;/code&gt; &lt;/a&gt; 문서는 아마도 당신이 얻을 수있는만큼 좋은 설명 일 것입니다 :</target>
        </trans-unit>
        <trans-unit id="5f1a9e80a8a62dc5fed2428c8ee1933622e0baed" translate="yes" xml:space="preserve">
          <source>The serializable class Foo does not declare a static final
  serialVersionUID field of type long</source>
          <target state="translated">직렬화 가능 클래스 Foo는 long 유형의 정적 final serialVersionUID 필드를 선언하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d3646af1ce2f3da7f74099102cfd890330046cf" translate="yes" xml:space="preserve">
          <source>The serialization runtime associates with each serializable class a version number, called a &lt;code&gt;serialVersionUID&lt;/code&gt;, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different &lt;code&gt;serialVersionUID&lt;/code&gt; than that of the corresponding sender's class, then deserialization will result in an 
  &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InvalidClassException.html&quot;&gt;&lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/a&gt;. A serializable class can declare its own &lt;code&gt;serialVersionUID&lt;/code&gt; explicitly by declaring a field named &lt;code&gt;serialVersionUID&lt;/code&gt; that must be static, final, and of type &lt;code&gt;long&lt;/code&gt;:</source>
          <target state="translated">직렬화 런타임은 직렬화 가능한 오브젝트의 송신자 및 수신자가 직렬화와 호환되는 해당 오브젝트의 클래스를로드했는지 검증하기 위해 직렬화 해제 중에 사용되는 &lt;code&gt;serialVersionUID&lt;/code&gt; 라는 버전 번호를 각 직렬화 가능 클래스와 버전 번호와 연관시킵니다. 수신자가 해당 송신자의 클래스와 다른 &lt;code&gt;serialVersionUID&lt;/code&gt; 를 가진 객체의 클래스를로드 한 경우 역 직렬화는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InvalidClassException.html&quot;&gt; &lt;code&gt;InvalidClassException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다. 직렬화 가능 클래스는 static, final 및 &lt;code&gt;long&lt;/code&gt; 유형이어야하는 &lt;code&gt;serialVersionUID&lt;/code&gt; 라는 필드를 선언하여 고유 한 &lt;code&gt;serialVersionUID&lt;/code&gt; 를 명시 적으로 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d73388301e50851d95c48f1857d574425566028" translate="yes" xml:space="preserve">
          <source>The serialization runtime comes up with a number called Serial version for each serializable class. This number is called serialVersionUID. Now there is some Math behind this number and it comes out based on the fields/methods that are defined in the class. For the same class the same version is generated every time. This number is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender's class, then deserialization will result in an InvalidClassException.</source>
          <target state="translated">직렬화 런타임은 각 직렬화 가능 클래스에 대해 직렬 버전이라는 숫자를 제공합니다. 이 번호를 serialVersionUID라고합니다. 이제이 숫자 뒤에 수학이 있으며 클래스에 정의 된 필드 / 메소드를 기반으로합니다. 동일한 클래스에 대해 매번 동일한 버전이 생성됩니다. 이 숫자는 직렬화 해제 중에 직렬화 된 오브젝트의 송신자와 수신자가 직렬화와 호환되는 해당 오브젝트에 대한 클래스를로드했는지 확인하는 데 사용됩니다. 수신자가 해당 송신자의 클래스와 다른 serialVersionUID를 가진 객체에 대한 클래스를로드 한 경우 역 직렬화는 InvalidClassException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e1820339c9471fdde6c6876cce75b62eb78d6e1e" translate="yes" xml:space="preserve">
          <source>This .lst includes the list of java files to add the serialVersionUID in the following format:</source>
          <target state="translated">이 .lst에는 다음 형식으로 serialVersionUID를 추가하는 Java 파일 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="df238493e0e777844116509927cb606c7ebeaf41" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;POJO's&lt;/code&gt; class was packaged inside the EJB jar and inside it's own jar in the WEB-INF/lib of the web module. They're actually the same class, but when I package the EJB module I unpack this POJO's jar to pack it together with the EJB module.</source>
          <target state="translated">이 &lt;code&gt;POJO's&lt;/code&gt; 클래스는 EJB jar 내부와 웹 모듈의 WEB-INF / lib에있는 자체 jar 내부에 패키지되었습니다. 그들은 실제로 같은 클래스이지만 EJB 모듈을 패키지 할 때이 POJO의 jar를 풀고 EJB 모듈과 함께 포장합니다.</target>
        </trans-unit>
        <trans-unit id="eda370108a690dac70b6b7f258be620a2ea98537" translate="yes" xml:space="preserve">
          <source>This question is very well documented in Effective Java by Joshua Bloch. A very good book and a must read. I will outline some of the reasons below :</source>
          <target state="translated">이 질문은 Joshua Bloch의 Effective Java에 잘 설명되어 있습니다. 아주 좋은 책과 필독서. 아래에 몇 가지 이유를 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="e6c3eaa61a8392ceb99402b7ec2b883a685250df" translate="yes" xml:space="preserve">
          <source>This script uses the JDK serialVer tool under hood. So make sure your $JAVA_HOME/bin is in the PATH.</source>
          <target state="translated">이 스크립트는 JDK serialVer 도구를 사용합니다. 따라서 $ JAVA_HOME / bin이 PATH에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dbfd0fd5f5dc0716357b84d3ad13563ed41cd74d" translate="yes" xml:space="preserve">
          <source>To tell the long story short this field is used to check if serialized data can be deserialized correctly. Serialization and deserialization are often made by different copies of program - for example server converts object to string and client converts received string to object. This field tells that both operates with same idea about what this object is. This field helps when:</source>
          <target state="translated">간단히 말해이 필드는 직렬화 된 데이터가 올바르게 직렬화 해제 될 수 있는지 확인하는 데 사용됩니다. 직렬화 및 역 직렬화는 종종 프로그램의 다른 사본에 의해 이루어집니다. 예를 들어 서버는 오브젝트를 문자열로 변환하고 클라이언트는 수신 된 문자열을 오브젝트로 변환합니다. 이 필드는이 객체가 무엇인지에 대해 동일한 아이디어로 작동한다는 것을 알려줍니다. 이 필드는 다음과 같은 경우에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dd3e2784d9ca1e76f345e2c02320bcee304f69db" translate="yes" xml:space="preserve">
          <source>To understand the significance of field serialVersionUID, one should understand how Serialization/Deserialization works.</source>
          <target state="translated">serialVersionUID 필드의 중요성을 이해하려면 Serialization / Deserialization 작동 방식을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="37e77042a8574f7bc74e7c4eac7f95cdb9c58c3e" translate="yes" xml:space="preserve">
          <source>Transient fields (with transient modifier) are NOT serialized, (i.e., not saved or restored). A class that implements Serializable must mark transient fields of classes that do not support serialization (e.g., a file stream).</source>
          <target state="translated">임시 필드 (일시 수정 자 포함)는 직렬화되지 않습니다 (즉, 저장 또는 복원되지 않음). Serializable을 구현하는 클래스는 직렬화를 지원하지 않는 클래스의 임시 필드 (예 : 파일 스트림)를 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="6933e4b126085de9a1c38f4952dbf4a40e9a5eb8" translate="yes" xml:space="preserve">
          <source>Unnecessary code: Local variable is never read</source>
          <target state="translated">불필요한 코드 : 지역 변수를 읽지 않습니다</target>
        </trans-unit>
        <trans-unit id="f4dc52549539b19698124f7e90a02424ea54ba1a" translate="yes" xml:space="preserve">
          <source>Unnecessary code: Redundant null check</source>
          <target state="translated">불필요한 코드 : 중복 null 검사</target>
        </trans-unit>
        <trans-unit id="c7210433dda8b7ce92a18a3075ff6bf0ef7ad0e4" translate="yes" xml:space="preserve">
          <source>Unnecessary code: Unnecessary cast or 'instanceof'</source>
          <target state="translated">불필요한 코드 : 불필요한 캐스트 또는 '인스턴스'</target>
        </trans-unit>
        <trans-unit id="fd9d198118f237407393e2591aad4500758c788d" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;serialVersionUID&lt;/code&gt; and why is it important?  Please show an example where missing &lt;code&gt;serialVersionUID&lt;/code&gt; will cause a problem.</source>
          <target state="translated">&lt;code&gt;serialVersionUID&lt;/code&gt; 란 무엇이며 왜 중요합니까? &lt;code&gt;serialVersionUID&lt;/code&gt; 가 누락되면 문제가 발생하는 예를 보여주십시오.</target>
        </trans-unit>
        <trans-unit id="a4ea858c614f1d33ff483134e363a7793202d993" translate="yes" xml:space="preserve">
          <source>What is SerialVersionUID?
Answer : - Lets say there are two persons, one from HQ and another from ODC, both are going to perform serialization and deserialization respectively. In this case to authenticate that the receiver who is in ODC is the authenticated person, JVM creates a Unique ID which is known as SerialVersionUID.</source>
          <target state="translated">SerialVersionUID 란 무엇입니까? 답변 :-본사와 ODC의 두 사람이 각각 직렬화와 역 직렬화를 수행한다고 가정합니다. 이 경우 ODC에있는 수신자가 인증 된 사람임을 인증하기 위해 JVM은 SerialVersionUID라는 고유 ID를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="950af41ee22eb0cc9a288d545197579a5b5fd3a5" translate="yes" xml:space="preserve">
          <source>What is a &lt;strong&gt;serialVersionUID&lt;/strong&gt; and why should I use it?</source>
          <target state="translated">&lt;strong&gt;serialVersionUID&lt;/strong&gt; 란 무엇이며 왜 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="8f076480c7cb5030ccf2dd924c9ba10624283650" translate="yes" xml:space="preserve">
          <source>What is a serialVersionUID and why should I use it</source>
          <target state="translated">serialVersionUID 란 무엇이며 왜 사용해야합니까</target>
        </trans-unit>
        <trans-unit id="0a65d9aec5e04f6f465638e6617262c10a1f5e64" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Object&lt;/code&gt; is serialized, Java Runtime associates the serial version number aka, the &lt;code&gt;serialVersionID&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 가 직렬화되면 Java Runtime은 직렬 버전 번호 (일명 &lt;code&gt;serialVersionID&lt;/code&gt; )를 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="143a994f6ea5500278ddcbc04f354fc10ddaf1e7" translate="yes" xml:space="preserve">
          <source>When a Serializable class object is serialized Java Runtime associates a serial version no.(called as serialVersionUID) with this serialized object. At the time when you deserialize this serialized object Java Runtime matches the serialVersionUID of serialized object with the serialVersionUID of the class. If both are equal then only it proceeds with the further process of deserialization else throws InvalidClassException.</source>
          <target state="translated">직렬화 가능 클래스 객체가 직렬화 될 때 Java 런타임은 직렬화 버전 번호 (serialVersionUID)를이 직렬화 객체와 연관시킵니다. 이 직렬화 된 객체를 직렬화 해제 할 때 Java 런타임은 직렬화 된 객체의 serialVersionUID를 클래스의 serialVersionUID와 일치시킵니다. 둘 다 동일하면 추가 직렬화 해제 프로세스 만 진행되고 그렇지 않으면 InvalidClassException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dc0a24660bcec6abbb26821fa0ecf2e40563a013" translate="yes" xml:space="preserve">
          <source>When is it important?</source>
          <target state="translated">언제 중요합니까?</target>
        </trans-unit>
        <trans-unit id="9af86a025d44d1c589a0e09607b2c8ff0ff76c70" translate="yes" xml:space="preserve">
          <source>When you declare a class as &lt;code&gt;Serializable&lt;/code&gt; by implementing marker interface &lt;code&gt;java.io.Serializable&lt;/code&gt;, Java runtime persist instance of that class into disk by using default Serialization mechanism, provided you have not customized the process using &lt;code&gt;Externalizable&lt;/code&gt; interface.</source>
          <target state="translated">마커 인터페이스 &lt;code&gt;java.io.Serializable&lt;/code&gt; 을 구현하여 클래스를 &lt;code&gt;Serializable&lt;/code&gt; 로 선언 할 때, Java 런타임은 &lt;code&gt;Externalizable&lt;/code&gt; 인터페이스를 사용하여 프로세스를 사용자 정의하지 않은 경우 기본 직렬화 메커니즘을 사용하여 해당 클래스의 인스턴스를 디스크에 유지합니다.</target>
        </trans-unit>
        <trans-unit id="a4261f44712ba672b21eab3784b5b8b8c48aba87" translate="yes" xml:space="preserve">
          <source>Why SerialVersionUID?</source>
          <target state="translated">왜 SerialVersionUID인가?</target>
        </trans-unit>
        <trans-unit id="e4dc0a485759072334d504ace695ec1b74eb1c80" translate="yes" xml:space="preserve">
          <source>Window &amp;gt; Preferences &amp;gt; Java &amp;gt; Compiler &amp;gt; Errors / Warnings &amp;gt; Potential Programming Problems</source>
          <target state="translated">창&amp;gt; 환경 설정&amp;gt; Java&amp;gt; 컴파일러&amp;gt; 오류 / 경고&amp;gt; 잠재적 프로그래밍 문제</target>
        </trans-unit>
        <trans-unit id="70a5098988a4dce007a61987c0714121468c081c" translate="yes" xml:space="preserve">
          <source>You can tell Eclipse to ignore these serialVersionUID  warnings:</source>
          <target state="translated">이 serialVersionUID 경고를 무시하도록 Eclipse에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea3b691c24335342398ff9d3ac09e0eb6716601e" translate="yes" xml:space="preserve">
          <source>and in the relevant methods call &lt;code&gt;myList.foo()&lt;/code&gt; instead of &lt;code&gt;this.foo()&lt;/code&gt; (or &lt;code&gt;super.foo()&lt;/code&gt;). (This does not fit in all cases, but still quite often.)</source>
          <target state="translated">관련 메소드에서 &lt;code&gt;this.foo()&lt;/code&gt; (또는 &lt;code&gt;super.foo()&lt;/code&gt; ) 대신 &lt;code&gt;myList.foo()&lt;/code&gt; 를 호출 하십시오 . (이는 모든 경우에 적합하지는 않지만 여전히 흔합니다.)</target>
        </trans-unit>
        <trans-unit id="7316c9b112287ddcea6abbf02e4c8446c3f27278" translate="yes" xml:space="preserve">
          <source>and many more.</source>
          <target state="translated">그리고 더 많은.</target>
        </trans-unit>
        <trans-unit id="eadcd9bd2a09c75aef04954e6799e50278ee124a" translate="yes" xml:space="preserve">
          <source>do</source>
          <target state="translated">do</target>
        </trans-unit>
        <trans-unit id="64c412067ed17ca88baea5c0927d455ab8360d0e" translate="yes" xml:space="preserve">
          <source>see also &lt;a href=&quot;http://javarevisited.blogspot.in/2014/05/why-use-serialversionuid-inside-serializable-class-in-java.html&quot;&gt;Why use SerialVersionUID inside Serializable class in Java&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://javarevisited.blogspot.in/2014/05/why-use-serialversionuid-inside-serializable-class-in-java.html&quot;&gt;Java의 Serializable 클래스에서 SerialVersionUID를 사용하는 이유&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2e648a183996542247521bad401174b3bcab9d2" translate="yes" xml:space="preserve">
          <source>since most of the time the default &lt;code&gt;serialVersionUID&lt;/code&gt; is sufficient.  This includes &lt;code&gt;Exception&lt;/code&gt;, &lt;code&gt;HttpServlet&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 기본 &lt;code&gt;serialVersionUID&lt;/code&gt; 이면 충분합니다. 여기에는 &lt;code&gt;Exception&lt;/code&gt; , &lt;code&gt;HttpServlet&lt;/code&gt; 이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4e5827f62a8e420e92778b85454e12110334a0" translate="yes" xml:space="preserve">
          <source>the default serialVersionUID computation is highly sensitive to class
  details that may vary depending on compiler implementations, and can
  thus result in unexpected &lt;code&gt;InvalidClassException&lt;/code&gt;s during
  deserialization.</source>
          <target state="translated">기본 serialVersionUID 계산은 컴파일러 구현에 따라 달라질 수있는 클래스 세부 사항에 매우 민감하므로 역 직렬화 중에 예기치 않은 &lt;code&gt;InvalidClassException&lt;/code&gt; 이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d086671c4b1df573da3a6c283b2da7789b180c73" translate="yes" xml:space="preserve">
          <source>you have many different copies of your program in different places (like 1 server and 100 clients). If you will change your object, alter your version number and forget to update one this clients, it will know that he is not capable of deserialization</source>
          <target state="translated">서로 다른 위치에 1 개의 서버와 100 개의 클라이언트와 같은 다양한 프로그램 사본이 있습니다. 객체를 변경하고 버전 번호를 변경하고이 클라이언트를 업데이트하는 것을 잊어 버린 경우에는 직렬화 해제 할 수 없음을 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="4458b0ad6a09175946b64bee0e58807911feb856" translate="yes" xml:space="preserve">
          <source>you have stored your data in some file and later on you try to open it with updated version of your program with modified object - you will know that this file is not compatible if you keep your version right</source>
          <target state="translated">데이터를 일부 파일에 저장 한 후 나중에 수정 된 객체로 프로그램의 업데이트 된 버전으로 데이터를 열려고합니다. 버전을 올바르게 유지하면이 파일이 호환되지 않음을 알 수 있습니다</target>
        </trans-unit>
        <trans-unit id="df86e582309ff9c8660c860f4050c0b8e4479141" translate="yes" xml:space="preserve">
          <source>you save the this script, say add_serialVersionUID.sh to you ~/bin. Then you run it in the root directory of your Maven or Gradle project like:</source>
          <target state="translated">add_serialVersionUID.sh라는 스크립트를 ~ / bin에 저장합니다. 그런 다음 Maven 또는 Gradle 프로젝트의 루트 디렉토리에서 다음과 같이 실행하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
