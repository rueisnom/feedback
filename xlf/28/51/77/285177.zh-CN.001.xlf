<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/285177">
    <body>
      <group id="285177">
        <trans-unit id="da2c2a406688ad784f008f6ba0c37d3f4968fde4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="1570e0a400659d87380ad774797b12bbbbef9194" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; or</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0578b5272e7590f83f86c29696c0dc2dcfc69161" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;that new constructor call must be the first statement in the current constructor&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新的构造函数调用必须是当前构造函数中的第一条语句&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="113446d8c05dcdbe513e313130a7359b2fe21f6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;默认构造函数&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e504ff0eea855cb66cb68170a7d0daf098d203e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;However, keep in mind that&lt;/strong&gt; within such an explicit constructor invocation statement &lt;strong&gt;you may not refer to&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，请记住，&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这样的显式构造函数调用语句中，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可能不会引用&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c6ecf08d4ef58fcc1a22b456f5b5727456a4094" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I will tell you an easy way&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我会告诉你一个简单的方法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8fdabbee9df7d4adcd4c3a1d8b69be279041658c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parameterized constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参数化构造函数&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36836982d213919a45ff0d8bae98d2725b0a6e98" translate="yes" xml:space="preserve">
          <source>Also you can call parent constructor by using &lt;code&gt;super()&lt;/code&gt; call</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您也可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;super()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来调用父构造函数&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b351f4ed63056e18b5ad475f23042f6f33ddd67" translate="yes" xml:space="preserve">
          <source>Also, in the case of inheritance, when sub-class's object is created, the super class constructor is first called.</source>
          <target state="translated">另外,在继承的情况下,在创建子类的对象时,首先调用超级类构造函数。</target>
        </trans-unit>
        <trans-unit id="28c09431c459319070264df5eb50ac6b26e78fa1" translate="yes" xml:space="preserve">
          <source>As everybody already have said, you use &lt;code&gt;this(&amp;hellip;)&lt;/code&gt;, which is called an &lt;em&gt;explicit constructor invocation&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正如大家已经说过的，您可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this(&amp;hellip;)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这称为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显式构造函数调用&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e25a328797305f111c2114167163229894c68252" translate="yes" xml:space="preserve">
          <source>As stated in JLS (&amp;sect;8.8.7.1).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如JLS（第8.8.7.1节）所述。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf3a64e8cdb03533b2cb5b6c8ac554264862c6d8" translate="yes" xml:space="preserve">
          <source>Bellow is a link that I explain other topic about constructor and getters() and setters() and I used a class with two constructors. I hope the explanations and examples help you.</source>
          <target state="translated">Bellow是一个链接,我解释了关于构造函数和getters()和setters()的其他主题,我用了一个有两个构造函数的类。我希望这些解释和例子能帮助到你。</target>
        </trans-unit>
        <trans-unit id="c526bc07425ffc1be847fceb88efeb4d2e528240" translate="yes" xml:space="preserve">
          <source>But most often I try to do it the other way around by calling the more complex constructors from the simpler ones on the first line, to the extent possible. For the above example</source>
          <target state="translated">但大多数情况下,我尝试反其道而行之,尽可能地从第一行的较简单的构造函数中调用较复杂的构造函数。在上面的例子中</target>
        </trans-unit>
        <trans-unit id="b352d2c0748e18100553eb126c40fd5afc858ce0" translate="yes" xml:space="preserve">
          <source>Call it with...</source>
          <target state="translated">叫它用.....</target>
        </trans-unit>
        <trans-unit id="08c629ca58c6af8a5e124bb86ea1ce1b8ca4e4ea" translate="yes" xml:space="preserve">
          <source>Calling constructor from another constructor</source>
          <target state="translated">从其他构造函数中调用构造函数</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eeff9a63bf20eab5f1e144bf188811896077bcb0" translate="yes" xml:space="preserve">
          <source>Here's another Rectangle class, with a different implementation from the one in the Objects section.</source>
          <target state="translated">这里是另一个Rectangle类,与Objects部分的实现不同。</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">希望这对你有帮助。</target>
        </trans-unit>
        <trans-unit id="1a4878850a19e4ba95a9ea5c6ab33e240129f8c3" translate="yes" xml:space="preserve">
          <source>How do I call one constructor from another in Java</source>
          <target state="translated">如何在Java中从另一个构造函数中调用一个构造函数?</target>
        </trans-unit>
        <trans-unit id="9cd61cf9ea6fcc205f720e1465e10fcb258d0780" translate="yes" xml:space="preserve">
          <source>However, such a call must be the &lt;strong&gt;first&lt;/strong&gt; statement of your constructor. To &lt;strong&gt;overcome&lt;/strong&gt; this limitation, use &lt;a href=&quot;https://stackoverflow.com/a/51571736/9772691&quot;&gt;this answer&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，这样的调用必须是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;构造函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一条&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语句。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;克服&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此限制，请使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/51571736/9772691&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此答案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29b5be6516cfa45ce600e3f206a012a0e823d433" translate="yes" xml:space="preserve">
          <source>I know there are so many examples of this question but what I found I am putting here to share my Idea. there are two ways to chain constructor. In Same class you can use this keyword. in Inheritance, you need to use super keyword.</source>
          <target state="translated">我知道这个问题有很多的例子,但是我发现的是我在这里分享我的想法。在同一个类中,你可以使用这个关键字,在继承中,你需要使用超级关键字。</target>
        </trans-unit>
        <trans-unit id="a7bef60a9c8ba9945f6fea6181eaa5bc82defcdb" translate="yes" xml:space="preserve">
          <source>I prefer this way:</source>
          <target state="translated">我更喜欢这种方式。</target>
        </trans-unit>
        <trans-unit id="8a0a1a6c31c2f468bfa17b1badfb996ec443bcaa" translate="yes" xml:space="preserve">
          <source>I will explain in one Example</source>
          <target state="translated">我将用一个例子来说明</target>
        </trans-unit>
        <trans-unit id="a772f022da42c0a58b99959ba423388fced1389f" translate="yes" xml:space="preserve">
          <source>In Java another constructor of the same class can be called from a constructor via &lt;code&gt;this()&lt;/code&gt;. Note however that &lt;code&gt;this&lt;/code&gt; has to be on the first line.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在Java中，可以通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从构造函数中调用同一类的另一个构造函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是请注意，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须在第一行。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="857ecb12e0d4c75308567f3f5bdaa628eb9e91d9" translate="yes" xml:space="preserve">
          <source>In the above example I showed 3 types of calling</source>
          <target state="translated">在上面的例子中,我展示了3种类型的调用方式</target>
        </trans-unit>
        <trans-unit id="ed58c2b20d1c779f5f24b86488e90144d82df0e5" translate="yes" xml:space="preserve">
          <source>Is it possible to call a constructor from another (within the same class, not from a subclass)? If yes how? And what could be the best way to call another constructor (if there are several ways to do it)?</source>
          <target state="translated">是否可以从另一个类中调用构造函数(在同一个类中,而不是从子类中调用)?如果是,怎么做?最好的方法是什么(如果有几种方法的话)?</target>
        </trans-unit>
        <trans-unit id="9da498802f2772660a98c0b51c8680e59083ae79" translate="yes" xml:space="preserve">
          <source>It is called Telescoping Constructor anti-pattern or constructor chaining. Yes, you can definitely do. I see many examples above and I want to add by saying that if you know that you need only two or three constructor, it might be ok. But if you need more, please try to use different design pattern like Builder pattern. As for example:</source>
          <target state="translated">这就是所谓的伸缩构造函数反模式或构造函数链式。是的,你肯定可以这样做。我在上面看到了很多例子,我想补充一下,如果你知道你只需要两个或三个构造函数,可能就可以了。但是,如果你需要更多,请尝试使用不同的设计模式,比如Builder模式。举个例子。</target>
        </trans-unit>
        <trans-unit id="66d004e02aa0bd3c90660cddc0c81a6c1737ff64" translate="yes" xml:space="preserve">
          <source>Just for completeness: There is also the &lt;a href=&quot;https://stackoverflow.com/questions/3987428/what-is-an-initialization-block&quot;&gt;Instance initialization block&lt;/a&gt; that gets executed always and before any other constructor is called. It consists simply of a block of statements &quot;{ ... }&quot; somewhere in the body of your class definition.  You can even have more than one.  You can't call them, but they're like &quot;shared constructor&quot; code if you want to reuse some code across constructors, similar to calling methods.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅出于完整性考虑：还有&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3987428/what-is-an-initialization-block&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实例初始化块&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;始终在调用任何其他构造函数之前执行。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它仅由类定义主体中某处的语句&amp;ldquo; {...}&amp;rdquo;块组成。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您甚至可以拥有多个。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您不能调用它们，但是如果您想跨构造器重用某些代码，则它们类似于&amp;ldquo;共享构造器&amp;rdquo;代码，类似于调用方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1d7d343e3f1883c55ee4833e010cf3de77bb6f6" translate="yes" xml:space="preserve">
          <source>Note:
&lt;strong&gt;this must be the first statement in the constructor.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意： &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这必须是构造函数中的第一条语句。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c3c87e545947fc34b0d17bf8dd7b820d790be25" translate="yes" xml:space="preserve">
          <source>Originally from an anser by Mirko Klemm, slightly modified to address the question:</source>
          <target state="translated">原载于Mirko Klemm的回答,稍作修改,以解决这个问题。</target>
        </trans-unit>
        <trans-unit id="2c64aa5e2c637c8c6604b5cd115dc7194eec49f0" translate="yes" xml:space="preserve">
          <source>Output -
string as arg constructor..
Default constructor..
int as arg constructor..</source>
          <target state="translated">Output-string作为参数构造函数.....默认的构造函数....int作为参数构造函数.....</target>
        </trans-unit>
        <trans-unit id="b60d3818158ba9dbeee3b0a5bda99862e20e9e64" translate="yes" xml:space="preserve">
          <source>Please note that for constructor, only overloading concept is applicable and not inheritance or overriding.</source>
          <target state="translated">请注意,对于构造函数,只适用于重载概念,不适用于继承和重载。</target>
        </trans-unit>
        <trans-unit id="c0837e769968431d150bbf5446ef7cf12b4e4b95" translate="yes" xml:space="preserve">
          <source>Pretty simple</source>
          <target state="translated">很简单</target>
        </trans-unit>
        <trans-unit id="d1a28d81c68af25fcf29c170dcb874d6691a17a9" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/questions/284896&quot;&gt;this related question&lt;/a&gt;, which is about C# but where the same principles apply.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另请参见&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/284896&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; C＃有关但适用相同原理的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相关问题&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b55c0a50cc14146837a8fe190b060cd511d1bdc9" translate="yes" xml:space="preserve">
          <source>Setter methods or constructors</source>
          <target state="translated">Setter方法或构造函数</target>
        </trans-unit>
        <trans-unit id="8deb1cfdc16d10db651aff1f90e9993550a27ead" translate="yes" xml:space="preserve">
          <source>So in your case</source>
          <target state="translated">所以在你的情况下</target>
        </trans-unit>
        <trans-unit id="93774368e56263cf0765c4499f0ac1c3e9f304a5" translate="yes" xml:space="preserve">
          <source>So, something like below will not work.</source>
          <target state="translated">所以,像下面这样的东西是行不通的。</target>
        </trans-unit>
        <trans-unit id="cea6e61837f7133ec906933675fe50fbb564825c" translate="yes" xml:space="preserve">
          <source>That &lt;code&gt;this&lt;/code&gt; has to appear on the first line looks like a big limitation, but you can construct the arguments of other constructors via static methods. For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有出现在第一线看起来像一个大的限制，但可以通过静态方法构建其他构造函数的参数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b473341650fae32aaa7670f04766d11ce38db7c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt; can be used to call a constructor from a constructor, when writing several constructor for a class, there are times when you'd like to call one constructor from another to avoid duplicate code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;this&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以用来从构造函数调用构造函数，当为一个类编写多个构造函数时，有时您希望从另一个构造函数调用以避免重复代码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46cb785349c7e141897f24d50c33594ec96e1a6f" translate="yes" xml:space="preserve">
          <source>There are &lt;strong&gt;two&lt;/strong&gt; types of constructors:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两种&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型的构造函数：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7d05e73fcf59db3100ee9ab16c27575c98172193" translate="yes" xml:space="preserve">
          <source>There are design patterns that cover the need for complex construction - if it can't be done succinctly, create a factory method or a factory class.</source>
          <target state="translated">有的设计模式涵盖了复杂结构的需求--如果不能简明扼要地完成,就创建一个工厂方法或工厂类。</target>
        </trans-unit>
        <trans-unit id="0d824cab49c8e2bffb159a9925aa5fe848c301c8" translate="yes" xml:space="preserve">
          <source>There is also a &quot;static&quot; version of this to initialize static members: &quot;static { ... }&quot;</source>
          <target state="translated">还有一个 &quot;静态 &quot;版本,用于初始化静态成员。&quot;static{....}&quot;</target>
        </trans-unit>
        <trans-unit id="b86ec29c29a7fe5f742c631234d9a9f82e359477" translate="yes" xml:space="preserve">
          <source>This class contains a set of constructors. Each constructor initializes some or all of the rectangle's member variables.</source>
          <target state="translated">这个类包含了一组构造函数。每个构造函数初始化矩形的部分或全部成员变量。</target>
        </trans-unit>
        <trans-unit id="e6eb5df5f73e0e830ef7ab5b3b0bb277bfe295b7" translate="yes" xml:space="preserve">
          <source>This is Name less Object. this automatically calls the default constructor.
3.This calls the Parameterized constructor.</source>
          <target state="translated">2.这个是Name less Object.这个会自动调用默认的构造函数。3.this调用参数化构造函数。</target>
        </trans-unit>
        <trans-unit id="6e8901eec108afd7fb2965a3eb12cb2ac6b16570" translate="yes" xml:space="preserve">
          <source>This is known as constructor overloading.</source>
          <target state="translated">这就是所谓的构造函数超载。</target>
        </trans-unit>
        <trans-unit id="e11ccaaaee014d236c3c0ddb05be21104e16827e" translate="yes" xml:space="preserve">
          <source>Thus, in this case also another constructor call is first declared before any other statements.</source>
          <target state="translated">因此,在这种情况下,另一个构造函数的调用也是先于其他语句声明的。</target>
        </trans-unit>
        <trans-unit id="e94da6c3ce24db587867b70aecc294c08a1dfa21" translate="yes" xml:space="preserve">
          <source>To call a super class, use &lt;code&gt;super(someValue)&lt;/code&gt;. The call to super must be the first call in the constructor or you will get a compiler error.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要调用超类，请使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;super(someValue)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对super的调用必须是构造函数中的第一个调用，否则会出现编译器错误。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c5584dacc3d23e8ed9c3c12f048a86e11d74317" translate="yes" xml:space="preserve">
          <source>To chain to a particular superclass constructor instead of one in the same class, use &lt;code&gt;super&lt;/code&gt; instead of &lt;code&gt;this&lt;/code&gt;. Note that &lt;strong&gt;you can only chain to one constructor&lt;/strong&gt;, and &lt;strong&gt;it has to be the first statement in your constructor body&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要链接到特定的超类构造函数而不是同一个类中的构造函数，请使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;super&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代替&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您只能链接到一个构造函数&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它必须是构造函数主体中的第一条语句&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2957781ef81901c7cae99584981e6e6e10de870d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;this(args)&lt;/code&gt;. The preferred pattern is to work from the smallest constructor to the largest.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this(args)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首选模式是从最小的构造函数到最大的构造函数工作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c71ec62e7c534c99f241f1b9c64ad5a0eff8f03a" translate="yes" xml:space="preserve">
          <source>When I need to call another constructor from inside the code (not on the first line), I usually use a helper method like this:</source>
          <target state="translated">当我需要从代码内部调用另一个构造函数时(不是在第一行),我通常会使用像这样的帮助方法。</target>
        </trans-unit>
        <trans-unit id="f601b8dbd208f77468ecf20c9b2cae92e73a7157" translate="yes" xml:space="preserve">
          <source>With the latest java and the addition of lambdas, it is easy to create a constructor which can accept any initialization code you desire.</source>
          <target state="translated">随着最新的java和lambdas的加入,可以很容易地创建一个可以接受任何你想要的初始化代码的构造函数。</target>
        </trans-unit>
        <trans-unit id="2b4a9b886e4715c909583716543881bb5d30e20f" translate="yes" xml:space="preserve">
          <source>Within a constructor, you can use the &lt;code&gt;this&lt;/code&gt; keyword to invoke another constructor in the same class. Doing so is called an &lt;strong&gt;explicit constructor invocation&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在构造函数中，可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字调用同一类中的另一个构造函数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样做称为&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显式构造函数调用&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="324f4547602c6809ee881e493de131de31938621" translate="yes" xml:space="preserve">
          <source>Yes it is possible to call one constructor from another with use of &lt;code&gt;this()&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是的，可以使用&lt;/font&gt; &lt;code&gt;this()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;从另一个构造函数调用另一个构造函数&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6a873f2a98e0da557f4b0a4af6d3da47a7216320" translate="yes" xml:space="preserve">
          <source>Yes it is possible to call one constructor from another. But there is a rule to it. If a call is made from one constructor to another, then</source>
          <target state="translated">是的,它可以从另一个构造函数中调用一个构造函数。但是有一个规则。如果从一个构造函数调用到另一个构造函数,那么</target>
        </trans-unit>
        <trans-unit id="59827cccf7d8a67e3e558ad7439376a75bfa2aac" translate="yes" xml:space="preserve">
          <source>Yes, any number of constructors can be present in a class and they can be called by another constructor using &lt;code&gt;this()&lt;/code&gt; [Please do not confuse &lt;code&gt;this()&lt;/code&gt; constructor call with &lt;code&gt;this&lt;/code&gt; keyword]. &lt;code&gt;this()&lt;/code&gt; or &lt;code&gt;this(args)&lt;/code&gt; should be the first line in the constructor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是的，一个类中可以存在任意数量的构造函数，并且其他构造函数可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用它们&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请不要将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;构造函数调用与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;混淆&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;this(args)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该是构造函数中的第一行。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="40a92cc621d6b692f65bd0a075695cbff22ef108" translate="yes" xml:space="preserve">
          <source>Yes, it is possible:</source>
          <target state="translated">是的,这是有可能的。</target>
        </trans-unit>
        <trans-unit id="c086bb32bd17fbc422d078734db73fdb1f74abdf" translate="yes" xml:space="preserve">
          <source>Yes, you can call constructors from another constructors. For example:</source>
          <target state="translated">是的,你可以从其他构造函数中调用构造函数。比如说。</target>
        </trans-unit>
        <trans-unit id="3aeb02ac8ed5161f02b49a5b15c3a87ce2af1162" translate="yes" xml:space="preserve">
          <source>You can a constructor from another constructor of same class by using &quot;this&quot; keyword.
Example -</source>
          <target state="translated">你可以通过使用 &quot;this &quot;关键字,从同一类的另一个构造函数中选择一个构造函数。例子 --</target>
        </trans-unit>
        <trans-unit id="b9a53367857637b24d5cc48dfc2224a3953603e9" translate="yes" xml:space="preserve">
          <source>You can also use a more recently advocated approach of valueOf or just &quot;of&quot;:</source>
          <target state="translated">你也可以用最近比较提倡的valueOf或者只是 &quot;of &quot;的方法。</target>
        </trans-unit>
        <trans-unit id="347f9a5e8e0b14bdf9ec4ce6426cd612e7118d05" translate="yes" xml:space="preserve">
          <source>You can call another constructor via the &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html&quot;&gt;&lt;code&gt;this(...)&lt;/code&gt;&lt;/a&gt; keyword (when you need to call a constructor from the same class) or the &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/IandI/super.html&quot;&gt;&lt;code&gt;super(...)&lt;/code&gt;&lt;/a&gt; keyword
(when you need to call a constructor from a superclass).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以通过&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html&quot;&gt; &lt;code&gt;this(...)&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字（需要从同一类调用构造函数）或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/IandI/super.html&quot;&gt; &lt;code&gt;super(...)&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字（需要从超类调用构造函数）来调用另一个构造函数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="daf8c27c3f64e7d7ad76f0c05d70dd4e96372582" translate="yes" xml:space="preserve">
          <source>You may need more. Builder pattern would be a great solution in this case. Here is an article, it might be helpful
&lt;a href=&quot;https://medium.com/@modestofiguereo/design-patterns-2-the-builder-pattern-and-the-telescoping-constructor-anti-pattern-60a33de7522e&quot;&gt;https://medium.com/@modestofiguereo/design-patterns-2-the-builder-pattern-and-the-telescoping-constructor-anti-pattern-60a33de7522e&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可能需要更多。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，构建器模式将是一个很好的解决方案。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一篇文章，可能对您有所帮助 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://medium.com/@modestofiguereo/design-patterns-2-the-builder-pattern-and-the-telescoping-constructor-anti-pattern-60a33de7522e&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://medium.com/@modestofiguereo/design-patterns-2-the-builder-pattern-and-the-telescoping-constructor-anti-pattern-60a33de7522e&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1ab5d224884da8087e91dd77dd2d60fbc63cb1a" translate="yes" xml:space="preserve">
          <source>[&lt;em&gt;Note: I just want to add one aspect, which I did not see in the other answers: how to overcome limitations of the requirement that this() has to be on the first line).&lt;/em&gt;]</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[ &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意：我只想添加一个方面，而我在其他答案中没有看到：如何克服this（）必须在第一行的要求的限制）。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="11f02ed4a995c4fbe4f90ff04c856b69d07434fd" translate="yes" xml:space="preserve">
          <source>any &lt;em&gt;inner classes&lt;/em&gt; declared in this class or any superclass, or</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此类中声明的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内部类&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或任何超类，或&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ca3e00f6e8414f6b7690d1a46f1a23f4a994d97" translate="yes" xml:space="preserve">
          <source>any &lt;em&gt;instance methods&lt;/em&gt; or</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实例方法&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1a887ef0441b5a79b09d33a25a3f7c321a51d59" translate="yes" xml:space="preserve">
          <source>any &lt;em&gt;instance variables&lt;/em&gt; or</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实例变量&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d9773ad419a3d8fa9a0c6f17211db402c336af7" translate="yes" xml:space="preserve">
          <source>now here is some small extra credit:</source>
          <target state="translated">现在,这里是一些小的加分项。</target>
        </trans-unit>
        <trans-unit id="47ffbb8852e5c27ad65b26b1f5795ea1ed0ea736" translate="yes" xml:space="preserve">
          <source>this() call to this must be first statement in constructor</source>
          <target state="translated">对this()的调用必须是构造函数中的第一条语句。</target>
        </trans-unit>
        <trans-unit id="e4cf133ec21253dd9c3ca82fdb4db5898c4b377f" translate="yes" xml:space="preserve">
          <source>you can also read in details from 
&lt;a href=&quot;https://beginnersbook.com/2013/12/java-constructor-chaining-with-example/&quot;&gt;Constructor Chaining in Java&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您还可以从&lt;/font&gt;&lt;a href=&quot;https://beginnersbook.com/2013/12/java-constructor-chaining-with-example/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java构造函数链接中&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;详细了解 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
