<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1008019">
    <body>
      <group id="1008019">
        <trans-unit id="36c9232103517e64f0d6682eef65f9fd0ad31cd8" translate="yes" xml:space="preserve">
          <source>&quot;Compiler automatically builds code that creates 's' first time through the
declaration, not thereafter, and then deletes the static object at program
termination.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;컴파일러는 선언을 통해 처음으로 's'를 작성하는 코드를 자동으로 빌드 한 다음 프로그램 종료시 정적 오브젝트를 삭제합니다.&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d2883dd9a74d31ba7a51055b6db8d87e7a0f4434" translate="yes" xml:space="preserve">
          <source>...and rely on the program going out of scope to clean up afterwards.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... 그리고 범위를 벗어난 프로그램에 의존하여 나중에 정리하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ec67d195d87a2b6d8be97175d5c6042febf0567" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;@Loki Astari's answer&lt;/a&gt; is excellent.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@Loki Astari의 대답&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 훌륭합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07ef837398f606106ec996846c93366067556b6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First Way:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫 번째 방법 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7edf76288aa87f9cb7eedb19f44e96cd79d975b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second Way&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 번째 방법&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5e615b218d4601acd5025fd68241094524be9d5" translate="yes" xml:space="preserve">
          <source>Access your singleton like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같이 싱글 톤에 액세스하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e8bc9322ae6e0805dbbf23f31f8b5391ac03a45d" translate="yes" xml:space="preserve">
          <source>Another issue with doing it this way is that it isn't thread-safe. In a multithreaded environment, two threads could get through the &quot;if&quot; before either has a chance to allocate the new instance (so both would). This still isn't too big of a deal if you are relying on program termination to clean up anyway.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 방법으로 수행하는 또 다른 문제는 스레드로부터 안전하지 않다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다중 스레드 환경에서 두 인스턴스가 새 인스턴스를 할당하기 전에 &quot;if&quot;를 통과 할 수 있습니다 (둘 다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어쨌든 정리하기 위해 프로그램 종료에 의존하는 경우 여전히 큰 문제는 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2268cee1e2231822454db604a4a9d2507f7be692" translate="yes" xml:space="preserve">
          <source>Another non-allocating alternative: create a singleton, say of class &lt;code&gt;C&lt;/code&gt;, as you need it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또 다른 비 할당 대안 : 클래스 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤을 작성 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="011e2628ae6347f5e9d083f901ce7ec4d7f2f95a" translate="yes" xml:space="preserve">
          <source>Being a Singleton, you usually do not want it to be destructed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤이기 때문에 일반적으로 파괴하기를 원하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a64604c83d016260a4733124a887b95b873e63c" translate="yes" xml:space="preserve">
          <source>C++ Singleton design pattern</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 싱글 톤 디자인 패턴&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b4ac098631e8cd642bf5398d974d442fffbb33de" translate="yes" xml:space="preserve">
          <source>Can any one provide me a sample of Singleton in c++?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아무도 나에게 C ++의 싱글 톤 샘플을 제공 할 수 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="36434822ee78833774234098604d3ea82e322d9c" translate="yes" xml:space="preserve">
          <source>Dr Dobbs: C++ and The Perils of Double-Checked Locking: Part I</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dr Dobbs : C ++ 및 이중 확인 잠금의 위험 : 1 부&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="d17857ecfe425c540113b2fd20e8ccff69da0f24" translate="yes" xml:space="preserve">
          <source>Finding C++ static initialization order problems</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 정적 초기화 순서 문제 찾기&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="efb7ceb0ff0a01cffe2bed6ecc78a9b33e6bac7e" translate="yes" xml:space="preserve">
          <source>From this declaration I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem in the implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 선언에서 인스턴스 필드가 힙에서 시작된 것으로 추론 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 메모리 할당이 있음을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리가 정확히 할당 해제 될 때가 확실하지 않은 것은 무엇입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아니면 버그와 메모리 누수가 있습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현에 문제가있는 것 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e8c991a85485d2e54dacdbf83944ac53596b1f6" translate="yes" xml:space="preserve">
          <source>Has anyone mentioned &lt;code&gt;std::call_once&lt;/code&gt; and &lt;code&gt;std::once_flag&lt;/code&gt;?
Most other approaches - including double checked locking - are broken.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::call_once&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::once_flag&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 언급 한 사람이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이중 검사 잠금을 포함한 대부분의 다른 접근 방식이 중단되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e22081f06dbc88faa869c500655545f8b3b49e97" translate="yes" xml:space="preserve">
          <source>Here 00915CB8 is the memory location of singleton Object, same for the duration of the program but (normally!) different each time the program is run.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서 00915CB8은 싱글 톤 오브젝트의 메모리 위치이며 프로그램 기간 동안 동일하지만 프로그램이 실행될 때마다 다릅니다 (일반적으로!).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d93f58ba958d8ddddf1f1a269f714ce7fae89839" translate="yes" xml:space="preserve">
          <source>Here is an easy implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 쉬운 구현입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83f14721c00dbed7f33a39fff1861abde1780df6" translate="yes" xml:space="preserve">
          <source>Here is an updated C++11 implementation of the Singleton design pattern that is lazy-evaluated, correctly-destroyed, and &lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;thread-safe&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 게으른 평가, 올바르게 파괴되고 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드로부터 안전한&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Singleton 디자인 패턴의 업데이트 된 C ++ 11 구현입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b06e170e85f393d0825ee9533ff40bb6760c88f" translate="yes" xml:space="preserve">
          <source>However there are times with multiple static objects where you need to be able to guarantee that the &lt;em&gt;singleton&lt;/em&gt; will not be destroyed until all your static objects that use the &lt;em&gt;singleton&lt;/em&gt; no longer need it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 여러 정적 개체가있는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우에는 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 사용하는 모든 정적 개체가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 이상 필요하지 않을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때까지 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;손상&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 되지 않도록 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보장 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해야합니다.&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="448691124971d770be6bd3cf7a1db111c706cea4" translate="yes" xml:space="preserve">
          <source>However, it is good practice to clean up at program termination. Therefore, you can do this with an auxiliary static SingletonDestructor class and declare that as a friend in your Singleton.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 프로그램 종료시 정리하는 것이 좋습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 보조 정적 SingletonDestructor 클래스를 사용하여이 작업을 수행하고이를 Singleton의 친구로 선언 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a961b506da874e67a11c5fad251a627e2bb6cb12" translate="yes" xml:space="preserve">
          <source>I did not find a CRTP implementation among the answers, so here it is:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;답변 중 CRTP 구현을 찾지 못 했으므로 여기에 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a02edb8cd40a9fa55f78844c4bb1fde3d56d28a8" translate="yes" xml:space="preserve">
          <source>I met this problem, when trying to introduce a Singleton in the Qt application. I decided, that all my setup dialogs must be Singletons, and adopted the pattern above. Unfortunately, Qt's main class &lt;code&gt;QApplication&lt;/code&gt; was allocated on stack in the &lt;code&gt;main&lt;/code&gt; function, and Qt forbids creating/destroying dialogs when no application object is available.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Qt 응용 프로그램에 Singleton을 도입하려고 할 때이 문제가 발생했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 설정 대화 상자가 싱글 톤이어야한다고 결정하고 위의 패턴을 채택했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;불행히도 Qt의 메인 클래스 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;QApplication&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 함수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 스택에 할당되었으며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Qt는 사용 가능한 응용 프로그램 객체가 없을 때 대화 상자를 만들거나 파괴하는 것을 금지합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bfa20c1c1aff78139863f88ace5d0a2adc9a6311" translate="yes" xml:space="preserve">
          <source>I prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 이런 종류의 구현을 선호한다. (실제로, 싱글 톤을 가능한 많이 피하기 때문에 내가 선호한다고 올바르게 말하지는 않는다) :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee2aed6c9894fa2b3220ca1cf8279311dd18c188" translate="yes" xml:space="preserve">
          <source>I think You should write a static function wherein your static object is deleted.
You should call this function when you are about to close your application.
This will ensure you dont have memory leakage.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정적 객체가 삭제되는 정적 함수를 작성해야한다고 생각합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;응용 프로그램을 닫으려고 할 때이 함수를 호출해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이렇게하면 메모리 누수가 발생하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f1aa530a0739a8ab5932864cc56e6ecc2819aa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 자체가 템플릿 클래스는 다음입니다 상황이 지저분 얻을 수 있지만, 아마도 다음과 같은 서명이 헬퍼 클래스를 구현하여,이 방법을 사용하는 것은 여전히 가능하다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50f3ffb9b1ad143b57ce983140aed72bd955b546" translate="yes" xml:space="preserve">
          <source>If you want to allocate the object in heap, why don't use a unique pointer. Memory will also be deallocated since we are using a unique pointer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체를 힙으로 할당하려면 고유 포인터를 사용하지 않는 것이 좋습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;고유 한 포인터를 사용하므로 메모리도 할당 해제됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ad91f497862ef558e636b6c57c8848e082bec9f" translate="yes" xml:space="preserve">
          <source>If you work on a platform where cleanup must be done manually, I'd probably add a manual cleanup routine.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정리를 수동으로 수행해야하는 플랫폼에서 작업하는 경우 수동 정리 루틴을 추가했을 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="58153ad0f2a351dc0310fad80b8006f69491576b" translate="yes" xml:space="preserve">
          <source>Implement it similar to the way you have it in your example. As for destruction, &quot;Singletons usually endure for the length of the program run; most OSs will recover memory and most other resources when a program terminates, so there is an argument for not worrying about this.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예제에서와 비슷한 방식으로 구현하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파괴에 관해서는 &quot;단일 프로그램은 일반적으로 프로그램 실행 기간 동안 견뎌야한다. 대부분의 OS는 프로그램이 종료 될 때 메모리와 대부분의 다른 자원을 복구하므로 이에 대해 걱정하지 않아도된다&quot;고 말했다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ec513111a6255768ad759087587f71a305fd98c" translate="yes" xml:space="preserve">
          <source>In 2008 I provided a C++98 implementation of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction, not-technically-thread-safe:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2008 년에 나는 기술적으로 스레드로부터 안전하지 않은 게으른 평가되고, 파괴를 보장하는 Singleton 디자인 패턴의 C ++ 98 구현을 제공했다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6ad103f816f6531a30eb7e68d5a16576c0db7171" translate="yes" xml:space="preserve">
          <source>In addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에있는 다른 토론 외에도 사용을 하나의 인스턴스로 제한하지 않고 전역 성을 가질 수 있다는 점에 주목할 가치가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 참조 카운트의 경우를 생각해보십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0a8cc7fb43e3e00c5689247fd36b5590d04d43fe" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;std::shared_ptr&lt;/code&gt; can be used to keep the &lt;em&gt;singleton&lt;/em&gt; alive for all users even when the static destructors are being called at the end of the program:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 정적 소멸자가 프로그램 끝에서 호출되는 경우에도 모든 사용자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 유지할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0297137859db5072b87d3de3253a183fe8d2a132" translate="yes" xml:space="preserve">
          <source>It has no dynamic memory allocation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동적 메모리 할당이 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4161b1ad79a47a16c61ad1aba0f2011aa4fd5ab4" translate="yes" xml:space="preserve">
          <source>It is indeed probably allocated from the heap, but without the sources there is no way of knowing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 힙에서 할당되었지만 소스가 없으면 알 방법이 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c30ebb06c17cf8f53d6d497493adf232a4a32fee" translate="yes" xml:space="preserve">
          <source>It will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton.  If you want to be able to explicitly clean it, it's fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it's used, but that's outside of the scope of a &quot;classic&quot; singleton.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그램이 종료되면 단절되고 할당이 해제되며 이는 싱글 톤에 대한 정상적인 동작입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;명시 적으로 정리하고 싶다면 클래스에 정적 메소드를 추가하여 깨끗한 상태로 복원하고 다음에 사용할 때 다시 할당 할 수는 있지만 쉽게 범위를 벗어납니다. &quot;클래식&quot;싱글 톤.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c64e5602a9af0c16dc3d83cb29fc0a0fb06998c8" translate="yes" xml:space="preserve">
          <source>My implementation is similar to Galik's. The difference is my implementation allows the shared pointers to clean up allocated memory, as opposed to holding onto the memory until the application is exited and the static pointers are cleaned up.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 구현은 Galik과 유사합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;차이점은 응용 프로그램이 종료되고 정적 포인터가 정리 될 때까지 메모리를 유지하는 대신 공유 포인터가 할당 된 메모리를 정리하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d3cd3cde4aa0af185c90283942754979a78a9c2b" translate="yes" xml:space="preserve">
          <source>My main question is, how do I implement it in the right way?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 주요 질문은 올바른 방법으로 구현하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="697496554c522fb6e5431ed20fc49a5e7756de39" translate="yes" xml:space="preserve">
          <source>N.B. This is not a thread safe one.You have to ensure thread safety.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;NB 이것은 스레드 안전이 아니며 스레드 안전을 보장해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ae7578b52cf3c8766544802ea79b9c71361d40f" translate="yes" xml:space="preserve">
          <source>Neither this nor Cătălin's answer is automatically thread-safe in current C++, but will be in C++0x.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것과 Cătălin의 대답은 현재 C ++에서 자동으로 스레드 안전하지 않지만 C ++ 0x에 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c7a38653bee09a3cd6956dd4b338c749ce46dd8" translate="yes" xml:space="preserve">
          <source>Note also that with the Meyers Singleton you &quot;can get into very difficult situation if objects rely on each other at the time of
termination - when does the Singleton disappear relative to other objects? But for simple applications, this works fine.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Meyers Singleton을 사용하면 &quot;종료 시점에 객체가 서로 의존하는 경우 매우 어려운 상황에 처할 수 있습니다. Singleton은 언제 다른 객체에 비해 사라 집니까? 그러나 간단한 응용 프로그램의 경우에는 잘 작동합니다.&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="afd9ddaa4d72c4a6baeb072dcccdd11cd7953239" translate="yes" xml:space="preserve">
          <source>Now somewhere inside a function (such as &lt;code&gt;main&lt;/code&gt;) you can do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 내부와 같은 함수 내부에서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음을 수행 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a78e09f10d27dc0831eef859b1c65cfa888d905a" translate="yes" xml:space="preserve">
          <source>One major problem in singleton pattern implementation is safe initialization. The only safe way is to guard the initialization sequence with synchronizing barriers. But those barriers themselves need to be safely initiated. &lt;code&gt;std::once_flag&lt;/code&gt; is the mechanism to get guaranteed safe initialization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤 패턴 구현에서 한 가지 주요 문제는 안전한 초기화입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;유일한 안전한 방법은 동기화 장벽으로 초기화 시퀀스를 지키는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 이러한 장벽 자체는 안전하게 시작되어야합니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::once_flag&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 안전한 초기화를 보장하는 메커니즘입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fbe47028e7d8120fc3d32b4563c89e0009142d4f" translate="yes" xml:space="preserve">
          <source>Only one object created and this object reference is returned each and every time afterwords.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 번에 하나의 오브젝트 만 작성되고이 오브젝트 참조는 항상 매번 리턴됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="41fc1d2c4e5b1f7226fe4db3fa895813c007fb9a" translate="yes" xml:space="preserve">
          <source>Recently I've bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real life example):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최근에 저는 C ++에 대한 Singleton 디자인 패턴의 구현 / 구현에 부딪 쳤습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같이 보입니다 (실제 예제에서 채택했습니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="276b20dd2003e2c8b8147112735ed61b5985f32f" translate="yes" xml:space="preserve">
          <source>See this article about when to use a singleton: (not often)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤 사용시기에 대한이 기사를 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dc48ffee79c43defeacd652988f6d13d63671cd8" translate="yes" xml:space="preserve">
          <source>See this article describing lifetimes:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수명을 설명하는이 기사를 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6929b1498a833a4dd1c77bb041d752cda196cffc" translate="yes" xml:space="preserve">
          <source>See this article that discusses some threading implications to singletons:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤에 대한 몇 가지 스레딩 영향에 대해 설명하는이 기사를 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1297f70db8f6ff1cb7f6cadad4fd0176e9ad52a" translate="yes" xml:space="preserve">
          <source>See this article that explains why double checked locking will not work on C++:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++에서 이중 검사 잠금이 작동하지 않는 이유를 설명하는이 기사를 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8a3f5854c04a6c2fd9c6b0eed898518205b893b" translate="yes" xml:space="preserve">
          <source>See this two article about initialization order and how to cope:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;초기화 순서 및 대처 방법에 대한이 두 기사를 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e229eb46fdb8abc36ed541fd75a96ad01079842c" translate="yes" xml:space="preserve">
          <source>Simple singleton class, This must be your header class file</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단한 싱글턴 클래스, 헤더 클래스 파일이어야합니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f5183f104a6ee7a2ee3c3f8a78ffcad0dd7ada1" translate="yes" xml:space="preserve">
          <source>Singleton instance declared as static variable of GetInstance method, is it thread-safe?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GetInstance 메서드의 정적 변수로 선언 된 싱글 톤 인스턴스입니다. 스레드로부터 안전합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="616cb2246d061aa00ec22ca9c85c492806ae00f9" translate="yes" xml:space="preserve">
          <source>Singleton: How should it be used</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;싱글 톤 : 어떻게 사용해야합니까&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ddbfa6229ac4bbfeea0426af8472583accde3ea" translate="yes" xml:space="preserve">
          <source>Static variables initialisation order</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정적 변수 초기화 순서&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3606cc4233d18abdcf887e06f1cde5c7e5230832" translate="yes" xml:space="preserve">
          <source>That is why I prefer heap-allocated singletons. I provide an explicit &lt;code&gt;init()&lt;/code&gt; and &lt;code&gt;term()&lt;/code&gt; methods for all the singletons and call them inside &lt;code&gt;main&lt;/code&gt;. Thus I have a full control over the order of singletons creation/destruction, and also I guarantee that singletons will be created, no matter whether someone called &lt;code&gt;getInstance()&lt;/code&gt; or not.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇기 때문에 힙 할당 싱글 톤을 선호합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 싱글 톤에 대해 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;명시적인 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;init()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;term()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드를 제공하고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 내부에서 호출합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 싱글 톤 생성 / 파괴 순서를 완전히 제어 할 수 있으며 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;getInstance()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 호출 여부에 관계없이 싱글 톤이 생성되도록 보장합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="024eab215b08bb3333ee58e19b30d9d60b0c180e" translate="yes" xml:space="preserve">
          <source>The Singleton_destroyer will be created on program startup, and &quot;when program terminates, all global/static objects are destroyed by the runtime library shutdown code (inserted by the linker), so the_destroyer will be destroyed; its destructor will delete the Singleton, running its destructor.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Singleton_destroyer는 프로그램 시작시 생성되고 &quot;프로그램이 종료되면 모든 전역 / 정적 객체가 런타임 라이브러리 종료 코드 (링커에 의해 삽입 됨)에 의해 파괴되므로 _destroyer가 파괴됩니다. 소멸자는 Singleton을 삭제하여 파괴 장치.&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5008e6ca7deb401eab76f0a1b7199dbd571aeac8" translate="yes" xml:space="preserve">
          <source>The paper that was linked to above describes the shortcoming of double checked locking is that the compiler may allocate the memory for the object and set a pointer to the address of the allocated memory, before the object's constructor has been called. It is quite easy in c++ however to use allocaters to allocate the memory manually, and then use a construct call to initialize the memory. Using this appraoch, the double-checked locking works just fine.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위에 링크 된 논문은 이중 확인 잠금의 단점에 대해 설명합니다. 컴파일러는 객체의 생성자가 호출되기 전에 객체에 메모리를 할당하고 할당 된 메모리의 주소에 대한 포인터를 설정할 수 있다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 C ++에서는 할당자를 사용하여 메모리를 수동으로 할당 한 다음 구성 호출을 사용하여 메모리를 초기화하는 것이 매우 쉽습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 방법을 사용하면 이중 확인 잠금이 제대로 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b6f3f591e89067a6d11cf1b1060464622dca5fbe" translate="yes" xml:space="preserve">
          <source>The refs don't need to store a pointer back to their respective &lt;code&gt;Store&lt;/code&gt; because that information is supplied at compile-time. You also don't have to worry about the &lt;code&gt;Store&lt;/code&gt;'s lifetime because the compiler requires that it is global.  If there is indeed only one instance of &lt;code&gt;Store&lt;/code&gt; then there's no overhead in this approach; with more than one instance it's up to the compiler to be clever about code generation. If necessary, the &lt;code&gt;ItemRef&lt;/code&gt; class can even be made a &lt;code&gt;friend&lt;/code&gt; of &lt;code&gt;Store&lt;/code&gt; (you can have templated friends!).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조는 해당 정보가 컴파일 타임에 제공되므로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해당 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; 에&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 포인터를 다시 저장할 필요가 없습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 또한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러가 전역을 요구하기 때문에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 수명 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에 대해 걱정할 필요가 없습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 실제로 하나의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인스턴스 만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있는 경우이 방법에는 오버 헤드가 없습니다. 둘 이상의 인스턴스를 사용하면 코드 생성에 대해 영리한 것은 컴파일러의 책임입니다. 필요한 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ItemRef&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 &lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;friend&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 만들 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수도 있습니다 (템플릿 템플릿을 사용할 수 있습니다).&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0786d361e2bcc95d4119e640b7e9a62ee7f81d86" translate="yes" xml:space="preserve">
          <source>The solution in the accepted answer has a significant drawback - the destructor for the singleton is called after the control leaves the &lt;code&gt;main()&lt;/code&gt; function. There may be problems really, when some dependent objects are allocated inside &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;허용 된 답변의 솔루션에는 상당한 단점이 있습니다. 단일의 소멸자는 컨트롤이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 함수를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;떠난 후에 호출 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부 종속 객체가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 내부에 할당되면 실제로 문제가 발생할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f40212b178fce257aced5352c8a45824c8a75d7d" translate="yes" xml:space="preserve">
          <source>The typical implementation (taken from some code I have in emacs already) would be:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적인 구현 (이맥스에서 이미 가지고있는 일부 코드에서 가져온)은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="56278e8448390147f165b72dfac3329a1d70ac20" translate="yes" xml:space="preserve">
          <source>The user can now create a &lt;code&gt;StoreWrapper&lt;/code&gt; type (and global instance) for each global &lt;code&gt;Store&lt;/code&gt; instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using &lt;code&gt;Store&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용자는 이제 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 글로벌 &lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인스턴스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에 대해 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;StoreWrapper&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형 (및 글로벌 인스턴스)을 작성 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 항상 랩퍼 인스턴스를 통해 스토어에 액세스 할 수 있습니다 (따라서 &lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용에 필요한 템플리트 매개 변수의 세부 사항을 잊어 버림 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;).&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e31dbd568adbc6521089b6d09e212fdb118726cc" translate="yes" xml:space="preserve">
          <source>There are two ways that I know to create a Singleton class correctly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Singleton 클래스를 올바르게 만드는 두 가지 방법이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="28521cdf5fefb8ca060ab5a22e6ddfb09cef7d8c" translate="yes" xml:space="preserve">
          <source>This is about object life-time management. Suppose you have more than singletons in your software. And they depend on Logger singleton. During application destruction, suppose another singleton object uses Logger to log its destruction steps. You have to guarantee that Logger should be cleaned up last. Therefore, please also check out this paper:
&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot;&gt;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 개체 수명 관리에 관한 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소프트웨어에 싱글 톤 이상이 있다고 가정합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 그들은 Logger singleton에 의존합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;응용 프로그램을 제거하는 동안 다른 싱글 톤 개체가 로거를 사용하여 제거 단계를 기록한다고 가정합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로거를 마지막으로 정리해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서이 백서를 확인하십시오 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d20124031b945444d0c1fd440a24d36bac0ab7f" translate="yes" xml:space="preserve">
          <source>This is called the Meyers Singleton, created by C++ wizard Scott Meyers. Simply define get_instance() differently. Now you can also get rid of the pointer member variable.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것을 C ++ 마법사 Scott Meyers가 만든 Meyers Singleton이라고합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;get_instance ()를 다르게 정의하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 포인터 멤버 변수를 제거 할 수도 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4c22b28b3d41d395f49ea96f9637893cadacf026" translate="yes" xml:space="preserve">
          <source>This is neat because the value returned is by reference and you can use &lt;code&gt;.&lt;/code&gt; syntax instead of &lt;code&gt;-&amp;gt;&lt;/code&gt; to access member variables.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반환 된 값은 참조 용이므로 사용할 수 있으므로 깔끔합니다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멤버 변수에 액세스하려면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대신 구문을 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3abd989834b48d9e30b53bbf5b75ed134706ae78" translate="yes" xml:space="preserve">
          <source>To use just inherit your class from this, like: &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 클래스를 상속하려면 다음과 같이 클래스를 상속하십시오. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abfe440688144dc3488f94a3bcdd9a80d1b0b46" translate="yes" xml:space="preserve">
          <source>We went over this topic recently in my EECS class. If you want to look at the lecture notes in detail, visit &lt;a href=&quot;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&quot;&gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 최근에 EECS 수업에서이 주제를 다루었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;강의 노트를 자세히 보려면 &lt;/font&gt;&lt;a href=&quot;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf를&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 방문하십시오.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef46b5cc56312a21edb0f46af654cc29a8de451c" translate="yes" xml:space="preserve">
          <source>What are all the common undefined behaviours that a C++ programmer should know about?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 프로그래머가 알아야 할 일반적인 정의되지 않은 동작은 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f9481ffc9d80995ea84a632ec6be1da7a9d03648" translate="yes" xml:space="preserve">
          <source>What is the lifetime of a static variable in a C++ function?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 함수에서 정적 변수의 수명은 얼마입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cfbba3022f0da956a8ae5155afd7fd1da6d095b2" translate="yes" xml:space="preserve">
          <source>You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 할당을 피할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멀티 스레딩 환경의 경우 문제가있는 많은 변형이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="109c3cc202bf5d2be202483e322663f064482610" translate="yes" xml:space="preserve">
          <source>You must know that Singleton instance &lt;em&gt;doesn't need to be manually deleted by us&lt;/em&gt;. We need a single object of it throughout the whole program, so &lt;em&gt;at the end of program execution, it will be automatically deallocated.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Singleton 인스턴스 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 수동으로 삭제할 필요가 없다는&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 것을 알아야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전체 프로그램에서 단일 객체가 필요하므로 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그램 실행이 끝나면 자동으로 할당이 해제됩니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c860d67c8e3dbf690743f011c26ee8f12ab81ca" translate="yes" xml:space="preserve">
          <source>Your code is correct, except that &lt;em&gt;you didn't declare the instance pointer outside the class&lt;/em&gt;. The inside class declarations of static variables are not considered declarations in C++, however this is allowed in other languages like &lt;strong&gt;C#&lt;/strong&gt; or &lt;strong&gt;Java&lt;/strong&gt; etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 외부에서 인스턴스 포인터를 선언하지 않은&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 것을 제외하고는 코드가 정확 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정적 변수의 내부 클래스 선언은 C ++의 선언으로 간주되지 않지만 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C #&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 등과 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같은 다른 언어에서는 허용됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92bd75ebd8fd2b0179172217b15350cc6d4002f0" translate="yes" xml:space="preserve">
          <source>using</source>
          <target state="translated">using</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
