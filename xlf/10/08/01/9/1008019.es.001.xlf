<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1008019">
    <body>
      <group id="1008019">
        <trans-unit id="36c9232103517e64f0d6682eef65f9fd0ad31cd8" translate="yes" xml:space="preserve">
          <source>&quot;Compiler automatically builds code that creates 's' first time through the
declaration, not thereafter, and then deletes the static object at program
termination.&quot;</source>
          <target state="translated">&quot;El compilador construye automáticamente el código que crea 's' la primera vez a través de la declaración,no después,y luego borra el objeto estático al terminar el programa&quot;.</target>
        </trans-unit>
        <trans-unit id="d2883dd9a74d31ba7a51055b6db8d87e7a0f4434" translate="yes" xml:space="preserve">
          <source>...and rely on the program going out of scope to clean up afterwards.</source>
          <target state="translated">...y depender de que el programa se salga de su alcance para limpiarlo después.</target>
        </trans-unit>
        <trans-unit id="9ec67d195d87a2b6d8be97175d5c6042febf0567" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;@Loki Astari's answer&lt;/a&gt; is excellent.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La respuesta de @Loki Astari&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es excelente.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07ef837398f606106ec996846c93366067556b6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First Way:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Primera forma:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7edf76288aa87f9cb7eedb19f44e96cd79d975b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second Way&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Segunda forma&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5e615b218d4601acd5025fd68241094524be9d5" translate="yes" xml:space="preserve">
          <source>Access your singleton like this:</source>
          <target state="translated">Accede a tu singleton así:</target>
        </trans-unit>
        <trans-unit id="e8bc9322ae6e0805dbbf23f31f8b5391ac03a45d" translate="yes" xml:space="preserve">
          <source>Another issue with doing it this way is that it isn't thread-safe. In a multithreaded environment, two threads could get through the &quot;if&quot; before either has a chance to allocate the new instance (so both would). This still isn't too big of a deal if you are relying on program termination to clean up anyway.</source>
          <target state="translated">Otro problema de hacerlo de esta manera es que no es seguro para los hilos.En un entorno multihilo,dos hilos podrían pasar por el &quot;si&quot; antes de que cualquiera de ellos tenga la oportunidad de asignar la nueva instancia (así que ambos lo harían).Esto todavía no es demasiado importante si dependes de la terminación del programa para limpiar de todos modos.</target>
        </trans-unit>
        <trans-unit id="2268cee1e2231822454db604a4a9d2507f7be692" translate="yes" xml:space="preserve">
          <source>Another non-allocating alternative: create a singleton, say of class &lt;code&gt;C&lt;/code&gt;, as you need it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otra alternativa sin asignaci&amp;oacute;n: cree un singleton, digamos de la clase &lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , seg&amp;uacute;n lo necesite:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="011e2628ae6347f5e9d083f901ce7ec4d7f2f95a" translate="yes" xml:space="preserve">
          <source>Being a Singleton, you usually do not want it to be destructed.</source>
          <target state="translated">Siendo un Singleton,normalmente no quieres que se destruya.</target>
        </trans-unit>
        <trans-unit id="1a64604c83d016260a4733124a887b95b873e63c" translate="yes" xml:space="preserve">
          <source>C++ Singleton design pattern</source>
          <target state="translated">C++Patrón de diseño Singleton</target>
        </trans-unit>
        <trans-unit id="b4ac098631e8cd642bf5398d974d442fffbb33de" translate="yes" xml:space="preserve">
          <source>Can any one provide me a sample of Singleton in c++?</source>
          <target state="translated">¿Puede alguien proporcionarme una muestra de Singleton en c++?</target>
        </trans-unit>
        <trans-unit id="36434822ee78833774234098604d3ea82e322d9c" translate="yes" xml:space="preserve">
          <source>Dr Dobbs: C++ and The Perils of Double-Checked Locking: Part I</source>
          <target state="translated">Dr.Dobbs:C++y Los peligros de un cierre doblemente comprobado:Parte I</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="d17857ecfe425c540113b2fd20e8ccff69da0f24" translate="yes" xml:space="preserve">
          <source>Finding C++ static initialization order problems</source>
          <target state="translated">Encontrar problemas de orden de inicialización estática de C++</target>
        </trans-unit>
        <trans-unit id="efb7ceb0ff0a01cffe2bed6ecc78a9b33e6bac7e" translate="yes" xml:space="preserve">
          <source>From this declaration I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem in the implementation.</source>
          <target state="translated">De esta declaración puedo deducir que el campo de instancia se inicia en el montón.Eso significa que hay una asignación de memoria.Lo que no tengo claro es cuándo exactamente se va a distribuir la memoria.¿O hay un error y una fuga de memoria? Parece que hay un problema en la implementación.</target>
        </trans-unit>
        <trans-unit id="2e8c991a85485d2e54dacdbf83944ac53596b1f6" translate="yes" xml:space="preserve">
          <source>Has anyone mentioned &lt;code&gt;std::call_once&lt;/code&gt; and &lt;code&gt;std::once_flag&lt;/code&gt;?
Most other approaches - including double checked locking - are broken.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Alguien ha mencionado &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::call_once&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::once_flag&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La mayor&amp;iacute;a de los otros enfoques, incluido el bloqueo de doble verificaci&amp;oacute;n, est&amp;aacute;n rotos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e22081f06dbc88faa869c500655545f8b3b49e97" translate="yes" xml:space="preserve">
          <source>Here 00915CB8 is the memory location of singleton Object, same for the duration of the program but (normally!) different each time the program is run.</source>
          <target state="translated">Aquí 00915CB8 es la ubicación de memoria de Singleton Object,la misma para la duración del programa pero (¡normalmente!)diferente cada vez que se ejecuta el programa.</target>
        </trans-unit>
        <trans-unit id="d93f58ba958d8ddddf1f1a269f714ce7fae89839" translate="yes" xml:space="preserve">
          <source>Here is an easy implementation.</source>
          <target state="translated">Aquí hay una implementación fácil.</target>
        </trans-unit>
        <trans-unit id="83f14721c00dbed7f33a39fff1861abde1780df6" translate="yes" xml:space="preserve">
          <source>Here is an updated C++11 implementation of the Singleton design pattern that is lazy-evaluated, correctly-destroyed, and &lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;thread-safe&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; hay una implementaci&amp;oacute;n actualizada de C ++ 11 del patr&amp;oacute;n de dise&amp;ntilde;o Singleton que se eval&amp;uacute;a de forma diferida, se destruye correctamente y &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;es segura para subprocesos&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b06e170e85f393d0825ee9533ff40bb6760c88f" translate="yes" xml:space="preserve">
          <source>However there are times with multiple static objects where you need to be able to guarantee that the &lt;em&gt;singleton&lt;/em&gt; will not be destroyed until all your static objects that use the &lt;em&gt;singleton&lt;/em&gt; no longer need it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, hay veces con est&amp;aacute;tica varios objetos donde tiene que ser capaz de garantizar que el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;producto &amp;uacute;nico&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no ser&amp;aacute; destruido hasta que todos los objetos est&amp;aacute;ticos que utilizan el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;producto &amp;uacute;nico&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ya no lo necesitan.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="448691124971d770be6bd3cf7a1db111c706cea4" translate="yes" xml:space="preserve">
          <source>However, it is good practice to clean up at program termination. Therefore, you can do this with an auxiliary static SingletonDestructor class and declare that as a friend in your Singleton.</source>
          <target state="translated">Sin embargo,es una buena práctica limpiar al terminar el programa.Por lo tanto,puedes hacer esto con una clase de SingletonDestructor estático auxiliar y declararlo como un amigo en tu Singleton.</target>
        </trans-unit>
        <trans-unit id="a961b506da874e67a11c5fad251a627e2bb6cb12" translate="yes" xml:space="preserve">
          <source>I did not find a CRTP implementation among the answers, so here it is:</source>
          <target state="translated">No encontré una implementación de CRTP entre las respuestas,así que aquí está:</target>
        </trans-unit>
        <trans-unit id="a02edb8cd40a9fa55f78844c4bb1fde3d56d28a8" translate="yes" xml:space="preserve">
          <source>I met this problem, when trying to introduce a Singleton in the Qt application. I decided, that all my setup dialogs must be Singletons, and adopted the pattern above. Unfortunately, Qt's main class &lt;code&gt;QApplication&lt;/code&gt; was allocated on stack in the &lt;code&gt;main&lt;/code&gt; function, and Qt forbids creating/destroying dialogs when no application object is available.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Encontr&amp;eacute; este problema al intentar introducir un Singleton en la aplicaci&amp;oacute;n Qt. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Decid&amp;iacute; que todos mis cuadros de di&amp;aacute;logo de configuraci&amp;oacute;n deben ser Singletons, y adopt&amp;eacute; el patr&amp;oacute;n anterior. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desafortunadamente, la clase principal &lt;/font&gt;&lt;/font&gt; &lt;code&gt;QApplication&lt;/code&gt; de Qt&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se asign&amp;oacute; en la pila en la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y Qt proh&amp;iacute;be crear / destruir di&amp;aacute;logos cuando no hay ning&amp;uacute;n objeto de aplicaci&amp;oacute;n disponible.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bfa20c1c1aff78139863f88ace5d0a2adc9a6311" translate="yes" xml:space="preserve">
          <source>I prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):</source>
          <target state="translated">Prefiero este tipo de implementación (en realidad,no se dice correctamente que lo prefiero,porque evito los solteros tanto como sea posible):</target>
        </trans-unit>
        <trans-unit id="ee2aed6c9894fa2b3220ca1cf8279311dd18c188" translate="yes" xml:space="preserve">
          <source>I think You should write a static function wherein your static object is deleted.
You should call this function when you are about to close your application.
This will ensure you dont have memory leakage.</source>
          <target state="translated">Creo que deberías escribir una función estática en la que se elimine tu objeto estático.Deberías llamar a esta función cuando estés a punto de cerrar tu aplicación.Esto asegurará que no tengas fugas de memoria.</target>
        </trans-unit>
        <trans-unit id="4f1aa530a0739a8ab5932864cc56e6ecc2819aa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es una clase con plantilla, entonces las cosas se vuelven m&amp;aacute;s complicadas, pero a&amp;uacute;n es posible usar este m&amp;eacute;todo, quiz&amp;aacute;s implementando una clase auxiliar con la siguiente firma:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50f3ffb9b1ad143b57ce983140aed72bd955b546" translate="yes" xml:space="preserve">
          <source>If you want to allocate the object in heap, why don't use a unique pointer. Memory will also be deallocated since we are using a unique pointer.</source>
          <target state="translated">Si quieres asignar el objeto en montón,¿por qué no usas un puntero único.La memoria también será deslocalizada ya que estamos usando un puntero único.</target>
        </trans-unit>
        <trans-unit id="8ad91f497862ef558e636b6c57c8848e082bec9f" translate="yes" xml:space="preserve">
          <source>If you work on a platform where cleanup must be done manually, I'd probably add a manual cleanup routine.</source>
          <target state="translated">Si trabajas en una plataforma donde la limpieza debe hacerse manualmente,probablemente añadiría una rutina de limpieza manual.</target>
        </trans-unit>
        <trans-unit id="58153ad0f2a351dc0310fad80b8006f69491576b" translate="yes" xml:space="preserve">
          <source>Implement it similar to the way you have it in your example. As for destruction, &quot;Singletons usually endure for the length of the program run; most OSs will recover memory and most other resources when a program terminates, so there is an argument for not worrying about this.&quot;</source>
          <target state="translated">Implementarlo de manera similar a como lo tiene en su ejemplo.En cuanto a la destrucción,&quot;Los singletons suelen durar todo el tiempo que se ejecuta el programa;la mayoría de los sistemas operativos recuperan la memoria y la mayoría de los demás recursos cuando un programa termina,así que hay un argumento para no preocuparse por esto&quot;.</target>
        </trans-unit>
        <trans-unit id="8ec513111a6255768ad759087587f71a305fd98c" translate="yes" xml:space="preserve">
          <source>In 2008 I provided a C++98 implementation of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction, not-technically-thread-safe:</source>
          <target state="translated">En 2008 proporcioné una implementación C++98 del patrón de diseño Singleton que es perezoso,de destrucción garantizada,no seguro desde el punto de vista técnico:</target>
        </trans-unit>
        <trans-unit id="6ad103f816f6531a30eb7e68d5a16576c0db7171" translate="yes" xml:space="preserve">
          <source>In addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something...</source>
          <target state="translated">Además de la otra discusión aquí,puede valer la pena señalar que se puede tener un carácter global,sin limitar el uso a un solo caso.Por ejemplo,consideremos el caso de referencia contando algo...</target>
        </trans-unit>
        <trans-unit id="0a8cc7fb43e3e00c5689247fd36b5590d04d43fe" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;std::shared_ptr&lt;/code&gt; can be used to keep the &lt;em&gt;singleton&lt;/em&gt; alive for all users even when the static destructors are being called at the end of the program:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En este caso, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se puede usar para mantener &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;vivo &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;singleton&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para todos los usuarios, incluso cuando se llama a los destructores est&amp;aacute;ticos al final del programa:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0297137859db5072b87d3de3253a183fe8d2a132" translate="yes" xml:space="preserve">
          <source>It has no dynamic memory allocation.</source>
          <target state="translated">No tiene una asignación de memoria dinámica.</target>
        </trans-unit>
        <trans-unit id="4161b1ad79a47a16c61ad1aba0f2011aa4fd5ab4" translate="yes" xml:space="preserve">
          <source>It is indeed probably allocated from the heap, but without the sources there is no way of knowing.</source>
          <target state="translated">De hecho,es probable que se asigne desde el montón,pero sin las fuentes no hay forma de saberlo.</target>
        </trans-unit>
        <trans-unit id="c30ebb06c17cf8f53d6d497493adf232a4a32fee" translate="yes" xml:space="preserve">
          <source>It will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton.  If you want to be able to explicitly clean it, it's fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it's used, but that's outside of the scope of a &quot;classic&quot; singleton.</source>
          <target state="translated">Será derribado y reparado cuando el programa termine,que es el comportamiento normal y deseado para un solo tonelada.Si quieres ser capaz de limpiarlo explícitamente,es bastante fácil añadir un método estático a la clase que te permita restaurarlo a un estado de limpieza,y hacer que se reasigne la próxima vez que se use,pero eso está fuera del alcance de un singleton &quot;clásico&quot;.</target>
        </trans-unit>
        <trans-unit id="c64e5602a9af0c16dc3d83cb29fc0a0fb06998c8" translate="yes" xml:space="preserve">
          <source>My implementation is similar to Galik's. The difference is my implementation allows the shared pointers to clean up allocated memory, as opposed to holding onto the memory until the application is exited and the static pointers are cleaned up.</source>
          <target state="translated">Mi implementación es similar a la de Galik.La diferencia es que mi implementación permite que los punteros compartidos limpien la memoria asignada,en lugar de mantener la memoria hasta que se salga de la aplicación y se limpien los punteros estáticos.</target>
        </trans-unit>
        <trans-unit id="d3cd3cde4aa0af185c90283942754979a78a9c2b" translate="yes" xml:space="preserve">
          <source>My main question is, how do I implement it in the right way?</source>
          <target state="translated">Mi principal pregunta es,¿cómo lo implemento de la manera correcta?</target>
        </trans-unit>
        <trans-unit id="697496554c522fb6e5431ed20fc49a5e7756de39" translate="yes" xml:space="preserve">
          <source>N.B. This is not a thread safe one.You have to ensure thread safety.</source>
          <target state="translated">N.B.Este no es un hilo seguro.Tienes que asegurar la seguridad del hilo.</target>
        </trans-unit>
        <trans-unit id="3ae7578b52cf3c8766544802ea79b9c71361d40f" translate="yes" xml:space="preserve">
          <source>Neither this nor Cătălin's answer is automatically thread-safe in current C++, but will be in C++0x.</source>
          <target state="translated">Ni esta ni la respuesta de Cătălin es automáticamente segura para los hilos en el C++actual,pero lo será en el C++0x.</target>
        </trans-unit>
        <trans-unit id="6c7a38653bee09a3cd6956dd4b338c749ce46dd8" translate="yes" xml:space="preserve">
          <source>Note also that with the Meyers Singleton you &quot;can get into very difficult situation if objects rely on each other at the time of
termination - when does the Singleton disappear relative to other objects? But for simple applications, this works fine.&quot;</source>
          <target state="translated">Tenga en cuenta también que con el Meyers Singleton &quot;puede ponerse en una situación muy difícil si los objetos dependen unos de otros en el momento de la terminación-¿cuándo desaparece el Singleton en relación con otros objetos? Pero para aplicaciones simples,esto funciona bien.&quot;</target>
        </trans-unit>
        <trans-unit id="afd9ddaa4d72c4a6baeb072dcccdd11cd7953239" translate="yes" xml:space="preserve">
          <source>Now somewhere inside a function (such as &lt;code&gt;main&lt;/code&gt;) you can do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora en alg&amp;uacute;n lugar dentro de una funci&amp;oacute;n (como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) puede hacer:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a78e09f10d27dc0831eef859b1c65cfa888d905a" translate="yes" xml:space="preserve">
          <source>One major problem in singleton pattern implementation is safe initialization. The only safe way is to guard the initialization sequence with synchronizing barriers. But those barriers themselves need to be safely initiated. &lt;code&gt;std::once_flag&lt;/code&gt; is the mechanism to get guaranteed safe initialization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un problema importante en la implementaci&amp;oacute;n del patr&amp;oacute;n singleton es la inicializaci&amp;oacute;n segura. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La &amp;uacute;nica forma segura es proteger la secuencia de inicializaci&amp;oacute;n con barreras de sincronizaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero esas barreras en s&amp;iacute; mismas deben iniciarse de manera segura. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::once_flag&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es el mecanismo para garantizar una inicializaci&amp;oacute;n segura garantizada.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fbe47028e7d8120fc3d32b4563c89e0009142d4f" translate="yes" xml:space="preserve">
          <source>Only one object created and this object reference is returned each and every time afterwords.</source>
          <target state="translated">Sólo se crea un objeto y esta referencia de objeto se devuelve cada vez después.</target>
        </trans-unit>
        <trans-unit id="41fc1d2c4e5b1f7226fe4db3fa895813c007fb9a" translate="yes" xml:space="preserve">
          <source>Recently I've bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real life example):</source>
          <target state="translated">Recientemente me he topado con una realización-implementación del patrón de diseño Singleton para C++.Se ha visto así (lo he adoptado del ejemplo de la vida real):</target>
        </trans-unit>
        <trans-unit id="276b20dd2003e2c8b8147112735ed61b5985f32f" translate="yes" xml:space="preserve">
          <source>See this article about when to use a singleton: (not often)</source>
          <target state="translated">Vea este artículo sobre cuándo usar un Singleton:(no muy a menudo)</target>
        </trans-unit>
        <trans-unit id="dc48ffee79c43defeacd652988f6d13d63671cd8" translate="yes" xml:space="preserve">
          <source>See this article describing lifetimes:</source>
          <target state="translated">Vea este artículo que describe las vidas:</target>
        </trans-unit>
        <trans-unit id="6929b1498a833a4dd1c77bb041d752cda196cffc" translate="yes" xml:space="preserve">
          <source>See this article that discusses some threading implications to singletons:</source>
          <target state="translated">Vea este artículo que discute algunas implicaciones de los hilos para los solteros:</target>
        </trans-unit>
        <trans-unit id="c1297f70db8f6ff1cb7f6cadad4fd0176e9ad52a" translate="yes" xml:space="preserve">
          <source>See this article that explains why double checked locking will not work on C++:</source>
          <target state="translated">Vea este artículo que explica por qué el bloqueo doblemente comprobado no funcionará en C++:</target>
        </trans-unit>
        <trans-unit id="d8a3f5854c04a6c2fd9c6b0eed898518205b893b" translate="yes" xml:space="preserve">
          <source>See this two article about initialization order and how to cope:</source>
          <target state="translated">Véase este dos artículo sobre el orden de inicialización y cómo afrontarlo:</target>
        </trans-unit>
        <trans-unit id="e229eb46fdb8abc36ed541fd75a96ad01079842c" translate="yes" xml:space="preserve">
          <source>Simple singleton class, This must be your header class file</source>
          <target state="translated">Una clase simple de un solo botón,este debe ser su archivo de clase de cabecera.</target>
        </trans-unit>
        <trans-unit id="0f5183f104a6ee7a2ee3c3f8a78ffcad0dd7ada1" translate="yes" xml:space="preserve">
          <source>Singleton instance declared as static variable of GetInstance method, is it thread-safe?</source>
          <target state="translated">La instancia Singleton declarada como variable estática del método GetInstance,¿es segura para el hilo?</target>
        </trans-unit>
        <trans-unit id="616cb2246d061aa00ec22ca9c85c492806ae00f9" translate="yes" xml:space="preserve">
          <source>Singleton: How should it be used</source>
          <target state="translated">Singleton:¿Cómo debe usarse?</target>
        </trans-unit>
        <trans-unit id="1ddbfa6229ac4bbfeea0426af8472583accde3ea" translate="yes" xml:space="preserve">
          <source>Static variables initialisation order</source>
          <target state="translated">Orden de inicialización de las variables estáticas</target>
        </trans-unit>
        <trans-unit id="3606cc4233d18abdcf887e06f1cde5c7e5230832" translate="yes" xml:space="preserve">
          <source>That is why I prefer heap-allocated singletons. I provide an explicit &lt;code&gt;init()&lt;/code&gt; and &lt;code&gt;term()&lt;/code&gt; methods for all the singletons and call them inside &lt;code&gt;main&lt;/code&gt;. Thus I have a full control over the order of singletons creation/destruction, and also I guarantee that singletons will be created, no matter whether someone called &lt;code&gt;getInstance()&lt;/code&gt; or not.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es por eso que prefiero los singletons asignados al mont&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Proporciono un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;init()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;term()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; expl&amp;iacute;cito &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;para todos los singletons y los llamo dentro de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, tengo un control total sobre el orden de creaci&amp;oacute;n / destrucci&amp;oacute;n de singletons, y tambi&amp;eacute;n garantizo que se crear&amp;aacute;n singletons, sin importar si alguien llam&amp;oacute; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;getInstance()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o no.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="024eab215b08bb3333ee58e19b30d9d60b0c180e" translate="yes" xml:space="preserve">
          <source>The Singleton_destroyer will be created on program startup, and &quot;when program terminates, all global/static objects are destroyed by the runtime library shutdown code (inserted by the linker), so the_destroyer will be destroyed; its destructor will delete the Singleton, running its destructor.&quot;</source>
          <target state="translated">El Singleton_destroyer se creará al inicio del programa,y &quot;cuando el programa termine,todos los objetos globalstáticos serán destruidos por el código de cierre de la librería en tiempo de ejecución (insertado por el enlazador),por lo que el_destroyer será destruido;su destructor borrará el Singleton,ejecutando su destructor&quot;.</target>
        </trans-unit>
        <trans-unit id="5008e6ca7deb401eab76f0a1b7199dbd571aeac8" translate="yes" xml:space="preserve">
          <source>The paper that was linked to above describes the shortcoming of double checked locking is that the compiler may allocate the memory for the object and set a pointer to the address of the allocated memory, before the object's constructor has been called. It is quite easy in c++ however to use allocaters to allocate the memory manually, and then use a construct call to initialize the memory. Using this appraoch, the double-checked locking works just fine.</source>
          <target state="translated">El documento al que se ha hecho referencia anteriormente describe la deficiencia del bloqueo doblemente comprobado es que el compilador puede asignar la memoria para el objeto y establecer un puntero a la dirección de la memoria asignada,antes de que se haya llamado al constructor del objeto.Sin embargo,en c++es bastante fácil utilizar asignadores para asignar la memoria manualmente,y luego utilizar una llamada al constructor para inicializar la memoria.Usando esta valoración,el bloqueo doblemente comprobado funciona muy bien.</target>
        </trans-unit>
        <trans-unit id="b6f3f591e89067a6d11cf1b1060464622dca5fbe" translate="yes" xml:space="preserve">
          <source>The refs don't need to store a pointer back to their respective &lt;code&gt;Store&lt;/code&gt; because that information is supplied at compile-time. You also don't have to worry about the &lt;code&gt;Store&lt;/code&gt;'s lifetime because the compiler requires that it is global.  If there is indeed only one instance of &lt;code&gt;Store&lt;/code&gt; then there's no overhead in this approach; with more than one instance it's up to the compiler to be clever about code generation. If necessary, the &lt;code&gt;ItemRef&lt;/code&gt; class can even be made a &lt;code&gt;friend&lt;/code&gt; of &lt;code&gt;Store&lt;/code&gt; (you can have templated friends!).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las referencias no necesitan almacenar un puntero en su respectiva &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; porque esa informaci&amp;oacute;n se proporciona en tiempo de compilaci&amp;oacute;n. Tampoco tiene que preocuparse por la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;vida &amp;uacute;til de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; porque el compilador requiere que sea global. Si de hecho solo hay una instancia de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; entonces no hay sobrecarga en este enfoque; con m&amp;aacute;s de una instancia, depende del compilador ser inteligente sobre la generaci&amp;oacute;n de c&amp;oacute;digo. Si es necesario, la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;clase &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ItemRef&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; puede incluso hacerse &lt;/font&gt;&lt;/font&gt; &lt;code&gt;friend&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (&amp;iexcl;puedes tener amigos con plantilla!).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0786d361e2bcc95d4119e640b7e9a62ee7f81d86" translate="yes" xml:space="preserve">
          <source>The solution in the accepted answer has a significant drawback - the destructor for the singleton is called after the control leaves the &lt;code&gt;main()&lt;/code&gt; function. There may be problems really, when some dependent objects are allocated inside &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La soluci&amp;oacute;n en la respuesta aceptada tiene un inconveniente significativo: se llama al destructor para el singleton despu&amp;eacute;s de que el control abandona la funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede haber problemas realmente, cuando algunos objetos dependientes se asignan dentro de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f40212b178fce257aced5352c8a45824c8a75d7d" translate="yes" xml:space="preserve">
          <source>The typical implementation (taken from some code I have in emacs already) would be:</source>
          <target state="translated">La implementación típica (tomada de algún código que ya tengo en el emacs)sería:</target>
        </trans-unit>
        <trans-unit id="56278e8448390147f165b72dfac3329a1d70ac20" translate="yes" xml:space="preserve">
          <source>The user can now create a &lt;code&gt;StoreWrapper&lt;/code&gt; type (and global instance) for each global &lt;code&gt;Store&lt;/code&gt; instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using &lt;code&gt;Store&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El usuario ahora puede crear un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tipo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;StoreWrapper&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (e instancia global) para cada &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;instancia de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; global &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, y siempre acceder a las tiendas a trav&amp;eacute;s de su instancia de wrapper (olvidando as&amp;iacute; los detalles sangrientos de los par&amp;aacute;metros de plantilla necesarios para usar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e31dbd568adbc6521089b6d09e212fdb118726cc" translate="yes" xml:space="preserve">
          <source>There are two ways that I know to create a Singleton class correctly.</source>
          <target state="translated">Hay dos formas que conozco para crear una clase de Singleton correctamente.</target>
        </trans-unit>
        <trans-unit id="28521cdf5fefb8ca060ab5a22e6ddfb09cef7d8c" translate="yes" xml:space="preserve">
          <source>This is about object life-time management. Suppose you have more than singletons in your software. And they depend on Logger singleton. During application destruction, suppose another singleton object uses Logger to log its destruction steps. You have to guarantee that Logger should be cleaned up last. Therefore, please also check out this paper:
&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot;&gt;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se trata de la gesti&amp;oacute;n del tiempo de vida del objeto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Supongamos que tiene m&amp;aacute;s de singletons en su software. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y dependen de Logger Singleton. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Durante la destrucci&amp;oacute;n de la aplicaci&amp;oacute;n, supongamos que otro objeto singleton usa Logger para registrar sus pasos de destrucci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Debe garantizar que Logger se debe limpiar en &amp;uacute;ltimo lugar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, consulte tambi&amp;eacute;n este documento: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d20124031b945444d0c1fd440a24d36bac0ab7f" translate="yes" xml:space="preserve">
          <source>This is called the Meyers Singleton, created by C++ wizard Scott Meyers. Simply define get_instance() differently. Now you can also get rid of the pointer member variable.</source>
          <target state="translated">Esto se llama el Meyers Singleton,creado por el mago de C++Scott Meyers.Simplemente define get_instance()de manera diferente.Ahora también puedes deshacerte de la variable miembro del puntero.</target>
        </trans-unit>
        <trans-unit id="4c22b28b3d41d395f49ea96f9637893cadacf026" translate="yes" xml:space="preserve">
          <source>This is neat because the value returned is by reference and you can use &lt;code&gt;.&lt;/code&gt; syntax instead of &lt;code&gt;-&amp;gt;&lt;/code&gt; to access member variables.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto es ordenado porque el valor devuelto es por referencia y puede usar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sintaxis en lugar de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para acceder a las variables miembro.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3abd989834b48d9e30b53bbf5b75ed134706ae78" translate="yes" xml:space="preserve">
          <source>To use just inherit your class from this, like: &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para usar solo herede su clase de esto, como: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abfe440688144dc3488f94a3bcdd9a80d1b0b46" translate="yes" xml:space="preserve">
          <source>We went over this topic recently in my EECS class. If you want to look at the lecture notes in detail, visit &lt;a href=&quot;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&quot;&gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Repasamos este tema recientemente en mi clase de EECS. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si desea ver las notas de la conferencia en detalle, visite &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef46b5cc56312a21edb0f46af654cc29a8de451c" translate="yes" xml:space="preserve">
          <source>What are all the common undefined behaviours that a C++ programmer should know about?</source>
          <target state="translated">¿Cuáles son todos los comportamientos comunes no definidos que un programador de C++debería conocer?</target>
        </trans-unit>
        <trans-unit id="f9481ffc9d80995ea84a632ec6be1da7a9d03648" translate="yes" xml:space="preserve">
          <source>What is the lifetime of a static variable in a C++ function?</source>
          <target state="translated">¿Cuál es la vida útil de una variable estática en una función de C++?</target>
        </trans-unit>
        <trans-unit id="cfbba3022f0da956a8ae5155afd7fd1da6d095b2" translate="yes" xml:space="preserve">
          <source>You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.</source>
          <target state="translated">Podrías evitar la asignación de memoria.Hay muchas variantes,todas tienen problemas en caso de un entorno multihilo.</target>
        </trans-unit>
        <trans-unit id="109c3cc202bf5d2be202483e322663f064482610" translate="yes" xml:space="preserve">
          <source>You must know that Singleton instance &lt;em&gt;doesn't need to be manually deleted by us&lt;/em&gt;. We need a single object of it throughout the whole program, so &lt;em&gt;at the end of program execution, it will be automatically deallocated.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Debe saber que la instancia de Singleton &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no necesita ser eliminada manualmente por nosotros&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Necesitamos un solo objeto en todo el programa, por lo que &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;al final de la ejecuci&amp;oacute;n del programa, se desasignar&amp;aacute; autom&amp;aacute;ticamente.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c860d67c8e3dbf690743f011c26ee8f12ab81ca" translate="yes" xml:space="preserve">
          <source>Your code is correct, except that &lt;em&gt;you didn't declare the instance pointer outside the class&lt;/em&gt;. The inside class declarations of static variables are not considered declarations in C++, however this is allowed in other languages like &lt;strong&gt;C#&lt;/strong&gt; or &lt;strong&gt;Java&lt;/strong&gt; etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Su c&amp;oacute;digo es correcto, excepto que &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no declar&amp;oacute; el puntero de instancia fuera de la clase&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las declaraciones internas de clase de variables est&amp;aacute;ticas no se consideran declaraciones en C ++, sin embargo, esto est&amp;aacute; permitido en otros lenguajes como &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C #&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; etc.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92bd75ebd8fd2b0179172217b15350cc6d4002f0" translate="yes" xml:space="preserve">
          <source>using</source>
          <target state="translated">using</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
