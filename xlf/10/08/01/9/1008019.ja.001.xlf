<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1008019">
    <body>
      <group id="1008019">
        <trans-unit id="36c9232103517e64f0d6682eef65f9fd0ad31cd8" translate="yes" xml:space="preserve">
          <source>&quot;Compiler automatically builds code that creates 's' first time through the
declaration, not thereafter, and then deletes the static object at program
termination.&quot;</source>
          <target state="translated">&quot;コンパイラが自動的にビルドするコードは、宣言によって最初に's'を作成し、その後ではなく、プログラムの終了時にスタティックオブジェクトを削除します。&quot;</target>
        </trans-unit>
        <trans-unit id="d2883dd9a74d31ba7a51055b6db8d87e7a0f4434" translate="yes" xml:space="preserve">
          <source>...and rely on the program going out of scope to clean up afterwards.</source>
          <target state="translated">...そして、後始末のためにプログラムが範囲外になることに頼っています。</target>
        </trans-unit>
        <trans-unit id="9ec67d195d87a2b6d8be97175d5c6042febf0567" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;@Loki Astari's answer&lt;/a&gt; is excellent.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@Loki Astariの答え&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はすばらしい。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07ef837398f606106ec996846c93366067556b6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First Way:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最初の方法：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7edf76288aa87f9cb7eedb19f44e96cd79d975b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second Way&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;二番目の方法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5e615b218d4601acd5025fd68241094524be9d5" translate="yes" xml:space="preserve">
          <source>Access your singleton like this:</source>
          <target state="translated">このようにシングルトンにアクセスします。</target>
        </trans-unit>
        <trans-unit id="e8bc9322ae6e0805dbbf23f31f8b5391ac03a45d" translate="yes" xml:space="preserve">
          <source>Another issue with doing it this way is that it isn't thread-safe. In a multithreaded environment, two threads could get through the &quot;if&quot; before either has a chance to allocate the new instance (so both would). This still isn't too big of a deal if you are relying on program termination to clean up anyway.</source>
          <target state="translated">この方法のもう一つの問題点は、スレッドセーフではないということです。マルチスレッド環境では、2 つのスレッドがどちらかが新しいインスタンスを割り当てる機会を得る前に &quot;if&quot; を通過してしまう可能性があります (つまり、両方ともそうなります)。プログラムの終了をクリーンアップのために利用しているのであれば、これはまだそれほど大きな問題ではありません。</target>
        </trans-unit>
        <trans-unit id="2268cee1e2231822454db604a4a9d2507f7be692" translate="yes" xml:space="preserve">
          <source>Another non-allocating alternative: create a singleton, say of class &lt;code&gt;C&lt;/code&gt;, as you need it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;別の非割り当ての代替手段：&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要に応じて、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラス&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シングルトンを作成&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="011e2628ae6347f5e9d083f901ce7ec4d7f2f95a" translate="yes" xml:space="preserve">
          <source>Being a Singleton, you usually do not want it to be destructed.</source>
          <target state="translated">シングルトンである以上、通常は破壊されることを望まない。</target>
        </trans-unit>
        <trans-unit id="1a64604c83d016260a4733124a887b95b873e63c" translate="yes" xml:space="preserve">
          <source>C++ Singleton design pattern</source>
          <target state="translated">C++シングルトンデザインパターン</target>
        </trans-unit>
        <trans-unit id="b4ac098631e8cd642bf5398d974d442fffbb33de" translate="yes" xml:space="preserve">
          <source>Can any one provide me a sample of Singleton in c++?</source>
          <target state="translated">誰かc++でシングルトンのサンプルを提供してくれませんか?</target>
        </trans-unit>
        <trans-unit id="36434822ee78833774234098604d3ea82e322d9c" translate="yes" xml:space="preserve">
          <source>Dr Dobbs: C++ and The Perils of Double-Checked Locking: Part I</source>
          <target state="translated">ドブス博士 C++とダブルチェックロックの危険性。第一部</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="d17857ecfe425c540113b2fd20e8ccff69da0f24" translate="yes" xml:space="preserve">
          <source>Finding C++ static initialization order problems</source>
          <target state="translated">C++の静的な初期化順序の問題を見つける</target>
        </trans-unit>
        <trans-unit id="efb7ceb0ff0a01cffe2bed6ecc78a9b33e6bac7e" translate="yes" xml:space="preserve">
          <source>From this declaration I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem in the implementation.</source>
          <target state="translated">この宣言から、インスタンスフィールドがヒープ上で開始されていることが推測できます。これはメモリの割り当てがあることを意味します。私にとって完全に不明なのは、正確にいつメモリが解放されるのかということです。それともバグやメモリリークがあるのでしょうか?実装に問題があるようです。</target>
        </trans-unit>
        <trans-unit id="2e8c991a85485d2e54dacdbf83944ac53596b1f6" translate="yes" xml:space="preserve">
          <source>Has anyone mentioned &lt;code&gt;std::call_once&lt;/code&gt; and &lt;code&gt;std::once_flag&lt;/code&gt;?
Most other approaches - including double checked locking - are broken.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;誰かが&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::call_once&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::once_flag&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;について言及し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;か？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他のほとんどのアプローチ（ダブルチェックロックを含む）は壊れています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e22081f06dbc88faa869c500655545f8b3b49e97" translate="yes" xml:space="preserve">
          <source>Here 00915CB8 is the memory location of singleton Object, same for the duration of the program but (normally!) different each time the program is run.</source>
          <target state="translated">ここで 00915CB8 はシングルトンオブジェクトのメモリ位置であり、プログラムが実行されている間は同じですが、(通常は!)プログラムが実行されるたびに異なります。</target>
        </trans-unit>
        <trans-unit id="d93f58ba958d8ddddf1f1a269f714ce7fae89839" translate="yes" xml:space="preserve">
          <source>Here is an easy implementation.</source>
          <target state="translated">ここでは簡単な実装をご紹介します。</target>
        </trans-unit>
        <trans-unit id="83f14721c00dbed7f33a39fff1861abde1780df6" translate="yes" xml:space="preserve">
          <source>Here is an updated C++11 implementation of the Singleton design pattern that is lazy-evaluated, correctly-destroyed, and &lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;thread-safe&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下は、遅延評価され、正しく破棄され、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スレッドセーフ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;であるシングルトン設計パターンの更新されたC ++ 11実装です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b06e170e85f393d0825ee9533ff40bb6760c88f" translate="yes" xml:space="preserve">
          <source>However there are times with multiple static objects where you need to be able to guarantee that the &lt;em&gt;singleton&lt;/em&gt; will not be destroyed until all your static objects that use the &lt;em&gt;singleton&lt;/em&gt; no longer need it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、複数のスタティックで回があり、あなたがいることを保証することができるようにする必要がある場所オブジェクトである&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シングルトンを&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用するすべての静的オブジェクトまで破壊されることはありません&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シングルトンを&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もはやそれを必要とします。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="448691124971d770be6bd3cf7a1db111c706cea4" translate="yes" xml:space="preserve">
          <source>However, it is good practice to clean up at program termination. Therefore, you can do this with an auxiliary static SingletonDestructor class and declare that as a friend in your Singleton.</source>
          <target state="translated">しかし、プログラムの終了時にクリーンアップするのは良い習慣です。そこで、補助的な静的SingletonDestructorクラスを使って、それをSingletonのフレンドとして宣言します。</target>
        </trans-unit>
        <trans-unit id="a961b506da874e67a11c5fad251a627e2bb6cb12" translate="yes" xml:space="preserve">
          <source>I did not find a CRTP implementation among the answers, so here it is:</source>
          <target state="translated">回答の中にCRTPの実装が見当たらなかったので、ここで紹介します。</target>
        </trans-unit>
        <trans-unit id="a02edb8cd40a9fa55f78844c4bb1fde3d56d28a8" translate="yes" xml:space="preserve">
          <source>I met this problem, when trying to introduce a Singleton in the Qt application. I decided, that all my setup dialogs must be Singletons, and adopted the pattern above. Unfortunately, Qt's main class &lt;code&gt;QApplication&lt;/code&gt; was allocated on stack in the &lt;code&gt;main&lt;/code&gt; function, and Qt forbids creating/destroying dialogs when no application object is available.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Qtアプリケーションにシングルトンを導入しようとしたときに、この問題に遭遇しました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私は、すべてのセットアップダイアログをシングルトンにする必要があると判断し、上記のパターンを採用しました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;残念ながら、Qtのメインクラス&lt;/font&gt;&lt;/font&gt; &lt;code&gt;QApplication&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スタックに割り当てられており、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アプリケーションオブジェクトが使用できない場合、Qtはダイアログの作成/破棄を禁止します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bfa20c1c1aff78139863f88ace5d0a2adc9a6311" translate="yes" xml:space="preserve">
          <source>I prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):</source>
          <target state="translated">私はこのような実装を好む(実際には、私はできるだけシングルトンを避けているので、私が好むとは正しくは言われていません)。</target>
        </trans-unit>
        <trans-unit id="ee2aed6c9894fa2b3220ca1cf8279311dd18c188" translate="yes" xml:space="preserve">
          <source>I think You should write a static function wherein your static object is deleted.
You should call this function when you are about to close your application.
This will ensure you dont have memory leakage.</source>
          <target state="translated">静的オブジェクトを削除する静的関数を書くべきだと思います。アプリケーションを閉じようとしたときにこの関数を呼び出すべきです。これでメモリリークを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="4f1aa530a0739a8ab5932864cc56e6ecc2819aa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自体はテンプレートクラスであり、その後、物事はメシエ得るが、おそらく、次のシグネチャを持つヘルパークラスを実装することにより、この方法を使用することも可能です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50f3ffb9b1ad143b57ce983140aed72bd955b546" translate="yes" xml:space="preserve">
          <source>If you want to allocate the object in heap, why don't use a unique pointer. Memory will also be deallocated since we are using a unique pointer.</source>
          <target state="translated">ヒープでオブジェクトを確保したいのであれば、なぜユニークポインタを使わないのか。一意なポインタを使っているので、メモリもデアロケートされます。</target>
        </trans-unit>
        <trans-unit id="8ad91f497862ef558e636b6c57c8848e082bec9f" translate="yes" xml:space="preserve">
          <source>If you work on a platform where cleanup must be done manually, I'd probably add a manual cleanup routine.</source>
          <target state="translated">クリーンアップを手動で行わなければならないプラットフォームで作業する場合は、おそらく手動のクリーンアップルーチンを追加すると思います。</target>
        </trans-unit>
        <trans-unit id="58153ad0f2a351dc0310fad80b8006f69491576b" translate="yes" xml:space="preserve">
          <source>Implement it similar to the way you have it in your example. As for destruction, &quot;Singletons usually endure for the length of the program run; most OSs will recover memory and most other resources when a program terminates, so there is an argument for not worrying about this.&quot;</source>
          <target state="translated">あなたの例のように実装してください。破壊については、&quot;シングルトンは通常、プログラムの実行中の長さに耐えます。ほとんどのOSはプログラムの終了時にメモリと他のほとんどのリソースを回復します。</target>
        </trans-unit>
        <trans-unit id="8ec513111a6255768ad759087587f71a305fd98c" translate="yes" xml:space="preserve">
          <source>In 2008 I provided a C++98 implementation of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction, not-technically-thread-safe:</source>
          <target state="translated">2008年には、遅延評価され、破壊が保証され、技術的にスレッドセーフではないシングルトン設計パターンのC++98実装を提供しました。</target>
        </trans-unit>
        <trans-unit id="6ad103f816f6531a30eb7e68d5a16576c0db7171" translate="yes" xml:space="preserve">
          <source>In addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something...</source>
          <target state="translated">ここでの他の議論に加えて、使用法を一つのインスタンスに限定することなく、グローバル性を持つことができることにも注目する価値があるかもしれません。例えば、参照が何かをカウントしている場合を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="0a8cc7fb43e3e00c5689247fd36b5590d04d43fe" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;std::shared_ptr&lt;/code&gt; can be used to keep the &lt;em&gt;singleton&lt;/em&gt; alive for all users even when the static destructors are being called at the end of the program:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この場合、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用して&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、プログラムの最後に静的デストラクタが呼び出されている場合でも、すべてのユーザーの&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シングルトン&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を維持できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0297137859db5072b87d3de3253a183fe8d2a132" translate="yes" xml:space="preserve">
          <source>It has no dynamic memory allocation.</source>
          <target state="translated">動的なメモリ割り当てはありません。</target>
        </trans-unit>
        <trans-unit id="4161b1ad79a47a16c61ad1aba0f2011aa4fd5ab4" translate="yes" xml:space="preserve">
          <source>It is indeed probably allocated from the heap, but without the sources there is no way of knowing.</source>
          <target state="translated">確かにヒープから割り当てられていると思われますが、ソースがなければ知る術がありません。</target>
        </trans-unit>
        <trans-unit id="c30ebb06c17cf8f53d6d497493adf232a4a32fee" translate="yes" xml:space="preserve">
          <source>It will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton.  If you want to be able to explicitly clean it, it's fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it's used, but that's outside of the scope of a &quot;classic&quot; singleton.</source>
          <target state="translated">プログラムの終了時には破棄されて解放されますが、これはシングルトンの通常の望ましい動作です。これを明示的にクリーンにしたい場合は、クラスに静的メソッドを追加してクリーンな状態に戻し、次回の使用時に再割り当てを行うことができますが、これは「古典的な」シングルトンの範囲外です。</target>
        </trans-unit>
        <trans-unit id="c64e5602a9af0c16dc3d83cb29fc0a0fb06998c8" translate="yes" xml:space="preserve">
          <source>My implementation is similar to Galik's. The difference is my implementation allows the shared pointers to clean up allocated memory, as opposed to holding onto the memory until the application is exited and the static pointers are cleaned up.</source>
          <target state="translated">私の実装は Galik の実装に似ています。違いは、アプリケーションが終了して静的ポインタがクリーンアップされるまでメモリを保持するのとは対照的に、私の実装では共有ポインタが割り当てられたメモリをクリーンアップすることができます。</target>
        </trans-unit>
        <trans-unit id="d3cd3cde4aa0af185c90283942754979a78a9c2b" translate="yes" xml:space="preserve">
          <source>My main question is, how do I implement it in the right way?</source>
          <target state="translated">私の一番の疑問は、どうやって正しい方法で実装すればいいのかということです。</target>
        </trans-unit>
        <trans-unit id="697496554c522fb6e5431ed20fc49a5e7756de39" translate="yes" xml:space="preserve">
          <source>N.B. This is not a thread safe one.You have to ensure thread safety.</source>
          <target state="translated">注意:これはスレッドセーフではないので、スレッドセーフを確保する必要があります。</target>
        </trans-unit>
        <trans-unit id="3ae7578b52cf3c8766544802ea79b9c71361d40f" translate="yes" xml:space="preserve">
          <source>Neither this nor Cătălin's answer is automatically thread-safe in current C++, but will be in C++0x.</source>
          <target state="translated">これも Cătălin の答えも、現在の C++では自動的にスレッドセーフではありませんが、C++0x ではスレッドセーフになります。</target>
        </trans-unit>
        <trans-unit id="6c7a38653bee09a3cd6956dd4b338c749ce46dd8" translate="yes" xml:space="preserve">
          <source>Note also that with the Meyers Singleton you &quot;can get into very difficult situation if objects rely on each other at the time of
termination - when does the Singleton disappear relative to other objects? But for simple applications, this works fine.&quot;</source>
          <target state="translated">また、マイヤーズシングルトンでは「終了時にオブジェクトが互いに依存している場合、非常に困難な状況に陥る可能性があることにも注意してください。しかし、シンプルなアプリケーションでは、これは問題なく動作します。</target>
        </trans-unit>
        <trans-unit id="afd9ddaa4d72c4a6baeb072dcccdd11cd7953239" translate="yes" xml:space="preserve">
          <source>Now somewhere inside a function (such as &lt;code&gt;main&lt;/code&gt;) you can do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これで、関数（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;など&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どこかで&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次のことができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a78e09f10d27dc0831eef859b1c65cfa888d905a" translate="yes" xml:space="preserve">
          <source>One major problem in singleton pattern implementation is safe initialization. The only safe way is to guard the initialization sequence with synchronizing barriers. But those barriers themselves need to be safely initiated. &lt;code&gt;std::once_flag&lt;/code&gt; is the mechanism to get guaranteed safe initialization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シングルトンパターンの実装における1つの主要な問題は、安全な初期化です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;安全な唯一の方法は、同期バリアを使用して初期化シーケンスを保護することです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、それらの障壁自体を安全に開始する必要があります。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::once_flag&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、安全な初期化が保証されるメカニズムです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fbe47028e7d8120fc3d32b4563c89e0009142d4f" translate="yes" xml:space="preserve">
          <source>Only one object created and this object reference is returned each and every time afterwords.</source>
          <target state="translated">作成されたオブジェクトは1つだけで、このオブジェクト参照はその後も毎回返されます。</target>
        </trans-unit>
        <trans-unit id="41fc1d2c4e5b1f7226fe4db3fa895813c007fb9a" translate="yes" xml:space="preserve">
          <source>Recently I've bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real life example):</source>
          <target state="translated">最近、C++のSingletonデザインパターンの実現実装にぶつかった。それは次のようなものです(実例から採用しています)。</target>
        </trans-unit>
        <trans-unit id="276b20dd2003e2c8b8147112735ed61b5985f32f" translate="yes" xml:space="preserve">
          <source>See this article about when to use a singleton: (not often)</source>
          <target state="translated">シングルトンを使うタイミングについてはこちらの記事をご覧ください。(あまりない)</target>
        </trans-unit>
        <trans-unit id="dc48ffee79c43defeacd652988f6d13d63671cd8" translate="yes" xml:space="preserve">
          <source>See this article describing lifetimes:</source>
          <target state="translated">ライフタイムについてはこちらの記事をご覧ください。</target>
        </trans-unit>
        <trans-unit id="6929b1498a833a4dd1c77bb041d752cda196cffc" translate="yes" xml:space="preserve">
          <source>See this article that discusses some threading implications to singletons:</source>
          <target state="translated">シングルトンに対するいくつかのスレッドの意味合いを議論しているこの記事を参照してください。</target>
        </trans-unit>
        <trans-unit id="c1297f70db8f6ff1cb7f6cadad4fd0176e9ad52a" translate="yes" xml:space="preserve">
          <source>See this article that explains why double checked locking will not work on C++:</source>
          <target state="translated">C++でダブルチェックのロックが効かない理由についてはこちらの記事をご覧ください。</target>
        </trans-unit>
        <trans-unit id="d8a3f5854c04a6c2fd9c6b0eed898518205b893b" translate="yes" xml:space="preserve">
          <source>See this two article about initialization order and how to cope:</source>
          <target state="translated">初期化の順番と対処法については、この2つの記事をご覧ください。</target>
        </trans-unit>
        <trans-unit id="e229eb46fdb8abc36ed541fd75a96ad01079842c" translate="yes" xml:space="preserve">
          <source>Simple singleton class, This must be your header class file</source>
          <target state="translated">シンプルなシングルトンクラス、これはあなたのヘッダクラスファイルでなければなりません。</target>
        </trans-unit>
        <trans-unit id="0f5183f104a6ee7a2ee3c3f8a78ffcad0dd7ada1" translate="yes" xml:space="preserve">
          <source>Singleton instance declared as static variable of GetInstance method, is it thread-safe?</source>
          <target state="translated">GetInstanceメソッドの静的変数として宣言されたシングルトンインスタンスはスレッドセーフですか?</target>
        </trans-unit>
        <trans-unit id="616cb2246d061aa00ec22ca9c85c492806ae00f9" translate="yes" xml:space="preserve">
          <source>Singleton: How should it be used</source>
          <target state="translated">シングルトン。どのように使用するべきか</target>
        </trans-unit>
        <trans-unit id="1ddbfa6229ac4bbfeea0426af8472583accde3ea" translate="yes" xml:space="preserve">
          <source>Static variables initialisation order</source>
          <target state="translated">静的変数の初期化順序</target>
        </trans-unit>
        <trans-unit id="3606cc4233d18abdcf887e06f1cde5c7e5230832" translate="yes" xml:space="preserve">
          <source>That is why I prefer heap-allocated singletons. I provide an explicit &lt;code&gt;init()&lt;/code&gt; and &lt;code&gt;term()&lt;/code&gt; methods for all the singletons and call them inside &lt;code&gt;main&lt;/code&gt;. Thus I have a full control over the order of singletons creation/destruction, and also I guarantee that singletons will be created, no matter whether someone called &lt;code&gt;getInstance()&lt;/code&gt; or not.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのため、ヒープに割り当てられたシングルトンを使用します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべてのシングルトンに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;明示的な&lt;/font&gt;&lt;/font&gt; &lt;code&gt;init()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;および&lt;/font&gt;&lt;/font&gt; &lt;code&gt;term()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッド&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を提供し、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それらを&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内で呼び出します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、シングルトンの作成/破棄の順序を完全に制御&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;できます。また、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;誰かが&lt;/font&gt;&lt;/font&gt; &lt;code&gt;getInstance()&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;呼び出したかどうかに関係なく、シングルトンが作成されることを保証し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="024eab215b08bb3333ee58e19b30d9d60b0c180e" translate="yes" xml:space="preserve">
          <source>The Singleton_destroyer will be created on program startup, and &quot;when program terminates, all global/static objects are destroyed by the runtime library shutdown code (inserted by the linker), so the_destroyer will be destroyed; its destructor will delete the Singleton, running its destructor.&quot;</source>
          <target state="translated">Singleton_destroyerはプログラムの起動時に作成され、&quot;プログラムが終了すると、すべてのglobalstaticオブジェクトはランタイムライブラリのシャットダウンコード(リンカーによって挿入された)によって破壊されるので、the_destroyerは破壊され、そのデストラクタはそのデストラクタを実行してSingletonを削除します。&quot;</target>
        </trans-unit>
        <trans-unit id="5008e6ca7deb401eab76f0a1b7199dbd571aeac8" translate="yes" xml:space="preserve">
          <source>The paper that was linked to above describes the shortcoming of double checked locking is that the compiler may allocate the memory for the object and set a pointer to the address of the allocated memory, before the object's constructor has been called. It is quite easy in c++ however to use allocaters to allocate the memory manually, and then use a construct call to initialize the memory. Using this appraoch, the double-checked locking works just fine.</source>
          <target state="translated">上のリンク先の論文では、ダブルチェックロックの欠点として、オブジェクトのコンストラクタが呼ばれる前に、コンパイラがオブジェクトのメモリを割り当てて、割り当てられたメモリのアドレスへのポインタを設定してしまうことがあると説明されています。しかし、c++ではアロケータを使って手動でメモリを確保し、コンストラクタを使ってメモリを初期化することは非常に簡単です。この方法を使えば、ダブルチェックロックは問題なく動作します。</target>
        </trans-unit>
        <trans-unit id="b6f3f591e89067a6d11cf1b1060464622dca5fbe" translate="yes" xml:space="preserve">
          <source>The refs don't need to store a pointer back to their respective &lt;code&gt;Store&lt;/code&gt; because that information is supplied at compile-time. You also don't have to worry about the &lt;code&gt;Store&lt;/code&gt;'s lifetime because the compiler requires that it is global.  If there is indeed only one instance of &lt;code&gt;Store&lt;/code&gt; then there's no overhead in this approach; with more than one instance it's up to the compiler to be clever about code generation. If necessary, the &lt;code&gt;ItemRef&lt;/code&gt; class can even be made a &lt;code&gt;friend&lt;/code&gt; of &lt;code&gt;Store&lt;/code&gt; (you can have templated friends!).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その情報はコンパイル時に提供されるので、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;refはそれぞれの&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;へのポインターを格納する必要はありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。また&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、コンパイラーはグローバルであることを要求するため、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の存続期間&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;について心配する必要はありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。実際に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インスタンスが1つしかない場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、このアプローチにはオーバーヘッドはありません。複数のインスタンスがある場合、コード生成について賢いのはコンパイラ次第です。必要に応じて、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ItemRef&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; の&lt;/font&gt; &lt;code&gt;friend&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;することもできます（テンプレートの友達を作ることができます！）。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0786d361e2bcc95d4119e640b7e9a62ee7f81d86" translate="yes" xml:space="preserve">
          <source>The solution in the accepted answer has a significant drawback - the destructor for the singleton is called after the control leaves the &lt;code&gt;main()&lt;/code&gt; function. There may be problems really, when some dependent objects are allocated inside &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;受け入れられた回答のソリューションには重大な欠点があります-シングルトンのデストラクタは、コントロールが&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;離れた後に呼び出され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内にいくつかの依存オブジェクトが割り当てられると、実際に問題が発生する可能性があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f40212b178fce257aced5352c8a45824c8a75d7d" translate="yes" xml:space="preserve">
          <source>The typical implementation (taken from some code I have in emacs already) would be:</source>
          <target state="translated">典型的な実装は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="56278e8448390147f165b72dfac3329a1d70ac20" translate="yes" xml:space="preserve">
          <source>The user can now create a &lt;code&gt;StoreWrapper&lt;/code&gt; type (and global instance) for each global &lt;code&gt;Store&lt;/code&gt; instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using &lt;code&gt;Store&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ユーザーは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、グローバルな&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;インスタンス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ごとに&lt;/font&gt;&lt;/font&gt; &lt;code&gt;StoreWrapper&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;タイプ（およびグローバルインスタンス）を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作成&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;し、ラッパーインスタンスを介して常にストアにアクセスできます（したがって、&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用するために必要なテンプレートパラメーターの細かい詳細を忘れます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e31dbd568adbc6521089b6d09e212fdb118726cc" translate="yes" xml:space="preserve">
          <source>There are two ways that I know to create a Singleton class correctly.</source>
          <target state="translated">私が知っているシングルトンクラスを正しく作成する方法は2つあります。</target>
        </trans-unit>
        <trans-unit id="28521cdf5fefb8ca060ab5a22e6ddfb09cef7d8c" translate="yes" xml:space="preserve">
          <source>This is about object life-time management. Suppose you have more than singletons in your software. And they depend on Logger singleton. During application destruction, suppose another singleton object uses Logger to log its destruction steps. You have to guarantee that Logger should be cleaned up last. Therefore, please also check out this paper:
&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot;&gt;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これはオブジェクトの寿命管理に関するものです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ソフトウェアにシングルトン以上のものが存在するとします。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ロガーシングルトンに依存しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アプリケーションの破棄中に、別のシングルトンオブジェクトがLoggerを使用して、破棄手順を記録するとします。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ロガーを最後にクリーンアップすることを保証する必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、このペーパーも確認して&lt;/font&gt;&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ください。http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;： &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d20124031b945444d0c1fd440a24d36bac0ab7f" translate="yes" xml:space="preserve">
          <source>This is called the Meyers Singleton, created by C++ wizard Scott Meyers. Simply define get_instance() differently. Now you can also get rid of the pointer member variable.</source>
          <target state="translated">これはマイヤーズ・シングルトンと呼ばれるもので、C++のウィザードであるスコット・マイヤーズが作成したものです。単純にget_instance()を別の形で定義するだけです。これで、ポインタのメンバ変数を取り除くこともできます。</target>
        </trans-unit>
        <trans-unit id="4c22b28b3d41d395f49ea96f9637893cadacf026" translate="yes" xml:space="preserve">
          <source>This is neat because the value returned is by reference and you can use &lt;code&gt;.&lt;/code&gt; syntax instead of &lt;code&gt;-&amp;gt;&lt;/code&gt; to access member variables.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返される値は参照によるものであり、を使用できるため、これは適切です&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代わりに構文を使用して、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メンバー変数にアクセスします。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3abd989834b48d9e30b53bbf5b75ed134706ae78" translate="yes" xml:space="preserve">
          <source>To use just inherit your class from this, like: &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用するには、次のようにクラスを継承します：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abfe440688144dc3488f94a3bcdd9a80d1b0b46" translate="yes" xml:space="preserve">
          <source>We went over this topic recently in my EECS class. If you want to look at the lecture notes in detail, visit &lt;a href=&quot;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&quot;&gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私は最近、EECSクラスでこのトピックを取り上げました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;講義ノートを詳細に確認したい場合は、&lt;/font&gt;&lt;a href=&quot;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http：//umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にアクセスしてください。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef46b5cc56312a21edb0f46af654cc29a8de451c" translate="yes" xml:space="preserve">
          <source>What are all the common undefined behaviours that a C++ programmer should know about?</source>
          <target state="translated">C++プログラマが知っておくべき一般的な未定義の動作とは?</target>
        </trans-unit>
        <trans-unit id="f9481ffc9d80995ea84a632ec6be1da7a9d03648" translate="yes" xml:space="preserve">
          <source>What is the lifetime of a static variable in a C++ function?</source>
          <target state="translated">C++関数の静的変数の寿命は?</target>
        </trans-unit>
        <trans-unit id="cfbba3022f0da956a8ae5155afd7fd1da6d095b2" translate="yes" xml:space="preserve">
          <source>You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.</source>
          <target state="translated">メモリの割り当てを避けることができます。マルチスレッド環境の場合に問題がある。</target>
        </trans-unit>
        <trans-unit id="109c3cc202bf5d2be202483e322663f064482610" translate="yes" xml:space="preserve">
          <source>You must know that Singleton instance &lt;em&gt;doesn't need to be manually deleted by us&lt;/em&gt;. We need a single object of it throughout the whole program, so &lt;em&gt;at the end of program execution, it will be automatically deallocated.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シングルトンインスタンスを&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;手動で削除する必要がない&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことを知って&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;おく必要があり&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プログラム全体で単一のオブジェクトが必要なため&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、プログラムの実行が終了すると、自動的に割り当てが解除されます。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c860d67c8e3dbf690743f011c26ee8f12ab81ca" translate="yes" xml:space="preserve">
          <source>Your code is correct, except that &lt;em&gt;you didn't declare the instance pointer outside the class&lt;/em&gt;. The inside class declarations of static variables are not considered declarations in C++, however this is allowed in other languages like &lt;strong&gt;C#&lt;/strong&gt; or &lt;strong&gt;Java&lt;/strong&gt; etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラスの外でインスタンスポインターを宣言しなかった&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以外は、コードは正しい&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;静的変数の内部クラス宣言は、C ++では宣言と見なされませんが、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C＃&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;や&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他の言語では許可されてい&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92bd75ebd8fd2b0179172217b15350cc6d4002f0" translate="yes" xml:space="preserve">
          <source>using</source>
          <target state="translated">using</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
