<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1008019">
    <body>
      <group id="1008019">
        <trans-unit id="36c9232103517e64f0d6682eef65f9fd0ad31cd8" translate="yes" xml:space="preserve">
          <source>&quot;Compiler automatically builds code that creates 's' first time through the
declaration, not thereafter, and then deletes the static object at program
termination.&quot;</source>
          <target state="translated">&quot;Компилятор автоматически строит код,который создает 's' в первый раз через объявление,а не после,а затем удаляет статический объект при завершении программы&quot;.</target>
        </trans-unit>
        <trans-unit id="d2883dd9a74d31ba7a51055b6db8d87e7a0f4434" translate="yes" xml:space="preserve">
          <source>...and rely on the program going out of scope to clean up afterwards.</source>
          <target state="translated">...и полагаться на программу,выходящую из-под контроля,чтобы потом навести порядок.</target>
        </trans-unit>
        <trans-unit id="9ec67d195d87a2b6d8be97175d5c6042febf0567" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;@Loki Astari's answer&lt;/a&gt; is excellent.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ответ @Loki Astari&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; отличный.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07ef837398f606106ec996846c93366067556b6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First Way:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Первый путь:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7edf76288aa87f9cb7eedb19f44e96cd79d975b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second Way&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Второй путь&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5e615b218d4601acd5025fd68241094524be9d5" translate="yes" xml:space="preserve">
          <source>Access your singleton like this:</source>
          <target state="translated">Доступ к твоей одиночке вот так:</target>
        </trans-unit>
        <trans-unit id="e8bc9322ae6e0805dbbf23f31f8b5391ac03a45d" translate="yes" xml:space="preserve">
          <source>Another issue with doing it this way is that it isn't thread-safe. In a multithreaded environment, two threads could get through the &quot;if&quot; before either has a chance to allocate the new instance (so both would). This still isn't too big of a deal if you are relying on program termination to clean up anyway.</source>
          <target state="translated">Другая проблема в том,что это не безопасно для потоков.В многопоточной среде два потока могут пройти через &quot;if&quot;,прежде чем у одного из них появится возможность выделить новый экземпляр (так же как и у другого).Это все равно не так уж и сложно,если вы полагаетесь на завершение программы для очистки в любом случае.</target>
        </trans-unit>
        <trans-unit id="2268cee1e2231822454db604a4a9d2507f7be692" translate="yes" xml:space="preserve">
          <source>Another non-allocating alternative: create a singleton, say of class &lt;code&gt;C&lt;/code&gt;, as you need it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другая нераспределительная альтернатива: создайте синглтон, скажем, класса &lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , как вам это нужно:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="011e2628ae6347f5e9d083f901ce7ec4d7f2f95a" translate="yes" xml:space="preserve">
          <source>Being a Singleton, you usually do not want it to be destructed.</source>
          <target state="translated">Будучи одиночкой,вы обычно не хотите,чтобы она была уничтожена.</target>
        </trans-unit>
        <trans-unit id="1a64604c83d016260a4733124a887b95b873e63c" translate="yes" xml:space="preserve">
          <source>C++ Singleton design pattern</source>
          <target state="translated">C++шаблон однокнопочного дизайна</target>
        </trans-unit>
        <trans-unit id="b4ac098631e8cd642bf5398d974d442fffbb33de" translate="yes" xml:space="preserve">
          <source>Can any one provide me a sample of Singleton in c++?</source>
          <target state="translated">Кто-нибудь может предоставить мне образец синглтона на c++?</target>
        </trans-unit>
        <trans-unit id="36434822ee78833774234098604d3ea82e322d9c" translate="yes" xml:space="preserve">
          <source>Dr Dobbs: C++ and The Perils of Double-Checked Locking: Part I</source>
          <target state="translated">Доктор Доббс:C++и &quot;Опасности двойной проверки блокировки&quot;:Часть I</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="d17857ecfe425c540113b2fd20e8ccff69da0f24" translate="yes" xml:space="preserve">
          <source>Finding C++ static initialization order problems</source>
          <target state="translated">Поиск проблем со статическим порядком инициализации C++</target>
        </trans-unit>
        <trans-unit id="efb7ceb0ff0a01cffe2bed6ecc78a9b33e6bac7e" translate="yes" xml:space="preserve">
          <source>From this declaration I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem in the implementation.</source>
          <target state="translated">Из этого заявления я могу сделать вывод,что поле экземпляра инициируется на куче.Это означает,что есть выделение памяти.Что для меня совершенно непонятно,когда именно произойдет перераспределение памяти? Или есть ошибка и утечка памяти? Похоже,что в реализации есть проблема.</target>
        </trans-unit>
        <trans-unit id="2e8c991a85485d2e54dacdbf83944ac53596b1f6" translate="yes" xml:space="preserve">
          <source>Has anyone mentioned &lt;code&gt;std::call_once&lt;/code&gt; and &lt;code&gt;std::once_flag&lt;/code&gt;?
Most other approaches - including double checked locking - are broken.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кто-нибудь упомянул &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::call_once&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::once_flag&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Большинство других подходов - включая двойную проверку блокировки - не работают.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e22081f06dbc88faa869c500655545f8b3b49e97" translate="yes" xml:space="preserve">
          <source>Here 00915CB8 is the memory location of singleton Object, same for the duration of the program but (normally!) different each time the program is run.</source>
          <target state="translated">Здесь 00915CB8 является ячейкой памяти однокнопочного объекта,одинаковой на время выполнения программы,но (как правило!)разной при каждом запуске программы.</target>
        </trans-unit>
        <trans-unit id="d93f58ba958d8ddddf1f1a269f714ce7fae89839" translate="yes" xml:space="preserve">
          <source>Here is an easy implementation.</source>
          <target state="translated">Вот легкая реализация.</target>
        </trans-unit>
        <trans-unit id="83f14721c00dbed7f33a39fff1861abde1780df6" translate="yes" xml:space="preserve">
          <source>Here is an updated C++11 implementation of the Singleton design pattern that is lazy-evaluated, correctly-destroyed, and &lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;thread-safe&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот обновленная реализация C ++ 11 шаблона проектирования Singleton, которая вычисляется лениво, корректно уничтожается и является &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;поточно-ориентированной&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b06e170e85f393d0825ee9533ff40bb6760c88f" translate="yes" xml:space="preserve">
          <source>However there are times with multiple static objects where you need to be able to guarantee that the &lt;em&gt;singleton&lt;/em&gt; will not be destroyed until all your static objects that use the &lt;em&gt;singleton&lt;/em&gt; no longer need it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако бывают случаи с несколькими статическими объектами, когда вам нужно быть в состоянии гарантировать, что &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;синглтон&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не будет уничтожен, пока все ваши статические объекты, которые используют &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;синглтон,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; больше не будут в этом нуждаться.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="448691124971d770be6bd3cf7a1db111c706cea4" translate="yes" xml:space="preserve">
          <source>However, it is good practice to clean up at program termination. Therefore, you can do this with an auxiliary static SingletonDestructor class and declare that as a friend in your Singleton.</source>
          <target state="translated">Тем не менее,хорошей практикой является уборка по окончании программы.Поэтому вы можете сделать это с помощью вспомогательного статического класса SingletonDestructor и объявить об этом как о друге в своем Singleton.</target>
        </trans-unit>
        <trans-unit id="a961b506da874e67a11c5fad251a627e2bb6cb12" translate="yes" xml:space="preserve">
          <source>I did not find a CRTP implementation among the answers, so here it is:</source>
          <target state="translated">Я не нашел реализации CRTP среди ответов,так что вот она:</target>
        </trans-unit>
        <trans-unit id="a02edb8cd40a9fa55f78844c4bb1fde3d56d28a8" translate="yes" xml:space="preserve">
          <source>I met this problem, when trying to introduce a Singleton in the Qt application. I decided, that all my setup dialogs must be Singletons, and adopted the pattern above. Unfortunately, Qt's main class &lt;code&gt;QApplication&lt;/code&gt; was allocated on stack in the &lt;code&gt;main&lt;/code&gt; function, and Qt forbids creating/destroying dialogs when no application object is available.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я столкнулся с этой проблемой, когда пытался ввести Singleton в приложении Qt. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я решил, что все мои диалоговые окна настройки должны быть Singletons, и принял шаблон выше. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;К сожалению, основной класс Qt &lt;/font&gt;&lt;/font&gt; &lt;code&gt;QApplication&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; был размещен в стеке в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; функции, и Qt запрещает создавать / уничтожать диалоги, когда объект приложения недоступен.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bfa20c1c1aff78139863f88ace5d0a2adc9a6311" translate="yes" xml:space="preserve">
          <source>I prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):</source>
          <target state="translated">Я предпочитаю такую реализацию (на самом деле,неправильно сказано,что я предпочитаю,потому что я максимально избегаю синглонов):</target>
        </trans-unit>
        <trans-unit id="ee2aed6c9894fa2b3220ca1cf8279311dd18c188" translate="yes" xml:space="preserve">
          <source>I think You should write a static function wherein your static object is deleted.
You should call this function when you are about to close your application.
This will ensure you dont have memory leakage.</source>
          <target state="translated">Я думаю,что Вы должны написать статическую функцию,в которой Ваш статический объект будет удален.Эту функцию следует вызывать,когда вы собираетесь закрыть свое приложение.Это позволит избежать утечки памяти.</target>
        </trans-unit>
        <trans-unit id="4f1aa530a0739a8ab5932864cc56e6ecc2819aa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; сам по себе является шаблонным классом, то ситуация становится более запутанной, но все еще возможно использовать этот метод, возможно, путем реализации вспомогательного класса со следующей сигнатурой:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50f3ffb9b1ad143b57ce983140aed72bd955b546" translate="yes" xml:space="preserve">
          <source>If you want to allocate the object in heap, why don't use a unique pointer. Memory will also be deallocated since we are using a unique pointer.</source>
          <target state="translated">Если вы хотите выделить объект в куче,почему бы не использовать уникальный указатель.Память также будет распределена,так как мы используем уникальный указатель.</target>
        </trans-unit>
        <trans-unit id="8ad91f497862ef558e636b6c57c8848e082bec9f" translate="yes" xml:space="preserve">
          <source>If you work on a platform where cleanup must be done manually, I'd probably add a manual cleanup routine.</source>
          <target state="translated">Если вы работаете на платформе,где очистка должна выполняться вручную,я,вероятно,добавлю ручную очистку.</target>
        </trans-unit>
        <trans-unit id="58153ad0f2a351dc0310fad80b8006f69491576b" translate="yes" xml:space="preserve">
          <source>Implement it similar to the way you have it in your example. As for destruction, &quot;Singletons usually endure for the length of the program run; most OSs will recover memory and most other resources when a program terminates, so there is an argument for not worrying about this.&quot;</source>
          <target state="translated">Реализуйте его так же,как и в вашем примере.Что касается разрушения,то &quot;синглеты обычно выдерживают в течение всего времени выполнения программы;большинство операционных систем восстанавливают память и большинство других ресурсов,когда программа завершается,так что есть аргумент,чтобы не беспокоиться об этом&quot;.</target>
        </trans-unit>
        <trans-unit id="8ec513111a6255768ad759087587f71a305fd98c" translate="yes" xml:space="preserve">
          <source>In 2008 I provided a C++98 implementation of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction, not-technically-thread-safe:</source>
          <target state="translated">В 2008 году я предоставил C++98 реализацию шаблона дизайна &quot;Синглтон&quot;,который является ленивым,гарантированно разрушаемым,нетехнически безопасным для резьбы:</target>
        </trans-unit>
        <trans-unit id="6ad103f816f6531a30eb7e68d5a16576c0db7171" translate="yes" xml:space="preserve">
          <source>In addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something...</source>
          <target state="translated">В дополнение к другой дискуссии здесь,возможно,стоит отметить,что вы можете иметь глобальность,не ограничиваясь одним экземпляром.Например,рассмотрим случай подсчета ссылок...</target>
        </trans-unit>
        <trans-unit id="0a8cc7fb43e3e00c5689247fd36b5590d04d43fe" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;std::shared_ptr&lt;/code&gt; can be used to keep the &lt;em&gt;singleton&lt;/em&gt; alive for all users even when the static destructors are being called at the end of the program:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этом случае &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; может использоваться, чтобы поддерживать &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;синглтон&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для всех пользователей, даже когда статические деструкторы вызываются в конце программы:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0297137859db5072b87d3de3253a183fe8d2a132" translate="yes" xml:space="preserve">
          <source>It has no dynamic memory allocation.</source>
          <target state="translated">У него нет динамического выделения памяти.</target>
        </trans-unit>
        <trans-unit id="4161b1ad79a47a16c61ad1aba0f2011aa4fd5ab4" translate="yes" xml:space="preserve">
          <source>It is indeed probably allocated from the heap, but without the sources there is no way of knowing.</source>
          <target state="translated">Он действительно,вероятно,выделяется из кучи,но без источников нет возможности узнать об этом.</target>
        </trans-unit>
        <trans-unit id="c30ebb06c17cf8f53d6d497493adf232a4a32fee" translate="yes" xml:space="preserve">
          <source>It will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton.  If you want to be able to explicitly clean it, it's fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it's used, but that's outside of the scope of a &quot;classic&quot; singleton.</source>
          <target state="translated">При завершении работы программы она будет сорвана и разобрана,что является нормальным,желаемым поведением для одиночной кнопки.Если вы хотите иметь возможность явно очистить его,то довольно легко добавить в класс статический метод,позволяющий восстановить его до чистого состояния и заставить его перераспределить в следующий раз при использовании,но это выходит за рамки &quot;классического&quot; синглтона.</target>
        </trans-unit>
        <trans-unit id="c64e5602a9af0c16dc3d83cb29fc0a0fb06998c8" translate="yes" xml:space="preserve">
          <source>My implementation is similar to Galik's. The difference is my implementation allows the shared pointers to clean up allocated memory, as opposed to holding onto the memory until the application is exited and the static pointers are cleaned up.</source>
          <target state="translated">Моя реализация похожа на реализацию Галика.Разница в том,что моя реализация позволяет разделяемым указателям очищать выделенную память,в отличие от удержания в памяти до тех пор,пока приложение не будет закрыто и статические указатели не будут очищены.</target>
        </trans-unit>
        <trans-unit id="d3cd3cde4aa0af185c90283942754979a78a9c2b" translate="yes" xml:space="preserve">
          <source>My main question is, how do I implement it in the right way?</source>
          <target state="translated">Мой главный вопрос в том,как правильно его реализовать?</target>
        </trans-unit>
        <trans-unit id="697496554c522fb6e5431ed20fc49a5e7756de39" translate="yes" xml:space="preserve">
          <source>N.B. This is not a thread safe one.You have to ensure thread safety.</source>
          <target state="translated">N.B.Это не резьбонадежная резьбонадежная резьба.</target>
        </trans-unit>
        <trans-unit id="3ae7578b52cf3c8766544802ea79b9c71361d40f" translate="yes" xml:space="preserve">
          <source>Neither this nor Cătălin's answer is automatically thread-safe in current C++, but will be in C++0x.</source>
          <target state="translated">Ни этот,ни ответ Cătălin не является автоматически потокобезопасным в текущем C++,но будет на C++0x.</target>
        </trans-unit>
        <trans-unit id="6c7a38653bee09a3cd6956dd4b338c749ce46dd8" translate="yes" xml:space="preserve">
          <source>Note also that with the Meyers Singleton you &quot;can get into very difficult situation if objects rely on each other at the time of
termination - when does the Singleton disappear relative to other objects? But for simple applications, this works fine.&quot;</source>
          <target state="translated">Отметим также,что с помощью Meyers Singleton вы &quot;можете попасть в очень сложную ситуацию,если объекты полагаются друг на друга в момент прекращения-когда синглтон исчезает по отношению к другим объектам? Но для простых приложений это работает хорошо&quot;.</target>
        </trans-unit>
        <trans-unit id="afd9ddaa4d72c4a6baeb072dcccdd11cd7953239" translate="yes" xml:space="preserve">
          <source>Now somewhere inside a function (such as &lt;code&gt;main&lt;/code&gt;) you can do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь где-то внутри функции (например, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) вы можете сделать:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a78e09f10d27dc0831eef859b1c65cfa888d905a" translate="yes" xml:space="preserve">
          <source>One major problem in singleton pattern implementation is safe initialization. The only safe way is to guard the initialization sequence with synchronizing barriers. But those barriers themselves need to be safely initiated. &lt;code&gt;std::once_flag&lt;/code&gt; is the mechanism to get guaranteed safe initialization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Одной из основных проблем в реализации одноэлементных шаблонов является безопасная инициализация. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Единственный безопасный способ - защитить последовательность инициализации с помощью синхронизирующих барьеров. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но сами эти барьеры должны быть благополучно инициированы. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::once_flag&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это механизм гарантированной безопасной инициализации.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fbe47028e7d8120fc3d32b4563c89e0009142d4f" translate="yes" xml:space="preserve">
          <source>Only one object created and this object reference is returned each and every time afterwords.</source>
          <target state="translated">Только один объект создан,и ссылка на этот объект возвращается каждый раз после слов.</target>
        </trans-unit>
        <trans-unit id="41fc1d2c4e5b1f7226fe4db3fa895813c007fb9a" translate="yes" xml:space="preserve">
          <source>Recently I've bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real life example):</source>
          <target state="translated">Недавно я столкнулся с реализацией шаблона дизайна Singleton для C++.Он выглядел так (я взял его из реального примера):</target>
        </trans-unit>
        <trans-unit id="276b20dd2003e2c8b8147112735ed61b5985f32f" translate="yes" xml:space="preserve">
          <source>See this article about when to use a singleton: (not often)</source>
          <target state="translated">См.эту статью о том,когда использовать одиночку:(не часто)</target>
        </trans-unit>
        <trans-unit id="dc48ffee79c43defeacd652988f6d13d63671cd8" translate="yes" xml:space="preserve">
          <source>See this article describing lifetimes:</source>
          <target state="translated">См.эту статью,описывающую жизнь:</target>
        </trans-unit>
        <trans-unit id="6929b1498a833a4dd1c77bb041d752cda196cffc" translate="yes" xml:space="preserve">
          <source>See this article that discusses some threading implications to singletons:</source>
          <target state="translated">См.эту статью,в которой обсуждаются некоторые нитевидные последствия для синглонов:</target>
        </trans-unit>
        <trans-unit id="c1297f70db8f6ff1cb7f6cadad4fd0176e9ad52a" translate="yes" xml:space="preserve">
          <source>See this article that explains why double checked locking will not work on C++:</source>
          <target state="translated">Смотрите эту статью,которая объясняет,почему блокировка двойной проверки не будет работать на C++:</target>
        </trans-unit>
        <trans-unit id="d8a3f5854c04a6c2fd9c6b0eed898518205b893b" translate="yes" xml:space="preserve">
          <source>See this two article about initialization order and how to cope:</source>
          <target state="translated">Смотрите две статьи о порядке инициализации и о том,как с этим справиться:</target>
        </trans-unit>
        <trans-unit id="e229eb46fdb8abc36ed541fd75a96ad01079842c" translate="yes" xml:space="preserve">
          <source>Simple singleton class, This must be your header class file</source>
          <target state="translated">Простой однокнопочный класс.Это должен быть ваш заголовочный файл класса.</target>
        </trans-unit>
        <trans-unit id="0f5183f104a6ee7a2ee3c3f8a78ffcad0dd7ada1" translate="yes" xml:space="preserve">
          <source>Singleton instance declared as static variable of GetInstance method, is it thread-safe?</source>
          <target state="translated">Одноэлементный экземпляр,объявленный статической переменной метода GetInstance,является ли он потокобезопасным?</target>
        </trans-unit>
        <trans-unit id="616cb2246d061aa00ec22ca9c85c492806ae00f9" translate="yes" xml:space="preserve">
          <source>Singleton: How should it be used</source>
          <target state="translated">Синглтон:Как его использовать</target>
        </trans-unit>
        <trans-unit id="1ddbfa6229ac4bbfeea0426af8472583accde3ea" translate="yes" xml:space="preserve">
          <source>Static variables initialisation order</source>
          <target state="translated">Порядок инициализации статических переменных</target>
        </trans-unit>
        <trans-unit id="3606cc4233d18abdcf887e06f1cde5c7e5230832" translate="yes" xml:space="preserve">
          <source>That is why I prefer heap-allocated singletons. I provide an explicit &lt;code&gt;init()&lt;/code&gt; and &lt;code&gt;term()&lt;/code&gt; methods for all the singletons and call them inside &lt;code&gt;main&lt;/code&gt;. Thus I have a full control over the order of singletons creation/destruction, and also I guarantee that singletons will be created, no matter whether someone called &lt;code&gt;getInstance()&lt;/code&gt; or not.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот почему я предпочитаю выделенные кучей синглтоны. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я предоставляю явные &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;методы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;init()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;term()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для всех синглетонов и вызываю их внутри &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, я полностью контролирую порядок создания / уничтожения синглетонов, а также гарантирую, что синглтоны будут созданы, независимо от того, вызвал ли кто-то &lt;/font&gt;&lt;/font&gt; &lt;code&gt;getInstance()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или нет.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="024eab215b08bb3333ee58e19b30d9d60b0c180e" translate="yes" xml:space="preserve">
          <source>The Singleton_destroyer will be created on program startup, and &quot;when program terminates, all global/static objects are destroyed by the runtime library shutdown code (inserted by the linker), so the_destroyer will be destroyed; its destructor will delete the Singleton, running its destructor.&quot;</source>
          <target state="translated">При запуске программы будет создан Singleton_destroyer,и &quot;по окончании работы программы все глобальные объекты будут уничтожены кодом завершения работы библиотеки (вставленным компоновщиком),поэтому_destroyer будет уничтожен;его деструктор удалит Singleton,запустив его деструктор&quot;.</target>
        </trans-unit>
        <trans-unit id="5008e6ca7deb401eab76f0a1b7199dbd571aeac8" translate="yes" xml:space="preserve">
          <source>The paper that was linked to above describes the shortcoming of double checked locking is that the compiler may allocate the memory for the object and set a pointer to the address of the allocated memory, before the object's constructor has been called. It is quite easy in c++ however to use allocaters to allocate the memory manually, and then use a construct call to initialize the memory. Using this appraoch, the double-checked locking works just fine.</source>
          <target state="translated">В статье,на которую была сделана ссылка,описан недостаток двойной проверки блокировки,заключающийся в том,что компилятор может выделить память для объекта и установить указатель на адрес выделенной памяти,до того,как будет вызван конструктор объекта.Однако в c++довольно просто использовать аллокаторы для ручного выделения памяти,а затем использовать вызов конструкции для инициализации памяти.Используя этот аллокатор,блокировка с двойной проверкой работает просто отлично.</target>
        </trans-unit>
        <trans-unit id="b6f3f591e89067a6d11cf1b1060464622dca5fbe" translate="yes" xml:space="preserve">
          <source>The refs don't need to store a pointer back to their respective &lt;code&gt;Store&lt;/code&gt; because that information is supplied at compile-time. You also don't have to worry about the &lt;code&gt;Store&lt;/code&gt;'s lifetime because the compiler requires that it is global.  If there is indeed only one instance of &lt;code&gt;Store&lt;/code&gt; then there's no overhead in this approach; with more than one instance it's up to the compiler to be clever about code generation. If necessary, the &lt;code&gt;ItemRef&lt;/code&gt; class can even be made a &lt;code&gt;friend&lt;/code&gt; of &lt;code&gt;Store&lt;/code&gt; (you can have templated friends!).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ссылкам не нужно хранить указатель обратно на их соответствующее &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; потому что эта информация предоставляется во время компиляции. Вам также не нужно беспокоиться о времени жизни &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , потому что компилятор требует, чтобы он был глобальным. Если действительно есть только один экземпляр &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; то в этом подходе нет накладных расходов; с более чем одним экземпляром компилятор должен быть умным в отношении генерации кода. В &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;случае необходимости, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ItemRef&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; класс даже может быть сделан &lt;/font&gt;&lt;/font&gt; &lt;code&gt;friend&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (вы можете иметь шаблонные друг!).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0786d361e2bcc95d4119e640b7e9a62ee7f81d86" translate="yes" xml:space="preserve">
          <source>The solution in the accepted answer has a significant drawback - the destructor for the singleton is called after the control leaves the &lt;code&gt;main()&lt;/code&gt; function. There may be problems really, when some dependent objects are allocated inside &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Решение в принятом ответе имеет существенный недостаток - деструктор для синглтона вызывается после того, как элемент управления покидает &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функцию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На самом деле могут быть проблемы, когда некоторые зависимые объекты размещаются внутри &lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f40212b178fce257aced5352c8a45824c8a75d7d" translate="yes" xml:space="preserve">
          <source>The typical implementation (taken from some code I have in emacs already) would be:</source>
          <target state="translated">Типичной реализацией (взятой из некоторого кода,который у меня уже есть в emacs)будет:</target>
        </trans-unit>
        <trans-unit id="56278e8448390147f165b72dfac3329a1d70ac20" translate="yes" xml:space="preserve">
          <source>The user can now create a &lt;code&gt;StoreWrapper&lt;/code&gt; type (and global instance) for each global &lt;code&gt;Store&lt;/code&gt; instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using &lt;code&gt;Store&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь пользователь может создать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;тип &lt;/font&gt;&lt;/font&gt; &lt;code&gt;StoreWrapper&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (и глобальный экземпляр) для каждого глобального &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;экземпляра &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и всегда получать доступ к хранилищам через свой экземпляр оболочки (таким образом, забывая о мрачных деталях параметров шаблона, необходимых для использования &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e31dbd568adbc6521089b6d09e212fdb118726cc" translate="yes" xml:space="preserve">
          <source>There are two ways that I know to create a Singleton class correctly.</source>
          <target state="translated">Есть два способа,которые я знаю,как правильно создать класс Singleton.</target>
        </trans-unit>
        <trans-unit id="28521cdf5fefb8ca060ab5a22e6ddfb09cef7d8c" translate="yes" xml:space="preserve">
          <source>This is about object life-time management. Suppose you have more than singletons in your software. And they depend on Logger singleton. During application destruction, suppose another singleton object uses Logger to log its destruction steps. You have to guarantee that Logger should be cleaned up last. Therefore, please also check out this paper:
&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot;&gt;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Речь идет об объекте управления временем жизни. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предположим, у вас есть больше, чем синглтонов в вашем программном обеспечении. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И они зависят от синглтона Logger. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предположим, что во время уничтожения приложения другой одноэлементный объект использует Logger для регистрации шагов его уничтожения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы должны гарантировать, что Logger должен быть очищен последним. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому, пожалуйста, ознакомьтесь с этой статьей: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d20124031b945444d0c1fd440a24d36bac0ab7f" translate="yes" xml:space="preserve">
          <source>This is called the Meyers Singleton, created by C++ wizard Scott Meyers. Simply define get_instance() differently. Now you can also get rid of the pointer member variable.</source>
          <target state="translated">Это называется Meyers Singleton,созданный мастером C++Скоттом Мейерсом.Просто определите get_instance()по-другому.Теперь вы также можете избавиться от переменной члена указателя.</target>
        </trans-unit>
        <trans-unit id="4c22b28b3d41d395f49ea96f9637893cadacf026" translate="yes" xml:space="preserve">
          <source>This is neat because the value returned is by reference and you can use &lt;code&gt;.&lt;/code&gt; syntax instead of &lt;code&gt;-&amp;gt;&lt;/code&gt; to access member variables.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это аккуратно, потому что возвращаемое значение является ссылкой, и вы можете использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;.&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;синтаксис вместо &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для доступа к переменным-членам.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3abd989834b48d9e30b53bbf5b75ed134706ae78" translate="yes" xml:space="preserve">
          <source>To use just inherit your class from this, like: &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы использовать просто наследовать ваш класс от этого, как: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abfe440688144dc3488f94a3bcdd9a80d1b0b46" translate="yes" xml:space="preserve">
          <source>We went over this topic recently in my EECS class. If you want to look at the lecture notes in detail, visit &lt;a href=&quot;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&quot;&gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мы недавно обсуждали эту тему в моем классе EECS. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы хотите подробно ознакомиться с примечаниями к лекции, посетите &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef46b5cc56312a21edb0f46af654cc29a8de451c" translate="yes" xml:space="preserve">
          <source>What are all the common undefined behaviours that a C++ programmer should know about?</source>
          <target state="translated">Какие типичные неопределённые поведения должен знать Си++-программист?</target>
        </trans-unit>
        <trans-unit id="f9481ffc9d80995ea84a632ec6be1da7a9d03648" translate="yes" xml:space="preserve">
          <source>What is the lifetime of a static variable in a C++ function?</source>
          <target state="translated">Каково время жизни статической переменной в функции С++?</target>
        </trans-unit>
        <trans-unit id="cfbba3022f0da956a8ae5155afd7fd1da6d095b2" translate="yes" xml:space="preserve">
          <source>You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.</source>
          <target state="translated">Можно было бы избежать выделения памяти.Существует множество вариантов,все из которых имеют проблемы в случае многопоточной среды.</target>
        </trans-unit>
        <trans-unit id="109c3cc202bf5d2be202483e322663f064482610" translate="yes" xml:space="preserve">
          <source>You must know that Singleton instance &lt;em&gt;doesn't need to be manually deleted by us&lt;/em&gt;. We need a single object of it throughout the whole program, so &lt;em&gt;at the end of program execution, it will be automatically deallocated.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы должны знать, что экземпляр Singleton нам &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не нужно удалять вручную&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Нам нужен один его объект во всей программе, поэтому &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в конце выполнения программы он будет автоматически освобожден.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c860d67c8e3dbf690743f011c26ee8f12ab81ca" translate="yes" xml:space="preserve">
          <source>Your code is correct, except that &lt;em&gt;you didn't declare the instance pointer outside the class&lt;/em&gt;. The inside class declarations of static variables are not considered declarations in C++, however this is allowed in other languages like &lt;strong&gt;C#&lt;/strong&gt; or &lt;strong&gt;Java&lt;/strong&gt; etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ваш код верен, за исключением того, что &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вы не объявили указатель экземпляра вне класса&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Внутренние объявления класса статических переменных не считаются объявлениями в C ++, однако это допускается в других языках, таких как &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C #&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и т. Д.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92bd75ebd8fd2b0179172217b15350cc6d4002f0" translate="yes" xml:space="preserve">
          <source>using</source>
          <target state="translated">using</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
