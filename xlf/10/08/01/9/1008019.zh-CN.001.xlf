<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1008019">
    <body>
      <group id="1008019">
        <trans-unit id="36c9232103517e64f0d6682eef65f9fd0ad31cd8" translate="yes" xml:space="preserve">
          <source>&quot;Compiler automatically builds code that creates 's' first time through the
declaration, not thereafter, and then deletes the static object at program
termination.&quot;</source>
          <target state="translated">&quot;编译器自动构建的代码第一次通过声明创建's',而不是此后,然后在程序终止时删除静态对象。&quot;</target>
        </trans-unit>
        <trans-unit id="d2883dd9a74d31ba7a51055b6db8d87e7a0f4434" translate="yes" xml:space="preserve">
          <source>...and rely on the program going out of scope to clean up afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec67d195d87a2b6d8be97175d5c6042febf0567" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;@Loki Astari's answer&lt;/a&gt; is excellent.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/1008289/3807729&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@Loki Astari的回答&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非常好。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07ef837398f606106ec996846c93366067556b6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First Way:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一种方式：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7edf76288aa87f9cb7eedb19f44e96cd79d975b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second Way&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第二路&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5e615b218d4601acd5025fd68241094524be9d5" translate="yes" xml:space="preserve">
          <source>Access your singleton like this:</source>
          <target state="translated">像这样进入你的单人房</target>
        </trans-unit>
        <trans-unit id="e8bc9322ae6e0805dbbf23f31f8b5391ac03a45d" translate="yes" xml:space="preserve">
          <source>Another issue with doing it this way is that it isn't thread-safe. In a multithreaded environment, two threads could get through the &quot;if&quot; before either has a chance to allocate the new instance (so both would). This still isn't too big of a deal if you are relying on program termination to clean up anyway.</source>
          <target state="translated">这样做的另一个问题是,它不是线程安全的。在一个多线程环境中,两个线程可能会在任何一个线程有机会分配新的实例之前通过 &quot;if&quot;(所以两个都会)。如果你依靠程序终止来清理的话,这仍然不是什么大问题。</target>
        </trans-unit>
        <trans-unit id="2268cee1e2231822454db604a4a9d2507f7be692" translate="yes" xml:space="preserve">
          <source>Another non-allocating alternative: create a singleton, say of class &lt;code&gt;C&lt;/code&gt;, as you need it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一种非分配方式：根据需要创建一个单例，例如类&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="011e2628ae6347f5e9d083f901ce7ec4d7f2f95a" translate="yes" xml:space="preserve">
          <source>Being a Singleton, you usually do not want it to be destructed.</source>
          <target state="translated">作为一个单身汉,你通常不希望它被毁掉。</target>
        </trans-unit>
        <trans-unit id="1a64604c83d016260a4733124a887b95b873e63c" translate="yes" xml:space="preserve">
          <source>C++ Singleton design pattern</source>
          <target state="translated">C++Singleton设计模式</target>
        </trans-unit>
        <trans-unit id="b4ac098631e8cd642bf5398d974d442fffbb33de" translate="yes" xml:space="preserve">
          <source>Can any one provide me a sample of Singleton in c++?</source>
          <target state="translated">有谁能给我提供一个C++中的Singleton的例子吗?</target>
        </trans-unit>
        <trans-unit id="36434822ee78833774234098604d3ea82e322d9c" translate="yes" xml:space="preserve">
          <source>Dr Dobbs: C++ and The Perils of Double-Checked Locking: Part I</source>
          <target state="translated">Dobbs博士。C++和双重校验锁定的危险。第一部分</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="d17857ecfe425c540113b2fd20e8ccff69da0f24" translate="yes" xml:space="preserve">
          <source>Finding C++ static initialization order problems</source>
          <target state="translated">寻找C++静态初始化顺序问题</target>
        </trans-unit>
        <trans-unit id="efb7ceb0ff0a01cffe2bed6ecc78a9b33e6bac7e" translate="yes" xml:space="preserve">
          <source>From this declaration I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem in the implementation.</source>
          <target state="translated">从这个声明中,我可以推断出实例字段是在堆上发起的。这意味着有一个内存分配。我完全不清楚的是,到底是什么时候会分配内存?还是说是有bug和内存泄露?好像是实现中出现了问题。</target>
        </trans-unit>
        <trans-unit id="2e8c991a85485d2e54dacdbf83944ac53596b1f6" translate="yes" xml:space="preserve">
          <source>Has anyone mentioned &lt;code&gt;std::call_once&lt;/code&gt; and &lt;code&gt;std::once_flag&lt;/code&gt;?
Most other approaches - including double checked locking - are broken.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有人提到过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::call_once&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::once_flag&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;吗？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大多数其他方法-包括双重检查锁定-都是无效的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e22081f06dbc88faa869c500655545f8b3b49e97" translate="yes" xml:space="preserve">
          <source>Here 00915CB8 is the memory location of singleton Object, same for the duration of the program but (normally!) different each time the program is run.</source>
          <target state="translated">这里00915CB8是单子对象的内存位置,在程序运行期间是一样的,但(通常情况下!)每次运行程序都不一样。</target>
        </trans-unit>
        <trans-unit id="d93f58ba958d8ddddf1f1a269f714ce7fae89839" translate="yes" xml:space="preserve">
          <source>Here is an easy implementation.</source>
          <target state="translated">这里有一个简单的实现方法。</target>
        </trans-unit>
        <trans-unit id="83f14721c00dbed7f33a39fff1861abde1780df6" translate="yes" xml:space="preserve">
          <source>Here is an updated C++11 implementation of the Singleton design pattern that is lazy-evaluated, correctly-destroyed, and &lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;thread-safe&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是Singleton设计模式的更新的C ++ 11实现，该模式是延迟评估，正确销毁且&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/449823/52074&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;线程安全的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b06e170e85f393d0825ee9533ff40bb6760c88f" translate="yes" xml:space="preserve">
          <source>However there are times with multiple static objects where you need to be able to guarantee that the &lt;em&gt;singleton&lt;/em&gt; will not be destroyed until all your static objects that use the &lt;em&gt;singleton&lt;/em&gt; no longer need it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不过也有与多个静态对象的时间，你需要能够保证该&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;单&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不会被破坏，直到使用了所有的静态对象&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的单身&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不再需要它。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="448691124971d770be6bd3cf7a1db111c706cea4" translate="yes" xml:space="preserve">
          <source>However, it is good practice to clean up at program termination. Therefore, you can do this with an auxiliary static SingletonDestructor class and declare that as a friend in your Singleton.</source>
          <target state="translated">然而,在程序终止时清理是一个很好的做法。因此,你可以用一个辅助的静态SingletonDestructor类来做,并在你的Singleton中声明为好友。</target>
        </trans-unit>
        <trans-unit id="a961b506da874e67a11c5fad251a627e2bb6cb12" translate="yes" xml:space="preserve">
          <source>I did not find a CRTP implementation among the answers, so here it is:</source>
          <target state="translated">我在答案中没有找到CRTP的实现,所以就在这里。</target>
        </trans-unit>
        <trans-unit id="a02edb8cd40a9fa55f78844c4bb1fde3d56d28a8" translate="yes" xml:space="preserve">
          <source>I met this problem, when trying to introduce a Singleton in the Qt application. I decided, that all my setup dialogs must be Singletons, and adopted the pattern above. Unfortunately, Qt's main class &lt;code&gt;QApplication&lt;/code&gt; was allocated on stack in the &lt;code&gt;main&lt;/code&gt; function, and Qt forbids creating/destroying dialogs when no application object is available.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试在Qt应用程序中引入Singleton时遇到了这个问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我决定，我所有的设置对话框都必须是Singletons，并采用上面的模式。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不幸的是，Qt的主类&lt;/font&gt;&lt;/font&gt; &lt;code&gt;QApplication&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是在堆栈上分配的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且当没有应用程序对象可用时，Qt禁止创建/销毁对话框。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bfa20c1c1aff78139863f88ace5d0a2adc9a6311" translate="yes" xml:space="preserve">
          <source>I prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):</source>
          <target state="translated">我更喜欢这种实现方式(其实不正确的说我更喜欢,因为我尽量避免单体)。</target>
        </trans-unit>
        <trans-unit id="ee2aed6c9894fa2b3220ca1cf8279311dd18c188" translate="yes" xml:space="preserve">
          <source>I think You should write a static function wherein your static object is deleted.
You should call this function when you are about to close your application.
This will ensure you dont have memory leakage.</source>
          <target state="translated">我认为你应该写一个静态函数,在这个函数中删除你的静态对象。你应该在你即将关闭你的应用程序时调用这个函数。这将确保你不会出现内存泄漏。</target>
        </trans-unit>
        <trans-unit id="4f1aa530a0739a8ab5932864cc56e6ecc2819aa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本身是模板化的类，那么事情会变得更加混乱，但是仍然可以使用此方法，也许可以通过实现具有以下签名的帮助器类：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50f3ffb9b1ad143b57ce983140aed72bd955b546" translate="yes" xml:space="preserve">
          <source>If you want to allocate the object in heap, why don't use a unique pointer. Memory will also be deallocated since we are using a unique pointer.</source>
          <target state="translated">如果你想在堆中分配对象,为什么不使用唯一指针呢?因为我们使用的是唯一指针,所以内存也会被deocallated。</target>
        </trans-unit>
        <trans-unit id="8ad91f497862ef558e636b6c57c8848e082bec9f" translate="yes" xml:space="preserve">
          <source>If you work on a platform where cleanup must be done manually, I'd probably add a manual cleanup routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58153ad0f2a351dc0310fad80b8006f69491576b" translate="yes" xml:space="preserve">
          <source>Implement it similar to the way you have it in your example. As for destruction, &quot;Singletons usually endure for the length of the program run; most OSs will recover memory and most other resources when a program terminates, so there is an argument for not worrying about this.&quot;</source>
          <target state="translated">实现方式与你的例子中的类似。至于销毁,&quot;单子通常会在程序运行的时间内忍受;大多数操作系统会在程序终止时恢复内存和大多数其他资源,所以有理由不担心这个问题。&quot;</target>
        </trans-unit>
        <trans-unit id="8ec513111a6255768ad759087587f71a305fd98c" translate="yes" xml:space="preserve">
          <source>In 2008 I provided a C++98 implementation of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction, not-technically-thread-safe:</source>
          <target state="translated">2008年,我提供了一个C++98的Singleton设计模式的实现,该模式是懒惰的、保证破坏的、技术上不安全的Singleton设计模式。</target>
        </trans-unit>
        <trans-unit id="6ad103f816f6531a30eb7e68d5a16576c0db7171" translate="yes" xml:space="preserve">
          <source>In addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something...</source>
          <target state="translated">除了这里的其他讨论之外,可能值得注意的是,你可以有全局性,而不把用法限制在一个实例中。例如,考虑一下引用计数的情况......</target>
        </trans-unit>
        <trans-unit id="0a8cc7fb43e3e00c5689247fd36b5590d04d43fe" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;std::shared_ptr&lt;/code&gt; can be used to keep the &lt;em&gt;singleton&lt;/em&gt; alive for all users even when the static destructors are being called at the end of the program:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即使在程序结束时调用了静态析构函数，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有用户&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保持&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;单例状态&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0297137859db5072b87d3de3253a183fe8d2a132" translate="yes" xml:space="preserve">
          <source>It has no dynamic memory allocation.</source>
          <target state="translated">它没有动态的内存分配。</target>
        </trans-unit>
        <trans-unit id="4161b1ad79a47a16c61ad1aba0f2011aa4fd5ab4" translate="yes" xml:space="preserve">
          <source>It is indeed probably allocated from the heap, but without the sources there is no way of knowing.</source>
          <target state="translated">确实有可能是从堆里分配出来的,但没有来源就无从得知。</target>
        </trans-unit>
        <trans-unit id="c30ebb06c17cf8f53d6d497493adf232a4a32fee" translate="yes" xml:space="preserve">
          <source>It will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton.  If you want to be able to explicitly clean it, it's fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it's used, but that's outside of the scope of a &quot;classic&quot; singleton.</source>
          <target state="translated">当程序终止时,它将被拆掉并被deallocated,这对于一个单子类来说是正常的,也是需要的行为。如果你希望能够显式地清理它,在类中添加一个静态方法,允许你将其恢复到一个干净的状态,并在下次使用时让它重新分配,这是很容易的,但这不在 &quot;经典 &quot;单体的范围之内。</target>
        </trans-unit>
        <trans-unit id="c64e5602a9af0c16dc3d83cb29fc0a0fb06998c8" translate="yes" xml:space="preserve">
          <source>My implementation is similar to Galik's. The difference is my implementation allows the shared pointers to clean up allocated memory, as opposed to holding onto the memory until the application is exited and the static pointers are cleaned up.</source>
          <target state="translated">我的实现与Galik的实现类似。不同的是,我的实现允许共享指针清理已分配的内存,而不是在应用程序退出并清理静态指针之前,保留在内存上。</target>
        </trans-unit>
        <trans-unit id="d3cd3cde4aa0af185c90283942754979a78a9c2b" translate="yes" xml:space="preserve">
          <source>My main question is, how do I implement it in the right way?</source>
          <target state="translated">我的主要问题是,如何以正确的方式实现?</target>
        </trans-unit>
        <trans-unit id="697496554c522fb6e5431ed20fc49a5e7756de39" translate="yes" xml:space="preserve">
          <source>N.B. This is not a thread safe one.You have to ensure thread safety.</source>
          <target state="translated">注意:这个不是螺纹安全的,要保证螺纹的安全。</target>
        </trans-unit>
        <trans-unit id="3ae7578b52cf3c8766544802ea79b9c71361d40f" translate="yes" xml:space="preserve">
          <source>Neither this nor Cătălin's answer is automatically thread-safe in current C++, but will be in C++0x.</source>
          <target state="translated">这个和Cătălin的答案在当前的C++中都不是自动的线程安全的,但在C++0x中会有。</target>
        </trans-unit>
        <trans-unit id="6c7a38653bee09a3cd6956dd4b338c749ce46dd8" translate="yes" xml:space="preserve">
          <source>Note also that with the Meyers Singleton you &quot;can get into very difficult situation if objects rely on each other at the time of
termination - when does the Singleton disappear relative to other objects? But for simple applications, this works fine.&quot;</source>
          <target state="translated">还需要注意的是,使用Meyers Singleton,你 &quot;如果对象在终止时相互依赖,你会进入非常困难的情况--相对于其他对象,Singleton什么时候会消失?但对于简单的应用来说,这很好用。&quot;</target>
        </trans-unit>
        <trans-unit id="afd9ddaa4d72c4a6baeb072dcccdd11cd7953239" translate="yes" xml:space="preserve">
          <source>Now somewhere inside a function (such as &lt;code&gt;main&lt;/code&gt;) you can do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在函数内部的某处（例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）执行以下操作：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a78e09f10d27dc0831eef859b1c65cfa888d905a" translate="yes" xml:space="preserve">
          <source>One major problem in singleton pattern implementation is safe initialization. The only safe way is to guard the initialization sequence with synchronizing barriers. But those barriers themselves need to be safely initiated. &lt;code&gt;std::once_flag&lt;/code&gt; is the mechanism to get guaranteed safe initialization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;单例模式实现中的一个主要问题是安全初始化。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;唯一安全的方法是使用同步屏障来保护初始化序列。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，这些障碍本身需要安全地启动。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::once_flag&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是用于确保安全初始化的机制。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fbe47028e7d8120fc3d32b4563c89e0009142d4f" translate="yes" xml:space="preserve">
          <source>Only one object created and this object reference is returned each and every time afterwords.</source>
          <target state="translated">只创建了一个对象,而这个对象的引用每隔一段时间就会返回一次。</target>
        </trans-unit>
        <trans-unit id="41fc1d2c4e5b1f7226fe4db3fa895813c007fb9a" translate="yes" xml:space="preserve">
          <source>Recently I've bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real life example):</source>
          <target state="translated">最近我碰到了一个C++的Singleton设计模式的实现。它看起来是这样的(我采用了现实生活中的例子)。</target>
        </trans-unit>
        <trans-unit id="276b20dd2003e2c8b8147112735ed61b5985f32f" translate="yes" xml:space="preserve">
          <source>See this article about when to use a singleton: (not often)</source>
          <target state="translated">请看这篇文章中关于何时使用单子的内容。(不经常使用)</target>
        </trans-unit>
        <trans-unit id="dc48ffee79c43defeacd652988f6d13d63671cd8" translate="yes" xml:space="preserve">
          <source>See this article describing lifetimes:</source>
          <target state="translated">请看这篇描述人生的文章。</target>
        </trans-unit>
        <trans-unit id="6929b1498a833a4dd1c77bb041d752cda196cffc" translate="yes" xml:space="preserve">
          <source>See this article that discusses some threading implications to singletons:</source>
          <target state="translated">请看这篇文章,讨论了一些线程对单子的影响。</target>
        </trans-unit>
        <trans-unit id="c1297f70db8f6ff1cb7f6cadad4fd0176e9ad52a" translate="yes" xml:space="preserve">
          <source>See this article that explains why double checked locking will not work on C++:</source>
          <target state="translated">请看这篇文章,解释了为什么双重检查锁定会在C++上不起作用。</target>
        </trans-unit>
        <trans-unit id="d8a3f5854c04a6c2fd9c6b0eed898518205b893b" translate="yes" xml:space="preserve">
          <source>See this two article about initialization order and how to cope:</source>
          <target state="translated">请看这两篇关于初始化顺序和如何应对的文章。</target>
        </trans-unit>
        <trans-unit id="e229eb46fdb8abc36ed541fd75a96ad01079842c" translate="yes" xml:space="preserve">
          <source>Simple singleton class, This must be your header class file</source>
          <target state="translated">简单的单子类,这一定是你的头类文件。</target>
        </trans-unit>
        <trans-unit id="0f5183f104a6ee7a2ee3c3f8a78ffcad0dd7ada1" translate="yes" xml:space="preserve">
          <source>Singleton instance declared as static variable of GetInstance method, is it thread-safe?</source>
          <target state="translated">Singleton实例声明为GetInstance方法的静态变量,是否是线程安全的?</target>
        </trans-unit>
        <trans-unit id="616cb2246d061aa00ec22ca9c85c492806ae00f9" translate="yes" xml:space="preserve">
          <source>Singleton: How should it be used</source>
          <target state="translated">Singleton。应该如何使用</target>
        </trans-unit>
        <trans-unit id="1ddbfa6229ac4bbfeea0426af8472583accde3ea" translate="yes" xml:space="preserve">
          <source>Static variables initialisation order</source>
          <target state="translated">静态变量的初始化顺序</target>
        </trans-unit>
        <trans-unit id="3606cc4233d18abdcf887e06f1cde5c7e5230832" translate="yes" xml:space="preserve">
          <source>That is why I prefer heap-allocated singletons. I provide an explicit &lt;code&gt;init()&lt;/code&gt; and &lt;code&gt;term()&lt;/code&gt; methods for all the singletons and call them inside &lt;code&gt;main&lt;/code&gt;. Thus I have a full control over the order of singletons creation/destruction, and also I guarantee that singletons will be created, no matter whether someone called &lt;code&gt;getInstance()&lt;/code&gt; or not.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这就是为什么我更喜欢堆分配的单例。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为所有单例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供了一个显式的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;init()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;term()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法，并将其称为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，我可以完全控制单例的创建/销毁顺序，并且我保证无论是否有人调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;getInstance()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都可以创建单例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="024eab215b08bb3333ee58e19b30d9d60b0c180e" translate="yes" xml:space="preserve">
          <source>The Singleton_destroyer will be created on program startup, and &quot;when program terminates, all global/static objects are destroyed by the runtime library shutdown code (inserted by the linker), so the_destroyer will be destroyed; its destructor will delete the Singleton, running its destructor.&quot;</source>
          <target state="translated">Singleton_destroyer将在程序启动时创建,&quot;当程序终止时,所有的全局static对象都会被运行时库的关机代码(由链接器插入)销毁,所以_destroyer将被销毁;它的destructor将删除Singleton,运行它的destructor。&quot;</target>
        </trans-unit>
        <trans-unit id="5008e6ca7deb401eab76f0a1b7199dbd571aeac8" translate="yes" xml:space="preserve">
          <source>The paper that was linked to above describes the shortcoming of double checked locking is that the compiler may allocate the memory for the object and set a pointer to the address of the allocated memory, before the object's constructor has been called. It is quite easy in c++ however to use allocaters to allocate the memory manually, and then use a construct call to initialize the memory. Using this appraoch, the double-checked locking works just fine.</source>
          <target state="translated">上面链接的那篇论文介绍了双重检查锁的缺点,就是在对象的构造函数还没有被调用之前,编译器可能会为对象分配内存,并设置一个指针到分配的内存地址。然而在C++中,使用 allocator手动分配内存,然后使用构造函数调用来初始化内存是非常容易的。使用这个appraoch,双重检查锁定就能很好地工作。</target>
        </trans-unit>
        <trans-unit id="b6f3f591e89067a6d11cf1b1060464622dca5fbe" translate="yes" xml:space="preserve">
          <source>The refs don't need to store a pointer back to their respective &lt;code&gt;Store&lt;/code&gt; because that information is supplied at compile-time. You also don't have to worry about the &lt;code&gt;Store&lt;/code&gt;'s lifetime because the compiler requires that it is global.  If there is indeed only one instance of &lt;code&gt;Store&lt;/code&gt; then there's no overhead in this approach; with more than one instance it's up to the compiler to be clever about code generation. If necessary, the &lt;code&gt;ItemRef&lt;/code&gt; class can even be made a &lt;code&gt;friend&lt;/code&gt; of &lt;code&gt;Store&lt;/code&gt; (you can have templated friends!).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ref不需要将指针存储回其各自的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为该信息是在编译时提供的。您也不必担心&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的生存期，因为编译器要求它是全局的。如果确实只有一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实例，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那么这种方法就没有开销。对于一个以上的实例，要取决于编译器的代码生成技巧。如果有必要，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ItemRef&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类甚至可以做一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;friend&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（可以有模板的朋友！）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0786d361e2bcc95d4119e640b7e9a62ee7f81d86" translate="yes" xml:space="preserve">
          <source>The solution in the accepted answer has a significant drawback - the destructor for the singleton is called after the control leaves the &lt;code&gt;main()&lt;/code&gt; function. There may be problems really, when some dependent objects are allocated inside &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;接受的答案中的解决方案有一个很大的缺点-在控件离开&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之后，调用单例的析构&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内部分配一些相关对象时，确实可能存在问题&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f40212b178fce257aced5352c8a45824c8a75d7d" translate="yes" xml:space="preserve">
          <source>The typical implementation (taken from some code I have in emacs already) would be:</source>
          <target state="translated">典型的实现(取自我已经在emacs中的一些代码)是这样的。</target>
        </trans-unit>
        <trans-unit id="56278e8448390147f165b72dfac3329a1d70ac20" translate="yes" xml:space="preserve">
          <source>The user can now create a &lt;code&gt;StoreWrapper&lt;/code&gt; type (and global instance) for each global &lt;code&gt;Store&lt;/code&gt; instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using &lt;code&gt;Store&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，用户可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为每个全局&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;实例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;StoreWrapper&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型（和全局实例）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并始终通过其包装实例访问商店（从而省去了使用&lt;/font&gt; &lt;code&gt;Store&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;所需的模板参数的繁琐细节&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e31dbd568adbc6521089b6d09e212fdb118726cc" translate="yes" xml:space="preserve">
          <source>There are two ways that I know to create a Singleton class correctly.</source>
          <target state="translated">我所知道的正确创建单人班有两种方法。</target>
        </trans-unit>
        <trans-unit id="28521cdf5fefb8ca060ab5a22e6ddfb09cef7d8c" translate="yes" xml:space="preserve">
          <source>This is about object life-time management. Suppose you have more than singletons in your software. And they depend on Logger singleton. During application destruction, suppose another singleton object uses Logger to log its destruction steps. You have to guarantee that Logger should be cleaned up last. Therefore, please also check out this paper:
&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot;&gt;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是关于对象生命周期管理的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设您的软件中有多个单例。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它们取决于Logger单例。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在应用程序销毁期间，假设另一个单例对象使用Logger记录其销毁步骤。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您必须保证Logger应该最后清理。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，也请查看以下文章：&lt;/font&gt;&lt;a href=&quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d20124031b945444d0c1fd440a24d36bac0ab7f" translate="yes" xml:space="preserve">
          <source>This is called the Meyers Singleton, created by C++ wizard Scott Meyers. Simply define get_instance() differently. Now you can also get rid of the pointer member variable.</source>
          <target state="translated">这就是所谓的Meyers Singleton,由C++向导Scott Meyers创建。只要用不同的方式定义get_instance()就可以了。现在你也可以去掉指针成员变量。</target>
        </trans-unit>
        <trans-unit id="4c22b28b3d41d395f49ea96f9637893cadacf026" translate="yes" xml:space="preserve">
          <source>This is neat because the value returned is by reference and you can use &lt;code&gt;.&lt;/code&gt; syntax instead of &lt;code&gt;-&amp;gt;&lt;/code&gt; to access member variables.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这很简洁，因为返回的值是通过引用获得的，您可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语法而不是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来访问成员变量。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3abd989834b48d9e30b53bbf5b75ed134706ae78" translate="yes" xml:space="preserve">
          <source>To use just inherit your class from this, like: &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要使用它，只需继承您的类，例如：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;class Test : public Singleton&amp;lt;Test&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abfe440688144dc3488f94a3bcdd9a80d1b0b46" translate="yes" xml:space="preserve">
          <source>We went over this topic recently in my EECS class. If you want to look at the lecture notes in detail, visit &lt;a href=&quot;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&quot;&gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们最近在EECS课堂上讨论了这个主题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果要详细查看讲义，请访问&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef46b5cc56312a21edb0f46af654cc29a8de451c" translate="yes" xml:space="preserve">
          <source>What are all the common undefined behaviours that a C++ programmer should know about?</source>
          <target state="translated">C++程序员应该知道的常见未定义行为都有哪些?</target>
        </trans-unit>
        <trans-unit id="f9481ffc9d80995ea84a632ec6be1da7a9d03648" translate="yes" xml:space="preserve">
          <source>What is the lifetime of a static variable in a C++ function?</source>
          <target state="translated">C++函数中的静态变量的寿命是多少?</target>
        </trans-unit>
        <trans-unit id="cfbba3022f0da956a8ae5155afd7fd1da6d095b2" translate="yes" xml:space="preserve">
          <source>You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.</source>
          <target state="translated">你可以避免内存分配。有很多变种,在多线程环境下都有问题。</target>
        </trans-unit>
        <trans-unit id="109c3cc202bf5d2be202483e322663f064482610" translate="yes" xml:space="preserve">
          <source>You must know that Singleton instance &lt;em&gt;doesn't need to be manually deleted by us&lt;/em&gt;. We need a single object of it throughout the whole program, so &lt;em&gt;at the end of program execution, it will be automatically deallocated.&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您必须知道Singleton实例&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不需要由我们手动删除&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们在整个程序中只需要一个对象，因此&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在程序执行结束时，它将自动释放。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c860d67c8e3dbf690743f011c26ee8f12ab81ca" translate="yes" xml:space="preserve">
          <source>Your code is correct, except that &lt;em&gt;you didn't declare the instance pointer outside the class&lt;/em&gt;. The inside class declarations of static variables are not considered declarations in C++, however this is allowed in other languages like &lt;strong&gt;C#&lt;/strong&gt; or &lt;strong&gt;Java&lt;/strong&gt; etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您的代码是正确的，除了&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您没有在class外声明实例指针&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;静态变量的内部类声明在C ++中不视为声明，但是在其他语言（例如&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C＃&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）中允许这样做&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92bd75ebd8fd2b0179172217b15350cc6d4002f0" translate="yes" xml:space="preserve">
          <source>using</source>
          <target state="translated">using</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
