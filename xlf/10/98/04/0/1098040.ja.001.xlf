<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1098040">
    <body>
      <group id="1098040">
        <trans-unit id="519517a217d707547400fa92b3393d52b8dc528e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; is the primitive value that represents the intentional absence of any object value, or in short terms, the &lt;strong&gt;confirmed&lt;/strong&gt; lack of value. On the other hand, &lt;code&gt;undefined&lt;/code&gt; is unknown value (not defined). If there is a property that will be used later with a &lt;em&gt;proper&lt;/em&gt; value consider use &lt;code&gt;null&lt;/code&gt; reference instead of &lt;code&gt;undefined&lt;/code&gt; because in the initial moment the property is &lt;strong&gt;confirmed&lt;/strong&gt; to lack a value.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; は、オブジェクト値の意図的な欠如、または短期的には、値の&lt;strong&gt;確認された&lt;/strong&gt;欠如を表すプリミティブ値です。 一方、 &lt;code&gt;undefined&lt;/code&gt; は不明な値（未定義）です。 後で&lt;em&gt;適切な&lt;/em&gt;値で使用されるプロパティがある場合は、最初の瞬間にプロパティに値がないことが&lt;strong&gt;確認さ&lt;/strong&gt;れるため、 &lt;code&gt;undefined&lt;/code&gt; ではなく &lt;code&gt;null&lt;/code&gt; 参照の使用を検討して&lt;em&gt;ください&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6cee3e35e1acd88bad0f9680a837b208eed84d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; is a special constant value.  So you can say, e.g.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; は特別な定数値です。 たとえば、次のように言うことができます</target>
        </trans-unit>
        <trans-unit id="7dd5e72bc3dd8230f447b9dc531cd7a08e403a64" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;false&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;false&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2383eb2bd66a87e2a4cd5c348c55493d9bb4a5ac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in&lt;/em&gt; operator and &lt;em&gt;hasOwnProperty&lt;/em&gt; are &quot;methods&quot; that use Property Descriptor mechanism in Javascript (similar to Java reflection in the Java language).</source>
          <target state="translated">&lt;em&gt;in&lt;/em&gt;演算子と&lt;em&gt;hasOwnProperty&lt;/em&gt;は、Javascriptのプロパティ記述子メカニズムを使用する「メソッド」です（Java言語のJavaリフレクションと同様）。</target>
        </trans-unit>
        <trans-unit id="40c4e2aba6f20ef3054aa9f6652924532338589f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;true&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;true&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6f3be30363beecac276101c94086e2fdd56bca2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;!!obj.theProperty&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;!!obj.theProperty&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad6fb95c81adc0b04b875d53f3bb20e51a78f1f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;'theProperty' in obj&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;objの「theProperty」&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c332061cf4bd899460b0a4c0a7eaa14bdb27b163" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Answer:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9108ede24ec6135336892fdeecab45ae62e7a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Explanation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b1f16ac208823b9ad05420eced587aea51038d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Results&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f3bb088e67323c8d8b4d2f82d6f9c75e019ea6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;obj.hasOwnProperty('theProperty')&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;obj.hasOwnProperty('theProperty')&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e95b6137b1dc26d6257a673e19d7ec8280859c7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;yourArray.indexOf(yourArrayKeyName) &amp;gt; -1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;yourArray.indexOf（yourArrayKeyName）&amp;gt; -1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d33250a5fbfa20daee602816ee62705f3a74f3f9" translate="yes" xml:space="preserve">
          <source>Accessing directly a missing property using (associative) array style or object style will return an &lt;em&gt;undefined&lt;/em&gt; constant.</source>
          <target state="translated">（連想）配列スタイルまたはオブジェクトスタイルを使用して欠落しているプロパティに直接アクセスすると、 &lt;em&gt;未定義の&lt;/em&gt;定数が返されます。</target>
        </trans-unit>
        <trans-unit id="dab954de02cc8e3adeae87ce15894f88ae50d047" translate="yes" xml:space="preserve">
          <source>Accessing elements directly (brackets style)</source>
          <target state="translated">要素への直接アクセス(カッコスタイル</target>
        </trans-unit>
        <trans-unit id="cac0f8526d8eeeaf1e88a433c142248c239182ba" translate="yes" xml:space="preserve">
          <source>Accessing elements directly (object style)</source>
          <target state="translated">要素への直接アクセス(オブジェクトスタイル</target>
        </trans-unit>
        <trans-unit id="9580e1f866b8cb810efbd1a60075d21c9b12406d" translate="yes" xml:space="preserve">
          <source>Advise</source>
          <target state="translated">Advise</target>
        </trans-unit>
        <trans-unit id="116d162e5036a6d9038509356dbf204094e3a269" translate="yes" xml:space="preserve">
          <source>Also see this NPM package: &lt;a href=&quot;https://www.npmjs.com/package/has-deep-value&quot;&gt;https://www.npmjs.com/package/has-deep-value&lt;/a&gt;</source>
          <target state="translated">このNPMパッケージも参照してください： &lt;a href=&quot;https://www.npmjs.com/package/has-deep-value&quot;&gt;https&lt;/a&gt; : //www.npmjs.com/package/has-deep-value</target>
        </trans-unit>
        <trans-unit id="484c6818ac76d11234ebfe88349071d160a86b4f" translate="yes" xml:space="preserve">
          <source>As people have already mentioned here, you could have an object with a property associated with an &quot;undefined&quot; constant.</source>
          <target state="translated">ここで既に言及されているように、「未定義」の定数に関連付けられたプロパティを持つオブジェクトを持つことができます。</target>
        </trans-unit>
        <trans-unit id="c2025e17a6d8b0ceb50c575a22468de823cc41ed" translate="yes" xml:space="preserve">
          <source>As people have commented, modern versions of the Javascript engines (with firefox exception) has changed the approach for access properties. Current implementation is slower than the previous one for this particular case but difference between access key and object are neglectable.</source>
          <target state="translated">コメントされているように、最近のJavascriptエンジン(Firefoxを除く)では、アクセスプロパティのアプローチが変わっています。現在の実装は、この特定のケースでは以前の実装よりも遅くなっていますが、アクセスキーとオブジェクトの違いは無視できるほどのものではありません。</target>
        </trans-unit>
        <trans-unit id="19802860ccafd0790484da9e938a84df5e02dc56" translate="yes" xml:space="preserve">
          <source>Avoid objects with &lt;code&gt;undefined&lt;/code&gt; values. Check directly whenever possible and use &lt;code&gt;null&lt;/code&gt; to initialize property values. Otherwise, use the slow &lt;code&gt;in&lt;/code&gt; operator or &lt;code&gt;hasOwnProperty()&lt;/code&gt; method.</source>
          <target state="translated">値が &lt;code&gt;undefined&lt;/code&gt; ないオブジェクトは避けてください。 可能な限り直接チェックし、 &lt;code&gt;null&lt;/code&gt; を使用してプロパティ値を初期化します。 それ以外の場合は、スロー &lt;code&gt;in&lt;/code&gt; 演算子または &lt;code&gt;hasOwnProperty()&lt;/code&gt; メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="547eb5add296d7dae2f7db9f812265ad081246ec" translate="yes" xml:space="preserve">
          <source>But,</source>
          <target state="translated">But,</target>
        </trans-unit>
        <trans-unit id="0becfe2c4668960d0e296880fc0a116e615ed692" translate="yes" xml:space="preserve">
          <source>Checking for undefined-ness is not an accurate way of testing whether a key exists. What if the key exists but the value is actually &lt;code&gt;undefined&lt;/code&gt;?</source>
          <target state="translated">undefined-nessのチェックは、キーが存在するかどうかをテストする正確な方法ではありません。 キーは存在するが値が実際には &lt;code&gt;undefined&lt;/code&gt; 場合はどうなりますか？</target>
        </trans-unit>
        <trans-unit id="bb97f78198e080fa51dc96e31746177d0a1b7395" translate="yes" xml:space="preserve">
          <source>Checking if a key exists in a JavaScript object</source>
          <target state="translated">JavaScriptオブジェクトにキーが存在するかどうかをチェックする</target>
        </trans-unit>
        <trans-unit id="ab6b4e896ea7eaaed3d3b7bd63695ed61f2bc666" translate="yes" xml:space="preserve">
          <source>Compare:</source>
          <target state="translated">Compare:</target>
        </trans-unit>
        <trans-unit id="bac41fa8996acdea0eeac7071146e860d4a300a4" translate="yes" xml:space="preserve">
          <source>Do check &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;other use of JavaScript Destructuring&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;JavaScript Destructuringの他の使用を&lt;/a&gt;確認してください</target>
        </trans-unit>
        <trans-unit id="8c98edbeeae1cf8ff6b929a6a0f7e4b52a617468" translate="yes" xml:space="preserve">
          <source>Does not check the prototype chain. (since all objects have the 'toString' method, 1 and 2 will return true on it, while 3 can return false on it.)</source>
          <target state="translated">プロトタイプチェーンをチェックしません。(すべてのオブジェクトは 'toString' メソッドを持っているので、1と2はそれに対して真を返し、3はそれに対して偽を返すことができます)。</target>
        </trans-unit>
        <trans-unit id="272b1b749b29175ccd8be91a3cef72f36a2988da" translate="yes" xml:space="preserve">
          <source>EDIT: 12/04/2018 - NOT RELEVANT ANYMORE</source>
          <target state="translated">編集:12042018-もう関係ない</target>
        </trans-unit>
        <trans-unit id="91842c0c3845e129051833509aa3157536fe9516" translate="yes" xml:space="preserve">
          <source>EDIT: What is the reason to assign to a property the &lt;code&gt;undefined&lt;/code&gt; value?</source>
          <target state="translated">編集： &lt;code&gt;undefined&lt;/code&gt; 値をプロパティに割り当てる理由は何ですか？</target>
        </trans-unit>
        <trans-unit id="e507eb360663726b7ec803640c593cbacb792539" translate="yes" xml:space="preserve">
          <source>ES6 solution</source>
          <target state="translated">イーエスエルシックスソリューション</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="d255f10a635b9aa2777665c01d1e6f11ad8653a0" translate="yes" xml:space="preserve">
          <source>For performance comparison between the methods that are &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;hasOwnProperty&lt;/code&gt; and key is &lt;code&gt;undefined&lt;/code&gt;, see this &lt;a href=&quot;http://jsben.ch/#/WqlIl&quot;&gt;&lt;strong&gt;benchmark&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">、 &lt;code&gt;hasOwnProperty&lt;/code&gt; およびkeyが &lt;code&gt;undefined&lt;/code&gt; のメソッド間のパフォーマンス比較については、この&lt;a href=&quot;http://jsben.ch/#/WqlIl&quot;&gt;&lt;strong&gt;ベンチマークを&lt;/strong&gt;&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="6a51d9e151f799cc8f82b96b8bf564cca524cb7d" translate="yes" xml:space="preserve">
          <source>For that reason, it is much better practice to first use the &lt;code&gt;in&lt;/code&gt; operator and then compare the value that is inside the key once you already know it exists.</source>
          <target state="translated">そのため、最初に &lt;code&gt;in&lt;/code&gt; 演算子を使用し、キーが既に存在することがわかったら、キーの内部にある値を比較することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c1b286568b766db19804151d364239b2983a4693" translate="yes" xml:space="preserve">
          <source>For those which have &lt;code&gt;lodash&lt;/code&gt; included in their project:</source>
          <target state="translated">プロジェクトに &lt;code&gt;lodash&lt;/code&gt; が含まれている場合：</target>
        </trans-unit>
        <trans-unit id="b01e8d047367be0b116d5989292452861f000c2d" translate="yes" xml:space="preserve">
          <source>Gets the value at path of object. If the resolved value is undefined,
  the defaultValue is returned in its place.</source>
          <target state="translated">オブジェクトのパスの値を取得します。解決された値が未定義の場合は、代わりに defaultValue が返されます。</target>
        </trans-unit>
        <trans-unit id="dabeae73ffa9b82898fbf2e0ae896b13572bd7b0" translate="yes" xml:space="preserve">
          <source>Here's a helper function I find quite useful</source>
          <target state="translated">私がとても便利だと思うヘルパー関数を紹介します。</target>
        </trans-unit>
        <trans-unit id="64344cbf98de8af9deafcc5544f6215efff6a838" translate="yes" xml:space="preserve">
          <source>How do I check if a particular key exists in a JavaScript object or array?</source>
          <target state="translated">JavaScriptオブジェクトや配列に特定のキーが存在するかどうかを確認するには?</target>
        </trans-unit>
        <trans-unit id="c6ff6c8ba9a89e1910cf47b19f592b919ca2e438" translate="yes" xml:space="preserve">
          <source>How do I check if a particular key exists in a JavaScript object or array?
  If a key doesn't exist and I try to access it, will it return false? Or throw an error?</source>
          <target state="translated">JavaScriptオブジェクトや配列に特定のキーが存在するかどうかを確認するには?キーが存在しない場合、それにアクセスしようとすると false を返しますか?それともエラーが発生しますか?</target>
        </trans-unit>
        <trans-unit id="3aa399fdccae569ce9bd6caafa430ca0222b02ac" translate="yes" xml:space="preserve">
          <source>If a key doesn't exist, and I try to access it, will it return false? Or throw an error?</source>
          <target state="translated">キーが存在しない場合、それにアクセスしようとすると false を返しますか?それともエラーを投げるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e3aba7203af978b71d93f08471a4c062b1c41459" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; library then object/array operations become simple.</source>
          <target state="translated">&lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt;ライブラリを使用している場合は、オブジェクト/配列の操作が簡単になります。</target>
        </trans-unit>
        <trans-unit id="506421cbb0a189ba09225b28b78467347bc22072" translate="yes" xml:space="preserve">
          <source>If you want to check for any key at any depth on an object and account for falsey values consider this line for a utility function:</source>
          <target state="translated">オブジェクト上の任意の深さのキーをチェックして、偽の値を考慮したい場合は、ユーティリティ関数のこの行を考えてみてください。</target>
        </trans-unit>
        <trans-unit id="197ebcc04461504aff342802b90c68b67fff9715" translate="yes" xml:space="preserve">
          <source>If you want to check if a key doesn't exist, remember to use parenthesis:</source>
          <target state="translated">キーが存在しないかどうかを確認したい場合は、括弧を使用することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="4767ea50f8d0dea7df79893a955afb013861529c" translate="yes" xml:space="preserve">
          <source>If you want to check if the object has at least one property in es2015</source>
          <target state="translated">オブジェクトがes2015で少なくとも1つのプロパティを持っているかどうかを確認したい場合は</target>
        </trans-unit>
        <trans-unit id="1a6d289d515efa919b3ce78998706215aea08f0b" translate="yes" xml:space="preserve">
          <source>In 'array' world we can look on indexes as some kind of keys. What is surprising the &lt;code&gt;in&lt;/code&gt; operator (which is good choice for object) also works with arrays. The returned value for non-existed key is &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">「配列」の世界では、インデックスをある種のキーと見なすことができます。 &lt;code&gt;in&lt;/code&gt; 演算子の驚くべきこと（オブジェクトに適した選択）も配列で機能します。 存在しないキーの戻り値は &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="635b76f22d1af237405169ff52f18ea5b7ed34a8" translate="yes" xml:space="preserve">
          <source>In that case, you will have to use &lt;em&gt;hasOwnProperty&lt;/em&gt; or &lt;em&gt;in&lt;/em&gt; operator to know if the key is really there. But, &lt;em&gt;but at what price?&lt;/em&gt;</source>
          <target state="translated">その場合、 &lt;em&gt;hasOwnProperty&lt;/em&gt;または&lt;em&gt;in&lt;/em&gt;演算子を使用して、キーが実際に存在するかどうかを確認する必要があります。 しかし、しかし、 &lt;em&gt;どのような価格で？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a59812f97ddc03dd9bb7022b5e6ae1cf75fd5899" translate="yes" xml:space="preserve">
          <source>In your case _.has method can be used. Example:</source>
          <target state="translated">その場合は _.has メソッドを使用することができます。例を示しています。</target>
        </trans-unit>
        <trans-unit id="ace4bca3b2e92937347af125445ffa35cd48f497" translate="yes" xml:space="preserve">
          <source>Is likely testing only object attribute values that are very different from array keys</source>
          <target state="translated">配列のキーとは非常に異なるオブジェクトの属性値のみをテストしている可能性が高い</target>
        </trans-unit>
        <trans-unit id="fd900217e9a325799924409fce65745b93f07e07" translate="yes" xml:space="preserve">
          <source>It will return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="efab43bf9bd925e569fa55a920f20efac0786ae3" translate="yes" xml:space="preserve">
          <source>It's been pretty reliable and works well cross-browser.</source>
          <target state="translated">かなり信頼性が高く、クロスブラウザでも問題なく動作します。</target>
        </trans-unit>
        <trans-unit id="a115e1cc35fc96c77cd0dfa0142628a4bee3b3fd" translate="yes" xml:space="preserve">
          <source>Just pass it the key you want to find, and search obj (the object or array) you want to find it in.</source>
          <target state="translated">これに検索したいキーを渡して、検索したいobj(オブジェクトや配列)を検索するだけです。</target>
        </trans-unit>
        <trans-unit id="dd830936b2f315c1e71b7c0eb4843062f657ba39" translate="yes" xml:space="preserve">
          <source>New awesome solution with &lt;strong&gt;JavaScript Destructuring&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;JavaScript Destructuring&lt;/strong&gt;を&lt;strong&gt;使用した&lt;/strong&gt;新しい素晴らしいソリューション：</target>
        </trans-unit>
        <trans-unit id="d582670184eb20dfbec6b2b998f2713d8292f0af" translate="yes" xml:space="preserve">
          <source>On the other hand, calling an object method or key will use Javascript [[Get]] mechanism. That is far way faster!</source>
          <target state="translated">一方、オブジェクトメソッドやキーを呼び出す場合は、Javascriptの[[Get]]機構を使用します。その方がはるかに速いです。</target>
        </trans-unit>
        <trans-unit id="745da0edfda252ba9371e9761d85c7c48246c395" translate="yes" xml:space="preserve">
          <source>One-line example.</source>
          <target state="translated">一行の例。</target>
        </trans-unit>
        <trans-unit id="b8132bff5731b0efdde9faa2931be30d76521970" translate="yes" xml:space="preserve">
          <source>Or, if you want to particularly test for properties of the object instance (and not inherited properties), use &lt;code&gt;hasOwnProperty&lt;/code&gt;:</source>
          <target state="translated">または、特に継承されたプロパティではなく、オブジェクトインスタンスのプロパティをテストする場合は、 &lt;code&gt;hasOwnProperty&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="45c3dc1c7731c6185824876ed514e54f71bacb64" translate="yes" xml:space="preserve">
          <source>Reference:</source>
          <target state="translated">Reference:</target>
        </trans-unit>
        <trans-unit id="d4143b60adcc66e93b5641fa050f5ed81f7b6f54" translate="yes" xml:space="preserve">
          <source>Return value as &lt;strong&gt;true&lt;/strong&gt; implies that key exists in the object.</source>
          <target state="translated">&lt;strong&gt;true&lt;/strong&gt;としての戻り値は、オブジェクトにキーが存在することを意味します。</target>
        </trans-unit>
        <trans-unit id="6bfe3a0c55e0873dec8f263aaed2bba9ddfd3bc5" translate="yes" xml:space="preserve">
          <source>That question puzzles me. In Javascript, there are at least two references for absent objects to avoid problems like this: &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">その質問は私を困惑させます。 JavaScriptでは、このような問題を回避するために、存在しないオブジェクトに対して少なくとも2つの参照があり &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7fe9ba2a314f95863f81184d3c1efed1b4071915" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://underscorejs.org/#has&quot;&gt;underscore.js&lt;/a&gt; way -</source>
          <target state="translated">&lt;a href=&quot;http://underscorejs.org/#has&quot;&gt;underscore.jsの&lt;/a&gt;方法-</target>
        </trans-unit>
        <trans-unit id="eb4d6aecd13e672a16a35097398454e1cd50dfcb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/1098955/1619432&quot;&gt;accepted answer&lt;/a&gt; refers to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object&quot;&gt;Object&lt;/a&gt;. Beware using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in&quot;&gt;&lt;code&gt;in&lt;/code&gt; operator&lt;/a&gt; on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;Array&lt;/a&gt; to find data instead of keys:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/1098955/1619432&quot;&gt;受け入れられた答え&lt;/a&gt;は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object&quot;&gt;Objectを&lt;/a&gt;指します。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;配列&lt;/a&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in&quot;&gt; &lt;code&gt;in&lt;/code&gt; 演算子&lt;/a&gt;を使用して、キーの代わりにデータを検索することに注意してください。</target>
        </trans-unit>
        <trans-unit id="a153cd380c4fb21f0dff2341fcc0edac0aed61c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator will check if the key exists in the object. If you checked if the value was undefined: &lt;code&gt;if (myObj[&quot;key&quot;] === 'undefined')&lt;/code&gt;, you could run into problems because a key could possibly exist in your object with the &lt;code&gt;undefined&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 演算子は、キーがオブジェクトに存在するかどうかを確認します。 値が未定義であるかどうかを確認した場合： &lt;code&gt;if (myObj[&quot;key&quot;] === 'undefined')&lt;/code&gt; 、キーが &lt;code&gt;undefined&lt;/code&gt; 値でオブジェクトに存在する可能性があるため、問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d5241f8e79bfc2410d2beaaf9730f6e0fc49c440" translate="yes" xml:space="preserve">
          <source>The Property Descriptor type is used to explain the manipulation and reification of named property attributes. Values of the Property Descriptor type are records composed of named fields where each field&amp;rsquo;s name is an attribute name and its value is a corresponding attribute value as specified in 8.6.1. In addition, any field may be present or absent.</source>
          <target state="translated">プロパティ記述子タイプは、名前付きプロパティ属性の操作と具体化を説明するために使用されます。 プロパティ記述子タイプの値は、名前付きフィールドで構成されるレコードであり、各フィールドの名前は属性名であり、その値は8.6.1で指定されている対応する属性値です。 さらに、任意のフィールドが存在する場合と存在しない場合があります。</target>
        </trans-unit>
        <trans-unit id="cf30e904462e4aae8cdd7b168aacd1ad1e066096" translate="yes" xml:space="preserve">
          <source>The easiest way to check is</source>
          <target state="translated">一番簡単な確認方法は</target>
        </trans-unit>
        <trans-unit id="eccfaf4f159b6f103e4ed08f52dc3742db4aa864" translate="yes" xml:space="preserve">
          <source>The result was</source>
          <target state="translated">という結果になりました。</target>
        </trans-unit>
        <trans-unit id="13f099e05e978962ca2336adeefe3db61eaeaba5" translate="yes" xml:space="preserve">
          <source>The slow and reliable &lt;em&gt;in&lt;/em&gt; operator and &lt;em&gt;hasOwnProperty&lt;/em&gt; method</source>
          <target state="translated">演算子と&lt;em&gt;hasOwnProperty&lt;/em&gt;メソッドの遅いと信頼性</target>
        </trans-unit>
        <trans-unit id="67aceb7888201fdd507d61a20469d552462e5be5" translate="yes" xml:space="preserve">
          <source>There is a lodash &lt;a href=&quot;https://lodash.com/docs/4.17.4#get&quot;&gt;_.get&lt;/a&gt; method  which tries to get &quot;deep&quot; keys:</source>
          <target state="translated">「深い」キーを取得しようとするlodash &lt;a href=&quot;https://lodash.com/docs/4.17.4#get&quot;&gt;_.get&lt;/a&gt;メソッドがあります。</target>
        </trans-unit>
        <trans-unit id="a7279aec2d48ec0145befa61c75ba5a2e06f1c8d" translate="yes" xml:space="preserve">
          <source>These example can demonstrate the differences between defferent ways. Hope it will help you to pick the right one for your needs:</source>
          <target state="translated">これらの例は、defferentの方法の違いを示すことができます。それはあなたの必要性のための右のものを選ぶのを助ける希望。</target>
        </trans-unit>
        <trans-unit id="f2a7ad11aaa38430987a75a278719d32b9fbc4f7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;keyExists(key, search)&lt;/code&gt; can be used to easily lookup a key within  objects or arrays!</source>
          <target state="translated">この &lt;code&gt;keyExists(key, search)&lt;/code&gt; を使用して、オブジェクトまたは配列内のキーを簡単に検索できます！</target>
        </trans-unit>
        <trans-unit id="e217f557ce364dce64998b7b407800bcc32871e5" translate="yes" xml:space="preserve">
          <source>This is probably the best way to check for missing keys.  However, as is pointed out in a comment below, it's theoretically possible that you'd want to have the actual value be &lt;code&gt;undefined&lt;/code&gt;.  I've never needed to do this and can't think of a reason offhand why I'd ever want to, but just for the sake of completeness, you can use the &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">これはおそらく、欠落したキーをチェックするための最良の方法です。 ただし、以下のコメントで指摘されているように、実際の値を &lt;code&gt;undefined&lt;/code&gt; にすることが理論的に可能です。 私はこれを行う必要がなかったので、私がこれまでにしたくなかった理由を考えることができませんが、完全を期すために、 &lt;code&gt;in&lt;/code&gt; 演算子を使用できます</target>
        </trans-unit>
        <trans-unit id="c8e3604f695a9f8b1fa5584d30b0d91c334f5116" translate="yes" xml:space="preserve">
          <source>This solution works best for me because I use typescript, and using strings like so &lt;code&gt;'foo' in obj&lt;/code&gt; or &lt;code&gt;obj.hasOwnProperty('foo')&lt;/code&gt; 
  to check whether a key exists or not does not provide me with intellisense.</source>
          <target state="translated">typescriptを使用し &lt;code&gt;'foo' in obj&lt;/code&gt; または &lt;code&gt;obj.hasOwnProperty('foo')&lt;/code&gt; で 'foo'のような文字列を使用してキーが存在するかどうかを確認しても、インテリセンスは提供されないため、このソリューションは私にとって最適です。</target>
        </trans-unit>
        <trans-unit id="0b44bcd403c32099bee3e6a3d6ebd539f0d28337" translate="yes" xml:space="preserve">
          <source>This will effectively check if that key, however &lt;strong&gt;deep&lt;/strong&gt;, is defined and &lt;em&gt;will not&lt;/em&gt; throw an error which might harm the flow of your program if that key is not defined.</source>
          <target state="translated">これにより、そのキーが定義されているかどうかが効果的にチェックされ、そのキーが定義されて&lt;em&gt;いない&lt;/em&gt;場合にプログラムのフローに悪影響を与える可能性のあるエラーがスローされません。</target>
        </trans-unit>
        <trans-unit id="04a17a364ca132f362dfda3ce086d3904a604016" translate="yes" xml:space="preserve">
          <source>Three ways to check if a property is present in a javascript object:</source>
          <target state="translated">javascriptのオブジェクトにプロパティが存在するかどうかを確認する3つの方法。</target>
        </trans-unit>
        <trans-unit id="f99da6036e454edfd993c0213467c52e9cfe7c5f" translate="yes" xml:space="preserve">
          <source>To test existing elements in an Array: &lt;a href=&quot;https://stackoverflow.com/questions/143847/best-way-to-find-an-item-in-a-javascript-array&quot;&gt;Best way to find if an item is in a JavaScript array?&lt;/a&gt;</source>
          <target state="translated">配列内の既存の要素をテストするには： &lt;a href=&quot;https://stackoverflow.com/questions/143847/best-way-to-find-an-item-in-a-javascript-array&quot;&gt;アイテムがJavaScript配列内にあるかどうかを確認する最良の方法は？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3123a22dd221942534d6208cb1e60c6c71d8ffa" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;in&lt;/em&gt; operator</source>
          <target state="translated">演算子での使用</target>
        </trans-unit>
        <trans-unit id="f86614f10a31f1f570d64c3b5a17bf9cca50d526" translate="yes" xml:space="preserve">
          <source>Using hasOwnProperty</source>
          <target state="translated">hasOwnPropertyの使用</target>
        </trans-unit>
        <trans-unit id="2eec541a006f6b09e686f7436683abe3e6d845ad" translate="yes" xml:space="preserve">
          <source>We can use - &lt;code&gt;hasOwnProperty.call(obj, key);&lt;/code&gt;</source>
          <target state="translated">使用できます &lt;code&gt;hasOwnProperty.call(obj, key);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a067fe8a55b6144d51f2d530845ff0dc8ca6d704" translate="yes" xml:space="preserve">
          <source>While this doesn't necessarily check if a key exists, it does check for the truthiness of a value. Which &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; fall under.</source>
          <target state="translated">これは必ずしもキーが存在するかどうかをチェックするわけではありませんが、値の真正性をチェックします。 &lt;code&gt;undefined&lt;/code&gt; と &lt;code&gt;null&lt;/code&gt; のどちらに該当するか。</target>
        </trans-unit>
        <trans-unit id="457bff231268164f32510ef666da9107b349ede2" translate="yes" xml:space="preserve">
          <source>Will convert value to bool. returns TRUE for all but the 'false' value</source>
          <target state="translated">値を bool に変換します。</target>
        </trans-unit>
        <trans-unit id="2fed6708a323c378f4a3a12917f1c5363d03d335" translate="yes" xml:space="preserve">
          <source>Will return true if the property exists, no matter its value (even empty)</source>
          <target state="translated">プロパティが存在する場合は、その値に関わらず(空であっても)真を返します。</target>
        </trans-unit>
        <trans-unit id="eac56352850ccb3acbc7e16d5bf1803ccf3abb1e" translate="yes" xml:space="preserve">
          <source>You should instead use the &lt;code&gt;in&lt;/code&gt; operator:</source>
          <target state="translated">代わりに &lt;code&gt;in&lt;/code&gt; 演算子を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="fc38e4aeb7a5b66c5616d1fa21a41af646fb7594" translate="yes" xml:space="preserve">
          <source>benchmark</source>
          <target state="translated">benchmark</target>
        </trans-unit>
        <trans-unit id="07d20acd3d6d3a65dab86aac1963f8fc7266dde3" translate="yes" xml:space="preserve">
          <source>for example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="a1389338d08e6248cae8a563fa79ff7a162f904f" translate="yes" xml:space="preserve">
          <source>quick answer</source>
          <target state="translated">即答</target>
        </trans-unit>
        <trans-unit id="2591d4a035f0e656adc70efd7854b78cb4e0c7b1" translate="yes" xml:space="preserve">
          <source>returns &lt;strong&gt;false&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;falseを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9faec3bddf2b4f017257e503cfb75e48f2fc3027" translate="yes" xml:space="preserve">
          <source>returns &lt;strong&gt;true&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;trueを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad0b98958a31a215cba31be4bf81cc9aebb12feb" translate="yes" xml:space="preserve">
          <source>so, I tell you...</source>
          <target state="translated">だから</target>
        </trans-unit>
        <trans-unit id="0a9c48942216c4967e64d4915aacd84115cacc3b" translate="yes" xml:space="preserve">
          <source>using &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Obiekty/Array/some&quot;&gt;&lt;code&gt;Array#some&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;. It will return &lt;strong&gt;true&lt;/strong&gt; if given key exists in the object or &lt;strong&gt;false&lt;/strong&gt; if it doesn't.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Obiekty/Array/some&quot;&gt; &lt;code&gt;Array#some&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;と&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys&lt;/code&gt; を使用し&lt;/a&gt;&lt;/strong&gt;ます。 指定されたキーがオブジェクトに存在する場合は&lt;strong&gt;true&lt;/strong&gt;を返し、存在しない場合は&lt;strong&gt;false&lt;/strong&gt;を返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="16b8e8b30c3eb529dc4b9960c99b9ecbb67dd4c9" translate="yes" xml:space="preserve">
          <source>vanila js</source>
          <target state="translated">バニラJS</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
