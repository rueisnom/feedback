<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/10636611">
    <body>
      <group id="10636611">
        <trans-unit id="79b3ba11b449f653cf94ea42d31d8665cb70305e" translate="yes" xml:space="preserve">
          <source>&quot;How do we get around it?&quot; Have the server tell the request that CORS is OK.</source>
          <target state="translated">&quot;どうやって回避する?&quot; サーバーにCORSがOKであることを リクエストに伝えさせます。</target>
        </trans-unit>
        <trans-unit id="922d106809a27f5ea5725cbecf04bcf0394fbc75" translate="yes" xml:space="preserve">
          <source>&quot;Why don't we just block the browser from doing that?&quot; Yep. CORS.</source>
          <target state="translated">&quot;ブラウザをブロックすればいいんじゃない?&quot; そうだな そうだな</target>
        </trans-unit>
        <trans-unit id="8cce81f32d4f3933a9d189ba04d55f2214ac9ccf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;Wikipedia&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;Wikipedia&lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="a4a8b5194f78b6038b34fcb3aaefa3c75ec70357" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; is a &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/cors/&quot;&gt;CORS (Cross-Origin Resource Sharing) header&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; は&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/cors/&quot;&gt;CORS（Cross-Origin Resource Sharing）ヘッダー&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="c09130b0fcfe3404570f3cf7d450decda7ec406d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Content-Type&lt;/code&gt; (this is only simple when its value is &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;Content-Type&lt;/code&gt; （値が &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 、 &lt;code&gt;multipart/form-data&lt;/code&gt; 、または &lt;code&gt;text/plain&lt;/code&gt; の場合のみ、これは単純です ）</target>
        </trans-unit>
        <trans-unit id="31c8c8b02a31794b56f4026cc609f63ad40bb60d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https://cors-anywhere.herokuapp.com/&lt;/code&gt; + &lt;code&gt;Your API URL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;https://cors-anywhere.herokuapp.com/&lt;/code&gt; + &lt;code&gt;Your API URL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85bb5e6604df9c285a25a74cf794fab003bbd6a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;1. A client downloads javascript code MyCode.js from &lt;a href=&quot;http://siteA&quot;&gt;http://siteA&lt;/a&gt; - the origin.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;1.クライアントが&lt;a href=&quot;http://siteA&quot;&gt;http：// siteA-&lt;/a&gt;オリジンからJavaScriptコードMyCode.jsをダウンロードします。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e67c2a45dcc374cf1513c3c3847ca0329605f44f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;2. The response header of MyCode.js contains Access-Control-Allow-Origin: &lt;a href=&quot;http://siteB&quot;&gt;http://siteB&lt;/a&gt;, which I thought meant that MyCode.js was allowed to make cross-origin references to the site B.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;2. MyCode.jsの応答ヘッダーにはAccess-Control-Allow-Origin： &lt;a href=&quot;http://siteB&quot;&gt;http：//&lt;/a&gt; siteBが含まれています。これは、MyCode.jsがサイトBへのクロスオリジン参照を作成することを許可されていることを意味していました。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e72ad7b755a692bece6c7ac0d6f5e50584dca43a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DomainA AJAX request headers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DomainA AJAXリクエストヘッダー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d140b20d9bc077421ada900ec804924f2dd7508c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DomainB response headers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DomainB応答ヘッダー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="43b44e358ed9ab663aff14a7eb3cb779b17abc1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key point:&lt;/strong&gt; When a client makes a request to the server, it will send the cookies stored under that domain.</source>
          <target state="translated">&lt;strong&gt;重要なポイント：&lt;/strong&gt;クライアントがサーバーにリクエストを行うと、そのドメインに保存されているCookieが送信されます。</target>
        </trans-unit>
        <trans-unit id="451ed0d1faeb007761b9f1f6e5c819251b69932c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Mechanism&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;メカニズム&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="458265a655ab105933b08a0c271497ca9d12a196" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this must have before all router&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;これはすべてのルータの前にある必要があります&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="3144daeec601dcd1b43f2a37773bb3e0722f2c8f" translate="yes" xml:space="preserve">
          <source>A client downloads javascript code MyCode.js from http://siteA - &lt;strong&gt;the origin&lt;/strong&gt;.</source>
          <target state="translated">クライアントは、http：// siteA-オリジンからJavaScriptコードMyCode.jsをダウンロードします。</target>
        </trans-unit>
        <trans-unit id="b487ed479c5653fe0a2624288946f1c8ef051bd4" translate="yes" xml:space="preserve">
          <source>A resource makes a &lt;strong&gt;cross-origin HTTP request&lt;/strong&gt; when it requests a resource from a different domain, or port than the one which the first resource itself serves.</source>
          <target state="translated">リソースは、最初のリソース自体が提供するドメインまたはポートとは異なるドメインまたはポートからのリソースを要求すると、 &lt;strong&gt;クロスオリジンHTTP要求を作成&lt;/strong&gt;します。</target>
        </trans-unit>
        <trans-unit id="ce0f87926e811ddf23f0d196ca75fb63d5c3ead6" translate="yes" xml:space="preserve">
          <source>A response that tells the browser to allow code from any origin to
  access a resource will include the following:</source>
          <target state="translated">ブラウザがリソースへのアクセスを許可するように指示するレスポンスには、以下のようなものが含まれます。</target>
        </trans-unit>
        <trans-unit id="ba3428e2ff13f1e68025f1c48520f8917410ea5c" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;this&lt;/a&gt; Mozilla Developer Network article,</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;この&lt;/a&gt; Mozilla Developer Networkの記事によると、</target>
        </trans-unit>
        <trans-unit id="bf23c326dd333575e69254167b04cd66436a8ddf" translate="yes" xml:space="preserve">
          <source>Although some validation and authorization can be performed by the server, &lt;strong&gt;it is generally the browser's responsibility&lt;/strong&gt; to support these headers and honor the restrictions they impose.</source>
          <target state="translated">一部の検証と承認はサーバーで実行できますが、 &lt;strong&gt;通常、&lt;/strong&gt;これらのヘッダーをサポートし、それらが課す制限を守るの&lt;strong&gt;はブラウザの責任&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="35cb55e5ed57188c2c958286ec803a59b4bb54db" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; (ACAO) header in its response indicating which origin sites are allowed.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; れているオリジンサイトを示す応答のAccess-Control-Allow-Origin （ACAO）ヘッダー。</target>
        </trans-unit>
        <trans-unit id="4a79c7e5f70a613673420444f94f034d8ff57aa2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; (ACAO) header with a wildcard that allows all domains:</source>
          <target state="translated">すべてのドメインを許可するワイルドカード付きの &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; （ACAO）ヘッダー：</target>
        </trans-unit>
        <trans-unit id="181e454044a5f8794317a9184ef7086fe1502149" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;HTML page&lt;/strong&gt; served from &lt;code&gt;http://domain-a.com&lt;/code&gt; makes an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; src request for &lt;code&gt;http://domain-b.com/image.jpg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;http://domain-a.com&lt;/code&gt; から提供される&lt;strong&gt;HTMLページ&lt;/strong&gt;は、 http://domain-b.com/image.jpgに対する &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; srcリクエストを作成し &lt;code&gt;http://domain-b.com/image.jpg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b609b5a98435feed729bf00208beca36f266c405" translate="yes" xml:space="preserve">
          <source>An error page if the server does not allow the cross-origin request</source>
          <target state="translated">サーバーがクロスオリジンリクエストを許可していない場合のエラーページ</target>
        </trans-unit>
        <trans-unit id="2aa81cf349bfa1a844c8cd05dff5a9ad245bf1b1" translate="yes" xml:space="preserve">
          <source>An example story: On your computer, there's a cookie for &lt;code&gt;yourbank.com&lt;/code&gt;. Maybe your session is in there.</source>
          <target state="translated">事例の例：あなたのコンピューターに &lt;code&gt;yourbank.com&lt;/code&gt; の cookieがあります。 多分あなたのセッションはそこにあります。</target>
        </trans-unit>
        <trans-unit id="b97580e9a4d93057941cecbf72a8e5d77baa599d" translate="yes" xml:space="preserve">
          <source>And the server sends back an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;, just as it would for a simple request:</source>
          <target state="translated">そしてサーバーは、単純なリクエストの場合と同様に、 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; を送り返します。</target>
        </trans-unit>
        <trans-unit id="bbcce9482362cd9d846f8ef9260df5096f61aefb" translate="yes" xml:space="preserve">
          <source>Apparently, I have completely misunderstood its semantics. I thought of something like this:</source>
          <target state="translated">どうやら私はその意味を完全に誤解していたようです 私はこんなことを考えました</target>
        </trans-unit>
        <trans-unit id="9c0a94e83fa3f4a9ba8e76553be179ce0c84ddf9" translate="yes" xml:space="preserve">
          <source>As I mentioned above, W3 recommended browser to implement a &quot;&lt;strong&gt;preflight request&lt;/strong&gt;&quot; before submiting the actually Cross-Origin HTTP request, in a nutshell it is an HTTP &lt;code&gt;OPTIONS&lt;/code&gt; request:</source>
          <target state="translated">上で述べたように、W3は実際にクロスオリジンのHTTPリクエストを送信する前に「 &lt;strong&gt;プリフライトリクエスト&lt;/strong&gt; 」を実装するようブラウザに推奨しました。簡単に言えば、これはHTTP &lt;code&gt;OPTIONS&lt;/code&gt; リクエストです。</target>
        </trans-unit>
        <trans-unit id="18fc2f97599c6123f77e230a7df453afa9545e6c" translate="yes" xml:space="preserve">
          <source>Cross-Origin Resource Sharing (CORS)</source>
          <target state="translated">クロスオリジンリソースシェアリング(CORS)</target>
        </trans-unit>
        <trans-unit id="cd4c33b899fc233fd73d75ce9074d02da1ac4b4d" translate="yes" xml:space="preserve">
          <source>Cross-Origin Resource Sharing - &lt;code&gt;CORS&lt;/code&gt; (A.K.A. Cross-Domain AJAX request) is an issue that most web developers might encounter, according to Same-Origin-Policy, browsers restrict client JavaScript in a security sandbox, usually JS cannot directly communicate with a remote server from a different domain. In the past developers created many tricky ways to achieve Cross-Domain resource request, most commonly using ways are:</source>
          <target state="translated">クロスオリジンリソースシェアリング &lt;code&gt;CORS&lt;/code&gt; （別名クロスドメインAJAXリクエスト）は、ほとんどのWeb開発者が遭遇する可能性のある問題であり、Same-Origin-Policyによると、ブラウザーはセキュリティサンドボックス内のクライアントJavaScriptを制限します。通常、JSはリモートと直接通信できません。別のドメインのサーバー。 過去に、開発者はクロスドメインリソースリクエストを実現するための多くのトリッキーな方法を作成しましたが、最も一般的に使用されている方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="011fc91df492b0380e17a87ee2e66441e70c4e0f" translate="yes" xml:space="preserve">
          <source>Embeds remote server in an iframe and communicate through fragment or window.name, refer &lt;a href=&quot;http://www.ibm.com/developerworks/library/wa-crossdomaincomm/#N10120&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">リモートサーバーをiframeに埋め込み、フラグメントまたはwindow.nameを介して通信し&lt;a href=&quot;http://www.ibm.com/developerworks/library/wa-crossdomaincomm/#N10120&quot;&gt;ます&lt;/a&gt; 。 ここを参照してください 。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="c55d6bc880c85b7ddccab1864214b1926c931775" translate="yes" xml:space="preserve">
          <source>For cross origin sharing, set header: &lt;code&gt;'Access-Control-Allow-Origin':'*';&lt;/code&gt;</source>
          <target state="translated">クロスオリジン共有の場合、ヘッダーを設定します： &lt;code&gt;'Access-Control-Allow-Origin':'*';&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d1c001eb437a4a4ce15ecea22bb7619b01e35aa" translate="yes" xml:space="preserve">
          <source>For each resource/page that Site B wants to make accessible to Site A, Site B should serve its pages with the response header:</source>
          <target state="translated">サイトBがサイトAにアクセスできるようにしたい各リソースページに対して、サイトBはそのページをレスポンスヘッダーで提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="448733166bdf64413416b6944ad16b39bf49185a" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and &lt;code&gt;Fetch&lt;/code&gt; follow the &lt;strong&gt;same-origin policy&lt;/strong&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;XMLHttpRequest&lt;/code&gt; と &lt;code&gt;Fetch&lt;/code&gt; は、 &lt;strong&gt;同じ生成元のポリシーに&lt;/strong&gt;従います。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="2ac76251686f22fcdbe32b54806e17b5c620fa63" translate="yes" xml:space="preserve">
          <source>For more info, visit &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin&quot;&gt;here&lt;/a&gt;....</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin&quot;&gt;こちらを&lt;/a&gt;ご覧ください ....</target>
        </trans-unit>
        <trans-unit id="c434a7a5f602c383de2c018c1b0444a3ea8fbb96" translate="yes" xml:space="preserve">
          <source>For more specific examples see the documentation. I have used the simple example above to get around the CORS issue in an ionic application I am building that has to access a separate flask server.</source>
          <target state="translated">より具体的な例については、ドキュメントを参照してください。別々のフラスコサーバーにアクセスする必要がある、私が構築している ionic アプリケーションで CORS 問題を回避するために、上記の簡単な例を使用しました。</target>
        </trans-unit>
        <trans-unit id="da1bd7e32d017921022d548d7ad4d638f61ae61e" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict &lt;strong&gt;cross-origin HTTP&lt;/strong&gt; requests &lt;strong&gt;initiated from within scripts&lt;/strong&gt;.</source>
          <target state="translated">セキュリティ上の理由から、ブラウザ&lt;strong&gt;はスクリプト内から開始さ&lt;/strong&gt;れた&lt;strong&gt;クロスオリジンHTTP&lt;/strong&gt;リクエストを制限&lt;strong&gt;します&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6d0578bc5e77903d01a8d5a163a1d8888a0ad92" translate="yes" xml:space="preserve">
          <source>From a high level we can simply deem CORS is a contract between client AJAX call from domain A and a page hosted on domain B, a typical Cross-Origin request/response would be:</source>
          <target state="translated">高レベルから我々は単にCORSは、ドメインAからのクライアントAJAXコールとドメインB上でホストされているページの間の契約であるとみなすことができます、典型的なクロスオリジンのrequestresponseは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="6edd5efadce6bfaad382d3cb5bd545a64ef9e2c0" translate="yes" xml:space="preserve">
          <source>From my own experience, it's hard to find a simple explanation why CORS is even a concern.</source>
          <target state="translated">私の経験からすると、なぜCORSが気になるのかさえも簡単に説明できません。</target>
        </trans-unit>
        <trans-unit id="1727a759182c88301c3e81d2fbbe9997d5ed21c4" translate="yes" xml:space="preserve">
          <source>How CORS works (&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header)</source>
          <target state="translated">CORSのしくみ（ &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダー）</target>
        </trans-unit>
        <trans-unit id="c8cc4076ef7542bc5aed83b4de859cfb8a1094e1" translate="yes" xml:space="preserve">
          <source>How does Access-Control-Allow-Origin header work</source>
          <target state="translated">Access-Control-Allow-Originヘッダの仕組み</target>
        </trans-unit>
        <trans-unit id="7ababbc9fc0b6cccf17b2439c963b15cce41b12d" translate="yes" xml:space="preserve">
          <source>I blogged about CORS three years ago: &lt;a href=&quot;http://wayneye.com/Blog/Ajax-Cross-Origin-HTTP-request&quot;&gt;AJAX Cross-Origin HTTP request&lt;/a&gt;</source>
          <target state="translated">3年前にCORSについてブログに投稿しました： &lt;a href=&quot;http://wayneye.com/Blog/Ajax-Cross-Origin-HTTP-request&quot;&gt;AJAX Cross-Origin HTTP request&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6d70cc5a4760303b495e7652f8245f1fe3b0fb9" translate="yes" xml:space="preserve">
          <source>I do not want to utilize JSONP.</source>
          <target state="translated">JSONPを利用したくない。</target>
        </trans-unit>
        <trans-unit id="d09fde375f0cd87d20979405e3d38cb1e221db9d" translate="yes" xml:space="preserve">
          <source>I have full control of both site A and site B. How do I enable the javascript code downloaded from the site A to access resources on the site B using this header?</source>
          <target state="translated">サイトAとサイトBの両方を完全に制御しています。サイトAからダウンロードしたjavascriptのコードが、このヘッダーを使用してサイトBのリソースにアクセスできるようにするにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="9ab469e49ab007a1f4aca272e24988f133d0239d" translate="yes" xml:space="preserve">
          <source>I saw a lot of added this headers:</source>
          <target state="translated">このヘッダーを追加したのをたくさん見ました。</target>
        </trans-unit>
        <trans-unit id="bcfe019fd908beb42af7ba76dea547996805d921" translate="yes" xml:space="preserve">
          <source>I think the reason for my bad intuition is the point of view I have when developing a site. It's &lt;strong&gt;my&lt;/strong&gt; site, with all &lt;strong&gt;my&lt;/strong&gt; JavaScript, therefore it isn't doing anything malicious and it should be up to &lt;strong&gt;me&lt;/strong&gt; to specify which other sites &lt;strong&gt;my&lt;/strong&gt; JavaScript can interact with. When in fact I should be thinking which &lt;strong&gt;other&lt;/strong&gt; sites JavaScript are trying to interact with my site and should I use CORS to allow them?</source>
          <target state="translated">私の直感が悪いのは、サイトを開発するときの視点だと思います。 これは&lt;strong&gt;私の&lt;/strong&gt;サイトであり、すべて&lt;strong&gt;の&lt;/strong&gt; JavaScriptを使用し&lt;strong&gt;て&lt;/strong&gt;いるため、悪意のあることは何も行ってい&lt;strong&gt;ません&lt;/strong&gt; 。JavaScriptが対話できる他のサイトを指定するのは&lt;strong&gt;私&lt;/strong&gt;次第&lt;strong&gt;です&lt;/strong&gt; 。 実際に、JavaScriptが自分のサイトとやり取りしようとしている&lt;strong&gt;他の&lt;/strong&gt;サイトを考えるべきであり、CORSを使用してそれらを許可する必要があるのですか？</target>
        </trans-unit>
        <trans-unit id="ea75fc450491732817d81c5e6ba7c55e53aaaf8c" translate="yes" xml:space="preserve">
          <source>If another client makes a &lt;em&gt;cross origin&lt;/em&gt; request to a server, those cookies are sent along, just as before.  Ruh roh.</source>
          <target state="translated">別のクライアントがサーバーに対して&lt;em&gt;クロスオリジン&lt;/em&gt;要求を行う場合、これらのCookieは以前と同様に送信されます。 ルーロ。</target>
        </trans-unit>
        <trans-unit id="0fbef03b48408fe4be85b4fd43c89fcb90ea9874" translate="yes" xml:space="preserve">
          <source>If foo.aspx supports OPTIONS HTTP verb, it might return response like below:</source>
          <target state="translated">foo.aspxがOPTIONS HTTP verbをサポートしている場合、以下のようなレスポンスを返すかもしれません。</target>
        </trans-unit>
        <trans-unit id="82d42f9e57a8e7c74c1875653db07a225efbc513" translate="yes" xml:space="preserve">
          <source>If the server responds to the OPTIONS preflight with appropriate response headers (&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; for non-simple headers, &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; for non-simple verbs) that match the non-simple verb and/or non-simple headers, then the browser sends the actual request.</source>
          <target state="translated">サーバーが適切な応答ヘッダー（非単純ヘッダーの場合は &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 、非単純動詞の場合は &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; ）を使用してOPTIONSプリフライトに応答する場合、非単純動詞および/または非-simpleヘッダーの場合、ブラウザは実際のリクエストを送信します。</target>
        </trans-unit>
        <trans-unit id="b209912bc039e43f1ba2a6ad10304105e971e755" translate="yes" xml:space="preserve">
          <source>If you are using PHP, try adding the following code at the beginning of the php file:</source>
          <target state="translated">PHPをお使いの方は、PHPファイルの先頭に以下のコードを追加してみてください。</target>
        </trans-unit>
        <trans-unit id="012b5bc6588408b5759125ca431dc0ee67a011c5" translate="yes" xml:space="preserve">
          <source>If you are using external domains such as server, try this:</source>
          <target state="translated">サーバーなどの外部ドメインを使用している場合は、こちらを試してみてください。</target>
        </trans-unit>
        <trans-unit id="fac656ade96604b1bb74bdc54813902f91db4ff2" translate="yes" xml:space="preserve">
          <source>If you are using localhost, try this:</source>
          <target state="translated">localhostを使用している場合は、これを試してみてください。</target>
        </trans-unit>
        <trans-unit id="fa242605a7d86095b9190396fd9364feb7753098" translate="yes" xml:space="preserve">
          <source>If you want just to test a cross domain application in which the browser blocks your request, then you can just open your browser in unsafe mode and test your application without changing your code and without making your code unsafe.
From MAC OS you can do this from the terminal line:</source>
          <target state="translated">ブラウザがリクエストをブロックするクロスドメインアプリケーションをテストしたい場合は、ブラウザを安全でないモードで開き、コードを変更せずに、コードを安全でない状態にすることなく、アプリケーションをテストすることができます。MAC OSからはターミナルラインからこれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="511761e5536cf8f170218acc8981aa0ecce25b0b" translate="yes" xml:space="preserve">
          <source>In Python I have been using the &lt;a href=&quot;https://flask-cors.readthedocs.io/en/latest/&quot;&gt;&lt;code&gt;Flask-CORS&lt;/code&gt; library&lt;/a&gt; with great success. It makes dealing with CORS super easy and painless. I added some code from the library's documentation below.</source>
          <target state="translated">Pythonでは、 &lt;a href=&quot;https://flask-cors.readthedocs.io/en/latest/&quot;&gt; &lt;code&gt;Flask-CORS&lt;/code&gt; ライブラリ&lt;/a&gt;を使用して大きな成功を収めてきました。 CORSを非常に簡単かつ簡単に扱うことができます。 以下のライブラリのドキュメントからコードをいくつか追加しました。</target>
        </trans-unit>
        <trans-unit id="ecb9b7c454fe20235af87d4ec8e149d40f0c3d94" translate="yes" xml:space="preserve">
          <source>Installing:</source>
          <target state="translated">Installing:</target>
        </trans-unit>
        <trans-unit id="59923435fe33e2e35eb67133c1bb2118e8264bb1" translate="yes" xml:space="preserve">
          <source>It's all about cookies. Cookies are stored on a client by their domain.</source>
          <target state="translated">クッキーのことです。クッキーは、そのドメインによってクライアントに保存されます。</target>
        </trans-unit>
        <trans-unit id="036bc79e753677ceaeb2e07cdc182e7630df8ef3" translate="yes" xml:space="preserve">
          <source>JSON With Padding (&lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt;).</source>
          <target state="translated">JSON With Padding（ &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ca44019ded082daf451d8d84c802691d29ea6475" translate="yes" xml:space="preserve">
          <source>Just by adding the Proxy link will work, but it can also throw error for No Access again. Hence better to add header as shown below.</source>
          <target state="translated">Proxyのリンクを追加するだけで動作しますが、再度アクセス禁止のエラーを出すこともあります。そのため、以下のようにヘッダを追加します。</target>
        </trans-unit>
        <trans-unit id="990982cfd7f5181c1c4b59985f6c17c7572a78da" translate="yes" xml:space="preserve">
          <source>Many pages on the web today load resources like &lt;strong&gt;CSS stylesheets&lt;/strong&gt;, &lt;strong&gt;images&lt;/strong&gt; and &lt;strong&gt;scripts&lt;/strong&gt; from separate domains (thus it should be cool).</source>
          <target state="translated">今日のWeb上の多くのページは、 &lt;strong&gt;CSSスタイルシート&lt;/strong&gt; 、 &lt;strong&gt;画像&lt;/strong&gt; 、 &lt;strong&gt;スクリプト&lt;/strong&gt;などのリソースを個別のドメインからロードしています（そのため、すばらしいはずです）。</target>
        </trans-unit>
        <trans-unit id="42aa7d0d1e4cb56cb1cdea6f9ad0ab375346d78d" translate="yes" xml:space="preserve">
          <source>Modern browsers use &lt;strong&gt;CORS&lt;/strong&gt; in an &lt;strong&gt;API container&lt;/strong&gt; - such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;code&gt;Fetch&lt;/code&gt; - to mitigate risks of cross-origin HTTP requests.</source>
          <target state="translated">最新のブラウザーは、 &lt;code&gt;XMLHttpRequest&lt;/code&gt; や &lt;code&gt;Fetch&lt;/code&gt; などの&lt;strong&gt;APIコンテナーで&lt;/strong&gt; &lt;strong&gt;CORS&lt;/strong&gt;を使用して、クロスオリジンHTTPリクエストのリスクを軽減します。</target>
        </trans-unit>
        <trans-unit id="c158f1129e2a1e2d82881627004ee2f4629d1c66" translate="yes" xml:space="preserve">
          <source>Modern browsers will not block cross-domain requests outright.  If Site A requests a page from Site B, the browser will actually fetch the requested page &lt;em&gt;on the network level&lt;/em&gt; and check if the response headers list Site A as a permitted requester domain.  If Site B has not indicated that Site A is allowed to access this page, the browser will trigger the &lt;code&gt;XMLHttpRequest&lt;/code&gt;'s &lt;code&gt;error&lt;/code&gt; event and  deny the response data to the requesting JavaScript code.</source>
          <target state="translated">最新のブラウザは、クロスドメインリクエストを完全にブロックしません。 サイトAがサイトBからページをリクエストすると、ブラウザは実際に&lt;em&gt;ネットワークレベルで&lt;/em&gt;リクエストされたページ&lt;em&gt;を&lt;/em&gt;フェッチし、応答ヘッダーにサイトAが許可されたリクエスタドメインとしてリストされているかどうかを確認します。 サイトAがこのページへのアクセスを許可されていることをサイトBが示していない場合、ブラウザーは &lt;code&gt;XMLHttpRequest&lt;/code&gt; の &lt;code&gt;error&lt;/code&gt; イベントをトリガーし、要求しているJavaScriptコードへの応答データを拒否します。</target>
        </trans-unit>
        <trans-unit id="76e7b7d6dbafadc7d02482466d004be762003b16" translate="yes" xml:space="preserve">
          <source>Node: &lt;code&gt;app.use('Access-Control-Allow-Origin':'*');&lt;/code&gt;</source>
          <target state="translated">ノード： &lt;code&gt;app.use('Access-Control-Allow-Origin':'*');&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0774d4e9c921c6d51ae15b2d71eb985b886205bd" translate="yes" xml:space="preserve">
          <source>Non-simple requests</source>
          <target state="translated">シンプルでないリクエスト</target>
        </trans-unit>
        <trans-unit id="c17d4be261192d21bdacbfa184e2f727114899f3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; and &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; are added by the browser automatically; you do not need to add them. This OPTIONS preflight gets the successful response headers:</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Method&lt;/code&gt; および &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; は、ブラウザーによって自動的に追加されることに注意してください。 それらを追加する必要はありません。 このOPTIONSプリフライトは、成功した応答ヘッダーを取得します。</target>
        </trans-unit>
        <trans-unit id="bca29b4c27957d6c5a6dfc00cdfff94aa12e7ae5" translate="yes" xml:space="preserve">
          <source>Noted that, you have to paste the following code under &lt;code&gt;&amp;lt;system.webServer&amp;gt;&lt;/code&gt; tag</source>
          <target state="translated">&lt;code&gt;&amp;lt;system.webServer&amp;gt;&lt;/code&gt; タグの下に次のコードを貼り付ける必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f2b757a60b81b0610f7e0143768cb1bf5f5771cb" translate="yes" xml:space="preserve">
          <source>Once you understand why it's there, the headers and discussion becomes a lot clearer.  I'll give it a shot in a few lines.</source>
          <target state="translated">なぜそこにあるのかを理解すると、ヘッダーや議論がかなり明確になります。数行でやってみます。</target>
        </trans-unit>
        <trans-unit id="b9fd5fe1077f37c5e40b6997c12d1c88618c93ec" translate="yes" xml:space="preserve">
          <source>One thing is sure - I still do not understand how am I supposed to use this header.</source>
          <target state="translated">一つ確かなことは-私はまだこのヘッダーをどのように使用することになっているのか理解していません。</target>
        </trans-unit>
        <trans-unit id="0c524bfd8fb631d16e1066def5e7ed1f33a402d3" translate="yes" xml:space="preserve">
          <source>Only if the response contains &quot;Access-Control-Allow-Origin&quot; AND its value is &quot;*&quot; or contain the domain who submitted the CORS request, by satisfying this mandtory condition browser will submit the actual Cross-Domain request, and cache the result in &quot;&lt;strong&gt;Preflight-Result-Cache&lt;/strong&gt;&quot;.</source>
          <target state="translated">応答に「Access-Control-Allow-Origin」が含まれ、その値が「*」であるか、CORSリクエストを送信したドメインが含まれている場合にのみ、この必須条件を満たしているブラウザは実際のクロスドメインリクエストを送信し、結果をキャッシュします「 &lt;strong&gt;プリフライト結果キャッシュ&lt;/strong&gt; 」</target>
        </trans-unit>
        <trans-unit id="cba4c2393e21aee27e3e96781ebdf9c4f329b911" translate="yes" xml:space="preserve">
          <source>Origin: &lt;a href=&quot;http://www.example.com&quot;&gt;http://www.example.com&lt;/a&gt;</source>
          <target state="translated">起源： &lt;a href=&quot;http://www.example.com&quot;&gt;http&lt;/a&gt; : //www.example.com</target>
        </trans-unit>
        <trans-unit id="42682c0cef7e29104cf2fb7a57155baed6c873a6" translate="yes" xml:space="preserve">
          <source>P.S.</source>
          <target state="translated">P.S.</target>
        </trans-unit>
        <trans-unit id="ef3b9fb63ad4f41fc921c9eb7daaa16c866b787c" translate="yes" xml:space="preserve">
          <source>Php: &lt;code&gt;header('Access-Control-Allow-Origin':'*');&lt;/code&gt;</source>
          <target state="translated">Php： &lt;code&gt;header('Access-Control-Allow-Origin':'*');&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="092830db2ae0b848e4a7fbe6ebb0dd4a586af9c1" translate="yes" xml:space="preserve">
          <source>Question is a bit too old to answer, but I am posting this for any future reference to this question.</source>
          <target state="translated">質問が古すぎて答えられませんが、今後の参考になればと思い投稿させていただきます。</target>
        </trans-unit>
        <trans-unit id="e8424d8bb7f11a8cc4b3389cc51d65e5c14d8fe2" translate="yes" xml:space="preserve">
          <source>Same-Origin Policy</source>
          <target state="translated">同一起源のポリシー</target>
        </trans-unit>
        <trans-unit id="d8f49b02b468a270ab421e2d51f5d4263f1bb933" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/a/13400954/710446&quot;&gt;Understanding XMLHttpRequest over CORS&lt;/a&gt; for a little more information about non-simple requests.</source>
          <target state="translated">非単純なリクエストの詳細については、 &lt;a href=&quot;https://stackoverflow.com/a/13400954/710446&quot;&gt;CORS&lt;/a&gt;を介したXMLHttpRequestについてを参照してください。</target>
        </trans-unit>
        <trans-unit id="4e327445570f452b897677d54af70e33b468e526" translate="yes" xml:space="preserve">
          <source>Simple example that allows CORS for all domains on all routes:</source>
          <target state="translated">すべてのルート上のすべてのドメインに対してCORSを許可するシンプルな例。</target>
        </trans-unit>
        <trans-unit id="034a38a06dec45075704e4adb13cbb4ae9f733ba" translate="yes" xml:space="preserve">
          <source>Simply paste the following code in your web.config file.</source>
          <target state="translated">以下のコードをweb.configファイルに貼り付けてください。</target>
        </trans-unit>
        <trans-unit id="ff6537b92aed8439a00dd653b603494c0e54b0aa" translate="yes" xml:space="preserve">
          <source>Since the cookies are validated as expected, the server will authorize the response.</source>
          <target state="translated">クッキーは期待通りに検証されているので、サーバーは応答を承認します。</target>
        </trans-unit>
        <trans-unit id="3d6a778de145e7651342fa186ec3e751766e4556" translate="yes" xml:space="preserve">
          <source>So now, a few questions and answers become apparent:</source>
          <target state="translated">そこで今、いくつかの疑問と答えが明らかになってきました。</target>
        </trans-unit>
        <trans-unit id="168634b8d2a054313c9a1ffe3818f5e07f300afc" translate="yes" xml:space="preserve">
          <source>So, a web application using &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;code&gt;Fetch&lt;/code&gt; could only make &lt;strong&gt;HTTP requests&lt;/strong&gt; to &lt;strong&gt;its own domain&lt;/strong&gt;.</source>
          <target state="translated">そのため、 &lt;code&gt;XMLHttpRequest&lt;/code&gt; または &lt;code&gt;Fetch&lt;/code&gt; を使用するWebアプリケーションは&lt;strong&gt;、自身のドメイン&lt;/strong&gt; &lt;strong&gt;に対して&lt;/strong&gt;のみ&lt;strong&gt;HTTPリクエスト&lt;/strong&gt;を行うことができました。</target>
        </trans-unit>
        <trans-unit id="d82b9a3c342873a23c4fab6db3c55ef4ea6a66cc" translate="yes" xml:space="preserve">
          <source>Sometimes you need to work cross domain, which is where CORS comes in. CORS relaxes the same origin policy for domainA.com, using the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header to list other domains (domainB.com) that are trusted to run JavaScript that can interact with domainA.com.</source>
          <target state="translated">CORSが入ってくるクロスドメインで作業する必要がある場合があります。CORSは、domainA.comの同じ生成元ポリシーを緩和し、 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダーを使用して、実行が信頼されている他のドメイン（domainB.com）をリストします。 domainA.comとやり取りできるJavaScript。</target>
        </trans-unit>
        <trans-unit id="d8284b007aa1410cee38f4acd287058a3c7a25bb" translate="yes" xml:space="preserve">
          <source>Supposing that Site A wants to send a PUT request for &lt;code&gt;/somePage&lt;/code&gt;, with a non-simple &lt;code&gt;Content-Type&lt;/code&gt; value of &lt;code&gt;application/json&lt;/code&gt;, the browser would first send a preflight request:</source>
          <target state="translated">サイトAが &lt;code&gt;/somePage&lt;/code&gt; の PUTリクエストを送信し、 &lt;code&gt;Content-Type&lt;/code&gt; の値が &lt;code&gt;application/json&lt;/code&gt; でない場合、ブラウザは最初にプリフライトリクエストを送信します。</target>
        </trans-unit>
        <trans-unit id="da390ae4eac8720e9ebf822a8c4b20180f117363" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Cross-Origin Resource Sharing (CORS)&lt;/strong&gt; mechanism gives web servers &lt;strong&gt;cross-domain access controls&lt;/strong&gt;, which enable secure cross-domain data transfers.</source>
          <target state="translated">&lt;strong&gt;Cross-Origin Resource Sharing（CORS）&lt;/strong&gt;メカニズムは、Webサーバーに&lt;strong&gt;クロスドメインアクセス制御&lt;/strong&gt;を提供し、安全なクロスドメインデータ転送を可能にします。</target>
        </trans-unit>
        <trans-unit id="3f523716bd882432eaaceb8c667a9d5d0f98dab8" translate="yes" xml:space="preserve">
          <source>The Access-Control-Allow-Origin response header indicates whether the
  response can be shared with requesting code from the given origin.</source>
          <target state="translated">Access-Control-Allow-Origin応答ヘッダーは、指定されたオリジンからの要求コードと応答を共有できるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="64becf81c730d7ddecadf5494d020a3051823f23" translate="yes" xml:space="preserve">
          <source>The CORS standard describes new HTTP headers which provide browsers and servers a way to request remote URLs only when they have permission.</source>
          <target state="translated">CORS 標準では、ブラウザとサーバが権限を持っている場合にのみ、リモート URL を要求する方法を提供する新しい HTTP ヘッダを記述しています。</target>
        </trans-unit>
        <trans-unit id="7579024e9c6a9814e5d551a9eae975f7eb6243e4" translate="yes" xml:space="preserve">
          <source>The blue parts I marked above were the kernal facts, &quot;Origin&quot; request header &quot;indicates where the cross-origin request or preflight request originates from&quot;, the &quot;Access-Control-Allow-Origin&quot; response header indicates this page allows remote request from DomainA (if the value is * indicate allows remote requests from any domain).</source>
          <target state="translated">私が上記でマークした青い部分は、kernal facts、&quot;Origin &quot;リクエストヘッダ &quot;クロスオリジンリクエストまたはプリフライトリクエストがどこから来たかを示します&quot;、&quot;Access-Control-Allow-Origin &quot;レスポンスヘッダは、このページがDomainAからのリモートリクエストを許可することを示しています(値が*の場合は、任意のドメインからのリモートリクエストを許可することを示しています)。</target>
        </trans-unit>
        <trans-unit id="b65de9513f32a4c4cc6825021c061136c01a69dd" translate="yes" xml:space="preserve">
          <source>The browser sends the &lt;code&gt;OPTIONS&lt;/code&gt; request with an &lt;code&gt;Origin HTTP&lt;/code&gt; header.</source>
          <target state="translated">ブラウザは、 &lt;code&gt;Origin HTTP&lt;/code&gt; ヘッダーを含む &lt;code&gt;OPTIONS&lt;/code&gt; リクエストを送信します 。</target>
        </trans-unit>
        <trans-unit id="7d531bbe49a2d68cdc67d51711b7278da9b33732" translate="yes" xml:space="preserve">
          <source>The browsers sends the actual request:</source>
          <target state="translated">ブラウザは実際のリクエストを送信します。</target>
        </trans-unit>
        <trans-unit id="a934d256e0a980eeb9f6c444da2f62c93f8bf7b4" translate="yes" xml:space="preserve">
          <source>The client triggers some functionality of MyCode.js, which in turn make requests to http://siteB, which should be fine, despite being cross-origin requests.</source>
          <target state="translated">クライアントはMyCode.jsのいくつかの機能をトリガーし、その機能がhttp:/siteBへのリクエストを行います。</target>
        </trans-unit>
        <trans-unit id="dbf7b1541a715c0443009d1f4641e7a2ee11f024" translate="yes" xml:space="preserve">
          <source>The code that does the downloading - your html script tag or xhr from javascript or whatever - came from, let's say, &lt;a href=&quot;http://siteZ&quot;&gt;http://siteZ&lt;/a&gt;.  And, when the browser requests MyCode.js, it sends an Origin: header saying &quot;Origin: &lt;a href=&quot;http://siteZ&quot;&gt;http://siteZ&lt;/a&gt;&quot;, because it can see that you're requesting to siteA and siteZ != siteA.  (You cannot stop or interfere with this.)</source>
          <target state="translated">ダウンロードを実行するコード（htmlスクリプトタグまたはjavascriptからのxhrなど）は、 &lt;a href=&quot;http://siteZ&quot;&gt;http：// siteZのようになり&lt;/a&gt;ます。 また、ブラウザーがMyCode.jsを要求すると、「Origin： &lt;a href=&quot;http://siteZ&quot;&gt;http：// siteZ&lt;/a&gt; 」というOrigin：ヘッダーが送信されます。これは、siteAおよびsiteZ！= siteAに要求していることがわかるためです。 （これを停止または妨害することはできません。）</target>
        </trans-unit>
        <trans-unit id="e26172510c48c8b57c33a3ae16c5818426df4b74" translate="yes" xml:space="preserve">
          <source>The purpose of the same origin policy is to protect you from malicious JavaScript on siteA.com accessing private information you've chosen to share only with siteB.com. Without the same origin policy, JavaScript written by the authors of siteA.com could make your browser make requests to siteB.com, using your authentication cookies for siteB.com. In this way, siteA.com could steal the secret information you share with siteB.com.</source>
          <target state="translated">同一起源ポリシーの目的は、siteA.com上の悪意のあるJavaScriptがsiteB.comとのみ共有することを選択した個人情報にアクセスすることからお客様を保護することです。同じ起源のポリシーがない場合、siteA.com の作者によって書かれた JavaScript は、siteB.com の認証クッキーを使用して、ブラウザに siteB.com へのリクエストを行わせることができます。このようにして、siteA.comはあなたがsiteB.comと共有している秘密の情報を盗むことができます。</target>
        </trans-unit>
        <trans-unit id="61bc29dae0f332e323eadbd6d92b28a19615ab02" translate="yes" xml:space="preserve">
          <source>The response header of MyCode.js contains &lt;strong&gt;Access-Control-Allow-Origin: http://siteB&lt;/strong&gt;, which I thought meant that MyCode.js was allowed to make cross-origin references to the site B.</source>
          <target state="translated">MyCode.jsの応答ヘッダーには&lt;strong&gt;Access-Control-Allow-Origin：http：//&lt;/strong&gt; siteBが含まれています。これは、MyCode.jsがサイトBへのクロスオリジン参照を作成できることを意味していると思いました。</target>
        </trans-unit>
        <trans-unit id="7da85dccb097c912fea1e023dcaa3cbcbacfb502" translate="yes" xml:space="preserve">
          <source>The server at &lt;code&gt;service.example.com&lt;/code&gt; may respond with:</source>
          <target state="translated">&lt;code&gt;service.example.com&lt;/code&gt; のサーバーは次のように応答します。</target>
        </trans-unit>
        <trans-unit id="f9366f7ceb9098513bc618100e4a166fb851ac2d" translate="yes" xml:space="preserve">
          <source>The value of this header is the domain that served the parent page. When a page from &lt;code&gt;http://www.example.com&lt;/code&gt; attempts to access a user's data in &lt;code&gt;service.example.com&lt;/code&gt;, the following request header would be sent to &lt;code&gt;service.example.com&lt;/code&gt;:</source>
          <target state="translated">このヘッダーの値は、親ページを提供したドメインです。 &lt;code&gt;http://www.example.com&lt;/code&gt; のページが &lt;code&gt;service.example.com&lt;/code&gt; 内のユーザーのデータにアクセスしようとすると、次のリクエストヘッダーが &lt;code&gt;service.example.com&lt;/code&gt; に送信されます。</target>
        </trans-unit>
        <trans-unit id="657f30c61187db82d87b65e6ce81f0467605fd0d" translate="yes" xml:space="preserve">
          <source>Then, MyCode.js comes from siteA.  When it makes requests to siteB, they are all cross-origin, the browser sends Origin: siteA, and siteB has to take the siteA, recognize it's on the short list of allowed requesters, and send back A-C-A-O: siteA.  Only then will the browser let your script get the result of those requests.</source>
          <target state="translated">そして、MyCode.jsはsiteAから来ています。ブラウザはOrigin:siteAを送信し、siteBはsiteAを受け取り、それが許可されているリクエスターの短いリストの中にあることを認識し、A-C-A-O:siteAを送り返さなければなりません。ブラウザがリクエストの結果を取得できるようになるのは、このときだけです。</target>
        </trans-unit>
        <trans-unit id="cc9aabc473d7e2d21950303f057e3358802271a9" translate="yes" xml:space="preserve">
          <source>This will allow to share content for different domain.</source>
          <target state="translated">これにより、異なるドメインのコンテンツを共有することができます。</target>
        </trans-unit>
        <trans-unit id="4503c23a82401d11ba63cd20aeb3e7ecf9db4793" translate="yes" xml:space="preserve">
          <source>Those cookies get gathered up and sent along - and now, &lt;code&gt;malicious.com&lt;/code&gt; has a response from &lt;code&gt;yourbank&lt;/code&gt;.</source>
          <target state="translated">これらのCookieは収集されて一緒に送信されます-そして今、 &lt;code&gt;malicious.com&lt;/code&gt; は &lt;code&gt;yourbank&lt;/code&gt; からの応答を持っています。</target>
        </trans-unit>
        <trans-unit id="aa4d6d318719d478d3206b9a5fe136b655674ae9" translate="yes" xml:space="preserve">
          <source>Those tricky ways have more or less some issues, for example JSONP might result in security hole if developers simply &quot;eval&quot; it, and #3 above, although it works, both domains should build strict contract between each other, it neither flexible nor elegant IMHO:)</source>
          <target state="translated">例えば、JSONPは開発者が単に &quot;eval &quot;するだけでセキュリティホールが発生する可能性がありますし、上記の#3では、動作はするものの、両ドメイン間で厳密な契約を結ぶ必要があり、柔軟性もエレガントさもありません。)</target>
        </trans-unit>
        <trans-unit id="9ca094af81bfc3826ed4436cf83d45cb4a2e4d44" translate="yes" xml:space="preserve">
          <source>To improve web applications, developers asked browser vendors to allow cross-domain requests.</source>
          <target state="translated">ウェブアプリケーションを改善するために、開発者はブラウザベンダーにクロスドメインリクエストを許可するよう求めた。</target>
        </trans-unit>
        <trans-unit id="dec4c5b25b8efa7a70ca001140b06f9b4fc9abc0" translate="yes" xml:space="preserve">
          <source>To understand which domain should serve the CORS headers, consider this. You visit malicious.com, which contains some JavaScript that tries to make a cross domain request to mybank.com. It should be up to mybank.com, not malicious.com, to decide whether or not it sets CORS headers that relax the same origin policy allowing the JavaScript from malicious.com to interact with it. If malicous.com could set its own CORS headers allowing its own JavaScript access to mybank.com, this would completely nullify the same origin policy.</source>
          <target state="translated">どのドメインが CORS ヘッダを提供すべきかを理解するために、次のように考えてみましょう。あなたは malicious.com にアクセスし、その中には mybank.com にクロスドメインリクエストを行おうとする JavaScript が含まれているとします。malicious.com ではなく mybank.com が、malicious.com からの JavaScript とのやりとりを可能にする同じオリジンポリシーを緩和する CORS ヘッダを設定するかどうかを決めるのは、malicious.com ではなく mybank.com に任されるべきです。malicous.comが独自のJavaScriptのmybank.comへのアクセスを許可する独自のCORSヘッダを設定することができれば、同じオリジンポリシーは完全に無効になります。</target>
        </trans-unit>
        <trans-unit id="7bf85d7014db5e0169f6a290c30265c13b955563" translate="yes" xml:space="preserve">
          <source>Use Flash/Silverlight or server side as a &quot;proxy&quot; to communicate
with remote.</source>
          <target state="translated">FlashSilverlightやサーバー側を「プロキシ」として使用して、リモートとの通信を行います。</target>
        </trans-unit>
        <trans-unit id="54542703a4403c62702b623ce59c580d816c24ad" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;React&lt;/strong&gt; and &lt;strong&gt;Axios&lt;/strong&gt;, join proxy link to the URL and add header as shown below</source>
          <target state="translated">&lt;strong&gt;React&lt;/strong&gt;と&lt;strong&gt;Axios&lt;/strong&gt;を使用して、プロキシリンクをURLに結合し、以下に示すようにヘッダーを追加します</target>
        </trans-unit>
        <trans-unit id="a44858f05242a7b455ce62fdc8df88a473321dc7" translate="yes" xml:space="preserve">
          <source>W3C had introduced Cross-Origin Resource Sharing (CORS) as a standard solution to provide a safe, flexible and a recommended standard way to solve this issue.</source>
          <target state="translated">W3Cでは、この問題を安全かつ柔軟に解決するための推奨される標準的なソリューションとして、Cross-Origin Resource Sharing(CORS)を導入していました。</target>
        </trans-unit>
        <trans-unit id="f1278b75a70fd6c5b6a83f2408abb534e43d6ca3" translate="yes" xml:space="preserve">
          <source>Well, I am wrong. It does not work like this at all. So, I have read &lt;a href=&quot;http://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;Cross-origin resource sharing&lt;/a&gt; and attempted to read &lt;a href=&quot;http://www.w3.org/TR/cors/.&quot;&gt;Cross-Origin Resource Sharing in w3c recommendation&lt;/a&gt;</source>
          <target state="translated">まあ、私は間違っています。 このようにはまったく機能しません。 それで、私は&lt;a href=&quot;http://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;クロスオリジンリソースシェアリング&lt;/a&gt;を読み&lt;a href=&quot;http://www.w3.org/TR/cors/.&quot;&gt;、w3c推奨のクロスオリジンリソースシェアリングを読み込もうとしました&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="acd1d52dcbd73103ac06849984a12c77293f662b" translate="yes" xml:space="preserve">
          <source>What happens on the network level can be &lt;em&gt;slightly&lt;/em&gt; more complex than explained above. If the request is a &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request&quot;&gt;&quot;non-simple&quot; request&lt;/a&gt;, the browser first sends a data-less &quot;preflight&quot; OPTIONS request, to verify that the server will accept the request. A request is non-simple when either (or both):</source>
          <target state="translated">ネットワークレベルで発生することは、上記で説明したものよりも&lt;em&gt;少し&lt;/em&gt;複雑になる可能性があります。 リクエストが&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request&quot;&gt;「非シンプル」リクエストの&lt;/a&gt;場合、ブラウザはまずデータのない「プリフライト」OPTIONSリクエストを送信して、サーバーがリクエストを受け入れることを確認します。 次のいずれか（または両方）の場合、リクエストは単純ではありません。</target>
        </trans-unit>
        <trans-unit id="69b9ebc5edfe8d1c244868c40d9107fcf6856520" translate="yes" xml:space="preserve">
          <source>When Site A tries to fetch content from Site B,  Site B can send an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; response header to tell the browser that the content of this page is accessible to certain origins. (An &lt;em&gt;origin&lt;/em&gt; is a &lt;a href=&quot;https://stackoverflow.com/a/19542686/710446&quot;&gt;domain, plus a scheme and port number&lt;/a&gt;.)  By default, Site B's pages are &lt;a href=&quot;https://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;not accessible to any other origin&lt;/a&gt;; using the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header opens a door for cross-origin access by specific requesting origins.</source>
          <target state="translated">サイトAがサイトBからコンテンツをフェッチしようとすると、サイトBは &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 応答ヘッダーを送信して、このページのコンテンツが特定の発行元からアクセス可能であることをブラウザーに通知できます。 （ &lt;em&gt;オリジン&lt;/em&gt;は&lt;a href=&quot;https://stackoverflow.com/a/19542686/710446&quot;&gt;ドメインとスキームおよびポート番号&lt;/a&gt;です。）デフォルトでは、サイトBのページは&lt;a href=&quot;https://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;他のオリジンにはアクセスできません&lt;/a&gt; 。 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダーを使用すると、特定の要求元によるクロスオリジンアクセスのドアが開きます。</target>
        </trans-unit>
        <trans-unit id="e9af21b6fffa981c22773bf6561ab52a3a2c16ad" translate="yes" xml:space="preserve">
          <source>When sending the actual request (after preflight is done), the behavior is identical to how a simple request is handled. In other words, a non-simple request whose preflight is successful is treated the same as a simple request (i.e., the server must still send &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; again for the actual response).</source>
          <target state="translated">実際のリクエストを送信するとき（プリフライトが実行された後）の動作は、単純なリクエストが処理される方法と同じです。 言い換えると、プリフライトが成功した単純でない要求は、単純な要求と同じように扱われます（つまり、サーバーは実際の応答のために引き続き &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; を再度送信する必要があります）。</target>
        </trans-unit>
        <trans-unit id="5c2243f9a6f92171c8e09c8e839ba5cb7bfc4bc2" translate="yes" xml:space="preserve">
          <source>Whenever I start thinking about CORS, my intuition about which site hosts the headers is incorrect, just as you described in your question. For me, it helps to think about the purpose of the same origin policy.</source>
          <target state="translated">CORSについて考え始めると、ご質問に書かれているように、どのサイトがヘッダーをホストしているのかという直感が間違っています。私にとっては、同一オリジンポリシーの目的を考えるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="bd36019344446d4d78cea760c6728f16f73a6008" translate="yes" xml:space="preserve">
          <source>Yikes.</source>
          <target state="translated">Yikes.</target>
        </trans-unit>
        <trans-unit id="0df105fca3eb53e9f6af003aa2f59e35fafdf39f" translate="yes" xml:space="preserve">
          <source>You browse to &lt;code&gt;malicious.com&lt;/code&gt;. Malicious makes a bunch of requests to different banks, including &lt;code&gt;yourbank.com&lt;/code&gt;.</source>
          <target state="translated">Malicious.comに &lt;code&gt;malicious.com&lt;/code&gt; ます。 Maliciousは &lt;code&gt;yourbank.com&lt;/code&gt; を含むさまざまな銀行に多数のリクエストを作成します。</target>
        </trans-unit>
        <trans-unit id="575553b8514f130229077f4c265369eae6418abf" translate="yes" xml:space="preserve">
          <source>You're logged in on your browser to &lt;code&gt;yourbank.com&lt;/code&gt;.  You request to see all your accounts.  &lt;code&gt;yourbank.com&lt;/code&gt; receives the pile of cookies and sends back its response (your accounts).</source>
          <target state="translated">ブラウザで &lt;code&gt;yourbank.com&lt;/code&gt; にログインしています。 すべてのアカウントを表示するように要求します。 &lt;code&gt;yourbank.com&lt;/code&gt; はCookieの山を受け取り、その応答（アカウント）を送り返します。</target>
        </trans-unit>
        <trans-unit id="76203283d6535a8379e646ae6b32fcc30abf3986" translate="yes" xml:space="preserve">
          <source>a) server side: in file app.js i give headers to all response like:</source>
          <target state="translated">a)サーバー側:app.js ファイルでは、以下のようにすべてのレスポンスにヘッダを与えています。</target>
        </trans-unit>
        <trans-unit id="5131eb102c64e7b1977894cc40c9e5ca9c90ab5d" translate="yes" xml:space="preserve">
          <source>b) client side: in send ajax you need add: &quot;withCredentials: true,&quot; like:</source>
          <target state="translated">b)クライアント側:ajaxを送信する際に、&quot;withCredentials:true,&quot;のように追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="b20f0919247dbc58bf2955f34f20d7033015f132" translate="yes" xml:space="preserve">
          <source>but i dont need that,</source>
          <target state="translated">でも、それは必要ない</target>
        </trans-unit>
        <trans-unit id="2897789ee2c19bf53c9dc2e8e84ef213689a1c9b" translate="yes" xml:space="preserve">
          <source>good luck.</source>
          <target state="translated">頑張れ</target>
        </trans-unit>
        <trans-unit id="24178e1d2a641a4fcfd1e7606989c6d425edc0c4" translate="yes" xml:space="preserve">
          <source>i work with express 4 and node 7.4 and angular,I had the same problem me help this:</source>
          <target state="translated">私はExpress 4とノード7.4とangularで動作し、私は同じ問題を持っていた私はこれを助けてください。</target>
        </trans-unit>
        <trans-unit id="d066fab57be4b00b3b31353f308ec42e5e698855" translate="yes" xml:space="preserve">
          <source>no.  It means, Only siteB is allowed to do this request.  So your request for MyCode.js from siteZ gets an error instead, and the browser typically gives you nothing.  But if you make your server return A-C-A-O: siteZ instead, you'll get MyCode.js .  Or if it sends '*', that'll work, that'll let everybody in.  Or if the server always sends the string from the Origin: header... but... for security, if you're afraid of hackers, your server should only allow origins on a shortlist, that are allowed to make those requests.</source>
          <target state="translated">ではなく、サイトBのみが許可されていることを意味します。これは、サイトBのみがこのリクエストを許可されていることを意味しています。つまり、サイトZからのMyCode.jsへのリクエストは、代わりにエラーになり、ブラウザは通常何も与えません。しかし、あなたのサーバーがA-C-A-O:siteZを返すようにすれば、MyCode.jsを取得することができます。または、'*'を送る場合は、それが機能し、誰でも入れるようになります。あるいは、サーバーが常にOrigin:ヘッダーからの文字列を送るならば...しかし...セキュリティのために、ハッカーを恐れているのであれば、サーバーはリクエストを許可されているショートリストのオリジンのみを許可すべきです。</target>
        </trans-unit>
        <trans-unit id="58403ccfa5556c2cca1135361e0a2e51ef732b2a" translate="yes" xml:space="preserve">
          <source>using an HTTP verb other than GET or POST (e.g. PUT, DELETE)</source>
          <target state="translated">GETやPOST以外のHTTP動詞を使った</target>
        </trans-unit>
        <trans-unit id="13a2ea31f53ce7d7d241eaebbc7aa4ec4fd25d28" translate="yes" xml:space="preserve">
          <source>using non-simple request headers; the only simple requests headers are:</source>
          <target state="translated">単純ではないリクエストヘッダを使用している場合は、単純なリクエストヘッダのみを使用します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
