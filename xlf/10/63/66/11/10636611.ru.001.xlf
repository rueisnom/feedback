<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/10636611">
    <body>
      <group id="10636611">
        <trans-unit id="79b3ba11b449f653cf94ea42d31d8665cb70305e" translate="yes" xml:space="preserve">
          <source>&quot;How do we get around it?&quot; Have the server tell the request that CORS is OK.</source>
          <target state="translated">&quot;Как нам обойти это?&quot; Пусть сервер скажет запрос,что CORS в порядке.</target>
        </trans-unit>
        <trans-unit id="922d106809a27f5ea5725cbecf04bcf0394fbc75" translate="yes" xml:space="preserve">
          <source>&quot;Why don't we just block the browser from doing that?&quot; Yep. CORS.</source>
          <target state="translated">&quot;Почему бы нам просто не заблокировать браузер от этого?&quot; Ага.CORS.</target>
        </trans-unit>
        <trans-unit id="8cce81f32d4f3933a9d189ba04d55f2214ac9ccf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;Wikipedia&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;Wikipedia&lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="a4a8b5194f78b6038b34fcb3aaefa3c75ec70357" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; is a &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/cors/&quot;&gt;CORS (Cross-Origin Resource Sharing) header&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; - это &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/cors/&quot;&gt;заголовок CORS (Cross-Origin Resource Sharing)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c09130b0fcfe3404570f3cf7d450decda7ec406d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Content-Type&lt;/code&gt; (this is only simple when its value is &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;Content-Type&lt;/code&gt; (это просто, когда его значение равно &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; , &lt;code&gt;multipart/form-data&lt;/code&gt; или &lt;code&gt;text/plain&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="31c8c8b02a31794b56f4026cc609f63ad40bb60d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https://cors-anywhere.herokuapp.com/&lt;/code&gt; + &lt;code&gt;Your API URL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;https://cors-anywhere.herokuapp.com/&lt;/code&gt; + &lt;code&gt;Your API URL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85bb5e6604df9c285a25a74cf794fab003bbd6a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;1. A client downloads javascript code MyCode.js from &lt;a href=&quot;http://siteA&quot;&gt;http://siteA&lt;/a&gt; - the origin.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;1. Клиент загружает код JavaScript MyCode.js из &lt;a href=&quot;http://siteA&quot;&gt;http: // siteA&lt;/a&gt; - источник.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e67c2a45dcc374cf1513c3c3847ca0329605f44f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;2. The response header of MyCode.js contains Access-Control-Allow-Origin: &lt;a href=&quot;http://siteB&quot;&gt;http://siteB&lt;/a&gt;, which I thought meant that MyCode.js was allowed to make cross-origin references to the site B.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;2. Заголовок ответа MyCode.js содержит Access-Control-Allow-Origin: &lt;a href=&quot;http://siteB&quot;&gt;http: // siteB&lt;/a&gt; , что, как я думал, означало, что MyCode.js было разрешено делать ссылки на сайт B.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e72ad7b755a692bece6c7ac0d6f5e50584dca43a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DomainA AJAX request headers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Заголовки AJAX-запроса DomainA&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d140b20d9bc077421ada900ec804924f2dd7508c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DomainB response headers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Заголовки ответа DomainB&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="43b44e358ed9ab663aff14a7eb3cb779b17abc1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key point:&lt;/strong&gt; When a client makes a request to the server, it will send the cookies stored under that domain.</source>
          <target state="translated">&lt;strong&gt;Ключевой момент:&lt;/strong&gt; когда клиент отправляет запрос на сервер, он отправляет файлы cookie, хранящиеся в этом домене.</target>
        </trans-unit>
        <trans-unit id="451ed0d1faeb007761b9f1f6e5c819251b69932c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Mechanism&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Механизм&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="458265a655ab105933b08a0c271497ca9d12a196" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this must have before all router&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;это должно быть раньше всех роутеров&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3144daeec601dcd1b43f2a37773bb3e0722f2c8f" translate="yes" xml:space="preserve">
          <source>A client downloads javascript code MyCode.js from http://siteA - &lt;strong&gt;the origin&lt;/strong&gt;.</source>
          <target state="translated">Клиент загружает код JavaScript MyCode.js с http: // siteA - &lt;strong&gt;источник&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b487ed479c5653fe0a2624288946f1c8ef051bd4" translate="yes" xml:space="preserve">
          <source>A resource makes a &lt;strong&gt;cross-origin HTTP request&lt;/strong&gt; when it requests a resource from a different domain, or port than the one which the first resource itself serves.</source>
          <target state="translated">Ресурс делает &lt;strong&gt;HTTP-запрос перекрестного происхождения,&lt;/strong&gt; когда запрашивает ресурс из другого домена или порта, отличного от того, который обслуживает первый ресурс.</target>
        </trans-unit>
        <trans-unit id="ce0f87926e811ddf23f0d196ca75fb63d5c3ead6" translate="yes" xml:space="preserve">
          <source>A response that tells the browser to allow code from any origin to
  access a resource will include the following:</source>
          <target state="translated">Ответ,который говорит браузеру разрешить код любого происхождения для доступа к ресурсу,будет включать следующее:</target>
        </trans-unit>
        <trans-unit id="ba3428e2ff13f1e68025f1c48520f8917410ea5c" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;this&lt;/a&gt; Mozilla Developer Network article,</source>
          <target state="translated">Согласно &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;этой&lt;/a&gt; статье Mozilla Developer Network,</target>
        </trans-unit>
        <trans-unit id="bf23c326dd333575e69254167b04cd66436a8ddf" translate="yes" xml:space="preserve">
          <source>Although some validation and authorization can be performed by the server, &lt;strong&gt;it is generally the browser's responsibility&lt;/strong&gt; to support these headers and honor the restrictions they impose.</source>
          <target state="translated">Хотя некоторая проверка и авторизация может выполняться сервером, &lt;strong&gt;браузер&lt;/strong&gt; , &lt;strong&gt;как правило, несет ответственность&lt;/strong&gt; за поддержку этих заголовков и соблюдение ограничений, которые они налагают.</target>
        </trans-unit>
        <trans-unit id="35cb55e5ed57188c2c958286ec803a59b4bb54db" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; (ACAO) header in its response indicating which origin sites are allowed.</source>
          <target state="translated">Заголовок &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; (ACAO) в своем ответе указывает, какие сайты происхождения разрешены.</target>
        </trans-unit>
        <trans-unit id="4a79c7e5f70a613673420444f94f034d8ff57aa2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; (ACAO) header with a wildcard that allows all domains:</source>
          <target state="translated">Заголовок &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; (ACAO) с подстановочным знаком, который позволяет всем доменам:</target>
        </trans-unit>
        <trans-unit id="181e454044a5f8794317a9184ef7086fe1502149" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;HTML page&lt;/strong&gt; served from &lt;code&gt;http://domain-a.com&lt;/code&gt; makes an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; src request for &lt;code&gt;http://domain-b.com/image.jpg&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;HTML-страница,&lt;/strong&gt; обслуживаемая с &lt;code&gt;http://domain-a.com&lt;/code&gt; , отправляет &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; запрос src для &lt;code&gt;http://domain-b.com/image.jpg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b609b5a98435feed729bf00208beca36f266c405" translate="yes" xml:space="preserve">
          <source>An error page if the server does not allow the cross-origin request</source>
          <target state="translated">Ошибка страницы,если сервер не разрешает перекрестный запрос</target>
        </trans-unit>
        <trans-unit id="2aa81cf349bfa1a844c8cd05dff5a9ad245bf1b1" translate="yes" xml:space="preserve">
          <source>An example story: On your computer, there's a cookie for &lt;code&gt;yourbank.com&lt;/code&gt;. Maybe your session is in there.</source>
          <target state="translated">Пример истории: на вашем компьютере есть файл cookie для &lt;code&gt;yourbank.com&lt;/code&gt; . Может быть, ваша сессия там.</target>
        </trans-unit>
        <trans-unit id="b97580e9a4d93057941cecbf72a8e5d77baa599d" translate="yes" xml:space="preserve">
          <source>And the server sends back an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;, just as it would for a simple request:</source>
          <target state="translated">И сервер отправляет обратно &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; , как это было бы для простого запроса:</target>
        </trans-unit>
        <trans-unit id="bbcce9482362cd9d846f8ef9260df5096f61aefb" translate="yes" xml:space="preserve">
          <source>Apparently, I have completely misunderstood its semantics. I thought of something like this:</source>
          <target state="translated">Очевидно,я совершенно неправильно понял его семантику.Я подумал о чем-то подобном:</target>
        </trans-unit>
        <trans-unit id="9c0a94e83fa3f4a9ba8e76553be179ce0c84ddf9" translate="yes" xml:space="preserve">
          <source>As I mentioned above, W3 recommended browser to implement a &quot;&lt;strong&gt;preflight request&lt;/strong&gt;&quot; before submiting the actually Cross-Origin HTTP request, in a nutshell it is an HTTP &lt;code&gt;OPTIONS&lt;/code&gt; request:</source>
          <target state="translated">Как я упоминал выше, W3 рекомендовал браузеру реализовать &amp;laquo;предварительный &lt;strong&gt;запрос&lt;/strong&gt; &amp;raquo; перед отправкой фактически HTTP-запроса Cross-Origin, в двух словах, это запрос HTTP &lt;code&gt;OPTIONS&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="18fc2f97599c6123f77e230a7df453afa9545e6c" translate="yes" xml:space="preserve">
          <source>Cross-Origin Resource Sharing (CORS)</source>
          <target state="translated">Совместное использование ресурсов (CORS)</target>
        </trans-unit>
        <trans-unit id="cd4c33b899fc233fd73d75ce9074d02da1ac4b4d" translate="yes" xml:space="preserve">
          <source>Cross-Origin Resource Sharing - &lt;code&gt;CORS&lt;/code&gt; (A.K.A. Cross-Domain AJAX request) is an issue that most web developers might encounter, according to Same-Origin-Policy, browsers restrict client JavaScript in a security sandbox, usually JS cannot directly communicate with a remote server from a different domain. In the past developers created many tricky ways to achieve Cross-Domain resource request, most commonly using ways are:</source>
          <target state="translated">Распределение ресурсов между источниками. &lt;code&gt;CORS&lt;/code&gt; (междоменный AJAX-запрос AKA) - это проблема, с которой может столкнуться большинство веб-разработчиков. В соответствии с Same-Origin-Policy браузеры ограничивают клиентский JavaScript в изолированной программной среде безопасности, обычно JS не может напрямую взаимодействовать с удаленным сервер из другого домена. В прошлом разработчики создавали множество хитрых способов достижения запроса к междоменным ресурсам, чаще всего с использованием следующих способов:</target>
        </trans-unit>
        <trans-unit id="011fc91df492b0380e17a87ee2e66441e70c4e0f" translate="yes" xml:space="preserve">
          <source>Embeds remote server in an iframe and communicate through fragment or window.name, refer &lt;a href=&quot;http://www.ibm.com/developerworks/library/wa-crossdomaincomm/#N10120&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Встраивает удаленный сервер в iframe и общается через фрагмент или имя.окна, см. &lt;a href=&quot;http://www.ibm.com/developerworks/library/wa-crossdomaincomm/#N10120&quot;&gt;Здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="c55d6bc880c85b7ddccab1864214b1926c931775" translate="yes" xml:space="preserve">
          <source>For cross origin sharing, set header: &lt;code&gt;'Access-Control-Allow-Origin':'*';&lt;/code&gt;</source>
          <target state="translated">Для обмена между источниками установите заголовок: &lt;code&gt;'Access-Control-Allow-Origin':'*';&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d1c001eb437a4a4ce15ecea22bb7619b01e35aa" translate="yes" xml:space="preserve">
          <source>For each resource/page that Site B wants to make accessible to Site A, Site B should serve its pages with the response header:</source>
          <target state="translated">Для каждой ресурсной страницы,которую Сайт Б хочет сделать доступной для Сайта А,Сайт Б должен обслуживать свои страницы с заголовком ответа:</target>
        </trans-unit>
        <trans-unit id="448733166bdf64413416b6944ad16b39bf49185a" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and &lt;code&gt;Fetch&lt;/code&gt; follow the &lt;strong&gt;same-origin policy&lt;/strong&gt;.</source>
          <target state="translated">Например, &lt;code&gt;XMLHttpRequest&lt;/code&gt; и &lt;code&gt;Fetch&lt;/code&gt; следуют &lt;strong&gt;одной&lt;/strong&gt; и той &lt;strong&gt;же политике происхождения&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="2ac76251686f22fcdbe32b54806e17b5c620fa63" translate="yes" xml:space="preserve">
          <source>For more info, visit &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin&quot;&gt;here&lt;/a&gt;....</source>
          <target state="translated">Для получения дополнительной информации посетите &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin&quot;&gt;здесь&lt;/a&gt; ....</target>
        </trans-unit>
        <trans-unit id="c434a7a5f602c383de2c018c1b0444a3ea8fbb96" translate="yes" xml:space="preserve">
          <source>For more specific examples see the documentation. I have used the simple example above to get around the CORS issue in an ionic application I am building that has to access a separate flask server.</source>
          <target state="translated">Более конкретные примеры см.в документации.Я использовал простой пример выше,чтобы обойти проблему CORS в ионном приложении,которое я создаю и которому необходим доступ к отдельному флэш-серверу.</target>
        </trans-unit>
        <trans-unit id="da1bd7e32d017921022d548d7ad4d638f61ae61e" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict &lt;strong&gt;cross-origin HTTP&lt;/strong&gt; requests &lt;strong&gt;initiated from within scripts&lt;/strong&gt;.</source>
          <target state="translated">По соображениям безопасности браузеры ограничивают &lt;strong&gt;перекрестные HTTP-&lt;/strong&gt; запросы, &lt;strong&gt;инициируемые из сценариев&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d6d0578bc5e77903d01a8d5a163a1d8888a0ad92" translate="yes" xml:space="preserve">
          <source>From a high level we can simply deem CORS is a contract between client AJAX call from domain A and a page hosted on domain B, a typical Cross-Origin request/response would be:</source>
          <target state="translated">С высокого уровня мы можем просто считать,что CORS-это контракт между звонком клиента AJAX из домена A и страницей,размещенной в домене B,типичный ответ на запрос Cross-Origin:</target>
        </trans-unit>
        <trans-unit id="6edd5efadce6bfaad382d3cb5bd545a64ef9e2c0" translate="yes" xml:space="preserve">
          <source>From my own experience, it's hard to find a simple explanation why CORS is even a concern.</source>
          <target state="translated">По моему собственному опыту,трудно найти простое объяснение тому,почему CORS вообще вызывает беспокойство.</target>
        </trans-unit>
        <trans-unit id="1727a759182c88301c3e81d2fbbe9997d5ed21c4" translate="yes" xml:space="preserve">
          <source>How CORS works (&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header)</source>
          <target state="translated">Как работает CORS (заголовок &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c8cc4076ef7542bc5aed83b4de859cfb8a1094e1" translate="yes" xml:space="preserve">
          <source>How does Access-Control-Allow-Origin header work</source>
          <target state="translated">Как работает заголовок &quot;Access-Control-Alloww-Origin&quot;.</target>
        </trans-unit>
        <trans-unit id="7ababbc9fc0b6cccf17b2439c963b15cce41b12d" translate="yes" xml:space="preserve">
          <source>I blogged about CORS three years ago: &lt;a href=&quot;http://wayneye.com/Blog/Ajax-Cross-Origin-HTTP-request&quot;&gt;AJAX Cross-Origin HTTP request&lt;/a&gt;</source>
          <target state="translated">Я писал о CORS три года назад: &lt;a href=&quot;http://wayneye.com/Blog/Ajax-Cross-Origin-HTTP-request&quot;&gt;HTTP-запрос AJAX Cross-Origin&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6d70cc5a4760303b495e7652f8245f1fe3b0fb9" translate="yes" xml:space="preserve">
          <source>I do not want to utilize JSONP.</source>
          <target state="translated">Я не хочу использовать JSONP.</target>
        </trans-unit>
        <trans-unit id="d09fde375f0cd87d20979405e3d38cb1e221db9d" translate="yes" xml:space="preserve">
          <source>I have full control of both site A and site B. How do I enable the javascript code downloaded from the site A to access resources on the site B using this header?</source>
          <target state="translated">Я имею полный контроль и над сайтом А,и над сайтом Б.Как с помощью этого заголовка включить javascript-код,загруженный с сайта А,для доступа к ресурсам на сайте Б?</target>
        </trans-unit>
        <trans-unit id="9ab469e49ab007a1f4aca272e24988f133d0239d" translate="yes" xml:space="preserve">
          <source>I saw a lot of added this headers:</source>
          <target state="translated">Я много раз видел,как добавляли эти заголовки:</target>
        </trans-unit>
        <trans-unit id="bcfe019fd908beb42af7ba76dea547996805d921" translate="yes" xml:space="preserve">
          <source>I think the reason for my bad intuition is the point of view I have when developing a site. It's &lt;strong&gt;my&lt;/strong&gt; site, with all &lt;strong&gt;my&lt;/strong&gt; JavaScript, therefore it isn't doing anything malicious and it should be up to &lt;strong&gt;me&lt;/strong&gt; to specify which other sites &lt;strong&gt;my&lt;/strong&gt; JavaScript can interact with. When in fact I should be thinking which &lt;strong&gt;other&lt;/strong&gt; sites JavaScript are trying to interact with my site and should I use CORS to allow them?</source>
          <target state="translated">Я думаю, что причиной моей плохой интуиции является точка зрения, которую я имею при разработке сайта. Это &lt;strong&gt;мой&lt;/strong&gt; сайт со всем &lt;strong&gt;моим&lt;/strong&gt; JavaScript, поэтому он не делает ничего вредоносного, и &lt;strong&gt;я&lt;/strong&gt; должен указать, с какими другими сайтами может взаимодействовать &lt;strong&gt;мой&lt;/strong&gt; JavaScript. Когда на самом деле я должен думать, какие &lt;strong&gt;другие&lt;/strong&gt; сайты JavaScript пытается взаимодействовать с моим сайтом, и должен ли я использовать CORS, чтобы разрешить их?</target>
        </trans-unit>
        <trans-unit id="ea75fc450491732817d81c5e6ba7c55e53aaaf8c" translate="yes" xml:space="preserve">
          <source>If another client makes a &lt;em&gt;cross origin&lt;/em&gt; request to a server, those cookies are sent along, just as before.  Ruh roh.</source>
          <target state="translated">Если другой клиент отправляет серверу запрос на &lt;em&gt;перекрестный источник&lt;/em&gt; , эти куки отправляются вместе, как и раньше. Рух Ро.</target>
        </trans-unit>
        <trans-unit id="0fbef03b48408fe4be85b4fd43c89fcb90ea9874" translate="yes" xml:space="preserve">
          <source>If foo.aspx supports OPTIONS HTTP verb, it might return response like below:</source>
          <target state="translated">Если foo.aspx поддерживает HTTP глагол OPTIONS,он может вернуть ответ,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="82d42f9e57a8e7c74c1875653db07a225efbc513" translate="yes" xml:space="preserve">
          <source>If the server responds to the OPTIONS preflight with appropriate response headers (&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; for non-simple headers, &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; for non-simple verbs) that match the non-simple verb and/or non-simple headers, then the browser sends the actual request.</source>
          <target state="translated">Если сервер отвечает на предварительный просмотр OPTIONS с соответствующими заголовками ответа ( &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; для непростых заголовков, &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; для непростых глаголов), которые соответствуют непростому глаголу и / или не -простые заголовки, то браузер отправляет фактический запрос.</target>
        </trans-unit>
        <trans-unit id="b209912bc039e43f1ba2a6ad10304105e971e755" translate="yes" xml:space="preserve">
          <source>If you are using PHP, try adding the following code at the beginning of the php file:</source>
          <target state="translated">Если вы используете PHP,попробуйте добавить следующий код в начало php-файла:</target>
        </trans-unit>
        <trans-unit id="012b5bc6588408b5759125ca431dc0ee67a011c5" translate="yes" xml:space="preserve">
          <source>If you are using external domains such as server, try this:</source>
          <target state="translated">Если вы используете внешние домены,такие как сервер,попробуйте это:</target>
        </trans-unit>
        <trans-unit id="fac656ade96604b1bb74bdc54813902f91db4ff2" translate="yes" xml:space="preserve">
          <source>If you are using localhost, try this:</source>
          <target state="translated">Если вы используете &quot;Местный хозяин&quot;,попробуйте это:</target>
        </trans-unit>
        <trans-unit id="fa242605a7d86095b9190396fd9364feb7753098" translate="yes" xml:space="preserve">
          <source>If you want just to test a cross domain application in which the browser blocks your request, then you can just open your browser in unsafe mode and test your application without changing your code and without making your code unsafe.
From MAC OS you can do this from the terminal line:</source>
          <target state="translated">Если вы хотите просто протестировать междоменное приложение,в котором браузер блокирует ваш запрос,то вы можете просто открыть браузер в небезопасном режиме и протестировать приложение,не изменяя код и не делая ваш код небезопасным.С помощью MAC OS вы можете сделать это из строки терминала:</target>
        </trans-unit>
        <trans-unit id="511761e5536cf8f170218acc8981aa0ecce25b0b" translate="yes" xml:space="preserve">
          <source>In Python I have been using the &lt;a href=&quot;https://flask-cors.readthedocs.io/en/latest/&quot;&gt;&lt;code&gt;Flask-CORS&lt;/code&gt; library&lt;/a&gt; with great success. It makes dealing with CORS super easy and painless. I added some code from the library's documentation below.</source>
          <target state="translated">В Python я с большим успехом использую &lt;a href=&quot;https://flask-cors.readthedocs.io/en/latest/&quot;&gt;библиотеку &lt;code&gt;Flask-CORS&lt;/code&gt; &lt;/a&gt; . Это делает работу с CORS супер простой и безболезненной. Я добавил код из документации библиотеки ниже.</target>
        </trans-unit>
        <trans-unit id="ecb9b7c454fe20235af87d4ec8e149d40f0c3d94" translate="yes" xml:space="preserve">
          <source>Installing:</source>
          <target state="translated">Installing:</target>
        </trans-unit>
        <trans-unit id="59923435fe33e2e35eb67133c1bb2118e8264bb1" translate="yes" xml:space="preserve">
          <source>It's all about cookies. Cookies are stored on a client by their domain.</source>
          <target state="translated">Все дело в печенье.Файлы cookie хранятся на клиенте в его домене.</target>
        </trans-unit>
        <trans-unit id="036bc79e753677ceaeb2e07cdc182e7630df8ef3" translate="yes" xml:space="preserve">
          <source>JSON With Padding (&lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt;).</source>
          <target state="translated">JSON с набивкой ( &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ca44019ded082daf451d8d84c802691d29ea6475" translate="yes" xml:space="preserve">
          <source>Just by adding the Proxy link will work, but it can also throw error for No Access again. Hence better to add header as shown below.</source>
          <target state="translated">Просто добавив прокси-ссылку,она будет работать,но она также может бросить ошибку для No Access снова.Поэтому лучше добавить заголовок,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="990982cfd7f5181c1c4b59985f6c17c7572a78da" translate="yes" xml:space="preserve">
          <source>Many pages on the web today load resources like &lt;strong&gt;CSS stylesheets&lt;/strong&gt;, &lt;strong&gt;images&lt;/strong&gt; and &lt;strong&gt;scripts&lt;/strong&gt; from separate domains (thus it should be cool).</source>
          <target state="translated">Сегодня многие страницы в Интернете загружают ресурсы, такие как &lt;strong&gt;таблицы стилей CSS&lt;/strong&gt; , &lt;strong&gt;изображения&lt;/strong&gt; и &lt;strong&gt;скрипты,&lt;/strong&gt; из разных доменов (поэтому это должно быть круто).</target>
        </trans-unit>
        <trans-unit id="42aa7d0d1e4cb56cb1cdea6f9ad0ab375346d78d" translate="yes" xml:space="preserve">
          <source>Modern browsers use &lt;strong&gt;CORS&lt;/strong&gt; in an &lt;strong&gt;API container&lt;/strong&gt; - such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;code&gt;Fetch&lt;/code&gt; - to mitigate risks of cross-origin HTTP requests.</source>
          <target state="translated">Современные браузеры используют &lt;strong&gt;CORS&lt;/strong&gt; в &lt;strong&gt;контейнере API&lt;/strong&gt; - таком как &lt;code&gt;XMLHttpRequest&lt;/code&gt; или &lt;code&gt;Fetch&lt;/code&gt; - для снижения рисков HTTP-запросов между источниками.</target>
        </trans-unit>
        <trans-unit id="c158f1129e2a1e2d82881627004ee2f4629d1c66" translate="yes" xml:space="preserve">
          <source>Modern browsers will not block cross-domain requests outright.  If Site A requests a page from Site B, the browser will actually fetch the requested page &lt;em&gt;on the network level&lt;/em&gt; and check if the response headers list Site A as a permitted requester domain.  If Site B has not indicated that Site A is allowed to access this page, the browser will trigger the &lt;code&gt;XMLHttpRequest&lt;/code&gt;'s &lt;code&gt;error&lt;/code&gt; event and  deny the response data to the requesting JavaScript code.</source>
          <target state="translated">Современные браузеры не будут блокировать междоменные запросы напрямую. Если сайт A запрашивает страницу с сайта B, браузер фактически извлекает запрошенную страницу &lt;em&gt;на сетевом уровне&lt;/em&gt; и проверяет, содержит ли заголовки ответа сайт A в качестве разрешенного домена запрашивающей стороны. Если сайт B не указал, что сайту A разрешен доступ к этой странице, браузер вызовет событие &lt;code&gt;error&lt;/code&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; и запретит данные ответа запрашивающему коду JavaScript.</target>
        </trans-unit>
        <trans-unit id="76e7b7d6dbafadc7d02482466d004be762003b16" translate="yes" xml:space="preserve">
          <source>Node: &lt;code&gt;app.use('Access-Control-Allow-Origin':'*');&lt;/code&gt;</source>
          <target state="translated">Узел: &lt;code&gt;app.use('Access-Control-Allow-Origin':'*');&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0774d4e9c921c6d51ae15b2d71eb985b886205bd" translate="yes" xml:space="preserve">
          <source>Non-simple requests</source>
          <target state="translated">Необычные запросы</target>
        </trans-unit>
        <trans-unit id="c17d4be261192d21bdacbfa184e2f727114899f3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; and &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; are added by the browser automatically; you do not need to add them. This OPTIONS preflight gets the successful response headers:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; и &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; добавляются браузером автоматически; Вам не нужно добавлять их. Этот предварительный просмотр OPTIONS получает заголовки успешного ответа:</target>
        </trans-unit>
        <trans-unit id="bca29b4c27957d6c5a6dfc00cdfff94aa12e7ae5" translate="yes" xml:space="preserve">
          <source>Noted that, you have to paste the following code under &lt;code&gt;&amp;lt;system.webServer&amp;gt;&lt;/code&gt; tag</source>
          <target state="translated">Заметил, что вы должны вставить следующий код в &lt;code&gt;&amp;lt;system.webServer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2b757a60b81b0610f7e0143768cb1bf5f5771cb" translate="yes" xml:space="preserve">
          <source>Once you understand why it's there, the headers and discussion becomes a lot clearer.  I'll give it a shot in a few lines.</source>
          <target state="translated">Как только вы понимаете,заголовки и дискуссии становятся намного яснее.Я попробую в нескольких строчках.</target>
        </trans-unit>
        <trans-unit id="b9fd5fe1077f37c5e40b6997c12d1c88618c93ec" translate="yes" xml:space="preserve">
          <source>One thing is sure - I still do not understand how am I supposed to use this header.</source>
          <target state="translated">Одно можно сказать точно-я до сих пор не понимаю,как мне использовать этот заголовок.</target>
        </trans-unit>
        <trans-unit id="0c524bfd8fb631d16e1066def5e7ed1f33a402d3" translate="yes" xml:space="preserve">
          <source>Only if the response contains &quot;Access-Control-Allow-Origin&quot; AND its value is &quot;*&quot; or contain the domain who submitted the CORS request, by satisfying this mandtory condition browser will submit the actual Cross-Domain request, and cache the result in &quot;&lt;strong&gt;Preflight-Result-Cache&lt;/strong&gt;&quot;.</source>
          <target state="translated">Только если ответ содержит &amp;laquo;Access-Control-Allow-Origin&amp;raquo; И его значение равно &amp;laquo;*&amp;raquo; или содержит домен, который отправил запрос CORS, при выполнении этого обязательного условия браузер отправит фактический междоменный запрос и кеширует результат в &quot; &lt;strong&gt;Preflight-Result-Cache&lt;/strong&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="cba4c2393e21aee27e3e96781ebdf9c4f329b911" translate="yes" xml:space="preserve">
          <source>Origin: &lt;a href=&quot;http://www.example.com&quot;&gt;http://www.example.com&lt;/a&gt;</source>
          <target state="translated">Происхождение: &lt;a href=&quot;http://www.example.com&quot;&gt;http://www.example.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42682c0cef7e29104cf2fb7a57155baed6c873a6" translate="yes" xml:space="preserve">
          <source>P.S.</source>
          <target state="translated">P.S.</target>
        </trans-unit>
        <trans-unit id="ef3b9fb63ad4f41fc921c9eb7daaa16c866b787c" translate="yes" xml:space="preserve">
          <source>Php: &lt;code&gt;header('Access-Control-Allow-Origin':'*');&lt;/code&gt;</source>
          <target state="translated">Php: &lt;code&gt;header('Access-Control-Allow-Origin':'*');&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="092830db2ae0b848e4a7fbe6ebb0dd4a586af9c1" translate="yes" xml:space="preserve">
          <source>Question is a bit too old to answer, but I am posting this for any future reference to this question.</source>
          <target state="translated">Вопрос слишком старый,чтобы на него отвечать,но я размещаю его для любой будущей ссылки на этот вопрос.</target>
        </trans-unit>
        <trans-unit id="e8424d8bb7f11a8cc4b3389cc51d65e5c14d8fe2" translate="yes" xml:space="preserve">
          <source>Same-Origin Policy</source>
          <target state="translated">однородная политика</target>
        </trans-unit>
        <trans-unit id="d8f49b02b468a270ab421e2d51f5d4263f1bb933" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/a/13400954/710446&quot;&gt;Understanding XMLHttpRequest over CORS&lt;/a&gt; for a little more information about non-simple requests.</source>
          <target state="translated">Посмотрите &lt;a href=&quot;https://stackoverflow.com/a/13400954/710446&quot;&gt;Понимание XMLHttpRequest через CORS&lt;/a&gt; для немного больше информации о непростых запросах.</target>
        </trans-unit>
        <trans-unit id="4e327445570f452b897677d54af70e33b468e526" translate="yes" xml:space="preserve">
          <source>Simple example that allows CORS for all domains on all routes:</source>
          <target state="translated">Простой пример,который позволяет CORS для всех доменов на всех маршрутах:</target>
        </trans-unit>
        <trans-unit id="034a38a06dec45075704e4adb13cbb4ae9f733ba" translate="yes" xml:space="preserve">
          <source>Simply paste the following code in your web.config file.</source>
          <target state="translated">Просто вставьте следующий код в ваш файл web.config.</target>
        </trans-unit>
        <trans-unit id="ff6537b92aed8439a00dd653b603494c0e54b0aa" translate="yes" xml:space="preserve">
          <source>Since the cookies are validated as expected, the server will authorize the response.</source>
          <target state="translated">Так как куки-файлы проверяются,как и ожидалось,сервер авторизует ответ.</target>
        </trans-unit>
        <trans-unit id="3d6a778de145e7651342fa186ec3e751766e4556" translate="yes" xml:space="preserve">
          <source>So now, a few questions and answers become apparent:</source>
          <target state="translated">Итак,теперь несколько вопросов и ответов становятся очевидными:</target>
        </trans-unit>
        <trans-unit id="168634b8d2a054313c9a1ffe3818f5e07f300afc" translate="yes" xml:space="preserve">
          <source>So, a web application using &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;code&gt;Fetch&lt;/code&gt; could only make &lt;strong&gt;HTTP requests&lt;/strong&gt; to &lt;strong&gt;its own domain&lt;/strong&gt;.</source>
          <target state="translated">Таким образом, веб-приложение, использующее &lt;code&gt;XMLHttpRequest&lt;/code&gt; или &lt;code&gt;Fetch&lt;/code&gt; , может отправлять &lt;strong&gt;HTTP-запросы только&lt;/strong&gt; в &lt;strong&gt;свой домен&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d82b9a3c342873a23c4fab6db3c55ef4ea6a66cc" translate="yes" xml:space="preserve">
          <source>Sometimes you need to work cross domain, which is where CORS comes in. CORS relaxes the same origin policy for domainA.com, using the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header to list other domains (domainB.com) that are trusted to run JavaScript that can interact with domainA.com.</source>
          <target state="translated">Иногда вам нужно работать с междоменными доменами, в которые входит CORS. CORS ослабляет ту же политику происхождения для domainA.com, используя заголовок &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; для перечисления других доменов (domainB.com), которым доверяют запускать JavaScript, который может взаимодействовать с domainA.com.</target>
        </trans-unit>
        <trans-unit id="d8284b007aa1410cee38f4acd287058a3c7a25bb" translate="yes" xml:space="preserve">
          <source>Supposing that Site A wants to send a PUT request for &lt;code&gt;/somePage&lt;/code&gt;, with a non-simple &lt;code&gt;Content-Type&lt;/code&gt; value of &lt;code&gt;application/json&lt;/code&gt;, the browser would first send a preflight request:</source>
          <target state="translated">Предположим, что Сайт A хочет отправить запрос PUT для &lt;code&gt;/somePage&lt;/code&gt; с непростым значением &lt;code&gt;Content-Type&lt;/code&gt; для &lt;code&gt;application/json&lt;/code&gt; , браузер сначала отправит предварительный запрос:</target>
        </trans-unit>
        <trans-unit id="da390ae4eac8720e9ebf822a8c4b20180f117363" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Cross-Origin Resource Sharing (CORS)&lt;/strong&gt; mechanism gives web servers &lt;strong&gt;cross-domain access controls&lt;/strong&gt;, which enable secure cross-domain data transfers.</source>
          <target state="translated">Механизм &lt;strong&gt;общего доступа к ресурсам (CORS)&lt;/strong&gt; предоставляет веб-серверам &lt;strong&gt;контроль доступа между доменами&lt;/strong&gt; , который обеспечивает безопасную передачу данных между доменами.</target>
        </trans-unit>
        <trans-unit id="3f523716bd882432eaaceb8c667a9d5d0f98dab8" translate="yes" xml:space="preserve">
          <source>The Access-Control-Allow-Origin response header indicates whether the
  response can be shared with requesting code from the given origin.</source>
          <target state="translated">Заголовок ответа AccessControl-Alloww-Origin указывает,может ли ответ быть разделен с кодом запроса из данного источника.</target>
        </trans-unit>
        <trans-unit id="64becf81c730d7ddecadf5494d020a3051823f23" translate="yes" xml:space="preserve">
          <source>The CORS standard describes new HTTP headers which provide browsers and servers a way to request remote URLs only when they have permission.</source>
          <target state="translated">Стандарт CORS описывает новые заголовки HTTP,которые предоставляют браузерам и серверам способ запроса удаленных URL-адресов только при наличии разрешения.</target>
        </trans-unit>
        <trans-unit id="7579024e9c6a9814e5d551a9eae975f7eb6243e4" translate="yes" xml:space="preserve">
          <source>The blue parts I marked above were the kernal facts, &quot;Origin&quot; request header &quot;indicates where the cross-origin request or preflight request originates from&quot;, the &quot;Access-Control-Allow-Origin&quot; response header indicates this page allows remote request from DomainA (if the value is * indicate allows remote requests from any domain).</source>
          <target state="translated">Синие части,которые я отметил выше,были весенними фактами,заголовок &quot;Origin&quot; request header &quot;указывает,откуда исходит перекрестный запрос или предполетный запрос&quot;,заголовок ответа &quot;Access-Control-Allow-Origin&quot; указывает на то,что эта страница разрешает удаленный запрос от DomainA (если значение*указывает на разрешение удаленных запросов с любого домена).</target>
        </trans-unit>
        <trans-unit id="b65de9513f32a4c4cc6825021c061136c01a69dd" translate="yes" xml:space="preserve">
          <source>The browser sends the &lt;code&gt;OPTIONS&lt;/code&gt; request with an &lt;code&gt;Origin HTTP&lt;/code&gt; header.</source>
          <target state="translated">Браузер отправляет запрос &lt;code&gt;OPTIONS&lt;/code&gt; с &lt;code&gt;Origin HTTP&lt;/code&gt; заголовком Origin .</target>
        </trans-unit>
        <trans-unit id="7d531bbe49a2d68cdc67d51711b7278da9b33732" translate="yes" xml:space="preserve">
          <source>The browsers sends the actual request:</source>
          <target state="translated">Браузеры посылают реальный запрос:</target>
        </trans-unit>
        <trans-unit id="a934d256e0a980eeb9f6c444da2f62c93f8bf7b4" translate="yes" xml:space="preserve">
          <source>The client triggers some functionality of MyCode.js, which in turn make requests to http://siteB, which should be fine, despite being cross-origin requests.</source>
          <target state="translated">Клиент запускает некоторую функциональность MyCode.js,которая,в свою очередь,делает запросы на http:/siteB,что должно быть нормально,несмотря на кросс-оригинальные запросы.</target>
        </trans-unit>
        <trans-unit id="dbf7b1541a715c0443009d1f4641e7a2ee11f024" translate="yes" xml:space="preserve">
          <source>The code that does the downloading - your html script tag or xhr from javascript or whatever - came from, let's say, &lt;a href=&quot;http://siteZ&quot;&gt;http://siteZ&lt;/a&gt;.  And, when the browser requests MyCode.js, it sends an Origin: header saying &quot;Origin: &lt;a href=&quot;http://siteZ&quot;&gt;http://siteZ&lt;/a&gt;&quot;, because it can see that you're requesting to siteA and siteZ != siteA.  (You cannot stop or interfere with this.)</source>
          <target state="translated">Код, который выполняет загрузку - ваш тег html-скрипта или xhr из javascript или чего-либо еще - поступил, скажем, с &lt;a href=&quot;http://siteZ&quot;&gt;http: // siteZ&lt;/a&gt; . И когда браузер запрашивает MyCode.js, он отправляет заголовок Origin: &amp;laquo;Origin: &lt;a href=&quot;http://siteZ&quot;&gt;http: // siteZ&lt;/a&gt; &amp;raquo;, потому что он может видеть, что вы запрашиваете siteA и siteZ! = SiteA. (Вы не можете остановиться или помешать этому.)</target>
        </trans-unit>
        <trans-unit id="e26172510c48c8b57c33a3ae16c5818426df4b74" translate="yes" xml:space="preserve">
          <source>The purpose of the same origin policy is to protect you from malicious JavaScript on siteA.com accessing private information you've chosen to share only with siteB.com. Without the same origin policy, JavaScript written by the authors of siteA.com could make your browser make requests to siteB.com, using your authentication cookies for siteB.com. In this way, siteA.com could steal the secret information you share with siteB.com.</source>
          <target state="translated">Цель той же политики происхождения,чтобы защитить вас от вредоносных JavaScript на siteA.com доступ к частной информации,которую вы решили поделиться только с siteB.com.Без той же самой политики происхождения,JavaScript,написанный авторами сайта siteA.com может сделать ваш браузер делать запросы на siteB.com,используя вашу аутентификацию cookies для siteB.com.Таким образом,siteA.com мог бы украсть секретную информацию,которую вы делите с siteB.com.</target>
        </trans-unit>
        <trans-unit id="61bc29dae0f332e323eadbd6d92b28a19615ab02" translate="yes" xml:space="preserve">
          <source>The response header of MyCode.js contains &lt;strong&gt;Access-Control-Allow-Origin: http://siteB&lt;/strong&gt;, which I thought meant that MyCode.js was allowed to make cross-origin references to the site B.</source>
          <target state="translated">Заголовок ответа MyCode.js содержит &lt;strong&gt;Access-Control-Allow-Origin: http: // siteB&lt;/strong&gt; , что, как я думал, означало, что MyCode.js было разрешено делать ссылки на сайт B.</target>
        </trans-unit>
        <trans-unit id="7da85dccb097c912fea1e023dcaa3cbcbacfb502" translate="yes" xml:space="preserve">
          <source>The server at &lt;code&gt;service.example.com&lt;/code&gt; may respond with:</source>
          <target state="translated">Сервер на &lt;code&gt;service.example.com&lt;/code&gt; может ответить:</target>
        </trans-unit>
        <trans-unit id="f9366f7ceb9098513bc618100e4a166fb851ac2d" translate="yes" xml:space="preserve">
          <source>The value of this header is the domain that served the parent page. When a page from &lt;code&gt;http://www.example.com&lt;/code&gt; attempts to access a user's data in &lt;code&gt;service.example.com&lt;/code&gt;, the following request header would be sent to &lt;code&gt;service.example.com&lt;/code&gt;:</source>
          <target state="translated">Значением этого заголовка является домен, который обслуживал родительскую страницу. Когда страница с &lt;code&gt;http://www.example.com&lt;/code&gt; пытается получить доступ к данным пользователя на &lt;code&gt;service.example.com&lt;/code&gt; , следующий заголовок запроса будет отправлен на &lt;code&gt;service.example.com&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="657f30c61187db82d87b65e6ce81f0467605fd0d" translate="yes" xml:space="preserve">
          <source>Then, MyCode.js comes from siteA.  When it makes requests to siteB, they are all cross-origin, the browser sends Origin: siteA, and siteB has to take the siteA, recognize it's on the short list of allowed requesters, and send back A-C-A-O: siteA.  Only then will the browser let your script get the result of those requests.</source>
          <target state="translated">Потом,MyCode.js приходит с сайтаА.Когда он делает запросы к siteB,они все перекрестные,браузер посылает Origin:siteA,а siteB должен взять siteA,распознать,что он в коротком списке разрешенных запросов,и отправить обратно A-C-A-O:siteA.Только тогда браузер позволит вашему скрипту получить результат этих запросов.</target>
        </trans-unit>
        <trans-unit id="cc9aabc473d7e2d21950303f057e3358802271a9" translate="yes" xml:space="preserve">
          <source>This will allow to share content for different domain.</source>
          <target state="translated">Это позволит обмениваться контентом для разных доменов.</target>
        </trans-unit>
        <trans-unit id="4503c23a82401d11ba63cd20aeb3e7ecf9db4793" translate="yes" xml:space="preserve">
          <source>Those cookies get gathered up and sent along - and now, &lt;code&gt;malicious.com&lt;/code&gt; has a response from &lt;code&gt;yourbank&lt;/code&gt;.</source>
          <target state="translated">Эти файлы cookie собираются и отправляются вместе, и теперь &lt;code&gt;malicious.com&lt;/code&gt; получил ответ от &lt;code&gt;yourbank&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa4d6d318719d478d3206b9a5fe136b655674ae9" translate="yes" xml:space="preserve">
          <source>Those tricky ways have more or less some issues, for example JSONP might result in security hole if developers simply &quot;eval&quot; it, and #3 above, although it works, both domains should build strict contract between each other, it neither flexible nor elegant IMHO:)</source>
          <target state="translated">Эти хитрые способы имеют более или менее некоторые проблемы,например,JSONP может привести к дыре в безопасности,если разработчики просто &quot;оценить&quot; его,и № 3 выше,хотя это работает,оба домена должны строить строгий контракт друг с другом,это не гибкий и не элегантный IMHO:)</target>
        </trans-unit>
        <trans-unit id="9ca094af81bfc3826ed4436cf83d45cb4a2e4d44" translate="yes" xml:space="preserve">
          <source>To improve web applications, developers asked browser vendors to allow cross-domain requests.</source>
          <target state="translated">Для улучшения веб-приложений разработчики обратились к поставщикам браузеров с просьбой разрешить междоменные запросы.</target>
        </trans-unit>
        <trans-unit id="dec4c5b25b8efa7a70ca001140b06f9b4fc9abc0" translate="yes" xml:space="preserve">
          <source>To understand which domain should serve the CORS headers, consider this. You visit malicious.com, which contains some JavaScript that tries to make a cross domain request to mybank.com. It should be up to mybank.com, not malicious.com, to decide whether or not it sets CORS headers that relax the same origin policy allowing the JavaScript from malicious.com to interact with it. If malicous.com could set its own CORS headers allowing its own JavaScript access to mybank.com, this would completely nullify the same origin policy.</source>
          <target state="translated">Чтобы понять,какой домен должен обслуживать заголовки CORS,рассмотрим это.Вы посещаете malicious.com,который содержит некоторый JavaScript,пытающийся сделать кросс-запрос домена на mybank.com.Это должно быть до mybank.com,а не malicious.com,чтобы решить,установить или нет CORS заголовки,которые расслабляют ту же самую политику происхождения,позволяя JavaScript от malicious.com,чтобы взаимодействовать с ним.Если бы malicous.com мог установить свои собственные заголовки CORS,разрешающие его собственному JavaScript доступу к mybank.com,это полностью аннулировало бы ту же самую политику происхождения.</target>
        </trans-unit>
        <trans-unit id="7bf85d7014db5e0169f6a290c30265c13b955563" translate="yes" xml:space="preserve">
          <source>Use Flash/Silverlight or server side as a &quot;proxy&quot; to communicate
with remote.</source>
          <target state="translated">Используйте FlashSilverlight или серверную сторону в качестве &quot;прокси-сервера&quot; для связи с удаленными.</target>
        </trans-unit>
        <trans-unit id="54542703a4403c62702b623ce59c580d816c24ad" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;React&lt;/strong&gt; and &lt;strong&gt;Axios&lt;/strong&gt;, join proxy link to the URL and add header as shown below</source>
          <target state="translated">Используя &lt;strong&gt;React&lt;/strong&gt; и &lt;strong&gt;Axios&lt;/strong&gt; , присоедините прокси-ссылку к URL и добавьте заголовок, как показано ниже</target>
        </trans-unit>
        <trans-unit id="a44858f05242a7b455ce62fdc8df88a473321dc7" translate="yes" xml:space="preserve">
          <source>W3C had introduced Cross-Origin Resource Sharing (CORS) as a standard solution to provide a safe, flexible and a recommended standard way to solve this issue.</source>
          <target state="translated">W3C внедрила Cross-Origin Resource Sharing (CORS)в качестве стандартного решения для обеспечения безопасного,гибкого и рекомендуемого стандартного способа решения этой проблемы.</target>
        </trans-unit>
        <trans-unit id="f1278b75a70fd6c5b6a83f2408abb534e43d6ca3" translate="yes" xml:space="preserve">
          <source>Well, I am wrong. It does not work like this at all. So, I have read &lt;a href=&quot;http://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;Cross-origin resource sharing&lt;/a&gt; and attempted to read &lt;a href=&quot;http://www.w3.org/TR/cors/.&quot;&gt;Cross-Origin Resource Sharing in w3c recommendation&lt;/a&gt;</source>
          <target state="translated">Ну, я не прав. Это не работает, как это вообще. Итак, я прочитал &lt;a href=&quot;http://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;разделение ресурсов между источниками&lt;/a&gt; и попытался прочитать &lt;a href=&quot;http://www.w3.org/TR/cors/.&quot;&gt;разделение ресурсов между источниками в рекомендации w3c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="acd1d52dcbd73103ac06849984a12c77293f662b" translate="yes" xml:space="preserve">
          <source>What happens on the network level can be &lt;em&gt;slightly&lt;/em&gt; more complex than explained above. If the request is a &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request&quot;&gt;&quot;non-simple&quot; request&lt;/a&gt;, the browser first sends a data-less &quot;preflight&quot; OPTIONS request, to verify that the server will accept the request. A request is non-simple when either (or both):</source>
          <target state="translated">То, что происходит на уровне сети, может быть &lt;em&gt;немного&lt;/em&gt; сложнее, чем объяснено выше. Если запрос является &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request&quot;&gt;&amp;laquo;непростым&amp;raquo; запросом&lt;/a&gt; , браузер сначала отправляет запрос &amp;laquo;предварительных полетов&amp;raquo; OPTIONS без данных, чтобы убедиться, что сервер примет запрос. Запрос является непростым, когда либо (или оба):</target>
        </trans-unit>
        <trans-unit id="69b9ebc5edfe8d1c244868c40d9107fcf6856520" translate="yes" xml:space="preserve">
          <source>When Site A tries to fetch content from Site B,  Site B can send an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; response header to tell the browser that the content of this page is accessible to certain origins. (An &lt;em&gt;origin&lt;/em&gt; is a &lt;a href=&quot;https://stackoverflow.com/a/19542686/710446&quot;&gt;domain, plus a scheme and port number&lt;/a&gt;.)  By default, Site B's pages are &lt;a href=&quot;https://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;not accessible to any other origin&lt;/a&gt;; using the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header opens a door for cross-origin access by specific requesting origins.</source>
          <target state="translated">Когда сайт A пытается извлечь контент с сайта B, сайт B может отправить заголовок ответа &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; , чтобы сообщить браузеру, что содержимое этой страницы доступно для определенных источников. (Источник - это &lt;a href=&quot;https://stackoverflow.com/a/19542686/710446&quot;&gt;домен, а также схема и номер порта&lt;/a&gt; .) По умолчанию страницы сайта B &lt;a href=&quot;https://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;недоступны для любого другого источника&lt;/a&gt; ; использование заголовка &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; открывает двери для перекрестного доступа по определенным запрашивающим источникам.</target>
        </trans-unit>
        <trans-unit id="e9af21b6fffa981c22773bf6561ab52a3a2c16ad" translate="yes" xml:space="preserve">
          <source>When sending the actual request (after preflight is done), the behavior is identical to how a simple request is handled. In other words, a non-simple request whose preflight is successful is treated the same as a simple request (i.e., the server must still send &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; again for the actual response).</source>
          <target state="translated">При отправке фактического запроса (после выполнения предварительной проверки) поведение идентично тому, как обрабатывается простой запрос. Другими словами, непростой запрос, предпечатная проверка которого успешна, обрабатывается так же, как и простой запрос (т. Е. Сервер все равно должен снова отправить &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; для фактического ответа).</target>
        </trans-unit>
        <trans-unit id="5c2243f9a6f92171c8e09c8e839ba5cb7bfc4bc2" translate="yes" xml:space="preserve">
          <source>Whenever I start thinking about CORS, my intuition about which site hosts the headers is incorrect, just as you described in your question. For me, it helps to think about the purpose of the same origin policy.</source>
          <target state="translated">Всякий раз,когда я начинаю думать о CORS,моя интуиция о том,на каком сайте размещены заголовки,неверна,как вы описали в своем вопросе.Для меня это помогает задуматься о цели той же политики происхождения.</target>
        </trans-unit>
        <trans-unit id="bd36019344446d4d78cea760c6728f16f73a6008" translate="yes" xml:space="preserve">
          <source>Yikes.</source>
          <target state="translated">Yikes.</target>
        </trans-unit>
        <trans-unit id="0df105fca3eb53e9f6af003aa2f59e35fafdf39f" translate="yes" xml:space="preserve">
          <source>You browse to &lt;code&gt;malicious.com&lt;/code&gt;. Malicious makes a bunch of requests to different banks, including &lt;code&gt;yourbank.com&lt;/code&gt;.</source>
          <target state="translated">Вы заходите на сайт &lt;code&gt;malicious.com&lt;/code&gt; . Malicious делает кучу запросов в разные банки, включая &lt;code&gt;yourbank.com&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="575553b8514f130229077f4c265369eae6418abf" translate="yes" xml:space="preserve">
          <source>You're logged in on your browser to &lt;code&gt;yourbank.com&lt;/code&gt;.  You request to see all your accounts.  &lt;code&gt;yourbank.com&lt;/code&gt; receives the pile of cookies and sends back its response (your accounts).</source>
          <target state="translated">Вы вошли в свой браузер на &lt;code&gt;yourbank.com&lt;/code&gt; . Вы просите просмотреть все ваши аккаунты. &lt;code&gt;yourbank.com&lt;/code&gt; получает кучу файлов cookie и отправляет ответ (ваши аккаунты).</target>
        </trans-unit>
        <trans-unit id="76203283d6535a8379e646ae6b32fcc30abf3986" translate="yes" xml:space="preserve">
          <source>a) server side: in file app.js i give headers to all response like:</source>
          <target state="translated">a)на стороне сервера:в файле app.js я даю заголовки всем ответам типа:</target>
        </trans-unit>
        <trans-unit id="5131eb102c64e7b1977894cc40c9e5ca9c90ab5d" translate="yes" xml:space="preserve">
          <source>b) client side: in send ajax you need add: &quot;withCredentials: true,&quot; like:</source>
          <target state="translated">б)клиентская сторона:в отправке ajax нужно добавить:&quot;withCredentials:true,&quot; например:</target>
        </trans-unit>
        <trans-unit id="b20f0919247dbc58bf2955f34f20d7033015f132" translate="yes" xml:space="preserve">
          <source>but i dont need that,</source>
          <target state="translated">но мне это не нужно,</target>
        </trans-unit>
        <trans-unit id="2897789ee2c19bf53c9dc2e8e84ef213689a1c9b" translate="yes" xml:space="preserve">
          <source>good luck.</source>
          <target state="translated">Удачи.</target>
        </trans-unit>
        <trans-unit id="24178e1d2a641a4fcfd1e7606989c6d425edc0c4" translate="yes" xml:space="preserve">
          <source>i work with express 4 and node 7.4 and angular,I had the same problem me help this:</source>
          <target state="translated">Я работаю с экспрессом 4 и узлом 7.4 и угловым,у меня была та же проблема,что и с моей помощью:</target>
        </trans-unit>
        <trans-unit id="d066fab57be4b00b3b31353f308ec42e5e698855" translate="yes" xml:space="preserve">
          <source>no.  It means, Only siteB is allowed to do this request.  So your request for MyCode.js from siteZ gets an error instead, and the browser typically gives you nothing.  But if you make your server return A-C-A-O: siteZ instead, you'll get MyCode.js .  Or if it sends '*', that'll work, that'll let everybody in.  Or if the server always sends the string from the Origin: header... but... for security, if you're afraid of hackers, your server should only allow origins on a shortlist, that are allowed to make those requests.</source>
          <target state="translated">Нет.Это означает,что только сайтВ имеет право делать этот запрос.Таким образом,ваш запрос на MyCode.js с siteZ получает ошибку,а браузер,как правило,ничего не дает.Но если вы заставите ваш сервер вернуть A-C-A-O:siteZ вместо этого,вы получите MyCode.js.Или,если он пошлет &quot;*&quot;,это сработает,это впустит всех.Или если сервер всегда присылает строку из заголовка Origin:...но...для безопасности,если вы боитесь хакеров,ваш сервер должен разрешать только исходные данные из короткого списка,которые разрешены для выполнения этих запросов.</target>
        </trans-unit>
        <trans-unit id="58403ccfa5556c2cca1135361e0a2e51ef732b2a" translate="yes" xml:space="preserve">
          <source>using an HTTP verb other than GET or POST (e.g. PUT, DELETE)</source>
          <target state="translated">используя HTTP глагол,отличный от GET или POST (например,PUT,DELETE).</target>
        </trans-unit>
        <trans-unit id="13a2ea31f53ce7d7d241eaebbc7aa4ec4fd25d28" translate="yes" xml:space="preserve">
          <source>using non-simple request headers; the only simple requests headers are:</source>
          <target state="translated">с использованием непростых заголовков запросов;единственными простыми заголовками запросов являются заголовки:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
