<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1014861">
    <body>
      <group id="1014861">
        <trans-unit id="7b397ba52ee94766842947b88cacc5d7c45eb414" translate="yes" xml:space="preserve">
          <source>(Copy and pasted from the URL above).</source>
          <target state="translated">从上面的URL复制粘贴)。</target>
        </trans-unit>
        <trans-unit id="705bae603e7f65e8924343357e7788723ac06749" translate="yes" xml:space="preserve">
          <source>(compare the two lists on the left styled with standard selectors and the two lists on the right styled with axe selectors)</source>
          <target state="translated">(比较左边的两个列表使用标准选择器,右边的两个列表使用斧头选择器)</target>
        </trans-unit>
        <trans-unit id="d27f20f24403a2ee408f76161810e65b625ac349" translate="yes" xml:space="preserve">
          <source>... I'm hoping that there is some sort of workaround that exists native to CSS Level 2...</source>
          <target state="translated">...我希望在CSS Level 2中能有某种原生的解决方法......</target>
        </trans-unit>
        <trans-unit id="82e0198d7fb554ce11dda78b7187f808521eff94" translate="yes" xml:space="preserve">
          <source>... but for things like &lt;code&gt;::after&lt;/code&gt; and &lt;code&gt;:hover&lt;/code&gt;, I'm not at all certain in which CSS version those first appeared.</source>
          <target state="translated">...但是对于 &lt;code&gt;::after&lt;/code&gt; 和 &lt;code&gt;:hover&lt;/code&gt; 之类的东西，我完全不确定那些最初出现在哪个CSS版本中。</target>
        </trans-unit>
        <trans-unit id="eddc39850fc9dfc650c1fd65c41dbbc827922439" translate="yes" xml:space="preserve">
          <source>... pretty &lt;em&gt;gross&lt;/em&gt;, but with just CSS and HTML it is possible to touch and re-touch anything but the &lt;code&gt;body&lt;/code&gt; and &lt;code&gt;:root&lt;/code&gt; from just about anywhere by linking the &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt; properties of &lt;code&gt;radio&lt;/code&gt;/&lt;code&gt;checkbox&lt;/code&gt;&lt;em&gt;&lt;code&gt;input&lt;/code&gt;s&lt;/em&gt; and &lt;code&gt;label&lt;/code&gt;&lt;em&gt;triggers&lt;/em&gt;; likely someone'll show how to re-touch those at some point.</source>
          <target state="translated">...相当&lt;em&gt;粗略&lt;/em&gt; ，但是仅使用CSS和HTML，就可以通过链接 &lt;code&gt;id&lt;/code&gt; 以及 &lt;code&gt;radio&lt;/code&gt; / &lt;code&gt;checkbox&lt;/code&gt; &lt;em&gt; &lt;code&gt;input&lt;/code&gt; s&lt;/em&gt;和 &lt;code&gt;label&lt;/code&gt; &lt;em&gt;触发器的&lt;/em&gt;属性从几乎任何地方触摸和重新触摸除 &lt;code&gt;body&lt;/code&gt; 和 &lt;code&gt;:root&lt;/code&gt; 之外的任何东西； 可能有人会在某个时候展示如何重新修饰它们。</target>
        </trans-unit>
        <trans-unit id="8b043cba9ff6a55d3381955a4bd58a718bc7edc7" translate="yes" xml:space="preserve">
          <source>3.2. The Nesting At-Rule: @nest</source>
          <target state="translated">3.2.The Nesting At-Rule:@nest</target>
        </trans-unit>
        <trans-unit id="3da93df5d2b54ef90c349bf508b3a08d5eddf8b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://css-tricks.com/parent-selectors-in-css/&quot;&gt;Chris Coyier on the talks of Parent selector&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://css-tricks.com/parent-selectors-in-css/&quot;&gt;克里斯&amp;middot;科耶尔（Chris Coyier）在家长选择者的谈话中&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6ec4d61fd9ab8aae629c7bd115d45fe7e27e7b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://csswizardry.com/2011/09/writing-efficient-css-selectors/&quot;&gt;Harry Roberts again on writing efficient CSS selectors&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://csswizardry.com/2011/09/writing-efficient-css-selectors/&quot;&gt;哈里&amp;middot;罗伯茨（Harry Roberts）再次致力于编写高效的CSS选择器&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="38a1f468f30c6d5ab191612fbceaee120b26a668" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://elementqueries.com/demos/parent.html&quot;&gt;Here's a demo of &lt;code&gt;$parent&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://staticresource.com/parent.html&quot;&gt;another &lt;code&gt;$parent&lt;/code&gt; demo that works in Internet&amp;nbsp;Explorer&amp;nbsp;8&lt;/a&gt;, as well as &lt;a href=&quot;https://i.imgur.com/QyVAj2u.png&quot;&gt;a screenshot in case you don't have Internet&amp;nbsp;Explorer&amp;nbsp;8 around to test with&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://elementqueries.com/demos/parent.html&quot;&gt;这是一个&lt;/a&gt; &lt;a href=&quot;http://staticresource.com/parent.html&quot;&gt; &lt;code&gt;$parent&lt;/code&gt; 演示&lt;/a&gt;和另一个在Internet Explorer 8中工作的$ parent演示，以及&lt;a href=&quot;https://i.imgur.com/QyVAj2u.png&quot;&gt;一个屏幕快照，以防您没有Internet Explorer 8可以进行测试&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f14858af83fb794e7da625e0923603d47a5ac8b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://snook.ca/archives/html_and_css/css-parent-selectors&quot;&gt;Jonathan Snook explains how CSS is evaluated&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://snook.ca/archives/html_and_css/css-parent-selectors&quot;&gt;Jonathan Snook解释了如何评估CSS&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef35928c432b9c4253e81fbd92a966eae480f52c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jsfiddle.net/ilyabogdanov/o4fkL7kv/&quot;&gt;Another example&lt;/a&gt; how to use it with text-inputs - select parent fieldset</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/ilyabogdanov/o4fkL7kv/&quot;&gt;另一个&lt;/a&gt;如何与文本输入一起使用的示例 -选择父字段集</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59126bc4b62e268cb8bfd989e38d43eaba68ba53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;axe&lt;/strong&gt; is presently in a relatively early BETA stage of development.</source>
          <target state="translated">&lt;strong&gt;斧头&lt;/strong&gt;目前处于BETA的相对早期开发阶段。</target>
        </trans-unit>
        <trans-unit id="0a33cff9020a55fa3185256ec7c4be09e6bf6115" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="581b2a4bc4f69b824674b1fafce3cebe87835ff7" translate="yes" xml:space="preserve">
          <source>Although there is no parent selector in standard CSS at present, I am working on a (personal) project called &lt;strong&gt;axe&lt;/strong&gt; (ie. &lt;em&gt;Augmented CSS Selector Syntax / ACSSSS&lt;/em&gt;) which, among its 7 new selectors, includes both:</source>
          <target state="translated">尽管目前标准CSS中没有父选择器，但是我正在开发一个名为&lt;strong&gt;ax&lt;/strong&gt; （即&lt;em&gt;CSS增强选择器语法/ ACSSSS&lt;/em&gt; ）的（个人）项目，该项目在其7个新选择器中包括：</target>
        </trans-unit>
        <trans-unit id="cd78f2ac716d2cda34f6ca00275c12ae8f213f6e" translate="yes" xml:space="preserve">
          <source>An element can be focused if it has a &lt;code&gt;tabindex&lt;/code&gt; attribute.</source>
          <target state="translated">如果元素具有 &lt;code&gt;tabindex&lt;/code&gt; 属性，则可以对其进行聚焦。</target>
        </trans-unit>
        <trans-unit id="69ad4e17d87b7e2b85b003e0a8823937ee0cb2eb" translate="yes" xml:space="preserve">
          <source>And then simply:</source>
          <target state="translated">然后干脆。</target>
        </trans-unit>
        <trans-unit id="c87d339dfeeb0ffcb18ef3ea996bc725cc487ee7" translate="yes" xml:space="preserve">
          <source>Any ideas?</source>
          <target state="translated">有什么想法吗?</target>
        </trans-unit>
        <trans-unit id="46da08d1043ad879cdcc45e6f65a18f2928a64da" translate="yes" xml:space="preserve">
          <source>As an example, my CSS would be something like this:</source>
          <target state="translated">举例来说,我的CSS是这样的。</target>
        </trans-unit>
        <trans-unit id="f30ffa0dd6e130ff96540648031fcd83f6808c90" translate="yes" xml:space="preserve">
          <source>As mentioned by a couple of others, there isn't a way to style an element's parent/s using just CSS but the following works with &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;:</source>
          <target state="translated">正如其他一些人提到的那样，没有一种方法可以仅使用CSS来样式化元素的父元素，但是以下方法可用于&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="ad5b8a09eccf6abdc58ead5f76417e9e20fb8e36" translate="yes" xml:space="preserve">
          <source>At least up to and including CSS&amp;nbsp;3 you cannot select like that.
But it can be done pretty easily nowadays in JavaScript, you just need to add a bit of vanilla JavaScript, notice that the code is pretty short.</source>
          <target state="translated">至少不能包括CSS 3那样选择。 但是，如今使用JavaScript可以很容易地做到这一点，您只需要添加一些普通的JavaScript，请注意代码很短。</target>
        </trans-unit>
        <trans-unit id="43449dc9ba2bd2b62b86c3428241f7e4790aaf86" translate="yes" xml:space="preserve">
          <source>BTW, it works in Internet&amp;nbsp;Explorer.</source>
          <target state="translated">顺便说一句，它可以在Internet Explorer中使用。</target>
        </trans-unit>
        <trans-unit id="fb13078eac3f8b09b86d5eef2f091a49b9e6bc9b" translate="yes" xml:space="preserve">
          <source>Browser support for focus-within</source>
          <target state="translated">浏览器支持 &quot;内聚焦 &quot;功能</target>
        </trans-unit>
        <trans-unit id="2aee8f3ddcd99c50c0e1366c2789e0a30beb2659" translate="yes" xml:space="preserve">
          <source>Browser support: &lt;a href=&quot;https://caniuse.com/#feat=css-has&quot;&gt;none&lt;/a&gt;</source>
          <target state="translated">浏览器支持： &lt;a href=&quot;https://caniuse.com/#feat=css-has&quot;&gt;无&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a3e5d0dc70b9f32887f6a06fe04c38bba9810f51" translate="yes" xml:space="preserve">
          <source>But &lt;a href=&quot;http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/&quot;&gt;Nicole Sullivan has some interesting facts on positive trends&lt;/a&gt;.</source>
          <target state="translated">但是&lt;a href=&quot;http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/&quot;&gt;妮可&amp;bull;沙利文（Nicole Sullivan）对于积极趋势有一些有趣的事实&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="6effa79c887dd8d50614b8719d9ff351118d26aa" translate="yes" xml:space="preserve">
          <source>But as you already seem to have an &lt;code&gt;.active&lt;/code&gt; class, it would be easier to move that class to the &lt;code&gt;li&lt;/code&gt; (instead of the &lt;code&gt;a&lt;/code&gt;). That way you can access both the &lt;code&gt;li&lt;/code&gt; and the &lt;code&gt;a&lt;/code&gt; via CSS only.</source>
          <target state="translated">但是，由于您似乎已经具有 &lt;code&gt;.active&lt;/code&gt; 类，因此将该类移到 &lt;code&gt;li&lt;/code&gt; （而不是 &lt;code&gt;a&lt;/code&gt; ）会更容易。 这样，您只能通过CSS访问 &lt;code&gt;li&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f6985a9d0eb315212432208d6414fa92b4733f0" translate="yes" xml:space="preserve">
          <source>But we have to wait for browsers' implementation :(</source>
          <target state="translated">但我们必须等待浏览器的实现 :(</target>
        </trans-unit>
        <trans-unit id="61681cfa05004a759407afbe83568d2e0493d3f2" translate="yes" xml:space="preserve">
          <source>CSS 2.1 Selectors Spec</source>
          <target state="translated">CSS 2.1 选择器规格</target>
        </trans-unit>
        <trans-unit id="1dccedaba4e0a58fadb2e33c024826e8f5a099f0" translate="yes" xml:space="preserve">
          <source>CSS 4 will be fancy if it adds some &lt;em&gt;hooks&lt;/em&gt; into &lt;em&gt;walking backwards&lt;/em&gt;. Till then it is possible (though &lt;strong&gt;not&lt;/strong&gt; advisable) to use &lt;code&gt;checkbox&lt;/code&gt; and/or &lt;code&gt;radio&lt;/code&gt;&lt;em&gt;&lt;code&gt;input&lt;/code&gt;s&lt;/em&gt; to &lt;em&gt;break&lt;/em&gt; the usual way that things are connected, and through that also allow CSS to operate outside of its normal scope...</source>
          <target state="translated">如果CSS 4 &lt;em&gt;向后走&lt;/em&gt;时增加了一些&lt;em&gt;钩子，&lt;/em&gt;它将非常有用。 到那时为止，有可能（尽管&lt;strong&gt;不&lt;/strong&gt;建议）使用 &lt;code&gt;checkbox&lt;/code&gt; 和/或 &lt;code&gt;radio&lt;/code&gt; &lt;em&gt; &lt;code&gt;input&lt;/code&gt; &lt;/em&gt;来&lt;em&gt;打破&lt;/em&gt;连接事物的常用方式，并通过这种方式还可以使CSS在其正常范围之外运行。</target>
        </trans-unit>
        <trans-unit id="dab33d9e23d7eb31831e879a062b7f5917762fda" translate="yes" xml:space="preserve">
          <source>CSS output:</source>
          <target state="translated">CSS输出。</target>
        </trans-unit>
        <trans-unit id="3b5005583c3ac04422c049fe373d867e888072be" translate="yes" xml:space="preserve">
          <source>Changing parent element based on child element can currently only happen when we have an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element inside the parent element. When an input gets focus, its corresponding parent element can get affected using CSS.</source>
          <target state="translated">当前只有在父元素内有 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 元素时，才可以基于子元素更改父元素。 当输入获得焦点时，其相应的父元素会受到CSS的影响。</target>
        </trans-unit>
        <trans-unit id="18556e9ea9f9b7f6726983bf605220880f25984b" translate="yes" xml:space="preserve">
          <source>Check out this HTML:</source>
          <target state="translated">看看这个HTML。</target>
        </trans-unit>
        <trans-unit id="c5bb43480ad4b78749fb66e153d30232a52d93b0" translate="yes" xml:space="preserve">
          <source>Currently there is no parent selector &amp;amp; it is not even being discussed in any of the talks of W3C. You need to understand how CSS is evaluated by the browser to actually understand if we need it or not.</source>
          <target state="translated">当前没有父选择器，并且W3C的任何讨论中都没有讨论它。 您需要了解浏览器如何评估CSS，才能真正了解我们是否需要它。</target>
        </trans-unit>
        <trans-unit id="4eef675c1b4319602fca50d2de01a62cb4a97177" translate="yes" xml:space="preserve">
          <source>EQCSS also includes &lt;a href=&quot;http://elementqueries.com/#meta-selectors&quot;&gt;meta-selectors&lt;/a&gt;: &lt;code&gt;$prev&lt;/code&gt; for the element before a selected element and &lt;code&gt;$this&lt;/code&gt; for only those elements that match an element query, and more.</source>
          <target state="translated">EQCSS还包括&lt;a href=&quot;http://elementqueries.com/#meta-selectors&quot;&gt;元选择器&lt;/a&gt; ： &lt;code&gt;$prev&lt;/code&gt; 用于元素在选定元素之前， &lt;code&gt;$this&lt;/code&gt; 仅用于那些与元素查询匹配的元素，等等。</target>
        </trans-unit>
        <trans-unit id="3b640aba86fcca65dec1908b6e5c562b31f87dc5" translate="yes" xml:space="preserve">
          <source>Example of valid selectors under this specification:</source>
          <target state="translated">本规范规定的有效选择器的例子。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="464ccf1905e87e5a95c6748de2f236f1f89e0a98" translate="yes" xml:space="preserve">
          <source>Following example will help you understand using &lt;code&gt;:focus-within&lt;/code&gt; in CSS.</source>
          <target state="translated">以下示例将帮助您了解在CSS中使用 &lt;code&gt;:focus-within&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="f50f072fe39c030829e35c9b8a3624078bf644d8" translate="yes" xml:space="preserve">
          <source>Here's a hack using &lt;code&gt;pointer-events&lt;/code&gt; with &lt;code&gt;hover&lt;/code&gt;:</source>
          <target state="translated">这是将 &lt;code&gt;pointer-events&lt;/code&gt; 与 &lt;code&gt;hover&lt;/code&gt; 使用的一种技巧：</target>
        </trans-unit>
        <trans-unit id="b611322ac06e504df2ce1ba1df17c7e673e24596" translate="yes" xml:space="preserve">
          <source>How do I select the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element that is a direct parent of the anchor element?</source>
          <target state="translated">如何选择作为锚元素直接父元素的 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 元素？</target>
        </trans-unit>
        <trans-unit id="6ffd2b70834f91480e84a36fbbcb343068436409" translate="yes" xml:space="preserve">
          <source>However, you can do something like this as well.</source>
          <target state="translated">不过,你也可以这样做。</target>
        </trans-unit>
        <trans-unit id="a5bd05eb13e3214b3adc618685843351edaf7a3e" translate="yes" xml:space="preserve">
          <source>I am not sure about the other &lt;code&gt;:&lt;/code&gt; selectors, but I &lt;code&gt;:checked&lt;/code&gt; for pre-CSS&amp;nbsp;3. If I remember correctly, it was something like &lt;code&gt;[checked]&lt;/code&gt; which is why you may find it in the above code, for example,</source>
          <target state="translated">我不确定其他 &lt;code&gt;:&lt;/code&gt; 选择器，但我 &lt;code&gt;:checked&lt;/code&gt; 了CSS 3之前的版本。如果我没记错的话，它就像 &lt;code&gt;[checked]&lt;/code&gt; 之类 ，这就是为什么您可以在上面的代码中找到它的原因，例如，</target>
        </trans-unit>
        <trans-unit id="196213724285ce38a731fd4d44cc552e824831f8" translate="yes" xml:space="preserve">
          <source>I don&amp;rsquo;t think you can select the parent in CSS only.</source>
          <target state="translated">我认为您只能在CSS中选择父级。</target>
        </trans-unit>
        <trans-unit id="16c4776cbb70e04fad7c494fb5241e5d112347a8" translate="yes" xml:space="preserve">
          <source>I know the OP was looking for a CSS solution but it is simple to achieve using jQuery. In my case I needed to find the &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; parent tag for a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; tag contained in the child &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;. jQuery has the &lt;code&gt;:has&lt;/code&gt; selector so it's possible to identify a parent by the children it contains:</source>
          <target state="translated">我知道OP一直在寻找CSS解决方案，但是使用jQuery很容易实现。 在我的情况下，我需要为子 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 中包含的 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 标签找到 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 父标签。 jQuery具有 &lt;code&gt;:has&lt;/code&gt; 选择器，因此可以通过其包含的子代来标识父代：</target>
        </trans-unit>
        <trans-unit id="dfe5220200994dbee3e70035d15507704322a597" translate="yes" xml:space="preserve">
          <source>I'd hire some JavaScript code to do that. For example, in React when you iterate over an array, add another class to the parent component, which indicates it contains your children:</source>
          <target state="translated">我会雇佣一些JavaScript代码来做这个事情。例如,在React中,当你迭代一个数组时,在父组件中添加另一个类,表示它包含你的子组件。</target>
        </trans-unit>
        <trans-unit id="70662a08d8251062a3671c0306a258aefc83c674" translate="yes" xml:space="preserve">
          <source>If there was a way to do it, it would be in either of the current CSS selectors specs:</source>
          <target state="translated">如果有办法的话,就会在目前的CSS选择器规格中的任何一个中。</target>
        </trans-unit>
        <trans-unit id="6f922b4a2d0b8bb48f6cf2ff662f85897aeb2004" translate="yes" xml:space="preserve">
          <source>If you want to achieve this using jQuery here is the reference for the &lt;a href=&quot;http://www.snoopcode.com/jquery/jquery-parent-selector&quot;&gt;jQuery parent selector&lt;/a&gt;.</source>
          <target state="translated">如果要使用jQuery实现此目的，请参考&lt;a href=&quot;http://www.snoopcode.com/jquery/jquery-parent-selector&quot;&gt;jQuery父选择器&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="d65e5da9c83a072af4ee2b07ecb88b8f0f120074" translate="yes" xml:space="preserve">
          <source>In the meantime, you'll have to resort to JavaScript if you need to select a parent element.</source>
          <target state="translated">在此期间,如果你需要选择父元素,你将不得不求助于JavaScript。</target>
        </trans-unit>
        <trans-unit id="f16c306ee15fdd03dfd636b9bce7c73b96e2dda9" translate="yes" xml:space="preserve">
          <source>Is there a CSS parent selector</source>
          <target state="translated">是否有一个CSS父选择器</target>
        </trans-unit>
        <trans-unit id="13ec5a3a448276a5a42986cd1ef56bef5b48f756" translate="yes" xml:space="preserve">
          <source>It's now 2019, and the &lt;a href=&quot;https://drafts.csswg.org/css-nesting-1/&quot;&gt;latest draft of the CSS Nesting Module&lt;/a&gt; actually has something like this. Introducing &lt;code&gt;@nest&lt;/code&gt; at-rules.</source>
          <target state="translated">现在是2019年， &lt;a href=&quot;https://drafts.csswg.org/css-nesting-1/&quot;&gt;CSS嵌套模块&lt;/a&gt;的最新草案实际上就是这样。 介绍 &lt;code&gt;@nest&lt;/code&gt; 规则。</target>
        </trans-unit>
        <trans-unit id="4b931fd1efc1773a431641d534b7304ded42decc" translate="yes" xml:space="preserve">
          <source>It's possible with ampersand in &lt;a href=&quot;http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29&quot;&gt;Sass&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29&quot;&gt;Sass中的&lt;/a&gt; ＆符是可能的：</target>
        </trans-unit>
        <trans-unit id="74301d932f63fc4e123ec9936b949e5886c20f87" translate="yes" xml:space="preserve">
          <source>Just an idea for horizontal menu...</source>
          <target state="translated">只是一个横向菜单的想法.....</target>
        </trans-unit>
        <trans-unit id="47023b4c7e50240fc29adb73ee5120bc8d7e6ed8" translate="yes" xml:space="preserve">
          <source>No, you cannot select the parent in CSS only.</source>
          <target state="translated">不是的,你不能只在CSS中选择父体。</target>
        </trans-unit>
        <trans-unit id="20e18f525ed9580c55fc072a10875e2a19f1cdef" translate="yes" xml:space="preserve">
          <source>Not in CSS 2 as far as I'm aware.  CSS 3 has more robust selectors but is not consistently implemented across all browsers.  Even with the improved selectors, I don't believe it will accomplish exactly what you've specified in your example.</source>
          <target state="translated">据我所知,CSS 2中没有。CSS 3有更强大的选择器,但并不是所有浏览器都能一致实现。即使有了改进后的选择器,我不相信它能达到你的例子中所指定的效果。</target>
        </trans-unit>
        <trans-unit id="8c22cb9ba25f96a44e36262373ee0c19158feb75" translate="yes" xml:space="preserve">
          <source>Obviously there are ways of doing this with JavaScript, but I'm hoping that there is some sort of workaround that exists native to CSS Level 2.</source>
          <target state="translated">很明显,JavaScript有一些方法可以做到这一点,但我希望有一些原生的CSS Level 2的工作方法。</target>
        </trans-unit>
        <trans-unit id="234c99c2581b8c6536fb11fe85dcb8d8997ba0cb" translate="yes" xml:space="preserve">
          <source>One additional caveat is that only &lt;strong&gt;one&lt;/strong&gt;&lt;code&gt;input&lt;/code&gt; of a specific &lt;code&gt;id&lt;/code&gt; maybe used, first &lt;code&gt;checkbox&lt;/code&gt;/&lt;code&gt;radio&lt;/code&gt;&lt;em&gt;wins&lt;/em&gt; a toggled state in other words... &lt;strong&gt;But&lt;/strong&gt; multiple labels can all point to the same &lt;code&gt;input&lt;/code&gt;, though that would make both the HTML and CSS look even grosser.</source>
          <target state="translated">另外一个警告是，只能使用一个特定 &lt;code&gt;id&lt;/code&gt; 的 &lt;code&gt;input&lt;/code&gt; ，换句话说，第一个 &lt;code&gt;checkbox&lt;/code&gt; / &lt;code&gt;radio&lt;/code&gt; &lt;em&gt;赢得&lt;/em&gt;切换状态... &lt;strong&gt;但是&lt;/strong&gt;多个标签都可以指向同一个 &lt;code&gt;input&lt;/code&gt; ，尽管这会使HTML和CSS看起来甚至更大。</target>
        </trans-unit>
        <trans-unit id="dad84c76aa649120afe0f6e800a2dd0ebf6d391f" translate="yes" xml:space="preserve">
          <source>One of the things EQCSS adds is a parent selector. It works in all browsers, Internet&amp;nbsp;Explorer&amp;nbsp;8 and up. Here's the format:</source>
          <target state="translated">EQCSS添加的一件事是父选择器。 它适用于所有浏览器，Internet Explorer 8及更高版本。 格式如下：</target>
        </trans-unit>
        <trans-unit id="a02dc6e19f4de7ac398851a48b96aa66b7230018" translate="yes" xml:space="preserve">
          <source>Or a shorter way if you use &lt;strong&gt;jQuery&lt;/strong&gt; in your application:</source>
          <target state="translated">如果您在应用程序中使用&lt;strong&gt;jQuery&lt;/strong&gt; ，则可以使用更短的方法：</target>
        </trans-unit>
        <trans-unit id="43800482e3beb106c88c7aaf358738953555e1f3" translate="yes" xml:space="preserve">
          <source>Or select it when it's active:</source>
          <target state="translated">或者在活动的时候选择它。</target>
        </trans-unit>
        <trans-unit id="ca5bd20a655a2bc4968ade970397decdfd873fd9" translate="yes" xml:space="preserve">
          <source>Part of CSS</source>
          <target state="translated">CSS的一部分</target>
        </trans-unit>
        <trans-unit id="f2cdaf3876200e6785af9542210009f91d3480c1" translate="yes" xml:space="preserve">
          <source>Part of HTML</source>
          <target state="translated">HTML的一部分</target>
        </trans-unit>
        <trans-unit id="01da1613b2040aa32ee1cde9b1a6656ac4994461" translate="yes" xml:space="preserve">
          <source>See a demo here:</source>
          <target state="translated">请看这里的演示。</target>
        </trans-unit>
        <trans-unit id="0b82b256a797a7919f29e1212ab0fa27a680b419" translate="yes" xml:space="preserve">
          <source>Selectors Level 3 Spec</source>
          <target state="translated">选择器3级规格</target>
        </trans-unit>
        <trans-unit id="fd5cee2f3389e51c22f44f6ab1db6f1e89aebf1f" translate="yes" xml:space="preserve">
          <source>So here we've opened an element query on every element &lt;code&gt;a.active&lt;/code&gt;, and for the styles inside that query, things like &lt;code&gt;$parent&lt;/code&gt; make sense, because there's a reference point. The browser can find the parent, because it's very similar to &lt;code&gt;parentNode&lt;/code&gt; in JavaScript.</source>
          <target state="translated">因此，这里我们在每个元素 &lt;code&gt;a.active&lt;/code&gt; 上打开了一个元素查询，对于该查询中的样式， &lt;code&gt;$parent&lt;/code&gt; 类的东西很有意义，因为有一个参考点。 浏览器可以找到父级，因为它与JavaScript中的 &lt;code&gt;parentNode&lt;/code&gt; 非常相似。</target>
        </trans-unit>
        <trans-unit id="52a2c95be3c108c186043953d9e9e35ce7f66497" translate="yes" xml:space="preserve">
          <source>Tabindex</source>
          <target state="translated">Tabindex</target>
        </trans-unit>
        <trans-unit id="9bd7792b2744f0d1b786cf5d8d866a187ed9a7c0" translate="yes" xml:space="preserve">
          <source>Technically there is no direct way to do this. However, you can sort that out with either jQuery or JavaScript.</source>
          <target state="translated">在技术上,没有直接的方法可以做到这一点。不过,你可以用jQuery或JavaScript来解决。</target>
        </trans-unit>
        <trans-unit id="4eaef36c3573d5075574bb5d85ee107c8ad1986a" translate="yes" xml:space="preserve">
          <source>That all stated, please don't ever use this in production, not even in anger. As a joke sure, or in other words just because something &lt;em&gt;can&lt;/em&gt; be done does not always mean it &lt;em&gt;should&lt;/em&gt;.</source>
          <target state="translated">综上所述，请不要在生产中使用它，甚至不要生气。 开个玩笑，或者说仅仅是因为&lt;em&gt;可以&lt;/em&gt;做某事并不总是意味着&lt;em&gt;应该做&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a629de3f83fd6a1d08af4cc79dae0063f03bb926" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://dev.w3.org/csswg/selectors4/#relational&quot;&gt;Selectors Level 4 Working Draft&lt;/a&gt; includes a &lt;code&gt;:has()&lt;/code&gt; pseudo-class that works the same as the &lt;a href=&quot;https://api.jquery.com/has-selector/&quot;&gt;jQuery implementation&lt;/a&gt;. As of 2019, &lt;strong&gt;&lt;a href=&quot;https://caniuse.com/#feat=css-has&quot;&gt;this is still not supported by any browser&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://dev.w3.org/csswg/selectors4/#relational&quot;&gt;选择器第4级工作草案&lt;/a&gt;包括 &lt;code&gt;:has()&lt;/code&gt; 伪类，其工作原理与&lt;a href=&quot;https://api.jquery.com/has-selector/&quot;&gt;jQuery实现&lt;/a&gt;相同。 截至2019年， &lt;strong&gt;&lt;a href=&quot;https://caniuse.com/#feat=css-has&quot;&gt;任何浏览器仍不支持此功能&lt;/a&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="28e1654c9ed1b1cc0caadd43d65e06ae4949ab6f" translate="yes" xml:space="preserve">
          <source>The @nest rule functions identically to a style rule: it starts with a selector, and contains declarations that apply to the elements the selector matches. The only difference is that the selector used in a @nest rule must be nest-containing, which means it contains a nesting selector in it somewhere. A list of selectors is nest-containing if all of its individual complex selectors are nest-containing.</source>
          <target state="translated">@nest规则的功能与样式规则相同:它以选择器开始,并包含适用于选择器匹配的元素的声明。唯一不同的是,@nest规则中使用的选择器必须是包含嵌套的,这意味着它的某个地方包含了一个嵌套选择器。如果一个选择器列表中的所有复数选择器都是嵌套的,那么这个选择器列表就是包含嵌套的。</target>
        </trans-unit>
        <trans-unit id="18e42931d9416cdf818b4232a0135af47f2e5f6b" translate="yes" xml:space="preserve">
          <source>The CSS selector &amp;ldquo;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_selectors&quot;&gt;General Sibling Combinator&lt;/a&gt;&amp;rdquo; could maybe used for what you want:</source>
          <target state="translated">CSS选择器&amp;ldquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_selectors&quot;&gt;General Sibling Combinator&lt;/a&gt; &amp;rdquo;可能用于您想要的内容：</target>
        </trans-unit>
        <trans-unit id="b018e3bf2d2a2a0a6d77db0e353a74d400c77660" translate="yes" xml:space="preserve">
          <source>The W3C excluded such a selector because of the huge performance impact it would have on a browser.</source>
          <target state="translated">W3C排除了这样的选择器,因为它将对浏览器的性能产生巨大的影响。</target>
        </trans-unit>
        <trans-unit id="b456d9cbdcf9b8cd585766201d57b3476c428074" translate="yes" xml:space="preserve">
          <source>The article &lt;em&gt;&lt;a href=&quot;http://snook.ca/archives/html_and_css/css-parent-selectors&quot;&gt;Why we don't have a parent selector&lt;/a&gt;&lt;/em&gt; explains it in detail.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://snook.ca/archives/html_and_css/css-parent-selectors&quot;&gt;为什么我们没有父选择器&lt;/a&gt;&lt;/em&gt;的文章&lt;em&gt;对此做&lt;/em&gt;了详细说明。</target>
        </trans-unit>
        <trans-unit id="801acbc757fcb57499e82fcad44f7ba6ab312dfc" translate="yes" xml:space="preserve">
          <source>The menu that I am trying to style is being spewed out by a CMS, so I can't move the active element to the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element... (unless I theme the menu creation module which I'd rather not do).</source>
          <target state="translated">我正在尝试设置样式的菜单已由CMS弹出，因此我无法将活动元素移动到 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 元素...（除非我将菜单创建模块作为主题，但我不希望这样做） 。</target>
        </trans-unit>
        <trans-unit id="7795ddddbd1162f3d3bf7ad4e15c37d50aa7a07a" translate="yes" xml:space="preserve">
          <source>The pseudo element &lt;code&gt;:focus-within&lt;/code&gt; allows a parent to be selected if a descendent has focus.</source>
          <target state="translated">如果后代具有焦点，则伪元素 &lt;code&gt;:focus-within&lt;/code&gt; 允许选择父对象。</target>
        </trans-unit>
        <trans-unit id="6871a464234ef2e2de2e8af814ef8a3bdbc58428" translate="yes" xml:space="preserve">
          <source>The short answer is &lt;strong&gt;NO&lt;/strong&gt;; we don't have a &lt;code&gt;parent selector&lt;/code&gt; at this stage in CSS, but if you don't have to swap the elements or classes anyway, the second option is using JavaScript. Something like this:</source>
          <target state="translated">简短的答案是否; 在CSS的现阶段，我们没有 &lt;code&gt;parent selector&lt;/code&gt; ，但是如果您仍然不必交换元素或类，第二个选择是使用JavaScript。 像这样：</target>
        </trans-unit>
        <trans-unit id="71729e03cfb9f3fd601d1a7ab83c941bcfc92b47" translate="yes" xml:space="preserve">
          <source>Then the browser will have to wait until it has loaded and parsed everything until the &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; to determine if the page should be red or not.</source>
          <target state="translated">然后，浏览器将不得不等待，直到它加载并解析了所有内容，直到 &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; 确定该页面是否应为红色。</target>
        </trans-unit>
        <trans-unit id="d00d805d268185840395c641e28b3bc5add4b860" translate="yes" xml:space="preserve">
          <source>There are many more capabilities; just check out the documentation of the plugin.</source>
          <target state="translated">还有很多功能;查看插件的文档就可以了。</target>
        </trans-unit>
        <trans-unit id="e67cea1b2a161c6681e116a6774619d3f84b1bd3" translate="yes" xml:space="preserve">
          <source>There is a lot of technical explanation here.</source>
          <target state="translated">这里有很多技术上的解释。</target>
        </trans-unit>
        <trans-unit id="afc3a63e369a4fed52f8738f4589c056fb25ee8d" translate="yes" xml:space="preserve">
          <source>There is currently no way to select the parent of an element in CSS.</source>
          <target state="translated">目前还没有办法在CSS中选择一个元素的父元素。</target>
        </trans-unit>
        <trans-unit id="64126c1f70e0ad510ec815dd95643cda6db57054" translate="yes" xml:space="preserve">
          <source>There is no parent selector; just the way there is no previous sibling selector. One good reason for not having these selectors is because the browser has to traverse through all children of an element to determine whether or not a class should be applied. For example, if you wrote:</source>
          <target state="translated">没有父选择器;就像没有上一个兄弟姐妹选择器一样。没有这些选择器的一个很好的原因是,浏览器必须遍历一个元素的所有子元素来决定是否应该应用一个类。例如,如果你写了:</target>
        </trans-unit>
        <trans-unit id="b4ca2e90f6a7c0b5a95dec74a07e5bdd9c96f44e" translate="yes" xml:space="preserve">
          <source>There isn't a way to do this in CSS&amp;nbsp;2. You could add the class to the &lt;code&gt;li&lt;/code&gt; and reference the &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">CSS 2中没有做到这一点的方法。您可以将类添加到 &lt;code&gt;li&lt;/code&gt; 并引用 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2a34e62954344c0300972e93384773fea6391d93" translate="yes" xml:space="preserve">
          <source>There no css (and therefore in css preprocessors) parent selector due to &quot;The major reasons for the CSS Working Group previously rejecting proposals for parent selectors are related to browser performance and incremental rendering issues.&quot;</source>
          <target state="translated">没有css(因此在css预处理程序中)父选择器,原因是 &quot;CSS工作组之前拒绝父选择器的建议的主要原因与浏览器性能和增量渲染问题有关。&quot;</target>
        </trans-unit>
        <trans-unit id="18d3bacd368887644309231e77445d8201da133f" translate="yes" xml:space="preserve">
          <source>There's a plugin that extends CSS to include some non-standard features that can really help when designing websites. It's called &lt;a href=&quot;http://elementqueries.com&quot;&gt;EQCSS&lt;/a&gt;.</source>
          <target state="translated">有一个扩展CSS的插件，其中包含一些非标准功能，这些功能在设计网站时会真正提供帮助。 它称为&lt;a href=&quot;http://elementqueries.com&quot;&gt;EQCSS&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebd3737a340ed903c39226bcb7604071a5298840" translate="yes" xml:space="preserve">
          <source>These people are all top class in the field of front end development.</source>
          <target state="translated">这些人在前端开发领域都是一流的。</target>
        </trans-unit>
        <trans-unit id="60157f44e253a7ae7ce43a373250de2567d3b3e7" translate="yes" xml:space="preserve">
          <source>This is the most discussed aspect of the &lt;strong&gt;Selectors Level 4&lt;/strong&gt; specification.
With this, a selector will be able to style an element according to its child by using an exclamation mark after the given selector (!).</source>
          <target state="translated">这是&lt;strong&gt;选择器4级&lt;/strong&gt;规范中讨论最多的方面。 这样，选择器将能够通过在给定选择器（！）之后使用感叹号来根据元素的子元素来设置样式。</target>
        </trans-unit>
        <trans-unit id="a3377bca324d82054b28ed12a562d840cb5ba6ee" translate="yes" xml:space="preserve">
          <source>This matches any &lt;code&gt;F&lt;/code&gt; element that is preceded by an &lt;code&gt;E&lt;/code&gt; element.</source>
          <target state="translated">这匹配任何以 &lt;code&gt;E&lt;/code&gt; 元素开头的 &lt;code&gt;F&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="ade13046564c9f73c7d23a1d0201e5b601d80cff" translate="yes" xml:space="preserve">
          <source>This way you can change the style in multiple inner tags, based on the rollover of the parent element.</source>
          <target state="translated">这样一来,你可以根据父元素的翻转,在多个内部标签中改变样式。</target>
        </trans-unit>
        <trans-unit id="a2ae2524fa82d3b6ca48d01699e987c240ed2e95" translate="yes" xml:space="preserve">
          <source>This will select any parent of a text input. But wait, there's still much more. If you want, you can select a specified parent:</source>
          <target state="translated">这将选择任何一个文本输入的父级。但是,等等,还有更多。如果你愿意的话,你可以选择指定的父级。</target>
        </trans-unit>
        <trans-unit id="6bf4a3263761c784d37c158220ed791d196fdd9e" translate="yes" xml:space="preserve">
          <source>To aid in all these issues, this specification defines the @nest rule, which imposes fewer restrictions on how to validly nest style rules. Its syntax is:</source>
          <target state="translated">为了帮助解决所有这些问题,本规范定义了@nest规则,它对如何有效地嵌套样式规则施加了较少的限制。它的语法是:</target>
        </trans-unit>
        <trans-unit id="a1376a8f7898599fd7de6e615cc6b7beba746b37" translate="yes" xml:space="preserve">
          <source>Try to switch &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;block&lt;/code&gt; display, and then use any style you want. The &lt;code&gt;a&lt;/code&gt; element will fill the &lt;code&gt;li&lt;/code&gt; element, and you will be able to modify its look as you want. Don't forget to set &lt;code&gt;li&lt;/code&gt; padding to 0.</source>
          <target state="translated">尝试将 &lt;code&gt;a&lt;/code&gt; 切换为 &lt;code&gt;block&lt;/code&gt; 显示，然后使用所需的任何样式。 &lt;code&gt;a&lt;/code&gt; 元素将填充 &lt;code&gt;li&lt;/code&gt; 元素，您将能够根据需要修改其外观。 不要忘记将 &lt;code&gt;li&lt;/code&gt; padding设置为0。</target>
        </trans-unit>
        <trans-unit id="24975ca5508ea9851cec97364cf5dabca8f5a370" translate="yes" xml:space="preserve">
          <source>Updated demo and the rest of code</source>
          <target state="translated">更新的演示和其余代码</target>
        </trans-unit>
        <trans-unit id="afe653ce0b85079b9bb98d11a41b5e77b2f6340a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;:has()&lt;/code&gt; the original question could be solved with this:</source>
          <target state="translated">使用 &lt;code&gt;:has()&lt;/code&gt; 可以用以下方法解决原始问题：</target>
        </trans-unit>
        <trans-unit id="60034bec0808b20e41b05d45e963a29c8888458e" translate="yes" xml:space="preserve">
          <source>While direct nesting looks nice, it is somewhat fragile. Some valid nesting selectors, like .foo &amp;amp;, are disallowed, and editing the selector in certain ways can make the rule invalid unexpectedly. As well, some people find the nesting challenging to distinguish visually from the surrounding declarations.</source>
          <target state="translated">虽然直接嵌套看起来不错，但它有些脆弱。 不允许使用某些有效的嵌套选择器，例如.foo＆，并且以某些方式编辑选择器会使规则意外无效。 同样，有些人发现嵌套很难在视觉上与周围的声明区分开。</target>
        </trans-unit>
        <trans-unit id="dbb5d3a24caf372a638b498419bfe0d5936fdb36" translate="yes" xml:space="preserve">
          <source>Yes: &lt;a href=&quot;https://developer.mozilla.org//docs/Web/CSS/:has&quot;&gt;&lt;code&gt;:has()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">是&lt;a href=&quot;https://developer.mozilla.org//docs/Web/CSS/:has&quot;&gt; &lt;code&gt;:has()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4becc4185bc33bcd14acd7a5c4a3c162b49aff0" translate="yes" xml:space="preserve">
          <source>You can select that &lt;code&gt;span.help&lt;/code&gt; when the &lt;code&gt;input&lt;/code&gt; is active and show it:</source>
          <target state="translated">您可以在 &lt;code&gt;input&lt;/code&gt; 处于活动状态时选择该 &lt;code&gt;span.help&lt;/code&gt; 并显示它：</target>
        </trans-unit>
        <trans-unit id="19eac2928591c549608327e2a7b6ea1dbfb4196b" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/Idered/cssParentSelector&quot;&gt;this script&lt;/a&gt;:</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://github.com/Idered/cssParentSelector&quot;&gt;以下脚本&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="86a4aaca88668f11e33e1f945825696dbcae43cc" translate="yes" xml:space="preserve">
          <source>You might try to use hyperlink as the parent, and then change the inner elements on hover. Like this:</source>
          <target state="translated">你可以尝试使用超链接作为父节点,然后在悬停时改变内部元素。就像这样。</target>
        </trans-unit>
        <trans-unit id="d481d1b33f51732b9c2e5434d7c91e77a6a5dc0a" translate="yes" xml:space="preserve">
          <source>an &lt;em&gt;any ancestor selector&lt;/em&gt;&lt;code&gt;^&lt;/code&gt; (which enables the opposite selection to &lt;code&gt;[SPACE]&lt;/code&gt;)</source>
          <target state="translated">&lt;em&gt;任何祖先选择器&lt;/em&gt; &lt;code&gt;^&lt;/code&gt; （启用与 &lt;code&gt;[SPACE]&lt;/code&gt; 相反的选择）</target>
        </trans-unit>
        <trans-unit id="03b96edb4dca056d15b356bd25000fefadf68769" translate="yes" xml:space="preserve">
          <source>an &lt;em&gt;immediate parent&lt;/em&gt; selector &lt;code&gt;&amp;lt;&lt;/code&gt; (which enables the opposite selection to &lt;code&gt;&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;em&gt;直接父&lt;/em&gt;选择器 &lt;code&gt;&amp;lt;&lt;/code&gt; （启用与之相反的选择）</target>
        </trans-unit>
        <trans-unit id="c0cd0fa5b431f90d6f44d53fb95437bc7b01360c" translate="yes" xml:space="preserve">
          <source>will select the &lt;code&gt;ul&lt;/code&gt; element that has a child element with id &lt;em&gt;someId&lt;/em&gt;. Or to answer the original question, something like the following should do the trick (untested):</source>
          <target state="translated">将选择具有id为&lt;em&gt;someId&lt;/em&gt;的子元素的 &lt;code&gt;ul&lt;/code&gt; 元素。 或回答原始问题，应使用以下方法解决问题（未测试）：</target>
        </trans-unit>
        <trans-unit id="dac52e037e129a40e9eab87f2da23d1eab4ce701" translate="yes" xml:space="preserve">
          <source>will set a red background-color if the user hovers over any anchor.</source>
          <target state="translated">如果用户悬停在任何锚点上,将设置一个红色背景色。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
