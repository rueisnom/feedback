<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1026069">
    <body>
      <group id="1026069">
        <trans-unit id="9de390a8260c191b43450f70ae86feb669df0906" translate="yes" xml:space="preserve">
          <source>(You may encapsulate it in a function or even add it to the String prototype if you use it frequently.)</source>
          <target state="translated">(Puedes encapsularlo en una función o incluso añadirlo al prototipo de String si lo usas frecuentemente).</target>
        </trans-unit>
        <trans-unit id="b9bf45d36ec359981f7c6104d1efde02af646768" translate="yes" xml:space="preserve">
          <source>...and for all guys who think that there's a better way of doing this, without extending native prototypes:</source>
          <target state="translated">...y para todos los que piensen que hay una mejor manera de hacer esto,sin extender los prototipos nativos:</target>
        </trans-unit>
        <trans-unit id="367d2eac8d3ed38b462e4255bae2e055a734f474" translate="yes" xml:space="preserve">
          <source>...and then, there is so much more to this question when you consider internationalisation, as &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;this astonishingly good answer&lt;/a&gt; (buried below) shows.</source>
          <target state="translated">... y luego, hay mucho m&amp;aacute;s en esta pregunta cuando se considera la internacionalizaci&amp;oacute;n, como lo muestra &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;esta asombrosamente buena respuesta&lt;/a&gt; (enterrada a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="01458e5b9ce1421cc63ab3a554d729db7d445bfd" translate="yes" xml:space="preserve">
          <source>4,577,946 ops/s &amp;plusmn;1.2% for the most voted answer.</source>
          <target state="translated">4,577,946 ops / s &amp;plusmn; 1.2% para la respuesta m&amp;aacute;s votada.</target>
        </trans-unit>
        <trans-unit id="a2ffd6820da15f37abf4c947e438311a5752e475" translate="yes" xml:space="preserve">
          <source>4,956,962 ops/s &amp;plusmn;3.03% for this solution,</source>
          <target state="translated">4,956,962 ops / s &amp;plusmn; 3.03% para esta soluci&amp;oacute;n,</target>
        </trans-unit>
        <trans-unit id="21536903e387743ca164f63d9cc09e9b8b6bb9e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;/index.html&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;/index.html&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;/index.html&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;/index.html&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d494e91c3e544750401f32794514d26617133c2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;the Eiffel Tower&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;The Eiffel Tower&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;the Eiffel Tower&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;The Eiffel Tower&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="163679a6bb6d7fb0504648cd5281b896b69b7f3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;this is a test&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;This is a test&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;this is a test&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;This is a test&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="228001a68abeb7721c7e6836bdfa016232028ea1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; gives us the ability to declare &lt;code&gt;capitalizeFirstChar&lt;/code&gt; as constant, which is desired since as a programmer you should always explicitly state your intentions.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; nos da la capacidad de declarar &lt;code&gt;capitalizeFirstChar&lt;/code&gt; como constante, lo cual es deseable ya que como programador siempre debe indicar expl&amp;iacute;citamente sus intenciones.</target>
        </trans-unit>
        <trans-unit id="fe5ad94b64fc4f2a2e524d4f6153761e202b6090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parameters =&amp;gt; function&lt;/code&gt; is so called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;parameters =&amp;gt; function&lt;/code&gt; se llama &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;funci&amp;oacute;n de flecha&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a8043e9b8b738f65ac06fcc7f0df98edb180022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string.substring(1)&lt;/code&gt; is faster than &lt;code&gt;string.slice(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string.substring(1)&lt;/code&gt; es m&amp;aacute;s r&amp;aacute;pido que &lt;code&gt;string.slice(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d710ede0941e4a1632178bcd80a8c8aab513de6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;* The code units of UTF-16 / UCS2 are also Unicode code points in the sense that e.g. U+D800 is technically a code point, but that&amp;rsquo;s not what it &amp;ldquo;means&amp;rdquo; here ... sort of ... though it gets pretty fuzzy. What the surrogates definitely are not, though, is USVs (Unicode scalar values).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;* Las unidades de c&amp;oacute;digo de UTF-16 / UCS2 tambi&amp;eacute;n son puntos de c&amp;oacute;digo Unicode en el sentido de que, por ejemplo, U + D800 es t&amp;eacute;cnicamente un punto de c&amp;oacute;digo, pero eso no es lo que &quot;significa&quot; aqu&amp;iacute; ... m&amp;aacute;s o menos ... aunque se pone bastante borroso.&lt;/em&gt; &lt;em&gt;Sin embargo, lo que los sustitutos definitivamente no son son los USV (valores escalares Unicode).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80e943d6704e4d184a5db2220f9f6efdc9fbefec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;** Though if a surrogate code unit is &amp;ldquo;orphaned&amp;rdquo; &amp;mdash; i.e., not part of a logical pair &amp;mdash; you could still get surrogates here, too.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;** Sin embargo, si una unidad de c&amp;oacute;digo sustituto est&amp;aacute; &quot;hu&amp;eacute;rfana&quot;, es decir, no forma parte de un par l&amp;oacute;gico, tambi&amp;eacute;n podr&amp;iacute;a obtener sustitutos aqu&amp;iacute;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cdf2e5c67a4f0fdde3be9c75c84dbfc0ff1c9081" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;*** maybe. I haven&amp;rsquo;t tested it. Unless you have determined capitalization is a meaningful bottleneck, I probably wouldn&amp;rsquo;t sweat it &amp;mdash; choose whatever you believe is most clear and readable.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;*** tal vez.&lt;/em&gt; &lt;em&gt;No lo he probado.&lt;/em&gt; &lt;em&gt;A menos que haya determinado que la capitalizaci&amp;oacute;n es un cuello de botella significativo, probablemente no me preocupe, elija lo que considere m&amp;aacute;s claro y legible.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1853748fb3df42199189a7bc4ca52932cac9483c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;**** such a function might wish to test both the first and second code units instead of just the first, since it&amp;rsquo;s possible that the first unit is an orphaned surrogate. For example the input &quot;\uD800x&quot; would capitalize the X as-is, which may or may not be expected.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;**** tal funci&amp;oacute;n podr&amp;iacute;a desear probar las unidades de c&amp;oacute;digo primera y segunda en lugar de solo la primera, ya que es posible que la primera unidad sea un sustituto hu&amp;eacute;rfano.&lt;/em&gt; &lt;em&gt;Por ejemplo, la entrada &quot;\ uD800x&quot; capitalizar&amp;iacute;a la X tal cual, lo que puede esperarse o no.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e323f33e94cbca47eb23464c89f17f842364d336" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;***** Here&amp;rsquo;s the &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1361876&quot;&gt;Bugzilla issue&lt;/a&gt; if you want to follow the progress more directly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;***** Aqu&amp;iacute; est&amp;aacute; el &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1361876&quot;&gt;problema de Bugzilla&lt;/a&gt; si desea seguir el progreso m&amp;aacute;s directamente.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34b7e56ddb1cb38bfcf26066f4b7ae7fb74172d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Initially I didn&amp;rsquo;t see any answers addressing issues related to astral plane code points. There &lt;a href=&quot;https://stackoverflow.com/a/45224904/1631952&quot;&gt;is one&lt;/a&gt;, but it&amp;rsquo;s a bit buried (like this one will be, I guess!)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Inicialmente no vi ninguna respuesta que abordara problemas relacionados con los puntos de c&amp;oacute;digo del plano astral.&lt;/em&gt; &lt;em&gt;Hay &lt;a href=&quot;https://stackoverflow.com/a/45224904/1631952&quot;&gt;uno&lt;/a&gt; , pero est&amp;aacute; un poco enterrado (&amp;iexcl;como este, supongo!)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67d4c331b2081030c9036c63f7dcc26c1bc21da1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You could use bitwise math instead of &lt;code&gt;&amp;gt; 0xFFFF&lt;/code&gt; there, but it&amp;rsquo;s probably easier to understand this way and either would achieve the same thing.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Podr&amp;iacute;as usar matem&amp;aacute;ticas bit a bit en lugar de &lt;code&gt;&amp;gt; 0xFFFF&lt;/code&gt; all&amp;iacute;, pero probablemente sea m&amp;aacute;s f&amp;aacute;cil de entender de esta manera y cualquiera de las dos lograr&amp;iacute;a lo mismo.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e11e3af42de6298ef3229ff0943985a06191a5a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SHORTEST&lt;/strong&gt; 3 solutions, 1 and 2 handle cases when &lt;code&gt;s&lt;/code&gt; string  is &lt;code&gt;&quot;&quot;&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;SHORTEST&lt;/strong&gt; 3 soluciones, 1 y 2 manejan casos cuando &lt;code&gt;s&lt;/code&gt; cadena s es &lt;code&gt;&quot;&quot;&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0241744970e1f05578cdbbce0e8b6ad42587ba7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the 2018 ECMAScript&amp;nbsp;6+ Solution&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Esta es la soluci&amp;oacute;n 2018 ECMAScript 6+&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f715e43a9cd501ad9b3351990a77f7d25046bb86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n 2:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b38760c3360e1a927a9cacd29a860eddc0edeb9" translate="yes" xml:space="preserve">
          <source>According to the comments below this doesn't work in IE 7 or below.</source>
          <target state="translated">De acuerdo con los comentarios que siguen,esto no funciona en el IE 7 o inferior.</target>
        </trans-unit>
        <trans-unit id="ca975c6c918692672e6209be6187776c7dfee237" translate="yes" xml:space="preserve">
          <source>Also the alternative option is JavaScript, so the best gonna be something like this:</source>
          <target state="translated">También la opción alternativa es JavaScript,así que lo mejor será algo como esto:</target>
        </trans-unit>
        <trans-unit id="d379b63cddadbeb97273b4dc578ce9d650af84b8" translate="yes" xml:space="preserve">
          <source>And for all coffee-junkies:</source>
          <target state="translated">Y para todos los &quot;coffee-junkies&quot;:</target>
        </trans-unit>
        <trans-unit id="a65c6aab9ccb89445d5895ed004afd6ead95252c" translate="yes" xml:space="preserve">
          <source>And then:</source>
          <target state="translated">Y luego:</target>
        </trans-unit>
        <trans-unit id="4cab7d90a7f1fec6fb511da21e50825814a58e70" translate="yes" xml:space="preserve">
          <source>As you can see, the first two methods are essentially comparable in terms of performance, whereas altering the &lt;code&gt;String.prototype&lt;/code&gt; is by far the slowest in terms of performance.</source>
          <target state="translated">Como puede ver, los dos primeros m&amp;eacute;todos son esencialmente comparables en t&amp;eacute;rminos de rendimiento, mientras que alterar el &lt;code&gt;String.prototype&lt;/code&gt; es, con mucho, el m&amp;aacute;s lento en t&amp;eacute;rminos de rendimiento.</target>
        </trans-unit>
        <trans-unit id="b738c32be44272442962e986db9a0980aba6f5fb" translate="yes" xml:space="preserve">
          <source>At the start I also mentioned internationalization considerations. Some of these are very difficult to account for because they require knowledge not only of &lt;em&gt;what&lt;/em&gt; language is being used, but also may require specific knowledge of the words in the language. For example, the Irish digraph &quot;mb&quot; capitalizes as &quot;mB&quot; at the start of a word. Another example, the German eszett, never begins a word (afaik), but still helps illustrate the problem. The lowercase eszett (&amp;ldquo;&amp;szlig;&amp;rdquo;) capitalizes to &amp;ldquo;SS,&amp;rdquo; but  &amp;ldquo;SS&amp;rdquo; could lowercase to either &amp;ldquo;&amp;szlig;&amp;rdquo; or &amp;ldquo;ss&amp;rdquo; &amp;mdash; you require out-of-band knowledge of the German language to know which is correct!</source>
          <target state="translated">Al principio tambi&amp;eacute;n mencion&amp;eacute; consideraciones de internacionalizaci&amp;oacute;n. Algunos de estos son muy dif&amp;iacute;ciles de explicar porque requieren conocimiento no solo de &lt;em&gt;qu&amp;eacute;&lt;/em&gt; idioma se est&amp;aacute; utilizando, sino que tambi&amp;eacute;n pueden requerir un conocimiento espec&amp;iacute;fico de las palabras en el idioma. Por ejemplo, el d&amp;iacute;grafo irland&amp;eacute;s &quot;mb&quot; se capitaliza como &quot;mB&quot; al comienzo de una palabra. Otro ejemplo, el eszett alem&amp;aacute;n, nunca comienza una palabra (afaik), pero todav&amp;iacute;a ayuda a ilustrar el problema. La letra min&amp;uacute;scula eszett (&amp;ldquo;&amp;szlig;&amp;rdquo;) se escribe en may&amp;uacute;scula a &amp;ldquo;SS&amp;rdquo;, pero &amp;ldquo;SS&amp;rdquo; puede aparecer en min&amp;uacute;scula a &amp;ldquo;&amp;szlig;&amp;rdquo; o &amp;ldquo;ss&amp;rdquo;. &amp;iexcl;Requiere conocimiento fuera de banda del idioma alem&amp;aacute;n para saber cu&amp;aacute;l es la correcta!</target>
        </trans-unit>
        <trans-unit id="cdcb4da1ad0efcd4394c1ed55e3b70f42e24c0b4" translate="yes" xml:space="preserve">
          <source>At the time of writing (Feb 2020), Firefox/Spidermonkey has not yet implemented any of the RegExp features introduced in the last two years*****. You can check the current status of this feature at the &lt;a href=&quot;http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Unicode_Property_Escapes&quot;&gt;Kangax compat table&lt;/a&gt;. Babel is able to compile RegExp literals with property references to equivalent patterns without them, but be aware that the resulting code may be enormous.</source>
          <target state="translated">En el momento de escribir este art&amp;iacute;culo (febrero de 2020), Firefox / Spidermonkey a&amp;uacute;n no ha implementado ninguna de las caracter&amp;iacute;sticas RegExp introducidas en los &amp;uacute;ltimos dos a&amp;ntilde;os *****. Puede verificar el estado actual de esta funci&amp;oacute;n en la &lt;a href=&quot;http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Unicode_Property_Escapes&quot;&gt;tabla de compatibilidad de Kangax&lt;/a&gt; . Babel puede compilar literales RegExp con referencias de propiedad a patrones equivalentes sin ellos, pero tenga en cuenta que el c&amp;oacute;digo resultante puede ser enorme.</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="c28281d29953dd5bbfe8e32fb31c9ecf6084a1d8" translate="yes" xml:space="preserve">
          <source>CSS only</source>
          <target state="translated">Sólo CSS</target>
        </trans-unit>
        <trans-unit id="2f3f9c86a9d991e58459d1d1c5a24e5332a22188" translate="yes" xml:space="preserve">
          <source>Capitalize the first letter of all words in a string:</source>
          <target state="translated">Poner en mayúsculas la primera letra de todas las palabras de una cadena:</target>
        </trans-unit>
        <trans-unit id="a69da05af469308b462024895eb097e9dd01295b" translate="yes" xml:space="preserve">
          <source>Checkout this solution:</source>
          <target state="translated">Comprueba esta solución:</target>
        </trans-unit>
        <trans-unit id="0ab8dd120611ec6f99b50238ac21e32cacf65d79" translate="yes" xml:space="preserve">
          <source>Created with &lt;a href=&quot;https://jsbench.me/&quot;&gt;JSBench.me&lt;/a&gt; on Google Chrome 57.</source>
          <target state="translated">Creado con &lt;a href=&quot;https://jsbench.me/&quot;&gt;JSBench.me&lt;/a&gt; en Google Chrome 57.</target>
        </trans-unit>
        <trans-unit id="38eff30dd7da438c13e56e85015681e989636246" translate="yes" xml:space="preserve">
          <source>Despite being called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter&quot;&gt;&lt;code&gt;::first-letter&lt;/code&gt;&lt;/a&gt;, it applies to the first &lt;strong&gt;character&lt;/strong&gt;, i.e. in case of string &lt;code&gt;%a&lt;/code&gt;, this selector would apply to &lt;code&gt;%&lt;/code&gt; and as such &lt;code&gt;a&lt;/code&gt; would not be capitalized.</source>
          <target state="translated">A pesar de llamarse &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter&quot;&gt; &lt;code&gt;::first-letter&lt;/code&gt; &lt;/a&gt; , se aplica al primer &lt;strong&gt;car&amp;aacute;cter&lt;/strong&gt; , es decir, en el caso de la cadena &lt;code&gt;%a&lt;/code&gt; , este selector se aplicar&amp;iacute;a a &lt;code&gt;%&lt;/code&gt; y, como tal, no se capitalizar&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="b53015fce6abe5786b7601af4988a62b9ce4c6c7" translate="yes" xml:space="preserve">
          <source>ES2015 one-liner</source>
          <target state="translated">ES2015 una línea</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="5efc2d2017db789ed39b3f6945df2de895bab671" translate="yes" xml:space="preserve">
          <source>For another case I need it to capitalize the first letter and lowercase the rest. The following cases made me change this function:</source>
          <target state="translated">Para otro caso lo necesito para poner en mayúsculas la primera letra y en minúsculas el resto.Los siguientes casos me hicieron cambiar esta función:</target>
        </trans-unit>
        <trans-unit id="fed1125217a67648d6e1fabd36895a4669511da3" translate="yes" xml:space="preserve">
          <source>For even more internationalization options, please see the &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;original answer below&lt;/a&gt;.</source>
          <target state="translated">Para obtener a&amp;uacute;n m&amp;aacute;s opciones de internacionalizaci&amp;oacute;n, consulte la &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;respuesta original a continuaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="fd7ea24cff598ca7d051a4d8d628b73aae9173a8" translate="yes" xml:space="preserve">
          <source>For longer strings, this is probably not terribly efficient*** &amp;mdash; we don&amp;rsquo;t really need to iterate the remainder. We could use &lt;code&gt;String.prototype.codePointAt&lt;/code&gt; to get at that first (possible) letter, but we&amp;rsquo;d still need to determine where the slice should begin. One way to avoid iterating the remainder would be to test whether the first codepoint is outside the BMP; if it isn&amp;rsquo;t, the slice begins at 1, and if it is, the slice begins at 2.</source>
          <target state="translated">Para cadenas m&amp;aacute;s largas, esto probablemente no sea terriblemente eficiente ***: realmente no necesitamos repetir el resto. Podr&amp;iacute;amos usar &lt;code&gt;String.prototype.codePointAt&lt;/code&gt; para llegar a esa primera (posible) letra, pero a&amp;uacute;n tendr&amp;iacute;amos que determinar d&amp;oacute;nde deber&amp;iacute;a comenzar el segmento. Una forma de evitar iterar el resto ser&amp;iacute;a probar si el primer punto de c&amp;oacute;digo est&amp;aacute; fuera del BMP; si no es as&amp;iacute;, el corte comienza en 1, y si lo es, el corte comienza en 2.</target>
        </trans-unit>
        <trans-unit id="b63decbd83c1b992eb529da43269358b03bcf440" translate="yes" xml:space="preserve">
          <source>From ES2015 on, dealing with this became a bit easier. &lt;code&gt;String.prototype[@@iterator]&lt;/code&gt; yields strings corresponding to code points**. So for example, we can do this:</source>
          <target state="translated">A partir de ES2015, lidiar con esto se volvi&amp;oacute; un poco m&amp;aacute;s f&amp;aacute;cil. &lt;code&gt;String.prototype[@@iterator]&lt;/code&gt; produce cadenas correspondientes a los puntos de c&amp;oacute;digo **. Entonces, por ejemplo, podemos hacer esto:</target>
        </trans-unit>
        <trans-unit id="74c10e52cd68360f7bdbca8c52fc4938b2eb4e9a" translate="yes" xml:space="preserve">
          <source>Here are the fastest methods based on &lt;a href=&quot;http://jsperf.com/capitalize-the-first-letter-of-string-in-javascript/2&quot;&gt;this jsperf test&lt;/a&gt; (ordered from fastest to slowest).</source>
          <target state="translated">Estos son los m&amp;eacute;todos m&amp;aacute;s r&amp;aacute;pidos basados ​​en &lt;a href=&quot;http://jsperf.com/capitalize-the-first-letter-of-string-in-javascript/2&quot;&gt;esta prueba jsperf&lt;/a&gt; (ordenados del m&amp;aacute;s r&amp;aacute;pido al m&amp;aacute;s lento).</target>
        </trans-unit>
        <trans-unit id="36ec1b221f06d0c0a874dc6ea003751af9a2707b" translate="yes" xml:space="preserve">
          <source>Here is a function called &lt;strong&gt;ucfirst()&lt;/strong&gt; (short for &quot;upper case first letter&quot;):</source>
          <target state="translated">Aqu&amp;iacute; hay una funci&amp;oacute;n llamada &lt;strong&gt;ucfirst ()&lt;/strong&gt; (abreviatura de &quot;primera letra may&amp;uacute;scula&quot;):</target>
        </trans-unit>
        <trans-unit id="f63bba80779b9f905ca9275279f4d3217ddae10f" translate="yes" xml:space="preserve">
          <source>Here is a shortened version of the popular answer that gets the first letter by treating the string as an array:</source>
          <target state="translated">Aquí hay una versión abreviada de la respuesta popular que obtiene la primera letra tratando la cuerda como una matriz:</target>
        </trans-unit>
        <trans-unit id="8de7492950ddcf0f0806df769b72006c014004f5" translate="yes" xml:space="preserve">
          <source>Here's a more object-oriented approach:</source>
          <target state="translated">Aquí hay un enfoque más orientado a los objetos:</target>
        </trans-unit>
        <trans-unit id="26ec945f349fe1c8f7b8bfe93fdfedd83c5c2657" translate="yes" xml:space="preserve">
          <source>How do I make the first letter of a string uppercase in JavaScript</source>
          <target state="translated">¿Cómo hago que la primera letra de una cadena sea mayúscula en JavaScript</target>
        </trans-unit>
        <trans-unit id="41600359895123b43257f89a1713e3beaa5909e0" translate="yes" xml:space="preserve">
          <source>How do I make the first letter of a string uppercase, but not change the case of any of the other letters?</source>
          <target state="translated">¿Cómo hago que la primera letra de una cadena sea mayúscula,pero no cambio el caso de ninguna de las otras letras?</target>
        </trans-unit>
        <trans-unit id="2471381604a49f6d0e0c580d6ed33d04e7bbf029" translate="yes" xml:space="preserve">
          <source>However, some cased characters fall outside the BMP (basic multilingual plane, code points U+0 to U+FFFF). For example take this Deseret text:</source>
          <target state="translated">Sin embargo,algunos caracteres de la caja caen fuera del BMP (plano básico multilingüe,puntos de código U+0 a U+FFFF).Por ejemplo,tomemos este texto de Deseret:</target>
        </trans-unit>
        <trans-unit id="ab4561105ba74782ce146baef49296c05955c8d5" translate="yes" xml:space="preserve">
          <source>I didn&amp;rsquo;t see any mention in the existing answers of issues related to &lt;s&gt;astral plane code points or&lt;/s&gt; internationalization. &amp;ldquo;Uppercase&amp;rdquo; doesn&amp;rsquo;t mean the same thing in every language using a given script.</source>
          <target state="translated">No vi ninguna menci&amp;oacute;n en las respuestas existentes de cuestiones relacionadas con los &lt;s&gt;puntos de c&amp;oacute;digo del plano astral o la&lt;/s&gt; internacionalizaci&amp;oacute;n. &quot;May&amp;uacute;sculas&quot; no significa lo mismo en todos los idiomas que utilizan un script determinado.</target>
        </trans-unit>
        <trans-unit id="57568b656d3bfd8b25836b6e404e950afe5e8ed8" translate="yes" xml:space="preserve">
          <source>I found this arrow function easiest. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;Replace&lt;/a&gt; matches the first letter character (&lt;code&gt;\w&lt;/code&gt;) of your string and converts it to uppercase. Nothing fancier necessary.</source>
          <target state="translated">Encontr&amp;eacute; esta funci&amp;oacute;n de flecha m&amp;aacute;s f&amp;aacute;cil. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;Reemplazar&lt;/a&gt; coincide con el primer car&amp;aacute;cter de letra ( &lt;code&gt;\w&lt;/code&gt; ) de su cadena y lo convierte a may&amp;uacute;sculas. Nada m&amp;aacute;s lujoso necesario.</target>
        </trans-unit>
        <trans-unit id="fc8ad3518c2d8b9e7e804ae69020ba2d72f9b38e" translate="yes" xml:space="preserve">
          <source>I went with name &lt;code&gt;capitalizeFirstChar&lt;/code&gt; instead of &lt;code&gt;capitalizeFirstLetter&lt;/code&gt;, because OP didn't asked for code that capitalizes the first letter in the entire string, but the very first char (if it's letter, of course).</source>
          <target state="translated">Fui con el nombre &lt;code&gt;capitalizeFirstChar&lt;/code&gt; en lugar de &lt;code&gt;capitalizeFirstLetter&lt;/code&gt; , porque OP no solicit&amp;oacute; un c&amp;oacute;digo que capitalice la primera letra de toda la cadena, sino el primer car&amp;aacute;cter (si es letra, por supuesto).</target>
        </trans-unit>
        <trans-unit id="12beaec08e35b5059fe37bcbcaff9243ba2cb242" translate="yes" xml:space="preserve">
          <source>If you  want to reuse it over and over, it's better attach it to javascript native String, so something like below:</source>
          <target state="translated">Si quieres reutilizarlo una y otra vez,es mejor adjuntarlo a String nativo de javascript,así que algo como lo de abajo:</target>
        </trans-unit>
        <trans-unit id="5595b4caaf07e85122b5dcf531caac0aed37a182" translate="yes" xml:space="preserve">
          <source>If you are wanting to reformat all-caps text, you might want to modify the other examples as such:</source>
          <target state="translated">Si desea volver a formatear el texto de todas las tapas,puede modificar los otros ejemplos como tal:</target>
        </trans-unit>
        <trans-unit id="391b6c39ae6bd183048d53c4501002d9557638f3" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; or &lt;a href=&quot;http://lodash.com/&quot;&gt;Lo-Dash&lt;/a&gt;, the &lt;a href=&quot;https://github.com/epeli/underscore.string&quot;&gt;underscore.string&lt;/a&gt; library provides string extensions, including capitalize:</source>
          <target state="translated">Si usa &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; o &lt;a href=&quot;http://lodash.com/&quot;&gt;Lo-Dash&lt;/a&gt; , la biblioteca &lt;a href=&quot;https://github.com/epeli/underscore.string&quot;&gt;underscore.string&lt;/a&gt; proporciona extensiones de cadena, que incluyen may&amp;uacute;sculas:</target>
        </trans-unit>
        <trans-unit id="3580d94edc18905a809fe61049b66ac884fd95f0" translate="yes" xml:space="preserve">
          <source>If you want to work with Unicode code points instead of code units (for example to handle Unicode characters outside of the Basic Multilingual Plane) you can leverage the fact that &lt;code&gt;String#[@iterator]&lt;/code&gt; works with code points, and you can use &lt;code&gt;toLocaleUpperCase&lt;/code&gt; to get locale-correct uppercasing:</source>
          <target state="translated">Si desea trabajar con puntos de c&amp;oacute;digo Unicode en lugar de unidades de c&amp;oacute;digo (por ejemplo, para manejar caracteres Unicode fuera del plano multiling&amp;uuml;e b&amp;aacute;sico), puede aprovechar el hecho de que &lt;code&gt;String#[@iterator]&lt;/code&gt; funciona con puntos de c&amp;oacute;digo, y puede usar &lt;code&gt;toLocaleUpperCase&lt;/code&gt; para obtener may&amp;uacute;sculas correctas para la localizaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="520fb73d2d3cb4c07939630bd614bc3b08d45c7a" translate="yes" xml:space="preserve">
          <source>If you're already (or considering) using &lt;code&gt;lodash&lt;/code&gt;, the solution is easy:</source>
          <target state="translated">Si ya est&amp;aacute; (o est&amp;aacute; considerando) usar &lt;code&gt;lodash&lt;/code&gt; , la soluci&amp;oacute;n es f&amp;aacute;cil:</target>
        </trans-unit>
        <trans-unit id="4ec057c220d248000ac866fd08c88dfedb4df649" translate="yes" xml:space="preserve">
          <source>If you're interested in the performance of a few different methods posted:</source>
          <target state="translated">Si está interesado en el desempeño de algunos métodos diferentes publicados:</target>
        </trans-unit>
        <trans-unit id="22ed663eee054bfc4462b75cb3de053fa66754b0" translate="yes" xml:space="preserve">
          <source>In CSS:</source>
          <target state="translated">En el CSS:</target>
        </trans-unit>
        <trans-unit id="513ed99d77b99d0268fb8f84f8be5411764fabcb" translate="yes" xml:space="preserve">
          <source>In IE9+ or IE5.5+ it's supported in legacy notation with only one colon (&lt;code&gt;:first-letter&lt;/code&gt;).</source>
          <target state="translated">En IE9 + o IE5.5 + se admite en notaci&amp;oacute;n heredada con solo dos puntos ( &lt;code&gt;:first-letter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2c731feb5a1bab9995bffb541f3ec85ca6616ec0" translate="yes" xml:space="preserve">
          <source>In a browser, the user&amp;rsquo;s most-preferred language tag is indicated by &lt;code&gt;navigator.language&lt;/code&gt;, a list in order of preference is found at &lt;code&gt;navigator.languages&lt;/code&gt;, and a given DOM element&amp;rsquo;s language can be obtained (usually) with &lt;code&gt;Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE&lt;/code&gt; in multilanguage documents.</source>
          <target state="translated">En un navegador, la etiqueta de idioma m&amp;aacute;s preferida del usuario se indica mediante &lt;code&gt;navigator.language&lt;/code&gt; , se encuentra una lista en orden de preferencia en &lt;code&gt;navigator.languages&lt;/code&gt; , y el idioma de un elemento DOM dado se puede obtener (generalmente) con &lt;code&gt;Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE&lt;/code&gt; YOUR_DEFAULT_HERE en documentos en varios idiomas .</target>
        </trans-unit>
        <trans-unit id="3e7be93047b07099fd9e6aeac9ef8367e4ad1893" translate="yes" xml:space="preserve">
          <source>In agents which support Unicode property character classes in RegExp, which were introduced in ES2018, we can clean stuff up further by directly expressing what characters we&amp;rsquo;re interested in:</source>
          <target state="translated">En los agentes que admiten clases de caracteres de propiedad Unicode en RegExp, que se introdujeron en ES2018, podemos limpiar a&amp;uacute;n m&amp;aacute;s las cosas expresando directamente en qu&amp;eacute; caracteres estamos interesados:</target>
        </trans-unit>
        <trans-unit id="237f8c8207eb9f09670dd34797c5476976d0f091" translate="yes" xml:space="preserve">
          <source>In all likelihood, people asking this question will not be concerned with Deseret capitalization or internationalization. But it&amp;rsquo;s good to be aware of these issues because there&amp;rsquo;s a good chance you&amp;rsquo;ll encounter them eventually even if they aren&amp;rsquo;t concerns presently. They&amp;rsquo;re not &amp;ldquo;edge&amp;rdquo; cases, or rather, they&amp;rsquo;re not &lt;em&gt;by-definition&lt;/em&gt; edge cases &amp;mdash; there&amp;rsquo;s a whole country where most people speak Turkish, anyway, and conflating code units with codepoints is a fairly common source of bugs (especially with regard to emoji). Both strings and language are pretty complicated!</source>
          <target state="translated">Con toda probabilidad, las personas que hagan esta pregunta no se preocupar&amp;aacute;n por la capitalizaci&amp;oacute;n o la internacionalizaci&amp;oacute;n de Deseret. Pero es bueno estar al tanto de estos problemas porque hay una buena posibilidad de que los encuentre eventualmente, incluso si no son preocupaciones en la actualidad. No son casos &quot;l&amp;iacute;mite&quot;, o mejor dicho, no son casos l&amp;iacute;mite &lt;em&gt;por definici&amp;oacute;n&lt;/em&gt; : hay un pa&amp;iacute;s entero donde la mayor&amp;iacute;a de la gente habla turco, de todos modos, y la combinaci&amp;oacute;n de unidades de c&amp;oacute;digo con puntos de c&amp;oacute;digo es una fuente bastante com&amp;uacute;n de errores (especialmente con respecto a los emoji). &amp;iexcl;Tanto las cadenas como el lenguaje son bastante complicados!</target>
        </trans-unit>
        <trans-unit id="b9215739ff07c5a531e3c157e3d8b7debaf7f595" translate="yes" xml:space="preserve">
          <source>In the benchmark I performed there was no significant difference between &lt;code&gt;string.charAt(0)&lt;/code&gt; and &lt;code&gt;string[0]&lt;/code&gt;. Note however, that &lt;code&gt;string[0]&lt;/code&gt; would be &lt;code&gt;undefined&lt;/code&gt; for empty string, so it should be rewritten to &lt;code&gt;string &amp;amp;&amp;amp; string[0]&lt;/code&gt;, which is way too verbose, compared to the alternative.</source>
          <target state="translated">En el punto de referencia que realic&amp;eacute;, no hubo diferencias significativas entre &lt;code&gt;string.charAt(0)&lt;/code&gt; y &lt;code&gt;string[0]&lt;/code&gt; . Sin embargo, tenga en cuenta que la &lt;code&gt;string[0]&lt;/code&gt; no estar&amp;iacute;a &lt;code&gt;undefined&lt;/code&gt; para la cadena vac&amp;iacute;a, por lo que deber&amp;iacute;a reescribirse en la &lt;code&gt;string &amp;amp;&amp;amp; string[0]&lt;/code&gt; , que es demasiado detallada, en comparaci&amp;oacute;n con la alternativa.</target>
        </trans-unit>
        <trans-unit id="aa4f881902e40d1677a1a09723b87da7f2131a80" translate="yes" xml:space="preserve">
          <source>It happens to be that UTF-16 code units are 1:1 with USV code points within two ranges, U+0 to U+D7FF and U+E000 to U+FFFF inclusive. Most cased characters fall into those two ranges, but not all of them.</source>
          <target state="translated">Sucede que las unidades de código UTF-16 son 1:1 con puntos de código USV dentro de dos rangos,U+0 a U+D7FF y U+E000 a U+FFFF inclusive.La mayoría de los caracteres encajados caen en esos dos rangos,pero no todos.</target>
        </trans-unit>
        <trans-unit id="cfcdd40d2baaffb7a5e373b22106b786580f61af" translate="yes" xml:space="preserve">
          <source>It seems to be easier in CSS:</source>
          <target state="translated">Parece ser más fácil en el CSS:</target>
        </trans-unit>
        <trans-unit id="be0d696fbec75b29d058a2ffde594a36cc305bd4" translate="yes" xml:space="preserve">
          <source>It will output &lt;code&gt;&quot;Ruby java&quot;&lt;/code&gt; to the console.</source>
          <target state="translated">Producir&amp;aacute; &lt;code&gt;&quot;Ruby java&quot;&lt;/code&gt; en la consola.</target>
        </trans-unit>
        <trans-unit id="753fc3e18b8a5011f782214d0491ba42959f8ddc" translate="yes" xml:space="preserve">
          <source>It works by splitting the string into two pieces.  On the first line it pulls out &lt;strong&gt;firstLetter&lt;/strong&gt; and then on the second line it capitalises &lt;strong&gt;firstLetter&lt;/strong&gt; by calling &lt;strong&gt;firstLetter.toUpperCase()&lt;/strong&gt; and joins it with the rest of the string, which is found by calling &lt;strong&gt;str.substr(1)&lt;/strong&gt;.</source>
          <target state="translated">Funciona dividiendo la cuerda en dos pedazos. En la primera l&amp;iacute;nea, saca &lt;strong&gt;firstLetter&lt;/strong&gt; y luego, en la segunda l&amp;iacute;nea, capitaliza &lt;strong&gt;firstLetter&lt;/strong&gt; llamando a &lt;strong&gt;firstLetter.toUpperCase ()&lt;/strong&gt; y lo une con el resto de la cadena, que se encuentra llamando a &lt;strong&gt;str.substr (1)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="39cf6e340b712fcaeefaccd6c9cae7c6fb438b3b" translate="yes" xml:space="preserve">
          <source>It's always better to handle these kinds of stuff using &lt;strong&gt;CSS first&lt;/strong&gt;, in general, if you can solve something using CSS, go for that first, then try JavaScript to solve your problems, so in this case try using &lt;code&gt;:first-letter&lt;/code&gt; in CSS and apply &lt;code&gt;text-transform:capitalize;&lt;/code&gt;</source>
          <target state="translated">Siempre es mejor manejar este tipo de cosas usando &lt;strong&gt;CSS primero&lt;/strong&gt; , en general, si puede resolver algo usando CSS, vaya primero, luego intente JavaScript para resolver sus problemas, as&amp;iacute; que en este caso intente usar &lt;code&gt;:first-letter&lt;/code&gt; en CSS y aplicar &lt;code&gt;text-transform:capitalize;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68cebc3a030d29b43fc7340eaf94a510388b167b" translate="yes" xml:space="preserve">
          <source>Most of the proposed functions look like this:</source>
          <target state="translated">La mayoría de las funciones propuestas se ven así:</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="bd0ec7f92d0013f9249f7d0c47b7dbfe0e9eaf1d" translate="yes" xml:space="preserve">
          <source>See their docs: &lt;a href=&quot;https://lodash.com/docs#capitalize&quot;&gt;https://lodash.com/docs#capitalize&lt;/a&gt;</source>
          <target state="translated">Vea sus documentos: &lt;a href=&quot;https://lodash.com/docs#capitalize&quot;&gt;https://lodash.com/docs#capitalize&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Mostrar fragmento de código</target>
        </trans-unit>
        <trans-unit id="7125002cd82871109849d7c7802837b04e3aa758" translate="yes" xml:space="preserve">
          <source>Since there are numerous answers, but none in ES2015 that would solve original problem efficiently, I came up with the following:</source>
          <target state="translated">Como hay numerosas respuestas,pero ninguna en ES2015 que resuelva eficientemente el problema original,se me ocurrió lo siguiente:</target>
        </trans-unit>
        <trans-unit id="a05e8ccd4f0db9fa8ab4b2d4f1e59cc14da07156" translate="yes" xml:space="preserve">
          <source>So try creating a class for that, so you can use it globally, for example: &lt;code&gt;.first-letter-uppercase&lt;/code&gt; and add something like below in your CSS:</source>
          <target state="translated">Intente crear una clase para eso, de modo que pueda usarla globalmente, por ejemplo: &lt;code&gt;.first-letter-uppercase&lt;/code&gt; y agregue algo como a continuaci&amp;oacute;n en su CSS:</target>
        </trans-unit>
        <trans-unit id="1dc1f21e14a758a9bf27e090a7e7aff5d2f7c19a" translate="yes" xml:space="preserve">
          <source>Some other answers modify &lt;code&gt;String.prototype&lt;/code&gt; (this answer used to as well), but I would advise against this now due to maintainability (hard to find out where the function is being added to the &lt;code&gt;prototype&lt;/code&gt; and could cause conflicts if other code uses the same name / a browser adds a native function with that same name in future).</source>
          <target state="translated">Algunas otras respuestas modifican &lt;code&gt;String.prototype&lt;/code&gt; (esta respuesta tambi&amp;eacute;n sol&amp;iacute;a hacerlo), pero desaconsejar&amp;iacute;a esto ahora debido a la capacidad de mantenimiento (dif&amp;iacute;cil de averiguar d&amp;oacute;nde se agrega la funci&amp;oacute;n al &lt;code&gt;prototype&lt;/code&gt; y podr&amp;iacute;a causar conflictos si otro c&amp;oacute;digo usa el mismo nombre / un navegador agrega una funci&amp;oacute;n nativa con ese mismo nombre en el futuro).</target>
        </trans-unit>
        <trans-unit id="f328eb536a4786b3e3cffb9fe5ba8a131e439b94" translate="yes" xml:space="preserve">
          <source>Thanks J-P for the aclaration.</source>
          <target state="translated">Gracias J-P por la aclaración.</target>
        </trans-unit>
        <trans-unit id="e7e02386fc0fdd5750e124eedc2fe82fb16c6cbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ucfirst&lt;/code&gt; function works if you do it like this.</source>
          <target state="translated">La &lt;code&gt;ucfirst&lt;/code&gt; funci&amp;oacute;n funciona si lo hace as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="f8d4f74a2fbde727e6e72b8c96f5adb95eabac25" translate="yes" xml:space="preserve">
          <source>The basic solution is:</source>
          <target state="translated">La solución básica es:</target>
        </trans-unit>
        <trans-unit id="ca5df1b84c287b849617bdac4e324fb5a89cfdb4" translate="yes" xml:space="preserve">
          <source>The first character here fails to capitalize because the array-indexed properties of strings don&amp;rsquo;t access &amp;ldquo;characters&amp;rdquo; or code points*. They access UTF-16 code units. This is true also when slicing &amp;mdash; the index values point at code units.</source>
          <target state="translated">El primer car&amp;aacute;cter aqu&amp;iacute; no se puede poner en may&amp;uacute;scula porque las propiedades indexadas de la matriz de cadenas no acceden a &quot;caracteres&quot; o puntos de c&amp;oacute;digo *. Acceden a las unidades de c&amp;oacute;digo UTF-16. Esto tambi&amp;eacute;n es cierto cuando se divide: los valores de &amp;iacute;ndice apuntan a unidades de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="3e7ba471ab8219d28d83cb805cb394c50a047c08" translate="yes" xml:space="preserve">
          <source>The most famous example of these kinds of issues, probably, is Turkish. In Turkish Latin, the capital form of i is İ, while the lowercase form of I is ı &amp;mdash; they&amp;rsquo;re two different letters. Fortunately we do have a way to account for this:</source>
          <target state="translated">El ejemplo m&amp;aacute;s famoso de este tipo de problemas, probablemente, es el turco. En lat&amp;iacute;n turco, la forma may&amp;uacute;scula de i es İ, mientras que la forma min&amp;uacute;scula de I es ı: son dos letras diferentes. Afortunadamente, tenemos una forma de dar cuenta de esto:</target>
        </trans-unit>
        <trans-unit id="4c47e3933006e2a994f15b0b8d727bc485f4d3ad" translate="yes" xml:space="preserve">
          <source>There is a very simple way to implement it by &lt;strong&gt;replace&lt;/strong&gt;. For ECMAScript&amp;nbsp;6:</source>
          <target state="translated">Hay una manera muy simple de implementarlo mediante el &lt;strong&gt;reemplazo&lt;/strong&gt; . Para ECMAScript 6:</target>
        </trans-unit>
        <trans-unit id="04f622e4b19164c4d7616ea7f0401578b5a965de" translate="yes" xml:space="preserve">
          <source>This could be tweaked a bit to also handle capitalizing multiple words in a string with fairly good accuracy. The &lt;code&gt;CWU&lt;/code&gt; or &lt;a href=&quot;https://unicode.org/reports/tr44/#CWU&quot;&gt;Changes_When_Uppercased&lt;/a&gt; character property matches all code points which, well, change when uppercased. We can try this out with a titlecased digraph characters like the Dutch &lt;a href=&quot;https://en.wikipedia.org/wiki/IJ_(digraph)&quot;&gt;ĳ&lt;/a&gt; for example:</source>
          <target state="translated">Esto podr&amp;iacute;a modificarse un poco para manejar tambi&amp;eacute;n may&amp;uacute;sculas m&amp;uacute;ltiples palabras en una cadena con bastante buena precisi&amp;oacute;n. La propiedad de car&amp;aacute;cter &lt;code&gt;CWU&lt;/code&gt; o &lt;a href=&quot;https://unicode.org/reports/tr44/#CWU&quot;&gt;Changes_When_Uppercased&lt;/a&gt; coincide con todos los puntos de c&amp;oacute;digo que, bueno, cambian cuando se escribe en may&amp;uacute;scula. Podemos probar esto con caracteres de d&amp;iacute;grafo enchapados en el t&amp;iacute;tulo como el holand&amp;eacute;s &lt;a href=&quot;https://en.wikipedia.org/wiki/IJ_(digraph)&quot;&gt;ĳ&lt;/a&gt; por ejemplo:</target>
        </trans-unit>
        <trans-unit id="aaf0e7360a18b0ecd99a513342639b5cd16aa14e" translate="yes" xml:space="preserve">
          <source>This is a text string =&amp;gt; This Is A Text String</source>
          <target state="translated">Esta es una cadena de texto =&amp;gt; Esto es una cadena de texto</target>
        </trans-unit>
        <trans-unit id="445a7900debb9aa27ba0234cd7efda1545c51c28" translate="yes" xml:space="preserve">
          <source>This is from &lt;em&gt;&lt;a href=&quot;http://www.w3schools.com/cssref/pr_text_text-transform.asp&quot;&gt;CSS text-transform Property&lt;/a&gt;&lt;/em&gt; (at &lt;a href=&quot;http://en.wikipedia.org/wiki/W3Schools&quot;&gt;W3Schools&lt;/a&gt;).</source>
          <target state="translated">Esto es de &lt;em&gt;&lt;a href=&quot;http://www.w3schools.com/cssref/pr_text_text-transform.asp&quot;&gt;CSS&lt;/a&gt;&lt;/em&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/W3Schools&quot;&gt;Text&lt;/a&gt; &lt;em&gt;-transform Property&lt;/em&gt; (en W3Schools ).</target>
        </trans-unit>
        <trans-unit id="c6f3cfe2c963966513eb01910fe27bfe53212f39" translate="yes" xml:space="preserve">
          <source>This will ensure that the following text is changed:</source>
          <target state="translated">Esto asegurará que se cambie el siguiente texto:</target>
        </trans-unit>
        <trans-unit id="0af318f5e656024280a36dcfb0426885a76eff9c" translate="yes" xml:space="preserve">
          <source>To avoid &lt;code&gt;undefined&lt;/code&gt; for empty strings (see &lt;a href=&quot;https://stackoverflow.com/questions/1026069/capitalize-the-first-letter-of-string-in-javascript/7224605?noredirect=1#comment40995528_7224605&quot;&gt;@njzk2's comment below&lt;/a&gt;), you can check for an empty string:</source>
          <target state="translated">Para evitar cadenas &lt;code&gt;undefined&lt;/code&gt; (ver &lt;a href=&quot;https://stackoverflow.com/questions/1026069/capitalize-the-first-letter-of-string-in-javascript/7224605?noredirect=1#comment40995528_7224605&quot;&gt;el comentario de @ njzk2 a continuaci&amp;oacute;n&lt;/a&gt; ), puede verificar si hay una cadena vac&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="7545eb65f39400b816765aedda58dcaf2245938f" translate="yes" xml:space="preserve">
          <source>Update Nov.2016 (ES6), just for FUN :</source>
          <target state="translated">Actualización Nov.2016 (ES6),sólo para DIVERSIÓN :</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="438b77c967ff84de26b6c856e0dbc9c0ccb11946" translate="yes" xml:space="preserve">
          <source>Vanilla js for first upper case:</source>
          <target state="translated">Vainilla js para la primera mayúscula:</target>
        </trans-unit>
        <trans-unit id="cc356c06beeecbb1483af35dc9f41fbcb69e577a" translate="yes" xml:space="preserve">
          <source>We can also make this work in ES5 and below by taking that logic a bit further if necessary. There are no intrinsic methods in ES5 for working with codepoints, so we have to manually test whether the first code unit is a surrogate****:</source>
          <target state="translated">También podemos hacer que esto funcione en el ES5 y más abajo llevando esa lógica un poco más lejos si es necesario.No hay métodos intrínsecos en ES5 para trabajar con puntos de código,así que tenemos que probar manualmente si la primera unidad de código es un sustituto****:</target>
        </trans-unit>
        <trans-unit id="38598e2d769aafd63e8b0ada676593eea8abbce4" translate="yes" xml:space="preserve">
          <source>We could get the first character with one of my favorite &lt;code&gt;RegExp&lt;/code&gt;, looks like a cute smiley: &lt;code&gt;/^./&lt;/code&gt;</source>
          <target state="translated">Podr&amp;iacute;amos obtener el primer personaje con uno de mis &lt;code&gt;RegExp&lt;/code&gt; favoritos, parece un lindo smiley: &lt;code&gt;/^./&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80c2861bacbf5087e7a78a28702e92c207722448" translate="yes" xml:space="preserve">
          <source>With the expected output being:</source>
          <target state="translated">Con el resultado esperado:</target>
        </trans-unit>
        <trans-unit id="0728cce84a033f171749d6217a9b0b732df74446" translate="yes" xml:space="preserve">
          <source>You can capitalise a string by calling &lt;strong&gt;ucfirst(&quot;some string&quot;)&lt;/strong&gt; -- for example,</source>
          <target state="translated">Puede poner en may&amp;uacute;scula una cadena llamando a &lt;strong&gt;ucfirst (&quot;alguna cadena&quot;)&lt;/strong&gt; , por ejemplo,</target>
        </trans-unit>
        <trans-unit id="4f213a95acdcde6d613a25cf52f2b2753c1f8659" translate="yes" xml:space="preserve">
          <source>You can do it in one line like this</source>
          <target state="translated">Puedes hacerlo en una línea como esta</target>
        </trans-unit>
        <trans-unit id="6c4e71a0412953fe2f3f9b1b1c678eb0f7b05035" translate="yes" xml:space="preserve">
          <source>You might think this would fail for an empty string, and indeed in a language like C you would have to cater for this. However in JavaScript, when you take a substring of an empty string, you just get an empty string back.</source>
          <target state="translated">Se podría pensar que esto fallaría por una cuerda vacía,y de hecho en un lenguaje como el C tendrías que atender esto.Sin embargo en JavaScript,cuando tomas una subcadena de una cadena vacía,sólo obtienes una cadena vacía de vuelta.</target>
        </trans-unit>
        <trans-unit id="d4a9eb672ba09519a041a6378259fc7533179e68" translate="yes" xml:space="preserve">
          <source>You'd call the function, like this:</source>
          <target state="translated">Llamarías a la función,así:</target>
        </trans-unit>
        <trans-unit id="b3de993735805658454ec6a662d98b23e05c1c34" translate="yes" xml:space="preserve">
          <source>_.capitalize(string) Converts first letter of the string to
  uppercase.</source>
          <target state="translated">Convierte la primera letra de la cadena en mayúscula.</target>
        </trans-unit>
        <trans-unit id="58ed86c48852b86ec22065963de4717546a22f0f" translate="yes" xml:space="preserve">
          <source>and call it as below:</source>
          <target state="translated">y llamarlo como abajo:</target>
        </trans-unit>
        <trans-unit id="5841729c0f596832e8c1fdf28e8579200c954984" translate="yes" xml:space="preserve">
          <source>and call it like:</source>
          <target state="translated">y llamarlo así:</target>
        </trans-unit>
        <trans-unit id="07ca609f2cad16f006215d4b73b16c731cd9ef2e" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;capitalize(&quot;hello&quot;) // Hello&lt;/code&gt;</source>
          <target state="translated">luego &lt;code&gt;capitalize(&quot;hello&quot;) // Hello&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
