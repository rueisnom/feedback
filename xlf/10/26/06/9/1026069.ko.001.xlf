<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1026069">
    <body>
      <group id="1026069">
        <trans-unit id="9de390a8260c191b43450f70ae86feb669df0906" translate="yes" xml:space="preserve">
          <source>(You may encapsulate it in a function or even add it to the String prototype if you use it frequently.)</source>
          <target state="translated">자주 사용하는 경우 함수로 캡슐화하거나 문자열 프로토 타입에 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9bf45d36ec359981f7c6104d1efde02af646768" translate="yes" xml:space="preserve">
          <source>...and for all guys who think that there's a better way of doing this, without extending native prototypes:</source>
          <target state="translated">... 기본 프로토 타입을 확장하지 않고도 더 좋은 방법이 있다고 생각하는 모든 사람들에게 :</target>
        </trans-unit>
        <trans-unit id="367d2eac8d3ed38b462e4255bae2e055a734f474" translate="yes" xml:space="preserve">
          <source>...and then, there is so much more to this question when you consider internationalisation, as &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;this astonishingly good answer&lt;/a&gt; (buried below) shows.</source>
          <target state="translated">... 그리고 국제화를 고려할 때이 질문에 훨씬 더 많은 것이 있습니다. &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;이 놀라운 대답&lt;/a&gt; (아래에 묻혀 있음)이 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="01458e5b9ce1421cc63ab3a554d729db7d445bfd" translate="yes" xml:space="preserve">
          <source>4,577,946 ops/s &amp;plusmn;1.2% for the most voted answer.</source>
          <target state="translated">가장 많이 투표 된 답변에 대해 4,577,946 ops / s &amp;plusmn; 1.2 %</target>
        </trans-unit>
        <trans-unit id="a2ffd6820da15f37abf4c947e438311a5752e475" translate="yes" xml:space="preserve">
          <source>4,956,962 ops/s &amp;plusmn;3.03% for this solution,</source>
          <target state="translated">이 솔루션의 경우 4,956,962 ops / s &amp;plusmn; 3.03 %,</target>
        </trans-unit>
        <trans-unit id="21536903e387743ca164f63d9cc09e9b8b6bb9e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;/index.html&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;/index.html&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;/index.html&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;/index.html&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d494e91c3e544750401f32794514d26617133c2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;the Eiffel Tower&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;The Eiffel Tower&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;the Eiffel Tower&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;The Eiffel Tower&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="163679a6bb6d7fb0504648cd5281b896b69b7f3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;this is a test&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;This is a test&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;this is a test&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;This is a test&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="228001a68abeb7721c7e6836bdfa016232028ea1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; gives us the ability to declare &lt;code&gt;capitalizeFirstChar&lt;/code&gt; as constant, which is desired since as a programmer you should always explicitly state your intentions.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 는 우리에게 &lt;code&gt;capitalizeFirstChar&lt;/code&gt; 를 상수로 선언하는 기능을 제공합니다. 이것은 프로그래머로서 항상 의도를 명시 적으로 명시해야하기 때문에 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="fe5ad94b64fc4f2a2e524d4f6153761e202b6090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parameters =&amp;gt; function&lt;/code&gt; is so called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;parameters =&amp;gt; function&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 함수&lt;/a&gt; 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a8043e9b8b738f65ac06fcc7f0df98edb180022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string.substring(1)&lt;/code&gt; is faster than &lt;code&gt;string.slice(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string.substring(1)&lt;/code&gt; 은 string.slice (1) 보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="5d710ede0941e4a1632178bcd80a8c8aab513de6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;* The code units of UTF-16 / UCS2 are also Unicode code points in the sense that e.g. U+D800 is technically a code point, but that&amp;rsquo;s not what it &amp;ldquo;means&amp;rdquo; here ... sort of ... though it gets pretty fuzzy. What the surrogates definitely are not, though, is USVs (Unicode scalar values).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;* UTF-16 / UCS2의 코드 단위는 또한 U + D800이 기술적으로 코드 포인트라는 점에서 유니 코드 코드 포인트입니다. 그러나 이것이&amp;ldquo;의미&amp;rdquo;한 것이 아닙니다. 흐린.&lt;/em&gt; &lt;em&gt;그러나 대리자가 확실히 아닌 것은 USV (유니 코드 스칼라 값)입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80e943d6704e4d184a5db2220f9f6efdc9fbefec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;** Though if a surrogate code unit is &amp;ldquo;orphaned&amp;rdquo; &amp;mdash; i.e., not part of a logical pair &amp;mdash; you could still get surrogates here, too.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;** 대리 코드 단위가 &quot;분리 된&quot;(즉, 논리 쌍의 일부가 아닌) 경우에도 여전히 대리자를 얻을 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cdf2e5c67a4f0fdde3be9c75c84dbfc0ff1c9081" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;*** maybe. I haven&amp;rsquo;t tested it. Unless you have determined capitalization is a meaningful bottleneck, I probably wouldn&amp;rsquo;t sweat it &amp;mdash; choose whatever you believe is most clear and readable.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;*** 아마도.&lt;/em&gt; &lt;em&gt;나는 그것을 테스트하지 않았습니다.&lt;/em&gt; &lt;em&gt;대문자 사용이 의미있는 병목 현상이 아니라면 땀을 흘리지 않을 것입니다. 가장 명확하고 읽기 쉬운 항목을 선택하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1853748fb3df42199189a7bc4ca52932cac9483c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;**** such a function might wish to test both the first and second code units instead of just the first, since it&amp;rsquo;s possible that the first unit is an orphaned surrogate. For example the input &quot;\uD800x&quot; would capitalize the X as-is, which may or may not be expected.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;**** 이러한 함수는 첫 번째 단위가 분리 된 대리 일 가능성이 있기 때문에 첫 번째 코드 대신 첫 번째 코드 단위와 두 번째 코드 단위를 모두 테스트하려고 할 수 있습니다.&lt;/em&gt; &lt;em&gt;예를 들어 입력 &quot;\ uD800x&quot;는 X를 그대로 대문자로 표시하므로 예상되거나 예상되지 않을 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e323f33e94cbca47eb23464c89f17f842364d336" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;***** Here&amp;rsquo;s the &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1361876&quot;&gt;Bugzilla issue&lt;/a&gt; if you want to follow the progress more directly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;***** 진행 상황을 더 직접적으로 따르고 싶다면 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1361876&quot;&gt;Bugzilla 문제&lt;/a&gt; 가 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34b7e56ddb1cb38bfcf26066f4b7ae7fb74172d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Initially I didn&amp;rsquo;t see any answers addressing issues related to astral plane code points. There &lt;a href=&quot;https://stackoverflow.com/a/45224904/1631952&quot;&gt;is one&lt;/a&gt;, but it&amp;rsquo;s a bit buried (like this one will be, I guess!)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;처음에는 아스트랄 평면 코드 포인트와 관련된 문제를 해결하는 답변을 보지 못했습니다.&lt;/em&gt; &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/45224904/1631952&quot;&gt;하나&lt;/a&gt; 가 있지만 조금 묻혀 있습니다 (이것이 될 것입니다.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67d4c331b2081030c9036c63f7dcc26c1bc21da1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You could use bitwise math instead of &lt;code&gt;&amp;gt; 0xFFFF&lt;/code&gt; there, but it&amp;rsquo;s probably easier to understand this way and either would achieve the same thing.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;&amp;gt; 0xFFFF&lt;/code&gt; 대신 비트 단위의 수학을 사용할 수 있지만이 방법을 이해하는 것이 더 쉬울 수도 있고 같은 것을 얻을 수도 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e11e3af42de6298ef3229ff0943985a06191a5a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SHORTEST&lt;/strong&gt; 3 solutions, 1 and 2 handle cases when &lt;code&gt;s&lt;/code&gt; string  is &lt;code&gt;&quot;&quot;&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 문자열이 &lt;code&gt;&quot;&quot;&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 인 경우 &lt;strong&gt;SHORTEST&lt;/strong&gt; 3 솔루션, 1 및 2 핸들 케이스 :</target>
        </trans-unit>
        <trans-unit id="0241744970e1f05578cdbbce0e8b6ad42587ba7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the 2018 ECMAScript&amp;nbsp;6+ Solution&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;이것은 2018 ECMAScript 6+ 솔루션입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f715e43a9cd501ad9b3351990a77f7d25046bb86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;업데이트 2 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b38760c3360e1a927a9cacd29a860eddc0edeb9" translate="yes" xml:space="preserve">
          <source>According to the comments below this doesn't work in IE 7 or below.</source>
          <target state="translated">아래 의견에 따르면 IE 7 이하에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca975c6c918692672e6209be6187776c7dfee237" translate="yes" xml:space="preserve">
          <source>Also the alternative option is JavaScript, so the best gonna be something like this:</source>
          <target state="translated">또한 대체 옵션은 JavaScript이므로 다음과 같은 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d379b63cddadbeb97273b4dc578ce9d650af84b8" translate="yes" xml:space="preserve">
          <source>And for all coffee-junkies:</source>
          <target state="translated">그리고 모든 커피 중독자들에게 :</target>
        </trans-unit>
        <trans-unit id="a65c6aab9ccb89445d5895ed004afd6ead95252c" translate="yes" xml:space="preserve">
          <source>And then:</source>
          <target state="translated">그리고:</target>
        </trans-unit>
        <trans-unit id="4cab7d90a7f1fec6fb511da21e50825814a58e70" translate="yes" xml:space="preserve">
          <source>As you can see, the first two methods are essentially comparable in terms of performance, whereas altering the &lt;code&gt;String.prototype&lt;/code&gt; is by far the slowest in terms of performance.</source>
          <target state="translated">보시다시피, 처음 두 방법은 성능 측면에서 필적 할 &lt;code&gt;String.prototype&lt;/code&gt; 변경은 성능면에서 가장 느립니다.</target>
        </trans-unit>
        <trans-unit id="b738c32be44272442962e986db9a0980aba6f5fb" translate="yes" xml:space="preserve">
          <source>At the start I also mentioned internationalization considerations. Some of these are very difficult to account for because they require knowledge not only of &lt;em&gt;what&lt;/em&gt; language is being used, but also may require specific knowledge of the words in the language. For example, the Irish digraph &quot;mb&quot; capitalizes as &quot;mB&quot; at the start of a word. Another example, the German eszett, never begins a word (afaik), but still helps illustrate the problem. The lowercase eszett (&amp;ldquo;&amp;szlig;&amp;rdquo;) capitalizes to &amp;ldquo;SS,&amp;rdquo; but  &amp;ldquo;SS&amp;rdquo; could lowercase to either &amp;ldquo;&amp;szlig;&amp;rdquo; or &amp;ldquo;ss&amp;rdquo; &amp;mdash; you require out-of-band knowledge of the German language to know which is correct!</source>
          <target state="translated">처음에는 국제화 고려 사항도 언급했습니다. 이들 중 일부는 사용되는 언어에 대한 지식뿐만 아니라 언어의 단어에 대한 특정 지식이 필요할 수 있기 때문에 설명하기가 매우 어렵습니다. 예를 들어, 아일랜드어 &quot;mb&quot;는 단어의 시작 부분에서 &quot;mB&quot;로 대문자로 표시됩니다. 또 다른 예인 독일어 eszett는 단어 (afaik)를 시작하지 않지만 여전히 문제를 설명하는 데 도움이됩니다. 소문자 eszett ( &quot;&amp;szlig;&quot;)는 &quot;SS&quot;로 대문자를 사용하지만 &quot;SS&quot;는 &quot;&amp;szlig;&quot;또는 &quot;ss&quot;로 소문자를 지정할 수 있습니다. 어떤 언어가 올바른지 알기 위해서는 독일어에 대한 대역 외 지식이 필요합니다!</target>
        </trans-unit>
        <trans-unit id="cdcb4da1ad0efcd4394c1ed55e3b70f42e24c0b4" translate="yes" xml:space="preserve">
          <source>At the time of writing (Feb 2020), Firefox/Spidermonkey has not yet implemented any of the RegExp features introduced in the last two years*****. You can check the current status of this feature at the &lt;a href=&quot;http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Unicode_Property_Escapes&quot;&gt;Kangax compat table&lt;/a&gt;. Babel is able to compile RegExp literals with property references to equivalent patterns without them, but be aware that the resulting code may be enormous.</source>
          <target state="translated">작문 당시 (2020 년 2 월) Firefox / Spidermonkey는 지난 2 년 동안 소개 된 RegExp 기능을 아직 구현하지 않았습니다 *****. &lt;a href=&quot;http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Unicode_Property_Escapes&quot;&gt;Kangax compat 테이블&lt;/a&gt; 에서이 기능의 현재 상태를 확인할 수 있습니다. Babel은 해당 패턴이없는 동등한 패턴에 대한 속성 참조를 사용하여 RegExp 리터럴을 컴파일 할 수 있지만 결과 코드는 엄청날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="c28281d29953dd5bbfe8e32fb31c9ecf6084a1d8" translate="yes" xml:space="preserve">
          <source>CSS only</source>
          <target state="translated">CSS 만</target>
        </trans-unit>
        <trans-unit id="2f3f9c86a9d991e58459d1d1c5a24e5332a22188" translate="yes" xml:space="preserve">
          <source>Capitalize the first letter of all words in a string:</source>
          <target state="translated">문자열에서 모든 단어의 첫 글자를 대문자로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a69da05af469308b462024895eb097e9dd01295b" translate="yes" xml:space="preserve">
          <source>Checkout this solution:</source>
          <target state="translated">이 솔루션을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0ab8dd120611ec6f99b50238ac21e32cacf65d79" translate="yes" xml:space="preserve">
          <source>Created with &lt;a href=&quot;https://jsbench.me/&quot;&gt;JSBench.me&lt;/a&gt; on Google Chrome 57.</source>
          <target state="translated">Chrome 57에서 &lt;a href=&quot;https://jsbench.me/&quot;&gt;JSBench.me로&lt;/a&gt; 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="38eff30dd7da438c13e56e85015681e989636246" translate="yes" xml:space="preserve">
          <source>Despite being called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter&quot;&gt;&lt;code&gt;::first-letter&lt;/code&gt;&lt;/a&gt;, it applies to the first &lt;strong&gt;character&lt;/strong&gt;, i.e. in case of string &lt;code&gt;%a&lt;/code&gt;, this selector would apply to &lt;code&gt;%&lt;/code&gt; and as such &lt;code&gt;a&lt;/code&gt; would not be capitalized.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter&quot;&gt; &lt;code&gt;::first-letter&lt;/code&gt; &lt;/a&gt; 라고하지만 첫 번째 &lt;strong&gt;문자에&lt;/strong&gt; 적용됩니다 (예 : 문자열 &lt;code&gt;%a&lt;/code&gt; 경우).이 선택기는 &lt;code&gt;%&lt;/code&gt; 에 적용되므로 대문자로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b53015fce6abe5786b7601af4988a62b9ce4c6c7" translate="yes" xml:space="preserve">
          <source>ES2015 one-liner</source>
          <target state="translated">ES2015 원 라이너</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="5efc2d2017db789ed39b3f6945df2de895bab671" translate="yes" xml:space="preserve">
          <source>For another case I need it to capitalize the first letter and lowercase the rest. The following cases made me change this function:</source>
          <target state="translated">다른 경우에는 첫 글자를 대문자로하고 나머지는 소문자로 사용해야합니다. 다음과 같은 경우이 기능을 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="fed1125217a67648d6e1fabd36895a4669511da3" translate="yes" xml:space="preserve">
          <source>For even more internationalization options, please see the &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;original answer below&lt;/a&gt;.</source>
          <target state="translated">더 많은 국제화 옵션에 대해서는 &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;아래&lt;/a&gt; 의 원래 답변을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd7ea24cff598ca7d051a4d8d628b73aae9173a8" translate="yes" xml:space="preserve">
          <source>For longer strings, this is probably not terribly efficient*** &amp;mdash; we don&amp;rsquo;t really need to iterate the remainder. We could use &lt;code&gt;String.prototype.codePointAt&lt;/code&gt; to get at that first (possible) letter, but we&amp;rsquo;d still need to determine where the slice should begin. One way to avoid iterating the remainder would be to test whether the first codepoint is outside the BMP; if it isn&amp;rsquo;t, the slice begins at 1, and if it is, the slice begins at 2.</source>
          <target state="translated">더 긴 문자열의 경우, 아마도 그렇게 효율적이지 않을 것입니다. *** 우리는 실제로 나머지를 반복 할 필요가 없습니다. &lt;code&gt;String.prototype.codePointAt&lt;/code&gt; 를 사용하여 첫 번째 (가능한) 문자를 얻을 수 있지만 슬라이스 시작 위치를 결정해야합니다. 나머지를 반복하지 않는 한 가지 방법은 첫 번째 코드 포인트가 BMP 외부에 있는지 테스트하는 것입니다. 그렇지 않으면 슬라이스는 1에서 시작하고, 그렇지 않으면 슬라이스는 2에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b63decbd83c1b992eb529da43269358b03bcf440" translate="yes" xml:space="preserve">
          <source>From ES2015 on, dealing with this became a bit easier. &lt;code&gt;String.prototype[@@iterator]&lt;/code&gt; yields strings corresponding to code points**. So for example, we can do this:</source>
          <target state="translated">ES2015부터는 이것을 다루는 것이 약간 쉬워졌습니다. &lt;code&gt;String.prototype[@@iterator]&lt;/code&gt; 은 코드 포인트 **에 해당하는 문자열을 생성합니다. 예를 들어 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74c10e52cd68360f7bdbca8c52fc4938b2eb4e9a" translate="yes" xml:space="preserve">
          <source>Here are the fastest methods based on &lt;a href=&quot;http://jsperf.com/capitalize-the-first-letter-of-string-in-javascript/2&quot;&gt;this jsperf test&lt;/a&gt; (ordered from fastest to slowest).</source>
          <target state="translated">&lt;a href=&quot;http://jsperf.com/capitalize-the-first-letter-of-string-in-javascript/2&quot;&gt;이 jsperf 테스트를&lt;/a&gt; 기반으로 가장 빠른 방법은 다음과 같습니다 (가장 빠른 순서에서 가장 느린 순서로).</target>
        </trans-unit>
        <trans-unit id="36ec1b221f06d0c0a874dc6ea003751af9a2707b" translate="yes" xml:space="preserve">
          <source>Here is a function called &lt;strong&gt;ucfirst()&lt;/strong&gt; (short for &quot;upper case first letter&quot;):</source>
          <target state="translated">다음은 &lt;strong&gt;ucfirst ()&lt;/strong&gt; 라는 함수입니다 ( &quot;대문자 첫 글자&quot;의 줄임말).</target>
        </trans-unit>
        <trans-unit id="f63bba80779b9f905ca9275279f4d3217ddae10f" translate="yes" xml:space="preserve">
          <source>Here is a shortened version of the popular answer that gets the first letter by treating the string as an array:</source>
          <target state="translated">다음은 문자열을 배열로 취급하여 첫 글자를 얻는 인기있는 답변의 단축 버전입니다.</target>
        </trans-unit>
        <trans-unit id="8de7492950ddcf0f0806df769b72006c014004f5" translate="yes" xml:space="preserve">
          <source>Here's a more object-oriented approach:</source>
          <target state="translated">보다 객체 지향적 인 접근 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26ec945f349fe1c8f7b8bfe93fdfedd83c5c2657" translate="yes" xml:space="preserve">
          <source>How do I make the first letter of a string uppercase in JavaScript</source>
          <target state="translated">JavaScript에서 문자열의 첫 글자를 대문자로 바꾸는 방법</target>
        </trans-unit>
        <trans-unit id="41600359895123b43257f89a1713e3beaa5909e0" translate="yes" xml:space="preserve">
          <source>How do I make the first letter of a string uppercase, but not change the case of any of the other letters?</source>
          <target state="translated">문자열의 첫 글자를 대문자로 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2471381604a49f6d0e0c580d6ed33d04e7bbf029" translate="yes" xml:space="preserve">
          <source>However, some cased characters fall outside the BMP (basic multilingual plane, code points U+0 to U+FFFF). For example take this Deseret text:</source>
          <target state="translated">그러나 일부 사례 문자는 BMP (기본 다국어 평면, 코드 포인트 U + 0 ~ U + FFFF)를 벗어납니다. 예를 들어 다음 Deseret 텍스트를 보자.</target>
        </trans-unit>
        <trans-unit id="ab4561105ba74782ce146baef49296c05955c8d5" translate="yes" xml:space="preserve">
          <source>I didn&amp;rsquo;t see any mention in the existing answers of issues related to &lt;s&gt;astral plane code points or&lt;/s&gt; internationalization. &amp;ldquo;Uppercase&amp;rdquo; doesn&amp;rsquo;t mean the same thing in every language using a given script.</source>
          <target state="translated">나는 &lt;s&gt;아스트랄 비행기 코드 포인트 또는&lt;/s&gt; 국제화와 관련된 문제에 대한 기존의 답변에서 언급을 보지 못했습니다. &amp;ldquo;대문자&amp;rdquo;는 특정 스크립트를 사용하는 모든 언어에서 동일한 것을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="57568b656d3bfd8b25836b6e404e950afe5e8ed8" translate="yes" xml:space="preserve">
          <source>I found this arrow function easiest. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;Replace&lt;/a&gt; matches the first letter character (&lt;code&gt;\w&lt;/code&gt;) of your string and converts it to uppercase. Nothing fancier necessary.</source>
          <target state="translated">이 화살표 기능이 가장 쉽다는 것을 알았습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;Replace&lt;/a&gt; 는 문자열의 첫 문자 ( &lt;code&gt;\w&lt;/code&gt; )와 일치하여 대문자로 변환합니다. 더 멋진 것은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc8ad3518c2d8b9e7e804ae69020ba2d72f9b38e" translate="yes" xml:space="preserve">
          <source>I went with name &lt;code&gt;capitalizeFirstChar&lt;/code&gt; instead of &lt;code&gt;capitalizeFirstLetter&lt;/code&gt;, because OP didn't asked for code that capitalizes the first letter in the entire string, but the very first char (if it's letter, of course).</source>
          <target state="translated">OP는 전체 문자열의 첫 번째 문자를 대문자로하는 코드를 요청하지 않았지만 첫 번째 문자 (물론 문자 인 경우)를 대문자로 바꾸는 코드를 요청하지 않았기 때문에 &lt;code&gt;capitalizeFirstChar&lt;/code&gt; 대신 capitalizeFirstChar 라는 이름을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="12beaec08e35b5059fe37bcbcaff9243ba2cb242" translate="yes" xml:space="preserve">
          <source>If you  want to reuse it over and over, it's better attach it to javascript native String, so something like below:</source>
          <target state="translated">반복해서 재사용하려면 자바 스크립트 네이티브 문자열에 첨부하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5595b4caaf07e85122b5dcf531caac0aed37a182" translate="yes" xml:space="preserve">
          <source>If you are wanting to reformat all-caps text, you might want to modify the other examples as such:</source>
          <target state="translated">모든 대문자 텍스트를 다시 포맷하려면 다른 예제를 다음과 같이 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="391b6c39ae6bd183048d53c4501002d9557638f3" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; or &lt;a href=&quot;http://lodash.com/&quot;&gt;Lo-Dash&lt;/a&gt;, the &lt;a href=&quot;https://github.com/epeli/underscore.string&quot;&gt;underscore.string&lt;/a&gt; library provides string extensions, including capitalize:</source>
          <target state="translated">&lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; 또는 &lt;a href=&quot;http://lodash.com/&quot;&gt;Lo-Dash&lt;/a&gt; 를 사용하는 경우 &lt;a href=&quot;https://github.com/epeli/underscore.string&quot;&gt;underscore.string&lt;/a&gt; 라이브러리는 대문자를 포함하여 문자열 확장을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3580d94edc18905a809fe61049b66ac884fd95f0" translate="yes" xml:space="preserve">
          <source>If you want to work with Unicode code points instead of code units (for example to handle Unicode characters outside of the Basic Multilingual Plane) you can leverage the fact that &lt;code&gt;String#[@iterator]&lt;/code&gt; works with code points, and you can use &lt;code&gt;toLocaleUpperCase&lt;/code&gt; to get locale-correct uppercasing:</source>
          <target state="translated">코드 단위 대신 유니 코드 코드 포인트로 작업하려면 (예 : 기본 다국어 평면 외부에서 유니 코드 문자를 처리하기 위해) &lt;code&gt;String#[@iterator]&lt;/code&gt; 가 코드 포인트에서 작동한다는 사실을 활용할 수 있으며 &lt;code&gt;toLocaleUpperCase&lt;/code&gt; 를 사용하여 로케일이 올바른 대문자를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="520fb73d2d3cb4c07939630bd614bc3b08d45c7a" translate="yes" xml:space="preserve">
          <source>If you're already (or considering) using &lt;code&gt;lodash&lt;/code&gt;, the solution is easy:</source>
          <target state="translated">&lt;code&gt;lodash&lt;/code&gt; 를 이미 사용하고 있거나 고려하고 있다면 해결책은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="4ec057c220d248000ac866fd08c88dfedb4df649" translate="yes" xml:space="preserve">
          <source>If you're interested in the performance of a few different methods posted:</source>
          <target state="translated">게시 된 몇 가지 다른 방법의 성능에 관심이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="22ed663eee054bfc4462b75cb3de053fa66754b0" translate="yes" xml:space="preserve">
          <source>In CSS:</source>
          <target state="translated">CSS에서 :</target>
        </trans-unit>
        <trans-unit id="513ed99d77b99d0268fb8f84f8be5411764fabcb" translate="yes" xml:space="preserve">
          <source>In IE9+ or IE5.5+ it's supported in legacy notation with only one colon (&lt;code&gt;:first-letter&lt;/code&gt;).</source>
          <target state="translated">IE9 + 또는 IE5.5 +에서는 하나의 콜론 ( &lt;code&gt;:first-letter&lt;/code&gt; )만으로 레거시 표기법으로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2c731feb5a1bab9995bffb541f3ec85ca6616ec0" translate="yes" xml:space="preserve">
          <source>In a browser, the user&amp;rsquo;s most-preferred language tag is indicated by &lt;code&gt;navigator.language&lt;/code&gt;, a list in order of preference is found at &lt;code&gt;navigator.languages&lt;/code&gt;, and a given DOM element&amp;rsquo;s language can be obtained (usually) with &lt;code&gt;Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE&lt;/code&gt; in multilanguage documents.</source>
          <target state="translated">브라우저에서 사용자가 가장 선호하는 언어 태그는 &lt;code&gt;navigator.language&lt;/code&gt; 로 표시되며, 선호 순서대로 목록은 &lt;code&gt;navigator.languages&lt;/code&gt; 에 있으며 주어진 DOM 요소의 언어는 &lt;code&gt;Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE&lt;/code&gt; 다국어 문서의 YOUR_DEFAULT_HERE</target>
        </trans-unit>
        <trans-unit id="3e7be93047b07099fd9e6aeac9ef8367e4ad1893" translate="yes" xml:space="preserve">
          <source>In agents which support Unicode property character classes in RegExp, which were introduced in ES2018, we can clean stuff up further by directly expressing what characters we&amp;rsquo;re interested in:</source>
          <target state="translated">ES2018에 도입 된 RegExp에서 유니 코드 속성 문자 클래스를 지원하는 에이전트에서 관심있는 문자를 직접 표현하여 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="237f8c8207eb9f09670dd34797c5476976d0f091" translate="yes" xml:space="preserve">
          <source>In all likelihood, people asking this question will not be concerned with Deseret capitalization or internationalization. But it&amp;rsquo;s good to be aware of these issues because there&amp;rsquo;s a good chance you&amp;rsquo;ll encounter them eventually even if they aren&amp;rsquo;t concerns presently. They&amp;rsquo;re not &amp;ldquo;edge&amp;rdquo; cases, or rather, they&amp;rsquo;re not &lt;em&gt;by-definition&lt;/em&gt; edge cases &amp;mdash; there&amp;rsquo;s a whole country where most people speak Turkish, anyway, and conflating code units with codepoints is a fairly common source of bugs (especially with regard to emoji). Both strings and language are pretty complicated!</source>
          <target state="translated">아마이 질문을하는 사람들은 Deseret 대문자 또는 국제화에 관심이 없을 것입니다. 그러나 현재 문제가되지 않더라도 결국에는 문제가 발생할 가능성이 높기 때문에 이러한 문제를 알고있는 것이 좋습니다. 그것들은&amp;ldquo;가장자리&amp;rdquo;가 아니고 오히려 &lt;em&gt;정의에 의해 정의&lt;/em&gt; 되지는 않습니다. 대부분의 사람들이 터키어를 사용하는 나라가 있습니다. 어쨌든 코드 단위로 코드 단위를 묶는 것은 상당히 일반적인 버그의 원인입니다 (특히 이모티콘과 관련하여). 문자열과 언어는 매우 복잡합니다!</target>
        </trans-unit>
        <trans-unit id="b9215739ff07c5a531e3c157e3d8b7debaf7f595" translate="yes" xml:space="preserve">
          <source>In the benchmark I performed there was no significant difference between &lt;code&gt;string.charAt(0)&lt;/code&gt; and &lt;code&gt;string[0]&lt;/code&gt;. Note however, that &lt;code&gt;string[0]&lt;/code&gt; would be &lt;code&gt;undefined&lt;/code&gt; for empty string, so it should be rewritten to &lt;code&gt;string &amp;amp;&amp;amp; string[0]&lt;/code&gt;, which is way too verbose, compared to the alternative.</source>
          <target state="translated">벤치 마크에서 &lt;code&gt;string.charAt(0)&lt;/code&gt; 과 &lt;code&gt;string[0]&lt;/code&gt; 사이에는 큰 차이가 없었습니다. 그러나 &lt;code&gt;string[0]&lt;/code&gt; 은 빈 문자열에 대해 &lt;code&gt;undefined&lt;/code&gt; 되어 있지 않으므로 대안에 비해 너무 장황한 &lt;code&gt;string &amp;amp;&amp;amp; string[0]&lt;/code&gt; 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa4f881902e40d1677a1a09723b87da7f2131a80" translate="yes" xml:space="preserve">
          <source>It happens to be that UTF-16 code units are 1:1 with USV code points within two ranges, U+0 to U+D7FF and U+E000 to U+FFFF inclusive. Most cased characters fall into those two ranges, but not all of them.</source>
          <target state="translated">UTF-16 코드 단위는 U + 0에서 U + D7FF까지의 UV 코드 포인트와 U + E000에서 U + FFFF를 포함하여 USV 코드 포인트와 함께 1 : 1입니다. 대부분의 경우 문자는이 두 범위에 속하지만 전부는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cfcdd40d2baaffb7a5e373b22106b786580f61af" translate="yes" xml:space="preserve">
          <source>It seems to be easier in CSS:</source>
          <target state="translated">CSS에서 더 쉬운 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="be0d696fbec75b29d058a2ffde594a36cc305bd4" translate="yes" xml:space="preserve">
          <source>It will output &lt;code&gt;&quot;Ruby java&quot;&lt;/code&gt; to the console.</source>
          <target state="translated">&lt;code&gt;&quot;Ruby java&quot;&lt;/code&gt; 를 콘솔에 출력합니다.</target>
        </trans-unit>
        <trans-unit id="753fc3e18b8a5011f782214d0491ba42959f8ddc" translate="yes" xml:space="preserve">
          <source>It works by splitting the string into two pieces.  On the first line it pulls out &lt;strong&gt;firstLetter&lt;/strong&gt; and then on the second line it capitalises &lt;strong&gt;firstLetter&lt;/strong&gt; by calling &lt;strong&gt;firstLetter.toUpperCase()&lt;/strong&gt; and joins it with the rest of the string, which is found by calling &lt;strong&gt;str.substr(1)&lt;/strong&gt;.</source>
          <target state="translated">문자열을 두 조각으로 나눠서 작동합니다. 첫 번째 줄에서 &lt;strong&gt;firstLetter&lt;/strong&gt; 를 가져온 다음 두 번째 줄에서 &lt;strong&gt;firstLetter.toUpperCase ()&lt;/strong&gt; 를 호출 &lt;strong&gt;하여&lt;/strong&gt; &lt;strong&gt;firstLetter&lt;/strong&gt; 를 대문자 &lt;strong&gt;로&lt;/strong&gt; &lt;strong&gt;만들고 str.substr (1)&lt;/strong&gt; 을 호출하여 찾은 나머지 문자열과 조인합니다.</target>
        </trans-unit>
        <trans-unit id="39cf6e340b712fcaeefaccd6c9cae7c6fb438b3b" translate="yes" xml:space="preserve">
          <source>It's always better to handle these kinds of stuff using &lt;strong&gt;CSS first&lt;/strong&gt;, in general, if you can solve something using CSS, go for that first, then try JavaScript to solve your problems, so in this case try using &lt;code&gt;:first-letter&lt;/code&gt; in CSS and apply &lt;code&gt;text-transform:capitalize;&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;CSS를&lt;/strong&gt; 사용하여 이러한 종류의 물건을 처리하는 것이 좋습니다. 일반적으로 CSS를 사용하여 무언가를 해결할 수 있다면 먼저 시도한 다음 JavaScript를 사용하여 문제를 해결하십시오.이 경우 CSS에서 &lt;code&gt;:first-letter&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;text-transform:capitalize;&lt;/code&gt; 적용 : 자본;</target>
        </trans-unit>
        <trans-unit id="68cebc3a030d29b43fc7340eaf94a510388b167b" translate="yes" xml:space="preserve">
          <source>Most of the proposed functions look like this:</source>
          <target state="translated">제안 된 기능의 대부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="bd0ec7f92d0013f9249f7d0c47b7dbfe0e9eaf1d" translate="yes" xml:space="preserve">
          <source>See their docs: &lt;a href=&quot;https://lodash.com/docs#capitalize&quot;&gt;https://lodash.com/docs#capitalize&lt;/a&gt;</source>
          <target state="translated">문서를 참조하십시오 : &lt;a href=&quot;https://lodash.com/docs#capitalize&quot;&gt;https://lodash.com/docs#capitalize&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="7125002cd82871109849d7c7802837b04e3aa758" translate="yes" xml:space="preserve">
          <source>Since there are numerous answers, but none in ES2015 that would solve original problem efficiently, I came up with the following:</source>
          <target state="translated">ES2015에는 원래의 문제를 효율적으로 해결할 수있는 답변이 많지 않기 때문에 다음을 생각해 냈습니다.</target>
        </trans-unit>
        <trans-unit id="a05e8ccd4f0db9fa8ab4b2d4f1e59cc14da07156" translate="yes" xml:space="preserve">
          <source>So try creating a class for that, so you can use it globally, for example: &lt;code&gt;.first-letter-uppercase&lt;/code&gt; and add something like below in your CSS:</source>
          <target state="translated">따라서 클래스를 만들어보십시오. 예를 들어 &lt;code&gt;.first-letter-uppercase&lt;/code&gt; 와 같이 전역 적으로 사용할 수 있으며 CSS에 아래와 같은 것을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1dc1f21e14a758a9bf27e090a7e7aff5d2f7c19a" translate="yes" xml:space="preserve">
          <source>Some other answers modify &lt;code&gt;String.prototype&lt;/code&gt; (this answer used to as well), but I would advise against this now due to maintainability (hard to find out where the function is being added to the &lt;code&gt;prototype&lt;/code&gt; and could cause conflicts if other code uses the same name / a browser adds a native function with that same name in future).</source>
          <target state="translated">다른 답변은 &lt;code&gt;String.prototype&lt;/code&gt; 을 수정하지만 (이 답변은 예전에도 사용되었지만) 유지 관리 가능성 때문에이 문제에 대해 권고 할 것입니다 (기능이 &lt;code&gt;prototype&lt;/code&gt; 에 추가되는 위치를 찾기가 어렵고 다른 코드가 동일한 것을 사용하는 경우 충돌을 일으킬 수 있음) 이름 / 브라우저는 나중에 같은 이름으로 기본 기능을 추가합니다).</target>
        </trans-unit>
        <trans-unit id="f328eb536a4786b3e3cffb9fe5ba8a131e439b94" translate="yes" xml:space="preserve">
          <source>Thanks J-P for the aclaration.</source>
          <target state="translated">설명을 해주셔서 감사합니다.</target>
        </trans-unit>
        <trans-unit id="e7e02386fc0fdd5750e124eedc2fe82fb16c6cbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ucfirst&lt;/code&gt; function works if you do it like this.</source>
          <target state="translated">&lt;code&gt;ucfirst&lt;/code&gt; 하면 ucfirst 함수가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f8d4f74a2fbde727e6e72b8c96f5adb95eabac25" translate="yes" xml:space="preserve">
          <source>The basic solution is:</source>
          <target state="translated">기본 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca5df1b84c287b849617bdac4e324fb5a89cfdb4" translate="yes" xml:space="preserve">
          <source>The first character here fails to capitalize because the array-indexed properties of strings don&amp;rsquo;t access &amp;ldquo;characters&amp;rdquo; or code points*. They access UTF-16 code units. This is true also when slicing &amp;mdash; the index values point at code units.</source>
          <target state="translated">문자열의 배열 색인 속성이 &quot;문자&quot;또는 코드 포인트 *에 액세스하지 않기 때문에 여기서 첫 번째 문자는 대문자로 표시되지 않습니다. UTF-16 코드 단위에 액세스합니다. 슬라이스 할 때도 마찬가지입니다. 인덱스 값은 코드 단위를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="3e7ba471ab8219d28d83cb805cb394c50a047c08" translate="yes" xml:space="preserve">
          <source>The most famous example of these kinds of issues, probably, is Turkish. In Turkish Latin, the capital form of i is İ, while the lowercase form of I is ı &amp;mdash; they&amp;rsquo;re two different letters. Fortunately we do have a way to account for this:</source>
          <target state="translated">이러한 종류의 문제 중 가장 유명한 예는 아마도 터키어입니다. 터키어 라틴어에서 i의 대문자는 İ이고 소문자는 ı입니다. 두 개의 다른 문자입니다. 다행히도 우리는 이것을 설명 할 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c47e3933006e2a994f15b0b8d727bc485f4d3ad" translate="yes" xml:space="preserve">
          <source>There is a very simple way to implement it by &lt;strong&gt;replace&lt;/strong&gt;. For ECMAScript&amp;nbsp;6:</source>
          <target state="translated">&lt;strong&gt;replace&lt;/strong&gt; 로 구현하는 매우 간단한 방법이 있습니다. ECMAScript 6의 경우 :</target>
        </trans-unit>
        <trans-unit id="04f622e4b19164c4d7616ea7f0401578b5a965de" translate="yes" xml:space="preserve">
          <source>This could be tweaked a bit to also handle capitalizing multiple words in a string with fairly good accuracy. The &lt;code&gt;CWU&lt;/code&gt; or &lt;a href=&quot;https://unicode.org/reports/tr44/#CWU&quot;&gt;Changes_When_Uppercased&lt;/a&gt; character property matches all code points which, well, change when uppercased. We can try this out with a titlecased digraph characters like the Dutch &lt;a href=&quot;https://en.wikipedia.org/wiki/IJ_(digraph)&quot;&gt;ĳ&lt;/a&gt; for example:</source>
          <target state="translated">이것은 상당히 좋은 정확도로 문자열에서 여러 단어를 대문자로 처리하도록 약간 조정될 수 있습니다. &lt;code&gt;CWU&lt;/code&gt; 또는 &lt;a href=&quot;https://unicode.org/reports/tr44/#CWU&quot;&gt;Changes_When_Uppercased&lt;/a&gt; 문자 특성은 대문자로 변경 될 때 모든 코드 포인트와 일치합니다. 예를 들어 Dutch &lt;a href=&quot;https://en.wikipedia.org/wiki/IJ_(digraph)&quot;&gt;ĳ&lt;/a&gt; 와 같은 제목이있는 digraph 문자를 사용하여이 작업을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaf0e7360a18b0ecd99a513342639b5cd16aa14e" translate="yes" xml:space="preserve">
          <source>This is a text string =&amp;gt; This Is A Text String</source>
          <target state="translated">이것은 텍스트 문자열입니다 =&amp;gt; 이것은 텍스트 문자열입니다</target>
        </trans-unit>
        <trans-unit id="445a7900debb9aa27ba0234cd7efda1545c51c28" translate="yes" xml:space="preserve">
          <source>This is from &lt;em&gt;&lt;a href=&quot;http://www.w3schools.com/cssref/pr_text_text-transform.asp&quot;&gt;CSS text-transform Property&lt;/a&gt;&lt;/em&gt; (at &lt;a href=&quot;http://en.wikipedia.org/wiki/W3Schools&quot;&gt;W3Schools&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.w3schools.com/cssref/pr_text_text-transform.asp&quot;&gt;CSS 텍스트 변환 속성&lt;/a&gt;&lt;/em&gt; ( &lt;a href=&quot;http://en.wikipedia.org/wiki/W3Schools&quot;&gt;W3Schools&lt;/a&gt; )에서 가져온 것입니다.</target>
        </trans-unit>
        <trans-unit id="c6f3cfe2c963966513eb01910fe27bfe53212f39" translate="yes" xml:space="preserve">
          <source>This will ensure that the following text is changed:</source>
          <target state="translated">그러면 다음 텍스트가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="0af318f5e656024280a36dcfb0426885a76eff9c" translate="yes" xml:space="preserve">
          <source>To avoid &lt;code&gt;undefined&lt;/code&gt; for empty strings (see &lt;a href=&quot;https://stackoverflow.com/questions/1026069/capitalize-the-first-letter-of-string-in-javascript/7224605?noredirect=1#comment40995528_7224605&quot;&gt;@njzk2's comment below&lt;/a&gt;), you can check for an empty string:</source>
          <target state="translated">빈 문자열에 대해 &lt;code&gt;undefined&lt;/code&gt; 것을 피하려면 (아래 &lt;a href=&quot;https://stackoverflow.com/questions/1026069/capitalize-the-first-letter-of-string-in-javascript/7224605?noredirect=1#comment40995528_7224605&quot;&gt;@ njzk2의 주석 참조&lt;/a&gt; ) 빈 문자열을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7545eb65f39400b816765aedda58dcaf2245938f" translate="yes" xml:space="preserve">
          <source>Update Nov.2016 (ES6), just for FUN :</source>
          <target state="translated">FUN 전용 2016 년 11 월 (ES6) 업데이트 :</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="438b77c967ff84de26b6c856e0dbc9c0ccb11946" translate="yes" xml:space="preserve">
          <source>Vanilla js for first upper case:</source>
          <target state="translated">첫 번째 대문자의 바닐라 js :</target>
        </trans-unit>
        <trans-unit id="cc356c06beeecbb1483af35dc9f41fbcb69e577a" translate="yes" xml:space="preserve">
          <source>We can also make this work in ES5 and below by taking that logic a bit further if necessary. There are no intrinsic methods in ES5 for working with codepoints, so we have to manually test whether the first code unit is a surrogate****:</source>
          <target state="translated">필요한 경우 해당 논리를 조금 더 발전시켜 ES5 이하에서이 작업을 수행 할 수도 있습니다. ES5에는 코드 포인트 작업을위한 내장 메소드가 없으므로 첫 번째 코드 단위가 대리 ****인지 수동으로 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="38598e2d769aafd63e8b0ada676593eea8abbce4" translate="yes" xml:space="preserve">
          <source>We could get the first character with one of my favorite &lt;code&gt;RegExp&lt;/code&gt;, looks like a cute smiley: &lt;code&gt;/^./&lt;/code&gt;</source>
          <target state="translated">우리는 내가 좋아하는 &lt;code&gt;RegExp&lt;/code&gt; 중 하나를 사용하여 첫 번째 캐릭터를 얻을 수 있었고, 귀여운 스마일처럼 보입니다 : &lt;code&gt;/^./&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80c2861bacbf5087e7a78a28702e92c207722448" translate="yes" xml:space="preserve">
          <source>With the expected output being:</source>
          <target state="translated">예상되는 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0728cce84a033f171749d6217a9b0b732df74446" translate="yes" xml:space="preserve">
          <source>You can capitalise a string by calling &lt;strong&gt;ucfirst(&quot;some string&quot;)&lt;/strong&gt; -- for example,</source>
          <target state="translated">&lt;strong&gt;ucfirst ( &quot;some string&quot;)&lt;/strong&gt; 를 호출하여 문자열을 대문자로 지정할 수 있습니다 &lt;strong&gt;(&lt;/strong&gt; 예 :</target>
        </trans-unit>
        <trans-unit id="4f213a95acdcde6d613a25cf52f2b2753c1f8659" translate="yes" xml:space="preserve">
          <source>You can do it in one line like this</source>
          <target state="translated">이렇게 한 줄로 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6c4e71a0412953fe2f3f9b1b1c678eb0f7b05035" translate="yes" xml:space="preserve">
          <source>You might think this would fail for an empty string, and indeed in a language like C you would have to cater for this. However in JavaScript, when you take a substring of an empty string, you just get an empty string back.</source>
          <target state="translated">빈 문자열에 대해서는 이것이 실패한다고 생각할 수 있으며 실제로 C와 같은 언어에서는이를 충족시켜야합니다. 그러나 JavaScript에서 빈 문자열의 하위 문자열을 가져 오면 빈 문자열이 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d4a9eb672ba09519a041a6378259fc7533179e68" translate="yes" xml:space="preserve">
          <source>You'd call the function, like this:</source>
          <target state="translated">다음과 같이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b3de993735805658454ec6a662d98b23e05c1c34" translate="yes" xml:space="preserve">
          <source>_.capitalize(string) Converts first letter of the string to
  uppercase.</source>
          <target state="translated">_.capitalize (string) 문자열의 첫 글자를 대문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="58ed86c48852b86ec22065963de4717546a22f0f" translate="yes" xml:space="preserve">
          <source>and call it as below:</source>
          <target state="translated">아래와 같이 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="5841729c0f596832e8c1fdf28e8579200c954984" translate="yes" xml:space="preserve">
          <source>and call it like:</source>
          <target state="translated">다음과 같이 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="07ca609f2cad16f006215d4b73b16c731cd9ef2e" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;capitalize(&quot;hello&quot;) // Hello&lt;/code&gt;</source>
          <target state="translated">then &lt;code&gt;capitalize(&quot;hello&quot;) // Hello&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
