<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1026069">
    <body>
      <group id="1026069">
        <trans-unit id="9de390a8260c191b43450f70ae86feb669df0906" translate="yes" xml:space="preserve">
          <source>(You may encapsulate it in a function or even add it to the String prototype if you use it frequently.)</source>
          <target state="translated">(Вы можете инкапсулировать его в функцию или даже добавить его в прототип Струны,если вы используете его часто).</target>
        </trans-unit>
        <trans-unit id="b9bf45d36ec359981f7c6104d1efde02af646768" translate="yes" xml:space="preserve">
          <source>...and for all guys who think that there's a better way of doing this, without extending native prototypes:</source>
          <target state="translated">...и для всех парней,которые думают,что есть лучший способ сделать это,не расширяя родные прототипы:</target>
        </trans-unit>
        <trans-unit id="367d2eac8d3ed38b462e4255bae2e055a734f474" translate="yes" xml:space="preserve">
          <source>...and then, there is so much more to this question when you consider internationalisation, as &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;this astonishingly good answer&lt;/a&gt; (buried below) shows.</source>
          <target state="translated">... и затем, когда вы рассматриваете интернационализацию, в &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;этом&lt;/a&gt; вопросе есть еще много всего, как показывает этот удивительно хороший ответ (скрытый ниже).</target>
        </trans-unit>
        <trans-unit id="01458e5b9ce1421cc63ab3a554d729db7d445bfd" translate="yes" xml:space="preserve">
          <source>4,577,946 ops/s &amp;plusmn;1.2% for the most voted answer.</source>
          <target state="translated">4577946 операций / с &amp;plusmn; 1,2% для наиболее проголосовавшего ответа.</target>
        </trans-unit>
        <trans-unit id="a2ffd6820da15f37abf4c947e438311a5752e475" translate="yes" xml:space="preserve">
          <source>4,956,962 ops/s &amp;plusmn;3.03% for this solution,</source>
          <target state="translated">4,956,962 ops / s &amp;plusmn; 3,03% для этого решения,</target>
        </trans-unit>
        <trans-unit id="21536903e387743ca164f63d9cc09e9b8b6bb9e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;/index.html&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;/index.html&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;/index.html&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;/index.html&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d494e91c3e544750401f32794514d26617133c2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;the Eiffel Tower&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;The Eiffel Tower&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;the Eiffel Tower&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;The Eiffel Tower&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="163679a6bb6d7fb0504648cd5281b896b69b7f3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;this is a test&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;This is a test&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;this is a test&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;This is a test&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="228001a68abeb7721c7e6836bdfa016232028ea1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; gives us the ability to declare &lt;code&gt;capitalizeFirstChar&lt;/code&gt; as constant, which is desired since as a programmer you should always explicitly state your intentions.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; дает нам возможность объявить &lt;code&gt;capitalizeFirstChar&lt;/code&gt; константой, что желательно, поскольку как программист вы всегда должны явно указывать свои намерения.</target>
        </trans-unit>
        <trans-unit id="fe5ad94b64fc4f2a2e524d4f6153761e202b6090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parameters =&amp;gt; function&lt;/code&gt; is so called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;parameters =&amp;gt; function&lt;/code&gt; - это так называемая &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;функция стрелки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a8043e9b8b738f65ac06fcc7f0df98edb180022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string.substring(1)&lt;/code&gt; is faster than &lt;code&gt;string.slice(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string.substring(1)&lt;/code&gt; работает быстрее, чем &lt;code&gt;string.slice(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d710ede0941e4a1632178bcd80a8c8aab513de6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;* The code units of UTF-16 / UCS2 are also Unicode code points in the sense that e.g. U+D800 is technically a code point, but that&amp;rsquo;s not what it &amp;ldquo;means&amp;rdquo; here ... sort of ... though it gets pretty fuzzy. What the surrogates definitely are not, though, is USVs (Unicode scalar values).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;* Кодовые единицы UTF-16 / UCS2 также являются кодовыми точками Unicode в том смысле, что, например, U + D800 технически является кодовой точкой, но это не то, что здесь &amp;laquo;означает&amp;raquo; ... вроде ... хотя и получается довольно нечеткая.&lt;/em&gt; &lt;em&gt;Что суррогаты определенно не являются, тем не менее, являются USV (скалярные значения Unicode).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80e943d6704e4d184a5db2220f9f6efdc9fbefec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;** Though if a surrogate code unit is &amp;ldquo;orphaned&amp;rdquo; &amp;mdash; i.e., not part of a logical pair &amp;mdash; you could still get surrogates here, too.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;** Хотя, если единица суррогатного кода &amp;laquo;осиротела&amp;raquo;, т. Е. Не является частью логической пары, вы все равно можете получить здесь и суррогаты.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cdf2e5c67a4f0fdde3be9c75c84dbfc0ff1c9081" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;*** maybe. I haven&amp;rsquo;t tested it. Unless you have determined capitalization is a meaningful bottleneck, I probably wouldn&amp;rsquo;t sweat it &amp;mdash; choose whatever you believe is most clear and readable.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;*** может быть.&lt;/em&gt; &lt;em&gt;Я не проверял это.&lt;/em&gt; &lt;em&gt;Если вы не определили, что использование заглавных букв является значительным узким местом, я бы, наверное, не потел его - выбирайте то, что вы считаете наиболее понятным и читабельным.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1853748fb3df42199189a7bc4ca52932cac9483c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;**** such a function might wish to test both the first and second code units instead of just the first, since it&amp;rsquo;s possible that the first unit is an orphaned surrogate. For example the input &quot;\uD800x&quot; would capitalize the X as-is, which may or may not be expected.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;**** такая функция может захотеть проверить как первую, так и вторую кодовые единицы, а не только первую, поскольку вполне возможно, что первая единица является суррогатом-сиротой.&lt;/em&gt; &lt;em&gt;Например, ввод &quot;\ uD800x&quot; будет использовать заглавную букву X как есть, что может ожидаться или не ожидаться.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e323f33e94cbca47eb23464c89f17f842364d336" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;***** Here&amp;rsquo;s the &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1361876&quot;&gt;Bugzilla issue&lt;/a&gt; if you want to follow the progress more directly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;***** Вот &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1361876&quot;&gt;проблема Bugzilla,&lt;/a&gt; если вы хотите следить за прогрессом более непосредственно.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34b7e56ddb1cb38bfcf26066f4b7ae7fb74172d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Initially I didn&amp;rsquo;t see any answers addressing issues related to astral plane code points. There &lt;a href=&quot;https://stackoverflow.com/a/45224904/1631952&quot;&gt;is one&lt;/a&gt;, but it&amp;rsquo;s a bit buried (like this one will be, I guess!)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Первоначально я не видел ответов на вопросы, связанные с кодовыми точками астрального плана.&lt;/em&gt; &lt;em&gt;Есть &lt;a href=&quot;https://stackoverflow.com/a/45224904/1631952&quot;&gt;один&lt;/a&gt; , но он немного похоронен (как этот, я думаю!)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67d4c331b2081030c9036c63f7dcc26c1bc21da1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You could use bitwise math instead of &lt;code&gt;&amp;gt; 0xFFFF&lt;/code&gt; there, but it&amp;rsquo;s probably easier to understand this way and either would achieve the same thing.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Вы можете использовать здесь &lt;code&gt;&amp;gt; 0xFFFF&lt;/code&gt; математику вместо &amp;gt; 0xFFFF , но, вероятно, это легче понять, и любой из них достигнет того же.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e11e3af42de6298ef3229ff0943985a06191a5a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SHORTEST&lt;/strong&gt; 3 solutions, 1 and 2 handle cases when &lt;code&gt;s&lt;/code&gt; string  is &lt;code&gt;&quot;&quot;&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;Кратчайшие&lt;/strong&gt; 3 решения, 1 и 2 обрабатывают случаи, когда строка &lt;code&gt;s&lt;/code&gt; имеет значение &lt;code&gt;&quot;&quot;&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0241744970e1f05578cdbbce0e8b6ad42587ba7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the 2018 ECMAScript&amp;nbsp;6+ Solution&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Это решение ECMAScript 6+ 2018 года&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f715e43a9cd501ad9b3351990a77f7d25046bb86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обновление 2:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b38760c3360e1a927a9cacd29a860eddc0edeb9" translate="yes" xml:space="preserve">
          <source>According to the comments below this doesn't work in IE 7 or below.</source>
          <target state="translated">Согласно приведенным ниже комментариям,это не работает в IE 7 и ниже.</target>
        </trans-unit>
        <trans-unit id="ca975c6c918692672e6209be6187776c7dfee237" translate="yes" xml:space="preserve">
          <source>Also the alternative option is JavaScript, so the best gonna be something like this:</source>
          <target state="translated">Также альтернативным вариантом является JavaScript,так что лучше всего будет что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="d379b63cddadbeb97273b4dc578ce9d650af84b8" translate="yes" xml:space="preserve">
          <source>And for all coffee-junkies:</source>
          <target state="translated">И для всех кофе-наркоманов:</target>
        </trans-unit>
        <trans-unit id="a65c6aab9ccb89445d5895ed004afd6ead95252c" translate="yes" xml:space="preserve">
          <source>And then:</source>
          <target state="translated">А потом:</target>
        </trans-unit>
        <trans-unit id="4cab7d90a7f1fec6fb511da21e50825814a58e70" translate="yes" xml:space="preserve">
          <source>As you can see, the first two methods are essentially comparable in terms of performance, whereas altering the &lt;code&gt;String.prototype&lt;/code&gt; is by far the slowest in terms of performance.</source>
          <target state="translated">Как вы можете видеть, первые два метода по существу сопоставимы с точки зрения производительности, тогда как изменение &lt;code&gt;String.prototype&lt;/code&gt; является самым медленным с точки зрения производительности.</target>
        </trans-unit>
        <trans-unit id="b738c32be44272442962e986db9a0980aba6f5fb" translate="yes" xml:space="preserve">
          <source>At the start I also mentioned internationalization considerations. Some of these are very difficult to account for because they require knowledge not only of &lt;em&gt;what&lt;/em&gt; language is being used, but also may require specific knowledge of the words in the language. For example, the Irish digraph &quot;mb&quot; capitalizes as &quot;mB&quot; at the start of a word. Another example, the German eszett, never begins a word (afaik), but still helps illustrate the problem. The lowercase eszett (&amp;ldquo;&amp;szlig;&amp;rdquo;) capitalizes to &amp;ldquo;SS,&amp;rdquo; but  &amp;ldquo;SS&amp;rdquo; could lowercase to either &amp;ldquo;&amp;szlig;&amp;rdquo; or &amp;ldquo;ss&amp;rdquo; &amp;mdash; you require out-of-band knowledge of the German language to know which is correct!</source>
          <target state="translated">В начале я также упомянул соображения интернационализации. Некоторые из них очень трудно объяснить, потому что они требуют знания не только того, &lt;em&gt;какой&lt;/em&gt; язык используется, но также могут потребовать определенных знаний слов в языке. Например, ирландский орграф &amp;laquo;mb&amp;raquo; пишется с заглавной буквы как &amp;laquo;mB&amp;raquo; в начале слова. Другой пример, немецкий eszett, никогда не начинает слово (afaik), но все же помогает проиллюстрировать проблему. Строчные буквы eszett (&amp;laquo;&amp;szlig;&amp;raquo;) пишутся с заглавной буквы &amp;laquo;SS&amp;raquo;, но &amp;laquo;SS&amp;raquo; может быть строчными или &amp;laquo;&amp;szlig;&amp;raquo;, или &amp;laquo;ss&amp;raquo; - вам необходимо внеполосное знание немецкого языка, чтобы знать, что правильно!</target>
        </trans-unit>
        <trans-unit id="cdcb4da1ad0efcd4394c1ed55e3b70f42e24c0b4" translate="yes" xml:space="preserve">
          <source>At the time of writing (Feb 2020), Firefox/Spidermonkey has not yet implemented any of the RegExp features introduced in the last two years*****. You can check the current status of this feature at the &lt;a href=&quot;http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Unicode_Property_Escapes&quot;&gt;Kangax compat table&lt;/a&gt;. Babel is able to compile RegExp literals with property references to equivalent patterns without them, but be aware that the resulting code may be enormous.</source>
          <target state="translated">На момент написания статьи (февраль 2020 г.) Firefox / Spidermonkey еще не реализовал ни одной из функций RegExp, представленных за последние два года *****. Вы можете проверить текущее состояние этой функции в &lt;a href=&quot;http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Unicode_Property_Escapes&quot;&gt;таблице сравнения Kangax&lt;/a&gt; . Babel может компилировать литералы RegExp со ссылками на свойства для эквивалентных шаблонов без них, но имейте в виду, что полученный код может быть огромным.</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="c28281d29953dd5bbfe8e32fb31c9ecf6084a1d8" translate="yes" xml:space="preserve">
          <source>CSS only</source>
          <target state="translated">только CSS</target>
        </trans-unit>
        <trans-unit id="2f3f9c86a9d991e58459d1d1c5a24e5332a22188" translate="yes" xml:space="preserve">
          <source>Capitalize the first letter of all words in a string:</source>
          <target state="translated">Запишите первую букву всех слов в строке:</target>
        </trans-unit>
        <trans-unit id="a69da05af469308b462024895eb097e9dd01295b" translate="yes" xml:space="preserve">
          <source>Checkout this solution:</source>
          <target state="translated">Проверьте это решение:</target>
        </trans-unit>
        <trans-unit id="0ab8dd120611ec6f99b50238ac21e32cacf65d79" translate="yes" xml:space="preserve">
          <source>Created with &lt;a href=&quot;https://jsbench.me/&quot;&gt;JSBench.me&lt;/a&gt; on Google Chrome 57.</source>
          <target state="translated">Создано с помощью &lt;a href=&quot;https://jsbench.me/&quot;&gt;JSBench.me&lt;/a&gt; в Google Chrome 57.</target>
        </trans-unit>
        <trans-unit id="38eff30dd7da438c13e56e85015681e989636246" translate="yes" xml:space="preserve">
          <source>Despite being called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter&quot;&gt;&lt;code&gt;::first-letter&lt;/code&gt;&lt;/a&gt;, it applies to the first &lt;strong&gt;character&lt;/strong&gt;, i.e. in case of string &lt;code&gt;%a&lt;/code&gt;, this selector would apply to &lt;code&gt;%&lt;/code&gt; and as such &lt;code&gt;a&lt;/code&gt; would not be capitalized.</source>
          <target state="translated">Несмотря на то, что он называется &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter&quot;&gt; &lt;code&gt;::first-letter&lt;/code&gt; &lt;/a&gt; , он применяется к первому &lt;strong&gt;символу&lt;/strong&gt; , т. Е. В случае строки &lt;code&gt;%a&lt;/code&gt; этот селектор будет применяться к &lt;code&gt;%&lt;/code&gt; и, как таковой, не будет заглавной.</target>
        </trans-unit>
        <trans-unit id="b53015fce6abe5786b7601af4988a62b9ce4c6c7" translate="yes" xml:space="preserve">
          <source>ES2015 one-liner</source>
          <target state="translated">однолинейный ES2015</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="5efc2d2017db789ed39b3f6945df2de895bab671" translate="yes" xml:space="preserve">
          <source>For another case I need it to capitalize the first letter and lowercase the rest. The following cases made me change this function:</source>
          <target state="translated">Для другого случая мне нужно,чтобы первая буква была заглавной,а остальные-строчной.Следующие случаи заставили меня изменить эту функцию:</target>
        </trans-unit>
        <trans-unit id="fed1125217a67648d6e1fabd36895a4669511da3" translate="yes" xml:space="preserve">
          <source>For even more internationalization options, please see the &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;original answer below&lt;/a&gt;.</source>
          <target state="translated">Для еще большего количества вариантов интернационализации, пожалуйста, смотрите &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;оригинальный ответ ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="fd7ea24cff598ca7d051a4d8d628b73aae9173a8" translate="yes" xml:space="preserve">
          <source>For longer strings, this is probably not terribly efficient*** &amp;mdash; we don&amp;rsquo;t really need to iterate the remainder. We could use &lt;code&gt;String.prototype.codePointAt&lt;/code&gt; to get at that first (possible) letter, but we&amp;rsquo;d still need to determine where the slice should begin. One way to avoid iterating the remainder would be to test whether the first codepoint is outside the BMP; if it isn&amp;rsquo;t, the slice begins at 1, and if it is, the slice begins at 2.</source>
          <target state="translated">Для более длинных строк это, вероятно, не очень эффективно *** - нам не нужно итерировать остаток. Мы могли бы использовать &lt;code&gt;String.prototype.codePointAt&lt;/code&gt; , чтобы получить эту первую (возможную) букву, но нам все равно нужно было бы определить, где должен начинаться фрагмент. Один из способов избежать итерации остатка - проверить, находится ли первая кодовая точка вне BMP; если это не так, срез начинается с 1, а если это так, срез начинается с 2.</target>
        </trans-unit>
        <trans-unit id="b63decbd83c1b992eb529da43269358b03bcf440" translate="yes" xml:space="preserve">
          <source>From ES2015 on, dealing with this became a bit easier. &lt;code&gt;String.prototype[@@iterator]&lt;/code&gt; yields strings corresponding to code points**. So for example, we can do this:</source>
          <target state="translated">С ES2015 справиться с этим стало немного легче. &lt;code&gt;String.prototype[@@iterator]&lt;/code&gt; строки, соответствующие кодовым точкам **. Так, например, мы можем сделать это:</target>
        </trans-unit>
        <trans-unit id="74c10e52cd68360f7bdbca8c52fc4938b2eb4e9a" translate="yes" xml:space="preserve">
          <source>Here are the fastest methods based on &lt;a href=&quot;http://jsperf.com/capitalize-the-first-letter-of-string-in-javascript/2&quot;&gt;this jsperf test&lt;/a&gt; (ordered from fastest to slowest).</source>
          <target state="translated">Вот самые быстрые методы, основанные на &lt;a href=&quot;http://jsperf.com/capitalize-the-first-letter-of-string-in-javascript/2&quot;&gt;этом тесте jsperf&lt;/a&gt; (упорядоченные от самого быстрого до самого медленного).</target>
        </trans-unit>
        <trans-unit id="36ec1b221f06d0c0a874dc6ea003751af9a2707b" translate="yes" xml:space="preserve">
          <source>Here is a function called &lt;strong&gt;ucfirst()&lt;/strong&gt; (short for &quot;upper case first letter&quot;):</source>
          <target state="translated">Вот функция с именем &lt;strong&gt;ucfirst ()&lt;/strong&gt; (сокращение от &amp;laquo;первая буква верхнего регистра&amp;raquo;):</target>
        </trans-unit>
        <trans-unit id="f63bba80779b9f905ca9275279f4d3217ddae10f" translate="yes" xml:space="preserve">
          <source>Here is a shortened version of the popular answer that gets the first letter by treating the string as an array:</source>
          <target state="translated">Вот сокращенный вариант популярного ответа,который получает первую букву,рассматривая строку как массив:</target>
        </trans-unit>
        <trans-unit id="8de7492950ddcf0f0806df769b72006c014004f5" translate="yes" xml:space="preserve">
          <source>Here's a more object-oriented approach:</source>
          <target state="translated">Вот более объектно-ориентированный подход:</target>
        </trans-unit>
        <trans-unit id="26ec945f349fe1c8f7b8bfe93fdfedd83c5c2657" translate="yes" xml:space="preserve">
          <source>How do I make the first letter of a string uppercase in JavaScript</source>
          <target state="translated">Как сделать первую букву строки заглавной в JavaScript</target>
        </trans-unit>
        <trans-unit id="41600359895123b43257f89a1713e3beaa5909e0" translate="yes" xml:space="preserve">
          <source>How do I make the first letter of a string uppercase, but not change the case of any of the other letters?</source>
          <target state="translated">Как сделать первую букву строки заглавной,но не менять регистр остальных букв?</target>
        </trans-unit>
        <trans-unit id="2471381604a49f6d0e0c580d6ed33d04e7bbf029" translate="yes" xml:space="preserve">
          <source>However, some cased characters fall outside the BMP (basic multilingual plane, code points U+0 to U+FFFF). For example take this Deseret text:</source>
          <target state="translated">Однако некоторые оболочки символов выходят за пределы BMP (базовая многоязычная плоскость,код указывает на U+0 до U+FFFF).Например,возьмем этот текст Deseret:</target>
        </trans-unit>
        <trans-unit id="ab4561105ba74782ce146baef49296c05955c8d5" translate="yes" xml:space="preserve">
          <source>I didn&amp;rsquo;t see any mention in the existing answers of issues related to &lt;s&gt;astral plane code points or&lt;/s&gt; internationalization. &amp;ldquo;Uppercase&amp;rdquo; doesn&amp;rsquo;t mean the same thing in every language using a given script.</source>
          <target state="translated">Я не видел упоминаний в существующих ответах на вопросы, связанные с &lt;s&gt;кодовыми точками астрального плана или&lt;/s&gt; интернационализацией. &amp;laquo;Прописные буквы&amp;raquo; не означают одно и то же в каждом языке, использующем данный скрипт.</target>
        </trans-unit>
        <trans-unit id="57568b656d3bfd8b25836b6e404e950afe5e8ed8" translate="yes" xml:space="preserve">
          <source>I found this arrow function easiest. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;Replace&lt;/a&gt; matches the first letter character (&lt;code&gt;\w&lt;/code&gt;) of your string and converts it to uppercase. Nothing fancier necessary.</source>
          <target state="translated">Я нашел эту функцию стрелки проще всего. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;Replace&lt;/a&gt; соответствует первому буквенному символу ( &lt;code&gt;\w&lt;/code&gt; ) вашей строки и преобразует его в верхний регистр. Ничего более сложного не нужно.</target>
        </trans-unit>
        <trans-unit id="fc8ad3518c2d8b9e7e804ae69020ba2d72f9b38e" translate="yes" xml:space="preserve">
          <source>I went with name &lt;code&gt;capitalizeFirstChar&lt;/code&gt; instead of &lt;code&gt;capitalizeFirstLetter&lt;/code&gt;, because OP didn't asked for code that capitalizes the first letter in the entire string, but the very first char (if it's letter, of course).</source>
          <target state="translated">Я пошел с именем &lt;code&gt;capitalizeFirstChar&lt;/code&gt; вместо &lt;code&gt;capitalizeFirstLetter&lt;/code&gt; , потому что OP запрашивал не код, который использует первую букву во всей строке, а самый первый символ (если, конечно, это буква).</target>
        </trans-unit>
        <trans-unit id="12beaec08e35b5059fe37bcbcaff9243ba2cb242" translate="yes" xml:space="preserve">
          <source>If you  want to reuse it over and over, it's better attach it to javascript native String, so something like below:</source>
          <target state="translated">Если вы хотите использовать его снова и снова,лучше прикрепить его к родной строке javascript,так что что что-то вроде того,что описано ниже:</target>
        </trans-unit>
        <trans-unit id="5595b4caaf07e85122b5dcf531caac0aed37a182" translate="yes" xml:space="preserve">
          <source>If you are wanting to reformat all-caps text, you might want to modify the other examples as such:</source>
          <target state="translated">Если вы хотите переформатировать текст всех крышек,вы можете изменить другие примеры как таковые:</target>
        </trans-unit>
        <trans-unit id="391b6c39ae6bd183048d53c4501002d9557638f3" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; or &lt;a href=&quot;http://lodash.com/&quot;&gt;Lo-Dash&lt;/a&gt;, the &lt;a href=&quot;https://github.com/epeli/underscore.string&quot;&gt;underscore.string&lt;/a&gt; library provides string extensions, including capitalize:</source>
          <target state="translated">Если вы используете &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; или &lt;a href=&quot;http://lodash.com/&quot;&gt;Lo-Dash&lt;/a&gt; , библиотека &lt;a href=&quot;https://github.com/epeli/underscore.string&quot;&gt;underscore.string&lt;/a&gt; предоставляет расширения строк, включая прописные:</target>
        </trans-unit>
        <trans-unit id="3580d94edc18905a809fe61049b66ac884fd95f0" translate="yes" xml:space="preserve">
          <source>If you want to work with Unicode code points instead of code units (for example to handle Unicode characters outside of the Basic Multilingual Plane) you can leverage the fact that &lt;code&gt;String#[@iterator]&lt;/code&gt; works with code points, and you can use &lt;code&gt;toLocaleUpperCase&lt;/code&gt; to get locale-correct uppercasing:</source>
          <target state="translated">Если вы хотите работать с кодовыми точками Unicode вместо кодовых единиц (например, для обработки символов Unicode за пределами базовой многоязычной плоскости), вы можете использовать тот факт, что &lt;code&gt;String#[@iterator]&lt;/code&gt; работает с кодовыми точками, и вы можете использовать &lt;code&gt;toLocaleUpperCase&lt;/code&gt; для получить правильную локаль:</target>
        </trans-unit>
        <trans-unit id="520fb73d2d3cb4c07939630bd614bc3b08d45c7a" translate="yes" xml:space="preserve">
          <source>If you're already (or considering) using &lt;code&gt;lodash&lt;/code&gt;, the solution is easy:</source>
          <target state="translated">Если вы уже (или рассматриваете) использование &lt;code&gt;lodash&lt;/code&gt; , решение легко:</target>
        </trans-unit>
        <trans-unit id="4ec057c220d248000ac866fd08c88dfedb4df649" translate="yes" xml:space="preserve">
          <source>If you're interested in the performance of a few different methods posted:</source>
          <target state="translated">Если вы заинтересованы в выполнении нескольких различных методов размещены:</target>
        </trans-unit>
        <trans-unit id="22ed663eee054bfc4462b75cb3de053fa66754b0" translate="yes" xml:space="preserve">
          <source>In CSS:</source>
          <target state="translated">В CSS:</target>
        </trans-unit>
        <trans-unit id="513ed99d77b99d0268fb8f84f8be5411764fabcb" translate="yes" xml:space="preserve">
          <source>In IE9+ or IE5.5+ it's supported in legacy notation with only one colon (&lt;code&gt;:first-letter&lt;/code&gt;).</source>
          <target state="translated">В IE9 + или IE5.5 + это поддерживается в устаревшей нотации только с одним двоеточием ( &lt;code&gt;:first-letter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2c731feb5a1bab9995bffb541f3ec85ca6616ec0" translate="yes" xml:space="preserve">
          <source>In a browser, the user&amp;rsquo;s most-preferred language tag is indicated by &lt;code&gt;navigator.language&lt;/code&gt;, a list in order of preference is found at &lt;code&gt;navigator.languages&lt;/code&gt;, and a given DOM element&amp;rsquo;s language can be obtained (usually) with &lt;code&gt;Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE&lt;/code&gt; in multilanguage documents.</source>
          <target state="translated">В браузере наиболее предпочтительный языковой тег пользователя указывается с помощью &lt;code&gt;navigator.language&lt;/code&gt; , список в порядке предпочтения находится на &lt;code&gt;navigator.languages&lt;/code&gt; , а язык данного элемента DOM можно получить (обычно) с помощью &lt;code&gt;Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE&lt;/code&gt; YOUR_DEFAULT_HERE в многоязычных документах.</target>
        </trans-unit>
        <trans-unit id="3e7be93047b07099fd9e6aeac9ef8367e4ad1893" translate="yes" xml:space="preserve">
          <source>In agents which support Unicode property character classes in RegExp, which were introduced in ES2018, we can clean stuff up further by directly expressing what characters we&amp;rsquo;re interested in:</source>
          <target state="translated">В агентах, которые поддерживают классы символов свойств Unicode в RegExp, которые были представлены в ES2018, мы можем очистить вещи, непосредственно выражая, какие символы нас интересуют:</target>
        </trans-unit>
        <trans-unit id="237f8c8207eb9f09670dd34797c5476976d0f091" translate="yes" xml:space="preserve">
          <source>In all likelihood, people asking this question will not be concerned with Deseret capitalization or internationalization. But it&amp;rsquo;s good to be aware of these issues because there&amp;rsquo;s a good chance you&amp;rsquo;ll encounter them eventually even if they aren&amp;rsquo;t concerns presently. They&amp;rsquo;re not &amp;ldquo;edge&amp;rdquo; cases, or rather, they&amp;rsquo;re not &lt;em&gt;by-definition&lt;/em&gt; edge cases &amp;mdash; there&amp;rsquo;s a whole country where most people speak Turkish, anyway, and conflating code units with codepoints is a fairly common source of bugs (especially with regard to emoji). Both strings and language are pretty complicated!</source>
          <target state="translated">По всей вероятности, люди, задающие этот вопрос, не будут беспокоиться о капитализации или интернационализации Deseret. Но хорошо знать об этих проблемах, потому что есть большая вероятность, что вы в конечном итоге столкнетесь с ними, даже если в настоящее время они не являются проблемой. Это не &amp;laquo;крайние&amp;raquo; случаи, или, скорее, они не &lt;em&gt;являются&lt;/em&gt; крайними случаями &lt;em&gt;по определению&lt;/em&gt; - во всяком случае, есть целая страна, где большинство людей говорят по-турецки, и объединение блоков кода с кодовыми точками является довольно распространенным источником ошибок (особенно в что касается эмодзи). И строки, и язык довольно сложны!</target>
        </trans-unit>
        <trans-unit id="b9215739ff07c5a531e3c157e3d8b7debaf7f595" translate="yes" xml:space="preserve">
          <source>In the benchmark I performed there was no significant difference between &lt;code&gt;string.charAt(0)&lt;/code&gt; and &lt;code&gt;string[0]&lt;/code&gt;. Note however, that &lt;code&gt;string[0]&lt;/code&gt; would be &lt;code&gt;undefined&lt;/code&gt; for empty string, so it should be rewritten to &lt;code&gt;string &amp;amp;&amp;amp; string[0]&lt;/code&gt;, which is way too verbose, compared to the alternative.</source>
          <target state="translated">В тесте, который я выполнил, не было значительной разницы между &lt;code&gt;string.charAt(0)&lt;/code&gt; и &lt;code&gt;string[0]&lt;/code&gt; . Однако обратите внимание, что &lt;code&gt;string[0]&lt;/code&gt; будет &lt;code&gt;undefined&lt;/code&gt; для пустой строки, поэтому ее следует переписать в &lt;code&gt;string &amp;amp;&amp;amp; string[0]&lt;/code&gt; , которая слишком многословна по сравнению с альтернативой.</target>
        </trans-unit>
        <trans-unit id="aa4f881902e40d1677a1a09723b87da7f2131a80" translate="yes" xml:space="preserve">
          <source>It happens to be that UTF-16 code units are 1:1 with USV code points within two ranges, U+0 to U+D7FF and U+E000 to U+FFFF inclusive. Most cased characters fall into those two ranges, but not all of them.</source>
          <target state="translated">Так получилось,что единицы кода UTF-16 составляют 1:1 с точками USV кода в двух диапазонах,от U+0 до U+D7FF и от U+E000 до U+FFFF включительно.Большинство оболочек символов попадают в эти два диапазона,но не все.</target>
        </trans-unit>
        <trans-unit id="cfcdd40d2baaffb7a5e373b22106b786580f61af" translate="yes" xml:space="preserve">
          <source>It seems to be easier in CSS:</source>
          <target state="translated">Похоже,в CSS легче:</target>
        </trans-unit>
        <trans-unit id="be0d696fbec75b29d058a2ffde594a36cc305bd4" translate="yes" xml:space="preserve">
          <source>It will output &lt;code&gt;&quot;Ruby java&quot;&lt;/code&gt; to the console.</source>
          <target state="translated">Он выведет &lt;code&gt;&quot;Ruby java&quot;&lt;/code&gt; на консоль.</target>
        </trans-unit>
        <trans-unit id="753fc3e18b8a5011f782214d0491ba42959f8ddc" translate="yes" xml:space="preserve">
          <source>It works by splitting the string into two pieces.  On the first line it pulls out &lt;strong&gt;firstLetter&lt;/strong&gt; and then on the second line it capitalises &lt;strong&gt;firstLetter&lt;/strong&gt; by calling &lt;strong&gt;firstLetter.toUpperCase()&lt;/strong&gt; and joins it with the rest of the string, which is found by calling &lt;strong&gt;str.substr(1)&lt;/strong&gt;.</source>
          <target state="translated">Это работает, разделив строку на две части. В первой строке он извлекает &lt;strong&gt;firstLetter,&lt;/strong&gt; а затем во второй строке он использует &lt;strong&gt;прописную букву firstLetter&lt;/strong&gt; , вызывая &lt;strong&gt;firstLetter.toUpperCase (),&lt;/strong&gt; и соединяет его с остальной частью строки, которая определяется путем вызова &lt;strong&gt;str.substr (1)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="39cf6e340b712fcaeefaccd6c9cae7c6fb438b3b" translate="yes" xml:space="preserve">
          <source>It's always better to handle these kinds of stuff using &lt;strong&gt;CSS first&lt;/strong&gt;, in general, if you can solve something using CSS, go for that first, then try JavaScript to solve your problems, so in this case try using &lt;code&gt;:first-letter&lt;/code&gt; in CSS and apply &lt;code&gt;text-transform:capitalize;&lt;/code&gt;</source>
          <target state="translated">Всегда лучше &lt;strong&gt;сначала&lt;/strong&gt; обрабатывать такие вещи, используя &lt;strong&gt;CSS&lt;/strong&gt; , в общем, если вы можете решить что-то с помощью CSS, сначала сделайте это, затем попробуйте JavaScript, чтобы решить ваши проблемы, поэтому в этом случае попробуйте использовать &lt;code&gt;:first-letter&lt;/code&gt; in CSS и применить &lt;code&gt;text-transform:capitalize;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68cebc3a030d29b43fc7340eaf94a510388b167b" translate="yes" xml:space="preserve">
          <source>Most of the proposed functions look like this:</source>
          <target state="translated">Большинство предлагаемых функций выглядят так:</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="bd0ec7f92d0013f9249f7d0c47b7dbfe0e9eaf1d" translate="yes" xml:space="preserve">
          <source>See their docs: &lt;a href=&quot;https://lodash.com/docs#capitalize&quot;&gt;https://lodash.com/docs#capitalize&lt;/a&gt;</source>
          <target state="translated">Смотрите их документы: &lt;a href=&quot;https://lodash.com/docs#capitalize&quot;&gt;https://lodash.com/docs#capitalize&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Показать фрагмент кода</target>
        </trans-unit>
        <trans-unit id="7125002cd82871109849d7c7802837b04e3aa758" translate="yes" xml:space="preserve">
          <source>Since there are numerous answers, but none in ES2015 that would solve original problem efficiently, I came up with the following:</source>
          <target state="translated">Поскольку ответов много,но ни один в ES2015 не решил бы оригинальную проблему эффективно,я придумал следующее:</target>
        </trans-unit>
        <trans-unit id="a05e8ccd4f0db9fa8ab4b2d4f1e59cc14da07156" translate="yes" xml:space="preserve">
          <source>So try creating a class for that, so you can use it globally, for example: &lt;code&gt;.first-letter-uppercase&lt;/code&gt; and add something like below in your CSS:</source>
          <target state="translated">Поэтому попробуйте создать для этого класс, чтобы вы могли использовать его глобально, например: &lt;code&gt;.first-letter-uppercase&lt;/code&gt; и добавить что-то вроде ниже в свой CSS:</target>
        </trans-unit>
        <trans-unit id="1dc1f21e14a758a9bf27e090a7e7aff5d2f7c19a" translate="yes" xml:space="preserve">
          <source>Some other answers modify &lt;code&gt;String.prototype&lt;/code&gt; (this answer used to as well), but I would advise against this now due to maintainability (hard to find out where the function is being added to the &lt;code&gt;prototype&lt;/code&gt; and could cause conflicts if other code uses the same name / a browser adds a native function with that same name in future).</source>
          <target state="translated">Некоторые другие ответы изменяют &lt;code&gt;String.prototype&lt;/code&gt; (этот ответ также использовался), но я бы посоветовал не делать этого сейчас из-за удобства сопровождения (сложно определить, где функция добавляется к &lt;code&gt;prototype&lt;/code&gt; и может вызвать конфликты, если другой код использует тот же имя / браузер добавляет нативную функцию с тем же именем в будущем).</target>
        </trans-unit>
        <trans-unit id="f328eb536a4786b3e3cffb9fe5ba8a131e439b94" translate="yes" xml:space="preserve">
          <source>Thanks J-P for the aclaration.</source>
          <target state="translated">Спасибо,Джей-Пи,что устроил разминку.</target>
        </trans-unit>
        <trans-unit id="e7e02386fc0fdd5750e124eedc2fe82fb16c6cbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ucfirst&lt;/code&gt; function works if you do it like this.</source>
          <target state="translated">Функция &lt;code&gt;ucfirst&lt;/code&gt; работает, если вы делаете это так.</target>
        </trans-unit>
        <trans-unit id="f8d4f74a2fbde727e6e72b8c96f5adb95eabac25" translate="yes" xml:space="preserve">
          <source>The basic solution is:</source>
          <target state="translated">Основное решение:</target>
        </trans-unit>
        <trans-unit id="ca5df1b84c287b849617bdac4e324fb5a89cfdb4" translate="yes" xml:space="preserve">
          <source>The first character here fails to capitalize because the array-indexed properties of strings don&amp;rsquo;t access &amp;ldquo;characters&amp;rdquo; or code points*. They access UTF-16 code units. This is true also when slicing &amp;mdash; the index values point at code units.</source>
          <target state="translated">Первый символ здесь не может быть написан заглавными буквами, потому что индексированные по массиву свойства строк не имеют доступа к &amp;laquo;символам&amp;raquo; или кодовым точкам *. Они получают доступ к кодовым единицам UTF-16. Это верно и при разрезании - значения индекса указывают на единицы кода.</target>
        </trans-unit>
        <trans-unit id="3e7ba471ab8219d28d83cb805cb394c50a047c08" translate="yes" xml:space="preserve">
          <source>The most famous example of these kinds of issues, probably, is Turkish. In Turkish Latin, the capital form of i is İ, while the lowercase form of I is ı &amp;mdash; they&amp;rsquo;re two different letters. Fortunately we do have a way to account for this:</source>
          <target state="translated">Наиболее известный пример такого рода проблем, вероятно, турецкий. В турецкой латыни заглавная форма i - это İ, а строчная форма I - ı - это две разные буквы. К счастью, у нас есть способ объяснить это:</target>
        </trans-unit>
        <trans-unit id="4c47e3933006e2a994f15b0b8d727bc485f4d3ad" translate="yes" xml:space="preserve">
          <source>There is a very simple way to implement it by &lt;strong&gt;replace&lt;/strong&gt;. For ECMAScript&amp;nbsp;6:</source>
          <target state="translated">Существует очень простой способ реализовать его путем &lt;strong&gt;замены&lt;/strong&gt; . Для ECMAScript 6:</target>
        </trans-unit>
        <trans-unit id="04f622e4b19164c4d7616ea7f0401578b5a965de" translate="yes" xml:space="preserve">
          <source>This could be tweaked a bit to also handle capitalizing multiple words in a string with fairly good accuracy. The &lt;code&gt;CWU&lt;/code&gt; or &lt;a href=&quot;https://unicode.org/reports/tr44/#CWU&quot;&gt;Changes_When_Uppercased&lt;/a&gt; character property matches all code points which, well, change when uppercased. We can try this out with a titlecased digraph characters like the Dutch &lt;a href=&quot;https://en.wikipedia.org/wiki/IJ_(digraph)&quot;&gt;ĳ&lt;/a&gt; for example:</source>
          <target state="translated">Это можно немного подправить, чтобы обрабатывать несколько слов в строке с большой точностью. &lt;a href=&quot;https://unicode.org/reports/tr44/#CWU&quot;&gt;Символьное&lt;/a&gt; свойство &lt;code&gt;CWU&lt;/code&gt; или Changes_When_Uppercased соответствует всем кодовым точкам, которые, в общем случае, изменяются в верхнем регистре. Мы можем попробовать это с помощью заглавных букв, таких как голландский &lt;a href=&quot;https://en.wikipedia.org/wiki/IJ_(digraph)&quot;&gt;ĳ,&lt;/a&gt; например:</target>
        </trans-unit>
        <trans-unit id="aaf0e7360a18b0ecd99a513342639b5cd16aa14e" translate="yes" xml:space="preserve">
          <source>This is a text string =&amp;gt; This Is A Text String</source>
          <target state="translated">Это текстовая строка =&amp;gt; Это текстовая строка</target>
        </trans-unit>
        <trans-unit id="445a7900debb9aa27ba0234cd7efda1545c51c28" translate="yes" xml:space="preserve">
          <source>This is from &lt;em&gt;&lt;a href=&quot;http://www.w3schools.com/cssref/pr_text_text-transform.asp&quot;&gt;CSS text-transform Property&lt;/a&gt;&lt;/em&gt; (at &lt;a href=&quot;http://en.wikipedia.org/wiki/W3Schools&quot;&gt;W3Schools&lt;/a&gt;).</source>
          <target state="translated">Это из &lt;em&gt;&lt;a href=&quot;http://www.w3schools.com/cssref/pr_text_text-transform.asp&quot;&gt;CSS text-transform Property&lt;/a&gt;&lt;/em&gt; (в &lt;a href=&quot;http://en.wikipedia.org/wiki/W3Schools&quot;&gt;W3Schools&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c6f3cfe2c963966513eb01910fe27bfe53212f39" translate="yes" xml:space="preserve">
          <source>This will ensure that the following text is changed:</source>
          <target state="translated">Это обеспечит изменение следующего текста:</target>
        </trans-unit>
        <trans-unit id="0af318f5e656024280a36dcfb0426885a76eff9c" translate="yes" xml:space="preserve">
          <source>To avoid &lt;code&gt;undefined&lt;/code&gt; for empty strings (see &lt;a href=&quot;https://stackoverflow.com/questions/1026069/capitalize-the-first-letter-of-string-in-javascript/7224605?noredirect=1#comment40995528_7224605&quot;&gt;@njzk2's comment below&lt;/a&gt;), you can check for an empty string:</source>
          <target state="translated">Чтобы избежать &lt;code&gt;undefined&lt;/code&gt; для пустых строк (см &lt;a href=&quot;https://stackoverflow.com/questions/1026069/capitalize-the-first-letter-of-string-in-javascript/7224605?noredirect=1#comment40995528_7224605&quot;&gt;. Комментарий @ njzk2 ниже&lt;/a&gt; ), вы можете проверить наличие пустой строки:</target>
        </trans-unit>
        <trans-unit id="7545eb65f39400b816765aedda58dcaf2245938f" translate="yes" xml:space="preserve">
          <source>Update Nov.2016 (ES6), just for FUN :</source>
          <target state="translated">Обновить ноябрь 2016 (ES6),только для FUN :</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="438b77c967ff84de26b6c856e0dbc9c0ccb11946" translate="yes" xml:space="preserve">
          <source>Vanilla js for first upper case:</source>
          <target state="translated">Ваниль Джейс для первого верхнего ящика:</target>
        </trans-unit>
        <trans-unit id="cc356c06beeecbb1483af35dc9f41fbcb69e577a" translate="yes" xml:space="preserve">
          <source>We can also make this work in ES5 and below by taking that logic a bit further if necessary. There are no intrinsic methods in ES5 for working with codepoints, so we have to manually test whether the first code unit is a surrogate****:</source>
          <target state="translated">Мы также можем сделать эту работу в ES5 и ниже,при необходимости немного углубив эту логику.В ES5 нет встроенных методов работы с кодовыми точками,поэтому нам приходится вручную проверять,является ли первый блок кода суррогатным****:</target>
        </trans-unit>
        <trans-unit id="38598e2d769aafd63e8b0ada676593eea8abbce4" translate="yes" xml:space="preserve">
          <source>We could get the first character with one of my favorite &lt;code&gt;RegExp&lt;/code&gt;, looks like a cute smiley: &lt;code&gt;/^./&lt;/code&gt;</source>
          <target state="translated">Мы могли бы получить первого персонажа с одним из моих любимых &lt;code&gt;RegExp&lt;/code&gt; , похожим на милый смайлик: &lt;code&gt;/^./&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80c2861bacbf5087e7a78a28702e92c207722448" translate="yes" xml:space="preserve">
          <source>With the expected output being:</source>
          <target state="translated">С ожидаемым результатом:</target>
        </trans-unit>
        <trans-unit id="0728cce84a033f171749d6217a9b0b732df74446" translate="yes" xml:space="preserve">
          <source>You can capitalise a string by calling &lt;strong&gt;ucfirst(&quot;some string&quot;)&lt;/strong&gt; -- for example,</source>
          <target state="translated">Вы можете использовать строку с &lt;strong&gt;заглавной буквы,&lt;/strong&gt; вызывая &lt;strong&gt;ucfirst (&amp;laquo;некоторая строка&amp;raquo;)&lt;/strong&gt; - например,</target>
        </trans-unit>
        <trans-unit id="4f213a95acdcde6d613a25cf52f2b2753c1f8659" translate="yes" xml:space="preserve">
          <source>You can do it in one line like this</source>
          <target state="translated">Ты можешь сделать это в одной строке</target>
        </trans-unit>
        <trans-unit id="6c4e71a0412953fe2f3f9b1b1c678eb0f7b05035" translate="yes" xml:space="preserve">
          <source>You might think this would fail for an empty string, and indeed in a language like C you would have to cater for this. However in JavaScript, when you take a substring of an empty string, you just get an empty string back.</source>
          <target state="translated">Вы можете подумать,что это не удастся для пустой строки,и действительно,на таком языке,как C,вы должны будете удовлетворить это.Однако в JavaScript,когда вы берете подстроку пустой строки,вы просто получаете пустую строку обратно.</target>
        </trans-unit>
        <trans-unit id="d4a9eb672ba09519a041a6378259fc7533179e68" translate="yes" xml:space="preserve">
          <source>You'd call the function, like this:</source>
          <target state="translated">Вы бы вызвали функцию,вот так:</target>
        </trans-unit>
        <trans-unit id="b3de993735805658454ec6a662d98b23e05c1c34" translate="yes" xml:space="preserve">
          <source>_.capitalize(string) Converts first letter of the string to
  uppercase.</source>
          <target state="translated">_.capitalize(string)Преобразует первую букву строки в верхний регистр.</target>
        </trans-unit>
        <trans-unit id="58ed86c48852b86ec22065963de4717546a22f0f" translate="yes" xml:space="preserve">
          <source>and call it as below:</source>
          <target state="translated">и назовите это как ниже:</target>
        </trans-unit>
        <trans-unit id="5841729c0f596832e8c1fdf28e8579200c954984" translate="yes" xml:space="preserve">
          <source>and call it like:</source>
          <target state="translated">и назови это так:</target>
        </trans-unit>
        <trans-unit id="07ca609f2cad16f006215d4b73b16c731cd9ef2e" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;capitalize(&quot;hello&quot;) // Hello&lt;/code&gt;</source>
          <target state="translated">затем с &lt;code&gt;capitalize(&quot;hello&quot;) // Hello&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
