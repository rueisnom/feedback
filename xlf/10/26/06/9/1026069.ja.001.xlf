<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1026069">
    <body>
      <group id="1026069">
        <trans-unit id="9de390a8260c191b43450f70ae86feb669df0906" translate="yes" xml:space="preserve">
          <source>(You may encapsulate it in a function or even add it to the String prototype if you use it frequently.)</source>
          <target state="translated">(頻繁に使用する場合は、関数にカプセル化したり、Stringのプロトタイプに追加したりすることもできます)。</target>
        </trans-unit>
        <trans-unit id="b9bf45d36ec359981f7c6104d1efde02af646768" translate="yes" xml:space="preserve">
          <source>...and for all guys who think that there's a better way of doing this, without extending native prototypes:</source>
          <target state="translated">...そして、ネイティブプロトタイプを拡張しなくても、もっと良い方法があると考えているすべての人のために。</target>
        </trans-unit>
        <trans-unit id="367d2eac8d3ed38b462e4255bae2e055a734f474" translate="yes" xml:space="preserve">
          <source>...and then, there is so much more to this question when you consider internationalisation, as &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;this astonishingly good answer&lt;/a&gt; (buried below) shows.</source>
          <target state="translated">...そして、 &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;この驚くべき良い答え&lt;/a&gt; （以下に埋められます）が示すように、国際化を考えると、この質問にはもっと多くのことが含まれます。</target>
        </trans-unit>
        <trans-unit id="01458e5b9ce1421cc63ab3a554d729db7d445bfd" translate="yes" xml:space="preserve">
          <source>4,577,946 ops/s &amp;plusmn;1.2% for the most voted answer.</source>
          <target state="translated">最も投票された回答に対して4,577,946 ops / s&amp;plusmn;1.2％。</target>
        </trans-unit>
        <trans-unit id="a2ffd6820da15f37abf4c947e438311a5752e475" translate="yes" xml:space="preserve">
          <source>4,956,962 ops/s &amp;plusmn;3.03% for this solution,</source>
          <target state="translated">このソリューションでは4,956,962 ops / s&amp;plusmn;3.03％、</target>
        </trans-unit>
        <trans-unit id="21536903e387743ca164f63d9cc09e9b8b6bb9e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;/index.html&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;/index.html&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;/index.html&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;/index.html&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d494e91c3e544750401f32794514d26617133c2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;the Eiffel Tower&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;The Eiffel Tower&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;the Eiffel Tower&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;The Eiffel Tower&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="163679a6bb6d7fb0504648cd5281b896b69b7f3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;this is a test&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;This is a test&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;this is a test&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;This is a test&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="228001a68abeb7721c7e6836bdfa016232028ea1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; gives us the ability to declare &lt;code&gt;capitalizeFirstChar&lt;/code&gt; as constant, which is desired since as a programmer you should always explicitly state your intentions.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; は、 &lt;code&gt;capitalizeFirstChar&lt;/code&gt; を定数として宣言する機能を提供します。これは、プログラマーとして常に意図を明示的に示す必要があるため、望ましいことです。</target>
        </trans-unit>
        <trans-unit id="fe5ad94b64fc4f2a2e524d4f6153761e202b6090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parameters =&amp;gt; function&lt;/code&gt; is so called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;parameters =&amp;gt; function&lt;/code&gt; は、いわゆる&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;矢印関数&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="8a8043e9b8b738f65ac06fcc7f0df98edb180022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string.substring(1)&lt;/code&gt; is faster than &lt;code&gt;string.slice(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string.substring(1)&lt;/code&gt; はstring.slice（1）より高速です。</target>
        </trans-unit>
        <trans-unit id="5d710ede0941e4a1632178bcd80a8c8aab513de6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;* The code units of UTF-16 / UCS2 are also Unicode code points in the sense that e.g. U+D800 is technically a code point, but that&amp;rsquo;s not what it &amp;ldquo;means&amp;rdquo; here ... sort of ... though it gets pretty fuzzy. What the surrogates definitely are not, though, is USVs (Unicode scalar values).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;* UTF-16 / UCS2のコード単位は、たとえばU + D800が技術的にコードポイントであるという意味でUnicodeコードポイントでもありますが、ここでは「意味する」ことではありません...ファジー。&lt;/em&gt; &lt;em&gt;サロゲートが間違いなくそうではないのは、USV（Unicodeスカラー値）です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80e943d6704e4d184a5db2220f9f6efdc9fbefec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;** Though if a surrogate code unit is &amp;ldquo;orphaned&amp;rdquo; &amp;mdash; i.e., not part of a logical pair &amp;mdash; you could still get surrogates here, too.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;**サロゲートコードユニットが「孤立」している場合、つまり論理ペアの一部ではない場合でも、ここでもサロゲートを取得できます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cdf2e5c67a4f0fdde3be9c75c84dbfc0ff1c9081" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;*** maybe. I haven&amp;rsquo;t tested it. Unless you have determined capitalization is a meaningful bottleneck, I probably wouldn&amp;rsquo;t sweat it &amp;mdash; choose whatever you believe is most clear and readable.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;*** 多分。&lt;/em&gt; &lt;em&gt;私はそれをテストしていません。&lt;/em&gt; &lt;em&gt;大文字の使用が意味のあるボトルネックであると判断しない限り、私はおそらくそれを気にすることはありません。最も明確で読みやすいと思われるものを選択してください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1853748fb3df42199189a7bc4ca52932cac9483c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;**** such a function might wish to test both the first and second code units instead of just the first, since it&amp;rsquo;s possible that the first unit is an orphaned surrogate. For example the input &quot;\uD800x&quot; would capitalize the X as-is, which may or may not be expected.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;****最初のユニットが孤立したサロゲートである可能性があるため、このような関数は、最初のコードユニットだけでなく、最初と2番目のコードユニットの両方をテストする場合があります。&lt;/em&gt; &lt;em&gt;たとえば、入力 &quot;\ uD800x&quot;はXをそのまま大文字にしますが、これは予期されている場合とされていない場合があります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e323f33e94cbca47eb23464c89f17f842364d336" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;***** Here&amp;rsquo;s the &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1361876&quot;&gt;Bugzilla issue&lt;/a&gt; if you want to follow the progress more directly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;*****進行状況をより直接追跡したい場合の&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1361876&quot;&gt;Bugzillaの問題&lt;/a&gt;は次のとおりです。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34b7e56ddb1cb38bfcf26066f4b7ae7fb74172d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Initially I didn&amp;rsquo;t see any answers addressing issues related to astral plane code points. There &lt;a href=&quot;https://stackoverflow.com/a/45224904/1631952&quot;&gt;is one&lt;/a&gt;, but it&amp;rsquo;s a bit buried (like this one will be, I guess!)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;最初は、アストラルプレーンのコードポイントに関連する問題に対処する回答はありませんでした。&lt;/em&gt; &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/45224904/1631952&quot;&gt;1つ&lt;/a&gt;ありますが 、少し埋まっています（このようになると思います！）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67d4c331b2081030c9036c63f7dcc26c1bc21da1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You could use bitwise math instead of &lt;code&gt;&amp;gt; 0xFFFF&lt;/code&gt; there, but it&amp;rsquo;s probably easier to understand this way and either would achieve the same thing.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;そこでは &lt;code&gt;&amp;gt; 0xFFFF&lt;/code&gt; 代わりにビットごとの数学を使用することもできますが、この方法を理解する方がおそらく簡単で、どちらも同じことを実現します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e11e3af42de6298ef3229ff0943985a06191a5a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SHORTEST&lt;/strong&gt; 3 solutions, 1 and 2 handle cases when &lt;code&gt;s&lt;/code&gt; string  is &lt;code&gt;&quot;&quot;&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;SHORTEST&lt;/strong&gt; 3ソリューション、1および2は、 &lt;code&gt;s&lt;/code&gt; ストリングが &lt;code&gt;&quot;&quot;&lt;/code&gt; 、 &lt;code&gt;null&lt;/code&gt; 、および &lt;code&gt;undefined&lt;/code&gt; 場合を処理します 。</target>
        </trans-unit>
        <trans-unit id="0241744970e1f05578cdbbce0e8b6ad42587ba7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the 2018 ECMAScript&amp;nbsp;6+ Solution&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;これは2018 ECMAScript 6+ソリューション&lt;/strong&gt;です：</target>
        </trans-unit>
        <trans-unit id="f715e43a9cd501ad9b3351990a77f7d25046bb86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アップデート2：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b38760c3360e1a927a9cacd29a860eddc0edeb9" translate="yes" xml:space="preserve">
          <source>According to the comments below this doesn't work in IE 7 or below.</source>
          <target state="translated">下のコメントによると、これはIE7以下では動作しません。</target>
        </trans-unit>
        <trans-unit id="ca975c6c918692672e6209be6187776c7dfee237" translate="yes" xml:space="preserve">
          <source>Also the alternative option is JavaScript, so the best gonna be something like this:</source>
          <target state="translated">また、代替のオプションはJavaScriptですので、このようなものになるでしょう。</target>
        </trans-unit>
        <trans-unit id="d379b63cddadbeb97273b4dc578ce9d650af84b8" translate="yes" xml:space="preserve">
          <source>And for all coffee-junkies:</source>
          <target state="translated">コーヒー好きの皆さんにも</target>
        </trans-unit>
        <trans-unit id="a65c6aab9ccb89445d5895ed004afd6ead95252c" translate="yes" xml:space="preserve">
          <source>And then:</source>
          <target state="translated">そして、その後。</target>
        </trans-unit>
        <trans-unit id="4cab7d90a7f1fec6fb511da21e50825814a58e70" translate="yes" xml:space="preserve">
          <source>As you can see, the first two methods are essentially comparable in terms of performance, whereas altering the &lt;code&gt;String.prototype&lt;/code&gt; is by far the slowest in terms of performance.</source>
          <target state="translated">ご覧のとおり、最初の2つのメソッドはパフォーマンスの点では本質的に同等 &lt;code&gt;String.prototype&lt;/code&gt; が、 String.prototypeの変更はパフォーマンスの点ではるかに遅いです。</target>
        </trans-unit>
        <trans-unit id="b738c32be44272442962e986db9a0980aba6f5fb" translate="yes" xml:space="preserve">
          <source>At the start I also mentioned internationalization considerations. Some of these are very difficult to account for because they require knowledge not only of &lt;em&gt;what&lt;/em&gt; language is being used, but also may require specific knowledge of the words in the language. For example, the Irish digraph &quot;mb&quot; capitalizes as &quot;mB&quot; at the start of a word. Another example, the German eszett, never begins a word (afaik), but still helps illustrate the problem. The lowercase eszett (&amp;ldquo;&amp;szlig;&amp;rdquo;) capitalizes to &amp;ldquo;SS,&amp;rdquo; but  &amp;ldquo;SS&amp;rdquo; could lowercase to either &amp;ldquo;&amp;szlig;&amp;rdquo; or &amp;ldquo;ss&amp;rdquo; &amp;mdash; you require out-of-band knowledge of the German language to know which is correct!</source>
          <target state="translated">最初に、国際化の考慮事項についても触れました。 これらのいくつかは、使用されて&lt;em&gt;いる&lt;/em&gt;言語に関する知識だけでなく、その言語の単語に関する特定の知識も必要とする場合があるため、説明するのが非常に困難です。 たとえば、アイルランド語のダイグラフ「mb」は、単語の先頭で「mB」として大文字になります。 もう1つの例、ドイツ語のeszettは、単語（afaik）を始めることはありませんが、問題の説明に役立ちます。 小文字のeszett（「&amp;szlig;」）は「SS」を大文字にしますが、「SS」は「&amp;szlig;」または「ss」のいずれかに小文字にすることができます。どちらが正しいかを知るには、ドイツ語の帯域外の知識が必要です。</target>
        </trans-unit>
        <trans-unit id="cdcb4da1ad0efcd4394c1ed55e3b70f42e24c0b4" translate="yes" xml:space="preserve">
          <source>At the time of writing (Feb 2020), Firefox/Spidermonkey has not yet implemented any of the RegExp features introduced in the last two years*****. You can check the current status of this feature at the &lt;a href=&quot;http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Unicode_Property_Escapes&quot;&gt;Kangax compat table&lt;/a&gt;. Babel is able to compile RegExp literals with property references to equivalent patterns without them, but be aware that the resulting code may be enormous.</source>
          <target state="translated">執筆時点（2020年2月）では、Firefox / Spidermonkeyは過去2年間に導入されたRegExp機能をまだ実装していません*****。 この機能の現在のステータスは、 &lt;a href=&quot;http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Unicode_Property_Escapes&quot;&gt;Kangax compat table&lt;/a&gt;で確認できます 。 Babelは、RegExpリテラルを、それらを含まない同等のパターンへのプロパティ参照でコンパイルできますが、結果のコードが膨大になる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="c28281d29953dd5bbfe8e32fb31c9ecf6084a1d8" translate="yes" xml:space="preserve">
          <source>CSS only</source>
          <target state="translated">CSSのみ</target>
        </trans-unit>
        <trans-unit id="2f3f9c86a9d991e58459d1d1c5a24e5332a22188" translate="yes" xml:space="preserve">
          <source>Capitalize the first letter of all words in a string:</source>
          <target state="translated">文字列内のすべての単語の最初の文字を大文字にします。</target>
        </trans-unit>
        <trans-unit id="a69da05af469308b462024895eb097e9dd01295b" translate="yes" xml:space="preserve">
          <source>Checkout this solution:</source>
          <target state="translated">このソリューションをチェックアウトしてください。</target>
        </trans-unit>
        <trans-unit id="0ab8dd120611ec6f99b50238ac21e32cacf65d79" translate="yes" xml:space="preserve">
          <source>Created with &lt;a href=&quot;https://jsbench.me/&quot;&gt;JSBench.me&lt;/a&gt; on Google Chrome 57.</source>
          <target state="translated">Google Chrome 57の&lt;a href=&quot;https://jsbench.me/&quot;&gt;JSBench.me&lt;/a&gt;で作成されました。</target>
        </trans-unit>
        <trans-unit id="38eff30dd7da438c13e56e85015681e989636246" translate="yes" xml:space="preserve">
          <source>Despite being called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter&quot;&gt;&lt;code&gt;::first-letter&lt;/code&gt;&lt;/a&gt;, it applies to the first &lt;strong&gt;character&lt;/strong&gt;, i.e. in case of string &lt;code&gt;%a&lt;/code&gt;, this selector would apply to &lt;code&gt;%&lt;/code&gt; and as such &lt;code&gt;a&lt;/code&gt; would not be capitalized.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter&quot;&gt; &lt;code&gt;::first-letter&lt;/code&gt; &lt;/a&gt;と呼ばれますが、最初の&lt;strong&gt;文字に&lt;/strong&gt;適用され&lt;strong&gt;ます&lt;/strong&gt; 。つまり、文字列 &lt;code&gt;%a&lt;/code&gt; の場合、このセレクターは &lt;code&gt;%&lt;/code&gt; に適用されるため、大文字ではありません。</target>
        </trans-unit>
        <trans-unit id="b53015fce6abe5786b7601af4988a62b9ce4c6c7" translate="yes" xml:space="preserve">
          <source>ES2015 one-liner</source>
          <target state="translated">ES2015ワンライナー</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="5efc2d2017db789ed39b3f6945df2de895bab671" translate="yes" xml:space="preserve">
          <source>For another case I need it to capitalize the first letter and lowercase the rest. The following cases made me change this function:</source>
          <target state="translated">別のケースでは、最初の文字を大文字にして残りを小文字にする必要があります。以下のような場合に、この関数を変更しました。</target>
        </trans-unit>
        <trans-unit id="fed1125217a67648d6e1fabd36895a4669511da3" translate="yes" xml:space="preserve">
          <source>For even more internationalization options, please see the &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;original answer below&lt;/a&gt;.</source>
          <target state="translated">さらに多くの国際化オプションについては、 &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;以下&lt;/a&gt;の元の回答を参照してください。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="fd7ea24cff598ca7d051a4d8d628b73aae9173a8" translate="yes" xml:space="preserve">
          <source>For longer strings, this is probably not terribly efficient*** &amp;mdash; we don&amp;rsquo;t really need to iterate the remainder. We could use &lt;code&gt;String.prototype.codePointAt&lt;/code&gt; to get at that first (possible) letter, but we&amp;rsquo;d still need to determine where the slice should begin. One way to avoid iterating the remainder would be to test whether the first codepoint is outside the BMP; if it isn&amp;rsquo;t, the slice begins at 1, and if it is, the slice begins at 2.</source>
          <target state="translated">より長い文字列の場合、これはおそらくそれほど効率的ではありません*** &amp;mdash;残りの部分を繰り返す必要はありません。 &lt;code&gt;String.prototype.codePointAt&lt;/code&gt; を使用してその最初の（可能な）文字を取得することもできますが、スライスの開始位置を決定する必要があります。 残りの反復を回避する1つの方法は、最初のコードポイントがBMPの外側にあるかどうかをテストすることです。 そうでない場合、スライスは1から始まり、そうである場合、スライスは2から始まります。</target>
        </trans-unit>
        <trans-unit id="b63decbd83c1b992eb529da43269358b03bcf440" translate="yes" xml:space="preserve">
          <source>From ES2015 on, dealing with this became a bit easier. &lt;code&gt;String.prototype[@@iterator]&lt;/code&gt; yields strings corresponding to code points**. So for example, we can do this:</source>
          <target state="translated">ES2015以降、これへの対応は少し簡単になりました。 &lt;code&gt;String.prototype[@@iterator]&lt;/code&gt; は、コードポイントに対応する文字列を生成します**。 たとえば、次のようにできます。</target>
        </trans-unit>
        <trans-unit id="74c10e52cd68360f7bdbca8c52fc4938b2eb4e9a" translate="yes" xml:space="preserve">
          <source>Here are the fastest methods based on &lt;a href=&quot;http://jsperf.com/capitalize-the-first-letter-of-string-in-javascript/2&quot;&gt;this jsperf test&lt;/a&gt; (ordered from fastest to slowest).</source>
          <target state="translated">&lt;a href=&quot;http://jsperf.com/capitalize-the-first-letter-of-string-in-javascript/2&quot;&gt;このjsperfテストに&lt;/a&gt;基づく最速のメソッドを次に示します （最速から最遅の順に並べられています）。</target>
        </trans-unit>
        <trans-unit id="36ec1b221f06d0c0a874dc6ea003751af9a2707b" translate="yes" xml:space="preserve">
          <source>Here is a function called &lt;strong&gt;ucfirst()&lt;/strong&gt; (short for &quot;upper case first letter&quot;):</source>
          <target state="translated">ここに&lt;strong&gt;ucfirst（）&lt;/strong&gt;という関数があります&lt;strong&gt;（&lt;/strong&gt; 「大文字の最初の文字」の略）：</target>
        </trans-unit>
        <trans-unit id="f63bba80779b9f905ca9275279f4d3217ddae10f" translate="yes" xml:space="preserve">
          <source>Here is a shortened version of the popular answer that gets the first letter by treating the string as an array:</source>
          <target state="translated">ここでは、文字列を配列として扱うことで最初の文字を取得する一般的な答えの短縮版を紹介します。</target>
        </trans-unit>
        <trans-unit id="8de7492950ddcf0f0806df769b72006c014004f5" translate="yes" xml:space="preserve">
          <source>Here's a more object-oriented approach:</source>
          <target state="translated">ここでは、よりオブジェクト指向のアプローチをご紹介します。</target>
        </trans-unit>
        <trans-unit id="26ec945f349fe1c8f7b8bfe93fdfedd83c5c2657" translate="yes" xml:space="preserve">
          <source>How do I make the first letter of a string uppercase in JavaScript</source>
          <target state="translated">JavaScriptで文字列の最初の文字を大文字にするには?</target>
        </trans-unit>
        <trans-unit id="41600359895123b43257f89a1713e3beaa5909e0" translate="yes" xml:space="preserve">
          <source>How do I make the first letter of a string uppercase, but not change the case of any of the other letters?</source>
          <target state="translated">文字列の最初の文字を大文字にして、他の文字の大文字小文字を変えないようにするには?</target>
        </trans-unit>
        <trans-unit id="2471381604a49f6d0e0c580d6ed33d04e7bbf029" translate="yes" xml:space="preserve">
          <source>However, some cased characters fall outside the BMP (basic multilingual plane, code points U+0 to U+FFFF). For example take this Deseret text:</source>
          <target state="translated">しかし、いくつかの大文字小文字は、BMP(基本的な多言語プレーン、コードポイントU+0からU+FFFF)の外に落ちます。例えば、この Deseret のテキストを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ab4561105ba74782ce146baef49296c05955c8d5" translate="yes" xml:space="preserve">
          <source>I didn&amp;rsquo;t see any mention in the existing answers of issues related to &lt;s&gt;astral plane code points or&lt;/s&gt; internationalization. &amp;ldquo;Uppercase&amp;rdquo; doesn&amp;rsquo;t mean the same thing in every language using a given script.</source>
          <target state="translated">&lt;s&gt;アストラルプレーンのコードポイントや&lt;/s&gt;国際化に関連する問題の既存の回答には何の言及もありませんでした。 「大文字」は、特定のスクリプトを使用するすべての言語で同じことを意味するわけではありません。</target>
        </trans-unit>
        <trans-unit id="57568b656d3bfd8b25836b6e404e950afe5e8ed8" translate="yes" xml:space="preserve">
          <source>I found this arrow function easiest. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;Replace&lt;/a&gt; matches the first letter character (&lt;code&gt;\w&lt;/code&gt;) of your string and converts it to uppercase. Nothing fancier necessary.</source>
          <target state="translated">私はこの矢印関数が最も簡単だと思いました。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;Replace&lt;/a&gt;は、文字列の最初の文字（ &lt;code&gt;\w&lt;/code&gt; ）に一致し、それを大文字に変換します。 特別なことは必要ありません。</target>
        </trans-unit>
        <trans-unit id="fc8ad3518c2d8b9e7e804ae69020ba2d72f9b38e" translate="yes" xml:space="preserve">
          <source>I went with name &lt;code&gt;capitalizeFirstChar&lt;/code&gt; instead of &lt;code&gt;capitalizeFirstLetter&lt;/code&gt;, because OP didn't asked for code that capitalizes the first letter in the entire string, but the very first char (if it's letter, of course).</source>
          <target state="translated">OPは文字列全体の最初の文字を大文字にするコードを要求しなかったので、 &lt;code&gt;capitalizeFirstChar&lt;/code&gt; ではなく、 &lt;code&gt;capitalizeFirstLetter&lt;/code&gt; という名前を付けました。</target>
        </trans-unit>
        <trans-unit id="12beaec08e35b5059fe37bcbcaff9243ba2cb242" translate="yes" xml:space="preserve">
          <source>If you  want to reuse it over and over, it's better attach it to javascript native String, so something like below:</source>
          <target state="translated">何度も再利用したい場合は、javascriptネイティブのStringにアタッチした方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="5595b4caaf07e85122b5dcf531caac0aed37a182" translate="yes" xml:space="preserve">
          <source>If you are wanting to reformat all-caps text, you might want to modify the other examples as such:</source>
          <target state="translated">全角文字のテキストを再フォーマットしたい場合は、他の例をこのように修正した方がいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="391b6c39ae6bd183048d53c4501002d9557638f3" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; or &lt;a href=&quot;http://lodash.com/&quot;&gt;Lo-Dash&lt;/a&gt;, the &lt;a href=&quot;https://github.com/epeli/underscore.string&quot;&gt;underscore.string&lt;/a&gt; library provides string extensions, including capitalize:</source>
          <target state="translated">&lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt;または&lt;a href=&quot;http://lodash.com/&quot;&gt;Lo-Dash&lt;/a&gt;を使用する場合、 &lt;a href=&quot;https://github.com/epeli/underscore.string&quot;&gt;underscore.string&lt;/a&gt;ライブラリは、大文字を含む文字列拡張を提供します。</target>
        </trans-unit>
        <trans-unit id="3580d94edc18905a809fe61049b66ac884fd95f0" translate="yes" xml:space="preserve">
          <source>If you want to work with Unicode code points instead of code units (for example to handle Unicode characters outside of the Basic Multilingual Plane) you can leverage the fact that &lt;code&gt;String#[@iterator]&lt;/code&gt; works with code points, and you can use &lt;code&gt;toLocaleUpperCase&lt;/code&gt; to get locale-correct uppercasing:</source>
          <target state="translated">コード単位ではなくUnicodeコードポイントを使用する場合（たとえば、基本多言語プレーンの外部でUnicode文字を処理する場合）、 &lt;code&gt;String#[@iterator]&lt;/code&gt; がコードポイントで機能するという事実を活用できます &lt;code&gt;toLocaleUpperCase&lt;/code&gt; を使用して、ロケールに応じた大文字を取得します。</target>
        </trans-unit>
        <trans-unit id="520fb73d2d3cb4c07939630bd614bc3b08d45c7a" translate="yes" xml:space="preserve">
          <source>If you're already (or considering) using &lt;code&gt;lodash&lt;/code&gt;, the solution is easy:</source>
          <target state="translated">&lt;code&gt;lodash&lt;/code&gt; を既に使用している（または検討している）場合、解決策は簡単です。</target>
        </trans-unit>
        <trans-unit id="4ec057c220d248000ac866fd08c88dfedb4df649" translate="yes" xml:space="preserve">
          <source>If you're interested in the performance of a few different methods posted:</source>
          <target state="translated">投稿されたいくつかの方法の性能が気になる方は</target>
        </trans-unit>
        <trans-unit id="22ed663eee054bfc4462b75cb3de053fa66754b0" translate="yes" xml:space="preserve">
          <source>In CSS:</source>
          <target state="translated">CSSでは</target>
        </trans-unit>
        <trans-unit id="513ed99d77b99d0268fb8f84f8be5411764fabcb" translate="yes" xml:space="preserve">
          <source>In IE9+ or IE5.5+ it's supported in legacy notation with only one colon (&lt;code&gt;:first-letter&lt;/code&gt;).</source>
          <target state="translated">IE9 +またはIE5.5 +では、1つのコロン（ &lt;code&gt;:first-letter&lt;/code&gt; ）のみのレガシー表記でサポートされます。</target>
        </trans-unit>
        <trans-unit id="2c731feb5a1bab9995bffb541f3ec85ca6616ec0" translate="yes" xml:space="preserve">
          <source>In a browser, the user&amp;rsquo;s most-preferred language tag is indicated by &lt;code&gt;navigator.language&lt;/code&gt;, a list in order of preference is found at &lt;code&gt;navigator.languages&lt;/code&gt;, and a given DOM element&amp;rsquo;s language can be obtained (usually) with &lt;code&gt;Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE&lt;/code&gt; in multilanguage documents.</source>
          <target state="translated">ブラウザーでは、ユーザーの最も優先される言語タグは &lt;code&gt;navigator.language&lt;/code&gt; で示され、優先順のリストは &lt;code&gt;navigator.languages&lt;/code&gt; にあり、指定されたDOM要素の言語は（通常） &lt;code&gt;Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE&lt;/code&gt; YOUR_DEFAULT_HERE （多言語ドキュメント）。</target>
        </trans-unit>
        <trans-unit id="3e7be93047b07099fd9e6aeac9ef8367e4ad1893" translate="yes" xml:space="preserve">
          <source>In agents which support Unicode property character classes in RegExp, which were introduced in ES2018, we can clean stuff up further by directly expressing what characters we&amp;rsquo;re interested in:</source>
          <target state="translated">ES2018で導入されたRegExpのUnicodeプロパティ文字クラスをサポートするエージェントでは、関心のある文字を直接表現することで、さらにクリーンアップできます。</target>
        </trans-unit>
        <trans-unit id="237f8c8207eb9f09670dd34797c5476976d0f091" translate="yes" xml:space="preserve">
          <source>In all likelihood, people asking this question will not be concerned with Deseret capitalization or internationalization. But it&amp;rsquo;s good to be aware of these issues because there&amp;rsquo;s a good chance you&amp;rsquo;ll encounter them eventually even if they aren&amp;rsquo;t concerns presently. They&amp;rsquo;re not &amp;ldquo;edge&amp;rdquo; cases, or rather, they&amp;rsquo;re not &lt;em&gt;by-definition&lt;/em&gt; edge cases &amp;mdash; there&amp;rsquo;s a whole country where most people speak Turkish, anyway, and conflating code units with codepoints is a fairly common source of bugs (especially with regard to emoji). Both strings and language are pretty complicated!</source>
          <target state="translated">おそらく、この質問をする人々は、Deseretの大文字化または国際化に関与しません。 ただし、これらの問題は、現時点では問題になっていなくても、最終的には発生する可能性が高いため、注意が必要です。 それらは「エッジ」ケースではなく、むしろ&lt;em&gt;定義による&lt;/em&gt;エッジケースではありません。とにかく、ほとんどの人がトルコ語を話す国があり、コードユニットとコードポイントの融合がかなり一般的なバグのソースです（特に絵文字に関して）。 文字列と言語はどちらもかなり複雑です！</target>
        </trans-unit>
        <trans-unit id="b9215739ff07c5a531e3c157e3d8b7debaf7f595" translate="yes" xml:space="preserve">
          <source>In the benchmark I performed there was no significant difference between &lt;code&gt;string.charAt(0)&lt;/code&gt; and &lt;code&gt;string[0]&lt;/code&gt;. Note however, that &lt;code&gt;string[0]&lt;/code&gt; would be &lt;code&gt;undefined&lt;/code&gt; for empty string, so it should be rewritten to &lt;code&gt;string &amp;amp;&amp;amp; string[0]&lt;/code&gt;, which is way too verbose, compared to the alternative.</source>
          <target state="translated">私が実行したベンチマークでは、 &lt;code&gt;string.charAt(0)&lt;/code&gt; と &lt;code&gt;string[0]&lt;/code&gt; 間に有意差はありませんでした。 ただし、 &lt;code&gt;string[0]&lt;/code&gt; は空の文字列に対しては &lt;code&gt;undefined&lt;/code&gt; ため、代替案と比較して、 &lt;code&gt;string &amp;amp;&amp;amp; string[0]&lt;/code&gt; に書き換える必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="aa4f881902e40d1677a1a09723b87da7f2131a80" translate="yes" xml:space="preserve">
          <source>It happens to be that UTF-16 code units are 1:1 with USV code points within two ranges, U+0 to U+D7FF and U+E000 to U+FFFF inclusive. Most cased characters fall into those two ranges, but not all of them.</source>
          <target state="translated">たまたまですが、UTF-16 のコード単位は U+0 ~ U+D7FF と U+E000 ~ U+FFFF の 2 つの範囲内で USV コードポイントと 1:1 になっています。大半の大文字小文字はこの2つの範囲に収まりますが、すべてではありません。</target>
        </trans-unit>
        <trans-unit id="cfcdd40d2baaffb7a5e373b22106b786580f61af" translate="yes" xml:space="preserve">
          <source>It seems to be easier in CSS:</source>
          <target state="translated">CSSの方が簡単なようです。</target>
        </trans-unit>
        <trans-unit id="be0d696fbec75b29d058a2ffde594a36cc305bd4" translate="yes" xml:space="preserve">
          <source>It will output &lt;code&gt;&quot;Ruby java&quot;&lt;/code&gt; to the console.</source>
          <target state="translated">&lt;code&gt;&quot;Ruby java&quot;&lt;/code&gt; をコンソールに出力します。</target>
        </trans-unit>
        <trans-unit id="753fc3e18b8a5011f782214d0491ba42959f8ddc" translate="yes" xml:space="preserve">
          <source>It works by splitting the string into two pieces.  On the first line it pulls out &lt;strong&gt;firstLetter&lt;/strong&gt; and then on the second line it capitalises &lt;strong&gt;firstLetter&lt;/strong&gt; by calling &lt;strong&gt;firstLetter.toUpperCase()&lt;/strong&gt; and joins it with the rest of the string, which is found by calling &lt;strong&gt;str.substr(1)&lt;/strong&gt;.</source>
          <target state="translated">文字列を2つに分割することで機能します。 1行目で&lt;strong&gt;firstLetter&lt;/strong&gt;を引き出し、2行目で&lt;strong&gt;firstLetter.toUpperCase（）&lt;/strong&gt;を呼び出して&lt;strong&gt;firstLetterを&lt;/strong&gt;大文字にし、それを&lt;strong&gt;str.substr（1）を&lt;/strong&gt;呼び出して見つかった残りの文字列と結合します。</target>
        </trans-unit>
        <trans-unit id="39cf6e340b712fcaeefaccd6c9cae7c6fb438b3b" translate="yes" xml:space="preserve">
          <source>It's always better to handle these kinds of stuff using &lt;strong&gt;CSS first&lt;/strong&gt;, in general, if you can solve something using CSS, go for that first, then try JavaScript to solve your problems, so in this case try using &lt;code&gt;:first-letter&lt;/code&gt; in CSS and apply &lt;code&gt;text-transform:capitalize;&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;CSS&lt;/strong&gt;を使用してこれらの種類のものを&lt;strong&gt;最初&lt;/strong&gt;に処理することは常により良いです。一般に、CSSを使用して何かを解決できる場合は、最初にそれを実行し、次にJavaScriptを試して問題を解決してください。この場合、CSSで &lt;code&gt;:first-letter&lt;/code&gt; を使用してみてください。 &lt;code&gt;text-transform:capitalize;&lt;/code&gt; 適用する：大文字にする;</target>
        </trans-unit>
        <trans-unit id="68cebc3a030d29b43fc7340eaf94a510388b167b" translate="yes" xml:space="preserve">
          <source>Most of the proposed functions look like this:</source>
          <target state="translated">提案されている機能のほとんどは、次のようなものです。</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="bd0ec7f92d0013f9249f7d0c47b7dbfe0e9eaf1d" translate="yes" xml:space="preserve">
          <source>See their docs: &lt;a href=&quot;https://lodash.com/docs#capitalize&quot;&gt;https://lodash.com/docs#capitalize&lt;/a&gt;</source>
          <target state="translated">彼らのドキュメントを参照してください： &lt;a href=&quot;https://lodash.com/docs#capitalize&quot;&gt;https&lt;/a&gt; : //lodash.com/docs#capitalize</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">コードスニペットを表示</target>
        </trans-unit>
        <trans-unit id="7125002cd82871109849d7c7802837b04e3aa758" translate="yes" xml:space="preserve">
          <source>Since there are numerous answers, but none in ES2015 that would solve original problem efficiently, I came up with the following:</source>
          <target state="translated">数多くの解答がありますが、元の問題を効率よく解けるような解答はES2015にはありませんでしたので、以下のように考えてみました。</target>
        </trans-unit>
        <trans-unit id="a05e8ccd4f0db9fa8ab4b2d4f1e59cc14da07156" translate="yes" xml:space="preserve">
          <source>So try creating a class for that, so you can use it globally, for example: &lt;code&gt;.first-letter-uppercase&lt;/code&gt; and add something like below in your CSS:</source>
          <target state="translated">したがって、そのためのクラスを作成してみてください。たとえば、 &lt;code&gt;.first-letter-uppercase&lt;/code&gt; でグローバルに使用できるようにして、CSSに以下のようなものを追加します。</target>
        </trans-unit>
        <trans-unit id="1dc1f21e14a758a9bf27e090a7e7aff5d2f7c19a" translate="yes" xml:space="preserve">
          <source>Some other answers modify &lt;code&gt;String.prototype&lt;/code&gt; (this answer used to as well), but I would advise against this now due to maintainability (hard to find out where the function is being added to the &lt;code&gt;prototype&lt;/code&gt; and could cause conflicts if other code uses the same name / a browser adds a native function with that same name in future).</source>
          <target state="translated">他のいくつかの回答は &lt;code&gt;String.prototype&lt;/code&gt; を変更しますが （この回答は以前にも使用されていました）、保守性のためにこれに対して反対のアドバイスをします（ &lt;code&gt;prototype&lt;/code&gt; 関数が追加されている場所を見つけるのが難しく、他のコードが同じものを使用する場合に競合を引き起こす可能性があります） name /ブラウザは、同じ名前のネイティブ関数を将来追加します）。</target>
        </trans-unit>
        <trans-unit id="f328eb536a4786b3e3cffb9fe5ba8a131e439b94" translate="yes" xml:space="preserve">
          <source>Thanks J-P for the aclaration.</source>
          <target state="translated">J-Pさん、アクラクションありがとうございます。</target>
        </trans-unit>
        <trans-unit id="e7e02386fc0fdd5750e124eedc2fe82fb16c6cbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ucfirst&lt;/code&gt; function works if you do it like this.</source>
          <target state="translated">このようにすると、 &lt;code&gt;ucfirst&lt;/code&gt; 関数が機能します。</target>
        </trans-unit>
        <trans-unit id="f8d4f74a2fbde727e6e72b8c96f5adb95eabac25" translate="yes" xml:space="preserve">
          <source>The basic solution is:</source>
          <target state="translated">基本的な解決策は</target>
        </trans-unit>
        <trans-unit id="ca5df1b84c287b849617bdac4e324fb5a89cfdb4" translate="yes" xml:space="preserve">
          <source>The first character here fails to capitalize because the array-indexed properties of strings don&amp;rsquo;t access &amp;ldquo;characters&amp;rdquo; or code points*. They access UTF-16 code units. This is true also when slicing &amp;mdash; the index values point at code units.</source>
          <target state="translated">文字列の配列インデックス付きプロパティは「文字」またはコードポイント*にアクセスしないため、ここの最初の文字は大文字にできません。 それらはUTF-16コード単位にアクセスします。 これはスライスする場合にも当てはまります。インデックス値はコード単位を指しています。</target>
        </trans-unit>
        <trans-unit id="3e7ba471ab8219d28d83cb805cb394c50a047c08" translate="yes" xml:space="preserve">
          <source>The most famous example of these kinds of issues, probably, is Turkish. In Turkish Latin, the capital form of i is İ, while the lowercase form of I is ı &amp;mdash; they&amp;rsquo;re two different letters. Fortunately we do have a way to account for this:</source>
          <target state="translated">この種の問題の最も有名な例は、おそらくトルコ語です。 トルコ語ラテン語では、iの大文字の形式はisですが、Iの小文字の形式はıです。これらは2つの異なる文字です。 幸いなことに、これを説明する方法があります。</target>
        </trans-unit>
        <trans-unit id="4c47e3933006e2a994f15b0b8d727bc485f4d3ad" translate="yes" xml:space="preserve">
          <source>There is a very simple way to implement it by &lt;strong&gt;replace&lt;/strong&gt;. For ECMAScript&amp;nbsp;6:</source>
          <target state="translated">&lt;strong&gt;replaceで&lt;/strong&gt;実装する非常に簡単な方法があります。 ECMAScript 6の場合：</target>
        </trans-unit>
        <trans-unit id="04f622e4b19164c4d7616ea7f0401578b5a965de" translate="yes" xml:space="preserve">
          <source>This could be tweaked a bit to also handle capitalizing multiple words in a string with fairly good accuracy. The &lt;code&gt;CWU&lt;/code&gt; or &lt;a href=&quot;https://unicode.org/reports/tr44/#CWU&quot;&gt;Changes_When_Uppercased&lt;/a&gt; character property matches all code points which, well, change when uppercased. We can try this out with a titlecased digraph characters like the Dutch &lt;a href=&quot;https://en.wikipedia.org/wiki/IJ_(digraph)&quot;&gt;ĳ&lt;/a&gt; for example:</source>
          <target state="translated">これを少し調整して、文字列内の複数の単語の大文字化をかなり正確に処理することもできます。 &lt;code&gt;CWU&lt;/code&gt; または&lt;a href=&quot;https://unicode.org/reports/tr44/#CWU&quot;&gt;Changes_When_Uppercased&lt;/a&gt;文字プロパティは、大文字の場合に変更されるすべてのコードポイントと一致します。 たとえば、オランダ語のlikeのようなタイトル付きダイグラフ文字でこれを試すことができます。</target>
        </trans-unit>
        <trans-unit id="aaf0e7360a18b0ecd99a513342639b5cd16aa14e" translate="yes" xml:space="preserve">
          <source>This is a text string =&amp;gt; This Is A Text String</source>
          <target state="translated">これはテキスト文字列です=&amp;gt;これはテキスト文字列です</target>
        </trans-unit>
        <trans-unit id="445a7900debb9aa27ba0234cd7efda1545c51c28" translate="yes" xml:space="preserve">
          <source>This is from &lt;em&gt;&lt;a href=&quot;http://www.w3schools.com/cssref/pr_text_text-transform.asp&quot;&gt;CSS text-transform Property&lt;/a&gt;&lt;/em&gt; (at &lt;a href=&quot;http://en.wikipedia.org/wiki/W3Schools&quot;&gt;W3Schools&lt;/a&gt;).</source>
          <target state="translated">これは、 &lt;em&gt;&lt;a href=&quot;http://www.w3schools.com/cssref/pr_text_text-transform.asp&quot;&gt;CSSのtext-transformプロパティ&lt;/a&gt;&lt;/em&gt; （ &lt;a href=&quot;http://en.wikipedia.org/wiki/W3Schools&quot;&gt;W3Schools&lt;/a&gt; ）からのものです。</target>
        </trans-unit>
        <trans-unit id="c6f3cfe2c963966513eb01910fe27bfe53212f39" translate="yes" xml:space="preserve">
          <source>This will ensure that the following text is changed:</source>
          <target state="translated">これにより、以下のテキストが確実に変更されます。</target>
        </trans-unit>
        <trans-unit id="0af318f5e656024280a36dcfb0426885a76eff9c" translate="yes" xml:space="preserve">
          <source>To avoid &lt;code&gt;undefined&lt;/code&gt; for empty strings (see &lt;a href=&quot;https://stackoverflow.com/questions/1026069/capitalize-the-first-letter-of-string-in-javascript/7224605?noredirect=1#comment40995528_7224605&quot;&gt;@njzk2's comment below&lt;/a&gt;), you can check for an empty string:</source>
          <target state="translated">空の文字列が &lt;code&gt;undefined&lt;/code&gt; にならないようにするには（以下の&lt;a href=&quot;https://stackoverflow.com/questions/1026069/capitalize-the-first-letter-of-string-in-javascript/7224605?noredirect=1#comment40995528_7224605&quot;&gt;@ njzk2のコメントを参照&lt;/a&gt; ）、空の文字列を確認できます。</target>
        </trans-unit>
        <trans-unit id="7545eb65f39400b816765aedda58dcaf2245938f" translate="yes" xml:space="preserve">
          <source>Update Nov.2016 (ES6), just for FUN :</source>
          <target state="translated">アップデート2016年11月(ES6)、ちょうどFUNのために .</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="438b77c967ff84de26b6c856e0dbc9c0ccb11946" translate="yes" xml:space="preserve">
          <source>Vanilla js for first upper case:</source>
          <target state="translated">最初の大文字にバニラjs。</target>
        </trans-unit>
        <trans-unit id="cc356c06beeecbb1483af35dc9f41fbcb69e577a" translate="yes" xml:space="preserve">
          <source>We can also make this work in ES5 and below by taking that logic a bit further if necessary. There are no intrinsic methods in ES5 for working with codepoints, so we have to manually test whether the first code unit is a surrogate****:</source>
          <target state="translated">必要に応じて、このロジックをもう少し発展させることで、ES5 以下でも動作させることができます。ES5 にはコードポイントを操作するための本質的なメソッドがないので、最初のコードユニットがサロゲート****であるかどうかを手動でテストしなければなりません。</target>
        </trans-unit>
        <trans-unit id="38598e2d769aafd63e8b0ada676593eea8abbce4" translate="yes" xml:space="preserve">
          <source>We could get the first character with one of my favorite &lt;code&gt;RegExp&lt;/code&gt;, looks like a cute smiley: &lt;code&gt;/^./&lt;/code&gt;</source>
          <target state="translated">私のお気に入りの &lt;code&gt;RegExp&lt;/code&gt; の 1つで最初の文字を取得できます。かわいいスマイルのように見えます： &lt;code&gt;/^./&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80c2861bacbf5087e7a78a28702e92c207722448" translate="yes" xml:space="preserve">
          <source>With the expected output being:</source>
          <target state="translated">期待される出力で</target>
        </trans-unit>
        <trans-unit id="0728cce84a033f171749d6217a9b0b732df74446" translate="yes" xml:space="preserve">
          <source>You can capitalise a string by calling &lt;strong&gt;ucfirst(&quot;some string&quot;)&lt;/strong&gt; -- for example,</source>
          <target state="translated">&lt;strong&gt;ucfirst（ &quot;some string&quot;）を&lt;/strong&gt;呼び出すことで文字列を大文字にすることができます-たとえば、</target>
        </trans-unit>
        <trans-unit id="4f213a95acdcde6d613a25cf52f2b2753c1f8659" translate="yes" xml:space="preserve">
          <source>You can do it in one line like this</source>
          <target state="translated">こんな感じで一行でできます。</target>
        </trans-unit>
        <trans-unit id="6c4e71a0412953fe2f3f9b1b1c678eb0f7b05035" translate="yes" xml:space="preserve">
          <source>You might think this would fail for an empty string, and indeed in a language like C you would have to cater for this. However in JavaScript, when you take a substring of an empty string, you just get an empty string back.</source>
          <target state="translated">これは空の文字列では失敗すると思うかもしれませんし、C言語のような言語ではこれに対応しなければならないでしょう。しかし、JavaScriptでは、空の文字列の部分文字列を取得すると、空の文字列が返ってきます。</target>
        </trans-unit>
        <trans-unit id="d4a9eb672ba09519a041a6378259fc7533179e68" translate="yes" xml:space="preserve">
          <source>You'd call the function, like this:</source>
          <target state="translated">こんな感じで関数を呼び出すんですね。</target>
        </trans-unit>
        <trans-unit id="b3de993735805658454ec6a662d98b23e05c1c34" translate="yes" xml:space="preserve">
          <source>_.capitalize(string) Converts first letter of the string to
  uppercase.</source>
          <target state="translated">_.capitalize(string)文字列の最初の文字を大文字に変換します。</target>
        </trans-unit>
        <trans-unit id="58ed86c48852b86ec22065963de4717546a22f0f" translate="yes" xml:space="preserve">
          <source>and call it as below:</source>
          <target state="translated">と、以下のように呼びます。</target>
        </trans-unit>
        <trans-unit id="5841729c0f596832e8c1fdf28e8579200c954984" translate="yes" xml:space="preserve">
          <source>and call it like:</source>
          <target state="translated">のように呼んでみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="07ca609f2cad16f006215d4b73b16c731cd9ef2e" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;capitalize(&quot;hello&quot;) // Hello&lt;/code&gt;</source>
          <target state="translated">次に、 &lt;code&gt;capitalize(&quot;hello&quot;) // Hello&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
