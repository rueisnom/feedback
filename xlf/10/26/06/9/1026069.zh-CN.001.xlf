<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1026069">
    <body>
      <group id="1026069">
        <trans-unit id="9de390a8260c191b43450f70ae86feb669df0906" translate="yes" xml:space="preserve">
          <source>(You may encapsulate it in a function or even add it to the String prototype if you use it frequently.)</source>
          <target state="translated">(你可以把它封装在一个函数中,或者如果你经常使用它,甚至可以把它添加到String原型中)。</target>
        </trans-unit>
        <trans-unit id="b9bf45d36ec359981f7c6104d1efde02af646768" translate="yes" xml:space="preserve">
          <source>...and for all guys who think that there's a better way of doing this, without extending native prototypes:</source>
          <target state="translated">...对于所有认为有更好的方法的人来说,不需要扩展原生原型,就能做到这一点。</target>
        </trans-unit>
        <trans-unit id="367d2eac8d3ed38b462e4255bae2e055a734f474" translate="yes" xml:space="preserve">
          <source>...and then, there is so much more to this question when you consider internationalisation, as &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;this astonishingly good answer&lt;/a&gt; (buried below) shows.</source>
          <target state="translated">...然后，当您考虑国际化时，这个问题还有很多，正如&lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;这个令人惊讶的好答案&lt;/a&gt; （埋在下面）所示。</target>
        </trans-unit>
        <trans-unit id="01458e5b9ce1421cc63ab3a554d729db7d445bfd" translate="yes" xml:space="preserve">
          <source>4,577,946 ops/s &amp;plusmn;1.2% for the most voted answer.</source>
          <target state="translated">投票最多的答案为4,577,946个操作/秒&amp;plusmn;1.2％。</target>
        </trans-unit>
        <trans-unit id="a2ffd6820da15f37abf4c947e438311a5752e475" translate="yes" xml:space="preserve">
          <source>4,956,962 ops/s &amp;plusmn;3.03% for this solution,</source>
          <target state="translated">此解决方案为4,956,962 ops / s&amp;plusmn;3.03％，</target>
        </trans-unit>
        <trans-unit id="21536903e387743ca164f63d9cc09e9b8b6bb9e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;/index.html&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;/index.html&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;/index.html&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;/index.html&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d494e91c3e544750401f32794514d26617133c2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;the Eiffel Tower&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;The Eiffel Tower&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;the Eiffel Tower&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;The Eiffel Tower&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="163679a6bb6d7fb0504648cd5281b896b69b7f3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;this is a test&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;This is a test&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;this is a test&quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;&quot;This is a test&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="228001a68abeb7721c7e6836bdfa016232028ea1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; gives us the ability to declare &lt;code&gt;capitalizeFirstChar&lt;/code&gt; as constant, which is desired since as a programmer you should always explicitly state your intentions.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 使我们能够将 &lt;code&gt;capitalizeFirstChar&lt;/code&gt; 声明为常量，这是需要的，因为作为程序员，您应始终明确声明您的意图。</target>
        </trans-unit>
        <trans-unit id="fe5ad94b64fc4f2a2e524d4f6153761e202b6090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parameters =&amp;gt; function&lt;/code&gt; is so called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;parameters =&amp;gt; function&lt;/code&gt; 就是所谓的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;箭头函数&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a8043e9b8b738f65ac06fcc7f0df98edb180022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string.substring(1)&lt;/code&gt; is faster than &lt;code&gt;string.slice(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string.substring(1)&lt;/code&gt; 比 &lt;code&gt;string.slice(1)&lt;/code&gt; 快。</target>
        </trans-unit>
        <trans-unit id="5d710ede0941e4a1632178bcd80a8c8aab513de6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;* The code units of UTF-16 / UCS2 are also Unicode code points in the sense that e.g. U+D800 is technically a code point, but that&amp;rsquo;s not what it &amp;ldquo;means&amp;rdquo; here ... sort of ... though it gets pretty fuzzy. What the surrogates definitely are not, though, is USVs (Unicode scalar values).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;*从某种意义上说，UTF-16 / UCS2的代码单元也是Unicode代码点，例如从技术上说U + D800是一个代码点，但这并不是它的&amp;ldquo;含义&amp;rdquo;&amp;hellip;&amp;hellip;虽然很漂亮模糊。&lt;/em&gt; &lt;em&gt;但是，替代品绝对不是USV（Unicode标量值）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80e943d6704e4d184a5db2220f9f6efdc9fbefec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;** Though if a surrogate code unit is &amp;ldquo;orphaned&amp;rdquo; &amp;mdash; i.e., not part of a logical pair &amp;mdash; you could still get surrogates here, too.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;**尽管如果代理代码单元是&amp;ldquo;孤立的&amp;rdquo;（即，不是逻辑对的一部分），您仍然可以在此处获得代理。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cdf2e5c67a4f0fdde3be9c75c84dbfc0ff1c9081" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;*** maybe. I haven&amp;rsquo;t tested it. Unless you have determined capitalization is a meaningful bottleneck, I probably wouldn&amp;rsquo;t sweat it &amp;mdash; choose whatever you believe is most clear and readable.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;*** 也许。&lt;/em&gt; &lt;em&gt;我还没有测试。&lt;/em&gt; &lt;em&gt;除非您确定大写是一个有意义的瓶颈，否则我可能不会大惊小怪-选择您认为最清晰易读的内容。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1853748fb3df42199189a7bc4ca52932cac9483c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;**** such a function might wish to test both the first and second code units instead of just the first, since it&amp;rsquo;s possible that the first unit is an orphaned surrogate. For example the input &quot;\uD800x&quot; would capitalize the X as-is, which may or may not be expected.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;****这样的功能可能希望同时测试第一个和第二个代码单元，而不仅仅是第一个，因为第一个单元可能是孤立的代理。&lt;/em&gt; &lt;em&gt;例如，输入&amp;ldquo; \ uD800x&amp;rdquo;将按原样将X大写，这可能会或可能不会出现。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e323f33e94cbca47eb23464c89f17f842364d336" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;***** Here&amp;rsquo;s the &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1361876&quot;&gt;Bugzilla issue&lt;/a&gt; if you want to follow the progress more directly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;*****如果您想直接关注进度，这是&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1361876&quot;&gt;Bugzilla问题&lt;/a&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34b7e56ddb1cb38bfcf26066f4b7ae7fb74172d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Initially I didn&amp;rsquo;t see any answers addressing issues related to astral plane code points. There &lt;a href=&quot;https://stackoverflow.com/a/45224904/1631952&quot;&gt;is one&lt;/a&gt;, but it&amp;rsquo;s a bit buried (like this one will be, I guess!)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;最初，我看不到任何与星体平面代码点相关的问题的答案。&lt;/em&gt; &lt;em&gt;有&lt;a href=&quot;https://stackoverflow.com/a/45224904/1631952&quot;&gt;一个&lt;/a&gt; ，但是有点埋没了（我想是这样的！）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67d4c331b2081030c9036c63f7dcc26c1bc21da1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You could use bitwise math instead of &lt;code&gt;&amp;gt; 0xFFFF&lt;/code&gt; there, but it&amp;rsquo;s probably easier to understand this way and either would achieve the same thing.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;您可以在那里使用按位数学运算，而不是 &lt;code&gt;&amp;gt; 0xFFFF&lt;/code&gt; ，但是用这种方式可能更容易理解，并且两者都可以实现相同的目的。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e11e3af42de6298ef3229ff0943985a06191a5a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SHORTEST&lt;/strong&gt; 3 solutions, 1 and 2 handle cases when &lt;code&gt;s&lt;/code&gt; string  is &lt;code&gt;&quot;&quot;&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;最短的&lt;/strong&gt; 3个解决方案，1和2处理 &lt;code&gt;s&lt;/code&gt; 字符串为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 的情况 ：</target>
        </trans-unit>
        <trans-unit id="0241744970e1f05578cdbbce0e8b6ad42587ba7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the 2018 ECMAScript&amp;nbsp;6+ Solution&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;这是2018 ECMAScript 6+解决方案&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="f715e43a9cd501ad9b3351990a77f7d25046bb86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更新2：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b38760c3360e1a927a9cacd29a860eddc0edeb9" translate="yes" xml:space="preserve">
          <source>According to the comments below this doesn't work in IE 7 or below.</source>
          <target state="translated">根据下面的评论,这在IE 7及以下版本中无法使用。</target>
        </trans-unit>
        <trans-unit id="ca975c6c918692672e6209be6187776c7dfee237" translate="yes" xml:space="preserve">
          <source>Also the alternative option is JavaScript, so the best gonna be something like this:</source>
          <target state="translated">另外,备选方案是JavaScript,所以最好是这样的。</target>
        </trans-unit>
        <trans-unit id="d379b63cddadbeb97273b4dc578ce9d650af84b8" translate="yes" xml:space="preserve">
          <source>And for all coffee-junkies:</source>
          <target state="translated">也是为所有的咖啡迷们准备的。</target>
        </trans-unit>
        <trans-unit id="a65c6aab9ccb89445d5895ed004afd6ead95252c" translate="yes" xml:space="preserve">
          <source>And then:</source>
          <target state="translated">然后。</target>
        </trans-unit>
        <trans-unit id="4cab7d90a7f1fec6fb511da21e50825814a58e70" translate="yes" xml:space="preserve">
          <source>As you can see, the first two methods are essentially comparable in terms of performance, whereas altering the &lt;code&gt;String.prototype&lt;/code&gt; is by far the slowest in terms of performance.</source>
          <target state="translated">如您所见，前两种方法在性能上基本上是可比的，而更改 &lt;code&gt;String.prototype&lt;/code&gt; 到目前为止是性能最慢的。</target>
        </trans-unit>
        <trans-unit id="b738c32be44272442962e986db9a0980aba6f5fb" translate="yes" xml:space="preserve">
          <source>At the start I also mentioned internationalization considerations. Some of these are very difficult to account for because they require knowledge not only of &lt;em&gt;what&lt;/em&gt; language is being used, but also may require specific knowledge of the words in the language. For example, the Irish digraph &quot;mb&quot; capitalizes as &quot;mB&quot; at the start of a word. Another example, the German eszett, never begins a word (afaik), but still helps illustrate the problem. The lowercase eszett (&amp;ldquo;&amp;szlig;&amp;rdquo;) capitalizes to &amp;ldquo;SS,&amp;rdquo; but  &amp;ldquo;SS&amp;rdquo; could lowercase to either &amp;ldquo;&amp;szlig;&amp;rdquo; or &amp;ldquo;ss&amp;rdquo; &amp;mdash; you require out-of-band knowledge of the German language to know which is correct!</source>
          <target state="translated">在开始时，我还提到了国际化的考虑。 其中一些非常难以解释，因为它们不仅需要了解所使用的语言，还可能需要特定语言的知识。 例如，爱尔兰语字母&amp;ldquo; mb&amp;rdquo;在单词开头大写为&amp;ldquo; mB&amp;rdquo;。 另一个示例，德语eszett，从不以单词开头（afaik），但仍有助于说明问题。 小写的eszett（&amp;ldquo;&amp;szlig;&amp;rdquo;）大写为&amp;ldquo; SS&amp;rdquo;，但是&amp;ldquo; SS&amp;rdquo;可以小写为&amp;ldquo;&amp;szlig;&amp;rdquo;或&amp;ldquo; ss&amp;rdquo;-您需要带德语的带外知识才能知道哪种正确！</target>
        </trans-unit>
        <trans-unit id="cdcb4da1ad0efcd4394c1ed55e3b70f42e24c0b4" translate="yes" xml:space="preserve">
          <source>At the time of writing (Feb 2020), Firefox/Spidermonkey has not yet implemented any of the RegExp features introduced in the last two years*****. You can check the current status of this feature at the &lt;a href=&quot;http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Unicode_Property_Escapes&quot;&gt;Kangax compat table&lt;/a&gt;. Babel is able to compile RegExp literals with property references to equivalent patterns without them, but be aware that the resulting code may be enormous.</source>
          <target state="translated">在撰写本文时（2020年2月），Firefox / Spidermonkey尚未实现过去两年中引入的任何RegExp功能*****。 您可以在&lt;a href=&quot;http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Unicode_Property_Escapes&quot;&gt;Kangax兼容表中&lt;/a&gt;查看此功能的当前状态。 Babel能够使用对等效模式的属性引用来编译RegExp常量，而无需使用等效模式，但是请注意，生成的代码可能非常庞大。</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="c28281d29953dd5bbfe8e32fb31c9ecf6084a1d8" translate="yes" xml:space="preserve">
          <source>CSS only</source>
          <target state="translated">仅CSS</target>
        </trans-unit>
        <trans-unit id="2f3f9c86a9d991e58459d1d1c5a24e5332a22188" translate="yes" xml:space="preserve">
          <source>Capitalize the first letter of all words in a string:</source>
          <target state="translated">将字符串中所有单词的第一个字母大写。</target>
        </trans-unit>
        <trans-unit id="a69da05af469308b462024895eb097e9dd01295b" translate="yes" xml:space="preserve">
          <source>Checkout this solution:</source>
          <target state="translated">看一下这个解决方案。</target>
        </trans-unit>
        <trans-unit id="0ab8dd120611ec6f99b50238ac21e32cacf65d79" translate="yes" xml:space="preserve">
          <source>Created with &lt;a href=&quot;https://jsbench.me/&quot;&gt;JSBench.me&lt;/a&gt; on Google Chrome 57.</source>
          <target state="translated">在Google Chrome 57上使用&lt;a href=&quot;https://jsbench.me/&quot;&gt;JSBench.me&lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="38eff30dd7da438c13e56e85015681e989636246" translate="yes" xml:space="preserve">
          <source>Despite being called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter&quot;&gt;&lt;code&gt;::first-letter&lt;/code&gt;&lt;/a&gt;, it applies to the first &lt;strong&gt;character&lt;/strong&gt;, i.e. in case of string &lt;code&gt;%a&lt;/code&gt;, this selector would apply to &lt;code&gt;%&lt;/code&gt; and as such &lt;code&gt;a&lt;/code&gt; would not be capitalized.</source>
          <target state="translated">尽管被称为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::first-letter&quot;&gt; &lt;code&gt;::first-letter&lt;/code&gt; &lt;/a&gt; ，但它适用于第一个&lt;strong&gt;字符&lt;/strong&gt; ，即在字符串 &lt;code&gt;%a&lt;/code&gt; 的情况下，此选择器将适用于 &lt;code&gt;%&lt;/code&gt; ，因此 &lt;code&gt;a&lt;/code&gt; 将不被大写。</target>
        </trans-unit>
        <trans-unit id="b53015fce6abe5786b7601af4988a62b9ce4c6c7" translate="yes" xml:space="preserve">
          <source>ES2015 one-liner</source>
          <target state="translated">ES2015单行本</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="5efc2d2017db789ed39b3f6945df2de895bab671" translate="yes" xml:space="preserve">
          <source>For another case I need it to capitalize the first letter and lowercase the rest. The following cases made me change this function:</source>
          <target state="translated">对于另一种情况,我需要它将第一个字母大写,其余的字母小写。下面的情况让我改变了这个功能。</target>
        </trans-unit>
        <trans-unit id="fed1125217a67648d6e1fabd36895a4669511da3" translate="yes" xml:space="preserve">
          <source>For even more internationalization options, please see the &lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;original answer below&lt;/a&gt;.</source>
          <target state="translated">有关更多国际化选项，请参见&lt;a href=&quot;https://stackoverflow.com/a/53930826/38522&quot;&gt;下面&lt;/a&gt;的原始答案 。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="fd7ea24cff598ca7d051a4d8d628b73aae9173a8" translate="yes" xml:space="preserve">
          <source>For longer strings, this is probably not terribly efficient*** &amp;mdash; we don&amp;rsquo;t really need to iterate the remainder. We could use &lt;code&gt;String.prototype.codePointAt&lt;/code&gt; to get at that first (possible) letter, but we&amp;rsquo;d still need to determine where the slice should begin. One way to avoid iterating the remainder would be to test whether the first codepoint is outside the BMP; if it isn&amp;rsquo;t, the slice begins at 1, and if it is, the slice begins at 2.</source>
          <target state="translated">对于更长的字符串，这可能效率不高***-我们真的不需要迭代其余部分。 我们可以使用 &lt;code&gt;String.prototype.codePointAt&lt;/code&gt; 来获得第一个（可能的）字母，但是我们仍然需要确定切片应从何处开始。 避免迭代其余部分的一种方法是测试第一个代码点是否在BMP之外。 如果不是，则切片从1开始，如果是，则切片从2开始。</target>
        </trans-unit>
        <trans-unit id="b63decbd83c1b992eb529da43269358b03bcf440" translate="yes" xml:space="preserve">
          <source>From ES2015 on, dealing with this became a bit easier. &lt;code&gt;String.prototype[@@iterator]&lt;/code&gt; yields strings corresponding to code points**. So for example, we can do this:</source>
          <target state="translated">从ES2015开始，处理此问题变得更加容易。 &lt;code&gt;String.prototype[@@iterator]&lt;/code&gt; 产生与代码点**相对应的字符串。 因此，例如，我们可以这样做：</target>
        </trans-unit>
        <trans-unit id="74c10e52cd68360f7bdbca8c52fc4938b2eb4e9a" translate="yes" xml:space="preserve">
          <source>Here are the fastest methods based on &lt;a href=&quot;http://jsperf.com/capitalize-the-first-letter-of-string-in-javascript/2&quot;&gt;this jsperf test&lt;/a&gt; (ordered from fastest to slowest).</source>
          <target state="translated">这是基于&lt;a href=&quot;http://jsperf.com/capitalize-the-first-letter-of-string-in-javascript/2&quot;&gt;此jsperf测试&lt;/a&gt;的最快方法（从最快到最慢的顺序）。</target>
        </trans-unit>
        <trans-unit id="36ec1b221f06d0c0a874dc6ea003751af9a2707b" translate="yes" xml:space="preserve">
          <source>Here is a function called &lt;strong&gt;ucfirst()&lt;/strong&gt; (short for &quot;upper case first letter&quot;):</source>
          <target state="translated">这是一个称为&lt;strong&gt;ucfirst（）&lt;/strong&gt;的函数&lt;strong&gt;（&lt;/strong&gt; &amp;ldquo;大写首字母&amp;rdquo;的缩写）：</target>
        </trans-unit>
        <trans-unit id="f63bba80779b9f905ca9275279f4d3217ddae10f" translate="yes" xml:space="preserve">
          <source>Here is a shortened version of the popular answer that gets the first letter by treating the string as an array:</source>
          <target state="translated">这里是一个简化版的流行答案,通过把字符串当作数组来获取第一个字母。</target>
        </trans-unit>
        <trans-unit id="8de7492950ddcf0f0806df769b72006c014004f5" translate="yes" xml:space="preserve">
          <source>Here's a more object-oriented approach:</source>
          <target state="translated">这里有一个更加面向对象的方法。</target>
        </trans-unit>
        <trans-unit id="26ec945f349fe1c8f7b8bfe93fdfedd83c5c2657" translate="yes" xml:space="preserve">
          <source>How do I make the first letter of a string uppercase in JavaScript</source>
          <target state="translated">如何在JavaScript中使字符串的第一个字母大写?</target>
        </trans-unit>
        <trans-unit id="41600359895123b43257f89a1713e3beaa5909e0" translate="yes" xml:space="preserve">
          <source>How do I make the first letter of a string uppercase, but not change the case of any of the other letters?</source>
          <target state="translated">如何使一个字符串的第一个字母大写,但不改变其他字母的大小写?</target>
        </trans-unit>
        <trans-unit id="2471381604a49f6d0e0c580d6ed33d04e7bbf029" translate="yes" xml:space="preserve">
          <source>However, some cased characters fall outside the BMP (basic multilingual plane, code points U+0 to U+FFFF). For example take this Deseret text:</source>
          <target state="translated">但是,有些字符在BMP(基本多语言平面,代码点U+0到U+FFFF)之外。例如,以这个Deseret文本为例。</target>
        </trans-unit>
        <trans-unit id="ab4561105ba74782ce146baef49296c05955c8d5" translate="yes" xml:space="preserve">
          <source>I didn&amp;rsquo;t see any mention in the existing answers of issues related to &lt;s&gt;astral plane code points or&lt;/s&gt; internationalization. &amp;ldquo;Uppercase&amp;rdquo; doesn&amp;rsquo;t mean the same thing in every language using a given script.</source>
          <target state="translated">我在现有答案中没有看到与&lt;s&gt;星体平面代码点或&lt;/s&gt;国际化有关的任何问题。 使用给定脚本，&amp;ldquo;大写&amp;rdquo;在每种语言中并不意味着相同。</target>
        </trans-unit>
        <trans-unit id="57568b656d3bfd8b25836b6e404e950afe5e8ed8" translate="yes" xml:space="preserve">
          <source>I found this arrow function easiest. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;Replace&lt;/a&gt; matches the first letter character (&lt;code&gt;\w&lt;/code&gt;) of your string and converts it to uppercase. Nothing fancier necessary.</source>
          <target state="translated">我发现此箭头功能最简单。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;Replace&lt;/a&gt;匹配字符串的第一个字母字符（ &lt;code&gt;\w&lt;/code&gt; ），并将其转换为大写。 不需要任何爱好者。</target>
        </trans-unit>
        <trans-unit id="fc8ad3518c2d8b9e7e804ae69020ba2d72f9b38e" translate="yes" xml:space="preserve">
          <source>I went with name &lt;code&gt;capitalizeFirstChar&lt;/code&gt; instead of &lt;code&gt;capitalizeFirstLetter&lt;/code&gt;, because OP didn't asked for code that capitalizes the first letter in the entire string, but the very first char (if it's letter, of course).</source>
          <target state="translated">我使用 &lt;code&gt;capitalizeFirstChar&lt;/code&gt; 名字大写，而不是 &lt;code&gt;capitalizeFirstLetter&lt;/code&gt; ，因为OP并不要求使用代码来大写整个字符串中的第一个字母，而是大写第一个字符（当然，如果是字母）。</target>
        </trans-unit>
        <trans-unit id="12beaec08e35b5059fe37bcbcaff9243ba2cb242" translate="yes" xml:space="preserve">
          <source>If you  want to reuse it over and over, it's better attach it to javascript native String, so something like below:</source>
          <target state="translated">如果你想重复使用,最好是将其附加到javascript原生String中,如下图所示。</target>
        </trans-unit>
        <trans-unit id="5595b4caaf07e85122b5dcf531caac0aed37a182" translate="yes" xml:space="preserve">
          <source>If you are wanting to reformat all-caps text, you might want to modify the other examples as such:</source>
          <target state="translated">如果你想对全大写的文本进行重新格式化,你可能会想把其他的例子修改成这样。</target>
        </trans-unit>
        <trans-unit id="391b6c39ae6bd183048d53c4501002d9557638f3" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; or &lt;a href=&quot;http://lodash.com/&quot;&gt;Lo-Dash&lt;/a&gt;, the &lt;a href=&quot;https://github.com/epeli/underscore.string&quot;&gt;underscore.string&lt;/a&gt; library provides string extensions, including capitalize:</source>
          <target state="translated">如果您使用&lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt;或&lt;a href=&quot;http://lodash.com/&quot;&gt;Lo-Dash&lt;/a&gt; ，则&lt;a href=&quot;https://github.com/epeli/underscore.string&quot;&gt;underscore.string&lt;/a&gt;库提供字符串扩展名，包括大写：</target>
        </trans-unit>
        <trans-unit id="3580d94edc18905a809fe61049b66ac884fd95f0" translate="yes" xml:space="preserve">
          <source>If you want to work with Unicode code points instead of code units (for example to handle Unicode characters outside of the Basic Multilingual Plane) you can leverage the fact that &lt;code&gt;String#[@iterator]&lt;/code&gt; works with code points, and you can use &lt;code&gt;toLocaleUpperCase&lt;/code&gt; to get locale-correct uppercasing:</source>
          <target state="translated">如果要使用Unicode代码点而不是代码单元（例如，在基本多语言平面之外处理Unicode字符），则可以利用 &lt;code&gt;String#[@iterator]&lt;/code&gt; 与代码点一起使用的事实，并且可以使用 &lt;code&gt;toLocaleUpperCase&lt;/code&gt; 来处理获取正确的语言环境大写：</target>
        </trans-unit>
        <trans-unit id="520fb73d2d3cb4c07939630bd614bc3b08d45c7a" translate="yes" xml:space="preserve">
          <source>If you're already (or considering) using &lt;code&gt;lodash&lt;/code&gt;, the solution is easy:</source>
          <target state="translated">如果您已经（或正在考虑）使用 &lt;code&gt;lodash&lt;/code&gt; ，则解决方案很简单：</target>
        </trans-unit>
        <trans-unit id="4ec057c220d248000ac866fd08c88dfedb4df649" translate="yes" xml:space="preserve">
          <source>If you're interested in the performance of a few different methods posted:</source>
          <target state="translated">如果你对几种不同的方法有兴趣的话,可以贴出一些不同的表现。</target>
        </trans-unit>
        <trans-unit id="22ed663eee054bfc4462b75cb3de053fa66754b0" translate="yes" xml:space="preserve">
          <source>In CSS:</source>
          <target state="translated">在CSS中。</target>
        </trans-unit>
        <trans-unit id="513ed99d77b99d0268fb8f84f8be5411764fabcb" translate="yes" xml:space="preserve">
          <source>In IE9+ or IE5.5+ it's supported in legacy notation with only one colon (&lt;code&gt;:first-letter&lt;/code&gt;).</source>
          <target state="translated">在IE9 +或IE5.5 +中，仅使用一个冒号（ &lt;code&gt;:first-letter&lt;/code&gt; ）的传统表示法即可支持。</target>
        </trans-unit>
        <trans-unit id="2c731feb5a1bab9995bffb541f3ec85ca6616ec0" translate="yes" xml:space="preserve">
          <source>In a browser, the user&amp;rsquo;s most-preferred language tag is indicated by &lt;code&gt;navigator.language&lt;/code&gt;, a list in order of preference is found at &lt;code&gt;navigator.languages&lt;/code&gt;, and a given DOM element&amp;rsquo;s language can be obtained (usually) with &lt;code&gt;Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE&lt;/code&gt; in multilanguage documents.</source>
          <target state="translated">在浏览器中，用户最喜欢的语言标签由 &lt;code&gt;navigator.language&lt;/code&gt; 指示，在 &lt;code&gt;navigator.languages&lt;/code&gt; 中找到按优先顺序排列的列表，并且可以（通常）使用 &lt;code&gt;Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE&lt;/code&gt; 多语言文档中的YOUR_DEFAULT_HERE 。</target>
        </trans-unit>
        <trans-unit id="3e7be93047b07099fd9e6aeac9ef8367e4ad1893" translate="yes" xml:space="preserve">
          <source>In agents which support Unicode property character classes in RegExp, which were introduced in ES2018, we can clean stuff up further by directly expressing what characters we&amp;rsquo;re interested in:</source>
          <target state="translated">在ES2018中引入的在RegExp中支持Unicode属性字符类的代理中，我们可以通过直接表达我们感兴趣的字符来进一步清理内容：</target>
        </trans-unit>
        <trans-unit id="237f8c8207eb9f09670dd34797c5476976d0f091" translate="yes" xml:space="preserve">
          <source>In all likelihood, people asking this question will not be concerned with Deseret capitalization or internationalization. But it&amp;rsquo;s good to be aware of these issues because there&amp;rsquo;s a good chance you&amp;rsquo;ll encounter them eventually even if they aren&amp;rsquo;t concerns presently. They&amp;rsquo;re not &amp;ldquo;edge&amp;rdquo; cases, or rather, they&amp;rsquo;re not &lt;em&gt;by-definition&lt;/em&gt; edge cases &amp;mdash; there&amp;rsquo;s a whole country where most people speak Turkish, anyway, and conflating code units with codepoints is a fairly common source of bugs (especially with regard to emoji). Both strings and language are pretty complicated!</source>
          <target state="translated">提出这个问题的人极有可能与Deseret的大写字母或国际化无关。 但是，意识到这些问题是一件好事，因为即使现在不关心这些问题，您也很有可能最终会遇到它们。 它们不是&amp;ldquo;边缘&amp;rdquo;情况，或更确切地说，它们不是&lt;em&gt;按定义的&lt;/em&gt;边缘情况&amp;ndash;在整个国家，大多数人还是会说土耳其语，将代码单元与代码点合并是一个相当常见的错误来源（尤其是与关于表情符号）。 字符串和语言都非常复杂！</target>
        </trans-unit>
        <trans-unit id="b9215739ff07c5a531e3c157e3d8b7debaf7f595" translate="yes" xml:space="preserve">
          <source>In the benchmark I performed there was no significant difference between &lt;code&gt;string.charAt(0)&lt;/code&gt; and &lt;code&gt;string[0]&lt;/code&gt;. Note however, that &lt;code&gt;string[0]&lt;/code&gt; would be &lt;code&gt;undefined&lt;/code&gt; for empty string, so it should be rewritten to &lt;code&gt;string &amp;amp;&amp;amp; string[0]&lt;/code&gt;, which is way too verbose, compared to the alternative.</source>
          <target state="translated">在我执行的基准测试中， &lt;code&gt;string.charAt(0)&lt;/code&gt; 和 &lt;code&gt;string[0]&lt;/code&gt; 之间没有显着差异。 但是请注意，对于空字符串， &lt;code&gt;string[0]&lt;/code&gt; 将是 &lt;code&gt;undefined&lt;/code&gt; 的，因此应将其重写为 &lt;code&gt;string &amp;amp;&amp;amp; string[0]&lt;/code&gt; ，与替代方法相比，它太冗长了。</target>
        </trans-unit>
        <trans-unit id="aa4f881902e40d1677a1a09723b87da7f2131a80" translate="yes" xml:space="preserve">
          <source>It happens to be that UTF-16 code units are 1:1 with USV code points within two ranges, U+0 to U+D7FF and U+E000 to U+FFFF inclusive. Most cased characters fall into those two ranges, but not all of them.</source>
          <target state="translated">恰好UTF-16编码单位是1:1,USV编码点在两个范围内,U+0到U+D7FF和U+E000到U+FFFF两个范围内。大多数外壳字符都属于这两个范围,但不是全部。</target>
        </trans-unit>
        <trans-unit id="cfcdd40d2baaffb7a5e373b22106b786580f61af" translate="yes" xml:space="preserve">
          <source>It seems to be easier in CSS:</source>
          <target state="translated">这在CSS中似乎更容易一些。</target>
        </trans-unit>
        <trans-unit id="be0d696fbec75b29d058a2ffde594a36cc305bd4" translate="yes" xml:space="preserve">
          <source>It will output &lt;code&gt;&quot;Ruby java&quot;&lt;/code&gt; to the console.</source>
          <target state="translated">它将向控制台输出 &lt;code&gt;&quot;Ruby java&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="753fc3e18b8a5011f782214d0491ba42959f8ddc" translate="yes" xml:space="preserve">
          <source>It works by splitting the string into two pieces.  On the first line it pulls out &lt;strong&gt;firstLetter&lt;/strong&gt; and then on the second line it capitalises &lt;strong&gt;firstLetter&lt;/strong&gt; by calling &lt;strong&gt;firstLetter.toUpperCase()&lt;/strong&gt; and joins it with the rest of the string, which is found by calling &lt;strong&gt;str.substr(1)&lt;/strong&gt;.</source>
          <target state="translated">它通过将字符串分成两部分来工作。 在第一行中，它首先提取&lt;strong&gt;firstLetter&lt;/strong&gt; ，然后在第二行中，它通过调用&lt;strong&gt;firstLetter.toUpperCase（）&lt;/strong&gt;将大写的&lt;strong&gt;首&lt;/strong&gt;字母&lt;strong&gt;大写&lt;/strong&gt; ，并将其与字符串的其余部分&lt;strong&gt;（&lt;/strong&gt;通过调用&lt;strong&gt;str.substr&lt;/strong&gt; &lt;strong&gt;（1）&lt;/strong&gt;找到&lt;strong&gt;）连接起来&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="39cf6e340b712fcaeefaccd6c9cae7c6fb438b3b" translate="yes" xml:space="preserve">
          <source>It's always better to handle these kinds of stuff using &lt;strong&gt;CSS first&lt;/strong&gt;, in general, if you can solve something using CSS, go for that first, then try JavaScript to solve your problems, so in this case try using &lt;code&gt;:first-letter&lt;/code&gt; in CSS and apply &lt;code&gt;text-transform:capitalize;&lt;/code&gt;</source>
          <target state="translated">通常，最好先使用&lt;strong&gt;CSS&lt;/strong&gt;处理这类事情，通常，如果您可以使用CSS解决某些问题，请先解决该问题，然后尝试使用JavaScript解决问题，因此在这种情况下，请尝试在CSS中使用 &lt;code&gt;:first-letter&lt;/code&gt; 应用 &lt;code&gt;text-transform:capitalize;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68cebc3a030d29b43fc7340eaf94a510388b167b" translate="yes" xml:space="preserve">
          <source>Most of the proposed functions look like this:</source>
          <target state="translated">大多数建议的功能看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="bd0ec7f92d0013f9249f7d0c47b7dbfe0e9eaf1d" translate="yes" xml:space="preserve">
          <source>See their docs: &lt;a href=&quot;https://lodash.com/docs#capitalize&quot;&gt;https://lodash.com/docs#capitalize&lt;/a&gt;</source>
          <target state="translated">查看他们的文档： &lt;a href=&quot;https://lodash.com/docs#capitalize&quot;&gt;https&lt;/a&gt; : //lodash.com/docs#capitalize</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">显示代码片段</target>
        </trans-unit>
        <trans-unit id="7125002cd82871109849d7c7802837b04e3aa758" translate="yes" xml:space="preserve">
          <source>Since there are numerous answers, but none in ES2015 that would solve original problem efficiently, I came up with the following:</source>
          <target state="translated">由于答案很多,但在ES2015中没有一个能有效解决原问题的答案,所以我想出了下面的答案。</target>
        </trans-unit>
        <trans-unit id="a05e8ccd4f0db9fa8ab4b2d4f1e59cc14da07156" translate="yes" xml:space="preserve">
          <source>So try creating a class for that, so you can use it globally, for example: &lt;code&gt;.first-letter-uppercase&lt;/code&gt; and add something like below in your CSS:</source>
          <target state="translated">因此，请尝试为此创建一个类，以便可以在全局范围内使用它，例如： &lt;code&gt;.first-letter-uppercase&lt;/code&gt; 并在CSS中添加以下内容：</target>
        </trans-unit>
        <trans-unit id="1dc1f21e14a758a9bf27e090a7e7aff5d2f7c19a" translate="yes" xml:space="preserve">
          <source>Some other answers modify &lt;code&gt;String.prototype&lt;/code&gt; (this answer used to as well), but I would advise against this now due to maintainability (hard to find out where the function is being added to the &lt;code&gt;prototype&lt;/code&gt; and could cause conflicts if other code uses the same name / a browser adds a native function with that same name in future).</source>
          <target state="translated">其他一些答案修改了 &lt;code&gt;String.prototype&lt;/code&gt; （这个答案也曾经使用过），但是由于可维护性，我现在不建议这样做（很难找出将函数添加到 &lt;code&gt;prototype&lt;/code&gt; ，如果其他代码使用相同的代码，可能会导致冲突。名称/浏览器，将来会添加具有相同名称的本机函数）。</target>
        </trans-unit>
        <trans-unit id="f328eb536a4786b3e3cffb9fe5ba8a131e439b94" translate="yes" xml:space="preserve">
          <source>Thanks J-P for the aclaration.</source>
          <target state="translated">谢谢J-P的解释。</target>
        </trans-unit>
        <trans-unit id="e7e02386fc0fdd5750e124eedc2fe82fb16c6cbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ucfirst&lt;/code&gt; function works if you do it like this.</source>
          <target state="translated">如果您这样做， &lt;code&gt;ucfirst&lt;/code&gt; 函数将起作用。</target>
        </trans-unit>
        <trans-unit id="f8d4f74a2fbde727e6e72b8c96f5adb95eabac25" translate="yes" xml:space="preserve">
          <source>The basic solution is:</source>
          <target state="translated">基本的解决方案是:</target>
        </trans-unit>
        <trans-unit id="ca5df1b84c287b849617bdac4e324fb5a89cfdb4" translate="yes" xml:space="preserve">
          <source>The first character here fails to capitalize because the array-indexed properties of strings don&amp;rsquo;t access &amp;ldquo;characters&amp;rdquo; or code points*. They access UTF-16 code units. This is true also when slicing &amp;mdash; the index values point at code units.</source>
          <target state="translated">这里的第一个字符不能大写，因为字符串的数组索引属性无法访问&amp;ldquo;字符&amp;rdquo;或代码点*。 他们访问UTF-16代码单元。 切片时也是如此&amp;mdash;索引值指向代码单位。</target>
        </trans-unit>
        <trans-unit id="3e7ba471ab8219d28d83cb805cb394c50a047c08" translate="yes" xml:space="preserve">
          <source>The most famous example of these kinds of issues, probably, is Turkish. In Turkish Latin, the capital form of i is İ, while the lowercase form of I is ı &amp;mdash; they&amp;rsquo;re two different letters. Fortunately we do have a way to account for this:</source>
          <target state="translated">这类问题中最著名的例子就是土耳其语。 在土耳其语拉丁语中，i的大写形式为İ，而I的小写形式为ı，它们是两个不同的字母。 幸运的是，我们确实可以解决这个问题：</target>
        </trans-unit>
        <trans-unit id="4c47e3933006e2a994f15b0b8d727bc485f4d3ad" translate="yes" xml:space="preserve">
          <source>There is a very simple way to implement it by &lt;strong&gt;replace&lt;/strong&gt;. For ECMAScript&amp;nbsp;6:</source>
          <target state="translated">有一个非常简单的方法可以通过&lt;strong&gt;replace&lt;/strong&gt;实现它。 对于ECMAScript 6：</target>
        </trans-unit>
        <trans-unit id="04f622e4b19164c4d7616ea7f0401578b5a965de" translate="yes" xml:space="preserve">
          <source>This could be tweaked a bit to also handle capitalizing multiple words in a string with fairly good accuracy. The &lt;code&gt;CWU&lt;/code&gt; or &lt;a href=&quot;https://unicode.org/reports/tr44/#CWU&quot;&gt;Changes_When_Uppercased&lt;/a&gt; character property matches all code points which, well, change when uppercased. We can try this out with a titlecased digraph characters like the Dutch &lt;a href=&quot;https://en.wikipedia.org/wiki/IJ_(digraph)&quot;&gt;ĳ&lt;/a&gt; for example:</source>
          <target state="translated">可以进行一些微调，以同样准确地处理字符串中多个单词的大写。 &lt;code&gt;CWU&lt;/code&gt; 或&lt;a href=&quot;https://unicode.org/reports/tr44/#CWU&quot;&gt;Changes_When_Uppercased&lt;/a&gt;字符属性与所有代码点匹配，这些代码点大写时也会发生变化。 我们可以尝试使用带有标题的双色字母字符（例如Dutchĳ）来进行尝试：</target>
        </trans-unit>
        <trans-unit id="aaf0e7360a18b0ecd99a513342639b5cd16aa14e" translate="yes" xml:space="preserve">
          <source>This is a text string =&amp;gt; This Is A Text String</source>
          <target state="translated">这是一个文本字符串=&amp;gt;这是一个文本字符串</target>
        </trans-unit>
        <trans-unit id="445a7900debb9aa27ba0234cd7efda1545c51c28" translate="yes" xml:space="preserve">
          <source>This is from &lt;em&gt;&lt;a href=&quot;http://www.w3schools.com/cssref/pr_text_text-transform.asp&quot;&gt;CSS text-transform Property&lt;/a&gt;&lt;/em&gt; (at &lt;a href=&quot;http://en.wikipedia.org/wiki/W3Schools&quot;&gt;W3Schools&lt;/a&gt;).</source>
          <target state="translated">这是来自&lt;em&gt;&lt;a href=&quot;http://www.w3schools.com/cssref/pr_text_text-transform.asp&quot;&gt;CSS文本转换属性&lt;/a&gt;&lt;/em&gt; （位于&lt;a href=&quot;http://en.wikipedia.org/wiki/W3Schools&quot;&gt;W3Schools&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c6f3cfe2c963966513eb01910fe27bfe53212f39" translate="yes" xml:space="preserve">
          <source>This will ensure that the following text is changed:</source>
          <target state="translated">这样一来,就可以保证下面的文字有了变化。</target>
        </trans-unit>
        <trans-unit id="0af318f5e656024280a36dcfb0426885a76eff9c" translate="yes" xml:space="preserve">
          <source>To avoid &lt;code&gt;undefined&lt;/code&gt; for empty strings (see &lt;a href=&quot;https://stackoverflow.com/questions/1026069/capitalize-the-first-letter-of-string-in-javascript/7224605?noredirect=1#comment40995528_7224605&quot;&gt;@njzk2's comment below&lt;/a&gt;), you can check for an empty string:</source>
          <target state="translated">为了避免 &lt;code&gt;undefined&lt;/code&gt; 空字符串（请参见&lt;a href=&quot;https://stackoverflow.com/questions/1026069/capitalize-the-first-letter-of-string-in-javascript/7224605?noredirect=1#comment40995528_7224605&quot;&gt;下面的@ njzk2的注释&lt;/a&gt; ），您可以检查空字符串：</target>
        </trans-unit>
        <trans-unit id="7545eb65f39400b816765aedda58dcaf2245938f" translate="yes" xml:space="preserve">
          <source>Update Nov.2016 (ES6), just for FUN :</source>
          <target state="translated">Update Nov.2016 (ES6),just for FUN :</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="438b77c967ff84de26b6c856e0dbc9c0ccb11946" translate="yes" xml:space="preserve">
          <source>Vanilla js for first upper case:</source>
          <target state="translated">第一大写的Vanilla js。</target>
        </trans-unit>
        <trans-unit id="cc356c06beeecbb1483af35dc9f41fbcb69e577a" translate="yes" xml:space="preserve">
          <source>We can also make this work in ES5 and below by taking that logic a bit further if necessary. There are no intrinsic methods in ES5 for working with codepoints, so we have to manually test whether the first code unit is a surrogate****:</source>
          <target state="translated">如果有必要,我们也可以在ES5及以下版本中,通过将这个逻辑再往前走一点,就可以实现这个功能。在ES5中,没有固有的方法来处理代码点,所以我们必须手动测试第一个代码单元是否是代用******。</target>
        </trans-unit>
        <trans-unit id="38598e2d769aafd63e8b0ada676593eea8abbce4" translate="yes" xml:space="preserve">
          <source>We could get the first character with one of my favorite &lt;code&gt;RegExp&lt;/code&gt;, looks like a cute smiley: &lt;code&gt;/^./&lt;/code&gt;</source>
          <target state="translated">我们可以使用我最喜欢的 &lt;code&gt;RegExp&lt;/code&gt; 来获得第一个字符，它看起来像一个可爱的笑脸： &lt;code&gt;/^./&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80c2861bacbf5087e7a78a28702e92c207722448" translate="yes" xml:space="preserve">
          <source>With the expected output being:</source>
          <target state="translated">预期产出为:</target>
        </trans-unit>
        <trans-unit id="0728cce84a033f171749d6217a9b0b732df74446" translate="yes" xml:space="preserve">
          <source>You can capitalise a string by calling &lt;strong&gt;ucfirst(&quot;some string&quot;)&lt;/strong&gt; -- for example,</source>
          <target state="translated">您可以通过调用&lt;strong&gt;ucfirst（&amp;ldquo; some string&amp;rdquo;）&lt;/strong&gt;来大写字符串，例如，</target>
        </trans-unit>
        <trans-unit id="4f213a95acdcde6d613a25cf52f2b2753c1f8659" translate="yes" xml:space="preserve">
          <source>You can do it in one line like this</source>
          <target state="translated">你可以像这样用一句话就能完成</target>
        </trans-unit>
        <trans-unit id="6c4e71a0412953fe2f3f9b1b1c678eb0f7b05035" translate="yes" xml:space="preserve">
          <source>You might think this would fail for an empty string, and indeed in a language like C you would have to cater for this. However in JavaScript, when you take a substring of an empty string, you just get an empty string back.</source>
          <target state="translated">你可能会认为这对于空字符串来说是失败的,事实上在C语言中,你必须满足这个要求。但是在JavaScript中,当你取一个空字符串的子串时,你只需要返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="d4a9eb672ba09519a041a6378259fc7533179e68" translate="yes" xml:space="preserve">
          <source>You'd call the function, like this:</source>
          <target state="translated">你会调用这个函数,就像这样。</target>
        </trans-unit>
        <trans-unit id="b3de993735805658454ec6a662d98b23e05c1c34" translate="yes" xml:space="preserve">
          <source>_.capitalize(string) Converts first letter of the string to
  uppercase.</source>
          <target state="translated">_.大写(string)将字符串的第一个字母转换成大写。</target>
        </trans-unit>
        <trans-unit id="58ed86c48852b86ec22065963de4717546a22f0f" translate="yes" xml:space="preserve">
          <source>and call it as below:</source>
          <target state="translated">并称其为如下。</target>
        </trans-unit>
        <trans-unit id="5841729c0f596832e8c1fdf28e8579200c954984" translate="yes" xml:space="preserve">
          <source>and call it like:</source>
          <target state="translated">并称其为。</target>
        </trans-unit>
        <trans-unit id="07ca609f2cad16f006215d4b73b16c731cd9ef2e" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;capitalize(&quot;hello&quot;) // Hello&lt;/code&gt;</source>
          <target state="translated">然后 &lt;code&gt;capitalize(&quot;hello&quot;) // Hello&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
