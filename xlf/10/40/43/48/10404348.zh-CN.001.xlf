<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/10404348">
    <body>
      <group id="10404348">
        <trans-unit id="6b1b12e790c4787d3fcf4a86cbac74f401fd5da3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OUTPUT :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;输出：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c72235376d99078e608449c5740fb6f756febb8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table creation and data insertion:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表创建和数据插入：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d95b0a48db8db0c8a3d3af749644083aa0f1f96a" translate="yes" xml:space="preserve">
          <source>Different approach for creating columns string</source>
          <target state="translated">创建列字符串的不同方法</target>
        </trans-unit>
        <trans-unit id="22b22d10199fad2e991da6bab06720836dd3c59f" translate="yes" xml:space="preserve">
          <source>Dynamic SQL PIVOT</source>
          <target state="translated">动态SQL PIVOT</target>
        </trans-unit>
        <trans-unit id="2481e5b07397459d668f9b9cecfe643ad32aeeda" translate="yes" xml:space="preserve">
          <source>Dynamic SQL PIVOT:</source>
          <target state="translated">动态SQL PIVOT。</target>
        </trans-unit>
        <trans-unit id="78efeae9b689544e385dbf2d3fc8acf050def373" translate="yes" xml:space="preserve">
          <source>First and foremost I built this solution to solve a problem a couple of coworkers were having with inconstant and large data sets needing to be pivoted quickly.</source>
          <target state="translated">首先,也是最重要的是,我建立这个解决方案是为了解决几个同事遇到的一个问题,那就是不稳定的大数据集需要快速转换。</target>
        </trans-unit>
        <trans-unit id="27bd68248ee31e3316ae82336154b5086b53df37" translate="yes" xml:space="preserve">
          <source>I know this question is older but I was looking thru the answers and thought that I might be able to expand on the &quot;dynamic&quot; portion of the problem and possibly help someone out.</source>
          <target state="translated">我知道这个问题比较老了,但我在看了一下答案,觉得也许我可以把问题的 &quot;动态 &quot;部分扩展一下,也许可以帮助到别人。</target>
        </trans-unit>
        <trans-unit id="29ed3a73befbdfa4b816d9191e7d2d32ae7cd669" translate="yes" xml:space="preserve">
          <source>I've been tasked with coming up with a means of translating the following data:</source>
          <target state="translated">我的任务是想出一种方法来翻译以下数据。</target>
        </trans-unit>
        <trans-unit id="f700c06766c7d54a2d8f580241d1f3856706f162" translate="yes" xml:space="preserve">
          <source>Lets start with the code to create the stored procedure. This code should work in all versions of SSMS 2005 and above but I have not tested it in 2005 or 2016 but I can not see why it would not work.</source>
          <target state="translated">让我们从创建存储过程的代码开始。这段代码应该可以在所有版本的SSMS 2005及以上版本中工作,但我没有在2005年或2016年的版本中测试过,但我不明白为什么它不能工作。</target>
        </trans-unit>
        <trans-unit id="e5b4b1a4b371092503774a307be0665e1e5194ab" translate="yes" xml:space="preserve">
          <source>Next we will get our data ready for the example. I have taken the data example from the accepted answer with the addition of a couple of data elements to use in this proof of concept to show the varied outputs of the aggregate change.</source>
          <target state="translated">接下来我们将为这个例子准备好数据。我从已接受的答案中提取了数据实例,在这个概念证明中加入了几个数据元素,以显示出汇总变化的输出。</target>
        </trans-unit>
        <trans-unit id="0b097a51197a221cf1bf8b3c7b376e45b49aff2b" translate="yes" xml:space="preserve">
          <source>Obligatory reference to&lt;a href=&quot;http://www.sommarskog.se/dynamic_sql.html&quot;&gt; The Curse and Blessings of Dynamic SQL&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;强制性引用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.sommarskog.se/dynamic_sql.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;动态SQL的诅咒和祝福&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ad13de5cd0e8244d1c31b251ad072f22296a42f" translate="yes" xml:space="preserve">
          <source>Pivots with Dynamic Columns in SQL Server 2005</source>
          <target state="translated">在SQL Server 2005中使用动态列的枢轴</target>
        </trans-unit>
        <trans-unit id="6f0c566d71b15800d15b47f0c350f2065dc8595b" translate="yes" xml:space="preserve">
          <source>Query to generate the exact results which also replaces NULL with zeros:</source>
          <target state="translated">查询生成准确的结果,也可以用零代替NULL。</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="1410432e97c12f1104d9a729286bd2ceeab4b227" translate="yes" xml:space="preserve">
          <source>SQL Server - Dynamic PIVOT Table - SQL Injection</source>
          <target state="translated">SQL Server-动态PIVOT表-SQL注入</target>
        </trans-unit>
        <trans-unit id="f5a4f0886b7755994ab69d208c740bba62adf577" translate="yes" xml:space="preserve">
          <source>SQL Server dynamic PIVOT query</source>
          <target state="translated">SQL Server动态PIVOT查询</target>
        </trans-unit>
        <trans-unit id="d2b6f173055a4d05fc8d71ab5a33c9cc1df75b9f" translate="yes" xml:space="preserve">
          <source>The below code provides the results which replaces &lt;strong&gt;NULL&lt;/strong&gt; to &lt;strong&gt;zero&lt;/strong&gt; in the output.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在下面的代码提供了替换的结果&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;NULL&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;零&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;输出。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d29e4912b9cae7ea236d222c2bccf518b67ab69" translate="yes" xml:space="preserve">
          <source>The blank spots can be NULLs or blanks, either is fine, and the categories would need to be dynamic. Another possible caveat to this is that we'll be running the query in a limited capacity, which means temp tables are out. I've tried to research and have landed on &lt;code&gt;PIVOT&lt;/code&gt; but as I've never used that before I really don't understand it, despite my best efforts to figure it out. Can anyone point me in the right direction?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;空白点可以是NULL或空白，这很好，并且类别必须是动态的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对此的另一个可能的警告是，我们将以有限的容量运行查询，这意味着临时表已用完。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我已经尝试研究并着手研究&lt;/font&gt;&lt;/font&gt; &lt;code&gt;PIVOT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但尽管我已尽力找出&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;答案，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但我从未真正了解它之前从未使用过它。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;谁能指出我正确的方向？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c2bf313c5303630f0e153884422b26d30c8890e" translate="yes" xml:space="preserve">
          <source>The following examples show the varied execution statements showing the varied aggregates as a simple example. I did not opt to change the static, pivot, and value columns to keep the example simple. You should be able to just copy and paste the code to start messing with it yourself</source>
          <target state="translated">下面的例子显示了不同的执行语句,作为一个简单的例子,显示了不同的聚合体。我没有选择改变静态列、透视列和值列,以保持例子的简单。你应该可以直接复制并粘贴代码,然后自己动手操作一下</target>
        </trans-unit>
        <trans-unit id="59021cf6affd8312d35b72ea852497d633025293" translate="yes" xml:space="preserve">
          <source>There's my solution cleaning up the unnecesary null values</source>
          <target state="translated">这就是我的解决方案,清理掉不必要的空值</target>
        </trans-unit>
        <trans-unit id="252b9d8b0ea6bbc7274570b525d0168dc7ded7a4" translate="yes" xml:space="preserve">
          <source>This execution returns the following data sets respectively.</source>
          <target state="translated">此项执行分别返回以下数据集:</target>
        </trans-unit>
        <trans-unit id="df314795f0787c27d40ac024e393792d36f10943" translate="yes" xml:space="preserve">
          <source>This procedure is going to take in the key variables of a pivot statement to dynamically create pivot statements for varying tables, column names and aggregates. The Static column is used as the group by / identity column for the pivot(this can be stripped out of the code if not necessary but is pretty common in pivot statements and was necessary to solve the original issue), the pivot column is where the end resultant column names will be generated from, and the value column is what the aggregate will be applied to. The Table parameter is the name of the table including the schema (schema.tablename) this portion of the code could use some love because it is not as clean as I would like it to be. It worked for me because my usage was not publicly facing and sql injection was not a concern. The Aggregate parameter will accept any standard sql aggregate 'AVG', 'SUM', 'MAX' etc. The code also defaults to MAX as an aggregate this is not necessary but the audience this was originally built for did not understand pivots and were typically using max as an aggregate.</source>
          <target state="translated">这个过程要吸收透视语句中的关键变量,动态地创建不同表、表名和聚合的透视语句。静态列作为数据透视语句的分组(如果没有必要,可以从代码中剥离出来,但这在数据透视语句中很常见,也是解决原始问题的必要条件),数据透视列是最终结果列名的来源,而值列则是聚合的对象。Table参数是表的名称,包括模式(schema.tablename),这部分的代码还需要一些爱护,因为它并不像我希望的那样干净。它对我来说是有效的,因为我的使用方式不是公开的,而且SQL注入也不是一个问题。Aggregate参数将接受任何标准的sql集合'AVG','SUM','MAX'等。代码也默认为MAX作为聚合,这并不是必须的,但最初的受众不理解枢轴,通常使用MAX作为聚合。</target>
        </trans-unit>
        <trans-unit id="93338e5f2fb0f0825e84d9a46510e44c5a2a50bd" translate="yes" xml:space="preserve">
          <source>This solution requires the creation of a stored procedure so if that is out of the question for your needs please stop reading now.</source>
          <target state="translated">这个解决方案需要创建一个存储过程,如果这不符合您的需求,请停止阅读。</target>
        </trans-unit>
        <trans-unit id="2ab66c773b9dadb497bf36a83af266b8b0f57ccc" translate="yes" xml:space="preserve">
          <source>Updated version for SQL Server 2017 using STRING_AGG function to construct the pivot column list:</source>
          <target state="translated">为SQL Server 2017更新版本,使用STRING_AGG函数构造透视列列表。</target>
        </trans-unit>
        <trans-unit id="38e6f51a7808c92e256819a0872b3b689516a843" translate="yes" xml:space="preserve">
          <source>You can achieve this using dynamic TSQL (remember to use QUOTENAME to avoid SQL injection attacks):</source>
          <target state="translated">你可以使用动态的TSQL来实现(记得使用QUOTENAME来避免SQL注入攻击)。</target>
        </trans-unit>
        <trans-unit id="f321bb51407fecc5d2801890431ad1e0f9922dbf" translate="yes" xml:space="preserve">
          <source>into the following:</source>
          <target state="translated">成如下:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
