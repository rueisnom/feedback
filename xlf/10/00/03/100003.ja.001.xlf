<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/100003">
    <body>
      <group id="100003">
        <trans-unit id="75f904e8b7fedc01e237553e4c1e63dc973e6787" translate="yes" xml:space="preserve">
          <source>(A side-note on the contents of the class &lt;code&gt;__dict__&lt;/code&gt;: &lt;code&gt;__module__&lt;/code&gt; is there because classes must know where they are defined, and  &lt;code&gt;__dict__&lt;/code&gt; and &lt;code&gt;__weakref__&lt;/code&gt; are there because we don't define &lt;code&gt;__slots__&lt;/code&gt; - if we &lt;a href=&quot;https://stackoverflow.com/q/472000/541136&quot;&gt;define &lt;code&gt;__slots__&lt;/code&gt;&lt;/a&gt; we'll save a bit of space in the instances, as we can disallow &lt;code&gt;__dict__&lt;/code&gt; and &lt;code&gt;__weakref__&lt;/code&gt; by excluding them. For example:</source>
          <target state="translated">（クラス &lt;code&gt;__dict__&lt;/code&gt; の内容に関する &lt;code&gt;__module__&lt;/code&gt; ： __module__は、クラスがそれらが定義されている場所を知っている必要があるために存在し、 &lt;code&gt;__weakref__&lt;/code&gt; および__weakref__は、 __ slots__を定義していないために存在します &lt;code&gt;__slots__&lt;/code&gt; を&lt;a href=&quot;https://stackoverflow.com/q/472000/541136&quot;&gt;定義する&lt;/a&gt;場合、 &lt;code&gt;__dict__&lt;/code&gt; と &lt;code&gt;__weakref__&lt;/code&gt; を除外することで禁止できるため、インスタンス内のスペース。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="80ce04df15f97539136582b49b933ab604f9103b" translate="yes" xml:space="preserve">
          <source>(I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backwards
compatibility in Python)</source>
          <target state="translated">(同じ関数でも、渡すパラメータによって全く異なる用途が2つあることは愚かなことだと思います。これはPythonの下位互換性の問題です)</target>
        </trans-unit>
        <trans-unit id="2ac0d02e51ef16f7af8ae886bdf0e4fa530c5f5d" translate="yes" xml:space="preserve">
          <source>... but I digress.)</source>
          <target state="translated">...でも余談だけど)</target>
        </trans-unit>
        <trans-unit id="f6ebd068cb008bd8fb59b8b2729d85510c67060a" translate="yes" xml:space="preserve">
          <source>99% of the time you need class alteration, you are better off using these.</source>
          <target state="translated">99%の場合、クラスの変更が必要なので、これらを使用した方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="97c9f0c35f46135bb3f31b3babd294116e47cb9e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&lt;/a&gt; (archived at &lt;a href=&quot;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html（https://web.archive.org/web/20080206005253/http://www.onlamp&lt;/a&gt; &lt;a href=&quot;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;。 com / pub / a / python / 2003/04/17 / metaclasses.html&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="3bdb50500a7c19592bda8809f1f54a3155b055d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclasses&quot;&gt;Here&lt;/a&gt; you can read about how to use metaclasses to customize class construction.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclasses&quot;&gt;ここで&lt;/a&gt;は、メタクラスを使用してクラス構成をカスタマイズする方法について読むことができます。</target>
        </trans-unit>
        <trans-unit id="a50fc3237b1a93efefaaf939cf45f327c9ed165c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__new__&lt;/code&gt; is responsible for the actual creation/modification of the final class.</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; は、最終クラスの実際の作成/変更を担当します。</target>
        </trans-unit>
        <trans-unit id="1a0d6bf17eaa1810f965cf7374357b165ec381aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__prepare__&lt;/code&gt; lets you supply a custom mapping (such as an &lt;code&gt;OrderedDict&lt;/code&gt;) to be used as the namespace while the class is being created.  You must return an instance of whatever namespace you choose.  If you don't implement &lt;code&gt;__prepare__&lt;/code&gt; a normal &lt;code&gt;dict&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;__prepare__&lt;/code&gt; を使用すると、クラスの作成中に名前空間として使用するカスタムマッピング（ &lt;code&gt;OrderedDict&lt;/code&gt; など）を提供できます。 選択したネームスペースのインスタンスを返す必要があります。 &lt;code&gt;__prepare__&lt;/code&gt; を実装しない場合、通常の辞書が使用されます。</target>
        </trans-unit>
        <trans-unit id="023d195e822e75fe65a0924f1427b5fdf01fc5ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__prepare__&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;__prepare__&lt;/code&gt; 、および</target>
        </trans-unit>
        <trans-unit id="7d878c7158652444f7186704c3b33f7141e22209" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; accepts a dictionary to define the attributes of the class. So:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; は、クラスの属性を定義するための辞書を受け入れます。 そう：</target>
        </trans-unit>
        <trans-unit id="5d2e1c2d0bbec05a50948a1721fe99a3b39aa6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is actually a &lt;code&gt;metaclass&lt;/code&gt; -- a class that creates another classes.
Most &lt;code&gt;metaclass&lt;/code&gt; are the subclasses of &lt;code&gt;type&lt;/code&gt;. The &lt;code&gt;metaclass&lt;/code&gt; receives the &lt;code&gt;new&lt;/code&gt; class as its first argument and provide access to class object with details as mentioned below:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; は実際には &lt;code&gt;metaclass&lt;/code&gt; -別のクラスを作成するクラスです。 ほとんどの &lt;code&gt;metaclass&lt;/code&gt; は &lt;code&gt;type&lt;/code&gt; のサブクラスです。 &lt;code&gt;metaclass&lt;/code&gt; は &lt;code&gt;new&lt;/code&gt; クラスを最初の引数として受け取り、以下に示すようにクラスオブジェクトへのアクセスと詳細を提供します。</target>
        </trans-unit>
        <trans-unit id="d9eba8487bfc807b1b32e61a4fcc2b4d4099fc9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is actually its own metaclass. This is not something you could
reproduce in pure Python, and is done by cheating a little bit at the implementation
level.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; は実際には独自のメタクラスです。 これは純粋なPythonで再現できるものではなく、実装レベルで少し不正を行うことによって行われます。</target>
        </trans-unit>
        <trans-unit id="55ff24a1972577aa56cf45cfad50fad1fa3a38ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is its own metaclass. The class of a class is a metaclass-- the body of a class is the arguments passed to the metaclass that is used to construct the class.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; は独自のメタクラスです。 クラスのクラスはメタクラスです。クラスの本体は、クラスの構築に使用されるメタクラスに渡される引数です。</target>
        </trans-unit>
        <trans-unit id="b56139b823c7b0ae94bce907510423f13ee59acc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is the built-in metaclass Python uses, but of course, you can create your
own metaclass.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; はPythonが使用する組み込みメタクラスですが、もちろん、独自のメタクラスを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="2e9b06716bef6742d220da876612fb09c18a1de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; works this way:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; はこのように機能します：</target>
        </trans-unit>
        <trans-unit id="a9b27deb1c48c1688dcbf6153f9703f0928f091b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note, this answer is for Python 2.x as it was written in 2008, metaclasses are slightly different in 3.x.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;この回答はPython 2.xの場合の回答です。2008年に作成されたため、3.xではメタクラスが少し異なります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90461ec79be347574dc9366bf79436c53a18378b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Python Guru Tim Peters&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;パイソングルティムピーターズ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaee62583d5533c9937128f100302a2beb82df5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;attrs&lt;/code&gt;&lt;/strong&gt;: dictionary containing attributes names and values</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;attrs&lt;/code&gt; &lt;/strong&gt; ：属性の名前と値を含む辞書</target>
        </trans-unit>
        <trans-unit id="6b235afc3403ff79e2b3ea50c1ad732bc7d0bc59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;bases&lt;/code&gt;&lt;/strong&gt;: tuple of the parent class (for inheritance, can be empty)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;bases&lt;/code&gt; &lt;/strong&gt; ：親クラスのタプル（継承のため、空にすることができます）</target>
        </trans-unit>
        <trans-unit id="f9b873798f48e29d3714485763a3478bb4a497d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;name&lt;/code&gt;&lt;/strong&gt;: name of the class</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;name&lt;/code&gt; &lt;/strong&gt; ：クラスの名前</target>
        </trans-unit>
        <trans-unit id="f7b324be8699a5976c969c726c75d9164d86dcb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that the magic behaviour that &lt;code&gt;Initialised&lt;/code&gt; gains by having the metaclass &lt;code&gt;init_attributes&lt;/code&gt; is not passed onto a subclass of &lt;code&gt;Initialised&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;メタクラス &lt;code&gt;init_attributes&lt;/code&gt; を持つことによって &lt;code&gt;Initialised&lt;/code&gt; が得る魔法の動作は、 Initializedのサブクラスに渡されないことに注意してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ac292049c7ca4650474b47279520a7d5fdba79f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;:  This example is simple enough it could have also been accomplished with a class decorator, but presumably an actual metaclass would be doing much more.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt; ：この例は非常に単純なので、クラスデコレータを使用して実行することもできますが、実際のメタクラスはさらに多くのことを行うと考えられます。</target>
        </trans-unit>
        <trans-unit id="18064ffdb8c53a2819134a580d83cb2c5c9bab27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 3 update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Python 3アップデート&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fd0a25468fd58988cf36428bbcb7968431bd58e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;type()&lt;/code&gt; of a class is its &lt;em&gt;metaclass&lt;/em&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;クラスの &lt;code&gt;type()&lt;/code&gt; はその&lt;em&gt;メタクラス&lt;/em&gt;です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c766e32141cfa3130f81de60585eea6ff38f65d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This object (the class) is itself capable of creating objects (the instances),
and this is why it's a class&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;このオブジェクト（クラス）自体は、オブジェクト（インスタンス）を作成することができます&lt;/strong&gt; 。 &lt;strong&gt;そのため、これがクラス&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="6c248c325fb87b5d5270a24375d32cd2c9f65122" translate="yes" xml:space="preserve">
          <source>A bare-bones, do-nothing-extra metaclass would like:</source>
          <target state="translated">素っ気ない、何もしないエクストラメタクラスが好きなんだろうな。</target>
        </trans-unit>
        <trans-unit id="92b4c38772f64c8e05f839618ee864357a996cbf" translate="yes" xml:space="preserve">
          <source>A class is to an instance as a metaclass is to a class.</source>
          <target state="translated">メタクラスがクラスにあるように、クラスはインスタンスにあります。</target>
        </trans-unit>
        <trans-unit id="0c27db643b5b5e645284c4cc80a9276398d074a2" translate="yes" xml:space="preserve">
          <source>A class, in Python, is an object, and just like any other object, it is an instance of &quot;something&quot;. This &quot;something&quot; is what is termed as a Metaclass. This metaclass is a special type of class that creates other class's objects. Hence, metaclass is responsible for making new classes. This allows the programmer to customize the way classes are generated.</source>
          <target state="translated">Pythonではクラスはオブジェクトであり、他のオブジェクトと同じように &quot;何か &quot;のインスタンスです。この &quot;何か &quot;はメタクラスと呼ばれるものです。このメタクラスは、他のクラスのオブジェクトを生成する特殊なクラスです。したがって、メタクラスは新しいクラスを作る役割を担っています。これにより、プログラマはクラスの生成方法をカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="98368b5bba9571afb40d6d81649f78ad6a167a0f" translate="yes" xml:space="preserve">
          <source>A dictionary having all class methods and class variables</source>
          <target state="translated">すべてのクラスメソッドとクラス変数を持つ辞書</target>
        </trans-unit>
        <trans-unit id="07bad8c7f891539fd063eae960107658c65808db" translate="yes" xml:space="preserve">
          <source>A metaclass is a class that tells how (some) other class should be created.</source>
          <target state="translated">メタクラスとは、他のクラスがどのように作成されるべきかを指示するクラスのことです。</target>
        </trans-unit>
        <trans-unit id="873c9fcb3efb256f101a6622b416b45f928aa997" translate="yes" xml:space="preserve">
          <source>A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;__new__&lt;/code&gt; methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.</source>
          <target state="translated">メタクラスは最も一般的にクラスファクトリとして使用されます。 クラスを呼び出してオブジェクトを作成すると、Pythonはメタクラスを呼び出して（ 'class'ステートメントを実行すると）新しいクラスを作成します。 したがって、通常の &lt;code&gt;__init__&lt;/code&gt; および &lt;code&gt;__new__&lt;/code&gt; メソッドと組み合わせて、メタクラスを使用すると、新しいクラスをレジストリに登録したり、クラスを完全に別のものに置き換えたりするなど、クラスの作成時に「特別なこと」を実行できます。</target>
        </trans-unit>
        <trans-unit id="3486e865599100d4c2f2690dc8d832dc90595e5c" translate="yes" xml:space="preserve">
          <source>A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.</source>
          <target state="translated">メタクラスとは、クラスのクラスのことです。クラスはクラスのインスタンス(つまりオブジェクト)がどのように振る舞うかを定義するのに対し、メタクラスはクラスがどのように振る舞うかを定義します。クラスはメタクラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="4ea4880d366e98584d6186c7ff37dd31a7e3a934" translate="yes" xml:space="preserve">
          <source>A sample run of:</source>
          <target state="translated">サンプルラン。</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">簡単な例です。</target>
        </trans-unit>
        <trans-unit id="abaef223fba357f5e679cf230585920e62f69619" translate="yes" xml:space="preserve">
          <source>A simple metaclass can address that problem:</source>
          <target state="translated">シンプルなメタクラスはその問題に対処することができます。</target>
        </trans-unit>
        <trans-unit id="f9675ef41670c1a7e08847654b4300f2976b5bd7" translate="yes" xml:space="preserve">
          <source>According to the Python object model, the class is the object, so the class must be an instance of another certain class.
By default, a Python class is instance of the type class. That is, type is metaclass of most of the built-in classes and metaclass of user-defined classes.</source>
          <target state="translated">Pythonのオブジェクトモデルによると、クラスはオブジェクトなので、クラスは別の特定のクラスのインスタンスでなければなりません。デフォルトでは、Pythonのクラスはtypeクラスのインスタンスになります。つまり、typeはほとんどの組み込みクラスのメタクラスであり、ユーザー定義クラスのメタクラスです。</target>
        </trans-unit>
        <trans-unit id="4adff09b65f995e39fb598615865ea22fe246c14" translate="yes" xml:space="preserve">
          <source>An expected usage: &lt;code&gt;__prepare__&lt;/code&gt; a namespace</source>
          <target state="translated">予想される使用法： &lt;code&gt;__prepare__&lt;/code&gt; 名前空間</target>
        </trans-unit>
        <trans-unit id="53beca7540dd22467058afe2ce16662999fefed8" translate="yes" xml:space="preserve">
          <source>And it has approximately the correct &lt;code&gt;repr&lt;/code&gt; (which we can no longer eval unless we can find a way to represent our functions.):</source>
          <target state="translated">そして、それはほぼ正しい &lt;code&gt;repr&lt;/code&gt; を持っています（関数を表す方法を見つけられない限り、これを評価することはできません）。</target>
        </trans-unit>
        <trans-unit id="ce4bfa8f5c082d4fff81df807663be51c7c917c2" translate="yes" xml:space="preserve">
          <source>And now let's create an instance of &lt;code&gt;Class_1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Class_1&lt;/code&gt; 、 Class_1のインスタンスを作成しましょう</target>
        </trans-unit>
        <trans-unit id="5bf68fb2be7839bf9d1dd84adfe71a7440908b18" translate="yes" xml:space="preserve">
          <source>And now we have a record of the order in which these methods (and other class attributes) were created:</source>
          <target state="translated">これで、これらのメソッド(および他のクラス属性)が作成された順番の記録ができました。</target>
        </trans-unit>
        <trans-unit id="4ca06910faa36e6b2502325b8ed3b633d8e2df95" translate="yes" xml:space="preserve">
          <source>And now, an example that actually means something, this will automatically make the variables in the list &quot;attributes&quot; set on the class, and set to None.</source>
          <target state="translated">そして今、実際に何かを意味する例は、これは自動的にリスト内の変数を作成します &quot;属性 &quot;クラスに設定し、Noneに設定します。</target>
        </trans-unit>
        <trans-unit id="9ab311e6c0f38e17cbdcfba4ac88667451f90d25" translate="yes" xml:space="preserve">
          <source>And of course, you can inherit from it, so:</source>
          <target state="translated">もちろん、それを継承することもできますので</target>
        </trans-unit>
        <trans-unit id="72e4dbbed8155cf6d13a6faec1d3c917549c55be" translate="yes" xml:space="preserve">
          <source>And usage:</source>
          <target state="translated">使い方も。</target>
        </trans-unit>
        <trans-unit id="0d4a22c47e425bea8ea588e394d41d40ede76cb4" translate="yes" xml:space="preserve">
          <source>And used as a normal class:</source>
          <target state="translated">そして、普通のクラスとして使用。</target>
        </trans-unit>
        <trans-unit id="d11b95735f7ea9c7ca4cdd3c0cc7d13b93d2b46f" translate="yes" xml:space="preserve">
          <source>And what can create a class? &lt;code&gt;type&lt;/code&gt;, or anything that subclasses or uses it.</source>
          <target state="translated">そして、何がクラスを作成できますか？ &lt;code&gt;type&lt;/code&gt; 、またはそれをサブクラス化または使用するもの。</target>
        </trans-unit>
        <trans-unit id="649539847a08116b173bc0337d0fca037b42617c" translate="yes" xml:space="preserve">
          <source>And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.</source>
          <target state="translated">そして、通常作成されるクラスオブジェクトにメソッドを追加するのと同じように、動的にクラスを作成した後に、さらに多くのメソッドを追加することができます。</target>
        </trans-unit>
        <trans-unit id="530eddb18915c39bc5dcde4a3a20f4402846be8a" translate="yes" xml:space="preserve">
          <source>And, of course, you can create your own &lt;code&gt;metaclass&lt;/code&gt; to define the behaviour of any class that are created using your class.</source>
          <target state="translated">そしてもちろん、独自の &lt;code&gt;metaclass&lt;/code&gt; を作成して、クラスを使用して作成されたクラスの動作を定義できます。</target>
        </trans-unit>
        <trans-unit id="65df52390d32d6445d153fc0a9ee8f28f45c2439" translate="yes" xml:space="preserve">
          <source>Another way of creating a metaclass comprises of 'metaclass' keyword. Define the metaclass as a simple class. In the parameters of inherited class, pass metaclass=metaclass_name</source>
          <target state="translated">メタクラスを作成するもう一つの方法は、'metaclass' キーワードで構成されています。メタクラスを単純なクラスとして定義します。継承クラスのパラメータに metaclass=metaclass_name を渡します。</target>
        </trans-unit>
        <trans-unit id="f4b130a19c5f693fbbf062ec80d3671ef783f1ea" translate="yes" xml:space="preserve">
          <source>Anything that's a subclass of &lt;code&gt;MyType&lt;/code&gt; then gets a class attribute &lt;code&gt;_order&lt;/code&gt; that records the order in which the classes were defined.</source>
          <target state="translated">&lt;code&gt;MyType&lt;/code&gt; のサブクラスであるものはすべて 、クラスが定義された順序を記録するクラス属性 &lt;code&gt;_order&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="39af72b7c646d137c090c578f75c34590856559b" translate="yes" xml:space="preserve">
          <source>As soon as you use the keyword &lt;code&gt;class&lt;/code&gt;, Python executes it and creates
an OBJECT. The instruction</source>
          <target state="translated">キーワード &lt;code&gt;class&lt;/code&gt; を使用するとすぐに、Pythonがそれを実行し、OBJECTを作成します。 指示</target>
        </trans-unit>
        <trans-unit id="2bbce40d7b29697d5feb257ab36b2c9ef937448a" translate="yes" xml:space="preserve">
          <source>As you can see, you have to repeat the name of the attribute twice.  This makes typos possible along with irritating bugs.</source>
          <target state="translated">ご覧のように、属性名を2回繰り返さなければなりません。これにより、イライラするバグと一緒に誤字脱字が可能になります。</target>
        </trans-unit>
        <trans-unit id="9956578f1491cba6ae62da4a5182369af56ec1ea" translate="yes" xml:space="preserve">
          <source>Automatic change of class (on creation) is required</source>
          <target state="translated">クラスの自動変更(作成時)が必要</target>
        </trans-unit>
        <trans-unit id="a0904b4d0a120872451f6708177857cd4876a29b" translate="yes" xml:space="preserve">
          <source>Be careful here that the &lt;code&gt;__metaclass__&lt;/code&gt; attribute will not be inherited, the metaclass of the parent (&lt;code&gt;Bar.__class__&lt;/code&gt;) will be. If &lt;code&gt;Bar&lt;/code&gt; used a &lt;code&gt;__metaclass__&lt;/code&gt; attribute that created &lt;code&gt;Bar&lt;/code&gt; with &lt;code&gt;type()&lt;/code&gt; (and not &lt;code&gt;type.__new__()&lt;/code&gt;), the subclasses will not inherit that behavior.</source>
          <target state="translated">ここで、 &lt;code&gt;__metaclass__&lt;/code&gt; 属性は継承されず、親のメタクラス（ &lt;code&gt;Bar.__class__&lt;/code&gt; ）は継承されることに注意してください。 &lt;code&gt;Bar&lt;/code&gt; が &lt;code&gt;type()&lt;/code&gt; ではなく（ &lt;code&gt;type.__new__()&lt;/code&gt; ではなく） Barを作成する &lt;code&gt;__metaclass__&lt;/code&gt; 属性を使用した場合、サブクラスはその動作を継承しません。</target>
        </trans-unit>
        <trans-unit id="80625100761a15802531450282948dc4d9d74c05" translate="yes" xml:space="preserve">
          <source>Before understanding metaclasses, you need to master classes in Python. And Python has a very peculiar idea of what classes are, borrowed from the Smalltalk language.</source>
          <target state="translated">メタクラスを理解する前に、Pythonでクラスをマスターする必要があります。そして、PythonはSmalltalk言語から借りてきたクラスとは何かという非常に奇妙な考えを持っています。</target>
        </trans-unit>
        <trans-unit id="6a2ed346f5d5ae803e927c67a0b729ccdfc1ac42" translate="yes" xml:space="preserve">
          <source>But 98% of the time, you don't need class alteration at all.</source>
          <target state="translated">でも98%はクラス改造は全く必要ないんですよね。</target>
        </trans-unit>
        <trans-unit id="217006127ae3f18c4bd2c902e86bbb02d1e2be15" translate="yes" xml:space="preserve">
          <source>But classes are more than that in Python. Classes are objects too.</source>
          <target state="translated">しかし、Pythonではクラスはそれ以上のものです。クラスもオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="c6925819c7efe04fd6c3ab39f7eb68854e9cde4a" translate="yes" xml:space="preserve">
          <source>But if you do this:</source>
          <target state="translated">でも、これをやってしまうと</target>
        </trans-unit>
        <trans-unit id="ef4914127f447e16a1796467ee1b0bb970abd2e5" translate="yes" xml:space="preserve">
          <source>But it's not so dynamic, since you still have to write the whole class yourself.</source>
          <target state="translated">それでもクラス全体を自分で書かなければならないので、あまりダイナミックではありません。</target>
        </trans-unit>
        <trans-unit id="3f48f38ce849fd78c7a275acf29a06ca3a0397d9" translate="yes" xml:space="preserve">
          <source>But still, it's an object, and therefore:</source>
          <target state="translated">しかし、それでも、それはオブジェクトであり、それゆえに。</target>
        </trans-unit>
        <trans-unit id="3b16fb856b8f2d6a24ccdf8c533162de4f2a2b85" translate="yes" xml:space="preserve">
          <source>But this is not proper OOP. We are calling &lt;code&gt;type&lt;/code&gt; directly and we aren't overriding or calling the parent's &lt;code&gt;__new__&lt;/code&gt;. Let's do that instead:</source>
          <target state="translated">しかし、これは適切なOOPではありません。 &lt;code&gt;type&lt;/code&gt; を直接呼び出しており、親の &lt;code&gt;__new__&lt;/code&gt; をオーバーライドしたり呼び出したりしていません。 代わりにそれをしましょう：</target>
        </trans-unit>
        <trans-unit id="bca74e7aa7842dd7785f6fa3e79fd35320fecfb0" translate="yes" xml:space="preserve">
          <source>But we learned that Python classes are objects.</source>
          <target state="translated">しかし、Pythonのクラスはオブジェクトであることを学びました。</target>
        </trans-unit>
        <trans-unit id="9da0aa54f4f4de88a9f5b6ed8d8101a2c5efd27f" translate="yes" xml:space="preserve">
          <source>By API developers</source>
          <target state="translated">API開発者による</target>
        </trans-unit>
        <trans-unit id="b4df2ba03eab94130e4fd06a9c5054fa64ad06cd" translate="yes" xml:space="preserve">
          <source>Can be translated to:</source>
          <target state="translated">と訳すことができます。</target>
        </trans-unit>
        <trans-unit id="334466b784281739a3c38583b4c063fdc0aba559" translate="yes" xml:space="preserve">
          <source>Careful, it's tricky.</source>
          <target state="translated">慎重に、それはトリッキーです。</target>
        </trans-unit>
        <trans-unit id="23e735f2e42f0ee01fd065b66b276180dd776b09" translate="yes" xml:space="preserve">
          <source>Class Name</source>
          <target state="translated">クラス名</target>
        </trans-unit>
        <trans-unit id="67581e4d912d7924cb46e54e6204e5fcc51399f9" translate="yes" xml:space="preserve">
          <source>Classes as objects</source>
          <target state="translated">オブジェクトとしてのクラス</target>
        </trans-unit>
        <trans-unit id="2a6d4b43aad00a6ba23618dd38abe34e6ccdd450" translate="yes" xml:space="preserve">
          <source>Creating a new model</source>
          <target state="translated">新規モデルの作成</target>
        </trans-unit>
        <trans-unit id="9d277645538f63f2b9666091e215ce0c2c94b67c" translate="yes" xml:space="preserve">
          <source>Creating classes dynamically</source>
          <target state="translated">動的にクラスを作成する</target>
        </trans-unit>
        <trans-unit id="a5890931814483d070ece2ba611db02e74fa66fb" translate="yes" xml:space="preserve">
          <source>Custom metaclasses</source>
          <target state="translated">カスタムメタクラス</target>
        </trans-unit>
        <trans-unit id="3583495fe771aa17938b325299e9568902990630" translate="yes" xml:space="preserve">
          <source>Django makes something complex look simple by exposing a simple API
and using metaclasses, recreating code from this API to do the real job
behind the scenes.</source>
          <target state="translated">Django はシンプルな API を公開し、メタクラスを使用することで、複雑なものをシンプルに見せ、この API からコードを再現して裏で本当の仕事をしています。</target>
        </trans-unit>
        <trans-unit id="0c2efb2ec65dc0aa53f18cfb1abd5f87fcb64df6" translate="yes" xml:space="preserve">
          <source>Eventually you'll want to add methods to your class. Just define a function
with the proper signature and assign it as an attribute.</source>
          <target state="translated">最終的にはクラスにメソッドを追加したいと思うでしょう。適切なシグネチャを持つ関数を定義し、それを属性として割り当てるだけです。</target>
        </trans-unit>
        <trans-unit id="07cbe8c7c80e4f1f64a5bbbd7a413d143a41a369" translate="yes" xml:space="preserve">
          <source>Everything is an object in Python, and they are all either instances of classes
or instances of metaclasses.</source>
          <target state="translated">Pythonではすべてがオブジェクトであり、それらはすべてクラスのインスタンスかメタクラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="8fd816dd026cb3639455418c4ec1f8fa0fe97cd2" translate="yes" xml:space="preserve">
          <source>Everything, and I mean everything, is an object in Python. That includes ints,
strings, functions and classes. All of them are objects. And all of them have
been created from a class:</source>
          <target state="translated">すべてのもの、つまりすべてのものは、Pythonではオブジェクトです。それには、イント、文字列、関数、クラスも含まれます。それらはすべてオブジェクトです。そして、それらはすべてクラスから作られています。</target>
        </trans-unit>
        <trans-unit id="673604a3dfb5c3ee8e65923cb90776673fb75935" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 除きます。</target>
        </trans-unit>
        <trans-unit id="ff75c36a00faaeb29de73a493ffe4e766d3c9c95" translate="yes" xml:space="preserve">
          <source>First, you can create a class in a function using &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">まず、classを使用して関数内にクラスを作成できます。</target>
        </trans-unit>
        <trans-unit id="b279b3945b4d05b8b08bfb5dd600595061650654" translate="yes" xml:space="preserve">
          <source>First, you know that classes are objects that can create instances.</source>
          <target state="translated">まず、クラスはインスタンスを作成できるオブジェクトであることを知っていますね。</target>
        </trans-unit>
        <trans-unit id="0afa5be4efcb2364e68a5fbe4c217e7cc8946f64" translate="yes" xml:space="preserve">
          <source>For doing that, your default &lt;code&gt;metaclass&lt;/code&gt; type class must be inherited as this is the main &lt;code&gt;metaclass&lt;/code&gt;:</source>
          <target state="translated">これを行うには、これがメインの &lt;code&gt;metaclass&lt;/code&gt; あるため、デフォルトの &lt;code&gt;metaclass&lt;/code&gt; タイプクラスを継承する必要があります 。</target>
        </trans-unit>
        <trans-unit id="64d1e55feb37865331973d2697ad8c261c0e1af4" translate="yes" xml:space="preserve">
          <source>For example, if you look at &lt;a href=&quot;http://docs.djangoproject.com/en/dev/topics/db/models/&quot;&gt;Django models&lt;/a&gt;, their definition looks a bit confusing. It looks as if you are only defining class properties:</source>
          <target state="translated">たとえば、 &lt;a href=&quot;http://docs.djangoproject.com/en/dev/topics/db/models/&quot;&gt;Djangoモデル&lt;/a&gt;を見ると、その定義は少しわかりにくいように見えます。 クラスプロパティのみを定義しているように見えます。</target>
        </trans-unit>
        <trans-unit id="fe22872a0b690652860e20740774999a464ef779" translate="yes" xml:space="preserve">
          <source>From the above it stems that the metaclass' &lt;code&gt;__call__()&lt;/code&gt; is also given the opportunity to decide whether or not a call to &lt;code&gt;Class_1.__new__()&lt;/code&gt; or &lt;code&gt;Class_1.__init__()&lt;/code&gt; will eventually be made. Over the course of its execution it could actually return an object that hasn't been touched by either of these methods. Take for example this approach to the singleton pattern:</source>
          <target state="translated">上記から、メタクラスの &lt;code&gt;__call__()&lt;/code&gt; は、 &lt;code&gt;Class_1.__new__()&lt;/code&gt; または &lt;code&gt;Class_1.__init__()&lt;/code&gt; への呼び出しが最終的に行われるかどうかを決定する機会も与えられていることがわかります。 その実行の過程で、これらのメソッドのいずれにも影響されていないオブジェクトを実際に返す可能性があります。 シングルトンパターンへのこのアプローチを例にとります：</target>
        </trans-unit>
        <trans-unit id="019ad28a21f071a1a1c801c23bffdedde5c57127" translate="yes" xml:space="preserve">
          <source>Here is an even more concrete example, showing how you can subclass 'type' to make a metaclass that performs an action when the class is created. This is quite tricky:</source>
          <target state="translated">ここではさらに具体的な例として、クラスが作成されたときにアクションを実行するメタクラスを作るために 'type' をサブクラス化する方法を示しています。これはかなりトリッキーです。</target>
        </trans-unit>
        <trans-unit id="89a9dab91d6a0e821bd0d8857c7afd11ec41324d" translate="yes" xml:space="preserve">
          <source>Here is where the secret starts. Look for where name, bases and the dict come from in this example class definition.</source>
          <target state="translated">ここからが秘密の始まりです。この例のクラス定義では、名前、ベース、ディクトがどこから来ているかを探してください。</target>
        </trans-unit>
        <trans-unit id="933820812619c6ea7008cbcf3a5bef8f52f428f5" translate="yes" xml:space="preserve">
          <source>Here's an aggregated example of the bits and pieces:</source>
          <target state="translated">ビットの集合体の例を紹介します。</target>
        </trans-unit>
        <trans-unit id="c7172cb8e50347e53ec2a1c70cf3f132135b13bb" translate="yes" xml:space="preserve">
          <source>Here's another example of what it can be used for:</source>
          <target state="translated">ここでもう一つ、何に使えるかの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="b92f66963c22e5d12229c7c1ff474ff5ca10c558" translate="yes" xml:space="preserve">
          <source>Here's the default &lt;code&gt;__repr__&lt;/code&gt; of classes:</source>
          <target state="translated">クラスのデフォルトの &lt;code&gt;__repr__&lt;/code&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="da679ef3b897db5427c2dd4128c089961c066bc2" translate="yes" xml:space="preserve">
          <source>However, at runtime the Person objects are filled with all sorts of useful methods. See the &lt;a href=&quot;http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py&quot;&gt;source&lt;/a&gt; for some amazing metaclassery.</source>
          <target state="translated">ただし、実行時には、Personオブジェクトはあらゆる種類の便利なメソッドで満たされます。 すばらしいメタクラセリーの&lt;a href=&quot;http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py&quot;&gt;ソース&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3687f11b0c4210b7d9c0b35a3e13741dc07a26f7" translate="yes" xml:space="preserve">
          <source>However, metaclasses actually define the &lt;em&gt;type&lt;/em&gt; of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. &lt;code&gt;type.__subclasses__()&lt;/code&gt; is an example of a method on the &lt;code&gt;type&lt;/code&gt; metaclass. You can also define the normal 'magic' methods, like &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__iter__&lt;/code&gt; and &lt;code&gt;__getattr__&lt;/code&gt;, to implement or change how the class behaves.</source>
          <target state="translated">ただし、メタクラスは実際にはクラスの&lt;em&gt;タイプ&lt;/em&gt;ではなくクラスの&lt;em&gt;タイプ&lt;/em&gt;を定義するため、メタクラスを使用してさらに多くのことができます。 たとえば、メタクラスに通常のメソッドを定義できます。 これらのメタクラスメソッドは、インスタンスなしでクラスで呼び出すことができるという点でクラスメソッドと似ていますが、クラスのインスタンスで呼び出すことができないという点でもクラスメソッドとは異なります。 &lt;code&gt;type.__subclasses__()&lt;/code&gt; は、 &lt;code&gt;type&lt;/code&gt; メタクラスのメソッドの例です。 &lt;code&gt;__add__&lt;/code&gt; 、 &lt;code&gt;__iter__&lt;/code&gt; 、 &lt;code&gt;__getattr__&lt;/code&gt; getattr__などの通常の「マジック」メソッドを定義して、クラスの動作を実装または変更することもできます。</target>
        </trans-unit>
        <trans-unit id="4fa00b7305761f3d48d74e2fcaa87d88b46b8653" translate="yes" xml:space="preserve">
          <source>I think the ONLamp introduction to metaclass programming is well written and gives a really good introduction to the topic despite being several years old already.</source>
          <target state="translated">ONLampのメタクラスプログラミング入門書は、すでに数年前のものにもかかわらず、よく書かれていて、本当に良い入門書になっていると思います。</target>
        </trans-unit>
        <trans-unit id="5de71cb6474da6bbfd1892d86a39743c6e1f7a0d" translate="yes" xml:space="preserve">
          <source>I've never written one myself, but I think one of the nicest uses of metaclasses can be seen in the &lt;a href=&quot;http://www.djangoproject.com/&quot;&gt;Django framework&lt;/a&gt;. The model classes use a metaclass approach to enable a declarative style of writing new models or form classes. While the metaclass is creating the class, all members get the possibility to customize the class itself.</source>
          <target state="translated">自分で書いたことはありませんが、メタクラスの最も優れた使い方の1つが&lt;a href=&quot;http://www.djangoproject.com/&quot;&gt;Djangoフレームワークで&lt;/a&gt;見られると思います。 モデルクラスはメタクラスアプローチを使用して、新しいモデルまたはフォームクラスを作成する宣言型スタイルを可能にします。 メタクラスがクラスを作成している間、すべてのメンバーがクラス自体をカスタマイズする可能性があります。</target>
        </trans-unit>
        <trans-unit id="d4a30d2f2ca2899fa19429f58792d2d3e210fba9" translate="yes" xml:space="preserve">
          <source>If Python can't find &lt;code&gt;__metaclass__&lt;/code&gt;, it will look for a &lt;code&gt;__metaclass__&lt;/code&gt; at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes).</source>
          <target state="translated">Pythonが &lt;code&gt;__metaclass__&lt;/code&gt; を見つけられない場合は、MODULEレベルで &lt;code&gt;__metaclass__&lt;/code&gt; を探し、同じことを試みます（ただし、何も継承しないクラス、基本的には古いスタイルのクラスのみ）。</target>
        </trans-unit>
        <trans-unit id="b2c247f997e1856448d121b399db1ce401dfe052" translate="yes" xml:space="preserve">
          <source>If yes, create in memory a class object (I said a class object, stay with me here), with the name &lt;code&gt;Foo&lt;/code&gt; by using what is in &lt;code&gt;__metaclass__&lt;/code&gt;.</source>
          <target state="translated">はいの場合は、 &lt;code&gt;__metaclass__&lt;/code&gt; の内容を使用して、 &lt;code&gt;Foo&lt;/code&gt; という名前のクラスオブジェクト（クラスオブジェクトと言いましたが、ここでそのままにします）をメモリ内に作成します。</target>
        </trans-unit>
        <trans-unit id="1c4ed3e469d021631b88778db056f898cbd3075a" translate="yes" xml:space="preserve">
          <source>If you do so, Python will use the metaclass to create the class &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">その場合、Pythonはメタクラスを使用してクラス &lt;code&gt;Foo&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="d569392d6709098664ec3f652636842d8ae2fd08" translate="yes" xml:space="preserve">
          <source>If you've done Python programming for more than a few months you'll eventually stumble upon code that looks like this:</source>
          <target state="translated">Pythonのプログラミングを数ヶ月以上やっていると、最終的にはこのようなコードにつまずくことになります。</target>
        </trans-unit>
        <trans-unit id="8ffaab56641a084b45859b1b16c94f6d85871567" translate="yes" xml:space="preserve">
          <source>If, for example, we want to know in what order a class's methods are created in, we could provide an ordered dict as the namespace of the class. We would do this with &lt;code&gt;__prepare__&lt;/code&gt; which &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace&quot;&gt;returns the namespace dict for the class if it is implemented in Python 3&lt;/a&gt;:</source>
          <target state="translated">たとえば、クラスのメソッドが作成される順序を知りたい場合は、クラスの名前空間として順序付けされたdictを提供できます。 &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace&quot;&gt;Python 3で実装されている場合、クラスの名前空間dict&lt;/a&gt;を返す &lt;code&gt;__prepare__&lt;/code&gt; を使用してこれを行い ます 。</target>
        </trans-unit>
        <trans-unit id="0ddfbe7f84c69375a34cda89908ad9181be61fdd" translate="yes" xml:space="preserve">
          <source>Imagine a stupid example, where you decide that all classes in your module
should have their attributes written in uppercase. There are several ways to
do this, but one way is to set &lt;code&gt;__metaclass__&lt;/code&gt; at the module level.</source>
          <target state="translated">モジュール内のすべてのクラスの属性を大文字で記述する必要があると判断した愚かな例を想像してみてください。 これを行うにはいくつかの方法がありますが、1つはモジュールレベルで &lt;code&gt;__metaclass__&lt;/code&gt; を設定することです。</target>
        </trans-unit>
        <trans-unit id="91a6aa8c8b6a75378372d8ea48354d684c37eb6b" translate="yes" xml:space="preserve">
          <source>In Python 2, you can add a &lt;code&gt;__metaclass__&lt;/code&gt; attribute when you write a class (see next section for the Python 3 syntax):</source>
          <target state="translated">Python 2では、クラスを作成するときに &lt;code&gt;__metaclass__&lt;/code&gt; 属性を追加できます（Python 3の構文については次のセクションを参照してください）。</target>
        </trans-unit>
        <trans-unit id="7e651e9d51572a5346d5e0e8610271f23aa0d208" translate="yes" xml:space="preserve">
          <source>In Python, what are metaclasses and what do we use them for?</source>
          <target state="translated">Pythonでは、メタクラスとは何か、何のために使うのか?</target>
        </trans-unit>
        <trans-unit id="4650ac989c9d3329e40be1c6ab845b25d2070a47" translate="yes" xml:space="preserve">
          <source>In addition to the published answers I can say that a &lt;code&gt;metaclass&lt;/code&gt; defines the behaviour for a class. So, you can explicitly set your metaclass. Whenever Python gets a keyword &lt;code&gt;class&lt;/code&gt; then it starts searching for the &lt;code&gt;metaclass&lt;/code&gt;. If it's not found &amp;ndash; the default metaclass type is used to create the class's object. Using the &lt;code&gt;__metaclass__&lt;/code&gt; attribute, you can set &lt;code&gt;metaclass&lt;/code&gt; of your class:</source>
          <target state="translated">公開された回答に加えて、 &lt;code&gt;metaclass&lt;/code&gt; はクラスの動作を定義すると言えます。 したがって、メタクラスを明示的に設定できます。 Pythonがキーワード &lt;code&gt;class&lt;/code&gt; 取得するたびに、 &lt;code&gt;metaclass&lt;/code&gt; 検索を開始します 。 見つからない場合は、デフォルトのメタクラスタイプを使用してクラスのオブジェクトを作成します。 &lt;code&gt;__metaclass__&lt;/code&gt; 属性を使用して、クラスの &lt;code&gt;metaclass&lt;/code&gt; を設定できます。</target>
        </trans-unit>
        <trans-unit id="c35d9935b1a444e907c91e37c19879d0759a37ba" translate="yes" xml:space="preserve">
          <source>In addition to using type() to create classes dynamically, you can control creation behavior of class and use metaclass.</source>
          <target state="translated">type()を使って動的にクラスを作成するだけでなく、クラスの作成動作を制御したり、メタクラスを利用したりすることができます。</target>
        </trans-unit>
        <trans-unit id="4a7677010e3a9723dd238a2332a0b15302776bce" translate="yes" xml:space="preserve">
          <source>In most languages, classes are just pieces of code that describe how to produce an object. That's kinda true in Python too:</source>
          <target state="translated">ほとんどの言語では、クラスはオブジェクトを生成する方法を記述するコードの断片にすぎません。これはPythonでも同じことが言えます。</target>
        </trans-unit>
        <trans-unit id="fa72180e3995db72ed5f698c8ee07149c8c3a22b" translate="yes" xml:space="preserve">
          <source>In object-oriented programming, a metaclass is a class whose instances are classes. Just as an ordinary class defines the behavior of certain objects, a metaclass defines the behavior of certain class and their instances
The term metaclass simply means something used to create classes. In other words, it is the class of a class. The metaclass is used to create the class so like the object being an instance of a class, a class is an instance of a metaclass. In python classes are also considered objects.</source>
          <target state="translated">オブジェクト指向プログラミングでは、メタクラスとはインスタンスがクラスであるクラスのことを指します。通常のクラスが特定のオブジェクトの振る舞いを定義するのと同じように、メタクラスは特定のクラスとそのインスタンスの振る舞いを定義します。 メタクラスという用語は、単にクラスを作成するために使用されるものを意味します。言い換えれば、クラスのクラスです。オブジェクトがクラスのインスタンスであるように、クラスはメタクラスのインスタンスです。pythonではクラスもオブジェクトとみなされます。</target>
        </trans-unit>
        <trans-unit id="2e61694f68b17195f1c41dbc03080f71c6ec3509" translate="yes" xml:space="preserve">
          <source>In real code, we can pass the default metaclass, &lt;code&gt;type&lt;/code&gt;, everything we need to instantiate a class and we get a class:</source>
          <target state="translated">実際のコードでは、デフォルトのメタクラスである &lt;code&gt;type&lt;/code&gt; を渡すことができます。クラスをインスタンス化するために必要なすべてのものがあり、クラスを取得します。</target>
        </trans-unit>
        <trans-unit id="6cde1b05c392829cf0748f367e1a5f3cc79ef8e7" translate="yes" xml:space="preserve">
          <source>In short: A class is a blueprint for the creation of an instance, a metaclass is a blueprint for the creation of a class. It can be easily seen that in Python classes need to be first-class objects too to enable this behavior.</source>
          <target state="translated">要するに、クラスはインスタンスを作成するための設計図であり、メタクラスはクラスを作成するための設計図です。Pythonではクラスはこの動作を可能にするためにもファーストクラスのオブジェクトである必要があることが簡単にわかります。</target>
        </trans-unit>
        <trans-unit id="0dcf456ed380c367ea7337a047070feeb2404ac6" translate="yes" xml:space="preserve">
          <source>Indeed, metaclasses are especially useful to do black magic, and therefore
complicated stuff. But by themselves, they are simple:</source>
          <target state="translated">確かに、メタクラスは黒魔術を行うのに特に有用であり、したがって複雑なものである。しかし、それ自体は単純です。</target>
        </trans-unit>
        <trans-unit id="e6acf61863b31d67d149b4e6ca40eee6b1199fa9" translate="yes" xml:space="preserve">
          <source>Is there a &lt;code&gt;__metaclass__&lt;/code&gt; attribute in &lt;code&gt;Foo&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; に &lt;code&gt;__metaclass__&lt;/code&gt; 属性はありますか？</target>
        </trans-unit>
        <trans-unit id="8b238ceb9e5599e813e4358cf7862918d33b97b1" translate="yes" xml:space="preserve">
          <source>It is the same as functionally calling &lt;code&gt;type&lt;/code&gt; with the appropriate arguments and assigning the result to a variable of that name:</source>
          <target state="translated">これは、適切な引数を指定して関数 &lt;code&gt;type&lt;/code&gt; を呼び出し、その名前の変数に結果を割り当てるのと同じです。</target>
        </trans-unit>
        <trans-unit id="0f552d4e543041b1701247e77678f01050c07d0e" translate="yes" xml:space="preserve">
          <source>It translates to this in the metaclass to use it:</source>
          <target state="translated">それを使うためにメタクラスではこれに変換します。</target>
        </trans-unit>
        <trans-unit id="c7ba3c56dd302201c8d63fd76926944ea19006b4" translate="yes" xml:space="preserve">
          <source>It won't return an &lt;code&gt;IntegerField&lt;/code&gt; object. It will return an &lt;code&gt;int&lt;/code&gt;, and can even take it directly from the database.</source>
          <target state="translated">&lt;code&gt;IntegerField&lt;/code&gt; オブジェクトは返しません。 &lt;code&gt;int&lt;/code&gt; を返し、データベースから直接取得することもできます。</target>
        </trans-unit>
        <trans-unit id="d8d805048c69fa736de925d3367248b04c361716" translate="yes" xml:space="preserve">
          <source>It'll produce the output like this:</source>
          <target state="translated">こんな感じで出力されます。</target>
        </trans-unit>
        <trans-unit id="7cf1c9cf775a5387c4ff94bd47121db2b5c988dd" translate="yes" xml:space="preserve">
          <source>It's because the function &lt;code&gt;type&lt;/code&gt; is in fact a metaclass. &lt;code&gt;type&lt;/code&gt; is the
metaclass Python uses to create all classes behind the scenes.</source>
          <target state="translated">これは、関数 &lt;code&gt;type&lt;/code&gt; が実際にはメタクラスであるためです。 &lt;code&gt;type&lt;/code&gt; は、Pythonが舞台裏ですべてのクラスを作成するために使用するメタクラスです。</target>
        </trans-unit>
        <trans-unit id="b762e9c56bf18ad7968cf2abfa72dfb4cd610a39" translate="yes" xml:space="preserve">
          <source>Just as we can use class definitions to change how custom object instances behave, we can use a metaclass class definition to change the way a class object behaves.</source>
          <target state="translated">クラス定義を使用してカスタム・オブジェクト・インスタンスの動作を変更できるように、メタクラスのクラス定義を使用してクラス・オブジェクトの動作を変更することができます。</target>
        </trans-unit>
        <trans-unit id="12861900e6ee5fc644f17e214205bf98f2b552b1" translate="yes" xml:space="preserve">
          <source>Let's check:</source>
          <target state="translated">確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="e24b773897b7eab9e5ea3419aecc80a071b54a96" translate="yes" xml:space="preserve">
          <source>Let's observe what happens when repeatedly trying to create an object of type &lt;code&gt;Class_2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Class_2&lt;/code&gt; 型のオブジェクトを繰り返し作成しようとするとどうなるかを見てみましょう</target>
        </trans-unit>
        <trans-unit id="0d3e22e4d5a330681408b9b810a86a368c8150f7" translate="yes" xml:space="preserve">
          <source>Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean:</source>
          <target state="translated">上記を書き換えてみましょうが、意味がわかったので、より短く、より現実的な変数名にしましょう。</target>
        </trans-unit>
        <trans-unit id="bae90bb62607735e9b7e3a157dc8431c62f56161" translate="yes" xml:space="preserve">
          <source>Let's study the method call chain from specifically the perspective of creating an instance of a class.</source>
          <target state="translated">具体的には、クラスのインスタンスを作成するという観点から、メソッドコールチェーンを勉強してみましょう。</target>
        </trans-unit>
        <trans-unit id="045e68d2ed13507db1ee3f048ec03ec22ab6a6b4" translate="yes" xml:space="preserve">
          <source>Lets define a metaclass that will demonstrate how '&lt;strong&gt;class:&lt;/strong&gt;' calls it.</source>
          <target state="translated">' &lt;strong&gt;class：&lt;/strong&gt; 'がそれを呼び出す方法を示すメタクラスを定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="320371557536a1d1e98f35433ae20c51e9eed7fc" translate="yes" xml:space="preserve">
          <source>Likewise, when we define a class explicitly with the default metaclass, &lt;code&gt;type&lt;/code&gt;, we instantiate it:</source>
          <target state="translated">同様に、デフォルトのメタクラス &lt;code&gt;type&lt;/code&gt; を使用してクラスを明示的に定義すると、インスタンス化されます。</target>
        </trans-unit>
        <trans-unit id="dd4270596259e170c6cba8ca00280d127d29899d" translate="yes" xml:space="preserve">
          <source>Luckily, &lt;code&gt;__metaclass__&lt;/code&gt; can actually be any callable, it doesn't need to be a
formal class (I know, something with 'class' in its name doesn't need to be
a class, go figure... but it's helpful).</source>
          <target state="translated">幸いなことに、 &lt;code&gt;__metaclass__&lt;/code&gt; は実際には呼び出し可能であり、正式なクラスである必要はありません（名前に「class」が含まれているものは、クラスである必要はありません。</target>
        </trans-unit>
        <trans-unit id="a84965b59c86adeaf5175c77b1367ae45a51beca" translate="yes" xml:space="preserve">
          <source>Magic will take effect when we passed keyword arguments in metaclass, it indicates the Python interpreter to create the CustomList through ListMetaclass. &lt;strong&gt;new&lt;/strong&gt; (), at this point, we can modify the class definition, for example, and add a new method and then return the revised definition.</source>
          <target state="translated">マジックは、メタクラスでキーワード引数を渡したときに有効になります。これは、PythonインタープリターがListMetaclassを介してCustomListを作成することを示します。 &lt;strong&gt;new&lt;/strong&gt; （）、この時点で、たとえばクラス定義を変更し、新しいメソッドを追加して、変更された定義を返すことができます。</target>
        </trans-unit>
        <trans-unit id="5fe9adb504d86047cca71de452afe1639b04cca8" translate="yes" xml:space="preserve">
          <source>Metaclass can be specifically used in the following situations :-</source>
          <target state="translated">メタクラスは特に次のような状況で使用することができます。</target>
        </trans-unit>
        <trans-unit id="3af05144e3743c95c5ae229f63e24413fd772f08" translate="yes" xml:space="preserve">
          <source>Metaclass is a kind of class which defines how the class will behave like or we can say that A class is itself an instance of a metaclass.</source>
          <target state="translated">メタクラスとは、クラスがどのように振る舞うかを定義したクラスの一種で、クラスはそれ自体がメタクラスのインスタンスであると言えます。</target>
        </trans-unit>
        <trans-unit id="a4c7336a776a31b11543813110e2a48bdc565d93" translate="yes" xml:space="preserve">
          <source>Metaclasses are deeper magic that
  99% of users should never worry about.
  If you wonder whether you need them,
  you don't (the people who actually
  need them know with certainty that
  they need them, and don't need an
  explanation about why).</source>
          <target state="translated">メタクラスは、99%のユーザーが絶対に気にしてはいけない奥の深い魔法です。必要かどうか疑問に思ったら必要ない(実際に必要な人は必要だと確信を持って知っていて、その理由についての説明は必要ない)。</target>
        </trans-unit>
        <trans-unit id="fcb03720145595ceaed2564444518a68539698a8" translate="yes" xml:space="preserve">
          <source>Metaclasses are the 'stuff' that creates classes.</source>
          <target state="translated">メタクラスはクラスを作る「もの」です。</target>
        </trans-unit>
        <trans-unit id="347480dda5a48202f0a0a3b1b3be6014055c70c8" translate="yes" xml:space="preserve">
          <source>Metaclasses are the secret sauce that make 'class' work. The default metaclass for a new style object is called 'type'.</source>
          <target state="translated">メタクラスは 'class' を機能させる秘密のソースです。新しいスタイルオブジェクトのデフォルトのメタクラスは 'type' と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="b0d32362c1bfdecea091b0735835a3190f185e2b" translate="yes" xml:space="preserve">
          <source>Metaclasses in Python 3</source>
          <target state="translated">Python 3のメタクラス</target>
        </trans-unit>
        <trans-unit id="97071630fbed73be9de0cacbd51a241cef7bdfa8" translate="yes" xml:space="preserve">
          <source>Metaclasses take 3 args. '&lt;strong&gt;name&lt;/strong&gt;', '&lt;strong&gt;bases&lt;/strong&gt;' and '&lt;strong&gt;dict&lt;/strong&gt;'</source>
          <target state="translated">メタクラスは3つの引数を取ります。 「 &lt;strong&gt;名前&lt;/strong&gt; 」、「 &lt;strong&gt;ベース&lt;/strong&gt; 」、「 &lt;strong&gt;辞書&lt;/strong&gt; 」</target>
        </trans-unit>
        <trans-unit id="8797caa69e6420c0f3bfebfa19ca4cdf0b6929f4" translate="yes" xml:space="preserve">
          <source>Nevertheless, it is usually encouraged for users to avoid using metaclasses unless absolutely necessary.</source>
          <target state="translated">それにもかかわらず、絶対に必要な場合を除き、通常はメタクラスの使用を避けることが推奨されています。</target>
        </trans-unit>
        <trans-unit id="4ad4b27bbadcdc0adcdbc297fc1201cb31705fca" translate="yes" xml:space="preserve">
          <source>Note that in python 3.6 a new dunder method &lt;code&gt;__init_subclass__(cls, **kwargs)&lt;/code&gt; was introduced to replace a lot of common use cases for metaclasses. Is is called when a subclass of the defining class is created. See &lt;a href=&quot;https://docs.python.org/3.6/reference/datamodel.html&quot;&gt;python docs&lt;/a&gt;.</source>
          <target state="translated">Python 3.6 &lt;code&gt;__init_subclass__(cls, **kwargs)&lt;/code&gt; メタクラスの多くの一般的な使用例を置き換えるために、新しいdunderメソッド__init_subclass __（cls、** kwargs）が導入されたことに注意してください。 Isは、定義するクラスのサブクラスが作成されるときに呼び出されます。 &lt;a href=&quot;https://docs.python.org/3.6/reference/datamodel.html&quot;&gt;python docsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="06fe24108d0ae7b5ac24fe3074dd0a7cf192f87c" translate="yes" xml:space="preserve">
          <source>Note, some things automatically get added to the &lt;code&gt;__dict__&lt;/code&gt;, i.e., the namespace:</source>
          <target state="translated">いくつかのものは自動的に &lt;code&gt;__dict__&lt;/code&gt; 、つまり名前空間に追加されます：</target>
        </trans-unit>
        <trans-unit id="fe5b2192b1a3dda71ee761442e7acc561c0dae83" translate="yes" xml:space="preserve">
          <source>Note, this example was adapted from the &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;documentation&lt;/a&gt; - the new &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/enum.py&quot;&gt;enum in the standard library&lt;/a&gt; does this.</source>
          <target state="translated">この例は&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;ドキュメント&lt;/a&gt;から改作されたものであることに注意してください- &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/enum.py&quot;&gt;標準ライブラリの&lt;/a&gt;新しい列挙型がこれを行います。</target>
        </trans-unit>
        <trans-unit id="2e4afa936b2a2c77839b1cc61ded016a8418009e" translate="yes" xml:space="preserve">
          <source>Notice that the class was not instantiated at any time; the simple act of creating the class triggered execution of the &lt;code&gt;metaclass&lt;/code&gt;.</source>
          <target state="translated">クラスがインスタンス化されていないことに注意してください。 クラスを作成するという単純な行為は、 &lt;code&gt;metaclass&lt;/code&gt; 実行を引き起こしました。</target>
        </trans-unit>
        <trans-unit id="e8092d965c6169ed84145f59ba7bbf9f5d4c853f" translate="yes" xml:space="preserve">
          <source>Now the big question is, what can you put in &lt;code&gt;__metaclass__&lt;/code&gt; ?</source>
          <target state="translated">ここで大きな問題は、 &lt;code&gt;__metaclass__&lt;/code&gt; に何を入れることができるかということです。</target>
        </trans-unit>
        <trans-unit id="d2dcde526fc4daaef6d655606e4496048204c05b" translate="yes" xml:space="preserve">
          <source>Now the big question. Why would you use some obscure error prone feature?</source>
          <target state="translated">さて、大きな疑問です。なぜエラーになりやすい機能を使うのか?</target>
        </trans-unit>
        <trans-unit id="1312ae6700f74e01674fc6c089a10ffa91f468b1" translate="yes" xml:space="preserve">
          <source>Now you wonder why the heck is it written in lowercase, and not &lt;code&gt;Type&lt;/code&gt;?</source>
          <target state="translated">では、なぜ &lt;code&gt;Type&lt;/code&gt; ではなく小文字で書かれているのでしょうか。</target>
        </trans-unit>
        <trans-unit id="9e1ac6d44c14c13e117e5f981206e38957129c52" translate="yes" xml:space="preserve">
          <source>Now, let's do exactly the same, but using a real class for a metaclass:</source>
          <target state="translated">では、全く同じことをしてみましょう。</target>
        </trans-unit>
        <trans-unit id="390ebafcf350ad02efb790f33b6aaead595c1109" translate="yes" xml:space="preserve">
          <source>Now, what is the &lt;code&gt;__class__&lt;/code&gt; of any &lt;code&gt;__class__&lt;/code&gt; ?</source>
          <target state="translated">さて、 &lt;code&gt;__class__&lt;/code&gt; のは何 &lt;code&gt;__class__&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="d1ac610b74a4f310bfc7d2292f70767803b25d13" translate="yes" xml:space="preserve">
          <source>Observe that the code above doesn't actually do anything more than logging the tasks. Each method delegates the actual work to its parent's implementation, thus keeping the default behavior. Since &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;Meta_1&lt;/code&gt;'s parent class (&lt;code&gt;type&lt;/code&gt; being the default parent metaclass) and considering the ordering sequence of the output above, we now have a clue as to what would be the pseudo implementation of &lt;code&gt;type.__call__()&lt;/code&gt;:</source>
          <target state="translated">上記のコードは、実際にはタスクをログに記録する以外に何も実行しないことに注意してください。 各メソッドは、実際の作業をその親の実装に委譲し、デフォルトの動作を維持します。 &lt;code&gt;type&lt;/code&gt; は &lt;code&gt;Meta_1&lt;/code&gt; の親クラス（ &lt;code&gt;type&lt;/code&gt; はデフォルトの親メタクラス）であり、上記の出力の順序付けシーケンスを考慮すると、 &lt;code&gt;type.__call__()&lt;/code&gt; 擬似実装が何であるかについての手がかりが得られます。</target>
        </trans-unit>
        <trans-unit id="9d0d319c87f6fad802806c07bd7c51a428962ba2" translate="yes" xml:space="preserve">
          <source>Oh, and in python 3 if you do this call with keyword arguments, like this:</source>
          <target state="translated">ああ、そして、Python 3では、この呼び出しをキーワード引数で行うと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="7cfdd53a3948e13bf6052b4df361c602b9dadb4c" translate="yes" xml:space="preserve">
          <source>One of the most valuable things we can do by default in writing a Python object is to provide it with a good &lt;code&gt;__repr__&lt;/code&gt;. When we call &lt;code&gt;help(repr)&lt;/code&gt; we learn that there's a good test for a &lt;code&gt;__repr__&lt;/code&gt; that also requires a test for equality - &lt;code&gt;obj == eval(repr(obj))&lt;/code&gt;. The following simple implementation of &lt;code&gt;__repr__&lt;/code&gt; and &lt;code&gt;__eq__&lt;/code&gt; for class instances of our type class provides us with a demonstration that may improve on the default &lt;code&gt;__repr__&lt;/code&gt; of classes:</source>
          <target state="translated">Pythonオブジェクトを記述する際にデフォルトで実行できる最も価値のあることの1つは、オブジェクトに適切な &lt;code&gt;__repr__&lt;/code&gt; を提供することです 。 &lt;code&gt;help(repr)&lt;/code&gt; を呼び出すと、 &lt;code&gt;__repr__&lt;/code&gt; の適切なテストがあり、同等性のテストも必要であることがわかります-obj &lt;code&gt;obj == eval(repr(obj))&lt;/code&gt; 。 タイプクラスのクラスインスタンスに対する &lt;code&gt;__repr__&lt;/code&gt; および &lt;code&gt;__eq__&lt;/code&gt; の次の簡単な実装は、クラスのデフォルトの &lt;code&gt;__repr__&lt;/code&gt; を改善できるデモを提供します。</target>
        </trans-unit>
        <trans-unit id="110c76ebedce2cc5ef80aca4ff4ae9ae674cabba" translate="yes" xml:space="preserve">
          <source>One thing added to metaclasses in python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:</source>
          <target state="translated">python 3でメタクラスに追加されたことの一つは、以下のように属性をキーワード引数としてメタクラスに渡すことができるということです。</target>
        </trans-unit>
        <trans-unit id="34e532c0c60597f39dcc4f2a9b5f7a1d572c0614" translate="yes" xml:space="preserve">
          <source>One use for metaclasses is adding new properties and methods to an instance automatically.</source>
          <target state="translated">メタクラスの用途の一つは、インスタンスに新しいプロパティやメソッドを自動的に追加することです。</target>
        </trans-unit>
        <trans-unit id="ef268ec4d64e990e936a954651784766af9637be" translate="yes" xml:space="preserve">
          <source>Others have explained how metaclasses work and how they fit into the Python type system. Here's an example of what they can be used for. In a testing framework I wrote, I wanted to keep track of the order in which classes were defined, so that I could later instantiate them in this order. I found it easiest to do this using a metaclass.</source>
          <target state="translated">他の人たちは、メタクラスがどのように動作するのか、そしてそれが Python の型システムにどのように適合するのかを説明しています。ここでは、メタクラスが何に使われるかの例を紹介します。私が書いたテストフレームワークでは、クラスが定義された順番を追跡して、後でその順番でインスタンス化できるようにしたいと思っていました。これを行うにはメタクラスを使うのが一番簡単だとわかりました。</target>
        </trans-unit>
        <trans-unit id="a1e368bcdd9e3ad64f80172f6605fff557c816ac" translate="yes" xml:space="preserve">
          <source>Pseudocode:</source>
          <target state="translated">Pseudocode:</target>
        </trans-unit>
        <trans-unit id="b046f20ec5ac77994d3cd2fa8b65aab70b67256f" translate="yes" xml:space="preserve">
          <source>Put a third way, a metaclass is a class's class.</source>
          <target state="translated">第三の方法で言えば、メタクラスはクラスのクラスです。</target>
        </trans-unit>
        <trans-unit id="8d527c34e169c405cdbe5dedda08a7bde822577d" translate="yes" xml:space="preserve">
          <source>Put another way, a class is an instance of a metaclass:</source>
          <target state="translated">別の言い方をすれば、クラスはメタクラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="57d1465b29ebaa761602dcd70cff407e53c47e35" translate="yes" xml:space="preserve">
          <source>Putting it differently</source>
          <target state="translated">別の場所に置く</target>
        </trans-unit>
        <trans-unit id="ce9d464e6a7243401820e72c717964ac86dda8b2" translate="yes" xml:space="preserve">
          <source>Python classes are themselves objects - as in instance - of their meta-class.</source>
          <target state="translated">Pythonのクラスは、それ自体がメタクラスのインスタンスのようなオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="47913b0ef43e652acfa0a6f76a38e652fae1a60c" translate="yes" xml:space="preserve">
          <source>Python does the following:</source>
          <target state="translated">Pythonは以下のようなことをします。</target>
        </trans-unit>
        <trans-unit id="1cef07b48fc1a95aee7f514ccf91ce22d457b8f0" translate="yes" xml:space="preserve">
          <source>Python will look for &lt;code&gt;__metaclass__&lt;/code&gt; in the class definition. If it finds it,
it will use it to create the object class &lt;code&gt;Foo&lt;/code&gt;. If it doesn't, it will use
&lt;code&gt;type&lt;/code&gt; to create the class.</source>
          <target state="translated">Pythonはクラス定義で &lt;code&gt;__metaclass__&lt;/code&gt; を探します。 見つかった場合は、それを使用してオブジェクトクラス &lt;code&gt;Foo&lt;/code&gt; を作成します。 そうでない場合は、 &lt;code&gt;type&lt;/code&gt; を使用してクラスを作成します。</target>
        </trans-unit>
        <trans-unit id="c68f250ede1ff4f4e9314c1012a1057abd055fc7" translate="yes" xml:space="preserve">
          <source>Read that several times.</source>
          <target state="translated">何度か読んでみてください。</target>
        </trans-unit>
        <trans-unit id="10b8e71a62f5bb23590ad5fac72a1920c13c031d" translate="yes" xml:space="preserve">
          <source>Read the section below for how python handles this.</source>
          <target state="translated">pythonがどのように処理するかは、以下のセクションをお読みください。</target>
        </trans-unit>
        <trans-unit id="363f6db0e6302144237a5fb8dc97f8c0bca8e69c" translate="yes" xml:space="preserve">
          <source>Remember the function &lt;code&gt;type&lt;/code&gt;? The good old function that lets you know what
type an object is:</source>
          <target state="translated">関数の &lt;code&gt;type&lt;/code&gt; 覚えていますか？ オブジェクトのタイプを知るための古き良き関数：</target>
        </trans-unit>
        <trans-unit id="cf75004630642fa532edd3e9852d9ebbd8dc3330" translate="yes" xml:space="preserve">
          <source>Role of a metaclass' &lt;code&gt;__call__()&lt;/code&gt; method when creating a class instance</source>
          <target state="translated">クラスインスタンスを作成するときのメタクラスの &lt;code&gt;__call__()&lt;/code&gt; メソッドの役割</target>
        </trans-unit>
        <trans-unit id="ab6d3b5b86935e5bb21ca62e95635f583fc6b80d" translate="yes" xml:space="preserve">
          <source>Say you want some simple validation code to run on your attributes -- like it must always be an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;str&lt;/code&gt;.  Without a metaclass, your class would look something like:</source>
          <target state="translated">たとえば、常に &lt;code&gt;int&lt;/code&gt; または &lt;code&gt;str&lt;/code&gt; である必要があるように、いくつかの単純な検証コードを属性で実行したいとします 。 メタクラスがない場合、クラスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="924f4a98a9789c119e7866bd528b9dbf5b11a53a" translate="yes" xml:space="preserve">
          <source>Secondly, metaclasses are complicated. You may not want to use them for
very simple class alterations. You can change classes by using two different techniques:</source>
          <target state="translated">第二に、メタクラスは複雑です。非常に単純なクラスの変更には使いたくないかもしれません。クラスを変更するには、2つの異なるテクニックを使います。</target>
        </trans-unit>
        <trans-unit id="4dfe816bf571911a330a66b6c754c40a58c06f42" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;__metaclass__&lt;/code&gt; can accept any callable, why would you use a class
since it's obviously more complicated?</source>
          <target state="translated">&lt;code&gt;__metaclass__&lt;/code&gt; は任意の呼び出し可能オブジェクトを受け入れることができるので、クラスが明らかに複雑であるため、なぜクラスを使用するのですか？</target>
        </trans-unit>
        <trans-unit id="bac0117f2a38a17d034595eaa6fbc681396fe5b3" translate="yes" xml:space="preserve">
          <source>Since classes are objects, they must be generated by something.</source>
          <target state="translated">クラスはオブジェクトなので、何かによって生成されなければなりません。</target>
        </trans-unit>
        <trans-unit id="760ecfb3930f9e09bb9d06c038adf0fa41b52fc4" translate="yes" xml:space="preserve">
          <source>Since classes are objects, you can create them on the fly, like any object.</source>
          <target state="translated">クラスはオブジェクトなので、他のオブジェクトと同じようにその場で作成することができます。</target>
        </trans-unit>
        <trans-unit id="7922a02533e41a18df57099805414126241c109f" translate="yes" xml:space="preserve">
          <source>So now when we create an object with this metaclass, the &lt;code&gt;__repr__&lt;/code&gt; echoed on the command line provides a much less ugly sight than the default:</source>
          <target state="translated">したがって、このメタクラスを使用してオブジェクトを作成すると、コマンドラインにエコーされた &lt;code&gt;__repr__&lt;/code&gt; は、デフォルトよりも見苦しくない表示になります。</target>
        </trans-unit>
        <trans-unit id="b3eadfdf1eb9197422100ebb25f09e54a92a4803" translate="yes" xml:space="preserve">
          <source>So we will start with a simple example, by using a function.</source>
          <target state="translated">ということで、まずは関数を使った簡単な例からご紹介します。</target>
        </trans-unit>
        <trans-unit id="3baa5edda84402a64f5f0858188ef99b09a86284" translate="yes" xml:space="preserve">
          <source>So what we did was instantiate a metaclass by creating a class. We can also treat the metaclass as we would any other class. It has a method resolution order:</source>
          <target state="translated">そこで何をしたかというと、クラスを作成してメタクラスをインスタンス化したのです。メタクラスを他のクラスと同じように扱うこともできます。メソッドの解決順序を持っています。</target>
        </trans-unit>
        <trans-unit id="787050e4deb5bdd8472bfd457a5d01da81c38749" translate="yes" xml:space="preserve">
          <source>So, a metaclass is just the stuff that creates class objects.</source>
          <target state="translated">つまり、メタクラスとは、クラスオブジェクトを作成するだけのものです。</target>
        </trans-unit>
        <trans-unit id="2cdd6c8b1bfe3a886c05a5ee17876f43593f8214" translate="yes" xml:space="preserve">
          <source>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.</source>
          <target state="translated">クラスのサブクラスは、メタクラスを指定した場合にはそのメタクラスのインスタンスになりますが、メタクラス関数を指定した場合にはなりません。</target>
        </trans-unit>
        <trans-unit id="0e65e54eb14defefa9b23c03a66343a7b6f47568" translate="yes" xml:space="preserve">
          <source>TLDR: A metaclass instantiates and defines behavior for a class just like a class instantiates and defines behavior for an instance.</source>
          <target state="translated">TLDR:メタクラスは、クラスがインスタンスのインスタンスを作成して動作を定義するのと同じように、クラスのインスタンスを作成して動作を定義します。</target>
        </trans-unit>
        <trans-unit id="ed0c814a6c1a71ccfd0f078327070092fba4af8e" translate="yes" xml:space="preserve">
          <source>That's it. There is really nothing more about metaclasses.</source>
          <target state="translated">それだけです。メタクラスについては、本当にもう何もありません。</target>
        </trans-unit>
        <trans-unit id="a4cdd3d253d3c4a2ec82a87618d1e84a1259cbb8" translate="yes" xml:space="preserve">
          <source>The 'ValidateType' class for reference:</source>
          <target state="translated">参照用の'ValidateType'クラス。</target>
        </trans-unit>
        <trans-unit id="604a85cd97fdfe89bc4bd3ea794f26e3143cb342" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__&quot;&gt;&lt;code&gt;__metaclass__&lt;/code&gt;&lt;/a&gt; attribute</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__&quot;&gt; &lt;code&gt;__metaclass__&lt;/code&gt; &lt;/a&gt;属性</target>
        </trans-unit>
        <trans-unit id="b9bee8c22368a6bedc8cb2204d7e38427ec1a6fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__call__()&lt;/code&gt; method is invoked when an instance of a class is used as a callable. But as we've seen from previous answers a class itself is an instance of a metaclass, so when we use the class as a callable (i.e. when we create an instance of it) we're actually calling its metaclass' &lt;code&gt;__call__()&lt;/code&gt; method. At this point most Python programmers are a bit confused because they've been told that when creating an instance like this &lt;code&gt;instance = SomeClass()&lt;/code&gt; you're calling its &lt;code&gt;__init__()&lt;/code&gt; method. Some who've dug a bit deeper know that before &lt;code&gt;__init__()&lt;/code&gt; there's &lt;code&gt;__new__()&lt;/code&gt;. Well, today another layer of truth is being revealed, before &lt;code&gt;__new__()&lt;/code&gt; there's the metaclass' &lt;code&gt;__call__()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__call__()&lt;/code&gt; メソッドは、クラスのインスタンスが呼び出し可能として使用されるときに呼び出されます。 しかし、以前の回答から見てきたように、クラス自体はメタクラスのインスタンスなので、クラスを呼び出し可能オブジェクトとして使用するとき（つまり、インスタンスを作成するとき）は、実際にそのメタクラスの &lt;code&gt;__call__()&lt;/code&gt; メソッドを呼び出しています。 この時点で、ほとんどのPythonプログラマーは少し混乱しています。この &lt;code&gt;instance = SomeClass()&lt;/code&gt; ようなインスタンスを作成するときは、 &lt;code&gt;__init__()&lt;/code&gt; メソッドを呼び出していると言われているからです。 少し深く掘り下げた人の中には、 &lt;code&gt;__init__()&lt;/code&gt; &lt;code&gt;__new__()&lt;/code&gt; の前に__new __（）があることを知っています。 さて、今日、 &lt;code&gt;__new__()&lt;/code&gt; 前に、メタクラスの &lt;code&gt;__call__()&lt;/code&gt; が存在する、真実の別の層が明らかにされています。</target>
        </trans-unit>
        <trans-unit id="bbdb757e7f3a0fd9bcff0fc938b6c42345b821ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;metaclass&lt;/code&gt; is powerful, there are many things (such as monkey magic) you can do with it, but be careful this may only be known to you.</source>
          <target state="translated">&lt;code&gt;metaclass&lt;/code&gt; は強力であり、それを使ってできることはたくさんあります（モンキーマジックなど）が、これは自分しか知らない可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7ffedf4f89a6efcf7f214cee31b40dd5d82d9dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type(obj)&lt;/code&gt; function gets you the type of an object.</source>
          <target state="translated">&lt;code&gt;type(obj)&lt;/code&gt; 関数は、オブジェクトのタイプを取得します。</target>
        </trans-unit>
        <trans-unit id="19c9cb1547b44911ff93834c533ce8c6106e48d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;metaclass&lt;/em&gt; of the object we created, in both cases, is &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">作成したオブジェクトの&lt;em&gt;メタクラス&lt;/em&gt;は、どちらの場合も &lt;code&gt;type&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a1aa36bd31df16516299e0a9f975574341ae6676" translate="yes" xml:space="preserve">
          <source>The above should look familiar. Well, where does &lt;code&gt;Class&lt;/code&gt; come from? It's an instance of a metaclass (also pseudocode):</source>
          <target state="translated">上記はおなじみのはずです。 さて、 &lt;code&gt;Class&lt;/code&gt; どこから来たのですか？ これはメタクラス（疑似コード）のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="a2875f88e41a0ad13dd2d5379ef6582ba0fb3dd7" translate="yes" xml:space="preserve">
          <source>The answer is: something that can create a class.</source>
          <target state="translated">答えは、クラスを作ることができるもの。</target>
        </trans-unit>
        <trans-unit id="9a86d7001554378f3dcbce322b370aaa90ec530c" translate="yes" xml:space="preserve">
          <source>The behaviour of metaclasses however stays &lt;a href=&quot;https://www.python.org/dev/peps/pep-3115/&quot;&gt;largely the same&lt;/a&gt;.</source>
          <target state="translated">ただし、メタクラスの動作は&lt;a href=&quot;https://www.python.org/dev/peps/pep-3115/&quot;&gt;ほぼ同じ&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="3f6d3b98cc17992d9030a84dca7f0f6a00ff380a" translate="yes" xml:space="preserve">
          <source>The default metaclass, which is applied when when you determine classes as:</source>
          <target state="translated">デフォルトのメタクラスであり、クラスを「クラス」として決定する際に適用されます。</target>
        </trans-unit>
        <trans-unit id="29b56e4ed0cf2c522c5e5b6e0b098db30123e1fe" translate="yes" xml:space="preserve">
          <source>The intention is clear. When you read &lt;code&gt;UpperAttrMetaclass(type)&lt;/code&gt;, you know
what's going to follow</source>
          <target state="translated">その意図は明らかです。 &lt;code&gt;UpperAttrMetaclass(type)&lt;/code&gt; を読むと、何が続くかがわかります</target>
        </trans-unit>
        <trans-unit id="a6e5997843f57dcebc725e6a5762f1c51bce68a1" translate="yes" xml:space="preserve">
          <source>The last word</source>
          <target state="translated">最後の言葉</target>
        </trans-unit>
        <trans-unit id="fde54b7f3e6afffc50941664e058311d935cae06" translate="yes" xml:space="preserve">
          <source>The latter is possible when you implement the &lt;code&gt;__call__()&lt;/code&gt; magic method on the class.</source>
          <target state="translated">後者は、クラスに &lt;code&gt;__call__()&lt;/code&gt; マジックメソッドを実装する場合に可能です。</target>
        </trans-unit>
        <trans-unit id="71bb84c4860a5a46695ab1e2438f2ed1d5a90d31" translate="yes" xml:space="preserve">
          <source>The main purpose of a metaclass is to change the class automatically,
when it's created.</source>
          <target state="translated">メタクラスの主な目的は、クラスが作成されたときに、自動的にクラスを変更することです。</target>
        </trans-unit>
        <trans-unit id="3c9b5afc7d5812bc24e508fdde2021ee24771b8d" translate="yes" xml:space="preserve">
          <source>The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:</source>
          <target state="translated">メタクラスの主なユースケースは、APIを作成することです。典型的な例は Django の ORM です。このようなものを定義することができます。</target>
        </trans-unit>
        <trans-unit id="7ed8ebb489915f332c0205bc56188ef3801ec4e9" translate="yes" xml:space="preserve">
          <source>The metaclass enabling this</source>
          <target state="translated">これを可能にするメタクラス</target>
        </trans-unit>
        <trans-unit id="d7864ae5ef3f0b7a2f3aacd5831a1402dbade9c3" translate="yes" xml:space="preserve">
          <source>The output will be:</source>
          <target state="translated">出力されます。</target>
        </trans-unit>
        <trans-unit id="5268adb28d12d30ac6d135d5f75b63e9da11e68b" translate="yes" xml:space="preserve">
          <source>The potential uses for metaclasses are boundless. Some ideas that have been explored include logging, interface checking, automatic delegation, automatic property creation, proxies, frameworks, and automatic resource locking/synchronization.</source>
          <target state="translated">メタクラスの潜在的な用途は無限です。探索されてきたアイデアの中には、ロギング、インターフェースチェック、自動委任、自動プロパティ作成、プロキシ、フレームワーク、自動リソースロック同期化などがあります。</target>
        </trans-unit>
        <trans-unit id="6907452e93a5a80f5c109418b9bf18c96cd67c09" translate="yes" xml:space="preserve">
          <source>The reason behind the complexity of the code using metaclasses is not because
of metaclasses, it's because you usually use metaclasses to do twisted stuff
relying on introspection, manipulating inheritance, vars such as &lt;code&gt;__dict__&lt;/code&gt;, etc.</source>
          <target state="translated">メタクラスを使用するコードの複雑さの背後にある理由は、メタクラスが原因ではなく、通常、メタクラスを使用して、イントロスペクション、継承の操作、__dict__などの変数などに依存するねじれたものを実行するためです。</target>
        </trans-unit>
        <trans-unit id="292b3d3fa44cb0944294ebc9a86345b3567f6d79" translate="yes" xml:space="preserve">
          <source>The syntax to set the metaclass has been changed in Python 3:</source>
          <target state="translated">Python 3ではメタクラスを設定する構文が変更されました。</target>
        </trans-unit>
        <trans-unit id="b4d33846e5640be4c1d9597eafdcc9bc72aceaf5" translate="yes" xml:space="preserve">
          <source>The thing that's left to say is: If you don't know what metaclasses are, the probability that you &lt;strong&gt;will not need them&lt;/strong&gt; is 99%.</source>
          <target state="translated">残すべきことは、メタクラスが何であるかがわからない場合、メタクラスが&lt;strong&gt;不要になる&lt;/strong&gt;確率は99％です。</target>
        </trans-unit>
        <trans-unit id="959c3572d6d62fe879c68854fc146ad30c9bb8cd" translate="yes" xml:space="preserve">
          <source>The tl;dr version</source>
          <target state="translated">tl;drバージョン</target>
        </trans-unit>
        <trans-unit id="656d2c5fc9c081a8217d9d6a68f3f31fc9b34aef" translate="yes" xml:space="preserve">
          <source>The type() function can return the type of an object or create a new type,</source>
          <target state="translated">type()関数は、オブジェクトの型を返したり、新しい型を作成したりすることができます。</target>
        </trans-unit>
        <trans-unit id="733141dd8934a1c4901342843517b7b8404b6323" translate="yes" xml:space="preserve">
          <source>Then if it can't find any &lt;code&gt;__metaclass__&lt;/code&gt; at all, it will use the &lt;code&gt;Bar&lt;/code&gt;'s (the first parent) own metaclass (which might be the default &lt;code&gt;type&lt;/code&gt;) to create the class object.</source>
          <target state="translated">次に、__ metaclass__がまったく見つからない場合は、 &lt;code&gt;Bar&lt;/code&gt; の（最初の親）独自のメタクラス（デフォルトの &lt;code&gt;type&lt;/code&gt; ある可能性があります）を使用してクラスオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="a771a2f9cc215079a67d4f526fd98ab5b55dcf1f" translate="yes" xml:space="preserve">
          <source>There are (at this point) two key methods in a metaclass:</source>
          <target state="translated">メタクラスには(この時点で)2つの重要なメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="40e0c7527fe508c7995960aaf38056900b9ff412" translate="yes" xml:space="preserve">
          <source>There are several reasons to do so:</source>
          <target state="translated">その理由はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="9e2063eee3f575331ddd73d7a81c2d318f5daa93" translate="yes" xml:space="preserve">
          <source>These are called metaclasses, damn it! It must mean something!</source>
          <target state="translated">これはメタクラスと呼ばれている 畜生!何か意味があるはずだ!</target>
        </trans-unit>
        <trans-unit id="3b5c4cd62ac6b431a5176848fb6508cfa06be65a" translate="yes" xml:space="preserve">
          <source>This is a case where I saw metaclass as a solution to my problem:
I had a really complicated problem, that probably could have been solved differently, but I chose to solve it using a metaclass.  Because of the complexity, it is one of the few modules I have written where the comments in the module surpass the amount of code that has been written.  Here it is...</source>
          <target state="translated">これは私がメタクラスを自分の問題の解決策として見たケースです:私は本当に複雑な問題を抱えていて、それはおそらく別の方法で解決できたかもしれませんが、私はそれをメタクラスを使って解決することを選びました。その複雑さゆえに、私が書いた数少ないモジュールの一つで、モジュール内のコメントが書かれたコードの量を超えています。ここにあります...</target>
        </trans-unit>
        <trans-unit id="bd01e02e8d937d71c953efd2b047baa65d13a9d0" translate="yes" xml:space="preserve">
          <source>This is a class that uses that metaclass</source>
          <target state="translated">これはそのメタクラスを使ったクラスです。</target>
        </trans-unit>
        <trans-unit id="0eaab00f42bc385328b90e65be0df9fd3ce443e5" translate="yes" xml:space="preserve">
          <source>This is a metaclass that logs exactly the moment before an instance is created and the moment it's about to return it.</source>
          <target state="translated">これは、インスタンスが作成される前の瞬間と、インスタンスが戻ろうとしている瞬間を正確にログに記録するメタクラスです。</target>
        </trans-unit>
        <trans-unit id="a91ffeba7150d22f41622349f220dc2a7bd0941e" translate="yes" xml:space="preserve">
          <source>This is possible because &lt;code&gt;models.Model&lt;/code&gt; defines &lt;code&gt;__metaclass__&lt;/code&gt; and
it uses some magic that will turn the &lt;code&gt;Person&lt;/code&gt; you just defined with simple statements
into a complex hook to a database field.</source>
          <target state="translated">これが可能なのは、 &lt;code&gt;models.Model&lt;/code&gt; が &lt;code&gt;__metaclass__&lt;/code&gt; を定義し、単純なステートメントで定義した &lt;code&gt;Person&lt;/code&gt; をデータベースフィールドへの複雑なフックに変換する魔法を使用しているためです 。</target>
        </trans-unit>
        <trans-unit id="4f1bef529754046ab93614c707e29ea65f065a58" translate="yes" xml:space="preserve">
          <source>This is what Python does when you use the keyword &lt;code&gt;class&lt;/code&gt;, and it does so by using a metaclass.</source>
          <target state="translated">これは、キーワード &lt;code&gt;class&lt;/code&gt; を使用するときにPythonが行うことであり、メタクラスを使用して行います。</target>
        </trans-unit>
        <trans-unit id="690dffa17d6286ca4b5f0d265293b3aba8dc9308" translate="yes" xml:space="preserve">
          <source>This is what the metaclass would look like (not using &lt;code&gt;__prepare__&lt;/code&gt; since it is not needed):</source>
          <target state="translated">メタクラスは次のようになります（必要ないため &lt;code&gt;__prepare__&lt;/code&gt; は使用しません）。</target>
        </trans-unit>
        <trans-unit id="3a703a42ef6d26d4b5acc17812e989feee889a40" translate="yes" xml:space="preserve">
          <source>This way, all classes of this module will be created using this metaclass,
and we just have to tell the metaclass to turn all attributes to uppercase.</source>
          <target state="translated">このようにして、このモジュールのすべてのクラスがこのメタクラスを使って作成され、すべての属性を大文字にするようにメタクラスに指示するだけです。</target>
        </trans-unit>
        <trans-unit id="c8eb39184302c31569399fad3b80b08d690c761d" translate="yes" xml:space="preserve">
          <source>To create a metaclass, overriding of &lt;strong&gt;new&lt;/strong&gt;() and &lt;strong&gt;init&lt;/strong&gt;() methods is usually done. &lt;strong&gt;new&lt;/strong&gt;() can be overridden to change the way objects are created, while &lt;strong&gt;init&lt;/strong&gt;() can be overridden to change the way of initializing the object. Metaclass can be created by a number of ways. One of the ways is to use type() function. type() function, when called with 3 parameters, creates a metaclass. The parameters are :-</source>
          <target state="translated">メタクラスを作成するには、通常、 &lt;strong&gt;new&lt;/strong&gt; （）および&lt;strong&gt;init&lt;/strong&gt; （）メソッドをオーバーライドします。 &lt;strong&gt;new&lt;/strong&gt; （）をオーバーライドしてオブジェクトの作成方法を変更できます&lt;strong&gt;。init&lt;/strong&gt; （）をオーバーライドしてオブジェクトの初期化方法を変更できます。 メタクラスはいくつかの方法で作成できます。 1つの方法は、type（）関数を使用することです。 type（）関数は、3つのパラメーターを指定して呼び出されると、メタクラスを作成します。 パラメータは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7f66480aa700b9c3c9e3a6513f4f91ad438a6ac8" translate="yes" xml:space="preserve">
          <source>To use a metaclass:</source>
          <target state="translated">メタクラスを使用するには</target>
        </trans-unit>
        <trans-unit id="9d625953b8c96c50aabee6488063e1446a582041" translate="yes" xml:space="preserve">
          <source>Tuple having base classes inherited by class</source>
          <target state="translated">クラスを継承した基底クラスを持つタプル</target>
        </trans-unit>
        <trans-unit id="d0594a199ce5d4ac41e3201736acd504b143394b" translate="yes" xml:space="preserve">
          <source>We can extend &lt;code&gt;type&lt;/code&gt; just like any other class definition:</source>
          <target state="translated">他のクラス定義と同じように &lt;code&gt;type&lt;/code&gt; を拡張できます。</target>
        </trans-unit>
        <trans-unit id="d88182269b2e241ec478b27d4767550768772015" translate="yes" xml:space="preserve">
          <source>We can make it even cleaner by using &lt;code&gt;super&lt;/code&gt;, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):</source>
          <target state="translated">継承を容易にする &lt;code&gt;super&lt;/code&gt; を使用することで、さらにクリーンにすることができます（そうすることで、メタクラス、メタクラスから継承、タイプから継承できるため）。</target>
        </trans-unit>
        <trans-unit id="92762df1c860bcdb2ae4c1a3bc542b57879d0959" translate="yes" xml:space="preserve">
          <source>We can see that the metaclass' &lt;code&gt;__call__()&lt;/code&gt; method is the one that's called first. It then delegates creation of the instance to the class's &lt;code&gt;__new__()&lt;/code&gt; method and initialization to the instance's &lt;code&gt;__init__()&lt;/code&gt;. It's also the one that ultimately returns the instance.</source>
          <target state="translated">メタクラスの &lt;code&gt;__call__()&lt;/code&gt; メソッドが最初に呼び出されるメソッドであることがわかります。 次に、インスタンスの作成をクラスの &lt;code&gt;__new__()&lt;/code&gt; メソッドに委任し 、初期化をインスタンスの &lt;code&gt;__init__()&lt;/code&gt; 委任します。 また、最終的にインスタンスを返すものでもあります。</target>
        </trans-unit>
        <trans-unit id="16d288708e3034e3415f37e929abe09a44ae3d9f" translate="yes" xml:space="preserve">
          <source>Well in fact, classes are themselves instances. Of metaclasses.</source>
          <target state="translated">実際にはクラスはそれ自体がインスタンスだ メタクラスの</target>
        </trans-unit>
        <trans-unit id="d278e4f17ef8ed67c2a22f4c32904a94d842130f" translate="yes" xml:space="preserve">
          <source>Well, &lt;a href=&quot;http://docs.python.org/2/library/functions.html#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; has a completely different ability, it can also create classes on the fly. &lt;code&gt;type&lt;/code&gt; can take the description of a class as parameters,
and return a class.</source>
          <target state="translated">まあ、 &lt;a href=&quot;http://docs.python.org/2/library/functions.html#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;は完全に異なる能力を持っています、それはまたその場でクラスを作成することもできます。 &lt;code&gt;type&lt;/code&gt; は、クラスの説明をパラメーターとして取り、クラスを返すことができます。</target>
        </trans-unit>
        <trans-unit id="f58b345320ab6cedc6dd827175904f92af7b09a9" translate="yes" xml:space="preserve">
          <source>Well, I guess it's a matter of consistency with &lt;code&gt;str&lt;/code&gt;, the class that creates
strings objects, and &lt;code&gt;int&lt;/code&gt; the class that creates integer objects. &lt;code&gt;type&lt;/code&gt; is
just the class that creates class objects.</source>
          <target state="translated">それは、文字列オブジェクトを作成するクラスである &lt;code&gt;str&lt;/code&gt; と、整数オブジェクトを作成するクラスである &lt;code&gt;int&lt;/code&gt; との一貫性の問題だと思います。 &lt;code&gt;type&lt;/code&gt; は、クラスオブジェクトを作成するクラスです。</target>
        </trans-unit>
        <trans-unit id="a0696d6279da7380ed7a9d1f185eabd27a76e2f1" translate="yes" xml:space="preserve">
          <source>Well, metaclasses are what create these objects. They are the classes' classes,
you can picture them this way:</source>
          <target state="translated">メタクラスはこれらのオブジェクトを作成するものです。それらはクラスのクラスです このようにイメージすることができます</target>
        </trans-unit>
        <trans-unit id="cd8f8377093c7a9f568847ac99d779518ff62c1b" translate="yes" xml:space="preserve">
          <source>Well, usually you don't:</source>
          <target state="translated">まあ、普通はしないでしょう。</target>
        </trans-unit>
        <trans-unit id="464df4ba1017e09b5d8fcbcb6bc3f85fc5e4129e" translate="yes" xml:space="preserve">
          <source>What are metaclasses (finally)</source>
          <target state="translated">メタクラスとは何か(最終的に</target>
        </trans-unit>
        <trans-unit id="7be40721cc8b807cb99d9d947eae9af189c69085" translate="yes" xml:space="preserve">
          <source>What are metaclasses in Python</source>
          <target state="translated">Pythonのメタクラスとは</target>
        </trans-unit>
        <trans-unit id="95ac2d20e8da72812ecb5a849d130ac5cab6552d" translate="yes" xml:space="preserve">
          <source>What are metaclasses? What do you use them for?</source>
          <target state="translated">メタクラスとは何ですか?何に使うの?</target>
        </trans-unit>
        <trans-unit id="ca7233bf93e47a10f12eab5a25b942225351fd97" translate="yes" xml:space="preserve">
          <source>What can they be used for? From the &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">それらは何に使用できますか？ &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;ドキュメント&lt;/a&gt;から：</target>
        </trans-unit>
        <trans-unit id="faccab95a2838e0f66852ca4a5c0f3a913942d90" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;class&lt;/code&gt; statement is executed, Python first executes the body of the &lt;code&gt;class&lt;/code&gt; statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the &lt;code&gt;__metaclass__&lt;/code&gt; attribute of the class-to-be (if any) or the &lt;code&gt;__metaclass__&lt;/code&gt; global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; ステートメントが実行されると、Pythonはまず &lt;code&gt;class&lt;/code&gt; ステートメントの本体を通常のコードブロックとして実行します。 結果の名前空間（dict）は、存在するクラスの属性を保持します。 メタクラスは、対象クラスのベースクラス（メタクラスは継承されます）、対象クラスの &lt;code&gt;__metaclass__&lt;/code&gt; 属性（存在する場合）、または &lt;code&gt;__metaclass__&lt;/code&gt; グローバル変数を調べることによって決定されます。 次に、メタクラスがクラスの名前、ベース、属性とともに呼び出され、インスタンス化されます。</target>
        </trans-unit>
        <trans-unit id="0f703991c228a312fa1f4a4718f72097c5f38dc7" translate="yes" xml:space="preserve">
          <source>When we instantiate an object, we get an instance:</source>
          <target state="translated">オブジェクトをインスタンス化すると、インスタンスを取得します。</target>
        </trans-unit>
        <trans-unit id="2e8ee345e21d7df889e916663fa72306a26db891" translate="yes" xml:space="preserve">
          <source>When you do:</source>
          <target state="translated">その時は</target>
        </trans-unit>
        <trans-unit id="8eadeed1a219183cc2c88f7ec677f6b2d5aec1aa" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; keyword, Python creates this object automatically. But as
with most things in Python, it gives you a way to do it manually.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; キーワードを使用すると、Pythonはこのオブジェクトを自動的に作成します。 しかし、Pythonのほとんどの場合と同様に、これを使用して手動で行うことができます。</target>
        </trans-unit>
        <trans-unit id="ea3a686b188cb5fead0828deafd55680a345ac59" translate="yes" xml:space="preserve">
          <source>When you write a class definition and Python executes it, it uses a metaclass to instantiate the class object (which will, in turn, be used to instantiate instances of that class).</source>
          <target state="translated">クラス定義を書いてPythonがそれを実行すると、メタクラスを使ってクラスオブジェクトのインスタンス化を行います(これは順番にそのクラスのインスタンス化に使われます)。</target>
        </trans-unit>
        <trans-unit id="0c3bff2984a4115df4dcc3bfb7149ff8691306a4" translate="yes" xml:space="preserve">
          <source>When you write a class definition, for example, like this,</source>
          <target state="translated">クラス定義を書くとき、例えばこんな感じです。</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="8c962cb76a1933afc23c5280c46178cdc0963538" translate="yes" xml:space="preserve">
          <source>While in Python you can use arbitrary callables for metaclasses (like &lt;a href=&quot;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037&quot;&gt;Jerub&lt;/a&gt; shows), the better approach is to make it an actual class itself. &lt;code&gt;type&lt;/code&gt; is the usual metaclass in Python. &lt;code&gt;type&lt;/code&gt; is itself a class, and it is its own type. You won't be able to recreate something like &lt;code&gt;type&lt;/code&gt; purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Pythonではメタクラス（ &lt;a href=&quot;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037&quot;&gt;Jerub&lt;/a&gt;ショーなど）に任意の呼び出し可能オブジェクトを使用できますが、より良いアプローチは、それ自体を実際のクラスにすることです。 &lt;code&gt;type&lt;/code&gt; はPythonの通常のメタクラスです。 &lt;code&gt;type&lt;/code&gt; はそれ自体がクラスであり、独自の型です。 &lt;code&gt;type&lt;/code&gt; ようなものを純粋にPythonで再作成することはできませんが、Pythonは少しごまかします。 Pythonで独自のメタクラスを作成するには、本当に &lt;code&gt;type&lt;/code&gt; をサブクラス化したいだけです。</target>
        </trans-unit>
        <trans-unit id="ff246de9114513e53dcf845cd6f5e43b2c9dffe8" translate="yes" xml:space="preserve">
          <source>Why would you use metaclasses classes instead of functions?</source>
          <target state="translated">なぜ関数ではなくメタクラスを使うのか?</target>
        </trans-unit>
        <trans-unit id="29f54ff47c50feb7cebfef143da1409f28cafef5" translate="yes" xml:space="preserve">
          <source>Why would you use metaclasses?</source>
          <target state="translated">なぜメタクラスを使うのか?</target>
        </trans-unit>
        <trans-unit id="70111da65d9e847b219ad4430cd1c1828a6ec8a3" translate="yes" xml:space="preserve">
          <source>With a nice &lt;code&gt;__repr__&lt;/code&gt; defined for the class instance, we have a stronger ability to debug our code. However, much further checking with &lt;code&gt;eval(repr(Class))&lt;/code&gt; is unlikely (as functions would be rather impossible to eval from their default &lt;code&gt;__repr__&lt;/code&gt;'s).</source>
          <target state="translated">クラスインスタンスに素敵な &lt;code&gt;__repr__&lt;/code&gt; を定義すると、コードをデバッグする機能が強化されます。 ただし、 &lt;code&gt;eval(repr(Class))&lt;/code&gt; を使用してそれ以上チェックすることはほとんどありません（関数がデフォルトの &lt;code&gt;__repr__&lt;/code&gt; から評価することはかなり不可能であるため）。</target>
        </trans-unit>
        <trans-unit id="7e2b61a0c2abd2b5f5ed9ec2bcb225e75cc74640" translate="yes" xml:space="preserve">
          <source>Yes, objects.</source>
          <target state="translated">はい、オブジェです。</target>
        </trans-unit>
        <trans-unit id="0ff433fbf5a657d09064a10812fe33b78649c66e" translate="yes" xml:space="preserve">
          <source>You can call it a 'class factory' if you wish.</source>
          <target state="translated">お望みならば「クラスファクトリー」と呼んでもいいでしょう。</target>
        </trans-unit>
        <trans-unit id="315df7f70140693e8a8bc6a5c96aefabd150fb69" translate="yes" xml:space="preserve">
          <source>You can hook on &lt;code&gt;__new__&lt;/code&gt;, &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;__call__&lt;/code&gt;. Which will allow
you to do different stuff. Even if usually you can do it all in &lt;code&gt;__new__&lt;/code&gt;,
some people are just more comfortable using &lt;code&gt;__init__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; 、 __init__および &lt;code&gt;__call__&lt;/code&gt; をフックできます 。 これにより、さまざまなことが可能になります。 通常、すべてを &lt;code&gt;__new__&lt;/code&gt; で実行できる場合でも、 __init__を使用する方が快適な場合もあります。</target>
        </trans-unit>
        <trans-unit id="58cba9a2524d4784e2abd94ecd3a9d0567aa5f1b" translate="yes" xml:space="preserve">
          <source>You can structure your code better. You never use metaclasses for something as
trivial as the above example. It's usually for something complicated. Having the
ability to make several methods and group them in one class is very useful
to make the code easier to read.</source>
          <target state="translated">あなたのコードをより良い構造にすることができます。上の例のような些細なことにメタクラスを使うことはありません。通常は複雑なものに使用します。複数のメソッドを作成し、それらを一つのクラスにまとめる機能を持つことは、コードを読みやすくするために非常に便利です。</target>
        </trans-unit>
        <trans-unit id="64c7301b56292e883aabaa3c4edaf3cf8efc42f2" translate="yes" xml:space="preserve">
          <source>You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.</source>
          <target state="translated">OOPが使える。メタクラスはメタクラスから継承したり、親メソッドをオーバーライドしたりすることができます。メタクラスはメタクラスを使うこともできる</target>
        </trans-unit>
        <trans-unit id="fb6eb327fa8c07c0f464979436e448c8c249d0c5" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;metaclass&lt;/code&gt; to change the function of its instance (the class).</source>
          <target state="translated">&lt;code&gt;metaclass&lt;/code&gt; を使用して、そのインスタンス（クラス）の機能を変更できます。</target>
        </trans-unit>
        <trans-unit id="c4bc4a8b7d34394849ad10cef64e38894a0239e3" translate="yes" xml:space="preserve">
          <source>You define classes in order to create objects, right?</source>
          <target state="translated">オブジェクトを作るためにクラスを定義するんですよね。</target>
        </trans-unit>
        <trans-unit id="849b6a4a3ab49b1e6d5d5fb3aa2174a5dd045d4a" translate="yes" xml:space="preserve">
          <source>You instantiate a class object.</source>
          <target state="translated">クラスオブジェクトをインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="452647fa644731ccf4d36abe26b42b7338dc3ada" translate="yes" xml:space="preserve">
          <source>You may have noticed the extra argument &lt;code&gt;cls&lt;/code&gt;. There is
nothing special about it: &lt;code&gt;__new__&lt;/code&gt; always receives the class it's defined in, as first parameter. Just like you have &lt;code&gt;self&lt;/code&gt; for ordinary methods which receive the instance as first parameter, or the defining class for class methods.</source>
          <target state="translated">余分な引数 &lt;code&gt;cls&lt;/code&gt; に気づいたかもしれません。 特別なことは何もありません &lt;code&gt;__new__&lt;/code&gt; 常に、最初のパラメーターとして、定義されているクラスを受け取ります。 インスタンスを最初のパラメーターとして受け取る通常のメソッドの &lt;code&gt;self&lt;/code&gt; や、クラスメソッドの定義クラスのように。</target>
        </trans-unit>
        <trans-unit id="22aa6e506f7cc49a7a64f3ca6d175caba8e4b9d1" translate="yes" xml:space="preserve">
          <source>You see that by checking the &lt;code&gt;__class__&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;__class__&lt;/code&gt; 属性を確認するとわかります。</target>
        </trans-unit>
        <trans-unit id="cbebccfb501c9be50998ab8dec87986aaf76e78c" translate="yes" xml:space="preserve">
          <source>You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.</source>
          <target state="translated">Pythonでは、クラスはオブジェクトであり、動的にその場でクラスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="33931bf86a8faf49146362a3955005056936d8f9" translate="yes" xml:space="preserve">
          <source>You use a metaclass every time you create a class:</source>
          <target state="translated">クラスを作成するたびにメタクラスを使用します。</target>
        </trans-unit>
        <trans-unit id="892eaf1f9b8ad532b3d9e3281eddca7576cc2b2a" translate="yes" xml:space="preserve">
          <source>You usually do this for APIs, where you want to create classes matching the
current context.</source>
          <target state="translated">これは通常、現在のコンテキストにマッチするクラスを作成したいAPIに対して行います。</target>
        </trans-unit>
        <trans-unit id="c865cc52046698fef0b1aa97a9a5a1e90813f189" translate="yes" xml:space="preserve">
          <source>You write &lt;code&gt;class Foo(object)&lt;/code&gt; first, but the class object &lt;code&gt;Foo&lt;/code&gt; is not created
in memory yet.</source>
          <target state="translated">最初に &lt;code&gt;class Foo(object)&lt;/code&gt; 記述しますが、クラスオブジェクト &lt;code&gt;Foo&lt;/code&gt; はまだメモリ内に作成されていません。</target>
        </trans-unit>
        <trans-unit id="fba87a7567989400ed959bfd1f57626604f0e103" translate="yes" xml:space="preserve">
          <source>You'll notice that we use &quot;MyShinyClass&quot; as the name of the class
and as the variable to hold the class reference. They can be different,
but there is no reason to complicate things.</source>
          <target state="translated">クラス名として、またクラス参照を保持する変数として「MyShinyClass」を使用していることにお気づきでしょう。これらは異なるものであっても構いませんが、物事を複雑にする理由はありません。</target>
        </trans-unit>
        <trans-unit id="468ec3a2130a90f33fbe9e9010d78aea548729a5" translate="yes" xml:space="preserve">
          <source>You've seen that &lt;code&gt;type&lt;/code&gt; lets you do something like this:</source>
          <target state="translated">この &lt;code&gt;type&lt;/code&gt; 使用すると、次のようなことができることがわかりました。</target>
        </trans-unit>
        <trans-unit id="62dbbb0781988a55d8018a0fec2c8ecd07b793aa" translate="yes" xml:space="preserve">
          <source>anyhow, those two are the most commonly used hooks. metaclassing is powerful, and above is nowhere near and exhaustive list of uses for metaclassing.</source>
          <target state="translated">いずれにしても、この2つは最も一般的に使われているフックです。メタクラス化は強力であり、上記はメタクラス化の用途の網羅的なリストではありません。</target>
        </trans-unit>
        <trans-unit id="b3505d90044ca3190f7e9581b12b5ae05136055b" translate="yes" xml:space="preserve">
          <source>can be created manually this way:</source>
          <target state="translated">は、この方法で手動で作成することができます。</target>
        </trans-unit>
        <trans-unit id="6737e4457bda9ffaf5726333b2319e8722cf25b9" translate="yes" xml:space="preserve">
          <source>class decorators</source>
          <target state="translated">クラスデコレータ</target>
        </trans-unit>
        <trans-unit id="44c4e8ef96ee00251b1324e275bce4fb98f44122" translate="yes" xml:space="preserve">
          <source>creates in memory an object with the name &quot;ObjectCreator&quot;.</source>
          <target state="translated">ObjectCreator &quot;という名前のオブジェクトをメモリに作成します。</target>
        </trans-unit>
        <trans-unit id="4f7f64c1613218412d7173f07c7407d18b5776a8" translate="yes" xml:space="preserve">
          <source>e.g.:</source>
          <target state="translated">e.g.:</target>
        </trans-unit>
        <trans-unit id="7db9ff8b86f3d42798dfbf41b5e2001a92aac528" translate="yes" xml:space="preserve">
          <source>for example, we can create a Hi class with the type() function and do not  need to use this way with class Hi(object):</source>
          <target state="translated">例えば、type()関数でHiクラスを作ることができ、クラスHi(object)ではこの方法を使う必要はありません。</target>
        </trans-unit>
        <trans-unit id="760b292bf27a8fcf8c272fa886f3c465a88b9738" translate="yes" xml:space="preserve">
          <source>i.e. the &lt;code&gt;__metaclass__&lt;/code&gt; attribute is no longer used, in favor of a keyword argument in the list of base classes.</source>
          <target state="translated">つまり、基本クラスのリストのキーワード引数を優先して、 &lt;code&gt;__metaclass__&lt;/code&gt; 属性は使用されなくなりました。</target>
        </trans-unit>
        <trans-unit id="bebe93e3c9401a8e4b84a6e20e06834c7fbff805" translate="yes" xml:space="preserve">
          <source>intercept a class creation</source>
          <target state="translated">クラス作成を傍受する</target>
        </trans-unit>
        <trans-unit id="b6a7d03698a36198740b6b7e1269046f935e6ce5" translate="yes" xml:space="preserve">
          <source>meta class are used to apply some rule to an entire set of classes. For example, suppose you're building an ORM to access a database, and you want records from each table to be of a class mapped to that table (based on fields, business rules, etc..,), a possible use of metaclass is for instance, connection pool logic, which is share by all classes of record from all tables. Another use is logic to to support foreign keys, which involves multiple classes of records.</source>
          <target state="translated">メタクラスはクラスのセット全体に何らかのルールを適用するために使用されます。例えば、データベースにアクセスするためのORMを構築していて、各テーブルからのレコードをそのテーブルにマッピングされたクラスにしたいとします (フィールドやビジネスルールなどに基づいて)。他にも、レコードの複数のクラスを含む外部キーをサポートするためのロジックを使用することができます。</target>
        </trans-unit>
        <trans-unit id="b24e026cd23631fc8326fba464790376a289820a" translate="yes" xml:space="preserve">
          <source>modify the class</source>
          <target state="translated">クラスを変更する</target>
        </trans-unit>
        <trans-unit id="1123af1e86c1be3e13a73d667767a3eaa9fab222" translate="yes" xml:space="preserve">
          <source>monkey patching</source>
          <target state="translated">モンキーパッチ</target>
        </trans-unit>
        <trans-unit id="2bcec56171df3c6150684b60fb0f16c51e1923ed" translate="yes" xml:space="preserve">
          <source>produces:</source>
          <target state="translated">produces:</target>
        </trans-unit>
        <trans-unit id="17156a7f53f004d6bfc86c20c78c7a60336f9799" translate="yes" xml:space="preserve">
          <source>return the modified class</source>
          <target state="translated">変更されたクラスを返します。</target>
        </trans-unit>
        <trans-unit id="f89967a1b044b115ecabfb714ba2baf9e25b3905" translate="yes" xml:space="preserve">
          <source>when a particular effect has to be applied to all the subclasses</source>
          <target state="translated">特定の効果をすべてのサブクラスに適用しなければならない場合</target>
        </trans-unit>
        <trans-unit id="129a078ecb9597f440ced3af47b17543ec3a8923" translate="yes" xml:space="preserve">
          <source>when you define metaclass, you subclass type, and can overrided the following magic methods to insert your logic.</source>
          <target state="translated">メタクラスを定義する際には、型をサブクラス化し、以下のマジックメソッドをオーバーライドしてロジックを挿入することができます。</target>
        </trans-unit>
        <trans-unit id="a0ebc00ce2803c4b05ae16c519fdb6afbeecd7c8" translate="yes" xml:space="preserve">
          <source>would be:</source>
          <target state="translated">となるでしょう。</target>
        </trans-unit>
        <trans-unit id="f00aae84260cf328c69240a8408c132eec41893a" translate="yes" xml:space="preserve">
          <source>you can add attributes to it</source>
          <target state="translated">属性を追加することができます。</target>
        </trans-unit>
        <trans-unit id="7f5329be6ce9f06a3c0b500a9af459ec3e4c8730" translate="yes" xml:space="preserve">
          <source>you can assign it to a variable</source>
          <target state="translated">変数に割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="d5e1f2ccb7cae42051601ddb1f83165a911f6cab" translate="yes" xml:space="preserve">
          <source>you can copy it</source>
          <target state="translated">あなたはそれをコピーすることができます</target>
        </trans-unit>
        <trans-unit id="98b6e75ac98f8c1aab7ac264a673d0bea107ebd2" translate="yes" xml:space="preserve">
          <source>you can pass it as a function parameter</source>
          <target state="translated">関数のパラメータとして渡すことができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
