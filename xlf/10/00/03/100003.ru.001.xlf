<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/100003">
    <body>
      <group id="100003">
        <trans-unit id="75f904e8b7fedc01e237553e4c1e63dc973e6787" translate="yes" xml:space="preserve">
          <source>(A side-note on the contents of the class &lt;code&gt;__dict__&lt;/code&gt;: &lt;code&gt;__module__&lt;/code&gt; is there because classes must know where they are defined, and  &lt;code&gt;__dict__&lt;/code&gt; and &lt;code&gt;__weakref__&lt;/code&gt; are there because we don't define &lt;code&gt;__slots__&lt;/code&gt; - if we &lt;a href=&quot;https://stackoverflow.com/q/472000/541136&quot;&gt;define &lt;code&gt;__slots__&lt;/code&gt;&lt;/a&gt; we'll save a bit of space in the instances, as we can disallow &lt;code&gt;__dict__&lt;/code&gt; and &lt;code&gt;__weakref__&lt;/code&gt; by excluding them. For example:</source>
          <target state="translated">(Замечание по содержанию класса &lt;code&gt;__dict__&lt;/code&gt; : &lt;code&gt;__module__&lt;/code&gt; есть, потому что классы должны знать, где они определены, и &lt;code&gt;__dict__&lt;/code&gt; и &lt;code&gt;__weakref__&lt;/code&gt; там, потому что мы не определяем &lt;code&gt;__slots__&lt;/code&gt; - если мы &lt;a href=&quot;https://stackoverflow.com/q/472000/541136&quot;&gt;определим &lt;code&gt;__slots__&lt;/code&gt; ,&lt;/a&gt; мы сохраним немного пространство в экземплярах, поскольку мы можем запретить &lt;code&gt;__dict__&lt;/code&gt; и &lt;code&gt;__weakref__&lt;/code&gt; , исключив их. Например:</target>
        </trans-unit>
        <trans-unit id="80ce04df15f97539136582b49b933ab604f9103b" translate="yes" xml:space="preserve">
          <source>(I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backwards
compatibility in Python)</source>
          <target state="translated">(Я знаю,это глупо,что одна и та же функция может иметь два совершенно разных назначения в зависимости от параметров,которые вы ей передаете.Это проблема из-за обратной совместимости на Python).</target>
        </trans-unit>
        <trans-unit id="2ac0d02e51ef16f7af8ae886bdf0e4fa530c5f5d" translate="yes" xml:space="preserve">
          <source>... but I digress.)</source>
          <target state="translated">...но я отступаю.)</target>
        </trans-unit>
        <trans-unit id="f6ebd068cb008bd8fb59b8b2729d85510c67060a" translate="yes" xml:space="preserve">
          <source>99% of the time you need class alteration, you are better off using these.</source>
          <target state="translated">99% времени,когда вам нужно изменить класс,вам лучше использовать их.</target>
        </trans-unit>
        <trans-unit id="97c9f0c35f46135bb3f31b3babd294116e47cb9e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&lt;/a&gt; (archived at &lt;a href=&quot;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&lt;/a&gt; (архивируется по адресу &lt;a href=&quot;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;https://web.archive.org/web/20080206005253/http://www.onlamp. com / pub / a / python / 2003/04/17 / metaclasses.html&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3bdb50500a7c19592bda8809f1f54a3155b055d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclasses&quot;&gt;Here&lt;/a&gt; you can read about how to use metaclasses to customize class construction.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclasses&quot;&gt;Здесь&lt;/a&gt; вы можете прочитать о том, как использовать метаклассы для настройки построения классов.</target>
        </trans-unit>
        <trans-unit id="a50fc3237b1a93efefaaf939cf45f327c9ed165c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__new__&lt;/code&gt; is responsible for the actual creation/modification of the final class.</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; отвечает за фактическое создание / модификацию финального класса.</target>
        </trans-unit>
        <trans-unit id="1a0d6bf17eaa1810f965cf7374357b165ec381aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__prepare__&lt;/code&gt; lets you supply a custom mapping (such as an &lt;code&gt;OrderedDict&lt;/code&gt;) to be used as the namespace while the class is being created.  You must return an instance of whatever namespace you choose.  If you don't implement &lt;code&gt;__prepare__&lt;/code&gt; a normal &lt;code&gt;dict&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;__prepare__&lt;/code&gt; позволяет вам предоставить пользовательское отображение (например, &lt;code&gt;OrderedDict&lt;/code&gt; ), которое будет использоваться в качестве пространства имен во время создания класса. Вы должны вернуть экземпляр любого пространства имен, которое вы выберете. Если вы не реализуете &lt;code&gt;__prepare__&lt;/code&gt; , используется обычный &lt;code&gt;dict&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="023d195e822e75fe65a0924f1427b5fdf01fc5ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__prepare__&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;__prepare__&lt;/code&gt; и</target>
        </trans-unit>
        <trans-unit id="7d878c7158652444f7186704c3b33f7141e22209" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; accepts a dictionary to define the attributes of the class. So:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; принимает словарь для определения атрибутов класса. Так:</target>
        </trans-unit>
        <trans-unit id="5d2e1c2d0bbec05a50948a1721fe99a3b39aa6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is actually a &lt;code&gt;metaclass&lt;/code&gt; -- a class that creates another classes.
Most &lt;code&gt;metaclass&lt;/code&gt; are the subclasses of &lt;code&gt;type&lt;/code&gt;. The &lt;code&gt;metaclass&lt;/code&gt; receives the &lt;code&gt;new&lt;/code&gt; class as its first argument and provide access to class object with details as mentioned below:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; на самом деле &lt;code&gt;metaclass&lt;/code&gt; - класс, который создает другие классы. Большинство &lt;code&gt;metaclass&lt;/code&gt; являются подклассами &lt;code&gt;type&lt;/code&gt; . &lt;code&gt;metaclass&lt;/code&gt; получает &lt;code&gt;new&lt;/code&gt; класс в качестве первого аргумента и предоставляет доступ к объекту класса с деталями, как указано ниже:</target>
        </trans-unit>
        <trans-unit id="d9eba8487bfc807b1b32e61a4fcc2b4d4099fc9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is actually its own metaclass. This is not something you could
reproduce in pure Python, and is done by cheating a little bit at the implementation
level.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; на самом деле его собственный метакласс. Это не то, что вы могли бы воспроизвести на чистом Python, и это делается путем обмана на уровне реализации.</target>
        </trans-unit>
        <trans-unit id="55ff24a1972577aa56cf45cfad50fad1fa3a38ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is its own metaclass. The class of a class is a metaclass-- the body of a class is the arguments passed to the metaclass that is used to construct the class.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - это собственный метакласс. Класс класса - это метакласс - тело класса - это аргументы, передаваемые метаклассу, который используется для создания класса.</target>
        </trans-unit>
        <trans-unit id="b56139b823c7b0ae94bce907510423f13ee59acc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is the built-in metaclass Python uses, but of course, you can create your
own metaclass.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - это встроенный метакласс, который использует Python, но, конечно, вы можете создать свой собственный метакласс.</target>
        </trans-unit>
        <trans-unit id="2e9b06716bef6742d220da876612fb09c18a1de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; works this way:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; работает следующим образом:</target>
        </trans-unit>
        <trans-unit id="a9b27deb1c48c1688dcbf6153f9703f0928f091b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note, this answer is for Python 2.x as it was written in 2008, metaclasses are slightly different in 3.x.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Обратите внимание, что этот ответ для Python 2.x, как он был написан в 2008 году, метаклассы немного отличаются в 3.x.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90461ec79be347574dc9366bf79436c53a18378b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Python Guru Tim Peters&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Питон Гуру Тим Питерс&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaee62583d5533c9937128f100302a2beb82df5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;attrs&lt;/code&gt;&lt;/strong&gt;: dictionary containing attributes names and values</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;attrs&lt;/code&gt; &lt;/strong&gt; : словарь, содержащий имена и значения атрибутов</target>
        </trans-unit>
        <trans-unit id="6b235afc3403ff79e2b3ea50c1ad732bc7d0bc59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;bases&lt;/code&gt;&lt;/strong&gt;: tuple of the parent class (for inheritance, can be empty)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;bases&lt;/code&gt; &lt;/strong&gt; : кортеж родительского класса (для наследования может быть пустым)</target>
        </trans-unit>
        <trans-unit id="f9b873798f48e29d3714485763a3478bb4a497d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;name&lt;/code&gt;&lt;/strong&gt;: name of the class</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;name&lt;/code&gt; &lt;/strong&gt; : название класса</target>
        </trans-unit>
        <trans-unit id="f7b324be8699a5976c969c726c75d9164d86dcb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that the magic behaviour that &lt;code&gt;Initialised&lt;/code&gt; gains by having the metaclass &lt;code&gt;init_attributes&lt;/code&gt; is not passed onto a subclass of &lt;code&gt;Initialised&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обратите внимание, что магическое поведение, которое &lt;code&gt;Initialised&lt;/code&gt; получает, имея метакласс &lt;code&gt;init_attributes&lt;/code&gt; , не передается подклассу &lt;code&gt;Initialised&lt;/code&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ac292049c7ca4650474b47279520a7d5fdba79f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;:  This example is simple enough it could have also been accomplished with a class decorator, but presumably an actual metaclass would be doing much more.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Этот пример достаточно прост, его также можно было бы выполнить с помощью декоратора классов, но, вероятно, реальный метакласс сделал бы гораздо больше.</target>
        </trans-unit>
        <trans-unit id="18064ffdb8c53a2819134a580d83cb2c5c9bab27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 3 update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обновление Python 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fd0a25468fd58988cf36428bbcb7968431bd58e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;type()&lt;/code&gt; of a class is its &lt;em&gt;metaclass&lt;/em&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;type()&lt;/code&gt; класса является его &lt;em&gt;метаклассом&lt;/em&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c766e32141cfa3130f81de60585eea6ff38f65d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This object (the class) is itself capable of creating objects (the instances),
and this is why it's a class&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Этот объект (класс) сам по себе способен создавать объекты (экземпляры), и именно поэтому он является классом&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6c248c325fb87b5d5270a24375d32cd2c9f65122" translate="yes" xml:space="preserve">
          <source>A bare-bones, do-nothing-extra metaclass would like:</source>
          <target state="translated">Голые кости,не желающие ничего и не имеющие экстренного метакласа:</target>
        </trans-unit>
        <trans-unit id="92b4c38772f64c8e05f839618ee864357a996cbf" translate="yes" xml:space="preserve">
          <source>A class is to an instance as a metaclass is to a class.</source>
          <target state="translated">Класс-к экземпляру,как метакласс-к классу.</target>
        </trans-unit>
        <trans-unit id="0c27db643b5b5e645284c4cc80a9276398d074a2" translate="yes" xml:space="preserve">
          <source>A class, in Python, is an object, and just like any other object, it is an instance of &quot;something&quot;. This &quot;something&quot; is what is termed as a Metaclass. This metaclass is a special type of class that creates other class's objects. Hence, metaclass is responsible for making new classes. This allows the programmer to customize the way classes are generated.</source>
          <target state="translated">Класс на Python-это объект,и,как и любой другой объект,это экземпляр &quot;нечто&quot;.Это &quot;нечто&quot; и называется Metaclass.Этот метакласс-специальный тип класса,который создает объекты другого класса.Следовательно,метакласс отвечает за создание новых классов.Это позволяет программисту настроить способ генерации классов.</target>
        </trans-unit>
        <trans-unit id="98368b5bba9571afb40d6d81649f78ad6a167a0f" translate="yes" xml:space="preserve">
          <source>A dictionary having all class methods and class variables</source>
          <target state="translated">Словарь,содержащий все методы и переменные классов.</target>
        </trans-unit>
        <trans-unit id="07bad8c7f891539fd063eae960107658c65808db" translate="yes" xml:space="preserve">
          <source>A metaclass is a class that tells how (some) other class should be created.</source>
          <target state="translated">Метакласс-это класс,который сообщает,как (какой-то)другой класс должен быть создан.</target>
        </trans-unit>
        <trans-unit id="873c9fcb3efb256f101a6622b416b45f928aa997" translate="yes" xml:space="preserve">
          <source>A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;__new__&lt;/code&gt; methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.</source>
          <target state="translated">Метакласс чаще всего используется как фабрика классов. Когда вы создаете объект, вызывая класс, Python создает новый класс (когда он выполняет оператор 'class'), вызывая метакласс. В сочетании с обычными методами &lt;code&gt;__init__&lt;/code&gt; и &lt;code&gt;__new__&lt;/code&gt; метаклассы, таким образом, позволяют создавать &amp;laquo;дополнительные вещи&amp;raquo; при создании класса, такие как регистрация нового класса в каком-либо реестре или замена класса чем-то совершенно другим.</target>
        </trans-unit>
        <trans-unit id="3486e865599100d4c2f2690dc8d832dc90595e5c" translate="yes" xml:space="preserve">
          <source>A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.</source>
          <target state="translated">Метакласс-это класс класса.Класс определяет,как ведет себя экземпляр класса (т.е.объект),в то время как метакласс определяет,как ведет себя класс.Класс-это экземпляр метакласса.</target>
        </trans-unit>
        <trans-unit id="4ea4880d366e98584d6186c7ff37dd31a7e3a934" translate="yes" xml:space="preserve">
          <source>A sample run of:</source>
          <target state="translated">Образец:</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">Простой пример:</target>
        </trans-unit>
        <trans-unit id="abaef223fba357f5e679cf230585920e62f69619" translate="yes" xml:space="preserve">
          <source>A simple metaclass can address that problem:</source>
          <target state="translated">Простой метакласс может решить эту проблему:</target>
        </trans-unit>
        <trans-unit id="f9675ef41670c1a7e08847654b4300f2976b5bd7" translate="yes" xml:space="preserve">
          <source>According to the Python object model, the class is the object, so the class must be an instance of another certain class.
By default, a Python class is instance of the type class. That is, type is metaclass of most of the built-in classes and metaclass of user-defined classes.</source>
          <target state="translated">Согласно объектной модели Python,класс является объектом,поэтому он должен быть экземпляром другого определенного класса.По умолчанию класс Python является экземпляром класса типа.То есть тип-это метакласс большинства встроенных классов и метакласс пользовательских классов.</target>
        </trans-unit>
        <trans-unit id="4adff09b65f995e39fb598615865ea22fe246c14" translate="yes" xml:space="preserve">
          <source>An expected usage: &lt;code&gt;__prepare__&lt;/code&gt; a namespace</source>
          <target state="translated">Ожидаемое использование: &lt;code&gt;__prepare__&lt;/code&gt; пространство имен</target>
        </trans-unit>
        <trans-unit id="53beca7540dd22467058afe2ce16662999fefed8" translate="yes" xml:space="preserve">
          <source>And it has approximately the correct &lt;code&gt;repr&lt;/code&gt; (which we can no longer eval unless we can find a way to represent our functions.):</source>
          <target state="translated">И он имеет приблизительно правильный &lt;code&gt;repr&lt;/code&gt; (который мы больше не сможем оценить, если не сможем найти способ представить наши функции.):</target>
        </trans-unit>
        <trans-unit id="ce4bfa8f5c082d4fff81df807663be51c7c917c2" translate="yes" xml:space="preserve">
          <source>And now let's create an instance of &lt;code&gt;Class_1&lt;/code&gt;</source>
          <target state="translated">А теперь давайте создадим экземпляр &lt;code&gt;Class_1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bf68fb2be7839bf9d1dd84adfe71a7440908b18" translate="yes" xml:space="preserve">
          <source>And now we have a record of the order in which these methods (and other class attributes) were created:</source>
          <target state="translated">А теперь у нас есть запись о том,в каком порядке были созданы эти методы (и другие атрибуты класса):</target>
        </trans-unit>
        <trans-unit id="4ca06910faa36e6b2502325b8ed3b633d8e2df95" translate="yes" xml:space="preserve">
          <source>And now, an example that actually means something, this will automatically make the variables in the list &quot;attributes&quot; set on the class, and set to None.</source>
          <target state="translated">А теперь,пример,который на самом деле что-то значит,это автоматически сделает переменные в списке &quot;атрибуты&quot;,установленные на классе,и установит значение None.</target>
        </trans-unit>
        <trans-unit id="9ab311e6c0f38e17cbdcfba4ac88667451f90d25" translate="yes" xml:space="preserve">
          <source>And of course, you can inherit from it, so:</source>
          <target state="translated">И,конечно,ты можешь унаследовать от него,так что..:</target>
        </trans-unit>
        <trans-unit id="72e4dbbed8155cf6d13a6faec1d3c917549c55be" translate="yes" xml:space="preserve">
          <source>And usage:</source>
          <target state="translated">И использование:</target>
        </trans-unit>
        <trans-unit id="0d4a22c47e425bea8ea588e394d41d40ede76cb4" translate="yes" xml:space="preserve">
          <source>And used as a normal class:</source>
          <target state="translated">И использовался как обычный урок:</target>
        </trans-unit>
        <trans-unit id="d11b95735f7ea9c7ca4cdd3c0cc7d13b93d2b46f" translate="yes" xml:space="preserve">
          <source>And what can create a class? &lt;code&gt;type&lt;/code&gt;, or anything that subclasses or uses it.</source>
          <target state="translated">А что может создать класс? &lt;code&gt;type&lt;/code&gt; , или что-нибудь, что подклассы или использует его</target>
        </trans-unit>
        <trans-unit id="649539847a08116b173bc0337d0fca037b42617c" translate="yes" xml:space="preserve">
          <source>And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.</source>
          <target state="translated">И вы можете добавить еще больше методов после динамического создания класса,так же как и добавление методов к нормально созданному объекту класса.</target>
        </trans-unit>
        <trans-unit id="530eddb18915c39bc5dcde4a3a20f4402846be8a" translate="yes" xml:space="preserve">
          <source>And, of course, you can create your own &lt;code&gt;metaclass&lt;/code&gt; to define the behaviour of any class that are created using your class.</source>
          <target state="translated">И, конечно, вы можете создать свой собственный &lt;code&gt;metaclass&lt;/code&gt; чтобы определить поведение любого класса, созданного с использованием вашего класса.</target>
        </trans-unit>
        <trans-unit id="65df52390d32d6445d153fc0a9ee8f28f45c2439" translate="yes" xml:space="preserve">
          <source>Another way of creating a metaclass comprises of 'metaclass' keyword. Define the metaclass as a simple class. In the parameters of inherited class, pass metaclass=metaclass_name</source>
          <target state="translated">Другой способ создания метакласса состоит из ключевого слова 'metaclass'.Определите метакласс как простой класс.В параметрах наследуемого класса передайте metaclass=metaclass_name</target>
        </trans-unit>
        <trans-unit id="f4b130a19c5f693fbbf062ec80d3671ef783f1ea" translate="yes" xml:space="preserve">
          <source>Anything that's a subclass of &lt;code&gt;MyType&lt;/code&gt; then gets a class attribute &lt;code&gt;_order&lt;/code&gt; that records the order in which the classes were defined.</source>
          <target state="translated">Все, что является подклассом &lt;code&gt;MyType&lt;/code&gt; , затем получает атрибут класса &lt;code&gt;_order&lt;/code&gt; , который записывает порядок, в котором были определены классы.</target>
        </trans-unit>
        <trans-unit id="39af72b7c646d137c090c578f75c34590856559b" translate="yes" xml:space="preserve">
          <source>As soon as you use the keyword &lt;code&gt;class&lt;/code&gt;, Python executes it and creates
an OBJECT. The instruction</source>
          <target state="translated">Как только вы используете ключевое слово &lt;code&gt;class&lt;/code&gt; , Python выполняет его и создает OBJECT. Инструкция</target>
        </trans-unit>
        <trans-unit id="2bbce40d7b29697d5feb257ab36b2c9ef937448a" translate="yes" xml:space="preserve">
          <source>As you can see, you have to repeat the name of the attribute twice.  This makes typos possible along with irritating bugs.</source>
          <target state="translated">Как видите,нужно повторить имя атрибута дважды.Это делает возможным опечатки наряду с раздражающими ошибками.</target>
        </trans-unit>
        <trans-unit id="9956578f1491cba6ae62da4a5182369af56ec1ea" translate="yes" xml:space="preserve">
          <source>Automatic change of class (on creation) is required</source>
          <target state="translated">Требуется автоматическое изменение класса (при создании)</target>
        </trans-unit>
        <trans-unit id="a0904b4d0a120872451f6708177857cd4876a29b" translate="yes" xml:space="preserve">
          <source>Be careful here that the &lt;code&gt;__metaclass__&lt;/code&gt; attribute will not be inherited, the metaclass of the parent (&lt;code&gt;Bar.__class__&lt;/code&gt;) will be. If &lt;code&gt;Bar&lt;/code&gt; used a &lt;code&gt;__metaclass__&lt;/code&gt; attribute that created &lt;code&gt;Bar&lt;/code&gt; with &lt;code&gt;type()&lt;/code&gt; (and not &lt;code&gt;type.__new__()&lt;/code&gt;), the subclasses will not inherit that behavior.</source>
          <target state="translated">Будьте осторожны, &lt;code&gt;__metaclass__&lt;/code&gt; атрибут __metaclass__ не был унаследован, метакласс родительского ( &lt;code&gt;Bar.__class__&lt;/code&gt; ) будет. Если &lt;code&gt;Bar&lt;/code&gt; использовал атрибут &lt;code&gt;__metaclass__&lt;/code&gt; , который создал &lt;code&gt;Bar&lt;/code&gt; с &lt;code&gt;type()&lt;/code&gt; (а не с &lt;code&gt;type.__new__()&lt;/code&gt; ), подклассы не будут наследовать это поведение.</target>
        </trans-unit>
        <trans-unit id="80625100761a15802531450282948dc4d9d74c05" translate="yes" xml:space="preserve">
          <source>Before understanding metaclasses, you need to master classes in Python. And Python has a very peculiar idea of what classes are, borrowed from the Smalltalk language.</source>
          <target state="translated">Перед тем,как разобраться в метаклассах,нужно пройти мастер-классы на Питоне.И у Python есть очень своеобразное представление о том,что такое классы,заимствованные из языка Smalltalk.</target>
        </trans-unit>
        <trans-unit id="6a2ed346f5d5ae803e927c67a0b729ccdfc1ac42" translate="yes" xml:space="preserve">
          <source>But 98% of the time, you don't need class alteration at all.</source>
          <target state="translated">Но в 98% случаев тебе вообще не нужны изменения в классе.</target>
        </trans-unit>
        <trans-unit id="217006127ae3f18c4bd2c902e86bbb02d1e2be15" translate="yes" xml:space="preserve">
          <source>But classes are more than that in Python. Classes are objects too.</source>
          <target state="translated">Но занятия в Питоне-это больше,чем в Питоне.Классы тоже являются объектами.</target>
        </trans-unit>
        <trans-unit id="c6925819c7efe04fd6c3ab39f7eb68854e9cde4a" translate="yes" xml:space="preserve">
          <source>But if you do this:</source>
          <target state="translated">Но если ты сделаешь это:</target>
        </trans-unit>
        <trans-unit id="ef4914127f447e16a1796467ee1b0bb970abd2e5" translate="yes" xml:space="preserve">
          <source>But it's not so dynamic, since you still have to write the whole class yourself.</source>
          <target state="translated">Но это не так динамично,так как вы все равно должны написать весь класс сами.</target>
        </trans-unit>
        <trans-unit id="3f48f38ce849fd78c7a275acf29a06ca3a0397d9" translate="yes" xml:space="preserve">
          <source>But still, it's an object, and therefore:</source>
          <target state="translated">Но,тем не менее,это объект,и,следовательно:</target>
        </trans-unit>
        <trans-unit id="3b16fb856b8f2d6a24ccdf8c533162de4f2a2b85" translate="yes" xml:space="preserve">
          <source>But this is not proper OOP. We are calling &lt;code&gt;type&lt;/code&gt; directly and we aren't overriding or calling the parent's &lt;code&gt;__new__&lt;/code&gt;. Let's do that instead:</source>
          <target state="translated">Но это не правильный ООП. Мы вызываем &lt;code&gt;type&lt;/code&gt; напрямую, и мы не переопределяем или не вызываем родительский &lt;code&gt;__new__&lt;/code&gt; . Давайте сделаем это вместо этого:</target>
        </trans-unit>
        <trans-unit id="bca74e7aa7842dd7785f6fa3e79fd35320fecfb0" translate="yes" xml:space="preserve">
          <source>But we learned that Python classes are objects.</source>
          <target state="translated">Но мы узнали,что классы Python-это объекты.</target>
        </trans-unit>
        <trans-unit id="9da0aa54f4f4de88a9f5b6ed8d8101a2c5efd27f" translate="yes" xml:space="preserve">
          <source>By API developers</source>
          <target state="translated">Разработчиками API</target>
        </trans-unit>
        <trans-unit id="b4df2ba03eab94130e4fd06a9c5054fa64ad06cd" translate="yes" xml:space="preserve">
          <source>Can be translated to:</source>
          <target state="translated">Можно перевести:</target>
        </trans-unit>
        <trans-unit id="334466b784281739a3c38583b4c063fdc0aba559" translate="yes" xml:space="preserve">
          <source>Careful, it's tricky.</source>
          <target state="translated">Осторожно,это сложно.</target>
        </trans-unit>
        <trans-unit id="23e735f2e42f0ee01fd065b66b276180dd776b09" translate="yes" xml:space="preserve">
          <source>Class Name</source>
          <target state="translated">Название класса</target>
        </trans-unit>
        <trans-unit id="67581e4d912d7924cb46e54e6204e5fcc51399f9" translate="yes" xml:space="preserve">
          <source>Classes as objects</source>
          <target state="translated">Классы как объекты</target>
        </trans-unit>
        <trans-unit id="2a6d4b43aad00a6ba23618dd38abe34e6ccdd450" translate="yes" xml:space="preserve">
          <source>Creating a new model</source>
          <target state="translated">Создание новой модели</target>
        </trans-unit>
        <trans-unit id="9d277645538f63f2b9666091e215ce0c2c94b67c" translate="yes" xml:space="preserve">
          <source>Creating classes dynamically</source>
          <target state="translated">Создание классов динамично</target>
        </trans-unit>
        <trans-unit id="a5890931814483d070ece2ba611db02e74fa66fb" translate="yes" xml:space="preserve">
          <source>Custom metaclasses</source>
          <target state="translated">Пользовательские метаклассы</target>
        </trans-unit>
        <trans-unit id="3583495fe771aa17938b325299e9568902990630" translate="yes" xml:space="preserve">
          <source>Django makes something complex look simple by exposing a simple API
and using metaclasses, recreating code from this API to do the real job
behind the scenes.</source>
          <target state="translated">Django делает что-то сложное простым,раскрывая простой API и используя метаклассы,воссоздавая код из этого API,чтобы сделать реальную работу за кулисами.</target>
        </trans-unit>
        <trans-unit id="0c2efb2ec65dc0aa53f18cfb1abd5f87fcb64df6" translate="yes" xml:space="preserve">
          <source>Eventually you'll want to add methods to your class. Just define a function
with the proper signature and assign it as an attribute.</source>
          <target state="translated">В конце концов,вы захотите добавить методы в свой класс.Просто определите функцию с соответствующей сигнатурой и назначьте ее атрибутом.</target>
        </trans-unit>
        <trans-unit id="07cbe8c7c80e4f1f64a5bbbd7a413d143a41a369" translate="yes" xml:space="preserve">
          <source>Everything is an object in Python, and they are all either instances of classes
or instances of metaclasses.</source>
          <target state="translated">На Python все является объектом,и все они являются либо экземплярами классов,либо экземплярами метакласса.</target>
        </trans-unit>
        <trans-unit id="8fd816dd026cb3639455418c4ec1f8fa0fe97cd2" translate="yes" xml:space="preserve">
          <source>Everything, and I mean everything, is an object in Python. That includes ints,
strings, functions and classes. All of them are objects. And all of them have
been created from a class:</source>
          <target state="translated">Все,и я имею в виду все,это объект на Пайтоне.Он включает в себя инты,строки,функции и классы.Все они являются объектами.И все они были созданы из класса:</target>
        </trans-unit>
        <trans-unit id="673604a3dfb5c3ee8e65923cb90776673fb75935" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">За исключением &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff75c36a00faaeb29de73a493ffe4e766d3c9c95" translate="yes" xml:space="preserve">
          <source>First, you can create a class in a function using &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">Во-первых, вы можете создать класс в функции, используя &lt;code&gt;class&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b279b3945b4d05b8b08bfb5dd600595061650654" translate="yes" xml:space="preserve">
          <source>First, you know that classes are objects that can create instances.</source>
          <target state="translated">Во-первых,вы знаете,что классы-это объекты,которые могут создавать экземпляры.</target>
        </trans-unit>
        <trans-unit id="0afa5be4efcb2364e68a5fbe4c217e7cc8946f64" translate="yes" xml:space="preserve">
          <source>For doing that, your default &lt;code&gt;metaclass&lt;/code&gt; type class must be inherited as this is the main &lt;code&gt;metaclass&lt;/code&gt;:</source>
          <target state="translated">Для этого ваш класс &lt;code&gt;metaclass&lt;/code&gt; умолчанию должен быть унаследован, так как это основной &lt;code&gt;metaclass&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="64d1e55feb37865331973d2697ad8c261c0e1af4" translate="yes" xml:space="preserve">
          <source>For example, if you look at &lt;a href=&quot;http://docs.djangoproject.com/en/dev/topics/db/models/&quot;&gt;Django models&lt;/a&gt;, their definition looks a bit confusing. It looks as if you are only defining class properties:</source>
          <target state="translated">Например, если вы посмотрите на &lt;a href=&quot;http://docs.djangoproject.com/en/dev/topics/db/models/&quot;&gt;модели Django&lt;/a&gt; , их определение выглядит немного запутанным. Похоже, вы определяете только свойства класса:</target>
        </trans-unit>
        <trans-unit id="fe22872a0b690652860e20740774999a464ef779" translate="yes" xml:space="preserve">
          <source>From the above it stems that the metaclass' &lt;code&gt;__call__()&lt;/code&gt; is also given the opportunity to decide whether or not a call to &lt;code&gt;Class_1.__new__()&lt;/code&gt; or &lt;code&gt;Class_1.__init__()&lt;/code&gt; will eventually be made. Over the course of its execution it could actually return an object that hasn't been touched by either of these methods. Take for example this approach to the singleton pattern:</source>
          <target state="translated">Из вышесказанного следует, что метаклассу &lt;code&gt;__call__()&lt;/code&gt; также предоставляется возможность решить, будет ли в конечном итоге выполняться вызов &lt;code&gt;Class_1.__new__()&lt;/code&gt; или &lt;code&gt;Class_1.__init__()&lt;/code&gt; . В процессе его выполнения он может фактически вернуть объект, который не был затронут ни одним из этих методов. Возьмем для примера такой подход к шаблону синглтона:</target>
        </trans-unit>
        <trans-unit id="019ad28a21f071a1a1c801c23bffdedde5c57127" translate="yes" xml:space="preserve">
          <source>Here is an even more concrete example, showing how you can subclass 'type' to make a metaclass that performs an action when the class is created. This is quite tricky:</source>
          <target state="translated">Вот еще более конкретный пример,показывающий,как можно сделать подкласс &quot;type&quot;,чтобы сделать метакласс,который выполняет действие при создании класса.Это довольно сложно:</target>
        </trans-unit>
        <trans-unit id="89a9dab91d6a0e821bd0d8857c7afd11ec41324d" translate="yes" xml:space="preserve">
          <source>Here is where the secret starts. Look for where name, bases and the dict come from in this example class definition.</source>
          <target state="translated">Вот где начинается секрет.Ищите,откуда идет имя,основы и диктат в этом примере определения класса.</target>
        </trans-unit>
        <trans-unit id="933820812619c6ea7008cbcf3a5bef8f52f428f5" translate="yes" xml:space="preserve">
          <source>Here's an aggregated example of the bits and pieces:</source>
          <target state="translated">Вот обобщенный пример кусочков:</target>
        </trans-unit>
        <trans-unit id="c7172cb8e50347e53ec2a1c70cf3f132135b13bb" translate="yes" xml:space="preserve">
          <source>Here's another example of what it can be used for:</source>
          <target state="translated">Вот еще один пример того,для чего он может быть использован:</target>
        </trans-unit>
        <trans-unit id="b92f66963c22e5d12229c7c1ff474ff5ca10c558" translate="yes" xml:space="preserve">
          <source>Here's the default &lt;code&gt;__repr__&lt;/code&gt; of classes:</source>
          <target state="translated">Вот стандартное &lt;code&gt;__repr__&lt;/code&gt; классов:</target>
        </trans-unit>
        <trans-unit id="da679ef3b897db5427c2dd4128c089961c066bc2" translate="yes" xml:space="preserve">
          <source>However, at runtime the Person objects are filled with all sorts of useful methods. See the &lt;a href=&quot;http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py&quot;&gt;source&lt;/a&gt; for some amazing metaclassery.</source>
          <target state="translated">Однако во время выполнения объекты Person заполняются всевозможными полезными методами. Смотрите &lt;a href=&quot;http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py&quot;&gt;источник&lt;/a&gt; для некоторой удивительной метаклассерии.</target>
        </trans-unit>
        <trans-unit id="3687f11b0c4210b7d9c0b35a3e13741dc07a26f7" translate="yes" xml:space="preserve">
          <source>However, metaclasses actually define the &lt;em&gt;type&lt;/em&gt; of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. &lt;code&gt;type.__subclasses__()&lt;/code&gt; is an example of a method on the &lt;code&gt;type&lt;/code&gt; metaclass. You can also define the normal 'magic' methods, like &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__iter__&lt;/code&gt; and &lt;code&gt;__getattr__&lt;/code&gt;, to implement or change how the class behaves.</source>
          <target state="translated">Тем не менее, метаклассы фактически определяют &lt;em&gt;тип&lt;/em&gt; класса, а не просто фабрику для него, так что вы можете сделать с ними гораздо больше. Например, вы можете определить нормальные методы в метаклассе. Эти метакласс-методы похожи на методы класса в том смысле, что их можно вызывать в классе без экземпляра, но они также не похожи на методы класса в том смысле, что их нельзя вызывать в экземпляре класса. &lt;code&gt;type.__subclasses__()&lt;/code&gt; - это пример метода метакласса &lt;code&gt;type&lt;/code&gt; . Вы также можете определить обычные &amp;laquo;магические&amp;raquo; методы, такие как &lt;code&gt;__add__&lt;/code&gt; , &lt;code&gt;__iter__&lt;/code&gt; и &lt;code&gt;__getattr__&lt;/code&gt; , для реализации или изменения поведения класса.</target>
        </trans-unit>
        <trans-unit id="4fa00b7305761f3d48d74e2fcaa87d88b46b8653" translate="yes" xml:space="preserve">
          <source>I think the ONLamp introduction to metaclass programming is well written and gives a really good introduction to the topic despite being several years old already.</source>
          <target state="translated">Я думаю,что введение в программирование метакласса в ONLamp хорошо написано и дает действительно хорошее введение в эту тему,несмотря на то,что ему уже несколько лет.</target>
        </trans-unit>
        <trans-unit id="5de71cb6474da6bbfd1892d86a39743c6e1f7a0d" translate="yes" xml:space="preserve">
          <source>I've never written one myself, but I think one of the nicest uses of metaclasses can be seen in the &lt;a href=&quot;http://www.djangoproject.com/&quot;&gt;Django framework&lt;/a&gt;. The model classes use a metaclass approach to enable a declarative style of writing new models or form classes. While the metaclass is creating the class, all members get the possibility to customize the class itself.</source>
          <target state="translated">Сам я никогда не писал, но я думаю, что одно из самых хороших применений метаклассов можно увидеть в структуре &lt;a href=&quot;http://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt; . Классы моделей используют метаклассовый подход, чтобы включить декларативный стиль написания новых моделей или классов форм. Пока метакласс создает класс, все члены получают возможность настраивать сам класс.</target>
        </trans-unit>
        <trans-unit id="d4a30d2f2ca2899fa19429f58792d2d3e210fba9" translate="yes" xml:space="preserve">
          <source>If Python can't find &lt;code&gt;__metaclass__&lt;/code&gt;, it will look for a &lt;code&gt;__metaclass__&lt;/code&gt; at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes).</source>
          <target state="translated">Если Python не может найти &lt;code&gt;__metaclass__&lt;/code&gt; , он будет искать &lt;code&gt;__metaclass__&lt;/code&gt; на уровне MODULE и попытаться сделать то же самое (но только для классов, которые ничего не наследуют, в основном классы старого стиля).</target>
        </trans-unit>
        <trans-unit id="b2c247f997e1856448d121b399db1ce401dfe052" translate="yes" xml:space="preserve">
          <source>If yes, create in memory a class object (I said a class object, stay with me here), with the name &lt;code&gt;Foo&lt;/code&gt; by using what is in &lt;code&gt;__metaclass__&lt;/code&gt;.</source>
          <target state="translated">Если да, создайте в памяти объект класса (я сказал объект класса, оставайтесь здесь со мной) с именем &lt;code&gt;Foo&lt;/code&gt; , используя то, что находится в &lt;code&gt;__metaclass__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c4ed3e469d021631b88778db056f898cbd3075a" translate="yes" xml:space="preserve">
          <source>If you do so, Python will use the metaclass to create the class &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Если вы это сделаете, Python будет использовать метакласс для создания класса &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d569392d6709098664ec3f652636842d8ae2fd08" translate="yes" xml:space="preserve">
          <source>If you've done Python programming for more than a few months you'll eventually stumble upon code that looks like this:</source>
          <target state="translated">Если вы занимались программированием на Python более нескольких месяцев,то в конце концов наткнетесь на код,который выглядит так:</target>
        </trans-unit>
        <trans-unit id="8ffaab56641a084b45859b1b16c94f6d85871567" translate="yes" xml:space="preserve">
          <source>If, for example, we want to know in what order a class's methods are created in, we could provide an ordered dict as the namespace of the class. We would do this with &lt;code&gt;__prepare__&lt;/code&gt; which &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace&quot;&gt;returns the namespace dict for the class if it is implemented in Python 3&lt;/a&gt;:</source>
          <target state="translated">Если, например, мы хотим знать, в каком порядке создаются методы класса, мы можем предоставить упорядоченный dict в качестве пространства имен класса. Мы сделали бы это с &lt;code&gt;__prepare__&lt;/code&gt; , который &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace&quot;&gt;возвращает dict пространства имен для класса, если он реализован в Python 3&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0ddfbe7f84c69375a34cda89908ad9181be61fdd" translate="yes" xml:space="preserve">
          <source>Imagine a stupid example, where you decide that all classes in your module
should have their attributes written in uppercase. There are several ways to
do this, but one way is to set &lt;code&gt;__metaclass__&lt;/code&gt; at the module level.</source>
          <target state="translated">Представьте себе глупый пример, когда вы решаете, что все классы в вашем модуле должны иметь свои атрибуты, написанные в верхнем регистре. Есть несколько способов сделать это, но один из них - установить &lt;code&gt;__metaclass__&lt;/code&gt; на уровне модуля.</target>
        </trans-unit>
        <trans-unit id="91a6aa8c8b6a75378372d8ea48354d684c37eb6b" translate="yes" xml:space="preserve">
          <source>In Python 2, you can add a &lt;code&gt;__metaclass__&lt;/code&gt; attribute when you write a class (see next section for the Python 3 syntax):</source>
          <target state="translated">В Python 2 вы можете добавить атрибут &lt;code&gt;__metaclass__&lt;/code&gt; при написании класса (см. Следующий раздел о синтаксисе Python 3):</target>
        </trans-unit>
        <trans-unit id="7e651e9d51572a5346d5e0e8610271f23aa0d208" translate="yes" xml:space="preserve">
          <source>In Python, what are metaclasses and what do we use them for?</source>
          <target state="translated">В Питоне,что такое метаклассы и для чего мы их используем?</target>
        </trans-unit>
        <trans-unit id="4650ac989c9d3329e40be1c6ab845b25d2070a47" translate="yes" xml:space="preserve">
          <source>In addition to the published answers I can say that a &lt;code&gt;metaclass&lt;/code&gt; defines the behaviour for a class. So, you can explicitly set your metaclass. Whenever Python gets a keyword &lt;code&gt;class&lt;/code&gt; then it starts searching for the &lt;code&gt;metaclass&lt;/code&gt;. If it's not found &amp;ndash; the default metaclass type is used to create the class's object. Using the &lt;code&gt;__metaclass__&lt;/code&gt; attribute, you can set &lt;code&gt;metaclass&lt;/code&gt; of your class:</source>
          <target state="translated">В дополнение к опубликованным ответам я могу сказать, что &lt;code&gt;metaclass&lt;/code&gt; определяет поведение класса. Таким образом, вы можете явно установить свой метакласс. Всякий раз, когда Python получает &lt;code&gt;class&lt;/code&gt; ключевого слова, он начинает поиск &lt;code&gt;metaclass&lt;/code&gt; . Если он не найден - тип метакласса по умолчанию используется для создания объекта класса. Используя атрибут &lt;code&gt;__metaclass__&lt;/code&gt; , вы можете установить &lt;code&gt;metaclass&lt;/code&gt; вашего класса:</target>
        </trans-unit>
        <trans-unit id="c35d9935b1a444e907c91e37c19879d0759a37ba" translate="yes" xml:space="preserve">
          <source>In addition to using type() to create classes dynamically, you can control creation behavior of class and use metaclass.</source>
          <target state="translated">Помимо использования функции type()для динамического создания классов,можно управлять поведением создания класса и использовать метаклас.</target>
        </trans-unit>
        <trans-unit id="4a7677010e3a9723dd238a2332a0b15302776bce" translate="yes" xml:space="preserve">
          <source>In most languages, classes are just pieces of code that describe how to produce an object. That's kinda true in Python too:</source>
          <target state="translated">В большинстве языков классы-это всего лишь куски кода,описывающие,как создать объект.На Python это тоже верно:</target>
        </trans-unit>
        <trans-unit id="fa72180e3995db72ed5f698c8ee07149c8c3a22b" translate="yes" xml:space="preserve">
          <source>In object-oriented programming, a metaclass is a class whose instances are classes. Just as an ordinary class defines the behavior of certain objects, a metaclass defines the behavior of certain class and their instances
The term metaclass simply means something used to create classes. In other words, it is the class of a class. The metaclass is used to create the class so like the object being an instance of a class, a class is an instance of a metaclass. In python classes are also considered objects.</source>
          <target state="translated">В объектно-ориентированном программировании метаклас-это класс,экземплярами которого являются классы.Подобно тому,как обычный класс определяет поведение определенных объектов,так и метакласс определяет поведение определенного класса и их экземпляров Термин метакласс просто означает что-то,используемое для создания классов.Другими словами,это класс класса.Метакласс используется для создания класса,так же как и объект,являющийся экземпляром класса,класс является экземпляром метакласса.В питоновских классах объекты также считаются объектами.</target>
        </trans-unit>
        <trans-unit id="2e61694f68b17195f1c41dbc03080f71c6ec3509" translate="yes" xml:space="preserve">
          <source>In real code, we can pass the default metaclass, &lt;code&gt;type&lt;/code&gt;, everything we need to instantiate a class and we get a class:</source>
          <target state="translated">В реальном коде мы можем передать метакласс по умолчанию, &lt;code&gt;type&lt;/code&gt; , все, что нам нужно для создания экземпляра класса, и мы получаем класс:</target>
        </trans-unit>
        <trans-unit id="6cde1b05c392829cf0748f367e1a5f3cc79ef8e7" translate="yes" xml:space="preserve">
          <source>In short: A class is a blueprint for the creation of an instance, a metaclass is a blueprint for the creation of a class. It can be easily seen that in Python classes need to be first-class objects too to enable this behavior.</source>
          <target state="translated">Вкратце:класс-это чертеж для создания экземпляра,метакласс-это чертеж для создания класса.Легко заметить,что в классах Python тоже должны быть первоклассные объекты,чтобы включить такое поведение.</target>
        </trans-unit>
        <trans-unit id="0dcf456ed380c367ea7337a047070feeb2404ac6" translate="yes" xml:space="preserve">
          <source>Indeed, metaclasses are especially useful to do black magic, and therefore
complicated stuff. But by themselves, they are simple:</source>
          <target state="translated">Действительно,метакласы особенно полезны для совершения черной магии,а значит,и сложных вещей.Но сами по себе они просты:</target>
        </trans-unit>
        <trans-unit id="e6acf61863b31d67d149b4e6ca40eee6b1199fa9" translate="yes" xml:space="preserve">
          <source>Is there a &lt;code&gt;__metaclass__&lt;/code&gt; attribute in &lt;code&gt;Foo&lt;/code&gt;?</source>
          <target state="translated">Есть ли в &lt;code&gt;__metaclass__&lt;/code&gt; атрибут __metaclass__ ?</target>
        </trans-unit>
        <trans-unit id="8b238ceb9e5599e813e4358cf7862918d33b97b1" translate="yes" xml:space="preserve">
          <source>It is the same as functionally calling &lt;code&gt;type&lt;/code&gt; with the appropriate arguments and assigning the result to a variable of that name:</source>
          <target state="translated">Это то же самое, что функционально вызывать &lt;code&gt;type&lt;/code&gt; с соответствующими аргументами и присваивать результат переменной с таким именем:</target>
        </trans-unit>
        <trans-unit id="0f552d4e543041b1701247e77678f01050c07d0e" translate="yes" xml:space="preserve">
          <source>It translates to this in the metaclass to use it:</source>
          <target state="translated">Это переводится в метакласе,чтобы использовать его:</target>
        </trans-unit>
        <trans-unit id="c7ba3c56dd302201c8d63fd76926944ea19006b4" translate="yes" xml:space="preserve">
          <source>It won't return an &lt;code&gt;IntegerField&lt;/code&gt; object. It will return an &lt;code&gt;int&lt;/code&gt;, and can even take it directly from the database.</source>
          <target state="translated">Он не вернет объект &lt;code&gt;IntegerField&lt;/code&gt; . Он вернет &lt;code&gt;int&lt;/code&gt; и может даже взять его непосредственно из базы данных.</target>
        </trans-unit>
        <trans-unit id="d8d805048c69fa736de925d3367248b04c361716" translate="yes" xml:space="preserve">
          <source>It'll produce the output like this:</source>
          <target state="translated">Это даст такой результат:</target>
        </trans-unit>
        <trans-unit id="7cf1c9cf775a5387c4ff94bd47121db2b5c988dd" translate="yes" xml:space="preserve">
          <source>It's because the function &lt;code&gt;type&lt;/code&gt; is in fact a metaclass. &lt;code&gt;type&lt;/code&gt; is the
metaclass Python uses to create all classes behind the scenes.</source>
          <target state="translated">Это потому, что &lt;code&gt;type&lt;/code&gt; функции на самом деле является метаклассом. &lt;code&gt;type&lt;/code&gt; - это метакласс, который Python использует для создания всех классов за сценой.</target>
        </trans-unit>
        <trans-unit id="b762e9c56bf18ad7968cf2abfa72dfb4cd610a39" translate="yes" xml:space="preserve">
          <source>Just as we can use class definitions to change how custom object instances behave, we can use a metaclass class definition to change the way a class object behaves.</source>
          <target state="translated">Подобно тому,как мы можем использовать определения классов для изменения поведения пользовательских экземпляров объектов,мы можем использовать определение класса metaclass для изменения поведения объекта класса.</target>
        </trans-unit>
        <trans-unit id="12861900e6ee5fc644f17e214205bf98f2b552b1" translate="yes" xml:space="preserve">
          <source>Let's check:</source>
          <target state="translated">Давай проверим:</target>
        </trans-unit>
        <trans-unit id="e24b773897b7eab9e5ea3419aecc80a071b54a96" translate="yes" xml:space="preserve">
          <source>Let's observe what happens when repeatedly trying to create an object of type &lt;code&gt;Class_2&lt;/code&gt;</source>
          <target state="translated">Давайте посмотрим, что происходит при многократной попытке создать объект типа &lt;code&gt;Class_2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d3e22e4d5a330681408b9b810a86a368c8150f7" translate="yes" xml:space="preserve">
          <source>Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean:</source>
          <target state="translated">Давайте перепишем вышесказанное,но с более короткими и реалистичными именами переменных теперь,когда мы знаем,что они означают:</target>
        </trans-unit>
        <trans-unit id="bae90bb62607735e9b7e3a157dc8431c62f56161" translate="yes" xml:space="preserve">
          <source>Let's study the method call chain from specifically the perspective of creating an instance of a class.</source>
          <target state="translated">Рассмотрим цепочку вызова метода именно с точки зрения создания экземпляра класса.</target>
        </trans-unit>
        <trans-unit id="045e68d2ed13507db1ee3f048ec03ec22ab6a6b4" translate="yes" xml:space="preserve">
          <source>Lets define a metaclass that will demonstrate how '&lt;strong&gt;class:&lt;/strong&gt;' calls it.</source>
          <target state="translated">Давайте определим метакласс, который продемонстрирует, как &lt;strong&gt;class:&lt;/strong&gt; называет его.</target>
        </trans-unit>
        <trans-unit id="320371557536a1d1e98f35433ae20c51e9eed7fc" translate="yes" xml:space="preserve">
          <source>Likewise, when we define a class explicitly with the default metaclass, &lt;code&gt;type&lt;/code&gt;, we instantiate it:</source>
          <target state="translated">Аналогично, когда мы явно определяем класс с метаклассом по умолчанию &lt;code&gt;type&lt;/code&gt; , мы создаем его экземпляр:</target>
        </trans-unit>
        <trans-unit id="dd4270596259e170c6cba8ca00280d127d29899d" translate="yes" xml:space="preserve">
          <source>Luckily, &lt;code&gt;__metaclass__&lt;/code&gt; can actually be any callable, it doesn't need to be a
formal class (I know, something with 'class' in its name doesn't need to be
a class, go figure... but it's helpful).</source>
          <target state="translated">К счастью, &lt;code&gt;__metaclass__&lt;/code&gt; на самом деле может быть любым вызываемым, он не должен быть формальным классом (я знаю, что-то с именем &amp;laquo;class&amp;raquo; в названии не обязательно должно быть классом, поймите, что ... но это полезно).</target>
        </trans-unit>
        <trans-unit id="a84965b59c86adeaf5175c77b1367ae45a51beca" translate="yes" xml:space="preserve">
          <source>Magic will take effect when we passed keyword arguments in metaclass, it indicates the Python interpreter to create the CustomList through ListMetaclass. &lt;strong&gt;new&lt;/strong&gt; (), at this point, we can modify the class definition, for example, and add a new method and then return the revised definition.</source>
          <target state="translated">Магия вступит в силу, когда мы передадим аргументы ключевого слова в метаклассе, он указывает интерпретатору Python для создания CustomList через ListMetaclass. &lt;strong&gt;new&lt;/strong&gt; (), на этом этапе мы можем, например, изменить определение класса, добавить новый метод и затем вернуть исправленное определение.</target>
        </trans-unit>
        <trans-unit id="5fe9adb504d86047cca71de452afe1639b04cca8" translate="yes" xml:space="preserve">
          <source>Metaclass can be specifically used in the following situations :-</source>
          <target state="translated">Метакласс может быть специально использован в следующих ситуациях :-</target>
        </trans-unit>
        <trans-unit id="3af05144e3743c95c5ae229f63e24413fd772f08" translate="yes" xml:space="preserve">
          <source>Metaclass is a kind of class which defines how the class will behave like or we can say that A class is itself an instance of a metaclass.</source>
          <target state="translated">Метакласс-это разновидность класса,который определяет,как будет вести себя класс,или можно сказать,что класс A сам по себе является экземпляром метакласса.</target>
        </trans-unit>
        <trans-unit id="a4c7336a776a31b11543813110e2a48bdc565d93" translate="yes" xml:space="preserve">
          <source>Metaclasses are deeper magic that
  99% of users should never worry about.
  If you wonder whether you need them,
  you don't (the people who actually
  need them know with certainty that
  they need them, and don't need an
  explanation about why).</source>
          <target state="translated">Метаклассы-это глубокое волшебство,о котором 99% пользователей никогда не должны беспокоиться.Если вы задаетесь вопросом,нужны ли они вам,то нет (люди,которые действительно нуждаются в них,знают с уверенностью,что они нуждаются в них,и не нуждаются в объяснении почему).</target>
        </trans-unit>
        <trans-unit id="fcb03720145595ceaed2564444518a68539698a8" translate="yes" xml:space="preserve">
          <source>Metaclasses are the 'stuff' that creates classes.</source>
          <target state="translated">Метаклассы-это &quot;вещи&quot;,которые создают классы.</target>
        </trans-unit>
        <trans-unit id="347480dda5a48202f0a0a3b1b3be6014055c70c8" translate="yes" xml:space="preserve">
          <source>Metaclasses are the secret sauce that make 'class' work. The default metaclass for a new style object is called 'type'.</source>
          <target state="translated">Метаклассы-секретный соус,который заставляет &quot;класс&quot; работать.Метаклас по умолчанию для нового объекта стиля называется 'type'.</target>
        </trans-unit>
        <trans-unit id="b0d32362c1bfdecea091b0735835a3190f185e2b" translate="yes" xml:space="preserve">
          <source>Metaclasses in Python 3</source>
          <target state="translated">Метаклассы на питоне 3</target>
        </trans-unit>
        <trans-unit id="97071630fbed73be9de0cacbd51a241cef7bdfa8" translate="yes" xml:space="preserve">
          <source>Metaclasses take 3 args. '&lt;strong&gt;name&lt;/strong&gt;', '&lt;strong&gt;bases&lt;/strong&gt;' and '&lt;strong&gt;dict&lt;/strong&gt;'</source>
          <target state="translated">Метаклассы занимают 3 аргумента. &amp;laquo; &lt;strong&gt;имя&lt;/strong&gt; &amp;raquo;, &amp;laquo; &lt;strong&gt;основания&lt;/strong&gt; &amp;raquo; и &amp;laquo; &lt;strong&gt;дикт&lt;/strong&gt; &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="8797caa69e6420c0f3bfebfa19ca4cdf0b6929f4" translate="yes" xml:space="preserve">
          <source>Nevertheless, it is usually encouraged for users to avoid using metaclasses unless absolutely necessary.</source>
          <target state="translated">Тем не менее,пользователям,как правило,рекомендуется избегать использования мета-классов,если в этом нет абсолютной необходимости.</target>
        </trans-unit>
        <trans-unit id="4ad4b27bbadcdc0adcdbc297fc1201cb31705fca" translate="yes" xml:space="preserve">
          <source>Note that in python 3.6 a new dunder method &lt;code&gt;__init_subclass__(cls, **kwargs)&lt;/code&gt; was introduced to replace a lot of common use cases for metaclasses. Is is called when a subclass of the defining class is created. See &lt;a href=&quot;https://docs.python.org/3.6/reference/datamodel.html&quot;&gt;python docs&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что в python 3.6 появился новый метод &lt;code&gt;__init_subclass__(cls, **kwargs)&lt;/code&gt; который заменил множество общих случаев использования метаклассов. Вызывается, когда создается подкласс определяющего класса. Смотрите &lt;a href=&quot;https://docs.python.org/3.6/reference/datamodel.html&quot;&gt;документы по питону&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06fe24108d0ae7b5ac24fe3074dd0a7cf192f87c" translate="yes" xml:space="preserve">
          <source>Note, some things automatically get added to the &lt;code&gt;__dict__&lt;/code&gt;, i.e., the namespace:</source>
          <target state="translated">Обратите внимание, что некоторые вещи автоматически добавляются в &lt;code&gt;__dict__&lt;/code&gt; , то есть в пространство имен:</target>
        </trans-unit>
        <trans-unit id="fe5b2192b1a3dda71ee761442e7acc561c0dae83" translate="yes" xml:space="preserve">
          <source>Note, this example was adapted from the &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;documentation&lt;/a&gt; - the new &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/enum.py&quot;&gt;enum in the standard library&lt;/a&gt; does this.</source>
          <target state="translated">Обратите внимание, этот пример был адаптирован из &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;документации&lt;/a&gt; - это делает новый &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/enum.py&quot;&gt;enum в стандартной библиотеке&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4afa936b2a2c77839b1cc61ded016a8418009e" translate="yes" xml:space="preserve">
          <source>Notice that the class was not instantiated at any time; the simple act of creating the class triggered execution of the &lt;code&gt;metaclass&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что класс не был создан в любое время; простой акт создания класса запускает выполнение &lt;code&gt;metaclass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8092d965c6169ed84145f59ba7bbf9f5d4c853f" translate="yes" xml:space="preserve">
          <source>Now the big question is, what can you put in &lt;code&gt;__metaclass__&lt;/code&gt; ?</source>
          <target state="translated">Теперь большой вопрос, что вы можете поместить в &lt;code&gt;__metaclass__&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d2dcde526fc4daaef6d655606e4496048204c05b" translate="yes" xml:space="preserve">
          <source>Now the big question. Why would you use some obscure error prone feature?</source>
          <target state="translated">Теперь большой вопрос.Почему вы используете какую-то непонятную функцию,склонную к ошибкам?</target>
        </trans-unit>
        <trans-unit id="1312ae6700f74e01674fc6c089a10ffa91f468b1" translate="yes" xml:space="preserve">
          <source>Now you wonder why the heck is it written in lowercase, and not &lt;code&gt;Type&lt;/code&gt;?</source>
          <target state="translated">Теперь вы удивляетесь, почему, черт возьми, оно написано строчными буквами, а не &lt;code&gt;Type&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="9e1ac6d44c14c13e117e5f981206e38957129c52" translate="yes" xml:space="preserve">
          <source>Now, let's do exactly the same, but using a real class for a metaclass:</source>
          <target state="translated">Теперь,давайте сделаем то же самое,но используя настоящий класс для метакласса:</target>
        </trans-unit>
        <trans-unit id="390ebafcf350ad02efb790f33b6aaead595c1109" translate="yes" xml:space="preserve">
          <source>Now, what is the &lt;code&gt;__class__&lt;/code&gt; of any &lt;code&gt;__class__&lt;/code&gt; ?</source>
          <target state="translated">Теперь, что такое &lt;code&gt;__class__&lt;/code&gt; любого &lt;code&gt;__class__&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d1ac610b74a4f310bfc7d2292f70767803b25d13" translate="yes" xml:space="preserve">
          <source>Observe that the code above doesn't actually do anything more than logging the tasks. Each method delegates the actual work to its parent's implementation, thus keeping the default behavior. Since &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;Meta_1&lt;/code&gt;'s parent class (&lt;code&gt;type&lt;/code&gt; being the default parent metaclass) and considering the ordering sequence of the output above, we now have a clue as to what would be the pseudo implementation of &lt;code&gt;type.__call__()&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что приведенный выше код на самом деле не делает ничего, кроме регистрации задач. Каждый метод делегирует фактическую работу реализации его родителя, сохраняя поведение по умолчанию. Поскольку &lt;code&gt;type&lt;/code&gt; является родительским классом &lt;code&gt;Meta_1&lt;/code&gt; ( &lt;code&gt;type&lt;/code&gt; является родительским метаклассом по умолчанию) и, учитывая последовательность упорядочения вышеприведенных выходных данных, теперь у нас есть подсказка относительно того, какова будет псевдо-реализация &lt;code&gt;type.__call__()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9d0d319c87f6fad802806c07bd7c51a428962ba2" translate="yes" xml:space="preserve">
          <source>Oh, and in python 3 if you do this call with keyword arguments, like this:</source>
          <target state="translated">О,и на питоне 3,если вы сделаете этот звонок с аргументами по ключевым словам,как это:</target>
        </trans-unit>
        <trans-unit id="7cfdd53a3948e13bf6052b4df361c602b9dadb4c" translate="yes" xml:space="preserve">
          <source>One of the most valuable things we can do by default in writing a Python object is to provide it with a good &lt;code&gt;__repr__&lt;/code&gt;. When we call &lt;code&gt;help(repr)&lt;/code&gt; we learn that there's a good test for a &lt;code&gt;__repr__&lt;/code&gt; that also requires a test for equality - &lt;code&gt;obj == eval(repr(obj))&lt;/code&gt;. The following simple implementation of &lt;code&gt;__repr__&lt;/code&gt; and &lt;code&gt;__eq__&lt;/code&gt; for class instances of our type class provides us with a demonstration that may improve on the default &lt;code&gt;__repr__&lt;/code&gt; of classes:</source>
          <target state="translated">Одна из самых ценных вещей, которые мы можем сделать по умолчанию при написании объекта Python, - предоставить ему хороший &lt;code&gt;__repr__&lt;/code&gt; . Когда мы вызываем &lt;code&gt;help(repr)&lt;/code&gt; мы узнаем, что есть хороший тест для &lt;code&gt;__repr__&lt;/code&gt; , который также требует теста на равенство - &lt;code&gt;obj == eval(repr(obj))&lt;/code&gt; . Следующая простая реализация &lt;code&gt;__repr__&lt;/code&gt; и &lt;code&gt;__eq__&lt;/code&gt; для экземпляров класса нашего класса типов предоставляет нам демонстрацию, которая может улучшить стандартную &lt;code&gt;__repr__&lt;/code&gt; классов:</target>
        </trans-unit>
        <trans-unit id="110c76ebedce2cc5ef80aca4ff4ae9ae674cabba" translate="yes" xml:space="preserve">
          <source>One thing added to metaclasses in python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:</source>
          <target state="translated">Одна вещь,добавленная в метаклассы на питоне 3,заключается в том,что вы также можете передавать атрибуты,как ключевые инструменты,в метакласс,например,так:</target>
        </trans-unit>
        <trans-unit id="34e532c0c60597f39dcc4f2a9b5f7a1d572c0614" translate="yes" xml:space="preserve">
          <source>One use for metaclasses is adding new properties and methods to an instance automatically.</source>
          <target state="translated">Одним из способов использования метакласса является автоматическое добавление новых свойств и методов в экземпляр.</target>
        </trans-unit>
        <trans-unit id="ef268ec4d64e990e936a954651784766af9637be" translate="yes" xml:space="preserve">
          <source>Others have explained how metaclasses work and how they fit into the Python type system. Here's an example of what they can be used for. In a testing framework I wrote, I wanted to keep track of the order in which classes were defined, so that I could later instantiate them in this order. I found it easiest to do this using a metaclass.</source>
          <target state="translated">Другие объяснили,как работают метаклассы и как они вписываются в систему типа Python.Вот пример того,для чего они могут быть использованы.В тестовой фреймворк,который я написал,я хотел проследить за тем,в каком порядке были определены классы,чтобы потом можно было их конкретизировать в таком порядке.Мне показалось,что проще всего это сделать с помощью метакласса.</target>
        </trans-unit>
        <trans-unit id="a1e368bcdd9e3ad64f80172f6605fff557c816ac" translate="yes" xml:space="preserve">
          <source>Pseudocode:</source>
          <target state="translated">Pseudocode:</target>
        </trans-unit>
        <trans-unit id="b046f20ec5ac77994d3cd2fa8b65aab70b67256f" translate="yes" xml:space="preserve">
          <source>Put a third way, a metaclass is a class's class.</source>
          <target state="translated">Третий способ:метакласс-это класс.</target>
        </trans-unit>
        <trans-unit id="8d527c34e169c405cdbe5dedda08a7bde822577d" translate="yes" xml:space="preserve">
          <source>Put another way, a class is an instance of a metaclass:</source>
          <target state="translated">Другими словами,класс-это пример метакласса:</target>
        </trans-unit>
        <trans-unit id="57d1465b29ebaa761602dcd70cff407e53c47e35" translate="yes" xml:space="preserve">
          <source>Putting it differently</source>
          <target state="translated">По-другому.</target>
        </trans-unit>
        <trans-unit id="ce9d464e6a7243401820e72c717964ac86dda8b2" translate="yes" xml:space="preserve">
          <source>Python classes are themselves objects - as in instance - of their meta-class.</source>
          <target state="translated">Питоновые классы сами по себе являются объектами-как,например,их мета-классом.</target>
        </trans-unit>
        <trans-unit id="47913b0ef43e652acfa0a6f76a38e652fae1a60c" translate="yes" xml:space="preserve">
          <source>Python does the following:</source>
          <target state="translated">Питон делает следующее:</target>
        </trans-unit>
        <trans-unit id="1cef07b48fc1a95aee7f514ccf91ce22d457b8f0" translate="yes" xml:space="preserve">
          <source>Python will look for &lt;code&gt;__metaclass__&lt;/code&gt; in the class definition. If it finds it,
it will use it to create the object class &lt;code&gt;Foo&lt;/code&gt;. If it doesn't, it will use
&lt;code&gt;type&lt;/code&gt; to create the class.</source>
          <target state="translated">Python будет искать &lt;code&gt;__metaclass__&lt;/code&gt; в определении класса. Если он найдет его, он будет использовать его для создания класса объектов &lt;code&gt;Foo&lt;/code&gt; . Если этого не произойдет, он будет использовать &lt;code&gt;type&lt;/code&gt; для создания класса.</target>
        </trans-unit>
        <trans-unit id="c68f250ede1ff4f4e9314c1012a1057abd055fc7" translate="yes" xml:space="preserve">
          <source>Read that several times.</source>
          <target state="translated">Прочитай это несколько раз.</target>
        </trans-unit>
        <trans-unit id="10b8e71a62f5bb23590ad5fac72a1920c13c031d" translate="yes" xml:space="preserve">
          <source>Read the section below for how python handles this.</source>
          <target state="translated">Прочтите ниже раздел о том,как питон справляется с этим.</target>
        </trans-unit>
        <trans-unit id="363f6db0e6302144237a5fb8dc97f8c0bca8e69c" translate="yes" xml:space="preserve">
          <source>Remember the function &lt;code&gt;type&lt;/code&gt;? The good old function that lets you know what
type an object is:</source>
          <target state="translated">Помните &lt;code&gt;type&lt;/code&gt; функции? Старая добрая функция, которая позволяет узнать тип объекта:</target>
        </trans-unit>
        <trans-unit id="cf75004630642fa532edd3e9852d9ebbd8dc3330" translate="yes" xml:space="preserve">
          <source>Role of a metaclass' &lt;code&gt;__call__()&lt;/code&gt; method when creating a class instance</source>
          <target state="translated">Роль метода метакласса &lt;code&gt;__call__()&lt;/code&gt; при создании экземпляра класса</target>
        </trans-unit>
        <trans-unit id="ab6d3b5b86935e5bb21ca62e95635f583fc6b80d" translate="yes" xml:space="preserve">
          <source>Say you want some simple validation code to run on your attributes -- like it must always be an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;str&lt;/code&gt;.  Without a metaclass, your class would look something like:</source>
          <target state="translated">Скажем, вы хотите, чтобы на ваших атрибутах выполнялся какой-то простой проверочный код - как будто он всегда должен быть &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;str&lt;/code&gt; . Без метакласса ваш класс будет выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="924f4a98a9789c119e7866bd528b9dbf5b11a53a" translate="yes" xml:space="preserve">
          <source>Secondly, metaclasses are complicated. You may not want to use them for
very simple class alterations. You can change classes by using two different techniques:</source>
          <target state="translated">Во-вторых,метаклассы сложны.Возможно,вы не захотите использовать их для очень простых изменений классов.Вы можете менять классы,используя две разные техники:</target>
        </trans-unit>
        <trans-unit id="4dfe816bf571911a330a66b6c754c40a58c06f42" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;__metaclass__&lt;/code&gt; can accept any callable, why would you use a class
since it's obviously more complicated?</source>
          <target state="translated">Так как &lt;code&gt;__metaclass__&lt;/code&gt; может принимать любой вызываемый объект , зачем вам использовать класс, поскольку он явно более сложный?</target>
        </trans-unit>
        <trans-unit id="bac0117f2a38a17d034595eaa6fbc681396fe5b3" translate="yes" xml:space="preserve">
          <source>Since classes are objects, they must be generated by something.</source>
          <target state="translated">Так как классы являются объектами,они должны быть сгенерированы чем-то.</target>
        </trans-unit>
        <trans-unit id="760ecfb3930f9e09bb9d06c038adf0fa41b52fc4" translate="yes" xml:space="preserve">
          <source>Since classes are objects, you can create them on the fly, like any object.</source>
          <target state="translated">Поскольку классы являются объектами,их можно создавать на лету,как и любой другой объект.</target>
        </trans-unit>
        <trans-unit id="7922a02533e41a18df57099805414126241c109f" translate="yes" xml:space="preserve">
          <source>So now when we create an object with this metaclass, the &lt;code&gt;__repr__&lt;/code&gt; echoed on the command line provides a much less ugly sight than the default:</source>
          <target state="translated">Так что теперь, когда мы создаем объект с этим метаклассом, &lt;code&gt;__repr__&lt;/code&gt; , отображаемый в командной строке, обеспечивает гораздо менее уродливый вид, чем по умолчанию:</target>
        </trans-unit>
        <trans-unit id="b3eadfdf1eb9197422100ebb25f09e54a92a4803" translate="yes" xml:space="preserve">
          <source>So we will start with a simple example, by using a function.</source>
          <target state="translated">Итак,начнем с простого примера,с использования функции.</target>
        </trans-unit>
        <trans-unit id="3baa5edda84402a64f5f0858188ef99b09a86284" translate="yes" xml:space="preserve">
          <source>So what we did was instantiate a metaclass by creating a class. We can also treat the metaclass as we would any other class. It has a method resolution order:</source>
          <target state="translated">Итак,то,что мы сделали-это инстанцировали метакласс,создав класс.Мы также можем относиться к метаклассу,как к любому другому классу.У него есть порядок разрешения методов:</target>
        </trans-unit>
        <trans-unit id="787050e4deb5bdd8472bfd457a5d01da81c38749" translate="yes" xml:space="preserve">
          <source>So, a metaclass is just the stuff that creates class objects.</source>
          <target state="translated">Итак,метакласс-это просто вещь,которая создает объекты класса.</target>
        </trans-unit>
        <trans-unit id="2cdd6c8b1bfe3a886c05a5ee17876f43593f8214" translate="yes" xml:space="preserve">
          <source>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.</source>
          <target state="translated">Подклассы класса будут экземплярами его метакласса,если Вы указали метакласс-класс,но не с помощью функции метакласса.</target>
        </trans-unit>
        <trans-unit id="0e65e54eb14defefa9b23c03a66343a7b6f47568" translate="yes" xml:space="preserve">
          <source>TLDR: A metaclass instantiates and defines behavior for a class just like a class instantiates and defines behavior for an instance.</source>
          <target state="translated">TLDR:Metaclass instantiates и определяет поведение для класса так же,как и класс instantiates и определяет поведение для экземпляра.</target>
        </trans-unit>
        <trans-unit id="ed0c814a6c1a71ccfd0f078327070092fba4af8e" translate="yes" xml:space="preserve">
          <source>That's it. There is really nothing more about metaclasses.</source>
          <target state="translated">Вот так.Больше ничего нет о метаклассах.</target>
        </trans-unit>
        <trans-unit id="a4cdd3d253d3c4a2ec82a87618d1e84a1259cbb8" translate="yes" xml:space="preserve">
          <source>The 'ValidateType' class for reference:</source>
          <target state="translated">Класс 'ValidateType' для справки:</target>
        </trans-unit>
        <trans-unit id="604a85cd97fdfe89bc4bd3ea794f26e3143cb342" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__&quot;&gt;&lt;code&gt;__metaclass__&lt;/code&gt;&lt;/a&gt; attribute</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__&quot;&gt; &lt;code&gt;__metaclass__&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9bee8c22368a6bedc8cb2204d7e38427ec1a6fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__call__()&lt;/code&gt; method is invoked when an instance of a class is used as a callable. But as we've seen from previous answers a class itself is an instance of a metaclass, so when we use the class as a callable (i.e. when we create an instance of it) we're actually calling its metaclass' &lt;code&gt;__call__()&lt;/code&gt; method. At this point most Python programmers are a bit confused because they've been told that when creating an instance like this &lt;code&gt;instance = SomeClass()&lt;/code&gt; you're calling its &lt;code&gt;__init__()&lt;/code&gt; method. Some who've dug a bit deeper know that before &lt;code&gt;__init__()&lt;/code&gt; there's &lt;code&gt;__new__()&lt;/code&gt;. Well, today another layer of truth is being revealed, before &lt;code&gt;__new__()&lt;/code&gt; there's the metaclass' &lt;code&gt;__call__()&lt;/code&gt;.</source>
          <target state="translated">Метод &lt;code&gt;__call__()&lt;/code&gt; вызывается, когда экземпляр класса используется как вызываемый. Но, как мы видели из предыдущих ответов, сам класс является экземпляром метакласса, поэтому, когда мы используем класс в качестве вызываемого (то есть когда мы создаем его экземпляр), мы фактически вызываем его метакласс ' &lt;code&gt;__call__()&lt;/code&gt; , В этот момент большинство программистов на Python немного запутались, потому что им сказали, что при создании экземпляра, подобного этому &lt;code&gt;instance = SomeClass()&lt;/code&gt; вы вызываете его метод &lt;code&gt;__init__()&lt;/code&gt; . Некоторые, кто копнул немного глубже, знают, что до &lt;code&gt;__init__()&lt;/code&gt; есть &lt;code&gt;__new__()&lt;/code&gt; . Что ж, сегодня раскрывается еще один слой правды, перед &lt;code&gt;__new__()&lt;/code&gt; есть метакласс ' &lt;code&gt;__call__()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbdb757e7f3a0fd9bcff0fc938b6c42345b821ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;metaclass&lt;/code&gt; is powerful, there are many things (such as monkey magic) you can do with it, but be careful this may only be known to you.</source>
          <target state="translated">&lt;code&gt;metaclass&lt;/code&gt; является мощным, есть много вещей (например, магия обезьян), которые вы можете сделать с ним, но будьте осторожны, это может быть известно только вам.</target>
        </trans-unit>
        <trans-unit id="7ffedf4f89a6efcf7f214cee31b40dd5d82d9dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type(obj)&lt;/code&gt; function gets you the type of an object.</source>
          <target state="translated">Функция &lt;code&gt;type(obj)&lt;/code&gt; возвращает вам тип объекта.</target>
        </trans-unit>
        <trans-unit id="19c9cb1547b44911ff93834c533ce8c6106e48d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;metaclass&lt;/em&gt; of the object we created, in both cases, is &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Метакласс&lt;/em&gt; созданного нами объекта в обоих случаях является &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1aa36bd31df16516299e0a9f975574341ae6676" translate="yes" xml:space="preserve">
          <source>The above should look familiar. Well, where does &lt;code&gt;Class&lt;/code&gt; come from? It's an instance of a metaclass (also pseudocode):</source>
          <target state="translated">Выше должно выглядеть знакомо. Ну, откуда взялся &lt;code&gt;Class&lt;/code&gt; ? Это экземпляр метакласса (также псевдокода):</target>
        </trans-unit>
        <trans-unit id="a2875f88e41a0ad13dd2d5379ef6582ba0fb3dd7" translate="yes" xml:space="preserve">
          <source>The answer is: something that can create a class.</source>
          <target state="translated">Ответ:что-то,что может создать класс.</target>
        </trans-unit>
        <trans-unit id="9a86d7001554378f3dcbce322b370aaa90ec530c" translate="yes" xml:space="preserve">
          <source>The behaviour of metaclasses however stays &lt;a href=&quot;https://www.python.org/dev/peps/pep-3115/&quot;&gt;largely the same&lt;/a&gt;.</source>
          <target state="translated">Поведение метаклассов, однако, остается в &lt;a href=&quot;https://www.python.org/dev/peps/pep-3115/&quot;&gt;основном таким же&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f6d3b98cc17992d9030a84dca7f0f6a00ff380a" translate="yes" xml:space="preserve">
          <source>The default metaclass, which is applied when when you determine classes as:</source>
          <target state="translated">Метаклас по умолчанию,который применяется при определении классов как:</target>
        </trans-unit>
        <trans-unit id="29b56e4ed0cf2c522c5e5b6e0b098db30123e1fe" translate="yes" xml:space="preserve">
          <source>The intention is clear. When you read &lt;code&gt;UpperAttrMetaclass(type)&lt;/code&gt;, you know
what's going to follow</source>
          <target state="translated">Намерение ясно. Когда вы читаете &lt;code&gt;UpperAttrMetaclass(type)&lt;/code&gt; , вы знаете, что последует</target>
        </trans-unit>
        <trans-unit id="a6e5997843f57dcebc725e6a5762f1c51bce68a1" translate="yes" xml:space="preserve">
          <source>The last word</source>
          <target state="translated">Последнее слово</target>
        </trans-unit>
        <trans-unit id="fde54b7f3e6afffc50941664e058311d935cae06" translate="yes" xml:space="preserve">
          <source>The latter is possible when you implement the &lt;code&gt;__call__()&lt;/code&gt; magic method on the class.</source>
          <target state="translated">Последнее возможно, когда вы реализуете магический метод &lt;code&gt;__call__()&lt;/code&gt; в классе.</target>
        </trans-unit>
        <trans-unit id="71bb84c4860a5a46695ab1e2438f2ed1d5a90d31" translate="yes" xml:space="preserve">
          <source>The main purpose of a metaclass is to change the class automatically,
when it's created.</source>
          <target state="translated">Основное назначение метакласса-автоматическое изменение класса при его создании.</target>
        </trans-unit>
        <trans-unit id="3c9b5afc7d5812bc24e508fdde2021ee24771b8d" translate="yes" xml:space="preserve">
          <source>The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:</source>
          <target state="translated">Основным случаем использования метакласса является создание API.Типичным примером этого является Django ORM.Он позволяет определить что-то подобное:</target>
        </trans-unit>
        <trans-unit id="7ed8ebb489915f332c0205bc56188ef3801ec4e9" translate="yes" xml:space="preserve">
          <source>The metaclass enabling this</source>
          <target state="translated">Метакласс,позволяющий это</target>
        </trans-unit>
        <trans-unit id="d7864ae5ef3f0b7a2f3aacd5831a1402dbade9c3" translate="yes" xml:space="preserve">
          <source>The output will be:</source>
          <target state="translated">Выход будет:</target>
        </trans-unit>
        <trans-unit id="5268adb28d12d30ac6d135d5f75b63e9da11e68b" translate="yes" xml:space="preserve">
          <source>The potential uses for metaclasses are boundless. Some ideas that have been explored include logging, interface checking, automatic delegation, automatic property creation, proxies, frameworks, and automatic resource locking/synchronization.</source>
          <target state="translated">Потенциальные возможности использования метастекла безграничны.Некоторые идеи,которые были изучены,включают протоколирование,проверку интерфейсов,автоматическое делегирование,автоматическое создание свойств,прокси,фреймворки и автоматическую синхронизацию ресурсов.</target>
        </trans-unit>
        <trans-unit id="6907452e93a5a80f5c109418b9bf18c96cd67c09" translate="yes" xml:space="preserve">
          <source>The reason behind the complexity of the code using metaclasses is not because
of metaclasses, it's because you usually use metaclasses to do twisted stuff
relying on introspection, manipulating inheritance, vars such as &lt;code&gt;__dict__&lt;/code&gt;, etc.</source>
          <target state="translated">Причиной сложности кода с использованием метаклассов является не метаклассы, а то, что вы обычно используете метаклассы для скрученных вещей, полагаясь на самоанализ, манипулирование наследованием, переменные типа &lt;code&gt;__dict__&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="292b3d3fa44cb0944294ebc9a86345b3567f6d79" translate="yes" xml:space="preserve">
          <source>The syntax to set the metaclass has been changed in Python 3:</source>
          <target state="translated">Синтаксис установки метакласа был изменен на Python 3:</target>
        </trans-unit>
        <trans-unit id="b4d33846e5640be4c1d9597eafdcc9bc72aceaf5" translate="yes" xml:space="preserve">
          <source>The thing that's left to say is: If you don't know what metaclasses are, the probability that you &lt;strong&gt;will not need them&lt;/strong&gt; is 99%.</source>
          <target state="translated">Осталось сказать следующее: если вы не знаете, что такое метаклассы, вероятность того, что они вам &lt;strong&gt;не понадобятся,&lt;/strong&gt; составляет 99%.</target>
        </trans-unit>
        <trans-unit id="959c3572d6d62fe879c68854fc146ad30c9bb8cd" translate="yes" xml:space="preserve">
          <source>The tl;dr version</source>
          <target state="translated">версия tl;dr</target>
        </trans-unit>
        <trans-unit id="656d2c5fc9c081a8217d9d6a68f3f31fc9b34aef" translate="yes" xml:space="preserve">
          <source>The type() function can return the type of an object or create a new type,</source>
          <target state="translated">Функция type()может возвращать тип объекта или создавать новый тип,</target>
        </trans-unit>
        <trans-unit id="733141dd8934a1c4901342843517b7b8404b6323" translate="yes" xml:space="preserve">
          <source>Then if it can't find any &lt;code&gt;__metaclass__&lt;/code&gt; at all, it will use the &lt;code&gt;Bar&lt;/code&gt;'s (the first parent) own metaclass (which might be the default &lt;code&gt;type&lt;/code&gt;) to create the class object.</source>
          <target state="translated">Затем, если он вообще не может найти &lt;code&gt;__metaclass__&lt;/code&gt; , он будет использовать собственный метакласс &lt;code&gt;Bar&lt;/code&gt; (первый родительский) (который может быть &lt;code&gt;type&lt;/code&gt; по умолчанию) для создания объекта класса.</target>
        </trans-unit>
        <trans-unit id="a771a2f9cc215079a67d4f526fd98ab5b55dcf1f" translate="yes" xml:space="preserve">
          <source>There are (at this point) two key methods in a metaclass:</source>
          <target state="translated">Есть (на данный момент)два ключевых метода в метаклассе:</target>
        </trans-unit>
        <trans-unit id="40e0c7527fe508c7995960aaf38056900b9ff412" translate="yes" xml:space="preserve">
          <source>There are several reasons to do so:</source>
          <target state="translated">Есть несколько причин для этого:</target>
        </trans-unit>
        <trans-unit id="9e2063eee3f575331ddd73d7a81c2d318f5daa93" translate="yes" xml:space="preserve">
          <source>These are called metaclasses, damn it! It must mean something!</source>
          <target state="translated">Это называется метаклассами,черт возьми! Это должно что-то значить!</target>
        </trans-unit>
        <trans-unit id="3b5c4cd62ac6b431a5176848fb6508cfa06be65a" translate="yes" xml:space="preserve">
          <source>This is a case where I saw metaclass as a solution to my problem:
I had a really complicated problem, that probably could have been solved differently, but I chose to solve it using a metaclass.  Because of the complexity, it is one of the few modules I have written where the comments in the module surpass the amount of code that has been written.  Here it is...</source>
          <target state="translated">В этом случае я увидел в метаклассе решение своей проблемы:у меня была действительно сложная проблема,которую,наверное,можно было бы решить по-другому,но я решил решить ее с помощью метакласса.Из-за сложности,это один из немногих модулей,где комментарии в модуле превосходят количество написанного кода.Вот он.</target>
        </trans-unit>
        <trans-unit id="bd01e02e8d937d71c953efd2b047baa65d13a9d0" translate="yes" xml:space="preserve">
          <source>This is a class that uses that metaclass</source>
          <target state="translated">Это класс,который использует этот метакласс.</target>
        </trans-unit>
        <trans-unit id="0eaab00f42bc385328b90e65be0df9fd3ce443e5" translate="yes" xml:space="preserve">
          <source>This is a metaclass that logs exactly the moment before an instance is created and the moment it's about to return it.</source>
          <target state="translated">Это метакласс,который записывает в журнал именно тот момент,предшествующий созданию экземпляра,и тот момент,когда он собирается его вернуть.</target>
        </trans-unit>
        <trans-unit id="a91ffeba7150d22f41622349f220dc2a7bd0941e" translate="yes" xml:space="preserve">
          <source>This is possible because &lt;code&gt;models.Model&lt;/code&gt; defines &lt;code&gt;__metaclass__&lt;/code&gt; and
it uses some magic that will turn the &lt;code&gt;Person&lt;/code&gt; you just defined with simple statements
into a complex hook to a database field.</source>
          <target state="translated">Это возможно, потому что &lt;code&gt;models.Model&lt;/code&gt; определяет &lt;code&gt;__metaclass__&lt;/code&gt; и использует магию, которая превратит &lt;code&gt;Person&lt;/code&gt; вы только что определили, с помощью простых операторов, в сложную привязку к полю базы данных.</target>
        </trans-unit>
        <trans-unit id="4f1bef529754046ab93614c707e29ea65f065a58" translate="yes" xml:space="preserve">
          <source>This is what Python does when you use the keyword &lt;code&gt;class&lt;/code&gt;, and it does so by using a metaclass.</source>
          <target state="translated">Это то, что делает Python, когда вы используете ключевое слово &lt;code&gt;class&lt;/code&gt; , и это делается с помощью метакласса.</target>
        </trans-unit>
        <trans-unit id="690dffa17d6286ca4b5f0d265293b3aba8dc9308" translate="yes" xml:space="preserve">
          <source>This is what the metaclass would look like (not using &lt;code&gt;__prepare__&lt;/code&gt; since it is not needed):</source>
          <target state="translated">Вот как будет выглядеть метакласс (без использования &lt;code&gt;__prepare__&lt;/code&gt; , поскольку он не нужен):</target>
        </trans-unit>
        <trans-unit id="3a703a42ef6d26d4b5acc17812e989feee889a40" translate="yes" xml:space="preserve">
          <source>This way, all classes of this module will be created using this metaclass,
and we just have to tell the metaclass to turn all attributes to uppercase.</source>
          <target state="translated">Таким образом,все классы этого модуля будут созданы с использованием этого метакласса,и нам просто нужно сказать метаклассу,чтобы все атрибуты были повернуты в верхний регистр.</target>
        </trans-unit>
        <trans-unit id="c8eb39184302c31569399fad3b80b08d690c761d" translate="yes" xml:space="preserve">
          <source>To create a metaclass, overriding of &lt;strong&gt;new&lt;/strong&gt;() and &lt;strong&gt;init&lt;/strong&gt;() methods is usually done. &lt;strong&gt;new&lt;/strong&gt;() can be overridden to change the way objects are created, while &lt;strong&gt;init&lt;/strong&gt;() can be overridden to change the way of initializing the object. Metaclass can be created by a number of ways. One of the ways is to use type() function. type() function, when called with 3 parameters, creates a metaclass. The parameters are :-</source>
          <target state="translated">Для создания метакласса обычно выполняется переопределение методов &lt;strong&gt;new&lt;/strong&gt; () и &lt;strong&gt;init&lt;/strong&gt; (). &lt;strong&gt;new&lt;/strong&gt; () может быть переопределен, чтобы изменить способ создания объектов, в то время как &lt;strong&gt;init&lt;/strong&gt; () может быть переопределен, чтобы изменить способ инициализации объекта. Метакласс может быть создан несколькими способами. Одним из способов является использование функции type (). Функция type () при вызове с 3 параметрами создает метакласс. Параметры: -</target>
        </trans-unit>
        <trans-unit id="7f66480aa700b9c3c9e3a6513f4f91ad438a6ac8" translate="yes" xml:space="preserve">
          <source>To use a metaclass:</source>
          <target state="translated">Чтобы использовать метакласс:</target>
        </trans-unit>
        <trans-unit id="9d625953b8c96c50aabee6488063e1446a582041" translate="yes" xml:space="preserve">
          <source>Tuple having base classes inherited by class</source>
          <target state="translated">Кортеж,имеющий базовые классы,унаследованные от класса.</target>
        </trans-unit>
        <trans-unit id="d0594a199ce5d4ac41e3201736acd504b143394b" translate="yes" xml:space="preserve">
          <source>We can extend &lt;code&gt;type&lt;/code&gt; just like any other class definition:</source>
          <target state="translated">Мы можем расширить &lt;code&gt;type&lt;/code&gt; как и любое другое определение класса:</target>
        </trans-unit>
        <trans-unit id="d88182269b2e241ec478b27d4767550768772015" translate="yes" xml:space="preserve">
          <source>We can make it even cleaner by using &lt;code&gt;super&lt;/code&gt;, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):</source>
          <target state="translated">Мы можем сделать его еще чище, используя &lt;code&gt;super&lt;/code&gt; , что облегчит наследование (потому что да, вы можете иметь метаклассы, наследуя от метаклассов, наследуя от типа):</target>
        </trans-unit>
        <trans-unit id="92762df1c860bcdb2ae4c1a3bc542b57879d0959" translate="yes" xml:space="preserve">
          <source>We can see that the metaclass' &lt;code&gt;__call__()&lt;/code&gt; method is the one that's called first. It then delegates creation of the instance to the class's &lt;code&gt;__new__()&lt;/code&gt; method and initialization to the instance's &lt;code&gt;__init__()&lt;/code&gt;. It's also the one that ultimately returns the instance.</source>
          <target state="translated">Мы видим, что метод &lt;code&gt;__call__()&lt;/code&gt; ' __call __ () - это тот, который вызывается первым. Затем он делегирует создание экземпляра методу &lt;code&gt;__new__()&lt;/code&gt; класса и инициализацию &lt;code&gt;__init__()&lt;/code&gt; экземпляра. Это также тот, который в конечном итоге возвращает экземпляр.</target>
        </trans-unit>
        <trans-unit id="16d288708e3034e3415f37e929abe09a44ae3d9f" translate="yes" xml:space="preserve">
          <source>Well in fact, classes are themselves instances. Of metaclasses.</source>
          <target state="translated">Ну,на самом деле,занятия сами по себе примеры.Метаклассов.</target>
        </trans-unit>
        <trans-unit id="d278e4f17ef8ed67c2a22f4c32904a94d842130f" translate="yes" xml:space="preserve">
          <source>Well, &lt;a href=&quot;http://docs.python.org/2/library/functions.html#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; has a completely different ability, it can also create classes on the fly. &lt;code&gt;type&lt;/code&gt; can take the description of a class as parameters,
and return a class.</source>
          <target state="translated">Ну, у &lt;a href=&quot;http://docs.python.org/2/library/functions.html#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; есть совершенно другая способность, он также может создавать классы на лету. &lt;code&gt;type&lt;/code&gt; может принимать описание класса в качестве параметров и возвращать класс.</target>
        </trans-unit>
        <trans-unit id="f58b345320ab6cedc6dd827175904f92af7b09a9" translate="yes" xml:space="preserve">
          <source>Well, I guess it's a matter of consistency with &lt;code&gt;str&lt;/code&gt;, the class that creates
strings objects, and &lt;code&gt;int&lt;/code&gt; the class that creates integer objects. &lt;code&gt;type&lt;/code&gt; is
just the class that creates class objects.</source>
          <target state="translated">Ну, я предполагаю, что это вопрос согласованности с &lt;code&gt;str&lt;/code&gt; , классом, который создает строковые объекты, и &lt;code&gt;int&lt;/code&gt; с классом, который создает целочисленные объекты. &lt;code&gt;type&lt;/code&gt; это просто класс, который создает объекты класса.</target>
        </trans-unit>
        <trans-unit id="a0696d6279da7380ed7a9d1f185eabd27a76e2f1" translate="yes" xml:space="preserve">
          <source>Well, metaclasses are what create these objects. They are the classes' classes,
you can picture them this way:</source>
          <target state="translated">Ну,метаклассы-это то,что создает эти объекты.Это классы,вы можете представить их таким образом:</target>
        </trans-unit>
        <trans-unit id="cd8f8377093c7a9f568847ac99d779518ff62c1b" translate="yes" xml:space="preserve">
          <source>Well, usually you don't:</source>
          <target state="translated">Ну,обычно нет:</target>
        </trans-unit>
        <trans-unit id="464df4ba1017e09b5d8fcbcb6bc3f85fc5e4129e" translate="yes" xml:space="preserve">
          <source>What are metaclasses (finally)</source>
          <target state="translated">Что такое метаклассы (наконец-то)...</target>
        </trans-unit>
        <trans-unit id="7be40721cc8b807cb99d9d947eae9af189c69085" translate="yes" xml:space="preserve">
          <source>What are metaclasses in Python</source>
          <target state="translated">Что такое метаклассы на Питоне?</target>
        </trans-unit>
        <trans-unit id="95ac2d20e8da72812ecb5a849d130ac5cab6552d" translate="yes" xml:space="preserve">
          <source>What are metaclasses? What do you use them for?</source>
          <target state="translated">Что такое метаклассы? Для чего они используются?</target>
        </trans-unit>
        <trans-unit id="ca7233bf93e47a10f12eab5a25b942225351fd97" translate="yes" xml:space="preserve">
          <source>What can they be used for? From the &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">Для чего они могут быть использованы? Из &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;документов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="faccab95a2838e0f66852ca4a5c0f3a913942d90" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;class&lt;/code&gt; statement is executed, Python first executes the body of the &lt;code&gt;class&lt;/code&gt; statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the &lt;code&gt;__metaclass__&lt;/code&gt; attribute of the class-to-be (if any) or the &lt;code&gt;__metaclass__&lt;/code&gt; global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.</source>
          <target state="translated">Когда выполняется оператор &lt;code&gt;class&lt;/code&gt; , Python сначала выполняет тело оператора &lt;code&gt;class&lt;/code&gt; как обычный блок кода. Результирующее пространство имен (dict) содержит атрибуты будущего класса. Метакласс определяется путем просмотра базовых классов будущего класса (метаклассы наследуются), атрибута &lt;code&gt;__metaclass__&lt;/code&gt; будущего класса (если есть) или глобальной переменной &lt;code&gt;__metaclass__&lt;/code&gt; . Затем метакласс вызывается с именем, основами и атрибутами класса, чтобы создать его экземпляр.</target>
        </trans-unit>
        <trans-unit id="0f703991c228a312fa1f4a4718f72097c5f38dc7" translate="yes" xml:space="preserve">
          <source>When we instantiate an object, we get an instance:</source>
          <target state="translated">Когда мы инстанцируем объект,мы получаем экземпляр:</target>
        </trans-unit>
        <trans-unit id="2e8ee345e21d7df889e916663fa72306a26db891" translate="yes" xml:space="preserve">
          <source>When you do:</source>
          <target state="translated">Когда ты это сделаешь:</target>
        </trans-unit>
        <trans-unit id="8eadeed1a219183cc2c88f7ec677f6b2d5aec1aa" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; keyword, Python creates this object automatically. But as
with most things in Python, it gives you a way to do it manually.</source>
          <target state="translated">Когда вы используете ключевое слово &lt;code&gt;class&lt;/code&gt; , Python создает этот объект автоматически. Но, как и большинство вещей в Python, он дает вам возможность сделать это вручную.</target>
        </trans-unit>
        <trans-unit id="ea3a686b188cb5fead0828deafd55680a345ac59" translate="yes" xml:space="preserve">
          <source>When you write a class definition and Python executes it, it uses a metaclass to instantiate the class object (which will, in turn, be used to instantiate instances of that class).</source>
          <target state="translated">Когда вы пишете определение класса и Python выполняет его,он использует метаклас для инстанцирования объекта класса (который,в свою очередь,будет использоваться для инстанцирования экземпляров этого класса).</target>
        </trans-unit>
        <trans-unit id="0c3bff2984a4115df4dcc3bfb7149ff8691306a4" translate="yes" xml:space="preserve">
          <source>When you write a class definition, for example, like this,</source>
          <target state="translated">Когда вы пишете определение класса,например,вот так,</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="8c962cb76a1933afc23c5280c46178cdc0963538" translate="yes" xml:space="preserve">
          <source>While in Python you can use arbitrary callables for metaclasses (like &lt;a href=&quot;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037&quot;&gt;Jerub&lt;/a&gt; shows), the better approach is to make it an actual class itself. &lt;code&gt;type&lt;/code&gt; is the usual metaclass in Python. &lt;code&gt;type&lt;/code&gt; is itself a class, and it is its own type. You won't be able to recreate something like &lt;code&gt;type&lt;/code&gt; purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">В то время как в Python вы можете использовать произвольные вызываемые &lt;a href=&quot;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037&quot;&gt;элементы&lt;/a&gt; для метаклассов (как показано на Jerub ), лучший подход состоит в том, чтобы сделать его самим классом. &lt;code&gt;type&lt;/code&gt; - это обычный метакласс в Python. &lt;code&gt;type&lt;/code&gt; сам по себе является классом, и это его собственный тип. Вы не сможете воссоздать что-то вроде &lt;code&gt;type&lt;/code&gt; исключительно в Python, но Python немного обманывает. Чтобы создать свой собственный метакласс в Python, вы просто хотите использовать &lt;code&gt;type&lt;/code&gt; подкласса.</target>
        </trans-unit>
        <trans-unit id="ff246de9114513e53dcf845cd6f5e43b2c9dffe8" translate="yes" xml:space="preserve">
          <source>Why would you use metaclasses classes instead of functions?</source>
          <target state="translated">Почему вы используете классы метакласса вместо функций?</target>
        </trans-unit>
        <trans-unit id="29f54ff47c50feb7cebfef143da1409f28cafef5" translate="yes" xml:space="preserve">
          <source>Why would you use metaclasses?</source>
          <target state="translated">Зачем тебе метаклассы?</target>
        </trans-unit>
        <trans-unit id="70111da65d9e847b219ad4430cd1c1828a6ec8a3" translate="yes" xml:space="preserve">
          <source>With a nice &lt;code&gt;__repr__&lt;/code&gt; defined for the class instance, we have a stronger ability to debug our code. However, much further checking with &lt;code&gt;eval(repr(Class))&lt;/code&gt; is unlikely (as functions would be rather impossible to eval from their default &lt;code&gt;__repr__&lt;/code&gt;'s).</source>
          <target state="translated">С хорошим &lt;code&gt;__repr__&lt;/code&gt; , определенным для экземпляра класса, мы имеем более сильную способность отлаживать наш код. Однако дальнейшая проверка с помощью &lt;code&gt;eval(repr(Class))&lt;/code&gt; маловероятна (так как функции было бы невозможно &lt;code&gt;__repr__&lt;/code&gt; из значений по умолчанию __repr__ ).</target>
        </trans-unit>
        <trans-unit id="7e2b61a0c2abd2b5f5ed9ec2bcb225e75cc74640" translate="yes" xml:space="preserve">
          <source>Yes, objects.</source>
          <target state="translated">Да,объекты.</target>
        </trans-unit>
        <trans-unit id="0ff433fbf5a657d09064a10812fe33b78649c66e" translate="yes" xml:space="preserve">
          <source>You can call it a 'class factory' if you wish.</source>
          <target state="translated">Вы можете назвать это &quot;фабрикой класса&quot;,если хотите.</target>
        </trans-unit>
        <trans-unit id="315df7f70140693e8a8bc6a5c96aefabd150fb69" translate="yes" xml:space="preserve">
          <source>You can hook on &lt;code&gt;__new__&lt;/code&gt;, &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;__call__&lt;/code&gt;. Which will allow
you to do different stuff. Even if usually you can do it all in &lt;code&gt;__new__&lt;/code&gt;,
some people are just more comfortable using &lt;code&gt;__init__&lt;/code&gt;.</source>
          <target state="translated">Вы можете подключить &lt;code&gt;__new__&lt;/code&gt; , &lt;code&gt;__init__&lt;/code&gt; и &lt;code&gt;__call__&lt;/code&gt; . Что позволит вам делать разные вещи. Даже если обычно вы можете делать все это в &lt;code&gt;__new__&lt;/code&gt; , некоторым людям просто удобнее использовать &lt;code&gt;__init__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58cba9a2524d4784e2abd94ecd3a9d0567aa5f1b" translate="yes" xml:space="preserve">
          <source>You can structure your code better. You never use metaclasses for something as
trivial as the above example. It's usually for something complicated. Having the
ability to make several methods and group them in one class is very useful
to make the code easier to read.</source>
          <target state="translated">Ты можешь структурировать свой код лучше.Вы никогда не используете метаклассы для чего-то столь банального,как приведенный выше пример.Обычно это для чего-то сложного.Очень полезно иметь возможность сделать несколько методов и сгруппировать их в один класс,чтобы сделать код более удобным для чтения.</target>
        </trans-unit>
        <trans-unit id="64c7301b56292e883aabaa3c4edaf3cf8efc42f2" translate="yes" xml:space="preserve">
          <source>You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.</source>
          <target state="translated">Ты можешь использовать ООП.Metaclass может наследовать от метакласса,переопределяя родительские методы.Метаклассы могут даже использовать метаклассы.</target>
        </trans-unit>
        <trans-unit id="fb6eb327fa8c07c0f464979436e448c8c249d0c5" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;metaclass&lt;/code&gt; to change the function of its instance (the class).</source>
          <target state="translated">Вы можете использовать &lt;code&gt;metaclass&lt;/code&gt; для изменения функции своего экземпляра (класса).</target>
        </trans-unit>
        <trans-unit id="c4bc4a8b7d34394849ad10cef64e38894a0239e3" translate="yes" xml:space="preserve">
          <source>You define classes in order to create objects, right?</source>
          <target state="translated">Вы ведь определяете классы для создания объектов?</target>
        </trans-unit>
        <trans-unit id="849b6a4a3ab49b1e6d5d5fb3aa2174a5dd045d4a" translate="yes" xml:space="preserve">
          <source>You instantiate a class object.</source>
          <target state="translated">Ты инстанцируешь объект класса.</target>
        </trans-unit>
        <trans-unit id="452647fa644731ccf4d36abe26b42b7338dc3ada" translate="yes" xml:space="preserve">
          <source>You may have noticed the extra argument &lt;code&gt;cls&lt;/code&gt;. There is
nothing special about it: &lt;code&gt;__new__&lt;/code&gt; always receives the class it's defined in, as first parameter. Just like you have &lt;code&gt;self&lt;/code&gt; for ordinary methods which receive the instance as first parameter, or the defining class for class methods.</source>
          <target state="translated">Возможно, вы заметили дополнительный аргумент &lt;code&gt;cls&lt;/code&gt; . В этом нет ничего особенного: &lt;code&gt;__new__&lt;/code&gt; всегда получает класс, в котором он определен, в качестве первого параметра. Также как у вас есть &lt;code&gt;self&lt;/code&gt; для обычных методов, которые получают экземпляр в качестве первого параметра, или определяющий класс для методов класса.</target>
        </trans-unit>
        <trans-unit id="22aa6e506f7cc49a7a64f3ca6d175caba8e4b9d1" translate="yes" xml:space="preserve">
          <source>You see that by checking the &lt;code&gt;__class__&lt;/code&gt; attribute.</source>
          <target state="translated">Вы видите это, проверив атрибут &lt;code&gt;__class__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbebccfb501c9be50998ab8dec87986aaf76e78c" translate="yes" xml:space="preserve">
          <source>You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.</source>
          <target state="translated">Вы видите,куда мы идем:на Python классы-это объекты,и вы можете создать класс на лету,динамически.</target>
        </trans-unit>
        <trans-unit id="33931bf86a8faf49146362a3955005056936d8f9" translate="yes" xml:space="preserve">
          <source>You use a metaclass every time you create a class:</source>
          <target state="translated">Вы используете метакласс каждый раз,когда создаете класс:</target>
        </trans-unit>
        <trans-unit id="892eaf1f9b8ad532b3d9e3281eddca7576cc2b2a" translate="yes" xml:space="preserve">
          <source>You usually do this for APIs, where you want to create classes matching the
current context.</source>
          <target state="translated">Обычно вы делаете это для API,где вы хотите создать классы,соответствующие текущему контексту.</target>
        </trans-unit>
        <trans-unit id="c865cc52046698fef0b1aa97a9a5a1e90813f189" translate="yes" xml:space="preserve">
          <source>You write &lt;code&gt;class Foo(object)&lt;/code&gt; first, but the class object &lt;code&gt;Foo&lt;/code&gt; is not created
in memory yet.</source>
          <target state="translated">Сначала вы пишете &lt;code&gt;class Foo(object)&lt;/code&gt; , но объект класса &lt;code&gt;Foo&lt;/code&gt; еще не создан в памяти.</target>
        </trans-unit>
        <trans-unit id="fba87a7567989400ed959bfd1f57626604f0e103" translate="yes" xml:space="preserve">
          <source>You'll notice that we use &quot;MyShinyClass&quot; as the name of the class
and as the variable to hold the class reference. They can be different,
but there is no reason to complicate things.</source>
          <target state="translated">Вы заметите,что мы используем &quot;MyShinyClass&quot; в качестве имени класса и в качестве переменной для хранения ссылки на класс.Они могут быть разными,но нет причин все усложнять.</target>
        </trans-unit>
        <trans-unit id="468ec3a2130a90f33fbe9e9010d78aea548729a5" translate="yes" xml:space="preserve">
          <source>You've seen that &lt;code&gt;type&lt;/code&gt; lets you do something like this:</source>
          <target state="translated">Вы видели, что этот &lt;code&gt;type&lt;/code&gt; позволяет вам сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="62dbbb0781988a55d8018a0fec2c8ecd07b793aa" translate="yes" xml:space="preserve">
          <source>anyhow, those two are the most commonly used hooks. metaclassing is powerful, and above is nowhere near and exhaustive list of uses for metaclassing.</source>
          <target state="translated">Во всяком случае,эти два наиболее часто используемых крюка.Метаклассирование является мощным,и выше не существует и исчерпывающего списка применений для метаклассирования.</target>
        </trans-unit>
        <trans-unit id="b3505d90044ca3190f7e9581b12b5ae05136055b" translate="yes" xml:space="preserve">
          <source>can be created manually this way:</source>
          <target state="translated">можно создать вручную:</target>
        </trans-unit>
        <trans-unit id="6737e4457bda9ffaf5726333b2319e8722cf25b9" translate="yes" xml:space="preserve">
          <source>class decorators</source>
          <target state="translated">классные декораторы</target>
        </trans-unit>
        <trans-unit id="44c4e8ef96ee00251b1324e275bce4fb98f44122" translate="yes" xml:space="preserve">
          <source>creates in memory an object with the name &quot;ObjectCreator&quot;.</source>
          <target state="translated">создает в памяти объект с именем &quot;ObjectCreator&quot;.</target>
        </trans-unit>
        <trans-unit id="4f7f64c1613218412d7173f07c7407d18b5776a8" translate="yes" xml:space="preserve">
          <source>e.g.:</source>
          <target state="translated">e.g.:</target>
        </trans-unit>
        <trans-unit id="7db9ff8b86f3d42798dfbf41b5e2001a92aac528" translate="yes" xml:space="preserve">
          <source>for example, we can create a Hi class with the type() function and do not  need to use this way with class Hi(object):</source>
          <target state="translated">Например,можно создать класс Hi с функцией type()и не использовать этот способ с классом Hi(object):</target>
        </trans-unit>
        <trans-unit id="760b292bf27a8fcf8c272fa886f3c465a88b9738" translate="yes" xml:space="preserve">
          <source>i.e. the &lt;code&gt;__metaclass__&lt;/code&gt; attribute is no longer used, in favor of a keyword argument in the list of base classes.</source>
          <target state="translated">т.е. атрибут &lt;code&gt;__metaclass__&lt;/code&gt; больше не используется в пользу ключевого аргумента в списке базовых классов.</target>
        </trans-unit>
        <trans-unit id="bebe93e3c9401a8e4b84a6e20e06834c7fbff805" translate="yes" xml:space="preserve">
          <source>intercept a class creation</source>
          <target state="translated">перехват создания класса</target>
        </trans-unit>
        <trans-unit id="b6a7d03698a36198740b6b7e1269046f935e6ce5" translate="yes" xml:space="preserve">
          <source>meta class are used to apply some rule to an entire set of classes. For example, suppose you're building an ORM to access a database, and you want records from each table to be of a class mapped to that table (based on fields, business rules, etc..,), a possible use of metaclass is for instance, connection pool logic, which is share by all classes of record from all tables. Another use is logic to to support foreign keys, which involves multiple classes of records.</source>
          <target state="translated">Мета-класс используется для применения некоторого правила ко всему набору классов.Например,предположим,что вы строите ORM для доступа к базе данных,и хотите,чтобы записи из каждой таблицы были класса,привязанного к этой таблице (на основе полей,бизнес-правил и т.д.,и т.п.),возможным использованием мета-класса является,например,логика пула соединений,которая разделяется всеми классами записей из всех таблиц.Другое применение-логика поддержки внешних ключей,которая включает в себя несколько классов записей.</target>
        </trans-unit>
        <trans-unit id="b24e026cd23631fc8326fba464790376a289820a" translate="yes" xml:space="preserve">
          <source>modify the class</source>
          <target state="translated">изменить класс</target>
        </trans-unit>
        <trans-unit id="1123af1e86c1be3e13a73d667767a3eaa9fab222" translate="yes" xml:space="preserve">
          <source>monkey patching</source>
          <target state="translated">заплатка обезьяны</target>
        </trans-unit>
        <trans-unit id="2bcec56171df3c6150684b60fb0f16c51e1923ed" translate="yes" xml:space="preserve">
          <source>produces:</source>
          <target state="translated">produces:</target>
        </trans-unit>
        <trans-unit id="17156a7f53f004d6bfc86c20c78c7a60336f9799" translate="yes" xml:space="preserve">
          <source>return the modified class</source>
          <target state="translated">возвращать изменённый класс</target>
        </trans-unit>
        <trans-unit id="f89967a1b044b115ecabfb714ba2baf9e25b3905" translate="yes" xml:space="preserve">
          <source>when a particular effect has to be applied to all the subclasses</source>
          <target state="translated">когда определенный эффект должен быть применен ко всем подклассам</target>
        </trans-unit>
        <trans-unit id="129a078ecb9597f440ced3af47b17543ec3a8923" translate="yes" xml:space="preserve">
          <source>when you define metaclass, you subclass type, and can overrided the following magic methods to insert your logic.</source>
          <target state="translated">когда вы определяете метакласс,вы определяете тип подкласса,и можете переопределить следующие волшебные методы для вставки вашей логики.</target>
        </trans-unit>
        <trans-unit id="a0ebc00ce2803c4b05ae16c519fdb6afbeecd7c8" translate="yes" xml:space="preserve">
          <source>would be:</source>
          <target state="translated">было бы:</target>
        </trans-unit>
        <trans-unit id="f00aae84260cf328c69240a8408c132eec41893a" translate="yes" xml:space="preserve">
          <source>you can add attributes to it</source>
          <target state="translated">вы можете добавлять к нему атрибуты</target>
        </trans-unit>
        <trans-unit id="7f5329be6ce9f06a3c0b500a9af459ec3e4c8730" translate="yes" xml:space="preserve">
          <source>you can assign it to a variable</source>
          <target state="translated">вы можете присвоить его переменной</target>
        </trans-unit>
        <trans-unit id="d5e1f2ccb7cae42051601ddb1f83165a911f6cab" translate="yes" xml:space="preserve">
          <source>you can copy it</source>
          <target state="translated">вы можете скопировать его</target>
        </trans-unit>
        <trans-unit id="98b6e75ac98f8c1aab7ac264a673d0bea107ebd2" translate="yes" xml:space="preserve">
          <source>you can pass it as a function parameter</source>
          <target state="translated">вы можете передать его как параметр функции</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
