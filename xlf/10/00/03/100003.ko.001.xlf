<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/100003">
    <body>
      <group id="100003">
        <trans-unit id="75f904e8b7fedc01e237553e4c1e63dc973e6787" translate="yes" xml:space="preserve">
          <source>(A side-note on the contents of the class &lt;code&gt;__dict__&lt;/code&gt;: &lt;code&gt;__module__&lt;/code&gt; is there because classes must know where they are defined, and  &lt;code&gt;__dict__&lt;/code&gt; and &lt;code&gt;__weakref__&lt;/code&gt; are there because we don't define &lt;code&gt;__slots__&lt;/code&gt; - if we &lt;a href=&quot;https://stackoverflow.com/q/472000/541136&quot;&gt;define &lt;code&gt;__slots__&lt;/code&gt;&lt;/a&gt; we'll save a bit of space in the instances, as we can disallow &lt;code&gt;__dict__&lt;/code&gt; and &lt;code&gt;__weakref__&lt;/code&gt; by excluding them. For example:</source>
          <target state="translated">(클래스 &lt;code&gt;__dict__&lt;/code&gt; : &lt;code&gt;__module__&lt;/code&gt; 의 내용에 대한 참고 사항은 클래스가 정의 된 위치를 알아야하기 때문에 존재하며 &lt;code&gt;__dict__&lt;/code&gt; 및 &lt;code&gt;__weakref__&lt;/code&gt; 는 &lt;code&gt;__slots__&lt;/code&gt; 를 정의하지 않기 때문에 존재합니다. __slots__ 를 &lt;a href=&quot;https://stackoverflow.com/q/472000/541136&quot;&gt;정의&lt;/a&gt; 하면 약간의 비용을 절약 할 수 있습니다 &lt;code&gt;__dict__&lt;/code&gt; 및 &lt;code&gt;__weakref__&lt;/code&gt; 를 제외하여 허용하지 않을 수 있으므로 인스턴스에 공백이 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="80ce04df15f97539136582b49b933ab604f9103b" translate="yes" xml:space="preserve">
          <source>(I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backwards
compatibility in Python)</source>
          <target state="translated">(나는 동일한 함수가 전달하는 매개 변수에 따라 두 가지 완전히 다른 용도를 가질 수 있다는 것은 바보 같은 사실입니다. Python의 하위 호환성으로 인해 문제가됩니다)</target>
        </trans-unit>
        <trans-unit id="2ac0d02e51ef16f7af8ae886bdf0e4fa530c5f5d" translate="yes" xml:space="preserve">
          <source>... but I digress.)</source>
          <target state="translated">...하지만 나는 산만하다.)</target>
        </trans-unit>
        <trans-unit id="f6ebd068cb008bd8fb59b8b2729d85510c67060a" translate="yes" xml:space="preserve">
          <source>99% of the time you need class alteration, you are better off using these.</source>
          <target state="translated">수업 변경이 필요한 시간의 99 %는이를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="97c9f0c35f46135bb3f31b3babd294116e47cb9e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&lt;/a&gt; (archived at &lt;a href=&quot;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html(https://web.archive.org/web/20080206005253/http://www.onlamp에&lt;/a&gt; 보관 됨) &lt;a href=&quot;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;com / pub / a / python / 2003 / 04 / 17 / metaclasses.html&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3bdb50500a7c19592bda8809f1f54a3155b055d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclasses&quot;&gt;Here&lt;/a&gt; you can read about how to use metaclasses to customize class construction.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclasses&quot;&gt;여기&lt;/a&gt; 에서는 메타 클래스를 사용하여 클래스 구성을 사용자 정의하는 방법에 대해 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a50fc3237b1a93efefaaf939cf45f327c9ed165c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__new__&lt;/code&gt; is responsible for the actual creation/modification of the final class.</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; 는 최종 클래스의 실제 생성 / 수정을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="1a0d6bf17eaa1810f965cf7374357b165ec381aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__prepare__&lt;/code&gt; lets you supply a custom mapping (such as an &lt;code&gt;OrderedDict&lt;/code&gt;) to be used as the namespace while the class is being created.  You must return an instance of whatever namespace you choose.  If you don't implement &lt;code&gt;__prepare__&lt;/code&gt; a normal &lt;code&gt;dict&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;__prepare__&lt;/code&gt; 를 사용하면 클래스를 만드는 동안 네임 스페이스로 사용할 사용자 지정 매핑 (예 : &lt;code&gt;OrderedDict&lt;/code&gt; )을 제공 할 수 있습니다. 선택한 네임 스페이스의 인스턴스를 반환해야합니다. &lt;code&gt;__prepare__&lt;/code&gt; 를 구현하지 않으면 일반 &lt;code&gt;dict&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="023d195e822e75fe65a0924f1427b5fdf01fc5ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__prepare__&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;__prepare__&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="7d878c7158652444f7186704c3b33f7141e22209" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; accepts a dictionary to define the attributes of the class. So:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 은 클래스의 속성을 정의하기위한 사전을 허용합니다. 그래서:</target>
        </trans-unit>
        <trans-unit id="5d2e1c2d0bbec05a50948a1721fe99a3b39aa6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is actually a &lt;code&gt;metaclass&lt;/code&gt; -- a class that creates another classes.
Most &lt;code&gt;metaclass&lt;/code&gt; are the subclasses of &lt;code&gt;type&lt;/code&gt;. The &lt;code&gt;metaclass&lt;/code&gt; receives the &lt;code&gt;new&lt;/code&gt; class as its first argument and provide access to class object with details as mentioned below:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 은 실제로 &lt;code&gt;metaclass&lt;/code&gt; 클래스 (다른 클래스를 만드는 클래스)입니다. 대부분의 &lt;code&gt;metaclass&lt;/code&gt; 클래스는 &lt;code&gt;type&lt;/code&gt; 의 서브 클래스입니다. &lt;code&gt;metaclass&lt;/code&gt; 는 &lt;code&gt;new&lt;/code&gt; 클래스를 첫 번째 인수로 받고 아래에 설명 된대로 세부 사항으로 클래스 오브젝트에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d9eba8487bfc807b1b32e61a4fcc2b4d4099fc9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is actually its own metaclass. This is not something you could
reproduce in pure Python, and is done by cheating a little bit at the implementation
level.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 은 실제로 자체 메타 클래스입니다. 이것은 순수한 파이썬에서 재현 할 수있는 것이 아니며 구현 수준에서 약간의 부정 행위로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="55ff24a1972577aa56cf45cfad50fad1fa3a38ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is its own metaclass. The class of a class is a metaclass-- the body of a class is the arguments passed to the metaclass that is used to construct the class.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 은 자체 메타 클래스입니다. 클래스의 클래스는 메타 클래스입니다. 클래스의 본문은 클래스를 구성하는 데 사용되는 메타 클래스에 전달되는 인수입니다.</target>
        </trans-unit>
        <trans-unit id="b56139b823c7b0ae94bce907510423f13ee59acc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is the built-in metaclass Python uses, but of course, you can create your
own metaclass.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 은 파이썬이 사용하는 내장 메타 클래스이지만, 물론 자신 만의 메타 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e9b06716bef6742d220da876612fb09c18a1de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; works this way:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a9b27deb1c48c1688dcbf6153f9703f0928f091b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note, this answer is for Python 2.x as it was written in 2008, metaclasses are slightly different in 3.x.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 답변은 2008 년에 작성된 Python 2.x에 대한 것이며 메타 클래스는 3.x에서 약간 다릅니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90461ec79be347574dc9366bf79436c53a18378b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Python Guru Tim Peters&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;파이썬 전문가 팀 피터스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaee62583d5533c9937128f100302a2beb82df5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;attrs&lt;/code&gt;&lt;/strong&gt;: dictionary containing attributes names and values</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;attrs&lt;/code&gt; &lt;/strong&gt; : 속성 이름과 값을 포함하는 사전</target>
        </trans-unit>
        <trans-unit id="6b235afc3403ff79e2b3ea50c1ad732bc7d0bc59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;bases&lt;/code&gt;&lt;/strong&gt;: tuple of the parent class (for inheritance, can be empty)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;bases&lt;/code&gt; &lt;/strong&gt; : 부모 클래스의 튜플 (상속을 위해 비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="f9b873798f48e29d3714485763a3478bb4a497d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;name&lt;/code&gt;&lt;/strong&gt;: name of the class</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;name&lt;/code&gt; &lt;/strong&gt; : 수업 이름</target>
        </trans-unit>
        <trans-unit id="f7b324be8699a5976c969c726c75d9164d86dcb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that the magic behaviour that &lt;code&gt;Initialised&lt;/code&gt; gains by having the metaclass &lt;code&gt;init_attributes&lt;/code&gt; is not passed onto a subclass of &lt;code&gt;Initialised&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;메타 클래스 &lt;code&gt;init_attributes&lt;/code&gt; 를 가짐으로써 &lt;code&gt;Initialised&lt;/code&gt; 얻는 마법의 행동은 Initialized 의 서브 클래스로 전달되지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ac292049c7ca4650474b47279520a7d5fdba79f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;:  This example is simple enough it could have also been accomplished with a class decorator, but presumably an actual metaclass would be doing much more.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예제는 클래스 데코레이터로도 달성 할 수있을만큼 간단하지만 실제 메타 클래스는 훨씬 더 많은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="18064ffdb8c53a2819134a580d83cb2c5c9bab27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 3 update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;파이썬 3 업데이트&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fd0a25468fd58988cf36428bbcb7968431bd58e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;type()&lt;/code&gt; of a class is its &lt;em&gt;metaclass&lt;/em&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;클래스의 &lt;code&gt;type()&lt;/code&gt; 은 &lt;em&gt;metaclass&lt;/em&gt; 입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c766e32141cfa3130f81de60585eea6ff38f65d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This object (the class) is itself capable of creating objects (the instances),
and this is why it's a class&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;이 객체 (클래스) 자체는 객체 (인스턴스)를 만들 수 있으며 이것이 클래스 인 이유&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c248c325fb87b5d5270a24375d32cd2c9f65122" translate="yes" xml:space="preserve">
          <source>A bare-bones, do-nothing-extra metaclass would like:</source>
          <target state="translated">베어 본, 할 일 없음 엑스트라 메타 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92b4c38772f64c8e05f839618ee864357a996cbf" translate="yes" xml:space="preserve">
          <source>A class is to an instance as a metaclass is to a class.</source>
          <target state="translated">메타 클래스가 클래스에 대한 클래스는 인스턴스에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c27db643b5b5e645284c4cc80a9276398d074a2" translate="yes" xml:space="preserve">
          <source>A class, in Python, is an object, and just like any other object, it is an instance of &quot;something&quot;. This &quot;something&quot; is what is termed as a Metaclass. This metaclass is a special type of class that creates other class's objects. Hence, metaclass is responsible for making new classes. This allows the programmer to customize the way classes are generated.</source>
          <target state="translated">파이썬에서 클래스는 객체이며 다른 객체와 마찬가지로 &quot;무언가&quot;의 인스턴스입니다. 이 &quot;무언가&quot;는 메타 클래스라고합니다. 이 메타 클래스는 다른 클래스의 객체를 생성하는 특수한 유형의 클래스입니다. 따라서 메타 클래스는 새로운 클래스를 만드는 역할을합니다. 이를 통해 프로그래머는 클래스 생성 방식을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98368b5bba9571afb40d6d81649f78ad6a167a0f" translate="yes" xml:space="preserve">
          <source>A dictionary having all class methods and class variables</source>
          <target state="translated">모든 클래스 메소드와 클래스 변수가있는 사전</target>
        </trans-unit>
        <trans-unit id="07bad8c7f891539fd063eae960107658c65808db" translate="yes" xml:space="preserve">
          <source>A metaclass is a class that tells how (some) other class should be created.</source>
          <target state="translated">메타 클래스는 다른 클래스를 작성하는 방법을 알려주는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="873c9fcb3efb256f101a6622b416b45f928aa997" translate="yes" xml:space="preserve">
          <source>A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;__new__&lt;/code&gt; methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.</source>
          <target state="translated">메타 클래스는 클래스 팩토리로 가장 일반적으로 사용됩니다. 클래스를 호출하여 객체를 만들면 파이썬은 메타 클래스를 호출하여 새 클래스를 생성합니다 ( 'class'문을 실행할 때). 메타 클래스는 일반적인 &lt;code&gt;__init__&lt;/code&gt; 및 &lt;code&gt;__new__&lt;/code&gt; 메소드와 결합하여 클래스를 만들 때 새 클래스를 일부 레지스트리에 등록하거나 클래스를 완전히 다른 것으로 대체하는 등 '추가 작업'을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3486e865599100d4c2f2690dc8d832dc90595e5c" translate="yes" xml:space="preserve">
          <source>A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.</source>
          <target state="translated">메타 클래스는 클래스의 클래스입니다. 클래스는 클래스의 인스턴스 (예 : 객체)의 동작을 정의하고 메타 클래스는 클래스의 동작 방식을 정의합니다. 클래스는 메타 클래스의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="4ea4880d366e98584d6186c7ff37dd31a7e3a934" translate="yes" xml:space="preserve">
          <source>A sample run of:</source>
          <target state="translated">샘플 런 :</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">간단한 예 :</target>
        </trans-unit>
        <trans-unit id="abaef223fba357f5e679cf230585920e62f69619" translate="yes" xml:space="preserve">
          <source>A simple metaclass can address that problem:</source>
          <target state="translated">간단한 메타 클래스가이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9675ef41670c1a7e08847654b4300f2976b5bd7" translate="yes" xml:space="preserve">
          <source>According to the Python object model, the class is the object, so the class must be an instance of another certain class.
By default, a Python class is instance of the type class. That is, type is metaclass of most of the built-in classes and metaclass of user-defined classes.</source>
          <target state="translated">Python 객체 모델에 따르면 클래스는 객체이므로 클래스는 다른 특정 클래스의 인스턴스 여야합니다. 기본적으로 Python 클래스는 유형 클래스의 인스턴스입니다. 즉, type은 대부분의 내장 클래스의 메타 클래스와 사용자 정의 클래스의 메타 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4adff09b65f995e39fb598615865ea22fe246c14" translate="yes" xml:space="preserve">
          <source>An expected usage: &lt;code&gt;__prepare__&lt;/code&gt; a namespace</source>
          <target state="translated">예상 사용법 : &lt;code&gt;__prepare__&lt;/code&gt; 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="53beca7540dd22467058afe2ce16662999fefed8" translate="yes" xml:space="preserve">
          <source>And it has approximately the correct &lt;code&gt;repr&lt;/code&gt; (which we can no longer eval unless we can find a way to represent our functions.):</source>
          <target state="translated">그리고 그것은 대략 올바른 &lt;code&gt;repr&lt;/code&gt; 을 가지고 있습니다 (우리가 함수를 나타내는 방법을 찾을 수 없다면 더 이상 평가할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="ce4bfa8f5c082d4fff81df807663be51c7c917c2" translate="yes" xml:space="preserve">
          <source>And now let's create an instance of &lt;code&gt;Class_1&lt;/code&gt;</source>
          <target state="translated">이제 &lt;code&gt;Class_1&lt;/code&gt; 의 인스턴스를 만들어 봅시다</target>
        </trans-unit>
        <trans-unit id="5bf68fb2be7839bf9d1dd84adfe71a7440908b18" translate="yes" xml:space="preserve">
          <source>And now we have a record of the order in which these methods (and other class attributes) were created:</source>
          <target state="translated">그리고 이제 우리는이 메소드들과 다른 클래스 속성들이 생성 된 순서에 대한 기록을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4ca06910faa36e6b2502325b8ed3b633d8e2df95" translate="yes" xml:space="preserve">
          <source>And now, an example that actually means something, this will automatically make the variables in the list &quot;attributes&quot; set on the class, and set to None.</source>
          <target state="translated">그리고 이제 실제로 무언가를 의미하는 예제입니다. 이렇게하면 목록의 변수가 클래스에서 &quot;속성&quot;으로 설정되고 없음으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab311e6c0f38e17cbdcfba4ac88667451f90d25" translate="yes" xml:space="preserve">
          <source>And of course, you can inherit from it, so:</source>
          <target state="translated">물론 당신은 그것을 상속받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e4dbbed8155cf6d13a6faec1d3c917549c55be" translate="yes" xml:space="preserve">
          <source>And usage:</source>
          <target state="translated">그리고 사용법 :</target>
        </trans-unit>
        <trans-unit id="0d4a22c47e425bea8ea588e394d41d40ede76cb4" translate="yes" xml:space="preserve">
          <source>And used as a normal class:</source>
          <target state="translated">그리고 일반 클래스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d11b95735f7ea9c7ca4cdd3c0cc7d13b93d2b46f" translate="yes" xml:space="preserve">
          <source>And what can create a class? &lt;code&gt;type&lt;/code&gt;, or anything that subclasses or uses it.</source>
          <target state="translated">그리고 클래스를 만들 수있는 것은 무엇입니까? &lt;code&gt;type&lt;/code&gt; 또는 서브 클래스로 사용하거나 사용하는 모든 것.</target>
        </trans-unit>
        <trans-unit id="649539847a08116b173bc0337d0fca037b42617c" translate="yes" xml:space="preserve">
          <source>And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.</source>
          <target state="translated">그리고 일반적으로 생성 된 클래스 객체에 메소드를 추가하는 것처럼 클래스를 동적으로 생성 한 후에 더 많은 메소드를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="530eddb18915c39bc5dcde4a3a20f4402846be8a" translate="yes" xml:space="preserve">
          <source>And, of course, you can create your own &lt;code&gt;metaclass&lt;/code&gt; to define the behaviour of any class that are created using your class.</source>
          <target state="translated">물론 클래스를 사용하여 만든 클래스의 동작을 정의하기 위해 자체 &lt;code&gt;metaclass&lt;/code&gt; 를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65df52390d32d6445d153fc0a9ee8f28f45c2439" translate="yes" xml:space="preserve">
          <source>Another way of creating a metaclass comprises of 'metaclass' keyword. Define the metaclass as a simple class. In the parameters of inherited class, pass metaclass=metaclass_name</source>
          <target state="translated">메타 클래스를 만드는 또 다른 방법은 '메타 클래스'키워드로 구성됩니다. 메타 클래스를 간단한 클래스로 정의하십시오. 상속 된 클래스의 매개 변수에서 metaclass = metaclass_name을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="f4b130a19c5f693fbbf062ec80d3671ef783f1ea" translate="yes" xml:space="preserve">
          <source>Anything that's a subclass of &lt;code&gt;MyType&lt;/code&gt; then gets a class attribute &lt;code&gt;_order&lt;/code&gt; that records the order in which the classes were defined.</source>
          <target state="translated">그런 다음 &lt;code&gt;MyType&lt;/code&gt; 의 서브 클래스 인 클래스는 클래스가 정의 된 순서를 기록하는 클래스 속성 &lt;code&gt;_order&lt;/code&gt; 를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="39af72b7c646d137c090c578f75c34590856559b" translate="yes" xml:space="preserve">
          <source>As soon as you use the keyword &lt;code&gt;class&lt;/code&gt;, Python executes it and creates
an OBJECT. The instruction</source>
          <target state="translated">키워드 &lt;code&gt;class&lt;/code&gt; 를 사용하자마자 Python은 키워드를 실행하고 OBJECT를 만듭니다. 지시</target>
        </trans-unit>
        <trans-unit id="2bbce40d7b29697d5feb257ab36b2c9ef937448a" translate="yes" xml:space="preserve">
          <source>As you can see, you have to repeat the name of the attribute twice.  This makes typos possible along with irritating bugs.</source>
          <target state="translated">보시다시피, 속성 이름을 두 번 반복해야합니다. 이것은 자극적 인 버그와 함께 오타가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9956578f1491cba6ae62da4a5182369af56ec1ea" translate="yes" xml:space="preserve">
          <source>Automatic change of class (on creation) is required</source>
          <target state="translated">수업 생성시 자동 변경이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a0904b4d0a120872451f6708177857cd4876a29b" translate="yes" xml:space="preserve">
          <source>Be careful here that the &lt;code&gt;__metaclass__&lt;/code&gt; attribute will not be inherited, the metaclass of the parent (&lt;code&gt;Bar.__class__&lt;/code&gt;) will be. If &lt;code&gt;Bar&lt;/code&gt; used a &lt;code&gt;__metaclass__&lt;/code&gt; attribute that created &lt;code&gt;Bar&lt;/code&gt; with &lt;code&gt;type()&lt;/code&gt; (and not &lt;code&gt;type.__new__()&lt;/code&gt;), the subclasses will not inherit that behavior.</source>
          <target state="translated">여기서 &lt;code&gt;__metaclass__&lt;/code&gt; 속성은 상속되지 않으며 부모 ( &lt;code&gt;Bar.__class__&lt;/code&gt; )의 메타 클래스가 상속되지 않도록주의하십시오. &lt;code&gt;Bar&lt;/code&gt; 가 &lt;code&gt;type()&lt;/code&gt; ( &lt;code&gt;type.__new__()&lt;/code&gt; 아닌 )으로 Bar 를 생성 한 &lt;code&gt;__metaclass__&lt;/code&gt; 속성을 사용한 경우 하위 클래스는 해당 동작을 상속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80625100761a15802531450282948dc4d9d74c05" translate="yes" xml:space="preserve">
          <source>Before understanding metaclasses, you need to master classes in Python. And Python has a very peculiar idea of what classes are, borrowed from the Smalltalk language.</source>
          <target state="translated">메타 클래스를 이해하기 전에 파이썬에서 클래스를 마스터해야합니다. 그리고 파이썬은 스몰 토크 언어에서 빌린 클래스가 무엇인지 매우 독창적입니다.</target>
        </trans-unit>
        <trans-unit id="6a2ed346f5d5ae803e927c67a0b729ccdfc1ac42" translate="yes" xml:space="preserve">
          <source>But 98% of the time, you don't need class alteration at all.</source>
          <target state="translated">그러나 시간의 98 %는 수업 변경이 전혀 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="217006127ae3f18c4bd2c902e86bbb02d1e2be15" translate="yes" xml:space="preserve">
          <source>But classes are more than that in Python. Classes are objects too.</source>
          <target state="translated">그러나 클래스는 파이썬보다 더 많습니다. 클래스도 객체입니다.</target>
        </trans-unit>
        <trans-unit id="c6925819c7efe04fd6c3ab39f7eb68854e9cde4a" translate="yes" xml:space="preserve">
          <source>But if you do this:</source>
          <target state="translated">그러나 이렇게하면 :</target>
        </trans-unit>
        <trans-unit id="ef4914127f447e16a1796467ee1b0bb970abd2e5" translate="yes" xml:space="preserve">
          <source>But it's not so dynamic, since you still have to write the whole class yourself.</source>
          <target state="translated">그러나 여전히 전체 수업을 직접 작성해야하기 때문에 그렇게 역동적이지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f48f38ce849fd78c7a275acf29a06ca3a0397d9" translate="yes" xml:space="preserve">
          <source>But still, it's an object, and therefore:</source>
          <target state="translated">그러나 여전히 객체이므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b16fb856b8f2d6a24ccdf8c533162de4f2a2b85" translate="yes" xml:space="preserve">
          <source>But this is not proper OOP. We are calling &lt;code&gt;type&lt;/code&gt; directly and we aren't overriding or calling the parent's &lt;code&gt;__new__&lt;/code&gt;. Let's do that instead:</source>
          <target state="translated">그러나 이것은 적절한 OOP가 아닙니다. 우리는 &lt;code&gt;type&lt;/code&gt; 직접 호출하고 부모의 &lt;code&gt;__new__&lt;/code&gt; 를 재정의하거나 호출하지 않습니다. 대신 해보자 :</target>
        </trans-unit>
        <trans-unit id="bca74e7aa7842dd7785f6fa3e79fd35320fecfb0" translate="yes" xml:space="preserve">
          <source>But we learned that Python classes are objects.</source>
          <target state="translated">그러나 파이썬 클래스는 객체라는 것을 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="9da0aa54f4f4de88a9f5b6ed8d8101a2c5efd27f" translate="yes" xml:space="preserve">
          <source>By API developers</source>
          <target state="translated">API 개발자</target>
        </trans-unit>
        <trans-unit id="b4df2ba03eab94130e4fd06a9c5054fa64ad06cd" translate="yes" xml:space="preserve">
          <source>Can be translated to:</source>
          <target state="translated">다음과 같이 번역 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="334466b784281739a3c38583b4c063fdc0aba559" translate="yes" xml:space="preserve">
          <source>Careful, it's tricky.</source>
          <target state="translated">조심하세요. 까다 롭습니다.</target>
        </trans-unit>
        <trans-unit id="23e735f2e42f0ee01fd065b66b276180dd776b09" translate="yes" xml:space="preserve">
          <source>Class Name</source>
          <target state="translated">수업 명</target>
        </trans-unit>
        <trans-unit id="67581e4d912d7924cb46e54e6204e5fcc51399f9" translate="yes" xml:space="preserve">
          <source>Classes as objects</source>
          <target state="translated">객체로서의 클래스</target>
        </trans-unit>
        <trans-unit id="2a6d4b43aad00a6ba23618dd38abe34e6ccdd450" translate="yes" xml:space="preserve">
          <source>Creating a new model</source>
          <target state="translated">새 모델 만들기</target>
        </trans-unit>
        <trans-unit id="9d277645538f63f2b9666091e215ce0c2c94b67c" translate="yes" xml:space="preserve">
          <source>Creating classes dynamically</source>
          <target state="translated">동적으로 클래스 만들기</target>
        </trans-unit>
        <trans-unit id="a5890931814483d070ece2ba611db02e74fa66fb" translate="yes" xml:space="preserve">
          <source>Custom metaclasses</source>
          <target state="translated">커스텀 메타 클래스</target>
        </trans-unit>
        <trans-unit id="3583495fe771aa17938b325299e9568902990630" translate="yes" xml:space="preserve">
          <source>Django makes something complex look simple by exposing a simple API
and using metaclasses, recreating code from this API to do the real job
behind the scenes.</source>
          <target state="translated">Django는 간단한 API를 노출하고 메타 클래스를 사용하여이 API에서 코드를 다시 작성하여 배후에서 실제 작업을 수행함으로써 복잡한 것을 단순하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0c2efb2ec65dc0aa53f18cfb1abd5f87fcb64df6" translate="yes" xml:space="preserve">
          <source>Eventually you'll want to add methods to your class. Just define a function
with the proper signature and assign it as an attribute.</source>
          <target state="translated">결국 클래스에 메소드를 추가하려고합니다. 적절한 서명으로 함수를 정의하고 속성으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="07cbe8c7c80e4f1f64a5bbbd7a413d143a41a369" translate="yes" xml:space="preserve">
          <source>Everything is an object in Python, and they are all either instances of classes
or instances of metaclasses.</source>
          <target state="translated">모든 것은 파이썬의 객체이며 모두 클래스의 인스턴스이거나 메타 클래스의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="8fd816dd026cb3639455418c4ec1f8fa0fe97cd2" translate="yes" xml:space="preserve">
          <source>Everything, and I mean everything, is an object in Python. That includes ints,
strings, functions and classes. All of them are objects. And all of them have
been created from a class:</source>
          <target state="translated">모든 것은 모든 것을 의미합니다. 파이썬의 객체입니다. 여기에는 정수, 문자열, 함수 및 클래스가 포함됩니다. 그들 모두는 대상입니다. 그리고 그들 모두는 수업에서 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="673604a3dfb5c3ee8e65923cb90776673fb75935" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 제외.</target>
        </trans-unit>
        <trans-unit id="ff75c36a00faaeb29de73a493ffe4e766d3c9c95" translate="yes" xml:space="preserve">
          <source>First, you can create a class in a function using &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">먼저 class를 사용하여 함수에서 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b279b3945b4d05b8b08bfb5dd600595061650654" translate="yes" xml:space="preserve">
          <source>First, you know that classes are objects that can create instances.</source>
          <target state="translated">먼저, 클래스는 인스턴스를 생성 할 수있는 객체라는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0afa5be4efcb2364e68a5fbe4c217e7cc8946f64" translate="yes" xml:space="preserve">
          <source>For doing that, your default &lt;code&gt;metaclass&lt;/code&gt; type class must be inherited as this is the main &lt;code&gt;metaclass&lt;/code&gt;:</source>
          <target state="translated">이를 위해서는 기본 &lt;code&gt;metaclass&lt;/code&gt; 유형 클래스가 기본 메타 클래스이므로 상속되어야합니다.</target>
        </trans-unit>
        <trans-unit id="64d1e55feb37865331973d2697ad8c261c0e1af4" translate="yes" xml:space="preserve">
          <source>For example, if you look at &lt;a href=&quot;http://docs.djangoproject.com/en/dev/topics/db/models/&quot;&gt;Django models&lt;/a&gt;, their definition looks a bit confusing. It looks as if you are only defining class properties:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;http://docs.djangoproject.com/en/dev/topics/db/models/&quot;&gt;Django models&lt;/a&gt; 을 보면 그 정의가 약간 혼란스러워 보입니다. 클래스 속성 만 정의하는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="fe22872a0b690652860e20740774999a464ef779" translate="yes" xml:space="preserve">
          <source>From the above it stems that the metaclass' &lt;code&gt;__call__()&lt;/code&gt; is also given the opportunity to decide whether or not a call to &lt;code&gt;Class_1.__new__()&lt;/code&gt; or &lt;code&gt;Class_1.__init__()&lt;/code&gt; will eventually be made. Over the course of its execution it could actually return an object that hasn't been touched by either of these methods. Take for example this approach to the singleton pattern:</source>
          <target state="translated">위에서 메타 클래스의 &lt;code&gt;__call__()&lt;/code&gt; 은 &lt;code&gt;Class_1.__new__()&lt;/code&gt; 또는 &lt;code&gt;Class_1.__init__()&lt;/code&gt; 대한 호출 여부를 결정할 수있는 기회가 주어집니다. 실행 과정에서 실제로 이러한 방법 중 하나에 의해 만지지 않은 객체를 반환 할 수 있습니다. 싱글 톤 패턴에 대한이 접근 방식을 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="019ad28a21f071a1a1c801c23bffdedde5c57127" translate="yes" xml:space="preserve">
          <source>Here is an even more concrete example, showing how you can subclass 'type' to make a metaclass that performs an action when the class is created. This is quite tricky:</source>
          <target state="translated">다음은 클래스를 만들 때 작업을 수행하는 메타 클래스를 만들기 위해 'type'을 서브 클래 싱하는 방법을 보여주는보다 구체적인 예입니다. 이것은 매우 까다 롭습니다.</target>
        </trans-unit>
        <trans-unit id="89a9dab91d6a0e821bd0d8857c7afd11ec41324d" translate="yes" xml:space="preserve">
          <source>Here is where the secret starts. Look for where name, bases and the dict come from in this example class definition.</source>
          <target state="translated">여기 비밀이 시작됩니다. 이 예제 클래스 정의에서 이름,베이스 및 dict의 출처를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="933820812619c6ea7008cbcf3a5bef8f52f428f5" translate="yes" xml:space="preserve">
          <source>Here's an aggregated example of the bits and pieces:</source>
          <target state="translated">다음은 비트와 조각의 집계 된 예입니다.</target>
        </trans-unit>
        <trans-unit id="c7172cb8e50347e53ec2a1c70cf3f132135b13bb" translate="yes" xml:space="preserve">
          <source>Here's another example of what it can be used for:</source>
          <target state="translated">사용 가능한 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b92f66963c22e5d12229c7c1ff474ff5ca10c558" translate="yes" xml:space="preserve">
          <source>Here's the default &lt;code&gt;__repr__&lt;/code&gt; of classes:</source>
          <target state="translated">클래스의 기본 &lt;code&gt;__repr__&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da679ef3b897db5427c2dd4128c089961c066bc2" translate="yes" xml:space="preserve">
          <source>However, at runtime the Person objects are filled with all sorts of useful methods. See the &lt;a href=&quot;http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py&quot;&gt;source&lt;/a&gt; for some amazing metaclassery.</source>
          <target state="translated">그러나 런타임시 Person 객체는 모든 종류의 유용한 메소드로 채워집니다. 놀라운 메타 클래스에 대한 &lt;a href=&quot;http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py&quot;&gt;소스&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3687f11b0c4210b7d9c0b35a3e13741dc07a26f7" translate="yes" xml:space="preserve">
          <source>However, metaclasses actually define the &lt;em&gt;type&lt;/em&gt; of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. &lt;code&gt;type.__subclasses__()&lt;/code&gt; is an example of a method on the &lt;code&gt;type&lt;/code&gt; metaclass. You can also define the normal 'magic' methods, like &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__iter__&lt;/code&gt; and &lt;code&gt;__getattr__&lt;/code&gt;, to implement or change how the class behaves.</source>
          <target state="translated">그러나 메타 클래스는 실제로 팩토리가 아니라 클래스의 &lt;em&gt;유형&lt;/em&gt; 을 정의하므로 더 많은 작업을 수행 할 수 있습니다. 예를 들어 메타 클래스에 일반 메소드를 정의 할 수 있습니다. 이러한 메타 클래스 메소드는 인스턴스없이 클래스에서 호출 될 수 있다는 점에서 클래스 메소드와 비슷하지만 클래스의 인스턴스에서 호출 할 수 없다는 점에서 클래스 메소드와는 다릅니다. &lt;code&gt;type.__subclasses__()&lt;/code&gt; 는 &lt;code&gt;type&lt;/code&gt; 메타 클래스에 대한 메소드의 예입니다. &lt;code&gt;__add__&lt;/code&gt; , &lt;code&gt;__iter__&lt;/code&gt; 및 &lt;code&gt;__getattr__&lt;/code&gt; 과 같은 일반적인 'magic'메서드를 정의하여 클래스의 동작 방식을 구현하거나 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fa00b7305761f3d48d74e2fcaa87d88b46b8653" translate="yes" xml:space="preserve">
          <source>I think the ONLamp introduction to metaclass programming is well written and gives a really good introduction to the topic despite being several years old already.</source>
          <target state="translated">메타 클래스 프로그래밍에 대한 ONLamp 소개는 잘 작성되어 있으며 이미 몇 년이 지났음에도 불구하고 주제에 대한 좋은 소개를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5de71cb6474da6bbfd1892d86a39743c6e1f7a0d" translate="yes" xml:space="preserve">
          <source>I've never written one myself, but I think one of the nicest uses of metaclasses can be seen in the &lt;a href=&quot;http://www.djangoproject.com/&quot;&gt;Django framework&lt;/a&gt;. The model classes use a metaclass approach to enable a declarative style of writing new models or form classes. While the metaclass is creating the class, all members get the possibility to customize the class itself.</source>
          <target state="translated">필자가 직접 작성한 적은 없지만 &lt;a href=&quot;http://www.djangoproject.com/&quot;&gt;장고 프레임 워크&lt;/a&gt; 에서 메타 클래스를 가장 잘 사용하는 방법 중 하나를 볼 수 있다고 생각합니다. 모델 클래스는 메타 클래스 접근 방식을 사용하여 선언적인 스타일의 새 모델 또는 양식 클래스를 작성할 수 있습니다. 메타 클래스가 클래스를 작성하는 동안 모든 멤버는 클래스 자체를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4a30d2f2ca2899fa19429f58792d2d3e210fba9" translate="yes" xml:space="preserve">
          <source>If Python can't find &lt;code&gt;__metaclass__&lt;/code&gt;, it will look for a &lt;code&gt;__metaclass__&lt;/code&gt; at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes).</source>
          <target state="translated">파이썬이 &lt;code&gt;__metaclass__&lt;/code&gt; 를 찾을 수 없다면, MODULE 레벨에서 &lt;code&gt;__metaclass__&lt;/code&gt; 를 찾고 동일한 작업을 시도합니다 (그러나 기본적으로 구식 클래스를 상속받지 않는 클래스에 대해서만).</target>
        </trans-unit>
        <trans-unit id="b2c247f997e1856448d121b399db1ce401dfe052" translate="yes" xml:space="preserve">
          <source>If yes, create in memory a class object (I said a class object, stay with me here), with the name &lt;code&gt;Foo&lt;/code&gt; by using what is in &lt;code&gt;__metaclass__&lt;/code&gt;.</source>
          <target state="translated">그렇다면 &lt;code&gt;__metaclass__&lt;/code&gt; 에 있는 것을 사용하여 &lt;code&gt;Foo&lt;/code&gt; 라는 이름으로 클래스 객체 (클래스 객체를 말했고 여기에 나와 함께 있음)를 메모리에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="1c4ed3e469d021631b88778db056f898cbd3075a" translate="yes" xml:space="preserve">
          <source>If you do so, Python will use the metaclass to create the class &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">그렇게하면 파이썬은 메타 클래스를 사용하여 &lt;code&gt;Foo&lt;/code&gt; 클래스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d569392d6709098664ec3f652636842d8ae2fd08" translate="yes" xml:space="preserve">
          <source>If you've done Python programming for more than a few months you'll eventually stumble upon code that looks like this:</source>
          <target state="translated">몇 달 이상 파이썬 프로그래밍을 해본다면 결국 다음과 같은 코드를 발견하게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="8ffaab56641a084b45859b1b16c94f6d85871567" translate="yes" xml:space="preserve">
          <source>If, for example, we want to know in what order a class's methods are created in, we could provide an ordered dict as the namespace of the class. We would do this with &lt;code&gt;__prepare__&lt;/code&gt; which &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace&quot;&gt;returns the namespace dict for the class if it is implemented in Python 3&lt;/a&gt;:</source>
          <target state="translated">예를 들어, 클래스의 메소드가 어떤 순서로 작성되는지 알고 싶다면, 클래스의 네임 스페이스로서 순서화 된 dict를 제공 할 수 있습니다. &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace&quot;&gt;파이썬 3에서 구현 된 경우 클래스의 네임 스페이스 dict를 반환하는&lt;/a&gt; &lt;code&gt;__prepare__&lt;/code&gt; 로이 를 수행 합니다 .</target>
        </trans-unit>
        <trans-unit id="0ddfbe7f84c69375a34cda89908ad9181be61fdd" translate="yes" xml:space="preserve">
          <source>Imagine a stupid example, where you decide that all classes in your module
should have their attributes written in uppercase. There are several ways to
do this, but one way is to set &lt;code&gt;__metaclass__&lt;/code&gt; at the module level.</source>
          <target state="translated">모듈의 모든 클래스에 특성이 대문자로 작성되어야한다고 결정하는 어리석은 예를 상상해보십시오. 여러 가지 방법이 있지만 한 가지 방법은 모듈 수준에서 &lt;code&gt;__metaclass__&lt;/code&gt; 를 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="91a6aa8c8b6a75378372d8ea48354d684c37eb6b" translate="yes" xml:space="preserve">
          <source>In Python 2, you can add a &lt;code&gt;__metaclass__&lt;/code&gt; attribute when you write a class (see next section for the Python 3 syntax):</source>
          <target state="translated">Python 2에서는 클래스를 작성할 때 &lt;code&gt;__metaclass__&lt;/code&gt; 속성을 추가 할 수 있습니다 (Python 3 구문은 다음 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="7e651e9d51572a5346d5e0e8610271f23aa0d208" translate="yes" xml:space="preserve">
          <source>In Python, what are metaclasses and what do we use them for?</source>
          <target state="translated">파이썬에서 메타 클래스 란 무엇이며 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="4650ac989c9d3329e40be1c6ab845b25d2070a47" translate="yes" xml:space="preserve">
          <source>In addition to the published answers I can say that a &lt;code&gt;metaclass&lt;/code&gt; defines the behaviour for a class. So, you can explicitly set your metaclass. Whenever Python gets a keyword &lt;code&gt;class&lt;/code&gt; then it starts searching for the &lt;code&gt;metaclass&lt;/code&gt;. If it's not found &amp;ndash; the default metaclass type is used to create the class's object. Using the &lt;code&gt;__metaclass__&lt;/code&gt; attribute, you can set &lt;code&gt;metaclass&lt;/code&gt; of your class:</source>
          <target state="translated">게시 된 답변 외에도 &lt;code&gt;metaclass&lt;/code&gt; 가 클래스 의 동작을 정의한다고 말할 수 있습니다. 따라서 메타 클래스를 명시 적으로 설정할 수 있습니다. 파이썬이 키워드 &lt;code&gt;class&lt;/code&gt; 를 얻을 때마다 &lt;code&gt;metaclass&lt;/code&gt; 검색하기 시작합니다. 찾을 수없는 경우 기본 메타 클래스 유형을 사용하여 클래스의 객체를 만듭니다. &lt;code&gt;__metaclass__&lt;/code&gt; 속성을 사용하여 &lt;code&gt;metaclass&lt;/code&gt; 의 메타 클래스 를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c35d9935b1a444e907c91e37c19879d0759a37ba" translate="yes" xml:space="preserve">
          <source>In addition to using type() to create classes dynamically, you can control creation behavior of class and use metaclass.</source>
          <target state="translated">type ()을 사용하여 클래스를 동적으로 생성하는 것 외에도 클래스의 생성 동작을 제어하고 메타 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a7677010e3a9723dd238a2332a0b15302776bce" translate="yes" xml:space="preserve">
          <source>In most languages, classes are just pieces of code that describe how to produce an object. That's kinda true in Python too:</source>
          <target state="translated">대부분의 언어에서 클래스는 객체를 생성하는 방법을 설명하는 코드 조각 일뿐입니다. 파이썬에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="fa72180e3995db72ed5f698c8ee07149c8c3a22b" translate="yes" xml:space="preserve">
          <source>In object-oriented programming, a metaclass is a class whose instances are classes. Just as an ordinary class defines the behavior of certain objects, a metaclass defines the behavior of certain class and their instances
The term metaclass simply means something used to create classes. In other words, it is the class of a class. The metaclass is used to create the class so like the object being an instance of a class, a class is an instance of a metaclass. In python classes are also considered objects.</source>
          <target state="translated">객체 지향 프로그래밍에서 메타 클래스는 인스턴스가 클래스 인 클래스입니다. 일반 클래스가 특정 객체의 동작을 정의하는 것처럼 메타 클래스는 특정 클래스 및 해당 인스턴스의 동작을 정의합니다. 메타 클래스라는 용어는 단순히 클래스를 만드는 데 사용되는 것을 의미합니다. 다시 말해, 그것은 클래스의 클래스입니다. 메타 클래스는 클래스의 인스턴스가되는 객체처럼 클래스를 만드는 데 사용되며 클래스는 메타 클래스의 인스턴스입니다. 파이썬에서는 클래스도 객체로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2e61694f68b17195f1c41dbc03080f71c6ec3509" translate="yes" xml:space="preserve">
          <source>In real code, we can pass the default metaclass, &lt;code&gt;type&lt;/code&gt;, everything we need to instantiate a class and we get a class:</source>
          <target state="translated">실제 코드에서는 기본 메타 클래스 인 &lt;code&gt;type&lt;/code&gt; 을 전달하여 클래스를 인스턴스화하고 클래스를 얻는 데 필요한 모든 것을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cde1b05c392829cf0748f367e1a5f3cc79ef8e7" translate="yes" xml:space="preserve">
          <source>In short: A class is a blueprint for the creation of an instance, a metaclass is a blueprint for the creation of a class. It can be easily seen that in Python classes need to be first-class objects too to enable this behavior.</source>
          <target state="translated">한마디로 : 클래스는 인스턴스 생성을위한 청사진이고, 메타 클래스는 클래스 생성을위한 청사진입니다. 파이썬 클래스에서는이 동작을 가능하게하기 위해 일류 객체 여야한다는 것을 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dcf456ed380c367ea7337a047070feeb2404ac6" translate="yes" xml:space="preserve">
          <source>Indeed, metaclasses are especially useful to do black magic, and therefore
complicated stuff. But by themselves, they are simple:</source>
          <target state="translated">실제로 메타 클래스는 블랙 매직을 수행하는 데 특히 유용하므로 복잡한 작업을 수행 할 수 있습니다. 그러나 그 자체로는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="e6acf61863b31d67d149b4e6ca40eee6b1199fa9" translate="yes" xml:space="preserve">
          <source>Is there a &lt;code&gt;__metaclass__&lt;/code&gt; attribute in &lt;code&gt;Foo&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 에 &lt;code&gt;__metaclass__&lt;/code&gt; 속성이 있습니까?</target>
        </trans-unit>
        <trans-unit id="8b238ceb9e5599e813e4358cf7862918d33b97b1" translate="yes" xml:space="preserve">
          <source>It is the same as functionally calling &lt;code&gt;type&lt;/code&gt; with the appropriate arguments and assigning the result to a variable of that name:</source>
          <target state="translated">적절한 인수를 사용하여 &lt;code&gt;type&lt;/code&gt; 을 기능적으로 호출하고 결과를 해당 이름의 변수에 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f552d4e543041b1701247e77678f01050c07d0e" translate="yes" xml:space="preserve">
          <source>It translates to this in the metaclass to use it:</source>
          <target state="translated">그것을 사용하기 위해 메타 클래스에서 이것을 번역합니다.</target>
        </trans-unit>
        <trans-unit id="c7ba3c56dd302201c8d63fd76926944ea19006b4" translate="yes" xml:space="preserve">
          <source>It won't return an &lt;code&gt;IntegerField&lt;/code&gt; object. It will return an &lt;code&gt;int&lt;/code&gt;, and can even take it directly from the database.</source>
          <target state="translated">&lt;code&gt;IntegerField&lt;/code&gt; 객체를 반환하지 않습니다. &lt;code&gt;int&lt;/code&gt; 를 반환하고 데이터베이스에서 직접 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8d805048c69fa736de925d3367248b04c361716" translate="yes" xml:space="preserve">
          <source>It'll produce the output like this:</source>
          <target state="translated">다음과 같이 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7cf1c9cf775a5387c4ff94bd47121db2b5c988dd" translate="yes" xml:space="preserve">
          <source>It's because the function &lt;code&gt;type&lt;/code&gt; is in fact a metaclass. &lt;code&gt;type&lt;/code&gt; is the
metaclass Python uses to create all classes behind the scenes.</source>
          <target state="translated">함수 &lt;code&gt;type&lt;/code&gt; 이 실제로 메타 클래스이기 때문입니다. &lt;code&gt;type&lt;/code&gt; 은 파이썬이 배후에서 모든 클래스를 생성하기 위해 사용하는 메타 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b762e9c56bf18ad7968cf2abfa72dfb4cd610a39" translate="yes" xml:space="preserve">
          <source>Just as we can use class definitions to change how custom object instances behave, we can use a metaclass class definition to change the way a class object behaves.</source>
          <target state="translated">클래스 정의를 사용하여 사용자 정의 객체 인스턴스의 동작 방식을 변경할 수있는 것처럼 메타 클래스 클래스 정의를 사용하여 클래스 객체의 동작 방식을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12861900e6ee5fc644f17e214205bf98f2b552b1" translate="yes" xml:space="preserve">
          <source>Let's check:</source>
          <target state="translated">점검 해보자:</target>
        </trans-unit>
        <trans-unit id="e24b773897b7eab9e5ea3419aecc80a071b54a96" translate="yes" xml:space="preserve">
          <source>Let's observe what happens when repeatedly trying to create an object of type &lt;code&gt;Class_2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Class_2&lt;/code&gt; 유형의 객체를 반복적으로 만들려고 할 때 어떤 일이 발생하는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0d3e22e4d5a330681408b9b810a86a368c8150f7" translate="yes" xml:space="preserve">
          <source>Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean:</source>
          <target state="translated">위의 내용을 다시 작성하지만 더 짧고 현실적인 변수 이름을 사용하여 의미를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bae90bb62607735e9b7e3a157dc8431c62f56161" translate="yes" xml:space="preserve">
          <source>Let's study the method call chain from specifically the perspective of creating an instance of a class.</source>
          <target state="translated">클래스의 인스턴스를 만드는 관점에서 메서드 호출 체인을 연구 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="045e68d2ed13507db1ee3f048ec03ec22ab6a6b4" translate="yes" xml:space="preserve">
          <source>Lets define a metaclass that will demonstrate how '&lt;strong&gt;class:&lt;/strong&gt;' calls it.</source>
          <target state="translated">' &lt;strong&gt;class :&lt;/strong&gt; '가 어떻게 그것을 호출하는지 보여줄 메타 클래스를 정의하자.</target>
        </trans-unit>
        <trans-unit id="320371557536a1d1e98f35433ae20c51e9eed7fc" translate="yes" xml:space="preserve">
          <source>Likewise, when we define a class explicitly with the default metaclass, &lt;code&gt;type&lt;/code&gt;, we instantiate it:</source>
          <target state="translated">마찬가지로 기본 메타 클래스 &lt;code&gt;type&lt;/code&gt; 을 사용하여 클래스를 명시 적으로 정의하면이를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="dd4270596259e170c6cba8ca00280d127d29899d" translate="yes" xml:space="preserve">
          <source>Luckily, &lt;code&gt;__metaclass__&lt;/code&gt; can actually be any callable, it doesn't need to be a
formal class (I know, something with 'class' in its name doesn't need to be
a class, go figure... but it's helpful).</source>
          <target state="translated">운 좋게도 &lt;code&gt;__metaclass__&lt;/code&gt; 는 실제로 호출 가능할 수 있으며 공식적인 클래스 일 필요는 없습니다 (이름에 'class'가있는 클래스는 클래스 일 필요는 없습니다. 그러나 도움이됩니다).</target>
        </trans-unit>
        <trans-unit id="a84965b59c86adeaf5175c77b1367ae45a51beca" translate="yes" xml:space="preserve">
          <source>Magic will take effect when we passed keyword arguments in metaclass, it indicates the Python interpreter to create the CustomList through ListMetaclass. &lt;strong&gt;new&lt;/strong&gt; (), at this point, we can modify the class definition, for example, and add a new method and then return the revised definition.</source>
          <target state="translated">매직은 메타 클래스에서 키워드 인수를 전달할 때 적용되며, 파이썬 인터프리터가 ListMetaclass를 통해 CustomList를 작성하도록 지시합니다. &lt;strong&gt;new&lt;/strong&gt; (),이 시점에서 클래스 정의를 수정하고 새 메소드를 추가 한 후 수정 된 정의를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe9adb504d86047cca71de452afe1639b04cca8" translate="yes" xml:space="preserve">
          <source>Metaclass can be specifically used in the following situations :-</source>
          <target state="translated">메타 클래스는 다음과 같은 상황에서 구체적으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3af05144e3743c95c5ae229f63e24413fd772f08" translate="yes" xml:space="preserve">
          <source>Metaclass is a kind of class which defines how the class will behave like or we can say that A class is itself an instance of a metaclass.</source>
          <target state="translated">메타 클래스는 클래스의 작동 방식을 정의하는 클래스의 일종입니다. 또는 클래스 자체가 메타 클래스의 인스턴스라고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c7336a776a31b11543813110e2a48bdc565d93" translate="yes" xml:space="preserve">
          <source>Metaclasses are deeper magic that
  99% of users should never worry about.
  If you wonder whether you need them,
  you don't (the people who actually
  need them know with certainty that
  they need them, and don't need an
  explanation about why).</source>
          <target state="translated">메타 클래스는 99 %의 사용자가 걱정할 필요가없는 더 깊은 마법입니다. 필요한지 궁금하다면 필요하지 않습니다 (실제로 필요한 사람들은 필요하다는 것을 확실하게 알고 있으며 이유에 대한 설명이 필요하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="fcb03720145595ceaed2564444518a68539698a8" translate="yes" xml:space="preserve">
          <source>Metaclasses are the 'stuff' that creates classes.</source>
          <target state="translated">메타 클래스는 클래스를 만드는 '재료'입니다.</target>
        </trans-unit>
        <trans-unit id="347480dda5a48202f0a0a3b1b3be6014055c70c8" translate="yes" xml:space="preserve">
          <source>Metaclasses are the secret sauce that make 'class' work. The default metaclass for a new style object is called 'type'.</source>
          <target state="translated">메타 클래스는 '클래스'가 작동하는 비밀 소스입니다. 새로운 스타일 객체의 기본 메타 클래스는 'type'입니다.</target>
        </trans-unit>
        <trans-unit id="b0d32362c1bfdecea091b0735835a3190f185e2b" translate="yes" xml:space="preserve">
          <source>Metaclasses in Python 3</source>
          <target state="translated">파이썬 3의 메타 클래스</target>
        </trans-unit>
        <trans-unit id="97071630fbed73be9de0cacbd51a241cef7bdfa8" translate="yes" xml:space="preserve">
          <source>Metaclasses take 3 args. '&lt;strong&gt;name&lt;/strong&gt;', '&lt;strong&gt;bases&lt;/strong&gt;' and '&lt;strong&gt;dict&lt;/strong&gt;'</source>
          <target state="translated">메타 클래스는 3 개의 인수를 취합니다. ' &lt;strong&gt;name&lt;/strong&gt; ', ' &lt;strong&gt;bases&lt;/strong&gt; '및 ' &lt;strong&gt;dict&lt;/strong&gt; '</target>
        </trans-unit>
        <trans-unit id="8797caa69e6420c0f3bfebfa19ca4cdf0b6929f4" translate="yes" xml:space="preserve">
          <source>Nevertheless, it is usually encouraged for users to avoid using metaclasses unless absolutely necessary.</source>
          <target state="translated">그럼에도 불구하고 일반적으로 사용자가 절대적으로 필요한 경우가 아니면 메타 클래스를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4ad4b27bbadcdc0adcdbc297fc1201cb31705fca" translate="yes" xml:space="preserve">
          <source>Note that in python 3.6 a new dunder method &lt;code&gt;__init_subclass__(cls, **kwargs)&lt;/code&gt; was introduced to replace a lot of common use cases for metaclasses. Is is called when a subclass of the defining class is created. See &lt;a href=&quot;https://docs.python.org/3.6/reference/datamodel.html&quot;&gt;python docs&lt;/a&gt;.</source>
          <target state="translated">파이썬 3.6에서는 메타 클래스에 대한 많은 일반적인 사용 사례를 대체하기 위해 새로운 던전 방법 &lt;code&gt;__init_subclass__(cls, **kwargs)&lt;/code&gt; 가 도입되었습니다. Is는 정의 클래스의 서브 클래스가 작성 될 때 호출됩니다. &lt;a href=&quot;https://docs.python.org/3.6/reference/datamodel.html&quot;&gt;파이썬 문서를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06fe24108d0ae7b5ac24fe3074dd0a7cf192f87c" translate="yes" xml:space="preserve">
          <source>Note, some things automatically get added to the &lt;code&gt;__dict__&lt;/code&gt;, i.e., the namespace:</source>
          <target state="translated">&lt;code&gt;__dict__&lt;/code&gt; 에 자동으로 추가되는 것, 즉 네임 스페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe5b2192b1a3dda71ee761442e7acc561c0dae83" translate="yes" xml:space="preserve">
          <source>Note, this example was adapted from the &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;documentation&lt;/a&gt; - the new &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/enum.py&quot;&gt;enum in the standard library&lt;/a&gt; does this.</source>
          <target state="translated">이 예제는 &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;문서&lt;/a&gt; 에서 수정되었습니다- &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/enum.py&quot;&gt;표준 라이브러리&lt;/a&gt; 의 새 열거 형 이이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2e4afa936b2a2c77839b1cc61ded016a8418009e" translate="yes" xml:space="preserve">
          <source>Notice that the class was not instantiated at any time; the simple act of creating the class triggered execution of the &lt;code&gt;metaclass&lt;/code&gt;.</source>
          <target state="translated">클래스는 언제라도 인스턴스화되지 않았습니다. 클래스를 작성하는 간단한 행동으로 &lt;code&gt;metaclass&lt;/code&gt; 실행이 트리거되었습니다.</target>
        </trans-unit>
        <trans-unit id="e8092d965c6169ed84145f59ba7bbf9f5d4c853f" translate="yes" xml:space="preserve">
          <source>Now the big question is, what can you put in &lt;code&gt;__metaclass__&lt;/code&gt; ?</source>
          <target state="translated">이제 큰 문제는 &lt;code&gt;__metaclass__&lt;/code&gt; 에 무엇을 넣을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d2dcde526fc4daaef6d655606e4496048204c05b" translate="yes" xml:space="preserve">
          <source>Now the big question. Why would you use some obscure error prone feature?</source>
          <target state="translated">이제 큰 질문입니다. 왜 모호한 오류가 발생하기 쉬운 기능을 사용 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="1312ae6700f74e01674fc6c089a10ffa91f468b1" translate="yes" xml:space="preserve">
          <source>Now you wonder why the heck is it written in lowercase, and not &lt;code&gt;Type&lt;/code&gt;?</source>
          <target state="translated">이제 도대체 왜 &lt;code&gt;Type&lt;/code&gt; 이 아닌 소문자로 쓰여 있는지 궁금합니다.</target>
        </trans-unit>
        <trans-unit id="9e1ac6d44c14c13e117e5f981206e38957129c52" translate="yes" xml:space="preserve">
          <source>Now, let's do exactly the same, but using a real class for a metaclass:</source>
          <target state="translated">이제 똑같이했지만 메타 클래스에 실제 클래스를 사용하자 :</target>
        </trans-unit>
        <trans-unit id="390ebafcf350ad02efb790f33b6aaead595c1109" translate="yes" xml:space="preserve">
          <source>Now, what is the &lt;code&gt;__class__&lt;/code&gt; of any &lt;code&gt;__class__&lt;/code&gt; ?</source>
          <target state="translated">이제 &lt;code&gt;__class__&lt;/code&gt; 의 &lt;code&gt;__class__&lt;/code&gt; 는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d1ac610b74a4f310bfc7d2292f70767803b25d13" translate="yes" xml:space="preserve">
          <source>Observe that the code above doesn't actually do anything more than logging the tasks. Each method delegates the actual work to its parent's implementation, thus keeping the default behavior. Since &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;Meta_1&lt;/code&gt;'s parent class (&lt;code&gt;type&lt;/code&gt; being the default parent metaclass) and considering the ordering sequence of the output above, we now have a clue as to what would be the pseudo implementation of &lt;code&gt;type.__call__()&lt;/code&gt;:</source>
          <target state="translated">위의 코드는 실제로 작업을 기록하는 것 이상을 수행하지 않습니다. 각 메소드는 실제 작업을 상위 구현에 위임하므로 기본 동작을 유지합니다. &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;Meta_1&lt;/code&gt; 의 부모 클래스 ( &lt;code&gt;type&lt;/code&gt; 은 기본 부모 메타 클래스 임)이고 위의 출력 순서 순서를 고려하므로 &lt;code&gt;type.__call__()&lt;/code&gt; 의 의사 구현이 무엇인지에 대한 단서가 있습니다 .__ call __ () :</target>
        </trans-unit>
        <trans-unit id="9d0d319c87f6fad802806c07bd7c51a428962ba2" translate="yes" xml:space="preserve">
          <source>Oh, and in python 3 if you do this call with keyword arguments, like this:</source>
          <target state="translated">아, 그리고 파이썬 3에서는 다음과 같이 키워드 인수 로이 호출을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7cfdd53a3948e13bf6052b4df361c602b9dadb4c" translate="yes" xml:space="preserve">
          <source>One of the most valuable things we can do by default in writing a Python object is to provide it with a good &lt;code&gt;__repr__&lt;/code&gt;. When we call &lt;code&gt;help(repr)&lt;/code&gt; we learn that there's a good test for a &lt;code&gt;__repr__&lt;/code&gt; that also requires a test for equality - &lt;code&gt;obj == eval(repr(obj))&lt;/code&gt;. The following simple implementation of &lt;code&gt;__repr__&lt;/code&gt; and &lt;code&gt;__eq__&lt;/code&gt; for class instances of our type class provides us with a demonstration that may improve on the default &lt;code&gt;__repr__&lt;/code&gt; of classes:</source>
          <target state="translated">파이썬 객체를 작성할 때 기본적으로 할 수있는 가장 귀중한 일 중 하나는 좋은 &lt;code&gt;__repr__&lt;/code&gt; 을 제공하는 것입니다. &lt;code&gt;help(repr)&lt;/code&gt; 을 호출하면 &lt;code&gt;__repr__&lt;/code&gt; 에 대한 좋은 테스트가 있고 동등성에 대한 테스트가 필요하다는 것을 알 수 있습니다 -obj &lt;code&gt;obj == eval(repr(obj))&lt;/code&gt; . 타입 클래스의 클래스 인스턴스에 대한 다음 &lt;code&gt;__repr__&lt;/code&gt; 및 &lt;code&gt;__eq__&lt;/code&gt; 의 간단한 구현은 클래스의 기본 &lt;code&gt;__repr__&lt;/code&gt; 을 개선 할 수있는 데모를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="110c76ebedce2cc5ef80aca4ff4ae9ae674cabba" translate="yes" xml:space="preserve">
          <source>One thing added to metaclasses in python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:</source>
          <target state="translated">파이썬 3에서 메타 클래스에 추가 된 한 가지는 키워드 인수로 속성을 메타 클래스에 전달할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="34e532c0c60597f39dcc4f2a9b5f7a1d572c0614" translate="yes" xml:space="preserve">
          <source>One use for metaclasses is adding new properties and methods to an instance automatically.</source>
          <target state="translated">메타 클래스의 한 가지 용도는 인스턴스에 새로운 속성과 메서드를 자동으로 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ef268ec4d64e990e936a954651784766af9637be" translate="yes" xml:space="preserve">
          <source>Others have explained how metaclasses work and how they fit into the Python type system. Here's an example of what they can be used for. In a testing framework I wrote, I wanted to keep track of the order in which classes were defined, so that I could later instantiate them in this order. I found it easiest to do this using a metaclass.</source>
          <target state="translated">다른 사람들은 메타 클래스의 작동 방식과 파이썬 유형 시스템에 어떻게 적합한 지 설명했습니다. 다음은 이들이 사용할 수있는 예입니다. 필자가 작성한 테스트 프레임 워크에서 클래스가 정의 된 순서를 추적하여 나중에이 순서로 클래스를 인스턴스화 할 수 있기를 원했습니다. 메타 클래스를 사용 하여이 작업을 수행하는 것이 가장 쉽다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="a1e368bcdd9e3ad64f80172f6605fff557c816ac" translate="yes" xml:space="preserve">
          <source>Pseudocode:</source>
          <target state="translated">Pseudocode:</target>
        </trans-unit>
        <trans-unit id="b046f20ec5ac77994d3cd2fa8b65aab70b67256f" translate="yes" xml:space="preserve">
          <source>Put a third way, a metaclass is a class's class.</source>
          <target state="translated">세 번째 방법으로 메타 클래스는 클래스의 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="8d527c34e169c405cdbe5dedda08a7bde822577d" translate="yes" xml:space="preserve">
          <source>Put another way, a class is an instance of a metaclass:</source>
          <target state="translated">다시 말해서 클래스는 메타 클래스의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="57d1465b29ebaa761602dcd70cff407e53c47e35" translate="yes" xml:space="preserve">
          <source>Putting it differently</source>
          <target state="translated">다르게 퍼팅</target>
        </trans-unit>
        <trans-unit id="ce9d464e6a7243401820e72c717964ac86dda8b2" translate="yes" xml:space="preserve">
          <source>Python classes are themselves objects - as in instance - of their meta-class.</source>
          <target state="translated">파이썬 클래스 자체는 메타 클래스의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="47913b0ef43e652acfa0a6f76a38e652fae1a60c" translate="yes" xml:space="preserve">
          <source>Python does the following:</source>
          <target state="translated">파이썬은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1cef07b48fc1a95aee7f514ccf91ce22d457b8f0" translate="yes" xml:space="preserve">
          <source>Python will look for &lt;code&gt;__metaclass__&lt;/code&gt; in the class definition. If it finds it,
it will use it to create the object class &lt;code&gt;Foo&lt;/code&gt;. If it doesn't, it will use
&lt;code&gt;type&lt;/code&gt; to create the class.</source>
          <target state="translated">파이썬은 클래스 정의에서 &lt;code&gt;__metaclass__&lt;/code&gt; 를 찾습니다. 발견되면이를 사용하여 &lt;code&gt;Foo&lt;/code&gt; 객체 클래스를 만듭니다. 그렇지 않으면 &lt;code&gt;type&lt;/code&gt; 을 사용하여 클래스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c68f250ede1ff4f4e9314c1012a1057abd055fc7" translate="yes" xml:space="preserve">
          <source>Read that several times.</source>
          <target state="translated">여러 번 읽어보세요.</target>
        </trans-unit>
        <trans-unit id="10b8e71a62f5bb23590ad5fac72a1920c13c031d" translate="yes" xml:space="preserve">
          <source>Read the section below for how python handles this.</source>
          <target state="translated">파이썬이 이것을 어떻게 처리하는지 아래 섹션을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="363f6db0e6302144237a5fb8dc97f8c0bca8e69c" translate="yes" xml:space="preserve">
          <source>Remember the function &lt;code&gt;type&lt;/code&gt;? The good old function that lets you know what
type an object is:</source>
          <target state="translated">함수 &lt;code&gt;type&lt;/code&gt; 기억하십니까? 객체가 어떤 유형인지 알 수있는 좋은 오래된 기능 :</target>
        </trans-unit>
        <trans-unit id="cf75004630642fa532edd3e9852d9ebbd8dc3330" translate="yes" xml:space="preserve">
          <source>Role of a metaclass' &lt;code&gt;__call__()&lt;/code&gt; method when creating a class instance</source>
          <target state="translated">클래스 인스턴스 생성시 메타 클래스의 &lt;code&gt;__call__()&lt;/code&gt; 메소드 역할</target>
        </trans-unit>
        <trans-unit id="ab6d3b5b86935e5bb21ca62e95635f583fc6b80d" translate="yes" xml:space="preserve">
          <source>Say you want some simple validation code to run on your attributes -- like it must always be an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;str&lt;/code&gt;.  Without a metaclass, your class would look something like:</source>
          <target state="translated">속성에 대해 간단한 유효성 검사 코드를 실행하려고한다고 가정 해 봅시다. 항상 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;str&lt;/code&gt; 이어야합니다. 메타 클래스가 없으면 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="924f4a98a9789c119e7866bd528b9dbf5b11a53a" translate="yes" xml:space="preserve">
          <source>Secondly, metaclasses are complicated. You may not want to use them for
very simple class alterations. You can change classes by using two different techniques:</source>
          <target state="translated">둘째, 메타 클래스가 복잡합니다. 매우 간단한 수업 변경에는 사용하지 않을 수도 있습니다. 두 가지 기술을 사용하여 클래스를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dfe816bf571911a330a66b6c754c40a58c06f42" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;__metaclass__&lt;/code&gt; can accept any callable, why would you use a class
since it's obviously more complicated?</source>
          <target state="translated">&lt;code&gt;__metaclass__&lt;/code&gt; 는 호출 가능한 것을 허용 할 수 있기 때문에 왜 더 복잡한 클래스를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="bac0117f2a38a17d034595eaa6fbc681396fe5b3" translate="yes" xml:space="preserve">
          <source>Since classes are objects, they must be generated by something.</source>
          <target state="translated">클래스는 객체이므로 무언가로 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="760ecfb3930f9e09bb9d06c038adf0fa41b52fc4" translate="yes" xml:space="preserve">
          <source>Since classes are objects, you can create them on the fly, like any object.</source>
          <target state="translated">클래스는 객체이기 때문에 다른 객체처럼 즉시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7922a02533e41a18df57099805414126241c109f" translate="yes" xml:space="preserve">
          <source>So now when we create an object with this metaclass, the &lt;code&gt;__repr__&lt;/code&gt; echoed on the command line provides a much less ugly sight than the default:</source>
          <target state="translated">이제이 메타 클래스를 사용하여 객체를 만들 때 명령 줄에 에코 된 &lt;code&gt;__repr__&lt;/code&gt; 이 기본값보다 훨씬 덜보기 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b3eadfdf1eb9197422100ebb25f09e54a92a4803" translate="yes" xml:space="preserve">
          <source>So we will start with a simple example, by using a function.</source>
          <target state="translated">함수를 사용하여 간단한 예부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="3baa5edda84402a64f5f0858188ef99b09a86284" translate="yes" xml:space="preserve">
          <source>So what we did was instantiate a metaclass by creating a class. We can also treat the metaclass as we would any other class. It has a method resolution order:</source>
          <target state="translated">우리가 한 것은 클래스를 만들어 메타 클래스를 인스턴스화하는 것입니다. 다른 클래스와 마찬가지로 메타 클래스를 처리 할 수도 있습니다. 메소드 해결 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="787050e4deb5bdd8472bfd457a5d01da81c38749" translate="yes" xml:space="preserve">
          <source>So, a metaclass is just the stuff that creates class objects.</source>
          <target state="translated">메타 클래스는 클래스 객체를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2cdd6c8b1bfe3a886c05a5ee17876f43593f8214" translate="yes" xml:space="preserve">
          <source>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.</source>
          <target state="translated">메타 클래스 클래스를 지정했지만 메타 클래스 함수가 ​​아닌 클래스의 서브 클래스는 메타 클래스의 인스턴스가됩니다.</target>
        </trans-unit>
        <trans-unit id="0e65e54eb14defefa9b23c03a66343a7b6f47568" translate="yes" xml:space="preserve">
          <source>TLDR: A metaclass instantiates and defines behavior for a class just like a class instantiates and defines behavior for an instance.</source>
          <target state="translated">TLDR : 메타 클래스는 클래스와 마찬가지로 클래스의 동작을 인스턴스화하고 정의하며 인스턴스의 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ed0c814a6c1a71ccfd0f078327070092fba4af8e" translate="yes" xml:space="preserve">
          <source>That's it. There is really nothing more about metaclasses.</source>
          <target state="translated">그게 다야. 메타 클래스에 대해서는 더 이상 아무것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4cdd3d253d3c4a2ec82a87618d1e84a1259cbb8" translate="yes" xml:space="preserve">
          <source>The 'ValidateType' class for reference:</source>
          <target state="translated">참조를위한 'ValidateType'클래스 :</target>
        </trans-unit>
        <trans-unit id="604a85cd97fdfe89bc4bd3ea794f26e3143cb342" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__&quot;&gt;&lt;code&gt;__metaclass__&lt;/code&gt;&lt;/a&gt; attribute</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__&quot;&gt; &lt;code&gt;__metaclass__&lt;/code&gt; &lt;/a&gt; 속성</target>
        </trans-unit>
        <trans-unit id="b9bee8c22368a6bedc8cb2204d7e38427ec1a6fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__call__()&lt;/code&gt; method is invoked when an instance of a class is used as a callable. But as we've seen from previous answers a class itself is an instance of a metaclass, so when we use the class as a callable (i.e. when we create an instance of it) we're actually calling its metaclass' &lt;code&gt;__call__()&lt;/code&gt; method. At this point most Python programmers are a bit confused because they've been told that when creating an instance like this &lt;code&gt;instance = SomeClass()&lt;/code&gt; you're calling its &lt;code&gt;__init__()&lt;/code&gt; method. Some who've dug a bit deeper know that before &lt;code&gt;__init__()&lt;/code&gt; there's &lt;code&gt;__new__()&lt;/code&gt;. Well, today another layer of truth is being revealed, before &lt;code&gt;__new__()&lt;/code&gt; there's the metaclass' &lt;code&gt;__call__()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__call__()&lt;/code&gt; 메소드는 클래스의 인스턴스가 호출 가능으로 사용될 때 호출됩니다. 그러나 이전 답변에서 보았 듯이 클래스 자체는 메타 클래스의 인스턴스이므로 클래스를 호출 가능 클래스로 사용할 때 (즉, 인스턴스를 만들 때) 실제로 메타 클래스 ' &lt;code&gt;__call__()&lt;/code&gt; 메서드를 호출합니다 . 이 시점에서 대부분의 Python 프로그래머는이 &lt;code&gt;instance = SomeClass()&lt;/code&gt; 와 같은 인스턴스를 만들 때 &lt;code&gt;__init__()&lt;/code&gt; 메서드를 호출한다고 들었 기 때문에 약간 혼란 스럽습니다. 조금 더 깊이 파고 들었던 일부 사람들은 &lt;code&gt;__init__()&lt;/code&gt; 전에 &lt;code&gt;__new__()&lt;/code&gt; 이 있다는 것을 알고 있습니다. 자, 오늘 또 다른 진실 층이 공개되고 있습니다. &lt;code&gt;__new__()&lt;/code&gt; 전에 메타 클래스 ' &lt;code&gt;__call__()&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbdb757e7f3a0fd9bcff0fc938b6c42345b821ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;metaclass&lt;/code&gt; is powerful, there are many things (such as monkey magic) you can do with it, but be careful this may only be known to you.</source>
          <target state="translated">&lt;code&gt;metaclass&lt;/code&gt; 는 강력하고, 당신이 할 수있는 많은 것들 (원숭이 마술과 같은)이 있지만, 이것이 당신에게만 알려질 수 있다는 것을주의하십시오.</target>
        </trans-unit>
        <trans-unit id="7ffedf4f89a6efcf7f214cee31b40dd5d82d9dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type(obj)&lt;/code&gt; function gets you the type of an object.</source>
          <target state="translated">&lt;code&gt;type(obj)&lt;/code&gt; 함수는 객체의 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="19c9cb1547b44911ff93834c533ce8c6106e48d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;metaclass&lt;/em&gt; of the object we created, in both cases, is &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">두 경우 모두 생성 한 객체의 &lt;em&gt;메타 클래스&lt;/em&gt; 는 &lt;code&gt;type&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a1aa36bd31df16516299e0a9f975574341ae6676" translate="yes" xml:space="preserve">
          <source>The above should look familiar. Well, where does &lt;code&gt;Class&lt;/code&gt; come from? It's an instance of a metaclass (also pseudocode):</source>
          <target state="translated">위의 내용은 익숙해야합니다. 글쎄, &lt;code&gt;Class&lt;/code&gt; 어디에서 왔습니까? 메타 클래스 (의사 코드)의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="a2875f88e41a0ad13dd2d5379ef6582ba0fb3dd7" translate="yes" xml:space="preserve">
          <source>The answer is: something that can create a class.</source>
          <target state="translated">답은 클래스를 만들 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9a86d7001554378f3dcbce322b370aaa90ec530c" translate="yes" xml:space="preserve">
          <source>The behaviour of metaclasses however stays &lt;a href=&quot;https://www.python.org/dev/peps/pep-3115/&quot;&gt;largely the same&lt;/a&gt;.</source>
          <target state="translated">그러나 메타 클래스의 동작은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3115/&quot;&gt;거의 동일하게&lt;/a&gt; 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3f6d3b98cc17992d9030a84dca7f0f6a00ff380a" translate="yes" xml:space="preserve">
          <source>The default metaclass, which is applied when when you determine classes as:</source>
          <target state="translated">클래스를 다음과 같이 결정할 때 적용되는 기본 메타 클래스 :</target>
        </trans-unit>
        <trans-unit id="29b56e4ed0cf2c522c5e5b6e0b098db30123e1fe" translate="yes" xml:space="preserve">
          <source>The intention is clear. When you read &lt;code&gt;UpperAttrMetaclass(type)&lt;/code&gt;, you know
what's going to follow</source>
          <target state="translated">의도는 분명하다. &lt;code&gt;UpperAttrMetaclass(type)&lt;/code&gt; 을 읽으면 따라야 할 사항을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6e5997843f57dcebc725e6a5762f1c51bce68a1" translate="yes" xml:space="preserve">
          <source>The last word</source>
          <target state="translated">마지막 단어</target>
        </trans-unit>
        <trans-unit id="fde54b7f3e6afffc50941664e058311d935cae06" translate="yes" xml:space="preserve">
          <source>The latter is possible when you implement the &lt;code&gt;__call__()&lt;/code&gt; magic method on the class.</source>
          <target state="translated">후자는 &lt;code&gt;__call__()&lt;/code&gt; 매직 메소드를 구현할 때 가능합니다.</target>
        </trans-unit>
        <trans-unit id="71bb84c4860a5a46695ab1e2438f2ed1d5a90d31" translate="yes" xml:space="preserve">
          <source>The main purpose of a metaclass is to change the class automatically,
when it's created.</source>
          <target state="translated">메타 클래스의 주요 목적은 클래스가 생성 될 때 클래스를 자동으로 변경하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c9b5afc7d5812bc24e508fdde2021ee24771b8d" translate="yes" xml:space="preserve">
          <source>The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:</source>
          <target state="translated">메타 클래스의 주요 사용 사례는 API를 만드는 것입니다. 이것의 전형적인 예는 Django ORM입니다. 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ed8ebb489915f332c0205bc56188ef3801ec4e9" translate="yes" xml:space="preserve">
          <source>The metaclass enabling this</source>
          <target state="translated">이것을 가능하게하는 메타 클래스</target>
        </trans-unit>
        <trans-unit id="d7864ae5ef3f0b7a2f3aacd5831a1402dbade9c3" translate="yes" xml:space="preserve">
          <source>The output will be:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5268adb28d12d30ac6d135d5f75b63e9da11e68b" translate="yes" xml:space="preserve">
          <source>The potential uses for metaclasses are boundless. Some ideas that have been explored include logging, interface checking, automatic delegation, automatic property creation, proxies, frameworks, and automatic resource locking/synchronization.</source>
          <target state="translated">메타 클래스의 잠재적 용도는 무한합니다. 조사 된 일부 아이디어에는 로깅, 인터페이스 검사, 자동 위임, 자동 속성 생성, 프록시, 프레임 워크 및 자동 리소스 잠금 / 동기화가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6907452e93a5a80f5c109418b9bf18c96cd67c09" translate="yes" xml:space="preserve">
          <source>The reason behind the complexity of the code using metaclasses is not because
of metaclasses, it's because you usually use metaclasses to do twisted stuff
relying on introspection, manipulating inheritance, vars such as &lt;code&gt;__dict__&lt;/code&gt;, etc.</source>
          <target state="translated">메타 클래스를 사용하는 코드의 복잡성에 대한 이유는 메타 클래스 때문이 아니라, 일반적으로 메타 클래스를 사용하여 내성, 상속 조작, &lt;code&gt;__dict__&lt;/code&gt; 등의 변수에 의존하는 트위스트 된 항목을 수행하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="292b3d3fa44cb0944294ebc9a86345b3567f6d79" translate="yes" xml:space="preserve">
          <source>The syntax to set the metaclass has been changed in Python 3:</source>
          <target state="translated">메타 클래스를 설정하는 문법이 파이썬 3에서 변경되었습니다 :</target>
        </trans-unit>
        <trans-unit id="b4d33846e5640be4c1d9597eafdcc9bc72aceaf5" translate="yes" xml:space="preserve">
          <source>The thing that's left to say is: If you don't know what metaclasses are, the probability that you &lt;strong&gt;will not need them&lt;/strong&gt; is 99%.</source>
          <target state="translated">남은 말 : 메타 클래스가 무엇인지 모르는 경우 메타 클래스가 필요하지 않을 확률은 99 %입니다.</target>
        </trans-unit>
        <trans-unit id="959c3572d6d62fe879c68854fc146ad30c9bb8cd" translate="yes" xml:space="preserve">
          <source>The tl;dr version</source>
          <target state="translated">tl; dr 버전</target>
        </trans-unit>
        <trans-unit id="656d2c5fc9c081a8217d9d6a68f3f31fc9b34aef" translate="yes" xml:space="preserve">
          <source>The type() function can return the type of an object or create a new type,</source>
          <target state="translated">type () 함수는 객체의 유형을 반환하거나 새 유형을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="733141dd8934a1c4901342843517b7b8404b6323" translate="yes" xml:space="preserve">
          <source>Then if it can't find any &lt;code&gt;__metaclass__&lt;/code&gt; at all, it will use the &lt;code&gt;Bar&lt;/code&gt;'s (the first parent) own metaclass (which might be the default &lt;code&gt;type&lt;/code&gt;) to create the class object.</source>
          <target state="translated">그런 다음 &lt;code&gt;__metaclass__&lt;/code&gt; 를 전혀 찾을 수 없으면 &lt;code&gt;Bar&lt;/code&gt; 의 첫 번째 상위 메타 클래스 (기본 &lt;code&gt;type&lt;/code&gt; 수 있음)를 사용하여 클래스 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a771a2f9cc215079a67d4f526fd98ab5b55dcf1f" translate="yes" xml:space="preserve">
          <source>There are (at this point) two key methods in a metaclass:</source>
          <target state="translated">메타 클래스에는 현재 두 가지 주요 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="40e0c7527fe508c7995960aaf38056900b9ff412" translate="yes" xml:space="preserve">
          <source>There are several reasons to do so:</source>
          <target state="translated">몇 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e2063eee3f575331ddd73d7a81c2d318f5daa93" translate="yes" xml:space="preserve">
          <source>These are called metaclasses, damn it! It must mean something!</source>
          <target state="translated">이것을 메타 클래스라고합니다. 뭔가를 의미해야합니다!</target>
        </trans-unit>
        <trans-unit id="3b5c4cd62ac6b431a5176848fb6508cfa06be65a" translate="yes" xml:space="preserve">
          <source>This is a case where I saw metaclass as a solution to my problem:
I had a really complicated problem, that probably could have been solved differently, but I chose to solve it using a metaclass.  Because of the complexity, it is one of the few modules I have written where the comments in the module surpass the amount of code that has been written.  Here it is...</source>
          <target state="translated">이것은 메타 클래스를 내 문제에 대한 해결책으로 보았습니다. 실제로 복잡한 문제가 있었으며 아마도 다르게 해결할 수 있었지만 메타 클래스를 사용하여 해결하기로 선택했습니다. 복잡성 때문에 모듈의 주석이 작성된 코드의 양을 능가하는 몇 가지 모듈 중 하나입니다. 여기있어...</target>
        </trans-unit>
        <trans-unit id="bd01e02e8d937d71c953efd2b047baa65d13a9d0" translate="yes" xml:space="preserve">
          <source>This is a class that uses that metaclass</source>
          <target state="translated">이 메타 클래스를 사용하는 클래스입니다</target>
        </trans-unit>
        <trans-unit id="0eaab00f42bc385328b90e65be0df9fd3ce443e5" translate="yes" xml:space="preserve">
          <source>This is a metaclass that logs exactly the moment before an instance is created and the moment it's about to return it.</source>
          <target state="translated">인스턴스가 생성되기 전과 인스턴스를 반환하는 순간을 정확하게 기록하는 메타 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="a91ffeba7150d22f41622349f220dc2a7bd0941e" translate="yes" xml:space="preserve">
          <source>This is possible because &lt;code&gt;models.Model&lt;/code&gt; defines &lt;code&gt;__metaclass__&lt;/code&gt; and
it uses some magic that will turn the &lt;code&gt;Person&lt;/code&gt; you just defined with simple statements
into a complex hook to a database field.</source>
          <target state="translated">&lt;code&gt;models.Model&lt;/code&gt; 은 &lt;code&gt;__metaclass__&lt;/code&gt; 를 정의하고 간단한 명령문으로 방금 정의한 &lt;code&gt;Person&lt;/code&gt; 을 데이터베이스 필드에 대한 복잡한 후크로 바꾸는 마법을 사용하기 때문에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4f1bef529754046ab93614c707e29ea65f065a58" translate="yes" xml:space="preserve">
          <source>This is what Python does when you use the keyword &lt;code&gt;class&lt;/code&gt;, and it does so by using a metaclass.</source>
          <target state="translated">이것은 키워드 &lt;code&gt;class&lt;/code&gt; 를 사용할 때 파이썬이하는 일이며 메타 클래스를 사용하여 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="690dffa17d6286ca4b5f0d265293b3aba8dc9308" translate="yes" xml:space="preserve">
          <source>This is what the metaclass would look like (not using &lt;code&gt;__prepare__&lt;/code&gt; since it is not needed):</source>
          <target state="translated">이것은 메타 클래스의 모습입니다 (필요하지 &lt;code&gt;__prepare__&lt;/code&gt; 때문에 __prepare__를 사용하지 않음).</target>
        </trans-unit>
        <trans-unit id="3a703a42ef6d26d4b5acc17812e989feee889a40" translate="yes" xml:space="preserve">
          <source>This way, all classes of this module will be created using this metaclass,
and we just have to tell the metaclass to turn all attributes to uppercase.</source>
          <target state="translated">이런 식으로이 모듈의 모든 클래스는이 메타 클래스를 사용하여 생성되며 모든 속성을 대문자로 바꾸도록 메타 클래스에 지시하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c8eb39184302c31569399fad3b80b08d690c761d" translate="yes" xml:space="preserve">
          <source>To create a metaclass, overriding of &lt;strong&gt;new&lt;/strong&gt;() and &lt;strong&gt;init&lt;/strong&gt;() methods is usually done. &lt;strong&gt;new&lt;/strong&gt;() can be overridden to change the way objects are created, while &lt;strong&gt;init&lt;/strong&gt;() can be overridden to change the way of initializing the object. Metaclass can be created by a number of ways. One of the ways is to use type() function. type() function, when called with 3 parameters, creates a metaclass. The parameters are :-</source>
          <target state="translated">메타 클래스를 만들려면 일반적으로 &lt;strong&gt;new&lt;/strong&gt; () 및 &lt;strong&gt;init&lt;/strong&gt; () 메서드를 재정의합니다. 객체 생성 방식을 변경하기 위해 &lt;strong&gt;new&lt;/strong&gt; ()를 재정의하고 객체 초기화 방식을 변경하기 위해 &lt;strong&gt;init&lt;/strong&gt; ()를 재정의 할 수 있습니다. 메타 클래스는 여러 가지 방법으로 만들 수 있습니다. 방법 중 하나는 type () 함수를 사용하는 것입니다. type () 함수는 3 개의 매개 변수와 함께 호출 될 때 메타 클래스를 만듭니다. 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f66480aa700b9c3c9e3a6513f4f91ad438a6ac8" translate="yes" xml:space="preserve">
          <source>To use a metaclass:</source>
          <target state="translated">메타 클래스를 사용하려면</target>
        </trans-unit>
        <trans-unit id="9d625953b8c96c50aabee6488063e1446a582041" translate="yes" xml:space="preserve">
          <source>Tuple having base classes inherited by class</source>
          <target state="translated">기본 클래스가 클래스에 상속 된 튜플</target>
        </trans-unit>
        <trans-unit id="d0594a199ce5d4ac41e3201736acd504b143394b" translate="yes" xml:space="preserve">
          <source>We can extend &lt;code&gt;type&lt;/code&gt; just like any other class definition:</source>
          <target state="translated">다른 클래스 정의와 마찬가지로 &lt;code&gt;type&lt;/code&gt; 을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d88182269b2e241ec478b27d4767550768772015" translate="yes" xml:space="preserve">
          <source>We can make it even cleaner by using &lt;code&gt;super&lt;/code&gt;, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 를 사용하여 더 깔끔하게 만들 수 있습니다. 상속을 쉽게 할 수 있습니다 (그렇기 때문에 메타 클래스, 메타 클래스에서 상속, 유형에서 상속 할 수 있기 때문에) :</target>
        </trans-unit>
        <trans-unit id="92762df1c860bcdb2ae4c1a3bc542b57879d0959" translate="yes" xml:space="preserve">
          <source>We can see that the metaclass' &lt;code&gt;__call__()&lt;/code&gt; method is the one that's called first. It then delegates creation of the instance to the class's &lt;code&gt;__new__()&lt;/code&gt; method and initialization to the instance's &lt;code&gt;__init__()&lt;/code&gt;. It's also the one that ultimately returns the instance.</source>
          <target state="translated">메타 클래스의 &lt;code&gt;__call__()&lt;/code&gt; 메소드가 가장 먼저 호출되는 것을 볼 수 있습니다. 그런 다음 인스턴스 생성을 클래스의 &lt;code&gt;__new__()&lt;/code&gt; 메서드에 위임하고 초기화를 인스턴스의 &lt;code&gt;__init__()&lt;/code&gt; 위임합니다. 또한 궁극적으로 인스턴스를 반환하는 것이기도합니다.</target>
        </trans-unit>
        <trans-unit id="16d288708e3034e3415f37e929abe09a44ae3d9f" translate="yes" xml:space="preserve">
          <source>Well in fact, classes are themselves instances. Of metaclasses.</source>
          <target state="translated">실제로 클래스 자체는 실례입니다. 메타 클래스</target>
        </trans-unit>
        <trans-unit id="d278e4f17ef8ed67c2a22f4c32904a94d842130f" translate="yes" xml:space="preserve">
          <source>Well, &lt;a href=&quot;http://docs.python.org/2/library/functions.html#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; has a completely different ability, it can also create classes on the fly. &lt;code&gt;type&lt;/code&gt; can take the description of a class as parameters,
and return a class.</source>
          <target state="translated">글쎄, &lt;a href=&quot;http://docs.python.org/2/library/functions.html#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 은 완전히 다른 능력을 가지고 있으며, 클래스를 즉석에서 만들 수도 있습니다. &lt;code&gt;type&lt;/code&gt; 은 클래스에 대한 설명을 매개 변수로 사용하여 클래스를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f58b345320ab6cedc6dd827175904f92af7b09a9" translate="yes" xml:space="preserve">
          <source>Well, I guess it's a matter of consistency with &lt;code&gt;str&lt;/code&gt;, the class that creates
strings objects, and &lt;code&gt;int&lt;/code&gt; the class that creates integer objects. &lt;code&gt;type&lt;/code&gt; is
just the class that creates class objects.</source>
          <target state="translated">글쎄, 문자열 객체를 만드는 클래스 인 &lt;code&gt;str&lt;/code&gt; 과 일관성있는 문제이며 정수 객체를 만드는 클래스는 &lt;code&gt;int&lt;/code&gt; 입니다. &lt;code&gt;type&lt;/code&gt; 은 클래스 객체를 만드는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="a0696d6279da7380ed7a9d1f185eabd27a76e2f1" translate="yes" xml:space="preserve">
          <source>Well, metaclasses are what create these objects. They are the classes' classes,
you can picture them this way:</source>
          <target state="translated">메타 클래스가 이러한 객체를 만드는 것입니다. 그것들은 클래스의 클래스입니다. 이런 식으로 그림을 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd8f8377093c7a9f568847ac99d779518ff62c1b" translate="yes" xml:space="preserve">
          <source>Well, usually you don't:</source>
          <target state="translated">글쎄, 보통 당신은하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="464df4ba1017e09b5d8fcbcb6bc3f85fc5e4129e" translate="yes" xml:space="preserve">
          <source>What are metaclasses (finally)</source>
          <target state="translated">메타 클래스 (최종)</target>
        </trans-unit>
        <trans-unit id="7be40721cc8b807cb99d9d947eae9af189c69085" translate="yes" xml:space="preserve">
          <source>What are metaclasses in Python</source>
          <target state="translated">파이썬에서 메타 클래스 란 무엇인가</target>
        </trans-unit>
        <trans-unit id="95ac2d20e8da72812ecb5a849d130ac5cab6552d" translate="yes" xml:space="preserve">
          <source>What are metaclasses? What do you use them for?</source>
          <target state="translated">메타 클래스 란 무엇입니까? 무엇을 위해 사용합니까?</target>
        </trans-unit>
        <trans-unit id="ca7233bf93e47a10f12eab5a25b942225351fd97" translate="yes" xml:space="preserve">
          <source>What can they be used for? From the &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">그들은 무엇을 위해 사용될 수 있습니까? &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;문서에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="faccab95a2838e0f66852ca4a5c0f3a913942d90" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;class&lt;/code&gt; statement is executed, Python first executes the body of the &lt;code&gt;class&lt;/code&gt; statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the &lt;code&gt;__metaclass__&lt;/code&gt; attribute of the class-to-be (if any) or the &lt;code&gt;__metaclass__&lt;/code&gt; global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 문장이 실행될 때, 파이썬은 먼저 &lt;code&gt;class&lt;/code&gt; 문장의 본문을 일반적인 코드 블록으로 실행합니다. 결과 네임 스페이스 (dict)는 클래스의 속성을 보유합니다. 메타 클래스는 class-to-be (메타 클래스가 상 속됨)의 기본 클래스, 클래스가 될 클래스의 &lt;code&gt;__metaclass__&lt;/code&gt; 속성 (있는 경우) 또는 &lt;code&gt;__metaclass__&lt;/code&gt; 전역 변수를보고 결정됩니다. 그런 다음 메타 클래스를 클래스의 이름, 기본 및 속성과 함께 호출하여이를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="0f703991c228a312fa1f4a4718f72097c5f38dc7" translate="yes" xml:space="preserve">
          <source>When we instantiate an object, we get an instance:</source>
          <target state="translated">객체를 인스턴스화하면 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8ee345e21d7df889e916663fa72306a26db891" translate="yes" xml:space="preserve">
          <source>When you do:</source>
          <target state="translated">할 때 :</target>
        </trans-unit>
        <trans-unit id="8eadeed1a219183cc2c88f7ec677f6b2d5aec1aa" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; keyword, Python creates this object automatically. But as
with most things in Python, it gives you a way to do it manually.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 키워드를 사용하면 Python이이 객체를 자동으로 만듭니다. 그러나 파이썬에서 대부분의 것들과 마찬가지로 수동으로 수행하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ea3a686b188cb5fead0828deafd55680a345ac59" translate="yes" xml:space="preserve">
          <source>When you write a class definition and Python executes it, it uses a metaclass to instantiate the class object (which will, in turn, be used to instantiate instances of that class).</source>
          <target state="translated">클래스 정의를 작성하고 파이썬이이를 실행하면 메타 클래스를 사용하여 클래스 객체를 인스턴스화합니다 (그러면 해당 클래스의 인스턴스를 인스턴스화하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="0c3bff2984a4115df4dcc3bfb7149ff8691306a4" translate="yes" xml:space="preserve">
          <source>When you write a class definition, for example, like this,</source>
          <target state="translated">예를 들어 다음과 같이 클래스 정의를 작성할 때</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="8c962cb76a1933afc23c5280c46178cdc0963538" translate="yes" xml:space="preserve">
          <source>While in Python you can use arbitrary callables for metaclasses (like &lt;a href=&quot;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037&quot;&gt;Jerub&lt;/a&gt; shows), the better approach is to make it an actual class itself. &lt;code&gt;type&lt;/code&gt; is the usual metaclass in Python. &lt;code&gt;type&lt;/code&gt; is itself a class, and it is its own type. You won't be able to recreate something like &lt;code&gt;type&lt;/code&gt; purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">파이썬에서는 메타 클래스 (예 : &lt;a href=&quot;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037&quot;&gt;Jerub&lt;/a&gt; 쇼)에 대해 임의의 호출 가능 항목을 사용할 수 있지만 더 나은 방법은 실제 클래스 자체로 만드는 것입니다. &lt;code&gt;type&lt;/code&gt; 은 파이썬에서 일반적인 메타 클래스입니다. &lt;code&gt;type&lt;/code&gt; 자체는 클래스이며 자체 유형입니다. 파이썬에서는 &lt;code&gt;type&lt;/code&gt; 과 같은 것을 다시 만들 수는 없지만 파이썬은 약간의 속임수를 씁니다. 파이썬에서 자신의 메타 클래스를 만들려면 실제로 &lt;code&gt;type&lt;/code&gt; 서브 클래스를 원합니다.</target>
        </trans-unit>
        <trans-unit id="ff246de9114513e53dcf845cd6f5e43b2c9dffe8" translate="yes" xml:space="preserve">
          <source>Why would you use metaclasses classes instead of functions?</source>
          <target state="translated">함수 대신 메타 클래스 클래스를 사용하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="29f54ff47c50feb7cebfef143da1409f28cafef5" translate="yes" xml:space="preserve">
          <source>Why would you use metaclasses?</source>
          <target state="translated">왜 메타 클래스를 사용 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="70111da65d9e847b219ad4430cd1c1828a6ec8a3" translate="yes" xml:space="preserve">
          <source>With a nice &lt;code&gt;__repr__&lt;/code&gt; defined for the class instance, we have a stronger ability to debug our code. However, much further checking with &lt;code&gt;eval(repr(Class))&lt;/code&gt; is unlikely (as functions would be rather impossible to eval from their default &lt;code&gt;__repr__&lt;/code&gt;'s).</source>
          <target state="translated">클래스 인스턴스에 대해 훌륭한 &lt;code&gt;__repr__&lt;/code&gt; 을 정의하면 코드를 디버깅 할 수있는 더 강력한 기능이 있습니다. 그러나 &lt;code&gt;eval(repr(Class))&lt;/code&gt; 사용한 추가 검사는 거의 불가능합니다 (함수는 기본 &lt;code&gt;__repr__&lt;/code&gt; 에서 평가하는 것이 다소 불가능하므로).</target>
        </trans-unit>
        <trans-unit id="7e2b61a0c2abd2b5f5ed9ec2bcb225e75cc74640" translate="yes" xml:space="preserve">
          <source>Yes, objects.</source>
          <target state="translated">예, 물건.</target>
        </trans-unit>
        <trans-unit id="0ff433fbf5a657d09064a10812fe33b78649c66e" translate="yes" xml:space="preserve">
          <source>You can call it a 'class factory' if you wish.</source>
          <target state="translated">원한다면 '클래스 팩토리'라고 부를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="315df7f70140693e8a8bc6a5c96aefabd150fb69" translate="yes" xml:space="preserve">
          <source>You can hook on &lt;code&gt;__new__&lt;/code&gt;, &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;__call__&lt;/code&gt;. Which will allow
you to do different stuff. Even if usually you can do it all in &lt;code&gt;__new__&lt;/code&gt;,
some people are just more comfortable using &lt;code&gt;__init__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; , &lt;code&gt;__init__&lt;/code&gt; 및 &lt;code&gt;__call__&lt;/code&gt; 에 연결할 수 있습니다. 다른 일을 할 수 있습니다. 일반적으로 &lt;code&gt;__new__&lt;/code&gt; 에서 모든 작업을 수행 할 수 있더라도 일부 사람들은 &lt;code&gt;__init__&lt;/code&gt; 사용하는 것이 더 편합니다.</target>
        </trans-unit>
        <trans-unit id="58cba9a2524d4784e2abd94ecd3a9d0567aa5f1b" translate="yes" xml:space="preserve">
          <source>You can structure your code better. You never use metaclasses for something as
trivial as the above example. It's usually for something complicated. Having the
ability to make several methods and group them in one class is very useful
to make the code easier to read.</source>
          <target state="translated">코드를 더 잘 구성 할 수 있습니다. 위의 예제처럼 사소한 것에 메타 클래스를 사용하지 마십시오. 일반적으로 복잡한 것입니다. 여러 메소드를 작성하고 하나의 클래스로 그룹화하는 기능이 있으면 코드를보다 쉽게 ​​읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64c7301b56292e883aabaa3c4edaf3cf8efc42f2" translate="yes" xml:space="preserve">
          <source>You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.</source>
          <target state="translated">OOP를 사용할 수 있습니다. 메타 클래스는 메타 클래스에서 상속 할 수 있고 부모 메소드를 대체 할 수 있습니다. 메타 클래스는 메타 클래스를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb6eb327fa8c07c0f464979436e448c8c249d0c5" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;metaclass&lt;/code&gt; to change the function of its instance (the class).</source>
          <target state="translated">&lt;code&gt;metaclass&lt;/code&gt; 를 사용하여 인스턴스 (클래스)의 기능을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4bc4a8b7d34394849ad10cef64e38894a0239e3" translate="yes" xml:space="preserve">
          <source>You define classes in order to create objects, right?</source>
          <target state="translated">객체를 생성하기 위해 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="849b6a4a3ab49b1e6d5d5fb3aa2174a5dd045d4a" translate="yes" xml:space="preserve">
          <source>You instantiate a class object.</source>
          <target state="translated">클래스 객체를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="452647fa644731ccf4d36abe26b42b7338dc3ada" translate="yes" xml:space="preserve">
          <source>You may have noticed the extra argument &lt;code&gt;cls&lt;/code&gt;. There is
nothing special about it: &lt;code&gt;__new__&lt;/code&gt; always receives the class it's defined in, as first parameter. Just like you have &lt;code&gt;self&lt;/code&gt; for ordinary methods which receive the instance as first parameter, or the defining class for class methods.</source>
          <target state="translated">추가 인수 &lt;code&gt;cls&lt;/code&gt; 를 보셨을 것입니다. &lt;code&gt;__new__&lt;/code&gt; 은 항상 정의 된 클래스를 첫 번째 매개 변수로받습니다. 인스턴스를 첫 번째 매개 변수로받는 일반 메소드 또는 클래스 메소드의 정의 클래스를 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22aa6e506f7cc49a7a64f3ca6d175caba8e4b9d1" translate="yes" xml:space="preserve">
          <source>You see that by checking the &lt;code&gt;__class__&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;__class__&lt;/code&gt; 속성을 확인하면 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbebccfb501c9be50998ab8dec87986aaf76e78c" translate="yes" xml:space="preserve">
          <source>You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.</source>
          <target state="translated">우리가 어디로 가고 있는지 알 수 있습니다. 파이썬에서 클래스는 객체이며 동적으로 클래스를 즉석에서 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33931bf86a8faf49146362a3955005056936d8f9" translate="yes" xml:space="preserve">
          <source>You use a metaclass every time you create a class:</source>
          <target state="translated">클래스를 만들 때마다 메타 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="892eaf1f9b8ad532b3d9e3281eddca7576cc2b2a" translate="yes" xml:space="preserve">
          <source>You usually do this for APIs, where you want to create classes matching the
current context.</source>
          <target state="translated">일반적으로 현재 컨텍스트와 일치하는 클래스를 작성하려는 API에 대해이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c865cc52046698fef0b1aa97a9a5a1e90813f189" translate="yes" xml:space="preserve">
          <source>You write &lt;code&gt;class Foo(object)&lt;/code&gt; first, but the class object &lt;code&gt;Foo&lt;/code&gt; is not created
in memory yet.</source>
          <target state="translated">&lt;code&gt;class Foo(object)&lt;/code&gt; 먼저 작성하지만 클래스 오브젝트 &lt;code&gt;Foo&lt;/code&gt; 는 아직 메모리에 작성되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fba87a7567989400ed959bfd1f57626604f0e103" translate="yes" xml:space="preserve">
          <source>You'll notice that we use &quot;MyShinyClass&quot; as the name of the class
and as the variable to hold the class reference. They can be different,
but there is no reason to complicate things.</source>
          <target state="translated">&quot;MyShinyClass&quot;를 클래스 이름으로 사용하고 클래스 참조를 보유하는 변수로 사용합니다. 그것들은 다를 수 있지만 문제를 복잡하게 할 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="468ec3a2130a90f33fbe9e9010d78aea548729a5" translate="yes" xml:space="preserve">
          <source>You've seen that &lt;code&gt;type&lt;/code&gt; lets you do something like this:</source>
          <target state="translated">해당 &lt;code&gt;type&lt;/code&gt; 사용하면 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62dbbb0781988a55d8018a0fec2c8ecd07b793aa" translate="yes" xml:space="preserve">
          <source>anyhow, those two are the most commonly used hooks. metaclassing is powerful, and above is nowhere near and exhaustive list of uses for metaclassing.</source>
          <target state="translated">어쨌든이 두 가지가 가장 일반적으로 사용되는 후크입니다. 메타 클래 싱 (metaclassing)은 강력하며, 메타 클래 싱을위한 사용 목록은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3505d90044ca3190f7e9581b12b5ae05136055b" translate="yes" xml:space="preserve">
          <source>can be created manually this way:</source>
          <target state="translated">이 방법으로 수동으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6737e4457bda9ffaf5726333b2319e8722cf25b9" translate="yes" xml:space="preserve">
          <source>class decorators</source>
          <target state="translated">클래스 데코레이터</target>
        </trans-unit>
        <trans-unit id="44c4e8ef96ee00251b1324e275bce4fb98f44122" translate="yes" xml:space="preserve">
          <source>creates in memory an object with the name &quot;ObjectCreator&quot;.</source>
          <target state="translated">이름이 &quot;ObjectCreator&quot;인 오브젝트를 메모리에 작성합니다.</target>
        </trans-unit>
        <trans-unit id="4f7f64c1613218412d7173f07c7407d18b5776a8" translate="yes" xml:space="preserve">
          <source>e.g.:</source>
          <target state="translated">e.g.:</target>
        </trans-unit>
        <trans-unit id="7db9ff8b86f3d42798dfbf41b5e2001a92aac528" translate="yes" xml:space="preserve">
          <source>for example, we can create a Hi class with the type() function and do not  need to use this way with class Hi(object):</source>
          <target state="translated">예를 들어 type () 함수를 사용하여 Hi 클래스를 만들 수 있으며 Hi (object) 클래스와 함께이 방법을 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="760b292bf27a8fcf8c272fa886f3c465a88b9738" translate="yes" xml:space="preserve">
          <source>i.e. the &lt;code&gt;__metaclass__&lt;/code&gt; attribute is no longer used, in favor of a keyword argument in the list of base classes.</source>
          <target state="translated">즉, 기본 클래스 목록의 키워드 인수를 위해 &lt;code&gt;__metaclass__&lt;/code&gt; 속성이 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bebe93e3c9401a8e4b84a6e20e06834c7fbff805" translate="yes" xml:space="preserve">
          <source>intercept a class creation</source>
          <target state="translated">클래스 생성을 가로 채다</target>
        </trans-unit>
        <trans-unit id="b6a7d03698a36198740b6b7e1269046f935e6ce5" translate="yes" xml:space="preserve">
          <source>meta class are used to apply some rule to an entire set of classes. For example, suppose you're building an ORM to access a database, and you want records from each table to be of a class mapped to that table (based on fields, business rules, etc..,), a possible use of metaclass is for instance, connection pool logic, which is share by all classes of record from all tables. Another use is logic to to support foreign keys, which involves multiple classes of records.</source>
          <target state="translated">메타 클래스는 일부 클래스를 전체 클래스 세트에 적용하는 데 사용됩니다. 예를 들어, 데이터베이스에 액세스하기 위해 ORM을 작성하고 각 테이블의 레코드가 필드, 비즈니스 규칙 등을 기반으로 해당 테이블에 맵핑 된 클래스의 메타 클래스 사용을 원한다고 가정하십시오. 예를 들어 모든 테이블의 모든 레코드 클래스에서 공유하는 연결 풀 논리입니다. 다른 용도로는 외래 키를 지원하는 논리가 있으며 여기에는 여러 레코드 클래스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b24e026cd23631fc8326fba464790376a289820a" translate="yes" xml:space="preserve">
          <source>modify the class</source>
          <target state="translated">수업을 수정하다</target>
        </trans-unit>
        <trans-unit id="1123af1e86c1be3e13a73d667767a3eaa9fab222" translate="yes" xml:space="preserve">
          <source>monkey patching</source>
          <target state="translated">원숭이 패치</target>
        </trans-unit>
        <trans-unit id="2bcec56171df3c6150684b60fb0f16c51e1923ed" translate="yes" xml:space="preserve">
          <source>produces:</source>
          <target state="translated">produces:</target>
        </trans-unit>
        <trans-unit id="17156a7f53f004d6bfc86c20c78c7a60336f9799" translate="yes" xml:space="preserve">
          <source>return the modified class</source>
          <target state="translated">수정 된 클래스를 반환</target>
        </trans-unit>
        <trans-unit id="f89967a1b044b115ecabfb714ba2baf9e25b3905" translate="yes" xml:space="preserve">
          <source>when a particular effect has to be applied to all the subclasses</source>
          <target state="translated">모든 서브 클래스에 특정 효과를 적용해야 할 때</target>
        </trans-unit>
        <trans-unit id="129a078ecb9597f440ced3af47b17543ec3a8923" translate="yes" xml:space="preserve">
          <source>when you define metaclass, you subclass type, and can overrided the following magic methods to insert your logic.</source>
          <target state="translated">메타 클래스를 정의 할 때 서브 클래스 유형을 지정하고 다음 매직 메소드를 재정 의하여 로직을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0ebc00ce2803c4b05ae16c519fdb6afbeecd7c8" translate="yes" xml:space="preserve">
          <source>would be:</source>
          <target state="translated">될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="f00aae84260cf328c69240a8408c132eec41893a" translate="yes" xml:space="preserve">
          <source>you can add attributes to it</source>
          <target state="translated">속성을 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7f5329be6ce9f06a3c0b500a9af459ec3e4c8730" translate="yes" xml:space="preserve">
          <source>you can assign it to a variable</source>
          <target state="translated">변수에 할당 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d5e1f2ccb7cae42051601ddb1f83165a911f6cab" translate="yes" xml:space="preserve">
          <source>you can copy it</source>
          <target state="translated">당신은 그것을 복사 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="98b6e75ac98f8c1aab7ac264a673d0bea107ebd2" translate="yes" xml:space="preserve">
          <source>you can pass it as a function parameter</source>
          <target state="translated">함수 매개 변수로 전달할 수 있습니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
