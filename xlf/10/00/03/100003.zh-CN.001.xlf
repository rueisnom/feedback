<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/100003">
    <body>
      <group id="100003">
        <trans-unit id="75f904e8b7fedc01e237553e4c1e63dc973e6787" translate="yes" xml:space="preserve">
          <source>(A side-note on the contents of the class &lt;code&gt;__dict__&lt;/code&gt;: &lt;code&gt;__module__&lt;/code&gt; is there because classes must know where they are defined, and  &lt;code&gt;__dict__&lt;/code&gt; and &lt;code&gt;__weakref__&lt;/code&gt; are there because we don't define &lt;code&gt;__slots__&lt;/code&gt; - if we &lt;a href=&quot;https://stackoverflow.com/q/472000/541136&quot;&gt;define &lt;code&gt;__slots__&lt;/code&gt;&lt;/a&gt; we'll save a bit of space in the instances, as we can disallow &lt;code&gt;__dict__&lt;/code&gt; and &lt;code&gt;__weakref__&lt;/code&gt; by excluding them. For example:</source>
          <target state="translated">（关于类 &lt;code&gt;__dict__&lt;/code&gt; 的 &lt;code&gt;__module__&lt;/code&gt; ： __module__在那里是因为类必须知道它们的定义位置，而 &lt;code&gt;__dict__&lt;/code&gt; 和 &lt;code&gt;__weakref__&lt;/code&gt; 在那里是因为我们没有定义__slots__-如果我们&lt;a href=&quot;https://stackoverflow.com/q/472000/541136&quot;&gt;定义 &lt;code&gt;__slots__&lt;/code&gt; ,&lt;/a&gt;我们将节省一些实例中的空格，因为我们可以通过排除 &lt;code&gt;__dict__&lt;/code&gt; 和 &lt;code&gt;__weakref__&lt;/code&gt; 来禁止它们，例如：</target>
        </trans-unit>
        <trans-unit id="80ce04df15f97539136582b49b933ab604f9103b" translate="yes" xml:space="preserve">
          <source>(I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backwards
compatibility in Python)</source>
          <target state="translated">我知道,同一个函数可以根据你传递给它的参数有两个完全不同的用途,这很傻。这是一个由于Python中的向后兼容性造成的问题)</target>
        </trans-unit>
        <trans-unit id="2ac0d02e51ef16f7af8ae886bdf0e4fa530c5f5d" translate="yes" xml:space="preserve">
          <source>... but I digress.)</source>
          <target state="translated">...但我想说的是)</target>
        </trans-unit>
        <trans-unit id="f6ebd068cb008bd8fb59b8b2729d85510c67060a" translate="yes" xml:space="preserve">
          <source>99% of the time you need class alteration, you are better off using these.</source>
          <target state="translated">99%的情况下,你需要改课的时候,最好用这些东西。</target>
        </trans-unit>
        <trans-unit id="97c9f0c35f46135bb3f31b3babd294116e47cb9e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&lt;/a&gt; (archived at &lt;a href=&quot;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&lt;/a&gt; （存档于&lt;a href=&quot;https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&quot;&gt;https://web.archive.org/web/20080206005253/http://www.onlamp。 com / pub / a / python / 2003/04/17 / metaclasses.html&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="3bdb50500a7c19592bda8809f1f54a3155b055d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclasses&quot;&gt;Here&lt;/a&gt; you can read about how to use metaclasses to customize class construction.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclasses&quot;&gt;在这里，&lt;/a&gt;您可以了解有关如何使用元类自定义类构造的信息。</target>
        </trans-unit>
        <trans-unit id="a50fc3237b1a93efefaaf939cf45f327c9ed165c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__new__&lt;/code&gt; is responsible for the actual creation/modification of the final class.</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; 负责最终课程的实际创建/修改。</target>
        </trans-unit>
        <trans-unit id="1a0d6bf17eaa1810f965cf7374357b165ec381aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__prepare__&lt;/code&gt; lets you supply a custom mapping (such as an &lt;code&gt;OrderedDict&lt;/code&gt;) to be used as the namespace while the class is being created.  You must return an instance of whatever namespace you choose.  If you don't implement &lt;code&gt;__prepare__&lt;/code&gt; a normal &lt;code&gt;dict&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;__prepare__&lt;/code&gt; 允许您提供自定义映射（例如 &lt;code&gt;OrderedDict&lt;/code&gt; ），以在创建类时用作名称空间。 您必须返回选择的任何名称空间的实例。 如果您不执行 &lt;code&gt;__prepare__&lt;/code&gt; ,则使用常规命令。</target>
        </trans-unit>
        <trans-unit id="023d195e822e75fe65a0924f1427b5fdf01fc5ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__prepare__&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;__prepare__&lt;/code&gt; ，以及</target>
        </trans-unit>
        <trans-unit id="7d878c7158652444f7186704c3b33f7141e22209" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; accepts a dictionary to define the attributes of the class. So:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 接受字典来定义类的属性。 所以：</target>
        </trans-unit>
        <trans-unit id="5d2e1c2d0bbec05a50948a1721fe99a3b39aa6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is actually a &lt;code&gt;metaclass&lt;/code&gt; -- a class that creates another classes.
Most &lt;code&gt;metaclass&lt;/code&gt; are the subclasses of &lt;code&gt;type&lt;/code&gt;. The &lt;code&gt;metaclass&lt;/code&gt; receives the &lt;code&gt;new&lt;/code&gt; class as its first argument and provide access to class object with details as mentioned below:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 实际上是一个 &lt;code&gt;metaclass&lt;/code&gt; -创建另一个类的类。 大多数 &lt;code&gt;metaclass&lt;/code&gt; 类是 &lt;code&gt;type&lt;/code&gt; 的子类 。 &lt;code&gt;metaclass&lt;/code&gt; 将 &lt;code&gt;new&lt;/code&gt; 类作为其第一个参数，并提供对类对象的访问，其细节如下所述：</target>
        </trans-unit>
        <trans-unit id="d9eba8487bfc807b1b32e61a4fcc2b4d4099fc9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is actually its own metaclass. This is not something you could
reproduce in pure Python, and is done by cheating a little bit at the implementation
level.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 实际上是它自己的元类。 这不是您可以在纯Python中复制的东西，而是通过在实现级别上作弊来完成的。</target>
        </trans-unit>
        <trans-unit id="55ff24a1972577aa56cf45cfad50fad1fa3a38ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is its own metaclass. The class of a class is a metaclass-- the body of a class is the arguments passed to the metaclass that is used to construct the class.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 是它自己的元类。 类的类是元类-类的主体是传递给用于构造类的元类的参数。</target>
        </trans-unit>
        <trans-unit id="b56139b823c7b0ae94bce907510423f13ee59acc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; is the built-in metaclass Python uses, but of course, you can create your
own metaclass.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 是Python使用的内置元类，但是您当然可以创建自己的元类。</target>
        </trans-unit>
        <trans-unit id="2e9b06716bef6742d220da876612fb09c18a1de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; works this way:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 这种方式工作：</target>
        </trans-unit>
        <trans-unit id="a9b27deb1c48c1688dcbf6153f9703f0928f091b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note, this answer is for Python 2.x as it was written in 2008, metaclasses are slightly different in 3.x.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;请注意，此答案适用于2008年编写的Python 2.x，在3.x中元类略有不同。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90461ec79be347574dc9366bf79436c53a18378b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Python Guru Tim Peters&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Python大师Tim Peters&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaee62583d5533c9937128f100302a2beb82df5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;attrs&lt;/code&gt;&lt;/strong&gt;: dictionary containing attributes names and values</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;attrs&lt;/code&gt; &lt;/strong&gt; ：包含属性名称和值的字典</target>
        </trans-unit>
        <trans-unit id="6b235afc3403ff79e2b3ea50c1ad732bc7d0bc59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;bases&lt;/code&gt;&lt;/strong&gt;: tuple of the parent class (for inheritance, can be empty)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;bases&lt;/code&gt; &lt;/strong&gt; ：父类的元组（对于继承，可以为空）</target>
        </trans-unit>
        <trans-unit id="f9b873798f48e29d3714485763a3478bb4a497d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;name&lt;/code&gt;&lt;/strong&gt;: name of the class</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;name&lt;/code&gt; &lt;/strong&gt; ：班级名称</target>
        </trans-unit>
        <trans-unit id="f7b324be8699a5976c969c726c75d9164d86dcb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that the magic behaviour that &lt;code&gt;Initialised&lt;/code&gt; gains by having the metaclass &lt;code&gt;init_attributes&lt;/code&gt; is not passed onto a subclass of &lt;code&gt;Initialised&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;请注意，通过具有元类 &lt;code&gt;init_attributes&lt;/code&gt; 获得 &lt;code&gt;Initialised&lt;/code&gt; 的魔术行为不会传递给 &lt;code&gt;Initialised&lt;/code&gt; 的子类。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ac292049c7ca4650474b47279520a7d5fdba79f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;:  This example is simple enough it could have also been accomplished with a class decorator, but presumably an actual metaclass would be doing much more.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：该示例非常简单，它也可以使用类装饰器来完成，但是大概一个实际的元类会做更多的事情。</target>
        </trans-unit>
        <trans-unit id="18064ffdb8c53a2819134a580d83cb2c5c9bab27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 3 update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Python 3更新&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fd0a25468fd58988cf36428bbcb7968431bd58e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;type()&lt;/code&gt; of a class is its &lt;em&gt;metaclass&lt;/em&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;类的 &lt;code&gt;type()&lt;/code&gt; 是其&lt;em&gt;元类&lt;/em&gt; 。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c766e32141cfa3130f81de60585eea6ff38f65d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This object (the class) is itself capable of creating objects (the instances),
and this is why it's a class&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;这个对象（类）本身具有创建对象（实例）的能力，这就是为什么它是一个类&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c248c325fb87b5d5270a24375d32cd2c9f65122" translate="yes" xml:space="preserve">
          <source>A bare-bones, do-nothing-extra metaclass would like:</source>
          <target state="translated">一个赤裸裸裸裸裸的,什么都不做的元类会喜欢。</target>
        </trans-unit>
        <trans-unit id="92b4c38772f64c8e05f839618ee864357a996cbf" translate="yes" xml:space="preserve">
          <source>A class is to an instance as a metaclass is to a class.</source>
          <target state="translated">一个类对一个实例来说,就像元类对一个类一样。</target>
        </trans-unit>
        <trans-unit id="0c27db643b5b5e645284c4cc80a9276398d074a2" translate="yes" xml:space="preserve">
          <source>A class, in Python, is an object, and just like any other object, it is an instance of &quot;something&quot;. This &quot;something&quot; is what is termed as a Metaclass. This metaclass is a special type of class that creates other class's objects. Hence, metaclass is responsible for making new classes. This allows the programmer to customize the way classes are generated.</source>
          <target state="translated">在 Python 中,类是一个对象,就像其他对象一样,它是 &quot;东西 &quot;的一个实例。这个 &quot;东西 &quot;就是被称为 Metaclass 的东西。这个元类是一种特殊类型的类,它创建了其他类的对象。因此,metaclass负责创建新的类。这使得程序员可以自定义类的生成方式。</target>
        </trans-unit>
        <trans-unit id="98368b5bba9571afb40d6d81649f78ad6a167a0f" translate="yes" xml:space="preserve">
          <source>A dictionary having all class methods and class variables</source>
          <target state="translated">包含所有类方法和类变量的字典</target>
        </trans-unit>
        <trans-unit id="07bad8c7f891539fd063eae960107658c65808db" translate="yes" xml:space="preserve">
          <source>A metaclass is a class that tells how (some) other class should be created.</source>
          <target state="translated">元类是一个类,它告诉(某些)其他类应该如何创建。</target>
        </trans-unit>
        <trans-unit id="873c9fcb3efb256f101a6622b416b45f928aa997" translate="yes" xml:space="preserve">
          <source>A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;__new__&lt;/code&gt; methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.</source>
          <target state="translated">元类最常用作类工厂。 当您通过调用类创建对象时，Python通过调用元类来创建一个新类（执行&amp;ldquo; class&amp;rdquo;语句时）。 因此，与常规的 &lt;code&gt;__init__&lt;/code&gt; 和 &lt;code&gt;__new__&lt;/code&gt; 方法结合使用，元类可以让您在创建类时做&amp;ldquo;额外的事情&amp;rdquo;，例如使用某些注册表注册新类或将其完全替换为其他类。</target>
        </trans-unit>
        <trans-unit id="3486e865599100d4c2f2690dc8d832dc90595e5c" translate="yes" xml:space="preserve">
          <source>A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.</source>
          <target state="translated">元类就是类的类。类定义了类的实例(即对象)的行为方式,而元类定义了类的行为方式。一个类是元类的一个实例。</target>
        </trans-unit>
        <trans-unit id="4ea4880d366e98584d6186c7ff37dd31a7e3a934" translate="yes" xml:space="preserve">
          <source>A sample run of:</source>
          <target state="translated">抽查了一下:</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="abaef223fba357f5e679cf230585920e62f69619" translate="yes" xml:space="preserve">
          <source>A simple metaclass can address that problem:</source>
          <target state="translated">一个简单的元类可以解决这个问题。</target>
        </trans-unit>
        <trans-unit id="f9675ef41670c1a7e08847654b4300f2976b5bd7" translate="yes" xml:space="preserve">
          <source>According to the Python object model, the class is the object, so the class must be an instance of another certain class.
By default, a Python class is instance of the type class. That is, type is metaclass of most of the built-in classes and metaclass of user-defined classes.</source>
          <target state="translated">根据Python对象模型,类就是对象,所以类必须是另一个特定类的实例。默认情况下,Python类是type类的实例。也就是说,type是大多数内置类的元类,也是用户定义类的元类。</target>
        </trans-unit>
        <trans-unit id="4adff09b65f995e39fb598615865ea22fe246c14" translate="yes" xml:space="preserve">
          <source>An expected usage: &lt;code&gt;__prepare__&lt;/code&gt; a namespace</source>
          <target state="translated">预期的用法： &lt;code&gt;__prepare__&lt;/code&gt; 名称空间</target>
        </trans-unit>
        <trans-unit id="53beca7540dd22467058afe2ce16662999fefed8" translate="yes" xml:space="preserve">
          <source>And it has approximately the correct &lt;code&gt;repr&lt;/code&gt; (which we can no longer eval unless we can find a way to represent our functions.):</source>
          <target state="translated">而且它大约具有正确的 &lt;code&gt;repr&lt;/code&gt; （除非找到能够表示功能的方法，否则我们将无法再评估）：</target>
        </trans-unit>
        <trans-unit id="ce4bfa8f5c082d4fff81df807663be51c7c917c2" translate="yes" xml:space="preserve">
          <source>And now let's create an instance of &lt;code&gt;Class_1&lt;/code&gt;</source>
          <target state="translated">现在让我们创建 &lt;code&gt;Class_1&lt;/code&gt; 的实例</target>
        </trans-unit>
        <trans-unit id="5bf68fb2be7839bf9d1dd84adfe71a7440908b18" translate="yes" xml:space="preserve">
          <source>And now we have a record of the order in which these methods (and other class attributes) were created:</source>
          <target state="translated">而现在我们有了这些方法(和其他类属性)创建的顺序记录。</target>
        </trans-unit>
        <trans-unit id="4ca06910faa36e6b2502325b8ed3b633d8e2df95" translate="yes" xml:space="preserve">
          <source>And now, an example that actually means something, this will automatically make the variables in the list &quot;attributes&quot; set on the class, and set to None.</source>
          <target state="translated">而现在,举一个实际意义的例子,这将使列表中的变量 &quot;属性 &quot;中的变量自动设置在类上,并设置为None。</target>
        </trans-unit>
        <trans-unit id="9ab311e6c0f38e17cbdcfba4ac88667451f90d25" translate="yes" xml:space="preserve">
          <source>And of course, you can inherit from it, so:</source>
          <target state="translated">当然,你也可以从中继承,所以。</target>
        </trans-unit>
        <trans-unit id="72e4dbbed8155cf6d13a6faec1d3c917549c55be" translate="yes" xml:space="preserve">
          <source>And usage:</source>
          <target state="translated">和用途。</target>
        </trans-unit>
        <trans-unit id="0d4a22c47e425bea8ea588e394d41d40ede76cb4" translate="yes" xml:space="preserve">
          <source>And used as a normal class:</source>
          <target state="translated">并作为普通类使用。</target>
        </trans-unit>
        <trans-unit id="d11b95735f7ea9c7ca4cdd3c0cc7d13b93d2b46f" translate="yes" xml:space="preserve">
          <source>And what can create a class? &lt;code&gt;type&lt;/code&gt;, or anything that subclasses or uses it.</source>
          <target state="translated">什么可以创建一个类？ &lt;code&gt;type&lt;/code&gt; ，或任何子类化或使用它的东西。</target>
        </trans-unit>
        <trans-unit id="649539847a08116b173bc0337d0fca037b42617c" translate="yes" xml:space="preserve">
          <source>And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.</source>
          <target state="translated">而且你可以在动态创建类后添加更多的方法,就像给正常创建的类对象添加方法一样。</target>
        </trans-unit>
        <trans-unit id="530eddb18915c39bc5dcde4a3a20f4402846be8a" translate="yes" xml:space="preserve">
          <source>And, of course, you can create your own &lt;code&gt;metaclass&lt;/code&gt; to define the behaviour of any class that are created using your class.</source>
          <target state="translated">并且，当然，您可以创建自己的 &lt;code&gt;metaclass&lt;/code&gt; 来定义使用该类创建的任何类的行为。</target>
        </trans-unit>
        <trans-unit id="65df52390d32d6445d153fc0a9ee8f28f45c2439" translate="yes" xml:space="preserve">
          <source>Another way of creating a metaclass comprises of 'metaclass' keyword. Define the metaclass as a simple class. In the parameters of inherited class, pass metaclass=metaclass_name</source>
          <target state="translated">另一种创建元类的方法包括 &quot;元类 &quot;关键字。定义metaclass为一个简单的类。在继承类的参数中,传递metaclass=metaclass_name</target>
        </trans-unit>
        <trans-unit id="f4b130a19c5f693fbbf062ec80d3671ef783f1ea" translate="yes" xml:space="preserve">
          <source>Anything that's a subclass of &lt;code&gt;MyType&lt;/code&gt; then gets a class attribute &lt;code&gt;_order&lt;/code&gt; that records the order in which the classes were defined.</source>
          <target state="translated">然后，任何属于 &lt;code&gt;MyType&lt;/code&gt; 的子类都将获得一个类属性 &lt;code&gt;_order&lt;/code&gt; ，该属性记录了定义类的顺序。</target>
        </trans-unit>
        <trans-unit id="39af72b7c646d137c090c578f75c34590856559b" translate="yes" xml:space="preserve">
          <source>As soon as you use the keyword &lt;code&gt;class&lt;/code&gt;, Python executes it and creates
an OBJECT. The instruction</source>
          <target state="translated">一旦使用关键字 &lt;code&gt;class&lt;/code&gt; ，Python就会执行它并创建一个对象。 指令</target>
        </trans-unit>
        <trans-unit id="2bbce40d7b29697d5feb257ab36b2c9ef937448a" translate="yes" xml:space="preserve">
          <source>As you can see, you have to repeat the name of the attribute twice.  This makes typos possible along with irritating bugs.</source>
          <target state="translated">正如你所看到的,你必须重复两次属性的名称。这使得打字错误和恼人的BUG成为可能。</target>
        </trans-unit>
        <trans-unit id="9956578f1491cba6ae62da4a5182369af56ec1ea" translate="yes" xml:space="preserve">
          <source>Automatic change of class (on creation) is required</source>
          <target state="translated">需要自动更改类别(创建时)。</target>
        </trans-unit>
        <trans-unit id="a0904b4d0a120872451f6708177857cd4876a29b" translate="yes" xml:space="preserve">
          <source>Be careful here that the &lt;code&gt;__metaclass__&lt;/code&gt; attribute will not be inherited, the metaclass of the parent (&lt;code&gt;Bar.__class__&lt;/code&gt;) will be. If &lt;code&gt;Bar&lt;/code&gt; used a &lt;code&gt;__metaclass__&lt;/code&gt; attribute that created &lt;code&gt;Bar&lt;/code&gt; with &lt;code&gt;type()&lt;/code&gt; (and not &lt;code&gt;type.__new__()&lt;/code&gt;), the subclasses will not inherit that behavior.</source>
          <target state="translated">这里要小心，不要继承 &lt;code&gt;__metaclass__&lt;/code&gt; 属性，父类的元类（ &lt;code&gt;Bar.__class__&lt;/code&gt; ）将被继承。 如果 &lt;code&gt;Bar&lt;/code&gt; 使用 &lt;code&gt;__metaclass__&lt;/code&gt; 属性创建了带有 &lt;code&gt;type()&lt;/code&gt; 的 &lt;code&gt;Bar&lt;/code&gt; （而不是 &lt;code&gt;type.__new__()&lt;/code&gt; ），则子类将不会继承该行为。</target>
        </trans-unit>
        <trans-unit id="80625100761a15802531450282948dc4d9d74c05" translate="yes" xml:space="preserve">
          <source>Before understanding metaclasses, you need to master classes in Python. And Python has a very peculiar idea of what classes are, borrowed from the Smalltalk language.</source>
          <target state="translated">在了解metaclasses之前,你需要先掌握Python中的类。而Python对于类有一个非常奇特的概念,它是从Smalltalk语言中借用过来的。</target>
        </trans-unit>
        <trans-unit id="6a2ed346f5d5ae803e927c67a0b729ccdfc1ac42" translate="yes" xml:space="preserve">
          <source>But 98% of the time, you don't need class alteration at all.</source>
          <target state="translated">但98%的时候,你根本不需要阶级改造。</target>
        </trans-unit>
        <trans-unit id="217006127ae3f18c4bd2c902e86bbb02d1e2be15" translate="yes" xml:space="preserve">
          <source>But classes are more than that in Python. Classes are objects too.</source>
          <target state="translated">但在Python中,类不仅仅是这样。类也是对象。</target>
        </trans-unit>
        <trans-unit id="c6925819c7efe04fd6c3ab39f7eb68854e9cde4a" translate="yes" xml:space="preserve">
          <source>But if you do this:</source>
          <target state="translated">但如果你这样做的话。</target>
        </trans-unit>
        <trans-unit id="ef4914127f447e16a1796467ee1b0bb970abd2e5" translate="yes" xml:space="preserve">
          <source>But it's not so dynamic, since you still have to write the whole class yourself.</source>
          <target state="translated">但也没那么灵动,因为还是要自己写整堂课的内容。</target>
        </trans-unit>
        <trans-unit id="3f48f38ce849fd78c7a275acf29a06ca3a0397d9" translate="yes" xml:space="preserve">
          <source>But still, it's an object, and therefore:</source>
          <target state="translated">但是,仍然是一个对象,因此。</target>
        </trans-unit>
        <trans-unit id="3b16fb856b8f2d6a24ccdf8c533162de4f2a2b85" translate="yes" xml:space="preserve">
          <source>But this is not proper OOP. We are calling &lt;code&gt;type&lt;/code&gt; directly and we aren't overriding or calling the parent's &lt;code&gt;__new__&lt;/code&gt;. Let's do that instead:</source>
          <target state="translated">但这不是适当的OOP。 我们直接调用 &lt;code&gt;type&lt;/code&gt; ，而不是覆盖或调用父级的 &lt;code&gt;__new__&lt;/code&gt; 。 让我们改为：</target>
        </trans-unit>
        <trans-unit id="bca74e7aa7842dd7785f6fa3e79fd35320fecfb0" translate="yes" xml:space="preserve">
          <source>But we learned that Python classes are objects.</source>
          <target state="translated">但我们了解到Python类是对象。</target>
        </trans-unit>
        <trans-unit id="9da0aa54f4f4de88a9f5b6ed8d8101a2c5efd27f" translate="yes" xml:space="preserve">
          <source>By API developers</source>
          <target state="translated">由API开发人员提供</target>
        </trans-unit>
        <trans-unit id="b4df2ba03eab94130e4fd06a9c5054fa64ad06cd" translate="yes" xml:space="preserve">
          <source>Can be translated to:</source>
          <target state="translated">可以翻译成:</target>
        </trans-unit>
        <trans-unit id="334466b784281739a3c38583b4c063fdc0aba559" translate="yes" xml:space="preserve">
          <source>Careful, it's tricky.</source>
          <target state="translated">小心点,这很棘手。</target>
        </trans-unit>
        <trans-unit id="23e735f2e42f0ee01fd065b66b276180dd776b09" translate="yes" xml:space="preserve">
          <source>Class Name</source>
          <target state="translated">班级名称</target>
        </trans-unit>
        <trans-unit id="67581e4d912d7924cb46e54e6204e5fcc51399f9" translate="yes" xml:space="preserve">
          <source>Classes as objects</source>
          <target state="translated">作为对象的类</target>
        </trans-unit>
        <trans-unit id="2a6d4b43aad00a6ba23618dd38abe34e6ccdd450" translate="yes" xml:space="preserve">
          <source>Creating a new model</source>
          <target state="translated">创建一个新模式</target>
        </trans-unit>
        <trans-unit id="9d277645538f63f2b9666091e215ce0c2c94b67c" translate="yes" xml:space="preserve">
          <source>Creating classes dynamically</source>
          <target state="translated">动态创建类</target>
        </trans-unit>
        <trans-unit id="a5890931814483d070ece2ba611db02e74fa66fb" translate="yes" xml:space="preserve">
          <source>Custom metaclasses</source>
          <target state="translated">自定义元类</target>
        </trans-unit>
        <trans-unit id="3583495fe771aa17938b325299e9568902990630" translate="yes" xml:space="preserve">
          <source>Django makes something complex look simple by exposing a simple API
and using metaclasses, recreating code from this API to do the real job
behind the scenes.</source>
          <target state="translated">Django通过暴露出一个简单的API,并使用metaclasses,从这个API中重新创建代码来完成真正的幕后工作,从而使复杂的东西看起来很简单。</target>
        </trans-unit>
        <trans-unit id="0c2efb2ec65dc0aa53f18cfb1abd5f87fcb64df6" translate="yes" xml:space="preserve">
          <source>Eventually you'll want to add methods to your class. Just define a function
with the proper signature and assign it as an attribute.</source>
          <target state="translated">最终,你会想在你的类中添加方法。只需定义一个函数,并将其作为一个属性分配给你的类。</target>
        </trans-unit>
        <trans-unit id="07cbe8c7c80e4f1f64a5bbbd7a413d143a41a369" translate="yes" xml:space="preserve">
          <source>Everything is an object in Python, and they are all either instances of classes
or instances of metaclasses.</source>
          <target state="translated">在 Python 中,所有的东西都是一个对象,它们都是类的实例或元类的实例。</target>
        </trans-unit>
        <trans-unit id="8fd816dd026cb3639455418c4ec1f8fa0fe97cd2" translate="yes" xml:space="preserve">
          <source>Everything, and I mean everything, is an object in Python. That includes ints,
strings, functions and classes. All of them are objects. And all of them have
been created from a class:</source>
          <target state="translated">所有的东西,我指的是所有的东西,在 Python 中都是一个对象。这包括 ints、字符串、函数和类。所有这些都是对象。而所有这些东西都是从类中产生的。</target>
        </trans-unit>
        <trans-unit id="673604a3dfb5c3ee8e65923cb90776673fb75935" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="ff75c36a00faaeb29de73a493ffe4e766d3c9c95" translate="yes" xml:space="preserve">
          <source>First, you can create a class in a function using &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">首先，您可以使用class在函数中创建一个 &lt;code&gt;class&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b279b3945b4d05b8b08bfb5dd600595061650654" translate="yes" xml:space="preserve">
          <source>First, you know that classes are objects that can create instances.</source>
          <target state="translated">首先,要知道类是可以创建实例的对象。</target>
        </trans-unit>
        <trans-unit id="0afa5be4efcb2364e68a5fbe4c217e7cc8946f64" translate="yes" xml:space="preserve">
          <source>For doing that, your default &lt;code&gt;metaclass&lt;/code&gt; type class must be inherited as this is the main &lt;code&gt;metaclass&lt;/code&gt;:</source>
          <target state="translated">为此，必须继承默认的 &lt;code&gt;metaclass&lt;/code&gt; 类型类，因为这是主要的 &lt;code&gt;metaclass&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="64d1e55feb37865331973d2697ad8c261c0e1af4" translate="yes" xml:space="preserve">
          <source>For example, if you look at &lt;a href=&quot;http://docs.djangoproject.com/en/dev/topics/db/models/&quot;&gt;Django models&lt;/a&gt;, their definition looks a bit confusing. It looks as if you are only defining class properties:</source>
          <target state="translated">例如，如果您查看&lt;a href=&quot;http://docs.djangoproject.com/en/dev/topics/db/models/&quot;&gt;Django模型&lt;/a&gt; ，则其定义看起来有些混乱。 似乎您只是在定义类属性：</target>
        </trans-unit>
        <trans-unit id="fe22872a0b690652860e20740774999a464ef779" translate="yes" xml:space="preserve">
          <source>From the above it stems that the metaclass' &lt;code&gt;__call__()&lt;/code&gt; is also given the opportunity to decide whether or not a call to &lt;code&gt;Class_1.__new__()&lt;/code&gt; or &lt;code&gt;Class_1.__init__()&lt;/code&gt; will eventually be made. Over the course of its execution it could actually return an object that hasn't been touched by either of these methods. Take for example this approach to the singleton pattern:</source>
          <target state="translated">从上面可以得出结论，元类的 &lt;code&gt;__call__()&lt;/code&gt; 也有机会决定是否最终对 &lt;code&gt;Class_1.__new__()&lt;/code&gt; 或 &lt;code&gt;Class_1.__init__()&lt;/code&gt; 进行调用。 在执行过程中，它实际上可能返回一个未被这两种方法触及的对象。 以这种单例模式的方法为例：</target>
        </trans-unit>
        <trans-unit id="019ad28a21f071a1a1c801c23bffdedde5c57127" translate="yes" xml:space="preserve">
          <source>Here is an even more concrete example, showing how you can subclass 'type' to make a metaclass that performs an action when the class is created. This is quite tricky:</source>
          <target state="translated">这里有一个更具体的例子,展示了如何在类被创建时,子类'type'来创建一个元类来执行一个动作。这是个相当棘手的问题。</target>
        </trans-unit>
        <trans-unit id="89a9dab91d6a0e821bd0d8857c7afd11ec41324d" translate="yes" xml:space="preserve">
          <source>Here is where the secret starts. Look for where name, bases and the dict come from in this example class definition.</source>
          <target state="translated">秘密就从这里开始了。在这个示例类的定义中寻找名称、base和dict的来源。</target>
        </trans-unit>
        <trans-unit id="933820812619c6ea7008cbcf3a5bef8f52f428f5" translate="yes" xml:space="preserve">
          <source>Here's an aggregated example of the bits and pieces:</source>
          <target state="translated">下面是一个汇总的零碎的例子。</target>
        </trans-unit>
        <trans-unit id="c7172cb8e50347e53ec2a1c70cf3f132135b13bb" translate="yes" xml:space="preserve">
          <source>Here's another example of what it can be used for:</source>
          <target state="translated">这里再举一个例子,说明它可以用来做什么。</target>
        </trans-unit>
        <trans-unit id="b92f66963c22e5d12229c7c1ff474ff5ca10c558" translate="yes" xml:space="preserve">
          <source>Here's the default &lt;code&gt;__repr__&lt;/code&gt; of classes:</source>
          <target state="translated">这是默认的 &lt;code&gt;__repr__&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="da679ef3b897db5427c2dd4128c089961c066bc2" translate="yes" xml:space="preserve">
          <source>However, at runtime the Person objects are filled with all sorts of useful methods. See the &lt;a href=&quot;http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py&quot;&gt;source&lt;/a&gt; for some amazing metaclassery.</source>
          <target state="translated">但是，在运行时，Person对象充满了各种有用的方法。 请参阅&lt;a href=&quot;http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py&quot;&gt;源代码&lt;/a&gt;中一些惊人的元类。</target>
        </trans-unit>
        <trans-unit id="3687f11b0c4210b7d9c0b35a3e13741dc07a26f7" translate="yes" xml:space="preserve">
          <source>However, metaclasses actually define the &lt;em&gt;type&lt;/em&gt; of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. &lt;code&gt;type.__subclasses__()&lt;/code&gt; is an example of a method on the &lt;code&gt;type&lt;/code&gt; metaclass. You can also define the normal 'magic' methods, like &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__iter__&lt;/code&gt; and &lt;code&gt;__getattr__&lt;/code&gt;, to implement or change how the class behaves.</source>
          <target state="translated">但是，元类实际上定义了类的&lt;em&gt;类型&lt;/em&gt; ，而不仅仅是它的工厂，因此您可以使用它们做更多的事情。 例如，您可以在元类上定义常规方法。 这些元类方法类似于类方法，因为它们可以在没有实例的情况下在类上调用，但是它们也不像类方法，因为它们不能在类的实例上被调用。 &lt;code&gt;type.__subclasses__()&lt;/code&gt; 是 &lt;code&gt;type&lt;/code&gt; 元类上方法的示例。 您还可以定义常规的&amp;ldquo;魔术&amp;rdquo;方法，例如 &lt;code&gt;__add__&lt;/code&gt; &lt;code&gt;__iter__&lt;/code&gt; ， &lt;code&gt;__getattr__&lt;/code&gt; iter__和__getattr__ ，以实现或更改类的行为。</target>
        </trans-unit>
        <trans-unit id="4fa00b7305761f3d48d74e2fcaa87d88b46b8653" translate="yes" xml:space="preserve">
          <source>I think the ONLamp introduction to metaclass programming is well written and gives a really good introduction to the topic despite being several years old already.</source>
          <target state="translated">我认为ONLamp的元类编程介绍写得很好,尽管已经有好几年的历史了,但还是给了一个非常好的主题介绍。</target>
        </trans-unit>
        <trans-unit id="5de71cb6474da6bbfd1892d86a39743c6e1f7a0d" translate="yes" xml:space="preserve">
          <source>I've never written one myself, but I think one of the nicest uses of metaclasses can be seen in the &lt;a href=&quot;http://www.djangoproject.com/&quot;&gt;Django framework&lt;/a&gt;. The model classes use a metaclass approach to enable a declarative style of writing new models or form classes. While the metaclass is creating the class, all members get the possibility to customize the class itself.</source>
          <target state="translated">我从来没有自己写过书，但是我认为在&lt;a href=&quot;http://www.djangoproject.com/&quot;&gt;Django框架中&lt;/a&gt;可以看到元类最好的用途之一。 模型类使用元类方法来启用声明性样式，以编写新模型或表单类。 当元类创建类时，所有成员都可以自定义类本身。</target>
        </trans-unit>
        <trans-unit id="d4a30d2f2ca2899fa19429f58792d2d3e210fba9" translate="yes" xml:space="preserve">
          <source>If Python can't find &lt;code&gt;__metaclass__&lt;/code&gt;, it will look for a &lt;code&gt;__metaclass__&lt;/code&gt; at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes).</source>
          <target state="translated">如果Python找不到 &lt;code&gt;__metaclass__&lt;/code&gt; ，它将在MODULE级别上寻找__metaclass__ ，并尝试做同样的事情（但仅适用于不继承任何内容的类，基本上是老式的类）。</target>
        </trans-unit>
        <trans-unit id="b2c247f997e1856448d121b399db1ce401dfe052" translate="yes" xml:space="preserve">
          <source>If yes, create in memory a class object (I said a class object, stay with me here), with the name &lt;code&gt;Foo&lt;/code&gt; by using what is in &lt;code&gt;__metaclass__&lt;/code&gt;.</source>
          <target state="translated">如果是，请使用 &lt;code&gt;__metaclass__&lt;/code&gt; 中的名称在内存中创建一个名为 &lt;code&gt;Foo&lt;/code&gt; 的类对象（我说一个类对象，在这里呆着） 。</target>
        </trans-unit>
        <trans-unit id="1c4ed3e469d021631b88778db056f898cbd3075a" translate="yes" xml:space="preserve">
          <source>If you do so, Python will use the metaclass to create the class &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">如果这样做，Python将使用该元类创建类 &lt;code&gt;Foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d569392d6709098664ec3f652636842d8ae2fd08" translate="yes" xml:space="preserve">
          <source>If you've done Python programming for more than a few months you'll eventually stumble upon code that looks like this:</source>
          <target state="translated">如果你做了几个月以上的Python编程,你最终会发现代码看起来像这样。</target>
        </trans-unit>
        <trans-unit id="8ffaab56641a084b45859b1b16c94f6d85871567" translate="yes" xml:space="preserve">
          <source>If, for example, we want to know in what order a class's methods are created in, we could provide an ordered dict as the namespace of the class. We would do this with &lt;code&gt;__prepare__&lt;/code&gt; which &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace&quot;&gt;returns the namespace dict for the class if it is implemented in Python 3&lt;/a&gt;:</source>
          <target state="translated">例如，如果我们想知道类的方法以什么顺序创建，则可以提供一个有序的dict作为类的名称空间。 我们将使用 &lt;code&gt;__prepare__&lt;/code&gt; 进行此操作， &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace&quot;&gt;如果该类是在Python 3中实现的，&lt;/a&gt;它将返回该类的名称空间dict ：</target>
        </trans-unit>
        <trans-unit id="0ddfbe7f84c69375a34cda89908ad9181be61fdd" translate="yes" xml:space="preserve">
          <source>Imagine a stupid example, where you decide that all classes in your module
should have their attributes written in uppercase. There are several ways to
do this, but one way is to set &lt;code&gt;__metaclass__&lt;/code&gt; at the module level.</source>
          <target state="translated">想象一个愚蠢的示例，在该示例中，您决定模块中的所有类的属性都应大写。 有多种方法可以执行此操作，但是一种方法是在模块级别设置 &lt;code&gt;__metaclass__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91a6aa8c8b6a75378372d8ea48354d684c37eb6b" translate="yes" xml:space="preserve">
          <source>In Python 2, you can add a &lt;code&gt;__metaclass__&lt;/code&gt; attribute when you write a class (see next section for the Python 3 syntax):</source>
          <target state="translated">在Python 2中，您可以在编写类时添加 &lt;code&gt;__metaclass__&lt;/code&gt; 属性（有关Python 3语法，请参见下一部分）：</target>
        </trans-unit>
        <trans-unit id="7e651e9d51572a5346d5e0e8610271f23aa0d208" translate="yes" xml:space="preserve">
          <source>In Python, what are metaclasses and what do we use them for?</source>
          <target state="translated">在Python中,什么是元类,我们用它们来做什么?</target>
        </trans-unit>
        <trans-unit id="4650ac989c9d3329e40be1c6ab845b25d2070a47" translate="yes" xml:space="preserve">
          <source>In addition to the published answers I can say that a &lt;code&gt;metaclass&lt;/code&gt; defines the behaviour for a class. So, you can explicitly set your metaclass. Whenever Python gets a keyword &lt;code&gt;class&lt;/code&gt; then it starts searching for the &lt;code&gt;metaclass&lt;/code&gt;. If it's not found &amp;ndash; the default metaclass type is used to create the class's object. Using the &lt;code&gt;__metaclass__&lt;/code&gt; attribute, you can set &lt;code&gt;metaclass&lt;/code&gt; of your class:</source>
          <target state="translated">除了已发布的答案，我可以说 &lt;code&gt;metaclass&lt;/code&gt; 定义了类的行为。 因此，您可以显式设置您的元类。 每当Python获得关键字 &lt;code&gt;class&lt;/code&gt; 它就会开始搜索 &lt;code&gt;metaclass&lt;/code&gt; 。 如果找不到，则使用默认的元类类型创建类的对象。 使用 &lt;code&gt;__metaclass__&lt;/code&gt; 属性，可以设置 &lt;code&gt;metaclass&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="c35d9935b1a444e907c91e37c19879d0759a37ba" translate="yes" xml:space="preserve">
          <source>In addition to using type() to create classes dynamically, you can control creation behavior of class and use metaclass.</source>
          <target state="translated">除了使用type()动态创建类外,还可以控制类的创建行为,使用metaclass。</target>
        </trans-unit>
        <trans-unit id="4a7677010e3a9723dd238a2332a0b15302776bce" translate="yes" xml:space="preserve">
          <source>In most languages, classes are just pieces of code that describe how to produce an object. That's kinda true in Python too:</source>
          <target state="translated">在大多数语言中,类只是描述如何产生一个对象的代码片段。在 Python 中也是这样。</target>
        </trans-unit>
        <trans-unit id="fa72180e3995db72ed5f698c8ee07149c8c3a22b" translate="yes" xml:space="preserve">
          <source>In object-oriented programming, a metaclass is a class whose instances are classes. Just as an ordinary class defines the behavior of certain objects, a metaclass defines the behavior of certain class and their instances
The term metaclass simply means something used to create classes. In other words, it is the class of a class. The metaclass is used to create the class so like the object being an instance of a class, a class is an instance of a metaclass. In python classes are also considered objects.</source>
          <target state="translated">在面向对象编程中,元类是一个类,其实例是类。正如普通类定义了某些对象的行为一样,元类也定义了某些类及其实例的行为 元类这个词只是指用来创建类的东西。换句话说,它就是类的类。元类是用来创建类的,所以就像对象是类的一个实例一样,类也是元类的一个实例。在python中,类也被认为是对象。</target>
        </trans-unit>
        <trans-unit id="2e61694f68b17195f1c41dbc03080f71c6ec3509" translate="yes" xml:space="preserve">
          <source>In real code, we can pass the default metaclass, &lt;code&gt;type&lt;/code&gt;, everything we need to instantiate a class and we get a class:</source>
          <target state="translated">在实际代码中，我们可以传递默认的元类 &lt;code&gt;type&lt;/code&gt; ，以实例化一个类并获得一个类所需的一切：</target>
        </trans-unit>
        <trans-unit id="6cde1b05c392829cf0748f367e1a5f3cc79ef8e7" translate="yes" xml:space="preserve">
          <source>In short: A class is a blueprint for the creation of an instance, a metaclass is a blueprint for the creation of a class. It can be easily seen that in Python classes need to be first-class objects too to enable this behavior.</source>
          <target state="translated">简而言之:类是创建实例的蓝图,元类是创建类的蓝图。不难看出,在Python中,类也需要是一级对象才能实现这种行为。</target>
        </trans-unit>
        <trans-unit id="0dcf456ed380c367ea7337a047070feeb2404ac6" translate="yes" xml:space="preserve">
          <source>Indeed, metaclasses are especially useful to do black magic, and therefore
complicated stuff. But by themselves, they are simple:</source>
          <target state="translated">的确,元神类在做黑魔法时特别有用,因此也是很复杂的东西。但就其本身而言,却很简单。</target>
        </trans-unit>
        <trans-unit id="e6acf61863b31d67d149b4e6ca40eee6b1199fa9" translate="yes" xml:space="preserve">
          <source>Is there a &lt;code&gt;__metaclass__&lt;/code&gt; attribute in &lt;code&gt;Foo&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 中是否有 &lt;code&gt;__metaclass__&lt;/code&gt; 属性？</target>
        </trans-unit>
        <trans-unit id="8b238ceb9e5599e813e4358cf7862918d33b97b1" translate="yes" xml:space="preserve">
          <source>It is the same as functionally calling &lt;code&gt;type&lt;/code&gt; with the appropriate arguments and assigning the result to a variable of that name:</source>
          <target state="translated">它与带有适当参数的函数调用 &lt;code&gt;type&lt;/code&gt; 相同，并将结果分配给该名称的变量相同：</target>
        </trans-unit>
        <trans-unit id="0f552d4e543041b1701247e77678f01050c07d0e" translate="yes" xml:space="preserve">
          <source>It translates to this in the metaclass to use it:</source>
          <target state="translated">翻译成这样,在metaclass中使用它。</target>
        </trans-unit>
        <trans-unit id="c7ba3c56dd302201c8d63fd76926944ea19006b4" translate="yes" xml:space="preserve">
          <source>It won't return an &lt;code&gt;IntegerField&lt;/code&gt; object. It will return an &lt;code&gt;int&lt;/code&gt;, and can even take it directly from the database.</source>
          <target state="translated">它不会返回 &lt;code&gt;IntegerField&lt;/code&gt; 对象。 它会返回一个 &lt;code&gt;int&lt;/code&gt; ，甚至可以直接从数据库中获取它。</target>
        </trans-unit>
        <trans-unit id="d8d805048c69fa736de925d3367248b04c361716" translate="yes" xml:space="preserve">
          <source>It'll produce the output like this:</source>
          <target state="translated">它会产生这样的输出。</target>
        </trans-unit>
        <trans-unit id="7cf1c9cf775a5387c4ff94bd47121db2b5c988dd" translate="yes" xml:space="preserve">
          <source>It's because the function &lt;code&gt;type&lt;/code&gt; is in fact a metaclass. &lt;code&gt;type&lt;/code&gt; is the
metaclass Python uses to create all classes behind the scenes.</source>
          <target state="translated">这是因为函数 &lt;code&gt;type&lt;/code&gt; 实际上是一个元类。 &lt;code&gt;type&lt;/code&gt; 是Python用于在幕后创建所有类的元类。</target>
        </trans-unit>
        <trans-unit id="b762e9c56bf18ad7968cf2abfa72dfb4cd610a39" translate="yes" xml:space="preserve">
          <source>Just as we can use class definitions to change how custom object instances behave, we can use a metaclass class definition to change the way a class object behaves.</source>
          <target state="translated">就像我们可以使用类定义来改变自定义对象实例的行为方式一样,我们也可以使用元类定义来改变类对象的行为方式。</target>
        </trans-unit>
        <trans-unit id="12861900e6ee5fc644f17e214205bf98f2b552b1" translate="yes" xml:space="preserve">
          <source>Let's check:</source>
          <target state="translated">我们来检查一下。</target>
        </trans-unit>
        <trans-unit id="e24b773897b7eab9e5ea3419aecc80a071b54a96" translate="yes" xml:space="preserve">
          <source>Let's observe what happens when repeatedly trying to create an object of type &lt;code&gt;Class_2&lt;/code&gt;</source>
          <target state="translated">让我们观察一下，反复尝试创建 &lt;code&gt;Class_2&lt;/code&gt; 类型的对象时会发生什么</target>
        </trans-unit>
        <trans-unit id="0d3e22e4d5a330681408b9b810a86a368c8150f7" translate="yes" xml:space="preserve">
          <source>Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean:</source>
          <target state="translated">让我们重写上面的内容,但现在我们知道了变量的含义,就用更短、更符合实际的变量名。</target>
        </trans-unit>
        <trans-unit id="bae90bb62607735e9b7e3a157dc8431c62f56161" translate="yes" xml:space="preserve">
          <source>Let's study the method call chain from specifically the perspective of creating an instance of a class.</source>
          <target state="translated">我们具体从创建一个类的实例的角度来研究方法调用链。</target>
        </trans-unit>
        <trans-unit id="045e68d2ed13507db1ee3f048ec03ec22ab6a6b4" translate="yes" xml:space="preserve">
          <source>Lets define a metaclass that will demonstrate how '&lt;strong&gt;class:&lt;/strong&gt;' calls it.</source>
          <target state="translated">让我们定义一个元类，该元类将演示&amp;ldquo; &lt;strong&gt;class：&lt;/strong&gt; &amp;rdquo;如何调用它。</target>
        </trans-unit>
        <trans-unit id="320371557536a1d1e98f35433ae20c51e9eed7fc" translate="yes" xml:space="preserve">
          <source>Likewise, when we define a class explicitly with the default metaclass, &lt;code&gt;type&lt;/code&gt;, we instantiate it:</source>
          <target state="translated">同样，当我们使用默认的元类显式定义一个类时，我们实例化它：</target>
        </trans-unit>
        <trans-unit id="dd4270596259e170c6cba8ca00280d127d29899d" translate="yes" xml:space="preserve">
          <source>Luckily, &lt;code&gt;__metaclass__&lt;/code&gt; can actually be any callable, it doesn't need to be a
formal class (I know, something with 'class' in its name doesn't need to be
a class, go figure... but it's helpful).</source>
          <target state="translated">幸运的是， &lt;code&gt;__metaclass__&lt;/code&gt; 实际上可以是任何可调用的，它不必是正式的类（我知道，名称中带有&amp;ldquo; class&amp;rdquo;的东西不必是类，请弄清楚&amp;hellip;&amp;hellip;但这很有用）。</target>
        </trans-unit>
        <trans-unit id="a84965b59c86adeaf5175c77b1367ae45a51beca" translate="yes" xml:space="preserve">
          <source>Magic will take effect when we passed keyword arguments in metaclass, it indicates the Python interpreter to create the CustomList through ListMetaclass. &lt;strong&gt;new&lt;/strong&gt; (), at this point, we can modify the class definition, for example, and add a new method and then return the revised definition.</source>
          <target state="translated">当我们在元类中传递关键字参数时，Magic才会生效，它指示Python解释器通过ListMetaclass创建CustomList。 &lt;strong&gt;new&lt;/strong&gt; （），此时，我们可以例如修改类定义，并添加新方法，然后返回修改后的定义。</target>
        </trans-unit>
        <trans-unit id="5fe9adb504d86047cca71de452afe1639b04cca8" translate="yes" xml:space="preserve">
          <source>Metaclass can be specifically used in the following situations :-</source>
          <target state="translated">元类可以专门用于以下情况:--</target>
        </trans-unit>
        <trans-unit id="3af05144e3743c95c5ae229f63e24413fd772f08" translate="yes" xml:space="preserve">
          <source>Metaclass is a kind of class which defines how the class will behave like or we can say that A class is itself an instance of a metaclass.</source>
          <target state="translated">元类是一种类,它定义了类的行为方式,或者我们可以说A类本身就是元类的一个实例。</target>
        </trans-unit>
        <trans-unit id="a4c7336a776a31b11543813110e2a48bdc565d93" translate="yes" xml:space="preserve">
          <source>Metaclasses are deeper magic that
  99% of users should never worry about.
  If you wonder whether you need them,
  you don't (the people who actually
  need them know with certainty that
  they need them, and don't need an
  explanation about why).</source>
          <target state="translated">Metaclasses是99%的用户不应该担心的更深层次的魔法。如果你怀疑自己是否需要它们,那你就不需要(真正需要它们的人肯定知道自己需要它们,不需要解释为什么)。</target>
        </trans-unit>
        <trans-unit id="fcb03720145595ceaed2564444518a68539698a8" translate="yes" xml:space="preserve">
          <source>Metaclasses are the 'stuff' that creates classes.</source>
          <target state="translated">Metaclasses是创建类的 &quot;东西&quot;。</target>
        </trans-unit>
        <trans-unit id="347480dda5a48202f0a0a3b1b3be6014055c70c8" translate="yes" xml:space="preserve">
          <source>Metaclasses are the secret sauce that make 'class' work. The default metaclass for a new style object is called 'type'.</source>
          <target state="translated">元类是使 &quot;类 &quot;发挥作用的秘密酱。新样式对象的默认元类被称为'类型'。</target>
        </trans-unit>
        <trans-unit id="b0d32362c1bfdecea091b0735835a3190f185e2b" translate="yes" xml:space="preserve">
          <source>Metaclasses in Python 3</source>
          <target state="translated">Python 3中的元类</target>
        </trans-unit>
        <trans-unit id="97071630fbed73be9de0cacbd51a241cef7bdfa8" translate="yes" xml:space="preserve">
          <source>Metaclasses take 3 args. '&lt;strong&gt;name&lt;/strong&gt;', '&lt;strong&gt;bases&lt;/strong&gt;' and '&lt;strong&gt;dict&lt;/strong&gt;'</source>
          <target state="translated">元类带有3个参数。 ' &lt;strong&gt;名称&lt;/strong&gt; '，' &lt;strong&gt;基数&lt;/strong&gt; '和' &lt;strong&gt;字典&lt;/strong&gt; '</target>
        </trans-unit>
        <trans-unit id="8797caa69e6420c0f3bfebfa19ca4cdf0b6929f4" translate="yes" xml:space="preserve">
          <source>Nevertheless, it is usually encouraged for users to avoid using metaclasses unless absolutely necessary.</source>
          <target state="translated">然而,通常鼓励用户避免使用元类,除非绝对必要。</target>
        </trans-unit>
        <trans-unit id="4ad4b27bbadcdc0adcdbc297fc1201cb31705fca" translate="yes" xml:space="preserve">
          <source>Note that in python 3.6 a new dunder method &lt;code&gt;__init_subclass__(cls, **kwargs)&lt;/code&gt; was introduced to replace a lot of common use cases for metaclasses. Is is called when a subclass of the defining class is created. See &lt;a href=&quot;https://docs.python.org/3.6/reference/datamodel.html&quot;&gt;python docs&lt;/a&gt;.</source>
          <target state="translated">请注意，在python 3.6中 &lt;code&gt;__init_subclass__(cls, **kwargs)&lt;/code&gt; 引入了新的dunder方法__init_subclass __（cls，** kwargs）来替换元类的许多常见用例。 创建定义类的子类时调用is。 参见&lt;a href=&quot;https://docs.python.org/3.6/reference/datamodel.html&quot;&gt;python docs&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="06fe24108d0ae7b5ac24fe3074dd0a7cf192f87c" translate="yes" xml:space="preserve">
          <source>Note, some things automatically get added to the &lt;code&gt;__dict__&lt;/code&gt;, i.e., the namespace:</source>
          <target state="translated">注意，一些东西会自动添加到 &lt;code&gt;__dict__&lt;/code&gt; ，即名称空间：</target>
        </trans-unit>
        <trans-unit id="fe5b2192b1a3dda71ee761442e7acc561c0dae83" translate="yes" xml:space="preserve">
          <source>Note, this example was adapted from the &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;documentation&lt;/a&gt; - the new &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/enum.py&quot;&gt;enum in the standard library&lt;/a&gt; does this.</source>
          <target state="translated">请注意，此示例改编自&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;文档&lt;/a&gt; - &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/enum.py&quot;&gt;标准库&lt;/a&gt;中的新枚举可实现此目的。</target>
        </trans-unit>
        <trans-unit id="2e4afa936b2a2c77839b1cc61ded016a8418009e" translate="yes" xml:space="preserve">
          <source>Notice that the class was not instantiated at any time; the simple act of creating the class triggered execution of the &lt;code&gt;metaclass&lt;/code&gt;.</source>
          <target state="translated">注意，该类在任何时候都没有实例化。 创建类的简单动作触发了 &lt;code&gt;metaclass&lt;/code&gt; 执行。</target>
        </trans-unit>
        <trans-unit id="e8092d965c6169ed84145f59ba7bbf9f5d4c853f" translate="yes" xml:space="preserve">
          <source>Now the big question is, what can you put in &lt;code&gt;__metaclass__&lt;/code&gt; ?</source>
          <target state="translated">现在最大的问题是，您可以在 &lt;code&gt;__metaclass__&lt;/code&gt; 中放入什么？</target>
        </trans-unit>
        <trans-unit id="d2dcde526fc4daaef6d655606e4496048204c05b" translate="yes" xml:space="preserve">
          <source>Now the big question. Why would you use some obscure error prone feature?</source>
          <target state="translated">现在是个大问题。你为什么要用一些晦涩难懂的易出错功能?</target>
        </trans-unit>
        <trans-unit id="1312ae6700f74e01674fc6c089a10ffa91f468b1" translate="yes" xml:space="preserve">
          <source>Now you wonder why the heck is it written in lowercase, and not &lt;code&gt;Type&lt;/code&gt;?</source>
          <target state="translated">现在，您想知道为什么用小写而不是 &lt;code&gt;Type&lt;/code&gt; 来写它吗？</target>
        </trans-unit>
        <trans-unit id="9e1ac6d44c14c13e117e5f981206e38957129c52" translate="yes" xml:space="preserve">
          <source>Now, let's do exactly the same, but using a real class for a metaclass:</source>
          <target state="translated">现在,让我们做同样的事情,但用一个真正的类来做元类。</target>
        </trans-unit>
        <trans-unit id="390ebafcf350ad02efb790f33b6aaead595c1109" translate="yes" xml:space="preserve">
          <source>Now, what is the &lt;code&gt;__class__&lt;/code&gt; of any &lt;code&gt;__class__&lt;/code&gt; ?</source>
          <target state="translated">现在，任何 &lt;code&gt;__class__&lt;/code&gt; 的 &lt;code&gt;__class__&lt;/code&gt; 是什么？</target>
        </trans-unit>
        <trans-unit id="d1ac610b74a4f310bfc7d2292f70767803b25d13" translate="yes" xml:space="preserve">
          <source>Observe that the code above doesn't actually do anything more than logging the tasks. Each method delegates the actual work to its parent's implementation, thus keeping the default behavior. Since &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;Meta_1&lt;/code&gt;'s parent class (&lt;code&gt;type&lt;/code&gt; being the default parent metaclass) and considering the ordering sequence of the output above, we now have a clue as to what would be the pseudo implementation of &lt;code&gt;type.__call__()&lt;/code&gt;:</source>
          <target state="translated">请注意，上面的代码除了记录任务之外实际上没有做任何其他事情。 每个方法将实际工作委托给其父级的实现，从而保留默认行为。 由于 &lt;code&gt;type&lt;/code&gt; 是 &lt;code&gt;Meta_1&lt;/code&gt; 的父类（ &lt;code&gt;type&lt;/code&gt; 是默认的父元类），并考虑了上面输出的排序顺序，因此我们现在可以知道 &lt;code&gt;type.__call__()&lt;/code&gt; 的伪实现是什么：</target>
        </trans-unit>
        <trans-unit id="9d0d319c87f6fad802806c07bd7c51a428962ba2" translate="yes" xml:space="preserve">
          <source>Oh, and in python 3 if you do this call with keyword arguments, like this:</source>
          <target state="translated">哦,在python 3中,如果你用关键字参数进行这个调用,就像这样。</target>
        </trans-unit>
        <trans-unit id="7cfdd53a3948e13bf6052b4df361c602b9dadb4c" translate="yes" xml:space="preserve">
          <source>One of the most valuable things we can do by default in writing a Python object is to provide it with a good &lt;code&gt;__repr__&lt;/code&gt;. When we call &lt;code&gt;help(repr)&lt;/code&gt; we learn that there's a good test for a &lt;code&gt;__repr__&lt;/code&gt; that also requires a test for equality - &lt;code&gt;obj == eval(repr(obj))&lt;/code&gt;. The following simple implementation of &lt;code&gt;__repr__&lt;/code&gt; and &lt;code&gt;__eq__&lt;/code&gt; for class instances of our type class provides us with a demonstration that may improve on the default &lt;code&gt;__repr__&lt;/code&gt; of classes:</source>
          <target state="translated">默认情况下，我们在编写Python对象时可以做的最有价值的事情之一就是为其提供良好的 &lt;code&gt;__repr__&lt;/code&gt; 。 当我们调用 &lt;code&gt;help(repr)&lt;/code&gt; 时,我们了解到 &lt;code&gt;__repr__&lt;/code&gt; 有一个很好的测试，它也需要测试相等性-obj &lt;code&gt;obj == eval(repr(obj))&lt;/code&gt; 。 以下是针对我们类型类的类实例的 &lt;code&gt;__repr__&lt;/code&gt; 和 &lt;code&gt;__eq__&lt;/code&gt; 的简单实现，为我们提供了一个可以改进默认类 &lt;code&gt;__repr__&lt;/code&gt; 的演示：</target>
        </trans-unit>
        <trans-unit id="110c76ebedce2cc5ef80aca4ff4ae9ae674cabba" translate="yes" xml:space="preserve">
          <source>One thing added to metaclasses in python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:</source>
          <target state="translated">在python 3中,有一件事被添加到元类中,就是你也可以将属性作为关键字参数传递到元类中,就像这样。</target>
        </trans-unit>
        <trans-unit id="34e532c0c60597f39dcc4f2a9b5f7a1d572c0614" translate="yes" xml:space="preserve">
          <source>One use for metaclasses is adding new properties and methods to an instance automatically.</source>
          <target state="translated">元类的一个用途是自动向实例添加新的属性和方法。</target>
        </trans-unit>
        <trans-unit id="ef268ec4d64e990e936a954651784766af9637be" translate="yes" xml:space="preserve">
          <source>Others have explained how metaclasses work and how they fit into the Python type system. Here's an example of what they can be used for. In a testing framework I wrote, I wanted to keep track of the order in which classes were defined, so that I could later instantiate them in this order. I found it easiest to do this using a metaclass.</source>
          <target state="translated">其他人已经解释了元类是如何工作的,以及它们是如何融入Python类型系统的。这里有一个例子说明它们可以用来做什么。在我写的一个测试框架中,我想跟踪类的定义顺序,以便以后可以按照这个顺序实例化它们。我发现使用元类来做这个事情最简单。</target>
        </trans-unit>
        <trans-unit id="a1e368bcdd9e3ad64f80172f6605fff557c816ac" translate="yes" xml:space="preserve">
          <source>Pseudocode:</source>
          <target state="translated">Pseudocode:</target>
        </trans-unit>
        <trans-unit id="b046f20ec5ac77994d3cd2fa8b65aab70b67256f" translate="yes" xml:space="preserve">
          <source>Put a third way, a metaclass is a class's class.</source>
          <target state="translated">说第三种方式,元类是一个类的类。</target>
        </trans-unit>
        <trans-unit id="8d527c34e169c405cdbe5dedda08a7bde822577d" translate="yes" xml:space="preserve">
          <source>Put another way, a class is an instance of a metaclass:</source>
          <target state="translated">换个说法,类就是元类的一个实例。</target>
        </trans-unit>
        <trans-unit id="57d1465b29ebaa761602dcd70cff407e53c47e35" translate="yes" xml:space="preserve">
          <source>Putting it differently</source>
          <target state="translated">换个说法</target>
        </trans-unit>
        <trans-unit id="ce9d464e6a7243401820e72c717964ac86dda8b2" translate="yes" xml:space="preserve">
          <source>Python classes are themselves objects - as in instance - of their meta-class.</source>
          <target state="translated">Python 类本身就是其元类的对象----就像实例一样----其元类的对象。</target>
        </trans-unit>
        <trans-unit id="47913b0ef43e652acfa0a6f76a38e652fae1a60c" translate="yes" xml:space="preserve">
          <source>Python does the following:</source>
          <target state="translated">Python的作用如下。</target>
        </trans-unit>
        <trans-unit id="1cef07b48fc1a95aee7f514ccf91ce22d457b8f0" translate="yes" xml:space="preserve">
          <source>Python will look for &lt;code&gt;__metaclass__&lt;/code&gt; in the class definition. If it finds it,
it will use it to create the object class &lt;code&gt;Foo&lt;/code&gt;. If it doesn't, it will use
&lt;code&gt;type&lt;/code&gt; to create the class.</source>
          <target state="translated">Python将在类定义中寻找 &lt;code&gt;__metaclass__&lt;/code&gt; 。 如果找到它，它将使用它来创建对象类 &lt;code&gt;Foo&lt;/code&gt; 。 如果没有，它将使用 &lt;code&gt;type&lt;/code&gt; 创建类。</target>
        </trans-unit>
        <trans-unit id="c68f250ede1ff4f4e9314c1012a1057abd055fc7" translate="yes" xml:space="preserve">
          <source>Read that several times.</source>
          <target state="translated">读了好几遍。</target>
        </trans-unit>
        <trans-unit id="10b8e71a62f5bb23590ad5fac72a1920c13c031d" translate="yes" xml:space="preserve">
          <source>Read the section below for how python handles this.</source>
          <target state="translated">请阅读下面的部分,了解python是如何处理的。</target>
        </trans-unit>
        <trans-unit id="363f6db0e6302144237a5fb8dc97f8c0bca8e69c" translate="yes" xml:space="preserve">
          <source>Remember the function &lt;code&gt;type&lt;/code&gt;? The good old function that lets you know what
type an object is:</source>
          <target state="translated">还记得函数 &lt;code&gt;type&lt;/code&gt; 吗？ 好的旧函数可以让您知道对象的类型：</target>
        </trans-unit>
        <trans-unit id="cf75004630642fa532edd3e9852d9ebbd8dc3330" translate="yes" xml:space="preserve">
          <source>Role of a metaclass' &lt;code&gt;__call__()&lt;/code&gt; method when creating a class instance</source>
          <target state="translated">创建类实例时元类的 &lt;code&gt;__call__()&lt;/code&gt; 方法的作用</target>
        </trans-unit>
        <trans-unit id="ab6d3b5b86935e5bb21ca62e95635f583fc6b80d" translate="yes" xml:space="preserve">
          <source>Say you want some simple validation code to run on your attributes -- like it must always be an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;str&lt;/code&gt;.  Without a metaclass, your class would look something like:</source>
          <target state="translated">假设您要在属性上运行一些简单的验证代码-就像它必须始终是 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;str&lt;/code&gt; 一样 。 没有元类，您的类将类似于：</target>
        </trans-unit>
        <trans-unit id="924f4a98a9789c119e7866bd528b9dbf5b11a53a" translate="yes" xml:space="preserve">
          <source>Secondly, metaclasses are complicated. You may not want to use them for
very simple class alterations. You can change classes by using two different techniques:</source>
          <target state="translated">其次,metaclasses很复杂。你可能不愿意用它们来进行非常简单的类修改。你可以通过使用两种不同的技术来改变类。</target>
        </trans-unit>
        <trans-unit id="4dfe816bf571911a330a66b6c754c40a58c06f42" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;__metaclass__&lt;/code&gt; can accept any callable, why would you use a class
since it's obviously more complicated?</source>
          <target state="translated">由于 &lt;code&gt;__metaclass__&lt;/code&gt; 可以接受任何可调用对象，因此为什么要使用一个类，因为它显然更复杂？</target>
        </trans-unit>
        <trans-unit id="bac0117f2a38a17d034595eaa6fbc681396fe5b3" translate="yes" xml:space="preserve">
          <source>Since classes are objects, they must be generated by something.</source>
          <target state="translated">既然类是对象,就一定是由什么东西产生的。</target>
        </trans-unit>
        <trans-unit id="760ecfb3930f9e09bb9d06c038adf0fa41b52fc4" translate="yes" xml:space="preserve">
          <source>Since classes are objects, you can create them on the fly, like any object.</source>
          <target state="translated">因为类是对象,所以你可以像其他对象一样,在飞行中创建它们。</target>
        </trans-unit>
        <trans-unit id="7922a02533e41a18df57099805414126241c109f" translate="yes" xml:space="preserve">
          <source>So now when we create an object with this metaclass, the &lt;code&gt;__repr__&lt;/code&gt; echoed on the command line provides a much less ugly sight than the default:</source>
          <target state="translated">因此，现在当我们使用该元类创建对象时，在命令行上回显的 &lt;code&gt;__repr__&lt;/code&gt; 所提供的视觉效果比默认值要难看得多：</target>
        </trans-unit>
        <trans-unit id="b3eadfdf1eb9197422100ebb25f09e54a92a4803" translate="yes" xml:space="preserve">
          <source>So we will start with a simple example, by using a function.</source>
          <target state="translated">所以我们先从一个简单的例子开始,用一个函数来说明。</target>
        </trans-unit>
        <trans-unit id="3baa5edda84402a64f5f0858188ef99b09a86284" translate="yes" xml:space="preserve">
          <source>So what we did was instantiate a metaclass by creating a class. We can also treat the metaclass as we would any other class. It has a method resolution order:</source>
          <target state="translated">所以我们所做的是通过创建一个类来实例化一个元类。我们也可以像对待其他类一样对待这个元类。它有一个方法解析顺序。</target>
        </trans-unit>
        <trans-unit id="787050e4deb5bdd8472bfd457a5d01da81c38749" translate="yes" xml:space="preserve">
          <source>So, a metaclass is just the stuff that creates class objects.</source>
          <target state="translated">所以,元类就是创建类对象的东西。</target>
        </trans-unit>
        <trans-unit id="2cdd6c8b1bfe3a886c05a5ee17876f43593f8214" translate="yes" xml:space="preserve">
          <source>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.</source>
          <target state="translated">如果你指定了元类,类的子类将成为其元类的实例,但如果你指定了元类函数,那么类的子类将成为它的元类的实例,但不是元类函数。</target>
        </trans-unit>
        <trans-unit id="0e65e54eb14defefa9b23c03a66343a7b6f47568" translate="yes" xml:space="preserve">
          <source>TLDR: A metaclass instantiates and defines behavior for a class just like a class instantiates and defines behavior for an instance.</source>
          <target state="translated">TLDR:元类实例化和定义行为,就像类实例化和定义行为一样。</target>
        </trans-unit>
        <trans-unit id="ed0c814a6c1a71ccfd0f078327070092fba4af8e" translate="yes" xml:space="preserve">
          <source>That's it. There is really nothing more about metaclasses.</source>
          <target state="translated">就这样吧。关于metaclasses真的没有什么了。</target>
        </trans-unit>
        <trans-unit id="a4cdd3d253d3c4a2ec82a87618d1e84a1259cbb8" translate="yes" xml:space="preserve">
          <source>The 'ValidateType' class for reference:</source>
          <target state="translated">'ValidateType'类供参考。</target>
        </trans-unit>
        <trans-unit id="604a85cd97fdfe89bc4bd3ea794f26e3143cb342" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__&quot;&gt;&lt;code&gt;__metaclass__&lt;/code&gt;&lt;/a&gt; attribute</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__&quot;&gt; &lt;code&gt;__metaclass__&lt;/code&gt; &lt;/a&gt;属性</target>
        </trans-unit>
        <trans-unit id="b9bee8c22368a6bedc8cb2204d7e38427ec1a6fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__call__()&lt;/code&gt; method is invoked when an instance of a class is used as a callable. But as we've seen from previous answers a class itself is an instance of a metaclass, so when we use the class as a callable (i.e. when we create an instance of it) we're actually calling its metaclass' &lt;code&gt;__call__()&lt;/code&gt; method. At this point most Python programmers are a bit confused because they've been told that when creating an instance like this &lt;code&gt;instance = SomeClass()&lt;/code&gt; you're calling its &lt;code&gt;__init__()&lt;/code&gt; method. Some who've dug a bit deeper know that before &lt;code&gt;__init__()&lt;/code&gt; there's &lt;code&gt;__new__()&lt;/code&gt;. Well, today another layer of truth is being revealed, before &lt;code&gt;__new__()&lt;/code&gt; there's the metaclass' &lt;code&gt;__call__()&lt;/code&gt;.</source>
          <target state="translated">当类的实例用作可调用对象时，将调用 &lt;code&gt;__call__()&lt;/code&gt; 方法。 但是，正如我们从前面的答案中看到的那样，类本身是元类的实例，因此，当我们使用该类作为可调用对象时（即，当我们创建它的实例时），实际上是在调用其元类的 &lt;code&gt;__call__()&lt;/code&gt; 方法。 。 在这一点上，大多数Python程序员有些困惑，因为他们被告知在创建类似 &lt;code&gt;instance = SomeClass()&lt;/code&gt; 您正在调用其 &lt;code&gt;__init__()&lt;/code&gt; 方法。 一些更深入的人知道 &lt;code&gt;__init__()&lt;/code&gt; 之前有 &lt;code&gt;__new__()&lt;/code&gt; 。 好吧，今天又有了另一层真相，在 &lt;code&gt;__new__()&lt;/code&gt; 之前是元类的 &lt;code&gt;__call__()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbdb757e7f3a0fd9bcff0fc938b6c42345b821ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;metaclass&lt;/code&gt; is powerful, there are many things (such as monkey magic) you can do with it, but be careful this may only be known to you.</source>
          <target state="translated">&lt;code&gt;metaclass&lt;/code&gt; 功能强大，可以用它做很多事情（例如猴子魔术），但是要小心，这可能只有您才知道。</target>
        </trans-unit>
        <trans-unit id="7ffedf4f89a6efcf7f214cee31b40dd5d82d9dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type(obj)&lt;/code&gt; function gets you the type of an object.</source>
          <target state="translated">&lt;code&gt;type(obj)&lt;/code&gt; 函数可获取对象的类型。</target>
        </trans-unit>
        <trans-unit id="19c9cb1547b44911ff93834c533ce8c6106e48d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;metaclass&lt;/em&gt; of the object we created, in both cases, is &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">在这两种情况下，我们创建的对象的&lt;em&gt;元类&lt;/em&gt;都是 &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1aa36bd31df16516299e0a9f975574341ae6676" translate="yes" xml:space="preserve">
          <source>The above should look familiar. Well, where does &lt;code&gt;Class&lt;/code&gt; come from? It's an instance of a metaclass (also pseudocode):</source>
          <target state="translated">上面看起来应该很熟悉。 好， &lt;code&gt;Class&lt;/code&gt; 从哪里来？ 它是一个元类的实例（也是伪代码）：</target>
        </trans-unit>
        <trans-unit id="a2875f88e41a0ad13dd2d5379ef6582ba0fb3dd7" translate="yes" xml:space="preserve">
          <source>The answer is: something that can create a class.</source>
          <target state="translated">答案是:能创造一个类的东西。</target>
        </trans-unit>
        <trans-unit id="9a86d7001554378f3dcbce322b370aaa90ec530c" translate="yes" xml:space="preserve">
          <source>The behaviour of metaclasses however stays &lt;a href=&quot;https://www.python.org/dev/peps/pep-3115/&quot;&gt;largely the same&lt;/a&gt;.</source>
          <target state="translated">但是，元类的行为&lt;a href=&quot;https://www.python.org/dev/peps/pep-3115/&quot;&gt;基本&lt;/a&gt;保持不变 。</target>
        </trans-unit>
        <trans-unit id="3f6d3b98cc17992d9030a84dca7f0f6a00ff380a" translate="yes" xml:space="preserve">
          <source>The default metaclass, which is applied when when you determine classes as:</source>
          <target state="translated">缺省的元类,当你确定类为时,就会应用到默认的元类。</target>
        </trans-unit>
        <trans-unit id="29b56e4ed0cf2c522c5e5b6e0b098db30123e1fe" translate="yes" xml:space="preserve">
          <source>The intention is clear. When you read &lt;code&gt;UpperAttrMetaclass(type)&lt;/code&gt;, you know
what's going to follow</source>
          <target state="translated">意图很明确。 当您阅读 &lt;code&gt;UpperAttrMetaclass(type)&lt;/code&gt; 时 ，您知道会发生什么</target>
        </trans-unit>
        <trans-unit id="a6e5997843f57dcebc725e6a5762f1c51bce68a1" translate="yes" xml:space="preserve">
          <source>The last word</source>
          <target state="translated">最后一句话</target>
        </trans-unit>
        <trans-unit id="fde54b7f3e6afffc50941664e058311d935cae06" translate="yes" xml:space="preserve">
          <source>The latter is possible when you implement the &lt;code&gt;__call__()&lt;/code&gt; magic method on the class.</source>
          <target state="translated">当您在类上实现 &lt;code&gt;__call__()&lt;/code&gt; 魔术方法时，后者是可能的。</target>
        </trans-unit>
        <trans-unit id="71bb84c4860a5a46695ab1e2438f2ed1d5a90d31" translate="yes" xml:space="preserve">
          <source>The main purpose of a metaclass is to change the class automatically,
when it's created.</source>
          <target state="translated">元类的主要目的是自动改变类,当类被创建的时候。</target>
        </trans-unit>
        <trans-unit id="3c9b5afc7d5812bc24e508fdde2021ee24771b8d" translate="yes" xml:space="preserve">
          <source>The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:</source>
          <target state="translated">元类的主要用例是创建一个API。一个典型的例子是Django ORM。它允许你定义这样的东西。</target>
        </trans-unit>
        <trans-unit id="7ed8ebb489915f332c0205bc56188ef3801ec4e9" translate="yes" xml:space="preserve">
          <source>The metaclass enabling this</source>
          <target state="translated">启用此功能的元类</target>
        </trans-unit>
        <trans-unit id="d7864ae5ef3f0b7a2f3aacd5831a1402dbade9c3" translate="yes" xml:space="preserve">
          <source>The output will be:</source>
          <target state="translated">输出将是。</target>
        </trans-unit>
        <trans-unit id="5268adb28d12d30ac6d135d5f75b63e9da11e68b" translate="yes" xml:space="preserve">
          <source>The potential uses for metaclasses are boundless. Some ideas that have been explored include logging, interface checking, automatic delegation, automatic property creation, proxies, frameworks, and automatic resource locking/synchronization.</source>
          <target state="translated">元类的潜在用途是无限的。一些已被探索的想法包括日志、接口检查、自动委托、自动属性创建、代理、框架和自动资源锁定同步等。</target>
        </trans-unit>
        <trans-unit id="6907452e93a5a80f5c109418b9bf18c96cd67c09" translate="yes" xml:space="preserve">
          <source>The reason behind the complexity of the code using metaclasses is not because
of metaclasses, it's because you usually use metaclasses to do twisted stuff
relying on introspection, manipulating inheritance, vars such as &lt;code&gt;__dict__&lt;/code&gt;, etc.</source>
          <target state="translated">使用元类的代码复杂的原因不是因为元类，而是因为您通常使用元类依靠自省，操纵继承以及诸如 &lt;code&gt;__dict__&lt;/code&gt; 之类的 var等来扭曲事物。</target>
        </trans-unit>
        <trans-unit id="292b3d3fa44cb0944294ebc9a86345b3567f6d79" translate="yes" xml:space="preserve">
          <source>The syntax to set the metaclass has been changed in Python 3:</source>
          <target state="translated">在Python 3中,设置元类的语法已经改变了。</target>
        </trans-unit>
        <trans-unit id="b4d33846e5640be4c1d9597eafdcc9bc72aceaf5" translate="yes" xml:space="preserve">
          <source>The thing that's left to say is: If you don't know what metaclasses are, the probability that you &lt;strong&gt;will not need them&lt;/strong&gt; is 99%.</source>
          <target state="translated">剩下要说的是：如果您不知道什么是元类，则&lt;strong&gt;不需要它们&lt;/strong&gt;的可能性为99％。</target>
        </trans-unit>
        <trans-unit id="959c3572d6d62fe879c68854fc146ad30c9bb8cd" translate="yes" xml:space="preserve">
          <source>The tl;dr version</source>
          <target state="translated">语焉不详的版本</target>
        </trans-unit>
        <trans-unit id="656d2c5fc9c081a8217d9d6a68f3f31fc9b34aef" translate="yes" xml:space="preserve">
          <source>The type() function can return the type of an object or create a new type,</source>
          <target state="translated">type()函数可以返回一个对象的类型或创建一个新的类型。</target>
        </trans-unit>
        <trans-unit id="733141dd8934a1c4901342843517b7b8404b6323" translate="yes" xml:space="preserve">
          <source>Then if it can't find any &lt;code&gt;__metaclass__&lt;/code&gt; at all, it will use the &lt;code&gt;Bar&lt;/code&gt;'s (the first parent) own metaclass (which might be the default &lt;code&gt;type&lt;/code&gt;) to create the class object.</source>
          <target state="translated">然后，如果根本找不到任何 &lt;code&gt;__metaclass__&lt;/code&gt; ，它将使用 &lt;code&gt;Bar&lt;/code&gt; 的（第一个父级）自己的元类（可能是默认 &lt;code&gt;type&lt;/code&gt; ）创建类对象。</target>
        </trans-unit>
        <trans-unit id="a771a2f9cc215079a67d4f526fd98ab5b55dcf1f" translate="yes" xml:space="preserve">
          <source>There are (at this point) two key methods in a metaclass:</source>
          <target state="translated">在一个元类中,有两个关键的方法(在这一点上)。</target>
        </trans-unit>
        <trans-unit id="40e0c7527fe508c7995960aaf38056900b9ff412" translate="yes" xml:space="preserve">
          <source>There are several reasons to do so:</source>
          <target state="translated">这样做有几个原因。</target>
        </trans-unit>
        <trans-unit id="9e2063eee3f575331ddd73d7a81c2d318f5daa93" translate="yes" xml:space="preserve">
          <source>These are called metaclasses, damn it! It must mean something!</source>
          <target state="translated">这些都叫metaclasses,该死的!这一定是有意义的!</target>
        </trans-unit>
        <trans-unit id="3b5c4cd62ac6b431a5176848fb6508cfa06be65a" translate="yes" xml:space="preserve">
          <source>This is a case where I saw metaclass as a solution to my problem:
I had a really complicated problem, that probably could have been solved differently, but I chose to solve it using a metaclass.  Because of the complexity, it is one of the few modules I have written where the comments in the module surpass the amount of code that has been written.  Here it is...</source>
          <target state="translated">这是我把metaclass看作是解决我问题的一个案例:我有一个非常复杂的问题,这个问题可能可以用不同的方式来解决,但我选择了用metaclass来解决。因为它的复杂性,它是我所写的模块中为数不多的模块之一,在这个模块中的注释超过了所写的代码量。下面是.....</target>
        </trans-unit>
        <trans-unit id="bd01e02e8d937d71c953efd2b047baa65d13a9d0" translate="yes" xml:space="preserve">
          <source>This is a class that uses that metaclass</source>
          <target state="translated">这是一个使用该元类的类。</target>
        </trans-unit>
        <trans-unit id="0eaab00f42bc385328b90e65be0df9fd3ce443e5" translate="yes" xml:space="preserve">
          <source>This is a metaclass that logs exactly the moment before an instance is created and the moment it's about to return it.</source>
          <target state="translated">这是一个元类,它准确地记录了一个实例创建前和即将返回实例的那一刻。</target>
        </trans-unit>
        <trans-unit id="a91ffeba7150d22f41622349f220dc2a7bd0941e" translate="yes" xml:space="preserve">
          <source>This is possible because &lt;code&gt;models.Model&lt;/code&gt; defines &lt;code&gt;__metaclass__&lt;/code&gt; and
it uses some magic that will turn the &lt;code&gt;Person&lt;/code&gt; you just defined with simple statements
into a complex hook to a database field.</source>
          <target state="translated">这是可能的，因为 &lt;code&gt;models.Model&lt;/code&gt; 定义了 &lt;code&gt;__metaclass__&lt;/code&gt; ,并且它使用了一些魔术，它将使用简单的语句将刚定义的 &lt;code&gt;Person&lt;/code&gt; 变成复杂的数据库字段挂钩。</target>
        </trans-unit>
        <trans-unit id="4f1bef529754046ab93614c707e29ea65f065a58" translate="yes" xml:space="preserve">
          <source>This is what Python does when you use the keyword &lt;code&gt;class&lt;/code&gt;, and it does so by using a metaclass.</source>
          <target state="translated">这是Python在使用关键字 &lt;code&gt;class&lt;/code&gt; 时所做的，并且通过使用元类来实现。</target>
        </trans-unit>
        <trans-unit id="690dffa17d6286ca4b5f0d265293b3aba8dc9308" translate="yes" xml:space="preserve">
          <source>This is what the metaclass would look like (not using &lt;code&gt;__prepare__&lt;/code&gt; since it is not needed):</source>
          <target state="translated">这就是元类的样子（由于不需要它，所以不使用 &lt;code&gt;__prepare__&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="3a703a42ef6d26d4b5acc17812e989feee889a40" translate="yes" xml:space="preserve">
          <source>This way, all classes of this module will be created using this metaclass,
and we just have to tell the metaclass to turn all attributes to uppercase.</source>
          <target state="translated">这样一来,这个模块的所有类都会用这个元类来创建,我们只需要告诉元类把所有的属性都变成大写就可以了。</target>
        </trans-unit>
        <trans-unit id="c8eb39184302c31569399fad3b80b08d690c761d" translate="yes" xml:space="preserve">
          <source>To create a metaclass, overriding of &lt;strong&gt;new&lt;/strong&gt;() and &lt;strong&gt;init&lt;/strong&gt;() methods is usually done. &lt;strong&gt;new&lt;/strong&gt;() can be overridden to change the way objects are created, while &lt;strong&gt;init&lt;/strong&gt;() can be overridden to change the way of initializing the object. Metaclass can be created by a number of ways. One of the ways is to use type() function. type() function, when called with 3 parameters, creates a metaclass. The parameters are :-</source>
          <target state="translated">要创建一个元类，通常要重写&lt;strong&gt;new&lt;/strong&gt; （）和&lt;strong&gt;init&lt;/strong&gt; （）方法。 可以重写&lt;strong&gt;new&lt;/strong&gt; （）来更改对象的创建方式，而可以重写&lt;strong&gt;init&lt;/strong&gt; （）来更改对象的初始化方式。 元类可以通过多种方式创建。 一种方法是使用type（）函数。 当使用3个参数调用type（）函数时，它将创建一个元类。 参数是：</target>
        </trans-unit>
        <trans-unit id="7f66480aa700b9c3c9e3a6513f4f91ad438a6ac8" translate="yes" xml:space="preserve">
          <source>To use a metaclass:</source>
          <target state="translated">要使用一个元类。</target>
        </trans-unit>
        <trans-unit id="9d625953b8c96c50aabee6488063e1446a582041" translate="yes" xml:space="preserve">
          <source>Tuple having base classes inherited by class</source>
          <target state="translated">有基类继承的Tuple的基类</target>
        </trans-unit>
        <trans-unit id="d0594a199ce5d4ac41e3201736acd504b143394b" translate="yes" xml:space="preserve">
          <source>We can extend &lt;code&gt;type&lt;/code&gt; just like any other class definition:</source>
          <target state="translated">我们可以像其他任何类定义一样扩展 &lt;code&gt;type&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d88182269b2e241ec478b27d4767550768772015" translate="yes" xml:space="preserve">
          <source>We can make it even cleaner by using &lt;code&gt;super&lt;/code&gt;, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):</source>
          <target state="translated">通过使用 &lt;code&gt;super&lt;/code&gt; ，我们可以使其更加整洁，这将简化继承（因为是的，您可以具有元类，从元类继承，从类型继承）：</target>
        </trans-unit>
        <trans-unit id="92762df1c860bcdb2ae4c1a3bc542b57879d0959" translate="yes" xml:space="preserve">
          <source>We can see that the metaclass' &lt;code&gt;__call__()&lt;/code&gt; method is the one that's called first. It then delegates creation of the instance to the class's &lt;code&gt;__new__()&lt;/code&gt; method and initialization to the instance's &lt;code&gt;__init__()&lt;/code&gt;. It's also the one that ultimately returns the instance.</source>
          <target state="translated">我们可以看到元类的 &lt;code&gt;__call__()&lt;/code&gt; 方法是第一个被调用的方法。 然后，它将实例的创建委托给类的 &lt;code&gt;__new__()&lt;/code&gt; 方法，并将实例初始化委托给实例的 &lt;code&gt;__init__()&lt;/code&gt; 。 它也是最终返回该实例的对象。</target>
        </trans-unit>
        <trans-unit id="16d288708e3034e3415f37e929abe09a44ae3d9f" translate="yes" xml:space="preserve">
          <source>Well in fact, classes are themselves instances. Of metaclasses.</source>
          <target state="translated">那么事实上,类本身就是实例。元类的实例。</target>
        </trans-unit>
        <trans-unit id="d278e4f17ef8ed67c2a22f4c32904a94d842130f" translate="yes" xml:space="preserve">
          <source>Well, &lt;a href=&quot;http://docs.python.org/2/library/functions.html#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; has a completely different ability, it can also create classes on the fly. &lt;code&gt;type&lt;/code&gt; can take the description of a class as parameters,
and return a class.</source>
          <target state="translated">好吧， &lt;a href=&quot;http://docs.python.org/2/library/functions.html#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;具有完全不同的能力，它也可以动态创建类。 &lt;code&gt;type&lt;/code&gt; 可以将类的描述作为参数，并返回一个类。</target>
        </trans-unit>
        <trans-unit id="f58b345320ab6cedc6dd827175904f92af7b09a9" translate="yes" xml:space="preserve">
          <source>Well, I guess it's a matter of consistency with &lt;code&gt;str&lt;/code&gt;, the class that creates
strings objects, and &lt;code&gt;int&lt;/code&gt; the class that creates integer objects. &lt;code&gt;type&lt;/code&gt; is
just the class that creates class objects.</source>
          <target state="translated">好吧，我想这与 &lt;code&gt;str&lt;/code&gt; ，创建字符串对象的类和 &lt;code&gt;int&lt;/code&gt; 创建整数对象的类的一致性有关。 &lt;code&gt;type&lt;/code&gt; 只是创建类对象的类。</target>
        </trans-unit>
        <trans-unit id="a0696d6279da7380ed7a9d1f185eabd27a76e2f1" translate="yes" xml:space="preserve">
          <source>Well, metaclasses are what create these objects. They are the classes' classes,
you can picture them this way:</source>
          <target state="translated">那么,元类就是创建这些对象的元类。它们是类的类,你可以这样想象它们的样子。</target>
        </trans-unit>
        <trans-unit id="cd8f8377093c7a9f568847ac99d779518ff62c1b" translate="yes" xml:space="preserve">
          <source>Well, usually you don't:</source>
          <target state="translated">嗯,通常情况下,你是不会的。</target>
        </trans-unit>
        <trans-unit id="464df4ba1017e09b5d8fcbcb6bc3f85fc5e4129e" translate="yes" xml:space="preserve">
          <source>What are metaclasses (finally)</source>
          <target state="translated">什么是metaclasses(终于)?</target>
        </trans-unit>
        <trans-unit id="7be40721cc8b807cb99d9d947eae9af189c69085" translate="yes" xml:space="preserve">
          <source>What are metaclasses in Python</source>
          <target state="translated">什么是Python中的元类</target>
        </trans-unit>
        <trans-unit id="95ac2d20e8da72812ecb5a849d130ac5cab6552d" translate="yes" xml:space="preserve">
          <source>What are metaclasses? What do you use them for?</source>
          <target state="translated">什么是metaclasses?你用它们来做什么?</target>
        </trans-unit>
        <trans-unit id="ca7233bf93e47a10f12eab5a25b942225351fd97" translate="yes" xml:space="preserve">
          <source>What can they be used for? From the &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">它们可以用来做什么？ 从&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#metaclass-example&quot;&gt;文档&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="faccab95a2838e0f66852ca4a5c0f3a913942d90" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;class&lt;/code&gt; statement is executed, Python first executes the body of the &lt;code&gt;class&lt;/code&gt; statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the &lt;code&gt;__metaclass__&lt;/code&gt; attribute of the class-to-be (if any) or the &lt;code&gt;__metaclass__&lt;/code&gt; global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.</source>
          <target state="translated">当执行 &lt;code&gt;class&lt;/code&gt; 语句时，Python首先将 &lt;code&gt;class&lt;/code&gt; 语句的主体作为普通代码块执行。 生成的名称空间（字典）保留了将来类的属性。 通过查看待定类的基类（继承了元类）， &lt;code&gt;__metaclass__&lt;/code&gt; 类的__metaclass__属性（如果有）或 &lt;code&gt;__metaclass__&lt;/code&gt; 全局变量来确定元类。 然后使用该类的名称，基数和属性调用该元类以实例化它。</target>
        </trans-unit>
        <trans-unit id="0f703991c228a312fa1f4a4718f72097c5f38dc7" translate="yes" xml:space="preserve">
          <source>When we instantiate an object, we get an instance:</source>
          <target state="translated">当我们实例化一个对象时,我们得到一个实例。</target>
        </trans-unit>
        <trans-unit id="2e8ee345e21d7df889e916663fa72306a26db891" translate="yes" xml:space="preserve">
          <source>When you do:</source>
          <target state="translated">当你做的时候。</target>
        </trans-unit>
        <trans-unit id="8eadeed1a219183cc2c88f7ec677f6b2d5aec1aa" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; keyword, Python creates this object automatically. But as
with most things in Python, it gives you a way to do it manually.</source>
          <target state="translated">使用 &lt;code&gt;class&lt;/code&gt; 关键字时，Python会自动创建此对象。 但是，与Python中的大多数事情一样，它为您提供了一种手动进行操作的方法。</target>
        </trans-unit>
        <trans-unit id="ea3a686b188cb5fead0828deafd55680a345ac59" translate="yes" xml:space="preserve">
          <source>When you write a class definition and Python executes it, it uses a metaclass to instantiate the class object (which will, in turn, be used to instantiate instances of that class).</source>
          <target state="translated">当你写了一个类定义,Python 执行它时,它使用一个元类来实例化类对象 (反过来,它将被用来实例化该类的实例)。</target>
        </trans-unit>
        <trans-unit id="0c3bff2984a4115df4dcc3bfb7149ff8691306a4" translate="yes" xml:space="preserve">
          <source>When you write a class definition, for example, like this,</source>
          <target state="translated">当你写一个类的定义时,比如说像这样。</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="8c962cb76a1933afc23c5280c46178cdc0963538" translate="yes" xml:space="preserve">
          <source>While in Python you can use arbitrary callables for metaclasses (like &lt;a href=&quot;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037&quot;&gt;Jerub&lt;/a&gt; shows), the better approach is to make it an actual class itself. &lt;code&gt;type&lt;/code&gt; is the usual metaclass in Python. &lt;code&gt;type&lt;/code&gt; is itself a class, and it is its own type. You won't be able to recreate something like &lt;code&gt;type&lt;/code&gt; purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">虽然在Python中您可以对元类使用任意可调用对象（例如&lt;a href=&quot;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037&quot;&gt;Jerub&lt;/a&gt;演示），但是更好的方法是使其成为实际的类。 &lt;code&gt;type&lt;/code&gt; 是Python中常见的元类。 &lt;code&gt;type&lt;/code&gt; 本身是一个类，并且是它自己的类型。 您将无法纯粹在Python中重新创建类似 &lt;code&gt;type&lt;/code&gt; 的内容 ，但是Python有点作弊。 要在Python中创建自己的元类，您实际上只想对 &lt;code&gt;type&lt;/code&gt; 进行子类化 。</target>
        </trans-unit>
        <trans-unit id="ff246de9114513e53dcf845cd6f5e43b2c9dffe8" translate="yes" xml:space="preserve">
          <source>Why would you use metaclasses classes instead of functions?</source>
          <target state="translated">为什么要用元类而不是函数?</target>
        </trans-unit>
        <trans-unit id="29f54ff47c50feb7cebfef143da1409f28cafef5" translate="yes" xml:space="preserve">
          <source>Why would you use metaclasses?</source>
          <target state="translated">为什么要用元类?</target>
        </trans-unit>
        <trans-unit id="70111da65d9e847b219ad4430cd1c1828a6ec8a3" translate="yes" xml:space="preserve">
          <source>With a nice &lt;code&gt;__repr__&lt;/code&gt; defined for the class instance, we have a stronger ability to debug our code. However, much further checking with &lt;code&gt;eval(repr(Class))&lt;/code&gt; is unlikely (as functions would be rather impossible to eval from their default &lt;code&gt;__repr__&lt;/code&gt;'s).</source>
          <target state="translated">通过为类实例定义一个不错的 &lt;code&gt;__repr__&lt;/code&gt; ，我们可以更强大地调试我们的代码。 但是，使用 &lt;code&gt;eval(repr(Class))&lt;/code&gt; 进行进一步检查的可能性不大（因为从其默认 &lt;code&gt;__repr__&lt;/code&gt; 进行评估的功能相当不可能）。</target>
        </trans-unit>
        <trans-unit id="7e2b61a0c2abd2b5f5ed9ec2bcb225e75cc74640" translate="yes" xml:space="preserve">
          <source>Yes, objects.</source>
          <target state="translated">是的,对象。</target>
        </trans-unit>
        <trans-unit id="0ff433fbf5a657d09064a10812fe33b78649c66e" translate="yes" xml:space="preserve">
          <source>You can call it a 'class factory' if you wish.</source>
          <target state="translated">如果你愿意,你可以称它为 &quot;班级工厂&quot;。</target>
        </trans-unit>
        <trans-unit id="315df7f70140693e8a8bc6a5c96aefabd150fb69" translate="yes" xml:space="preserve">
          <source>You can hook on &lt;code&gt;__new__&lt;/code&gt;, &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;__call__&lt;/code&gt;. Which will allow
you to do different stuff. Even if usually you can do it all in &lt;code&gt;__new__&lt;/code&gt;,
some people are just more comfortable using &lt;code&gt;__init__&lt;/code&gt;.</source>
          <target state="translated">您可以挂接 &lt;code&gt;__new__&lt;/code&gt; &lt;code&gt;__init__&lt;/code&gt; ， __init__和 &lt;code&gt;__call__&lt;/code&gt; 。 这将允许您做不同的事情。 即使通常您可以在 &lt;code&gt;__new__&lt;/code&gt; 中完成所有操作 ，但有些人还是更习惯使用 &lt;code&gt;__init__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58cba9a2524d4784e2abd94ecd3a9d0567aa5f1b" translate="yes" xml:space="preserve">
          <source>You can structure your code better. You never use metaclasses for something as
trivial as the above example. It's usually for something complicated. Having the
ability to make several methods and group them in one class is very useful
to make the code easier to read.</source>
          <target state="translated">你可以更好的结构化你的代码。你从来不会对像上面的例子这样琐碎的事情使用元类。它通常是用于复杂的东西。有能力将多个方法组成一个类,并将它们分组在一个类中是非常有用的,可以使代码更容易阅读。</target>
        </trans-unit>
        <trans-unit id="64c7301b56292e883aabaa3c4edaf3cf8efc42f2" translate="yes" xml:space="preserve">
          <source>You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.</source>
          <target state="translated">可以使用OOP。元类可以继承元类,覆盖父方法。Metaclass甚至可以使用metaclasses。</target>
        </trans-unit>
        <trans-unit id="fb6eb327fa8c07c0f464979436e448c8c249d0c5" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;metaclass&lt;/code&gt; to change the function of its instance (the class).</source>
          <target state="translated">您可以使用 &lt;code&gt;metaclass&lt;/code&gt; 来更改其实例（该类）的功能。</target>
        </trans-unit>
        <trans-unit id="c4bc4a8b7d34394849ad10cef64e38894a0239e3" translate="yes" xml:space="preserve">
          <source>You define classes in order to create objects, right?</source>
          <target state="translated">你定义类是为了创建对象,对吗?</target>
        </trans-unit>
        <trans-unit id="849b6a4a3ab49b1e6d5d5fb3aa2174a5dd045d4a" translate="yes" xml:space="preserve">
          <source>You instantiate a class object.</source>
          <target state="translated">你实例化了一个类对象。</target>
        </trans-unit>
        <trans-unit id="452647fa644731ccf4d36abe26b42b7338dc3ada" translate="yes" xml:space="preserve">
          <source>You may have noticed the extra argument &lt;code&gt;cls&lt;/code&gt;. There is
nothing special about it: &lt;code&gt;__new__&lt;/code&gt; always receives the class it's defined in, as first parameter. Just like you have &lt;code&gt;self&lt;/code&gt; for ordinary methods which receive the instance as first parameter, or the defining class for class methods.</source>
          <target state="translated">您可能已经注意到了额外的参数 &lt;code&gt;cls&lt;/code&gt; 。 没什么特别的： &lt;code&gt;__new__&lt;/code&gt; 始终将其定义的类作为第一个参数。 就像您对接收实例作为第一个参数的普通方法或对类方法的定义类具有 &lt;code&gt;self&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="22aa6e506f7cc49a7a64f3ca6d175caba8e4b9d1" translate="yes" xml:space="preserve">
          <source>You see that by checking the &lt;code&gt;__class__&lt;/code&gt; attribute.</source>
          <target state="translated">通过检查 &lt;code&gt;__class__&lt;/code&gt; 属性可以看到这一点。</target>
        </trans-unit>
        <trans-unit id="cbebccfb501c9be50998ab8dec87986aaf76e78c" translate="yes" xml:space="preserve">
          <source>You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.</source>
          <target state="translated">你知道我们要去哪里了吧:在Python中,类就是对象,你可以动态地创建一个类。</target>
        </trans-unit>
        <trans-unit id="33931bf86a8faf49146362a3955005056936d8f9" translate="yes" xml:space="preserve">
          <source>You use a metaclass every time you create a class:</source>
          <target state="translated">每次创建类的时候,你都会使用一个元类。</target>
        </trans-unit>
        <trans-unit id="892eaf1f9b8ad532b3d9e3281eddca7576cc2b2a" translate="yes" xml:space="preserve">
          <source>You usually do this for APIs, where you want to create classes matching the
current context.</source>
          <target state="translated">你通常会对API进行这样的操作,在这里你想创建与当前上下文匹配的类。</target>
        </trans-unit>
        <trans-unit id="c865cc52046698fef0b1aa97a9a5a1e90813f189" translate="yes" xml:space="preserve">
          <source>You write &lt;code&gt;class Foo(object)&lt;/code&gt; first, but the class object &lt;code&gt;Foo&lt;/code&gt; is not created
in memory yet.</source>
          <target state="translated">您首先编写 &lt;code&gt;class Foo(object)&lt;/code&gt; ，但是尚未在内存中创建类对象 &lt;code&gt;Foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fba87a7567989400ed959bfd1f57626604f0e103" translate="yes" xml:space="preserve">
          <source>You'll notice that we use &quot;MyShinyClass&quot; as the name of the class
and as the variable to hold the class reference. They can be different,
but there is no reason to complicate things.</source>
          <target state="translated">你会注意到,我们用 &quot;MyShinyClass &quot;作为类的名称,并作为持有类引用的变量。它们可以不同,但没有理由把事情复杂化。</target>
        </trans-unit>
        <trans-unit id="468ec3a2130a90f33fbe9e9010d78aea548729a5" translate="yes" xml:space="preserve">
          <source>You've seen that &lt;code&gt;type&lt;/code&gt; lets you do something like this:</source>
          <target state="translated">您已经看到该 &lt;code&gt;type&lt;/code&gt; 可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="62dbbb0781988a55d8018a0fec2c8ecd07b793aa" translate="yes" xml:space="preserve">
          <source>anyhow, those two are the most commonly used hooks. metaclassing is powerful, and above is nowhere near and exhaustive list of uses for metaclassing.</source>
          <target state="translated">无论如何,这两个是最常用的钩子。元分类是很强大的,以上是元分类的使用方法的详尽清单。</target>
        </trans-unit>
        <trans-unit id="b3505d90044ca3190f7e9581b12b5ae05136055b" translate="yes" xml:space="preserve">
          <source>can be created manually this way:</source>
          <target state="translated">可以通过这种方式手动创建。</target>
        </trans-unit>
        <trans-unit id="6737e4457bda9ffaf5726333b2319e8722cf25b9" translate="yes" xml:space="preserve">
          <source>class decorators</source>
          <target state="translated">装修班</target>
        </trans-unit>
        <trans-unit id="44c4e8ef96ee00251b1324e275bce4fb98f44122" translate="yes" xml:space="preserve">
          <source>creates in memory an object with the name &quot;ObjectCreator&quot;.</source>
          <target state="translated">在内存中创建一个名为 &quot;ObjectCreator &quot;的对象。</target>
        </trans-unit>
        <trans-unit id="4f7f64c1613218412d7173f07c7407d18b5776a8" translate="yes" xml:space="preserve">
          <source>e.g.:</source>
          <target state="translated">e.g.:</target>
        </trans-unit>
        <trans-unit id="7db9ff8b86f3d42798dfbf41b5e2001a92aac528" translate="yes" xml:space="preserve">
          <source>for example, we can create a Hi class with the type() function and do not  need to use this way with class Hi(object):</source>
          <target state="translated">例如,我们可以用type()函数来创建一个Hi类,而不需要用这种方式与类Hi(object)一起使用。</target>
        </trans-unit>
        <trans-unit id="760b292bf27a8fcf8c272fa886f3c465a88b9738" translate="yes" xml:space="preserve">
          <source>i.e. the &lt;code&gt;__metaclass__&lt;/code&gt; attribute is no longer used, in favor of a keyword argument in the list of base classes.</source>
          <target state="translated">也就是说，不再使用 &lt;code&gt;__metaclass__&lt;/code&gt; 属性，而是在基类列表中使用关键字参数。</target>
        </trans-unit>
        <trans-unit id="bebe93e3c9401a8e4b84a6e20e06834c7fbff805" translate="yes" xml:space="preserve">
          <source>intercept a class creation</source>
          <target state="translated">插班生</target>
        </trans-unit>
        <trans-unit id="b6a7d03698a36198740b6b7e1269046f935e6ce5" translate="yes" xml:space="preserve">
          <source>meta class are used to apply some rule to an entire set of classes. For example, suppose you're building an ORM to access a database, and you want records from each table to be of a class mapped to that table (based on fields, business rules, etc..,), a possible use of metaclass is for instance, connection pool logic, which is share by all classes of record from all tables. Another use is logic to to support foreign keys, which involves multiple classes of records.</source>
          <target state="translated">元类是用来将一些规则应用到整个类的集合中。例如,假设你正在构建一个ORM来访问一个数据库,你希望每个表的记录都是映射到该表的类(基于字段、业务规则等),元类的一个可能的用途是连接池逻辑,它是由所有表的所有记录类共享的。另一个用途是支持外键的逻辑,这涉及到多类记录的逻辑。</target>
        </trans-unit>
        <trans-unit id="b24e026cd23631fc8326fba464790376a289820a" translate="yes" xml:space="preserve">
          <source>modify the class</source>
          <target state="translated">改类</target>
        </trans-unit>
        <trans-unit id="1123af1e86c1be3e13a73d667767a3eaa9fab222" translate="yes" xml:space="preserve">
          <source>monkey patching</source>
          <target state="translated">猴补</target>
        </trans-unit>
        <trans-unit id="2bcec56171df3c6150684b60fb0f16c51e1923ed" translate="yes" xml:space="preserve">
          <source>produces:</source>
          <target state="translated">produces:</target>
        </trans-unit>
        <trans-unit id="17156a7f53f004d6bfc86c20c78c7a60336f9799" translate="yes" xml:space="preserve">
          <source>return the modified class</source>
          <target state="translated">返回修改后的类</target>
        </trans-unit>
        <trans-unit id="f89967a1b044b115ecabfb714ba2baf9e25b3905" translate="yes" xml:space="preserve">
          <source>when a particular effect has to be applied to all the subclasses</source>
          <target state="translated">当某一特定效果必须应用于所有子类时</target>
        </trans-unit>
        <trans-unit id="129a078ecb9597f440ced3af47b17543ec3a8923" translate="yes" xml:space="preserve">
          <source>when you define metaclass, you subclass type, and can overrided the following magic methods to insert your logic.</source>
          <target state="translated">当你定义metaclass时,你的子类类型,可以覆盖以下神奇的方法来插入你的逻辑。</target>
        </trans-unit>
        <trans-unit id="a0ebc00ce2803c4b05ae16c519fdb6afbeecd7c8" translate="yes" xml:space="preserve">
          <source>would be:</source>
          <target state="translated">会是:</target>
        </trans-unit>
        <trans-unit id="f00aae84260cf328c69240a8408c132eec41893a" translate="yes" xml:space="preserve">
          <source>you can add attributes to it</source>
          <target state="translated">你可以给它添加属性</target>
        </trans-unit>
        <trans-unit id="7f5329be6ce9f06a3c0b500a9af459ec3e4c8730" translate="yes" xml:space="preserve">
          <source>you can assign it to a variable</source>
          <target state="translated">你可以把它分配给一个变量</target>
        </trans-unit>
        <trans-unit id="d5e1f2ccb7cae42051601ddb1f83165a911f6cab" translate="yes" xml:space="preserve">
          <source>you can copy it</source>
          <target state="translated">你可以复制</target>
        </trans-unit>
        <trans-unit id="98b6e75ac98f8c1aab7ac264a673d0bea107ebd2" translate="yes" xml:space="preserve">
          <source>you can pass it as a function parameter</source>
          <target state="translated">你可以把它作为一个函数参数传递给</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
