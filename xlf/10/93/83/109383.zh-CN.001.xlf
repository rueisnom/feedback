<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/109383">
    <body>
      <group id="109383">
        <trans-unit id="59210f2b08d26d330e9074712c1c876a8c43f87b" translate="yes" xml:space="preserve">
          <source>&quot;Full&quot; answer/Live sorted map by values</source>
          <target state="translated">&quot;完整 &quot;答案按值排序的地图</target>
        </trans-unit>
        <trans-unit id="24f34a79fd761c933410c9714132422070ab3ae2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NB&lt;/em&gt;: If you are going to use a TreeMap, remember that if a comparison == 0, then the item is already in the list (which will happen if you have multiple values that compare the same).  To alleviate this, you could add your key to the comparator like so (presuming that your keys and values are &lt;code&gt;Comparable&lt;/code&gt;):</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：如果要使用TreeMap，请记住，如果比较== 0，则该项目已经在列表中（如果您有多个比较相同的值，则会发生此情况）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了减轻这种情况，您可以像这样将键添加到比较器中（假设键和值是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f47325a6fc8222fddd98d7d45f0e52b07510dabd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Approach&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最佳方法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1455ec89bb946aa7c607ee9824d6f539e07c38a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Given Map&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给定地图&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8180e08a074019aecc5b3655f03e62cb28a40fb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This has changed significantly in June 2012 - the previous code could never work: an internal HashMap is required to lookup the values without creating an infinite loop between the &lt;code&gt;TreeMap.get()&lt;/code&gt; -&amp;gt; &lt;code&gt;compare()&lt;/code&gt; and &lt;code&gt;compare()&lt;/code&gt; -&amp;gt; &lt;code&gt;get()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意：这种情况在2012年6月发生了重大变化-以前的代码无法正常工作：需要内部HashMap来查找值，而无需在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;TreeMap.get()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&amp;gt; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;compare()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;compare()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&amp;gt; &lt;/font&gt; &lt;code&gt;get()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;之间创建无限循环。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（）&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d12b121dd20db5c6fbdbda026bff85f6c3142492" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75116e5dff5e402b94cd5e09a93676a05bdbad87" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sort the map based on the value in ascending order&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据值升序对地图排序&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c1cf3cec9acba942c0f6db02c2b7ed840b8937b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sort the map based on value in desending order&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据值以降序对地图排序&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b321740a16a805ff8e622cd42e8145251809e12f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This code can break in multiple ways.&lt;/strong&gt; If you intend to use the code provided, be sure to read the comments as well to be aware of the implications. For example, values can no longer be retrieved by their key. (&lt;code&gt;get&lt;/code&gt; always returns &lt;code&gt;null&lt;/code&gt;.)</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该代码可以以多种方式破坏。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您打算使用提供的代码，请务必阅读注释，并注意其中的含义。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，无法再通过键检索值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;get&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;始终返回&lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a34d20822ab2f8404ff70541e222d92cfd66320b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Three 1-line answers...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;三个1行答案...&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e07ef7a777bdef36155b1aed7bcd56dbe0b842a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;inputUnsortedMap&lt;/strong&gt; is the input to the code.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;inputUnsortedMap&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是代码的输入。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="28138231f05aeaef17c033812972459fd2f8fb4e" translate="yes" xml:space="preserve">
          <source>= &lt;em&gt;Apply natural ordering to the value mapped by the key, and compound that with the natural ordering of the key&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;= &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将自然顺序应用于键所映射的值，并将其与键的自然顺序进行复合&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="abe33cac7b24cd1b4480a616ed422035183bd2d5" translate="yes" xml:space="preserve">
          <source>Afaik the most cleaner way is utilizing collections to sort map on value:</source>
          <target state="translated">Afaik最干净的方法是利用集合来对值进行排序映射。</target>
        </trans-unit>
        <trans-unit id="8bcb0e3c67a835c2b781df27ba3939902bc460d3" translate="yes" xml:space="preserve">
          <source>And as the last point I'll add simple iterator:</source>
          <target state="translated">而作为最后一点,我会加上简单的迭代器。</target>
        </trans-unit>
        <trans-unit id="6d628eccce9ad2ce1393f4a9fde0250c66bb27d4" translate="yes" xml:space="preserve">
          <source>And here is an embarrassingly incomplete unit test:</source>
          <target state="translated">而这里是一个尴尬的不完整的单元测试。</target>
        </trans-unit>
        <trans-unit id="7814e93746d456622d58195d74d5efbfabb45dfa" translate="yes" xml:space="preserve">
          <source>And if you don't want to use these framework... they come with source code.</source>
          <target state="translated">如果你不想用这些框架......他们会附带源代码。</target>
        </trans-unit>
        <trans-unit id="a6642e0e19da4f3fc763ebc54c91b57a8189efe3" translate="yes" xml:space="preserve">
          <source>Based on @devinmoore code, a map sorting methods using generics and supporting both ascending and descending ordering.</source>
          <target state="translated">基于@devinmoore的代码,使用属相排序方法,支持升序和降序排序。</target>
        </trans-unit>
        <trans-unit id="1d7ac361a6b0bb62efb129ec2135318521275d21" translate="yes" xml:space="preserve">
          <source>Create customized comparator and use it while creating new TreeMap object.</source>
          <target state="translated">创建自定义比较器,并在创建新的TreeMap对象时使用它。</target>
        </trans-unit>
        <trans-unit id="ab0cf0466a19667cd5504338bae8079c30855ead" translate="yes" xml:space="preserve">
          <source>Depending on the context, using &lt;code&gt;java.util.LinkedHashMap&amp;lt;T&amp;gt;&lt;/code&gt; which rememebers the order in which items are placed into the map.  Otherwise, if you need to sort values based on their natural ordering, I would recommend maintaining a separate List which can be sorted via &lt;code&gt;Collections.sort()&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据上下文，使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.util.LinkedHashMap&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来记住项目在地图中的放置顺序。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;否则，如果您需要根据值的自然顺序对值进行排序，我建议您维护一个单独的List，该列表可以通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Collections.sort()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行排序&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4053369ef0133035b8f91efc19166be7bfd3d95" translate="yes" xml:space="preserve">
          <source>Don't try the comparators above on a &lt;code&gt;TreeMap&lt;/code&gt;; there's no point trying to compare an inserted key when it doesn't have a value until after the put, i.e., it will break really fast</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不要在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;TreeMap&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上尝试上面的比较器&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在插入之前没有值的情况下尝试比较插入的键是没有意义的，即，它将很快中断&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b77083671289f2571c8f08230f320ac253f1e7c1" translate="yes" xml:space="preserve">
          <source>Don't worry though; if you were obsessed enough with having a &quot;live&quot; map sorted in this manner, you could solve not one but both(!) of the above issues with something crazy like the following:</source>
          <target state="translated">不过别担心,如果你足够执着于有一个 &quot;活的 &quot;地图以这种方式排序,你可以用下面这样疯狂的东西来解决上述问题,不是一个,而是两个(!)。</target>
        </trans-unit>
        <trans-unit id="5e297a41e8ef5ac08adf9ee0810c2244721fa92b" translate="yes" xml:space="preserve">
          <source>Eg:</source>
          <target state="translated">Eg:</target>
        </trans-unit>
        <trans-unit id="b4b3c9f0a22fd38968fff79f6e3693c798293b52" translate="yes" xml:space="preserve">
          <source>Finally, if you need to continously access the sorted information (rather than just sorting it once in a while), you can use an additional multi map. Let me know if you need more details...</source>
          <target state="translated">最后,如果你需要持续地获取排序信息(而不是偶尔排序一次),可以使用额外的多地图。如果你需要更多的细节,请告诉我......</target>
        </trans-unit>
        <trans-unit id="91779b7bc7a8678dd76731684aa5de7e25a37f72" translate="yes" xml:space="preserve">
          <source>For me it worked fine to adjust the comparator, if it equals do not return 0 but -1.</source>
          <target state="translated">对我来说,它可以很好地调整比较器,如果它等于不返回0,而是-1。</target>
        </trans-unit>
        <trans-unit id="8e406a246e214fab960dc0b3f305274417f48a0c" translate="yes" xml:space="preserve">
          <source>For reverse ordering, replace:</source>
          <target state="translated">对于逆向订购,请更换。</target>
        </trans-unit>
        <trans-unit id="53025cbca741873d6864b1a49b4f17f8a1e6fbbd" translate="yes" xml:space="preserve">
          <source>For sure the solution of Stephen is really great, but for those who can't use Guava:</source>
          <target state="translated">当然,史蒂芬的解决方案确实很好,但对于不会使用番石榴的人来说。</target>
        </trans-unit>
        <trans-unit id="bca8a2d6906fd6ec7b91d1353a79f62dfa010e80" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://www.programmersheaven.com/download/49349/download.aspx&quot;&gt;http://www.programmersheaven.com/download/49349/download.aspx&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.programmersheaven.com/download/49349/download.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.programmersheaven.com/download/49349/download.aspx&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56a87779c28758fc061e9ef20e880e2cdeac315c" translate="yes" xml:space="preserve">
          <source>Here is a solution that I think fits better:</source>
          <target state="translated">这里有一个我认为比较适合的解决方案。</target>
        </trans-unit>
        <trans-unit id="139f56c76399a711c8997f96d98e566e40c24f0d" translate="yes" xml:space="preserve">
          <source>Here is an OO solution (i.e., doesn't use &lt;code&gt;static&lt;/code&gt; methods):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个OO解决方案（即，不使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;static&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c533c62227f4b7c2270b57f90b436d33422eae0" translate="yes" xml:space="preserve">
          <source>Here's a generic version of such a thing:</source>
          <target state="translated">这里有一个通用版的这样的东西。</target>
        </trans-unit>
        <trans-unit id="084fe78490cb0d73e4a3807b7c36dde72217acab" translate="yes" xml:space="preserve">
          <source>Here's a generic-friendly version:</source>
          <target state="translated">这里有一个通用的友好版。</target>
        </trans-unit>
        <trans-unit id="9ac0ebba1bd0f6ef3b804bbac08300bd0d50871c" translate="yes" xml:space="preserve">
          <source>Here's a more efficient albeit less appealing version:</source>
          <target state="translated">这里有一个更有效的版本,尽管没有那么吸引人。</target>
        </trans-unit>
        <trans-unit id="5e29940c32e352c554753e7c84c8ed529fb6af4e" translate="yes" xml:space="preserve">
          <source>Here's my solution for sorting by value a map.
This solution handle the case where there are twice the same value etc...</source>
          <target state="translated">下面是我对按值排序地图的解决方案。这个解决方案可以处理有两次相同的值等的情况。</target>
        </trans-unit>
        <trans-unit id="fd68565812d25e5ceec29703dbcb893980a46c19" translate="yes" xml:space="preserve">
          <source>Hereby donated to the public domain.</source>
          <target state="translated">特此捐献给公共领域。</target>
        </trans-unit>
        <trans-unit id="de896150fc621e06779026f9882ddc4af288aa1f" translate="yes" xml:space="preserve">
          <source>Hope it will help some folks</source>
          <target state="translated">希望能帮到一些朋友们</target>
        </trans-unit>
        <trans-unit id="67c95dc6919a41c84123a1ba99f5ca2979c22d8b" translate="yes" xml:space="preserve">
          <source>I am relatively new to Java, and often find that I need to sort a &lt;code&gt;Map&amp;lt;Key, Value&amp;gt;&lt;/code&gt; on the values.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我对Java比较陌生，经常发现我需要对值进行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Map&amp;lt;Key, Value&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;排序&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="908c833d407b4a2c8b6db9e9799a55f6b8119602" translate="yes" xml:space="preserve">
          <source>I cooked up a generic friendly example that solves this use case. This implementation does not honor all of the contracts of the Map interface, such as reflecting value changes and removals in the sets return from keySet() and entrySet() in the original object. I felt such a solution would be too large to include in a Stack Overflow answer. If I manage to create a more complete implementation, perhaps I will post it to Github and then to it link in an updated version of this answer.</source>
          <target state="translated">我做了一个通用的友好示例,解决了这个用例。这个实现并不尊重Map接口的所有契约,比如在keySet()和entrySet()返回的集中反映值的变化和删除,在原始对象中反映值的变化和删除。我觉得这样的解决方案太大,不可能包含在 Stack Overflow 的答案中。如果我设法创建了一个更完整的实现,也许我会把它贴到Github上,然后在这个答案的更新版本中加入它的链接。</target>
        </trans-unit>
        <trans-unit id="317031672a0e89f6c2a629b6a08edb25468f3be6" translate="yes" xml:space="preserve">
          <source>I would use &lt;s&gt;Google Collections&lt;/s&gt;&lt;a href=&quot;http://code.google.com/p/guava-libraries/&quot;&gt;&lt;strong&gt;Guava&lt;/strong&gt;&lt;/a&gt; to do this - if your values are &lt;code&gt;Comparable&lt;/code&gt; then you can use</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我会用&lt;/font&gt;&lt;/font&gt;&lt;s&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Google Collections &lt;/font&gt;&lt;/font&gt;&lt;/s&gt;&lt;a href=&quot;http://code.google.com/p/guava-libraries/&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Guava&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;做到这一点-如果您的值&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那么您可以使用&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a85e4803753bab14df9e953288e5b01e3e3ce743" translate="yes" xml:space="preserve">
          <source>I've looked at the given answers, but a lot of them are more complicated than needed or remove map elements when several keys have same value.</source>
          <target state="translated">我看了一下给定的答案,但很多都比需要的复杂,或者当几个键的值相同时,删除地图元素。</target>
        </trans-unit>
        <trans-unit id="663337f61010a182644be7174423fc45b482972b" translate="yes" xml:space="preserve">
          <source>If the values are not comparable, you can pass an explicit comparator:</source>
          <target state="translated">如果值不具有可比性,可以通过一个显式比较器。</target>
        </trans-unit>
        <trans-unit id="f9d378d984dd82ac33a3950da1cdf1f52e09157b" translate="yes" xml:space="preserve">
          <source>If they're not comparable, then you'll need to do something along the lines of</source>
          <target state="translated">如果它们不具备可比性,那么你就需要做一些类似的事情。</target>
        </trans-unit>
        <trans-unit id="634e2e6c5860e8e445a868183470782068063016" translate="yes" xml:space="preserve">
          <source>If you have duplicate keys and only a small set of data (&amp;lt;1000) and your code is not performance critical you can just do the following:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您有重复的键并且只有少量数据（&amp;lt;1000），并且您的代码对性能没有要求，则可以执行以下操作：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3d4e611d915be2e33259d2008d321245d328e4a8" translate="yes" xml:space="preserve">
          <source>Important note:</source>
          <target state="translated">重要提示:</target>
        </trans-unit>
        <trans-unit id="f883c4ace034e3fd6f1007d660d4ff9a9ac4eda3" translate="yes" xml:space="preserve">
          <source>In example lower you are supposed to add TreeMap a comparator at place where * is. But by java API it gives comparator only keys, not values. All of examples stated here is based on 2 Maps. One Hash and one new Tree. Which is odd.</source>
          <target state="translated">在下面的例子中,你应该在*所在的地方添加一个比较器TreeMap。但是通过java API,它只给了比较器键,而不是值。这里所说的所有例子都是基于2个地图。一个Hash和一个新的Tree。这很奇怪。</target>
        </trans-unit>
        <trans-unit id="6586d1e2257bdfe2162cfb24c0698d16633d478f" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;Collections.sort&lt;/code&gt; as some do I'd suggest using &lt;code&gt;Arrays.sort&lt;/code&gt;. Actually what &lt;code&gt;Collections.sort&lt;/code&gt; does is something like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;建议不要使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Collections.sort&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;建议使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Collections.sort&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所做的是这样的：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="991c135400c02792721d8921359dce25deb031b3" translate="yes" xml:space="preserve">
          <source>Is not the fastest sort but does the job without any additional dependencies.</source>
          <target state="translated">并不是最快的排序,但不需要任何额外的依赖就能完成工作。</target>
        </trans-unit>
        <trans-unit id="b75f10d2fbf40f7c5b8a003fa03c3c07e643fab4" translate="yes" xml:space="preserve">
          <source>Is there an easier way?</source>
          <target state="translated">有没有更简单的方法?</target>
        </trans-unit>
        <trans-unit id="d7c0f8bb8d0763b15d4d8a0fcb314fc4f565812c" translate="yes" xml:space="preserve">
          <source>It just calls &lt;code&gt;toArray&lt;/code&gt; on the list and then uses &lt;code&gt;Arrays.sort&lt;/code&gt;. This way all the map entries will be copied three times: once from the map to the temporary list (be it a LinkedList or ArrayList), then to the temporary array and finally to the new map.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它只是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在列表上&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;toArray&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样，所有映射条目将被复制三次：一次从映射复制到临时列表（可以是LinkedList或ArrayList），然后复制到临时数组，最后复制到新映射。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="93c570b18e4444f9f408bb17babdf2f8e266be3c" translate="yes" xml:space="preserve">
          <source>It seems much easier than all of the foregoing. Use a TreeMap as follows:</source>
          <target state="translated">这似乎比前述的都要简单得多。使用TreeMap的方法如下。</target>
        </trans-unit>
        <trans-unit id="c83aa2b8e919834fc179d59370ab0766046987f6" translate="yes" xml:space="preserve">
          <source>Java 8 offers a new answer: convert the entries into a stream, and use the comparator combinators from Map.Entry:</source>
          <target state="translated">Java 8提供了一个新的答案:将条目转换为流,并使用Map.Entry.Comparator组合器。</target>
        </trans-unit>
        <trans-unit id="da486f4bf629dc5b76595ff52258d020b8a1628b" translate="yes" xml:space="preserve">
          <source>Late Entry.</source>
          <target state="translated">迟入。</target>
        </trans-unit>
        <trans-unit id="85e93491091c6837f83f8099436c3104aec0e1f2" translate="yes" xml:space="preserve">
          <source>Major problem. If you use the first answer (Google takes you here), change the comparator to add an equal clause, otherwise you cannot get values from the sorted_map by keys:</source>
          <target state="translated">主要的问题。如果你使用第一个答案(Google带你到这里),那么就把比较器改成增加一个等价子句,否则你无法从排序_map中通过key得到值。</target>
        </trans-unit>
        <trans-unit id="db4bc4dee0cc64da3139b564ccd0fe3a577f993e" translate="yes" xml:space="preserve">
          <source>Map base;
      public ValueComparator(Map base) {
          this.base = base;
      }</source>
          <target state="translated">Map base;public ValueComparator(Map base){this.base=base;}</target>
        </trans-unit>
        <trans-unit id="1c3b47602d39948f4c5aaa0860739da90b5ecdab" translate="yes" xml:space="preserve">
          <source>My solution ommits this one step as it does not create unnecessary LinkedList. Here is the code, generic-friendly and performance-optimal:</source>
          <target state="translated">我的解决方案不需要这一步,因为它不会创建不必要的LinkedList。下面是代码,通用友好,性能最佳。</target>
        </trans-unit>
        <trans-unit id="a416e119e42ab799185af74495aabb338a062eb4" translate="yes" xml:space="preserve">
          <source>Note that it's rather up in the air how to handle nulls.</source>
          <target state="translated">需要注意的是,如何处理空号是个相当大的问题。</target>
        </trans-unit>
        <trans-unit id="7e0344ffe6a7120425ae3fbaf57827c1fd6625f8" translate="yes" xml:space="preserve">
          <source>Note that the map is sorted from the highest value to the lowest.</source>
          <target state="translated">注意,地图是由最高值到最低值排序的。</target>
        </trans-unit>
        <trans-unit id="ef6a9570551cc08f58c8d148af9cf23cd42b2d22" translate="yes" xml:space="preserve">
          <source>Note that this will still not work if your keys compare to 0, but this should be sufficient for most &lt;code&gt;comparable&lt;/code&gt; items (as &lt;code&gt;hashCode&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;compareTo&lt;/code&gt; are often in sync...)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，如果您的键比较为0，这仍然不起作用，但是对于大多数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;comparable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;项目&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这已经足够了&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（因为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;hashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;equals&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;compareTo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常是同步的...）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4355eb0b2e5df1a98aae42fe20a2be8a874a9740" translate="yes" xml:space="preserve">
          <source>Now this will most likely work work, but:</source>
          <target state="translated">现在,这很可能会起到作用,但。</target>
        </trans-unit>
        <trans-unit id="f7720bc28b3f9e58540d0f4b5aa865986012280c" translate="yes" xml:space="preserve">
          <source>One important advantage of this approach is that it actually returns a Map, unlike some of the other solutions offered here.</source>
          <target state="translated">这种方法的一个重要优点是,它实际上返回了一张地图,与这里提供的其他一些解决方案不同。</target>
        </trans-unit>
        <trans-unit id="8e6fcb1ea485639b4d6636b9c4b0b4977af0b4bb" translate="yes" xml:space="preserve">
          <source>Or print to &lt;code&gt;System.out&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或打印到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.out&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="d2861ff73b05fc8241a4c85b96d71884a6634759" translate="yes" xml:space="preserve">
          <source>Point 1 is a bit of a deal-breaker for me; google collections is incredibly lazy (which is good: you can do pretty much every operation in an instant; the real work is done when you start using the result), and this requires copying a &lt;em&gt;whole&lt;/em&gt; map!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一点对我来说有点麻烦了；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;google collections非常懒惰（这很好：您可以立即执行几乎所有操作；当您开始使用结果时，实际工作就完成了），这需要复制&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;整个&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;地图！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="98ea47745006dea89293ca840f3a5ad25b683fb2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/collect/Ordering.html#onResultOf(com.google.common.base.Function)&quot;&gt;Ordering.onResultOf()&lt;/a&gt; and &lt;a href=&quot;http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/base/Functions.html#forMap(java.util.Map)&quot;&gt;Functions.forMap()&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参阅&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/collect/Ordering.html#onResultOf(com.google.common.base.Function)&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ordering.onResultOf（）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/base/Functions.html#forMap(java.util.Map)&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Functions.forMap（）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7ae9128126439315f3fe5b57e92b16bd5aeefaa3" translate="yes" xml:space="preserve">
          <source>Since &lt;strong&gt;&lt;em&gt;TreeMap&amp;lt;&amp;gt; does not work&lt;/em&gt;&lt;/strong&gt; for values that can be equal, I used this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TreeMap &amp;lt;&amp;gt;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于相等的值&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不起作用&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此我使用了以下方法：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2560d76da03a973d81dc40969c1168afacb43741" translate="yes" xml:space="preserve">
          <source>Since the values are not unique, I find myself converting the &lt;code&gt;keySet&lt;/code&gt; into an &lt;code&gt;array&lt;/code&gt;, and sorting that array through &lt;strong&gt;array sort&lt;/strong&gt; with a &lt;strong&gt;custom comparator&lt;/strong&gt; that sorts on the value associated with the key.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于值不是唯一的，因此我发现自己将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;keySet&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;array&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自定义比较器&lt;/font&gt;&lt;/strong&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组进行&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;排序&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，该&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自定义比较器&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对与键关联的值进行排序。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e5e0de973edbeefbc690e381c5294117ccaacdb" translate="yes" xml:space="preserve">
          <source>So change the map into a set this way:</source>
          <target state="translated">所以把地图改成这样的套路。</target>
        </trans-unit>
        <trans-unit id="6f0d43b1bb10002aa10059b154ca589ad700d52b" translate="yes" xml:space="preserve">
          <source>So leaves out E!!</source>
          <target state="translated">那就把E给忘了!</target>
        </trans-unit>
        <trans-unit id="20546584e598da1a7b70e4b09221b905bd1015ac" translate="yes" xml:space="preserve">
          <source>So now that we've got a comparator that does what we want, we need to get a result from it.</source>
          <target state="translated">所以,现在我们已经有了一个比较器来做我们想要的事情,我们需要从中得到一个结果。</target>
        </trans-unit>
        <trans-unit id="94ef289c163c75bc16c30b324e624ee8f4a98a5e" translate="yes" xml:space="preserve">
          <source>Some simple changes in order to have a sorted map with pairs that have duplicate values. In the compare method (class ValueComparator) when values are equal do not return 0 but return the result of comparing the 2 keys. Keys are distinct in a map so you succeed to keep duplicate values (which are sorted by keys by the way). So the above example could be modified like this:</source>
          <target state="translated">一些简单的修改,以便有一个有重复值的对的排序图。在比较方法(类ValueComparator)中,当值相等时不返回0,而是返回2个键的比较结果。键在地图中是有区别的,所以你可以成功地保留重复的值(顺便说一下,这些值是按键排序的)。所以上面的例子可以这样修改。</target>
        </trans-unit>
        <trans-unit id="030ced435e55b2bcce84e017b1b7d183f00f27c4" translate="yes" xml:space="preserve">
          <source>Sort a Map&lt;Key, Value&gt; by values</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;排序地图&lt;/font&gt;&lt;/font&gt;&lt;key, value=&quot;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 按值&lt;/font&gt;&lt;/font&gt;&lt;/key,&gt;</target>
        </trans-unit>
        <trans-unit id="4a0bb84d0747e0eff183b9159d67a14ec1d37164" translate="yes" xml:space="preserve">
          <source>Sorting the keys requires the Comparator to look up each value for each comparison. A more scalable solution would use the entrySet directly, since then the value would be immediately available for each comparison (although I haven't backed this up by numbers).</source>
          <target state="translated">对键进行排序,需要Comparator为每个比较器查找每个值。一个更可扩展的解决方案是直接使用entrySet,因为这样一来,每个比较的值就会立即可用(虽然我还没有用数字来证明)。</target>
        </trans-unit>
        <trans-unit id="48db8e95acb16a961456895bc67db00673426ef9" translate="yes" xml:space="preserve">
          <source>The answer voted for the most does not work when you have 2 items that equals.
the TreeMap leaves equal values out.</source>
          <target state="translated">当你有2个等值的项目时,投给最多的答案就不起作用了。</target>
        </trans-unit>
        <trans-unit id="41e61a3bfd970356553f26101c2af79d288ac372" translate="yes" xml:space="preserve">
          <source>The commons-collections library contains a solution called &lt;a href=&quot;http://commons.apache.org/collections/api-release/org/apache/commons/collections/bidimap/TreeBidiMap.html&quot;&gt;TreeBidiMap&lt;/a&gt;. Or, you could have a look at the Google Collections API. It has &lt;a href=&quot;http://google-collections.googlecode.com/svn/trunk/javadoc/com/google/common/collect/TreeMultimap.html&quot;&gt;TreeMultimap&lt;/a&gt; which you could use.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;commons-collections库包含一个名为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://commons.apache.org/collections/api-release/org/apache/commons/collections/bidimap/TreeBidiMap.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TreeBidiMap&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的解决方案&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或者，您可以查看Google Collections API。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它具有&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://google-collections.googlecode.com/svn/trunk/javadoc/com/google/common/collect/TreeMultimap.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TreeMultimap&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d6e545f68964fa59f0aa976d9f8863418abd5b21" translate="yes" xml:space="preserve">
          <source>The constructor would need to be called as</source>
          <target state="translated">构造函数需要按以下方式调用</target>
        </trans-unit>
        <trans-unit id="3f75b35c9e243539d4c076bc6bc600ed9af292c2" translate="yes" xml:space="preserve">
          <source>The entries are ordered by their values using the given comparator. Alternatively, if your values are mutually comparable, no explicit comparator is needed:</source>
          <target state="translated">条目是用给定的比较器按其值排序。或者,如果你的值是相互可比的,则不需要明确的比较器。</target>
        </trans-unit>
        <trans-unit id="02092979de37d83b5ad53f06cac684737782c70a" translate="yes" xml:space="preserve">
          <source>The example:</source>
          <target state="translated">的例子。</target>
        </trans-unit>
        <trans-unit id="35b977c4d4b3f28a69e6b4a7df89b951f0f8fe12" translate="yes" xml:space="preserve">
          <source>The exec:
&lt;a href=&quot;http://www.ideone.com/dq3Lu&quot;&gt;http://www.ideone.com/dq3Lu&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;执行人员：&lt;/font&gt;&lt;a href=&quot;http://www.ideone.com/dq3Lu&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//www.ideone.com/dq3Lu&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">的输出。</target>
        </trans-unit>
        <trans-unit id="3b721cdb3444c2e9ece1f65adc6d3da26eeb67d2" translate="yes" xml:space="preserve">
          <source>The result is a sorted list of Map.Entry objects, from which you can obtain the keys and values.</source>
          <target state="translated">结果是一个Map.Entry对象的排序列表,你可以从中获得键和值。</target>
        </trans-unit>
        <trans-unit id="bad039ad9a868f2d0bd4b4a2325abfa3c2035442" translate="yes" xml:space="preserve">
          <source>The returned iterable creates a fresh snapshot of the given map each time it's iterated, so barring concurrent modification, it will always reflect the current state of the map.</source>
          <target state="translated">每次迭代的时候,返回的迭代器都会创建一个新的地图快照,因此,除非并发修改,否则它将始终反映地图的当前状态。</target>
        </trans-unit>
        <trans-unit id="6600a621bf571421e93b166cdc9c42f89b8b645f" translate="yes" xml:space="preserve">
          <source>The returned list is a snapshot of the given map at the time this method is called, so neither will reflect subsequent changes to the other. For a live iterable view of the map:</source>
          <target state="translated">返回的列表是在调用此方法时给定地图的快照,所以两者都不会反映另一个的后续变化。对于地图的实时迭代视图。</target>
        </trans-unit>
        <trans-unit id="a3b99c1410faa23e32144b3fcd1d422616689057" translate="yes" xml:space="preserve">
          <source>The variable &lt;strong&gt;sortedOutputMap&lt;/strong&gt; will contain the data in decending order when iterated over. To change order just change &amp;gt; to a &amp;lt; in the if statement.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;迭代时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，变量&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sortedOutputMap&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将包含&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;降序排列&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的数据。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要更改顺序，只需在if语句中将&amp;gt;更改为&amp;lt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59f1fdb04544d382583d9db4f0fd9c6f4627cb44" translate="yes" xml:space="preserve">
          <source>There are a lot of answers for this question already, but none provided me what I was looking for, a map implementation that returns keys and entries sorted by the associated value, and maintains this property as keys and values are modified in the map. Two &lt;a href=&quot;https://stackoverflow.com/q/13108887/1760575&quot;&gt;other&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/q/7465369/1760575&quot;&gt;questions&lt;/a&gt; ask for this specifically.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个问题已经有很多答案，但是没有一个提供我所要的东西，一个地图实现返回按相关值排序的键和条目，并在映射中修改键和值时保持此属性。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两个&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/q/13108887/1760575&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其他&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/q/7465369/1760575&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;问题&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;询问此特别。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1209839bd6cf14dede97d52af2da744845f7f6c8" translate="yes" xml:space="preserve">
          <source>There are ways to lessen memory rotation for the above solution. The first ArrayList created could for instance be re-used as a return value; this would require suppression of some generics warnings, but it might be worth it for re-usable library code. Also,  the Comparator does not have to be re-allocated at every invocation.</source>
          <target state="translated">对于上述解决方案,有一些方法可以减少内存轮换。例如,创建的第一个ArrayList可以作为返回值被重复使用;这需要抑制一些属性警告,但对于可重用的库代码来说,这可能是值得的。另外,比较器不需要在每次调用时重新分配。</target>
        </trans-unit>
        <trans-unit id="b12f5e6b473cc157b1424d13a04089509927952a" translate="yes" xml:space="preserve">
          <source>These may be applied to a TreeMap (as &lt;code&gt;Ordering&lt;/code&gt; extends &lt;code&gt;Comparator&lt;/code&gt;), or a &lt;a href=&quot;https://stackoverflow.com/questions/109383/how-to-sort-a-mapkey-value-on-the-values-in-java/109389#109389&quot;&gt;LinkedHashMap after some sorting&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这些可以应用于TreeMap（随着&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Ordering&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;扩展&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），或&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应用于&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/109383/how-to-sort-a-mapkey-value-on-the-values-in-java/109389#109389&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;某些排序后&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LinkedHashMap&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6979c71753a0155d90f3027d1c6f82d7b3cb6d26" translate="yes" xml:space="preserve">
          <source>This is a variation of Anthony's answer, which doesn't work if there are duplicate values:</source>
          <target state="translated">这是安东尼的答案的变种,如果有重复值的话,这个答案就不起作用了。</target>
        </trans-unit>
        <trans-unit id="a811c4132ea0a610461d949d5c7ba1c70cfca427" translate="yes" xml:space="preserve">
          <source>This is just too complicated. Maps were not supposed to do such job as sorting them by Value. The easiest way is to create your own Class so it fits your requirement.</source>
          <target state="translated">这实在是太复杂了。地图不应该做这样的工作,比如按Value排序。最简单的方法就是创建自己的类,这样才符合你的要求。</target>
        </trans-unit>
        <trans-unit id="d286cc2e485a6d93d49f6c91c48c8676c5d6c240" translate="yes" xml:space="preserve">
          <source>This way you can easily add more dependencies.</source>
          <target state="translated">这样,你可以轻松地添加更多的依赖关系。</target>
        </trans-unit>
        <trans-unit id="7bb53a9ee7a3be4c0ad640c2617047bbab35fedd" translate="yes" xml:space="preserve">
          <source>This will let you consume the entries sorted in ascending order of value.  If you want descending value, simply reverse the comparator:</source>
          <target state="translated">这将使你可以使用按值的升序排列的条目。如果你想要降序,只需反转比较器即可。</target>
        </trans-unit>
        <trans-unit id="4ad3c99013fc121493dd959d33868e7de262e3a8" translate="yes" xml:space="preserve">
          <source>To accomplish this with the new features in Java 8:</source>
          <target state="translated">要实现这一点,需要借助Java 8中的新功能。</target>
        </trans-unit>
        <trans-unit id="92d4a6e82e1399c0d8cff002a694c0469b844052" translate="yes" xml:space="preserve">
          <source>Use a generic comparator such as :</source>
          <target state="translated">使用一个通用的比较器,如.NET Framework,使用通用的比较器。</target>
        </trans-unit>
        <trans-unit id="1193f8d0b344715897c6483e3c90b40961a6ced9" translate="yes" xml:space="preserve">
          <source>Use the below code in your main func</source>
          <target state="translated">在你的主函数中使用下面的代码</target>
        </trans-unit>
        <trans-unit id="520f4a950c7805fdf4ff5d4a995c173724866eaf" translate="yes" xml:space="preserve">
          <source>When we put, we ensure that the hash map has the value for the comparator, and then put to the TreeSet for sorting. But before that we check the hash map to see that the key is not actually a duplicate. Also, the comparator that we create will also include the key so that duplicate values don't delete the non-duplicate keys (due to == comparison).
These 2 items are &lt;em&gt;vital&lt;/em&gt; for ensuring the map contract is kept; if you think you don't want that, then you're almost at the point of reversing the map entirely (to &lt;code&gt;Map&amp;lt;V,K&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;放置时，确保哈希图具有比较器的值，然后将其放入TreeSet进行排序。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是在此之前，我们检查哈希图以查看该密钥实际上不是重复项。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另外，我们创建的比较器还将包含键，以便重复值不会删除非重复键（由于==比较）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这两个项目&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于确保遵守地图合同&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;至关重要&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您认为自己不想这样做，那么您几乎就要完全反转地图了（到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Map&amp;lt;V,K&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b3800ae2840c02be0d42b5cd0fb00d1591c94eae" translate="yes" xml:space="preserve">
          <source>Which will create a function (object) for the map [that takes any of the keys as input, returning the respective value], and then apply natural (comparable) ordering to them [the values].</source>
          <target state="translated">这将为地图创建一个函数(对象)[把任何一个键作为输入,返回相应的值],然后对它们[值]进行自然(可比性)排序。</target>
        </trans-unit>
        <trans-unit id="ac9a4decda199cbf299b80fbb8b703acf08cb93e" translate="yes" xml:space="preserve">
          <source>While I agree that the constant need to sort a map is probably a smell, I think the following code is the easiest way to do it without using a different data structure.</source>
          <target state="translated">虽然我同意不断需要对地图进行排序可能是一种味道,但我认为下面的代码是最简单的方法,不需要使用不同的数据结构就能做到。</target>
        </trans-unit>
        <trans-unit id="d7c9c4a0b243dba0863243e4440b8b1f7dfe26da" translate="yes" xml:space="preserve">
          <source>With Java 8, you can use the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;streams api&lt;/a&gt; to do it in a significantly less verbose way:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用Java 8，您可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;流api&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以明显更少的冗长方式进行操作：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d08aeac0e37b34150489ddefe62b7e0bf1af4e9b" translate="yes" xml:space="preserve">
          <source>With the advent of Java-8, we can use streams for data manipulation in a very easy/succinct way. You can use streams to sort the map entries by value and create a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html&quot;&gt;LinkedHashMap&lt;/a&gt; which preserves &lt;em&gt;insertion-order&lt;/em&gt; iteration.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;随着Java-8的出现，我们可以以非常简单/简洁的方式将流用于数据处理。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用流按值对映射条目进行排序，并创建一个&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LinkedHashMap&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来保留&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;插入顺序的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;迭代。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="61a9d2a8cce194ca596f4da2bd4c8529d8c4688b" translate="yes" xml:space="preserve">
          <source>You can then proceed to use other stream operations to consume the data. For example, if you want the top 10 in a new map:</source>
          <target state="translated">然后你就可以继续使用其他流操作来消耗数据。例如,如果你想在一个新地图中的前10名。</target>
        </trans-unit>
        <trans-unit id="4a8d92d6c54f8a8fc3b027577e1fc659355c4c4c" translate="yes" xml:space="preserve">
          <source>You might want to put &lt;strong&gt;&lt;em&gt;list&lt;/em&gt;&lt;/strong&gt; in a &lt;strong&gt;&lt;em&gt;LinkedHashMap&lt;/em&gt;&lt;/strong&gt;, but if you're only going to iterate over it right away, that's superfluous...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可能希望将&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;列表&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;放入&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LinkedHashMap中&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是如果仅要立即对其进行迭代，那将是多余的...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c207a3ee6f596118883f2fb3aa238a9d600e6b53" translate="yes" xml:space="preserve">
          <source>You will create class &lt;code&gt;Results&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您将创建类&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Results&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5c6b8ddb42ba96dd4c4fa8a69d04b9366e5de479" translate="yes" xml:space="preserve">
          <source>and the Comparator class:</source>
          <target state="translated">和比较器类。</target>
        </trans-unit>
        <trans-unit id="9a4e01b06fa70cd963fd0806cada0f3c129d33eb" translate="yes" xml:space="preserve">
          <source>and this is the test class (I just tested it, and this works for the Integer, String Map:</source>
          <target state="translated">和这个是测试类(我刚才测试了一下,这个对Integer,String Map的效果很好。</target>
        </trans-unit>
        <trans-unit id="63d7d60a93bb9d00a60d358f5823e138a7be4732" translate="yes" xml:space="preserve">
          <source>and this is the testcase for this:</source>
          <target state="translated">而这就是这个测试案例。</target>
        </trans-unit>
        <trans-unit id="4b34a8484641332075a7a6a8c58b504c1debcf0e" translate="yes" xml:space="preserve">
          <source>as a response to Aliens (2011 nov. 22):
I Am using this solution for a map of Integer Id's and names, but the idea is the same, so might be the code above is not correct (I will write it in a test and give you the correct code), this is the code for a Map sorting, based on the solution above:</source>
          <target state="translated">作为对外星人的回应(2011年11月22日)。我是用这个方案来做整数Id和名字的映射,但思路是一样的,所以可能是上面的代码不对(我会在测试中写出来,给你正确的代码),这是根据上面的方案,做了一个映射排序的代码。</target>
        </trans-unit>
        <trans-unit id="8f1f5dfdb484ce896928a3b42559b8791bae97a1" translate="yes" xml:space="preserve">
          <source>class ValueComparator implements Comparator {</source>
          <target state="translated">class ValueComparator implements Comparator {</target>
        </trans-unit>
        <trans-unit id="20f9d7abe77ceaa8e43570e4617e10ec897feb7e" translate="yes" xml:space="preserve">
          <source>here is the code for the Comparator of a Map:</source>
          <target state="translated">这里是地图比较器的代码。</target>
        </trans-unit>
        <trans-unit id="61a254bf4f1c04a77d3e03f4583b6ed73eaf3ceb" translate="yes" xml:space="preserve">
          <source>in the example:</source>
          <target state="translated">在这个例子中。</target>
        </trans-unit>
        <trans-unit id="6cac24b6691daafb3e026c0d154c06f28c692bad" translate="yes" xml:space="preserve">
          <source>needs to be done given a complete finished map</source>
          <target state="translated">需要完成一个完整的成品地图</target>
        </trans-unit>
        <trans-unit id="0dfff1cb67f373fc0eb5c32ed6e0375d8c0f139b" translate="yes" xml:space="preserve">
          <source>now it returns:</source>
          <target state="translated">现在它回来了。</target>
        </trans-unit>
        <trans-unit id="ce9b7d5944c4ca8809a3f11a4cc40ca740e2b7a9" translate="yes" xml:space="preserve">
          <source>of cource you can make this a lot more generic, but I just needed it for 1 case (the Map)</source>
          <target state="translated">的cource,你可以使这个更通用,但我只是需要它的1个案例(地图)。</target>
        </trans-unit>
        <trans-unit id="9db5a9dc748beadf9376377d4c6374fa017ac4aa" translate="yes" xml:space="preserve">
          <source>public int compare(Object a, Object b) {</source>
          <target state="translated">public int compare(Object a,Object b){</target>
        </trans-unit>
        <trans-unit id="cdf7e925f5746741c316f5fbcf39ad0dfca90775" translate="yes" xml:space="preserve">
          <source>results</source>
          <target state="translated">results</target>
        </trans-unit>
        <trans-unit id="32f066ab49d567aa0dda290679007c2477ad1732" translate="yes" xml:space="preserve">
          <source>results:</source>
          <target state="translated">results:</target>
        </trans-unit>
        <trans-unit id="98b53d73991861fe92d9df6865853de3b45489b4" translate="yes" xml:space="preserve">
          <source>the exmaple:
unsorted map</source>
          <target state="translated">exmaple:未排序的地图</target>
        </trans-unit>
        <trans-unit id="eed64825fd44a2f4999dca5fa77dd0db677c4dd3" translate="yes" xml:space="preserve">
          <source>unsorted map:</source>
          <target state="translated">未分类的地图。</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="9a3a7b33e4fd32b50e5145e2ec8541c7f8f730d2" translate="yes" xml:space="preserve">
          <source>{jobs=200, opportunity=200, USA=100, technology=70, software=50}</source>
          <target state="translated">{jobs=200,机会=200,美国=100,技术=70,软件=50}</target>
        </trans-unit>
        <trans-unit id="0ac30418555b78383f524d388809af86794686bb" translate="yes" xml:space="preserve">
          <source>{software=50, technology=70, USA=100, jobs=200, opportunity=200}</source>
          <target state="translated">{软件=50,技术=70,美国=100,工作机会=200,机会=200}。</target>
        </trans-unit>
        <trans-unit id="65873d0f887ce71b04e92d909ff1d67a4003826f" translate="yes" xml:space="preserve">
          <source>}
    }</source>
          <target state="translated">}}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
