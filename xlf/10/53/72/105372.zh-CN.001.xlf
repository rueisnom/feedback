<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/105372">
    <body>
      <group id="105372">
        <trans-unit id="204ee29d33b6243e0190c07dfb5eab1bae58afc9" translate="yes" xml:space="preserve">
          <source>'Suit' is a 'type' but is used like a 'variable'</source>
          <target state="translated">'Suit'是一个 &quot;类型&quot;,但使用起来却像 &quot;变量 &quot;一样。</target>
        </trans-unit>
        <trans-unit id="f2bf7d31a04dc34e0b6fb75921211d6512b3f1cc" translate="yes" xml:space="preserve">
          <source>(Actually, that's a bit more complicated than that - enum types are considered to have an &quot;underlying&quot; integer type, which means each enum value corresponds to an integer value (this is typically implicit, but can be manually specified). C# was designed in a way so that you could stuff &lt;em&gt;any&lt;/em&gt; integer of that type into the enum variable, even if it isn't a &quot;named&quot; value.)</source>
          <target state="translated">（实际上，这要复杂得多-枚举类型被认为具有&amp;ldquo;底层&amp;rdquo;整数类型，这意味着每个枚举值都对应一个整数值（这通常是隐式的，但可以手动指定）。C＃是设计的以便您可以将该类型的&lt;em&gt;任何&lt;/em&gt;整数填充到enum变量中，即使它不是&amp;ldquo;命名&amp;rdquo;值也是如此。）</target>
        </trans-unit>
        <trans-unit id="75c4d4b0e176e2184304b63994d713b095b617ae" translate="yes" xml:space="preserve">
          <source>(The current accepted answer has a cast that I don't think 
is needed (although I may be wrong).)</source>
          <target state="translated">(目前接受的答案中,有一个我认为不需要的投稿(虽然我可能错了))。</target>
        </trans-unit>
        <trans-unit id="ea0e98176aee6ddc771dbf3b53048227666d5df4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query&quot;&gt;LINQ&lt;/a&gt; Generic Way:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query&quot;&gt;LINQ&lt;/a&gt;通用方式：</target>
        </trans-unit>
        <trans-unit id="eff6af42e717cf5361127d9a29beed5d256a0098" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://web.archive.org/web/20101105013136/http://www.dolittle.no/blogs/einar/archive/2008/01/13/missing-enum-getvalues-when-doing-silverlight-for-instance.aspx&quot;&gt;Original Blog Post by Einar Ingebrigtsen&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://web.archive.org/web/20101105013136/http://www.dolittle.no/blogs/einar/archive/2008/01/13/missing-enum-getvalues-when-doing-silverlight-for-instance.aspx&quot;&gt;Einar Ingebrigtsen撰写的原始博客文章&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="628b003cff860c93265eccaec110cd80fc03d7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Enum.GetValues(type)&lt;/code&gt; // Since .NET 1.1, not in Silverlight or .NET Compact Framework</source>
          <target state="translated">&lt;code&gt;Enum.GetValues(type)&lt;/code&gt; //从.NET 1.1开始，不在Silverlight或.NET Compact Framework中</target>
        </trans-unit>
        <trans-unit id="c85e52b3b4353211b223e1d52ac1fdf07f1068e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EnumLoop&lt;/code&gt; has this completely generic definition:</source>
          <target state="translated">&lt;code&gt;EnumLoop&lt;/code&gt; 具有以下完全通用的定义：</target>
        </trans-unit>
        <trans-unit id="bfbf23c79144694d3391307903f4e52ac2d39f99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt; types are called &quot;enumeration types&quot; not because they are containers that &quot;enumerate&quot; values (which they aren't), but because they are defined by &lt;em&gt;enumerating&lt;/em&gt; the possible values for a variable of that type.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 类型之所以被称为&amp;ldquo;枚举类型&amp;rdquo;，不是因为它们是&amp;ldquo;枚举&amp;rdquo;值（不是）的容器，而是因为它们是通过&lt;em&gt;枚举&lt;/em&gt;该类型变量的可能值来定义的。</target>
        </trans-unit>
        <trans-unit id="e5c45b1afb733bf0b290d4865898a9aa1a4607d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type.GetEnumValues()&lt;/code&gt; // Only on .NET 4 and above</source>
          <target state="translated">&lt;code&gt;type.GetEnumValues()&lt;/code&gt; //仅在.NET 4及更高版本上</target>
        </trans-unit>
        <trans-unit id="5ec027cd63787fc63ff00a1d7f39f02a465ad222" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type.GetFields().Where(x =&amp;gt; x.IsLiteral).Select(x =&amp;gt; x.GetValue(null))&lt;/code&gt; // Works everywhere</source>
          <target state="translated">&lt;code&gt;type.GetFields().Where(x =&amp;gt; x.IsLiteral).Select(x =&amp;gt; x.GetValue(null))&lt;/code&gt; //随处可见</target>
        </trans-unit>
        <trans-unit id="8e4a67312cef01f89b813f460218af4e618c5098" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I am not sure why &lt;code&gt;GetEnumValues&lt;/code&gt; was introduced on type instances. It isn't very readable at all for me.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;我不确定为什么在类型实例上引入了 &lt;code&gt;GetEnumValues&lt;/code&gt; 。&lt;/em&gt; &lt;em&gt;这对我来说根本不是很可读。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f22550b58f5408cd4a7789a3f168d48edeb08400" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The cast to &lt;code&gt;(Suit[])&lt;/code&gt; is not strictly necessary, &lt;a href=&quot;https://gist.github.com/bartoszkp/9e059c3edccc07a5e588#gistcomment-2625454&quot;&gt;but it does make the code 0.5 ns faster&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：强制转换为 &lt;code&gt;(Suit[])&lt;/code&gt; 并不是绝对必要的， &lt;a href=&quot;https://gist.github.com/bartoszkp/9e059c3edccc07a5e588#gistcomment-2625454&quot;&gt;但是它确实使代码快了0.5 ns&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b10049e3c204f7b966f11b4223add60fd0a0dff9" translate="yes" xml:space="preserve">
          <source>A call would look like this:</source>
          <target state="translated">一个电话会是这样的。</target>
        </trans-unit>
        <trans-unit id="b8278d6fa198e09d50fbbd6937ff32e3b20545e9" translate="yes" xml:space="preserve">
          <source>A simple and generic way to convert an enum to something you can interact:</source>
          <target state="translated">一个简单而通用的方法,可以将一个词条转换为你可以交互的东西。</target>
        </trans-unit>
        <trans-unit id="489a98e4905ac18f73bdcd16377405cbf983f47f" translate="yes" xml:space="preserve">
          <source>Add method &lt;code&gt;public static IEnumerable&amp;lt;T&amp;gt; GetValues&amp;lt;T&amp;gt;()&lt;/code&gt; to your class, like:</source>
          <target state="translated">将方法 &lt;code&gt;public static IEnumerable&amp;lt;T&amp;gt; GetValues&amp;lt;T&amp;gt;()&lt;/code&gt; 到您的类，例如：</target>
        </trans-unit>
        <trans-unit id="9adfddcd92a71b3bc6564c2c5d83a45f949ebce5" translate="yes" xml:space="preserve">
          <source>Also you can bind to the public static members of the enum directly by using reflection:</source>
          <target state="translated">同时,你也可以通过使用反射直接绑定到enum的公共静态成员。</target>
        </trans-unit>
        <trans-unit id="5185077a60357f56c044d96e3e9c27f0dcfed475" translate="yes" xml:space="preserve">
          <source>And it gives the following compile-time error:</source>
          <target state="translated">而它给出的编译错误如下。</target>
        </trans-unit>
        <trans-unit id="a65c6aab9ccb89445d5895ed004afd6ead95252c" translate="yes" xml:space="preserve">
          <source>And then:</source>
          <target state="translated">然后。</target>
        </trans-unit>
        <trans-unit id="9fbda980a4e6671aa89af76a1ac43b0bd5a659b2" translate="yes" xml:space="preserve">
          <source>And you can use it like below:</source>
          <target state="translated">而且你可以像下面这样使用。</target>
        </trans-unit>
        <trans-unit id="2c8a83e8900192b4b50deba69a1aba7d1d83c362" translate="yes" xml:space="preserve">
          <source>As with any code that involves &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection&quot;&gt;reflection&lt;/a&gt;, you should take steps to ensure it runs only once and results are cached.</source>
          <target state="translated">与涉及&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection&quot;&gt;反射的&lt;/a&gt;任何代码一样，您应采取步骤确保其仅运行一次并缓存结果。</target>
        </trans-unit>
        <trans-unit id="01488da0f2c695215e3c263c1b0a620cdb5ef987" translate="yes" xml:space="preserve">
          <source>But that's not strictly enumerating, just looping. The second method is much faster than any other approach though...</source>
          <target state="translated">但这不是严格意义上的枚举,只是循环。第二种方法虽然比其他方法要快得多......</target>
        </trans-unit>
        <trans-unit id="b777c1f71b046ec9e2702c289bcdaf42a8b05a32" translate="yes" xml:space="preserve">
          <source>By the way, incrementing the value is not a good way to enumerate the values of an enum. You should do this instead.</source>
          <target state="translated">顺便说一下,递增值不是枚举一个枚举值的好方法。你应该这样做。</target>
        </trans-unit>
        <trans-unit id="e1b0a5a3ca314c0e37db1c2351ee79f4bdd02a1b" translate="yes" xml:space="preserve">
          <source>Call and pass your enum. Now you can iterate through it using &lt;code&gt;foreach&lt;/code&gt;:</source>
          <target state="translated">调用并传递您的枚举。 现在，您可以使用 &lt;code&gt;foreach&lt;/code&gt; 遍历它：</target>
        </trans-unit>
        <trans-unit id="130e344783d4105439d699f40125c5715cbf222e" translate="yes" xml:space="preserve">
          <source>E.g. the following code does not compile:</source>
          <target state="translated">例如:下面的代码无法编译。</target>
        </trans-unit>
        <trans-unit id="bfcf41711c45f4d582e1d7496ffdb987c0c718e9" translate="yes" xml:space="preserve">
          <source>EDIT: Should have suggested the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.enum.getvalues(v=vs.110).aspx&quot;&gt;System.Enum.GetValues&lt;/a&gt; method instead. Oops.</source>
          <target state="translated">编辑：应该建议&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.enum.getvalues(v=vs.110).aspx&quot;&gt;System.Enum.GetValues&lt;/a&gt;方法来代替。 哎呀</target>
        </trans-unit>
        <trans-unit id="488d755bd3034f031474bb24d86a52e629556d9e" translate="yes" xml:space="preserve">
          <source>For getting a list of int from an enum, use the following. It works!</source>
          <target state="translated">对于从一个枚举中获取int的列表,使用下面的方法。它的效果很好!</target>
        </trans-unit>
        <trans-unit id="36444104581e368e6494a254b78ef4c4bdba70fa" translate="yes" xml:space="preserve">
          <source>Having a helper class like &lt;code&gt;Enum&amp;lt;T&amp;gt;&lt;/code&gt; is what is most readable and memorable for me:</source>
          <target state="translated">对我来说，拥有像 &lt;code&gt;Enum&amp;lt;T&amp;gt;&lt;/code&gt; 这样的帮助器类是最容易阅读和记住的：</target>
        </trans-unit>
        <trans-unit id="4d987bf9b5c596c8a548ba1557b0eb1909241d54" translate="yes" xml:space="preserve">
          <source>Here is a working example of creating select options for a &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_definition_language&quot;&gt;DDL&lt;/a&gt;:</source>
          <target state="translated">这是为&lt;a href=&quot;https://en.wikipedia.org/wiki/Data_definition_language&quot;&gt;DDL&lt;/a&gt;创建选择选项的工作示例：</target>
        </trans-unit>
        <trans-unit id="e75161fd8733bf32d8db574b4afe41d157fb02e8" translate="yes" xml:space="preserve">
          <source>How can you enumerate an &lt;code&gt;enum&lt;/code&gt; in C#?</source>
          <target state="translated">您如何 &lt;code&gt;enum&lt;/code&gt; C＃中的枚举 ？</target>
        </trans-unit>
        <trans-unit id="c84443bbee6468fa570fcd4ddd774034fc4262fb" translate="yes" xml:space="preserve">
          <source>How to enumerate an enum</source>
          <target state="translated">如何枚举一个enum</target>
        </trans-unit>
        <trans-unit id="f71295e846abf2ebf66206d4e52f2c2e37af5217" translate="yes" xml:space="preserve">
          <source>I do not hold the opinion this is better, or even good. I am just stating yet another solution.</source>
          <target state="translated">我不认为这样做会更好,甚至是好的。我只是提出另一个解决方案。</target>
        </trans-unit>
        <trans-unit id="d695e5bed90c7a43ad6dc3f50817744cdf7c56ad" translate="yes" xml:space="preserve">
          <source>I know it is a bit messy, but if you are fan of one-liners, here is one:</source>
          <target state="translated">我知道有点乱,但如果你是单行本的粉丝,这里有一个。</target>
        </trans-unit>
        <trans-unit id="47435f3e3d1517a85d9c8156dd62f2793656b5a2" translate="yes" xml:space="preserve">
          <source>I made some extensions for easy enum usage. Maybe someone can use it...</source>
          <target state="translated">我做了一些扩展程序,方便枚举使用。也许有人可以用它.....</target>
        </trans-unit>
        <trans-unit id="f706da7a8ed272d2a138924d9e5f8c1acccb9734" translate="yes" xml:space="preserve">
          <source>I think caching the array would speed it up considerably.  It looks like you're getting a new array (through reflection) every time.  Rather:</source>
          <target state="translated">我认为缓存数组会大大加快它的速度。看起来你每次都会得到一个新的数组(通过反射)。相反的是。</target>
        </trans-unit>
        <trans-unit id="aef4593fde75c927e239b1d9aeaba5fe6fa96721" translate="yes" xml:space="preserve">
          <source>I think this is more efficient than other suggestions because &lt;code&gt;GetValues()&lt;/code&gt; is not called each time you have a loop. It is also more concise. And you get a compile-time error, not a runtime exception if &lt;code&gt;Suit&lt;/code&gt; is not an &lt;code&gt;enum&lt;/code&gt;.</source>
          <target state="translated">我认为这比其他建议更有效，因为每次有循环时不会调用 &lt;code&gt;GetValues()&lt;/code&gt; 。 这也更加简洁。 而且，如果 &lt;code&gt;Suit&lt;/code&gt; 不是 &lt;code&gt;enum&lt;/code&gt; ，则会得到编译时错误，而不是运行时异常。</target>
        </trans-unit>
        <trans-unit id="08426ede7845024ec8363a327be63a416a6c495d" translate="yes" xml:space="preserve">
          <source>I think you can use</source>
          <target state="translated">我想你可以用</target>
        </trans-unit>
        <trans-unit id="c71fe08aa4ab3025b3712ce5ed439b295b73dc54" translate="yes" xml:space="preserve">
          <source>I tried many ways and got the result from this code:</source>
          <target state="translated">我试了很多方法,都是通过这个代码得到的结果。</target>
        </trans-unit>
        <trans-unit id="5754c8aaf063971e507315c385218c84d323b198" translate="yes" xml:space="preserve">
          <source>I use ToString() then split and parse the spit array in flags.</source>
          <target state="translated">我使用ToString(),然后在flags中分割并解析吐出数组。</target>
        </trans-unit>
        <trans-unit id="0f65a7c0c8aabd73dcf605c5708aad1685be6eaf" translate="yes" xml:space="preserve">
          <source>I would use &lt;code&gt;Enum.GetValues(typeof(Suit))&lt;/code&gt; instead.</source>
          <target state="translated">我会改用 &lt;code&gt;Enum.GetValues(typeof(Suit))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d3eeef3663d9af4d6b31c62a690bda6aa657080" translate="yes" xml:space="preserve">
          <source>I've heard vague rumours that this is
  terifically slow. Anyone know? &amp;ndash; Orion
  Edwards Oct 15 '08 at 1:31 7</source>
          <target state="translated">我听过模糊的传言，说这太慢了。 有人知道吗 &amp;ndash; Orion Edwards 08年10月15日在1:31 7</target>
        </trans-unit>
        <trans-unit id="ce164deb41b4ac66b3fc10c0ed18762860a83ba4" translate="yes" xml:space="preserve">
          <source>If anyone knows how to get rid of the &lt;code&gt;T valueType = new T()&lt;/code&gt;, I'd be happy to see a solution.</source>
          <target state="translated">如果有人知道如何摆脱 &lt;code&gt;T valueType = new T()&lt;/code&gt; ，我将很高兴看到一个解决方案。</target>
        </trans-unit>
        <trans-unit id="b7989ee216e55942bc73f30b10d14df8440aeb1c" translate="yes" xml:space="preserve">
          <source>If enum values are contiguous and you can provide the first and last element of the enum, then:</source>
          <target state="translated">如果枚举值是连续的,并且可以提供枚举的第一个和最后一个元素,那么。</target>
        </trans-unit>
        <trans-unit id="4e5ec090707deff327e609b2e64c69fb0fa67593" translate="yes" xml:space="preserve">
          <source>If enum values range strictly from 0 to n - 1, a generic alternative is:</source>
          <target state="translated">如果枚举值的范围严格从0到n-1,一般的替代方案是:</target>
        </trans-unit>
        <trans-unit id="39889263d487079852bb1c20c0aa134d99325643" translate="yes" xml:space="preserve">
          <source>If you have:</source>
          <target state="translated">如果你有。</target>
        </trans-unit>
        <trans-unit id="02553c0e65d89d3e34617306e8ef88aabf22574d" translate="yes" xml:space="preserve">
          <source>If you need speed and type checking at build and run time, this helper method is better than using LINQ to cast each element:</source>
          <target state="translated">如果你在构建和运行时需要速度和类型检查,这种帮助方法比使用LINQ来铸造每个元素更好。</target>
        </trans-unit>
        <trans-unit id="50ce5a98656192c5eb253b5a488e358888162aa7" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Suit&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; are both enumerations:</source>
          <target state="translated">在这种情况下， &lt;code&gt;Suit&lt;/code&gt; 和 &lt;code&gt;Value&lt;/code&gt; 都是枚举：</target>
        </trans-unit>
        <trans-unit id="084b05b7f5b1b1bcec12c207bc96765dbf9581aa" translate="yes" xml:space="preserve">
          <source>It fails on the &lt;code&gt;Suit&lt;/code&gt; keyword, the second one.</source>
          <target state="translated">它在 &lt;code&gt;Suit&lt;/code&gt; 关键字（第二个）上失败。</target>
        </trans-unit>
        <trans-unit id="1537656a85cf3bdee1b6d6f52c4a3f226a4c4538" translate="yes" xml:space="preserve">
          <source>It is clean, simple, and, by @Jeppe-Stig-Nielsen's comment, fast.</source>
          <target state="translated">它很干净,很简单,而且,通过@Jeppe-Stig-Nielsen的评论,速度很快。</target>
        </trans-unit>
        <trans-unit id="fd3e08d7f38c4afc0cf631122546a28964fd62c7" translate="yes" xml:space="preserve">
          <source>It looks to me like you really want to print out the names of each enum, rather than the values. In which case &lt;code&gt;Enum.GetNames()&lt;/code&gt; seems to be the right approach.</source>
          <target state="translated">在我看来，您确实想要打印每个枚举的名称，而不是值。 在这种情况下， &lt;code&gt;Enum.GetNames()&lt;/code&gt; 似乎是正确的方法。</target>
        </trans-unit>
        <trans-unit id="360a6b89e50ba4bd210cc51e591971ee1f69294c" translate="yes" xml:space="preserve">
          <source>Just by combining the top answers, I threw together a very simple extension:</source>
          <target state="translated">只是结合上面的答案,我抛出了一个非常简单的延伸。</target>
        </trans-unit>
        <trans-unit id="10a092cb98eb6837964bf5134343571d1daf40dd" translate="yes" xml:space="preserve">
          <source>My solution works in &lt;a href=&quot;https://en.wikipedia.org/wiki/.NET_Compact_Framework&quot;&gt;.NET Compact Framework&lt;/a&gt; (3.5) and supports type checking &lt;strong&gt;at compile time&lt;/strong&gt;:</source>
          <target state="translated">我的解决方案在&lt;a href=&quot;https://en.wikipedia.org/wiki/.NET_Compact_Framework&quot;&gt;.NET Compact Framework&lt;/a&gt; （3.5）中工作，并&lt;strong&gt;在编译时&lt;/strong&gt;支持类型检查：</target>
        </trans-unit>
        <trans-unit id="e37b0b483215648e142c8ca2c80b58e28804d64a" translate="yes" xml:space="preserve">
          <source>Now you call:</source>
          <target state="translated">现在你来了。</target>
        </trans-unit>
        <trans-unit id="2f412be11b8b6e2fdd3aeed2275fcb0a44143bcf" translate="yes" xml:space="preserve">
          <source>Of course you can return &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, but that buys you nothing here.</source>
          <target state="translated">当然，您可以返回 &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; ，但是在这里您什么也买不到。</target>
        </trans-unit>
        <trans-unit id="c48ca7dddfe2d112cac0be14ca0611658d437c22" translate="yes" xml:space="preserve">
          <source>One can also use some sort of caching if performance matters, but I don't expect this to be an issue at all.</source>
          <target state="translated">如果性能重要的话,也可以使用某种缓存,但我认为这根本不会是个问题。</target>
        </trans-unit>
        <trans-unit id="82da7dfc583a0e4fe4bb642d8fab3b6d854e977c" translate="yes" xml:space="preserve">
          <source>Some versions of the .NET framework do not support &lt;code&gt;Enum.GetValues&lt;/code&gt;. Here's a good workaround from &lt;a href=&quot;https://web.archive.org/web/20100530072822/http://ideas.dalezak.ca/2008/11/enumgetvalues-in-compact-framework.html&quot;&gt;Ideas 2.0: Enum.GetValues in Compact Framework&lt;/a&gt;:</source>
          <target state="translated">.NET框架的某些版本不支持 &lt;code&gt;Enum.GetValues&lt;/code&gt; 。 这是&lt;a href=&quot;https://web.archive.org/web/20100530072822/http://ideas.dalezak.ca/2008/11/enumgetvalues-in-compact-framework.html&quot;&gt;Ideas 2.0&lt;/a&gt;的一个很好的解决方法：Compact Framework中的Enum.GetValues ：</target>
        </trans-unit>
        <trans-unit id="749ad7c6ceddd06a44a6cc8eda059e33ad78e6e0" translate="yes" xml:space="preserve">
          <source>That's at least a little faster, ja?</source>
          <target state="translated">这至少快了一点,是吗?</target>
        </trans-unit>
        <trans-unit id="5ea366c0157b9d18b4275a7ff3221c90cd637a68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.enum.getnames(v=vs.110).aspx&quot;&gt;System.Enum.GetNames method&lt;/a&gt; can be used to retrieve an array of strings which are the names of the enum values, as the name suggests.</source>
          <target state="translated">顾名思义， &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.enum.getnames(v=vs.110).aspx&quot;&gt;System.Enum.GetNames方法&lt;/a&gt;可用于检索字符串数组，这些字符串是枚举值的名称。</target>
        </trans-unit>
        <trans-unit id="9454a0d96d98fe3891e37f1a5902de10e403389c" translate="yes" xml:space="preserve">
          <source>The author uses a double for-loop to iterate through a pair of Enumerators (to create a full deck of cards):</source>
          <target state="translated">笔者用双换循环的方式,通过一对枚举器进行迭代(建立一副完整的牌组)。</target>
        </trans-unit>
        <trans-unit id="d9ceb8e1cff9691037ef71f5e6ef12dffd8981d8" translate="yes" xml:space="preserve">
          <source>The enum itself must be decorated with the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.flagsattribute.aspx&quot;&gt;FlagsAttribute&lt;/a&gt;:</source>
          <target state="translated">枚举本身必须用&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.flagsattribute.aspx&quot;&gt;FlagsAttribute&lt;/a&gt;装饰：</target>
        </trans-unit>
        <trans-unit id="31f80d82d321cecc7a18a82ce47aae20ea4c6a29" translate="yes" xml:space="preserve">
          <source>The first will give you values in form on an array of **&lt;code&gt;object&lt;/code&gt;**s, and the second will give you values in form of an array of **&lt;code&gt;String&lt;/code&gt;**s.</source>
          <target state="translated">第一个将以** &lt;code&gt;object&lt;/code&gt; **数组形式提供值，第二个将以** &lt;code&gt;String&lt;/code&gt; **数组形式提供值。</target>
        </trans-unit>
        <trans-unit id="a3c00a868093bad7c9671d53272d539a2466a64d" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;getListOfEnum&lt;/code&gt; uses reflection to take any enum type and returns an &lt;code&gt;IEnumerable&lt;/code&gt; of all enum values.</source>
          <target state="translated">方法 &lt;code&gt;getListOfEnum&lt;/code&gt; 使用反射来获取任何枚举类型，并返回所有枚举值的 &lt;code&gt;IEnumerable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55f11269620118a0c51541b00ccb10c4cded0769" translate="yes" xml:space="preserve">
          <source>There are two ways to iterate an &lt;code&gt;Enum&lt;/code&gt;:</source>
          <target state="translated">有两种方法可以迭代 &lt;code&gt;Enum&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b4b1865dc4a7fd39f1b8aa8db86d453dcc081bf2" translate="yes" xml:space="preserve">
          <source>There you go, &lt;code&gt;IEnumerable&amp;lt;Suit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IEnumerable&amp;lt;Suit&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39a561dadc1177d56df15e8441fdf0e4446cfa83" translate="yes" xml:space="preserve">
          <source>This question appears in Chapter 10 of &quot;&lt;a href=&quot;http://www.amazon.ca/Microsoft-Visual-2013-Step/dp/073568183X&quot;&gt;C# Step by Step 2013&lt;/a&gt;&quot;</source>
          <target state="translated">该问题出现在&amp;ldquo; &lt;a href=&quot;http://www.amazon.ca/Microsoft-Visual-2013-Step/dp/073568183X&quot;&gt;C＃Step by Step 2013&lt;/a&gt; &amp;rdquo;的第10章中</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="089ebedeb2803ff4e74259ec02f9b991ccf33afb" translate="yes" xml:space="preserve">
          <source>Three ways:</source>
          <target state="translated">三种方式。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="33b5900dd65f1fd3618f19573c76c63e4674e21f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Cast&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;Cast&amp;lt;T&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d00d002ca2e26a173c65238f0c1b8c6432fbf90d" translate="yes" xml:space="preserve">
          <source>Use it in a &lt;code&gt;foreach&lt;/code&gt; loop as below:</source>
          <target state="translated">在如下所示的 &lt;code&gt;foreach&lt;/code&gt; 循环中使用它：</target>
        </trans-unit>
        <trans-unit id="644d8c6b477119eaf658031f82a7cb1c621f1d00" translate="yes" xml:space="preserve">
          <source>What if you know the type will be an &lt;code&gt;enum&lt;/code&gt;, but you don't know what the exact type is at compile time?</source>
          <target state="translated">如果您知道类型将是 &lt;code&gt;enum&lt;/code&gt; ，但又不知道在编译时确切的类型该怎么办？</target>
        </trans-unit>
        <trans-unit id="d713ca8d870cdfeb112abd654479d42242f3e918" translate="yes" xml:space="preserve">
          <source>Will output:</source>
          <target state="translated">将输出。</target>
        </trans-unit>
        <trans-unit id="e747aad7bee356ac10c009028151f40094025583" translate="yes" xml:space="preserve">
          <source>You won't get &lt;code&gt;Enum.GetValues()&lt;/code&gt; in &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Silverlight&quot;&gt;Silverlight&lt;/a&gt;.</source>
          <target state="translated">您不会在&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Silverlight&quot;&gt;Silverlight中&lt;/a&gt;获得 &lt;code&gt;Enum.GetValues()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26393ee27fab3122bc1d86c27587f0ca6510073c" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;PlayingCard&lt;/code&gt; is a card object with a defined &lt;code&gt;Suit&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt;:</source>
          <target state="translated">而 &lt;code&gt;PlayingCard&lt;/code&gt; 是具有定义的 &lt;code&gt;Suit&lt;/code&gt; 和 &lt;code&gt;Value&lt;/code&gt; 的纸牌对象：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
