<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/105034">
    <body>
      <group id="105034">
        <trans-unit id="68960fcc7ae0d6fd78f4a201eeb38fa8bb9a0ecf" translate="yes" xml:space="preserve">
          <source>&quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;</source>
          <target state="translated">&quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;</target>
        </trans-unit>
        <trans-unit id="a032d777f177ebd6e92855f3bce4c9d3de29d561" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsbin.com/uqives/3&quot;&gt;On jsbin&lt;/a&gt; if you want to test it.</source>
          <target state="translated">&lt;a href=&quot;http://jsbin.com/uqives/3&quot;&gt;En jsbin&lt;/a&gt; si quieres probarlo.</target>
        </trans-unit>
        <trans-unit id="54853102ac5288d10305ee4fe284f5676c8b3049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(Math.random().toString(16).substr(2,8)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(Math.random().toString(16).substr(2,8)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="518c3687d473e405f713a2e4202e1617f257a7bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="7de15d516266250876bf7df115f60af51b87ba40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random().toString(16)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random().toString(16)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="a4bfa8acce2c58437408c5567e16ba754efc3619" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be advised:&lt;/strong&gt; my primary goal was to show and teach potential optimization strategies.  Other answers cover important topics such as collisions and truly random numbers, which are important for generating good UUIDs.</source>
          <target state="translated">&lt;strong&gt;Tenga en cuenta:&lt;/strong&gt; mi objetivo principal era mostrar y ense&amp;ntilde;ar posibles estrategias de optimizaci&amp;oacute;n. Otras respuestas cubren temas importantes como colisiones y n&amp;uacute;meros verdaderamente aleatorios, que son importantes para generar buenos UUID.</target>
        </trans-unit>
        <trans-unit id="a8558249d3c59db88fd2392888164f8297752e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But, can we get speed &lt;em&gt;and&lt;/em&gt; RFC compliance?  I say, YES!&lt;/strong&gt;  Can we maintain readability?  Well...  Not really, but it's easy if you follow along.</source>
          <target state="translated">&lt;strong&gt;Pero, &amp;iquest;podemos obtener velocidad &lt;em&gt;y&lt;/em&gt; cumplimiento de RFC?&lt;/strong&gt; &lt;strong&gt;&amp;iexcl;Yo digo si!&lt;/strong&gt; &amp;iquest;Podemos mantener la legibilidad? Bueno ... en realidad no, pero es f&amp;aacute;cil si sigues.</target>
        </trans-unit>
        <trans-unit id="0aa9a4872e5871a2d50503b7555d5a560abc60db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b79b40ec4e7164794f3d15d07d564b8ad8717468" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit :&lt;/strong&gt;  I thought it was worth pointing out that no GUID generator can guarantee unique keys (check the &lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_Unique_Identifier&quot;&gt;wikipedia article&lt;/a&gt;).  There is always a chance of collisions.  A GUID simply offers a large enough universe of keys to reduce the change of collisions to almost nil.</source>
          <target state="translated">&lt;strong&gt;Editar:&lt;/strong&gt; pens&amp;eacute; que val&amp;iacute;a la pena se&amp;ntilde;alar que ning&amp;uacute;n generador de GUID puede garantizar claves &amp;uacute;nicas (consulte el &lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_Unique_Identifier&quot;&gt;art&amp;iacute;culo de wikipedia&lt;/a&gt; ). Siempre existe la posibilidad de colisiones. Un GUID simplemente ofrece un universo de claves lo suficientemente grande como para reducir el cambio de colisiones a casi nulo.</target>
        </trans-unit>
        <trans-unit id="7015ec1e0155111b63b36ee572b6bff0228a4302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enjoy! :-)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;Disfrutar!&lt;/strong&gt; &lt;strong&gt;:-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274339a4ddbe260b6a97172504035c73b5738ea9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Features Generates RFC 4122 compliant UUIDs.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Caracter&amp;iacute;sticas Genera UUID que cumplen con RFC 4122.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d77806e165bb48692701ad0de9af22b7850fba31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Guid.empty&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guid.empty&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b0671d2fe50cfe5c11475ae51a2760cbcda6baf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Guid.newGuid()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guid.newGuid()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cf7a599e78acfd69a7e284fa3d3b67982dccad6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Install Using NPM:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Instalar usando NPM:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bf75b8ebe887aa6577cd720281924cbc349c929" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or Using uuid via browser:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O usando uuid a trav&amp;eacute;s del navegador:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35889b4f21085883cbaa19da2a6b14684bd0aada" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The algorithm:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El algoritmo:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25b1935958bb975920d8012409acce290de08a28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The assembly:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La Asamblea:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c002957f28f184ef81e532a83ab90120a2e876b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UUID.js The RFC-compliant UUID generator for JavaScript.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UUID.js El generador de UUID compatible con RFC para JavaScript.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="469336e52af17d529352df89c21d2a5435257e12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2015-06-02&lt;/strong&gt;:  Be aware that UUID uniqueness relies heavily on the underlying random number generator (RNG).  The solution above uses &lt;code&gt;Math.random()&lt;/code&gt; for brevity, however &lt;code&gt;Math.random()&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to be a high-quality RNG.  See Adam Hyland's &lt;a href=&quot;http://bocoup.com/weblog/random-numbers/&quot;&gt;excellent writeup on Math.random()&lt;/a&gt; for details.  For a more robust solution, consider something like &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;the uuid module&lt;/a&gt; (disclaimer: I, @broofa, am the author), which uses higher quality RNG APIs where available.</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n, 2015-06-02&lt;/strong&gt; : Tenga en cuenta que la unicidad UUID depende en gran medida del generador de n&amp;uacute;meros aleatorios (RNG) subyacente. La soluci&amp;oacute;n anterior usa &lt;code&gt;Math.random()&lt;/code&gt; por brevedad, sin embargo, &lt;em&gt;no se&lt;/em&gt; garantiza que &lt;code&gt;Math.random()&lt;/code&gt; sea ​​un RNG de alta calidad. Vea la &lt;a href=&quot;http://bocoup.com/weblog/random-numbers/&quot;&gt;excelente redacci&amp;oacute;n de&lt;/a&gt; Adam Hyland en Math.random () para m&amp;aacute;s detalles. Para una soluci&amp;oacute;n m&amp;aacute;s robusta, considere algo como &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;el m&amp;oacute;dulo uuid&lt;/a&gt; (descargo de responsabilidad: I, @broofa, soy el autor), que utiliza API RNG de mayor calidad cuando est&amp;aacute;n disponibles.</target>
        </trans-unit>
        <trans-unit id="be0809af7361460fb45bdf84889bab84728f5e00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2015-08-26&lt;/strong&gt;: As a side-note, this &lt;a href=&quot;https://gist.githubusercontent.com/aristus/f0c311df98d92e367df0&quot;&gt;gist&lt;/a&gt; describes how to determine how many IDs can be generated before reaching a certain probability of collision.  For example, with 3.26x10&lt;sup&gt;15&lt;/sup&gt; version 4 RFC4122 UUIDs you have a 1-in-a-million chance of collision.</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n, 2015-08-26&lt;/strong&gt; : Como nota al margen, este &lt;a href=&quot;https://gist.githubusercontent.com/aristus/f0c311df98d92e367df0&quot;&gt;resumen&lt;/a&gt; describe c&amp;oacute;mo determinar cu&amp;aacute;ntas ID se pueden generar antes de alcanzar una cierta probabilidad de colisi&amp;oacute;n. Por ejemplo, con 3.26x10 &lt;sup&gt;15&lt;/sup&gt; versi&amp;oacute;n 4 RFC4122 UUID tiene una probabilidad de colisi&amp;oacute;n de 1 en un mill&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8fd4ff892cec4b2ce586409848ac995315f7db82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2017-06-28&lt;/strong&gt;: A &lt;a href=&quot;https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html&quot;&gt;good article from Chrome developers&lt;/a&gt; discussing the state of Math.random PRNG quality in Chrome, Firefox, and Safari.  tl;dr - As of late-2015 it's &quot;pretty good&quot;, but not cryptographic quality.  To address that issue, here's an updated version of the above solution that uses ES6, the &lt;code&gt;crypto&lt;/code&gt; API, and &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;a bit of JS wizardry I can't take credit for&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n, 2017-06-28&lt;/strong&gt; : Un &lt;a href=&quot;https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html&quot;&gt;buen art&amp;iacute;culo de desarrolladores de Chrome que&lt;/a&gt; discute el estado de la calidad de Math.random PRNG en Chrome, Firefox y Safari. tl; dr: a finales de 2015 es &quot;bastante bueno&quot;, pero no de calidad criptogr&amp;aacute;fica. Para abordar ese problema, aqu&amp;iacute; hay una versi&amp;oacute;n actualizada de la soluci&amp;oacute;n anterior que usa ES6, la API de &lt;code&gt;crypto&lt;/code&gt; y &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;un poco de hechicer&amp;iacute;a JS de la que no puedo dar cr&amp;eacute;dito&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1395f19d7608f025cb58cb5b03b266e650d27c84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2020-01-06&lt;/strong&gt;: There is a &lt;a href=&quot;https://github.com/tc39/proposal-uuid&quot;&gt;proposal in the works&lt;/a&gt; for a standard &lt;code&gt;uuid&lt;/code&gt; module as part of the JS language</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n, 2020-01-06&lt;/strong&gt; : Hay una &lt;a href=&quot;https://github.com/tc39/proposal-uuid&quot;&gt;propuesta en proceso&lt;/a&gt; para un m&amp;oacute;dulo &lt;code&gt;uuid&lt;/code&gt; est&amp;aacute;ndar como parte del lenguaje JS</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="782117c6d143f47d437449ef980ce5c3b76b9beb" translate="yes" xml:space="preserve">
          <source>A popular Open Source tool for working with UUIDs in JavaScript is &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;node-uuid&lt;/a&gt;</source>
          <target state="translated">Una herramienta de c&amp;oacute;digo abierto popular para trabajar con UUID en JavaScript es &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;node-uuid&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba3de79909c92e381cfcb7d2ad3bb6d12b74b04d" translate="yes" xml:space="preserve">
          <source>A version based on Briguy37's answer and some bitwise operators to extract nibble sized windows from the buffer.</source>
          <target state="translated">Una versión basada en la respuesta de Briguy37 y algunos operadores poco inteligentes para extraer ventanas de tamaño mordisco del buffer.</target>
        </trans-unit>
        <trans-unit id="8b32b76d7d98de48b1c8d4fca55b71b36e586c91" translate="yes" xml:space="preserve">
          <source>A web service would be useful.</source>
          <target state="translated">Un servicio web sería útil.</target>
        </trans-unit>
        <trans-unit id="efe0742dcba00224262ee5b679bb64e2dd8254ac" translate="yes" xml:space="preserve">
          <source>Adjusted my own UUID/GUID generator with some extras &lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Ajust&amp;eacute; mi propio generador de UUID / GUID con algunos extras &lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12c755e3c27b17c5f8c8e0155d60eabe76a0405a" translate="yes" xml:space="preserve">
          <source>An UUID must have this format:</source>
          <target state="translated">Un UUID debe tener este formato:</target>
        </trans-unit>
        <trans-unit id="12c696bae1749afdd4c10d3071dc3d49e8ee7766" translate="yes" xml:space="preserve">
          <source>Basically, the same inner logic, except we check for &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;, and using a while loop (instead of &lt;code&gt;replace()&lt;/code&gt; callbacks) gets us an almost 3X improvement!</source>
          <target state="translated">B&amp;aacute;sicamente, la misma l&amp;oacute;gica interna, excepto que verificamos &lt;code&gt;-&lt;/code&gt; o &lt;code&gt;4&lt;/code&gt; , y el uso de un bucle while (en lugar de las devoluciones de llamada &lt;code&gt;replace()&lt;/code&gt; ) nos da una mejora casi 3X.</target>
        </trans-unit>
        <trans-unit id="99bc098eb1d1be9a1e4498d4108a52905669d15e" translate="yes" xml:space="preserve">
          <source>Below is my script with the Mash and Kybos methods from baagoe.com excluded.</source>
          <target state="translated">Abajo está mi guión con los métodos de Mash y Kybos de baagoe.com excluidos.</target>
        </trans-unit>
        <trans-unit id="c650c2cdd89b69f5f213fde542a728fd50fc0983" translate="yes" xml:space="preserve">
          <source>But first, my results, compared to broofa, &lt;code&gt;guid&lt;/code&gt; (the accepted answer), and the non-rfc-compliant &lt;code&gt;generateQuickGuid&lt;/code&gt;:</source>
          <target state="translated">Pero primero, mis resultados, en comparaci&amp;oacute;n con broofa, &lt;code&gt;guid&lt;/code&gt; (la respuesta aceptada) y el no compatible con rfc &lt;code&gt;generateQuickGuid&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3ef02731ee702db53ed68d0ba455be85ab88617" translate="yes" xml:space="preserve">
          <source>But if you're looking at that regular expression, those many &lt;code&gt;replace()&lt;/code&gt; callbacks, &lt;code&gt;toString()&lt;/code&gt;'s and &lt;code&gt;Math.random()&lt;/code&gt; function calls (where he's only using 4 bits of the result and wasting the rest), you may start to wonder about performance.  Indeed, joelpt even decided to toss out RFC for generic GUID speed with &lt;code&gt;generateQuickGUID&lt;/code&gt;.</source>
          <target state="translated">Pero si est&amp;aacute; viendo esa expresi&amp;oacute;n regular, esas muchas devoluciones de llamada &lt;code&gt;Math.random()&lt;/code&gt; , llamadas a la funci&amp;oacute;n &lt;code&gt;toString()&lt;/code&gt; y Math.random () (donde solo usa 4 bits del resultado y desperdicia el resto), puede comenzar preguntarse sobre el rendimiento. De hecho, joelpt incluso decidi&amp;oacute; deshacerse de RFC para la velocidad gen&amp;eacute;rica de GUID con &lt;code&gt;generateQuickGUID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="717ee0beb1305a91a9a0535e4961247e24e32fc5" translate="yes" xml:space="preserve">
          <source>Can't vouch for this implementation, but SOMEONE must publish a bonafide GUID generator.</source>
          <target state="translated">No puedo responder por esta implementación,pero ALGUIEN debe publicar un generador de guías de buena fe.</target>
        </trans-unit>
        <trans-unit id="01536fdf7462153cb5b1d4174a32db140aec25c2" translate="yes" xml:space="preserve">
          <source>Create GUID / UUID in JavaScript</source>
          <target state="translated">Crear GUID UUID en JavaScript</target>
        </trans-unit>
        <trans-unit id="95e6f920efe4af2e79e605edcc5e28ed1b15c6c5" translate="yes" xml:space="preserve">
          <source>Cryptographically strong random # generation on supporting platforms.</source>
          <target state="translated">Generación aleatoria criptográficamente fuerte en plataformas de apoyo.</target>
        </trans-unit>
        <trans-unit id="0ed439a6611cd1800f10c6bd949b76b487cd2b75" translate="yes" xml:space="preserve">
          <source>Download Raw File (uuid v1): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&lt;/a&gt;
Download Raw File (uuid v4): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&lt;/a&gt;</source>
          <target state="translated">Descargar archivo sin formato (uuid v1): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&lt;/a&gt; Descargar archivo sin formato (uuid v4): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node -uuid / master / v4.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="ed293f503837b9994324552ef62fd849b6ccd846" translate="yes" xml:space="preserve">
          <source>ES6 sample</source>
          <target state="translated">Muestra de ES6</target>
        </trans-unit>
        <trans-unit id="d7ddd41483a929219e6c64489e8d0eca72b29277" translate="yes" xml:space="preserve">
          <source>Edit: The above code follow the intention, but not the letter of the RFC. Among other discrepancies it's a few random digits short. (Add more random digits if you need it) The upside is that this it's really fast :)
You can &lt;a href=&quot;https://www.freecodeformat.com/validate-uuid-guid.php&quot;&gt;test validity of your GUID here&lt;/a&gt;</source>
          <target state="translated">Editar: El c&amp;oacute;digo anterior sigue la intenci&amp;oacute;n, pero no la letra del RFC. Entre otras discrepancias, hay unos pocos d&amp;iacute;gitos aleatorios cortos. (Agregue m&amp;aacute;s d&amp;iacute;gitos aleatorios si lo necesita). Lo bueno es que esto es realmente r&amp;aacute;pido :) Puede &lt;a href=&quot;https://www.freecodeformat.com/validate-uuid-guid.php&quot;&gt;probar la validez de su GUID aqu&amp;iacute;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d3d52832b1fac459c9b6a3703887d6cc457b232" translate="yes" xml:space="preserve">
          <source>Eventually we build the GUID with the following chaining: &lt;code&gt;_p8() + _p8(true) + _p8(true) + _p8()&lt;/code&gt;, and return it.</source>
          <target state="translated">Eventualmente construimos el GUID con el siguiente encadenamiento: &lt;code&gt;_p8() + _p8(true) + _p8(true) + _p8()&lt;/code&gt; , y lo devolvemos.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="ce2e69b5373a12bdf9ca27da533c517da11f6e58" translate="yes" xml:space="preserve">
          <source>Fastest GUID like string generator method in the format &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt;. This does not generate standard-compliant GUID.</source>
          <target state="translated">El GUID m&amp;aacute;s r&amp;aacute;pido como m&amp;eacute;todo de generador de cadenas en el formato &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt; . Esto no genera GUID compatible con el est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="5df81ffa82179b458e1d55e350db9d88805a69b2" translate="yes" xml:space="preserve">
          <source>Features:</source>
          <target state="translated">Features:</target>
        </trans-unit>
        <trans-unit id="19967ecebb03ba38cc744454a4a0af16a7d1a8e8" translate="yes" xml:space="preserve">
          <source>For an &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; version 4 compliant solution, this one-liner(ish) solution is the most compact I could come up with:</source>
          <target state="translated">Para una soluci&amp;oacute;n compatible con &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; versi&amp;oacute;n 4, esta soluci&amp;oacute;n de una l&amp;iacute;nea (ish) es la m&amp;aacute;s compacta que se me ocurre:</target>
        </trans-unit>
        <trans-unit id="0fa53fa9049ab50aea42e7e785eb43daf3f7b3eb" translate="yes" xml:space="preserve">
          <source>For an explanation, let's start with broofa's code:</source>
          <target state="translated">Para una explicación,empecemos con el código de Broofa:</target>
        </trans-unit>
        <trans-unit id="ab095b33ae4fc9f4c67064d2613f861fa360db4f" translate="yes" xml:space="preserve">
          <source>For those wanting an rfc4122 version 4 compliant solution with speed considerations (few calls to Math.random()):</source>
          <target state="translated">Para aquellos que quieran una solución compatible con rfc4122 versión 4 con consideraciones de velocidad (pocas llamadas a Math.random()):</target>
        </trans-unit>
        <trans-unit id="27fd956c4f1ae3c3c9ea49a4371ca211e7952e8e" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html&quot;&gt;sagi shkedy's technical blog&lt;/a&gt;:</source>
          <target state="translated">Del &lt;a href=&quot;http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html&quot;&gt;blog t&amp;eacute;cnico de sagi shkedy&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c23b6b59226a5a1d9cd6f8d8dedd94737c6ed311" translate="yes" xml:space="preserve">
          <source>Generate RFC4122 version 1 or version 4 UUIDs</source>
          <target state="translated">Generar RFC4122 versión 1 o versión 4 UUIDs</target>
        </trans-unit>
        <trans-unit id="4557d9f04a62ecf6d45c63f669d4d3c5969dbed7" translate="yes" xml:space="preserve">
          <source>Generates 26 [a-z0-9] characters, yielding a UID that is both shorter and more unique than RFC compliant GUIDs. Dashes can be trivially added if human-readability matters.</source>
          <target state="translated">Genera 26 [a-z0-9]caracteres,lo que da como resultado un UID que es a la vez más corto y más único que los GUIDs compatibles con RFC.Los guiones pueden ser añadidos trivialmente si la legibilidad humana importa.</target>
        </trans-unit>
        <trans-unit id="c37e10249fd54645ca14d4f8396558ccf7ed72d1" translate="yes" xml:space="preserve">
          <source>Here are usage examples and timings for this function and several of this question's other answers. The timing was performed under Chrome m25, 10 million iterations each.</source>
          <target state="translated">Aquí hay ejemplos de uso y tiempos para esta función y varias de las otras respuestas de esta pregunta.El cronometraje se realizó bajo el cromo m25,10 millones de iteraciones cada uno.</target>
        </trans-unit>
        <trans-unit id="2c247f731cda829ae025095a8672be34b63c5632" translate="yes" xml:space="preserve">
          <source>Here is a combination of the &lt;a href=&quot;https://stackoverflow.com/a/2117523/11236&quot;&gt;top voted answer&lt;/a&gt;, with a workaround for &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Chrome's collisions&lt;/a&gt;:</source>
          <target state="translated">Aqu&amp;iacute; hay una combinaci&amp;oacute;n de la &lt;a href=&quot;https://stackoverflow.com/a/2117523/11236&quot;&gt;respuesta m&amp;aacute;s votada&lt;/a&gt; , con una soluci&amp;oacute;n alternativa para &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;las colisiones de Chrome&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2ecd98e5e9126eb4bab9ba9ad9ac22335c8bce41" translate="yes" xml:space="preserve">
          <source>Here is a sample of the UUIDs generated :</source>
          <target state="translated">Aquí hay una muestra de los UUIDs generados:</target>
        </trans-unit>
        <trans-unit id="8261ebf8b6de8850d44b04f0d061fad3a19b0b3b" translate="yes" xml:space="preserve">
          <source>Here is a totally non-compliant but very performant implementation to generate an ASCII-safe GUID-like unique identifier.</source>
          <target state="translated">Aquí hay una implementación totalmente no conforme pero muy performante para generar un identificador único tipo GUID seguro de ASCII.</target>
        </trans-unit>
        <trans-unit id="503ff0a7dc77de993388c1e8009b02daf56b5134" translate="yes" xml:space="preserve">
          <source>Here is the timing code.</source>
          <target state="translated">Aquí está el código de tiempo.</target>
        </trans-unit>
        <trans-unit id="8117e866b4a966496f20af5f99e7bfccef4d04fa" translate="yes" xml:space="preserve">
          <source>Here's a fiddle to test.</source>
          <target state="translated">Aquí hay un violín para probar.</target>
        </trans-unit>
        <trans-unit id="60ff7b70fc22b138ecf074493ca83ac61514a43a" translate="yes" xml:space="preserve">
          <source>Here's a similar &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; version 4 compliant solution that solves that issue by offsetting the first 13 hex numbers by a hex portion of the timestamp, and once depleted offsets by a hex portion of the microseconds since pageload.  That way, even if &lt;code&gt;Math.random&lt;/code&gt; is on the same seed, both clients would have to generate the UUID the exact same number of microseconds since pageload (if high-perfomance time is supported) AND at the exact same millisecond (or 10,000+ years later) to get the same UUID:</source>
          <target state="translated">Aqu&amp;iacute; hay una &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;soluci&amp;oacute;n&lt;/a&gt; similar que cumple con RFC4122 versi&amp;oacute;n 4 que resuelve ese problema al compensar los primeros 13 n&amp;uacute;meros hexadecimales por una porci&amp;oacute;n hexadecimal de la marca de tiempo, y una vez agotadas las compensaciones por una porci&amp;oacute;n hexadecimal de los microsegundos desde la carga de la p&amp;aacute;gina. De esa manera, incluso si &lt;code&gt;Math.random&lt;/code&gt; est&amp;aacute; en la misma semilla, ambos clientes tendr&amp;iacute;an que generar el UUID exactamente el mismo n&amp;uacute;mero de microsegundos desde la carga de la p&amp;aacute;gina (si se admite el tiempo de alto rendimiento) Y exactamente en el mismo milisegundo (o m&amp;aacute;s de 10,000 a&amp;ntilde;os m&amp;aacute;s adelante) para obtener el mismo UUID:</target>
        </trans-unit>
        <trans-unit id="4e21d976cadf293249dcfa48c33d29b6a5e06a86" translate="yes" xml:space="preserve">
          <source>Here's a solution dated Oct. 9, 2011 from a comment by user &lt;em&gt;jed&lt;/em&gt; at &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;https://gist.github.com/982883&lt;/a&gt;:</source>
          <target state="translated">Aqu&amp;iacute; hay una soluci&amp;oacute;n con fecha del 9 de octubre de 2011 de un comentario del usuario &lt;em&gt;jed&lt;/em&gt; en &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;https://gist.github.com/982883&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b18abaaddfcfe54404b43a907e463bef2f7d1c8b" translate="yes" xml:space="preserve">
          <source>Here's some code based on &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;, section 4.4 (Algorithms for Creating a UUID from Truly Random or Pseudo-Random Number).</source>
          <target state="translated">Aqu&amp;iacute; hay un c&amp;oacute;digo basado en &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt; , secci&amp;oacute;n 4.4 (Algoritmos para crear un UUID a partir de un n&amp;uacute;mero verdaderamente aleatorio o pseudoaleatorio).</target>
        </trans-unit>
        <trans-unit id="79fadeaf6225db3316856bec94555fdca94516bd" translate="yes" xml:space="preserve">
          <source>I divided the GUID into 4 pieces, each piece divided into 2 types (or formats): &lt;code&gt;XXXXXXXX&lt;/code&gt; and &lt;code&gt;-XXXX-XXXX&lt;/code&gt;.</source>
          <target state="translated">Divid&amp;iacute; el GUID en 4 piezas, cada pieza dividida en 2 tipos (o formatos): &lt;code&gt;XXXXXXXX&lt;/code&gt; y &lt;code&gt;-XXXX-XXXX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a293bf864a92ae3bdd88eece8abb78a30146eb51" translate="yes" xml:space="preserve">
          <source>I hope my logic is correct -- it's very easy to make a mistake in this kind of tedious bit-work.  But the outputs look good to me.  I hope you enjoyed this mad ride through code optimization!</source>
          <target state="translated">Espero que mi lógica sea correcta...es muy fácil equivocarse en este tipo de tedioso trabajo.Pero las salidas me parecen bien.¡Espero que hayas disfrutado de este loco viaje a través de la optimización de código!</target>
        </trans-unit>
        <trans-unit id="25720d68a9e1e89c7d65f4d275b178f61def9e81" translate="yes" xml:space="preserve">
          <source>I know, it is an old question. Just for completeness, if your environment is SharePoint, there is a utility function called &lt;code&gt;SP.Guid.newGuid&lt;/code&gt; (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx&quot;&gt;msdn link&lt;/a&gt;) which creates a new guid. This function is inside the sp.init.js file. If you rewrite this function (to remove some other dependencies from other private functions), it looks like this:</source>
          <target state="translated">Lo s&amp;eacute;, es una vieja pregunta. Solo para completar, si su entorno es SharePoint, hay una funci&amp;oacute;n de utilidad llamada &lt;code&gt;SP.Guid.newGuid&lt;/code&gt; ( &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx&quot;&gt;enlace msdn&lt;/a&gt; ) que crea una nueva gu&amp;iacute;a. Esta funci&amp;oacute;n est&amp;aacute; dentro del archivo sp.init.js. Si reescribe esta funci&amp;oacute;n (para eliminar algunas otras dependencias de otras funciones privadas), se ver&amp;aacute; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="177c45f419a9b6ef3b4867a7b50e33c9277b2464" translate="yes" xml:space="preserve">
          <source>I really like how clean &lt;a href=&quot;https://stackoverflow.com/a/2117523/508537&quot;&gt;Broofa's answer&lt;/a&gt; is, but it's unfortunate that &lt;a href=&quot;https://stackoverflow.com/q/6906916/508537&quot;&gt;poor implementations of &lt;code&gt;Math.random&lt;/code&gt;&lt;/a&gt; leave the chance for collision.</source>
          <target state="translated">Realmente me gusta cu&amp;aacute;n limpia &lt;a href=&quot;https://stackoverflow.com/a/2117523/508537&quot;&gt;es la respuesta de Broofa&lt;/a&gt; , pero es lamentable que &lt;a href=&quot;https://stackoverflow.com/q/6906916/508537&quot;&gt;las implementaciones deficientes de &lt;code&gt;Math.random&lt;/code&gt; &lt;/a&gt; dejen la posibilidad de colisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="96f12778c6d1c9cb9e9f724becdd6f22ca538716" translate="yes" xml:space="preserve">
          <source>I tried an e6() that processes 16-bits at a time, still using the 256-element LUT, and it showed the diminishing returns of optimization.  Though it had fewer iterations, the inner logic was complicated by the increased processing, and it performed the same on desktop, and only ~10% faster on mobile.</source>
          <target state="translated">Probé un e6()que procesa 16 bits a la vez,todavía usando el LUT de 256 elementos,y mostró los rendimientos decrecientes de la optimización.Aunque tenía menos iteraciones,la lógica interna se complicaba por el aumento del procesamiento,y se comportaba igual en el escritorio,y sólo ~10% más rápido en el móvil.</target>
        </trans-unit>
        <trans-unit id="94aaabbae44f4bbe89bcd126762f2426e665aaa1" translate="yes" xml:space="preserve">
          <source>I wanted to understand broofa's answer, so I expanded it and added comments:</source>
          <target state="translated">Quería entender la respuesta de Broofa,así que la amplié y añadí comentarios:</target>
        </trans-unit>
        <trans-unit id="25657ae09cdf1fab859fd8ed647641b977c468b2" translate="yes" xml:space="preserve">
          <source>I'm sure most of you will understand what I did there, but maybe there is at least one person that will need an explanation:</source>
          <target state="translated">Estoy seguro de que la mayoría de ustedes entenderán lo que hice allí,pero tal vez haya al menos una persona que necesite una explicación:</target>
        </trans-unit>
        <trans-unit id="07563a60a63f4a9f390f1d6b7207d34d1b6c8994" translate="yes" xml:space="preserve">
          <source>I'm trying to create globally-unique identifiers in JavaScript.  I'm not sure what routines are available on all browsers, how &quot;random&quot; and seeded the built-in random number generator is, etc..</source>
          <target state="translated">Estoy tratando de crear identificadores únicos a nivel mundial en JavaScript.No estoy seguro de qué rutinas están disponibles en todos los navegadores,cuán &quot;aleatorio&quot; y sembrado está el generador de números aleatorios incorporado,etc.</target>
        </trans-unit>
        <trans-unit id="edc7a41e1c3907cce12f657d31fbd8e2e62aef40" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;the following Kybos&lt;/a&gt; random number generator to be a bit more cryptographically sound.</source>
          <target state="translated">Estoy usando &lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;el siguiente&lt;/a&gt; generador de n&amp;uacute;meros aleatorios de Kybos para que sea un poco m&amp;aacute;s criptogr&amp;aacute;fico.</target>
        </trans-unit>
        <trans-unit id="24039edb982143cd91d9ef8c02193697aea634ab" translate="yes" xml:space="preserve">
          <source>If ID's are generated more than 1 millisecond apart, they are 100% unique.</source>
          <target state="translated">Si las identificaciones se generan con más de un milisegundo de diferencia,son 100% únicas.</target>
        </trans-unit>
        <trans-unit id="ac405bebd06ff78ed2b4d8ddea9b5fb92065b420" translate="yes" xml:space="preserve">
          <source>If anyone is still interested, here's my solution.</source>
          <target state="translated">Si alguien sigue interesado,aquí está mi solución.</target>
        </trans-unit>
        <trans-unit id="48bbc7c26eab6650d1c206af8ed5fc119de549fd" translate="yes" xml:space="preserve">
          <source>If two ID's are generated at shorter intervals, and assuming that the random method is truly random, this would generate ID's that are 99.99999999999999% likely to be globally unique (collision in 1 of 10^15)</source>
          <target state="translated">Si se generan dos ID's a intervalos más cortos,y asumiendo que el método aleatorio es verdaderamente aleatorio,esto generaría ID's que tienen 99.999999999999% de probabilidad de ser globalmente únicos (colisión en 1 de 10^15)</target>
        </trans-unit>
        <trans-unit id="da9dc85e7b0b0b4506b983c73c54454686b58e25" translate="yes" xml:space="preserve">
          <source>If you just need a random 128 bit string in no particular format you can use:</source>
          <target state="translated">Si sólo necesitas una cadena aleatoria de 128 bits en ningún formato en particular que puedas usar:</target>
        </trans-unit>
        <trans-unit id="f6f68a22918e41434d843ee9ec535c8561aadbdf" translate="yes" xml:space="preserve">
          <source>Interested in how?  I've put the full source on &lt;a href=&quot;http://jsfiddle.net/jcward/7hyaC/3/&quot;&gt;http://jsfiddle.net/jcward/7hyaC/3/&lt;/a&gt; and on &lt;a href=&quot;http://jsperf.com/uuid-generator-opt/4&quot;&gt;http://jsperf.com/uuid-generator-opt/4&lt;/a&gt;</source>
          <target state="translated">&amp;iquest;Interesado en c&amp;oacute;mo? Puse la fuente completa en &lt;a href=&quot;http://jsfiddle.net/jcward/7hyaC/3/&quot;&gt;http://jsfiddle.net/jcward/7hyaC/3/&lt;/a&gt; y en &lt;a href=&quot;http://jsperf.com/uuid-generator-opt/4&quot;&gt;http://jsperf.com/uuid-generator-opt/4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67bc45c70d80a1bf17613bc8bbbc170612956cf6" translate="yes" xml:space="preserve">
          <source>It's just a simple AJAX call...</source>
          <target state="translated">Es sólo una simple llamada AJAX...</target>
        </trans-unit>
        <trans-unit id="0bad48021176f9dcc3cc0a91ab6055920051d3c7" translate="yes" xml:space="preserve">
          <source>JavaScript project on GitHub - &lt;a href=&quot;https://github.com/LiosK/UUID.js&quot;&gt;https://github.com/LiosK/UUID.js&lt;/a&gt;</source>
          <target state="translated">Proyecto JavaScript en GitHub: &lt;a href=&quot;https://github.com/LiosK/UUID.js&quot;&gt;https://github.com/LiosK/UUID.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aac95cb4089b08b71444e4ad4f7144f620d5f30d" translate="yes" xml:space="preserve">
          <source>Link to this post on my blog</source>
          <target state="translated">Enlace a esta entrada en mi blog</target>
        </trans-unit>
        <trans-unit id="c6d383d13425b9e72d4d3cd3c6a68dcf8a621c40" translate="yes" xml:space="preserve">
          <source>Low timestamp resolution of JavaScript is compensated by random
  numbers.</source>
          <target state="translated">La baja resolución de tiempo de JavaScript se compensa con números aleatorios.</target>
        </trans-unit>
        <trans-unit id="2a2f909c05dbaf7e4ed33d417a4c2eea6fe81f80" translate="yes" xml:space="preserve">
          <source>Minimized:</source>
          <target state="translated">Minimized:</target>
        </trans-unit>
        <trans-unit id="9ac71edf2df3b6f23bf1480bc49e05ce8b2772d8" translate="yes" xml:space="preserve">
          <source>Modualized:  &lt;a href=&quot;http://jcward.com/UUID.js&quot;&gt;http://jcward.com/UUID.js&lt;/a&gt; - &lt;code&gt;UUID.generate()&lt;/code&gt;</source>
          <target state="translated">Modualizado: &lt;a href=&quot;http://jcward.com/UUID.js&quot;&gt;http://jcward.com/UUID.js&lt;/a&gt; - &lt;code&gt;UUID.generate()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a267ce45e411c0a01408b105e2778acfc528266" translate="yes" xml:space="preserve">
          <source>Note that just randomly generating the identifiers byte by byte, or character by character, will not give you the same guarantees as a conforming implementation. Also, very important, systems working with compliant UUIDs may choose not to accept randomly generated ones, and many open source validators will actually check for a valid structure.</source>
          <target state="translated">Obsérvese que el mero hecho de generar aleatoriamente los identificadores byte por byte,o carácter por carácter,no le dará las mismas garantías que una implementación conforme.También,muy importante,los sistemas que trabajan con UUIDs conformes pueden elegir no aceptar los generados aleatoriamente,y muchos validadores de código abierto comprobarán realmente una estructura válida.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="301ff6a51953eb41837bc511f9e5c3ae53d3ae1d" translate="yes" xml:space="preserve">
          <source>Now I'm building the GUID using these 2 types to assemble the GUID with call 4 pieces, as follows: &lt;code&gt;XXXXXXXX&lt;/code&gt;&lt;code&gt;-XXXX-XXXX&lt;/code&gt;&lt;code&gt;-XXXX-XXXX&lt;/code&gt;&lt;code&gt;XXXXXXXX&lt;/code&gt;.</source>
          <target state="translated">Ahora estoy construyendo el GUID usando estos 2 tipos para ensamblar el GUID con 4 piezas de llamada, de la siguiente manera: &lt;code&gt;XXXXXXXX&lt;/code&gt; &lt;code&gt;-XXXX-XXXX&lt;/code&gt; &lt;code&gt;-XXXX-XXXX&lt;/code&gt; &lt;code&gt;XXXXXXXX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="541286569013fbf7b101171547520eb0173e2a80" translate="yes" xml:space="preserve">
          <source>On the client side:</source>
          <target state="translated">En el lado del cliente:</target>
        </trans-unit>
        <trans-unit id="a0f15b429784204142403c3e89a6f960dcf0f9c0" translate="yes" xml:space="preserve">
          <source>On the server side:</source>
          <target state="translated">En el lado del servidor:</target>
        </trans-unit>
        <trans-unit id="13545970e3244692419e21474fdc76bde2632c4f" translate="yes" xml:space="preserve">
          <source>Only uses 8 for &quot;y&quot; because that simplifies code readability (y is allowed to be 8, 9, A or B).</source>
          <target state="translated">Sólo usa 8 para &quot;y&quot; porque eso simplifica la legibilidad del código (se permite que la &quot;y&quot; sea 8,9,A o B).</target>
        </trans-unit>
        <trans-unit id="ba3badc82ce48554f2991852eda7f8ec170df9ae" translate="yes" xml:space="preserve">
          <source>Optimised for code readability not speed, so suitable for say a few hundred uuid's per second. Generates about 10000 uuid() per second in Chromium on my laptop using &lt;a href=&quot;http://jsbin.com/fuwigo/1&quot;&gt;http://jsbin.com/fuwigo/1&lt;/a&gt; to measure performance.</source>
          <target state="translated">Optimizado para la legibilidad del c&amp;oacute;digo, no para la velocidad, tan adecuado para unos pocos cientos de uuid por segundo. Genera alrededor de 10000 uuid () por segundo en Chromium en mi computadora port&amp;aacute;til usando &lt;a href=&quot;http://jsbin.com/fuwigo/1&quot;&gt;http://jsbin.com/fuwigo/1&lt;/a&gt; para medir el rendimiento.</target>
        </trans-unit>
        <trans-unit id="60ed329b871109f2e80c6d1ae06b4ed0b9f7192e" translate="yes" xml:space="preserve">
          <source>Quick Google found: &lt;a href=&quot;http://www.hoskinson.net/GuidGenerator/&quot;&gt;http://www.hoskinson.net/GuidGenerator/&lt;/a&gt;</source>
          <target state="translated">Google r&amp;aacute;pido encontrado: &lt;a href=&quot;http://www.hoskinson.net/GuidGenerator/&quot;&gt;http://www.hoskinson.net/GuidGenerator/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="141a92f11e1b6d5986e38858b9d1b5190206712a" translate="yes" xml:space="preserve">
          <source>Retrns Guid. Sets Guid to user specified Guid, if invalid, returns an empty guid.</source>
          <target state="translated">Retrae a Guid.Establece la guía en la guía especificada por el usuario,si no es válida,devuelve una guía vacía.</target>
        </trans-unit>
        <trans-unit id="1feb3a46dd04e5b57054f2f7163b3ede19e7d05f" translate="yes" xml:space="preserve">
          <source>Returns a new Guid and sets it's value internally.</source>
          <target state="translated">Devuelve un nuevo Guía y establece su valor internamente.</target>
        </trans-unit>
        <trans-unit id="f7190b2a5a80dd9efe0cd084caf578d575e92a30" translate="yes" xml:space="preserve">
          <source>Returns an empty Guid 00000000-0000-0000-0000-000000000000.</source>
          <target state="translated">Devuelve una guía vacía 00000000-0000-0000-0000-000000000000.</target>
        </trans-unit>
        <trans-unit id="9f0d77427c53b8fe9bdbe24d18a9cda7a1fd73bb" translate="yes" xml:space="preserve">
          <source>Returns boolean. True if empty/undefined/blank/null.</source>
          <target state="translated">Vuelve booleano.Cierto si está vacío,definido como un &quot;blandengue&quot;.</target>
        </trans-unit>
        <trans-unit id="0b9548497aeb94cb100a89d540f35d747703f2da" translate="yes" xml:space="preserve">
          <source>Returns boolean. True valid guid, false if not.</source>
          <target state="translated">Vuelve booleano.Verdadera guía válida,falsa si no.</target>
        </trans-unit>
        <trans-unit id="dc5fcb0d1e7fddd4555389a6d2e329c75a93e257" translate="yes" xml:space="preserve">
          <source>Returns value of internal Guid. If no guid has been specified, returns a new one (value is then stored internally).</source>
          <target state="translated">Devuelve el valor de la guía interna.Si no se ha especificado ninguna guía,devuelve una nueva (el valor se almacena entonces internamente).</target>
        </trans-unit>
        <trans-unit id="c26904e72aae0a0460d96b4406f82c33e9c9d7d4" translate="yes" xml:space="preserve">
          <source>Revisited my project that was using this function and disliked the verbosity. - But needed proper randomness.</source>
          <target state="translated">Revisé mi proyecto que usaba esta función y no me gustó la verborrea.-Pero necesitaba una aleatoriedad adecuada.</target>
        </trans-unit>
        <trans-unit id="a18caf389c3dfec80f9377a36c83ae5bd04e9610" translate="yes" xml:space="preserve">
          <source>Runs in node.js and browsers.</source>
          <target state="translated">Funciona en node.js y en los navegadores.</target>
        </trans-unit>
        <trans-unit id="150bfcc434ccf43658e52e7f89fa0b96084559fc" translate="yes" xml:space="preserve">
          <source>See RFC 4122 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;http://www.ietf.org/rfc/rfc4122.txt&lt;/a&gt;.</source>
          <target state="translated">Ver RFC 4122 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;http://www.ietf.org/rfc/rfc4122.txt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c898c8e028af83d42d23112d9bc7bc8ef781c67c" translate="yes" xml:space="preserve">
          <source>Should adhere to the RFC Type 4 (random) schema, since I had Problems last time parsing non-compliant uuids with Java's UUID.</source>
          <target state="translated">Debería adherirse al esquema RFC Tipo 4 (aleatorio),ya que tuve problemas la última vez analizando los uuids no conformes con el UUID de Java.</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Mostrar fragmento de código</target>
        </trans-unit>
        <trans-unit id="86a518bbca39591be11f3fd5fe07b57a8ca8b92a" translate="yes" xml:space="preserve">
          <source>Simple JavaScript module as a combination of best answers in this thread.</source>
          <target state="translated">Un simple módulo de JavaScript como una combinación de las mejores respuestas en este hilo.</target>
        </trans-unit>
        <trans-unit id="1659b110855243bf98e76cae362ba745d3973d56" translate="yes" xml:space="preserve">
          <source>Simple code that uses &lt;code&gt;crypto.getRandomValues(a)&lt;/code&gt; on &lt;a href=&quot;http://caniuse.com/#search=getRandomValues&quot;&gt;supported browsers&lt;/a&gt; (IE11+, iOS7+, FF21+, Chrome, Android Chrome). Avoids using &lt;code&gt;Math.random()&lt;/code&gt; because that can cause collisions (for example 20 collisions for 4000 generated uuids in a real situation by &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Muxa&lt;/a&gt;).</source>
          <target state="translated">C&amp;oacute;digo simple que usa &lt;code&gt;crypto.getRandomValues(a)&lt;/code&gt; en los &lt;a href=&quot;http://caniuse.com/#search=getRandomValues&quot;&gt;navegadores compatibles&lt;/a&gt; (IE11 +, iOS7 +, FF21 +, Chrome, Android Chrome). Evita usar &lt;code&gt;Math.random()&lt;/code&gt; porque eso puede causar colisiones (por ejemplo, 20 colisiones para 4000 uuidos generados en una situaci&amp;oacute;n real por &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Muxa&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f7eba97181912e78f6a57cfff39d6bcad00f38f4" translate="yes" xml:space="preserve">
          <source>Simple, fast generation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; UUIDS.</source>
          <target state="translated">Generaci&amp;oacute;n simple y r&amp;aacute;pida de &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; UUIDS.</target>
        </trans-unit>
        <trans-unit id="ef07d769a203f544d121bb303d711abf57a3bd8d" translate="yes" xml:space="preserve">
          <source>Small footprint (Want something smaller? &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;Check this out!&lt;/a&gt;)</source>
          <target state="translated">Huella peque&amp;ntilde;a (&amp;iquest;Quieres algo m&amp;aacute;s peque&amp;ntilde;o? &amp;iexcl; &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;Mira esto!&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8f5a810efa3353e6f2f014c15bc590ece9b55f4c" translate="yes" xml:space="preserve">
          <source>So by my 6th iteration of optimizations, I beat the most popular answer by over &lt;strong&gt;12X&lt;/strong&gt;, the accepted answer by over &lt;strong&gt;9X&lt;/strong&gt;, and the fast-non-compliant answer by &lt;strong&gt;2-3X&lt;/strong&gt;.  And I'm still rfc4122 compliant.</source>
          <target state="translated">Entonces, en mi sexta iteraci&amp;oacute;n de optimizaciones, super&amp;eacute; la respuesta m&amp;aacute;s popular en m&amp;aacute;s de &lt;strong&gt;12X&lt;/strong&gt; , la respuesta aceptada en m&amp;aacute;s de &lt;strong&gt;9X&lt;/strong&gt; y la respuesta r&amp;aacute;pida no compatible en &lt;strong&gt;2-3X&lt;/strong&gt; . Y sigo siendo compatible con rfc4122.</target>
        </trans-unit>
        <trans-unit id="9494e936f74439fc11e4574afbc044b327ffb0e1" translate="yes" xml:space="preserve">
          <source>So it replaces &lt;code&gt;x&lt;/code&gt; with any random hex digit, &lt;code&gt;y&lt;/code&gt; with random data (except forcing the top 2 bits to &lt;code&gt;10&lt;/code&gt; per the RFC spec), and the regex doesn't match the &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt; characters, so he doesn't have to deal with them.  Very, very slick.</source>
          <target state="translated">Por lo tanto, reemplaza &lt;code&gt;x&lt;/code&gt; con cualquier d&amp;iacute;gito hexadecimal aleatorio, &lt;code&gt;y&lt;/code&gt; con datos aleatorios (excepto forzar los 2 bits superiores a &lt;code&gt;10&lt;/code&gt; seg&amp;uacute;n la especificaci&amp;oacute;n RFC), y la expresi&amp;oacute;n regular no coincide con los &lt;code&gt;4&lt;/code&gt; caracteres, por lo que no tiene que tratar con ellos. Muy, muy h&amp;aacute;bil.</target>
        </trans-unit>
        <trans-unit id="72d265bb2510b83e6b57e5485d72d6bdb674bd84" translate="yes" xml:space="preserve">
          <source>Sometimes the &lt;code&gt;Math.random()&lt;/code&gt; function will return
shorter number (for example &lt;code&gt;0.4363&lt;/code&gt;), due to zeros at the end (from the example above, actually the number is &lt;code&gt;0.4363000000000000&lt;/code&gt;). That's why I'm appending to this string &lt;code&gt;&quot;000000000&quot;&lt;/code&gt; (a string with nine zeros) and then cutting it off with &lt;code&gt;substr()&lt;/code&gt; function to make it nine characters exactly (filling zeros to the right).</source>
          <target state="translated">A veces, la funci&amp;oacute;n &lt;code&gt;Math.random()&lt;/code&gt; devolver&amp;aacute; un n&amp;uacute;mero m&amp;aacute;s corto (por ejemplo, &lt;code&gt;0.4363&lt;/code&gt; ), debido a ceros al final (del ejemplo anterior, en realidad el n&amp;uacute;mero es &lt;code&gt;0.4363000000000000&lt;/code&gt; ). Es por eso que agrego a esta cadena &lt;code&gt;&quot;000000000&quot;&lt;/code&gt; (una cadena con nueve ceros) y luego la &lt;code&gt;substr()&lt;/code&gt; con la funci&amp;oacute;n substr () para que tenga nueve caracteres exactamente (rellenando ceros a la derecha).</target>
        </trans-unit>
        <trans-unit id="2b6553806f7c0f446906395a9393b4c8aa630b83" translate="yes" xml:space="preserve">
          <source>Ten million executions of this implementation take just 32.5 seconds, which is the fastest I've ever seen in a browser (the only solution without loops/iterations).</source>
          <target state="translated">Diez millones de ejecuciones de esta implementación tardan sólo 32,5 segundos,lo que es lo más rápido que he visto en un navegador (la única solución sin loopsiteraciones).</target>
        </trans-unit>
        <trans-unit id="863a161fb9b85e54a7fd55bdfa890d777c3ecfdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math.random()&lt;/code&gt; function returns a decimal number between 0 and 1 with 16 digits after the decimal fraction point (for
example &lt;code&gt;0.4363923368509859&lt;/code&gt;).</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;Math.random()&lt;/code&gt; devuelve un n&amp;uacute;mero decimal entre 0 y 1 con 16 d&amp;iacute;gitos despu&amp;eacute;s del punto de fracci&amp;oacute;n decimal (por ejemplo, &lt;code&gt;0.4363923368509859&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="acf4bc33ac4b01c7fa998c17fe2ab66beb9bb5bc" translate="yes" xml:space="preserve">
          <source>The GUID / UUID should be at least 32 characters and should stay in the ASCII range to avoid trouble when passing them around.</source>
          <target state="translated">El GUID UUID debe tener al menos 32 caracteres y debe permanecer en el rango ASCII para evitar problemas al pasarlos.</target>
        </trans-unit>
        <trans-unit id="8d751df4e468da72f5959abfc1549c743c1e3ef6" translate="yes" xml:space="preserve">
          <source>The GUID is in the following format &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt;.</source>
          <target state="translated">El GUID tiene el siguiente formato &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2541cbe64e15ab5d69eb08799c64ce9b1235e066" translate="yes" xml:space="preserve">
          <source>The above function should have a decent balance between speed and randomness.</source>
          <target state="translated">La función anterior debe tener un equilibrio decente entre la velocidad y la aleatoriedad.</target>
        </trans-unit>
        <trans-unit id="ee47e6da31b267bf2647229a714a454ce65b3891" translate="yes" xml:space="preserve">
          <source>The best way to generate them, is to follow implementation instructions in the said RFC, use one of the many community vetted open source implementations.</source>
          <target state="translated">La mejor manera de generarlos,es seguir las instrucciones de implementación en el mencionado RFC,usar una de las muchas implementaciones de código abierto examinadas por la comunidad.</target>
        </trans-unit>
        <trans-unit id="66063bdfe4ff5bb41650a2179c29b0ae5581986f" translate="yes" xml:space="preserve">
          <source>The better way:</source>
          <target state="translated">La mejor manera:</target>
        </trans-unit>
        <trans-unit id="c6b5d62b3d2700a480f847f1f5fc03de421dbca1" translate="yes" xml:space="preserve">
          <source>The final optimization technique to apply - unroll the loop.  Since we're looping a fixed number of times, we can technically write this all out by hand.  I tried this once with a single random variable r that I kept re-assigning, and performance tanked.  But with four variables assigned random data up front, then using the lookup table, and applying the proper RFC bits, this version smokes them all:</source>
          <target state="translated">La técnica de optimización final a aplicar-desenrollar el bucle.Ya que estamos haciendo un número fijo de bucles,técnicamente podemos escribir todo esto a mano.Lo intenté una vez con una sola variable aleatoria r que seguí reasignando,y el rendimiento se redujo.Pero con cuatro variables asignadas al azar por adelantado,luego usando la tabla de búsqueda,y aplicando los bits RFC adecuados,esta versión los elimina todos:</target>
        </trans-unit>
        <trans-unit id="27e5e746f56f3da4623926ba36af11cf24511a47" translate="yes" xml:space="preserve">
          <source>The first step toward performance is to eliminate the RegEx and its callback functions and use a simple loop instead.  This means we have to deal with the &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; characters whereas broofa did not.  Also, note that we can use String Array indexing to keep his slick String template architecture:</source>
          <target state="translated">El primer paso hacia el rendimiento es eliminar el RegEx y sus funciones de devoluci&amp;oacute;n de llamada y utilizar un bucle simple. Esto significa que tenemos que lidiar con los caracteres &lt;code&gt;-&lt;/code&gt; y &lt;code&gt;4&lt;/code&gt; , mientras que broofa no. Adem&amp;aacute;s, tenga en cuenta que podemos usar la indexaci&amp;oacute;n de String Array para mantener su elegante arquitectura de plantilla de String:</target>
        </trans-unit>
        <trans-unit id="1f91cea12f7bb764e0dde68e533cd0001d9f6c9a" translate="yes" xml:space="preserve">
          <source>The first thing to know is that function calls are expensive, as are regular expressions (though he only uses 1, it has 32 callbacks, one for each match, and in each of the 32 callbacks it calls Math.random() and v.toString(16)).</source>
          <target state="translated">Lo primero que hay que saber es que las llamadas a funciones son caras,al igual que las expresiones regulares (aunque sólo usa 1,tiene 32 llamadas,una por cada partido,y en cada una de las 32 llamadas llama a Math.random()y v.toString(16)).</target>
        </trans-unit>
        <trans-unit id="5efd11cea6dbb2ca7d3856a6504baae9880ab778" translate="yes" xml:space="preserve">
          <source>The function is as simple as:</source>
          <target state="translated">La función es tan simple como:</target>
        </trans-unit>
        <trans-unit id="237b687de13a23a564832cfd020006932e2b7094" translate="yes" xml:space="preserve">
          <source>The funny thing is, generating 16 bytes of random data is the easy part.  The whole trick is expressing it in String format with RFC compliance, and it's most tightly accomplished with 16 bytes of random data, an unrolled loop and lookup table.</source>
          <target state="translated">Lo gracioso es que generar 16 bytes de datos aleatorios es la parte fácil.El truco está en expresarlo en formato String con conformidad RFC,y se logra con 16 bytes de datos aleatorios,un bucle desenrollado y una tabla de búsqueda.</target>
        </trans-unit>
        <trans-unit id="5fe390d75a55e87b91e0f2c344ccf52b0f992757" translate="yes" xml:space="preserve">
          <source>The next optimization is another classic.  Since we're only handling 4-bits of output in each loop iteration, let's cut the number of loops in half and process 8-bits each iteration.  This is tricky since we still have to handle the RFC compliant bit positions, but it's not too hard.  We then have to make a larger lookup table (16x16, or 256) to store 0x00 - 0xff, and we build it only once, outside the e5() function.</source>
          <target state="translated">La siguiente optimización es otro clásico.Como sólo manejamos 4 bits de salida en cada iteración de bucle,cortemos el número de bucles a la mitad y procesemos 8 bits en cada iteración.Esto es difícil ya que todavía tenemos que manejar las posiciones de bits compatibles con RFC,pero no es demasiado difícil.Luego tenemos que hacer una tabla de búsqueda más grande (16x16,o 256)para almacenar 0x00-0xff,y la construimos sólo una vez,fuera de la función e5().</target>
        </trans-unit>
        <trans-unit id="2c2a678ccb7c402e8bfa66c3bb0b047a01880eeb" translate="yes" xml:space="preserve">
          <source>The next step is a small one on the desktop but makes a decent difference on mobile.  Let's make fewer Math.random() calls and utilize all those random bits instead of throwing 87% of them away with a random buffer that gets shifted out each iteration.  Let's also move that template definition out of the loop, just in case it helps:</source>
          <target state="translated">El siguiente paso es uno pequeño en el escritorio pero hace una diferencia decente en el móvil.Hagamos menos llamadas Math.random()y utilicemos todos esos bits aleatorios en lugar de tirar el 87% de ellos con un buffer aleatorio que se desplaza en cada iteración.También movamos esa definición de plantilla fuera del bucle,por si acaso ayuda:</target>
        </trans-unit>
        <trans-unit id="475810532e8a0fcebdd7c79eff23716432a61245" translate="yes" xml:space="preserve">
          <source>The reason for adding exactly nine zeros is because of the worse case scenario, which is when the &lt;code&gt;Math.random()&lt;/code&gt; function will return exactly 0 or 1 (probability of 1/10^16 for each one of them). That's why we needed to add nine zeros to it (&lt;code&gt;&quot;0&quot;+&quot;000000000&quot;&lt;/code&gt; or &lt;code&gt;&quot;1&quot;+&quot;000000000&quot;&lt;/code&gt;), and then cutting it off from the second index (3rd character) with a length of eight characters. For the rest of the cases, the addition of zeros will not harm the result because it is cutting it off anyway.</source>
          <target state="translated">La raz&amp;oacute;n para agregar exactamente nueve ceros se debe al peor de los casos, que es cuando la funci&amp;oacute;n &lt;code&gt;Math.random()&lt;/code&gt; devolver&amp;aacute; exactamente 0 o 1 (probabilidad de 1/10 ^ 16 para cada uno de ellos). Es por eso que necesit&amp;aacute;bamos agregarle nueve ceros ( &lt;code&gt;&quot;0&quot;+&quot;000000000&quot;&lt;/code&gt; o &lt;code&gt;&quot;1&quot;+&quot;000000000&quot;&lt;/code&gt; ), y luego cortarlo del segundo &amp;iacute;ndice (tercer car&amp;aacute;cter) con una longitud de ocho caracteres. Para el resto de los casos, la adici&amp;oacute;n de ceros no da&amp;ntilde;ar&amp;aacute; el resultado porque lo est&amp;aacute; cortando de todos modos.</target>
        </trans-unit>
        <trans-unit id="c79498301c475af77620127310a64ed51077604c" translate="yes" xml:space="preserve">
          <source>Then we cut off the &lt;code&gt;0.&lt;/code&gt; prefix (&lt;code&gt;0.6fb7687f&lt;/code&gt; =&amp;gt;
&lt;code&gt;6fb7687f&lt;/code&gt;) and get a string with eight hexadecimal
characters long.</source>
          <target state="translated">Luego cortamos el prefijo &lt;code&gt;0.&lt;/code&gt; ( &lt;code&gt;0.6fb7687f&lt;/code&gt; =&amp;gt; &lt;code&gt;6fb7687f&lt;/code&gt; ) y obtenemos una cadena con ocho caracteres hexadecimales.</target>
        </trans-unit>
        <trans-unit id="9c8cde2548b6605f69b7f5277aa0db7d69ca4dbc" translate="yes" xml:space="preserve">
          <source>Then we take this number and convert
it to a string with base 16 (from the example above we'll get
&lt;code&gt;0.6fb7687f&lt;/code&gt;).</source>
          <target state="translated">Luego tomamos este n&amp;uacute;mero y lo convertimos en una cadena con base 16 (del ejemplo anterior obtendremos &lt;code&gt;0.6fb7687f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f896659fdb57404f3ca1c0dd540b6ea7e7493cc7" translate="yes" xml:space="preserve">
          <source>There are other methods that involve using an ActiveX control, but stay away from these!</source>
          <target state="translated">Hay otros métodos que implican el uso de un control ActiveX,¡pero no te acerques a ellos!</target>
        </trans-unit>
        <trans-unit id="b6f314cd5d1632bbd12fce8c34bf0331b26c9531" translate="yes" xml:space="preserve">
          <source>There is a jQuery plugin that handles Guid's nicely @ &lt;a href=&quot;http://plugins.jquery.com/project/GUID_Helper&quot;&gt;http://plugins.jquery.com/project/GUID_Helper&lt;/a&gt;</source>
          <target state="translated">Hay un complemento jQuery que maneja muy bien Guid's @ &lt;a href=&quot;http://plugins.jquery.com/project/GUID_Helper&quot;&gt;http://plugins.jquery.com/project/GUID_Helper&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a114b1049ab77d7bb9cf82e5902a2fc8f9522f5b" translate="yes" xml:space="preserve">
          <source>This accomplishes the same goal as the &lt;a href=&quot;https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523&quot;&gt;current highest-rated answer&lt;/a&gt;, but in 50+ fewer bytes by exploiting coercion, recursion, and exponential notation. For those curious how it works, here's the annotated form of an older version of the function:</source>
          <target state="translated">Esto logra el mismo objetivo que la &lt;a href=&quot;https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523&quot;&gt;respuesta actual mejor calificada&lt;/a&gt; , pero en m&amp;aacute;s de 50 bytes menos explotando la coerci&amp;oacute;n, la recursi&amp;oacute;n y la notaci&amp;oacute;n exponencial. Para aquellos curiosos de c&amp;oacute;mo funciona, aqu&amp;iacute; est&amp;aacute; la forma anotada de una versi&amp;oacute;n anterior de la funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="c054a07bc3de1a2f3d45f3aab21e9af1ebf626bf" translate="yes" xml:space="preserve">
          <source>This create version 4 UUID (created from pseudo random numbers) :</source>
          <target state="translated">Esto crea la versión 4 UUID (creada a partir de números pseudo aleatorios):</target>
        </trans-unit>
        <trans-unit id="58ce504b9f25064cbcb7de092b962c9e2dda22c0" translate="yes" xml:space="preserve">
          <source>This one is based on date, and add a random suffix to &quot;ensure&quot; uniqueness.
Works well for css identifiers.
It always returns something like and is easy to hack:</source>
          <target state="translated">Este se basa en la fecha,y añade un sufijo aleatorio para &quot;asegurar&quot; la unicidad.Funciona bien para los identificadores css.Siempre devuelve algo como y es fácil de hackear:</target>
        </trans-unit>
        <trans-unit id="c7a27f8c65115f387fec4d67fe32dab189f55a09" translate="yes" xml:space="preserve">
          <source>This saves us 10-30% depending on platform.  Not bad.  But the next big step gets rid of the toString function calls altogether with an optimization classic - the look-up table.  A simple 16-element lookup table will perform the job of toString(16) in much less time:</source>
          <target state="translated">Esto nos ahorra un 10-30% dependiendo de la plataforma.No está mal.Pero el siguiente gran paso es deshacerse de las llamadas de la función toString junto con un clásico de la optimización:la tabla de búsqueda.Una simple tabla de búsqueda de 16 elementos realizará el trabajo de toString(16)en mucho menos tiempo:</target>
        </trans-unit>
        <trans-unit id="3e8bb274abfb2de0a2c13afefa3450f9f50f8d6e" translate="yes" xml:space="preserve">
          <source>To differ between these two types, I added a flag parameter to a pair creator function &lt;code&gt;_p8(s)&lt;/code&gt;, the &lt;code&gt;s&lt;/code&gt; parameter tells the function whether to add dashes or not.</source>
          <target state="translated">Para diferir entre estos dos tipos, agregu&amp;eacute; un par&amp;aacute;metro de indicador a una funci&amp;oacute;n creadora de pares &lt;code&gt;_p8(s)&lt;/code&gt; , el par&amp;aacute;metro &lt;code&gt;s&lt;/code&gt; le dice a la funci&amp;oacute;n si agregar guiones o no.</target>
        </trans-unit>
        <trans-unit id="1c7c150202fdddceb6b1c221a05cdb4e4c1ce115" translate="yes" xml:space="preserve">
          <source>To test the performance, you can run this code:</source>
          <target state="translated">Para probar el rendimiento,puedes ejecutar este código:</target>
        </trans-unit>
        <trans-unit id="fe1c1c9e7da2bc289fcd3379642172b845c1989a" translate="yes" xml:space="preserve">
          <source>UUID object allows a variety of access to the UUID including access to
  the UUID fields.</source>
          <target state="translated">El objeto UUID permite una variedad de acceso a la UUID incluyendo el acceso a los campos de UUID.</target>
        </trans-unit>
        <trans-unit id="a3b6d33b0517d8c2933196e2f509432ec47c7b44" translate="yes" xml:space="preserve">
          <source>UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier), according to &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;, are identifiers with a certain uniqueness guarantee.</source>
          <target state="translated">Los UUID (identificador &amp;uacute;nico universal), tambi&amp;eacute;n conocidos como GUID (identificador &amp;uacute;nico global), de acuerdo con &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt; , son identificadores con una cierta garant&amp;iacute;a de unicidad.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="670720d3ce8655613fb8e5107bd150a04eb2bb3d" translate="yes" xml:space="preserve">
          <source>Version 4 UUIDs (UUIDs from random numbers) and version 1 UUIDs
  (time-based UUIDs) are available.</source>
          <target state="translated">Están disponibles los UUID de la versión 4 (UUID de números aleatorios)y los UUID de la versión 1 (UUID basados en el tiempo).</target>
        </trans-unit>
        <trans-unit id="3ebdce3a7ac7e93ecd1c5e84caaea7c1835d5f49" translate="yes" xml:space="preserve">
          <source>Want even smaller? Check this out: &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;https://gist.github.com/jed/982883&lt;/a&gt;</source>
          <target state="translated">&amp;iquest;Quieres a&amp;uacute;n m&amp;aacute;s peque&amp;ntilde;o? Mira esto: &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;https://gist.github.com/jed/982883&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a55040507e6337ca3e32ec7d20777fced2a290d7" translate="yes" xml:space="preserve">
          <source>Well, this has a bunch of answers already, but unfortunately there's not a &quot;true&quot; random in the bunch. The version below is an adaptation of broofa's answer, but updated to include a &quot;true&quot; random function that uses crypto libraries where available, and the Alea() function as a fallback.</source>
          <target state="translated">Bueno,esto ya tiene un montón de respuestas,pero desafortunadamente no hay un &quot;verdadero&quot; azar en el montón.La siguiente versión es una adaptación de la respuesta de Broofa,pero actualizada para incluir una función aleatoria &quot;verdadera&quot; que utiliza librerías criptográficas cuando están disponibles,y la función Alea()como alternativa.</target>
        </trans-unit>
        <trans-unit id="7dad31345c220d2cbe299045c03a52e22b20d937" translate="yes" xml:space="preserve">
          <source>Where the &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; positions may only have certain values. At this time, the only valid values for M are 1, 2, 3, 4 and 5, so randomly generating that position would make most results unacceptable.</source>
          <target state="translated">Donde las posiciones &lt;em&gt;M&lt;/em&gt; y &lt;em&gt;N&lt;/em&gt; solo pueden tener ciertos valores. En este momento, los &amp;uacute;nicos valores v&amp;aacute;lidos para M son 1, 2, 3, 4 y 5, por lo que generar aleatoriamente esa posici&amp;oacute;n har&amp;iacute;a que la mayor&amp;iacute;a de los resultados sean inaceptables.</target>
        </trans-unit>
        <trans-unit id="0b33ee51f78c94d3fa3e3d46126b5b2de5f92677" translate="yes" xml:space="preserve">
          <source>Which will return something like &lt;code&gt;2350143528-4164020887-938913176-2513998651&lt;/code&gt;.</source>
          <target state="translated">Lo que devolver&amp;aacute; algo as&amp;iacute; como &lt;code&gt;2350143528-4164020887-938913176-2513998651&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00947a234207676f6b4f448ed89af28aa686b86c" translate="yes" xml:space="preserve">
          <source>With such a web service, you could develop a REST web interface that consumes the GUID web service, and serves it through AJAX to javascript in a browser.</source>
          <target state="translated">Con tal servicio web,se podría desarrollar una interfaz web REST que consuma el servicio web GUID,y lo sirva a través de AJAX a javascript en un navegador.</target>
        </trans-unit>
        <trans-unit id="d4fb620aaed70bd0d3e4873af0570771d0ed649d" translate="yes" xml:space="preserve">
          <source>You can increase this number by adding more digits, but to generate 100% unique ID's you will need to use a global counter.</source>
          <target state="translated">Puedes aumentar este número añadiendo más dígitos,pero para generar identificaciones 100% únicas necesitarás usar un contador global.</target>
        </trans-unit>
        <trans-unit id="ba59cf2f4053a03ebc1856c70811cb75b72d66b4" translate="yes" xml:space="preserve">
          <source>You can use node-uuid (&lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;https://github.com/kelektiv/node-uuid&lt;/a&gt;)</source>
          <target state="translated">Puede usar node-uuid ( &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;https://github.com/kelektiv/node-uuid&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="da5cce2c829e18ada2502aedf48c415870558171" translate="yes" xml:space="preserve">
          <source>broofa's answer is pretty slick, indeed - impressively clever, really...  rfc4122 compliant, somewhat readable, and compact.  Awesome!</source>
          <target state="translated">La respuesta de Broofa es bastante ingeniosa,de hecho...impresionantemente inteligente,realmente...que cumple con el rfc4122,algo legible y compacto.¡Impresionante!</target>
        </trans-unit>
        <trans-unit id="5f37ba236f9a0c5e9361a753b0b9f82646c7f35a" translate="yes" xml:space="preserve">
          <source>if you need RFC compatibility, this formatting will pass as a valid version 4 GUID:</source>
          <target state="translated">si necesitas compatibilidad con RFC,este formato pasará como una GUID de la versión 4 válida:</target>
        </trans-unit>
        <trans-unit id="b32441e1af6b6c4e0de9080307ccfb43a3ea08b5" translate="yes" xml:space="preserve">
          <source>uid-139410573297741</source>
          <target state="translated">uid-139410573297741</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
