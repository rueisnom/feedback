<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/105034">
    <body>
      <group id="105034">
        <trans-unit id="68960fcc7ae0d6fd78f4a201eeb38fa8bb9a0ecf" translate="yes" xml:space="preserve">
          <source>&quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;</source>
          <target state="translated">&quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;</target>
        </trans-unit>
        <trans-unit id="a032d777f177ebd6e92855f3bce4c9d3de29d561" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsbin.com/uqives/3&quot;&gt;On jsbin&lt;/a&gt; if you want to test it.</source>
          <target state="translated">テストしたい場合は&lt;a href=&quot;http://jsbin.com/uqives/3&quot;&gt;jsbin&lt;/a&gt;で。</target>
        </trans-unit>
        <trans-unit id="54853102ac5288d10305ee4fe284f5676c8b3049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(Math.random().toString(16).substr(2,8)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(Math.random().toString(16).substr(2,8)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="518c3687d473e405f713a2e4202e1617f257a7bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="7de15d516266250876bf7df115f60af51b87ba40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random().toString(16)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random().toString(16)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="a4bfa8acce2c58437408c5567e16ba754efc3619" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be advised:&lt;/strong&gt; my primary goal was to show and teach potential optimization strategies.  Other answers cover important topics such as collisions and truly random numbers, which are important for generating good UUIDs.</source>
          <target state="translated">&lt;strong&gt;注意してください：&lt;/strong&gt;私の主な目標は、潜在的な最適化戦略を示し、教えることでした。 その他の回答では、衝突や真の乱数など、適切なUUIDを生成するために重要な重要なトピックについて説明します。</target>
        </trans-unit>
        <trans-unit id="a8558249d3c59db88fd2392888164f8297752e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But, can we get speed &lt;em&gt;and&lt;/em&gt; RFC compliance?  I say, YES!&lt;/strong&gt;  Can we maintain readability?  Well...  Not really, but it's easy if you follow along.</source>
          <target state="translated">&lt;strong&gt;しかし、速度&lt;em&gt;と&lt;/em&gt; RFCへの準拠を取得できますか？&lt;/strong&gt; &lt;strong&gt;はい、そうです！&lt;/strong&gt; 読みやすさを維持できますか？ ええと...そんなことはありませんが、一緒に行けば簡単です。</target>
        </trans-unit>
        <trans-unit id="0aa9a4872e5871a2d50503b7555d5a560abc60db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b79b40ec4e7164794f3d15d07d564b8ad8717468" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit :&lt;/strong&gt;  I thought it was worth pointing out that no GUID generator can guarantee unique keys (check the &lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_Unique_Identifier&quot;&gt;wikipedia article&lt;/a&gt;).  There is always a chance of collisions.  A GUID simply offers a large enough universe of keys to reduce the change of collisions to almost nil.</source>
          <target state="translated">&lt;strong&gt;編集：&lt;/strong&gt; GUIDジェネレーターが一意のキーを保証できないことを指摘する価値があると思いました（ &lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_Unique_Identifier&quot;&gt;ウィキペディアの記事を&lt;/a&gt;確認してください ）。 衝突の可能性は常にあります。 GUIDは、衝突の変化をほとんどなくすのに十分な大きさのキーユニバースを提供します。</target>
        </trans-unit>
        <trans-unit id="7015ec1e0155111b63b36ee572b6bff0228a4302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enjoy! :-)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;楽しい！&lt;/strong&gt; &lt;strong&gt;:-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274339a4ddbe260b6a97172504035c73b5738ea9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Features Generates RFC 4122 compliant UUIDs.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;機能RFC 4122準拠のUUIDを生成します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d77806e165bb48692701ad0de9af22b7850fba31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Guid.empty&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guid.empty&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b0671d2fe50cfe5c11475ae51a2760cbcda6baf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Guid.newGuid()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guid.newGuid()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cf7a599e78acfd69a7e284fa3d3b67982dccad6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Install Using NPM:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NPMを使用したインストール：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bf75b8ebe887aa6577cd720281924cbc349c929" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or Using uuid via browser:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;またはブラウザ経由でuuidを使用する：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35889b4f21085883cbaa19da2a6b14684bd0aada" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The algorithm:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アルゴリズム：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25b1935958bb975920d8012409acce290de08a28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The assembly:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アセンブリ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c002957f28f184ef81e532a83ab90120a2e876b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UUID.js The RFC-compliant UUID generator for JavaScript.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UUID.js JavaScript用のRFC準拠のUUIDジェネレーター。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="469336e52af17d529352df89c21d2a5435257e12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2015-06-02&lt;/strong&gt;:  Be aware that UUID uniqueness relies heavily on the underlying random number generator (RNG).  The solution above uses &lt;code&gt;Math.random()&lt;/code&gt; for brevity, however &lt;code&gt;Math.random()&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to be a high-quality RNG.  See Adam Hyland's &lt;a href=&quot;http://bocoup.com/weblog/random-numbers/&quot;&gt;excellent writeup on Math.random()&lt;/a&gt; for details.  For a more robust solution, consider something like &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;the uuid module&lt;/a&gt; (disclaimer: I, @broofa, am the author), which uses higher quality RNG APIs where available.</source>
          <target state="translated">&lt;strong&gt;更新、2015-06-02&lt;/strong&gt; ：UUIDの一意性は、基礎となる乱数ジェネレータ（RNG）に大きく依存していることに注意してください。 上記のソリューションでは簡潔にするために &lt;code&gt;Math.random()&lt;/code&gt; を使用していますが、 &lt;code&gt;Math.random()&lt;/code&gt; が高品質のRNGであるとは&lt;em&gt;限りませ&lt;/em&gt;ん。 詳細については&lt;a href=&quot;http://bocoup.com/weblog/random-numbers/&quot;&gt;、Math.random（）に関する&lt;/a&gt; Adam Hylandの優れた記事を参照してください。 より堅牢なソリューションについては、可能な場合はより高品質のRNG APIを使用&lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;するuuidモジュール&lt;/a&gt; （免責事項：I、@ broofa、作成者）などを検討してください。</target>
        </trans-unit>
        <trans-unit id="be0809af7361460fb45bdf84889bab84728f5e00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2015-08-26&lt;/strong&gt;: As a side-note, this &lt;a href=&quot;https://gist.githubusercontent.com/aristus/f0c311df98d92e367df0&quot;&gt;gist&lt;/a&gt; describes how to determine how many IDs can be generated before reaching a certain probability of collision.  For example, with 3.26x10&lt;sup&gt;15&lt;/sup&gt; version 4 RFC4122 UUIDs you have a 1-in-a-million chance of collision.</source>
          <target state="translated">&lt;strong&gt;更新、2015-08-26&lt;/strong&gt; ：補足として、この&lt;a href=&quot;https://gist.githubusercontent.com/aristus/f0c311df98d92e367df0&quot;&gt;要点&lt;/a&gt;は、衝突の特定の確率に達する前に生成できるIDの数を決定する方法を説明しています。 たとえば、3.26x10 &lt;sup&gt;15&lt;/sup&gt;バージョン4 RFC4122 UUIDを使用すると、100万分の1の確率で衝突が発生します。</target>
        </trans-unit>
        <trans-unit id="8fd4ff892cec4b2ce586409848ac995315f7db82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2017-06-28&lt;/strong&gt;: A &lt;a href=&quot;https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html&quot;&gt;good article from Chrome developers&lt;/a&gt; discussing the state of Math.random PRNG quality in Chrome, Firefox, and Safari.  tl;dr - As of late-2015 it's &quot;pretty good&quot;, but not cryptographic quality.  To address that issue, here's an updated version of the above solution that uses ES6, the &lt;code&gt;crypto&lt;/code&gt; API, and &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;a bit of JS wizardry I can't take credit for&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;更新、2017-06-28&lt;/strong&gt; ：Chrome、Firefox、およびSafariにおけるMath.random PRNGの品質の状態について説明する&lt;a href=&quot;https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html&quot;&gt;Chrome開発者から&lt;/a&gt;の優れた記事 。 tl; dr-2015年後半の時点では「かなり良い」ですが、暗号品質ではありません。 この問題に対処するために、ES6、 &lt;code&gt;crypto&lt;/code&gt; API、および&lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;私が信用できない少しのJSウィザードを&lt;/a&gt;使用する上記のソリューションの更新バージョンを次に示します。</target>
        </trans-unit>
        <trans-unit id="1395f19d7608f025cb58cb5b03b266e650d27c84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2020-01-06&lt;/strong&gt;: There is a &lt;a href=&quot;https://github.com/tc39/proposal-uuid&quot;&gt;proposal in the works&lt;/a&gt; for a standard &lt;code&gt;uuid&lt;/code&gt; module as part of the JS language</source>
          <target state="translated">&lt;strong&gt;アップデート、2020-01-06&lt;/strong&gt; ：JS言語の一部としての標準 &lt;code&gt;uuid&lt;/code&gt; モジュールの&lt;a href=&quot;https://github.com/tc39/proposal-uuid&quot;&gt;提案が作業中&lt;/a&gt;です</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="782117c6d143f47d437449ef980ce5c3b76b9beb" translate="yes" xml:space="preserve">
          <source>A popular Open Source tool for working with UUIDs in JavaScript is &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;node-uuid&lt;/a&gt;</source>
          <target state="translated">JavaScriptでUUIDを操作するための一般的なオープンソースツールは&lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;node-uuidです。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba3de79909c92e381cfcb7d2ad3bb6d12b74b04d" translate="yes" xml:space="preserve">
          <source>A version based on Briguy37's answer and some bitwise operators to extract nibble sized windows from the buffer.</source>
          <target state="translated">Briguy37さんの回答と、バッファからニブルサイズのウィンドウを抽出するビット演算子に基づいたバージョン。</target>
        </trans-unit>
        <trans-unit id="8b32b76d7d98de48b1c8d4fca55b71b36e586c91" translate="yes" xml:space="preserve">
          <source>A web service would be useful.</source>
          <target state="translated">ウェブサービスがあれば便利です。</target>
        </trans-unit>
        <trans-unit id="efe0742dcba00224262ee5b679bb64e2dd8254ac" translate="yes" xml:space="preserve">
          <source>Adjusted my own UUID/GUID generator with some extras &lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">私自身のUUID / GUIDジェネレーターを&lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;ここ&lt;/a&gt;でいくつかの追加機能で調整しました 。</target>
        </trans-unit>
        <trans-unit id="12c755e3c27b17c5f8c8e0155d60eabe76a0405a" translate="yes" xml:space="preserve">
          <source>An UUID must have this format:</source>
          <target state="translated">UUID はこの形式を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="12c696bae1749afdd4c10d3071dc3d49e8ee7766" translate="yes" xml:space="preserve">
          <source>Basically, the same inner logic, except we check for &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;, and using a while loop (instead of &lt;code&gt;replace()&lt;/code&gt; callbacks) gets us an almost 3X improvement!</source>
          <target state="translated">基本的に、同じ内部ロジックですが、 &lt;code&gt;-&lt;/code&gt; または &lt;code&gt;4&lt;/code&gt; をチェックし、（ &lt;code&gt;replace()&lt;/code&gt; コールバックの代わりに） whileループを使用すると、ほぼ3倍の改善が得られます。</target>
        </trans-unit>
        <trans-unit id="99bc098eb1d1be9a1e4498d4108a52905669d15e" translate="yes" xml:space="preserve">
          <source>Below is my script with the Mash and Kybos methods from baagoe.com excluded.</source>
          <target state="translated">以下は baagoe.com の Mash と Kybos メソッドを除いたスクリプトです。</target>
        </trans-unit>
        <trans-unit id="c650c2cdd89b69f5f213fde542a728fd50fc0983" translate="yes" xml:space="preserve">
          <source>But first, my results, compared to broofa, &lt;code&gt;guid&lt;/code&gt; (the accepted answer), and the non-rfc-compliant &lt;code&gt;generateQuickGuid&lt;/code&gt;:</source>
          <target state="translated">しかし、最初に、私の結果は、broofa、 &lt;code&gt;guid&lt;/code&gt; （受け入れられた回答）、およびrfcに準拠していないgenerateQuickGuidと比較しています。</target>
        </trans-unit>
        <trans-unit id="b3ef02731ee702db53ed68d0ba455be85ab88617" translate="yes" xml:space="preserve">
          <source>But if you're looking at that regular expression, those many &lt;code&gt;replace()&lt;/code&gt; callbacks, &lt;code&gt;toString()&lt;/code&gt;'s and &lt;code&gt;Math.random()&lt;/code&gt; function calls (where he's only using 4 bits of the result and wasting the rest), you may start to wonder about performance.  Indeed, joelpt even decided to toss out RFC for generic GUID speed with &lt;code&gt;generateQuickGUID&lt;/code&gt;.</source>
          <target state="translated">しかし、その正規表現、それらの多くの &lt;code&gt;replace()&lt;/code&gt; コールバック、 &lt;code&gt;toString()&lt;/code&gt; 、および &lt;code&gt;Math.random()&lt;/code&gt; 関数呼び出し（彼が結果の4ビットのみを使用しており、残りを無駄にしている）を見ている場合、パフォーマンスについて疑問に思います。 実際、joelptは、generateQuickGUIDで汎用GUIDの速度を求めるRFCを放棄することさえ決定しました。</target>
        </trans-unit>
        <trans-unit id="717ee0beb1305a91a9a0535e4961247e24e32fc5" translate="yes" xml:space="preserve">
          <source>Can't vouch for this implementation, but SOMEONE must publish a bonafide GUID generator.</source>
          <target state="translated">この実装を保証することはできませんが、誰かが正規のGUIDジェネレータを公開しなければなりません。</target>
        </trans-unit>
        <trans-unit id="01536fdf7462153cb5b1d4174a32db140aec25c2" translate="yes" xml:space="preserve">
          <source>Create GUID / UUID in JavaScript</source>
          <target state="translated">JavaScriptでGUID UUIDを作成する</target>
        </trans-unit>
        <trans-unit id="95e6f920efe4af2e79e605edcc5e28ed1b15c6c5" translate="yes" xml:space="preserve">
          <source>Cryptographically strong random # generation on supporting platforms.</source>
          <target state="translated">サポートするプラットフォーム上での暗号的に強力なランダム#生成。</target>
        </trans-unit>
        <trans-unit id="0ed439a6611cd1800f10c6bd949b76b487cd2b75" translate="yes" xml:space="preserve">
          <source>Download Raw File (uuid v1): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&lt;/a&gt;
Download Raw File (uuid v4): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&lt;/a&gt;</source>
          <target state="translated">生ファイルのダウンロード（uuid v1）： &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&quot;&gt;https&lt;/a&gt; ://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js生ファイルのダウンロード（uuid v4）： &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&quot;&gt;https&lt;/a&gt; : //raw.githubusercontent.com/kelektiv/node -uuid / master / v4.js</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="ed293f503837b9994324552ef62fd849b6ccd846" translate="yes" xml:space="preserve">
          <source>ES6 sample</source>
          <target state="translated">ES6サンプル</target>
        </trans-unit>
        <trans-unit id="d7ddd41483a929219e6c64489e8d0eca72b29277" translate="yes" xml:space="preserve">
          <source>Edit: The above code follow the intention, but not the letter of the RFC. Among other discrepancies it's a few random digits short. (Add more random digits if you need it) The upside is that this it's really fast :)
You can &lt;a href=&quot;https://www.freecodeformat.com/validate-uuid-guid.php&quot;&gt;test validity of your GUID here&lt;/a&gt;</source>
          <target state="translated">編集：上記のコードは意図に従っていますが、RFCのレターではありません。 他の不一致の中でも、それはいくつかのランダムな数字が短いです。 （必要に応じてランダムな数字を追加します）利点は、これが本当に速いことです:) &lt;a href=&quot;https://www.freecodeformat.com/validate-uuid-guid.php&quot;&gt;ここでGUIDの有効性をテスト&lt;/a&gt;できます</target>
        </trans-unit>
        <trans-unit id="8d3d52832b1fac459c9b6a3703887d6cc457b232" translate="yes" xml:space="preserve">
          <source>Eventually we build the GUID with the following chaining: &lt;code&gt;_p8() + _p8(true) + _p8(true) + _p8()&lt;/code&gt;, and return it.</source>
          <target state="translated">最終的に、次のチェーンでGUIDを構築します： &lt;code&gt;_p8() + _p8(true) + _p8(true) + _p8()&lt;/code&gt; 、それを返します。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="ce2e69b5373a12bdf9ca27da533c517da11f6e58" translate="yes" xml:space="preserve">
          <source>Fastest GUID like string generator method in the format &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt;. This does not generate standard-compliant GUID.</source>
          <target state="translated">&lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt; 形式の文字列生成メソッドのような最速のGUID。 これは、標準に準拠したGUIDを生成しません。</target>
        </trans-unit>
        <trans-unit id="5df81ffa82179b458e1d55e350db9d88805a69b2" translate="yes" xml:space="preserve">
          <source>Features:</source>
          <target state="translated">Features:</target>
        </trans-unit>
        <trans-unit id="19967ecebb03ba38cc744454a4a0af16a7d1a8e8" translate="yes" xml:space="preserve">
          <source>For an &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; version 4 compliant solution, this one-liner(ish) solution is the most compact I could come up with:</source>
          <target state="translated">&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt;バージョン4準拠のソリューションの場合、このワンライナー（イッシュ）ソリューションは、私が思いつく中で最もコンパクトです。</target>
        </trans-unit>
        <trans-unit id="0fa53fa9049ab50aea42e7e785eb43daf3f7b3eb" translate="yes" xml:space="preserve">
          <source>For an explanation, let's start with broofa's code:</source>
          <target state="translated">説明のために、まずはブルファのコードを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ab095b33ae4fc9f4c67064d2613f861fa360db4f" translate="yes" xml:space="preserve">
          <source>For those wanting an rfc4122 version 4 compliant solution with speed considerations (few calls to Math.random()):</source>
          <target state="translated">速度を考慮したrfc4122バージョン4準拠のソリューションをお望みの方へ(Math.random()への呼び出しが少ない)。</target>
        </trans-unit>
        <trans-unit id="27fd956c4f1ae3c3c9ea49a4371ca211e7952e8e" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html&quot;&gt;sagi shkedy's technical blog&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html&quot;&gt;sagi shkedyのテクニカルブログから&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c23b6b59226a5a1d9cd6f8d8dedd94737c6ed311" translate="yes" xml:space="preserve">
          <source>Generate RFC4122 version 1 or version 4 UUIDs</source>
          <target state="translated">RFC4122バージョン1またはバージョン4のUUIDの生成</target>
        </trans-unit>
        <trans-unit id="4557d9f04a62ecf6d45c63f669d4d3c5969dbed7" translate="yes" xml:space="preserve">
          <source>Generates 26 [a-z0-9] characters, yielding a UID that is both shorter and more unique than RFC compliant GUIDs. Dashes can be trivially added if human-readability matters.</source>
          <target state="translated">26文字の[a-z0-9]を生成し、RFC準拠のGUIDよりも短くてユニークなUIDを生成します。人間の可読性に問題がある場合は、ダッシュを簡単に追加することができます。</target>
        </trans-unit>
        <trans-unit id="c37e10249fd54645ca14d4f8396558ccf7ed72d1" translate="yes" xml:space="preserve">
          <source>Here are usage examples and timings for this function and several of this question's other answers. The timing was performed under Chrome m25, 10 million iterations each.</source>
          <target state="translated">この関数の使用例とタイミングと、この質問の他の回答のいくつかをご紹介します。タイミングはChrome m25で1000万回ずつ繰り返しています。</target>
        </trans-unit>
        <trans-unit id="2c247f731cda829ae025095a8672be34b63c5632" translate="yes" xml:space="preserve">
          <source>Here is a combination of the &lt;a href=&quot;https://stackoverflow.com/a/2117523/11236&quot;&gt;top voted answer&lt;/a&gt;, with a workaround for &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Chrome's collisions&lt;/a&gt;:</source>
          <target state="translated">以下は、 &lt;a href=&quot;https://stackoverflow.com/a/2117523/11236&quot;&gt;トップ投票の回答&lt;/a&gt;と&lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Chromeの衝突の&lt;/a&gt;回避策の組み合わせです。</target>
        </trans-unit>
        <trans-unit id="2ecd98e5e9126eb4bab9ba9ad9ac22335c8bce41" translate="yes" xml:space="preserve">
          <source>Here is a sample of the UUIDs generated :</source>
          <target state="translated">ここに生成されたUUIDのサンプルがあります。</target>
        </trans-unit>
        <trans-unit id="8261ebf8b6de8850d44b04f0d061fad3a19b0b3b" translate="yes" xml:space="preserve">
          <source>Here is a totally non-compliant but very performant implementation to generate an ASCII-safe GUID-like unique identifier.</source>
          <target state="translated">完全に非準拠ですが、ASCIIセーフなGUIDのようなユニークな識別子を生成するための非常にパフォーマンスの高い実装がここにあります。</target>
        </trans-unit>
        <trans-unit id="503ff0a7dc77de993388c1e8009b02daf56b5134" translate="yes" xml:space="preserve">
          <source>Here is the timing code.</source>
          <target state="translated">こちらがタイミングコードです。</target>
        </trans-unit>
        <trans-unit id="8117e866b4a966496f20af5f99e7bfccef4d04fa" translate="yes" xml:space="preserve">
          <source>Here's a fiddle to test.</source>
          <target state="translated">ここにテスト用のバイオリンがあります。</target>
        </trans-unit>
        <trans-unit id="60ff7b70fc22b138ecf074493ca83ac61514a43a" translate="yes" xml:space="preserve">
          <source>Here's a similar &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; version 4 compliant solution that solves that issue by offsetting the first 13 hex numbers by a hex portion of the timestamp, and once depleted offsets by a hex portion of the microseconds since pageload.  That way, even if &lt;code&gt;Math.random&lt;/code&gt; is on the same seed, both clients would have to generate the UUID the exact same number of microseconds since pageload (if high-perfomance time is supported) AND at the exact same millisecond (or 10,000+ years later) to get the same UUID:</source>
          <target state="translated">最初の13桁の16進数をタイムスタンプの16進数部分でオフセットし、一度ページロード以降のマイクロ秒の16進数部分でオフセットを使い果たして、この問題を解決する同様の&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt;バージョン4準拠のソリューションを次に示します。 このようにすると、 &lt;code&gt;Math.random&lt;/code&gt; が同じシード上にある場合でも、両方のクライアントは、ページロード（高パフォーマンスの時間がサポートされている場合）とまったく同じミリ秒（または10,000+年）で、正確に同じマイクロ秒数のUUIDを生成する必要があります。後で）同じUUIDを取得するには：</target>
        </trans-unit>
        <trans-unit id="4e21d976cadf293249dcfa48c33d29b6a5e06a86" translate="yes" xml:space="preserve">
          <source>Here's a solution dated Oct. 9, 2011 from a comment by user &lt;em&gt;jed&lt;/em&gt; at &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;https://gist.github.com/982883&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://gist.github.com/982883&quot;&gt;https://gist.github.com/982883で&lt;/a&gt;ユーザー&lt;em&gt;jedが&lt;/em&gt;コメントした2011年10月9日付けのソリューションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b18abaaddfcfe54404b43a907e463bef2f7d1c8b" translate="yes" xml:space="preserve">
          <source>Here's some code based on &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;, section 4.4 (Algorithms for Creating a UUID from Truly Random or Pseudo-Random Number).</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122の&lt;/a&gt;セクション4.4（真の乱数または疑似乱数からUUIDを作成するためのアルゴリズム）に基づくコードを次に示します。</target>
        </trans-unit>
        <trans-unit id="79fadeaf6225db3316856bec94555fdca94516bd" translate="yes" xml:space="preserve">
          <source>I divided the GUID into 4 pieces, each piece divided into 2 types (or formats): &lt;code&gt;XXXXXXXX&lt;/code&gt; and &lt;code&gt;-XXXX-XXXX&lt;/code&gt;.</source>
          <target state="translated">GUIDを4つの部分に分割し、各部分を &lt;code&gt;XXXXXXXX&lt;/code&gt; と &lt;code&gt;-XXXX-XXXX&lt;/code&gt; の 2つのタイプ（または形式）に分割しました。</target>
        </trans-unit>
        <trans-unit id="a293bf864a92ae3bdd88eece8abb78a30146eb51" translate="yes" xml:space="preserve">
          <source>I hope my logic is correct -- it's very easy to make a mistake in this kind of tedious bit-work.  But the outputs look good to me.  I hope you enjoyed this mad ride through code optimization!</source>
          <target state="translated">私の論理が正しいことを願っています --この種の面倒なビットワークでは、間違いを犯すのは非常に簡単です。しかし、出力は私には良いように見えます。コード最適化の狂おしい旅を楽しんでいただけたでしょうか?</target>
        </trans-unit>
        <trans-unit id="25720d68a9e1e89c7d65f4d275b178f61def9e81" translate="yes" xml:space="preserve">
          <source>I know, it is an old question. Just for completeness, if your environment is SharePoint, there is a utility function called &lt;code&gt;SP.Guid.newGuid&lt;/code&gt; (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx&quot;&gt;msdn link&lt;/a&gt;) which creates a new guid. This function is inside the sp.init.js file. If you rewrite this function (to remove some other dependencies from other private functions), it looks like this:</source>
          <target state="translated">私は知っています、それは古い質問です。 完全を &lt;code&gt;SP.Guid.newGuid&lt;/code&gt; ために、環境がSharePointの場合、 SP.Guid.newGuid （ &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx&quot;&gt;msdn link&lt;/a&gt; ）というユーティリティ関数があり、新しいGUIDを作成します。 この関数は、sp.init.jsファイル内にあります。 この関数を書き換えると（他のプライベート関数から他の依存関係を削除するため）、次のようになります。</target>
        </trans-unit>
        <trans-unit id="177c45f419a9b6ef3b4867a7b50e33c9277b2464" translate="yes" xml:space="preserve">
          <source>I really like how clean &lt;a href=&quot;https://stackoverflow.com/a/2117523/508537&quot;&gt;Broofa's answer&lt;/a&gt; is, but it's unfortunate that &lt;a href=&quot;https://stackoverflow.com/q/6906916/508537&quot;&gt;poor implementations of &lt;code&gt;Math.random&lt;/code&gt;&lt;/a&gt; leave the chance for collision.</source>
          <target state="translated">私は&lt;a href=&quot;https://stackoverflow.com/a/2117523/508537&quot;&gt;Broofaの答え&lt;/a&gt;がいかにクリーンであるかを本当に気に入っていますが、 Math.randomの &lt;a href=&quot;https://stackoverflow.com/q/6906916/508537&quot;&gt;不適切な実装が&lt;/a&gt;衝突の可能性を残すのは残念です。</target>
        </trans-unit>
        <trans-unit id="96f12778c6d1c9cb9e9f724becdd6f22ca538716" translate="yes" xml:space="preserve">
          <source>I tried an e6() that processes 16-bits at a time, still using the 256-element LUT, and it showed the diminishing returns of optimization.  Though it had fewer iterations, the inner logic was complicated by the increased processing, and it performed the same on desktop, and only ~10% faster on mobile.</source>
          <target state="translated">一度に 16 ビットを処理する e6()を、256 要素の LUT を使用して試してみましたが、最適化の見返りが少なくなっていました。反復回数は少ないものの、処理の増加により内部ロジックが複雑になっており、デスクトップでは同じように動作し、モバイルでは~10%程度しか速くなりませんでした。</target>
        </trans-unit>
        <trans-unit id="94aaabbae44f4bbe89bcd126762f2426e665aaa1" translate="yes" xml:space="preserve">
          <source>I wanted to understand broofa's answer, so I expanded it and added comments:</source>
          <target state="translated">broofaさんの回答を理解したかったので、拡大してコメントを追加しました。</target>
        </trans-unit>
        <trans-unit id="25657ae09cdf1fab859fd8ed647641b977c468b2" translate="yes" xml:space="preserve">
          <source>I'm sure most of you will understand what I did there, but maybe there is at least one person that will need an explanation:</source>
          <target state="translated">私がそこでやったことはほとんどの方が理解してくれると思いますが、もしかしたら説明が必要な方が一人くらいはいるかもしれません。</target>
        </trans-unit>
        <trans-unit id="07563a60a63f4a9f390f1d6b7207d34d1b6c8994" translate="yes" xml:space="preserve">
          <source>I'm trying to create globally-unique identifiers in JavaScript.  I'm not sure what routines are available on all browsers, how &quot;random&quot; and seeded the built-in random number generator is, etc..</source>
          <target state="translated">私はJavaScriptでグローバルに一意な識別子を作成しようとしています。すべてのブラウザで利用できるルーチンがどのようなものか、内蔵の乱数発生器がどのように「ランダム」でシードされているかなど、よくわかりません。</target>
        </trans-unit>
        <trans-unit id="edc7a41e1c3907cce12f657d31fbd8e2e62aef40" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;the following Kybos&lt;/a&gt; random number generator to be a bit more cryptographically sound.</source>
          <target state="translated">&lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;次のKybos&lt;/a&gt;乱数ジェネレータを使用して、暗号化を少し強化しています。</target>
        </trans-unit>
        <trans-unit id="24039edb982143cd91d9ef8c02193697aea634ab" translate="yes" xml:space="preserve">
          <source>If ID's are generated more than 1 millisecond apart, they are 100% unique.</source>
          <target state="translated">IDが1ミリ秒以上離れて生成された場合は、100%一意です。</target>
        </trans-unit>
        <trans-unit id="ac405bebd06ff78ed2b4d8ddea9b5fb92065b420" translate="yes" xml:space="preserve">
          <source>If anyone is still interested, here's my solution.</source>
          <target state="translated">もし誰かがまだ興味を持っているならば、私の解決策はここにあります。</target>
        </trans-unit>
        <trans-unit id="48bbc7c26eab6650d1c206af8ed5fc119de549fd" translate="yes" xml:space="preserve">
          <source>If two ID's are generated at shorter intervals, and assuming that the random method is truly random, this would generate ID's that are 99.99999999999999% likely to be globally unique (collision in 1 of 10^15)</source>
          <target state="translated">2つのIDがより短い間隔で生成され、ランダム法が本当にランダムであると仮定すると、99.99999999999999999%の確率で世界的にユニークなIDが生成されることになります(10^15分の1の衝突)。</target>
        </trans-unit>
        <trans-unit id="da9dc85e7b0b0b4506b983c73c54454686b58e25" translate="yes" xml:space="preserve">
          <source>If you just need a random 128 bit string in no particular format you can use:</source>
          <target state="translated">特定の形式ではなく、ランダムな128ビットの文字列が必要なだけならば、使用することができます。</target>
        </trans-unit>
        <trans-unit id="f6f68a22918e41434d843ee9ec535c8561aadbdf" translate="yes" xml:space="preserve">
          <source>Interested in how?  I've put the full source on &lt;a href=&quot;http://jsfiddle.net/jcward/7hyaC/3/&quot;&gt;http://jsfiddle.net/jcward/7hyaC/3/&lt;/a&gt; and on &lt;a href=&quot;http://jsperf.com/uuid-generator-opt/4&quot;&gt;http://jsperf.com/uuid-generator-opt/4&lt;/a&gt;</source>
          <target state="translated">どのように興味がありますか？ 完全なソースを&lt;a href=&quot;http://jsfiddle.net/jcward/7hyaC/3/&quot;&gt;http://jsfiddle.net/jcward/7hyaC/3/&lt;/a&gt;および&lt;a href=&quot;http://jsperf.com/uuid-generator-opt/4&quot;&gt;http://jsperf.com/uuid-generator-opt/4に配置しました&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67bc45c70d80a1bf17613bc8bbbc170612956cf6" translate="yes" xml:space="preserve">
          <source>It's just a simple AJAX call...</source>
          <target state="translated">単純なAJAX呼び出しだ...</target>
        </trans-unit>
        <trans-unit id="0bad48021176f9dcc3cc0a91ab6055920051d3c7" translate="yes" xml:space="preserve">
          <source>JavaScript project on GitHub - &lt;a href=&quot;https://github.com/LiosK/UUID.js&quot;&gt;https://github.com/LiosK/UUID.js&lt;/a&gt;</source>
          <target state="translated">GitHub上のJavaScriptプロジェクト-https &lt;a href=&quot;https://github.com/LiosK/UUID.js&quot;&gt;://github.com/LiosK/UUID.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aac95cb4089b08b71444e4ad4f7144f620d5f30d" translate="yes" xml:space="preserve">
          <source>Link to this post on my blog</source>
          <target state="translated">私のブログのこの記事へのリンク</target>
        </trans-unit>
        <trans-unit id="c6d383d13425b9e72d4d3cd3c6a68dcf8a621c40" translate="yes" xml:space="preserve">
          <source>Low timestamp resolution of JavaScript is compensated by random
  numbers.</source>
          <target state="translated">JavaScriptのタイムスタンプの解像度が低い場合、乱数で補正されます。</target>
        </trans-unit>
        <trans-unit id="2a2f909c05dbaf7e4ed33d417a4c2eea6fe81f80" translate="yes" xml:space="preserve">
          <source>Minimized:</source>
          <target state="translated">Minimized:</target>
        </trans-unit>
        <trans-unit id="9ac71edf2df3b6f23bf1480bc49e05ce8b2772d8" translate="yes" xml:space="preserve">
          <source>Modualized:  &lt;a href=&quot;http://jcward.com/UUID.js&quot;&gt;http://jcward.com/UUID.js&lt;/a&gt; - &lt;code&gt;UUID.generate()&lt;/code&gt;</source>
          <target state="translated">Modualized： &lt;a href=&quot;http://jcward.com/UUID.js&quot;&gt;http&lt;/a&gt; : &lt;code&gt;UUID.generate()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a267ce45e411c0a01408b105e2778acfc528266" translate="yes" xml:space="preserve">
          <source>Note that just randomly generating the identifiers byte by byte, or character by character, will not give you the same guarantees as a conforming implementation. Also, very important, systems working with compliant UUIDs may choose not to accept randomly generated ones, and many open source validators will actually check for a valid structure.</source>
          <target state="translated">識別子をバイト単位で、あるいは文字単位でランダムに生成しても、 適合する実装と同じ保証は得られないことに注意してください。また、非常に重要なことですが、準拠したUUIDを使用しているシステムでは、ランダムに生成されたものを受け入れないことを選択することができます。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="301ff6a51953eb41837bc511f9e5c3ae53d3ae1d" translate="yes" xml:space="preserve">
          <source>Now I'm building the GUID using these 2 types to assemble the GUID with call 4 pieces, as follows: &lt;code&gt;XXXXXXXX&lt;/code&gt;&lt;code&gt;-XXXX-XXXX&lt;/code&gt;&lt;code&gt;-XXXX-XXXX&lt;/code&gt;&lt;code&gt;XXXXXXXX&lt;/code&gt;.</source>
          <target state="translated">次のように、これら2つのタイプを使用してGUIDを構築し、呼び出し4でGUIDをアセンブルします： &lt;code&gt;XXXXXXXX&lt;/code&gt; &lt;code&gt;-XXXX-XXXX&lt;/code&gt; &lt;code&gt;-XXXX-XXXX&lt;/code&gt; &lt;code&gt;XXXXXXXX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="541286569013fbf7b101171547520eb0173e2a80" translate="yes" xml:space="preserve">
          <source>On the client side:</source>
          <target state="translated">クライアント側では</target>
        </trans-unit>
        <trans-unit id="a0f15b429784204142403c3e89a6f960dcf0f9c0" translate="yes" xml:space="preserve">
          <source>On the server side:</source>
          <target state="translated">サーバー側では</target>
        </trans-unit>
        <trans-unit id="13545970e3244692419e21474fdc76bde2632c4f" translate="yes" xml:space="preserve">
          <source>Only uses 8 for &quot;y&quot; because that simplifies code readability (y is allowed to be 8, 9, A or B).</source>
          <target state="translated">y」に8を使用するのは、コードの読みやすさを簡単にするためです(yは8、9、AまたはBのいずれかにすることができます)。</target>
        </trans-unit>
        <trans-unit id="ba3badc82ce48554f2991852eda7f8ec170df9ae" translate="yes" xml:space="preserve">
          <source>Optimised for code readability not speed, so suitable for say a few hundred uuid's per second. Generates about 10000 uuid() per second in Chromium on my laptop using &lt;a href=&quot;http://jsbin.com/fuwigo/1&quot;&gt;http://jsbin.com/fuwigo/1&lt;/a&gt; to measure performance.</source>
          <target state="translated">速度ではなくコードの可読性が最適化されているため、毎秒数百のuuidに適しています。 パフォーマンスを測定するために&lt;a href=&quot;http://jsbin.com/fuwigo/1&quot;&gt;http://jsbin.com/fuwigo/1&lt;/a&gt;を使用して私のラップトップ上のChromiumで毎秒約10000 uuid（）を生成します。</target>
        </trans-unit>
        <trans-unit id="60ed329b871109f2e80c6d1ae06b4ed0b9f7192e" translate="yes" xml:space="preserve">
          <source>Quick Google found: &lt;a href=&quot;http://www.hoskinson.net/GuidGenerator/&quot;&gt;http://www.hoskinson.net/GuidGenerator/&lt;/a&gt;</source>
          <target state="translated">クイックGoogleが見つかりました： &lt;a href=&quot;http://www.hoskinson.net/GuidGenerator/&quot;&gt;http&lt;/a&gt; : //www.hoskinson.net/GuidGenerator/</target>
        </trans-unit>
        <trans-unit id="141a92f11e1b6d5986e38858b9d1b5190206712a" translate="yes" xml:space="preserve">
          <source>Retrns Guid. Sets Guid to user specified Guid, if invalid, returns an empty guid.</source>
          <target state="translated">Guidを返します。Guidをユーザが指定したGuidに設定し、無効な場合は空のGuidを返します。</target>
        </trans-unit>
        <trans-unit id="1feb3a46dd04e5b57054f2f7163b3ede19e7d05f" translate="yes" xml:space="preserve">
          <source>Returns a new Guid and sets it's value internally.</source>
          <target state="translated">新しいGuidを返し、その値を内部で設定します。</target>
        </trans-unit>
        <trans-unit id="f7190b2a5a80dd9efe0cd084caf578d575e92a30" translate="yes" xml:space="preserve">
          <source>Returns an empty Guid 00000000-0000-0000-0000-000000000000.</source>
          <target state="translated">空の Guid 00000000-0000-0000-0000-0000-000000000000 を返します。</target>
        </trans-unit>
        <trans-unit id="9f0d77427c53b8fe9bdbe24d18a9cda7a1fd73bb" translate="yes" xml:space="preserve">
          <source>Returns boolean. True if empty/undefined/blank/null.</source>
          <target state="translated">booleanを返します。emptyundefinedblanknullなら真。</target>
        </trans-unit>
        <trans-unit id="0b9548497aeb94cb100a89d540f35d747703f2da" translate="yes" xml:space="preserve">
          <source>Returns boolean. True valid guid, false if not.</source>
          <target state="translated">ブール値を返します。真の有効なguid、そうでない場合は偽。</target>
        </trans-unit>
        <trans-unit id="dc5fcb0d1e7fddd4555389a6d2e329c75a93e257" translate="yes" xml:space="preserve">
          <source>Returns value of internal Guid. If no guid has been specified, returns a new one (value is then stored internally).</source>
          <target state="translated">内部のGuidの値を返します。guidが指定されていない場合は、新しいguidを返します(値は内部に格納されます)。</target>
        </trans-unit>
        <trans-unit id="c26904e72aae0a0460d96b4406f82c33e9c9d7d4" translate="yes" xml:space="preserve">
          <source>Revisited my project that was using this function and disliked the verbosity. - But needed proper randomness.</source>
          <target state="translated">この関数を使用していたプロジェクトを再訪し、冗長性を嫌っていましたが、適切なランダム性が必要でした。-しかし、適切なランダム性が必要でした。</target>
        </trans-unit>
        <trans-unit id="a18caf389c3dfec80f9377a36c83ae5bd04e9610" translate="yes" xml:space="preserve">
          <source>Runs in node.js and browsers.</source>
          <target state="translated">node.jsとブラウザで実行します。</target>
        </trans-unit>
        <trans-unit id="150bfcc434ccf43658e52e7f89fa0b96084559fc" translate="yes" xml:space="preserve">
          <source>See RFC 4122 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;http://www.ietf.org/rfc/rfc4122.txt&lt;/a&gt;.</source>
          <target state="translated">RFC 4122 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;http://www.ietf.org/rfc/rfc4122.txtを&lt;/a&gt;参照してください 。</target>
        </trans-unit>
        <trans-unit id="c898c8e028af83d42d23112d9bc7bc8ef781c67c" translate="yes" xml:space="preserve">
          <source>Should adhere to the RFC Type 4 (random) schema, since I had Problems last time parsing non-compliant uuids with Java's UUID.</source>
          <target state="translated">前回、JavaのUUIDで非準拠のUUIDを解析する際に問題があったので、RFC Type 4 (random)スキーマに準拠する必要があります。</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">コードスニペットを表示</target>
        </trans-unit>
        <trans-unit id="86a518bbca39591be11f3fd5fe07b57a8ca8b92a" translate="yes" xml:space="preserve">
          <source>Simple JavaScript module as a combination of best answers in this thread.</source>
          <target state="translated">このスレッドのベストアンサーの組み合わせとしてのシンプルなJavaScriptモジュール。</target>
        </trans-unit>
        <trans-unit id="1659b110855243bf98e76cae362ba745d3973d56" translate="yes" xml:space="preserve">
          <source>Simple code that uses &lt;code&gt;crypto.getRandomValues(a)&lt;/code&gt; on &lt;a href=&quot;http://caniuse.com/#search=getRandomValues&quot;&gt;supported browsers&lt;/a&gt; (IE11+, iOS7+, FF21+, Chrome, Android Chrome). Avoids using &lt;code&gt;Math.random()&lt;/code&gt; because that can cause collisions (for example 20 collisions for 4000 generated uuids in a real situation by &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Muxa&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://caniuse.com/#search=getRandomValues&quot;&gt;サポートさ&lt;/a&gt;れているブラウザー （IE11 +、iOS7 +、FF21 +、Chrome、Android Chrome）で &lt;code&gt;crypto.getRandomValues(a)&lt;/code&gt; を使用する単純なコード。 衝突を引き起こす可能性があるため、 &lt;code&gt;Math.random()&lt;/code&gt; の使用を避けます（たとえば、実際の状況では、 &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Muxa&lt;/a&gt;によって生成された4000個のUUIDに対して20回の衝突）。</target>
        </trans-unit>
        <trans-unit id="f7eba97181912e78f6a57cfff39d6bcad00f38f4" translate="yes" xml:space="preserve">
          <source>Simple, fast generation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; UUIDS.</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; UUIDSのシンプルで高速な生成。</target>
        </trans-unit>
        <trans-unit id="ef07d769a203f544d121bb303d711abf57a3bd8d" translate="yes" xml:space="preserve">
          <source>Small footprint (Want something smaller? &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;Check this out!&lt;/a&gt;)</source>
          <target state="translated">小さなフットプリント（何か小さいものが欲しいですか？ &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;これをチェックしてください！&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="8f5a810efa3353e6f2f014c15bc590ece9b55f4c" translate="yes" xml:space="preserve">
          <source>So by my 6th iteration of optimizations, I beat the most popular answer by over &lt;strong&gt;12X&lt;/strong&gt;, the accepted answer by over &lt;strong&gt;9X&lt;/strong&gt;, and the fast-non-compliant answer by &lt;strong&gt;2-3X&lt;/strong&gt;.  And I'm still rfc4122 compliant.</source>
          <target state="translated">したがって、最適化の6回目の反復までに、最も人気のある回答を&lt;strong&gt;12倍&lt;/strong&gt;以上、受け入れられた回答を&lt;strong&gt;9倍&lt;/strong&gt;以上、そして非準拠の回答を&lt;strong&gt;2〜3倍上回ってい&lt;/strong&gt;ます。 そして、私はまだrfc4122に準拠しています。</target>
        </trans-unit>
        <trans-unit id="9494e936f74439fc11e4574afbc044b327ffb0e1" translate="yes" xml:space="preserve">
          <source>So it replaces &lt;code&gt;x&lt;/code&gt; with any random hex digit, &lt;code&gt;y&lt;/code&gt; with random data (except forcing the top 2 bits to &lt;code&gt;10&lt;/code&gt; per the RFC spec), and the regex doesn't match the &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt; characters, so he doesn't have to deal with them.  Very, very slick.</source>
          <target state="translated">したがって、 &lt;code&gt;x&lt;/code&gt; を任意の16進数に置き換え、 &lt;code&gt;y&lt;/code&gt; をランダムデータに置き換えます（ただし、RFC仕様に従って上位2ビットを &lt;code&gt;10&lt;/code&gt; に強制します）。正規表現は &lt;code&gt;-&lt;/code&gt; または &lt;code&gt;4&lt;/code&gt; 文字と一致しないため、対処する必要はありません彼らと。 非常に滑らかです。</target>
        </trans-unit>
        <trans-unit id="72d265bb2510b83e6b57e5485d72d6bdb674bd84" translate="yes" xml:space="preserve">
          <source>Sometimes the &lt;code&gt;Math.random()&lt;/code&gt; function will return
shorter number (for example &lt;code&gt;0.4363&lt;/code&gt;), due to zeros at the end (from the example above, actually the number is &lt;code&gt;0.4363000000000000&lt;/code&gt;). That's why I'm appending to this string &lt;code&gt;&quot;000000000&quot;&lt;/code&gt; (a string with nine zeros) and then cutting it off with &lt;code&gt;substr()&lt;/code&gt; function to make it nine characters exactly (filling zeros to the right).</source>
          <target state="translated">末尾のゼロのために、 &lt;code&gt;Math.random()&lt;/code&gt; 関数が短い数値（たとえば、 &lt;code&gt;0.4363&lt;/code&gt; ）を返すことがあります（上記の例から、実際の数値は &lt;code&gt;0.4363000000000000&lt;/code&gt; です ）。 そのため、この文字列 &lt;code&gt;&quot;000000000&quot;&lt;/code&gt; （9つのゼロを含む文字列）に追加し、 &lt;code&gt;substr()&lt;/code&gt; 関数を使用してそれを切り捨てて、9文字にする（右にゼロを埋める）ようにしています。</target>
        </trans-unit>
        <trans-unit id="2b6553806f7c0f446906395a9393b4c8aa630b83" translate="yes" xml:space="preserve">
          <source>Ten million executions of this implementation take just 32.5 seconds, which is the fastest I've ever seen in a browser (the only solution without loops/iterations).</source>
          <target state="translated">この実装の1000万回の実行時間はたったの32.5秒で、これまでのブラウザの中では最速です(ループのない唯一の解決策)。</target>
        </trans-unit>
        <trans-unit id="863a161fb9b85e54a7fd55bdfa890d777c3ecfdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math.random()&lt;/code&gt; function returns a decimal number between 0 and 1 with 16 digits after the decimal fraction point (for
example &lt;code&gt;0.4363923368509859&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Math.random()&lt;/code&gt; 関数は、小数点以下16桁の0から1までの10進数を返します（例： &lt;code&gt;0.4363923368509859&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="acf4bc33ac4b01c7fa998c17fe2ab66beb9bb5bc" translate="yes" xml:space="preserve">
          <source>The GUID / UUID should be at least 32 characters and should stay in the ASCII range to avoid trouble when passing them around.</source>
          <target state="translated">GUID の UUID は少なくとも 32 文字でなければならず、それらを渡すときのトラブルを避けるために ASCII の範囲内にとどめておく必要があります。</target>
        </trans-unit>
        <trans-unit id="8d751df4e468da72f5959abfc1549c743c1e3ef6" translate="yes" xml:space="preserve">
          <source>The GUID is in the following format &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt;.</source>
          <target state="translated">GUIDの形式は &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2541cbe64e15ab5d69eb08799c64ce9b1235e066" translate="yes" xml:space="preserve">
          <source>The above function should have a decent balance between speed and randomness.</source>
          <target state="translated">上記の機能は、速度とランダム性のバランスがまともなものであることが望ましい。</target>
        </trans-unit>
        <trans-unit id="ee47e6da31b267bf2647229a714a454ce65b3891" translate="yes" xml:space="preserve">
          <source>The best way to generate them, is to follow implementation instructions in the said RFC, use one of the many community vetted open source implementations.</source>
          <target state="translated">それらを生成する最善の方法は、前述のRFCの実装指示に従うことであり、多くのコミュニティで吟味されたオープンソースの実装の一つを使用します。</target>
        </trans-unit>
        <trans-unit id="66063bdfe4ff5bb41650a2179c29b0ae5581986f" translate="yes" xml:space="preserve">
          <source>The better way:</source>
          <target state="translated">より良い方法。</target>
        </trans-unit>
        <trans-unit id="c6b5d62b3d2700a480f847f1f5fc03de421dbca1" translate="yes" xml:space="preserve">
          <source>The final optimization technique to apply - unroll the loop.  Since we're looping a fixed number of times, we can technically write this all out by hand.  I tried this once with a single random variable r that I kept re-assigning, and performance tanked.  But with four variables assigned random data up front, then using the lookup table, and applying the proper RFC bits, this version smokes them all:</source>
          <target state="translated">最後に適用する最適化手法は、ループを展開することです。一定回数ループしているので、技術的にはすべて手書きで書き出すことができます。私は一度、ランダム変数rを1つだけ再割り当てしてみましたが、パフォーマンスが落ちてしまいました。しかし、4つの変数にランダムデータを割り当て、ルックアップテーブルを使用し、適切なRFCビットを適用することで、このバージョンはそれらすべてを吸うことができます。</target>
        </trans-unit>
        <trans-unit id="27e5e746f56f3da4623926ba36af11cf24511a47" translate="yes" xml:space="preserve">
          <source>The first step toward performance is to eliminate the RegEx and its callback functions and use a simple loop instead.  This means we have to deal with the &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; characters whereas broofa did not.  Also, note that we can use String Array indexing to keep his slick String template architecture:</source>
          <target state="translated">パフォーマンスに向けた最初のステップは、RegExとそのコールバック関数を削除し、代わりに単純なループを使用することです。 これは、 &lt;code&gt;-&lt;/code&gt; および &lt;code&gt;4&lt;/code&gt; 文字を処理する必要があるのに対し、ブルームは処理しなかったことを意味します。 また、文字列配列のインデックス付けを使用して、洗練された文字列テンプレートアーキテクチャを維持できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1f91cea12f7bb764e0dde68e533cd0001d9f6c9a" translate="yes" xml:space="preserve">
          <source>The first thing to know is that function calls are expensive, as are regular expressions (though he only uses 1, it has 32 callbacks, one for each match, and in each of the 32 callbacks it calls Math.random() and v.toString(16)).</source>
          <target state="translated">最初に知っておくべきことは、関数の呼び出しは正規表現と同様に高価であるということです(彼は1しか使っていませんが、それは32のコールバックを持っており、各マッチに1つずつ、そして32のコールバックのそれぞれでMath.random()とv.toString(16)を呼び出しています)。</target>
        </trans-unit>
        <trans-unit id="5efd11cea6dbb2ca7d3856a6504baae9880ab778" translate="yes" xml:space="preserve">
          <source>The function is as simple as:</source>
          <target state="translated">といったシンプルな機能です。</target>
        </trans-unit>
        <trans-unit id="237b687de13a23a564832cfd020006932e2b7094" translate="yes" xml:space="preserve">
          <source>The funny thing is, generating 16 bytes of random data is the easy part.  The whole trick is expressing it in String format with RFC compliance, and it's most tightly accomplished with 16 bytes of random data, an unrolled loop and lookup table.</source>
          <target state="translated">面白いことに、16バイトのランダムデータを生成するのは簡単なことです。全体のトリックは、それをRFCに準拠したString形式で表現することであり、16バイトのランダムデータ、展開されていないループ、およびルックアップテーブルで最も緊密に達成されています。</target>
        </trans-unit>
        <trans-unit id="5fe390d75a55e87b91e0f2c344ccf52b0f992757" translate="yes" xml:space="preserve">
          <source>The next optimization is another classic.  Since we're only handling 4-bits of output in each loop iteration, let's cut the number of loops in half and process 8-bits each iteration.  This is tricky since we still have to handle the RFC compliant bit positions, but it's not too hard.  We then have to make a larger lookup table (16x16, or 256) to store 0x00 - 0xff, and we build it only once, outside the e5() function.</source>
          <target state="translated">次の最適化は、もう一つの古典的なものです。各ループの繰り返しでは4ビットの出力しか扱えないので、ループの数を半分に減らして、各繰り返しで8ビットの出力を処理してみましょう。これはまだRFCに準拠したビット位置を処理しなければならないので厄介ですが、それほど難しいことではありません。次に、0x00-0xff を格納するために、より大きなルックアップテーブル (16x16 または 256)を作成しなければなりませんが、これは e5()関数の外で一度だけ作成します。</target>
        </trans-unit>
        <trans-unit id="2c2a678ccb7c402e8bfa66c3bb0b047a01880eeb" translate="yes" xml:space="preserve">
          <source>The next step is a small one on the desktop but makes a decent difference on mobile.  Let's make fewer Math.random() calls and utilize all those random bits instead of throwing 87% of them away with a random buffer that gets shifted out each iteration.  Let's also move that template definition out of the loop, just in case it helps:</source>
          <target state="translated">次のステップはデスクトップでは小さなものですが、モバイルではかなりの違いがあります。Math.random()の呼び出しを少なくして、87%のランダムビットをランダムバッファに捨ててしまうのではなく、すべてのランダムビットを利用しましょう。念のため、テンプレートの定義をループの外に移動させておきましょう。</target>
        </trans-unit>
        <trans-unit id="475810532e8a0fcebdd7c79eff23716432a61245" translate="yes" xml:space="preserve">
          <source>The reason for adding exactly nine zeros is because of the worse case scenario, which is when the &lt;code&gt;Math.random()&lt;/code&gt; function will return exactly 0 or 1 (probability of 1/10^16 for each one of them). That's why we needed to add nine zeros to it (&lt;code&gt;&quot;0&quot;+&quot;000000000&quot;&lt;/code&gt; or &lt;code&gt;&quot;1&quot;+&quot;000000000&quot;&lt;/code&gt;), and then cutting it off from the second index (3rd character) with a length of eight characters. For the rest of the cases, the addition of zeros will not harm the result because it is cutting it off anyway.</source>
          <target state="translated">正確に9つのゼロを追加する理由は、 &lt;code&gt;Math.random()&lt;/code&gt; 関数が正確に0または1を返すという最悪のシナリオのためです（それらのそれぞれに対して1/10 ^ 16の確率）。 そのため、9つのゼロ（ &lt;code&gt;&quot;0&quot;+&quot;000000000&quot;&lt;/code&gt; または &lt;code&gt;&quot;1&quot;+&quot;000000000&quot;&lt;/code&gt; ）を追加し、2番目のインデックス（3番目の文字）から8文字の長さで切り取る必要がありました。 残りのケースでは、ゼロを追加しても結果が損なわれることはありません。</target>
        </trans-unit>
        <trans-unit id="c79498301c475af77620127310a64ed51077604c" translate="yes" xml:space="preserve">
          <source>Then we cut off the &lt;code&gt;0.&lt;/code&gt; prefix (&lt;code&gt;0.6fb7687f&lt;/code&gt; =&amp;gt;
&lt;code&gt;6fb7687f&lt;/code&gt;) and get a string with eight hexadecimal
characters long.</source>
          <target state="translated">次に、 &lt;code&gt;0.&lt;/code&gt; プレフィックス（ &lt;code&gt;0.6fb7687f&lt;/code&gt; =&amp;gt; &lt;code&gt;6fb7687f&lt;/code&gt; ）を切り取り 、8つの16進文字からなる文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="9c8cde2548b6605f69b7f5277aa0db7d69ca4dbc" translate="yes" xml:space="preserve">
          <source>Then we take this number and convert
it to a string with base 16 (from the example above we'll get
&lt;code&gt;0.6fb7687f&lt;/code&gt;).</source>
          <target state="translated">次に、この数値を取得して、基数16の文字列に変換します（上記の例から、 &lt;code&gt;0.6fb7687f&lt;/code&gt; が得られます ）。</target>
        </trans-unit>
        <trans-unit id="f896659fdb57404f3ca1c0dd540b6ea7e7493cc7" translate="yes" xml:space="preserve">
          <source>There are other methods that involve using an ActiveX control, but stay away from these!</source>
          <target state="translated">ActiveXコントロールを使用する方法は他にもありますが、これらには近づかないようにしてください。</target>
        </trans-unit>
        <trans-unit id="b6f314cd5d1632bbd12fce8c34bf0331b26c9531" translate="yes" xml:space="preserve">
          <source>There is a jQuery plugin that handles Guid's nicely @ &lt;a href=&quot;http://plugins.jquery.com/project/GUID_Helper&quot;&gt;http://plugins.jquery.com/project/GUID_Helper&lt;/a&gt;</source>
          <target state="translated">Guidをうまく処理するjQueryプラグイン@ &lt;a href=&quot;http://plugins.jquery.com/project/GUID_Helper&quot;&gt;http://plugins.jquery.com/project/GUID_Helperがあります。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a114b1049ab77d7bb9cf82e5902a2fc8f9522f5b" translate="yes" xml:space="preserve">
          <source>This accomplishes the same goal as the &lt;a href=&quot;https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523&quot;&gt;current highest-rated answer&lt;/a&gt;, but in 50+ fewer bytes by exploiting coercion, recursion, and exponential notation. For those curious how it works, here's the annotated form of an older version of the function:</source>
          <target state="translated">これにより、 &lt;a href=&quot;https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523&quot;&gt;現在の最高評価の回答&lt;/a&gt;と同じ目標が達成されますが、強制、再帰、指数表記を利用することで、50バイト以上のバイト数が削減されます。 それがどのように機能するのか知りたい人のために、これは関数の古いバージョンの注釈付き形式です：</target>
        </trans-unit>
        <trans-unit id="c054a07bc3de1a2f3d45f3aab21e9af1ebf626bf" translate="yes" xml:space="preserve">
          <source>This create version 4 UUID (created from pseudo random numbers) :</source>
          <target state="translated">これは、バージョン4のUUID(擬似乱数から作成された)を作成します。</target>
        </trans-unit>
        <trans-unit id="58ce504b9f25064cbcb7de092b962c9e2dda22c0" translate="yes" xml:space="preserve">
          <source>This one is based on date, and add a random suffix to &quot;ensure&quot; uniqueness.
Works well for css identifiers.
It always returns something like and is easy to hack:</source>
          <target state="translated">これは日付に基づいており、一意性を「確実に」確保するためにランダムな接尾辞を追加します。css の識別子にも使えます。これは常に何かを返してくれるので、ハックするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="c7a27f8c65115f387fec4d67fe32dab189f55a09" translate="yes" xml:space="preserve">
          <source>This saves us 10-30% depending on platform.  Not bad.  But the next big step gets rid of the toString function calls altogether with an optimization classic - the look-up table.  A simple 16-element lookup table will perform the job of toString(16) in much less time:</source>
          <target state="translated">これでプラットフォームによっては10~30%の節約になります。悪くないですね。しかし、次の大きなステップでは、最適化の定番であるルックアップテーブルを使用して、toString 関数の呼び出しを完全に排除します。シンプルな 16 要素のルックアップテーブルは、toString(16)の仕事をより短時間で実行します。</target>
        </trans-unit>
        <trans-unit id="3e8bb274abfb2de0a2c13afefa3450f9f50f8d6e" translate="yes" xml:space="preserve">
          <source>To differ between these two types, I added a flag parameter to a pair creator function &lt;code&gt;_p8(s)&lt;/code&gt;, the &lt;code&gt;s&lt;/code&gt; parameter tells the function whether to add dashes or not.</source>
          <target state="translated">これらの2つのタイプを &lt;code&gt;_p8(s)&lt;/code&gt; するために、ペア作成関数_p8（s）にフラグパラメーターを追加しました。sパラメーターは、ダッシュを追加するかどうかを関数に指示します。</target>
        </trans-unit>
        <trans-unit id="1c7c150202fdddceb6b1c221a05cdb4e4c1ce115" translate="yes" xml:space="preserve">
          <source>To test the performance, you can run this code:</source>
          <target state="translated">パフォーマンスをテストするには、このコードを実行します。</target>
        </trans-unit>
        <trans-unit id="fe1c1c9e7da2bc289fcd3379642172b845c1989a" translate="yes" xml:space="preserve">
          <source>UUID object allows a variety of access to the UUID including access to
  the UUID fields.</source>
          <target state="translated">UUIDオブジェクトは、UUIDフィールドへのアクセスを含むUUIDへの様々なアクセスを可能にします。</target>
        </trans-unit>
        <trans-unit id="a3b6d33b0517d8c2933196e2f509432ec47c7b44" translate="yes" xml:space="preserve">
          <source>UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier), according to &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;, are identifiers with a certain uniqueness guarantee.</source>
          <target state="translated">&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;によれば、GUID（Globally Unique IDentifier）とも呼ばれるUUID（Universally Unique IDentifier）は、特定の一意性が保証された識別子です。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="670720d3ce8655613fb8e5107bd150a04eb2bb3d" translate="yes" xml:space="preserve">
          <source>Version 4 UUIDs (UUIDs from random numbers) and version 1 UUIDs
  (time-based UUIDs) are available.</source>
          <target state="translated">バージョン4のUUID(乱数からのUUID)とバージョン1のUUID(時間ベースのUUID)を用意しています。</target>
        </trans-unit>
        <trans-unit id="3ebdce3a7ac7e93ecd1c5e84caaea7c1835d5f49" translate="yes" xml:space="preserve">
          <source>Want even smaller? Check this out: &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;https://gist.github.com/jed/982883&lt;/a&gt;</source>
          <target state="translated">さらに小さくしたいですか？ これをチェックして&lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;ください&lt;/a&gt; ： https ： //gist.github.com/jed/982883</target>
        </trans-unit>
        <trans-unit id="a55040507e6337ca3e32ec7d20777fced2a290d7" translate="yes" xml:space="preserve">
          <source>Well, this has a bunch of answers already, but unfortunately there's not a &quot;true&quot; random in the bunch. The version below is an adaptation of broofa's answer, but updated to include a &quot;true&quot; random function that uses crypto libraries where available, and the Alea() function as a fallback.</source>
          <target state="translated">さて、これにはすでに多くの回答がありますが、残念ながら「真の」ランダムはありません。以下のバージョンは、broofaさんの回答をアレンジしたものですが、利用可能な場合には暗号ライブラリを使用する &quot;真の &quot;ランダム関数と、フォールバックとしてAlea()関数を含むように更新されています。</target>
        </trans-unit>
        <trans-unit id="7dad31345c220d2cbe299045c03a52e22b20d937" translate="yes" xml:space="preserve">
          <source>Where the &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; positions may only have certain values. At this time, the only valid values for M are 1, 2, 3, 4 and 5, so randomly generating that position would make most results unacceptable.</source>
          <target state="translated">&lt;em&gt;M&lt;/em&gt;と&lt;em&gt;Nの&lt;/em&gt;位置は特定の値のみを持つ場合があります。 現時点では、Mの有効な値は1、2、3、4、5のみなので、その位置をランダムに生成すると、ほとんどの結果が受け入れられなくなります。</target>
        </trans-unit>
        <trans-unit id="0b33ee51f78c94d3fa3e3d46126b5b2de5f92677" translate="yes" xml:space="preserve">
          <source>Which will return something like &lt;code&gt;2350143528-4164020887-938913176-2513998651&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;2350143528-4164020887-938913176-2513998651&lt;/code&gt; のようなものが返されます。</target>
        </trans-unit>
        <trans-unit id="00947a234207676f6b4f448ed89af28aa686b86c" translate="yes" xml:space="preserve">
          <source>With such a web service, you could develop a REST web interface that consumes the GUID web service, and serves it through AJAX to javascript in a browser.</source>
          <target state="translated">このようなウェブサービスでは、GUIDウェブサービスを消費するRESTウェブインターフェースを開発し、ブラウザのjavascriptにAJAXを介してそれを提供することができます。</target>
        </trans-unit>
        <trans-unit id="d4fb620aaed70bd0d3e4873af0570771d0ed649d" translate="yes" xml:space="preserve">
          <source>You can increase this number by adding more digits, but to generate 100% unique ID's you will need to use a global counter.</source>
          <target state="translated">桁数を増やすことでこの数を増やすことができますが、100%ユニークなIDを生成するにはグローバルカウンタを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ba59cf2f4053a03ebc1856c70811cb75b72d66b4" translate="yes" xml:space="preserve">
          <source>You can use node-uuid (&lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;https://github.com/kelektiv/node-uuid&lt;/a&gt;)</source>
          <target state="translated">node-uuid（ &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;https://github.com/kelektiv/node-uuid&lt;/a&gt; ）を使用できます</target>
        </trans-unit>
        <trans-unit id="da5cce2c829e18ada2502aedf48c415870558171" translate="yes" xml:space="preserve">
          <source>broofa's answer is pretty slick, indeed - impressively clever, really...  rfc4122 compliant, somewhat readable, and compact.  Awesome!</source>
          <target state="translated">broofaの回答は、確かに非常に洗練されています。凄いですね!</target>
        </trans-unit>
        <trans-unit id="5f37ba236f9a0c5e9361a753b0b9f82646c7f35a" translate="yes" xml:space="preserve">
          <source>if you need RFC compatibility, this formatting will pass as a valid version 4 GUID:</source>
          <target state="translated">RFC互換性が必要な場合は、この書式は有効なバージョン4 GUIDとして渡されます。</target>
        </trans-unit>
        <trans-unit id="b32441e1af6b6c4e0de9080307ccfb43a3ea08b5" translate="yes" xml:space="preserve">
          <source>uid-139410573297741</source>
          <target state="translated">uid-139410573297741</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
